

# 第二十二章：使用 STL 的并行算法

本章涵盖了 C++ 并行性的主题，特别是 C++17 中引入的工具和技术。从基础开始，本章展开介绍了执行策略的力量，允许开发者利用并行处理在他们的 C++ **标准模板库** (**STL**) 算法中。

本章我们将涵盖以下主题：

+   执行策略简介

+   引入执行策略

+   `constexpr` 对算法和容器的影响

+   性能考虑

# 技术要求

本章中的代码可以在 GitHub 上找到：

[`github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL`](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)

# 执行策略简介

处理器已经从关注提高单个核心的速度转变为结合多个核心以增强性能。对于开发者来说，这意味着可以在这些核心上并发执行多个指令，从而提高应用程序的效率和响应速度。

这种转向多核配置突出了集成并行编程技术的重要性。随着 C++17 的出现，C++ 在这一领域取得了显著进展，通过引入 `<execution>` 头文件。

## `<execution>` 头文件–在 STL 算法中启用并行性

在 C++17 之前，尽管 STL 提供了一套全面的算法，但它们都是顺序执行的。这种顺序操作意味着 STL 算法没有充分利用多核处理器的功能。

`<execution>` 头文件解决了这一限制。它不是添加新算法，而是通过引入执行策略，通过结合并行性来增强现有算法。

执行策略作为指令，指示 STL 算法所需的操作模式：顺序、并行或向量化。通过 `<execution>` 头文件，开发者可以指定这些偏好。

主要的执行策略包括以下内容：

+   `std::execution::seq`: 规定算法的顺序执行

+   `std::execution::par`: 在可行的情况下促进并行执行

+   `std::execution::par_unseq`: 支持并行和向量化执行

## 实现并行执行

将并行性集成到 STL 算法中非常简单。以 `std::sort` 算法为例。通常，它被以下方式使用：

```cpp
std::sort(begin(vec), end(vec));
```

要使用 `<execution>` 头文件进行并行排序，语法如下：

```cpp
std::sort(std::execution::par, begin(vec), end(vec));
```

这种修改使 `sort` 算法能够利用多个核心，从而可能提高排序过程的速度。

## 反思转向并行 STL 的过渡

虽然引入`<execution>`头文件及其相关的执行策略是一个显著的进步，但使用它们时必须谨慎。并行化确实引入了开销，如线程上下文切换和数据协调。这些开销有时会抵消并行化的好处，特别是对于数据集较小的任务。

然而，当谨慎使用时，`<execution>`头文件可以显著提高应用程序的性能。后续章节将更详细地探讨执行策略，使开发者能够有效地利用它们。

总结来说，C++17 的`<execution>`头文件是一个关键的增强。它提供了一种机制，将并行能力注入现有的 STL 算法中，使开发者能够开发针对多核生成优化的应用程序。

## 集成执行策略

C++17 标准中引入的`<execution>`头文件，通过提供一套专为并行计算设计的工具，为 C++编程增加了显著深度。当与 STL 算法结合使用时，这个头文件允许开发者有效地利用并发计算的能力。

执行策略是`<execution>`头文件的一个关键特性，对于控制 STL 算法的执行方式至关重要。通过在调用 STL 算法时指定执行策略，开发者可以指定算法是顺序运行、并行运行还是并行加向量化的运行。这种控制水平可以带来显著的性能提升，尤其是在计算密集型或处理大数据集的应用程序中。

从本质上讲，`<execution>`头文件及其相关的执行策略为 C++开发者提供了一套强大的工具集。它们提供了一种方式，可以挖掘现代多核处理器和分布式计算环境潜力，从而实现更高效和更快的代码执行。

## 将策略与标准算法集成

执行策略作为 STL 算法的指令，指示首选的操作模式。对于熟悉 STL 算法的开发者来说，集成这些策略需要对现有代码进行最小修改。

考虑`std::for_each`算法，它作用于集合中的每个元素。默认情况下，它按顺序操作：

```cpp
std::for_each(std::begin(vec), std::end(vec), [](int val) { /*...*/ });
```

对于大数据集或 lambda 函数内的计算密集型操作，并行执行可能是有益的。这可以通过简单地引入一个执行策略来实现：

```cpp
std::for_each(std::execution::par, std::begin(vec), std::end(vec), [](int val) { /*...*/ });
```

包含了`std::execution::par`之后，该算法现在已准备好进行并行执行。

## 理解并行执行策略

有两种主要的并行执行策略：

+   `std::execution::par`：这表示算法可以并行执行。它允许实现根据特定上下文来决定是否并行。

+   `std::execution::par_unseq`：这进一步建议了并行性，并允许向量化。这意味着当硬件支持时，多个循环迭代可能在单个处理器核心上并发执行。

例如，`std::transform`算法，它将函数应用于每个集合元素，可以利用这些策略：

```cpp
std::transform(std::execution::par_unseq, std::begin(vec), std::end(vec), std::begin(output), [](int val) { return val * val; });
```

每个`vec`元素都被平方，结果填充到输出中。`std::execution::par_unseq`策略表明了此操作的潜在并行化和向量化。

## 选择合适的执行策略

虽然执行策略增强了并行计算能力，但必须谨慎应用。并非每个数据集或算法都能从并行执行中获益，有时，开销可能会抵消小型数据集的优势。

`std::execution::seq`策略明确选择顺序执行，确保算法在单线程模式下运行。这在并行性引入不必要的开销或在不建议并行执行的环境中是有益的。

在使用具有副作用或需要同步的算法的并行策略时，也要警惕潜在的问题。

C++17 的执行策略简化了对并行性的访问。将这些策略与传统的 STL 算法配对，允许开发者最优地使用多核处理器。无论是使用`std::transform`处理大量数据集，还是使用`std::sort`对大型集合进行排序，或者使用`std::remove_if`过滤项目，执行策略都提供了额外的性能维度。

然而，始终要验证并行执行是否真正增强了您的应用程序，而没有带来不可预见的问题或瓶颈。不断地评估和测试您的代码是至关重要的。

在这个基础上，我们准备在下一节中考虑性能考虑因素。通过区分并行性的应用，我们可以开发出针对当代计算需求的效率高的 C++应用程序。

# `constexpr`对算法和容器的影响

随着 C++11 中`constexpr`指定符的引入及其在后续版本中的增强，C++中的编译时计算取得了重大飞跃。函数和构造函数通过`constexpr`在编译时操作的能力，使得优化和确保代码运行前的特定属性成为可能。本节探讨了`constexpr`在 STL 中的集成，特别是关于算法和容器。

## `constexpr`的演变

在 C++11 的初期，`constexpr`主要用于简单的计算。C++14 的扩展扩大了其范围，包括循环和条件结构。到 C++20，进一步的增强允许通过`std::allocator`进行`constexpr`分配。这使得`std::vector`和`std::string`等容器可以在`constexpr`下使用，尽管存在某些限制。

## 算法和`constexpr`的作用

最初，由于它们的泛型设计和多方面的要求，`constexpr`并不广泛适用于 STL 算法。然而，随着 C++20 标准的推出，更多的 STL 算法变得与`constexpr`兼容。这意味着，如果所有输入都是常量表达式，那么可以在编译时计算算法的结果。

以`std::find`或`std::count`函数为例。当用于静态数据结构，如数组或`std::array`时，它们可以在编译阶段执行。然而，截至 C++20，动态分配仍然主要在`constexpr`的领域之外。

以下代码片段使用`std::array`来突出`std::find`和`std::count`与`constexpr`的使用：

```cpp
#include <algorithm>
#include <array>
#include <iostream>
constexpr std::array<int, 6> data = {1, 2, 3, 4, 3, 5};
constexpr bool contains(int value) {
  return std::find(data.begin(), data.end(), value) !=
         data.end();
}
constexpr size_t countOccurrences(int value) {
  return std::count(data.begin(), data.end(), value);
}
int main() {
  static_assert(contains(3));
  static_assert(countOccurrences(3) == 2);
  std::cout << "Array contains 3: " << contains(3) << "\n";
  std::cout << "Occurrences of 3: " << countOccurrences(3)
            << "\n";
  return 0;
}
```

这里是示例输出：

```cpp
Array contains 3: 1
Occurrences of 3: 2
```

上一段代码中的`contains`和`countOccurrences`函数在编译时被评估，因为它们操作的是一个与`constexpr`兼容的`std::array`，并且它们的所有输入都是常量表达式。

值得注意的是，使用如`std::execution::par`之类的执行策略的并行算法不适合`constexpr`上下文，因为它们固有的对运行时资源的依赖。

## 容器和`constexpr`集成

C++20 的编译时分配能力使得特定的 STL 容器能够在`constexpr`环境中工作。虽然`std::array`始终兼容，甚至`std::vector`和`std::string`的一些操作也变得可行。不过，任何需要动态内存或导致未定义行为的操作，在`constexpr`上下文中都会导致编译时错误。

`constexpr`的发展轨迹表明，C++环境正在演变，编译时和运行时评估之间的界限变得越来越模糊。我们可能会很快看到更多高级算法和容器在编译时完全评估，从而优化性能和代码安全性。

然而，由于并行性的基本运行时特性，`constexpr`和并行算法的收敛仍然是一个不确定的前景。

总结来说，`constexpr`无疑重塑了 C++开发。随着它更深入地集成到 STL 中，开发者有了更多途径来精炼和巩固他们的应用程序。

# 性能考虑

并行算法是利用多核处理器能力的基础，旨在提高计算效率和性能。然而，从顺序编程到并行编程的转变并不简单。它需要深入理解固有的复杂性和权衡。在本节中，我们将探讨并行算法的各个方面，包括其性能改进的潜力、并行执行挑战、并行化的最佳数据大小、同步问题和在线程间平衡工作负载的微妙之处。这个全面的概述将更深入地了解并行算法的有效利用，强调在并行计算环境中实现最佳性能时，信息决策和性能分析的重要性。

并行算法在性能增强方面既提供了机会也带来了挑战。虽然它们在多核处理环境中提供了更快计算的可能性，但它们的实际使用需要仔细考虑和决策。

## 并行开销

随着开发者对并行解决方案进行实验，了解并行执行并不均匀地有利于所有算法或场景至关重要。可能会有开销，例如与启动多个线程和数据同步相关的开销。例如，对于小数据集，线程管理的开销可能会超过计算时间，使得并行化效率较低。

## 确定最佳数据大小

并行执行在超过特定数据大小阈值时显示出其优势。这个阈值受所采用的算法、计算的特性和硬件规格等因素的影响。具有大量数据集的资源密集型任务通常非常适合并行化，而较小的数据集可能更有效地顺序处理。

理解数据和计算类型对于优化性能至关重要。性能分析变得非常有价值，帮助开发者评估其代码的运行时行为，并决定何时采用并行化。

## 数据访问和同步挑战

并发可能导致多个线程同时访问相同的资源。数据竞争可能会出现，尤其是在频繁共享数据访问的情况下。实现适当的同步对于防止数据不一致至关重要。然而，同步也有其相关的开销。

## 伪共享——一个微妙性能问题

即使线程访问不同的数据，仍然可能发生伪共享。这发生在不同核心上的线程修改同一缓存行中的变量时，导致缓存失效和潜在的性能下降。注意数据布局并力求编写缓存优化的代码至关重要。

## 负载均衡

不同的计算任务可能需要不同的处理时间。如果线程以不同的速率完成任务，可能会导致资源利用率不足。实用的并行算法确保工作负载在线程之间均匀分布。一些高级并行技术，如工作窃取，可以动态重新分配任务，以保持一致的线程参与。

## 分析的重要性

性能优化的一个一致主题是分析的重要性。仅仅依赖假设是不可取的。如`perf`和`gprof`之类的分析工具以及如 Intel® VTune™之类的先进工具可以识别性能瓶颈、线程行为和竞争区域。这些工具提供了具体数据，以微调并行策略。

在本节中，我们回顾了与并行算法一起工作时需要考虑的性能因素。我们了解到，虽然并行算法可以显著提高计算效率，但它们的有效使用需要细微地理解各种因素。我们讨论了与并行执行相关的潜在开销，例如线程初始化和数据同步。我们还强调了确定并行执行最佳数据大小的重要性，强调并行化可能并不适用于所有场景，尤其是涉及小数据集的场景。我们进一步探讨了在并发环境中数据访问和同步的挑战，包括假共享问题。我们还简要介绍了负载平衡的概念，解释了计算任务的不均匀分布如何导致资源利用率不足。我们讨论了如工作窃取等高级技术，这些技术可以通过动态重新分配任务来帮助保持一致的线程参与。

从本节中获得的认识是无价的，因为它们为我们提供了在实现并行算法时做出明智决策的知识。理解这些性能考虑因素使我们能够充分利用多核处理器的全部潜力，同时避免常见的陷阱。在当今的多核处理环境中，这些知识至关重要，使我们能够编写更高效、性能更好的代码。它还为我们在 C++ STL 中继续探索数据结构和算法奠定了基础，因为我们努力深化我们的理解并提高我们的编程技能。

# 摘要

本章介绍了 STL 中的并行算法。我们首先熟悉了 C++17 中引入的`<execution>`头文件，它在使 STL 算法实现并行化方面发挥了关键作用。这一新增功能使我们能够指定执行策略，如`std::execution::seq`、`std::execution::par`和`std::execution::par_unseq`，从而规定 STL 算法的执行模式。

我们将这些执行策略实施到标准算法中，展示了从顺序执行到并行执行的转换的简单性。这通过将算法如`std::sort`和`std::for_each`调整为并行运行来体现，从而利用了多核的计算能力。

章节接着聚焦于`constexpr`指定符及其对 STL 算法和容器的深远影响。我们探讨了`constexpr`从 C++11 到 C++20 的演变及其在使算法如`std::find`和`std::count`的编译时计算成为可能中的作用。

性能考虑构成了我们最终讨论的核心，强调了使用并行算法的好处和潜在的风险。我们讨论了与并行性相关的开销，确定最佳数据大小的重要性，以及有效数据访问和同步的策略，以避免诸如伪共享和负载不平衡等问题。

本章传达的信息对于在多核处理环境中利用 STL 的能力是无价的。通过理解何时以及如何应用并行算法，我们可以编写更高效、响应更快的代码。对并行执行策略的深入理解以及使用`constexpr`优化代码的能力使我们能够最大化性能和资源利用率。
