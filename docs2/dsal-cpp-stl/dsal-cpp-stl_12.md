

# 操作和转换

本章讨论了 C++ **标准模板库**（**STL**）提供的数据操作技术。这些操作数据结构的技术，无论是复制、生成新数据、删除过时条目，还是执行交换或反转等高级操作，构成了大多数应用程序的重要组成部分。本章将向您介绍许多方法和细微差别，使您能够为您的任务选择合适的工具。伴随最佳实践，本章确保您能够高效地理解和应用这些技术。

本章将涵盖以下主要主题：

+   STL 容器中的复制和移动

+   探索返回值优化

+   STL 容器中的填充和生成

+   STL 容器中的删除和替换

+   STL 容器中的交换和反转

+   最佳实践

# 技术要求

本章中的代码可以在 GitHub 上找到：

[`github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL`](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)

# STL 容器中的复制和移动

C++中的 STL 以其强大的数据结构和算法而闻名。其最基本方面包括复制和移动容器的操作。这些操作不仅对数据操作至关重要，而且在 C++应用程序的效率和性能中也起着重要作用。本节探讨了 STL 中复制和移动的细微差别，探讨了它们的语义、对性能的影响以及选择其中一个而不是另一个所涉及的战略决策。

## STL 中的复制语义

**复制**，在最基本的意义上，是指创建一个对象的副本。在 STL 中，当你复制一个容器时，你将其内容复制到一个新的容器中。一种可视化这种方法的方式是想象复印一份文件。原始文件保持不变，而你有一份内容相同的新的文件。

例如，考虑以下内容：

```cpp
std::vector<int> original{1, 2, 3};
std::vector<int> duplicate(original); // Copy constructor
```

现在的`duplicate`向量是原始向量的副本。这两个容器完全独立；修改一个不会影响另一个。虽然这听起来很简单，但魔鬼往往藏在细节中。复制可能是一个昂贵的操作，特别是对于大型容器。原始容器中的每个元素都会被复制，这可能在时间效率至关重要的应用程序中导致性能陷阱。

## STL 中的移动语义

在 C++11 中引入的**移动语义**引领了资源管理的范式转变。它不是复制内容，而是将资源的所有权从（源）对象转移到（目标）对象。

想象一下，你有一个玩具箱（`std::vector`）。你不需要创建一个新的玩具箱并逐个转移玩具（复制），你只需将这个玩具箱交给别人（移动）。原来的玩具箱就空了，而另一个人拥有了所有的玩具。

这在代码中的表现如下：

```cpp
std::vector<int> original{1, 2, 3};
std::vector<int> destination(std::move(original)); // Move constructor
```

在此操作之后，`destination`拥有数据，而`original`处于有效但未指定的状态（通常是空的）。这种机制提供了显著的性能优势，尤其是在处理大数据集时，因为它消除了复制数据的开销。

## 拷贝与移动——一个有意的选择

现在，了解了这两种机制，开发者有责任做出明智的选择。拷贝确保数据完整性，因为原始数据保持未变。这在原始数据在后续操作中仍然发挥作用时很有用。然而，如果原始容器的数据是可丢弃的，或者你确信之后不再需要它，选择移动操作可以显著提高性能。

然而，需要谨慎。粗心使用移动语义可能会导致意外，尤其是如果假设数据仍然位于源容器中。在任何操作之后，始终要意识到对象的状态。

下面是一个示例，展示了粗心使用移动语义可能导致的潜在问题：

```cpp
#include <iostream>
#include <vector>
void printVector(const std::vector<int> &vec,
                 const std::string &name) {
  std::cout << name << ": ";
  for (int val : vec) { std::cout << val << " "; }
  std::cout << "\n";
}
int main() {
  std::vector<int> source = {10, 20, 30, 40, 50};
  std::vector<int> destination = std::move(source);
  std::cout
      << "Trying to access the 'source' vector after "
         "moving its data:\n";
  printVector(source, "Source");
  printVector(destination, "Destination");
  source.push_back(60);
  std::cout << "After trying to add data to 'source' "
               "post-move:\n";
  printVector(source, "Source");
  return 0;
}
```

以下为前述代码的输出：

```cpp
Trying to access the 'source' vector after moving its data:
Source:
Destination: 10 20 30 40 50
After trying to add data to 'source' post-move:
Source: 60
```

如所示，在从`source`到`destination`移动数据后，`source`向量处于有效但未指定的状态。它是空的，但仍然可以执行如`push_back`之类的操作。关键是要意识到这样的状态，不要假设在移动之后`source`容器中的数据仍然完好无损。

从本质上讲，当开发者理解 STL 操作的细微差别时，STL 的力量会得到放大。拷贝和移动是基础支柱，决定了数据如何管理以及应用程序如何高效运行。在我们深入探讨后续章节中的操作和转换技术时，始终要牢记这些机制。它们通常是构建高级技术的基础。

# 探索返回值优化

**返回值优化**（**RVO**）值得特别提及。现代编译器优化函数中的对象返回，有效地将看似拷贝的操作转换为移动，使操作非常高效。这是 C++不断发展和其倾向于性能优化的例证。

下面是一个代码示例，以展示 RVO 的概念：

```cpp
#include <iostream>
#include <vector>
class Sample {
public:
  Sample() { std::cout << "Constructor called!\n"; }
  Sample(const Sample &) {
    std::cout << "Copy Constructor called!\n";
  }
  Sample(Sample &&) noexcept {
    std::cout << "Move Constructor called!\n";
  }
  ~Sample() { std::cout << "Destructor called!\n"; }
};
Sample createSample() { return Sample(); }
int main() {
  std::cout << "Creating object via function return:\n";
  Sample obj = createSample();
  return 0;
}
```

在此代码中，当调用函数`createSample`时，它返回一个`Sample`对象。如果没有 RVO（Return Value Optimization，返回值优化），我们可能会预期一系列调用：`构造函数` -> `拷贝构造函数`（或`移动构造函数`）-> `析构函数`。然而，由于 RVO，许多现代编译器会优化创建过程，使得只需调用构造函数即可。输出通常如下所示：

```cpp
Creating object via function return:
Constructor called!
Destructor called!
```

没有调用拷贝构造函数（`Sample(const Sample&)`）或移动构造函数（`Sample(Sample&&) noexcept`）表明发生了 RVO。对象直接在`obj`的内存位置中构造，无需额外的复制或移动。

接下来，让我们探讨使用填充和生成元素的概念自动填充 STL 容器的有效方法。

# 在 STL 容器中进行填充和生成

填充容器和在其中生成数据类似于将粘土塑造成雕塑。数据结构是你的基础，而填充和生成数据的技巧则赋予了你的程序生命。随着我们继续挖掘 STL 的巨大潜力，本部分将专注于 STL 容器中*填充和生成*的关键技术。让我们挽起袖子，深入探索精确构建数据结构的艺术和科学！

## 使用静态分配填充

想象一个场景，你需要一个填充了特定值的容器，无论是零、特定字符还是任何其他重复模式。STL 通过针对静态分配的方法简化了这一点。

例如，`std::vector`提供了其构造函数的重载，允许你指定大小和默认值：

```cpp
std::vector<int> v(5, 2112);
```

这种方法确保了数据的一致性，这对于依赖于同质集合的操作至关重要。这并不仅限于向量。许多 STL 容器提供了类似的功能，确保开发者拥有在不同情境下所需的工具。

## 使用 STL 进行动态生成

虽然静态分配有其魅力，但更常见的情况是需要动态数据生成。无论是创建测试用例、模拟场景，还是任何需要特定模式的情况，STL 都不会让人失望。

STL 提供了`std::generate`和`std::generate_n`算法来满足这些需求。这些函数根据生成器函数将值赋给容器。

考虑以下示例：

```cpp
std::vector<int> v(5);
std::generate(v.begin(), v.end(), [n = 0]() mutable { return n++; });
```

在这里，我们利用了 lambda 函数动态地生成连续整数。这种方法提供了无与伦比的灵活性，允许开发者生成从简单的数字递增到基于复杂公式或计算的复杂值的数据。

## 确保相关性和效率

现在，拥有工具只是战斗的一半。有效地使用它们才是掌握的关键。在填充和生成数据时，请遵循以下步骤：

+   **选择合适的方法**：考虑数据的生命周期。如果创建后数据集保持静态，静态分配简单且高效。然而，对于不断变化的数据，动态生成方法提供了灵活性和适应性。

+   **注意大小**：过度填充可能导致内存效率低下，而不足填充可能会导致操作不完整或意外的行为。始终要敏锐地意识到大小需求。

+   **利用 lambda 的力量**：从 C++11 开始，lambda 简洁地定义了快速函数。它们在动态生成中非常有价值，允许定义定制函数，而不需要传统函数定义的冗长。

+   **考虑现实世界情境**：始终将问题与手头的情境联系起来。如果你正在填充容器以模拟现实世界数据，确保你的填充和生成技术反映了现实场景。这不仅仅是填充容器，而是有目的地填充它们。

总结来说，STL 容器中有效填充和生成数据的能力证明了该库的强大。无论你是追求静态分配的统一性，还是寻求生成模式的动态魅力，STL 都能很好地满足你的需求。随着我们在接下来的章节中向更复杂的操作迈进，始终要记住，数据是应用程序的核心。你如何塑造和培养它，往往决定了程序的节奏和脉搏。

# 在 STL 容器中进行移除和替换

在使用 C++ STL 进行数据处理时，我们经常发现自己正在添加或查看元素，并参与它们的整理。随着我们揭开本章的层层面纱，*移除和替换* 的艺术成为一项基本技能，在保留有价值的内容和丢弃冗余内容之间取得完美平衡。通过掌握这些操作，你可以提高处理 STL 容器的熟练度，增强数据的相关性和整体效率。

## 移除的本质

当我们深入探索 STL 中的数据存储丰富领域时，改进的需求是显而易见的。无论是移除过时的记录、异常值还是任何冗余信息，STL 都提供了强大的工具来协助你。你可以使用诸如 erase 和 remove 等函数来精确指定要清除的特定值或条件。例如，使用 `std::remove`，可以将特定元素移动到序列容器的末尾，而 `erase` 则可以永久地删除它们。正是这种操作组合确保了清理过程的流畅性。

然而，尽管移除操作效率很高，但谨慎是必要的。盲目地删除元素可能会破坏容器的连续性，甚至影响性能。关键在于明智地使用这些操作，并始终关注迭代器的有效性以及潜在的重新分配，尤其是在 `std::vector` 等动态容器中。

## 替换

想象一下，你有一组过时的值或占位符元素，需要更新它们。STL 不会让你陷入困境。`std::replace` 和 `std::replace_if` 等函数是你在这个任务中的盟友。使用 `std::replace`，你可以无缝地在整个集合中交换旧值和新值。对于更复杂的场景，当替换条件不仅仅是简单的值匹配时，`std::replace_if` 就会成为焦点。`std::replace_if` 允许通过 lambda 表达式或函数对象来指定条件，从而进行替换。

为了一个动手的例子，考虑一个集合，其中负值被视为错误并需要更新。使用 `std::replace_if`，你可以查找并替换每个负值，用一个默认值或修正值替换，所有这些都在一行优雅的代码中完成。

让我们看看使用 `std::replace` 和 `std::replace_if` 的一个例子：

```cpp
#include <algorithm>
#include <iostream>
#include <vector>
int main() {
  std::vector<int> values = {10, -1, 20, -2, 30};
  // Using std::replace to update a specific value
  std::replace(values.begin(), values.end(), -1,
               0); // Replace -1 with 0
  // Using std::replace_if to update based on a condition
  std::replace_if(
      values.begin(), values.end(),
      [](int value) {
        return value < 0;
      },  // Lambda function for condition
      0); // Replace negative values with 0
  // Printing the updated collection
  for (int value : values) { std::cout << value << " "; }
  std::cout << std::endl;
  return 0;
}
```

这里是示例输出：

```cpp
10 0 20 0 30
```

在这个例子中，我们使用 `std::replace` 来查找并替换一个特定的值（-1）为 0。然后我们使用 `std::replace_if` 和一个 lambda 函数来识别负值并将它们替换为 0。这个例子展示了 `std::replace` 在简单直接替换中的应用，以及 `std::replace_if` 在更复杂场景中的应用，其中条件（如识别负值）决定了替换。

## 平衡的艺术

平衡删除和替换需要节奏感和平衡感。虽然积极整理很有吸引力，但有时保留特定数据，即使过时或冗余，也可以作为历史记录或参考点。因此，始终以明确的目标进行删除和替换，确保数据完整性、相关性和效率不受损害。

在本节中，我们磨练了整理和修改集合的技能，重点关注它们的删除和替换。这个过程至关重要，因为它在保留有价值的数据与消除冗余之间取得平衡，提高了数据的相关性和容器效率。我们探讨了使用 `erase` 和 `remove` 等函数进行数据精炼的战略使用，以及谨慎删除以保持容器完整性和性能的重要性。我们学习了使用 `std::replace` 和 `std::replace_if` 的替换技术，这些技术在更新集合中至关重要，尤其是在处理复杂条件时。这些工具不仅确保数据的更新和准确性，而且突出了 STL 在数据操作中的灵活性和强大功能。

接下来，我们转向交换和反转，展示如何有效地改变容器内元素顺序和位置，这是管理和管理 C++ 数据结构的一个关键方面。

# STL 容器中的交换和反转

当我们遍历添加、初始化和改进我们的 STL 容器时，还有一个同样引人入胜的领域，在那里我们调整和重新排列元素以符合我们的要求。本节承诺带您进行一次探险，展示 STL 在重新定位和重新排列元素方面的能力，同时也会涉及到包括去重和抽样在内的复杂操作。

## 交换——互换的艺术

在许多实际场景中，需要在容器之间交换内容。无论是为了负载均衡、数据同步还是其他计算任务，STL 提供了交换函数，这是一个高效且简化的机制。

例如，`std::swap`可以与几乎所有的 STL 容器一起使用。如果你有两个`std::vector`并且希望交换它们的内容，`std::swap`可以在常数时间内完成魔法般的交换，而不需要复制或移动单个元素。这种效率来源于底层数据指针的交换，而不是实际内容。

## 反转 – 从末尾的一瞥

有时候，从不同的角度看待事物可以带来清晰，对于数据也是如此。STL 提供了`std::reverse`算法，它反转容器内元素顺序，提供新的视角或帮助满足特定的计算需求。无论是分析数据趋势还是满足倒序时间要求，`std::reverse`确保你的容器可以在线性时间内翻转其序列。

## 去重 – 突出独特性

随着数据量的增长，冗余的可能性也在增加。然而，STL 已经做好了应对这种情况的准备。`std::unique`算法有助于在排序序列中移除连续的重复项。虽然它不会直接删除重复项，但它将它们重新定位到容器的末尾，这使得在需要时删除它们变得方便。当与`std::sort`结合使用时，`std::unique`成为确保你的容器仅保留每个元素的唯一实例的有力工具。

## 采样 – 整体的一部分

在某些情况下，需要从更广泛的集合中采样一个子集。虽然 STL 没有提供直接的*sample*函数，但可以通过组合其他工具，如随机洗牌算法来推导出样本。通过随机洗牌然后选择前`n`个元素，你可以得到一个代表性的样本，可用于测试、分析或其他目的。

交换、反转、去重和采样只是 STL 广泛功能的一瞥。它们代表了数据的动态性质以及我们可能需要与之交互的多种方式。在你继续旅程的过程中，请记住，STL 不仅仅是工具和函数；它是一个旨在高效移动、塑形和管理你的数据的套件。

# 最佳实践

让我们回顾实现 STL 算法的最佳方式，以确保效率、维护数据完整性和识别最适合各种用例的最合适方法。

+   `std::sort`功能多样，但可能不是部分排序序列的最佳选择，此时`std::partial_sort`或`std::stable_sort`可能更为适用。

+   **优先选择算法而不是手写循环**：面对搜索或排序等任务时，优先选择 STL 算法而不是手写循环，因为它们经过优化和广泛测试，因此更可靠且通常更快。

+   尽可能使用`const`。它维护数据完整性并提供更好的接口洞察，避免意外修改。

+   `std::copy_n`确保没有越界访问，与`std::copy`相比。

+   `std::count`.

+   `std::transform`比`std::for_each`更合适。

+   使用`std::vector::reserve`进行预分配内存。这种做法避免了不必要的重新分配，提高了性能。

+   用于频繁查找的`std::set`可以显著优化性能。

+   `std::move`有助于实现这一点。

# 摘要

本章涵盖了在 STL 容器内改变和塑造数据的基本技术。我们首先理解了 STL 中复制和移动语义的细微差别，学习根据上下文在复制与移动元素之间做出有意的选择，以优化性能和资源管理。然后我们探讨了 RVO，这是一种优化编译器的技术，它消除了冗余的对象复制。

我们随后检查了填充和生成容器内容的方法，这对于高效初始化和修改大型数据集至关重要。我们涵盖了在容器内删除和替换元素的方法，平衡了数据完整性与性能的需求。本章还介绍了交换和反转元素的操作、去重以消除重复项以及抽样以创建数据的代表性子集。在整个过程中，我们专注于最佳实践，以确保这些操作以精确和高效的方式执行。

随着我们构建更复杂的程序，我们经常需要操作大量数据集。在这些操作方面的熟练程度能够创建更复杂和性能更高的应用程序，使信息对现代 C++编程变得有价值且至关重要。

在下一章中，我们将关注基本的和高级的数值操作，例如生成序列、求和元素以及处理相邻差分和内积。我们还将研究排序范围上的操作，巩固我们对如何将 STL 算法应用于数值数据的理解，从而增强我们在 C++中进行算法问题解决的工具集。下一章将继续建立在前面章节的基础上，确保对 STL 功能有一个连贯和全面的理解。
