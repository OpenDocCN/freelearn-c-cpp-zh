

# 排列、分区和堆

本章探讨了 C++ **标准模板库**（**STL**）算法库中最基本且经常被忽视的一些方面。本章通过分区来阐明序列组织，通过排列来改变序列，以及基于堆的操作的迷人世界。这些操作是许多高级算法和数据结构的基础。通过理解和掌握它们，开发者可以提高其应用程序的效率，优化数据处理，并确保数据集的完整性。

在本章中，我们将介绍与 STL 相关的一些主题：

+   分区

+   排列

+   堆操作

+   最佳实践

# 技术要求

本章中的代码可以在 GitHub 上找到：

[`github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL`](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)

# 分区

**分区**，在其最简单的形式中，是关于根据特定标准组织序列的过程，确保所有满足要求的元素都排在那些不满足要求的元素之前。这是关于高效地隔离数据，优化其组织以实现快速访问，并提高计算效率。

C++ STL 为分区任务提供了一套丰富的算法。虽然有人可能会倾向于使用简单的循环和条件语句来完成这些任务，但这些 STL 函数经过了优化、测试和设计，以提供最佳性能。这些算法由对底层系统有深刻理解的专家实现，处理边缘情况，并通常利用编译器优化，甚至（潜在地）并行化。

## std::partition 及其功能

在这个类别中最基础的功能之一是`std::partition`。这个函数根据谓词重新组织范围内的元素。它确保所有满足谓词的元素都排在那些不满足谓词的元素之前。但这里有一个需要记住的重要事情：元素的顺序不保证被保留。如果你关心顺序，那么`std::stable_partition`是你的朋友。虽然它可能有一些轻微的开销，但它保留了元素的相对顺序。

让我们来看一个例子。考虑一个整数序列，假设你想要将偶数和奇数分开。使用适当的 lambda 表达式调用`std::partition`可以迅速完成这项工作，如下面的代码所示：

```cpp
std::vector<int> numbers = {7, 1471414, 3, 18, 9, 518955};
auto it = std::partition(numbers.begin(), numbers.end(), [](int n) { return n % 2 == 0; });
```

在这个操作之后，迭代器将遍历奇数的范围。

## 使用 std::is_partitioned 检查分区

一旦对范围进行了分区，确保分区正确可能是有益的，尤其是在较大的系统或集成多个算法时。这时，`std::is_partitioned` 函数就派上用场，它检查一个范围是否根据给定的谓词进行了分区。这在基于多个操作构建时尤其有用，确保关于数据布局的假设保持稳固。

## `std::partition_point` 的实用性

分区之后，人们可能会问：“分界线在哪里？”这正是 `std::partition_point` 函数发挥作用的地方。该函数返回一个迭代器，指向新分区范围内不满足谓词的第一个元素。它假设范围已分区，并利用二分搜索，确保快速响应。

## 超越基本序列的分区

虽然前面的例子主要使用向量，但分区并不局限于它们。可以在数组、列表以及更高级的容器上应用这些技术。然而，记住底层容器的特性，例如随机访问能力，可能会影响这些操作的效率。

结合这些分区函数，可以构建高效、灵活且高度组织化的系统，以满足多样化的计算需求。考虑以下实际应用：

+   `std::is_partitioned` 和 `std::partition` 可以用于各种排序算法，如快速排序和豪尔分区。它们有助于根据条件高效地分区元素。

+   `std::partition_point` 可以用于二分搜索算法。它有助于找到分区范围内不满足给定条件的第一个元素。这在搜索排序数据集时非常有用。

+   `std::partition` 可以高效地将满足条件的元素与不满足条件的元素分开；例如，从列表中过滤出偶数和奇数。

+   `std::partition` 可以帮助根据这些标准将元素分离到不同的分区中。

+   `std::partition` 可以根据某些条件高效地划分数据，从而提高并行化。

+   `std::partition` 可以用来对数据进行分区，然后单独分析异常值。

+   **游戏开发**：在游戏开发中，可能会使用分区来分离可见对象和隐藏对象，以优化渲染。

+   **数据库查询**：在查询数据库时，可以使用分区来将匹配特定筛选条件的数据与数据集的其余部分分开。

+   **资源管理**：在资源管理场景中，例如内存分配，可以使用分区来高效地隔离已使用和未使用的内存块。作为开发者，我们不断与各种数据及其高效处理作斗争。分区提供了一种结构化的处理方式，使数据组织优化和快速数据访问成为可能。虽然看似简单，但它构成了许多高级算法的基础。

通过掌握 STL 中的分区技术，不仅可以提升单个操作的性能，还能提高应用程序的整体效率和结构。随着我们进入后续章节中的排列和堆操作，请记住高效数据组织的基础重要性。

# 排列

排列的旅程是了解序列元素如何排列的旅程。随着开发者今天处理的序列和数据集的庞大，组织、打乱、旋转和切换元素的能力成为一项迷人的练习，也是许多应用的关键需求。C++ STL 的强大排列算法提供了一条轻松解锁这种潜力的途径。在本节中，我们将学习如何生成、操作和旋转排列，以及实际示例。

## 使用 `std::next_permutation` 生成排列

想象列出数据集的所有可能排列，分析它们，并可能使用它们作为问题的暴力解决方法。STL 提供了 `std::next_permutation` 用于此目的。给定一个范围，此函数将其元素重新排列为下一个字典序较大的排列。当所有排列都已耗尽时，函数返回 `false`，为开发者提供清晰的信号。

考虑一个简单的序列：`{1, 2, 3}`。通过连续调用 `std::next_permutation`，可以生成 `{1, 3, 2}`、`{2, 1, 3}` 等等，直到序列循环回，如下面的代码所示：

```cpp
std::vector<int> data = {1, 2, 3};
 do {
  for (int num : data) { std::cout << num << " "; }
  std::cout << "\n";
} while (std::next_permutation(data.begin(), data.end()));
```

## 使用 `std::prev_permutation` 进行前驱排列

有时，回顾过去是至关重要的，探索先于当前排列的排列。我们之前讨论过的函数 `std::prev_permutation` 的双胞胎就是这样做的。它将序列转换为它的下一个字典序较小的排列。

## 使用 `std::shuffle` 随机排列元素

虽然结构化排列有其位置，但有时随机性才是当天的主题。

进入 `std::shuffle`，这是一个完全随机排列元素的算法。与一个强大的随机数生成器配对，它确保了真正的随机性，这对于许多应用至关重要。

`std::shuffle` 的实际应用包括以下内容：

+   `std::shuffle` 可以用来实现这种随机性。

+   `std::shuffle` 可以用来打乱答案选项。

+   `std::shuffle`，然后选择前 N 个元素。

+   `std::shuffle` 可以帮助将随机性引入游戏。

+   使用 `std::shuffle` 随机化轨道的顺序，为听众提供多样性。

+   `std::shuffle` 可以用来打乱输入或事件，以测试不同的代码路径。

+   **机器学习和数据科学**：在训练机器学习模型或进行数据科学实验时，您可能需要打乱数据集，以确保模型不会学习任何与顺序相关的偏差。

+   `std::shuffle` 可以用来生成此类算法所需的随机化。

+   使用 `std::shuffle` 模拟随机结果或卡牌或骰子的洗牌。

+   `std::shuffle` 不适合加密目的，但在加密算法中，洗牌的概念对于诸如安全卡牌游戏的卡洗功能等目的至关重要。

## 使用 `std::rotate` 旋转序列

并非所有的排列都涉及复杂的重新排列。有时，它只是简单的旋转。`std::rotate` 通过移动元素，使得选定的元素成为新的第一个元素。这就像转动一个旋钮，数字围绕一个中心点旋转。

以下是一个简单的示例，展示了 `std::rotate` 的使用：

```cpp
std::vector<int> nums = {1, 2, 3, 4, 5};
std::rotate(nums.begin(), nums.begin() + 2, nums.end());
// nums now holds {3, 4, 5, 1, 2}
```

让我们现在看看 `std::rotate` 的广泛实际应用：

+   `std::rotate` 可以用来高效地重新定位文本。

+   `std::rotate` 可以用来交换或循环图像资源。

+   **调度和时间管理**：在调度应用中，你可能希望通过旋转一天或一周的预约或任务来适应变化。

+   `std::rotate` 可以用来高效地管理数据在缓冲区内外移动。

+   `std::rotate` 可以用于此类位操作。

+   作为排序过程的一部分的 `std::rotate`，可以有效地处理部分有序数据。

+   **图像处理**：在图像处理中，你可能需要旋转像素值以执行图像变换或操作。

+   `std::rotate` 可以用来在解决方程或进行迭代计算时在向量或数组中移动元素。

+   **内存管理**：在内存管理场景中，你可能需要移动内存块以优化内存分配和碎片整理。

+   **算法优化**：在算法设计中，旋转元素可以通过减少交换或数据移动的数量来帮助提高某些操作的效率。

+   `std::rotate` 可以用来模拟拼图块的旋转。

+   `std::rotate` 可以用来通过旋转或移动数据点来创建动画效果。

使用 STL 的排列带来了数学理论与实际计算相结合的激动人心的混合体。它们体现了重组的精神，从不同的角度看待数据，确保没有遗漏任何一点（或序列！）。

# 堆操作

如果不探索堆，算法奇妙的旅程将是不完整的。**堆**是一种独特的结构，它以特定的顺序（升序或降序）优先处理数据。堆的核心是其承诺：具有最高（或最低）优先级的元素始终位于顶部。使用 C++ STL，堆的管理变得直观，为需要基于优先级操作的应用程序提供了效率和力量。

## 使用 `std::make_heap` 构建堆

从随机数据集合创建堆是这个过程的第一步。使用 `std::make_heap`，可以迅速将任何序列转换为最大堆，其中最大元素位于开头。以下代码演示了 `std::make_heap` 的使用：

```cpp
std::vector<int> v = {3, 7, 2, 5, 1, 7, 4, 9};
std::make_heap(v.begin(), v.end());
```

通过上述简单调用，我们的 `v` 向量现在包含一个有效的最大堆。基于给定的比较器或默认比较，最重要的元素始终位于前端。

## 添加和删除元素 – std::push_heap 和 std::pop_heap

使用堆时，操作不仅仅是查看顶部元素。向堆中添加和删除数据是基本操作。当新元素添加到底层序列时，`std::push_heap` 确保它被适当地放置在堆中，如下面的代码所示：

```cpp
v.push_back(8);  // Add element to vector
std::push_heap(v.begin(), v.end());  // Re-adjust the heap
```

相反，要删除顶部元素，使用 `std::pop_heap`。此函数不会删除元素，而是将其移动到序列的末尾，这使得删除变得方便，如下面的代码所示：

```cpp
std::pop_heap(v.begin(), v.end());
v.pop_back();  // Remove the former top element
```

从堆中添加和删除元素是堆操作的核心。现在，让我们继续探讨一些更高级的内容：基于堆的排序。

## 基于堆的排序 – std::sort_heap 的力量

堆不仅仅是优先级管理。其结构允许高效的排序机制。`std::sort_heap` 将堆转换为升序排序的范围，如下面的代码所示：

```cpp
std::sort_heap(v.begin(), v.end());
```

值得注意的是，当处理插入和提取操作频繁的数据集时，基于堆的排序可以特别有效，使其成为开发者工具箱中的宝贵工具。

## 使用 std::is_heap 检查堆的有效性

确保一个序列保持其堆属性至关重要。`std::is_heap` 提供了快速的有效性检查，如果给定的范围形成一个堆则返回 `true`，否则返回 `false`，如下面的代码所示：

```cpp
bool isHeap = std::is_heap(v.begin(), v.end());
```

此函数在处理复杂序列时特别有价值，确保数据操作没有破坏堆结构。

## 今天计算中堆的重要性

堆在现代计算中至关重要，从任务调度到网络数据包管理。其结构促进了高效的优先级管理，使它们在包括模拟、事件驱动编程等场景中变得不可或缺。

这些基于堆的操作可用于许多实际场景：

+   `std::priority_queue` 容器内部使用堆来有效地管理最优先的元素。

+   **作业调度**：在作业调度算法中，任务或作业通常具有相关的优先级或截止日期。可以使用最小堆来有效地优先排序和调度任务。

+   **迪杰斯特拉最短路径算法**：迪杰斯特拉算法用于在加权图中找到最短路径，它使用最小堆实现的优先队列来选择下一个要探索的顶点。

+   **Huffman 编码**：一种流行的数据压缩技术，Huffman 编码使用字符频率作为权重构建二叉树。在树构建过程中，最小堆可以用于有效地合并节点。

+   **堆排序**：堆排序是一种基于比较的排序算法，它使用二叉堆数据结构，通过反复从未排序的数组中提取最大（对于最大堆）或最小（对于最小堆）元素，从而得到一个排序数组。它是一种原地排序算法，时间复杂度为 *O(n * log n)*。

+   **事件调度**：在离散事件模拟或实时系统中，事件通常与时间戳相关联。可以使用最小堆来按时间顺序调度和处理事件。

+   **内存管理**：在某些内存管理系统中，动态内存分配和释放使用堆来高效地分配和释放内存块。

+   **负载均衡**：在负载均衡算法中，任务或进程被分配到可用资源中。最小堆可以帮助管理资源可用性和任务分配。

+   **在线中值计算**：在处理连续数据流时，可以通过维护两个堆（一个最大堆和一个最小堆）来有效地计算数据的中值。

+   **合并排序文件**：在合并多个排序文件或流时，可以使用最小堆从所有可用元素中选择最小元素，从而促进合并过程。

+   **磁盘空间管理**：在文件系统中，高效管理空闲磁盘空间通常涉及维护一个可用的磁盘块堆。

+   **打印队列中的作业优先级**：打印作业队列可以根据用户优先级或文档大小等因素对打印作业进行优先级排序，这可以通过使用堆实现的优先队列来高效管理。

C++ STL 提供的堆操作为开发者提供了高效处理优先级驱动任务的手段。它们将数据结构的理论优雅性与实用性相结合。在我们过渡到下一节的最佳实践时，理解堆在塑造高效、响应和可靠的应用中的作用至关重要。

# 最佳实践

探索排列、分区和堆可以为 C++ STL 的能力提供有价值的见解。当有效使用时，这些基础元素可以显著提高应用程序的性能和可靠性。遵循最佳实践对于最大化这些好处和确保一致、优化的数据操作至关重要。这些最佳实践包括以下内容：

+   **简化排列任务**：尽管排列提供了广泛的序列变体，但重要的是不要过度复杂化过程。选择直接服务于当前任务的排列操作。对于复杂的操作，将其分解可以帮助保持清晰和专注。

+   使用`std::next_permutation`和`std::prev_permutation`来遍历排列。利用这些函数可以消除手动生成排列的需要，并促进高效且无错误的操作。

+   **最优分区**：在划分数据时，精确且明确的谓词是必不可少的。不明确的准则可能导致不可预测的分区并可能降低应用程序的效率。熟悉你的数据特性可以帮助有效分区。如果数据具有固有的顺序或结构，将其纳入分区算法中可以增强性能并减少资源使用。

+   **保持比较器一致性**：对于堆操作，使用比较器的一致性至关重要。任何使用上的不一致都可能破坏堆结构并导致意外结果。例如，假设你使用一个比较器来构建最大堆，然后切换到不同的比较器来提取元素，在这种情况下，堆的结构可能会被破坏，你可能无法得到预期的最大元素。

+   使用`std::push_heap`和`std::pop_heap`来保持堆的完整性。

+   `std::sort`可能对于更多静态数据集来说更有效率。

这些分区、排列和堆概念可以显著提高应用程序的性能和可靠性。简化排列任务以避免复杂性，利用 STL 排列函数以提高效率，确保数据分区有明确的准则，保持堆操作的比较器一致性，使用适当的函数优先访问堆，以及根据数据集的特征和更新频率选择排序方法，所有这些都有助于。在这些领域遵循最佳实践对于最大化 C++ STL 的好处以及确保编程中数据操作的持续优化至关重要。

# 摘要

在本章中，我们讨论了序列的操作。我们探讨了基于特定谓词组织数据的分区技术，并检查了各种排列算法，这些算法允许在范围内重新排列元素。我们还研究了 STL 提供的堆操作，这些操作有助于实现优先队列和高效排序。

理解这些操作对于开发者来说是至关重要的，因为它们是许多高级算法的基础，并且对于高效数据处理至关重要。掌握分区技术可以快速分离数据，排列允许探索数据集所有可能的排序，而堆提供了一种按优先级始终排序集合的方法。这些工具对于需要优化数据检索、操作和组织的任务是基本的。

在下一章中，我们将探讨范围概念，它为处理元素序列提供了一种更具有表现力的方法。本章将讨论基于范围的操作在排序和搜索算法中的优势，突出其增强的可组合性和可读性。随着我们进入本章，我们将深入了解这些现代技术的实际应用，确保我们作为熟练且当代的 C++开发者的持续成长。
