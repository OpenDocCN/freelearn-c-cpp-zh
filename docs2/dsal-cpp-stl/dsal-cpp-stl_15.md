# 15

# 带有范围的 STL

本章讨论了 C++ 中范围应用的变革性采用，标志着从传统迭代器的范式转变。作为现代 C++ 的一个基本方面，范围推崇表达性和易用性的代码。通过本章，您将掌握使用标准算法利用范围的技术，实现既直观又强大的更简洁代码。通过掌握范围，C++ 开发者可以采用更模块化和高效的算法应用方法，为更可维护和高效的代码库奠定基础。

本章将涵盖以下主题：

+   范围简介

+   排序算法的范围

+   搜索算法的范围

+   最佳实践

# 技术要求

本章中的代码可以在 GitHub 上找到：

[`github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL`](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)

# 范围简介

编程范式不断发展，C++ 也不例外。随着穿越 C++ **标准模板库**（**STL**）广阔领域的旅程展开，其适应性和增长显然是其核心。这一进化步骤，以其表达性和效率而突出，是现代 C++ 中范围的出现。但范围究竟是什么？

## 理解范围的本质

使用 `begin` 和 `end` 定义一个序列，范围将此信息封装在统一的实体中。这种看似微妙的转变具有深远的影响，重塑了我们处理算法和数据操作的方法。

一目了然，以下展示了排序向量的冗长传统方式：

```cpp

std::sort(v.begin(), v.end());
```

然而，使用范围，我们可以这样表达：

```cpp

std::ranges::sort(v);
```

美在于其清晰和简洁。我们不再需要同时处理多个迭代器；范围优雅地传达了意图。

## 为什么转向范围？

从迭代器到范围的演变不仅仅是一个随意的设计选择；它解决了 C++ 社区迫切需要解决的问题，例如以下内容：

+   **表达性**：前面的示例表明，代码的可读性提高了。在不需要明确提及边界迭代器的情况下，在整个序列上表达算法可以促进更自然、声明式的编码风格。

+   **可组合性**：范围使 C++ 的编程方法更加函数化。这意味着算法可以无缝组合，从而产生模块化和易于理解的代码。

+   **错误最小化**：通过减少管理单个迭代器的需求，降低了与不匹配或错误使用迭代器相关的错误概率。这导致代码更安全、更易于维护。

## 查看范围操作的一瞥

范围不仅仅是关于更简洁的语法；它们提供了一系列可以以表达方式转换序列的操作。以下是一些操作：

+   **过滤**：根据特定条件轻松细化序列

+   **转换**：通过对其元素应用函数来修改序列

+   **连接**：无缝连接多个序列

使用范围，这些操作可以串联起来，从而产生既直观又强大的代码。例如，使用范围对序列进行转换和过滤变成了一项简单直接的任务。

## 展望未来——现代 STL 的力量

在 STL 中引入范围表示了向更表达性和更人性化的 C++ 的一大步。随着开发者踏上这一新篇章，他们会发现他们已经依赖的熟悉操作已经得到了增强，并准备好应对软件行业的现代挑战。

C++ 中的范围显著提高了代码质量和开发者生产力。范围提供了一种更声明性的数据操作方法，促进了更干净、更易读的代码。它们允许对数据集合进行操作，而无需显式处理迭代器或创建临时容器。这种抽象不仅减少了样板代码，还最小化了与手动迭代器管理相关的错误可能性。此外，范围还促进了延迟评估，其中计算被推迟到实际需要值时。这可能导致性能改进，尤其是在涉及大数据集或复杂过滤标准的情况下。展望未来，范围有可能通过简化算法应用、增强可组合性和可能引入更多编译器优化机会来彻底改变 C++ 编码实践。随着 C++ 语言的不断发展，范围很可能会成为编写更高效、可维护和直观代码的必要组成部分。

在本节中，我们探讨了现代 C++ 中范围的概念，这是 C++ STL 的一项重大进步。范围代表了序列的一种抽象，提供了一种统一的方式来处理数据序列，而不是传统的迭代器对。这种向范围的转变提高了代码的表达性、可读性和可维护性。范围减少了冗长迭代器管理的需求，最小化了错误并增强了代码的清晰度。它们支持各种操作，如过滤、转换和连接，这些操作可以无缝连接，以实现更直观和强大的编码。C++ 中范围的引入标志着向更声明性数据操作迈出的一步，承诺提高开发者的生产力和代码质量。随着 C++ 的不断发展，范围有望在塑造更高效、更人性化的编码实践中发挥关键作用。

在接下来的章节中，我们将更深入地探讨范围的细微差别，探索它们与经典 STL 算法的应用，并揭示最佳实践以确保它们得到最大限度的利用。

# 排序算法的范围

**排序**是一个基本操作，是算法广阔宇宙中的基石。多年来，STL 赋予我们强大的排序能力。随着范围的引入，这种能力通过简化语法并注入更强的表现力而得到增强。

在本节中，我们将探讨范围如何简化 C++中排序算法的实现。我们将检查基于范围的排序如何减少与传统的基于迭代器的方法相关的语法开销和潜在错误。此外，我们还将讨论范围如何提高排序代码的可读性和可维护性，使其更容易理解和修改。

## 传统 STL 排序——回顾

在深入探讨范围带来的增强功能之前，让我们快速回顾一下传统的 STL 排序方法。传统上，使用`std::sort`函数，需要两个迭代器标记序列的开始和结束：

```cpp

std::vector<int> nums = {4, 1, 3, 2};
std::sort(nums.begin(), nums.end());
```

虽然这种方法有效，但在可读性和用户友好性方面仍有提升空间。为了解决这个问题，引入了 STL 的基于范围的排序。

## 基于范围的排序——基础

重新定义优雅，基于范围的`std::ranges::sort`函数允许我们直接传递要排序的序列。无需与迭代器纠缠。根据我们之前的例子，使用范围，排序过程变为以下：

```cpp

std::vector<int> nums = {4, 1, 3, 2};
std::ranges::sort(nums);
```

基于范围的排序的简洁性使其使用起来非常愉快，减少了潜在的错误途径，并提高了可读性。

## 在排序中拥抱组合性

范围的皇冠上的宝石之一是它们促进组合的能力，这在排序场景中特别明亮。考虑只需要对序列的子集进行排序的需求，或者在进行排序之前链式连接多个操作的需要。范围无缝地满足这些需求。

例如，想象一下需要按逆序对序列中的偶数进行排序的要求。使用范围，这可以在几行代码中表达，利用过滤和排序的结合力量：

```cpp

#include <algorithm>
#include <iostream>
#include <ranges>
#include <vector>
int main() {
  std::vector<int> data = {5, 2, 9, 1, 5, 6, 8, 7, 3, 4};
  // Create a view of the data that filters even numbers
  // and then sorts them
  auto even_sorted =
      data | std::views::filter([](int x) {
        return x % 2 == 0;
      }) |
      std::views::transform([](int x) { return -x; }) |
      std::ranges::to<std::vector<int>>();
  std::sort(even_sorted.begin(), even_sorted.end());
  // Display the sorted even numbers
  std::cout << "Sorted even numbers: ";
  for (int num : even_sorted) { std::cout << num << " "; }
  std::cout << "\n";
  return 0;
}
```

这里是示例输出 1：

1 此示例已测试与 Visual Studio v17.8.6 兼容，但尚未与 GCC v13.2 或 Clang v17.0.1 编译。

```cpp

Sorted even numbers: -8 -6 -4 -2
```

在此示例中，向量数据包含一系列整数。我们使用范围管道创建一个视图，首先使用`std::views::filter`过滤出偶数。然后，我们使用`std::views::transform`对数字取反，使它们可以按逆序排序。最后，使用`std::ranges::to`将视图转换为向量。然后显示排序后的偶数。这展示了范围的组合能力，允许对数据序列进行简洁且富有表现力的操作。

能够链式执行操作，从过滤到排序流畅过渡，展示了范围的组合能力。

## 语法之外的优点——为什么范围在排序中闪耀

除了明显的语法优雅之外，使用范围与 STL 排序算法结合提供了以下好处：

+   将 `begin` 和 `end` 合并为一个单一实体，降低了不匹配迭代器的风险，提高了代码的安全性。

+   **灵活性**：范围与视图相结合，提供了一套动态的工具集。无论是使用自定义比较器进行排序，还是适应不同的数据结构，基于范围的途径都保持一致且简单明了。

+   **表达力**：范围促进了声明性代码风格，其中代码的意图突出。这种表达力在排序复杂数据类型或应用多方面逻辑时非常有价值。

## 排序中范围的革命

排序，一种与编程一样古老的操作，随着范围的引入而焕发新生。将传统的 STL 排序能力与现代范围的优雅性相结合，可以革命性地改变我们的实现，使代码更直观、可维护和高效。

范围已经改变了现代 C++ 中的排序算法。我们已经看到了 STL 排序的传统基于迭代器的方法，以及更简洁、更易读的基于范围的方法。传统方法，即使用 `std::sort` 和迭代器，是有效的，但在可读性和用户友好性方面可以改进。基于范围的排序，使用 `std::ranges::sort`，通过允许直接传递序列来简化这一点，减少了语法复杂性并降低了潜在错误。一个关键亮点是范围的组合性，这在排序场景中特别有益。

使用范围进行排序的优势不仅限于语法。它们通过将序列的开始和结束封装为单一实体来提供安全性，减少了不匹配迭代器的风险。它们提供了灵活性，通过动态工具使用自定义比较器或不同的数据结构进行排序。此外，范围使代码风格更具声明性，使代码的意图更加明显，特别是对于排序复杂数据类型或应用复杂逻辑非常有用。

C++ 中范围（ranges）的引入将 STL 排序算法的传统优势与现代范围的精致性相结合。这一革命导致了更直观、可维护和高效的代码实现。后续章节将继续探索，深入挖掘范围与其他 STL 排序算法的交互，并揭示其有效利用的最佳实践。

# 搜索算法的范围

当深入研究 STL 中算法搜索的领域时，很明显，范围的引入预示着一个简化且表达性强的代码时代的到来。为了欣赏这一演变，回顾 STL 中的传统搜索方法是必要的。

在容器内搜索的经典方式涉及使用诸如 `std::find` 或 `std::find_if` 的函数，其中你需要提供标记搜索范围的迭代器：

```cpp

std::vector<int> nums = {1, 2, 3, 4, 5};
auto it = std::find(nums.begin(), nums.end(), 3);
```

有效？是的。在表达性和适应性方面最优？或许不是。

## 寻找优雅——基于范围的搜索

使用基于范围的代码，过渡到更易读和简洁的代码是显而易见的。使用范围，搜索操作变得固有的声明性更强，如下面的代码所示：

```cpp

std::vector<int> nums = {1, 2, 3, 4, 5};
auto it = std::ranges::find(nums, 3);
```

除了简单的简洁性之外，基于范围的搜索的真正力量在于与其他范围适配器的结合，打开了一条通往更适应性和模块化代码的大门。

## 连接和过滤——可组合性的美丽

代码的优雅之处往往在于其能够以简单、易读的方式表达复杂操作。范围，凭借其可组合性，在实现这种优雅方面发挥着关键作用。让我们考虑一个细微的例子来更好地理解这一点：找到序列中既是素数又大于指定值的第一个三个数。当使用传统的 STL 方法处理这个任务时，可能需要繁琐的循环和条件检查。然而，范围将其转化为高效且易于理解的操作序列。

让我们看看一个有趣的例子来说明这个概念：

```cpp

#include <iostream>
#include <ranges>
#include <vector>
bool is_prime(int number) {
  if (number <= 1) return false;
  for (int i = 2; i * i <= number; i++) {
    if (number % i == 0) return false;
  }
  return true;
}
int main() {
  std::vector<int> nums = {4,  6,  8,  9,  10, 11,
                           13, 15, 17, 19, 23, 25};
  auto prime_greater_than_10 =
      nums |
      std::views::filter([](int n) { return n > 10; }) |
      std::views::filter(is_prime) | std::views::take(3);
  std::cout
      << "First three prime numbers greater than 10: ";
  for (int num : prime_greater_than_10) {
    std::cout << num << " ";
  }
  std::cout << "\n";
  return 0;
}
```

这里是示例输出：

```cpp

First three prime numbers greater than 10: 11 13 17
```

在这个例子中，我们从一个包含一系列整数的`nums`向量开始。使用范围，我们将三个操作串联起来：

1.  对大于 10 的数字进行过滤：`std::views::filter([](int n) { return n > 10; })`选择大于的数字。

1.  对素数进行过滤：`std::views::filter(is_prime)`使用`is_prime`函数仅保留素数

取前三个元素：`std::views::take(3)`将结果限制为满足先前标准的第一个三个元素。

结果是在单行可读代码中无缝集成条件。这个例子不仅展示了连接和过滤的力量，还突出了范围如何显著增强 C++代码的表达性和适应性。简洁性和表达性的结合使得范围成为现代 C++开发中不可或缺的特性。

## 理解搜索中的视图

**视图**在基于范围的景观中至关重要，尤其是在搜索场景中。与容器不同，视图不拥有自己的元素。它们呈现其源数据的转换视图，这可以是一个范围（例如容器）。当纳入搜索时，视图不会修改原始数据，但提供一个新的视角，这在模块化和可重用代码中特别有用。

## 扩展工具包——不仅仅是查找

虽然`std::ranges::find`是基石，但现代基于范围的途径提供了广泛的搜索算法。例如，`std::ranges::search`函数可以定位子序列，或`std::ranges::find_end`函数可以找到序列的最后一个出现，这些函数封装了基于范围的搜索的丰富性。它们的真正力量是通过其他范围适配器解锁的，为高效和表达性搜索任务提供了一系列可能性。

从传统方法过渡到 STL 中的基于范围的搜索，是 C++向更易读、模块化和表达性代码发展的证明。随着我们进一步深入到范围的世界，掌握这些工具和技术对于渴望编写高效且可维护代码的人来说至关重要。

# 最佳实践

向基于范围的 STL 过渡无疑是令人兴奋的。有了这种新的表达性和清晰度，我们手头有了强大的工具。然而，理解一系列最佳实践对于最大限度地发挥范围的作用并确保代码库的可维护性至关重要。让我们看看我们可以实施的一些最佳实践。

## 接受链式操作的力量

范围的一个显著特点是它们自然地能够链式操作。链式操作不仅增强了可读性，而且通过避免中间存储提高了效率：

```cpp

std::vector<int> nums = {5, 8, 10, 14, 18};
auto result = nums | std::views::filter([](int n) { return n % 2 == 0; })
                   | std::views::transform([](int n) { return n * 2; });
```

这优雅的一行代码过滤掉了奇数，然后加倍了偶数。通过促进这种链式操作，你可以培养出更干净、更简洁的代码。

## 防范范围陷阱 - 生命周期意识

全力以赴使用范围是诱人的，尤其是考虑到它们的可组合性。然而，需要谨慎行事。最常见的陷阱之一是无意中悬垂视图，如下面的代码所示：

```cpp

auto doubledEvens() {
    std::vector<int> nums = {1, 2, 3, 4, 5};
    return nums | std::views::filter([](int n) { return n % 2 == 0; })
                | std::views::transform([](int n) { return n * 2; });
}
```

上述代码返回一个局部变量的视图。当此函数退出时，局部变量将被销毁。由于返回的是已销毁变量的视图，这将导致未定义的行为。在处理视图时，始终要意识到底层数据的生命周期。

## 性能考虑 - 懒惰性和评估

范围，尤其是视图，是惰性操作的。这意味着它们仅在访问时才评估它们的元素。虽然这可以提高效率，但这也可能导致陷阱，尤其是在与有状态的运算或副作用结合使用时，如下面的示例所示：

```cpp

int x = 0;
auto range = std::views::iota(1) | std::views::transform(&x { return x += n; });
```

如果`range`被多次评估，lambda 中的副作用会累积，导致意外结果。在这种情况下，建议强制进行急切评估，可能通过将范围转换为容器来实现。

## 可读性胜于简洁性 - 寻找平衡

虽然范围允许编写简洁的代码，但请记住一个基本原则：代码被阅读的次数比被编写的次数多。过度紧凑的范围操作链可能难以理解，尤其是对于新加入代码库的人来说。在简洁性和清晰性之间找到平衡。

## 遵循范围习惯用法——保持标准化

与 C++语言的其它部分一样，已经出现了一些用于使用范围的惯用用法和模式。在可能的情况下，优先选择标准惯用用法。（例如，使用`std::ranges::sort`进行排序，使用`std::ranges::find`进行查找。这两者都比编写自己的循环来完成本质上相同的事情要好。）这使得你的代码对其他 C++开发者来说更容易理解，并确保你从社区测试过的模式中受益。

本节强调了在 C++中使用基于范围的 STL 时的关键最佳实践。它强调了拥抱链式操作的力量的重要性，通过避免中间存储来提高代码的可读性和效率。然而，它也警告了常见的陷阱，如悬空视图，并建议关注底层数据的生命周期。本节指出范围的惰性求值特性，建议在涉及有状态操作或副作用的情况下进行急切求值以避免意外结果。此外，它建议在代码简洁性和可读性之间保持平衡，确保代码易于访问和理解。最后，它建议遵循既定的范围习惯用法，利用标准模式以获得更好的清晰度和社区一致性。这些实践旨在最大限度地发挥范围的作用，同时确保代码的可维护性和健壮性。

# 摘要

在本章中，我们探讨了 C++ STL 中的范围概念以及它们如何增强我们处理元素序列的方式。我们从范围的介绍开始，理解其本质以及转向这一新范式背后的动机。我们看到范围操作如何促进更具有表达性和可读性的代码，并深入探讨了范围为排序算法引入的可组合性。

本章接着聚焦于基于范围的排序，讨论了基本概念以及范围带来的优势，例如更简洁的语法和改进的可组合性。我们还考察了范围在搜索算法中的应用，赞赏了范围如何以优雅而强大的方式使我们能够链式操作并应用过滤器。

范围帮助我们以更好地表达我们意图的方式编写更干净的代码。转向范围代表了 STL 中的一个重大进化，提供了代码的增强清晰度和效率。它允许我们以更可读和可维护的方式组合复杂操作，这对开发过程和代码库的长期性都有益。

现在我们对 STL 数据类型、算法和其他核心概念有了深入的理解，我们将在下一章中使用这些知识来创建我们自己的容器类型，这些类型可以与现有的 STL 算法和迭代器无缝集成。我们将涵盖 STL 兼容性的基本要求，如迭代器实现和值语义。我们将指导您有效地使用操作符重载和创建自定义哈希函数。通过学习创建与 STL 兼容的容器，我们可以扩展 STL 以满足其特定需求，确保其自定义类型能够从 STL 算法和实践的强大功能和灵活性中受益。

# 第四部分：创建与 STL 兼容的类型和算法

我们这本书的这一部分致力于在 C++标准模板库（STL）生态系统中创建和集成自定义类型和算法。我们首先探讨构建与 STL 兼容的容器，详细说明与 STL 算法无缝互操作的基本要求。我们讨论了构建健壮迭代器和操作符重载的细微差别，以提供对自定义类型直观和一致的行为。特别关注创建自定义哈希函数，以促进用户定义类型在无序关联容器中的使用。

接下来，我们将深入了解开发与 STL 兼容算法的复杂性。这包括掌握模板函数，理解重载的微妙之处，并利用内联函数来提高性能。我们将强调使用谓词和函数对象来增强灵活性。

最后，我们被介绍到类型特性和策略，这些是强大的工具，允许开发者编写更适应性和模块化的代码。我们获得了有效实施这些概念的知识，确保您的自定义类型和算法不仅与标准模板库（STL）很好地集成，而且遵循现代 C++编程的最佳实践。

到本部分结束时，您将获得扩展 STL 以满足您独特需求的知识，这将加深对模板元编程和 C++提供的强大抽象的理解。

本部分包含以下章节：

+   *第十六章**：创建 STL-类型容器*

+   *第十七章**：创建与 STL 兼容的算法*

+   *第十八章**：类型特性和策略*
