

# 使用 STL 的线程安全和并发

本章探讨了 C++ **标准模板库**（**STL**）中的并发。本章首先构建了对线程安全、竞态条件和它们固有风险的坚实基础理解。然后，我们转向 STL，解码其线程安全保证，并突出其潜在陷阱。随着我们的深入，读者将了解 C++ 中可用的各种同步工具，掌握它们在多线程环境中的应用，以保护 STL 容器。完成本章后，读者可以确保在并发 C++ 应用程序中数据的一致性和稳定性。

本章我们将涵盖以下主题：

+   并发与线程安全

+   理解线程安全

+   竞态条件

+   互斥锁和锁

+   STL 容器和线程安全

+   特定容器问题

+   STL 中的并发支持

+   使用 `std::thread`、`std::async`、`std::future` 和线程局部存储

+   STL 中的并发数据结构

# 技术要求

本章中的代码可以在 GitHub 上找到：

[`github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL`](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)

# 并发与线程安全

**并发**是多个任务在重叠时间段内执行的概念。这些任务可以在不同的处理单元上同时运行，或者可能在单个处理单元上交错运行。并发的目标是提高系统的响应性和吞吐量。并发在各种场景中都有益，例如设计处理多个同时客户端请求的服务器或在后台处理任务的同时必须保持用户界面响应。

在 C++ 中，并发可以以多种形式体现：多线程，其中独立的执行线程（可能）并行运行，或者异步编程，其中特定任务被卸载以供稍后执行。

在 C++ 中，理解并发和 **线程安全** 是相关但不同的概念至关重要。并发指的是程序同时执行多个操作序列的能力，这可以通过多线程或其他并行执行技术实现。然而，并发本身并不保证线程安全。线程安全是确保代码在多个线程并发访问时正确运行的属性。这涉及到仔细管理共享资源、同步数据访问和避免竞态条件。在并发环境中实现线程安全是 C++ 编程的一个挑战性方面。它需要明确的设计选择和使用特定的机制，如互斥锁、锁和原子操作，以防止数据损坏并确保所有线程的一致行为。

## 线程安全——稳定并发的支柱

**线程安全**指的是代码在多个线程并发访问时正确运行的能力。它确保共享数据保持其完整性，结果保持一致。线程安全并不本质上意味着函数或方法是无锁的或没有性能瓶颈；相反，它表示并发访问不会导致不可预测的结果或损害数据。

考虑一个类比：如果**并发**类似于繁忙的城市交叉口，那么线程安全就是交通信号灯，确保汽车（线程）不会相互碰撞。

## 并发和线程安全之间的相互作用

虽然这两个概念相互交织，但它们服务于不同的目的。并发关注于设计系统以在重叠的时间框架内执行多个任务，旨在提高性能和响应速度。另一方面，线程安全完全是关于正确性的。它关乎确保这些并发任务在交互共享资源时不会相互干扰。

让我们考虑一个简单的例子：C++中的计数器类。并发可能涉及从多个线程中增加计数器的值。然而，如果计数器的增加操作不是线程安全的，两个线程可能会同时读取相同的值，增加它，然后写回相同的增加后的值。在这种情况下，尽管试图通过并发来提高速度，但计数器最终会丢失计数，导致结果不正确。

## 挑战与回报

引入并发无疑可以使应用程序更快、更响应。然而，它也引入了复杂性。管理多个线程，处理死锁和竞态条件等问题可能具有挑战性。

但是，如果做得正确，回报是巨大的。程序变得更加高效，可能充分利用所有可用的处理单元。应用程序可以更加响应，从而提高用户体验。并发编程不再是选择，而是许多现代高性能应用程序的必要条件。

## 没有线程安全的并发 – 混乱的配方

想象一个世界，每个任务都试图尽可能快地执行自己，而不进行协调。在这样的世界里，任务可能会相互碰撞，相互干扰，并产生无意义的输出。这就是没有线程安全的并发编程的样子。这是一个优先考虑速度而非正确性的领域，通常会导致混乱。

作为一名 C++开发者，关键是要找到正确的平衡。在追求高并发以使应用程序快速的同时，投资于线程安全机制同样至关重要，以确保正确性。

理解并发和线程安全之间的区别为以下章节奠定了基础。我们将探讨 STL 提供的工具和结构，以实现高并发并确保线程安全。

# 理解线程安全

执行多个同时任务可以提高性能和响应速度。确保线程安全，尤其是在使用 STL 时，变得至关重要。如果被忽视，无缝并发的梦想可能会迅速变成数据不一致和不可预测行为的噩梦。

## STL 容器中的线程安全——奠定基础

STL 的吸引力在于其丰富的容器集合，它们为存储和管理数据提供了流畅的体验。但是，一旦引入多个线程，潜在的危险就会浮现。

线程安全主要关于确保当多个线程访问时，你的代码表现出可预测和正确的行为，即使这些线程是重叠的。对于 STL 容器来说，基本保证很简单：容器的同时只读访问是安全的。然而，一旦引入写入（修改），事情就变得复杂了。

理解这一点至关重要：虽然 STL 容器具有线程安全的读取操作，但写入操作则不是。如果一个线程正在更新一个容器，那么没有其他线程应该读取或写入它。否则，我们就是在招致灾难，或者用技术术语来说，就是**未定义行为**。

## 理解 STL 算法的线程安全特性

如果 STL 容器是库的灵魂，那么算法无疑是其跳动的心脏。它们负责 STL 的丰富功能，从搜索和排序到数据转换。

这里有个问题：STL 算法是函数，它们的线程安全性不是由算法本身决定的，而是由它们操作的数据决定的。如果一个算法在没有适当同步的情况下操作跨线程的共享数据，你就是在为竞态条件做准备，即使该算法只读取数据。

考虑这样一个场景，你在多个线程中使用 `std::find`。虽然该算法对于并发读取操作本质上是安全的，但如果在搜索过程中另一个线程修改了数据，结果可能会偏斜。

## 竞态条件——机器中的幽灵

竞态条件让并发程序员夜不能寐。当你的软件的行为依赖于事件相对时间顺序，例如线程调度的顺序时，就会发生**竞态条件**。后果从无害（轻微错误的数据）到灾难性（完全数据损坏或应用程序崩溃）不等。

在多线程环境中使用 STL 而没有采取适当的预防措施可能会引入竞态条件。例如，想象两个线程同时向一个 `std::vector` 推送元素。如果没有同步，向量的内部内存可能会损坏，导致一系列问题。

让我们看看一个简单的竞态条件。在这个例子中，我们将使用两个线程来增加一个计数器：

```cpp
#include <iostream>
#include <thread>
// Shared variable
int counter = 0;
// Function that increments the counter
void incrementCounter() {
  for (int i = 0; i < 100000; ++i) {
    ++counter; // Race condition occurs here
  }
}
int main() {
  // Creating two threads that run incrementCounter()
  std::thread thread1(incrementCounter);
  std::thread thread2(incrementCounter);
  // Wait for both threads to finish
  thread1.join();
  thread2.join();
  // Print the final value of counter
  std::cout << "Final value of counter is: " << counter
            << std::endl;
  return 0;
}
```

这里是一个可能的输出示例：

```cpp
Final value of counter is: 130750
```

竞争条件发生是因为两个线程同时访问和修改共享变量 counter，而没有任何同步机制（如**互斥锁**或**锁**）。由于缺乏同步，两个线程可能以不可预测的顺序读取、增加并写回计数器的值。这导致计数器的最终值不可预测，通常小于预期的 200,000，因为一些增加丢失了。由于竞争条件，多次运行此程序可能会得到不同的计数器最终值。为了解决这个问题，应使用适当的同步机制，如互斥锁，以确保一次只有一个线程修改共享变量。

## 保护并发——前进的道路

很明显，仅仅理解线程安全性只是战斗的一半。随着我们进入本章，我们将为您提供工具和技术来直面竞争条件，掌握可用的同步机制，并确保您的基于 STL 的多线程应用程序成为稳定性和一致性的堡垒。

# 竞争条件

在编程中，当系统的行为依赖于多个线程或进程的相对时间顺序时，就会发生竞争条件。在这种情况下，系统的结果变得不可预测，因为不同的线程可能在不适当的同步下同时访问和修改共享数据。这可能导致不一致或错误的结果，因为数据的最终状态取决于线程执行的顺序，而这个顺序无法提前确定。竞争条件是并发编程中常见的问题。它们可能特别具有挑战性，需要仔细的设计和同步机制来确保正确的和可预测的程序行为。

## 避免无声的陷阱——STL 中的竞争条件

当您进入并发编程之旅时，竞争条件代表了一个最微妙但最危险的陷阱之一。尽管它们的表现在沉默中，但它们可能导致意外和有时令人困惑的结果。识别并避开这些竞争条件，尤其是在 STL 领域，对于构建健壮的多线程应用程序至关重要。

## STL 中竞争条件的解剖

在本质上，当您的应用程序的行为取决于不可控事件的序列或时机时，竞争条件就会出现。在 STL 的上下文中，这通常发生在多个线程以无协调的方式访问共享数据时。

想象一个场景，其中两个线程不幸地同时尝试将元素插入`std::vector`的相同位置，或者考虑另一个实例，其中一个线程从`std::unordered_map`中读取，而另一个线程删除一个元素。结果会怎样？未定义的行为，在 C++的世界里，这相当于打开了潘多拉的盒子。

## 超出表面

竞态条件由于其不可预测性而特别危险。虽然并发应用程序可能在一次运行中看似完美无缺，但线程执行时间上的微小变化可能导致下一次运行时出现完全不同的结果。

除了异常行为外，STL 容器和算法中的竞态条件还可能导致更严重的问题。数据损坏、内存泄漏和崩溃只是冰山一角。鉴于这些问题难以捉摸和间歇性出现，调试这些问题可能具有挑战性。

## 预测竞态条件

有备无患。通过熟悉 STL 中竞态条件出现的常见场景，你可以提前应对这些问题：

+   `std::vector`和`std::string`，当它们的容量超过时，会自动调整大小。如果两个线程同时触发调整大小，内部状态可能会陷入混乱。

+   **迭代器失效**：修改容器通常会使得现有的迭代器失效。如果一个线程使用迭代器遍历容器，而另一个线程正在修改容器，那么第一个线程的迭代器可能会陷入无人之地。

+   **算法假设**：STL 算法对其操作的数据做出某些假设。并发修改可能会违反这些假设，导致结果错误或无限循环。

## 保护你的代码——采取主动立场

在熟悉了潜在的“热点”之后，自然地，我们需要加强我们的代码以抵御这些危险。关键在于同步。我们可以通过确保只有一个线程可以同时访问共享数据或执行某些操作来有效地防止竞态条件。

然而，不加区分的同步可能导致性能瓶颈，使并发的优势化为乌有。关键在于找到平衡点，审慎地应用同步。

随着我们进一步深入本章，我们将介绍一系列强大工具和技术。从互斥锁到锁，你将掌握检测和有效中和竞态条件的方法，确保你的 STL 驱动应用程序快速且稳定。

你准备好用 STL 征服并发编程的挑战了吗？让我们共同探索这个领域，确保你的软件保持一致性、可靠性和无竞态条件。

# 互斥锁和锁

**互斥锁**，简称**互斥**，类似于一个数字守门人。它调节访问，确保在任何给定时刻，只有一个线程可以进入其受保护的领域，消除并发访问的混乱。想象一下一个高风险的拍卖室，在任何时刻只能有一个人出价，从而防止重叠和冲突。这就是多线程应用程序中互斥锁的功能。

在 C++标准库中，头文件`<mutex>`赋予我们几种类型的互斥锁。其中最常用的是`std::mutex`。这是一个多用途的工具，适用于许多同步需求。一对操作——`lock()`和`unlock()`——提供了一种简单的方法来保护共享资源。

## 从手动到自动 - 锁保护与独特锁

手动锁定和解锁互斥锁可能会出错。总会有忘记解锁互斥锁的潜在危险，导致死锁。这时就出现了锁保护与独特锁；它们通过采用**资源获取即初始化（RAII**）原则简化了互斥锁的管理。

`std::lock_guard`是一个轻量级包装器，它自动管理互斥锁的状态。一旦锁保护器获取了互斥锁，它就保证在锁保护器的作用域结束时释放它。这消除了忘记释放互斥锁的风险。

另一方面，`std::unique_lock`要灵活一些。除了`lock_guard`提供的自动锁定管理外，`unique_lock`还提供了手动控制、延迟锁定以及转移互斥锁所有权的能力。这使得它适用于更复杂的同步场景。

## 避免僵局 - 死锁预防

想象一个场景，其中两个线程处于僵持状态，每个线程都期待对方释放资源。结果，两者都陷入永久的等待，导致经典的死锁。这种情况并非纯粹假设，尤其是在涉及互斥锁的情况下，因为如果不小心管理，它们可能会无意中造成这样的死锁。当涉及多个互斥锁时，采用避免死锁的策略至关重要。一种常见的方法是始终以相同的顺序获取互斥锁，无论你在哪个线程中。但是，当这不可行时，`std::lock`就派上用场了。它设计用来同时锁定多个互斥锁，而不会造成死锁的风险。

## 将互斥锁与 STL 容器结合使用

在掌握了互斥锁、锁保护、独特锁和死锁预防技术之后，将这些同步工具与 STL 容器集成变得直观起来。

例如，为了保护`std::vector`免受并发访问，可能需要在修改或访问向量的每个函数中放置`std::lock_guard`。同样，如果必须在`std::unordered_map`上执行多个原子操作，`std::unique_lock`可以提供保护，并在需要时手动控制锁的状态的灵活性。

拥有互斥锁和锁的工具后，STL 中的线程编程不再像在薄冰上行走。通过确保这些同步原语的合理和一致应用，你可以充分利用并发能力，同时避免竞争条件和死锁的陷阱。

在接下来的章节中，我们将继续我们的探索，特别关注在特定 STL 容器中进行线程操作时遇到的独特挑战和考虑因素。

# STL 容器和线程安全

当讨论 STL 容器时，假设它们在所有容器中都具备相同的线程安全性是诱人的。然而，这样的假设可能会误导。默认情况下，STL 容器在修改时不是线程安全的，这意味着如果一个线程正在修改一个容器，同时其他线程也在访问它，可能会导致未定义的行为。

然而，存在一些内在的保证。例如，只要没有线程正在修改它，多个线程同时从 STL 容器中读取是安全的。这通常被称为**读并发**。然而，当甚至有一个线程试图在其他人读取时更改容器，我们就会回到危险的竞争条件领域。

## 当安全需求需要加固时——并发修改

虽然并发读取是安全的，但修改会带来不同的挑战。假设两个或更多线程同时尝试修改 STL 容器，那么除非使用同步机制（例如我们用互斥锁和锁探索过的那些），否则行为将是未定义的。

以 `std::vector` 为例。如果在没有互斥锁保护这些操作的情况下，一个线程使用 `push_back` 添加元素，而另一个线程尝试使用 `pop_back` 移除元素，就会产生竞争条件。向量的大小可能在操作过程中改变，或者内存可能被重新分配，导致崩溃或数据不一致。

## 容器迭代器——脆弱的桥梁

迭代器是 STL 容器的基石，提供了遍历和操作容器元素的手段。然而，当涉及到并发时，迭代器是脆弱的。如果一个线程以导致重新分配或结构重组的方式修改容器，其他线程的迭代器可能会失效。使用失效的迭代器是，再次强调，未定义的行为。

例如，在 `std::list` 或 `std::map` 等容器中，添加元素不会使现有的迭代器失效。然而，在 `std::vector` 中，当向量超出其当前容量时触发的重新分配可能会使所有现有的迭代器失效。在安排多线程操作时，意识到这些细微差别至关重要。

## 带有内置保护机制的容器——并发容器

在认识到开发者在同步标准 STL 容器时面临的挑战时，该库引入了并发容器。这些容器，例如 `std::atomic` 以及某些编译器的 `concurrency` 命名空间中的容器（对于某些编译器），都内置了同步机制，以性能的潜在代价提供线程安全的操作。

重要的是要注意，这些容器可能不会提供与它们的标准 STL 对应物相同的接口或性能特性。它们是针对手动同步开销可能过于显著的场景而专门设计的工具。

虽然 STL 容器为 C++编程带来了极大的便利和效率，但它们也带来了理解其线程特性的责任。通过判断何时何地需要显式同步，并利用我们可用的工具和技术，我们可以确保我们的多线程应用程序保持健壮、高效，并且没有由并发引起的错误。

# 特定容器问题

不同的 STL 容器类型在多线程环境中具有独特的挑战和考虑因素。对这些容器上的操作的安全性不是固有的保证，因此在并发场景中使用它们是一个需要仔细规划的问题。例如，`std::vector` 或 `std::map` 等容器在同时被多个线程访问或修改时可能会表现出不可预测的行为，导致数据损坏或竞争条件。相比之下，`std::atomic` 等容器是为在单个元素上安全进行并发操作而设计的，但它们并不保护容器结构的整体安全性。因此，了解每个 STL 容器类型的特定线程影响是至关重要的。开发人员必须实现适当的锁定机制或在必要时使用线程安全变体，以确保在多线程环境中数据完整性和正确的程序行为。

## std::vector 在多线程中的行为

`std::vector` 是一种广泛使用的 STL 容器，充当动态数组，根据需要调整其大小。其连续内存分配提供了诸如缓存局部性等优势。然而，在多线程场景中，会面临挑战。

例如，当向量的容量超出并重新分配内存时，所有相关的迭代器、指针和引用都可能失效。如果一个线程正在迭代向量，而另一个线程触发重新分配（添加超出其限制的元素），这可能会导致问题。为了防止此类情况，应在多个线程访问向量时触发重新分配的操作期间实现同步机制。

## std::list 在并发中的特性

`std::list`，作为一种双链表，在多线程情况下具有有益的行为，但也需要谨慎。一个关键优势是，除非目标特定的被删除元素，否则插入或删除操作不会使迭代器失效，这使得某些操作自然地线程安全。

然而，需要谨慎行事。虽然迭代器可能保持不变，但并发修改可能会改变元素的顺序，导致结果不一致。

## 关联容器的考虑因素

例如，`std::set`、`std::map`、`std::multiset`和`std::multimap`这样的容器根据它们的键对元素进行排序。这确保了有组织的数据检索。

在多线程情况下，这个特性会带来挑战。并发的元素插入可能会导致不可预测的最终序列。此外，并发的删除可能会引发竞争条件。

## 无序容器的并发方面

无序版本的关联容器，如`std::unordered_set`和`std::unordered_map`，不按定义的顺序保持元素。然而，它们并不免除多线程问题。这些容器利用散列，元素添加可能会触发重新散列以优化性能。

重新散列可能导致迭代器失效。因此，尽管它们是无序的，但在并发操作期间仍需谨慎处理。

## 容器适配器的见解

STL 提供了容器适配器，如`std::stack`、`std::queue`和`std::priority_queue`。它们没有自己的存储，而是封装了其他容器。它们的线程安全性取决于它们所基于的容器。例如，使用`std::vector`的`std::stack`实例将会有相同的重新分配和迭代器失效问题。

了解每个 STL 容器的具体行为对于开发线程安全的 C++程序至关重要。虽然 STL 提供了具有不同优势的众多工具，但在多线程环境中它们也面临挑战。

# STL 中的并发支持

STL 已经发生了显著的变化，从数据结构和算法的集合转变为一个综合库，其中包含了用于并发编程的高级构造。这种扩展是为了响应对高效和健壮的多线程应用程序的需求，尤其是在多核处理器的时代。现代软件开发通常需要利用并发的力量来提高性能和响应速度。因此，对 STL 并发支持的深入理解对希望优化其应用程序的并发环境中的开发者来说是有益的和必要的。

本节将检查 STL 中集成的并发功能。这包括对线程管理、异步任务、原子操作以及利用并发时的挑战的详细审查。

STL 在并发领域的提供不仅仅是为了促进多线程，还在于以有效和可管理的方式进行。本节旨在提供对这些工具的全面理解，使您能够编写在当今计算需求日益增长的世界中高性能、可扩展和可靠的 C++应用程序。

## 线程简介

并发编程的核心是线程的概念。在 STL 中，这由`std::thread`表示。这个类提供了一个创建和监管线程的简单接口。启动一个新线程本质上就是定义一个函数或可调用实体，并将其传递给线程构造函数。在执行完任务后，你可以连接（等待其完成）或分离（允许其独立执行）线程。然而，这里有一个警告：手动处理线程需要仔细注意。确保所有线程都正确连接或分离是必要的，以避免潜在的问题，包括悬挂线程。

## 异步任务的出现

直接线程管理提供了相当的控制力，但 STL 引入了`std::async`和`std::future`来处理那些不需要如此细致监管的任务。这些构造函数使开发者能够将任务委托给潜在的并行执行，而无需直接线程监管的复杂性。`std::async`函数启动一个任务，其结果`std::future`提供了一个在任务准备好时获取结果的方法。这促进了更有序的代码，尤其是在关注以任务为中心的并行性时。

## 原子操作

STL 通过原子操作为低开销操作提供了一种强大的解决方案，在这些操作中，锁定机制可能显得不成比例。封装在`std::atomic`类模板中的原子操作在并发编程中发挥着关键作用，通过保证基本数据类型操作的原子性。

`std::atomic`旨在确保对基本类型（如整数和指针）的操作作为不可分割的单元执行。这种原子性在多线程环境中至关重要，因为它防止了中断操作可能带来的潜在风险，这些风险可能导致数据状态不一致或损坏。通过确保这些操作在没有中断的情况下完成，`std::atomic`消除了对传统锁定机制（如互斥锁）的需求，从而通过减少与锁定竞争和上下文切换相关的开销来提高性能。

然而，需要注意的是，使用原子操作需要仔细考虑，并理解它们的特性和限制。虽然它们提供了一种无锁编程的机制，但原子操作并不是所有并发问题的万能药。开发者必须了解内存顺序约束以及在不同硬件架构上的潜在性能影响。特别是，在内存排序（如`memory_order_relaxed`、`memory_order_acquire`、`memory_order_release`等）之间的选择，需要彻底理解同步需求和涉及的权衡。

内存排序，例如`memory_order_relaxed`、`memory_order_acquire`和`memory_order_release`，决定了原子变量上的操作相对于其他内存操作是如何排序的。

选择正确的内存排序对于确保所需的同步级别并平衡性能至关重要。例如，`memory_order_relaxed`提供最小的同步，不对内存操作施加排序约束，从而带来更高的性能，但同时也存在风险，即允许其他线程以不同的顺序看到操作。另一方面，`memory_order_acquire`和`memory_order_release`提供了关于读写排序的更强保证，这对于正确实现无锁数据结构和算法至关重要，但可能会带来性能成本，尤其是在内存模型较弱的系统中。

这些决策中涉及到的权衡是重大的。更宽松的内存排序可能导致性能提升，但也可能引入微妙的 bug，如果程序的正确性依赖于某些内存排序保证的话。相反，选择更强的内存排序可以简化关于并发代码正确性的推理，但可能会因为额外的内存同步屏障而导致性能下降。

因此，开发者必须了解他们特定应用程序的同步需求，并理解他们的内存排序选择如何与底层硬件架构交互。这种知识对于编写高效的 C++并发程序至关重要。

## 可能的并发挑战

尽管并发编程功能强大，但并非没有挑战。开发者可能会遇到死锁、竞态条件和资源竞争。死锁发生在多个线程无限期地等待彼此释放资源时。竞态条件可能导致由线程操作中的不可预见重叠引起的异常 bug。

**内存伪共享**是另一个显著的挑战。当不同的线程修改位于同一缓存行中的数据时，就会发生这种情况。这可能会影响性能，因为即使线程修改不同的数据，它们的内存接近性也可能触发多余的缓存失效。意识和谨慎可以帮助避开这些挑战。

## 使用 STL 的并发特性

STL 提供了用于并发编程的一系列工具，从线程的启动到原子任务的保证。这些工具满足各种需求。然而，明智地使用它们是至关重要的。

并发编程承诺提升性能和灵活的应用，但同时也伴随着复杂性和潜在的 bug。在并发编程中，了解可用的工具是一个必要的起点，但有效地使用它们需要持续的试验和学习。

以下 C++ 代码示例展示了 STL 的各种并发功能。此示例包括线程创建、异步任务执行和原子操作，同时强调了适当线程管理的重要性以及并发可能存在的陷阱：

```cpp
#include <atomic>
#include <future>
#include <iostream>
#include <thread>
#include <vector>
// A simple function that we will run in a separate thread.
void threadTask(int n) {
  std::this_thread::sleep_for(std::chrono::seconds(n));
  std::cout << "Thread " << std::this_thread::get_id()
            << " completed after " << n << " seconds.\n";
}
// A function that performs a task and returns a result.
int performComputation(int value) {
  std::this_thread::sleep_for(std::chrono::seconds(1));
  return (value * value);
}
int main() {
  // Start a thread that runs threadTask with n=2
  std::thread t(threadTask, 2);
  // task management with std::async and std::future
  std::future<int> futureResult = std::async(
      std::launch::async, performComputation, 5);
  // Atomic operation with std::atomic
  std::atomic<int> atomicCounter(0);
  // Demonstrate atomicity in concurrent operations
  std::vector<std::thread> threads;
  for (int i = 0; i < 10; ++i) {
    threads.emplace_back([&atomicCounter]() {
      for (int j = 0; j < 100; ++j) {
        atomicCounter += 1; // Atomic increment
      }
    });
  }
  // Joining the initial thread to ensure it has finished
  // before main exits
  if (t.joinable()) { t.join(); }
  // Retrieving the result from the future
  int computationResult = futureResult.get();
  std::cout << "The result of the computation is "
            << computationResult << ".\n";
  // Joining all threads to ensure complete execution
  for (auto &th : threads) {
    if (th.joinable()) { th.join(); }
  }
  std::cout << "The final value of the atomic counter is "
            << atomicCounter << ".\n";
  return 0;
}
```

下面是示例输出：

```cpp
Thread 32280 completed after 2 seconds.
The result of the computation is 25.
The final value of the atomic counter is 1000.
```

在这个例子中，我们做了以下几件事：

+   使用 `std::thread` 创建一个线程，该线程休眠指定的时间然后打印一条消息。

+   使用 `std::async` 以可能并行的方式执行计算，并使用 `std::future` 在准备好后获取结果。

+   使用 `std::atomic` 在多个线程中执行原子递增操作。

+   确保所有线程都正确连接，以避免悬挂线程。

这段代码是一个简单的演示，作为理解 C++ 中并发的基础。开发者必须进一步探索和处理更复杂的场景，包括同步、防止死锁以及避免竞争条件和虚假共享，以构建健壮的并发应用程序。

# 使用 std::thread、std::async、std::future 和线程局部存储

让我们看看 C++ 并发工具箱的四个核心组件：`std::thread`、`std::async`、`std::future` 和线程局部存储。这些元素对于促进 C++ 的多线程编程至关重要。`std::thread` 是基础，允许创建和管理线程。`std::async` 和 `std::future` 协同工作，以异步执行任务并以受控的方式检索其结果，提供了比原始线程更高的抽象级别。另一方面，线程局部存储为每个线程提供独特的数据实例。这在并发环境中避免数据冲突至关重要。本节旨在全面理解这些工具，展示如何有效地使用它们来编写健壮、高效且线程安全的 C++ 应用程序。

## 使用 std::thread 启动线程

在 C++ 的并发领域，`std::thread` 是一个主要工具。这个类允许开发者通过启动不同的线程来并发运行程序。要启动一个新线程，将可调用实体（如函数或 lambda）传递给 `std::thread` 构造函数。例如，要从独立线程打印“Hello, Concurrent World!”，请参阅以下示例：

```cpp
std::thread my_thread([]{
    std::cout << "Hello, Concurrent World!" << "\n";
});
my_thread.join();
```

使用 `join()` 函数确保主线程等待 `my_thread` 完成。还有 `detach()`，它允许主线程无延迟地继续。然而，仔细管理分离的线程对于避免意外行为至关重要。

## 使用 std::async 和 std::future 管理异步操作

虽然 `std::thread` 提供了显著的能力，但直接线程管理可能很复杂。STL 通过 `std::async` 和 `std::future` 提供了一种高级抽象，用于管理潜在的并行操作。

方法非常明确：将任务分配给 `std::async` 并检索一个最终将包含该任务结果的 `std::future` 对象。这种划分允许主线程继续执行或可选地使用 `std::future` 的 `get()` 方法等待结果，如下面的代码示例所示：

```cpp
auto future_result = std::async([]{
    return "Response from async!";
});
std::cout << future_result.get() << "\n";
```

如您所见，`std::async` 和 `std::future` 被设计成可以很好地协同工作，以帮助管理异步操作。

## 使用线程局部存储来保持数据一致性

在并发编程中确保每个线程有独立的数据存储以避免重叠并保持数据一致性可能具有挑战性。这通过 **线程局部存储**（**TLS**）得到解决。

在声明变量时使用 `thread_local` 关键字确保每个线程都有一个该变量的唯一实例。这在维持数据一致性并避免与共享数据访问相关的问题中起着至关重要的作用：

```cpp
thread_local int thread_counter = 0;
```

在这里，`thread_counter` 为每个线程实例化，从而防止线程间的干扰。

## 集成用于熟练并发编程的工具

通过 `std::thread`、`std::async`、`std::future` 和 TLS，你准备好在 C++ 中导航各种并发编程场景。STL 提供了委托任务以进行并行执行或巧妙管理线程特定数据的必要工具。

需要特别注意，虽然启动线程或任务很简单，但确保同步操作无争用、无死锁或无数据竞争需要关注和持续改进。

在过渡到后续部分，这些部分将回顾 STL 的并发数据结构时，保留这一段的基础洞察至关重要。并发编程是一个不断发展的领域，掌握每个工具和概念可以增强你开发高效和稳定并发应用的能力。

让我们通过一个代码示例来了解如何使用 `std::thread`、`std::async`、`std::future` 和 TLS 来并发执行任务和管理每个线程的数据：

```cpp
#include <future>
#include <iostream>
#include <thread>
#include <vector>
// Function to demonstrate the use of Thread Local Storage
void incrementThreadCounter() {
  // Unique to each thread
  thread_local int thread_counter = 0;
  thread_counter++;
  std::cout << "Thread " << std::this_thread::get_id()
            << " counter: " << thread_counter << "\n";
}
int main() {
  // Initiating a new thread using std::thread
  std::thread my_thread([] {
    std::cout << "Hello, Concurrent World!"
              << "\n";
  });
  // Ensure the main thread waits for my_thread to complete
  if (my_thread.joinable()) { my_thread.join(); }
  // Asynchronous operations w/std::async and std::future
  auto future_result =
      std::async([] { return "Response from async!"; });
  // Retrieve the result with std::future::get when ready
  std::cout << future_result.get() << "\n";
  // Demonstrating the use of Thread Local Storage (TLS)
  std::vector<std::thread> threads;
  for (int i = 0; i < 5; ++i) {
    threads.emplace_back(incrementThreadCounter);
  }
  // Join all threads to the main thread
  for (auto &thread : threads) {
    if (thread.joinable()) { thread.join(); }
  }
  return 0;
}
```

这里是示例输出：

```cpp
Hello, Concurrent World!
Response from async!
Thread 11672 counter: Thread 1
32816 counter: 1
Thread 7124 counter: 1
Thread 43792 counter: 1
Thread 23932 counter: 1
```

在此代码中，我们做了以下操作：

+   使用 `std::thread` 创建了一个线程来向控制台打印消息。

+   使用 `std::async` 执行一个异步操作，该操作返回一个字符串。结果通过 `std::future` 对象访问。

+   使用 `thread_local` 关键字演示了 TLS 的使用，以为每个线程维护一个单独的计数器。

+   启动了多个线程，每个线程增加其局部计数器，以展示 TLS 变量是如何为每个线程实例化的。

此示例封装了使用 STL 进行并发编程的要点，从线程创建和同步到使用 TLS 的数据隔离。虽然这些机制简化了并行执行，但我们必须谨慎判断以防止与并发相关的问题，如死锁和竞态条件。接下来的章节将探讨 STL 的并发数据结构，这些数据结构基于这些基础概念，以实现健壮并发程序的创作。

# STL 中的并发数据结构

STL 提供了各种数据结构，但并非所有数据结构都天生适合并发访问。理解如何有效地利用和调整这些数据结构，以确保在多线程环境中的安全和高效使用，至关重要。我们将检查常见 STL 数据结构的线程安全性方面，讨论在并发环境中每个数据结构的适当使用案例，并探索确保安全和有效并发访问的策略。本节旨在为开发者提供利用 STL 数据结构以最大化性能同时保持数据完整性的多线程环境下的知识。

## STL 的并发优化容器

虽然 STL 提供了许多容器，但并非所有都针对并发访问进行了优化。然而，随着对并发编程需求的增加，特定的并发友好型容器已经进入了许多 C++程序员的工具箱。

一个显著的例子是 `std::shared_timed_mutex` 及其兄弟 `std::shared_mutex`（从 C++17 开始）。这些同步原语允许多个线程同时读取共享数据，同时确保写入时的独占访问。这在读取操作比写入操作更频繁的情况下特别有用，例如在缓存场景中。

考虑这样一种情况，你有一个存储配置数据的 `std::map`：

```cpp
std::map<std::string, std::string> config_data;
std::shared_timed_mutex config_mutex;
```

要从这个映射中读取，多个线程可以获取共享锁：

```cpp
std::shared_lock lock(config_mutex);
auto val = config_data["some_key"];
```

然而，对于写入，唯一锁确保了独占访问：

```cpp
std::unique_lock lock(config_mutex);
config_data["some_key"] = "new_value";
```

虽然 `std::shared_timed_mutex` 不是一个容器，但它可以保护任何 STL 容器，确保并发读取访问同时序列化写入。

## 在并发环境中追求最大效率

并发不仅仅是使操作线程安全，也是关于实现更好的性能。正如你所看到的，原子类型和并发优化的容器有助于确保安全性，但还有更多。微调性能可能需要考虑锁竞争、避免伪共享和最小化同步开销。

以下是一些提高效率的技巧：

+   **限制锁的范围**：虽然锁对于确保数据一致性至关重要，但长时间持有锁可能会阻碍性能。确保你只持有锁的必要时间。

+   **选择合适的数据结构**：针对并发优化的容器可能为多线程应用程序提供更好的性能，即使它们在单线程场景中可能较慢。

+   **考虑粒度**：考虑你锁的粒度。有时，一个更细粒度的锁（仅保护数据的一部分）可能比一个更粗粒度的锁（保护整个数据结构）表现更好。

## 最佳实践在行动

让我们看看一个代码示例，该示例展示了在并发环境中使用 STL 容器的最佳实践，重点关注性能优化技术，如最小化锁的作用域、选择合适的数据结构和考虑锁的粒度。

首先，我们将编写一个并发优化的容器，具体为 `ConcurrentVector`，旨在有效地处理多线程环境。这个自定义容器类，模板化以容纳任何类型的元素（`T`），封装了一个标准的 `std::vector` 用于数据存储，同时使用 `std::shared_mutex` 来管理并发访问（我们将此示例分成几个部分。对于完整的代码，请参阅书籍的 GitHub 仓库）：

```cpp
// A hypothetical concurrency-optimized container that uses
// fine-grained locking
template <typename T> class ConcurrentVector {
private:
  std::vector<T> data;
  mutable std::shared_mutex mutex;
public:
  // Inserts an element into the container with minimal
  // lock duration
  void insert(const T &value) {
    std::unique_lock<std::shared_mutex> lock(mutex);
    data.push_back(value);
  }
  // Finds an element with read access, demonstrating
  // shared locking
  bool find(const T &value) const {
    std::shared_lock<std::shared_mutex> lock(mutex);
    return std::find(data.begin(), data.end(), value) !=
           data.end();
  }
  // Size accessor that uses shared locking
  size_t size() const {
    std::shared_lock<std::shared_mutex> lock(mutex);
    return data.size();
  }
};
```

接下来，我们将编写 `performConcurrentOperations` 函数，该函数将演示我们的 `ConcurrentVector` 类在多线程环境中的实际应用。此函数接受 `ConcurrentVector<int>` 的引用，并使用 C++ 标准线程启动两个并行操作：

```cpp
void performConcurrentOperations(
    ConcurrentVector<int> &concurrentContainer) {
  // Multiple threads perform operations on the container
  std::thread writer([&concurrentContainer]() {
    for (int i = 0; i < 100; ++i) {
      concurrentContainer.insert(i);
    }
  });
  std::thread reader([&concurrentContainer]() {
    for (int i = 0; i < 100; ++i) {
      if (concurrentContainer.find(i)) {
        std::cerr << "Value " << i
                  << " found in the container\n";
      }
    }
  });
  // Join threads to ensure complete execution
  writer.join();
  reader.join();
  // Output the final size of the container
  std::cout << "Final size of the container:"
            << concurrentContainer.size() << "\n";
}
```

最后，我们编写 `main()` 来驱动程序：

```cpp
int main() {
  ConcurrentVector<int> concurrentContainer;
  performConcurrentOperations(concurrentContainer);
  return 0;
}
```

这里是示例输出：

```cpp
...
Value 98 found in the container.
Value 99 found in the container.
Final size of the container: 100
```

在前面的代码示例中，我们做了以下操作：

+   我们定义了一个 `ConcurrentVector` 模板类，它模拟了一个并发优化的容器，内部使用 `std::shared_mutex` 来实现读写操作的细粒度控制。

+   `insert` 方法使用一个独特的锁来确保在写操作期间具有独占访问权限，但锁仅保留在插入期间，最小化锁的作用域。

+   `find` 和 `size` 方法使用共享锁，允许并发读取，展示了使用共享锁来提高读取吞吐量的应用。

+   创建了一个写线程和一个读线程来对 `ConcurrentVector` 实例执行并发插入和搜索操作，展示了容器处理并发操作的能力。

此示例说明了优化并发性能的关键考虑因素，例如限制锁的持续时间、选择合适的并发友好型数据结构以及使用细粒度锁来保护数据的小部分。这些实践对于希望提高多线程应用程序性能的中级 C++ 开发者至关重要。

# 摘要

本章讨论了 STL 中线程安全和并发的复杂性。我们首先区分了并发和线程安全，强调虽然它们相关，但各自都服务于不同的目的。我们的旅程从对线程安全作为稳定并发支柱的基础理解开始，探讨了缺乏线程安全可能导致不可预测的软件行为。我们考察了这些概念之间的相互作用，讨论了在保持线程安全的情况下并发编程的挑战和回报。

我们研究了 STL 容器和算法的线程安全特性，分析了竞争条件以及预测和防范这些条件的技术。本章提供了关于各种 STL 容器在多线程场景下行为的详细见解，从`std::vector`到`std::list`，再到关联容器和无序容器。我们还揭示了容器适配器的并发方面，断言在编写并发应用程序时，知识就是力量。

我们已经配备了核心工具：`std::thread`、`std::async`、`std::future`和 TLS。有了这些，我们启动了线程，管理异步操作，并在线程之间保持数据一致性。这些能力使我们能够熟练地处理关于安全和性能的并发。

本章探讨了 STL 的原子类型和针对并发优化的容器，提供了在并发环境中最大化效率的技巧。这些见解对于使用 STL 开发高性能、线程安全的应用程序至关重要。

本章传授的知识至关重要，因为线程安全和高效的并发对于现代 C++开发者至关重要。随着多核和多线程应用程序成为常态，理解这些原则对于能够充分利用 STL 的全部功能至关重要。

在下一章中，我们将进一步深入探讨 STL 的高级用法。我们将介绍概念和强大的模板特性，允许在编译时进行更精确的类型检查。我们将学习如何细化 STL 算法中的约束，并有效地使用这些约束来增强具有显式要求的数据结构。此外，我们还将探索 STL 与协程的集成，评估与范围和视图的潜在协同作用，并为当代 C++编程中即将到来的范式转变做好准备。
