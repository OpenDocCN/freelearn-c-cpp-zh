

# 高级容器适配器使用

容器适配器，正如其名称所示，将底层容器适配以提供特定的接口和功能。可以将它们视为一种增强或修改现有容器的方法，使其服务于不同的目的，而无需重新发明轮子。它们围绕基容器，提供一组独特的成员函数，赋予它们在各种编程场景中可能有用的行为。

本章提供了以下容器的参考：

+   `std::stack`

+   `std::queue`

+   `std::priority_queue`

+   `std::flat_set`

+   `std::flat_map`

+   `std::flat_multiset`

+   `std::flat_multimap`

# 技术要求

本章的代码可以在 GitHub 上找到：

[`github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL`](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)

# std::stack

`std::stack`是一种表示栈的数据结构，它是一个`std::deque`、`std::vector`和`std::list`，提供了一个简单且易于使用的接口来处理栈。你可以将元素推送到栈顶，从栈顶弹出元素，并访问栈顶元素而无需访问其他位置的元素。`std::stack`通常用于需要类似栈的行为的任务，例如跟踪函数调用序列、解析表达式和管理临时数据。它提供了一种方便的方式来管理数据，以确保最近添加的元素是第一个被移除的。

## 目的和适用性

`std::stack`是一个容器适配器，旨在提供 LIFO 数据结构。它基于另一个容器操作，例如`std::vector`、`std::deque`或`std::list`。

它在以下场景中特别适用：

+   当需要 LIFO 行为时

+   当你只需要访问最近添加的元素时

+   当插入和删除仅发生在一边时

当你需要一个简单的接口来以 LIFO 方式管理数据时，请选择`std::stack`。对于更灵活的操作，请考虑其底层容器。

## 理想用例

以下是一些`std::stack`的理想用例：

+   **表达式评估和解析**：例如，评估后缀表达式

+   **回溯算法**：例如，在图中执行深度优先搜索

+   **撤销操作在软件中**：维护用户操作的历史记录以撤销它们

## 性能

由于`std::stack`是一个容器适配器，其算法性能取决于底层容器的实现：

+   **插入（****push）**：*O(1)*

+   **删除（****pop）**：*O(1)*

+   **访问（****top）**：*O(1)*

+   **内存开销**：直接与底层容器相关

## 内存管理

`std::stack`的行为与其底层容器类似。例如，如果底层是`std::vector`，则调整大小可能涉及重新分配，将其内存加倍。

## 线程安全

与大多数 STL 容器一样，`std::stack` 在写操作上不是线程安全的。对于并发写入或读写组合，需要外部同步。

## 扩展和变体

`std::queue` 和 `std::priority_queue` 是 STL 中的其他适配器，分别提供 **先进先出**（**FIFO**）行为和基于优先级的访问。

## 排序和搜索的复杂度

排序和搜索本身并不适合 `std::stack`。你可能需要将元素转移到不同的容器中进行排序或搜索。

## 特殊接口和成员函数

`std::stack` 设计为提供三个特殊成员函数：

+   `push`：将一个元素推入栈顶

+   `pop`：从栈顶移除（弹出）一个元素

+   `top`：获取栈顶元素的值，而不移除它

## 比较操作

与原始底层容器相比，`std::stack` 提供了一个针对 LIFO 操作定制的受限接口。

## 与算法的交互

由于缺乏迭代器支持，与 STL 算法的直接交互有限。对于算法操作，请直接考虑底层容器。

## 异常

在空栈上尝试操作，如 `pop` 或 `top`，不会抛出异常，但会导致未定义的行为。在执行此类操作之前，请确保栈不为空。

## 定制化

虽然 `std::stack` 的行为无法改变太多，但使用自定义分配器或选择特定的底层容器可以影响性能和存储特性。

## 示例

以下代码展示了使用 `std::stack` 的示例。此示例实现了一个函数来评估 **逆波兰表示法**（**RPN**），一种后缀数学表示法。使用栈是此类问题的自然选择：

```cpp
#include <iostream>
#include <sstream>
#include <stack>
#include <string>
double evaluateRPN(const std::string &expression) {
  std::stack<double> s;
  std::istringstream iss(expression);
  std::string token;
  while (iss >> token) {
    if (token == "+" || token == "-" || token == "*" ||
        token == "/") {
      if (s.size() < 2) {
        throw std::runtime_error("Invalid RPN expression");
      }
      double b = s.top();
      s.pop();
      double a = s.top();
      s.pop();
      if (token == "+") {
        s.push(a + b);
      } else if (token == "-") {
        s.push(a - b);
      } else if (token == "*") {
        s.push(a * b);
      } else if (token == "/") {
        if (b == 0.0) {
          throw std::runtime_error("Division by zero");
        }
        s.push(a / b);
      }
    } else {
      s.push(std::stod(token));
    }
  }
  if (s.size() != 1) {
    throw std::runtime_error("Invalid RPN expression");
  }
  return s.top();
}
int main() {
  try {
    // Evaluate RPN expressions
    std::cout << "46 2 + = " << evaluateRPN("46 2 +")
              << "\n"; // 48
    std::cout << "5 1 2 + 4 * + 3 - = "
              << evaluateRPN("5 1 2 + 4 * + 3 -")
              << "\n"; // 14
    std::cout << "3 4 5 * - = " << evaluateRPN("3 4 5 * -")
              << "\n"; // -17
  } catch (const std::exception &e) {
    std::cerr << "Error: " << e.what() << "\n";
  }
  return 0;
}
```

以下是一个示例输出：

```cpp
46 2 + = 48
5 1 2 + 4 * + 3 - = 14
3 4 5 * - = -17
```

在前面的例子中，发生以下情况：

+   我们使用 `std::stack` 来管理操作数并评估逆波兰表达式（RPN）。

+   操作数被推入栈中。当遇到运算符时，从栈中弹出必要的操作数（通常是两个）。然后执行操作。最后，将结果推回栈中。

+   如果表达式在评估结束时有效，栈中应该恰好有一个数字：结果。

+   函数处理可能出现的错误，例如无效的 RPN 表达式或除以零。

这是对 `std::stack` 的典型使用，因为它展示了数据结构的 LIFO（后进先出）特性和其基本操作（`push`、`pop` 和 `top`）。

## 最佳实践

让我们探讨使用 `std::stack` 的最佳实践：

+   **保持 LIFO 规律**：栈是为 LIFO 操作设计的。避免直接操作底层容器以访问除了栈顶元素之外的其他元素。绕过 LIFO 逻辑会损害使用栈的目的和完整性。

+   在执行`top()`或`pop()`操作之前，始终使用`empty()`函数验证栈是否为空。从空栈访问或弹出会导致未定义行为和潜在的运行时错误。

+   `std::stack`使用`std::deque`作为其容器，这通常提供高效的推入和弹出操作。虽然你可以使用容器如`std::vector`或`std::list`来自定义它，但请注意它们各自的性能和内存特性。例如，虽然`std::vector`可能会有偶尔的调整大小开销，但`std::list`具有每个元素的额外开销。

+   `std::stack`本身不保证线程安全性。如果你从多个线程访问或修改栈，请使用适当的同步机制，如`std::mutex`，以防止数据竞争并保持一致性。

+   `std::stack`接口限制你只能访问栈顶元素，底层容器可能不限制。直接使用底层容器可以提供更广泛的数据访问，但如果不小心，可能会引入错误。

+   使用`emplace`直接在栈内构建元素。这可以减少对临时对象的需求以及潜在的复制/移动操作，从而提高代码的效率和简洁性。

+   **异常安全性**：某些操作可能提供基本或强异常安全性，这取决于底层容器。了解这些保证是至关重要的，特别是如果你的应用程序需要一定级别的异常安全性。

+   `std::stack`不直接暴露容量或预留机制，底层容器（尤其是如果它是`std::vector`）可能具有这种行为。如果你对栈的增长模式有信心，请考虑使用适当的底层容器并管理其容量以进行优化。

+   `auto`，请明确了解你的栈的类型。这包括它持有的元素类型和底层容器。这种清晰度确保你始终了解栈的性能特性和限制。

+   `std::vector<bool>`，使用带有特定底层容器的`std::stack<bool>`可能会由于容器特殊化而产生意外的行为或不效率。如果你需要一个布尔值的栈，请考虑替代方案或充分了解特定容器对布尔类型的处理行为。

# `std::queue`

`std::queue` 表示一个 FIFO 数据结构。它作为适配器类实现，通常基于其他底层容器，如 `std::deque` 或 `std::list`。`std::queue` 提供了一个简单的接口来处理队列，允许您在队列末尾（push）插入元素，并从队列前端（pop）删除元素。它在 C++ 中常用，例如在需要按添加顺序处理数据的场景中，如任务调度、图的广度优先遍历或树，以及在多线程程序中管理工作项。`std::queue` 确保队列中最长的元素是第一个被删除的，这使得它成为管理有序数据处理的有用工具。

## 目的和适用性

`std::queue` 是一个容器适配器，它建立在另一个容器（如 `std::deque`、`std::list` 或 `std::vector`）之上。其主要目的是提供 FIFO 数据访问。

它特别适合以下场景：

+   当需要顺序访问时

+   当元素需要按插入顺序处理时

如果搜索、排序或随机访问是主要关注点，`std::queue` 可能不是最佳选择。

## 理想的使用场景

以下是一些 `std::queue` 的理想使用场景：

+   **任务调度**：按任务到达的顺序管理任务

+   **数据序列化**：确保数据按接收顺序处理

+   **树遍历**：图的广度优先遍历或树的遍历

## 性能

由于 `std::queue` 是一个容器适配器，其算法性能取决于底层容器的实现：

+   **插入（**push**）**：*O(1)*

+   **删除（**pop**）**：*O(1)*

+   **访问（前和后）**：*O(1)*

+   **内存开销**：取决于底层容器

性能特征主要来自基本容器，通常是 `std::deque`。

## 内存管理

它的内存行为取决于底层容器。例如，如果您正在使用 `std::deque`，它管理内存块并且可以在两端增长。

## 线程安全

读取和写入本身不是线程安全的。如果需要并发访问，则必须使用外部同步，例如互斥锁。

## 扩展和变体

`std::priority_queue` 是另一个适配器，它根据优先级而不是插入顺序提供对最高元素的访问。

## 排序和搜索复杂度

排序和搜索不适用于 `std::queue`。`std::queue` 是为 FIFO 访问设计的。排序或随机搜索需要手动遍历底层容器，这既不高效，也违背了队列的目的。

## 特殊接口和成员函数

它的主要操作包括 `push()`、`pop()`、`front()` 和 `back()`。`size()` 和 `empty()` 用于大小检查和空检查。

## 比较

与提供 LIFO 访问的 `std::stack` 相比，`std::queue` 确保了 FIFO 行为。如果需要随机访问，那么 `std::vector` 可能更合适。

## 与算法的交互

由于缺乏迭代器，与大多数 STL 算法的直接交互有限。如果需要算法操作，你通常会直接在底层容器上工作。

## 异常

抛出的异常取决于底层容器的操作。然而，从空队列中访问元素（使用 `front()` 或 `back()`）可能会导致未定义的行为。

## 定制化

通过选择适当的底层容器，并可能使用自定义分配器，可以定制内存管理。

## 示例

`std::queue` 的一个日常用例是实现 `std::queue`。以下是一个在无向图上使用邻接表表示的基本 BFS 实现示例：

```cpp
#include <iostream>
#include <queue>
#include <vector>
class Graph {
public:
  Graph(int vertices) : numVertices(vertices) {
    adjList.resize(vertices);
  }
  void addEdge(int v, int w) {
    adjList[v].push_back(w);
    adjList[w].push_back(v);
  }
  void BFS(int startVertex) {
    std::vector<bool> visited(numVertices, false);
    std::queue<int> q;
    visited[startVertex] = true;
    q.push(startVertex);
    while (!q.empty()) {
      int currentVertex = q.front();
      std::cout << currentVertex << " ";
      q.pop();
      for (int neighbor : adjList[currentVertex]) {
        if (!visited[neighbor]) {
          visited[neighbor] = true;
          q.push(neighbor);
        }
      }
    }
  }
private:
  int numVertices{0};
  std::vector<std::vector<int>> adjList;
};
int main() {
  Graph g(6);
  g.addEdge(0, 1);
  g.addEdge(0, 2);
  g.addEdge(1, 3);
  g.addEdge(1, 4);
  g.addEdge(2, 4);
  g.addEdge(3, 4);
  g.addEdge(3, 5);
  std::cout << "BFS starting from vertex 0: ";
  g.BFS(0); // Output: 0 1 2 3 4 5
  return 0;
}
```

这里是示例输出：

```cpp
BFS starting from vertex 0: 0 1 2 3 4 5
```

以下要点解释了代码：

+   `Graph` 类使用邻接表（`adjList`）来表示图。

+   BFS 遍历从给定的顶点开始，将其标记为已访问，然后探索其邻居。邻居被添加到队列中，并按它们遇到的顺序（FIFO 顺序）进行处理，确保广度优先遍历。

+   随着顶点的访问，它们在访问向量中被标记，以确保它们不会被多次处理。

+   BFS 函数使用 `std::queue` 的主要操作：`push` 将顶点添加到队列中，`front` 检查下一个要处理的顶点，`pop` 移除它。

## 最佳实践

让我们探索使用 `std::queue` 的最佳实践：

+   **保持 FIFO 纪律**：队列天生就是为了 FIFO 操作设计的。尝试将其用于其他目的，如随机访问或使用 LIFO 顺序的栈操作，可能会导致次优设计和复杂性。

+   `std::queue` 不直接暴露迭代器。如果你需要遍历元素，考虑队列是否适合你的需求，或者是否应该直接访问底层容器。

+   使用 `front()` 或 `back()` 时，始终使用 `empty()` 函数检查队列是否为空。这可以防止尝试访问空队列中的元素时可能出现的未定义行为。

+   `std::queue` 实际上是 `std::deque`，但你可以使用其他容器，例如 `std::list`。每个容器都有其特性、权衡和内存开销。例如，虽然 `std::list` 提供了高效的插入和删除操作，但其每个元素的内存开销比 `std::deque` 高。

+   使用 `std::mutex` 来避免数据竞争和不一致性。对 `std::queue` 本身的操作不是天生线程安全的。

+   `std::vector` 容器（尽管对于队列来说这很少见）。这在实时或性能关键的应用程序中可能会引起性能问题。

+   使用 `emplace` 在队列中直接构建元素。这可以导致更高效的代码，因为它避免了临时对象的创建。

+   `std::vector`，`std::queue` 没有与容量相关的成员函数。在没有明确知识或控制的情况下，不要对底层容器的大小或容量做出假设。

+   `std::deque`为其操作提供了强大的异常安全性，确保在异常期间数据不会被损坏。

+   **小心使用类型别名**：如果你正在使用类型别名或自动类型推导，确保你知道队列的确切类型，特别是如果你在同一代码库中处理不同底层容器的队列时。这确保你不会错误地假设不同容器类型的特性或性能权衡。

# `std::priority_queue`

## 目的和适用性

`std::priority_queue`是一个基于随机访问容器类型（主要是`std::vector`）构建的适配器容器。其核心优势围绕以下方面：

+   总是保持最高优先级元素在顶部

+   确保高效地插入和检索最高元素

它在以下场景中表现出色：

+   当需要基于优先级的访问时

+   当插入是随机的，但访问总是针对最高重要性的元素时

在顺序不是关键因素，或者插入顺序比访问优先级更重要的情况下，`std::priority_queue`可能不是最佳选择。

## 理想使用场景

以下是一些`std::priority_queue`的理想使用场景：

+   **工作调度**：根据紧急程度或优先级分配工作

+   **路径查找算法**：这类算法的一个例子是 Dijkstra 算法，其中首先处理具有最短试探距离的节点

+   **模拟系统**：对于应根据优先级而不是顺序处理的事件

## 性能

由于`std::priority_queue`是一个容器适配器，其算法性能取决于底层容器实现：

+   **插入**：*O(log n)*，因为元素根据其优先级放置在其合适的位置

+   **删除**：最高元素为*O(log n)*，因为队列在重新结构化自身

+   **访问**：最高元素为*O(1)*

+   **内存开销**：中等，取决于底层容器

注意，当使用`std::vector`作为底层容器时，在调整大小过程中可能会出现额外的内存开销。

## 内存管理

这本质上取决于底层容器。使用`std::vector`时，在达到容量时可能会发生内存重新分配。可以使用分配器进行定制。

## 线程安全

并发访问需要谨慎。多个读取是安全的，但同时读取或写入需要外部同步机制，例如互斥锁。

## 扩展和变体

如果你需要一个确保序列保持的容器，你可能会考虑`std::queue`。如果你需要一个具有键值对和固有排序的关联容器，`std::map`或`std::set`可能更合适。

## 排序和搜索复杂度

排序不适用于`std::priority_queue`。直接访问最高优先级元素进行搜索是*O(1)*。然而，搜索其他元素并不直接，也不是这个容器的主要目的。

## 特殊接口和成员函数

除了基本操作（`push`、`pop`、`top`）之外，探索以下内容：

+   `emplace`：直接在优先队列内构建一个元素

+   `size`：检索元素数量

+   `swap`：交换两个优先队列的内容

## 比较操作

与尊重 FIFO 排序的`std::queue`相比，`std::priority_queue`始终确保可以访问最高优先级元素。与允许有序访问所有元素的`std::set`相比，前者专注于优先级。

## 与算法的交互

由于缺乏迭代器，大多数 STL 算法不能直接与`std::priority_queue`交互。然而，它自然与关注最高优先级元素的用户定义算法相吻合，例如使用`push()`和`pop()`的算法。

## 异常

抛出异常可能发生在底层容器操作期间，例如内存分配。异常安全性通常与底层容器的异常安全性相一致。

## 自定义

这里有一些自定义选项：

+   **分配器**：使用自定义分配器自定义内存分配

+   **比较器**：使用自定义比较函数修改优先级逻辑，允许自定义*优先级*的定义

## 示例

`std::priority_queue`常用于需要根据其优先级处理元素的场景。使用`std::priority_queue`的最常见示例之一是实现加权图的 Dijkstra 最短路径算法。

以下代码展示了使用`std::priority_queue`实现 Dijkstra 算法的示例：

```cpp
#include <climits>
#include <iostream>
#include <list>
#include <queue>
#include <vector>
class WeightedGraph {
public:
  WeightedGraph(int vertices) : numVertices(vertices) {
    adjList.resize(vertices);
  }
  void addEdge(int u, int v, int weight) {
    adjList[u].push_back({v, weight});
    adjList[v].push_back({u, weight});
  }
  void dijkstra(int startVertex) {
    std::priority_queue<std::pair<int, int>,
                        std::vector<std::pair<int, int>>,
                        std::greater<std::pair<int, int>>>
        pq;
    std::vector<int> distances(numVertices, INT_MAX);
    pq.push({0, startVertex});
    distances[startVertex] = 0;
    while (!pq.empty()) {
      int currentVertex = pq.top().second;
      pq.pop();
      for (auto &neighbor : adjList[currentVertex]) {
        int vertex = neighbor.first;
        int weight = neighbor.second;
        if (distances[vertex] >
            distances[currentVertex] + weight) {
          distances[vertex] =
              distances[currentVertex] + weight;
          pq.push({distances[vertex], vertex});
        }
      }
    }
    std::cout << "Distances from vertex " << startVertex
              << ":\n";
    for (int i = 0; i < numVertices; ++i) {
      std::cout << i << " -> " << distances[i] << '\n';
    }
  }
private:
  int numVertices{0};
  std::vector<std::list<std::pair<int, int>>> adjList;
};
int main() {
  WeightedGraph g(5);
  g.addEdge(0, 1, 9);
  g.addEdge(0, 2, 6);
  g.addEdge(0, 3, 5);
  g.addEdge(1, 3, 2);
  g.addEdge(2, 4, 1);
  g.addEdge(3, 4, 2);
  g.dijkstra(0);
  return 0;
}
```

这里是示例输出：

```cpp
Distances from vertex 0:
0 -> 0
1 -> 7
2 -> 6
3 -> 5
4 -> 7
```

在此实现中发生以下情况：

+   `WeightedGraph`类使用邻接表来表示图，其中每个列表元素都是一个表示相邻顶点和边权重的对。

+   `dijkstra`函数计算图中的给定顶点到所有其他顶点的最短距离。

+   `std::priority_queue`用于选择具有已知最短距离的最小顶点进行处理。

+   基于当前处理的顶点和其邻居，更新到顶点的距离。

+   随着算法的进行，`priority_queue`确保顶点按其已知最短距离的递增顺序进行处理。

使用`std::priority_queue`为 Dijkstra 算法中始终处理具有已知最小距离的顶点提供了一种高效的方法。

## 最佳实践

让我们探讨使用`std::priority_queue`的最佳实践：

+   `std::priority_queue`用于高效访问最高优先级元素，而不是提供所有元素的有序访问。不要假设您可以按完全排序的顺序访问元素。

+   **自定义优先级规则**：如果默认的比较逻辑不符合您的需求，请始终提供自定义比较器。这确保队列根据您特定的优先级规则维护元素。

+   `std::priority_queue` 使用 `std::vector` 作为其底层容器。虽然这通常很合适，但切换到如 `std::deque` 或 `std::list` 这样的容器可能会影响性能。选择与你的具体要求相匹配的容器。

+   **检查是否为空**：在尝试访问顶部元素或执行弹出操作之前，始终验证队列不为空。这可以防止未定义的行为。

+   **避免底层容器操作**：直接操作底层容器可能会破坏优先队列的完整性。避免这样做以确保优先级顺序保持一致。

+   使用 `emplace` 方法而不是 `push`。这提供了更高效的就地构造，并且可以节省不必要的复制或移动。

+   `std::priority_queue` 本身不是线程安全的。如果你需要在多个线程中访问或修改它，请确保使用适当的同步机制。

+   **注意内部排序**：虽然将优先队列视为始终持有排序元素列表很诱人，但请记住，它仅确保最顶端的元素具有最高优先级。其他元素的内部顺序不保证排序。

+   `std::priority_queue` 不提供其元素的迭代器。这种设计有意让用户避免意外破坏队列的优先级不变性。

+   **大小考虑**：注意底层容器的尺寸和容量，尤其是当你处理大量数据集时。定期检查和管理容量可以帮助优化内存使用。

通过遵循这些最佳实践，你可以确保以高效且与其设计意图一致的方式使用 `std::priority_queue`。

# std::flat_set

`std::flat_set` 是一个排序的关联容器，旨在以排序顺序存储唯一元素的集合。与其他关联容器（如 `std::set`）相比，`std::flat_set` 的特点是它实现为一个扁平容器，通常基于排序的 `std::vector` 容器。这意味着元素在内存中连续存储，与传统的基于树的关联容器相比，具有最优的内存使用和更快的迭代时间。

`std::flat_set` 维护其元素在一个有序顺序中，允许进行高效的搜索、插入和删除操作，同时提供与其他 C++ STL 中类似容器（如集合）的功能和接口。它在需要排序存储和高效内存管理优势时特别有用。

## 目的和适用性

`std::flat_set` 是一个表示存储在排序扁平数组中的关联集合的容器。它结合了 `std::vector` 容器（如缓存友好性）和 `std::set` 容器（如有序存储）的优点。

在以下场景中使用 `std::flat_set`：

+   当你需要具有集合属性的有序数据时

+   当内存分配开销是一个关注点时

+   当你想利用与 `std::vector` 类似的缓存局部性优势时

如果你需要执行许多插入和删除操作，其他集合类型，如 `std::set`，可能更适合，因为它们的实现基于树。

## 理想使用场景

以下是一些 `std::flat_set` 的理想使用场景：

+   `std::flat_set` 容器和对其进行排序可以很高效

+   `std::flat_set` 容器对于较小的尺寸可以明显快于基于树的集合

+   `std::flat_set` 可以具有优势

## 性能

由于 `std::flat_set` 是一个容器适配器，其算法性能取决于底层容器的实现：

+   **插入**：*O(n)*，因为可能需要移动

+   **删除**：*O(n)*，原因相同

+   **访问**：使用二分搜索进行查找的 *O(log n)*

+   **内存开销**：由于内存分配较少，少于基于树的结构

代价是查找速度与插入和删除成本的权衡，尤其是在集合增长时。

## 内存管理

`std::flat_set` 使用一段连续的内存块（类似于 `std::vector`）。当这块内存耗尽时会发生重新分配。你可以使用自定义分配器来影响分配策略。

## 线程安全

与大多数 STL 容器一样，并发读取是安全的，但写入或混合操作需要外部同步。

## 扩展和变体

`std::flat_map` 是 `std::flat_set` 的一个近亲，它在一个扁平结构中存储键值对。它提供了类似的表现特性和用途。

## 排序和搜索复杂度

它的排序和搜索复杂度如下：

+   **排序**：固有的容器操作，通常为 *O(n log n)*

+   **搜索**：由于对排序数据进行二分搜索，*O(log n)*

## 特殊接口和成员函数

除了典型的集合函数（`insert`、`erase`、`find`）之外，请考虑以下内容：

+   `reserve`：为了预期插入操作而分配内存

+   `capacity`：返回当前的分配大小

## 比较操作

与 `std::set` 相比，`std::flat_set` 提供更好的缓存局部性，但在大型数据集中频繁的插入/删除操作中可能会变得低效。

## 与算法的交互

需要随机访问迭代器的 STL 算法，如 `std::sort()`，可以直接应用。然而，请记住 `std::flat_set` 维持其排序顺序，因此手动排序是多余的。

## 异常

错误使用迭代器或超出容量可能导致异常。许多操作提供了强大的异常安全性，确保容器的一致性。

## 定制化

`std::flat_set` 允许使用自定义分配器，从而实现精细的内存控制。你也可以提供自定义比较器以进行专门的排序。

## 最佳实践

让我们探讨使用 `std::flat_set` 的最佳实践：

+   `std::flat_set` 最适合于一旦构建就多次查询的用例。如果你的应用程序需要频繁的插入和删除，传统的基于树的 `std::set` 容器可能更合适。

+   `std::flat_set` 相比其他集合实现的优势在于其连续的内存布局，这使得它对缓存友好。这可以导致对于小数据集或数据可以放入缓存的情况，性能有显著提升。

+   如果需要合并 `std::flat_set` 容器，考虑首先将所有元素插入到一个容器中，然后排序并使整个集合唯一。这种方法通常比逐个元素合并排序集合更有效。

+   如果你有一个合理的元素插入数量估计，建议使用 `reserve` 方法。这可以最小化内存重新分配并提高性能。

+   `std::set` 容器，它是基于树的，可以更优雅地处理此类修改。

+   `std::flat_set` 维护其元素在一个排序顺序中，避免手动对容器进行排序至关重要。向 `std::flat_set` 容器中添加元素将根据提供的比较器保持它们的顺序。

+   `std::flat_set` 提供了如 `find` 等成员函数，用于高效搜索，它们针对其内部结构进行了优化。使用这些成员函数通常比应用泛型算法更有效。如果你需要使用算法，确保它们是为排序序列设计的，例如 `std::lower_bound` 或 `std::upper_bound`。

+   `std::flat_set` 的默认比较器是 `std::less`。然而，如果你的数据需要自定义排序逻辑，确保在集合构建时提供自定义比较器。记住，这个比较器应该提供严格的弱顺序以保持集合的性质。

+   `std::flat_set` 提供。如果你的用例有这种模式，评估其他容器可能更适合。

+   在 `std::flat_set` 容器中修改元素（例如，通过迭代器）而不确保顺序，可能会导致未定义的行为。始终确认修改后排序顺序保持不变。

+   `std::flat_set` 与经过优化的随机访问迭代器的算法配合良好。然而，对于修改顺序或内容的算法要小心，因为它们可能会违反集合的性质。

# std::flat_map

`std::flat_map` 是一个排序的关联容器，它结合了 map 和 flat 容器的特性。类似于 `std::map`，它允许你存储键值对，键是唯一的且有序的。然而，与通常作为平衡二叉搜索树实现的 `std::map` 不同，`std::flat_map` 是一个 flat 容器，通常基于一个排序的 `std::vector` 容器。这意味着 `std::flat_map` 提供了比传统的基于树的关联容器（如 `std::map`）更高效的内存使用和更快的迭代时间。`std::flat_map` 容器中的元素在内存中连续存储，这可能导致更好的缓存局部性和针对某些用例的性能提升。

`std::flat_map`提供了类似于`std::map`的功能和接口，允许你在保持元素排序顺序的同时执行插入、删除和搜索等操作。当你需要排序存储的优势和平坦容器的优势时，它是有益的。

## 目的和适用性

`std::flat_map`是一个将键和值配对的容器，作为关联数组使用。以下原因使其与其他映射容器区分开来：

+   它使用类似向量的结构，提供了缓存局部性的优势。

+   这种连续的内存布局在某些场景中促进了改进的查找时间。

它的利基市场在于以下场景：

+   当映射主要是在构建一次然后经常查询时

+   当迭代速度和缓存局部性比插入/删除速度更重要时

+   当排序的映射表示至关重要时

如果你预见初始化后频繁的修改，考虑使用`std::map`。

## 理想用例

以下是一些`std::flat_map`的理想用例：

+   **配置数据**：存储在启动时加载一次但在应用程序运行时频繁查询的配置键值对

+   **空间索引**：在图形或游戏开发中，快速迭代和检索比频繁修改更重要

+   **数据序列化**：对于需要排序和偶尔查找但不是经常修改的数据集

## 性能

+   **插入**：由于底层向量结构，为*O(n)*

+   **删除**：由于可能需要移动元素，为*O(n)*

+   **访问**：由于对排序数组进行二分搜索，为*O(log n)*

+   **内存开销**：通常，这很低，但如果预留容量未有效利用，则可能会增加

## 内存管理

`std::flat_map`，像`std::vector`一样，当其容量超过时可能会重新分配。如果你可以预测最终的大小，使用`reserve`是明智的。分配器可以提供对内存管理行为的控制。

## 线程安全

虽然并发读取是安全的，但写入或两者的组合需要外部同步——例如，使用互斥锁。

## 扩展和变体

对于无序关联容器，STL 提供了`std::unordered_map`。如果你更喜欢具有有序键的平衡树结构，那么`std::map`是你的首选。

## 排序和搜索复杂度

它的排序和搜索复杂度如下：

+   **排序**：由于其结构固有，它始终保持有序

+   **搜索**：由于二分搜索，为*O(log n)*

## 接口和成员函数

常见成员如`insert`、`find`和`erase`都存在。但是，你也应该探索以下珍宝：

+   `emplace`: 直接在原地构建元素

+   `lower_bound`和`upper_bound`：这些提供了有效的范围搜索

+   `at`: 通过键提供带边界检查的直接访问值

## 比较操作

`std::flat_map` 在迭代和查找性能方面表现出色，尤其是在较小的数据集上。然而，如果频繁的修改主导了您的用例，您可能会倾向于 `std::map`。

## 与算法的交互

由于其随机访问特性，`std::flat_map` 与在迭代器上茁壮成长的 STL 算法配合良好。然而，任何破坏键顺序的算法都应谨慎处理。

## 异常

超出容量或访问越界键可能会触发异常。许多操作提供了强大的异常安全性，在出现异常时保留映射状态。

## 定制化

`std::flat_map` 允许自定义分配器，您可以在构造时指定自定义比较器以指定键顺序。

## 最佳实践

让我们探索使用 `std::flat_map` 的最佳实践：

+   由于插入和删除的高成本，`std::flat_map` 适用于频繁的插入和删除。对于此类情况，请考虑替代方案，例如 `std::map`。

+   **关键修改**：不要直接使用迭代器修改键。这会破坏映射的排序顺序。如果需要修改键，请考虑删除旧键值对并插入一个新的，以确保顺序维护。

+   使用 `reserve()` 减少内存重新分配的频率，提高性能。

+   使用 `emplace` 在原地高效地构建键值对，最大化性能并避免不必要的临时对象创建。

+   在此类场景中，`std::map` 可能会提供更好的性能指标。

+   **并发**：确保在多线程访问期间线程安全。并发读取通常是安全的，但写入或混合读写操作需要外部同步，例如互斥锁。

+   `std::flat_map`。它提供了优越的缓存局部性和高效的查找，尤其是在映射主要在初始化后查询时。

+   `std::flat_map`，在操作可能破坏此顺序时要小心。在修改后始终验证顺序以确保容器的完整性。

+   使用 `lower_bound` 和 `upper_bound` 进行高效的基于范围的查询，利用容器的排序特性。

+   `std::less`) 在许多场景下适用，`std::flat_map` 允许在实例化期间指定自定义比较器，以根据特定需求定制键顺序。

# std::flat_multiset

`std::flat_multiset` 是在 C++ STL 中引入的容器，旨在按排序顺序存储元素。与通常作为红黑树实现的 `std::multiset` 不同，`std::flat_multiset` 将其元素存储在连续的内存块中，类似于 `std::vector` 容器。这种设计选择由于数据局部性而提供了改进的缓存性能，使其在容器在填充后不经常修改的情况下效率更高。

## 目的和适用性

`Std::flat_multiset` 是一个存储元素在排序数组中的容器，类似于 `std::flat_set`，但允许出现多个等效元素。

此容器提供以下功能：

+   由于其排序特性，具有高效的查找时间

+   改善了缓存局部性和内存使用的可预测性

它在以下场景中尤其适用：

+   当允许重复且需要排序访问时

+   当优先考虑缓存局部性时

+   初始化后，数据集的大小相对稳定

然而，当频繁的插入或删除成为常态时，其他容器可能更合适。

## 理想的使用场景

以下是一些 `std::flat_multiset` 的理想使用场景：

+   **历史记录**：按时间顺序存储重复事件，例如交易日志

+   **频率计数器**：当顺序和访问速度至关重要时，计算元素出现的次数

+   **排序缓冲区**：处理过程中的临时存储，其中顺序至关重要，且预期会有重复

## 性能

由于 `std::flat_multiset` 是一个容器适配器，其算法性能取决于底层容器的实现：

+   **插入**：由于维护顺序可能需要元素移动，所以是 *O(n)*

+   **删除**：由于可能需要移动以填充间隙，所以是 *O(n)*

+   **访问**：由于二分搜索，查找效率为 *O(log n)*

+   `std::vector`，但缺乏树结构最小化了内存开销

## 内存管理

`std::flat_multiset` 以块的形式管理内存。使用 `reserve()` 预分配内存可以防止频繁的重新分配。自定义分配器可以进一步修改分配行为。

## 线程安全

同时读取是安全的。然而，并发修改或同时读取和写入需要外部同步机制。

## 扩展和变体

虽然 `std::flat_multiset` 存储一个元素的多个实例，但 `std::flat_set` 是其唯一元素对应物。对于基于哈希的方法，你可能想看看 `std::unordered_multiset`。

## 排序和搜索的复杂度

它的排序和搜索复杂度如下：

+   `std::flat_multiset` 维护顺序

+   **搜索**：由于二分搜索，效率为 *O(log n)*

## 特殊接口和成员函数

`std::flat_multiset` 提供了与底层类型几乎相同的接口。以下是一些特别有用的函数：

+   `equal_range`：返回等效元素的区间

+   `count`：高效地计算元素出现的次数

+   `emplace`：直接在原地构造元素

## 比较操作

与 `std::multiset` 相比，`std::flat_multiset` 提供了更好的缓存局部性，但可能因频繁修改而受到影响。初始化后，它在读密集型场景中表现出色。

## 与算法的交互

由于是排序的，`std::flat_multiset` 与基于二分搜索的算法非常协调。然而，那些打乱或重新排序的算法可能并不理想。

## 异常

尝试访问越界或管理内存不当可能导致异常。通常，操作是异常安全的，确保容器保持一致性。

## 自定义

`std::flat_multiset` 支持自定义分配器，允许对内存分配进行微调。此外，自定义比较器可以调整排序行为。

## 最佳实践

让我们探讨使用 `std::flat_multiset` 的最佳实践：

+   `std::flat_multiset` 主要适用于初始化后集合大小稳定的场景。频繁的插入或删除会导致由于需要维护排序顺序而导致的效率低下，通常会导致元素移动。

+   `std::multiset`，`std::flat_multiset` 的迭代器在修改后可能会失效，尤其是那些改变容器大小的操作。在修改容器后，始终重新评估迭代器的有效性。

+   在 `std::flat_multiset` 容器中，使用 `reserve()` 在一开始就分配足够的内存。这可以防止重复和昂贵的重新分配。虽然为预期的增长预留空间很重要，但过度预留会导致不必要的内存消耗。在两者之间寻求平衡。

+   `std::flat_multiset` 比起 `std::flat_set` 更为合适。它保留了一个元素的所有实例，而后者只保留唯一条目。

+   `std::list` 或 `std::multiset` 可能会为这类操作提供更高的效率。

+   使用 `emplace()` 在集合内直接构造元素。这可以消除不必要的临时构造和复制，特别是对于复杂的数据类型。

+   `std::flat_multiset` 是安全的。写入操作，无论是插入、删除还是修改，在多线程环境中都需要同步，以确保数据完整性和防止数据竞争。

+   `std::flat_multiset` 与受益于排序数据集的 STL 算法配合良好，例如 `std::lower_bound` 或 `std::upper_bound`。然而，请记住，改变顺序或引入元素的算法可能会使这种固有的排序失效。

+   使用 `std::flat_multiset` 来控制其排序行为。

+   **异常安全性**：注意可能抛出异常的操作，例如内存分配失败。确保异常安全代码将防止数据不一致和潜在的内存泄漏。

# std::flat_multimap

`std::flat_multimap` 是一个结合了关联和序列容器特性的容器适配器。它存储键值对，类似于 `std::multimap`，但有一个显著的区别：元素存储在一个平坦的、连续的内存空间中，类似于 `std::vector` 容器。这种存储方法由于提高了数据局部性而增强了缓存性能，这对于读取密集型操作特别有益。

## 目的和适用性

`Std::flat_multimap` 是 STL 中的一个容器，针对快速关联查找进行了优化。其显著特点包括以下内容：

+   存储在类似 `std::vector` 的有序连续内存块中

+   允许存在具有相同键的多个键值对

它在以下场景中最为合适：

+   当需要缓存局部性和关联查找时

+   在初始化后数据集稳定时，因为它不是为频繁的插入或删除而优化的

当扁平存储和允许键重复的优势与你的使用场景相匹配时，选择`std::flat_multimap`而不是其他容器。

## 理想使用场景

以下是一些`std::flat_multimap`的理想使用场景：

+   **Web 浏览器历史记录**：存储带有时间戳的 URL。对于同一 URL（键）可以存在多个条目（时间戳）。

+   **词频计数器**：当文本中的单词可以有多个含义，并且你想要存储每个含义及其计数时。

+   **事件调度器**：用于维护在特定时间（键）发生的事件（值），其中可能在同一时间戳发生多个事件。

## 性能

由于`std::flat_multimap`是一个容器适配器，其算法性能取决于底层容器的实现：

+   **插入**：由于可能需要元素移动，为*O(n)*

+   **删除**：由于维护顺序，为*O(n)*

+   **访问**：由于在排序数组上进行二分搜索，为*O(log n)*

+   **内存开销**：相对较低，具有缓存局部性的优势

代价在于在查找更快的同时，插入和删除会变慢。

## 内存管理

`std::flat_multimap`管理内存的方式类似于`std::vector`。`reserve()`函数可以预测并分配增长所需的内存。自定义分配器可以进一步调整内存行为。

## 线程安全性

并发读取是安全的。然而，写入或混合读写需要同步机制，如互斥锁。

## 扩展和变体

对于不允许重复键的容器，有`std::flat_map`。对于未排序和分桶存储，你可能想考虑`std::unordered_multimap`。

## 排序和搜索复杂度

其排序和搜索复杂度如下所述：

+   **排序**：是容器固有的，由内部管理

+   **搜索**：由于二分搜索，为*O(log n)*

## 接口和成员函数

除了标准函数（`insert`、`erase`、`find`）之外，探索以下内容：

+   `equal_range`：返回匹配键的所有条目的界限

+   `emplace`：直接在映射内构建键值对

## 比较

与`std::multimap`相比，`std::flat_multimap`提供了更好的缓存局部性，但修改较慢。与`std::unordered_multimap`相比，它以更快的查找速度换取了固有的排序。

## 与算法的交互

由于其排序特性，`std::flat_multimap`与`std::lower_bound`和`std::upper_bound`等算法结合使用时很有益。然而，对于修改顺序或引入元素的算法要小心。

## 异常

键插入或查找不会抛出异常，但要注意内存分配失败，尤其是在插入期间，这可能导致异常。异常安全性是优先考虑的，许多操作提供了强有力的保证。

## 定制化

虽然允许使用自定义分配器，但 `std::flat_multimap` 依赖于其内部排序机制。因此，定义键顺序的自定义比较器是必不可少的。

## 最佳实践

让我们探讨使用 `std::flat_multimap` 的最佳实践：

+   当用例涉及连续或频繁的插入和删除时，使用 `std::flat_multimap`。由于容器的线性特性，此类操作可能成本高昂。

+   `std::flat_multimap` 只支持输入、输出、前向和双向迭代器。它不提供随机访问迭代器。

+   **键数据类型考虑**：对于键，优先选择简洁和轻量级的数据类型。使用大型自定义数据类型可能会加剧插入和删除时元素移动的成本。

+   利用 `std::flat_multimap` 的 `reserve()` 函数。预分配内存可以减轻昂贵的重新分配和复制。

+   使用 `emplace` 方法就地构建键值对。这比分别创建和插入条目更有效。

+   `std::multimap` 或 `std::unordered_multimap`。这些容器在类似场景下可能提供更好的性能。

+   `std::flat_multimap`。并发读取通常是安全的，但如果没有适当的同步，写操作可能导致竞争条件。

+   `std::flat_multimap` 保留其内部排序，以满足您的特定要求。

+   `std::flat_multimap`，可以使用二分搜索算法，如 `std::lower_bound` 和 `std::upper_bound`，来有效地执行范围查询或查找特定键的操作。

+   `std::flat_multimap` 提供强大的异常保证，确保即使操作抛出异常，容器也能保持一致性。

+   使用 `std::flat_multimap` 的成员函数，如 `equal_range`，来处理和加工与特定键相关联的所有条目。

+   使用 `std::flat_multimap` 的成员函数，如 `capacity()` 和 `size()`。如果未使用额外的预留空间，考虑使用 `shrink_to_fit()` 释放此内存。
