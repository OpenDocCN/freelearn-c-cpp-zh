

# C++不是内存安全的

*如果你仍然像 2000 年一样写 C++*

C++在安全性方面存在问题，内存可能是其中一部分。存在两种类型的内存问题：空间和时间。空间问题指的是访问超出边界的内存，而时间问题指的是在不确定或已释放的状态下访问内存。现代 C++试图通过避免使用裸指针以及使用**std::span**或概念来避免许多陷阱。尽管如此，我们仍需努力；在本章中，我们将展示当前的 C++机制仍然不完整，并探讨安全配置文件作为可能的未来改进。

在本章中，我们将涵盖以下主要主题：

+   内存安全很重要

+   较早版本的 C++的内存安全问题

+   现代 C++的拯救

+   现代 C++的局限性

+   还有更多的工作要做

# 技术要求

本章的代码可在 GitHub 上找到，地址为[`github.com/PacktPublishing/Debunking-CPP-Myths`](https://github.com/PacktPublishing/Debunking-CPP-Myths)，位于**ch6**文件夹中。测试函数使用了 doctest（[`github.com/doctest/doctest`](https://github.com/doctest/doctest)），它包含在代码中。

# 内存安全很重要

我们大多数生活在现代世界的人都期望事情能够正常工作。我们期望有电力、清洁的水和卫生设施，以至于它们已经淡入背景。我们没有注意到或考虑保持电力流动所需的工作；这只是预期的。

软件是这个舞台上的新来者。我想人们没有意识到软件在人们做的几乎所有事情中有多么重要，从支付到娱乐，从救命紧急服务到从一个地方到另一个地方。

然而，在现代世界的所有无处不在的服务中，软件是那个尽管有其好处，但真的可能让你的生活变得困难的。想想那些身份信息泄露和有时被盗的人，他们的钱被隔离，因为受到勒索软件影响而无法获得或延迟获得医疗援助的人。软件无处不在，软件必须做得更好。

然而，我们，程序员，似乎对这些问题视而不见。软件很复杂，我们告诉自己。用户经常因为自己的错误而受骗。没有没有错误的程序。是的，这是正确的。软件越来越复杂，越来越多的人在小部分上工作。用户没有像他们应该的那样小心。更糟糕的是，技术不断变化，以至于 6 个月前工作得很好的代码库可能现在不再工作。

但这并不能免除我们在过程中的责任。航空公司可能会说同样的话：飞机是复杂的机器；当然，它们可能会出现缺陷，偶尔会从天空中坠落。乘客不阅读或听不到紧急指示；让我们责怪他们。相反，航空系统是这样的，飞行的风险在多年中持续降低，成为最安全的旅行方式。

因为我们，程序员，对这些问题的忽视，所以我们中很少有人期待白宫就我们应使用的语言提出技术建议。2024 年 2 月 26 日发布的这份技术报告指出，软件行业有忽视安全问题的常见根本原因的历史，并且为了国家安全，应用程序应该用内存安全语言编写。内存安全语言的列表包括 Java、C#、Python 和 Rust，不包括 C 和 C++。你可以在以下链接中了解更多信息：[`www.whitehouse.gov/oncd/briefing-room/2024/02/26/press-release-technical-report/`](https://www.whitehouse.gov/oncd/briefing-room/2024/02/26/press-release-technical-report/)。

对这份报告的反应是惊讶、好笑和困惑的混合。然而，几个月后，2024 年 7 月 19 日，当大约一半的世界受到 CrowdStrike 产品系列中内存问题的困扰，导致全球 Windows 系统出现内核恐慌时，报告的重要性得到了重新确认。这一事件导致飞机停飞，紧急系统无法正常工作，支付系统离线，并对数百万人的生活造成了破坏。我相信这可能是有很多人第一次意识到软件有多么重要，这意味着他们可能会开始关注谈论软件的政客。

所以，是的，内存安全很重要。内存管理错误在最坏的情况下可能导致软件重启的微小不便，但在最坏的情况下可能导致黑客利用漏洞或整个系统需要手动干预。就像软件中的所有事情一样，对内存安全的需要是情境性的；与单人游戏相比，生命攸关的应用程序需要不同类型的关注。然而，我认为，无论你正在构建什么软件，关注这个问题都很重要。我相信程序员有责任编写不仅应该按预期工作，而且尽可能保护用户免受危险，有时甚至让他们感到愉快的代码。我们，程序员，需要记住，我们编写的代码是由人使用的，人是重要的。尽管这不是我们唯一的问题，但直面内存安全问题是一个很好的进步方式。

# 较早版本的 C++的内存安全问题

在我们继续讨论旧版和现代 C++中的内存安全问题之前，让我们先尝试定义它。引用白宫报告中的内容：“*内存安全问题是一类影响内存如何以非预期方式访问、写入、分配或释放的漏洞(...)内存安全问题分为两大类：空间和时间。空间内存安全问题源于超出内存中变量和对象“正确”边界进行的内存访问。时间内存安全问题出现在内存访问超出时间或状态时，例如在对象释放后访问对象数据，或者当内存访问意外交织时。”*

*要查看引用的来源，您可以点击以下链接查看文档的第 7 页：* [`www.whitehouse.gov/wp-content/uploads/2024/02/Final-ONCD-Technical-Report.pdf`](https://www.whitehouse.gov/wp-content/uploads/2024/02/Final-ONCD-Technical-Report.pdf) .

任何 C++程序员都应该熟悉这两种类型的问题。空间内存问题在 C++中的裸数组中最为常见。例如，尝试执行这个程序，它创建一个数组，向其中添加一些值，然后尝试在其分配的内存之外写入和读取元素：

```cpp
int doSomeWork(int value1, int value2, int value3, int value4) {
int array[3];
array[0] = value1;
array[1] = value2;
array[3] = value3;
array[4] = value4;
return array[0] + array[1] + array[3] + array[4];
}
```

上述代码令人惊讶的地方在于它是不确定的操作。也就是说，您的编译器可能会以不同的方式对读取或写入数组边界之外的操作做出反应，从忽略它到编译错误。此外，根据操作系统和上下文的不同，代码可能工作并覆盖未指定的内存块。

注意

对于攻击者来说，这类代码就像是金子。为什么？好吧，有一定几率这个过程会在某个时刻被放置在 RAM 中，紧挨着一个执行有价值操作的过程。如果攻击者能够向这个函数发送正确的值，并在恰好正确的时间捕捉到这个过程，他们可能能够覆盖检查您银行应用程序身份验证的代码，安装键盘记录器，或者向您的系统添加恶意软件。当然，这种攻击并不保证一定会成功，但黑客有足够的时间，因为这些事情都是自动化的。只需要成功一次。

我在我的电脑上测试了这段代码，运行的是 Ubuntu Linux 操作系统，使用**clang**和**g++**进行编译。**g++**编译器愉快地编译了程序，即使开启了所有警告也没有发出警告。与此同时，**clang**在编译时给出警告，指出数组越界访问。当我尝试运行程序时，我收到消息**"*** stack smashing detected ***: terminated"**。因此，我在运行时有一些保护措施，但代码仍然以未知可能的副作用运行。

然而，请注意，这是一个非常简单的例子。如果我在代码的某个地方创建一个数组，将其传递给各种函数，并根据一些复杂的公式计算索引，我敢打赌没有任何编译器能发现这个问题。因此，我们只能依靠测试和操作系统保护。

*这种问题是不是语言的错？* 很少人可能知道，但在内存安全列表上的编程语言中可以编写这种类型的代码。例如，C# 有不安全代码的概念，并且有指针。你可以标记代码的一部分为不安全，创建指针来访问数据，并使用指针运算，有一些限制。区别在于你需要做很多工作才能实现这一点，而且它仍然没有 C++那样的效果。此外，在 C#中，以类似方式处理内存的代码非常明显，因为它需要成为不安全块的一部分。**C++的问题并不在于可以这样做；问题在于默认情况下做这些事情非常容易** **。**

既然我们在谈论指针，让我们看看如何误用它们。以下代码使用一个**void***实例通过一些类型转换和指针运算访问**int***类型分配值之外的内存：

```cpp
int pointerBounds() {
    int *aPointerToInt;
    void *aPointerToVoid;
    aPointerToVoid = new int();
    aPointerToInt = (int*)aPointerToVoid;
    *aPointerToInt = 234;
    aPointerToInt = (int*)((char*)aPointerToVoid + sizeof(int));
    *aPointerToInt = 2423;
    int value = *aPointerToInt;
    delete aPointerToVoid;
    return value;
}
TEST_CASE("try pointer bounds"){
int result = pointerBounds();
CHECK_EQ(2423, result);
}
```

再次，我们遇到了一些未定义的行为：将值赋给由指针运算得到的指针由编译器来决定。这次，**g++**和**clang**都给了我警告，但只是关于删除 void 指针。两个编译器都没有任何问题，因为我试图在分配区域之外写入和读取。更有趣的是，测试运行得非常好，函数的结果是预期的，每个人都感到高兴！甚至操作系统也没有对这种胡闹表示不满——希望如此，因为我没有超出进程分配的内存。

希望如此。

我们到目前为止已经看到了空间内存安全问题的例子，情况并不乐观。那么时间内存安全问题又如何呢？

任何使用过指针的人都必须处理在不再需要它们之后需要记住做两件事的需求：释放分配的内存并将它们重置为**NULL**。这两件事都很重要，因为忘记其中之一会导致时间内存安全问题：一个悬垂指针仍然可以访问已被释放的内存区域，或者当指针没有被释放时，可能将指针重置，使得内存区域不再可访问。

以以下函数为例，它初始化一个指向**int**的指针并赋予一个值，释放内存，然后返回存储在内存中的值：

```cpp
int danglingPointer() {
    int *aPointerToInt = new int(234);
    delete aPointerToInt;
    return *aPointerToInt;
}
TEST_CASE("Try dangling pointer"){
int result = danglingPointer();
CHECK_EQ(234, result);
}
```

再次，程序编译良好。在**g++**或**clang**中没有警告。它也运行了，但测试失败，因为存储在那个地址的内存中的值不是预期的那个：

```cpp
test.cpp:8: ERROR: CHECK_EQ( 234, result ) is NOT correct!
  values: CHECK_EQ( 234, 721392248 )
```

那个地址存储的值在每次后续调用中都会改变，给我带来其他结果，如下所示：

```cpp
test.cpp:8: ERROR: CHECK_EQ( 234, result ) is NOT correct!
  values: CHECK_EQ( 234, 1757279720 )
test.cpp:8: ERROR: CHECK_EQ( 234, result ) is NOT correct!
  values: CHECK_EQ( 234, -1936531037 )
```

在代码的后续计算中使用这个值意外地容易，并返回一个奇怪的结果。如果你对所执行的计算有些了解，并且可以传递重复的输入，这也是找出内存区域内容的一种方法。

时间内存安全问题更严重，因为在大型代码库的迷宫中跟踪指针的生命周期比确保我们不会超出其界限要困难得多。所以，是的——不幸的是，内存问题在 C++中可能是一个大问题。

然而，你会发现，所有之前的例子都采用了旧的 C++风格。我们使用了裸数组、裸指针和指针算术。这些都是你应该在现代 C++中非常谨慎使用的结构，原因就在于此。我无法说永远不要使用它们，因为有些特定情况下我们需要裸指针和裸数组，但如今，它们通常限于内存优化或底层编程。即使在这些情况下，你通常也可以在不安全的部分和现代 C++之间引入一个清晰的边界。

那么，现代 C++解决了所有这些问题吗？

# 现代 C++的拯救

让我们回顾一下前面的例子，但用现代 C++中推荐的 STL 等效项替换裸数组和裸指针。

首先，数组边界示例。我们只需将裸数组替换为**vector<int>**实例，就得到以下函数：

```cpp
int doSomeWork(int value1, int value2, int value3, int value4) {
vector<int> values;
values[0] = value1;
values[1] = value2;
values[3] = value3;
values[4] = value4;
return values[0] + values[1] + values[3] + values[4];
}
TEST_CASE("try vector bounds"){
int result = doSomeWork(1, 234, 543, 23423);
CHECK_EQ(1 + 234 + 543 + 23423, result);
}
```

不幸的是，运行此示例的结果并不理想。既没有**g++**也没有**clang**抱怨，当运行测试时，我们得到以下结果：

```cpp
TEST CASE:  try vector bounds
test.cpp:5: FATAL ERROR: test case CRASHED: SIGSEGV - Segmentation violation signal
```

**std::vector<>**不安全吗？嗯，我们仍然需要关注为其分配的空间。我们有几种选择：正确初始化它，使用提供的方法向集合中添加元素，或者请求为特定数量的项目保留内存。前两种是我通常会使用的，因为它们不太可能导致问题。但即使是第三种选择也会导致通过测试：

```cpp
int doSomeWork(int value1, int value2, int value3, int value4) {
vector<int> values;
values.reserve(5);
values[0] = value1;
values[1] = value2;
values[3] = value3;
values[4] = value4;
return values[0] + values[1] + values[3] + values[4];
}
```

一个令人愉快的惊喜是**std::vector**在 reserve 之后的行为，至少在**g++**上是这样。我尝试访问**values[2]**，在这个例子中没有设置，我得到了值 0。这比访问之前存储在该内存块中的值要好得多，我想这可能是**std::vector**使用的默认分配器的特性。这种差异是由于**operator[]**的未定义行为，可以通过使用**vector::at()**方法来避免。尽管如此，我们还是做了一些工作。所以，即使是在现代 STL 中，我们仍然可以编写可能导致内存问题的代码。当然，如果我们停止胡闹，并使用其中一种简单的方法，这个问题就会完全消失。如果我们使用初始化器语法，向量将基于传入的数据创建，而无需我们进行任何额外的计数：

```cpp
int doSomeWork(int value1, int value2, int value3, int value4) {
vector<int> values{value1, value2, 0, value3, value4};
return values[0] + values[1] + values[3] + values[4];
}
```

当然，这种语法让我们将所有元素添加到向量中，而不是其中的一些，从而防止了偏移 1 的错误。另一种选择是逐个添加元素：

```cpp
int doSomeWork(int value1, int value2, int value3, int value4) {
vector<int> values;
values.push_back(value1);
values.push_back(value2);
values.push_back(0);
values.push_back(value3);
values.push_back(value4);
return values[0] + values[1] + values[3] + values[4];
}
```

如预期的那样，这个版本也工作得很好。教训：使用无聊的结构，你将 99%的时间得到预期的行为。这是一条适用于任何编程语言的很好的座右铭，但在 C++中尤为重要。

让我们再次看看使用指针算术和**void***访问超出范围的内存的例子。它看起来是这样的：

```cpp
int pointerBounds() {
int *aPointerToInt;
void *aPointerToVoid;
aPointerToVoid = new int();
aPointerToInt = (int*)aPointerToVoid;
*aPointerToInt = 234;
aPointerToInt = (int*)((char*)aPointerToVoid + sizeof(int));
*aPointerToInt = 2423;
int value = *aPointerToInt;
delete aPointerToVoid;
return value;
}
```

我已经尽力将这段代码转换为使用**std::unique_ptr**或**std::shared_ptr**，我相信这是可能的，但过程极其复杂。第一个问题是处理我们使用的所有指针转换。没有简单的方法可以将**std::unique_ptr<int>**转换为**std::unique_ptr<char>**；唯一的方法是转换值并获取一个新的**unique_ptr<>**实例。

第二个问题是**void***没有直接转换为**std::shared_ptr<void>**的方法；你可以使用它，但只能通过手动分配内存并传递一个自定义的**删除器**函数。因此，虽然使用现代 STL 可以编写类似这样的代码，但这需要大量的工作，程序员除非有非常具体的需求，否则会坚持使用安全的方法。

在悬挂指针的例子中，我们遇到了相同的情况：

```cpp
int danglingPointer() {
    int *aPointerToInt = new int(234);
    delete aPointerToInt;
    return *aPointerToInt;
}
```

没有一种直接的方法可以删除智能指针并返回其值。我们可以通过调用**unique_ptr::reset**来重新分配，但这会再次使用指针。将纯智能指针转换为以下形式的转换看起来如下：

```cpp
int danglingPointer() {
    unique_ptr<int> aPointerToInt = make_unique<int>(234);
    return *aPointerToInt;
}
```

只有这样做才能完全符合预期：值被正确返回，内存被释放。默认情况下没有悬挂指针！

如果我们手动分配并传递一个对**std::unique_ptr<>**不执行任何操作的删除器，我们就可以将其变成一个悬挂指针。在大多数情况下，没有必要这样做，因此我预计大多数程序员会完全避免这个问题。如果需要多个所有者来管理内存块，你可以选择使用**std::shared_ptr<>**，这样你最常见的场景就得到了解决。

从所有这些可以得出结论，现代 C++的安全性很高，默认情况下减少了大量潜在的问题。但仍然有其局限性，这是我们接下来要关注的。

# 现代 C++的局限性

假设我们只使用 STL 集合，避免使用指针，当真正需要时，我们使用标准库中实现的智能指针，并且编写类型时考虑到内存安全性。我们就完成了吗？

Herb Sutter，C++ 标准化委员会的知名成员之一，在 2024 年 3 月 11 日发表的一篇名为 *C++ 安全性，在上下文中*（[`herbsutter.com/2024/03/11/safety-in-context/`](https://herbsutter.com/2024/03/11/safety-in-context/)）的博客文章中，探讨了这个问题以及避免 C++ 中安全问题的更一般性问题。他的结论是，编写默认具有安全性和安全漏洞的 C++ 代码太容易了。文章确定了需要更多关注的四个领域：类型、边界、初始化和生命周期。然后，他指出 C++ 20 中已经有一些机制：**span**、**string_view** 概念和边界感知范围。正如文章接下来讨论的，语言中缺少的是默认启用但程序员可以在需要时关闭的安全规则。

让我们解开所有这些信息，并给出一些示例。

列表中的第一项，C++20 中引入的新 **std::span**。它表示从裸数组、**std::array**、具有大小的指针（**std::vector**）或 **std::string** 中提取的连续对象序列。它的一个重大优势是它自动推断序列的大小，从而消除了常见的 off-by-1 错误。因此，我们现在有一种安全地将集合的子集传递给函数的方法，而不用担心会搞乱序列长度。此外，它还允许我们完全禁止指针算术，并使用 **std::span** 代替。

第二，**string_view**。一个 **std::string_view** 实例允许我们对字符串有一个只读视图，从而消除了另一个潜在的安全问题，即字符串在不应该修改的地方被修改，或者对字符串进行可能导致不安全的操作。

第三，概念。概念允许 C++ 程序员在泛型函数和类上定义约束，从而增强类型的安全性。例如，可以要求传递给泛型函数的值具有同时具有加法和减法方法的数据类型。概念仍在开发中，C++ 26 将带来改进，但它们已经帮助解决了许多潜在的安全问题。

第四，边界感知范围。**ranges** 库允许 C++ 程序员编写高效的函数式编程灵感驱动的操作，这些操作适用于集合，从而消除了另一个潜在误用的来源。范围知道它们的边界，并保护开发者免于在每次函数调用时传递开始和结束迭代器。

如果使用这些改进，它们已经从 C++ 98 走得很远了。然而，还有一些东西是缺失的。还记得访问未预留任何内存的 **std::vector** 中的索引并导致运行时出现内存错误的代码吗？让我们看看：

```cpp
int doSomeWork(int value1, int value2, int value3, int value4) {
    vector<int> values;
    values[0] = value1;
    values[1] = value2;
    values[3] = value3;
    values[4] = value4;
    return values[0] + values[1] + values[3] + values[4];
}
```

这段代码的问题在于，我们可以在不初始化索引 2 的情况下，愉快地访问分配的向量大小之外的索引。解决这个问题的一个可能方案如下：

+   启用 **safemode** 编译器标志

+   编译器在每次索引访问时都会生成一个范围检查，以验证**0 <= index <** **collection.size()**

+   在尝试调用此代码时我们没有在运行时得到错误，因为没有发生任何操作

这样的编译选项可以在不改变现有代码的情况下启用，并防止未知的问题。当然，一些程序员可能会因为可能降低性能而对此有意见。这正是为什么这样的选项应该通过编译器标志来启用，或者，更好的是，默认启用，但可以通过编译器标志来关闭。

这表明还有更多的工作要做来使 C++内存安全。

# 还有更多的工作要做

标准化委员会目前正在制定一个名为**安全配置文件**的提案，该提案允许采用一种结合编译增强、静态分析和分析工具的综合方法来消除大部分这些安全问题。完成时间尚不明确，我个人对他们的工作并不羡慕。目前使用的 C++代码有数百万甚至数十亿行，任何提案都需要对现有代码的影响降到最低，除了指出潜在的安全问题。同时，考虑到许多现有应用程序的重要性，它还必须尽可能少地影响性能。

另一方面，紧迫性是显而易见的。C++在内存安全方面存在问题，它可能会被列入美国政府项目的黑名单，以及其他政府也是如此。只有时间才能告诉我们问题何时得到解决以及它如何影响语言的使用。

# 摘要

在本章中，我们已经看到在 C++中默认编写不安全代码是多么容易。尽管后续标准引入了改进，包括 STL 集合和智能指针，但程序员仍然有可能犯下代价巨大的错误。当然，有方法可以捕捉这些错误：自动开发者测试、探索性测试、渗透测试等等。但语言默认设置很重要，而 C++的默认设置仍然是不安全的。

在审查这些问题之后，我唯一的选择是得出结论，C++默认情况下仍然是不安全的，编写内存安全的代码需要持续的关注和适当的工具。希望很快就会出现在标准中的安全配置文件可能会缓解许多问题，但世界上仍然有大量的 C++代码像 2000 年一样编写，所以这是一个混合的局面。

在下一章中，我们将探讨 C++中的并行性和并发状态。
