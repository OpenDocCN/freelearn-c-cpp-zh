# 1

# C++ 非常难学

*如果你想要发挥其全部力量*

C++ 的难点及其掌握方法

在本章中，我们将涵盖以下主要主题：

+   为什么 C++ 被认为很难学？

+   C++ 的难点及其掌握方法

+   斯特劳斯特拉斯学习 C++ 的方法

+   学习 C++ 的测试驱动方法

+   权力越大……

# 技术要求

本章中的代码示例可以在 GitHub 仓库 [`github.com/PacktPublishing/Debunking-CPP-Myths`](https://github.com/PacktPublishing/Debunking-CPP-Myths) 的 **ch1** 文件夹中找到。代码使用 **doctest**（[`github.com/doctest/doctest`](https://github.com/doctest/doctest)）作为测试库，**g++** 和 **make** 进行编译，并针对 C++ 20。你还需要 **valgrind**（[`valgrind.org/`](https://valgrind.org/)）来检查内存泄漏。

# 为什么 C++ 被认为很难学？

C++ 的早期被视为 C 的扩展，仅使用新的范式，**面向对象编程**（**OOP**），因此承诺解决不断增长的代码库中的许多问题。这个初始版本的 C++ 非常严格；你，程序员，必须深入理解内存分配和释放的工作原理以及指针算术的工作原理，同时要防范你可能会错过的一系列细微差别，这些差别通常会导致无用的错误信息。当时程序员普遍的文化氛围是，真正的程序员必须了解 CPU、RAM、各种汇编语言、操作系统的工作原理和编译器。标准化委员会几十年来几乎什么也没做来减少这种错误的可能性，这也不无帮助。难怪这种语言的声誉在几乎 40 年后仍然伴随着它。我学习它的经验仅有助于理解当时学习这种语言的困难。

在 20 世纪 90 年代，我在理工学院学习期间第一次接触到了 C++。它既让我着迷又让我困惑。我理解了这种语言的力量，尽管它正在与我作对——或者至少我是这样认为的。我必须努力编写出能工作的代码。我还不熟悉 STL，那时它还没有成为标准的一部分，所以我的大多数第一个 C++程序都涉及指针的使用。C++考试中常见的问题之一就是区分指针数组与数组指针。我只能想象这种语言的复杂性对于构建考试问题是多么有帮助！

为记录在案，请参阅以下指针到数组和指针数组之间的区别，这是 C++考试中常见的问题：

**int(*pointerToArrayOf10Numbers)[10];**

**int *arrayOfTenPointers[10]**

我通过实践和在网上知识对每个人开放之前能找到的书籍继续学习 C++。但对我对这种语言理解的最大的飞跃是在 2000 年左右的一个项目。项目负责人，一位非常技术性的比利时人，为我们设定了非常明确的指导方针和必须遵循的过程，以获得最佳的 C++代码。这种对卓越的需求并不仅仅来自他的愿望，而是来自项目的需求：我们在多年前就构建了一个 NoSQL 数据库引擎，而那时它们还没有被赋予这个标签。

对于这个项目，我必须学习和了解 Scott Meyers 的两本关于 C++的奠基性书籍《Effective C++》和《More Effective C++》中的所有规则。这两本书总共记录了 90 条针对 C++程序员的指南，从资源初始化和释放的问题到提高性能、继承、异常处理等细节。这也是我开始大量使用 STL 的时候，尽管与今天相比，标准库的范围要小得多。

这项新获得的知识使我的 C++程序更加可靠，并提高了我的工作效率。一个重要的贡献因素是我们与两本书的智慧相结合所采用的过程。我们编写了单元测试，进行了设计和代码审查，并精心编写我们的代码，因为我们知道在代码库接受之前，它将被同事剖析。这使得我们的代码几乎无错误，并帮助我们以合理的时间实现了高性能的复杂功能。

然而，这种语言仍在与我们作对。我们知道如何编写好的 C++代码，但这需要一种注意力和关怀，这不可避免地会减慢我们的速度。仅仅掌握 C++是不够的；这种语言必须有所回报。

在这个项目之后，我离开了 C++的世界，学习了 C#和托管 C++、Java、PHP、Python、Haskell、JavaScript 和 Groovy，仅限于那些我用于专业编程的语言。虽然每种编程语言都比 C++提供了更高的抽象层次和更少的烦恼，但我仍然怀念我的编程成长岁月。我知道 C++以及内存管理的所有复杂性，这让我对这些其他语言的内部运作有了深刻的理解，使我能够充分利用它们。Haskell 对我来说非常熟悉，因为它与我从 Andrei Alexandrescu 的奠基性著作《现代 C++设计》中学到的元编程技术密切相关。C++在我的脑海中不仅是我使用的第一个专业编程语言，而且也是我自那以后使用的每种其他语言的基础。

让我高兴的是，大约在 2010 年，消息传来，C++标准化委员会终于开始对语言进行大胆和频繁的改革。上一个 C++标准已经多年是 C++ 98；突然我们每三年就看到一个新版本。这种标准的滚动发布使得函数式编程范式、范围、新的并行和异步编程原语、移动语义的引入成为可能。但对于今天想要学习 C++的人来说，最大的变化是内存管理的简化以及**auto**类型的引入。这些变化带来的重大突破是，Java 或 C#程序员可以理解现代 C++程序，这是我们当初 Java 和 C#开始时不确定的。

这意味着与 90 年代相比，现在的语言学习要容易得多。这个变化的例子就是关于数组与指针或指针与数组之间区别的旧考试问题已经完全无关紧要；裸数组可以轻易地被**vector<>**或**list<>**所替代，而指针则被更精确的**shared_pointer<>**或**unique_pointer<>**所取代。这反过来又减少了与指针的分配和释放相关的担忧，从而既清理了代码，又减少了在 C++ 98 中普遍存在的难以理解的错误信息的可能性。

然而，我们无法说 C++语言像今天其他主流语言一样容易学习。让我们看看原因是什么。

# C++的难点及其掌握方法

C++像 Java、C#、PHP、JavaScript 或 Python 一样容易学习吗？尽管语言有所改进，但答案可能是：很可能不是。重要的是：C++是否应该像所有这些其他语言一样容易学习？

C++的消亡已经被预测了很长时间。Java、然后是 C#，如今是 Rust，它们依次被吹捧为我们的尊贵辩论主题的完全替代品。然而，每个语言似乎都在开辟自己的领域，而 C++仍然在需要仔细优化的程序或工作在受限环境中的程序中处于领先地位。今天，数百万行 C++代码存在，其中一些已经存在了几十年。虽然其中一些可以被转换为云原生、无服务器或微服务架构，但总会有更适合由 C++提供的工程风格解决的问题。

因此，我们得出结论，C++在开发世界中有着自己的目的，任何新的编程语言都面临着一场艰难的挑战，以取代它。这一观察带来了其后果：C++的某些特定部分将必然比其他语言更难以掌握。虽然 Java 或 C#可以让你免于思考内存分配以及当将参数传递给另一个方法时内存会发生什么，但 C++需要直面这些问题，并允许你根据上下文优化你的代码。

因此，如果你想理解 C++，你无法逃避内存管理。幸运的是，这已经不像以前那样成为一个大问题。

让我们通过观察不同语言如何管理内存分配和释放来分析差异。Java 使用完全的**面向对象**（**OO**）方法，其中每个值都是一个对象。C#的设计者决定使用包括典型数值、字符、结构体和枚举在内的值类型，以及与对象相对应的引用类型。在 Python 中，每个值都是一个对象，类型可以在程序中稍后确定。所有这些三种语言都具备垃圾回收器来处理内存释放。Python 语言除了垃圾回收器外，还使用引用计数机制，因此可以可选地禁用它。

C++ 98 标准没有提供任何内置的指针释放机制，而是将内存管理的全部权力和责任交给了程序员。不幸的是，这导致了问题。假设你初始化了一个指针并为一个值分配了一个大内存区域。然后你将这个指针传递给其他方法。谁负责释放内存？

例如，看看以下简单的代码示例：

```cpp
BigDataStructure* pData = new pData();
call1(pData);
call2(pData);
call3(pData);
```

调用者是否应该释放**pData**分配的内存？是**call3**来做吗？如果**call3**调用另一个具有相同**pData**实例的函数会发生什么？谁负责释放它？如果**call2**失败会发生什么？

内存释放的责任是不明确的，因此需要为每个函数或每个作用域指定，更准确地说。随着程序和数据流复杂性的增加，这个问题变得更加复杂。这会让大多数使用其他主流语言的程序员感到困惑，或者完全忽略责任，最终导致内存泄漏或调用已释放的内存区域。

Java、C# 和 Python 在不要求程序员小心的情况下解决了所有这些问题。两种技术是有帮助的：引用计数和垃圾回收。引用计数的工作原理如下：每次调用复制值时，引用计数都会增加。当超出作用域时，引用计数会减少。当引用计数达到 0 时，释放内存。垃圾回收器的工作原理类似，只是它们定期运行，并检查循环引用，确保即使复杂的内存结构也能正确释放，尽管可能会有延迟。

即使在 2000 年代，我们也没有阻止在 C++ 中实现引用计数。这种设计模式被称为智能指针，它允许我们不必过多考虑这些问题。

事实上，C++ 从一开始就还有一种更优雅的方式来处理这个问题：引用传递。有很好的理由说明为什么引用传递是 Java、C# 和 Python 中传递对象的默认方式：它非常自然和方便。它允许你创建一个对象，分配其内存，通过引用传递，最好的部分是：它的内存将在退出作用域时自动释放。让我们看看一个与使用指针类似的例子：

```cpp
BigDataStructure data{};
call1(data);
call2(data);
call3(data);
...
void call1(BigDataStructure& data){
    ...
}
```

这次，**call1** 中发生的事情并不重要；数据初始化的作用域退出后，内存将被正确释放。引用类型的唯一限制是，为变量分配的内存不能被重新分配。就我个人而言，我认为这是一个很大的优点，因为修改数据可能会很快变得混乱；事实上，如果可能的话，我更喜欢用 **const&** 来传递每个值。然而，对于通过内存重新分配启用的高度优化的多态数据结构，其应用是有限的。

看看前面的程序，如果我们忽略 **call1** 中的 **&** 符号，并将函数重命名以符合相应的约定，我们也可以读懂 Java 或 C#。所以，C++ 本可以从一开始就接近这些语言。为什么它现在还不够相似呢？

好吧，在 C++ 中你无法逃避内存管理。前面的代码对 Java 或 C# 程序员来说并不会引起更多的思考；我们已经确定 C++ 是不同的。标准化委员会意识到，在某些情况下，我们需要在一个函数中分配内存，在另一个函数中释放它，并且避免使用指针来做这件事将是理想的。于是，引入了移动语义。

注意

移动语义是 C++11 中引入的一个关键特性，通过消除不必要的对象复制来提高性能。它允许资源从一个对象转移到另一个对象，而不创建副本，这对于管理动态内存、文件句柄或其他资源的对象特别有益。要利用移动语义，你需要实现一个移动构造函数，它通过从**rvalue**（临时对象）将资源转移到新对象来初始化新对象，以及一个移动赋值运算符，它将资源从 rvalue 转移到你的类中的现有对象。**std::move**函数是一个工具，它将对象转换为 rvalue 引用，从而启用移动语义。为了帮助，编译器在特定条件下创建移动构造函数。

在以下示例中，我们可以看到如何使用移动语义将变量的作用域移动到函数 process 中：

```cpp
BigDataStructure data{};
process(data);
...
void process(BigDataStructure&& data){
}
```

除了使用两个井号符号之外，似乎没有太多不同。然而，行为却非常不同。**data**变量的作用域移动到被调用的函数中，以及**process**，内存将在退出时释放。

移动语义允许我们避免复制大数据值，并将释放内存的责任转移到被调用的函数中。这是我们迄今为止讨论的语言中独特的机制。据我所知，唯一其他实现这些机制的编程语言是系统编程的其他竞争者：Rust 和 Swift。

这证明了，尽管 C++现在与 Java 或 C#相似，但它确实要求程序员更详细地了解内存分配和释放的方式。我们可能已经克服了关注微小语法差异但影响很大的考试问题，但我们还没有克服学习比其他语言更多的需求。

尽管内存管理是讨论的大问题的一部分，但它并不是使学习 C++变得更困难唯一的原因。一些事情是不同的，对于新手来说可能有点烦人：

+   需要**#ifndef**预处理器指令或非标准的但通常支持的**#pragma once**来确保文件只包含一次

+   将**.h**文件与任意规则分开，规定什么应该放在**.h**中，什么应该放在**.cpp**中

+   使用**virtual methodName()=0**定义接口的非常奇怪的方式

虽然我们可以通过现代 IDE 自动应用规则和指南来确保我们使用所有这些装置，但它们的出现引发了一个问题：为什么它们仍然需要？

除了上述内容，更难以接受的是，没有简单的方法来构建程序并添加外部引用。尽管 Java 存在许多缺陷，但它有一个单一的编译器，以及 Maven/Gradle 作为标准工具，用于依赖关系管理，允许通过简单的命令下载和集成新的库。C#虽然长时间存在相同的问题，但已经基本标准化了社区创建的 NuGet 命令，用于获取外部库。Python 具有标准的**pip**命令，用于管理包。

使用 C++，你需要做更多的工作。与依赖于虚拟机的 Java 和 C#不同，你的 C++程序需要为每个支持的目标进行编译，并且每个目标都需要匹配正确的库。当然，有相应的工具。我听说最多的两个包管理器是 Conan 和**vcpkg**。对于构建系统，CMake 似乎相当受欢迎。问题是，这些工具都不是标准的。虽然 Java 的 Maven/Gradle 和 C#的 NuGet 都不是从标准开始的，但它们的工具集成和快速采用意味着它们现在是事实上的标准。C++还需要一段时间才能使这个语言部分成熟。我们将在单独的章节中更多地讨论这些问题，但很明显，C++的困惑部分也是由尝试简单程序时的这种复杂性产生的。

我们比较了 C++与其他语言的各种复杂性，并看到虽然语言变得更容易，但它仍然不像 Java 或 C#那样容易。但核心问题是：C++是否很难学？为了检验这一点，让我们看看初学者可以用来学习 C++的三种方法。

# 斯特劳斯特普学习 C++的方法

虽然 C++标准已经向简单化发展，但许多学习材料仍然保持不变。我想象着，鉴于 2010 年之后 C++标准变化的速度加快，跟上 C++标准可能很困难，而且总有一个问题存在：有多少代码使用了最新的标准？学生难道不是无论如何都需要学习 C++的旧方法，以便能够处理几十年前的代码库吗？

尽管存在这种可能性，但我们必须在某一点上前进，Bjarne Stroustrup 也有同样的想法。他的第三版书籍《*使用 C++进行编程：原理与实践*》（[`www.amazon.com/Programming-Principles-Practice-Using-C-ebook/dp/B0CW1HXMH3/`](https://www.amazon.com/Programming-Principles-Practice-Using-C-ebook/dp/B0CW1HXMH3/)），于 2024 年出版，面向编程初学者，并引导他们学习 C++语言。这本书是 C++的一个非常好的入门介绍，并附有示例和幻灯片，对任何想要教授或学习这门语言的人来说都很有用。

值得注意的是，斯特劳斯特普并没有回避指针和内存管理这个话题，反而讨论了必要的最小化内容，并立即展示了现代 C++避免这些问题的方法。

以 *第十六章* 相关的幻灯片为例，该章节专注于数组。它们从裸数组的解释开始，解释它们与指针的联系，以及在使用指针时可能会遇到的问题。然后引入了替代方案：**vector**、**set**、**map**、**unordered_map**、**array**、**string**、**unique_ptr**、**shared_ptr**、**span** 和 **not_null**。演示文稿以多种方式实现回文示例结束，比较了代码的安全性和简洁性。因此，整个章节的目的是展示数组与指针的各种问题，以及 STL 结构如何帮助避免这些问题。

产生的代码与 Java 或 C# 变体非常相似。然而，斯特劳斯特普指出，指针运算仍然对于实现数据结构是有用的。换句话说，要谨慎使用，并且只有在真正需要重型优化时才使用。

因此，我们得出结论，语言创造者并不回避指针和内存管理，而是专注于消除随之而来的许多潜在问题。这使得 C++ 程序员在 C++ 98 时代相比，对内存管理的关注较少，但仍然比 Java 或 C# 多一点。

问题是仍然存在：初学者能否在不过多考虑指针的情况下学习 C++？另一种教学方法似乎证明了这是可能的——如果我们想训练库用户而不是库创建者的话。

# 凯特·格雷戈里的方法——不教授 C

在 2015 年的 *CppCon* 讲座中（[`www.youtube.com/watch?v=YnWhqhNdYyk`](https://www.youtube.com/watch?v=YnWhqhNdYyk)），凯特·格雷戈里指出，学习 C++ 并不需要 C 作为先决条件，而且一开始就教授 **printf**、裸数组以及字符指针，对初学者来说，这实际上是在损害学习过程。

相反，她的建议是从 STL 中可用的对象开始。字符串和向量类对初学者来说相当清晰，并且运算符重载也是使用这些对象的一种非常自然的方式。初学者期望 **"abcd" + "efg"** 将产生 **"abcdefg"**；没有必要解释运算符重载的复杂性，以便他们可以编写简单的程序。此外，这种方法完全避免了讨论析构器和内存清理。

她继续争辩说，如果从示例开始，教初学者使用 lambda 表达式也很简单。考虑尝试在一个向量中查找一个值。第一种方法可能是使用一个可以快速浏览的 **for** 循环。第二种方法是使用 **std::find**。但如果我们想在 **vector<int>** 实例中查找一个偶数值呢？这很自然地将 lambda 表达式引入到对话中，而不需要对所有可能的编写方式进行整个讨论。

她认为，使用这种方法，初学者将能够使用现有的库。他们将在知识上存在一些差距，在为特定代码库工作的程序员课程中，你可能需要有一个部分向他们介绍阅读对他们工作有用的特定习语。如果你想让这些程序员成为库的创建者，那么你需要一个更高级的课程，深入探讨内存管理和指针可能实现的优化。

我在复杂技能培训方面的 15 年经验告诉我，这种教学方法非常好。培训中的一个关键点是理解你的目标受众，并尽最大努力避免知识的诅咒——即你无法回忆起你今天非常熟悉的东西不知道时的感觉。这种方法通过提供快速胜利和良好的进步，以及给予学习者编写代码的勇气，来迎合初学者的心态。因此，它无疑是学习 C++ 方法的改进。

然而，学习语言的方法不止这一种。是的，这是一种结构化的方法，但探索是学习的一个重要部分。有一种通过探索学习 C++ 的方法，它使用通常与推特冲突相关的方法：**测试驱动开发**（**TDD**）。

# 学习 C++ 的测试驱动方法

从书籍或结构化课程中学习只是其中一种方法；另一种是通过个人探索。想象一下学习 C++，但不是先要查看一大堆代码示例，而是编写你认为应该工作的代码，并逐步学习你的直觉与实际语言之间的差异。实际上，人们在通过结构化学习课程时自然会结合这两种方法。

通过探索学习的一个缺点是难以理解你的进度，你可能会经常陷入困境。有一种方法可以解救：TDD。

TDD 是一种反直觉但有效的增量设计方法。其最简单的描述如下：

+   **步骤 1，也称为红色**：编写一个失败的测试，显示需要实现的下一个案例

+   **步骤 2，也称为绿色**：编写最简单的代码以使测试通过（并保持所有其他测试通过）

+   **步骤 3，也称为重构**：重构生产代码和测试代码以简化。

这种红-绿-重构周期在非常小的周期内重复（通常 5-10 分钟），直到所有与当前功能或用户故事相关的行为都已实现。

解决 TDD 误解

个人而言，我是一个 TDD 的粉丝，并且我已经成功使用了超过 10 年。实际上，我使用 TDD 来编写这本书的示例代码。然而，我知道 TDD 在业界受到了不同的评价。部分原因是想象力不足，一个常见的问题是：我该如何为一个不存在的函数编写测试？嗯，基本上和编写一个之前不存在的代码的方式一样：你想象它存在，并专注于期望的输入和输出。其他批评来自于对 TDD 真正是什么以及它是如何工作的理解不足。伪 TDD 失败的例子通常涉及从边缘情况开始，并显示当你应该从正常路径情况开始时，事情会迅速变得复杂。关于 TDD 会减慢开发速度的说法是可信的，但事实是，这种方法帮助我们更加彻底和有计划，从而避免了通常在后期才被发现并需要大量汗水和压力来修复的问题。最后，TDD 不是设计高性能算法的方法，但它可以帮助你找到一个初始解决方案，你随后可以通过测试套件的帮助来优化它。

要理解如何通过修改的 TDD 周期来学习编程语言，我们需要澄清关于 TDD 的两个问题。首先，TDD 是非直观的，因为它要求对问题领域进行长时间的专注，而大多数编程课程教我们如何处理解决方案领域。其次，TDD 是一种增量设计方法；也就是说，以逐步的方式找到一个解决特定问题的代码结构，而不是一次性解决。这两个特性使得 TDD 在有适当支持的情况下，成为学习新编程语言的最佳选择。

想象一下，在你能够运行一个程序之前，不是先学习关于 C++的所有内容，而是先学习如何编写测试。这其实很简单，因为测试通常只使用语言的一小部分。此外，运行测试会立即给你反馈：如果有什么不对的地方，会显示失败或红色，而当一切正常时，会显示成功或绿色。最后，一旦你有一个或多个测试，这让你可以探索一个问题，并找出如何编写代码，使得编译器能够理解它——这正是你学习一门语言时想要的。在 C++中，找出错误信息可能有点问题，但如果你有一个人（或者未来可能是一个 AI）可以求助，你会在学习过程中学到很多东西，并且每当学到新东西时，你都会看到绿色的进度条。

这种方法已经在小规模上进行了测试，并且效果显著。以下是一个 C++学习会议可能的工作方式。

## 设置

学习过程中至少涉及两个参与者；我们将它们称为教练和学生。我更喜欢使用教练而不是讲师，因为目标是引导学生走他们自己的学习路径，而不是直接教他们东西。

我将讨论剩余的会话，好像只有学生参与一样。类似的设置也可以用于多个学生。

行动者需要做的第一件事是设定一个目标。通常，目标是学习至少 C++，但也可以是更深入地了解某个特定主题——例如，**std::vector** 或 STL 算法。

在技术设置方面，两个人在同一个显示器上观看代码并并肩工作效果最好。虽然最好是面对面进行，但通过各种工具远程也是可能的。

首先，教练需要设置一个简单的项目，包括测试库、生产代码文件和测试文件。需要提供一个简单的方式来运行测试，无论是通过按钮点击、键盘快捷键还是简单的命令。我推荐的 C++设置是使用 **doctest**（[`github.com/doctest/doctest`](https://github.com/doctest/doctest)），这是一个仅包含头文件的测试库，它非常快，并支持生产所需的大量功能。

这是这个项目的最简单结构：

+   一个测试文件，**test.cpp**

+   一个生产头文件，**prod.h**

+   一个 **doctest.h** 文件

+   一个允许我们运行测试的 Makefile

根据学习目标，可能还需要一个 **production cpp** 文件。

教练还需要提供一个第一次测试失败示例，并展示如何运行测试。学生接管键盘并运行测试。这个测试可以非常简单，如下面的示例所示：

```cpp
#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
#include "doctest.h" 
#include "prod.h"
TEST_CASE("Test Example"){
    auto anAnswer = answer();
    CHECK(anAnswer);
}
```

生产头文件显示了以下内容：

```cpp
bool answer(){
    return true;
}
```

首要任务是让测试通过。教练会不断问学生的一个问题：“你认为这会怎么工作？写下你找到的任何直观的想法。”如果学生找到了正确答案，太好了！如果没有，展示正确答案并解释原因。

这个示例非常有用，因为它介绍了一些语言元素并展示了它们的工作：函数声明、变量、测试和返回值。同时，这个过程也非常好，因为它给学生提供了一个进度衡量标准：测试通过是好的，测试未通过则意味着有东西要学习。

完成所有这些后，就到了探索阶段。

## 探索语言

以这种方式探索编程语言有两种方法：通过简单的问题逐一引入概念，也称为禅宗，或者通过解决更复杂的问题。

无论哪种方式，方法都是一样的：首先，教练写一个简单的测试或帮助学生写一个失败的简单测试。然后，要求学生写出他们认为最直观的解决方案。运行测试，如果它们没有通过，教练需要解释哪里出了问题。无论是教练还是学生进行更改，当测试通过时，步骤以清晰的进度结束。

在此过程中，重要的是要关注学生的下一步自然步骤。如果学生有具体的问题或好奇心，下一个测试可以处理这些问题，而不是通过脚本化的过程。这种适应性学习方法帮助学生感到掌控全局，这个过程给他们一种自主性的错觉，最终变成现实。

## 关于内存问题呢？

我们在本章中花了一些时间讨论这样一个事实：与使用其他主流编程语言相比，C++程序员需要学习更多的内存管理知识。他们如何通过这种方法学习内存管理？测试不会捕捉到内存问题，对吧？

事实上，我们希望学生从一开始就意识到他们需要关注内存。因此，内存检查需要集成到我们的测试套件中。我们有两个选择来实现这一点：要么使用专门的工具，要么选择可以检测内存问题的测试库。

如 **valgrind** 这样的专用工具很容易集成到我们的流程中。请参见以下 Makefile 的示例：

```cpp
check-leaks: test 
    valgrind -q --leak-check=full ./out/tests
test: test.cpp
    ./out/tests
test.cpp: .FORCE
    mkdir -p out/
    g++ -std=c++20 -I"src/" "test.cpp"  -o out/tests
.FORCE:
```

**test.cpp** 目标正在编译测试。测试目标依赖于 **test.cpp** 并运行测试。第一个目标，**check-leaks**，会自动运行 **valgrind**，并带有仅当出现错误时显示错误的选项，这样学生就不会感到不知所措。在没有参数的情况下运行 **make** 时，第一个目标会被选中，因此默认情况下会进行内存分析。

假设我们正在运行带有内存泄漏的测试，如下例所示：

```cpp
bool answer(){
int* a = new int(4);
return true;
}
```

我们立即看到了以下输出：

```cpp
==========================================================[doctest] test cases: 1 | 1 passed | 0 failed | 0 skipped
[doctest] assertions: 1 | 1 passed | 0 failed |
[doctest] Status: SUCCESS!
valgrind -q --leak-check=full ./out/tests
[doctest] doctest version is "2.4.11"
[doctest] run with "--help" for options
==========================================================[doctest] test cases: 1 | 1 passed | 0 failed | 0 skipped
[doctest] assertions: 1 | 1 passed | 0 failed |
[doctest] Status: SUCCESS!
==48400== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1
==48400==    at 0x4849013: operator new(unsigned long) ==48400==    by 0x124DC9: answer()
```

此输出为学生提供了足够的信息进行讨论。

第二种选择是使用已经实现了内存泄漏检测的测试库。CppUTest ([`cpputest.github.io/`](http://cpputest.github.io/)) 就是这样一种库，它还有支持 C 和适用于嵌入式代码的优势。

使用这些工具，现在很明显，这种方法适用于向任何想要尝试或深入研究特定部分的 C++学习者教授 C++。

现在我们今天学习了两种学习 C++的方法，让我们回到理解 C++的利基是什么以及为什么它必然比其他语言更复杂。

# 有很大的力量……

如果我想要你从本章中带走的东西，那就是 C++是一个非常强大的语言，而随着这种力量的到来，程序员有责任使用适当的抽象级别。

我确信，今天开始一个新项目、解决特定商业问题、仅使用最新标准和特定库的 C++程序员团队可以安全地编写代码，并具有良好的性能，无需过多担心内存问题，比他们的 Java 或 C#同事还要少。事实上，他们的代码很可能与其他语言的代码非常相似，预期有更好的性能。

然而，即使是这样一个团队，偶尔也会面临选择：我们是使用 STL 提供的现有工具实现一个稍微低效的解决方案，还是通过递归到指针算术、移动语义或自定义内存管理来优化它？这就是 C++的力量需要同样高水平的责任、细心和深刻理解的时候。

注意

当我写下这些文字时，世界仍在 2024 年 7 月的 CrowdStrike 事件之后陷入混乱。尽管官方已经披露（[`www.scmagazine.com/news/crowdstrike-discloses-new-technical-details-behind-outage`](https://www.scmagazine.com/news/crowdstrike-discloses-new-technical-details-behind-outage)），但事件的起因仍然不十分清楚。无论如何，似乎是一个 C++程序中的内存访问错误导致了全球 Windows 系统的内核恐慌，导致飞机停飞、资金转账停止，以及——最可怕的是——紧急服务关闭。当然，这种变化本不应该进入生产环境，但这却是一个提醒，说明世界对软件的依赖程度有多大，以及滥用 C++力量的后果。

# 总结

在本章中，我们考察了一个声明：“C++非常难学”。那么，它是吗？

我们回顾了 C++的历史，以及它最初确实是一个挑战，即使是编写最简单的程序。我们看到了 Java、C#和 Python 如何处理程序员面临的某些问题，以及 C++标准在过去 15 年中是如何意外地快速发展的，以消除其障碍。

虽然你现在可以写出类似于 Java 或 C#的 C++代码，但你可能仍然需要理解内存管理，这一点我们通过使用移动语义进行了例证。我们还看到，随着语言和时代的发展，学习 C++的方法也在不断演变，Stroustrup 只是简单介绍了指针，然后迅速转向 STL 中可用的更高级结构。我们看到，修改后的 TDD 循环可以帮助人们以探索的方式学习 C++，而不会因为错误信息的复杂性和语言的复杂性而感到不知所措。

我们还指出，C++在工具和可移植性方面存在劣势。在 C++中安装一个新的依赖项是一项完整的工作，与 Java、Python 或 C#不同，它们提供了一个事实上的标准命令来管理包。这可能会让想要成为 C++程序员的初学者望而却步。

最后，尽管标准有了进步，但我们不能忘记世界上存在的大量 C++代码，这些代码还没有达到最新的标准。很可能，即使你学习了现代 C++，你的工作迟早也会涉及到处理旧代码。

因此，我们得出结论，C++仍然比 Java、C#或 Python 更难学习，但它比以往任何时候都更接近，而且对于程序员的一个子集来说，语言的强大功能仍然具有吸引力。

在下一章中，Ferenc 将探讨以下问题：每个 C++程序都是标准化的吗？或者，也许程序员们是被解决问题和选择最适合他们环境的解决方案所驱动，忽略了标准，甚至创造了最终会被纳入标准的习惯用法。
