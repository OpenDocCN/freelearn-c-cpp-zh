# 10

# 在 C++ 中没有现代编程的库

*或者也许有太多，而且它们并不* *容易获得？*

C++ 是现代软件开发中使用最古老的语言。尽管有多次尝试取代它，但它仍然在偏好和实用性方面保持领先。然而，这种遗产也带来了自己的挑战。开发风格随着时间的推移而演变，包括更容易被开发者理解的结构，用更少的代码解决问题，或者有时看起来更美观。

任何技术生态系统中的一部分是可用的库列表，包括并补充标准库。由于 C++ 已经存在很长时间，它有库。然而，它们与其他技术使用者的体验相比如何？它们是否满足现代开发者的需求和期望，这些开发者可能正在考虑市场上可用的替代解决方案？

这些是我们接下来将要探讨的一些问题。

在本章中，我们将涵盖以下主要主题：

+   现代开发者体验

+   常见需求

+   兼容性

+   供应链安全

# 我们如何判断？

当思考像本章标题这样的问题时，我们面临着选择的大挑战。任何项目的库选择完全取决于上下文，完全取决于项目试图解决的问题。当然，有些功能无论项目做什么都是需要的，比如日志记录或单元测试，但除了这些之外我们应该选择什么？

最后，将 C++ 中的 Web 开发与 Java 中的 Web 开发进行比较似乎非常不公平，就像将 C++ 中的系统编程与 Java 中的系统编程进行比较一样。C++ 并没有广泛用于 Web 开发，Java 也没有用于系统编程。事实上，C++ 很早就有了自己的细分市场，尽管它已经被 Java、C#、Rust 和 Python 慢慢侵蚀，但它仍然在游戏开发、固件、高频交易、工程应用、汽车、系统编程以及可能的其他用例中占据着阵地。其他语言在这些领域几乎没有影响力，这有很多很好的原因，与 C++ 的灵活性、性能和控制力有关。

另一个问题是为上述语言（尤其是 C++）存在的库的数量。值得尊敬的 C++ 的一个优点是程序员有足够的时间开发像 Boost 这样的巨无霸库，它在 Java 或 C# 的世界中（不包括标准库）没有对手，在 Python 的世界中绝对没有竞争对手。我们可以争论说，JavaScript 有类似 React 及其周围生态系统的类似东西。然而，在可用的库数量方面，C++ 看起来占主导地位。

这些观察让我们意识到一个需要考虑的特征：这些库集合有多现代？我们希望从一门现代编程语言及其生态系统中得到什么？从这一角度来看，C++处于什么位置？让我们来探讨这些问题。

# 现代开发者的体验

让我们暂时跳出 C++的世界，变成一个观察其他技术使用者的“旁观者”。我们将陪伴他们从开始一个新项目，到后来向团队添加新成员。可能的第一步是他们将启动一个 IDE，创建一个新项目或项目结构。IDE 可能是来自微软的，如 Visual Studio .NET 或 Visual Studio Code，或者是来自 JetBrains 的，如 Java 的 IntelliJ IDEA，Python 的 PyCharm，或 C#/.NET 的 Rider。一小部分像我这样的奇怪程序员会使用命令行和 neovim。更奇怪的程序员甚至会使用 Emacs。我当然是在开玩笑；我们都知道真正的程序员会利用大气电的变化来直接操纵位，正如著名的 xkcd 漫画《真正的程序员》（[`xkcd.com/378/`](https://xkcd.com/378/)）所展示的那样。然而，让我们回到我们的故事。

在创建新项目时，IDE 会建议安装一些集成和库。一旦创建，项目就可以运行，尽管它不会做很多有用的事情。在创建过程中，将选择一个源代码控制仓库，很可能是基于 git 的现有仓库。然后可以在本地提交项目并将其推送到共享仓库。

在完成这些步骤之后，团队成员将有一些事情要做：启动 IDE，在本地克隆仓库，并让 IDE 按照项目配置获取必要的依赖项。

在这一点上，项目可能已经包含了日志记录和单元测试库。让我们暂停一下，来检查所使用的库。

Python 在其标准库中提供了日志记录功能，而 Java 有开源的 Log4J，.NET 则使用微软构建的 Microsoft.Extensions.Logging 或开源的 Log4Net。对于单元测试，Python 提供了单元测试和模拟的标准实现，但程序员往往更喜欢像 pytest 这样的开源扩展（[`docs.pytest.org/en/stable/`](https://docs.pytest.org/en/stable/)）。Java 需要单元测试库，通常是 JUnit 或 TestNG，以及模拟库，通常是 Mockito 或 JMock。最后，.NET 提供了一个标准的测试框架，但知识渊博的技术负责人更有可能选择 NUnit 或 xUnit，以及 Moq。

C++在这里处于什么位置呢？嗯，C++中日志库的选择并不少，这并不令人惊讶，因为日志系统与 C++同时成熟。我们可以认为日志库几乎是标准化的，它们在 API 上有着非常相似的行为和功能，只有细微的差别。除非你正在使用自带日志功能的技术，否则选择一个 C++的日志库几乎是一件非常困难的事情。我想，许多项目都使用 Boost 及其内置的日志功能。快速浏览 GitHub 可以发现，**spdlog**库（[`github.com/gabime/spdlog`](https://github.com/gabime/spdlog)）有 24k 个星标，尽管它只支持 C++ 11。

单元测试怎么样呢？这是一个有趣的话题。C++中存在多种形式的单元测试库。有 Google 启动的 GTest 和 GMock，这两个库具有通常的功能集。同样，CppTest 遵循标准的 xUnit 结构进行单元测试。然后是**doctest**（[`github.com/doctest/doctest`](https://github.com/doctest/doctest)），这是一个无依赖的单头库，这也是为什么我更喜欢用它来展示示例和本书伴随的代码。最后，值得一提的是**Cpputest**（[`cpputest.github.io`](http://cpputest.github.io)），因为它允许嵌入式开发，这得益于它的小型足迹和识别内存管理问题的功能。对于模拟，**FakeIt**（[`github.com/eranpeer/FakeIt`](https://github.com/eranpeer/FakeIt)）是另一个非常容易集成的单头框架。

所有这些库都可能会通过包管理器来设置，该管理器将依赖项列表存储在一个文本文件中，该文件可以是纯文本、标记格式或脚本。这个文件会被推送到中央仓库，并可用于重新创建依赖项，包括安装的库所需的依赖项。

在开发过程中，如果团队需要额外的库，他们可以简单地将其添加到依赖项中。由于安全考虑，这个过程在企业环境中可能更为受限：可能有一个预先批准的包列表，可能每个包都需要获得批准，或者可能只有特定的人可以添加依赖项。

无论哪种方式，当新开发者加入时，他们都会克隆中央仓库并运行安装命令，通常是通过在 IDE 中加载项目并让它自行处理，一切应该都会顺利。这就是我们飞行的故事的结尾。

让我们深入了解如果您使用包管理器时幕后发生的事情。由于我经常在 Ubuntu Linux 上结合使用命令行和 neovim 进行编程，我对这些技术中的每个技术的处理过程都有一些了解。对于 Python，建议使用虚拟环境，这样操作系统就不会被所有所需的库所污染。一个名为 **pipenv** 的工具结合了标准库提供的 **pip** 包管理器和 **venv** 虚拟环境，以便于轻松设置。命令行步骤如下：

```cpp
pipenv init
pipenv install [library name]
```

在新环境中，你可以简单地运行以下命令来安装所有依赖项：

```cpp
pipenv install
```

Java 和 .NET 有类似的流程，只是没有虚拟环境。它们都使用开源的包管理器；对于 Java，使用 Maven 或 Gradle，对于 .NET，则是 NuGet。

对于所有这三项技术，都存在一个所有库的中心位置：Python 的 Pypi（[`pypi.org/`](https://pypi.org/)），Maven 的 Maven Central（[`mvnrepository.com/repos/central`](https://www.mvnrepository.com/repos/central)），以及 NuGet 网站（[`www.nuget.org/`](https://www.nuget.org/)）。如前所述，大型公司可能会更加关注所使用的库，并在将第三方代码用于其系统之前进行更彻底的安全检查。这些公司往往提供自己的仓库，例如，在 Java 中使用 Artifactory（[`jfrog.com/artifactory/`](https://jfrog.com/artifactory/)）。

因此，使用事实上的标准工具，任何使用该技术的开发者都可以轻松地搜索库、更新它们并在新环境中安装它们。

自从我在 2000 年代初成为 C++ 程序员以来，C++ 已经走了很长的路。当时，添加一个新的库需要下载所需目标的二进制文件，或者更可能的是，自己编译它，这本身也带来了一系列挑战。如今，C++ 通过 Conan 和 vcpkg 正在缩小差距，许多程序员在 C++ 上的体验可能与我在 Java、Python 和 .NET 上描述的类似。大型公司的程序员最有可能认识到这一点，因为组织提供了一个包含经过批准的库的 Conan 或 vspkg 仓库，可以轻松找到并安装。将新的库添加到白名单可能有些麻烦，可能需要很长时间，但这是可以理解的。

没有这个基础设施，事情并不容易。库不是在单一位置提供的，工具似乎也不太好用。至少这是我的经验：当我尝试在一个简单的项目中使用 Conan 时，它给出了一堆错误，而我不知道如何修复它们。虽然我不喜欢 Maven，因为它在设置最简单的情况下也会无端下载很多包，但它始终如一且可靠，这正是我们从包管理器中需要的。所以，我恐怕不得不这么说：尽管有尝试将 C++包管理与其他技术相提并论，但它仍然感觉还不够成熟。

话虽如此，我相信许多在大公司工作的开发者不会感受到这些问题。因此，我们假设包管理器运行良好。接下来我们该做什么呢？根据项目和技术的不同，我们可能需要更多的库来帮助我们。接下来，让我们看看几个类别。

# 常见需求

这里是一些许多开发者都有，但顺序并不重要：

+   数据库连接、读取和写入

+   CSV 文件处理

+   压缩，例如，**gzip**

+   日期/时间增强

+   各种计算，例如：矩阵、复数、数学方程求解等

+   UI，用于桌面和移动应用

+   HTTP 客户端

+   HTTP 服务器

+   异步编程

+   图像处理

+   PDF 处理

+   后台任务

+   密码学

+   网络通信

+   序列化

+   发送电子邮件

+   JSON 处理

+   配置文件读取和写入：**ini**、**yaml**等

可以肯定的是，对于这些需求，都有相应的 C++库。让我们随机挑选几个：

+   **zlib** 用于 **zip** 和 **gzip** 压缩

+   Rapidcsv ([`github.com/d99kris/rapidcsv`](https://github.com/d99kris/rapidcsv)) 用于 CSV 处理

+   对于数据库访问，可以使用 ORM 如 TinyORM ([`www.tinyorm.org/`](https://www.tinyorm.org/)) 或 SQLPP1 ([`github.com/rbock/sqlpp11`](https://github.com/rbock/sqlpp11))，用于类型安全的 DSL 查询和结果

+   Poco 库 ([`pocoproject.org/`](https://pocoproject.org/)) 包含大量用于网络、发送电子邮件、数据库访问、JSON、OpenSSL 等的实用工具

+   UI 库包括 Qt、GTK、wxWidgets 或 Dear ImGui

+   HTTP 客户端由 Boost、Curl++或 cpp-netlib 实现

+   为了实现 Web 应用，Crow ([`crowcpp.org/master/`](https://crowcpp.org/master/)) 受 Python 的 Flask 启发，而 Oat++ ([`oatpp.io/`](https://oatpp.io/)) 和 Drogon ([`drogon.org/`](https://drogon.org/)) 为 Web API 和微服务提供了快速解决方案

我们可以继续说，但我认为我们已经表达了我们的观点：*C++ 有库*。它有 *很多库*。其中一些库启发了其他技术的实现，而另一些则从替代方案的最佳解决方案中汲取了灵感。在速度和低内存占用方面，C++ 实现的优势是显而易见的。其中一些库将许多功能打包到几百 KB 中。而且，存在许多仅包含头文件的实现，这使得它们具有可移植性和简单性。

C++ 也有框架。我们之前已经提到了一些，我们还可以添加其他一些：GTK、QT、Boost、POCO、WxWidgets 和 Unreal Engine，例如。库和框架的列表在网上有维护，我找到的最好的是 **awesome-cpp**（[`github.com/fffaraz/awesome-cpp`](https://github.com/fffaraz/awesome-cpp)）。

即使是细分编程风格和实践也有它们的库：

+   不变集合？使用 Immer（[`github.com/arximboldi/immer`](https://github.com/arximboldi/immer)）。

+   响应式编程？使用 RxCpp（[`github.com/ReactiveX/RxCpp`](https://github.com/ReactiveX/RxCpp)）。

+   微服务？当然，CppMicroServices（[`github.com/CppMicroServices/CppMicroServices`](https://github.com/CppMicroServices/CppMicroServices)）可以帮忙（不，微服务不是细分领域，但它们很少用 C++ 实现）。

+   网络汇编？是的，有 Emscripten（[`github.com/emscripten-core/emscripten`](https://github.com/emscripten-core/emscripten)），这是一个不错的选择。

+   无服务器？有 **aws-lambda-cpp**（[`github.com/awslabs/aws-lambda-cpp`](https://github.com/awslabs/aws-lambda-cpp)）。

我想现在很明显，我们很难找到一个领域，C++ 在其中没有库或框架。然而，我们能使用它们吗？

# 兼容性

假设你找到一个非常有前途的库，并决定将其添加到你的项目中。它是否工作？它会 *如何* 工作？

这就是 C++ 分裂展现其丑陋一面的地方。以下任何不希望发生的事情都有可能发生：

+   该库使用的 C++ 版本比你的代码新，并且你无法编译它

+   图书馆使用的 C++ 版本比你的代码旧

+   你会因各种原因收到很多警告

+   该库与你的 C++ 版本兼容，但其接口使用较旧的构造

+   该库在你的项目目标的所有平台上都不工作

+   该库与你的编译器不兼容

+   该库与你的编译过程不兼容

+   该库与你的项目目标的所有平台兼容，但在特定平台上存在不同的行为或性能问题或错误

我希望您永远不要遇到上述任何问题。此外，值得一提的是，在我们使用的比较技术中，您不太可能遇到这些问题：Python、Java 和.NET 都没有这些问题。嗯，几乎都没有；例如，创建使用 C++模块的 Python 程序可能会遇到相同的问题。或者，您可能创建了一个使用操作系统原语的 Java 程序，它在不同的操作系统上会有不同的问题。总的来说，在这些领域，人们一直在努力实现一致性。

公平地说，成熟的 C++框架和库，如 Boost 或**zlib**，也做出了同样的努力，并提供了一致的行为。只是在使用虚拟机的语言中创建一致的库要容易得多。

假设你的库运行良好：没有警告，没有奇怪的问题，并且它与你的代码和工具集很好地协同工作。最后一个问题是：我们能信任它吗？

# 供应链安全

对于关注的人来说，软件一直存在安全问题应该是显而易见的。随着软件使用的持续增加，它覆盖了我们日常生活的更多领域，这个问题正在变得越来越严重。

提高安全性的两个方面包括：网络安全专家，他们可以找到漏洞并构建保护工具，以及软件开发者，他们需要在发布前找到安全问题并管理相关的风险。我们知道没有绝对安全的软件，但我们也知道事情可以变得更好。

这种增加保护的具体领域是管理我们使用的库可能带来的潜在漏洞。有两种情况：要么漏洞是无意中引入的，要么是由恶意行为者故意注入的。

客观地说，任何技术都可能发生这种情况，许多知名的 C++库都由使用它们的大型公司进行安全审查。此外，如果您在大型公司工作，您有团队处理所有这些关注点。然而，并非所有开发都在大型公司进行，并非所有库都受到同等对待，正如我们将通过**xz 后门案例**所看到的那样。让我们暂时讨论第二种情况。恶意行为者可以通过多种方式注入漏洞：

+   他们可以通过向开源项目的代码做出贡献来实现这一点。

+   他们还可以分叉开源项目，并在有用的功能中添加漏洞。

+   他们有时甚至可以逃脱成为开源项目维护者的角色，然后在有用的功能中注入漏洞。请参阅我在[`mozaicworks.com/blog/xz-backdoor-and-other-news`](https://mozaicworks.com/blog/xz-backdoor-and-other-news)上详细评论的 xz 后门故事。

+   他们还可以用有漏洞的版本替换二进制文件，例如，通过在另一个网站而不是原始网站上提供它或成功劫持发布过程。

+   他们也可能尝试劫持下载，例如，通过 DNS 攻击。想象一下一个潜在的攻击者成功修改了你的本地主机文件，将你的仓库 URL 指向互联网上的另一个 IP 地址。

前面列表中的所有项目都是严重问题。在大公司中，安全部门和 IT/Ops 通常会担心这些问题，但在小公司中，你可能需要额外注意。我们知道的解决方案是验证所有二进制文件与其数字签名或哈希值。虽然编程语言和 Linux 的包管理器会自动执行此操作，但手动从 GitHub 下载二进制文件需要手动验证签名，希望签名与库文件一起提供。

第一种情况甚至更复杂。你怎么知道一个库是否有漏洞？对于开源代码，普遍的看法是，许多眼睛查看代码就能发现所有问题。然而，这非常依赖于贡献者的数量和他们的专业知识。

提到的 xz 后门案例令人毛骨悚然，特别是问题是由开发者 Andres Freund 发现的，他通过微基准测试期间**sshd**使用过多的 CPU 而产生了怀疑（[`mastodon.social/@AndresFreundTec/112180406142695845`](https://mastodon.social/@AndresFreundTec/112180406142695845)）。这使得开源库过度工作的维护者问题变得明显，但很快又回到了隐秘状态。

让我们假设大多数开源库不会被获得维护者状态的恶意行为者攻击。漏洞仍然可能逃逸，尤其是在 C++中，因为它在安全性方面有自己的挑战。一个小团队需要了解他们使用的库报告的漏洞，或者许可自动为他们执行此操作的许可证安全工具。

假设一切正常，仍然最好将应用程序中使用的库列表存储起来，这样运维人员就知道定期检查所有库中的漏洞。在这个领域，推荐的实践是为你的产品创建所谓的**软件物料清单**（**SBOM**）。SBOM 包含所有库及其依赖关系的列表。有特定的工具可以创建 SBOM 并基于它们扫描漏洞；然而，大多数工具都与 docker 容器一起工作。例如，考虑 Grype（[`github.com/anchore/grype`](https://github.com/anchore/grype)）及其配套工具 Syft [`github.com/anchore/syft`](https://github.com/anchore/syft)）。

这引出了本章的结论。

# 摘要

在本章中，我们了解到 C++拥有众多库和框架，涵盖了我们所可能需要的所有功能。与其他技术相比，获取它们的过程并不简单。由于它们不在一个中心位置，因此它们并不容易被发现，并且可能带来额外的麻烦，例如与编译器或旧代码风格的不兼容性。我们在这章中学到了这一点。

同样地，与其他技术一样，C++库容易存在漏洞，并可能受到供应链攻击。为了防范这些攻击，团队需要跟上发现的漏洞流，并在下载时验证二进制文件。正如我们在本章所学，额外的审计和扫描总是很有用的。因此，大型组织在安全性方面具有优势，因为它们有专门的团队来关注这些问题，但这是以灵活性为代价的。

那么，C++中是否有现代编程的库呢？当然有，只是它们更难找到，并且与其他广泛使用的技术相比兼容性较差。

在下一章中，我们将探讨 C++是否与其自身以及更广泛的技术向后兼容。
