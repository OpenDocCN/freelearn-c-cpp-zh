

# 在 C++中实现并行和并发没有简单的方法

*除非我们重新思考面向对象编程* *和函数式编程*

要在 C++中实现并行和并发，我们过去通常需要单独的库（例如，Boost）或操作系统原语。随着函数式编程结构的引入，在一定的约束下，并行和并发变得更加容易。

在本章中，我们将涵盖以下主要主题：

+   定义并行和并发

+   并行和并发中的常见问题

+   函数式编程来拯救！

+   Actor 模型

+   我们目前还无法做到的事情

# 技术要求

本章的代码可在 GitHub 上找到，地址为[`github.com/PacktPublishing/Debunking-CPP-Myths`](https://github.com/PacktPublishing/Debunking-CPP-Myths)，位于**ch7**文件夹中。代码是用 g++和 C++ 20 编译的 Makefiles。关于 Actor Model 的示例使用了**C++ Actor Framework**（**CAF**）（[`www.actor-framework.org/`](https://www.actor-framework.org/)），因此在开始工作之前您需要安装它。在 Ubuntu 上，可以通过运行**apt install libcaf-dev**来安装。示例中使用的 CAF 版本是稳定的 Ubuntu 库版本：**0.17**。

# 定义并行和并发

我的第一台电脑是 HC-90，这是一款在罗马尼亚制造的 ZX-80 克隆。我拥有两个版本：第一个版本需要磁带播放器来加载程序。尽管这种不便，但它与当时的主要竞争对手 CHIP 电脑（又是另一款在罗马尼亚制造的 ZX-80 克隆）相比有一个很大的优势。您知道，CHIP 电脑需要磁带来加载其操作系统，而 HC-90 有足够的 EPROM 内存可以直接引导到 BASIC 解释器。我拥有的第二个版本要好得多：它有一个 5 英寸软盘驱动器，这意味着您可以更快地加载程序。

在两个版本中，BASIC 解释器都是您与计算机的接口，由于除了游戏之外可用的程序不多，我在高中时花了一些时间编写 BASIC 程序和玩游戏。最终，我意识到我想要的不仅仅是 BASIC。我尝试了一些图形和声音，但问题是所有东西都非常慢。这让我学习了 ZX 80 汇编器，这是一次冒险。在汇编器中犯错非常容易，这会导致重启并丢失所有工作。这不是一种可持续的编程方式，但它让我更加珍视今天的编程便利。想象一下：我可以在我的电脑上编译和运行程序的测试，并将我的更改保存到源代码控制系统中。

我当时就知道，我想让图形和声音感觉更快。我没有意识到的是，我有一个根本的限制：只有一个 CPU（或者说，就像我们今天所说的，一个核心），这意味着图形、声音和逻辑代码必须顺序运行。CPU 可以接收一个播放声音的命令，然后转到显示一些图形，然后进行一些计算，由于指令和实际声音播放或图像显示之间的延迟非常短，所以这些任务看起来像是并行运行的。但它们并不是：它们是并发的。如果你将系统加载到最大，图像和声音就不再同步了，你可以观察到这一点。

如果我有更多的处理器或更多的核心来工作，会发生什么情况呢？嗯，我可以定义各种可以在单独的处理器上运行的任务。一个有能力的调度器可以接管这些任务，并将它们并行运行以填充空闲 CPU 的容量。如果任务定义得很好，我们可以从可用的核心中榨取大量的性能，并更快地得到答案。这就是**并行性**。

这个定义的一个细微差别，将在本章中变得有用，来自 Haskell 社区（见[`wiki.haskell.org/Parallelism_vs._Concurrency`](https://wiki.haskell.org/Parallelism_vs._Concurrency)）。他们在一个并行函数程序和一个并发函数程序之间做出了很大的区分，因此假设这两个程序都使用不可变性。并行函数程序使用核心来执行得更快，但它们是确定性的，程序的意义在顺序执行或并行执行时是不变的。与此相对比的是，并发函数程序运行并发线程，每个线程执行 I/O 操作，并且是非确定性的，因为我们不知道操作顺序。

不幸的是，正如软件开发中常见的那样，这些术语有自己的生命周期。你可能会遇到一些人认为并发和并行是完全不同的东西。在研究这个问题时，我在 StackOverflow 上发现了一场关于并发生与并行性是不同事物的争论。有人认为并发是并行的超集，因为并发指的是一组用于管理多个线程的方法。这可能是某些计算机科学书籍处理这个主题的方式。

需要清晰性的要求迫使我们选择一个定义。我将选择与我编程形成期最接近的定义：**并发**是指多个操作似乎同时运行，而**并行**是指它们确实如此。这种差异，虽然看似简单，但在设计程序时会导致意图上的差异。当我们设计一个预期将并行运行的程序时，我们定义可以并行运行的运算，并确定它们的顺序。我们试图通过将更大的任务分割成可以独立运行的部分来从 CPU 中挤出时间，这些部分不会相互影响太多。当我们设计一个预期将并发运行的程序时，我们通过将较长的任务推入 CPU 的空闲时间来优化响应时间。

这两种编程模型都具有挑战性，尽管方式不同。让我们提醒自己使用它们时面临的常见问题。

# 并行和并发中的常见问题

我坚信软件开发的基本问题是将系统的静态视图——代码——在心理上转化为其动态行为，或者程序运行时所做的操作。程序员每次考虑更改时都会在脑海中运行代码，通常是自动的，但总是以精神能量为代价。这就是我相信像**测试驱动开发**（**TDD**）和增量设计这样的实践是有用的原因；它们允许我们将部分精神能量支出从大脑转移到重复运行测试上。

这个基本问题对于单个线程来说已经很困难了，但对于并行或并发设计来说，它又增加了一个新的挑战层级。我们不仅需要想象代码会做什么，还需要想象代码将如何与其他同时运行的代码部分交互。因此，想象力和理解并行执行所需的脑力是第一个挑战。

然后，还有纯粹的技术挑战。

当资源被共享时，资源管理变得更加困难，尤其是在多个线程可以修改值的情况下。一个线程可能正在使用另一个线程已经更改的值，从而导致错误的结果。一个内存地址可能被一个线程释放，然后另一个线程尝试读取或写入它。

共享相同的基础设施也不容易。一个线程可能因为一个错误而占用所有资源，从而长时间阻塞其他线程。当程序由使用多个核心的独立任务组成时，这个问题不那么严重，但仍然会导致性能降低，因为独立任务需要在某个点上收敛。线程可能会无限期地等待彼此，或者直到超时发生。

从零开始实现处理并行或并发任务的程序是作为程序员可能需要做的最困难的事情之一。我记得有一次我花了整整一周时间调试线程间的同步问题，我知道我的技术领导和项目经理开始怀疑我的能力。我没有怀疑自己，但我不喜欢最终解决问题所花费的时间那么长。

因此，出现了库和模式，帮助我们实现并发和并行程序。大多数都邀请我们向一个方法传递一个表示线程的函数，该方法解决线程同步的一些复杂性。这是通过将我们可能需要的任务分成任务类型来实现的。此外，由 Hadoop 实现并由函数式编程启发的架构模型 MapReduce 也帮助我们处理大规模并行化。

正如我们所见，如果不讨论函数式编程方法，我们就无法讨论现代并行编程的途径。

# 函数式编程拯救了！

正如我们所见，并行和并发任务的一个问题是资源共享。在纯函数式编程中，通过不可变性直接解决了这个问题。由于一切都是不可变的默认值，并且任何对值的更改都是通过指向更改的值而不是修改初始值来实现的，因此线程永远不会面临修改其他线程使用的数据的风险。我们在讨论 C++中可用的不同范例时讨论了如何实现这一点。

但还有更多：函数式编程直接提供了可并行化的算法。当引入函数式算法和允许你在并行集合上运行操作的执行策略时，C++标准化委员会也认识到了这一点。

让我们来看一个简单的例子：我们想要计算一个集合中值的平方和。这种算法的函数式版本是一个典型的 map-reduce：首先，我们传入初始集合，将其映射到一个包含值平方的集合，然后通过添加所有元素来减少它。在 STL 中，这些操作分别由**std::transform**和**std::reduce**实现。一个结合它们的版本在**std::transform_reduce**中可用，但我们现在忽略它，以便使例子更相关。

函数看起来是这样的：

```cpp
long long sumOfSquares(const vector<int> numbers){
     vector<long long> squaredNumbers(numbers.size());
     auto squareNumber = [](const long it ){ return it * it; };
     transform(numbers.begin(), numbers.end(), squaredNumbers.begin(), squareNumber);
     return reduce(squaredNumbers.begin(), squaredNumbers.end(), 0);
}
TEST_CASE("sum of squares in parallel") {
        vector<int> numbers{234, 423, 345, 212, 112, 2412};
        CHECK_EQ(6227942, sumOfSquares(numbers));
}
```

为了并行运行这些操作，我们只需要向函数式算法添加一个参数，该参数指定了执行策略。我们将使用的执行策略是**std::execution::par**，这是标准库提供的**std::execution_parallel**的一个实例，它指定算法需要并行运行：

```cpp
long long sumOfSquares(const vector<int> numbers){
     vector<long long> squaredNumbers(numbers.size());
     auto squareNumber = [](const long it ){ return it * it; };
     transform(std::execution::par, numbers.begin(), numbers.end(), squaredNumbers.begin(), squareNumber);
     return reduce(std::execution::par, squaredNumbers.begin(), squaredNumbers.end(), 0);
}
```

从这个例子中，我们可以注意到几点。

首先，当你使用函数式编程时，在不同的执行策略之间切换非常容易。这使得我们能够更轻松地修复与并行化相关的问题，并优化代码。在所有情况下，并行运行算法并不一定比顺序执行更好。对于小数量或短集合，启动线程和管理它们所使用的资源可能比节省的时间更大。

第二，我们可以将执行策略作为参数或作为通用配置。这将使我们能够测试算法在独立于线程同步的情况下顺序执行。它还允许我们根据与输入数据相关的几个因素在运行时决定使用哪种策略。

第三，这些执行策略中的每一个都对你的代码施加了限制。例如，我们在这里使用的并行策略要求迭代器在过程中不被无效化，因此禁止写访问和**std::back_inserter**的使用。STL 中除了**std::execution::parallel_policy**、**std::execution::sequenced_policy**、**std::execution::parallel_unsequenced_policy**和**std::execution::unsequenced_policy**之外，还有其他执行策略，需要注意的是标准化委员会可能会为**std::parallel::cuda**和**std::parallel::opencl**添加内置策略。每个策略都有其局限性和约束，因此最可移植的代码是用于最大不变性和函数式算法的代码。

第四，算法按顺序运行，但每个算法都是并行化的。如果我们需要从我们的计算资源中获得更多，我们要么使用组合的**std::transform_reduce**算法，要么编写自己的算法将这两个算法结合起来。再次强调，并行运行代码是一个权衡：一些计算资源将用于启动和同步线程，对于某些配置，这可能不会带来很大的好处。

最后，第五点是映射-归约模式非常强大。任何一元函数都可以用于**map**，任何二元函数都可以用于**reduce**，我们可以绑定需要更多值的函数的参数，直到我们得到一元或二元函数。映射和归约可以以多种方式链式连接。如果你开始将你的程序视为输入/输出数据，你会发现我们所有的程序都可以写成输入/函数式转换/输出，其中许多函数式转换是**map**/**reduce**操作。这种认识导致了一个非常强大的编程模型，因为我们可以为算法的所有部分或部分开启或关闭并行化。偶尔，我们可能想要编写自己的算法，以优化代码中重要部分的并行化，但我们大多数情况下都可以免费获得。

唯一的缺点是我们需要使用不可变数据和函数式算法。

我们迄今为止讨论的设计风格是数据驱动的，因为它关注数据结构和它们的转换。正如在软件设计和架构方面，我们总是可以选择关注行为。确实，一种将程序分割成行为并允许并行编程的设计风格以 Actor Model 的形式出现。

# Actor Model

我们周围的世界以非常自然的方式并行移动。每一棵树、每一株植物或每一个人都在做自己的事情，偶尔它们会互动，涉及的事物会发生变化。因此，我们已经有了一个关于并行程序如何工作的心理模型：独立的实体封装它们的行为，并以某种方式在确保适当同步的基础设施上进行通信。

这个想法导致了 1973 年卡尔·休伊特（Carl Hewitt）创建 Actor Model。这个模型将程序分割成可以进行以下三种操作的 actor：

+   向其他 actor 发送消息

+   创建新的 actor

+   定义 actor 接收的下一条消息的行为

每个 actor 都有一个地址，在概念上类似于电子邮件地址，actor 只能与它们有地址的 actor 通信。这个地址可以包含在消息中，或者通过创建一个新的 actor 来获得。

Actor 模型将通信机制与每个 actor 的功能性分开。这导致了允许我们编写高度可并行化代码的实现，而无需处理线程原语。

C++最古老且最稳定的实现是 CAF（[`www.actor-framework.org/`](https://www.actor-framework.org/)）。一个较新的替代方案是来自阿里巴巴的**Hiactor**（[`github.com/alibaba/hiactor`](https://github.com/alibaba/hiactor)）。然而，最知名的实现来自 Java 世界：**Akka** **工具包**（[`akka.io/`](https://akka.io/)）。

让我们看看使用 CAF 实现两个 actor 之间聊天的一个简单示例。以下代码定义了一个 actor 的行为为一个 Lambda 表达式，创建了两个聊天 actor，并在它们之间发送消息。每个 actor 将它们的消息写入控制台：

```cpp
behavior chatter(event_based_actor* self, const string& name) {
return {
[=] (const string& msg) {
cout << name << " received: " << msg << endl;
}
};
}
void caf_main(actor_system& system) {
          auto alice = system.spawn(chatter, "Alice");
          auto bob = system.spawn(chatter, "Bob");
          scoped_actor self{system};
          self->send(alice, "Hello Alice!");
          self->send(bob, "Hello Bob!");
          self->send(alice, "How are you?");
          self->send(bob, "I'm good, thanks!");
          sleep_for(seconds(1));
}
CAF_MAIN()
```

运行此代码会导致不同的输出。最好的输出是我们预期的：

```cpp
Bob received: Hello Bob!
Alice received: Hello Alice!
Alice received: How are you?
Bob received: I'm good, thanks!
```

然而，重复运行代码会导致各种结果，如下所示：

```cpp
Bob received: Hello Bob!
Bob received: I'm good, thanks!
Alice received: Hello Alice!
Alice received: How are you?
```

我们还可以收到更糟糕的输出：

```cpp
Alice received: Hello Alice!
BobAlice received: How are you? received: Hello Bob!
Bob received: I'm good, thanks!
```

这些结果清楚地表明 actor 是并行运行的。它还表明，并行编程可以在这些框架的魔法之下掩盖其复杂性。

然而，actor 模型为我们提供了一种以对象的形式来思考并行编程的方法，这些对象响应请求，并允许我们选择所需的 actor 类型以及最适合我们系统的通信类型。前面的示例展示了一个基于事件的 actor，它接收异步消息，但该框架支持阻塞消息和多种类型的 actor，这取决于它们的生命周期。

actor 模型的一个优点是我们可以在不同的计算机上分布 actor，从而相对容易地扩展模型。当然，这意味着我们直接面对分布式系统的挑战，从使用此模型的第一行代码开始。

有了这些，我们已经看到了在标准库中使用以及通过使用值得尊敬的 actor 模型今天可以实现的可能性。但仍然有什么是不可能的？

# 我们目前还无法做到的是

正如你所见，使用并行和并发代码并不像“*编写你想要的代码，让工具和编译器来理解它*”那样简单。也许在 AI 的干预下，我们将来能够做到这一点，尽管根据我目前使用代码助手的经验，我必须说这看起来还非常遥远。

相反，你必须为选择的编程模型结构化你的代码。如果你一开始就把代码库作为一个单线程应用程序编写，并且不使用函数式结构，那么改变它将会很困难。我看到对象和 actor 之间有相似之处，从理论上讲，可能将每个对象转换成 actor，每个方法转换成事件，但这似乎过于理想化。现实是，当我们从同步系统切换到基于事件的系统时，还有很多事情可能会出错，其中很多都非常难以调试，并且需要深入理解 actor 模型以及你为 actor 使用的框架。

你最好的选择是在你选择的范式内重新设计应用程序：要么是数据中心的函数式，要么是行为中心的 actor 模型。

在数据中心的范式下，你查看输入的数据以及到达所需输出的所需转换集合。这些转换中的每一个都是不可变的，因此以数据作为输入并返回另一个数据结构作为输出。正如我们所见，这些转换中的每一个都是可并行的。偶尔，我们需要自己的算法或优化一些现有的算法，然后我们可以编写遵循相同模式的自己的实现。我们可以使用执行策略来微调系统，最终得到一个高度可定制且相对容易优化的系统。

使用以行为中心的范式，你将你的对象视为接收消息的演员。这更接近艾伦·凯对面向对象编程的原始观点。正如在[`www.purl.org/stefan_ram/pub/doc_kay_oop_en`](https://www.purl.org/stefan_ram/pub/doc_kay_oop_en)的电子邮件交流中所述，这是一种专注于消息而不是类的愿景，并在 Smalltalk 中得到了最紧密的实现。你从底层开始构建你的应用程序，使用演员及其消息机制，并测试输出是否符合预期。你需要详细了解可用的演员类型和消息类型，以便你可以选择适合你问题的那些。正如这个例子所示，演员并不保证执行顺序，这可能是或可能不是你系统的一个问题。这导致了一个高度可扩展的系统，但同时也更难以理解和调试。

这意味着我们不能自动将编写为同步和单线程的应用程序转换为并行或并发系统。大多数情况下，需要重新设计。

# 摘要

在 C++中实现并行性和并发性有简单的方法吗？这比过去容易，因为我们很少需要创建自己的线程并处理它们的同步，除非我们正在构建基础设施代码。我们不一定需要外部库或工具，因为 STL 支持许多算法的并行执行。

然而，我们无法避免并行和并发编程的基本复杂性。利用它的程序需要以不同的方式构建，有额外的约束，需要不同的思维方式和不同的设计范式。这不是 C++的问题——这是任何尝试并行化的一个问题。

因此，结论是，如果我们做出正确的选择，事情可以比过去更简单，但它仍然非常复杂。

在下一章中，我们将探讨最快形式的 C++是否是内联汇编。
