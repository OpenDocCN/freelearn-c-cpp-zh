- en: Advanced Tools and Upcoming Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级工具和即将推出的功能
- en: WebAssembly's ecosystem is constantly growing and evolving. Developers have
    seen the potential for WebAssembly. They build tools to improve the development
    experience or output Wasm modules from their language of choice (albeit with some
    limitations).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 的生态系统正在不断增长和演变。开发者们已经看到了 WebAssembly 的潜力。他们构建工具来改善开发体验或从他们选择的语言（尽管存在一些限制）中输出
    Wasm 模块。
- en: In this chapter, we'll evaluate the underlying technologies that make WebAssembly
    tick. We'll also review tools you can use in the browser and cover an advanced
    use case that utilizes Web Workers. Finally, we'll quickly review upcoming features
    and proposals that are on the roadmap for WebAssembly.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将评估使 WebAssembly 运行的底层技术。我们还将回顾您可以在浏览器中使用的工具，并涵盖一个利用 Web Workers 的高级用例。最后，我们将快速回顾
    WebAssembly 路线图上的即将推出的功能和提案。
- en: 'Our goal for this chapter is to understand the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本章的目标是理解以下内容：
- en: How WABT and Binaryen fit into the build process and what they can be used for
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WABT 和 Binaryen 如何融入构建过程以及它们可以用于什么
- en: How to compile a WebAssembly module using LLVM (rather than Emscripten)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 LLVM（而不是 Emscripten）编译 WebAssembly 模块
- en: Online tools such as WasmFiddle and other useful tooling online
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线工具，如 WasmFiddle 和其他在线实用工具
- en: How to utilize Web Workers to run WebAssembly in parallel
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何利用 Web Workers 并行运行 WebAssembly
- en: Upcoming features (proposed and in progress) that will be integrated into WebAssembly
    in the future
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即将集成到 WebAssembly 中的功能（已提出和正在进行）
- en: WABT and Binaryen
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WABT 和 Binaryen
- en: WABT and Binaryen allow developers to work with source files and develop tooling
    for WebAssembly. If you're interested in working with WebAssembly at a lower level,
    these tools provide the means for accomplishing such a goal. In this section,
    we'll evaluate these tools in greater detail and review the purpose and capabilities
    of each one.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: WABT 和 Binaryen 允许开发者处理源文件并为 WebAssembly 开发工具。如果您对在较低级别上与 WebAssembly 一起工作感兴趣，这些工具提供了实现这一目标的方法。在本节中，我们将更详细地评估这些工具，并回顾每个工具的目的和能力。
- en: WABT – the WebAssembly binary toolkit
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WABT – WebAssembly 二进制工具包
- en: WABT's focus is on the manipulation of WebAssembly binary (`.wasm`) files and
    text (`.wat`) files, as well as conversion between the two formats. WABT provides
    tools to translate **Wat to Wasm** (**wat2wasm**) and vice versa (**wasm2wat**),
    as well as a tool to convert a Wasm file to a C source and header file (**wasm2c**).
    You can view the entire list of tools in the README file of the WABT GitHub repository
    at [https://github.com/WebAssembly/wabt](https://github.com/WebAssembly/wabt).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: WABT 的重点是操作 WebAssembly 二进制（`.wasm`）文件和文本（`.wat`）文件，以及两种格式之间的转换。WABT 提供了将 **Wat
    转换为 Wasm**（**wat2wasm**）和相反（**wasm2wat**）的工具，以及将 Wasm 文件转换为 C 源文件和头文件的工具（**wasm2c**）。您可以在
    WABT GitHub 仓库的 README 文件中查看所有工具的完整列表，网址为 [https://github.com/WebAssembly/wabt](https://github.com/WebAssembly/wabt)。
- en: 'One example use case of WABT is the *WebAssembly Toolkit for VS Code* extension
    we installed in [Chapter 3](706c89b2-c820-4fb0-906c-2f2e49602d27.xhtml), *Setting
    Up a Development Environment*. The extension depends on WABT to view the text
    format associated with a `.wasm` file. The repository provides links to wat2wasm
    and wasm2wat demos, which you can use to test the validity of a Wat program or
    interact with a compiled binary using JavaScript. The following screenshot contains
    the Wat and JavaScript instantiation code from the wat2wasm demo:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: WABT 的一个示例用例是我们在 [第 3 章](706c89b2-c820-4fb0-906c-2f2e49602d27.xhtml) 中安装的 *WebAssembly
    Toolkit for VS Code* 扩展，*设置开发环境*。该扩展依赖于 WABT 来查看与 `.wasm` 文件关联的文本格式。仓库提供了 wat2wasm
    和 wasm2wat 演示的链接，您可以使用这些链接来测试 Wat 程序的有效性或使用 JavaScript 与编译后的二进制文件交互。以下截图包含 wat2wasm
    演示中的 Wat 和 JavaScript 实例化代码：
- en: '![](img/0c941193-4415-400d-9085-4d78bd80a19a.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c941193-4415-400d-9085-4d78bd80a19a.png)'
- en: Wat and JavaScript loading code from wat2wasm's "simple" example
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从 wat2wasm 的 "simple" 示例中加载 Wat 和 JavaScript 代码
- en: In line `3` of the JS panel, you may have noticed that the `addTwo()` function
    from `wasmInstance.exports` isn't prefixed with a `_`. Emscripten adds the `_`
    automatically in the compilation process. You could omit the `_` by converting
    the `.wasm` file to a `.wat`, updating the function names, and converting it back
    to `.wasm` using the WABT, although this wouldn't be very practical. The WABT
    simplifies the process of transforming text format to binary format and vice versa.
    If you want to build compilation tooling for WebAssembly, you'd use Binaryen,
    which we will cover next.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JS 面板的第 `3` 行，你可能已经注意到从 `wasmInstance.exports` 中来的 `addTwo()` 函数没有以 `_` 开头。Emscripten
    在编译过程中会自动添加 `_`。你可以通过将 `.wasm` 文件转换为 `.wat`，更新函数名称，然后使用 WABT 将其转换回 `.wasm` 来省略
    `_`，尽管这不太实用。WABT 简化了将文本格式转换为二进制格式以及相反的过程。如果你想为 WebAssembly 构建编译工具，你会使用 Binaryen，我们将在下一节中介绍。
- en: Binaryen
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Binaryen
- en: 'Binaryen''s GitHub page at [https://github.com/WebAssembly/binaryen](https://github.com/WebAssembly/binaryen)
    describes Binaryen as a compiler and toolchain infrastructure library for WebAssembly,
    written in C++. It aims to make compiling to WebAssembly easy, fast, and effective.
    It achieves these aims by providing a simple C API, an internal IR, and an optimizer.
    Just as with the WABT, Binaryen provides an extensive suite of tools for developing
    WebAssembly tooling. The following list describes a subset of the tools that Binaryen
    provides:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Binaryen 的 GitHub 页面 [https://github.com/WebAssembly/binaryen](https://github.com/WebAssembly/binaryen)
    将 Binaryen 描述为用 C++ 编写的 WebAssembly 编译器和工具链基础设施库。它的目标是使编译到 WebAssembly 变得简单、快速和有效。它通过提供简单的
    C API、内部 IR 和优化器来实现这些目标。就像 WABT 一样，Binaryen 为开发 WebAssembly 工具提供了一套广泛的工具。以下列表描述了
    Binaryen 提供的工具子集：
- en: '**wasm-shell**: Tool capable of loading and interpreting WebAssembly'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**wasm-shell**：能够加载和解释 WebAssembly 的工具'
- en: '**asm2wasm**: Compiles asm.js code to a Wasm module'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**asm2wasm**：将 asm.js 代码编译为 Wasm 模块'
- en: '**wasm2js**: Compiles a Wasm module to JavaScript'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**wasm2js**：将 Wasm 模块编译为 JavaScript'
- en: '**wasm-merge**: Combines multiple Wasm files into one'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**wasm-merge**：将多个 Wasm 文件合并为一个'
- en: '**wasm.js**: JavaScript library that includes the Binaryen interpreter, asm2wasm,
    the Wat parser, and other Binaryen tools'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**wasm.js**：包含 Binaryen 解释器、asm2wasm、Wat 解析器和其他 Binaryen 工具的 JavaScript 库'
- en: '**binaryen.js**: JavaScript library that provides a JavaScript interface for
    the Binaryen toolchain'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**binaryen.js**：提供 Binaryen 工具链 JavaScript 接口的 JavaScript 库'
- en: The wasm.js and binaryen.js tools are of particular interest for JavaScript
    developers interested in building WebAssembly tooling. The `binaryen.js` library
    is available as an `npm` package ([https://www.npmjs.com/package/binaryen](https://www.npmjs.com/package/binaryen)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对构建 WebAssembly 工具感兴趣的 JavaScript 开发者来说，wasm.js 和 binaryen.js 工具特别有趣。`binaryen.js`
    库作为一个 `npm` 包([https://www.npmjs.com/package/binaryen](https://www.npmjs.com/package/binaryen))提供。
- en: An excellent example of `binaryen.js` usage is AssemblyScript ([https://github.com/AssemblyScript/assemblyscript](https://github.com/AssemblyScript/assemblyscript)).
    AssemblyScript is a strictly typed subset of TypeScript that generates WebAssembly
    modules. The library comes packaged with a CLI to quickly scaffold new projects
    and manage the build step. In the *Compiling with LLVM *section, we'll cover how
    to compile Wasm modules using LLVM.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`binaryen.js` 的一个优秀示例是 AssemblyScript ([https://github.com/AssemblyScript/assemblyscript](https://github.com/AssemblyScript/assemblyscript))。AssemblyScript
    是 TypeScript 的严格类型子集，可以生成 WebAssembly 模块。该库附带了一个 CLI，可以快速搭建新项目并管理构建步骤。在 *使用 LLVM
    编译* 部分中，我们将介绍如何使用 LLVM 编译 Wasm 模块。'
- en: Compiling with LLVM
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 LLVM 编译
- en: In [Chapter 1, ](15ca4834-5544-4dd8-b307-f0bc95c63a21.xhtml)*What is WebAssembly?*,
    we discussed the relationship between Emscripten's EMSDK and LLVM. Emscripten
    uses LLVM and Clang to compile C/C++ down to LLVM bitcode. The Emscripten compiler
    (`emcc`) compiles that bitcode to asm.js, which is passed to Binaryen to generate
    a Wasm file. If you're interested in using LLVM, you can compile C/C++ to Wasm
    without installing the EMSDK. In this section, we will review the process for
    enabling Wasm compilation using LLVM. After compiling some example C++ code to
    a Wasm file, we'll try it out in the browser.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 1 章，](15ca4834-5544-4dd8-b307-f0bc95c63a21.xhtml)*什么是 WebAssembly？* 中，我们讨论了
    Emscripten 的 EMSDK 和 LLVM 之间的关系。Emscripten 使用 LLVM 和 Clang 将 C/C++ 编译成 LLVM 位码。Emscripten
    编译器 (`emcc`) 将该位码编译成 asm.js，然后传递给 Binaryen 生成 Wasm 文件。如果你对使用 LLVM 感兴趣，你可以编译 C/C++
    到 Wasm 而不必安装 EMSDK。在本节中，我们将回顾启用 Wasm 编译使用 LLVM 的过程。在将一些示例 C++ 代码编译为 Wasm 文件后，我们将在浏览器中尝试运行它。
- en: The installation process
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装过程
- en: 'If you want to compile WebAssembly modules using LLVM, several tools need to
    be installed and configured. Getting these tools working together correctly can
    be an arduous and time-consuming process. Fortunately, someone went through the
    trouble of making this process much simpler. Daniel Wirtz created an `npm` package
    named `webassembly` ([https://www.npmjs.com/package/webassembly](https://www.npmjs.com/package/webassembly))
    that can perform the following operations (with the corresponding CLI commands):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用LLVM编译WebAssembly模块，需要安装和配置几个工具。将这些工具正确地协同工作可能是一个既困难又耗时的过程。幸运的是，有人费心使这个过程变得更加简单。Daniel
    Wirtz创建了一个名为`webassembly`的`npm`包（[https://www.npmjs.com/package/webassembly](https://www.npmjs.com/package/webassembly)），它可以执行以下操作（对应相应的CLI命令）：
- en: Compile C/C++ code to a WebAssembly module (`wa compile`)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将C/C++代码编译成WebAssembly模块（`wa compile`）
- en: Link multiple WebAssembly modules to one (`wa link`)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多个WebAssembly模块链接成一个（`wa link`）
- en: Decompile a WebAssembly module to text format (`wa disassemble`)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将WebAssembly模块反汇编成文本格式（`wa disassemble`）
- en: Assemble WebAssembly text format to a module (`wa assemble`)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将WebAssembly文本格式汇编成模块（`wa assemble`）
- en: 'The library is using Binaryen, Clang, LLVM, and additional LLVM tools behind
    the scenes. We''ll install this package globally to ensure we have access to the
    `wa` command. To install, open a terminal instance and run the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 库在幕后使用Binaryen、Clang、LLVM和额外的LLVM工具。我们将全局安装此包以确保我们可以访问`wa`命令。安装时，打开一个终端实例并运行以下命令：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It may take a few minutes to install any required dependencies. Once complete,
    run the following command to validate the installation:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 安装任何所需的依赖可能需要几分钟时间。一旦完成，运行以下命令以验证安装：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You should see the following in terminal:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在终端中看到以下内容：
- en: '![](img/02098a68-e5fa-4ef1-8370-ba78bed728b4.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/02098a68-e5fa-4ef1-8370-ba78bed728b4.png)'
- en: Output of the wa command
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: wa命令的输出
- en: You should be ready to start compiling Wasm modules. Let's move on to the example
    code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该准备好开始编译Wasm模块了。让我们继续到示例代码。
- en: The example code
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: To test out the compiler, we're going to use a slightly modified version of
    the `without-glue.c` file from the *Interacting with JavaScript without glue code*
    section of [Chapter 5](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml), *Creating
    and Loading a WebAssembly Module*. The code for this section is located in the
    `/chapter-10-advanced-tools/compile-with-llvm` directory of the `learn-webassembly`
    repository. Follow the following instructions to create the files necessary for
    the compiler test. Let's start with the C++ file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试编译器，我们将使用[第5章](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml)“创建和加载WebAssembly模块”中“无需胶水代码与JavaScript交互”部分的`without-glue.c`文件的略微修改版本。此部分的代码位于`learn-webassembly`仓库的`/chapter-10-advanced-tools/compile-with-llvm`目录中。按照以下说明创建编译器测试所需的文件。让我们从C++文件开始。
- en: The C++ file
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++文件
- en: 'Create a new directory in your `/book-examples` directory named `/compile-with-llvm`.
    Create a new file in the `/compile-with-llvm` directory named `main.cpp` and populate
    it with the following contents:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`/book-examples`目录中创建一个名为`/compile-with-llvm`的新目录。在`/compile-with-llvm`目录中创建一个名为`main.cpp`的新文件，并填充以下内容：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code in this file is almost identical to the contents of `without-glue.c`
    from [Chapter 5](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml), *Creating and Loading
    a WebAssembly Module*. The comments have been removed from the file and the imported/exported
    functions are wrapped in an `extern "C"` block. The `__attribute__((visibility("default")))`
    lines are macro statements (similar to `EMSCRIPTEN_KEEPALIVE`) that ensure the
    functions aren't removed from the compiled output during the dead-code elimination
    step. Just as with prior examples, we'll interact with the compiled Wasm module
    through an HTML file. Let's create that next.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件中的代码几乎与[第5章](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml)“创建和加载WebAssembly模块”中`without-glue.c`的内容相同。文件中的注释已被移除，导入/导出函数被包裹在一个`extern
    "C"`块中。`__attribute__((visibility("default")))`行是宏语句（类似于`EMSCRIPTEN_KEEPALIVE`），确保在死代码消除步骤中函数不会被从编译输出中移除。就像先前的示例一样，我们将通过HTML文件与编译后的Wasm模块进行交互。让我们创建一个。
- en: The HTML file
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML文件
- en: 'Create a file named `index.html` in the `/compile-with-llvm` directory and
    populate it with the following contents:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/compile-with-llvm`目录中创建一个名为`index.html`的文件，并填充以下内容：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The contents of this file are very similar to the `without-glue.html` file from
    [Chapter 5](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml), *Creating and Loading
    a WebAssembly Module*. Instead of using the `loadWasm()` function from the `/common/load-wasm.js`
    file, we're using the `WebAssembly.instantiateStreaming()` function. This allows
    us to omit an additional `<script>` element and serve the files directly from
    the `/compile-with-llvm` directory.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件的内容与 [第 5 章](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml) 的 `without-glue.html`
    文件非常相似，*创建和加载 WebAssembly 模块*。我们不是使用 `/common/load-wasm.js` 文件中的 `loadWasm()`
    函数，而是使用 `WebAssembly.instantiateStreaming()` 函数。这允许我们省略一个额外的 `<script>` 元素，并直接从
    `/compile-with-llvm` 目录提供文件。
- en: The `_` is omitted from the `jsFillRect` and `jsClearRect` functions passed
    into the `importObj`. We can omit the `_` for the functions present on the `instance.exports`
    object as well. LLVM doesn't prefix any of the data/functions passed in or out
    of the module with a `_`. In the next section, we'll compile `main.cpp` and interact
    with the resultant Wasm file in the browser.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`_` 符号被省略了，在传递给 `importObj` 的 `jsFillRect` 和 `jsClearRect` 函数中。我们也可以省略 `instance.exports`
    对象上存在的函数的 `_` 前缀。LLVM 不会在传递进或出模块的数据/函数前加上 `_` 前缀。在下一节中，我们将编译 `main.cpp` 并在浏览器中与之交互。'
- en: Compiling and running the example
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和运行示例
- en: 'We installed the `webassembly npm` package with the `-g` flag, so the `wa`
    command should be available in the terminal. Open a terminal instance in the `/compile-with-llvm`
    directory and run the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `-g` 标志安装了 `webassembly npm` 包，所以 `wa` 命令应该在终端中可用。在 `/compile-with-llvm`
    目录中打开一个终端实例并运行以下命令：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You should see a file named `main.wasm` appear in the `compile-with-llvm` folder
    of VS Code''s file explorer. To ensure the Wasm module compiled correctly, run
    the following command within the `/compile-with-llvm` directory:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在 VS Code 的文件资源管理器中 `compile-with-llvm` 文件夹中看到一个名为 `main.wasm` 的文件。为确保 Wasm
    模块编译正确，请在 `/compile-with-llvm` 目录下运行以下命令：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you navigate to `http://127.0.0.1:8080/index.html` in your browser, you
    should see the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你浏览到 `http://127.0.0.1:8080/index.html`，你应该会看到以下内容：
- en: '![](img/bb069bef-1df9-437f-b2ce-8622b845ef2c.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bb069bef-1df9-437f-b2ce-8622b845ef2c.png)'
- en: LLVM compiled module running in the browser
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器中运行的 LLVM 编译模块
- en: Online tooling
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在线工具
- en: The installation and configuration process for compiling WebAssembly modules
    locally is, admittedly, a little cumbersome. Fortunately, there are several online
    tools available that allow you to develop and interact with WebAssembly in the
    browser. In this section, we'll review those tools and discuss the functionality
    each one provides.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 编译 WebAssembly 模块本地的安装和配置过程，诚然，有些繁琐。幸运的是，有几个在线工具可供你在浏览器中开发和交互 WebAssembly。在本节中，我们将回顾这些工具并讨论每个工具提供的功能。
- en: WasmFiddle
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WasmFiddle
- en: In the *Connecting the dots with WasmFiddle* section in [Chapter 2](0b30dfc9-4624-48b6-a968-0342540d1ef5.xhtml), *Elements
    of WebAssembly* *- Wat, Wasm, and the JavaScript API*, we used WasmFiddle to compile
    a simple C function to Wasm and interact with it using JavaScript. WasmFiddle
    provides a C/C++ editor, JavaScript editor, Wat/x86 viewer, and JavaScript output
    panel. You can also interact with the `<canvas>` if desired. WasmFiddle uses LLVM
    to generate the Wasm modules, which is why the imports and exports aren't prefixed
    with a `_`. You can interact with WasmFiddle at [https://wasdk.github.io/WasmFiddle](https://wasdk.github.io/WasmFiddle).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2 章](0b30dfc9-4624-48b6-a968-0342540d1ef5.xhtml) 的 *Connecting the dots
    with WasmFiddle* 部分，*WebAssembly 元素 - Wat, Wasm 和 JavaScript API*，我们使用 WasmFiddle
    将简单的 C 函数编译成 Wasm 并使用 JavaScript 与之交互。WasmFiddle 提供了 C/C++ 编辑器、JavaScript 编辑器、Wat/x86
    查看器和 JavaScript 输出面板。如果需要，你也可以与 `<canvas>` 交互。WasmFiddle 使用 LLVM 生成 Wasm 模块，这就是为什么导入和导出没有以
    `_` 前缀。你可以在 [https://wasdk.github.io/WasmFiddle](https://wasdk.github.io/WasmFiddle)
    与 WasmFiddle 交互。
- en: WebAssembly Explorer
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebAssembly 探索器
- en: 'WebAssembly Explorer, located at [https://mbebenita.github.io/WasmExplorer](https://mbebenita.github.io/WasmExplorer),
    provides similar functionality to WasmFiddle. It allows you to compile C or C++
    to a Wasm module and view the corresponding Wat. However, WebAssembly Explorer
    provides additional functionality not present in WasmFiddle. For example, you
    can compile C or C++ to Wasm and view the corresponding Firefox x86 and LLVM x86
    code. You can select from a list of code examples and specify the optimization
    level (`-O` flag in `emcc`). It also provides a button that allows you to import
    the code into WasmFiddle:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly Explorer，位于[https://mbebenita.github.io/WasmExplorer](https://mbebenita.github.io/WasmExplorer)，提供了与WasmFiddle类似的功能。它允许您将C或C++编译成Wasm模块并查看相应的Wat。然而，WebAssembly
    Explorer提供了WasmFiddle中没有的附加功能。例如，您可以将C或C++编译成Wasm并查看相应的Firefox x86和LLVM x86代码。您可以从代码示例列表中选择并指定优化级别（`emcc`中的`-O`标志）。它还提供了一个按钮，允许您将代码导入WasmFiddle：
- en: '![](img/cbe79b3c-c5b9-41b1-b817-e71e0e85c3fa.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cbe79b3c-c5b9-41b1-b817-e71e0e85c3fa.png)'
- en: Screenshot of WebAssembly Explorer
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly Explorer的截图
- en: WebAssembly Studio
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebAssembly Studio
- en: 'WebAssembly Studio, located at [https://webassembly.studio](https://webassembly.studio),
    is a feature-rich editor and development environment. You can create C, Rust,
    and AssemblyScript projects. It provides the capabilities to build and run code
    within the browser and integrates well with GitHub. WebAssembly Studio enables
    you to build a web application without having to install and configure the required
    WebAssembly tooling locally:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly Studio，位于[https://webassembly.studio](https://webassembly.studio)，是一个功能丰富的编辑器和开发环境。您可以创建C、Rust和AssemblyScript项目。它提供了在浏览器内构建和运行代码的能力，并且与GitHub集成良好。WebAssembly
    Studio使您能够在不本地安装和配置所需的WebAssembly工具的情况下构建Web应用程序：
- en: '![](img/586895b5-ace5-4179-9423-bae1c39361ce.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/586895b5-ace5-4179-9423-bae1c39361ce.png)'
- en: Screenshot of WebAssembly Studio
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly Studio的截图
- en: In the next section, we'll demonstrate how to add parallelism to your WebAssembly
    application with Web Workers.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将演示如何使用Web Workers将并行性添加到您的WebAssembly应用程序中。
- en: Parallel Wasm with Web Workers
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Web Workers的并行Wasm
- en: The process of building a complex application that performs heavy computation
    or other resource-intensive work can benefit greatly from using **threads**. Threads
    allow you to perform operations in parallel by dividing functionality among tasks
    that run independently. At of writing this, support for threads in WebAssembly
    is in the *Feature Proposal* phase. In this phase, the specification hasn't been
    written and the feature isn't implemented. Fortunately, JavaScript provides threading
    capabilities in the form of Web Workers. In this section, we'll demonstrate how
    to use JavaScript's Web Workers API to interact with Wasm modules in separate
    threads.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 构建执行大量计算或其他资源密集型工作的复杂应用程序的过程，使用**线程**可以大大受益。线程允许您通过将功能分配给独立运行的任务来并行执行操作。截至撰写本文时，WebAssembly对线程的支持处于**特性提案**阶段。在这个阶段，规范尚未编写，该功能尚未实现。幸运的是，JavaScript以Web
    Workers的形式提供了线程功能。在本节中，我们将演示如何使用JavaScript的Web Workers API与单独线程中的Wasm模块交互。
- en: Web Workers and WebAssembly
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web Workers和WebAssembly
- en: Web Workers allow you to utilize threads in the browser, which can improve the
    performance of your application by offloading some of the logic from the main
    (UI) thread. Worker threads are also capable of performing I/O using `XMLHttpRequest`.
    Worker threads communicate with the main thread by posting messages to an event
    handler.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Web Workers允许您在浏览器中利用线程，这可以通过将一些逻辑从主（UI）线程卸载来提高应用程序的性能。工作线程也能够使用`XMLHttpRequest`执行I/O。工作线程通过向事件处理器发送消息与主线程通信。
- en: Web Workers allow us to load Wasm modules into separate threads and perform
    operations that don't hinder the performance of the UI. Web Workers do have some
    limitations. They're unable to directly manipulate the DOM or access some of the
    methods and properties on the `window` object. The messages passed between threads
    must be serialized objects, which means you can't pass functions. Now that you
    know what a worker is, let's discuss how to create one.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Web Workers允许我们将Wasm模块加载到单独的线程中，并执行不会妨碍UI性能的操作。Web Workers确实有一些限制。它们无法直接操作DOM或访问`window`对象上的一些方法和属性。线程间传递的消息必须是序列化对象，这意味着您不能传递函数。现在您已经知道了什么是工作线程，让我们讨论如何创建一个。
- en: Creating a worker
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建工作线程
- en: Before you can create a worker, you need a JavaScript file with code that runs
    in the worker thread. You can see a simple example of a worker definition file
    at [https://github.com/mdn/simple-web-worker/blob/gh-pages/worker.js](https://github.com/mdn/simple-web-worker/blob/gh-pages/worker.js).
    The file should contain a `message` event listener that performs operations when
    messages are received from other threads and responds accordingly.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建一个工作线程之前，你需要一个包含在工作线程中运行的代码的 JavaScript 文件。你可以在 [https://github.com/mdn/simple-web-worker/blob/gh-pages/worker.js](https://github.com/mdn/simple-web-worker/blob/gh-pages/worker.js)
    看到一个简单的工作线程定义文件的示例。该文件应包含一个 `message` 事件监听器，当从其他线程接收到消息时执行操作，并相应地做出响应。
- en: Once that file is created, you're ready to use it with a worker. A worker is
    created by passing a URL argument to the `Worker()` constructor. The URL can be
    a string representing the name of the file with your worker definition code, or
    constructed using a `Blob`. The `Blob` technique can be useful if you're fetching
    the worker definition code from a server. The example application demonstrates
    how to use both approaches. Let's move on to the process of integrating WebAssembly
    with Web Workers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 创建该文件后，你就可以使用它与工作线程一起使用了。创建工作线程是通过将 URL 参数传递给 `Worker()` 构造函数来完成的。URL 可以是一个表示包含你的工作线程定义代码的文件名的字符串，或者使用
    `Blob` 构造。如果你是从服务器获取工作线程定义代码，`Blob` 技术可能很有用。示例应用程序演示了如何使用这两种方法。让我们继续了解将 WebAssembly
    与 Web Workers 集成的过程。
- en: The WebAssembly workflow
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebAssembly 的工作流程
- en: 'In order to utilize Wasm modules in separate threads, the Wasm file must be
    compiled in the main thread and instantiated in a Web Worker. Let''s review this
    process in more detail:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在单独的线程中利用 Wasm 模块，Wasm 文件必须在主线程中编译并在 Web Worker 中实例化。让我们更详细地回顾这个过程：
- en: A new Web Worker (we'll refer to it as `wasmWorker`) is created using the `Worker()`
    constructor.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Worker()` 构造函数创建一个新的 Web Worker（我们将称之为 `wasmWorker`）。
- en: A fetch call is made to retrieve a `.wasm` file and the `arrayBuffer()` function
    is called on the response.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发起一个获取 `.wasm` 文件的 fetch 调用，并在响应上调用 `arrayBuffer()` 函数。
- en: The resolved value of the `arrayBuffer()` function is passed to the `WebAssembly.compile()`
    function.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`arrayBuffer()` 函数的解析值被传递给 `WebAssembly.compile()` 函数。'
- en: The `WebAssembly.compile()` function resolves with a `WebAssembly.Module` instance,
    which is included in the body of a message posted to the `wasmWorker` using the
    `postMessage()` function.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WebAssembly.compile()` 函数解析为一个 `WebAssembly.Module` 实例，该实例包含在通过 `postMessage()`
    函数发送到 `wasmWorker` 的消息体中。'
- en: Within `wasmWorker`, the `WebAssembly.Module` instance from the message body
    is passed to the `WebAssembly.instantiate()` function, which resolves with a `WebAssembly.Instance`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `wasmWorker` 中，消息体中的 `WebAssembly.Module` 实例被传递给 `WebAssembly.instantiate()`
    函数，该函数解析为一个 `WebAssembly.Instance`。
- en: The `WebAssembly.Instance` exports object is assigned to a local variable in
    `wasmWorker` and is used to call Wasm functions.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WebAssembly.Instance` 导出对象被分配给 `wasmWorker` 中的一个局部变量，并用于调用 Wasm 函数。'
- en: To call a function from the `wasmWorker` Wasm instance, you post a message to
    the worker thread with any arguments to pass to the Wasm function. Then, `wasmWorker`
    executes the function and passes the results back to the main thread. That's the
    crux of how threads are utilized in the context of Web Workers. Before we move
    on to the example application, you may need to address a limitation that Google
    Chrome imposes. Follow the instructions in the *Limitations in Google Chrome *section
    to ensure the example application works successfully.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 `wasmWorker` Wasm 实例调用函数，你需要向工作线程发送一个消息，其中包含传递给 Wasm 函数的任何参数。然后，`wasmWorker`
    执行该函数并将结果传回主线程。这就是在 Web Workers 的上下文中利用线程的核心。在我们继续到示例应用程序之前，你可能需要解决 Google Chrome
    强加的限制。按照 *Google Chrome 限制* 部分的说明，确保示例应用程序能够成功运行。
- en: Limitations in Google Chrome
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Chrome 的限制
- en: 'Google Chrome places a restriction on what can be included in the body of a
    Web Worker''s `postMessage()` function. If you tried to send a compiled `WebAssembly.Module`
    to a worker, you''d get an error and the operation would be unsuccessful. You
    can override this by setting a flag. To enable this functionality, open Google
    Chrome and enter `chrome://flags` in the address bar. Type `cloning` in the search
    box at the top of the page. You should see a list item titled WebAssembly structured
    cloning support. Select the Enabled option from the dropdown next to the list
    item and press the RELAUNCH NOW button when prompted:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Google Chrome 对 Web Worker 的 `postMessage()` 函数体中可以包含的内容有限制。如果您尝试向工人发送编译后的 `WebAssembly.Module`，您将得到一个错误，并且操作将不会成功。您可以通过设置一个标志来覆盖这个限制。要启用此功能，打开
    Google Chrome 并在地址栏中输入 `chrome://flags`。在页面顶部的搜索框中输入 `cloning`。您应该会看到一个标题为 WebAssembly
    structured cloning support 的列表项。从列表项旁边的下拉菜单中选择“启用”选项，并在提示时按“立即重新启动”按钮：
- en: '![](img/077e795e-460d-413b-b6f4-cf82e5e797b0.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/077e795e-460d-413b-b6f4-cf82e5e797b0.png)'
- en: Updating the WebAssembly flag in Google Chrome
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 Google Chrome 中的 WebAssembly 标志
- en: After Chrome restarts, you can run the example application without issue. If
    you're using Mozilla Firefox, no action is required. It supports this feature
    by default. Let's move on to the example application that demonstrates the use
    of WebAssembly in threads.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome 重新启动后，您可以无问题地运行示例应用程序。如果您使用 Mozilla Firefox，则无需采取任何行动。它默认支持此功能。让我们继续到演示在线程中使用
    WebAssembly 的示例应用程序。
- en: Overview of the code
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码概述
- en: The example application isn't much of an application. It's a simple form that
    accepts two input values and returns the sum or difference of these two values.
    The add and subtract operations are each exported from their own Wasm module instantiated
    in a worker thread. The example may be contrived, but it effectively demonstrates
    how to integrate WebAssembly into Web Workers.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 示例应用程序并不是一个真正的应用程序。它是一个简单的表单，接受两个输入值，并返回这两个值的和或差。加法和减法操作分别从在工人线程中实例化的自己的 Wasm
    模块中导出。这个例子可能有些牵强，但它有效地展示了如何将 WebAssembly 集成到 Web Workers 中。
- en: The code for this section is located in the `/chapter-10-advanced-tools/parallel-wasm`
    directory of the `learn-webassembly` repository. The following sections walk through
    each section of the code base and describe how to build the application from scratch.
    If you wish to follow along, create a folder in your `/book-examples` directory
    named `/parallel-wasm`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 本节代码位于 `learn-webassembly` 仓库的 `/chapter-10-advanced-tools/parallel-wasm` 目录中。以下各节将逐一介绍代码库的各个部分，并描述如何从头开始构建应用程序。如果您想跟上来，请在您的
    `/book-examples` 目录中创建一个名为 `/parallel-wasm` 的文件夹。
- en: The C code
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C 代码
- en: 'The example uses two worker threads: one for addition and another for subtraction.
    Consequently, we''ll need two separate Wasm modules. Create a folder named `/lib`
    in your `/parallel-wasm` directory. Within the `/lib` directory, create a file
    named `add.c` and populate it with the following contents:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 示例使用两个工作线程：一个用于加法，另一个用于减法。因此，我们需要两个独立的 Wasm 模块。在您的 `/parallel-wasm` 目录中创建一个名为
    `/lib` 的文件夹。在 `/lib` 目录中，创建一个名为 `add.c` 的文件，并填充以下内容：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create another file in `/lib` named `subtract.c` and populate it with the following
    contents:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `/lib` 中创建另一个名为 `subtract.c` 的文件，并填充以下内容：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that the function name in both files is `calculate`. This was done so we
    don't have to write any conditional logic within the worker code to determine
    the Wasm function to call. The algebraic operation is tied to a worker, so when
    we need to add two numbers, the `_calculate()` function will be called in the
    `addWorker`. This will become clearer when we review the JavaScript portion of
    the code, which we'll cover next.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，两个文件中的函数名都是 `calculate`。这样做是为了我们不需要在工人代码中编写任何条件逻辑来确定要调用的 Wasm 函数。代数运算与一个工人相关联，所以当我们需要添加两个数字时，`_calculate()`
    函数将在 `addWorker` 中被调用。当我们回顾代码的 JavaScript 部分，这将会更加清晰，我们将在下一部分进行介绍。
- en: The JavaScript code
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 代码
- en: Before we dig into the JavaScript code, create a folder named `/src` in your
    `/parallel-wasm` directory. Let's start with the file containing the code that
    runs in the worker thread.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究 JavaScript 代码之前，在您的 `/parallel-wasm` 目录中创建一个名为 `/src` 的文件夹。让我们从运行在工作线程中的代码文件开始。
- en: Defining thread execution in worker.js
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 worker.js 中定义线程执行
- en: 'Create a new file in the `/src` directory named `worker.js` and populate it
    with the following contents:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `/src` 目录中创建一个新文件名为 `worker.js`，并填充以下内容：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The code is encapsulated within the event listener for the `message` event (`self.addEventListener(...)`),
    which is raised when the `postMessage()` function is called on the corresponding
    worker. The `event` parameter in the event listener's callback function contains
    a `data` property with the contents of the message. All of the messages passed
    between threads in the application follow the **Flux Standard Action** (**FSA**)
    convention. Objects that adhere to this convention have a `type` and `payload`
    property, where `type` is a string and `payload` can be of any type. You can read
    more about the FSA at [https://github.com/redux-utilities/flux-standard-action](https://github.com/redux-utilities/flux-standard-action).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 代码被封装在对应工作线程上调用 `postMessage()` 函数时触发的 `message` 事件的事件监听器中（`self.addEventListener(...)`）。当在对应工作线程上调用
    `postMessage()` 函数时，事件监听器的回调函数中的 `event` 参数包含一个 `data` 属性，该属性包含消息的内容。应用程序中线程间传递的所有消息都遵循
    **Flux Standard Action** （**FSA**）约定。遵循此约定的对象具有 `type` 和 `payload` 属性，其中 `type`
    是一个字符串，`payload` 可以是任何类型。您可以在 [https://github.com/redux-utilities/flux-standard-action](https://github.com/redux-utilities/flux-standard-action)
    上了解更多关于 FSA 的信息。
- en: You can use any format or structure for the data you pass using the `postMessage()`
    function, as long as the data is serializable.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `postMessage()` 函数传递任何格式或结构的数据，只要数据是可序列化的即可。
- en: The `switch` statement executes an action based on the message's `type` value,
    which is a string. If the `type` is `'COMPILE_WASM_REQUEST'`, the `WebAssembly.instantiate()`
    function is called with the `payload` from the message and `importObj`. The `exports`
    object of the result is assigned to the local `wasmInstance` variable for later
    use. If the `type` is `'CALC_REQUEST'`, the `wasmInstance._calculate()` function
    is called with the `firstVal` and `secondVal` values from the `payload` object.
    The calculation code should shed some light on why the function was named `_calculate()`
    instead of `_add()` or `_subtract()`. By using a general name, the worker doesn't
    care what operation it's performing, it just calls the function to get the result.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 语句根据消息的 `type` 值执行操作，该值是一个字符串。如果 `type` 是 `''COMPILE_WASM_REQUEST''`，则使用消息中的
    `payload` 和 `importObj` 调用 `WebAssembly.instantiate()` 函数。结果 `exports` 对象被分配给本地变量
    `wasmInstance` 以供后续使用。如果 `type` 是 `''CALC_REQUEST''`，则使用 `payload` 对象中的 `firstVal`
    和 `secondVal` 值调用 `wasmInstance._calculate()` 函数。计算代码应该能解释为什么函数被命名为 `_calculate()`
    而不是 `_add()` 或 `_subtract()`。通过使用一个通用的名称，工作线程不在乎它执行的是哪种操作，它只是调用函数以获取结果。'
- en: In both cases, the worker posts a message back to the main thread using the
    `postMessage()` function. I used a `REQUEST`/`RESPONSE` convention for the `type`
    property value. This allows you to quickly identify which thread the messages
    are originating from. Messages sent from the main thread end with `_REQUEST` in
    the `type` while responses coming from the worker threads end with `_RESPONSE`.
    Let's move on to the WebAssembly interaction code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，工作线程使用 `postMessage()` 函数将消息发送回主线程。我使用了 `REQUEST`/`RESPONSE` 约定来设置 `type`
    属性的值。这允许您快速识别消息的来源线程。来自主线程的消息在 `type` 中以 `_REQUEST` 结尾，而来自工作线程的响应以 `_RESPONSE`
    结尾。让我们继续到 WebAssembly 交互代码。
- en: Interacting with Wasm in WasmWorker.js
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 WasmWorker.js 中与 Wasm 交互
- en: 'Create a new file in the `/src` directory named `WasmWorker.js` and populate
    it with the following contents:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `/src` 目录下创建一个名为 `WasmWorker.js` 的新文件，并填充以下内容：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `WasmWorker` class manages a worker thread associated with a Wasm file.
    In the `WasmWorker` constructor, a new `Worker` is created and default event listeners
    are added for the `error` and `message` events. The `initialize()` function fetches
    the `.wasm` file associated with the `name` argument, compiles it, and sends the
    resultant `WebAssembly.Module` instance to the worker thread to be instantiated.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`WasmWorker` 类管理与 Wasm 文件相关联的工作线程。在 `WasmWorker` 构造函数中，创建一个新的 `Worker` 并为 `error`
    和 `message` 事件添加默认事件监听器。`initialize()` 函数获取与 `name` 参数关联的 `.wasm` 文件，编译它，并将结果
    `WebAssembly.Module` 实例发送到工作线程以进行实例化。'
- en: The `addListenerForType()` function is used to specify a `callback` function
    (`listener`) to execute when the `type` field in the message response matches
    the `type` argument passed to the function. This is required to capture the result
    of the `_calculate()` function from the worker thread.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `addListenerForType()` 函数指定一个 `callback` 函数（`listener`），当消息响应中的 `type` 字段与函数传递给函数的
    `type` 参数匹配时执行该函数。这是捕获工作线程中 `_calculate()` 函数结果所必需的。
- en: Finally, the `calculate()` function in `WasmWorker` posts a message to the worker
    thread with the `firstVal` and `secondVal` arguments passed in from the `<input>`
    elements on the `<form>`. Let's move on to the application loading code to see
    how `WasmWorker` interacts with the UI.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`WasmWorker`中的`calculate()`函数将`firstVal`和`secondVal`参数（从`<form>`中的`<input>`元素传递进来）发送到工作线程。让我们继续查看应用程序加载代码，看看`WasmWorker`如何与UI交互。
- en: Loading the application in index.js
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在`index.js`中加载应用程序
- en: 'Create a new file in the `/src` directory named `index.js` and populate it
    with the following contents:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/src`目录下创建一个名为`index.js`的新文件，并填充以下内容：
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The application entry point is the `loadPage()` function. Before we dig into
    the worker initialization code, let''s discuss the `getWorkerUrl()` function.
    Earlier in this section, we learned that you can pass a string representing a
    filename or a URL created from a `Blob` to the `Worker()` constructor. The following
    example code demonstrates the first technique:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的入口点是`loadPage()`函数。在我们深入研究工作器初始化代码之前，让我们讨论`getWorkerUrl()`函数。在本节前面，我们了解到你可以将表示文件名或由`Blob`创建的URL的字符串传递给`Worker()`构造函数。以下示例代码演示了第一种技术：
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The second technique is demonstrated in the `if (isBlob === 'true')` block of
    the `getWorkerUrl()` function. If the current `window.location` value ends with
    `?blob=true`, the URL passed to the `Worker()` constructor is created from a `Blob`.
    The only noticeable difference is the `document.title` value, which updates to
    reflect the URL type. Let's jump back to the `loadPage()` function to discuss
    the initialization code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种技术演示在`getWorkerUrl()`函数的`if (isBlob === 'true')`块中。如果当前的`window.location`值以`?blob=true`结尾，传递给`Worker()`构造函数的URL是由`Blob`创建的。唯一明显的区别是`document.title`的值，它更新以反映URL类型。让我们回到`loadPage()`函数，讨论初始化代码。
- en: 'After an event listener is added to the Reset button in the `loadPage()` function,
    two `WasmWorker` instances are created: `addWorker` and `subtractWorker`. Each
    worker is passed to the `initializeWorker()` function as the `wasmWorker` argument.
    In `initializeWorker()`, the `wasmWorker.initialize()` function is called to instantiate
    the Wasm module. The `wasmWorker.addListenerForType()` function is called to set
    the value of the Result `<input>` to the value returned from the `_calculate()`
    function in the corresponding worker. Finally, an event listener is added to the
    `click` event of the `<button>` that either adds or subtracts the `firstVal` and
    `secondVal` `<input>` values (based on the `name` argument). That''s it for the
    JavaScript code. Let''s create an HTML and CSS file, then move on to the build
    step.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在`loadPage()`函数中添加到重置按钮的事件监听器后，创建了两个`WasmWorker`实例：`addWorker`和`subtractWorker`。每个工作器作为`wasmWorker`参数传递给`initializeWorker()`函数。在`initializeWorker()`中，调用`wasmWorker.initialize()`函数来实例化Wasm模块。调用`wasmWorker.addListenerForType()`函数来设置Result
    `<input>`的值为相应工作器中`_calculate()`函数返回的值。最后，为添加或减去`firstVal`和`secondVal` `<input>`值（根据`name`参数）的`<button>`的`click`事件添加事件监听器。JavaScript代码就到这里。接下来，让我们创建HTML和CSS文件，然后进行构建步骤。
- en: The web assets
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络资产
- en: 'We need an HTML file to act as the entry point to the application. Create a
    file in the `/src` directory named `index.html` and populate it with the following
    contents:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个HTML文件作为应用程序的入口点。在`/src`目录下创建一个名为`index.html`的文件，并填充以下内容：
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The application consists of a `<form>` with three `<input>` elements and a block
    of three `<button>` elements. The first two `<input>` elements correspond to the
    `firstVal` and `secondVal` properties included in the `payload` sent to either
    worker thread. The final `<input>` is read-only and displays the result of either
    operation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序由一个包含三个`<input>`元素和一个包含三个`<button>`元素的`<form>`组成。前两个`<input>`元素对应于发送到任一工作线程的`payload`中包含的`firstVal`和`secondVal`属性。最后一个`<input>`是只读的，显示操作的结果。
- en: The block of `<button>` elements below the `<form>` perform operations on the
    `<input>` values. The first two `<button>` elements send the `<input>` values
    to either the `addWorker` or `subtractWorker` thread (depending on which button
    was pressed). The final `<button>` sets all of the `<input>` values to `0`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<form>`下面的`<button>`元素块对`<input>`值执行操作。前两个`<button>`元素将`<input>`值发送到`addWorker`或`subtractWorker`线程（取决于哪个按钮被按下）。最后一个`<button>`将所有`<input>`值设置为`0`。
- en: 'The application is initialized in the `<script>` tag in the last line before
    the `</body>` closing tag. Just as with Cook the Books, the `type="module"` attribute
    allows us to use the `import`/`export` syntax available in newer browsers. Finally,
    we need to add some styles to the application. Create a file in the `/src` directory
    named `styles.css` and populate it with the following contents:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序在`</body>`关闭标签之前的最后一行的`<script>`标签中初始化。就像Cook the Books一样，`type="module"`属性允许我们使用在新浏览器中可用的`import`/`export`语法。最后，我们需要为应用程序添加一些样式。在`/src`目录中创建一个名为`styles.css`的文件，并填充以下内容：
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That's the last file we need to create, but not the last one required to run
    the application. We still need to generate Wasm files from the C files in the
    `/lib` directory. Let's move on to the build step.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 那是我们需要创建的最后一个文件，但不是运行应用程序所必需的最后一个文件。我们仍然需要从`/lib`目录中的C文件生成Wasm文件。让我们继续到构建步骤。
- en: Building and running the application
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和运行应用程序
- en: With the code written, it's time to build and test the application. After completing
    the build step, we'll interact with the running application and review how to
    troubleshoot Web Workers using the browser's development tools.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 代码编写完成后，是时候构建和测试应用程序了。在完成构建步骤后，我们将与运行中的应用程序交互，并回顾如何使用浏览器的发展工具调试Web Workers。
- en: Compiling the C files
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译C文件
- en: 'We need to compile each C file to a separate `.wasm` file, which means the
    command needed to perform the compilation step is verbose. To perform the build,
    open a terminal instance in your `/parallel-wasm` directory and run the following
    commands:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将每个C文件编译成单独的`.wasm`文件，这意味着执行编译步骤所需的命令是冗长的。要执行构建，请在你的`/parallel-wasm`目录中打开终端实例并运行以下命令：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You should see two new files in the `/src` directory: `calc-add.wasm` and `calc-subtract.wasm`.
    With the required files in place, it''s time to test out the application.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在`/src`目录中看到两个新文件：`calc-add.wasm`和`calc-subtract.wasm`。在放置好所需的文件后，是时候测试应用程序了。
- en: Interacting with the application
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与应用程序交互
- en: 'Open a terminal instance in the `/parallel-wasm` directory and run the following
    command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/parallel-wasm`目录中打开终端实例并运行以下命令：
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you navigate to `http://127.0.0.1:8080/index.html` in your browser, you
    should see this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在浏览器中导航到`http://127.0.0.1:8080/index.html`，你应该看到这个：
- en: '![](img/de8e6b2e-53e0-49d2-9628-af2948abcb4e.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de8e6b2e-53e0-49d2-9628-af2948abcb4e.png)'
- en: ￼Wasm Workers application running in the browser
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中运行的Wasm Workers应用程序
- en: 'Try changing the values in the First Value and Second Value inputs and pressing
    the Add and Subtract buttons. The Result input should update with the calculated
    result. If you navigate to `http://127.0.0.1:8080/index.html?blob=true`, the URL
    argument passed to the `Worker()` constructor will use a `Blob` instead of the
    filename. The tab should change to reflect that the `Blob` technique is used to
    construct the URL:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试更改“第一个值”和“第二个值”输入中的值，并按下“加”和“减”按钮。结果输入应该更新为计算结果。如果你导航到`http://127.0.0.1:8080/index.html?blob=true`，传递给`Worker()`构造函数的URL参数将使用`Blob`而不是文件名。标签应该更改以反映使用Blob技术来构造URL：
- en: '![](img/06832741-0c1c-40a3-9b02-e6694db0942c.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/06832741-0c1c-40a3-9b02-e6694db0942c.png)'
- en: Tab title updated to reflect the Blob URL technique
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 标签标题更新以反映Blob URL技术
- en: Debugging Web Workers
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试Web Workers
- en: 'You can set breakpoints and interact with worker threads using the browser''s
    development tools. In Google Chrome, open Developer Tools and select the Sources
    tab. The file list panel should contain two instances of `worker.js`. The debugger
    panel contains a Threads section with the `main` thread and two `worker.js` threads.
    The following screenshot indicates the thread debugging elements within the Chrome
    Developer Tools panel for the running application:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用浏览器的发展工具设置断点并与工作线程交互。在Google Chrome中，打开开发者工具并选择“源”标签。文件列表面板应该包含两个`worker.js`实例。调试器面板包含一个包含`main`线程和两个`worker.js`线程的线程部分。以下截图显示了Chrome开发者工具面板中运行应用程序的线程调试元素：
- en: '![](img/243575cd-3c5c-43ad-a78c-cc3c248a0158.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/243575cd-3c5c-43ad-a78c-cc3c248a0158.png)'
- en: Thread debugging tools in the Chrome Developer Tools panel
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在Chrome开发者工具面板中的线程调试工具
- en: 'In Firefox, worker debugging is done in separate Developer Tools windows. To
    see this in action, open Developer Tools in Firefox and select the Debugger panel.
    Click on one of the `worker.js` list items in the Workers panel. A new Developer
    Tools window should appear that corresponds with the selected worker. The following
    screenshot shows a separate Developer Tools window for one of the `worker.js`
    instances selected from the Workers panel:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在Firefox中，工作线程调试是在单独的开发者工具窗口中完成的。要查看实际操作，请打开Firefox中的开发者工具并选择调试器面板。在工作者面板中点击一个`worker.js`列表项。应该会出现一个新的开发者工具窗口，与所选的工作者相对应。以下截图显示了从工作者面板中选择的一个`worker.js`实例的单独开发者工具窗口：
- en: '![](img/886e9bcd-c446-4a8d-aab4-2a303255aa2e.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/886e9bcd-c446-4a8d-aab4-2a303255aa2e.png)'
- en: Thread debugging tools in the Firefox Developer Tools panel
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Firefox开发者工具面板中的线程调试工具
- en: In the next section, we'll discuss some of the upcoming features of WebAssembly.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论WebAssembly的一些即将推出的功能。
- en: Upcoming features
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 即将推出的功能
- en: There are several upcoming WebAssembly features in various phases of the standardization
    process. Some of them are more impactful than others, but all of them are valuable
    improvements. In this section, we'll describe the standardization process and
    review a subset of the features that represent a significant shift in WebAssembly's
    capabilities. Most of the content in this section was referenced from Colin Eberhardt's
    blog post titled *The future of WebAssembly - A look at upcoming features and
    proposals*. The post can be found at [https://blog.scottlogic.com/2018/07/20/wasm-future.html](https://blog.scottlogic.com/2018/07/20/wasm-future.html).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个即将推出的WebAssembly功能处于标准化过程的各个阶段。其中一些比其他功能影响更大，但它们都是宝贵的改进。在本节中，我们将描述标准化过程并回顾一组代表WebAssembly能力重大转变的功能。本节的大部分内容参考了Colin
    Eberhardt的博客文章《WebAssembly的未来 - 查看即将推出的功能和提案》。文章可在[https://blog.scottlogic.com/2018/07/20/wasm-future.html](https://blog.scottlogic.com/2018/07/20/wasm-future.html)找到。
- en: The standardization process
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准化过程
- en: 'The WebAssembly W3C Process documentation at [https://github.com/WebAssembly/meetings/blob/master/process/phases.md](https://github.com/WebAssembly/meetings/blob/master/process/phases.md)
    describes the six phases (from 0 to 5) of the standardization process. The following
    list provides brief descriptions of each of these phases:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly W3C流程文档位于[https://github.com/WebAssembly/meetings/blob/master/process/phases.md](https://github.com/WebAssembly/meetings/blob/master/process/phases.md)，描述了标准化过程的六个阶段（从0到5）。以下列表提供了每个阶段的简要描述：
- en: '**Phase 0\. Pre-Proposal**: A WebAssembly **Community Group** (**CG**) member
    has an idea, and the CG votes on whether to move it to Phase 1.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**零阶段：预提案**：WebAssembly **社区组**（**CG**）成员有一个想法，CG投票决定是否将其移至第一阶段。'
- en: '**Phase 1\. Feature Proposal**: The pre-proposal process has succeeded and
    a repository is created in the WebAssembly organization on GitHub to document
    the feature.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一阶段：功能提案**：预提案过程已成功，在GitHub上的WebAssembly组织创建了一个存储库来记录该功能。'
- en: '**Phase 2\. Proposed Spec Text Available**: The full proposed spec text is
    available, possible implementations are prototyped, and a test suite is added.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第二阶段：可用的提案规范文本**：完整的提案规范文本可用，可能的实现已原型化，并添加了测试套件。'
- en: '**Phase 3\. Implementation Phase**: Embedders implement the feature, the repository
    is updated to include revisions to the formalization, and the spec is updated
    to include implementation of the feature in the reference interpreter.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三阶段：实施阶段**：嵌入器实现该功能，存储库更新以包含形式化的修订，规范更新以包含参考解释器中该功能的实现。'
- en: '**Phase 4\. Standardize the Feature**: If two or more Web VMs and at least
    one toolchain implement the feature, the feature is fully handed off to the WebAssembly
    **Working Group** (**WG**).'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第四阶段：标准化功能**：如果有两个或更多Web虚拟机和至少一个工具链实现了该功能，则该功能将完全移交给WebAssembly **工作组**（**WG**）。'
- en: '**Phase 5\. The Feature is Standardized**: The WG members have reached consensus
    that the feature is complete.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第五阶段：功能标准化**：工作组成员已达成共识，该功能已完整。'
- en: Now that you're familiar with the phases associated with the standardization
    process, let's move on to the threads proposal.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经熟悉了与标准化过程相关的阶段，让我们继续讨论线程提案。
- en: Threads
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程
- en: In the previous section, we used Web Workers to move Wasm modules into worker
    threads, which allowed us to call Wasm functions without blocking the main thread.
    However, passing messages between worker threads has performance limitations.
    In an effort to address this issue, a threads feature was proposed for WebAssembly.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用了 Web Workers 将 Wasm 模块移动到工作线程中，这使得我们可以在不阻塞主线程的情况下调用 Wasm 函数。然而，在工作线程之间传递消息有性能限制。为了解决这个问题，为
    WebAssembly 提出了一种线程特性。
- en: 'The proposal, currently in Phase 1, is described in detail at [https://github.com/WebAssembly/threads/blob/master/proposals/threads/Overview.md](https://github.com/WebAssembly/threads/blob/master/proposals/threads/Overview.md).
    Per the proposal documentation, the threads feature adds a new shared linear memory
    type and some new operations for atomic memory access. This proposal is relatively
    limited in scope. Eberhardt provides the following elaboration in his blog post:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 目前处于第一阶段这个提案的详细描述可以在 [https://github.com/WebAssembly/threads/blob/master/proposals/threads/Overview.md](https://github.com/WebAssembly/threads/blob/master/proposals/threads/Overview.md)
    找到。根据提案文档，线程特性添加了一种新的共享线性内存类型和一些新的原子内存访问操作。这个提案在范围上相对有限。Eberhardt 在他的博客文章中提供了以下阐述：
- en: '"Notably, this proposal does not introduce a mechanism for creating threads
    (which has caused a lot of debate) instead this functionality is supplied by the
    host. Within the context of wasm executed by the browser this will be the familiar
    WebWorkers."'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: “值得注意的是，这个提案没有引入创建线程的机制（这引起了很多争议），相反，这个功能由宿主提供。在浏览器执行 wasm 的上下文中，这将是我们熟悉的 WebWorkers。”
- en: Although the feature wouldn't allow for the creation of threads, it provides
    a simpler way of sharing data between the worker threads we create in JavaScript.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个特性不允许创建线程，但它为在 JavaScript 中创建的工作线程之间共享数据提供了一种更简单的方法。
- en: Host bindings
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宿主绑定
- en: 'The host bindings proposal, which is also in Phase 1, would address a significant
    limitation of WebAssembly when used in the browser: DOM manipulation. The proposal
    documentation at [https://github.com/WebAssembly/host-bindings/blob/master/proposals/host-bindings/Overview.md](https://github.com/WebAssembly/host-bindings/blob/master/proposals/host-bindings/Overview.md)
    provides the following list of goals for this feature:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 也处于第一阶段的宿主绑定提案将解决 WebAssembly 在浏览器中使用时的一个重大限制：DOM 操作。该特性的提案文档 [https://github.com/WebAssembly/host-bindings/blob/master/proposals/host-bindings/Overview.md](https://github.com/WebAssembly/host-bindings/blob/master/proposals/host-bindings/Overview.md)
    提供了以下目标列表：
- en: '**Ergonomics**: Allow WebAssembly modules to create, pass around, call, and
    manipulate JavaScript + DOM objects'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易用性**：允许 WebAssembly 模块创建、传递、调用和操作 JavaScript + DOM 对象'
- en: '**Speed**: Allow JS/DOM or other host calls to be well optimized'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：允许 JS/DOM 或其他宿主调用得到良好优化'
- en: '**Platform consistency**: Allow WebIDL to be used to annotate Wasm imports/exports
    (via a tool)'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台一致性**：允许使用 WebIDL 来注释 Wasm 导入/导出（通过一个工具）'
- en: '**Incrementalism**: Provide a strategy that is polyfillable'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渐进式**：提供一个可填充的策略'
- en: Improving WebAssembly's interoperability with JavaScript and Web APIs would
    simplify the development process considerably. It would also eliminate the need
    for the "glue" code that tools such as Emscripten provide.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 提高 WebAssembly 与 JavaScript 和 Web API 的互操作性将大大简化开发过程。它还将消除 Emscripten 等工具提供的“胶水”代码的需求。
- en: Garbage collection
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: 'The **garbage collection** (**GC**) proposal is currently in Phase 1\. We discussed
    garbage collection in the *What are the Limitations?* section of [Chapter 1](15ca4834-5544-4dd8-b307-f0bc95c63a21.xhtml), *What
    is WebAssembly?* The proposal documentation at [https://github.com/WebAssembly/gc/blob/master/proposals/gc/Overview.md](https://github.com/WebAssembly/gc/blob/master/proposals/gc/Overview.md)
    provides an extensive overview of the feature and describes the elements that
    need to be added to the specification. Eberhardt provides the following description
    of the proposal in his blog post:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**垃圾回收**（**GC**）提案目前处于第一阶段。我们在第 1 章的“什么是 WebAssembly？”部分讨论了垃圾回收，[https://github.com/WebAssembly/gc/blob/master/proposals/gc/Overview.md](https://github.com/WebAssembly/gc/blob/master/proposals/gc/Overview.md)
    的提案文档提供了对特性的广泛概述，并描述了需要添加到规范中的元素。Eberhardt 在他的博客文章中对提案提供了以下描述：'
- en: '"This proposal adds GC capabilities to WebAssembly. Interestingly, it will
    not have its own GC, instead it will integrate with the GC provided by the host
    environment. This makes a lot of sense as this, and various other proposals (host
    bindings, reference types), are designed to improve the interop with the host,
    making it easier to share state and call APIs. Having a single GC to manage memory
    makes this much easier."'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: “这个提案为 WebAssembly 添加了垃圾回收功能。有趣的是，它将不会拥有自己的垃圾回收器，而是将与宿主环境提供的垃圾回收器集成。这很有意义，因为这一提议以及各种其他提议（宿主绑定、引用类型）都是为了改善与宿主的互操作性，使共享状态和调用
    API 更加容易。有一个单一的垃圾回收器来管理内存会使这变得更加容易。”
- en: 'This feature will require a great deal of effort to implement, but adding it
    to WebAssembly will be worth the effort. Let''s wrap up this section with a feature
    currently in the implementation phase: reference types.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能实现起来需要付出大量的努力，但将其添加到 WebAssembly 中将是值得的。让我们以当前处于实施阶段的特性——引用类型来结束本节。
- en: Reference types
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用类型
- en: 'Reference types, currently in Phase 3, form the basis for the host bindings
    and GC features. The proposal documentation at [https://github.com/WebAssembly/reference-types/blob/master/proposals/reference-types/Overview.md](https://github.com/WebAssembly/reference-types/blob/master/proposals/reference-types/Overview.md)
    describes the addition of a new type, `anyref`, which can be used as both a value
    type and a table element type. The `anyref` type allows you to pass a JavaScript
    object to a Wasm module. Eberhardt describes the implications of this feature
    in his blog post:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型，目前处于第 3 阶段，是宿主绑定和垃圾回收功能的基础。提案文档在 [https://github.com/WebAssembly/reference-types/blob/master/proposals/reference-types/Overview.md](https://github.com/WebAssembly/reference-types/blob/master/proposals/reference-types/Overview.md)
    中描述了添加一个新的类型 `anyref`，它可以作为值类型和表元素类型使用。`anyref` 类型允许您将 JavaScript 对象传递给 Wasm 模块。Eberhardt
    在他的博客文章中描述了此功能的影响：
- en: '"The wasm module can''t really do much with the object via the anyref type.
    What''s more important is that the module is holding a reference to a garbage
    collected object on the JS heap, meaning they need to be traced during wasm execution.
    This proposal is seen as a stepping-stone towards the more significant garbage
    collection proposal."'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: “wasm 模块实际上无法通过 anyref 类型对对象做很多事情。更重要的是，该模块正在持有 JS 堆上垃圾回收对象的引用，这意味着在 wasm 执行期间需要对其进行跟踪。这个提案被视为向更重要的垃圾回收提案迈出的一个步骤。”
- en: There are several other exciting features in the pipeline for WebAssembly. The
    WebAssembly CG and WG are devoting their time and resources to making these features
    a reality. You can view all of the proposals at the WebAssembly organization page
    on GitHub, located at [https://github.com/WebAssembly](https://github.com/WebAssembly).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 还有几个令人兴奋的特性正在开发中。WebAssembly CG 和 WG 正在投入时间和资源，将这些特性变为现实。您可以在 GitHub
    上的 WebAssembly 组织页面查看所有提案，网址为 [https://github.com/WebAssembly](https://github.com/WebAssembly)。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed advanced tools and an alternate compilation method
    for WebAssembly. We learned about WABT and Binaryen's role in the WebAssembly
    development process and the functionality they provide. We compiled a Wasm module
    with LLVM through the use of the WebAssembly `npm` package and interacted with
    the result in the browser. We reviewed some of the WebAssembly tooling available
    online and created a simple application that uses Web Workers to store Wasm modules
    in separate threads. Finally, we discussed the upcoming features of WebAssembly
    and the standardization process. Now that you've gained a greater understanding
    of WebAssembly, go out there and build something!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了 WebAssembly 的高级工具和替代编译方法。我们了解了 WABT 和 Binaryen 在 WebAssembly 开发过程中的作用以及它们提供的功能。我们通过使用
    WebAssembly `npm` 包编译了 Wasm 模块，并在浏览器中与之交互。我们回顾了在线可用的 WebAssembly 工具，并创建了一个简单的应用程序，该应用程序使用
    Web Workers 在单独的线程中存储 Wasm 模块。最后，我们讨论了 WebAssembly 即将推出的功能以及标准化过程。现在，您对 WebAssembly
    有更深入的了解，去构建一些东西吧！
- en: Questions
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What does WABT stand for?
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WABT 代表什么？
- en: What three elements does Binaryen provide to make compiling to WebAssembly *easy*,
    *fast*, and *effective*?
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Binaryen 提供了哪三个元素来使编译到 WebAssembly 变得*简单*、*快速*和*有效*？
- en: What is the main difference between modules compiled using Emscripten versus
    LLVM with regard to the `importObj`/`exports`?
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Emscripten 编译的模块与使用 LLVM 编译的模块在 `importObj`/`exports` 方面有什么主要区别？
- en: Which online tool allows you to use AssemblyScript?
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个在线工具允许您使用 AssemblyScript？
- en: What are the two types of arguments you can pass to the `Worker()` constructor?
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以向 `Worker()` 构造函数传递哪两种类型的参数？
- en: What convention was used for passing messages between the main thread and worker
    threads?
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主线程和工作线程之间传递消息使用了哪种约定？
- en: How many phases are in the WebAssembly standardization process?
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebAssembly 标准化过程有多少个阶段？
- en: What is the name of the new type defined in the reference types feature?
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在引用类型特性中定义的新类型叫什么名字？
- en: Further reading
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: A crash course in memory management: [https://hacks.mozilla.org/2017/06/a-crash-course-in-memory-management](https://hacks.mozilla.org/2017/06/a-crash-course-in-memory-management)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存管理速成课程: [https://hacks.mozilla.org/2017/06/a-crash-course-in-memory-management](https://hacks.mozilla.org/2017/06/a-crash-course-in-memory-management)
- en: MDN Web Workers API: [https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API)
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MDN 网页工作者 API: [https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API)
- en: WebAssembly - Web Workers: [https://medium.com/@c.gerard.gallant/webassembly-web-workers-f2ba637c3e4a](https://medium.com/@c.gerard.gallant/webassembly-web-workers-f2ba637c3e4a)
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebAssembly - 网页工作者: [https://medium.com/@c.gerard.gallant/webassembly-web-workers-f2ba637c3e4a](https://medium.com/@c.gerard.gallant/webassembly-web-workers-f2ba637c3e4a)
