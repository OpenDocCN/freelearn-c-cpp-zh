- en: Porting a Game with Emscripten
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Emscripten 端口游戏
- en: As demonstrated in [Chapter 7](79019325-2d3e-452c-b680-ac90522aa4bf.xhtml), *Creating
    an Application from Scratch*, WebAssembly is still relatively limited in its current
    form. Emscripten provides powerful APIs for extending WebAssembly's capabilities
    to add functionality to your application. Compiling to a WebAssembly module and
    JavaScript glue code (instead of an executable) can, in some cases, only require
    minor changes to the existing C or C++ source.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如第 7 章[从零开始创建应用程序](79019325-2d3e-452c-b680-ac90522aa4bf.xhtml)中所示，WebAssembly
    在当前形式下仍然相对有限。Emscripten 提供了强大的 API，用于扩展 WebAssembly 的功能，为你的应用程序添加功能。将代码编译成 WebAssembly
    模块和 JavaScript 粘合代码（而不是可执行文件），在某些情况下，可能只需要对现有的 C 或 C++ 源代码进行少量更改。
- en: In this chapter, we're going to take a code base written in C++ that gets compiled
    to a traditional executable, and update the code so that it can be compiled to
    Wasm/JavaScript. We'll also add some additional features for tighter integration
    with the browser.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用一个用 C++ 编写的代码库，该代码库被编译成传统的可执行文件，并更新代码以便它可以编译成 Wasm/JavaScript。我们还将添加一些额外的功能，以便更紧密地与浏览器集成。
- en: 'By the end of this chapter, you''ll know how to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将知道如何做以下事情：
- en: Update a C++ code base to compile to a Wasm module/JavaScript glue code (instead
    of a native executable)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 C++ 代码库更新为编译成 Wasm 模块/JavaScript 粘合代码（而不是本地可执行文件）
- en: Use Emscripten's APIs to add browser integration to a C++ application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Emscripten 的 API 为 C++ 应用程序添加浏览器集成
- en: Build a multi-file C++ project with the proper `emcc` flags
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用适当的 `emcc` 标志构建多文件 C++ 项目
- en: Run and test a C++ application in the browser using `emrun`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `emrun` 在浏览器中运行和测试 C++ 应用程序
- en: Overview of the game
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏概述
- en: In this chapter, we're taking a Tetris clone written in C++ and updating the
    code to integrate Emscripten and compile to Wasm/JS. The code base in its original
    form compiled to an executable utilizes SDL2 and can be loaded from the command
    line. In this section, we're going to briefly review what Tetris is, how to get
    the code (without having to write it from scratch), and how to get it running.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用一个用 C++ 编写的俄罗斯方块克隆版，并更新代码以集成 Emscripten 并编译成 Wasm/JS。原始形式的代码库编译成可执行文件，使用了
    SDL2，并且可以从命令行加载。在本节中，我们将简要回顾俄罗斯方块是什么，如何获取代码（无需从头编写），以及如何运行它。
- en: What is Tetris?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是俄罗斯方块？
- en: In Tetris, the main objective of the game is to rotate and move pieces (*Tetriminos*)
    of various shapes within a playing field (*well* or *matrix*) to create a row
    of blocks without gaps. When a full row is created, it is deleted from the playing
    field and your score is increased by one. In our version of the game, there won't
    be a win condition (although it would be simple to add it).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在俄罗斯方块游戏中，游戏的主要目标是旋转和移动各种形状的块（*Tetriminos*）在游戏区域（*井*或*矩阵*）内，以创建没有间隙的方块行。当创建了一行完整的方块时，它将从游戏区域中删除，并且你的得分增加一分。在我们的游戏版本中，没有胜利条件（尽管添加它很简单）。
- en: 'It''s important to understand the rules and mechanics of the game because the
    code uses algorithms for concepts such as collision detection and scoring. Understanding
    the goal of a function helps you understand the code within. I recommend you give
    it a try online if you need to brush up on your Tetris skills. You can play it
    at [https://emulatoronline.com/nes-games/classic-tetris/](https://emulatoronline.com/nes-games/classic-tetris/)
    without having to install Adobe Flash. It looks just like the original Nintendo
    Version:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 理解游戏规则和机制很重要，因为代码使用了碰撞检测和得分等概念的算法。理解函数的目标有助于你理解代码内部。如果你需要复习你的俄罗斯方块技能，我建议你在网上试一试。你可以在[https://emulatoronline.com/nes-games/classic-tetris/](https://emulatoronline.com/nes-games/classic-tetris/)上玩，无需安装
    Adobe Flash。它看起来就像原始的任天堂版本：
- en: '![](img/60566c17-a951-44f8-a3f4-a1e2bf8c6115.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60566c17-a951-44f8-a3f4-a1e2bf8c6115.png)'
- en: Classic Tetris at EmulatorOnline.com
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: EmulatorOnline.com 上的经典俄罗斯方块
- en: The version we'll be working with won't contain the piece counters, levels,
    or points (we're sticking to line counts), but it will operate in the same way.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的数据版本将不包含方块计数器、等级或分数（我们坚持使用行数），但它将以相同的方式运行。
- en: The source of the source
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码的来源
- en: It turns out that a search for Tetris C++ provides a multitude of tutorials
    and example repositories to choose from. In the interest of sticking to the formatting
    and naming conventions that I've been using up to this point, I combined these
    resources to create my own version of the game. The *Further reading* section
    at the end of this chapter has links to these resources if you're interested in
    learning more. The concepts and process for porting a code base are applicable,
    regardless of the source. On that note, let's take a brief step-aside to discuss
    porting in general.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，搜索“俄罗斯方块C++”会提供大量的教程和示例仓库供选择。为了保持我到目前为止使用的格式和命名约定，我将这些资源结合起来，创建了我自己的游戏版本。本章末尾的“进一步阅读”部分包含了这些资源的链接，如果你有兴趣了解更多。移植代码库的概念和过程适用于任何来源。关于这一点，让我们简要地讨论一下移植的一般情况。
- en: A note about porting
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于移植的注意事项
- en: 'Porting an existing code base to Emscripten is not always a simple task. There
    are several variables to take into account when evaluating whether a C, C++, or
    Rust application is amenable to conversion. For example, games that make use of
    several third-party libraries or even a few third-party libraries that are of
    considerable complexity may require a significant amount of effort. Emscripten
    provides the following commonly used libraries out of the box:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 将现有的代码库移植到Emscripten并不总是简单的事情。在评估一个C、C++或Rust应用程序是否适合转换时，需要考虑几个变量。例如，使用多个第三方库或几个相当复杂的第三方库的游戏可能需要大量的努力。Emscripten提供了以下常用的库作为默认选项：
- en: '`asio`: A network and low-level I/O programming library'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asio`：一个网络和底层I/O编程库'
- en: '`Bullet`: A real-time collision detection and multi-physics simulation library'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bullet`：一个实时碰撞检测和多物理模拟库'
- en: '`Cocos2d`: A suite of open source, cross-platform, game development tools'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cocos2d`：一套开源、跨平台的游戏开发工具'
- en: '`FreeType`: A library used to render fonts'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FreeType`：一个用于渲染字体的库'
- en: '`HarfBuzz`: An OpenType text shaping engine'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HarfBuzz`：一个OpenType文本形状引擎'
- en: '`libpng`: The official PNG reference library'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libpng`：官方PNG参考库'
- en: '`Ogg`: A multimedia container format'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ogg`：一种多媒体容器格式'
- en: '`SDL2`: A library designed to provide low-level access to audio, a keyboard,
    a mouse, a joystick, and graphics hardware'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SDL2`：一个旨在提供对音频、键盘、鼠标、游戏手柄和图形硬件的低级访问的库'
- en: '`SDL2_image`: An image file loading library'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SDL2_image`：一个图像文件加载库'
- en: '`SDL2_mixer`: A sample multi-channel audio mixer library'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SDL2_mixer`：一个多通道音频混音库示例'
- en: '`SDL2_net`: A small sample cross-platform networking library'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SDL2_net`：一个小型的跨平台网络库示例'
- en: '`SDL2_ttf`: A sample library that allows you to use TrueType fonts in your
    SDL applications'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SDL2_ttf`：一个示例库，允许你在SDL应用程序中使用TrueType字体'
- en: '`Vorbis`: A general purpose audio and music encoding format'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vorbis`：一种通用的音频和音乐编码格式'
- en: '`zlib`: A lossless data compression library'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zlib`：一个无损数据压缩库'
- en: If the library isn't already ported, you will need to do it yourself. This would
    benefit the community, but requires a significant investment of time and resources.
    Our Tetris example only uses SDL2, which makes the porting process relatively
    simple.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果库还没有被移植，你需要自己进行移植。这将对社区有益，但需要大量的时间和资源投入。我们的俄罗斯方块示例仅使用SDL2，这使得移植过程相对简单。
- en: Getting the code
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取代码
- en: 'The code for this chapter is located in the `/chapter-08-tetris` folder of
    the `learn-webassembly` repository. There are two directories within `/chapter-08-tetris`:
    the `/output-native` folder, which contains the original (pre-ported) code and
    the `/output-wasm` folder, which contains the ported code.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码位于`learn-webassembly`仓库的`/chapter-08-tetris`文件夹中。在`/chapter-08-tetris`内部有两个目录：`/output-native`文件夹，其中包含原始（未移植）代码，以及`/output-wasm`文件夹，其中包含移植后的代码。
- en: If you want to use VS Code's Task feature for the native build step, you'll
    need to open the `/chapter-08-tetris/output-native` folder in VS Code, not the
    top-level `/learn-webassembly` folder.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要在VS Code中使用任务功能进行原生构建步骤，你需要打开VS Code中的`/chapter-08-tetris/output-native`文件夹，而不是顶层的`/learn-webassembly`文件夹。
- en: Building the native project
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建原生项目
- en: The `/cmake` folder and `CMakeLists.txt` file within the `/output-native` folder
    are required to build the project. The `README.md` file contains instructions
    to get the code up and running on each platform. Building the project isn't necessary
    to work through the porting process. The process for installing the required dependencies
    and getting the project to build successfully on your platform can be time-consuming
    and complex. If you still wish to proceed, you can build the executable through
    VS Code's Task feature by selecting Tasks | Run Task... from the menu and selecting
    Build Executable from the list after following the instructions in the `README.md`
    file.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`/cmake`文件夹和位于`/output-native`文件夹中的`CMakeLists.txt`文件是构建项目所必需的。`README.md`文件包含在每个平台上将代码运行起来的说明。构建项目对于完成移植过程不是必需的。安装所需依赖项并使项目在你的平台上成功构建的过程可能既耗时又复杂。如果你仍然希望继续，你可以通过VS
    Code的任务功能构建可执行文件，从菜单中选择**任务** | **运行任务...**，然后在遵循`README.md`文件中的说明后，从列表中选择**构建可执行文件**。'
- en: The game in action
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏运行中的画面
- en: 'If you were successful in building the project, you should be able to run it
    by selecting **Tasks** | **Run Task...** from the VS Code menu and selecting the
    Start Executable task from the list. If everything was successful, you should
    see something like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你成功构建了项目，你应该可以通过从VS Code菜单中选择**任务** | **运行任务...**，然后从列表中选择**启动可执行任务**来运行它。如果一切顺利，你应该会看到如下内容：
- en: '![](img/34e1026f-bd47-4209-a611-671d81f98ede.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/34e1026f-bd47-4209-a611-671d81f98ede.png)'
- en: Compiled game running natively
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本地编译的游戏运行
- en: Our version of the game doesn't have a losing condition; it just increments
    the ROWS count by one for each row you clear. If one of the Tetriminos touches
    the top of the board, the game is over and the board resets. It's a rudimentary
    implementation of the game, but additional features increase the complexity and
    amount of code required. Let's review the code base in more detail.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏版本没有失败条件；它只是为每清除一行增加一个ROWS计数。如果任何一个Tetriminos触碰到板的顶部，游戏结束，板子重置。这是一个基本的游戏实现，但增加的功能会增加复杂性和代码量。让我们更详细地回顾代码库。
- en: The code base in depth
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解代码库
- en: Now that you have the code available, you'll need to familiarize yourself with
    the code base. Without having a good understanding of the code you want to port,
    you'll have a much harder time porting it successfully. In this chapter, we're
    going to walk through each of the C++ class and header files and describe their
    roles in the application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了代码，你需要熟悉代码库。如果没有很好地理解你想要移植的代码，你将很难成功移植它。在本章中，我们将逐一介绍每个C++类和头文件，并描述它们在应用程序中的作用。
- en: Breaking the code into objects
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将代码分解为对象
- en: C++ was designed around an object-oriented paradigm, which is what the Tetris
    code base uses to simplify management of the application. The code base consists
    of C++ class files
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: C++的设计是基于面向对象范式，这也是俄罗斯方块代码库用来简化应用程序管理的。代码库由C++类文件组成
- en: (`.cpp`) and header files (`.h`) that represent objects within the context of
    the game. I used the gameplay summary from the *What is Tetris?* section to extrapolate
    which objects I needed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: （`.cpp`）和头文件（`.h`），它们代表游戏上下文中的对象。我使用了“什么是俄罗斯方块？”部分的游戏玩法总结来推断我需要哪些对象。
- en: 'The game pieces (Tetriminos) and playing field (referred to as a well or matrix)
    are good candidates for classes. Maybe less intuitively, but still just as valid,
    is the *game* itself. Classes don''t necessarily need to be as concrete as actual
    objects — they''re excellent for storing shared code. I''m a big fan of less typing,
    so I opted to use `Piece` to represent a Tetrimino and `Board` for the playing
    field (although the word *well *is shorter, it just doesn''t quite fit). I created
    a header file to store global variables (`constants.h`), a `Game` class to manage
    gameplay, and a `main.cpp` file, which acts as the entry point for the game. Here''s
    the contents of the `/src` folder:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏块（Tetriminos）和游戏区域（被称为井或矩阵）是作为类的良好候选。也许不那么直观，但同样有效，还有**游戏**本身。类不一定要像实际对象那样具体——它们非常适合存储共享代码。我是一个大粉丝，喜欢少打字，所以我选择使用`Piece`来表示Tetrimino，用`Board`来表示游戏区域（尽管单词“井”更短，但它并不完全合适）。我创建了一个头文件来存储全局变量（`constants.h`），一个`Game`类来管理游戏玩法，以及一个`main.cpp`文件，它作为游戏的入口点。以下是`/src`文件夹的内容：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each file (with the exception of `main.cpp` and `constants.h`) has a class (`.cpp`)
    and header (`.h`) file. Header files allow you to reuse code across multiple files
    and prevent code duplication. The *Further reading* section contains resources
    for you to learn more about header files if you're interested. The `constants.h`
    file is used in almost all of the other files within the application, so let's
    review that first.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件（除了`main.cpp`和`constants.h`）都有一个类（`.cpp`）和头文件（`.h`）。头文件允许你在多个文件之间重用代码，并防止代码重复。*进一步阅读*部分包含了你想要了解更多关于头文件资源的链接。`constants.h`文件在应用程序中的几乎所有其他文件中都被使用，所以让我们首先回顾一下。
- en: The constants file
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量文件
- en: 'Rather than have confusing *magic numbers* sprinkled throughout the code base,
    I opted for a header file containing the constants we''ll be using (`constants.h`).
    The contents of this file are shown here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在代码库中散布令人困惑的*魔法数字*，我选择了一个包含我们将要使用的常量的头文件（`constants.h`）。此文件的 内容如下所示：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `#ifndef` statement in the first line of the file is an `#include` guard,
    which prevents the header file from being included multiple times during compilation.
    These guards are used in all of the application's header files. The purpose of
    each of these constants will become clear when we step through each of the classes.
    I included it first to provide context around the various element sizes and how
    they relate to each other.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 文件第一行的`#ifndef`语句是一个`#include`保护，它防止在编译过程中多次包含头文件。这些保护在应用程序的所有头文件中都被使用。每个这些常量的用途将在我们逐步查看每个类时变得清晰。我首先包含它，是为了提供关于各种元素大小及其相互关系的背景信息。
- en: Let's move on to the various classes that represent aspects of the game. The
    `Piece` class represents an object at the lowest level, so we'll start there and
    work our way up to the `Board` and `Game` classes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到代表游戏各个方面的各种类。`Piece`类代表最低级别的对象，所以我们将从这里开始，逐步向上到`Board`和`Game`类。
- en: The piece class
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 片件类
- en: 'The piece, or *Tetrimino*, is the element that can be moved and rotated on
    the board. There are seven kinds of Tetriminos — each is represented by a letter
    and has a corresponding color:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 片件，或称为*Tetrimino*，是可以在棋盘上移动和旋转的元素。有七种Tetriminos——每种都由一个字母表示，并对应一种颜色：
- en: '![](img/bc6eabd2-b522-4990-9973-6d5432055b3d.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc6eabd2-b522-4990-9973-6d5432055b3d.png)'
- en: Tetrimino colors, taken from Wikipedia
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Tetrimino颜色，来自维基百科
- en: 'We need a way to define each piece in terms of shape, color, and current orientation.
    Each piece has four different orientations (at 90 degree increments), which results
    in 28 total variations for all pieces. The color doesn''t change, so that only
    needs to be assigned once. With that in mind, let''s first take a look at the
    header file (`piece.h`):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方式来定义每个片件在形状、颜色和当前方向上的特性。每个片件有四个不同的方向（以90度递增），这导致所有片件共有28种总变化。颜色不会改变，所以只需要分配一次。考虑到这一点，让我们首先看一下头文件（`piece.h`）：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The game uses SDL2 to render the various graphical elements and handle keyboard
    input, which is why we're passing a `SDL_Renderer` into the `draw()` function.
    You'll see how SDL2 is used in the `Game` class, but for now just be aware of
    its inclusion. The header file defines the interface for the `Piece` class; let's
    review the implementation in `piece.cpp`. We'll walk through each section of code
    and describe the functionality.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏使用SDL2来渲染各种图形元素和处理键盘输入，这就是为什么我们在`draw()`函数中传递`SDL_Renderer`的原因。你将在`Game`类中看到SDL2的使用，但就现在来说，只需知道它的包含即可。头文件定义了`Piece`类的接口；让我们回顾一下`piece.cpp`中的实现。我们将逐节查看代码并描述其功能。
- en: The constructor and draw() function
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数和draw()函数
- en: 'The first section of code defines the constructor of the `Piece` class and
    the `draw()` function:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一部分定义了`Piece`类的构造函数和`draw()`函数：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The constructor initializes the class with default values. The `BoardColumns`
    and `PieceSize` values are constants from the `constants.h` file. `BoardColumns`
    represents the amount of columns that can fit on a board, which is `10` in this
    case. The `PieceSize` constant represents the area or block that a piece takes
    up in columns, which is `4`. The initial value assigned to the private `columns_`
    variable represents the center of the board.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数使用默认值初始化类。`BoardColumns`和`PieceSize`值来自`constants.h`文件。`BoardColumns`表示可以在棋盘上容纳的列数，在这个例子中是`10`。`PieceSize`常量表示一个片件在列中占据的面积或块，是`4`。分配给私有`columns_`变量的初始值代表棋盘的中心。
- en: The `draw()` function loops through all of the possible rows and columns on
    the board and fills in any cells that are populated by a piece with the color
    that corresponds to its kind. The determination for whether a cell is populated
    by a piece is performed in the `isBlock()` function, which we'll discuss next.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw()` 函数遍历板上的所有可能的行和列，并用与拼图类型相对应的颜色填充任何被拼图填充的单元格。是否由拼图填充单元格的判断是在 `isBlock()`
    函数中进行的，我们将在下一节讨论。 '
- en: The move(), rotate(), and isBlock() functions
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`move()`、`rotate()` 和 `isBlock()` 函数'
- en: 'The second section contains the logic to move or rotate the piece and determine
    its current location:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含移动或旋转拼图以及确定其当前位置的逻辑：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `move()` function updates the values of the private `column_` and `row_`
    variables, which dictates the piece's location on the board. The `rotate()` function
    sets the value of the private `angle_` variable to either `0`, `1`, `2`, or `3`
    (which is why `%= 4` is used).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`move()` 函数更新私有 `column_` 和 `row_` 变量的值，这决定了拼图在板上的位置。`rotate()` 函数将私有 `angle_`
    变量的值设置为 `0`、`1`、`2` 或 `3`（这就是为什么使用 `%= 4`）。'
- en: Determination for which kind of piece is shown, its location, and rotation is
    performed in the `isBlock()` function. I omitted all but the first two elements
    of the `Shapes` multi-dimensional array to avoid cluttering up the file, but the
    remaining five piece kinds are present in the actual code. I will admit that this
    isn't the most elegant implementation, but it suits our purposes just fine.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 判断显示哪种拼图、其位置和旋转的判断是在 `isBlock()` 函数中进行的。我省略了 `Shapes` 多维数组中的除前两个元素之外的所有元素，以避免文件杂乱，但实际代码中仍然存在剩余的五种拼图类型。我必须承认，这并不是最优雅的实现方式，但它完全符合我们的需求。
- en: The private `kind_` and `angle_` values are specified as dimensions in the `Shapes`
    array to pick the four corresponding `char*` elements. These four elements represent
    the four possible orientations of the piece. If the index of `column + row * PieceSize`
    in the string is an asterisk, the piece is present in the specified row and column.
    If you decide to work through one of the Tetris tutorials available on the web
    (or look at one of the many Tetris repositories on GitHub), you'll find that there
    are several different ways to calculate whether a cell is populated by a piece.
    I chose this method because it's easier to visualize the pieces.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 私有 `kind_` 和 `angle_` 值在 `Shapes` 数组中指定为维度，以选择四个相应的 `char*` 元素。这四个元素代表拼图的四种可能方向。如果你决定通过网上可用的一个俄罗斯方块教程（或查看
    GitHub 上众多的俄罗斯方块仓库）进行工作，你会发现有几种不同的方法来计算单元格是否被拼图填充。我选择这种方法，因为它更容易可视化拼图。
- en: The getColumn() and getRow() functions
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`getColumn()` 和 `getRow()` 函数'
- en: 'The final section of code contains functions to get the row and column of the
    piece:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后部分包含获取拼图行和列的函数：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These functions simply return the value of the private `column_` or `row_` variable.
    Now that you have a better understanding of the `Piece` class, let's move on to
    the `Board`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数只是简单地返回私有 `column_` 或 `row_` 变量的值。现在你对 `Piece` 类有了更好的理解，让我们继续到 `Board`。
- en: The Board class
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Board` 类'
- en: 'The `Board` contains instances of the `Piece` class and needs to detect collisions
    among the pieces, when rows are filled, and when the game is over. Let''s start
    with the contents of the header file (`board.h`):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Board` 包含 `Piece` 类的实例，并需要检测拼图之间的碰撞、行是否填满以及游戏是否结束。让我们从头文件（`board.h`）的内容开始：'
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `Board` has a `draw()` function like the `Piece` class as well as several
    other functions for managing rows and keeping track of which cells are populated
    on the board. The `SDL2_ttf` library is used to render the ROWS: text at the bottom
    of the window with the current score (count of rows cleared). Now, let''s take
    a look at each section of the implementation file (`board.cpp`).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`Board` 类具有与 `Piece` 类相同的 `draw()` 函数，以及用于管理行和跟踪板上哪些单元格被填充的几个其他函数。`SDL2_ttf`
    库用于在窗口底部渲染 ROWS：文本，显示当前得分（清除的行数）。现在，让我们看一下实现文件（`board.cpp`）的每个部分。'
- en: The constructor and draw() function
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数和 `draw()` 函数
- en: 'The first section of code defines the constructor of the `Board` class and
    the `draw()` function:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一部分定义了 `Board` 类的构造函数和 `draw()` 函数：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `Board` constructor initializes the values of the private `cells_` and `currentScore_`
    variables to default values. The `cells_` variable is a two-dimensional array
    of Booleans, with the first dimension representing columns and the second rows.
    If a piece occupies a specific column and row, the corresponding value in the
    array is `true`. The `draw()` function behaves similarly to the `draw()` function
    of `Piece` in that it fills cells that contain pieces with color. However, this
    function only fills in cells that are occupied by pieces that have reached the
    bottom of the board with a light gray color, regardless of what kind of piece
    it is.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Board` 构造函数将私有 `cells_` 和 `currentScore_` 变量的值初始化为默认值。`cells_` 变量是一个布尔值二维数组，第一维表示列，第二维表示行。如果一个部件占据特定的列和行，则数组中的相应值为
    `true`。`draw()` 函数的行为类似于 `Piece` 的 `draw()` 函数，它用颜色填充包含部件的单元格。然而，此函数仅用浅灰色填充占据棋盘底部的部件所在的单元格，而不管部件的类型如何。'
- en: The isCollision() function
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`isCollision()` 函数'
- en: 'The second section of code contains logic to detect collisions:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第二部分包含检测碰撞的逻辑：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `isCollision()` function loops through each cell on the board until it reaches
    one populated by the `&piece` passed as an argument. If the piece is about to
    collide with either side of the board or it has reached the bottom, the function
    returns `true`, otherwise it returns `false`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`isCollision()` 函数遍历棋盘上的每个单元格，直到它到达由作为参数传递的 `&piece` 占据的一个单元格。如果该部件即将与棋盘的任一侧碰撞，或者它已经到达底部，则该函数返回
    `true`，否则返回 `false`。'
- en: The unite() function
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`unite()` 函数'
- en: 'The third section of code contains logic to unite a piece with the top row
    when it comes to rest:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第三部分包含在部件到达静止状态时将其与顶部行合并的逻辑：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `unite()` function and the corresponding `isRowFull()`, `areFullRowsPresent()`,
    and `updateOffsetRow()` functions perform several operations. It updates the private
    `cells_` variable with the rows and columns that the specified `&piece` argument
    occupies by setting the appropriate array location to `true`. It also clears any
    full rows (all columns filled) from the board by setting the corresponding `cells_`
    array locations to `false` and increments the `currentScore_`. After the row is
    cleared, the `cells_` array is updated to shift the row above the cleared row
    down by `1`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`unite()` 函数以及相应的 `isRowFull()`、`areFullRowsPresent()` 和 `updateOffsetRow()`
    函数执行多个操作。它通过将适当的数组位置设置为 `true` 来更新私有 `cells_` 变量，以指定 `&piece` 参数占据的行和列。它还通过将相应的
    `cells_` 数组位置设置为 `false` 来清除任何满行（所有列都填满）的行，并增加 `currentScore_`。在清除行之后，`cells_`
    数组被更新，以将清除行上方的行向下移动 `1`。'
- en: The displayScore() function
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`displayScore()` 函数'
- en: 'The final section of code displays the score at the bottom of the game window:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后一部分在游戏窗口底部显示分数：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `displayScore()` function uses the `SDL2_ttf` library to display the current
    score at the bottom of the window (underneath the board). The `TTF_Font *font`
    argument is passed in from the `Game` class to avoid initializing the font every
    time the score is updated. The `stringstream message` variable is used to create
    the text value and set it to a C `char*` within the `TTF_RenderText_Blended()`
    function. The rest of the code draws the text on a `SDL_Rect` to ensure that it's
    properly displayed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`displayScore()` 函数使用 `SDL2_ttf` 库在窗口底部（在棋盘下方）显示当前分数。`TTF_Font *font` 参数从 `Game`
    类传递进来，以避免每次更新分数时都初始化字体。`stringstream message` 变量用于创建文本值，并将其设置在 `TTF_RenderText_Blended()`
    函数中的 C `char*` 中。其余的代码在 `SDL_Rect` 上绘制文本，以确保其正确显示。'
- en: That's it for the `Board` class; let's move on to the `Game` to see how it all
    fits together.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `Board` 类的内容就到这里；让我们继续到 `Game` 类，看看所有这些是如何结合在一起的。
- en: The Game class
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Game` 类'
- en: 'The `Game` class contains the looping function that enables you to move pieces
    around the board with key presses. Here''s the contents of the header file (`game.h`):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Game` 类包含循环函数，允许您通过按键在棋盘上移动部件。以下是头文件（`game.h`）的内容：'
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `loop()` function contains the game logic and manages state based on events.
    The first two lines under the `private:` header prevent more than one instance
    of the game from being created, which could cause a memory leak. The private methods
    reduce the amount of code lines in the `loop()` function, which simplifies maintenance
    and debugging. Let's move on to the implementation in `game.cpp`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop()` 函数包含游戏逻辑，并根据事件管理状态。在 `private:` 标题下的前两行防止创建超过一个游戏实例，这可能导致内存泄漏。私有方法减少了
    `loop()` 函数中的代码行数，从而简化了维护和调试。让我们继续到 `game.cpp` 中的实现。'
- en: The constructor and destructor
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数和析构函数
- en: 'The first section of code defines the actions to perform when the class instance
    is loaded (constructor) and unloaded (destructor):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一部分定义了在类实例加载（构造函数）和卸载（析构函数）时执行的操作：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The constructor represents the entry point for the application, so all of the
    required resources are allocated and initialized within it. The `TTF_OpenFont()`
    function is referencing a TrueType font file downloaded from Google Fonts named
    Press Start 2P. You can view the font at [https://fonts.google.com/specimen/Press+Start+2P](https://fonts.google.com/specimen/Press+Start+2P).
    It's present in the `/resources` folder of the repository and gets copied into
    the same folder as the executable when the project is built. If at any point an
    error occurs when initializing the SDL2 resources, a `runtime_error` is thrown
    with details of the error. The destructor (`~Game()`) frees up the resources we
    allocated for SDL2 and `SDL2_ttf` before the application exits. This is done to
    avoid a memory leak.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数代表应用程序的入口点，因此所有必需的资源都在其中分配和初始化。`TTF_OpenFont()` 函数引用的是从 Google Fonts 下载的
    TrueType 字体文件，名为 Press Start 2P。您可以在 [https://fonts.google.com/specimen/Press+Start+2P](https://fonts.google.com/specimen/Press+Start+2P)
    查看该字体。它在存储库的 `/resources` 文件夹中，并在构建项目时被复制到可执行文件的同一文件夹中。如果在初始化 SDL2 资源时发生任何错误，则会抛出一个带有错误详细信息的
    `runtime_error`。析构函数 (`~Game()`) 在应用程序退出之前释放我们为 SDL2 和 `SDL2_ttf` 分配的资源。这样做是为了避免内存泄漏。
- en: The loop() function
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: loop() 函数
- en: 'The final section of code represents the `Game::loop`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后部分表示 `Game::loop`：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `loop()` function returns a Boolean as long as the `SDL_QUIT` event hasn't
    fired. Every `1` second, the `draw()` functions for the `Piece` and `Board` instances
    are executed, and the piece locations on the board are updated accordingly. The
    left, right, and down arrow keys control the piece's movement while the up arrow
    key rotates the piece by 90 degrees. Appropriate responses to key presses are
    handled in the `handleKeyEvents()` function. The `checkForCollision()` function
    determines if a new instance of the active piece collided with either side of
    the board or came to rest on top of the other pieces. If it did, a new piece is
    created. The logic for clearing the rows (via the `unite()` function of `Board`)
    is also handled in this function. We're almost done! Let's move on to the `main.cpp`
    file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop()` 函数只要 `SDL_QUIT` 事件没有触发就返回布尔值。每 `1` 秒，执行 `Piece` 和 `Board` 实例的 `draw()`
    函数，并相应地更新棋盘上的棋子位置。左、右和下箭头键控制棋子的移动，而上箭头键将棋子旋转 90 度。按键的适当响应在 `handleKeyEvents()`
    函数中处理。`checkForCollision()` 函数确定活动棋子的新实例是否与棋盘的任一边碰撞，或者落在其他棋子上面。如果是这样，就会创建一个新的棋子。清除行（通过
    `Board` 的 `unite()` 函数）的逻辑也在此函数中处理。我们几乎完成了！让我们继续到 `main.cpp` 文件。'
- en: The main file
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主文件
- en: 'There''s no header file associated with `main.cpp` because its only purpose
    is to act as an entry point to the application. In fact, the file is only seven
    lines long:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `main.cpp` 相关的没有头文件，因为它的唯一目的是作为应用程序的入口点。实际上，该文件只有七行：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `while` statement is exited when the `loop()` function returns `false`,
    which occurs when the `SDL_QUIT` event fires. All this file is doing is creating
    a new instance of `Game` and starting the loop. That's it for the codebase; let's
    start porting!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `loop()` 函数返回 `false` 时，`while` 语句退出，这发生在 `SDL_QUIT` 事件触发时。这个文件所做的只是创建一个新的
    `Game` 实例并启动循环。这就是代码库的全部内容；让我们开始迁移！
- en: Porting to Emscripten
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移到 Emscripten
- en: You have a good understanding of the code base, so now it's time to start porting
    it over with Emscripten. Fortunately, we're able to leverage some of the browser's
    features to simplify the code and completely remove a third-party library. In
    this section, we're going to update the code to compile to a Wasm module and JavaScript
    *glue* file and update some of the functionality to utilize the browser.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你对代码库有很好的理解，现在是时候开始使用 Emscripten 进行移植了。幸运的是，我们可以利用一些浏览器的功能来简化代码，并完全移除第三方库。在本节中，我们将更新代码以编译为
    Wasm 模块和 JavaScript *glue* 文件，并更新一些功能以利用浏览器。
- en: Preparing for porting
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备移植
- en: The `/output-wasm` folder contains the end result, but I recommend that you
    create a copy of the `/output-native` folder so that you can follow along with
    the porting process. There are VS Code Tasks set up for both native compilation
    and Emscripten compilation. If you get stuck, you can always reference the `/output-wasm`
    contents. Make sure you open your copied folder in VS Code (File | Open and select
    your copied folder), otherwise you won't be able to use the Tasks feature.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`/output-wasm` 文件夹包含最终结果，但我建议你创建 `/output-native` 文件夹的副本，这样你就可以跟随移植过程。已经为本地编译和
    Emscripten 编译设置了 VS Code 任务。如果你遇到困难，可以始终参考 `/output-wasm` 的内容。确保你在 VS Code 中打开你的副本文件夹（文件
    | 打开并选择你的副本文件夹），否则你将无法使用任务功能。'
- en: What's changing?
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有什么变化？
- en: 'This game is an ideal candidate for porting because it uses SDL2, a widely
    used library with an existing Emscripten port. Including SDL2 in the compilation
    step requires only one additional argument passed to the `emcc` command. An Emscripten
    port of the `SDL2_ttf` library also exists, but keeping it in the code base doesn''t
    make much sense. Its sole purpose is to render the score (amount of rows cleared)
    as text. We would need to include the TTF file with the application and complicate
    the build process. Emscripten provides the means for using JavaScript code within
    our C++, so we''re going to take a much simpler route: show the score in the DOM.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这款游戏是移植的理想候选者，因为它使用了 SDL2，这是一个广泛使用的库，并且已经存在 Emscripten 移植版本。在编译步骤中包含 SDL2 只需要将一个额外的参数传递给
    `emcc` 命令。`SDL2_ttf` 库的 Emscripten 移植版本也存在，但将其保留在代码库中并没有太多意义。它的唯一目的是将得分（清除的行数）以文本形式渲染。我们需要将
    TTF 文件与应用程序一起包含，从而复杂化构建过程。Emscripten 提供了在 C++ 中使用 JavaScript 代码的方法，因此我们将采取一条更简单的路线：在
    DOM 中显示得分。
- en: In addition to changing the existing code, we'll need to create an HTML and
    CSS file for displaying and styling the game in the browser. The JavaScript code
    we write will be minimal — we just need to load the Emscripten module and all
    our functionality is handled in the C++ code base. We'll also need to add a few
    `<div>` elements and lay them out accordingly to display the score. Let's start
    porting!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更改现有代码外，我们还需要创建一个 HTML 和 CSS 文件来在浏览器中显示和样式化游戏。我们编写的 JavaScript 代码将非常少——我们只需要加载
    Emscripten 模块，所有功能都在 C++ 代码库中处理。我们还需要添加几个 `<div>` 元素并相应地布局它们以显示得分。让我们开始移植！
- en: Adding the web assets
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加网络资源
- en: 'Create a folder in your project folder named `/public`. Add a new file named
    `index.html` to the `/public` folder and populate it with the following contents:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目文件夹中创建一个名为 `/public` 的文件夹。在 `/public` 文件夹中添加一个名为 `index.html` 的新文件，并填充以下内容：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `index.js` file being loaded in the first `<script>` tag doesn''t exist
    yet; that''ll be generated in the compilation step. Let''s add some styles to
    the elements. Create a `styles.css` file in the `/public` folder and populate
    it with the following contents:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个 `<script>` 标签中正在加载的 `index.js` 文件尚不存在；它将在编译步骤中生成。让我们给元素添加一些样式。在 `/public`
    文件夹中创建一个名为 `styles.css` 的文件，并填充以下内容：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Since the Press Start 2P font we're using is hosted on Google Fonts, we can
    import it for use on the site. The CSS rules in this file handle simple layout
    and styling. That's it for the web-related files we needed to create. Now, it's
    time to update the C++ code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的 Press Start 2P 字体托管在 Google Fonts 上，我们可以将其导入以在网站上使用。此文件中的 CSS 规则处理简单的布局和样式。这就是我们需要创建的所有与网络相关的文件。现在，是时候更新
    C++ 代码了。
- en: Porting the existing code
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移植现有代码
- en: We only need to edit a few files to get Emscripten working correctly. For the
    sake of simplicity and compactness, only the affected sections of code will be
    included (rather than the entire file). Let's work through the files in the same
    order as the previous section and start with `constants.h`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Emscripten正确工作，我们只需要编辑几个文件。为了简单和紧凑，我们只包括受影响的代码部分（而不是整个文件）。让我们按照上一节相同的顺序处理文件，并从`constants.h`开始。
- en: Updating the constants file
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新常数文件
- en: 'We''ll display the rows cleared count on the DOM instead of in the game window
    itself, so you can delete the `ScreenHeight` constant from the file. We no longer
    need additional space to accommodate for the score text:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在DOM上显示清除行数，而不是在游戏窗口本身中显示，因此可以删除文件中的`ScreenHeight`常量。我们不再需要额外的空间来容纳分数文本：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: No changes need to be made to the `Piece` class files (`piece.cpp`/`piece.h`).
    However, we will need to update the `Board` class. Let's start with the header
    file (`board.h`). Starting with the bottom and working our way up, let's update
    the `displayScore()` function. In the `<body>` section of the `index.html` file,
    there's a `<span>` element with `id="score"`. We're going to update this element
    using the `emscripten_run_script` command to display the current score. As a result,
    the `displayScore()` function becomes much shorter. The before and after is shown
    as follows.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要对`Piece`类文件（`piece.cpp`/`piece.h`）进行更改。但是，我们需要更新`Board`类。让我们从头文件（`board.h`）开始。从底部开始，逐步向上更新`displayScore()`函数。在`index.html`文件的`<body>`部分，有一个`id="score"`的`<span>`元素。我们将使用`emscripten_run_script`命令更新此元素以显示当前分数。因此，`displayScore()`函数变得更短。以下是前后对比。
- en: 'Here is the original version of the Board class''s `displayScore()` function:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Board`类`displayScore()`函数的原始版本：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here is the ported version of the `displayScore()` function:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`displayScore()`函数的移植版本：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `emscripten_run_script` action simply finds the `<span>` element on the
    DOM and sets the `innerHTML` to the current score. We can''t use the `EM_ASM()`
    function here because Emscripten doesn''t recognize the `document` object. Since
    we have access to the private `currentScore_` variable in the class, we''re going
    to move the `displayScore()` call in the `draw()` function into the `unite()`
    function. This limits the amount of calls to `displayScore()` to ensure that the
    function is called only when the score has actually changed. We only need to add
    one line of code to accomplish this. Here''s what the `unite()` function looks
    like now:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`emscripten_run_script`动作简单地找到DOM中的`<span>`元素，并将`innerHTML`设置为当前分数。在这里我们不能使用`EM_ASM()`函数，因为Emscripten不识别`document`对象。由于我们可以在类中访问私有的`currentScore_`变量，我们将把`draw()`函数中的`displayScore()`调用移动到`unite()`函数中。这限制了调用`displayScore()`的次数，确保函数仅在分数实际改变时被调用。我们只需要添加一行代码就能完成这个任务。现在`unite()`函数看起来是这样的：'
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Since we''re no longer using the `SDL2_ttf` library, we can update the `draw()`
    function signature and remove the `displayScore()` function call. Here''s the
    updated `draw()` function:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不再使用`SDL2_ttf`库，我们可以更新`draw()`函数签名并移除`displayScore()`函数调用。以下是更新后的`draw()`函数：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `displayScore()` function call was removed from the first line of the function
    and the `TTF_Font *font` argument was removed as well. Let''s add a call to `displayScore()`
    in the constructor to ensure that the initial value is set to `0` when the game
    ends and a new one begins:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`displayScore()`函数调用已被从函数的第一行移除，同时移除了`TTF_Font *font`参数。让我们在构造函数中添加对`displayScore()`的调用，以确保游戏结束时重置并开始新游戏时初始值设置为`0`：'
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'That''s it for the class file. Since we changed the signatures for the `displayScore()`
    and `draw()` functions, and removed the dependency for `SDL2_ttf`, we''ll need
    to update the header file. Remove the following lines from `board.h`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这节课的类文件就到这里。由于我们更改了`displayScore()`和`draw()`函数的签名，并移除了对`SDL2_ttf`的依赖，我们需要更新头文件。从`board.h`中移除以下行：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We're moving right along! The final change we need to make is the also the biggest
    one. The existing code base has a `Game` class that manages the application logic
    and a `main.cpp` file that calls the `Game.loop()` function in the `main()` function.
    The looping mechanism is a while loop that continues to run as long as the `SDL_QUIT`
    event hasn't fired. We need to change our approach to accommodate for Emscripten.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在稳步前进！我们需要做的最后一个更改也是最大的一个。现有的代码库中有一个 `Game` 类，它管理应用程序逻辑，还有一个 `main.cpp` 文件，在
    `main()` 函数中调用 `Game.loop()` 函数。循环机制是一个 while 循环，只要 `SDL_QUIT` 事件没有触发，它就会持续运行。我们需要改变我们的方法以适应
    Emscripten。
- en: 'Emscripten provides an `emscripten_set_main_loop` function that accepts an
    `em_callback_func` looping function, `fps`, and a `simulate_infinite_loop` flag.
    We can''t include the `Game` class and pass `Game.loop()` as the `em_callback_func`
    argument, because the build will fail. Instead, we''re going to eliminate the
    `Game` class completely and move the logic into the `main.cpp` file. Copy the
    contents of `game.cpp` into `main.cpp` (overwriting the existing contents) and
    delete the `Game` class files (`game.cpp`/`game.h`). Since we''re not declaring
    a class for `Game`, remove the `Game::` prefixes from the functions. The constructor
    and destructor are no longer valid (they''re no longer part of a class), so we
    need to move that logic to a different location. We also need to reorder the file
    to ensure that our called functions come before the calling functions. The final
    result looks like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Emscripten 提供了一个 `emscripten_set_main_loop` 函数，它接受一个 `em_callback_func` 循环函数、`fps`
    和一个 `simulate_infinite_loop` 标志。我们不能包含 `Game` 类并将 `Game.loop()` 作为 `em_callback_func`
    参数传递，因为构建将会失败。相反，我们将完全删除 `Game` 类并将逻辑移动到 `main.cpp` 文件中。将 `game.cpp` 的内容复制到 `main.cpp`
    中（覆盖现有内容）并删除 `Game` 类文件（`game.cpp`/`game.h`）。由于我们没有为 `Game` 声明一个类，所以需要从函数中移除 `Game::`
    前缀。构造函数和析构函数不再有效（它们不再是类的一部分），因此我们需要将逻辑移动到不同的位置。我们还需要重新排序文件，以确保我们的调用函数在调用函数之前。最终的结果如下：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `handleKeyEvents()` and `checkForCollision()` functions haven't changed;
    we simply moved them to the top of the file. The `loop()` function return type
    was changed from `bool` to `void` as required by `emscripten_set_main_loop`. Finally,
    the code from the constructor and destructor was moved into the `main()` function
    and any references to `SDL2_ttf` were removed. Instead of the while statement
    that called the `loop()` function of `Game`, we have the `emscripten_set_main_loop(loop,
    0, 1)` call. We changed the `#include` statements at the top of the file to accommodate
    for Emscripten, SDL2, and our `Board` and `Piece` classes. That's it for changes
    — now it's time to configure the build and test out the game.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleKeyEvents()` 和 `checkForCollision()` 函数没有变化；我们只是将它们移动到了文件顶部。`loop()`
    函数的返回类型从 `bool` 改为了 `void`，这是由 `emscripten_set_main_loop` 所要求的。最后，构造函数和析构函数中的代码被移动到了
    `main()` 函数中，并且移除了对 `SDL2_ttf` 的所有引用。我们不再使用调用 `Game` 的 `loop()` 函数的 while 语句，而是使用
    `emscripten_set_main_loop(loop, 0, 1)` 调用。我们将文件顶部的 `#include` 语句修改为适应 Emscripten、SDL2
    以及我们的 `Board` 和 `Piece` 类。这就是所有的更改——现在该配置构建并测试游戏了。'
- en: Building and running the game
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和运行游戏
- en: With the code updated and the required web assets present, it's time to build
    and test out the game. The compilation step is similar to the previous examples
    in this book, but we're going to use a different technique to run the game. In
    this section, we're going to configure the build task to accommodate for the C++
    files and run the application using a feature provided by Emscripten.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 代码更新并准备好所需的网络资源后，是时候构建并测试游戏了。编译步骤与本书中的前几个示例类似，但我们将使用不同的技术来运行游戏。在本节中，我们将配置构建任务以适应
    C++ 文件，并使用 Emscripten 提供的功能运行应用程序。
- en: Building with VS Code tasks
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 VS Code 任务进行构建
- en: 'We''re going to configure the build in two ways: with VS Code tasks and a Makefile.
    Makefiles are nice if you prefer to use a different editor than VS Code. The `/.vscode/tasks.json`
    file already contains the tasks you''ll need to build the project. The Emscripten
    build step is the default (a set of native build tasks is also present). Let''s
    walk through each task in the `tasks` array and review what''s taking place. The
    first task deletes any existing compiled output files prior to building:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以两种方式配置构建：使用 VS Code 任务和 Makefile。如果你更喜欢使用 VS Code 以外的编辑器，Makefiles 会很方便。`/.vscode/tasks.json`
    文件已经包含了构建项目所需的任务。Emscripten 构建步骤是默认的（也提供了一套原生构建任务）。让我们逐一查看 `tasks` 数组中的每个任务，并回顾正在发生的事情。第一个任务是在构建之前删除任何现有的编译输出文件：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The second task performs the build with the `emcc` command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个任务使用 `emcc` 命令执行构建：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The related arguments are placed on the same line. The only new and unfamiliar
    addition to the `args` array is the `--bind` argument with the corresponding `.cpp`
    files. This tells Emscripten that all the files after `--bind` are required to
    build the project. Test out the build by selecting Tasks | Run Build Task... from
    the menu or using the keyboard shortcut *Cmd*/*Ctrl + Shift + B*. It takes a few
    seconds to build, but the terminal will let you know when the compilation process
    is complete. If successful, you should see an `index.js` and `index.wasm` file
    in the `/public` folder.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 相关参数放在同一行上。`args` 数组中唯一的新增和不熟悉的参数是 `--bind` 参数，对应于 `.cpp` 文件。这告诉 Emscripten
    所有在 `--bind` 之后的所有文件都是构建项目所必需的。通过从菜单中选择“任务”|“运行构建任务...”或使用键盘快捷键 *Cmd*/*Ctrl +
    Shift + B* 来测试构建。构建需要几秒钟，但终端会在编译过程完成后通知您。如果成功，您应该在 `/public` 文件夹中看到 `index.js`
    和 `index.wasm` 文件。
- en: Building with a Makefile
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Makefile 构建
- en: 'If you prefer not to use VS Code, you can use a Makefile to accomplish the
    same goal as the VS Code tasks. Create a file named `Makefile` in your project
    folder and populate it with the following contents (make sure that the file is
    using tabs, not spaces):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想使用 VS Code，您可以使用 Makefile 完成与 VS Code 任务相同的目标。在您的项目文件夹中创建一个名为 `Makefile`
    的文件，并填充以下内容（确保文件使用的是制表符，而不是空格）：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The operations being performed are identical to the VS Code tasks, just in
    a different format using more universal tooling. The default build step is set
    in the file, so you can run the following command within your project folder to
    compile the project:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 正在执行的操作与 VS Code 任务相同，只是使用了更通用的工具以不同的格式。默认的构建步骤在文件中设置，因此您可以在项目文件夹内运行以下命令来编译项目：
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now that you have a compiled Wasm file and JavaScript glue code, let's try running
    the game.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有了编译好的 Wasm 文件和 JavaScript 粘合代码，让我们尝试运行游戏。
- en: Running the game
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行游戏
- en: 'Instead of using serve or `browser-sync`, we''re going to use a built-in feature
    of Emscripten''s toolchain, `emrun`. It provides the added benefit of capturing
    `stdout` and `stderr` (if you pass the `--emrun` linker flag to the `emcc` command)
    and printing them to the terminal if desired. We''re not going to use the `--emrun`
    flag, but having a local web server available without having to install any additional
    dependencies is a nice added feature to be aware of. Open up a terminal instance
    within your project folder and run the following command to start the game:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不使用 serve 或 `browser-sync`，而是使用 Emscripten 工具链的一个内置功能，`emrun`。它提供了额外的优势，即捕获
    `stdout` 和 `stderr`（如果您将 `--emrun` 链接器标志传递给 `emcc` 命令），并在需要时将它们打印到终端。我们不会使用 `--emrun`
    标志，但有一个本地 Web 服务器可用，无需安装任何额外的依赖项，这是一个值得注意的附加功能。在您的项目文件夹内打开一个终端实例，并运行以下命令来启动游戏：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can specify `firefox` for the browser if that''s what you''re using for
    development. The `--no_emrun_detect` flag hides a message in the terminal stating
    that the HTML page is not `emrun` capable. If you navigate to `http://localhost:6931/index.html`,
    you should see the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在开发时使用的是 `firefox` 浏览器，您可以指定 `firefox`。`--no_emrun_detect` 标志会隐藏终端中显示的 HTML
    页面不是 `emrun` 兼容的消息。如果您导航到 `http://localhost:6931/index.html`，您应该看到以下内容：
- en: '![](img/700df992-90f3-4452-84da-49e770e1a1c7.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/700df992-90f3-4452-84da-49e770e1a1c7.png)'
- en: Tetris running in the browser
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器中运行的俄罗斯方块
- en: Try rotating and moving the pieces to ensure that everything is working correctly.
    The ROWS count should increment by one when you've successfully cleared a row.
    You may also notice that if you're too close to the edge of the board, you won't
    be able to rotate some of the pieces. Congratulations, you've successfully ported
    a C++ game over to Emscripten!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试旋转和移动方块以确保一切正常工作。当您成功清除一行时，行数应该增加一。您也可能注意到，如果您离棋盘边缘太近，您将无法旋转某些方块。恭喜您，您已成功将
    C++ 游戏移植到 Emscripten！
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we ported a Tetris clone written in C++ that used SDL2 to Emscripten
    so it could be run in the browser with WebAssembly. We covered the rules of Tetris
    and how they map to the logic within the existing codebase. We also reviewed each
    file in the existing code base individually and which changes had to be made to
    successfully compile to a Wasm file and JavaScript glue code. After updating the
    existing code, we created the required HTML and CSS files, then configured a build
    step with the appropriate `emcc` flags. Once built, the game was run using Emscripten's
    `emrun` command.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 SDL2 编写的 Tetris 克隆移植到 Emscripten，以便在浏览器中使用 WebAssembly 运行。我们涵盖了 Tetris
    的规则以及它们如何映射到现有代码库中的逻辑。我们还逐个审查了现有代码库中的每个文件，并确定了为了成功编译为 Wasm 文件和 JavaScript 粘合代码需要做出的更改。更新现有代码后，我们创建了所需的
    HTML 和 CSS 文件，然后使用适当的 `emcc` 标志配置了构建步骤。构建完成后，游戏使用 Emscripten 的 `emrun` 命令运行。
- en: In [Chapter 9](52c9bfe6-6178-4795-8316-09aee11e8e28.xhtml), *Integrating with
    Node.js*, we're going to discuss how to integrate WebAssembly into Node.js and
    the benefits this integration provides.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 9 章](52c9bfe6-6178-4795-8316-09aee11e8e28.xhtml)，*与 Node.js 集成*，我们将讨论如何将
    WebAssembly 集成到 Node.js 中以及这种集成带来的好处。
- en: Questions
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the pieces called in Tetris?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Tetris 中的部件叫什么？
- en: What is one reason for choosing not to port an existing C++ code base to Emscripten?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么选择不将现有的 C++ 代码库移植到 Emscripten 的一个原因是什么？
- en: What tool did we use to compile the game natively (for example, to an executable)?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用了什么工具来本地编译游戏（例如，生成可执行文件）？
- en: What is the purpose of the `constants.h` file?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`constants.h` 文件的作用是什么？'
- en: Why were we able to eliminate the SDL2_ttf library?
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们能够消除 SDL2_ttf 库？
- en: Which Emscripten function did we use to start running the game?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用了哪个 Emscripten 函数来开始运行游戏？
- en: Which argument did we add to the `emcc` command to build the game and what purpose
    does it serve?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 `emcc` 命令中添加了哪个参数来构建游戏，它有什么作用？
- en: What advantage does `emrun` offer over a tool like `serve` and Browsersync?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`emrun` 相较于 `serve` 和 Browsersync 这样的工具有什么优势？'
- en: Further reading
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Header Files in C++: [https://www.sitesbay.com/cpp/cpp-header-files](https://www.sitesbay.com/cpp/cpp-header-files)
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++ 的头文件：[https://www.sitesbay.com/cpp/cpp-header-files](https://www.sitesbay.com/cpp/cpp-header-files)
- en: SDL2 Tetris on GitHub: [https://github.com/andwn/sdl2-tetris](https://github.com/andwn/sdl2-tetris)
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SDL2 Tetris on GitHub: [https://github.com/andwn/sdl2-tetris](https://github.com/andwn/sdl2-tetris)
- en: Tetris on GitHub: [https://github.com/abesary/tetris](https://github.com/abesary/tetris)
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tetris on GitHub: [https://github.com/abesary/tetris](https://github.com/abesary/tetris)
- en: Tetris - Linux on GitHub: [https://github.com/abesary/tetris-linux](https://github.com/abesary/tetris-linux)
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tetris - Linux on GitHub: [https://github.com/abesary/tetris-linux](https://github.com/abesary/tetris-linux)
