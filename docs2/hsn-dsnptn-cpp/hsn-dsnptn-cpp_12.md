

# 朋友工厂

在本章中，我们将讨论建立友谊。在这里，我们指的是 C++的友元，而不是 C++的朋友（你可以在你当地的 C++用户组中找到他们）。在 C++中，类的友元是函数或其他类，它们被授予对类的特殊访问权限。在这方面，它们与你的朋友并没有太大的不同。但 C++可以根据需要，按需制造朋友！

本章将涵盖以下主题：

+   友元函数在 C++中是如何工作的，它们做什么？

+   你应该在什么情况下使用友元函数而不是类成员函数？

+   如何将友元与模板结合

+   如何从模板生成友元函数

# 技术要求

本章的示例代码可以在以下 GitHub 链接中找到：https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter12.

# C++中的友元

让我们先回顾一下 C++授予类友谊的方式以及这种行动的影响，以及何时以及出于什么原因应该使用友谊（“我的代码直到我在每个地方添加`friend`才编译”不是一个有效的理由，而是一个表明接口设计不佳的迹象 - 相反，重新设计你的类）。

## 如何在 C++中授予友谊

*友元*是 C++的一个概念，它适用于类并影响对类成员的访问（*访问*是`public`和`private`控制的）。通常，公共成员函数和数据成员对任何人都是可访问的，而私有成员函数仅对类本身的其它成员函数是可访问的。以下代码无法编译，因为数据成员`C:x_`是私有的：

```cpp
// Example 01
class C {
  int x_;
  public:
  C(int x) : x_(x) {}
};
C increase(C c, int dx) {
  return C(c.x_ + dx);     // Does not compile
}
```

解决这个特定问题的最简单方法是将`increase()`作为一个成员函数，但让我们暂时保留这个版本。另一种选择是放宽访问权限，使`C::x_`成为公共的。这并不是一个好主意，因为它暴露了`x_` - 不仅对`increase()`，而且对任何想要直接修改`C`类型对象的代码。我们需要的是使`x_`对`increase()`公开，而对其他人则不公开。这是通过友元声明来实现的：

```cpp
// Example 02
class C {
  int x_;
  public:
  C(int x) : x_(x) {}
  friend C increase(C c, int dx);
};
C increase(C c, int dx) {
  return C(c.x_ + dx);    // Now it compiles
}
```

友元声明所做的只是给指定的函数赋予与类成员函数相同的访问权限。还有一种形式的友元声明，它授予的不是函数的友谊，而是类的友谊；这只是授予该类所有成员函数友谊的一种方式。

## 友元函数与成员函数的比较

我们确实需要回到这个问题，为什么不直接将`increase()`作为`C`类的成员函数呢？在前一节的示例中，实际上并没有这个必要 - `increase()`显然是`C`类公共接口的一部分，因为它是`C`支持的操作之一。它需要特殊的访问权限来完成其工作，因此它应该是一个成员函数。然而，也存在成员函数有局限性或根本不能使用的情况。

让我们考虑 `C` 类的一个加法运算符——这是使表达式如 `c1 + c2` 能够编译（如果两个变量都是类型 `C`）所必需的。加法，或 `operator+()`，可以声明为一个成员函数：

```cpp
// Example 03
class C {
  int x_;
  public:
  C(int x) : x_(x) {}
  C operator+(const C& rhs) const {
    return C(x_ + rhs.x_);
  }
};
...
C x(1), y(2);
C z = x + y;
```

这段代码编译并且完全按照我们的预期工作；看起来并没有什么明显的问题。那是因为到目前为止确实没有。但我们不仅能添加类型为 `C` 的对象：

```cpp
// Example 03
C x(1);
C z = x + 2;
```

这段代码也能编译，并且指向了 `C` 类声明中的一个微妙细节——我们没有显式地定义 `C(int)` 构造函数。这个构造函数现在引入了从 `int` 到 `C` 的隐式转换，这就是表达式 `x + 2` 编译的原因——首先，`2` 被转换成一个临时对象，`C(2)`，使用我们提供的构造函数，然后调用成员函数，`x.operator+(const C&)`——右侧是我们刚刚创建的临时对象。临时对象在表达式评估后立即被删除。从整数到隐式转换相当广泛，可能是一个疏忽。让我们假设它不是，并且我们确实希望表达式如 `x + 2` 能够编译。那有什么不满意的呢？再次，到目前为止没有。我们设计中的令人反感之处在于接下来会发生什么：

```cpp
// Example 03
C x(1);
C z = 2 + x; // Does NOT compile
```

如果 `x + 2` 能够编译，你合理地预期 `2 + x` 也能编译并给出相同的结果（在数学的某些领域加法不是交换的，但让我们在这里坚持算术）。它不能编译的原因是编译器无法从这里访问 `C` 类中的 `operator+()`，并且没有其他 `operator+()` 可用于这些参数。当使用成员函数运算符时，`x + y` 表达式只是对等价（如果冗长）调用 `x.operator+(y)` 的语法糖。对于任何其他二元运算符，如乘法或比较，也是如此。

重点是，成员函数运算符在表达式的第一个参数上调用（因此技术上，`x + y` 和 `y + x` 并不相同；成员函数在不同的对象上调用，但实现方式使得两者都给出相同的结果）。在我们的情况下，成员函数必须在数字 `2` 上调用，这是一个整数，根本没有成员函数。那么，表达式 `x + 2` 是如何编译的呢？实际上非常简单：`x +` 本身意味着 `x.operator+()`，而参数是 `+` 之后的所有内容。在我们的情况下，它是 `2`。所以，要么 `x.operator+(2)` 编译，要么不编译，但在任何情况下，对 `operator+` 调用的搜索都结束了。我们 `C` 类中的 `int` 隐式转换使这个调用编译。那么，为什么编译器不尝试对第一个参数进行转换呢？答案是，它永远不会这样做，因为它没有指导如何转换 - 可能存在无数其他具有 `operator+()` 成员函数的类型，其中一些可能接受 `C` 类作为它们的参数，或者 `C` 可以转换成某种类型。编译器不会尝试探索几乎无限多的这种可能的转换。

如果我们想在表达式中使用加号，其中第一个类型可能是内置类型或任何没有或不能有 `operator+()` 成员函数的其他类型，那么我们必须使用非成员函数。没问题；我们知道如何编写这些函数：

```cpp
C operator+(const C& lhs, const C& rhs) {
  return C(lhs.x_ + rhs.x_);
}
```

但现在我们失去了对私有数据成员 `C::x_` 的访问，因此我们的非成员 `operator+()` 也不能编译。我们在上一节中看到了那个问题的解决方案 - 我们需要将其定义为友元：

```cpp
// Example 04
class C {
  int x_;
  public:
  C(int x) : x_(x) {}
  friend C operator+(const C& lhs, const C& rhs);
};
C operator+(const C& lhs, const C& rhs) {
  return C(lhs.x_ + rhs.x_);
}
...
C x(1), y(2);
C z1 = x + y;
C z2 = x + 2;
C z3 = 1 + y;
```

现在，一切编译并按预期工作 - 非成员函数 `operator+()` 只是一个有两个类型为 `const C&` 的参数的非成员函数。它的规则与任何其他此类函数相同。

如果我们定义其体 *in situ*（紧随声明之后，在类内部），我们可以避免重复编写 `operator+()` 的声明：

```cpp
// Example 05
class C {
  int x_;
  public:
  C(int x) : x_(x) {}
  friend C operator+(const C& lhs, const C& rhs) {
    return C(lhs.x_ + rhs.x_);
  }
};
```

后一个例子与前面的例子略有不同，但通常你不会看到差异，所以这只是一个风格问题 - 将函数体移动到对象中会使对象本身更长，但将函数定义在类外则需要更多的输入（以及如果代码发生变化，友元声明和实际函数之间可能存在的差异）。我们将在下一节中解释 in situ 友元声明的复杂性。

无论哪种方式，友元函数实际上是类公共接口的一部分，但出于技术原因，我们在此情况下更倾向于使用非成员函数。甚至有一种情况，非成员函数是唯一的选择。考虑 C++ 输入/输出运算符，例如插入器，或 `operator<<()`，它们用于将对象写入流（例如，`std::cout`）。我们希望能够像这样打印 `C` 类型的对象：

```cpp
C c1(5);
std::cout << c1;
```

对于我们的类型 C，没有标准的`operator<<()`，因此我们必须声明自己的。插入器是一个二元运算符，就像加号一样（它两边都有参数），所以，如果它是一个成员函数，它必须是一个左边的对象上的函数。看看前面的语句——在`std::cout << c1`表达式中，左边的对象不是我们的对象`c1`，而是标准输出流`std::cout`。这就是我们必须添加成员函数的对象，但我们不能——`std::cout`在 C++标准库头文件中某处被声明，而且没有方法可以扩展其接口，至少不是直接的方式。我们可以声明`C`类上的成员函数，但这没有帮助——只有左边的对象的成员函数被考虑。唯一的替代方案是非成员函数。第一个参数必须是`std::ostream&`：

```cpp
// Example 06
class C {
  ...
  friend std::ostream& operator<<(std::ostream& out,
                                  const C& c);
};
std::ostream& operator<<(std::ostream& out, const C& c) {
  out << c.x_;
  return out;
}
```

这个函数必须被声明为`friend`，因为它还需要访问`C`类的私有数据。它也可以就地定义：

```cpp
// Example 07
class C {
  int x_;
  public:
  C(int x) : x_(x) {}
  friend std::ostream& operator<<(std::ostream& out,
                                  const C& c) {
    out << c.x_;
    return out;
  }
};
```

按照惯例，返回值是相同的流对象，因此插入器运算符可以被链式调用：

```cpp
C c1(5), c2(7);
std::cout << c1 << c2;
```

最后一条语句的解释方式是`(std::cout << c1) << c2`，这归结为`operator<<(operator<<(std::cout, c1), c2)`。外层的`operator<<()`是在内层`operator<<()`的返回值上调用的，而这个返回值是相同的：`std::cout`。再次强调，插入器是`C`类的公共接口的一部分——它使得类型`C`的对象可打印。然而，它必须是一个非成员函数。

C++中关于`friend`使用介绍的章节略过了几个偶尔很重要的微妙细节，因此让我们花些时间来阐明它们。

## 友谊的微妙细节

首先，让我们谈谈声明一个未定义的`friend`函数（即，没有就地实现）的效果：

```cpp
// Example 08
class C {
  friend C operator+(const C& lhs, const C& rhs);
  ...
};
C operator+(const C& lhs, const C& rhs) { … }
```

顺便说一下，你将`friend`声明放在类的公共部分还是私有部分，这完全无关紧要。但关于`friend`声明本身：我们授予了哪个函数访问权限？这是我们程序中第一次提到具有此签名的`operator+()`（其定义必须在类`C`本身声明之后出现）。结果是`friend`语句起到了双重作用：它还充当了函数的前置声明。

当然，没有规则阻止我们自行提前声明相同的函数：

```cpp
// Example 09
class C;
C operator+(const C& lhs, const C& rhs);
class C {
  friend C operator+(const C& lhs, const C& rhs);
  ...
};
C operator+(const C& lhs, const C& rhs) { … }
```

没有必要为了使用`friend`而单独使用前置声明，但如果我们想在程序中更早地使用`operator+()`，可能出于其他原因就需要这样做。

注意，如果`friend`提前声明与函数定义不匹配，或者`friend`语句与提前声明不匹配，编译器不会警告你。如果`friend`语句中的函数签名与实际函数不同，你将授予某个其他函数友谊，而这个函数是提前声明的但未在任何地方定义。你很可能在编译实际函数时遇到语法错误，因为现在它没有对类的特殊访问权限，无法访问其私有成员。但错误信息不会提及`friend`语句与函数定义之间的不匹配。你只需要知道，如果你授予了一个函数友谊，而编译器没有看到它，那么`friend`语句中的函数签名与函数定义中的签名之间存在差异。

当然，如果`friend`语句不仅声明了函数，还定义了它，那么它根本不是作为一个提前声明来执行的。但在这个情况下，还有一个细微之处，即新函数是在哪个作用域中定义的？考虑一下，如果你在类内部声明了一个静态函数，那么这个函数存在于类的自身作用域中。如果我们有一个类`C`和一个静态函数`f()`，这个函数在类外部的正确名称是`C::f`：

```cpp
class C {
  static void f(const C& c);
  ...
};
C c;
C::f(c);    // Must be called as C::f() not f()
```

很容易看出，这种情况并不适用于`friend`函数：

```cpp
class C {
  friend void f(const C& c);
  ...
};
C c;
C::f(c);    // Does not compile – not a member
```

考虑到我们已经看到，没有定义的`friend`语句提前声明了一个在类外部定义的函数。因此，如果`friend`声明在包含类的（在我们的例子中是全局作用域，但可能是一个`namespace`）作用域中提前声明了一个函数，那么具有就地定义的`friend`语句必须在相同的作用域中定义一个函数，即它将函数注入到类的外部作用域。对吗？是的，但并不完全是这样。

在实践中，你几乎不可能注意到“并不完全”的部分，一切都会表现得好像函数只是简单地注入到包含的作用域中。需要相当复杂的例子来演示实际发生的情况：

```cpp
// Example 10
class C {
  static int n_;
  int x_;
  public:
  C(int x) : x_(x) {}
  friend int f(int i) { return i + C::n_; }
  friend int g(const C& c) { return c.x_ + C::n_; }
};
int C::n_ = 42;
...
C c(1);
f(0);        // Does not comppile - no ADL
g(c);        // Compiles fine
```

在这里，我们有两个`friend`函数，`f()`和`g()`，它们都在声明点定义。函数`g()`表现得就像它在全局作用域（或者如果我们使用了`namespace`，则是包含类`C`的作用域）中声明一样。但是，在同一作用域中对`f()`的调用无法编译，错误信息将是“函数`f`在此作用域中未声明”或类似的内容。编译器错误信息的措辞差异很大，但错误的本质是这样的：对`f()`的调用没有找到要调用的函数。`f()`和`g()`函数之间的唯一区别是它们的参数；这最终证明是关键。

要理解这一点，我们必须知道当您编写像`f(0)`这样的函数调用时，编译器是如何查找函数名的。首先，这是一个非成员函数，因此编译器只查找那些（它也可以是一个函数对象——一个具有`operator()`的类，但这对现在来说并不重要，因为我们没有这样的类）。其次，编译器搜索当前作用域，即调用发生的作用域，以及所有包含的作用域，如嵌套函数体、类和命名空间，一直到全局作用域。但这还不是结束：编译器还会查看函数的参数，并搜索这些参数类型声明的作用域（或作用域）。这一步被称为**依赖参数查找**（**ADL**），也称为**科宁查找**，以纪念安德鲁·科宁（他否认发明了它）。在完成所有这些查找后，编译器在其找到的所有具有匹配名称的函数上执行重载解析（即，没有给任何特定作用域赋予优先级）。

那么，这与`friend`函数有什么关系呢？只有这一点：根据标准，由`friend`语句定义的函数被注入到包含类的范围内，但只能通过*依赖参数的查找*来找到。

这解释了我们刚才看到的行为：函数`f()`和`g()`都被注入到全局作用域，因为这是包含类`C`的作用域。函数`g()`有一个类型为`const C&`的参数，因此它通过 ADL 在包含类`C`的作用域中被找到。函数`f()`有一个类型为`int`的参数，而内置类型被认为是在任何作用域中声明的，它们“就是如此。”由于无法执行 ADL，并且作为`friend`定义的函数仅通过 ADL 找到，因此函数`f()`根本无法找到。

注意，这种情况非常脆弱。例如，如果我们提前声明了同一个函数，它可以在声明的作用域中找到，而不需要 ADL：

```cpp
// Example 11
int f(int i);    // Forward declaration
class C {
  ...
  friend int f(int i) { return i + C::n_; }
};
f(0);        // No problem
```

如果`friend`语句只声明了函数，稍后定义：

```cpp
// Example 12
class C {
  ...
  friend int f(int i);    // Forward declaration
};
int f(int i) { return i + C::n_; }
f(0);        // No problem
```

为什么我们不那么经常将其视为问题？因为大多数情况下，在类内部声明的`friend`函数至少有一个与类本身类型相关的参数（如指针或引用）。我们之前看到的`operator+()`和`operator<<()`都属于这一类。毕竟，声明函数为`friend`的唯一原因是为了使其能够访问类的私有成员，但如果它不操作类类型的对象，则不需要这种访问。作为一个非成员函数，它如何通过其参数之外的方式访问这样的对象？当然，有方法，但在实践中这种情况很少发生。

当程序定义自己的`operator new`时，还会发生另一个微妙且可能危险的案例。这并不违法，类特定的内存分配操作符通常是必要的。但声明一个并不那么简单。自定义`operator new`的两种常见用途：第一个是操作符为正在分配的类定义，通常在类内部定义。这些被称为类特定操作符，它们不是我们现在感兴趣的主题。我们需要解释第二种常见情况，即自定义`operator new`被定义为使用特定的分配器类分配内存。这通常是这样做：

```cpp
// Example 13
class Alloc {
  void* alloc(size_t s);    // Allocates memory
  void dealloc(void* p);     // Releases memory
  friend void* operator new (size_t s, Alloc* a);
  friend void operator delete(void* p, Alloc* a);
};
void* operator new (size_t s, Alloc* a) {
  return a->alloc(s);
}
void operator delete(void* p, Alloc* a) {
  a->dealloc(p);
}
class C { ... };
Alloc a;
C* c = new (&a) C;
```

有几个细节需要注意：首先，我们的分配器类`Alloc`为`operator new`提供了一个重载：每个`operator new`的第一个参数是强制性的，必须是分配的大小（编译器会填充这个值）。第二个参数（以及如果需要的话，第三个等）是任意的；在我们的情况下，它是将提供此分配内存的分配器类的指针。`operator new`本身是在全局作用域中的一个函数，并且它被声明为类`Alloc`的朋友。如果你想知道如何调用我们也声明的匹配的`operator delete`，答案是你不能；这个操作符仅由编译器本身在`operator new`的分配成功但新对象的构造函数抛出异常的情况下使用。编译器将使用与`operator new`相同的参数调用`operator delete`。但当你想要删除这个对象并且它的生命周期结束时，这并不是你删除对象的方式：无法向`delete`表达式添加额外的参数，所以你必须自己调用析构函数，然后显式地将内存返回给分配器。

这完全符合预期。编译器寻找对`operator new(size_t, Alloc*)`调用的最佳匹配，并如预期地在全局作用域中找到我们的自定义`operator new`。

现在，你可能会决定将操作符的主体移动到`friend`语句中，以节省一些输入并避免`friend`声明和实际的`operator new`定义不同步的可能性。这只需要进行微小的更改：

```cpp
// Example 14
class Alloc {
  void* alloc(size_t s);    // Allocates memory
  void dealloc(void* p);     // Releases memory
  friend void* operator new (size_t s, Alloc* a) {
    return a->alloc(s);
  }
  friend void operator delete(void* p, Alloc* a) {
    a->dealloc(p);
  }
};
class C { ... };
Alloc a;
C* c = new (&a) C;
```

这个程序几乎肯定能编译。在某些编译器上它将正常工作，在其他编译器上则会产生可怕的内存损坏。不幸的是，那些其他编译器是正确的。这是正在发生的事情：*new 表达式*（这是对语法“`new` … some-type”的标准名称）在查找匹配的 `operator new` 时有特殊的规则。具体来说，查找是在正在构造的类的范围（在我们的例子中是类 `C`）和全局范围内进行的（这些规则在标准的 `[expr.new]` 节中定义）。请注意，没有在 `operator new` 自身的参数范围内进行查找，即没有参数依赖查找。由于由 `friend` 语句定义的函数只能通过参数依赖查找找到，所以它根本找不到。但程序是如何编译的呢？这是因为 `operator new` 的另一个重载，所谓的 *placement new*。这个重载的形式是：

```cpp
void* new(size_t size, void* addr) { return addr; }
```

它在标准头文件 `<new>` 中声明，该头文件被许多其他头文件包含，因此你的程序很可能已经包含它，即使你没有明确这样做。

`placement new` 的意图是在之前分配的内存中构造一个对象（我们在之前关于类型擦除的章节中使用了这种方法来在类内部预留空间构造对象）。但它也是我们的 `operator new(size_t, Alloc*)` 调用的可能匹配，因为 `Alloc*` 可以隐式转换为 `void*`。我们自己的重载不需要这种转换，会是一个更好的匹配，但不幸的是，当在原地定义时，它不会被查找。结果是类型 `C` 的对象在分配器对象本身已经占用的内存中构造，在这个过程中破坏了后者对象。

您可以使用我们的示例来测试您的编译器：当在类外部定义时，自定义的 `operator new` 应该被调用，并且程序应该按预期工作。但是当由 `friend` 语句定义时，只能找到 placement new（一些编译器还会发出关于覆盖已构造对象的警告）。

到目前为止，我们的类只是普通类，不是模板，我们的非成员函数声明的朋友只是普通非模板函数。现在，让我们考虑如果类成为模板，需要做哪些改变（如果有的话）。

# 朋友和模板

C++ 中的类和函数都可以是模板，我们可以有几种不同的组合——一个类模板可以授予非模板函数朋友权限，如果其参数类型不依赖于模板参数；这不是一个特别有趣的情况，当然也不能解决我们现在正在处理的问题。当需要操作模板参数类型时，正确地选择朋友变得更加困难。

## 模板类的朋友

让我们先让我们的 `C` 类成为模板：

```cpp
template <typename T> class C {
  T x_;
  public:
  C(T x) : x_(x) {}
};
```

我们仍然想要添加 `C` 类型的对象并将它们打印出来。我们已经考虑了为什么前者用非成员函数完成更好，以及后者不能以任何其他方式完成的原因。这些原因对类模板同样有效。

没问题——我们可以声明与我们的模板类一起使用的模板函数，并执行之前章节中非模板函数所做的工作。让我们从 `operator+()` 开始：

```cpp
template <typename T>
C<T> operator+(const C<T>& lhs, const C<T>& rhs) {
  return C<T>(lhs.x_ + rhs.x_);
}
```

这是我们之前看到过的相同函数，只是变成了一个模板，可以接受类模板 `C` 的任何实例化。请注意，我们在这个模板上参数化了类型 `T`，即 `C` 的模板参数。当然，我们可以简单地声明以下内容：

```cpp
template <typename C>
C operator+(const C& lhs, const C& rhs) { // NEVER do this!
  return C<T>(lhs.x_ + rhs.x_);
}
```

然而，这引入了一个——不亚于全局作用域——声称接受任何类型两个参数的 `operator+()`。当然，它实际上只处理具有 `x_` 数据成员的类型。那么，当我们有一个也是可添加的模板类 `D`，但它有一个 `y_` 数据成员而不是 `x_` 数据成员时，我们将怎么办呢？

模板的早期版本至少限制在类模板 `C` 的所有可能实例化上。当然，它也面临着我们第一次尝试非成员函数时遇到的问题——它无法访问私有数据成员 `C<T>::x_`。没问题——毕竟，本章是关于朋友的。但朋友是针对什么的？整个类模板 `C` 将有一个朋友声明，只为所有 `T` 类型，并且它必须适用于模板函数 `operator+()` 的每个实例化。看起来我们必须授予整个函数模板朋友权限：

```cpp
// Example 15
template <typename T> class C {
  T x_;
  public:
  C(T x) : x_(x) {}
  template <typename U>
  friend C<U> operator+(const C<U>& lhs, const C<U>& rhs);
};
template <typename T>
C<T> operator+(const C<T>& lhs, const C<T>& rhs) {
  return C<T>(lhs.x_ + rhs.x_);
}
```

注意正确的语法——关键字 `friend` 出现在模板及其参数之后，但在函数的返回类型之前。此外，请注意，我们必须重命名嵌套朋友声明的模板参数——`T` 标识符已经被用于类模板参数。同样，我们可以在函数定义中将模板参数 `T` 重命名，但不必这样做——就像在函数声明和定义中一样，参数只是一个名称；它只在每个声明中有意义——同一函数的两个声明可以使用不同的名称来表示相同的参数。我们可以做的替代方案是将函数体内联，放入类中：

```cpp
// Example 16
template <typename T> class C {
  int x_;
  public:
  C(int x) : x_(x) {}
  template <typename U>
  friend C<U> operator+(const C<U>& lhs, const C<U>& rhs) {
    return C<U>(lhs.x_ + rhs.x_);
  }
};
```

你可能会指出，我们在模板类 `C` 的封装上打开了一个相当大的漏洞——通过将 `C<T>` 的任何实例化与整个模板函数视为友元，例如，我们使 `operator+(const C&<double>, const C&<double>)` 的实例化成为 `C<int>` 的友元。这显然是不必要的，尽管这种做法可能不会立即显现出危害（一个展示实际危害的例子将会相当复杂，因为这是必要的）。但这个问题忽略了我们的设计中一个更严重的问题，这个问题在我们开始使用它来添加内容时变得明显。它在一开始是可行的：

```cpp
C<int> x(1), y(2);
C<int> z = x + y; // So far so good...
```

但仅到此为止：

```cpp
C<int> x(1), y(2);
C<int> z1 = x + 2; // This does not compile!
C<int> z2 = 1 + 2; // Neither does this!
```

但这难道不是使用非成员函数的原因吗？我们的隐式转换怎么了？这曾经是可行的！答案在细节中——它曾经可行，但对于非模板函数 `operator+()`，模板函数的转换规则非常不同。确切的技术细节可以通过标准获得，但需要极大的勤奋和努力，但这是关键——在考虑非成员、非模板函数时，编译器会寻找所有具有给定名称（在我们的例子中是 `operator+`）的函数，然后检查它们是否接受正确的参数数量（可能考虑默认参数），然后检查对于每个这样的函数，对于它的每个参数，是否存在从提供的参数到指定参数类型的转换（关于哪些转换被考虑的规则相当复杂，但让我们说，用户提供的隐式转换和内置转换，如非 `const` 到 `const`，都被考虑）。如果这个过程只产生一个函数，那么就调用该函数（否则编译器要么选择 *最佳* 覆载，要么抱怨有多个候选者且调用是模糊的）。

对于模板函数，这个过程将再次产生几乎无限多的候选者——每个具有 `operator+()` 名称的模板函数都必须在所有已知类型上实例化，以检查是否足够多的类型转换可用以使其工作。相反，尝试了一个更简单的过程——除了前一段中描述的所有非模板函数（在我们的例子中，没有）之外，编译器还考虑了具有给定名称（再次是 `operator+`）的模板函数的实例化，以及所有参数类型与函数调用位置上的函数参数类型相等的类型（允许所谓的平凡转换，例如添加 `const`）。

在我们的例子中，`x + 2` 表达式中的参数类型分别是 `C<int>` 和 `int`。编译器会寻找一个接受这种类型两个参数的模板函数 `operator+` 的实例化，而用户提供的转换不被考虑。当然，这样的函数不存在，因此对 `operator+()` 的调用无法解析。

问题的根源在于我们真的希望用户提供的转换能够被编译器自动使用，但只要我们试图实例化一个模板函数，这种情况就不会发生。我们可以声明一个非模板函数 `operator+(const C<int>&, const C<int>&)`，但使用 `C` 模板类，我们必须为 `C` 类可能实例化的每个 `T` 类型声明一个。

# 模板友元工厂

我们需要的是为每个用于实例化类模板 `C` 的 `T` 类型自动生成一个非模板函数。当然，我们无法提前生成所有这些函数——理论上，可能有几乎无限数量的 `T` 类型可以与模板类 `C` 一起使用。幸运的是，我们不需要为这些类型中的每一个生成 `operator+()`，我们只需要为实际在程序中使用此模板的类型生成它们。

## 按需生成友元

我们即将看到的模式是一个非常古老的模式，由 John Barton 和 Lee Nackman 在 1994 年为了完全不同的目的引入——他们用它来绕过当时编译器存在的一些限制。发明者提出了 *受限模板扩展* 这个名字，但从未被广泛使用。多年以后，Dan Sacks 提出了 *友元工厂* 这个名字，但这个模式有时也简单地被称为 *Barton-Nackman 技巧*。

这种模式看起来非常简单，与本章前面编写的代码非常相似：

```cpp
// Example 17
template <typename T> class C {
  int x_;
  public:
  C(int x) : x_(x) {}
  friend C operator+(const C& lhs, const C& rhs) {
    return C(lhs.x_ + rhs.x_);
  }
};
```

我们正在利用一个非常特定的 C++ 功能，因此代码必须精确编写。非模板友元函数定义在类模板内部。此函数必须定义为内联的；它不能先声明为友元然后稍后定义，除非是显式模板实例化——我们可以在类内部声明友元函数，然后定义 `operator+<const C<int>>&, const C<int>&)`，这对于 `C<int>` 是有效的，但对于 `C<double>` 则无效（因为我们不知道调用者以后可能会实例化哪些类型，这并不很有用）。它可能具有 `T` 类型的参数，模板参数，`C<T>` 类型（在类模板内部可以简单地称为 `C`），以及任何其他固定或仅依赖于模板参数的类型，但它本身不能是模板。每个 `C` 类模板的实例化，无论模板参数类型的组合如何，都生成一个具有指定名称的非模板、非成员函数。请注意，生成的函数是非模板函数；它们是常规函数，并且通常的转换规则适用于它们。我们现在回到了非模板的 `operator+()`，所有转换都完全按照我们想要的方式进行：

```cpp
C<int> x(1), y(2);
C<int> z1 = x + y; // This works
C<int> z2 = x + 2; // and this too
C<int> z3 = 1 + 2; // so does this
```

这就是全部的模式。有几个细节我们必须注意。首先，关键字 `friend` 不能省略。一个类通常不能生成非成员函数，除非声明为友元。即使函数不需要访问任何私有数据，为了从类模板的实例化中自动生成非模板函数，这些函数必须被声明为友元（可以通过类似的方式生成静态非成员函数，但二进制运算符不能是静态函数——标准明确禁止）。其次，生成的函数放置在包含类的范围内，但必须通过参数依赖查找来找到，正如我们在本章前面学到的。例如，让我们为我们的 `C` 模板类定义插入操作符，但在这样做之前，将整个类包裹在一个命名空间中：

```cpp
// Example 18
namespace NS {
template <typename T> class C {
  int x_;
  public:
  C(int x) : x_(x) {}
  friend C operator+(const C& lhs, const C& rhs) {
    return C(lhs.x_ + rhs.x_);
  }
  friend std::ostream&
  operator<<(std::ostream& out, const C& c) {
    out << c.x_;
    return out;
  }
};
} // namespace NS
```

现在我们可以添加并打印 `C` 类型的对象：

```cpp
NS::C<int> x(1), y(2);
std::cout << (x + y) << std::endl;
```

注意，尽管 `C` 类模板现在位于命名空间 `NS` 中，并且必须这样使用（`NS::C<int>`），我们并不需要做任何特殊的事情来调用 `operator+()` 或 `operator<<()`。这并不意味着它们是在全局作用域中生成的。不，它们仍然在 `NS` 命名空间中，但我们看到的是参数依赖查找正在起作用——例如，当寻找名为 `operator+()` 的函数时，编译器会考虑当前作用域（即全局作用域，且没有）以及函数参数定义的作用域。在我们的例子中，`operator+()` 至少有一个参数是 `NS::C<int>` 类型，这会自动将 `NS` 命名空间中声明的所有函数都纳入考虑。友元工厂在其包含类模板的作用域中生成其函数，这当然是 `NS` 命名空间。因此，查找找到了定义，`+` 和 `<<` 操作符的解析正是我们期望的方式。请放心，这是设计好的，绝非偶然；参数查找规则被精心调整以产生这个期望和预期的结果。

很容易证明，尽管友元函数是在包含类的（在我们的例子中是命名空间 `NS`）作用域中生成的，但它们只能通过参数依赖查找来找到。一个直接尝试不使用参数依赖查找来查找函数的尝试将会失败：

```cpp
auto p = &NS::C<int>::operator+; // Does not compile
```

友元工厂模式与我们之前研究过的模式之一也有联系。

# 友元工厂和奇特重复的模板模式

友元工厂是一种模式，它从每个类模板的实例化中合成一个非模板、非成员函数——每次模板在新的类型上实例化时，都会生成一个新的函数。对于其参数，这个函数可以使用在该类模板实例化中可以声明的任何类型。通常，这是该类本身，但它可以是模板所知的任何类型。

以这种方式，友元工厂可以与`operator!=()`一起使用，可以通过`operator==()`实现：

```cpp
// Example 19
template <typename D> class B {
  public:
  friend bool operator!=(const D& lhs, const D& rhs) {
    return !(lhs == rhs);
  }
};
template <typename T> class C : public B<C<T>> {
  T x_;
  public:
  C(T x) : x_(x) {}
  friend bool operator==(const C& lhs, const C& rhs) {
    return lhs.x_ == rhs.x_;
  }
};
```

在这里，派生类`C`使用友元工厂模式，直接从类模板的实例化中生成一个非模板函数用于二进制`operator==()`。它还从基类`B`继承，这会触发对该模板的实例化，进而为已经生成`operator==()`的每个类型生成一个非模板函数`operator!=()`。

CRTP 的第二个用途是将成员函数转换为非成员函数。例如，二进制`operator+()`有时是用`operator+=()`实现的，而`operator+=()`始终是一个成员函数（它作用于其第一个操作数）。为了实现二进制`operator+()`，必须有人负责转换到该对象类型，然后才能调用`operator+=()`。这些转换是由使用友元工厂生成的通用 CRTP 基类生成的二进制运算符提供的。同样，如果我们建立我们的类有一个`print()`成员函数的约定，插入运算符也可以生成：

```cpp
// Example 20
template <typename D> class B {
  public:
  friend D operator+(const D& lhs, const D& rhs) {
    D res(lhs);
    res += rhs; // Convert += to +
    return res;
  }
  friend std::ostream&
  operator<<(std::ostream& out, const D& d) {
    d.print(out);
    return out;
  }
};
template <typename T> class C : public B<C<T>> {
  T x_;
  public:
  C(T x) : x_(x) {}
  C operator+=(const C& incr) {
    x_ += incr.x_;
    return *this;
  }
  void print(std::ostream& out) const {
    out << x_;
  }
};
```

以这种方式，CRTP 可以用来添加样板接口，同时将实现委托给派生类。毕竟，它是一个静态（编译时）委托模式。

# 摘要

在本章中，我们了解了一种非常 C++特定的模式，最初作为早期有缺陷的 C++编译器的解决方案而引入，但几年后找到了新的用途。友元工厂用于从类模板的实例化中生成非模板函数。作为非模板函数，这些生成的友元在参数转换方面比模板函数具有更灵活的规则。我们还学习了参数依赖查找、类型转换和友元工厂如何协同工作，通过一个远非直观的过程，提供了一种看起来非常自然的结果。

下一章将描述一种完全不同类型的工厂——一种基于经典工厂模式的 C++模式，它解决语言中的一种不对称性——所有成员函数，甚至是析构函数，都可以是虚拟的，除了构造函数。

# 问题

1.  声明一个函数为*友元*有什么效果？

1.  授予函数友元权限与函数模板的友元权限有什么区别？

1.  为什么二进制运算符通常实现为非成员函数？

1.  为什么插入运算符总是实现为非成员函数？

1.  模板函数和非模板函数的参数转换之间主要区别是什么？

1.  我们如何使模板实例化的过程同时生成一个独特的非模板、非成员函数？
