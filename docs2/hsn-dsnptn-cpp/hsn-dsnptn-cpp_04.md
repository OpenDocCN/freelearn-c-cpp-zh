# 4

# 交换——从简单到微妙

我们从一个非常简单、甚至可以说是谦逊的操作——`std::swap`开始，来探索基本的 C++惯用法。请放心，C++能够将交换这样基本的事情变成一个复杂的问题，具有细微的差别。

本章涵盖了以下主题：

+   标准 C++库中是如何使用`swap`的？

+   交换的应用有哪些？

+   我们如何使用交换编写异常安全的代码？

+   我们如何正确地为我们自己的类型实现交换？

+   我们如何正确地交换任意类型的变量？

# 技术要求

这里有一个链接到本章的所有示例代码：[`github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/main/Chapter04`](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/main/Chapter04)

这是一个链接到 C++核心指南：[`github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md`](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md)

这是一个链接到 C++ **指南支持库**（**GSL**）：[`github.com/Microsoft/GSL`](https://github.com/Microsoft/GSL)

# 交换与标准模板库

交换操作在 C++标准库中被广泛使用。所有`std::swap`。STL 算法中也有交换的使用。标准库也是一个模板，用于实现类似于标准库的自定义功能。

因此，我们将从查看标准提供的功能开始研究交换操作。

## 交换与 STL 容器

从概念上讲，交换等同于以下操作：

```cpp
template <typename T> void swap(T& x, T& y) { T tmp(x);
  x = y;
  y = tmp;
}
```

在调用`swap()`之后，`x`和`y`对象的内容被交换。然而，这可能是实现交换的最糟糕的方式。这种实现的第一和最明显的问题是它不必要地复制了两个对象（实际上进行了三次复制操作）。这个操作的执行时间与`T`类型的大小成比例。对于 STL 容器，大小指的是实际容器的大小，而不是元素类型的大小：

```cpp
void swap(std::vector<int>& x, std::vector<int>& y) {
  std::vector<int> tmp(x);
  x = y;
  y = tmp;
}
```

注意，这段代码可以编译，并且在大多数情况下甚至做对了。然而，它复制了向量的每个元素多次。第二个问题是它临时分配了资源——例如，在交换过程中，我们创建了一个使用与被交换的向量一样多的内存的第三个向量。考虑到最终状态中我们拥有的数据与开始时完全相同；只是我们用来访问这些数据的名称发生了变化，这种分配似乎是不必要的。原始实现中的最后一个问题是在考虑例如我们刚才提到的内存分配失败时出现的。

整个交换操作，本应像交换访问向量元素的名称一样简单且万无一失，却因为内存分配失败而失败。

但这并不是它失败的唯一方式——拷贝构造函数和赋值运算符都可以抛出异常。

所有 STL 容器，包括`std::vector`，都提供保证，它们可以在常数时间内进行交换。如果你考虑到 STL 容器对象本身只包含指向数据的指针和一些状态（如对象大小），那么这种实现方式相当直接。为了交换这些容器，我们只需要交换指针（以及当然的其他状态）——容器中的元素仍然保持在它们始终所在的位置，即在动态分配的内存中，不需要复制或甚至访问。交换的实现只需要交换指针、大小和其他状态变量（在真实的 STL 实现中，容器类，如向量，并不直接由内置类型（如指针）的数据成员组成，而是有一个或多个类数据成员，这些数据成员反过来由指针和其他内置类型组成）。

由于任何指针或其他向量数据成员都不是公开可访问的，交换操作必须实现为容器的成员函数，或者声明为友元。STL 采用前者方法——所有 STL 容器都有一个`swap()`成员函数，用于与同一类型的另一个对象交换对象（参见示例`01a`和`01b`）。

通过交换指针来实现这一点的实现间接地解决了我们提到的另外两个问题。首先，因为只有容器的数据成员被交换，所以没有内存分配。其次，复制指针和其他内置类型不能抛出异常，因此整个交换操作不会抛出（也不能以其他方式失败）。

我们迄今为止描述的简单且一致的图景只是大部分情况下是正确的。第一个复杂问题，而且是最简单的一个，仅适用于那些不仅参数化元素类型，还参数化某种可调用对象的容器。例如，`std::map`容器接受可选的比较函数来比较映射中的元素，默认情况下是`std::less`。这些可调用对象必须与容器一起存储。由于它们被频繁调用，出于性能考虑，最好将它们与容器对象本身放在相同的内存分配中，并且确实它们被作为容器类的数据成员。

然而，这种优化是有代价的——现在交换两个容器需要交换比较函数；也就是说，交换的是实际的对象，而不是指向它们的指针。比较对象由库的客户实现，因此没有保证交换它们是可能的，更不用说它不会抛出异常。

因此，对于`std::map`，标准提供了以下保证——为了使映射可交换，可调用对象也必须是可交换的。此外，交换两个映射不会抛出异常，除非交换比较对象可能会抛出异常，在这种情况下，任何由该交换抛出的异常都将从`std::map`交换中传播。

这种考虑不适用于不使用任何可调用对象的容器，例如`std::vector`，并且交换这些容器仍然不会抛出异常（至少到目前为止我们所知）。

在交换操作中，除了交换操作本身的一致性和自然行为之外，另一个复杂问题是由分配器引起的，这是一个难以解决的问题。考虑以下问题——两个交换的容器必须必然具有相同类型的分配器，但不一定是相同的分配器对象。每个容器都由其自己的分配器为其元素分配内存，并且它们必须由相同的分配器进行释放。交换之后，第一个容器拥有来自第二个容器的元素，并最终必须释放它们。这只能通过使用第一个容器的分配器（正确地）来完成；因此，分配器也必须进行交换。

在`allocator_type`分配器类出现之前，C++标准中有一个`trait`类，它定义了诸如`std::allocator_traits<allocator_type>::propagate_on_container_swap::value`这样的特性属性，如果这个值是`true`，那么分配器将通过非成员交换的不限定调用进行交换；即简单的`swap(allocator1, allocator2)`调用（参见下一节了解该调用实际执行的操作）。如果这个值不是`true`，那么分配器根本不会交换，并且两个容器对象必须使用相同的分配器。如果这也不是`true`，那么我们就回到了未定义行为。STL 容器中的`swap()`成员函数将条件性地声明为`noexcept()`，具有相同的限制。

要求交换两个容器不能抛出异常，至少在分配器不涉及并且容器不使用可调用对象或使用不抛出异常的对象的情况下是这样，这最终对容器的实现施加了一个相当微妙限制——它阻止了使用局部缓冲区优化。

我们将在*第十章*中详细讨论这种优化，*局部* *缓冲区优化*，但简而言之，这个想法是通过在容器类内部定义一个缓冲区来避免为元素非常少的容器（如短字符串）进行动态内存分配。然而，这种优化通常与非抛出异常的交换概念不兼容，因为容器对象内部的元素不能再通过交换指针来交换，而必须在不同容器之间进行复制。

## 非成员交换

标准还提供了一个模板`std::swap()`函数。在 C++11 之前，它在`<algorithm>`头文件中声明；在 C++11 中，它被移动到`<utility>`。函数的声明如下：

```cpp
template <typename T>
  void swap (T& a, T& b);
template <typename T, size_t N>
  void swap(T (&a)[N], T (&b)[N]);    // Since C++11
```

C++11 中增加了数组重载。在 C++20 中，这两个版本都被额外声明为`constexpr`。对于 STL 容器，`std::swap()`调用成员函数`swap()`。正如我们将在下一节中看到的，`swap()`的行为也可以为其他类型定制，但如果没有特别的努力，默认实现就会被使用。这个实现使用一个临时对象进行交换。在 C++11 之前，临时对象是通过拷贝构造来创建的，交换是通过两个赋值操作完成的，就像我们在前一节中所做的那样。类型必须是可拷贝的（即必须可拷贝构造和可拷贝赋值），否则`std::swap()`将无法编译（参见示例`02a`和`02b`）。在 C++11 中，`std::swap()`被重新定义为使用移动构造和移动赋值（参见示例`02c`）。通常，如果类是可拷贝的，但没有声明移动操作，那么就会使用拷贝构造函数和赋值操作。注意，如果类声明了拷贝操作，但声明了移动操作为删除，则没有自动回退到拷贝——那个类是非可移动类型，`std::swap()`将无法编译（参见示例`02d`）。

由于通常拷贝对象可能会抛出异常，因此对于没有提供自定义交换行为的两个对象进行交换也可能抛出异常。移动操作通常不会抛出异常，并且在 C++11 中，如果对象有一个移动构造函数和一个赋值操作符，并且它们都没有抛出异常，`std::swap()`也提供了一个无异常保证。这种行为在 C++17 中通过条件`noexcept()`规范得到了正式化。

## 标准化的交换

从对标准库如何处理交换的前述回顾中，我们可以得出以下准则：

+   支持 swap 的类应该实现执行操作常时间的`swap()`成员函数

+   应为所有可以交换的类型提供一个独立的`swap()`非成员函数

+   交换两个对象不应该抛出异常或以其他方式失败

后一个准则不那么严格，并且并不总是可能遵循。一般来说，如果类型有不会抛出异常的移动操作，那么也可以有一个非抛出异常的 swap 实现。还要注意，许多异常安全性保证，特别是标准库提供的，要求移动和交换操作不能抛出异常。

# 何时以及为什么使用 swap

交换功能为什么如此重要，以至于值得拥有自己的章节？关于这一点，为什么甚至要使用 swap，而不是继续通过原始名称引用对象？

主要是因为异常安全性，这也是我们为什么一直提到何时 swap 可以抛出异常，何时不可以。

## 交换和异常安全性

在 C++中，交换操作最重要的应用是编写异常安全代码，或者更普遍地说，是错误安全代码。简而言之，在异常安全程序中，抛出异常不应该使程序处于未定义状态。

更普遍地说，错误条件不应该使程序处于未定义状态。请注意，错误不需要通过异常处理方式来处理——例如，从函数返回错误代码也应该在不创建未定义行为的情况下处理。特别是，如果操作导致错误，则应释放操作过程中已消耗的资源。通常，人们还希望有一个更强的保证——每个操作要么成功，要么完全回滚。

让我们考虑一个例子，我们将对向量的所有元素应用转换，并将结果存储在一个新的向量中：

```cpp
// Example 03a
class C;            // Our element type
C transmogrify(C x) {    // Some operation on C
  return C(...);
}
void transmogrify(const std::vector<C>& in,
                  std::vector<C>& out) {
  out.resize(0);
  out.reserve(in.size());
  for (const auto& x : in) {
    out.push_back(transmogrify(x));
  }
}
```

在这里，我们通过输出参数返回向量。让我们假设使用一个已经存在的向量作为输出是一个要求，而我们并不是出于性能原因这样做。在所有最近的 C++版本中，通过值返回向量相当快：编译器要么应用返回值优化并完全省略复制（复制省略不是保证的但很可能是的）或者用移动来替换复制（也很快，是保证的）。向量最初为空，并增长到与输入向量相同的大小。`out`向量可能拥有的任何数据都消失了。注意，使用`reserve()`调用来避免重复释放正在增长的向量。

只要没有错误，即没有抛出异常，这段代码就能正常工作。但这并不保证。首先，`reserve()`执行内存分配，可能会失败。如果发生这种情况，`transmogrify()`函数将通过异常退出，并且输出向量将为空，因为`resize(0)`调用已经执行。输出向量的初始内容丢失，并且没有写入任何内容来替换它。其次，对向量元素的任何迭代都可能抛出异常。异常可能由输出向量的新元素的复制构造函数抛出，或者由转换本身抛出。无论如何，循环都会中断。STL 保证，即使在`push_back()`调用中的复制构造函数失败的情况下，输出向量也不会处于未定义状态——新元素不是*部分*创建的，向量大小也不会增加。

然而，已经存储的元素将保留在输出向量中（并且原始存在的任何元素都消失了）。这可能不是我们想要的——要求`transmogrify()`操作要么成功并应用于整个向量，要么失败而不做任何改变，这是合理的。

这种异常安全实现的关键是交换操作：

```cpp
// Example 03b
void transmogrify(const std::vector<C>& in,
                  std::vector<C>& out) {
  std::vector<C> tmp;
  tmp.reserve(in.size());
  for (const C& x : in) {
    tmp.push_back(transmogrify(x));
  }
  out.swap(tmp);    // Must not throw!
}
```

在这个例子中，我们改变了代码，在整个转换过程中操作临时向量。请注意，在典型的输出向量为空输入的情况下，这并不会增加内存的使用量。如果输出向量中有些数据，新数据和旧数据将一直存在于内存中，直到函数结束。这是必要的，以确保旧数据只有在新数据可以完全计算的情况下才会被删除。如果需要，可以通过降低整体内存使用量来交换这个保证，并在函数开始时（另一方面，任何想要进行这种权衡的调用者只需在调用`transmogrify()`之前清空向量）清空输出向量。

如果在执行`transmogrify()`函数的过程中，任何时刻抛出异常，直到最后一行，那么临时向量将被删除，就像在栈上分配的任何局部变量一样（参见*第五章*，本书后面的*RAII 全面探讨*）。最后一行是异常安全的关键——它交换输出向量和临时向量的内容。如果这一行可以抛出异常，那么我们所有的努力都将白费——交换失败，输出向量将处于未定义状态，因为我们不知道在异常抛出之前交换成功了多少。但是，如果交换没有抛出异常，就像`std::vector`的情况一样，那么只要控制流到达最后一行，整个`transmogrify()`操作就成功了，结果将返回给调用者。输出向量的旧内容会发生什么？现在它由临时向量拥有，而临时向量将在下一行（闭括号）隐式删除。假设`C`的析构函数遵循 C++指南并且不会抛出异常（否则将招致可怕的未定义行为），那么我们的整个函数已经实现了异常安全。

这种惯用方法有时被称为**拷贝-交换**，可能是实现具有提交-回滚语义或强异常安全保证的操作的最简单方法。这个惯用方法的关键是能够以低成本且不抛出异常的方式交换对象。

## 其他常见的交换惯用方法

还有几种更常用的技术依赖于交换，尽管它们都没有像交换用于异常安全那样至关重要。

让我们从一种非常简单的方法开始，将容器或任何其他可交换对象重置为其默认构造状态：

```cpp
// Example 04
class C {
    public:
    void swap(C& rhs) noexcept {
        … swap data members …
    }
};
C c = ....;    // Object with stuff in it
{
  C tmp;
  c.swap(tmp);    // c is now default-constructed
}            // Old c is now gone
```

注意，此代码明确创建了一个默认构造的（*空*）对象，仅为了与之交换，并使用额外的范围（一对大括号）来确保该对象尽快被删除。我们可以通过使用一个没有名称的临时对象来交换，做得更好：

```cpp
C c = ....;    // Object with stuff in it
C().swap(c);    // Temporary is created and deleted
```

在这里，临时对象是在同一行代码中创建和删除的，并且它携带了对象 `c` 的旧内容。请注意，交换内容的顺序非常重要——`swap()` 成员函数是在临时对象上被调用的。尝试进行反向操作将无法编译：

```cpp
C c = ....;    // Object with stuff in it
c.swap(C());    // Close but does not compile
```

这是因为 `swap()` 成员函数通过 `C&` 非常量引用来接收其参数，非非常量引用不能绑定到临时对象（更一般地说，到 `r`-值）。请注意，出于同样的原因，`swap()` 非成员函数也不能用于交换对象与临时对象，因此如果类没有 `swap()` 成员函数，那么必须显式创建一个命名对象。

这种习语的更一般形式用于在不更改程序中名称的情况下应用转换到原始对象。假设我们在程序中有一个向量，我们想要应用前面的 `transmogrify()` 函数；然而，我们不想创建一个新的向量。相反，我们想在程序中继续使用原始向量（或者至少它的变量名），但里面包含新的数据。这种习语是实现所需结果的一种优雅方式：

```cpp
// Example 05
std::vector<C> vec;
...                     // Write data into the vector
{
  std::vector<C> tmp;
  transmogrify(vec, tmp);    // tmp is the result
  swap(vec, tmp);        // Now vec is the result!
}                    // and now old vec is destroyed
...                    // Keep using vec, with new data
```

注意，如果 `transmogrify()` 可以抛出异常，我们必须使用整个作用域，包括交换，作为一个 `try` 块来实现异常安全性：

```cpp
std::vector<C> vec;
...                     // Write data into the vector
try {
  std::vector<C> tmp;
  transmogrify(vec, tmp);    // throws an exception
  swap(vec, tmp);        // we never get here
} catch (...) {}            // vec is unchanged
...                     // Keep using vec, with old data
```

这种模式可以根据需要重复多次，替换对象的内容，而不需要在程序中引入新的名称。将其与传统的不使用交换的 C 风格方法进行对比：

```cpp
std::vector<C> vec;
...    // Write data into the vector std::vector<C> vec1;
transmogrify(vec, vec1);    // Must use vec1 from now on!
std::vector<C> vec2;
transmogrify(vec1, vec2);     // Must use vec2 from now on!
```

注意，在计算新数据后，旧名称 `vec` 和 `vec1` 仍然可访问。在以下代码中使用 `vec` 而不是 `vec1` 将是一个容易犯的错误。使用之前演示的交换技术，程序不会被新的变量名称所污染。

## 如何正确实现和使用交换

我们已经看到了标准库如何实现交换功能，以及对于交换实现的期望。现在让我们看看如何正确支持您自己的类型的交换。

## 实现交换

我们已经看到，所有 STL 容器以及许多其他标准库类型（例如，`std::thread`）都提供了一个 `swap()` 成员函数。虽然这不是必需的，但这是实现交换的最简单方法，因为它需要访问类的私有数据，以及交换相同类型的对象与临时对象的唯一方法。正确声明 `swap()` 成员函数的方式如下：

```cpp
class C {
  public:
  void swap(C& rhs) noexcept;
};
```

当然，只有当确实可以提供无抛出保证时，才应包含 `noexcept` 规范；在某些情况下，它可能需要基于其他类型的属性进行条件化。如果适当，函数也可以声明为 `constexpr`。

如何实现交换？有几种方法。对于许多类，我们可以简单地逐个交换数据成员。这会将交换对象的问题委托给它们包含的类型，如果它们遵循该模式，最终会结束于交换构成一切的内建类型。如果你知道你的数据成员有一个`swap()`成员函数，那么你可以调用它。否则，你必须调用非成员交换。这很可能会调用`std::swap()`模板的一个实例化，但你不应通过该名称调用它，原因将在下一节中解释。

相反，你应该将名称引入包含作用域，并调用`swap()`而不使用`std::`限定符：

```cpp
//Example 06a
#include <utility>    // <algorithm> before C++11
...
class C {
  public:
  void swap(C& rhs) noexcept {
    using std::swap;    // Brings in std::swap into this scope
    v_.swap(rhs.v_);
    swap(i_, rhs.i_);    // Calls std::swap
  }
  ...
  private:
  std::vector<int> v_;
  int i_;
};
```

一种非常适用于交换的特定实现习惯用法是所谓的`.C`文件。实现数据的指针成员通常被称为`p_impl`或`pimpl`，因此得名该习惯用法。交换 pimpl 实现的类就像交换两个指针一样简单：

```cpp
// Example 06b
// In the header C.h:
class C_impl;        // Forward declaration
class C {
  public:
  void swap(C& rhs) noexcept {
    swap(pimpl_, rhs.pimpl_);
  }
  void f(...);        // Declaration only
  ...
  private:
  C_impl* pimpl_;
};
// In the C file:
class C_impl {
  ... real implementation ...
};
void C::f(...) {
  pimpl_->f(...);    // Actual implementation of C::f()
}
```

这就处理了成员函数`swap()`。但如果有人在我们的自定义类型上调用非成员`swap()`函数呢？按照目前的写法，这个调用将调用`std::swap()`的默认实现，如果它是可见的（例如，由于`using std::swap`声明），即使用复制或移动操作的那个实现。

```cpp
// Example 07a
class C {
  public:
  void swap(C& rhs) noexcept;
};
...
C c1(...), c2(...);
swap(c1, c2);    // Either does not compile
             // or calls std::swap
```

尽管我们有一个`swap()`成员函数，但`std::swap`并没有使用它。很明显，我们也必须支持一个非成员的`swap()`函数。我们可以在类声明之后轻松地声明一个，然而，我们也应该考虑如果类不是在全局作用域中声明，而是在一个命名空间中声明会发生什么：

```cpp
// Example07b
namespace N {
  class C {
    public:
    void swap(C& rhs) noexcept;
  };
  void swap(C& lhs, C& rhs) noexcept { lhs.swap(rhs); }
}
...
N::C c1(...), c2(...);
swap(c1, c2);    // Calls non-member N::swap()
```

无限定符调用`swap()`会调用`N`命名空间内的`swap()`非成员函数，该函数反过来会调用其中一个参数上的成员函数`swap()`（标准库采用的约定是调用`lhs.swap()`）。请注意，然而，我们没有调用`N::swap()`，而是只调用了`swap()`。在`N`命名空间之外，并且没有`using namespace N;`指定的情况下，无限定符调用通常不会解析为命名空间内的函数。然而，在这种情况下，它确实解析了，这是由于标准中的一个特性，称为**参数依赖查找**（**ADL**），也称为**科宁查找**。ADL 将所有在函数参数声明的作用域中声明的函数添加到重载解析中。

在我们的例子中，编译器在弄清楚`swap(...)`函数中的`c1`和`c2`参数所引用的`swap`名称之前，就已经将它们的类型识别为`N::C`。由于这些参数位于`N`命名空间中，因此该命名空间中声明的所有函数都会被添加到重载解析中，从而使`N::swap`函数变得可见。

如果类型有一个 `swap()` 成员函数，那么实现非成员 `swap()` 函数的最简单方法就是调用它。然而，这样的成员函数不是必需的；如果决定不支持 `swap()` 成员函数，那么非成员 `swap()` 必须能够访问类的私有数据。它必须被声明为一个 `friend` 函数：

```cpp
// Example 07c
class C {
  friend void swap(C& rhs) noexcept;
};
void swap(C& lhs, C& rhs) noexcept {
  ... swap data members of C ...
}
```

还可以在不使用单独定义的情况下，内联定义 `swap()` 函数的实现：

```cpp
// Example 07d
class C {
  friend void swap(C& lhs, C& rhs) noexcept {
    ... swap data members of C ...
  }
};
```

当我们有一个类模板而不是单个类时，这尤其方便。我们将在稍后的 *第十一章*，*作用域保护* 中更详细地考虑这个模式。

一个常被遗忘的实现细节是自我交换——`swap(x, x)`，或者，在成员函数调用的情况下，`x.swap(x)`。这是否定义良好？它到底做了什么？答案似乎是在 C++03 和 C++11（以及之后的版本）中，它应该是定义良好的，但最终什么也不做；也就是说，它不会改变对象（尽管不一定是零成本）。用户定义的 swap 实现应该对自我交换是隐式安全的，或者应该显式检查它。如果 swap 是基于复制或移动赋值实现的，那么需要注意的是，标准要求复制赋值必须对自我赋值是安全的，而移动赋值可能会改变对象，但必须将其置于一个有效状态，称为 **已移动状态**（在这个状态下，我们仍然可以将其他东西赋值给对象）。

我们还应该注意，同名但功能不同的 STL 函数 `std::iter_swap` 和 `std::swap_ranges` 实际上是使用 `swap()` – 可能是 `std::swap` – 来交换迭代器或迭代器范围的值的算法。它们也是如何正确调用 `swap()` 函数的一个例子，不仅是在 STL 中，而且在代码的任何地方，如下一节所示。

## 正确使用 swap

到目前为止，我们一直在调用 `swap()` 成员函数、`swap()` 非成员函数和显式命名的 `std::swap()` 操作之间切换，没有任何模式或理由。我们现在应该在这方面引入一些纪律。

首先，只要你知道它存在，调用 `swap()` 成员函数总是安全且合适的。后者的条件通常在编写模板代码时出现——当处理具体类型时，你通常知道它们提供了什么接口。这让我们只剩下一个问题——在调用 `swap()` 非成员函数时，我们应该使用 `std::` 前缀吗？

考虑以下情况，如图所示：

```cpp
// Example 08
namespace N {
  class C {
    public:
    void swap(C& rhs) noexcept;
  };
  void swap(C& lhs, C& rhs) noexcept { lhs.swap(rhs); }
}
...
N::C c1(...), c2(...);
std::swap(c1, c2);    // Calls std::swap()
swap(c1, c2);        // Calls N::swap()
```

注意，基于参数的查找不适用于合格名称，这就是为什么对`std::swap()`的调用仍然调用 STL 的`<utility>`头文件中模板`swap`的实例化。因此，建议永远不要显式调用`std::swap()`，而是使用`using`声明将那个重载引入当前作用域，然后调用无前缀的`swap`：

```cpp
using std::swap;    // Makes std::swap() available
swap(c1, c2);    // Calls N::swap() if provided
             // Otherwise, calls std::swap()
```

这正是 STL 算法所做的事情。例如，`std::iter_swap`通常是这样实现的：

```cpp
template <typename Iter1, typename Iter2>
void iter_swap(Iter1 a, ITer2 b) {
  using std::swap;
  swap(*a, *b);
}
```

不幸的是，`std::swap()`的完全合格调用在许多程序中很常见。为了保护自己免受此类代码的影响，并确保无论发生什么情况都能调用你的自定义`swap`实现，你可以为你自己的类型实例化`std::swap()`模板：

```cpp
// Example 09
namespace std {
void swap(N::C& lhs, N::C& rhs) noexcept {
  lhs.swap(rhs); }
}
```

通常，根据标准，不允许声明自己的函数或类用于保留的`std::`命名空间。然而，标准为某些模板函数的显式实例化（包括`std::swap()`）做出了例外。有了这样的特化，对`std::swap()`的调用将调用那个实例化，并将其转发到我们的自定义`swap`实现。请注意，仅实例化`std::swap()`模板是不够的，因为这样的实例化不参与基于参数的查找。如果未提供其他非成员`swap`函数，我们将遇到相反的问题：

```cpp
using std::swap;        // Makes std::swap() available
std::swap(c1, c2);    // Calls our std::swap() overload
swap(c1, c2);        // Calls default std::swap()
```

现在，非合格调用最终会调用默认的`std::swap()`操作的实例化——即带有移动构造函数和赋值操作的实例。为了确保每个`swap`调用都得到正确处理，应该实现一个非成员`swap()`函数和显式的`std::swap()`实例化（当然，它们可以，并且应该，都转发到相同的实现）。最后，请注意，标准允许我们通过模板实例化扩展`std::`命名空间，但不允许通过额外的模板重载。因此，如果我们有一个类模板而不是单个类型，我们不能为它特化`std::swap`；这样的代码很可能会编译，但标准不保证会选择所需的重载（技术上，标准调用未定义的行为并保证一切）。因此，直接调用`std::swap`应该避免。

# 摘要

C++中的 swap 功能用于实现几个重要模式。其中最关键的是异常安全事务的拷贝-交换实现。所有标准库容器以及大多数其他 STL 对象都提供了快速且在可能的情况下不抛出异常的 swap 成员函数。需要支持 swap 的用户定义类型应遵循相同的模式。然而，请注意，实现非抛出异常的 swap 函数通常需要额外的间接引用，并违反了几个优化模式。除了成员函数 swap 之外，我们还回顾了非成员 swap 的使用和实现。鉴于`std::swap`总是可用，并且可以在任何可拷贝或可移动的对象上调用，如果给定类型存在更好的 swap 方式（特别是任何具有成员函数 swap 的类型也应提供调用该成员函数的非成员函数重载），程序员应确保实现非成员 swap 函数。

最后，虽然不推荐，但非成员 swap 的替代用法足够常见，以至于应该考虑隐式实例化`std::swap`模板。

下一章将带我们游览 C++中最流行且强大的惯用法之一——C++管理资源的方式。

# 问题

1.  swap 的作用是什么？

1.  swap 在异常安全程序中是如何使用的？

1.  为什么 swap 函数应该是非抛出异常的？

1.  应该优先选择成员或非成员的 swap 实现？

1.  标准库对象是如何实现 swap 的？

1.  为什么非成员 swap 函数应该不带`std::`限定符调用？
