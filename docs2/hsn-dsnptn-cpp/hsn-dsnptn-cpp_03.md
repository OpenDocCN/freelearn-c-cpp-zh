# 3

# 内存与所有权

内存管理不当是 C++程序中最常见的问题之一。许多这些问题归结为对代码的哪一部分或哪个实体拥有特定内存的错误假设。然后，我们得到内存泄漏、访问未分配的内存、过度使用内存和其他难以调试的问题。现代 C++有一套内存所有权惯用法，当结合起来时，允许程序员在内存所有权方面清楚地表达他们的设计意图。这反过来又使得编写正确分配、访问和释放内存的代码变得容易得多。

本章涵盖了以下主题：

+   什么是内存所有权和资源所有权？

+   优秀设计的资源所有权的特征是什么？何时以及如何对资源所有权保持无知？我们如何在 C++中表达独占内存所有权？

+   我们如何在 C++中表达共享内存所有权？

+   不同内存所有权语言结构的成本是什么？

# 技术要求

您可以在[`github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md`](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md)找到 C++核心指南。

您可以在[`github.com/Microsoft/GSL`](https://github.com/Microsoft/GSL)找到 C++ **指南支持库**（**GSL**）。示例可在[`github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter03`](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter03)找到。

# 什么是内存所有权？

在 C++中，术语*内存所有权*指的是负责执行特定内存分配生命周期的实体。实际上，我们很少谈论原始内存的所有权。通常，我们管理驻留在该内存中的对象的所有权和生命周期，而内存所有权实际上只是*对象所有权*的简称。内存所有权的概念与*资源所有权*的概念紧密相关。首先，内存是一种资源。它不是程序可以管理的唯一资源，但它是迄今为止最常用的一个。其次，C++管理资源的方式是让对象拥有它们。因此，管理资源的问题简化为管理拥有对象的 问题，正如我们刚刚学到的，这就是我们谈论内存所有权时真正所指的。在这种情况下，内存所有权不仅仅是关于拥有内存，管理不当的所有权可能会导致泄漏、误计或丢失任何程序可以控制的资源——内存、互斥锁、文件、数据库句柄、猫视频、航班座位预订或核弹头。

## 优秀设计的内存所有权

设计良好的内存所有权看起来是什么样子？首先浮现出的朴素答案是，在程序的每个点上，都清楚谁拥有哪个对象。然而，这过于约束——程序的大部分内容并不处理资源的所有权，包括内存。这些程序部分仅仅使用资源。在编写此类代码时，知道特定的函数或类不拥有内存就足够了。知道谁做什么是完全无关紧要的：

```cpp
struct MyValues { long a, b, c, d; }
void Reset(MyValues* v) {
  // Don't care who owns v, as long as we don't
  v->a = v->b = v->c = v->d = 0;
}
```

那么，这样呢——在程序的每个点上，是否清楚谁拥有那个对象，或者是否清楚所有者没有改变？这更好，因为大部分代码将属于我们答案的第二部分。然而，这仍然过于约束——在获取对象所有权时，通常并不重要知道它是从哪里获取的：

```cpp
class A {
  public:
  // Constructor transfers ownership from whomever
  A(std::vector<int>&& v) : v(std::move(v)) {}
  private:
  std::vector<int> v_;    // We own this now
};
```

同样，共享所有权的全部意义（通过引用计数的`std::shared_ptr`表达）是我们不需要知道谁还拥有该对象：

```cpp
class A {
  public:
  // No idea who owns v, don't care
  A(std::shared_ptr<std::vector<int>> v) : v_(v) {}
  // Sharing ownership with any number of owners
  private:
  std::shared_ptr<std::vector<int>> v_;
};
```

对设计良好的内存所有权的更准确描述需要不止一句话。一般来说，以下是一些良好的内存所有权实践的特征：

+   如果一个函数或类以任何方式不改变内存所有权，这一点应该对每个函数或类的客户端以及实现者都是清晰的。

+   如果一个函数或类独占拥有传递给它的某些对象，这一点应该对客户端是清晰的（我们假设实现者已经知道这一点，因为他们必须编写代码）。

+   如果一个函数或类与它传递的对象共享所有权，这一点应该对客户端（或者任何阅读客户端代码的人）是清晰的。

+   对于每个创建的对象，对于每个使用它的代码单元，都清楚这段代码是否预期删除该对象。

## 设计不良的内存所有权

正如良好的内存所有权无法用简单的描述来概括，而是通过它满足的一系列标准来定义一样，不良的内存所有权实践也可以通过它们的共同表现来识别。一般来说，良好的设计使代码是否拥有资源变得清晰，而糟糕的设计则需要额外的知识，这些知识不能从上下文中推断出来。例如，以下`MakeWidget()`函数返回的对象由谁拥有？

```cpp
Widget* w = MakeWidget();
```

客户是否需要在不再需要时删除小部件？如果是，应该如何删除？如果我们决定删除小部件并以错误的方式执行，例如，在实际上没有通过`operator new`分配的小部件上调用`operator delete`，则肯定会发生内存损坏。在最佳情况下，程序将只是崩溃：

```cpp
WidgetFactory WF;
Widget* w = WF.MakeAnother();
```

工厂是否拥有它创建的小部件？当工厂对象被删除时，它会删除它们吗？或者，客户端被期望去做这件事？如果我们决定工厂可能知道它创建了什么，并且将在适当的时候删除所有这样的对象，我们可能会遇到内存泄漏（或者更糟，如果对象拥有其他资源）：

```cpp
Widget* w = MakeWidget();
Widget* w1 = Transmogrify(w);
```

`Transmogrify()` 是否拥有小部件的所有权？在 `Transmogrify()` 完成对小部件的处理后，`w` 小部件是否仍然存在？如果为了构建一个新的、经过转换的 `w1` 小部件而删除了小部件，我们现在有一个悬垂指针。如果我们没有删除小部件，但假设它可能被删除，我们就有了一个内存泄漏。

不要以为所有糟糕的内存管理实践都可以通过存在原始指针来识别，这里有一个关于内存管理的较差方法的例子，这种做法通常是对使用原始指针造成的问题的一种本能反应：

```cpp
void Double(std::shared_ptr<std::vector<int>> v) {
  for (auto& x : *v) {
    x *= 2;
  }
};
...
std::shared_ptr<std::vector<int>> v(...);
Double(v);
...
```

`Double()` 函数在其接口中声称它对向量拥有共享所有权。然而，这种所有权完全是多余的——`Double()` 没有必要拥有其参数——它不试图延长其生命周期，也不将所有权转让给任何人；它只是修改了调用者传入的向量。我们可以合理地期望调用者拥有该向量（或者甚至更高层次的调用栈中的某人拥有），并且当 `Double()` 将控制权返回给调用者时，向量仍然存在——毕竟，调用者希望我们将元素加倍，可能以便进行其他操作。

虽然这个列表远非完整，但它有助于展示由于对内存所有权的草率处理可能引起的问题范围。在下一节中，我们将回顾 C++ 社区开发的模式和指南，以帮助避免这些问题并清楚地表达程序员的意图。

# 在 C++ 中表达内存所有权

在其历史发展过程中，C++语言在表达内存所有权方面的方法不断演变。有时，相同的语法结构被赋予了不同的假设语义。这种演变部分是由语言中添加的新特性所驱动的（如果没有共享指针，就很难谈论共享内存所有权）。另一方面，C++11 及以后版本中添加的大多数内存管理工具并非新想法或新概念。共享指针的概念已经存在很长时间了。这种语言支持使得实现它变得更加容易（并且标准库中的共享指针使得大多数自定义实现变得不必要），但共享指针在 C++11 将其添加到标准之前就已经在 C++中使用。更为重要的变化是 C++社区对内存所有权的理解演变，以及共同实践和习惯用法的出现。正是在这个意义上，作为与不同语法特征相关联的一组惯例和语义，我们可以将内存管理实践视为 C++语言的设计模式。现在，让我们学习可以表达不同类型内存所有权的不同方法。

## 表达非拥有权

让我们从最常见的内存所有权类型开始。大多数代码并不分配、释放、构造或删除。它只是在由他人先前创建并由他人稍后删除的对象上执行其工作。你如何表达一个函数将要操作一个对象，但不会尝试删除它，或者相反，在函数本身完成之后延长其生命周期的概念？

实际上非常简单，每个 C++程序员都多次这样做：

```cpp
// Example 01
void Transmogrify(Widget* w) {        // I will not delete w
  ...
}
void MustTransmogrify(Widget& w) {   // Neither will I
  ...
}
```

在一个编写良好的程序中，具有原始指针参数的函数表明它以任何方式都不参与相应对象的拥有权；引用也是同样的情况。同样，包含成员函数指针的类引用一个对象，但期望其他人拥有它并管理其生命周期。请注意，下一个示例中`WidgetProcessor`类的析构函数不会删除该类所指向的对象——这是我们不拥有该对象的明确标志：

```cpp
// Example 02
class WidgetProcessor {
  public:
  WidgetProcessor(Widget* w) : w_(w) {}
  WidgetProcessor() {} // DO NOT delete w_!!!
    ...
  private:
  Widget* w_;    // I do not own w_
};
```

应该通过使用原始指针或引用来授予对对象的非拥有访问权限。是的——即使在 C++14 中，尽管它拥有所有智能指针，原始指针也有其位置。不仅如此，在大量代码中，大多数指针将是原始指针——所有非拥有指针（正如我们将在下一节中看到的，C++17 和 C++20 在这方面走得更远）。

你可能会在这个时候合理地指出，前面推荐的授予非拥有访问权的示例看起来与之前展示的坏习惯示例之一完全一样。区别在于上下文——在一个设计良好的程序中，只有非拥有访问权是通过原始指针和引用授予的。实际的所有权总是以某种其他方式表达。因此，当遇到原始指针时，函数或类不会以任何方式干涉对象的所有权。当然，这会在将带有原始指针的旧遗产代码转换为现代实践时造成一些混淆。为了清晰起见，建议一次转换一部分代码，并在遵循现代指南的代码和不遵循的代码之间清楚地标明过渡。

另一个需要讨论的问题是指针与引用的使用。就语法而言，引用基本上是一个永远不会为空的指针，并且不能被未初始化。采用一种约定，任何传递给函数的指针都可能为空，因此必须进行检查，任何不能接受空指针的函数必须改为接受引用。这是一个好习惯，并且被广泛使用，但使用得还不够广泛，以至于可以被视为一个接受的设计模式。也许是为了认识到这一点，C++ Core Guidelines 库提供了一个表达非空指针的替代方案——`not_null<T*>`。请注意，这本身不是语言的一部分，但可以在标准 C++ 中实现，而不需要任何语言扩展。

## 表达独占所有权

第二种最常见的所有权类型是独占所有权——代码创建一个对象，稍后会删除它。删除任务不会被委托给其他人，并且不允许对象寿命的扩展。这种内存所有权如此常见，以至于我们经常这样做，甚至没有意识到：

```cpp
void Work() {
  Widget w;
  Transmogrify(w);
  Draw(w);
}
```

所有局部（栈）变量都表达独特的内存所有权！请注意，在这个上下文中，“所有权”并不意味着其他人不会修改该对象。它仅仅意味着当`w`小部件的创建者——在我们的例子中是`DoWork()`函数——决定删除它时；删除将成功（还没有人删除它）并且对象实际上将被删除（没有人试图在作用域结束时保持对象存活）。

这是在 C++ 中构建对象的最古老方式，但仍然是最好的方式。如果栈变量能满足你的需求，就使用它。C++ 11 提供了另一种表达独家所有权的方法，它主要用在对象不能在栈上创建而必须分配在堆上的情况下。堆分配通常发生在所有权共享或转移时——毕竟，栈分配的对象将在包含作用域的末尾被删除；这是无法避免的。如果我们需要让对象存活更长时间，它必须分配在其他地方。创建对象在堆上的另一个原因是对象的大小或类型可能在编译时未知。这通常发生在对象是多态的情况下——创建了一个派生对象，但使用了基类指针。无论不分配对象在栈上的原因是什么，我们都有一种方法可以使用 `std::unique_ptr` 来表达这种对象的独家所有权：

```cpp
// Example 03
class FancyWidget : public Widget { ... };
std::unique_ptr<Widget> w(new FancyWidget);
```

还有一个技术原因，即使栈分配的对象似乎足够用，你也可能需要在堆上构建对象：栈的大小相当有限，通常在 2 MB 到 10 MB 之间。这是单个线程中所有栈分配的空间，当它超过这个限制时，程序会崩溃。足够大的对象可能会耗尽栈空间，或者将其推得太接近限制，以至于后续的分配无法进行。这样的对象必须创建在堆上，并由栈分配的唯一指针或其他资源拥有对象拥有。

如果创建对象的方式比仅仅使用 `operator new` 更复杂，我们需要一个工厂函数？这就是我们将考虑的类型的所有权。

## 表达独家所有权的转移

在前面的例子中，创建了一个新的对象，并立即将其绑定到一个唯一的指针，`std::unique_ptr`，这保证了独家所有权。如果对象是由工厂创建的，客户端代码看起来完全一样：

```cpp
std::unique_ptr<Widget> w(WidgetFactory());
```

但工厂函数应该返回什么？它当然可以返回一个原始指针，`Widget*`。毕竟，这就是 `new` 返回的内容。但这为错误使用 `WidgetFactory` 开辟了道路——例如，我们可能不会在唯一指针中捕获返回的原始指针，而是将其传递给一个像 `Transmogrify` 这样的函数，该函数接受原始指针因为它不处理所有权。现在，没有人拥有小部件，最终导致内存泄漏。理想情况下，`WidgetFactory` 应该被编写成强制调用者接收返回对象的拥有权。

我们在这里需要的是所有权转移——`WidgetFactory` 当然是它所构建的对象的独家所有者，但在某个时候，它需要将所有权转交给一个新的、也是独家所有者。执行此操作的代码非常简单：

```cpp
// Example 04
std::unique_ptr<Widget> WidgetFactory() {
  Widget* new_w = new Widget;
    ...
  return std::unique_ptr<Widget>(new_w);
}
std::unique_ptr<Widget> w(WidgetFactory());
```

这正是我们想要的方式，但为什么？难道唯一指针不提供独占所有权吗？答案是，它确实提供了，但它也是一个可移动对象（它有一个移动构造函数）。将唯一指针的内容移动到另一个唯一指针中会转移对象的所有权；原始指针将留在移动前的状态（它的销毁不会删除任何对象）。这种习语有什么好处呢？它清楚地表达了，并在编译时强制要求，工厂期望调用者对对象拥有独占（或共享）所有权。例如，以下代码，它会导致新的小部件没有所有者，无法编译：

```cpp
void Transmogrify(Widget* w);
Transmogrify(WidgetFactory());
```

那么，在我们正确假定所有权之后，我们如何调用`Transmogrify()`函数呢？这仍然是通过原始指针来完成的：

```cpp
std::unique_ptr<Widget> w(WidgetFactory());
Transmogrify(w.get());
Transmogrify(&*w);     // same as above if w is not null
```

但栈变量怎么办？在变量被销毁之前，所有权能否转移到其他人那里？这将会稍微复杂一些——对象的内存是在栈上分配的，并且正在消失，因此涉及到一些复制操作。确切需要复制的量取决于对象是否可移动。一般来说，移动操作会将所有权从被移动的对象转移到移动到的对象。这可以用于返回值，但更常用于传递参数给需要独占所有权的函数。这些函数必须声明为通过`rvalue`引用`T&&`来接受参数：

```cpp
// Example 05
void Consume(Widget&& w) {
  auto my_w = std::move(w);
    ...
}
Widget w, w1;
Consume(std::move(w));    // No more w
// w is in a moved-from state now
Consume(w1);    // Does not compile - must consent to move
```

注意，调用者必须通过将参数包裹在`std::move`中来显式放弃所有权。这是这种习语的优点之一；没有它，所有权转移的调用将看起来与普通调用完全相同。

## 表达共享所有权

我们需要覆盖的最后一种所有权类型是共享所有权，其中多个实体平等地拥有该对象。首先，提醒一下——共享所有权经常被误用，或者过度使用。考虑前面的例子，其中函数传递了一个它不需要拥有的对象的共享指针。让引用计数处理对象的所有权并且*不担心删除*是很诱人的。然而，这通常是设计不佳的迹象。在大多数系统中，在某个层面上，资源有明确的归属，并且这一点应该反映在资源管理的选择设计中。*不担心删除*的担忧仍然有效；显式删除对象应该是罕见的，但自动删除不需要共享所有权，只需要明确表达的所有权（唯一指针、数据成员和容器同样可以提供自动删除）。

话虽如此，共享所有权确实有一些明确的用例。共享所有权最常见的有效应用是在底层，例如在列表、树等数据结构内部。一个数据元素可能被同一数据结构的其他节点拥有，也可能被任何数量的当前指向它的迭代器拥有，还可能是由操作整个结构或其一部分（例如树的重新平衡）的数据结构成员函数中的某些临时变量拥有。在精心设计的情况下，整个数据结构的所有权通常是明确的。但每个节点或数据元素的所有权在真正意义上可能是共享的，即任何所有者都等同于其他所有者；没有一个是特权或主要的。

在 C++中，共享所有权的概念通过共享指针`std::shared_ptr`来表示：

```cpp
// Example 06
struct ListNode {
  T data;
  std::shared_ptr<ListNode> next, prev;
};
class ListIterator {
  ...
  std::shared_ptr<ListNode> node_;
};
class List {
  ...
  std::shared_ptr<ListNode> head_;
};
```

这种设计的优点是，从列表中解除链接的列表元素只要存在一种通过迭代器访问它的方式就会保持活跃。这并不是`std::list`的做法，它不提供这样的保证（删除`std::list`对象会使所有迭代器失效）。请注意，共享指针的双向链表使得列表中任何两个连续的节点都相互拥有对方，即使列表头被删除，它们也不会被删除；这会导致拥有的对象泄漏。因此，实际的设计可能会使用`std::weak_pointer`作为`next`或`prev`之一。

除了这些复杂性之外，这可能是一些应用程序的有效设计，在这些应用程序中，迭代器需要在列表被删除或某些元素从列表中删除后仍然拥有它们所引用的数据。一个例子是线程安全的列表，在这种情况下，很难保证一个线程不会在另一个线程仍然有一个指向它的迭代器时删除列表元素。请注意，这个特定的应用程序还需要原子共享指针，这些指针仅在 C++ 20 中可用（或者你可以使用 C++ 11 编写自己的）。

现在，关于接受共享指针作为参数的函数呢？在一个遵循良好内存所有权实践的程序中，这样的函数会向调用者传达它打算获取比函数调用本身持续时间更长的部分所有权——将创建共享指针的副本。在并发环境中，这也可能表明函数需要保护对象免受另一个线程删除，至少在它执行期间。

共享所有权的几个缺点你必须牢记在心。最著名的一个是共享指针的祸害，即循环依赖。如果两个具有共享指针的对象相互指向对方，整个对将无限期地保持*使用状态*。C++通过`std::weak_ptr`的形式提供了一个解决方案，它是共享指针的对应物，提供了一个指向可能已经被删除的对象的安全指针。如果前面提到的对象对使用了一个共享指针和一个弱指针，循环依赖就会被打破。

循环依赖问题确实是存在的，但它更常出现在使用共享所有权来掩盖资源所有权不明确这一更大问题的设计中。然而，共享所有权还有其他缺点。共享指针的性能始终会低于原始指针。另一方面，唯一指针可以与原始指针一样高效（实际上，`std::unique_ptr` 就是）。当共享指针首次创建时，必须进行额外的内存分配来存储引用计数。

在 C++11 中，可以使用 `std::make_shared` 来结合对象本身的分配和引用计数器的分配，但这意味着对象是带有共享意图创建的（通常，对象工厂返回的是唯一指针，其中一些后来被转换为共享指针）。复制或删除共享指针时，也必须增加或减少引用计数器。共享指针在并发数据结构中通常很有吸引力，在这些数据结构中，至少在低级别上，所有权的概念可能确实模糊，同时有多个访问同一对象的情况发生。然而，设计一个在所有上下文中都线程安全的共享指针并不容易，并且会带来额外的运行时开销。

到目前为止，我们主要将指针作为拥有对象（及其内存和其他资源）的手段（非拥有性也通过原始指针和引用或简单的非拥有性指针来表示）。然而，这并不是拥有资源的唯一方式（我们之前也提到，最常见的独占拥有形式是栈变量）。现在我们将看到如何直接使用拥有资源的对象来表示拥有性和非拥有性。

# 拥有对象和视图

C++ 自创建以来并未局限于拥有指针：任何对象都可以拥有资源，我们之前也提到，表达独占所有权的最简单方式是在栈上创建一个局部变量。当然，这样的对象也可以被指针（唯一或共享）拥有，当需要非拥有性访问时，这些对象通常通过原始指针或引用来访问。然而，在 C++17 和 C++20 中出现了一种不同的模式，这值得探索。

## 拥有资源的对象

每个熟悉 C++ 的程序员都熟悉拥有资源的对象；可能最常见的一个是 `std::string` – 一个拥有字符字符串的对象。当然，它也有许多专门的操作字符串的成员函数，但从内存所有权的角度来看，`std::string` 实质上是一个拥有 `char*` 指针。同样，`std::vector` 是任意类型对象数组的拥有对象。

构建此类对象最常见的方式是作为局部变量或作为类的数据成员。在后一种情况下，整个类的所有权问题由其他地方管理，但在类内部，所有数据成员都由对象本身独占拥有。考虑这个简单的例子：

```cpp
class C {
  std::string s_;
};
 …
std::vector<int> v = … ;    // v owns the array of int
C c;                       // c owns the string s
```

到目前为止，与本章前面几页关于独占所有权的部分相比，我们并没有说出任何新的内容。然而，我们已经微妙地将焦点从拥有指针转变为拥有对象。只要我们关注所有权方面，这些对象本质上就是专门的拥有（唯一）指针。然而，有一个重要的区别：大多数这样的对象会传递额外的信息，例如`std::string`的字符串长度或`std::vector`的数组大小。请记住：当我们到达 C++17/20 带来的变化时，这个问题还会再次出现。

虽然资源拥有对象自 C++开始以来就存在，但它们自身通常是通过指针拥有的。可能有两个主要原因；这两个原因都已被 C++的进步所淘汰。例如，通过拥有指针拥有字符串的第一个原因是需要转移所有权。栈对象在作用域结束时被销毁。类数据成员在对象被销毁时被销毁。在两种情况下，都没有办法将对象本身的所有权（例如`std::string`）转移到其他人。然而，如果我们关注所有权方面，那么字符串对象本身就是一个（装饰过的）拥有指针，目标是把底层资源（`std::string`的字符字符串）的所有权转移到另一个所有者。当我们这样表述时，答案很明显：自 C++11 以来，字符串有了移动语义，移动字符串几乎和移动指针一样便宜（记住，字符串是一个知道长度的拥有指针，所以长度也必须移动）。

我们可以更普遍地说，如果唯一的原因是所有权转移，就没有必要通过指针拥有一个易于移动的所有权对象。例如，考虑这个字符串构建器类：

```cpp
class Builder {
  std::string* str_;
  public:
  Builder(…) : str_(new std::string){
    … construct string str_ …
  }
  std::string* get(){
    std::string* tmp = str_;
    str_ = nullptr;
    return tmp;
  }
};
```

虽然这样做可以完成任务，但编写相同类的更好方法是简单地移动字符串：

```cpp
// Example 07
class Builder {
  std::string str_;
  public:
  Builder(…){ … construct string str_ … }
  std::string get(){ return std::move(str_); }
};
std::string my_string = Builder(…).get();
```

对于构建拥有易于移动对象的工厂来说，也是如此。工厂不是通过`std::unique_ptr`返回它们，而是可以直接返回对象本身：

```cpp
std::string MakeString(…) {
  std::string str;
  … construct the string …
  return str;
}
std::string my_string = MakeString(…);
```

返回值可能受益于返回值优化（编译器直接在为最终对象`my_string`分配的内存中构造返回值）。即使没有这种优化，我们也有保证这里没有复制字符串，只有移动（如果这个移动被优化掉，这种优化有时被称为**移动省略**，类似于更为人所知的**复制省略**，它优化掉了复制构造函数）。

使用所有权指针来处理资源拥有对象的第二个原因是对象的存在本身可能是条件性的：

```cpp
std::unique_ptr<std::string*> str;
if (need_string) str.reset(new std::string(…args…));
```

在许多情况下，可以使用“*空*”对象来代替，例如零长度的字符串。同样，对于许多拥有对象，尤其是对于所有廉价的移动 STL 容器，构建此类对象的开销是微不足道的。但是，空字符串和完全没有字符串（即空字符串可能是一个有效的结果，而没有任何字符串的存在对程序的其他部分有特殊意义）之间可能存在有意义的差异。在 C++17 中，我们可以使用`std::optional`来直接表达这种行为：

```cpp
std::optional<std::string> str;
if (need_string) str.emplace(…args…);
```

`std::optional<std::string>`类型的对象可能包含一个字符串或为空。非空的`std::optional`拥有它包含的对象（删除`std::optional`也会删除字符串）。与`std::unique_pointer`不同，这里没有堆内存分配：`std::optional`对象内部有足够的空间来存储`std::string`对象。`std::optional`也是可移动的，就像字符串本身一样，因此这种模式可以与之前的一种模式结合。总的来说，我们可以说在现代 C++中，没有必要间接拥有像`std::string`这样的轻量级所有权对象。然而，表达此类对象非所有权的做法直到最近才得到足够的关注。

## 对资源拥有对象的非所有权访问

我们已经看到`std::string`对象在大多数情况下可以替代`char*`（或`std::string`）的所有权指针。那么，我们如何表达非所有权访问呢？让我们假设我们需要将一个字符串传递给一个操作字符串但不拥有它（不销毁它）的函数。这是一个简单的练习：

```cpp
void work_on_string(const std::string& str);
std::string my_string = …;
work_on_string(my_string);
```

这就是我们自从 C++被创建以来一直在做的事情。但这种简单性隐藏着一个深刻的区别：记住，只要我们不关心所有额外的方法和它们提供的功能，`std::string`就只是一个指向字符字符串的所有权指针，同时它也知道自己的长度。那么，如果我们用一个所有权指针而不是字符串来处理相同的情况，我们会怎么处理呢？相应的指针是`std::unique_ptr<char[]>`，所以我们会写一些像这样的事情：

```cpp
void work_on_string(const char* str);
std::unique_ptr<char[]> my_string(new char[…length…]);
… initialize the string …
work_on_string(my_string.get());
```

按照之前的指南，我们向函数传递了一个非所有权的原始指针。我们绝对不会写这个声明：

```cpp
void work_on_string(const std::unique_ptr<char[]>& str);
```

然而，当相同的字符数组由`std::string`对象拥有时，我们却毫不犹豫地这样做。为什么我们对这些非常相似的问题采取如此不同的方法？现在是时候记住为什么字符串不仅仅是一个限制在字符数组中的拥有指针；它包含的信息不仅仅是指针：它还知道字符串的长度。在 C++中没有很好的方法可以授予对这种“*丰富*”拥有指针的非拥有访问权限，除非通过引用传递整个指针对象。相比之下，唯一指针（或任何其他拥有指针）包含的信息与基本指针相同，所以当不需要所有权时，拥有指针自然地减少到原始指针，而没有任何信息损失。

这种差异不仅仅是关于对称性。考虑一下，通过`const`引用传递字符串可以防止`work_on_string`函数改变字符串的内容。另一方面，非`const`引用允许函数清除字符串（释放它拥有的内存），这是所有权的一个方面。我们被迫通过混合两种无关的类型来模糊意图的清晰性，我们可以授予函数的访问类型：改变数据内容的能力和数据所有权。

C++17 在非常有限的范围内解决了这个问题：具体来说，对于字符串，它引入了一个新的类型`std::string_view`。字符串视图是一个指向字符串的（`const`）非拥有指针，同时也存储了字符串的长度。换句话说，它是一个完美的非拥有等价物，类似于`std::string`：字符串视图到字符串的关系正好与`const`原始指针到唯一指针的关系相同。现在，为了授予对`std::string`对象的非拥有访问权限，我们编写：

```cpp
// Example 09
void work_on_string(std::string_view str);
std::string my_string = …;
work_on_string(my_string);
```

相比之下，一个接收`std::string`对象所有权的函数仍然必须通过引用来接收它。具体来说，使用右值引用来转移所有权：

```cpp
// Example 09
void consume_string(std::string&& str);
std::string my_string = …;
consume_string(std::move(my_string));
// Do not use my_string anymore!
```

仅使用非`const`左值引用来允许函数更改字符串；在 C++17 中，没有好的*丰富指针*可以与非`const`原始指针等价。可能没有必要使用`const std::string&`，除非现有的接口需要它，因为`std::string_view`提供了等效的功能。

使用`std::string_view`（特别是，它极大地简化了处理 C 和 C++字符串的常见代码的编写）还有其他好处和优势，但在这个章节中，我们关注的是所有权方面。此外，记住字符串视图仅限于字符字符串。我们可以就另一个拥有类进行完全相同的讨论，例如，`std::vector<int>`。

我们现在看到一个新的模式出现：对于“丰富”的拥有指针，除了拥有内存外，还包含有关它所拥有的数据的一些信息，相应的非拥有对象（相当于原始指针）应该是一个视图对象，它包含相同的信息但不拥有资源。我们在 C++20 中找到了这个视图对象，即`std::span`。在此之前，唯一授予对整数向量非拥有访问权的好方法是按引用传递它：

```cpp
void work_on_data(std::vector<int>& data);
std::vector<int> my_data = …;
work_on_data(my_data);
```

在 C++20 中，我们可以使用范围来清楚地区分非拥有视图（原始指针等价物）和拥有对象（唯一指针等价物）：

```cpp
// Example 10
void ModifyData(std::span<int> data);
std::vector<int> my_data = …;
ModifyData(my_data); // Can change my_data
```

因此，`std::span<int>`是一个与`int*`等价的“丰富指针”——它包含一个非`const`指针，大小便宜地复制且不拥有它所指向的资源。与`std::string_view`不同，我们可以修改通过范围访问的对象。但如果我们想要`const`指针的等价物，我们可以使用`std::span<const int>`：

```cpp
// Example 10
void UseData(std::span<const int> data);
std::vector<int> my_data = …;
UseData(my_data); // Cannot change my_data
```

由于`std::string`包含一个连续的字符数组，它也可以与范围一起使用，在这种情况下，是`std::span<char>`或`std::span<const char>`。后者本质上与`std::string_view`相同，包括从字符串字面量构造它们的选择。前者相当于非`const`的`char`指针。

范围与向量或字符串配合良好，因为它们提供了对数组的非拥有视图。但对于其他 STL 容器则不适用，因为它们都在多个非连续分配中分配内存。为此，我们需要使用 C++20 的范围库。例如，将前面的非拥有向量访问泛化到任意容器可以写成这样：

```cpp
// Example 11
void ModifyData(std::ranges::view auto data) { … }
std::list<int> my_data = …;
ModifyData(std::views::all(my_data));
```

如果你从未见过 C++20 的模板，这需要一些习惯。第一行是一个模板函数：`auto`参数使“普通”函数成为模板，即使没有`template`关键字。在`auto`之前的`std::ranges::view`咒语限制了模板参数只能满足视图概念。视图是一个类似容器的对象，它具有`begin()`和`end()`成员函数，并且，此外，必须便宜地移动，或者便宜地复制或不可复制（这当然是对标准中列举的精确要求的宽松解释）。我们可以用`template`和`requires`关键字编写相同的函数，但这种紧凑的语法在 C++20 中是惯用的。

注意，在这种基于概念的开发风格中，对函数参数的限制由概念要求指定。我们可以编写相同的模板函数，要求范围而不是视图：

```cpp
void ModifyData(std::ranges::range auto data) { … }
std::list<int> my_data = …;
ModifyData(my_data);
```

范围本质上是有`begin()`和`end()`的任意对象，所以`std::list`是一个范围（但不是视图，它可以复制但并不便宜）。注意，按照目前的写法，函数是通过值传递参数的，因此会创建一个副本。除非这是意图（在这种情况下，并不是），正确编写此函数的方式如下：

```cpp
void ModifyData(std::ranges::range auto&& data) { … }
```

如果我们想要表达非修改性访问，`const`引用也会起作用。但需要注意的是，我们不必对视图做同样的事情：通过将`work_on_data`函数限制为仅接受视图，我们已经将其限制为类似`std::string_view`（或原始指针）的便宜复制类型。确实，通过引用传递范围就像传递字符串或向量本身一样：这给了被调用者访问所有权。如果我们想要编写一个明确不拥有范围的所有权的函数，视图是表达这种意思的正确方式。

对于 C++20 范围的模式，现在谈论还为时过早：它们存在的时间还不够长，还没有形成公认的、被广泛接受的使用惯例（模式所必需的要求），并且库仍然不完整。预计 C++23 将包含几个重大增强（特别是，C++20 范围中没有`std::span<const char>`的良好等效项——它将在 C++23 中添加）。

然而，我们可以自信地谈论在 C++中逐渐形成的更一般的模式：资源所有权，包括内存，应由拥有对象来处理，而非拥有访问应通过视图来授予。拥有对象可以是智能指针或更复杂和专业的容器对象。这些容器除了以更复杂的方式管理内存外，还嵌入有关它们包含的数据的更多信息。一般来说，对于每个容器，都应该有一个相应的视图，它授予非拥有访问权限，同时保留所有附加信息。对于智能指针，这个视图是一个原始指针或引用。对于`std::string`，这个视图是`std::string_view`。对于`std::vector`、数组以及任何其他拥有连续内存的容器，你将想要`std::span`。对于任意容器，相应的视图可以在 C++20 范围库中找到；对于自定义容器，你可能还需要编写自己的视图对象（只需确保它们满足相关的视图概念即可）。

# 摘要

在 C++中，内存所有权实际上只是对象所有权的简称，而对象所有权则是管理任意资源、其所有权和访问的方式。我们已经回顾了 C++社区为表达不同类型的内存所有权而开发的当代习惯用语。C++允许程序员表达独占或共享内存所有权。同样重要的是，在关于资源所有权无知的程序中表达*非所有权*。我们还了解了一个设计良好的程序中资源所有权的实践和属性。

我们现在有了习惯用语来清楚地表达程序中哪个实体拥有每个对象或资源，以及何时授予非拥有访问权限。下一章将介绍对资源进行最简单操作的习惯用语：交换或交换。

# 问题

1.  为什么在程序中清楚地表达内存所有权很重要？

1.  不清晰的内存所有权会导致哪些常见问题？

1.  C++中可以表达哪些类型的内存所有权？

1.  你如何编写不拥有内存的函数和类？

1.  为什么应该优先选择独占内存所有权而不是共享所有权？

1.  你如何在 C++中表达独占内存的所有权？

1.  你如何在 C++中表达共享内存的所有权？

1.  共享内存所有权的潜在缺点是什么？

1.  视图是什么？字符串视图为什么比通过引用传递字符串更好？

# 进一步阅读

+   *《C++20 STL 烹饪书》* 由 *Bill Weinman* 撰写：[`www.packtpub.com/product/c20-stl-cookbook/9781803248714`](https://www.packtpub.com/product/c20-stl-cookbook/9781803248714)

+   *《使用 C++进行模板元编程》* 由 *Marius Bancila* 撰写：[`www.packtpub.com/product/template-metaprogramming-with-c/9781803243450`](https://www.packtpub.com/product/template-metaprogramming-with-c/9781803243450)

+   *《C++ 数据结构和算法》* 由 *Wisnu Anggoro* 撰写：[`www.packtpub.com/application-development/c-data-structures-and-algorithms`](https://www.packtpub.com/application-development/c-data-structures-and-algorithms)

+   *《专家 C++编程》* 由 *Jeganathan Swaminathan*、*Maya Posch* 和 *Jacek Galowicz* 撰写：[`www.packtpub.com/application-development/expert-c-programming`](https://www.packtpub.com/application-development/expert-c-programming)

# 第二部分：常见的 C++惯用法

本部分描述了一些更常见的 C++惯用法：这些是公认的、普遍认可的方式来表达特定的想法或实现频繁需要的任务。在“模式”和“惯用法”之间的界限模糊至极。在这本书中，我们认为更完整的设计解决方案是模式，而更简单的技术是惯用法。换句话说，选择一个模式可能会影响你整个应用程序或其主要组件的设计，而使用惯用法则更多是借鉴他人的错误而做出的实现决策。

本部分包含以下章节：

+   *第四章*，*交换 - 从简单到微妙*

+   *第五章*，*全面审视 RAII*

+   *第六章*，*理解类型擦除*

+   *第七章*，*SFINAE、概念和重载解析管理*
