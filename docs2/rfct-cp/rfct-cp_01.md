

# C++ 编程规范

在本章中，我们将深入探讨干净代码的世界，并检查它在成功软件项目中的关键作用。我们将讨论技术债务的概念以及低质量代码如何导致其积累。此外，我们还将探讨通常被低估的代码格式化和文档化实践，这些对于维护可管理和有效的代码库至关重要。通过本章，我们将理解干净的代码不仅仅是锦上添花，而是任何项目的必需品。

我们将讨论编程规范的重要性，并介绍在 C++ 社区中使用的常见约定和最佳实践。到本章结束时，你将更好地理解什么是干净的代码，为什么它至关重要，以及为什么记录代码是至关重要的。

# 好的代码和坏的代码之间的区别

好的或干净的代码没有严格的定义。此外，没有自动工具可以衡量代码的质量。有代码检查器、代码检查工具和其他分析器可以帮助使代码更好。这些工具非常有价值，并且强烈推荐，但并不足够。人工智能可能会接管并为我们编写代码，但最终，它对代码质量的衡量将基于我们对好代码的人类想法。

编程语言最初是为了在机器和开发者之间提供一个接口而开发的；然而，随着软件产品复杂性的增长，现在很明显，它主要是开发者之间沟通想法和意图的一种方式。众所周知，开发者花在阅读代码上的时间是编写代码的十倍。这意味着为了提高效率，我们必须尽力使阅读变得更容易。使这个过程高效的最成功的方式是使代码可预测，甚至更好，是无聊的。这里的“无聊”是指读者看到代码时就能知道它将如何从功能、性能和副作用方面进行预期。以下是一个从数据库中检索对象的类的接口示例：

```cpp
class Database {
public:
  template<typename T>
  std::optional<T> get(const Id& id) const;
  template<typename T>
  std::optional<T> get(const std::string& name) const;
};
```

它支持两种查找模式，通过 `id` 和通过 `name`；它不应该因为 `const` 修饰符而改变 `Database` 对象的内部状态；并且它只能对数据库实例执行读取操作。它是无聊的，但符合基本预期。想象一下，在关键错误调查期间发现，在每次读取操作中，它都执行更新操作，有时甚至执行删除操作，这会有多令人惊讶？

正如读者所看到的，几个关键因素可以区分好的代码和坏的代码。好的代码通常是写得很好、易于阅读且高效的。它遵循 C++ 语言的约定和标准，并以逻辑和一致的方式组织。好的代码也具有良好的文档，通常包含清晰的注释，解释那些仅从代码阅读中不明显的内容的目的和功能。

# 为什么编程规范很重要

编码标准的重要性有多个原因。首先，它们有助于最小化技术债务。技术债务，也称为“代码债务”，是一个隐喻，描述了维护和修改设计不佳或编写不佳的代码的成本。正如财务债务会产生利息并需要持续支付一样，技术债务会以维护和修改设计不佳的代码所需的时间和精力为形式产生额外的成本。

技术债务可以通过多种方式积累，例如通过解决问题的快速修复或忽略最佳实践或编码标准。随着技术债务的积累，修改和维护代码变得越来越困难和耗时，这可能会对开发团队的效率和效果产生负面影响。

为了谨慎管理技术债务，避免积累过多的债务至关重要，因为它可能会成为开发团队的沉重负担。管理技术债务的策略包括定期重构代码以改进其设计和可维护性，遵循最佳实践和编码标准，以及积极寻求提高代码质量的机会。总的来说，管理技术债务是良好代码设计和开发的重要方面，有助于确保代码高效、可靠且易于工作。

编码标准有助于确保代码的质量和一致性。通过建立编写代码的指南和惯例，编码标准有助于确保代码编写良好、易于阅读和理解。这使得其他人更容易维护和更新代码，并有助于防止错误和缺陷。

此外，它们有助于提高代码的效率。通过遵循既定惯例和最佳实践，程序员可以编写更高效且性能更好的代码。这可以节省时间和资源，并有助于确保代码可扩展并能处理大量数据和流量。

此外，编码标准促进了程序员之间的协作和团队合作。通过建立一套共同的指南和惯例，编码标准使得程序员团队更容易在项目上合作。这促进了更好的沟通和协调，并有助于确保每个人都处于同一页面上，朝着相同的目标努力。

编码标准通常促进代码的互操作性和可移植性。通过遵循标准化的惯例集，一位程序员编写的代码可以很容易地被另一位程序员理解和使用。这使得代码更容易集成到更大的项目中，并有助于确保它可以在各种不同的平台和操作系统上使用。

C++编程语言可能是功能最丰富的编程语言之一。它起源于“带有类的 C 语言”，提供了高性能和几乎与 C 语言完全兼容的对象支持；后来引入了模板元编程，斯蒂潘诺夫和李共同开发了现在被称为 C++标准库的 C++标准模板库。现代 C++（C++11 及更高版本）为多种编程范式提供了广泛的支持，包括过程式、面向对象、泛型和函数式编程。它提供了诸如 lambda 表达式、基于范围的`for`循环、智能指针和类型推断等特性，这些特性使得函数式编程技术得以实现。此外，C++还提供了面向对象编程概念的支持，如继承、封装和多态。它还提供了模板元编程，这使泛型编程成为可能，并允许编译时优化。此外，C++还提供了线程、原子类型和未来等并发支持特性，使得编写并发和并行代码变得更加容易。这种灵活性是语言强大之所在，但往往会导致可维护性问题。

开发者必须理解我们提到的范式概念，如何将它们结合使用，以及它们最终如何影响代码的性能。这时，编码标准可以帮助解释代码库的复杂性。

所有这些因素使得编码规范成为现代 C++项目达到质量标准所必须具备的最低要求。

## 代码规范

与 Python、Go、Java 和其他许多语言不同，C++没有统一的代码规范。

对于 C++编程语言，存在几种流行的编码规范。以下是一些广泛遵循的常见规范：

+   `total_cost`或`customer_name`。类变量通常会有前缀或后缀以区分它们与其他变量，例如`m_user_count`或`user_count_`。函数的命名可以使用*camelCase*，每个单词的首字母（除了第一个单词）大写，例如`calculateTotalCost`或`getCustomerName`。类的命名可以使用*PascalCase*，每个单词的首字母大写，例如`Customer`或`Invoice`。

+   **注释**：注释规范规定了如何编写和格式化代码中的注释。注释用于提供代码的解释和文档，应清晰简洁。通常建议使用内联注释来解释特定的代码行，以及使用块注释来提供代码块或函数的概述。

+   `for`循环或`if`语句，以视觉上表示代码的结构。格式化策略通常包括指针和引用中的星号（`*`）和和号（`&`）对齐（例如，`int* ptr`与`int *ptr`或`Socket &socket`与`Socket& socket`），大括号的位置（同一行、下一行或上下文相关）。本书将在第十三章中涵盖自动化格式化的方面。

+   `goto`运算符。

需要注意的是，不同组织和团队之间的编码规范可能会有所不同。重要的是要遵循你的团队或组织建立的规范，或者如果没有指定，则定义你自己的规范。

制定编码规范可能会很繁琐；一些公司更愿意使用现有的规范并将其适应他们的需求。在 C++编程语言中，有几个流行的代码规范被开发者广泛遵循。这些标准旨在提高 C++代码的可读性、可维护性和整体质量。

C++的一个常见代码规范是 C++核心指南([`isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines`](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines))，它是由 C++的创造者 Bjarne Stroustrup 以及来自工业和学术界的一组专家开发的。这些指南涵盖了广泛的主题，包括命名约定、注释、格式化和编码风格。

另一个流行的 C++代码规范是 Google C++风格指南([`google.github.io/styleguide/cppguide.html`](https://google.github.io/styleguide/cppguide.html))，它被许多软件公司，包括谷歌，所采用。该指南提供了关于命名约定、注释、格式化和编码风格的指南，以及使用特定 C++功能和库的建议。

除了这些广泛遵循的标准之外，还有许多其他由个人组织或团队开发的代码规范，例如 LLVM 编码规范、WebKit 和 Mozilla 的风格指南。

如果一个项目符合特定的代码规范，阅读起来会更加容易，而且作为额外的好处，代码库会变得更加*可 grep*。考虑需要找到名为`request_id`的变量被赋值的地方。这可以通过`grep`实用程序轻松实现：

```cpp
$ grep -rn "request_id = " .
./RequestHandler.cpp:25: request_id = new_request_id;
./RequestHandler.cpp:122: request_id = request.getId();
```

代码审查员过去常常花费数小时在同行评审期间捕捉和评论代码格式的不一致性。幸运的是，今天我们有 Clang-Tidy 和 Clang-Format 这样的工具，允许我们通过代码编辑器和**持续集成**（**CI**）自动确保代码格式的统一性。我们将在本书的第十章中更深入地探讨它们的配置。

## 语言特性限制

C++是一种强大的语言；正如我们所知，强大的力量伴随着巨大的责任。对于工程师来说，尤其是那些没有花费几十年时间编写 C++代码的人来说，掌握这种语言的复杂性并不容易。因此，一些公司决定限制他们在项目中使用的功能。这些限制可能包括禁止多重继承、使用异常以及最小化使用宏、模板和特定的第三方库。此外，这些规定可能来自对遗留库的使用。例如，如果大部分代码不支持 C++异常，那么在没有事先了解结果的情况下，将它们添加到新的代码片段中可能不是一个好主意。

## 通用指南

对于一个项目来说，拥有一些通用指南总是好的。这些指南通常涵盖了在项目中工作的首选方式：

+   如果允许，原始指针的使用

+   获取器如何返回值以及如何提供给设置器（按值或引用）

+   代码注释的使用：

    +   是否允许一般性地使用注释？

    +   战略性和战术性注释的使用

    +   注释风格：自由、Doxygen 等

编码标准是必要的，以确保代码质量、一致性、互操作性、可移植性、效率和协作。通过遵循编码标准，程序员可以编写更好的代码，这些代码更容易理解、维护和使用，并且工作得更好、更高效。

# 可读性、效率、可维护性和可用性

可读性、效率、可维护性和可用性都是在编写代码时需要考虑的关键因素。

## 可读性

可读性指的是人类读者理解一段代码的容易程度。编写良好的代码易于阅读，具有清晰、简洁的语句，这些语句以逻辑和一致的方式组织。如果我们考虑到开发者阅读代码的时间是编写代码时间的十倍，这一点就变得非常重要。

让我们来看看以下这段代码：

```cpp
class Employee {
public:
  std::string get_name();
  std::string surname();
  uint64_t getId() const;
};
```

这个例子是一个夸张的例子，展示了代码没有遵循任何编码约定。使用`Employee`类的开发者可以理解这三个方法都是获取器。然而，名称上的差异使得用户花费更多的时间来理解代码或试图理解名称背后的原因。这些方法名称不同是因为程序员没有关心类的统一性吗？还是因为，例如，没有`get`前缀的方法是简单的获取器，而包含`get`前缀的方法是从文件或数据库中获取数据？

此外，没有`const`的方法是否会改变对象的状态（例如通过缓存），或者这是一个错误？你看到有多少问题可以提出吗？这些问题只有在开发者跳入相应的实现时才能回答，这意味着浪费了时间。使代码在代码库中看起来一致有助于开发者通过查看头文件中的声明或甚至通过现代代码编辑器的自动完成来理解类、方法和函数的含义和复杂性。

## 效率

效率指的是一段代码以高效的方式执行其预期任务的能力。高效的代码使用很少的资源，例如时间和内存，来完成一项任务，并且能够处理大量数据和流量而不会减慢或崩溃。通过提高代码的效率，程序员可以节省时间和资源，并确保他们的代码可扩展并能处理不断增长的用户群体的需求。

优化 C++代码有可靠的方法，例如通过常量引用传递只读参数以避免不必要的复制，或者在查找单个字符时使用`std::string::find`的字符重载版本以避免创建字符串：

```cpp
my_string.find('A');
my_string.find("A");
```

然而，实现并维持代码效率的更系统的方法是遵循帕累托原则。当应用于软件工程时，这个原则表明大约 20%的代码完成了 80%的工作。例如，通常在后台守护进程启动时优化代码解析配置文件是没有必要的，因为这仅在程序的生命周期中发生一次。然而，避免在主流程中复制大型数据结构可能很重要。提高效率的最佳方式包括选择这 20%的性能关键代码并为它添加基准测试。这些基准测试预计将作为 CI 过程的一部分运行，以确保没有引入退化。

此外，端到端测试可以衡量应用程序的整体性能。本书在*第十三章*中讨论了编写单元测试和端到端测试的最佳实践。需要注意的是，自动化工具不能取代工程师对新代码进行代码审查，主要是因为没有工具能够找到那 20%的代码，而这 20%的代码完成了 80%的工作。

## 可维护性

可维护性指的是代码随时间推移进行更新和修改的容易程度。编写良好的代码易于维护，具有清晰且文档齐全的代码，这些代码以逻辑和一致的方式组织。通过提高代码的可维护性，程序员可以使他人更容易更新和修改他们的代码，并确保代码在长时间内保持相关性和实用性。理想情况下，在开发新组件时，开发者应该考虑代码当前解决的问题以及代码的未来使用和扩展。例如，在开发数据提供者支持时，考虑该提供者是否将是唯一支持的对象可能是有用的。如果不是，考虑数据提供者的标准特性并将它们提取到抽象基类中可能是有帮助的。以下是一个示例：

```cpp
class BaseDataProvider {
public:
  BaseDataProvider() = default;
  BaseDataProvider(const BaseDataProvider&) = delete;
  BaseDataProvider(BaseDataProvider&&) = default;
  BaseDataProvider& operator = (const BaseDataProvider&) =
    delete;
  BaseDataProvider& operator = (BaseDataProvider&&) =
    default;
  virtual ~BaseDataProvider() = default;
  virtual Data getData() const = 0;
};
class NetworkDataProvider : public BaseDataProvider {
public:
  NetworkDataProvider(const Endpoint& endpoint);
  Data getData() const override;
};
class FileDataProvider : public BaseDataProvider {
public:
  FileDataProvider(const std::string& filename);
  Data getData() const override;
};
```

在这个例子中，`DataProvider` 类是一个抽象基类，它定义了提供数据时的接口。`NetworkDataProvider` 和 `FileDataProvider` 类从 `DataProvider` 派生出来，并覆盖了 `getData` 虚拟函数，分别提供从文件或网络端点读取数据的特定实现。这种设计使得通过简单地创建一个从 `DataProvider` 派生的新的类并提供 `getData` 虚拟函数的适当实现，可以轻松地添加新的数据源。

从这个例子中可以看出，基接口可能不仅包括功能，还包括对象的复制-移动策略。随后，用户代码可以通过基类引用接收数据提供者，并对提供者的类型一无所知，如下面的代码片段所示：

```cpp
class DataParser {
public:
  DataParser(const BaseDataProvider& provider);
  void parse();
};
```

此外，这种继承可以在为 `DataParser` 创建单元测试时模拟数据提供者。单元测试在*第十三章*中详细讨论。

顺便提一下，不要使代码过于复杂，或准备好应对任何变化，这一点至关重要。否则，需要使一切可扩展的需求可能会导致如下所示的怪物：

```cpp
#define BASE_CLASS(TYPE)                 \
  template <typename T>                  \
  class TYPE {                           \
  public:                                \
    T value;                             \
    TYPE(T val) : value(val) {}          \
  };
#define DERIVED_CLASS(TYPE, BASE)        \
  template <typename T>                  \
  class TYPE : public BASE<T> {          \
  public:                                \
    TYPE(T val) : BASE<T>(val) {}        \
    T getValue() { return value; } \
  };
BASE_CLASS(Base);
DERIVED_CLASS(Derived, Base);
int main() {
  Derived<int> obj(5);
  std::cout << obj.getValue() << std::endl;
  return 0;
}
```

这个类层次结构不必要地复杂，因为它几乎使用了所有的 C++ 特性：继承、模板和宏。虽然使用模板与继承是常见的做法，但宏现在被视为一种反模式。在这个例子中，`Derived` 类与 `Base` 类相比，添加的功能非常少，直接将 `getValue` 方法添加到 `Base` 类中会更直接。在某些情况下，使用继承和模板可能是有用的，但重要的是要适当地使用它们，不要过度使用。宏可能特别难以理解和维护，因为它们在代码编译之前由预处理器展开，因此很难看到实际的代码样子。在可能的情况下，通常最好使用函数或模板函数而不是宏。

如果扩展的可能性较低，保持其结构简单且接近基本需求是更好的选择。你如何决定采取哪种方法？嗯，冷静的考虑和代码审查是找到答案的方法。

## 可用性

可用性指的是其他人使用一段代码的容易程度。编写良好的代码易于使用，具有清晰直观的界面和文档，使其他人容易理解和使用代码。通过提高代码的可用性，程序员可以使他们的代码更容易被他人访问和使用，并确保他们的代码被广泛采用和使用。

总体而言，可读性、效率、可维护性和可用性都是在编写代码时需要考虑的重要因素。通过提高这些因素，程序员可以编写出更容易理解、维护和使用的优质代码。

# 摘要

在本章中，你了解了良好和糟糕代码的概念。良好的代码编写得很好，效率高，易于理解和维护。它遵循编码标准和最佳实践，并且不太容易出现错误。另一方面，糟糕的代码编写得不好，效率低下，难以理解和维护。

本章还介绍了技术债务的概念，它指的是需要重构或重写的低质量代码的积累。技术债务可能代价高昂且耗时，可能会阻碍新功能或功能的发展。

本章也强调了代码标准的重要性。代码标准是指导或规则，规定了代码应该如何编写、格式化和结构化。遵守代码标准有助于确保代码的一致性、易于理解和维护。它还使多个开发者能够更容易地在同一代码库上工作，并有助于防止错误和缺陷。

总体而言，本章强调了编写高质量代码和遵守代码标准的重要性，以避免技术债务并确保软件项目的长期成功和可维护性。

在下一章中，我们将深入软件设计原则的世界。具体来说，我们将关注 SOLID 原则，这是一组旨在通过使软件系统更易于维护、灵活和可扩展来改进软件设计的指导方针。下一章将详细解释每个原则，并附带它们如何应用于现实世界软件开发场景的示例。
