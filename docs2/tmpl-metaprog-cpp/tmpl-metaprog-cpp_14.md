# 作业答案

# *第一章*，模板简介

**问题 1**

我们为什么需要模板？它们提供了哪些优势？

**答案**

使用模板有几个好处：它们帮助我们避免编写重复的代码，促进了通用库的创建，并且可以帮助我们编写更少、更好的代码。

**问题 2**

如何调用模板函数？对于模板类又是如何？

**答案**

模板函数被称为函数模板。同样，模板类被称为类模板。

**问题 3**

有多少种模板参数类型？它们是什么？

**答案**

模板参数有三种类型：类型模板参数、非类型模板参数和模板模板参数。

**问题 4**

什么是部分专业化？完全专业化又是如何？

**答案**

专业化是一种为模板提供替代实现的技术，这种模板被称为主模板。部分专业化是为模板的一些参数提供的替代实现。当为所有模板参数提供参数时，这是一种完全专业化的替代实现。

**问题 5**

使用模板的主要缺点是什么？

**答案**

使用模板的主要缺点包括以下内容：复杂的语法、通常很长且难以阅读和理解的编译器错误，以及编译时间的增加。

# *第二章*，模板基础

**问题 1**

哪些类型的类型可以用于非类型模板参数？

**答案**

非类型模板参数只能具有结构化类型。结构化类型包括整数类型、浮点类型（自 C++20 起包括）、枚举类型、指针类型（指向对象或函数）、成员指针类型（指向成员对象或成员函数）、左值引用类型（指向对象或函数），以及满足几个要求的字面类类型：所有基类都是公共的且不可变的，所有非静态数据成员都是公共的且不可变的，所有基类和所有非静态数据成员的类型也是结构化类型或其数组。这些类型的 `const` 和 `volatile` 修饰版本也是允许的。

**问题 2**

默认模板参数不允许在哪些地方使用？

**答案**

默认模板参数不能用于参数包的声明，在友元类模板的声明中，以及在函数模板或成员函数模板的显式特化的声明或定义中。

**问题 3**

显式实例化声明是什么？它与显式实例化定义在语法上有什么区别？

**答案**

显式实例化声明是告诉编译器模板实例化的定义位于不同的翻译单元中，并且不应生成新定义的方法。其语法与显式实例化定义相同，只是声明前使用了`extern`关键字。

**问题 4**

什么是别名模板？

**答案**

别名模板是一个名称，与类型别名不同，它不是引用另一个类型，而是引用一个模板，换句话说，是一系列类型。别名模板通过使用声明引入。它们不能通过`typedef`声明引入。

**问题 5**

什么是模板 lambda？

**答案**

模板 lambda 是 C++20 中引入的泛型 lambda 的改进形式。它们允许我们使用模板语法显式指定编译器为 lambda 表达式生成的函数对象的模板化函数调用运算符的形状。

# *第三章*，变长模板

**问题 1**

什么是变长模板以及它们为什么有用？

**答案**

变长模板是具有可变数量参数的模板。它们不仅允许我们编写具有可变数量参数的函数，还可以编写类模板、可变模板和别名模板。与使用`va_`宏等其他方法不同，它们是类型安全的，不需要宏，也不需要我们显式指定参数数量。

**问题 2**

什么是参数包？

**答案**

存在两种参数包：模板参数包和函数参数包。前者是接受零个、一个或多个模板参数的模板参数。后者是接受零个、一个或多个函数参数的函数参数。

**问题 3**

在哪些上下文中可以展开参数包？

**答案**

参数包可以在多种上下文中展开，如下所示：模板参数列表、模板参数列表、函数参数列表、函数参数列表、括号初始化器、花括号初始化器、基指定符和成员初始化列表、折叠表达式、使用声明、lambda 捕获、`sizeof...`运算符、对齐指定符和属性列表。

**问题 4**

什么是折叠表达式？

**答案**

折叠表达式是一个涉及参数包的表达式，它将参数包的元素折叠（或归约）到二元运算符上。

**问题 5**

使用折叠表达式的优点是什么？

**答案**

使用折叠表达式的优点包括编写更少、更简单的代码，更少的模板实例化，这导致编译时间更快，并且可能更快地执行代码，因为多个函数调用被单个表达式所替代。

# *第四章*，高级模板概念

**问题 1**

在何时进行名称查找？

**答案**

名称查找是在模板实例化的点上对依赖名称（依赖于模板参数的类型或值的名称）进行的，在模板定义的点上对非依赖名称（不依赖于模板参数的名称）进行的。

**问题 2**

推导指南是什么？

**答案**

推导指南是一种机制，告诉编译器如何执行类模板参数的推导。推导指南是代表虚构类类型的构造函数签名的虚构函数模板。如果虚构函数模板的构造集上解析过载失败，则程序是不良形式，并生成错误。否则，所选函数模板特化的返回类型成为推导出的类模板特化。

**问题 3**

什么是前向引用？

**答案**

前向引用（也称为通用引用）是模板中的一个引用，如果传递了右值作为参数，则表现得像一个右值引用；如果传递了左值作为参数，则表现得像一个左值引用。前向引用必须具有 `T&&` 形式，例如在 `template <typename T> void f(T&&)` 中。如 `T const &&` 或 `std::vector<T>&&` 这样的形式不代表前向引用，而是正常的右值引用。

**问题 4**

`decltype` 做什么？

**答案**

`decltype` 说明符是一个类型说明符。它返回表达式的类型。它通常与 `auto` 说明符一起在模板中使用，以声明依赖于其模板参数的函数模板的返回类型，或者包装另一个函数并返回包装函数执行结果的函数的返回类型。

**问题 5**

`std::declval` 做什么？

**答案**

`std::declval` 是来自 `<utility>` 头文件的一个实用函数模板，它为其类型模板参数添加了一个右值引用。它只能在未评估上下文中使用（仅在编译时上下文中使用，在运行时不进行评估），其目的是帮助对没有默认构造函数或无法访问的（因为它私有或受保护）的类型进行依赖类型评估。

# *第五章*，类型特性和条件编译

**问题 1**

什么是类型特性？

**答案**

类型特性是小的类模板，使我们能够查询类型的属性或对类型进行转换。

**问题 2**

什么是 SFINAE？

**答案**

**SFINAE** 是 **Substitution Failure Is Not An Error** 的缩写。这是一个模板替换规则，其工作方式如下：当编译器遇到函数模板的使用时，它会替换参数以实例化模板；如果在此处发生错误，它不会被视为无效代码，而只是推导失败。因此，函数将从重载集中移除，而不是导致错误。因此，只有在特定函数调用在重载集中没有匹配项时才会发生错误。

**问题 3**

什么是 `constexpr if`？

**答案**

`constexpr if` 是 `if` 语句的编译时版本。它的语法是 `if` `constexpr(condition)`。它自 C++17 起可用，允许我们根据编译时表达式的值在编译时丢弃一个分支。

**问题 4**

`std::is_same` 做什么？

**答案**

`std::is_same` 是一个类型特性，用于检查两个类型是否相同。它包括对 `const` 和 `volatile` 修饰符的检查，如果两个类型有不同的修饰符（例如 `int` 和 `int const`），则返回 `false`。

**问题 5**

`std::conditional` 做什么？

**答案**

`std::conditional` 是一个元函数，根据编译时常量选择一个类型或另一个类型。

# *第六章*，概念和约束

**问题 1**

约束是什么？概念又是什么？

**答案**

约束是对模板参数施加的要求。概念是一组命名约束。

**问题 2**

需求子句和需求表达式是什么？

**答案**

需求子句是一个构造，允许我们指定模板参数或函数声明的约束。这个构造由 `requires` 关键字后跟一个编译时布尔表达式组成。需求子句会影响函数的行为，包括在重载解析中仅当布尔表达式为 `true` 时才包括它。另一方面，需求表达式具有 `requires (parameters-list) expression;` 的形式，其中 `parameters-list` 是可选的。它的目的是验证某些表达式是否良好形成，没有任何副作用或影响函数的行为。需求表达式可以与需求子句一起使用，尽管命名概念更受欢迎，主要是因为可读性。

**问题 3**

需求表达式的类别有哪些？

**答案**

需求表达式分为四类：简单需求、类型需求、复合需求和嵌套需求。

**问题 4**

约束如何影响重载解析中模板的排序？

**答案**

函数的约束会影响它们在重载解析集中的顺序。当多个重载与参数集匹配时，选择约束更强的重载。然而，请注意，使用类型特性（或一般而言的布尔表达式）和概念进行约束在语义上并不相同。有关此主题的详细信息，请回顾*了解具有约束的模板排序*部分。

**问题 5**

简化函数模板是什么？

**答案**

简化函数模板是 C++20 中引入的新特性，它为函数模板提供了简化的语法。可以使用`auto`指定符来定义函数参数，并且可以省略模板语法。编译器将自动从简化函数模板生成函数模板。这些函数可以使用概念进行约束，因此对模板参数施加要求。

# *第七章*，模式和惯用法

**问题 1**

奇特重复模板模式通常用于解决哪些典型问题？

**答案**

**奇特重复模板模式**（**CRTP**）通常用于解决为类型添加公共功能、避免代码重复、限制类型实例化的次数或实现组合设计模式等问题。

**问题 2**

混合模式是什么？它们的目的又是什么？

**答案**

混合模式是设计用来通过从它们打算补充的类继承来向其他类添加功能的小类。这与 CRTP 模式相反。

**问题 3**

类型擦除是什么？

**答案**

类型擦除是描述从类型中删除信息的模式的术语，这使得不相关的类型可以以通用方式处理。尽管可以通过`void`指针或多态实现类型擦除的形式，但真正的类型擦除模式是在 C++中使用模板实现的。

**问题 4**

标签分派是什么？它的替代方案有哪些？

**答案**

标签分派是一种技术，它使我们能够在编译时选择一个或另一个函数重载。虽然标签分派本身是`std::enable_if`和 SFINAE 的替代方案，但它也有自己的替代方案。这些是 C++17 中的 constexpr if 和 C++20 中的概念。

**问题 5**

表达式模板是什么？它们在哪里被使用？

**答案**

表达式模板是一种元编程技术，它允许在编译时进行计算的惰性评估。这种技术的优点是它避免了在运行时执行低效操作，代价是代码更加复杂，可能难以理解。表达式模板通常用于实现线性代数库。

# *第八章*，范围和算法

**问题 1**

标准库中的序列容器有哪些？

**答案**

C++ 标准库中的序列容器包括 `std::vector`，`std::deque`，`std::list`，`std::array` 和 `std::forward_list`。

**问题 2**

标准容器中定义了哪些常见的成员函数？

**答案**

标准库中大多数容器定义的成员函数包括 `size`（在 `std::forward_list` 中不存在），`empty`，`clear`（在 `std::array`，`std::stack`，`std::queue` 和 `std::priority_queue` 中不存在），`swap`，`begin` 和 `end`。

**问题 3**

迭代器是什么？有多少个类别？

**答案**

迭代器是一种抽象，它使我们能够以通用方式访问容器中的元素，而无需了解每个容器的实现细节。迭代器对于编写通用算法至关重要。在 C++ 中有六种迭代器类别：输入迭代器、正向迭代器、双向迭代器、随机访问迭代器、连续迭代器（自 C++17 起存在）和输出迭代器。

**问题 4**

随机访问迭代器支持哪些操作？

**答案**

随机访问迭代器必须支持以下操作（除了输入、正向和双向迭代器所需操作之外）：`+` 和 `-` 算术运算符，不等式比较（与其他迭代器），复合赋值运算符和偏移量解引用运算符。

**问题 5**

什么是范围访问函数？

**答案**

范围访问函数是非成员函数，它们提供了一种统一的方式来访问容器、数组和 `std::initializer_list` 类的数据或属性。这些函数包括 `std::size`/`std::ssize`，`std::empty`，`std::data`，`std::begin` 和 `std::end`。

# *第九章*，范围库

**问题 1**

什么是范围？

**答案**

范围是对元素序列的抽象，由起始迭代器和结束迭代器定义。起始迭代器指向序列中的第一个元素。结束迭代器指向序列的最后一个元素之后的位置。

**问题 2**

范围库中的视图是什么？

**答案**

C++ 范围库中的一个视图，也称为范围适配器，是一个实现算法的对象，该算法接受一个或多个范围作为输入，可能还有其他参数，并返回一个调整后的范围。视图是延迟计算的，这意味着它们在迭代元素之前不会执行调整。

**问题 3**

什么是限制性算法？

**答案**

限制性算法是现有标准库算法的实现，但位于 C++20 范围库中。它们被称为限制性，因为它们的模板参数使用 C++20 概念进行约束。在这些算法中，而不是要求一个 begin-end 迭代器对来指定，一个值范围接受单个范围参数。然而，也存在接受迭代器-哨兵对的过载。

**问题 4**

什么是哨兵？

**答案**

哨兵是对结束迭代器的抽象。这使得结束迭代器可以具有与范围迭代器不同的类型。哨兵不能被解引用或递增。当测试范围结束的条件依赖于某些变量（动态）条件，并且你不知道何时到达范围的末尾（例如，某个条件变为假）时，哨兵非常有用。

**问题 5**

你如何检查哨兵类型是否对应迭代器类型？

**答案**

你可以通过使用来自 `<iterator>` 头文件的 `std::sentinel_for` 概念来检查哨兵类型是否可以与迭代器类型一起使用。
