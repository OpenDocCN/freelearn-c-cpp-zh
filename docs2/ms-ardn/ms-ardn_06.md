# 第六章：编程 Arduino - 基础知识

我记得我编程的时间已经很长了，从电传打字机和大型机到个人电脑和嵌入式设备，我编写过游戏、商业应用、网站和移动应用，但我可以诚实地说我最喜欢编程微控制器板，如 Arduino。

原因是，对于微控制器，我的程序可以通过各种传感器和电机与外部世界交互，而不是为简单的用户交互编程。使用微控制器，我们只受限于我们的想象力和独创性；然而，在我们开始征服世界之前，我们必须首先学习 Arduino 编程语言的基础知识。

在本章中，你将学习：

+   变量和常量的含义以及如何使用它们

+   Arduino 编程语言提供的数学函数

+   如何给我们的代码添加注释

+   如何使用 Arduino 编程语言进行决策

+   如何创建循环以重复代码块

在第五章 *Arduino IDE* 中，我们学习了如何使用 Arduino IDE 和 Web 编辑器。我们还检查了`setup()`和`loop()`函数，并学习了如何使用它们。在本章和第七章 *编程 Arduino – 超越基础知识* 中，我们将学习 Arduino 编程语言以及如何使用该语言为 Arduino 开发应用程序。让我们从查看花括号开始。

# 花括号

左花括号（{）定义了代码块开始的位置，而右花括号（}）定义了结束的位置。我们在查看`setup()`和`loop()`函数时看到了这些括号；然而，花括号不仅限于定义函数内的代码，它们还用于定义其他代码块。我们将在本章的*决策*和*循环*部分看到这方面的例子。

每当有左花括号时，也必须有一个右花括号。当我们左右花括号数量相等时，我们说花括号是平衡的。不平衡的花括号可能导致编译器错误。如果你收到非常复杂且难以理解的编译器错误，你可能想从验证花括号是否平衡开始进行故障排除。

现在让我们看看分号的使用。

# 分号

每个语句的末尾都使用分号来分隔一个语句与下一个语句。如果一个语句不以分号结束，将导致编译时错误。忘记分号的错误文本非常明显，并将包括缺少分号的语句的行号。

分号也用于`for`循环中，以分隔不同的元素。我们将在本章的*循环*部分查看`for`循环。现在让我们看看我们如何给我们的代码添加注释。

# 注释

在我们的 Arduino 代码中可以使用两种类型的注释。这些是块注释和行注释。块注释用于注释文本跨越多行的情况，通常用于函数调用之前，让读者知道函数的作用。行注释用于需要简短的单行注释的情况，通常用于函数块内，让读者知道特定代码行的作用。

块注释以 `/*` 开头，以 `*/` 结尾。以下代码展示了块注释的外观：

```cpp
/* This is a block comment
   This comment can span multiple lines
   This type of comment is usually found outside function calls
*/
```

行注释以 `//` 开头，直到行尾。行注释可以位于行的开头，或者可以在语句结束后。以下示例展示了行注释的外观：

```cpp
// This is a single line comment
Serial.println("Hello World"); // comment after statement
```

总是给代码添加注释，让读者知道某些代码块的作用是一个好主意。现在让我们看看什么是变量。

# 变量

变量用于在代码中存储可以引用或操作的信息。变量被赋予一个唯一的名称，然后可以使用该名称访问信息。变量的名称应该是描述变量内容的，这样任何查看代码的人都能理解变量用于什么。

当从多个单词或短语创建名称时，使用驼峰式命名法，其中名称的第一个字母小写，但每个剩余单词的开头字母大写。一些驼峰式命名的例子有 ledOne、myVariable 和 redLedOnRightSide。

当声明一个变量时，通常给它一个初始值是一个好主意。这有助于避免在初始化之前意外访问变量。要声明一个变量，我们定义变量的类型，然后是变量的名称，然后如果我们打算给它一个初始值，我们添加等号后跟初始值。以下代码展示了我们如何这样做：

```cpp
int myInt = 0;
```

在前面的代码行中，我们声明了一个名为 `myInt` 的整型 (`int`) 变量，并赋予其初始值 `0`。让我们看看一些在 Arduino 语言中使用的一些更流行的内置数据类型。

# 数据类型

Arduino 编程语言中有许多内置的数据类型。在本节中，我们将查看最常用的类型。让我们首先看看布尔类型。

# 布尔

布尔数据类型可以包含两个可能的值之一，`true` 或 `false`。以下示例展示了如何声明一个布尔类型的变量：

```cpp
boolean myBool = true;
```

前面的代码声明了一个名为 `myBool` 的布尔类型变量，并设置了初始值 `true`。布尔类型在标准的 Arduino 程序中使用得很多，所有比较操作，正如我们将在本章后面看到的，都返回布尔值。

# 字节

`byte` 数据类型是一个 8 位数值，其范围从 0 到 255。以下展示了如何声明 `byte` 类型的变量：

```cpp
byte myByte = 128;
```

前面的代码声明了一个名为 `myByte` 的 `byte` 类型变量，其初始值为 `128`。

# 整数

整数类型是当不需要小数时存储数值数据的主要数据类型。整数类型的变量可以包含从 -32,768 到 32,768 的数字。整数使用 `int` 关键字定义。

我们可以使用 `unsigned` 关键字声明一个无符号整数。无符号整数可以从 0 到 65,535，而正常整数范围是 -32,768 到 32,768。以下代码展示了如何定义一个常规整数和一个无符号整数：

```cpp
int mySignedInt = 25;
unsigned int myUnsignedInt = 15;
```

在前面的代码中，我们声明了一个名为 `mySignedInt` 的整数类型变量，其初始值为 `25`。我们还声明了一个名为 `myUnsignedInt` 的无符号整数类型变量，其初始值为 `15`。

在一些 Arduino 板（如 Due 或 SAMD）上，整数可以存储大于 32,768 和小于 -32,768 的值。由于大多数板子的整数范围是 -32,768 到 32,768，我建议始终假设你可以使用这个范围。

# 长

`long` 数据类型可以存储从 -2,147,483,648 到 2,147,483,647 的整数。以下代码展示了如何定义 `long` 变量：

```cpp
long myLong = 123,456,789; 
```

在前面的代码中，我们声明了一个名为 `myLong` 的 `long` 类型变量，并给它赋值为 123,456,789。如果需要存储比整数类型更大的数字，则应避免使用 `long` 数据类型，因为它比整数类型使用更多的内存。

# `double` 和 `float`

`double` 和 `float` 数据类型是浮点数，这意味着它们可以包含小数点。`double` 和 `float` 类型都可以存储从 -3.4028235E+38 到 3.4028235E+38 的值。

在大多数平台上，`float` 数据类型的精度为六或七位小数，而 `double` 数据类型通常有十五位小数；然而，在 Arduino 平台上并非如此。在 Arduino 平台上，`double` 和 `float` 类型完全相同，因此它们都具有六或七位小数的精度。

有两个非常好的理由不使用 `double` 或 `float` 值，除非你绝对需要小数。第一个原因是精度不准确，例如，6.0 除以 3.0 可能并不总是等于 2。你可能会得到类似 1.9999999999 的结果。第二个原因是浮点数运算比整数运算慢得多。

以下代码展示了如何定义一个 `double` 和 `float` 变量：

```cpp
double myDouble = 1.25; 
float myFloat = 1.5; 
```

在前面的代码中，我们声明了一个名为 `myDouble` 的 `double` 类型变量，其值为 `1.25`。我们还声明了一个名为 `myFloat` 的 `float` 类型变量，其值为 `1.5`。

# 字符

`char`数据类型通常被描述为存储字符的数据类型，然而，这在技术上是不正确的。`char`数据类型将字符存储为基于 ASCII 表的数值。当定义一个`char`变量时，它可以定义为表示字符的数字或字符本身，如下面的代码所示：

```cpp
char myChar = 'A';
char myChar = 65;
```

在前面的代码中，两行都声明了一个名为`myChar`的`char`类型变量，其值为大写字母`A`。能够只存储单个字符的类型是有用的，但如果可以存储整个单词或句子会更有用。在本章的后面部分，我们将看到如何通过使用字符数组来存储单词或句子。

# 数组

数组是有序变量的集合，这些变量类型相同。数组中的每个变量称为**元素**，这些元素可以通过数组中的位置（索引）来访问。当定义一个数组时，我们必须声明将要存储在其中的变量的类型。定义数组有多种方式。以下示例展示了定义数组的一些基本方法：

```cpp
int myInts[10];
int myInts[] = {1, 2, 3, 4};
int myInts[8] = {2, 4, 6, 8, 10};
```

这些示例中的每一个都定义了一个整数数组。第一个示例定义了一个未初始化的包含十个整数的数组。在定义未初始化的数组时要小心，因为内存位置永远不会初始化，这可能导致非常意外的结果。

第二个示例定义了一个包含四个整数的数组，所有元素都初始化了值。此数组自动调整大小以匹配初始化数组中的元素数量。

最后一个示例定义了一个包含八个整数的数组，其中前五个元素初始化了值，但最后三个元素未初始化。再次建议不要定义这样的数组，因为最后三个元素未初始化。一会儿我们将看到当我们尝试访问一个未初始化值的数组元素时会发生什么，但首先我们需要看到我们如何访问数组中的元素。

我们通过索引访问数组中的元素。我们将要检索的元素的索引放在两个方括号之间，如下面的代码所示：

```cpp
int myInts[] = {1, 2, 3, 4};
int myInt = myInts[1];
```

在前面的代码中，我们首先定义了一个包含四个整数的数组并初始化了所有四个值。在下一行中，我们检索索引`1`处的元素并将值放入`myInt`变量中。

认为变量`myInt`包含数字`1`是不正确的，因为数组是零索引的，这意味着第一个值将在索引`0`处，因此`myInt`变量包含数字`2`。以下代码展示了这是如何工作的：

```cpp
int myInts[] = {1, 2, 3, 4};
int myInt0 = myInts[0]; // contains 1
int myInt1 = myInts[1]; // contains 2
int myInt2 = myInts[2]; // contains 3
int myInt3 = myInts[3]; // contains 4
```

这段代码显示的是当我们声明了一个包含四个整数的数组时，这个数组的有效索引从`0`开始，到`3`结束。现在我们知道了如何访问数组，让我们看看当我们访问未初始化的元素时会发生什么。在脚本的`setup()`函数中添加以下代码并运行它：

```cpp
int myInts[5];
Serial.println(myInts[0]);
Serial.println(myInts[1]);
Serial.println(myInts[2]);
Serial.println(myInts[3]);
Serial.println(myInts[4]);
```

在串行监视器中，你会看到打印出五个值，但它们可以是任何有效的整数值，因为元素从未被初始化。将新值赋给数组中的元素就像将值赋给任何变量一样。以下代码显示了这一点：

```cpp
int myInts[2];
myInts[0] = 0;
myInts[1] = 1;
```

在前面的代码中，我们定义了一个包含两个整数的数组，并将值`0`赋给第一个元素，将值`1`赋给第二个元素。

我们还可以创建多维数组，它们基本上是数组的数组。以下代码显示了两种定义 3×4 整数数组的方法：

```cpp
int myInts[3][4];
int myInts[][] = { {0,1,2,3}, {4,5,6,7}, {8,9,10,11} };
```

多维数组中的元素可以通过索引访问，就像单维数组一样。以下代码显示了如何做到这一点：

```cpp
int myInt = myInts[1,2]; // The value would be 6
```

现在我们已经看到了如何使用数组，让我们看看我们如何使用字符数组来存储单词和句子。

# 字符数组

在本章前面，我们看到了我们可以使用字符（`char`）类型来存储单个字符；然而，如果我们想存储整个单词或句子呢？我们可以使用字符数组来做到这一点。字符数组可以像其他数组一样初始化，如下面的代码所示：

```cpp
char myStr[10]; 
char myStr[8] = {'A', 'r', 'd', 'u', 'i', 'n', 'o', '\0'}; 
```

通常，字符数组被称为**字符串**。在前面代码中，我们定义了一个未初始化的字符串，它可以包含多达十个字符，还有一个包含单词*Arduino*的字符数组。

你可能会注意到，在*Arduino*字符串的末尾有一个`\0`字符。这个字符代表一个空字符。当我们定义一个字符串时，我们应该始终以空字符结束字符串，这被称为**空终止**。通过以空字符结束字符串，像`serial.println()`这样的函数就知道字符串在内存中的结束位置。如果没有空字符，这些函数将继续读取内存，直到遇到空字符，这将在控制台中产生大量垃圾。

有更简单的方式来声明一个字符串，如下面的代码所示：

```cpp
char myStr[] = "Arduino";
char myStr[10] = "Arduino";
```

在前面的代码中，第一行初始化了一个包含单词 Arduino 的字符串，数组自动调整大小，并在末尾添加了空终止符。在第二行中，我们初始化了一个包含单词 Arduino 的字符串，并包含额外的空间。空终止符被添加到单词 Arduino 的末尾。

Arduino 语言确实包含一个单独的字符串对象；然而，你会发现字符数组在示例代码中用得很多。我们将在第七章中查看字符串对象，*Arduino 编程——超越基础*。

现在我们已经看到了如何使用变量和数组，让我们看看如何定义一个常量。

# 常量

常量是一个永远不会改变的值。在 Arduino 编程语言中，我们有两种声明常量的方式。我们可以使用`const`关键字或`#define`组件。

`#define`组件使我们能够在应用程序编译之前给一个常量值命名。编译器将在应用程序编译之前替换所有对这些常量的引用，用分配的值替换。这意味着定义的常量在内存中不占用任何程序空间，如果您试图将大型程序压缩到 Arduino Nano 中，这可能是一个优点。

`#define`组件确实有一些缺点，其中最大的缺点是如果为常量定义的名称也包含在其他常量或变量名称中，则该名称将被`#define`组件中定义的值替换。因此，当我使用`#define`来定义常量时，我通常使用全部大写字母作为名称。

以下代码展示了如何使用`#define`组件。您将在以下代码中注意到，使用`#define`组件时，行尾没有分号。当使用像`#define`这样的指令时，您不需要使用分号：

```cpp
#define LED_PIN 8
```

声明常量的第二种方式是使用`const`关键字。`const`关键字是一个变量限定符，它修改了变量的行为，使其变为只读。这将使我们能够像使用任何其他变量一样使用该变量，但我们无法更改变量的值。如果我们尝试更改值，我们将收到编译时错误。

以下代码展示了如何使用`const`关键字：

```cpp
const float pi = 3.14; 
```

`const`关键字通常比`#define`组件更受欢迎；然而，对于内存有限的设备，可以使用`#define`。现在让我们看看如何在 Arduino 编程语言中执行数学函数。

# 算术函数

Arduino 编程语言包括运算符，使我们能够计算两个操作数的和、差、积和商。要使用这些运算符，两个操作数必须是同一类型。这意味着，例如，我们能够计算两个整型变量的和；然而，如果我们不将其中一个变量强制转换为同一类型，我们就无法计算浮点变量和整型变量的和。我们将在本章稍后讨论类型转换。

以下示例展示了我们如何计算两个变量的和、差、积和商：

```cpp
z = x + y; // calculates the sum of x and y
z = x - y; // calculates the difference of x and y
z = x * y; // calculates the product of x and y
z = x / y; // calculates the quotient of x and y
```

当我们执行除法操作时，有时我们只需要余数。为此，我们可以使用取模运算符。如果我们用 5 除以 2，结果将是 2.5，因此使用取模运算符的结果将是 5，因为那是余数。以下代码示例展示了如何使用取模运算符：

```cpp
z = x % y // z will contain the remainder of x divided by y
```

Arduino 编程语言还包括复合赋值运算符，使我们能够将算术和变量赋值操作结合起来。这使得我们能够在执行算术运算的同时将结果赋值给原始变量。以下代码展示了 Arduino 编程语言中的复合运算符：

```cpp
x++; // increments x by 1 and assigns the result to x
x--; // decrements x by 1 and assigns the result to x
x += y; //increments x by y and assigns the result to x
x -= y; //decrement x by y and assigns the result to x
x *= y; //multiplies x and y and assigns the result to x
x /= y; //divides x and y and assigns the result to x
```

也有许多数学函数，使我们能够执行各种常见的数学运算。以下代码展示了其中一些更常见的函数：

```cpp
abs(x) // returns the absolute value of x
max(x,y) // returns the larger of the two values
min(x,y) //returns the smaller of the two values
pow(x,y) // returns the value of x raised to the power of y
sq(x) // returns the value of x squared
sqrt(x) // returns the square root of the value
```

现在我们已经看到了 Arduino 编程语言提供的算术运算符和函数，让我们来看看比较运算符。

# 比较运算符

Arduino 编程语言包括比较运算符，使我们能够比较两个操作数的值。比较运算符返回一个布尔值，指示比较是否为真或假。以下代码展示了我们如何使用这些运算符：

```cpp
x == y // returns true if x is equal to y
x != y // returns true if x is not equal to y
x > y // returns true if x is greater than y
x < y // returns true if x is less than y
x >= y // returns true if x is greater or equal to y
x <= y // returns true if x is less than or equal to y
```

现在我们已经看到了 Arduino 编程语言提供的比较运算符，让我们来看看逻辑运算符。

# 逻辑运算符

Arduino 编程语言中包含几个逻辑运算符。这些运算符是 AND、OR 和 NOT 运算符。NOT 运算符使我们能够反转比较操作。AND 和 OR 运算符使我们能够将多个比较运算符组合成一步。以下代码展示了如何使用逻辑运算符：

```cpp
(x > 5 && x < 10) // true if x is greater than 5 and less than 10
(x > 5 || x < 1) // true if x is greater than 5 or less than 1
!(x == y) // returns true if x is not equal to y
```

现在让我们看看如何进行变量类型转换。

# 类型转换

类型转换运算符将变量类型转换为不同的类型。这将使我们能够在不同类型的变量上执行操作，例如算术运算。例如，如果我们想要将两个变量相加，其中一个为浮点类型，另一个为整型，那么我们需要将其中一个变量进行类型转换，以便两个变量具有相同的类型。

需要注意的一点是，当我们把浮点值转换为整型值时，值会被截断而不是四舍五入。这意味着如果浮点变量包含值为 2.9，而我们将其转换为整型，值将是 2。考虑到这一点，我们通常希望将整型值转换为浮点值，而不是将浮点值转换为整型值，即使这意味着操作会花费更长的时间。

以下代码展示了如何将整型变量转换为浮点变量以执行算术计算：

```cpp
int x = 5;
float y = 3.14;
float z = (float)x + y;
```

我们可以编写的几乎所有有用的应用程序都包含某种逻辑。这种逻辑通常是通过根据某些输入来决定做什么来实现的。这要求我们的应用程序做出决策。让我们看看如何使用 Arduino 编程语言来实现这一点。

# 决策

在 Arduino 编程语言中，我们使用`if`语句来做出决策。`if`语句将检查条件是否为真，如果是，将执行花括号内的代码块。

以下展示了`if`语句的语法：

```cpp
if (condition) {
  // Code to execute
}
```

我们可以在`if`语句之后使用`else`语句来执行一个代码块，如果条件不成立。

下面的代码显示了`if/else`语句的语法：

```cpp
if (condition) {
  // Code to execute if condition is true
} else {
  // Code to execute if condition is false
}
```

`if`语句中的条件可以是任何布尔值或返回布尔结果的运算。你会发现你代码中的大多数`if`语句都将包含比较操作。让我们看看一些将说明这一点的代码：

```cpp
if (varA > varB) {
  Serial.println("varA is greater than varB");
} else {
  Serial.println("varB is greater or equal to varA");
}
```

在前面的代码中，我们使用了大于（`>`）比较运算符来查看`varA`是否大于`varB`。如果比较操作返回`true`，则将`varA is greater than varB`消息发送到控制台。如果比较操作返回`false`，则将`varB is greater or equal to varA`消息发送到控制台。

我们也可以通过使用带有`else`语句的`if`语句将`if`语句串联起来。以下代码说明了这一点：

```cpp
if (varA == varB) {
  Serial.println("varA is equal to varB");
} else if (varA > varB) {
  Serial.println("varA is greater than varB");
} else {
  Serial.println("varB is greater than varA");
}
```

在前面的代码中，我们使用了等于（`==`）比较运算符来查看`varA`是否等于`varB`，如果是这样，我们就将`varA is equal to varB`消息发送到控制台。如果不相等，我们随后使用大于（`>`）比较运算符来查看`varA`是否大于`varB`，如果是这样，我们就将`varA is greater than varB`消息发送到控制台。如果两个比较操作都不成功，我们就将`varA is equal to varB`消息发送到控制台。

当使用`else`和`if`语句一起时，代码将执行第一个返回`true`条件的代码块，然后忽略`else`语句的其余部分。

使用`if`和`else`语句是在应用程序中执行逻辑的最常见方式；然而，如果我们需要检查两个或三个以上的条件，代码可能会变得非常混乱。只需想象一下，如果最后的`if`/`else`示例有十个不同的条件需要检查。如果需要检查两个或三个以上的条件，我们可以使用`switch`/`case`语句。

`switch`/`case`语句接受一个值，将其与几个可能的匹配项进行比较，并根据第一个成功的匹配执行相应的代码块。当存在多个可能的匹配项时，`switch`语句是使用多个`else-if`语句的替代方案。如果有三个或更多的可能匹配项，则首选`switch`语句而不是`else-if`语句。`switch`语句的格式如下：

```cpp
switch (var) { 
  case match1:
    // Code to execute if condition matches case
  break;
  case match2:
   // Code to execute if condition matches case
  break;
  case match3:
   // Code to execute if condition matches case
  break;
  default:
   // Code to execute if condition matches case
}
```

前面的代码以`switch`语句开始，并在`switch`语句的括号内有一个名为`var`的变量。代码将尝试将`var`变量的值与每个从第一个开始的`case`语句进行匹配，一旦找到匹配项，它就会执行代码。

每个`case`语句中的代码应该以`break`语句结束。需要`break`语句是因为一旦`switch`语句匹配到某个`case`，它不仅会执行该`case`语句中的代码，还会执行每个后续`case`语句中的代码。这意味着如果我们没有包含`break`语句，并且`var`变量与`match2`中的值匹配，`match2`、`match3`和`default`中的代码都将执行。代码遇到`break`语句后立即退出`switch`语句，防止其他`case`语句中的代码执行。

现在我们已经看到了如何在 Arduino 编程语言中做出决策，让我们看看如何执行循环。

# 循环

Arduino 编程语言有三种循环语句，即`for`循环、`while`循环和`do`/`while`循环。我们将从查看`for`循环开始。

`for`循环用于重复执行代码块。`for`循环通常用于执行特定次数的代码块或访问数组中的元素。`for`语句有三个部分。这些部分是初始化、条件和增量。

在`for`语句的初始化部分，我们初始化需要初始化的任何变量。可以有多个初始化，用逗号分隔，但我建议避免在此处进行与`for`循环不直接相关的任何初始化。

`for`语句的条件部分期望一个返回`true`或`false`的语句，它通常包含一个条件语句。这个循环部分决定了循环何时结束。当条件语句返回`true`时，`for`循环将继续执行代码块。一旦条件语句返回`false`，循环将退出。

`for`语句的增量部分用于改变变量的值。这种改变在每次循环执行时都会进行。以下代码展示了`for`语句的语法：

```cpp
for (initialization; condition; change) { }
```

要查看实际代码的运行效果，以下展示了如何创建一个将循环十次的`for`语句：

```cpp
for (int i = 0; i < 10; i++) {
  // Code to execute
}
```

在前面的代码中，`for`语句在初始化部分将`i`变量初始化为零。在条件部分，`for`语句检查`i`变量是否小于十，如果是，代码将继续循环。在变化部分，每次循环执行时，`for`循环将`i`变量增加一。在示例中，`for`循环最初将`0`赋值给`i`变量，然后每次循环增加它，直到`i`变量等于`9`。

我们接下来要查看的下一个循环是`while`循环。`while`循环将重复执行一个代码块，直到`while`语句中定义的条件返回`false`。这可能是一个危险的循环，因为如果条件永远不会返回`false`，则循环将无限继续。`while`语句的语法如下：

```cpp
while (condition) {
  // code to execute
}
```

`while`语句中的条件应该返回`true`或`false`。这个条件通常是一个比较语句。以下代码展示了`while`语句的示例：

```cpp
int x = 0;
while (x < 200) {
  // code to execute
  x++;
}
```

在前面的代码中，代码块在`x`变量小于`200`时执行。在代码块结束时，`x`变量增加 1。如果我们忘记在代码块中放置增加`x`的行，那么`while`循环将无限循环。确保将更改语句放在代码块内非常重要，否则循环将永远不会退出。

使用`while`循环时，条件在执行代码块之前被检查。这意味着如果当`while`语句首次被调用时条件返回`false`，则代码块将永远不会被执行。如果我们需要确保代码块在条件检查之前至少执行一次，我们可以使用`do/while`循环。

`do/while`循环与`while`循环完全相同，只是条件是在执行代码块之后而不是之前被检查的。以下代码展示了这个循环的语法：

```cpp
do {
  // code to execute
} while (condition);
```

与`while`循环一样，`while`语句中的条件应该返回`true`或`false`，通常是一个比较语句。以下代码展示了`do/while`语句的示例：

```cpp
int x = 0;
do {
  // code to execute
  x++;
} while (x < 200);
```

前面的代码将执行代码块 200 次，这与上一个`while`循环中的代码完全一样。唯一的区别是，在`while`循环中，条件在执行代码块之前被检查，而在`do/while`循环中，条件在执行代码块之后被检查。

# 函数

函数是一个具有特定任务的命名代码块。当创建一个新的草图时，IDE 或 Web 编辑器会自动为我们创建两个函数，正如我们在上一章中看到的；然而，我们不仅限于只有这两个函数，我们还有能力自己声明自定义函数。以下代码展示了创建函数的语法：

```cpp
type name (parameters) { } 
```

要声明一个函数，我们需要声明函数的类型。函数类型是函数返回的值。如果函数不打算返回值，就像`setup()`和`loop()`函数一样，那么函数类型将是`void`。

一旦声明了函数类型，我们就定义函数的名称。函数名称应该是描述函数功能的。例如，如果我们正在创建一个可以打开或关闭 LED 的草图，那么我们可能会有名为`ledOff()`和`ledOn()`的函数。在命名函数时使用驼峰式命名法是一种良好的做法，就像变量一样。

在函数名称之后，我们在括号内放置函数的参数。参数是通过调用它的代码传递给函数的数据。函数通常依赖于这些数据来执行其所需的逻辑。您可以在括号内通过逗号分隔来放置多个参数。

我们使用花括号来定义函数代码块的开始和结束。左花括号表示函数的开始，而右花括号表示函数的结束。以下示例展示了不同类型的函数：

```cpp
void myFunction() {
  // Function code
}    

void myFunction(int param) {
  // Function code
}

int myFunction() {
  // Function code
}

int myFunction(int param) {
  // Function Code
}
```

第一个函数的返回类型是`void`，这意味着它不返回任何值。它也没有任何参数。这种类型的函数会被用来执行不需要返回任何信息回调用它的代码且不需要任何额外信息来执行其所需任务的任务。

第二个函数也有`void`类型的返回值，但它接受一个参数。这种类型的函数会在函数需要从调用它的代码中获取一些信息以执行其任务时使用。参数的第一部分是参数类型。在这个例子中，类型是`int`，这意味着数据将是整数类型。参数的第二部分是参数的名称。这意味着在这个例子中，参数名为`param`，是整数类型。要声明多个参数，我们可以用逗号将它们分开，如下所示：`(int param1, int param2, float param3)`。

第三个函数的返回类型是`int`，这意味着它必须返回一个整数；然而，它不接受任何参数。如果我们想要从函数传递信息回调用它的代码，这种类型的函数会被使用。

第四个函数返回一个整数并接受一个参数。如果我们想要将信息传递回调用它的代码，并且需要从该代码中获取信息以执行其任务，这种类型的函数会被使用。

我们使用`return`语句从函数返回一个值。以下代码展示了如何做到这一点：

```cpp
int myFunction() {
  var x = 1;
  var y = 2;
  return x + y;
}
```

当在函数内部创建变量时，就像我们在上一个示例中看到的那样，该变量只能在那个函数内部访问。以下代码说明了这一点：

```cpp
int g = 1;
void function myFunction1() {
  int x1 = 2;
}
void function myFunction2() {
 int x2 = 3;
}
```

在前面的代码中，`g`变量，因为它是在函数外部声明的，所以可以被任何函数访问。当你像这样在函数外部声明变量时，它被视为一个全局变量。`x1`变量只能在`myFunction1()`函数内部访问，而`x2`变量只能在`myFunction2()`函数内部访问。

# 摘要

在本章中，我们介绍了 Arduino 编程语言的基础知识。本章中的材料为本书中涵盖的所有其他内容奠定了基础，因此，理解这里所展示的项目非常重要。

在下一章中，我们将探讨 Arduino 编程语言和 Arduino 开发环境的一些更高级的功能。
