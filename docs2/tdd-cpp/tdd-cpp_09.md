

# 第九章：使用测试

到目前为止，本书的所有内容都是关于使用 TDD 来设计和构建一个单元测试库。虽然这很有价值，但它是一个自举项目，我们使用 TDD 来帮助创建一个 TDD 的工具。

本章有所不同。我们将首次使用 TDD 来创建一个将使用单元测试库的项目。这仍然是一个旨在供其他项目使用的库。我们将创建一个日志库，并使用 TDD 和单元测试库来实现以下目标：

+   设计一个易于使用的界面

+   提高代码质量

+   在保持对代码的信心的情况下，根据需要重构设计

+   创建帮助捕捉需求和记录库用法的测试

这种方法现在应该已经很熟悉了。我们将从简单开始，先让某个功能工作，然后再增强设计并添加新功能。每个步骤都将从测试开始，以驱动设计，从而实现目标。

我们首先思考一下为什么我们要构建一个日志库。这对于确定项目的整体方向非常重要。然后我们将探讨 TDD 如何帮助我们，以及理想的日志库应该是什么样子。接着，我们将开始构建日志库。

在本章结束时，你将拥有一个简单的日志库，你可以在自己的项目中使用。但更重要的是，通过看到如何在真实项目中使用 TDD，你将获得一项技能。

# 技术要求

本章中所有代码都使用标准 C++，它基于任何现代 C++ 20 或更高版本的编译器和标准库。代码使用前几章中的测试库，并将启动一个新的项目。

你可以在以下 GitHub 仓库中找到本章的所有代码：

[`github.com/PacktPublishing/Test-Driven-Development-with-CPP`](https://github.com/PacktPublishing/Test-Driven-Development-with-CPP)

# 为什么要构建一个日志库？

在其他库中已经有很多用于日志的选择了。那么为什么还要构建另一个日志库？这不是应该是一本关于 TDD 的书吗？

这是一本实用的书，展示了如何在你的项目中使用 TDD。而实现这一目标最好的方法之一就是使用 TDD 来构建一个项目。我们需要为这本书找一个项目，我认为日志库是完美的，因为我们可以从简单开始，并在过程中增强它。日志库本身既实用又实际，这也符合本书的主题。

如果你已经有了自己的日志库或者正在使用其他地方找到的日志库，那么这本书仍然能帮助你更好地理解它是如何工作的。你还可以从构建日志库的过程中受益，这样你就可以将同样的过程应用到自己的项目中。

但我们不会满足于一个只做所有其他日志库所做的事情的日志库。遵循 TDD 方法，我们需要有一个很好的想法，知道某物将如何被使用。我们从用户的角度来处理问题。

我们将像构建微服务一样来处理这个问题。而不是构建一个作为单一应用程序的软件解决方案，这个应用程序能够完成所有需要的功能，微服务架构构建的是一些较小的应用程序，它们接受请求，执行一些期望的服务，并返回结果。有时一个服务可以调用其他服务来执行其功能。

这种架构有许多好处，本书将不会深入探讨。这种架构正在被用来在我们应用 TDD 来设计日志库时，提供一个特定的用途，这个日志库将特别适合微服务环境。

如果没有关注和了解将需要你设计的软件的具体用户，你面临的风险是设计出不符合该用户需求的东西。本书的用户将是一位编写微服务的软件开发者，需要记录服务做了什么。这就是我鼓励你在设计自己的软件时要达到的那种关注类型。因为没有这种关注，我们可能会直接跳入一个做大多数其他日志库所做的事情的日志库。我们的微服务开发者会看到一个通用目的的日志库，并发现它没有什么特别之处。

我们的目标是让同一个微服务开发者看到我们的日志库，并立即看到其好处，并想要开始使用它。下一节将展示 TDD 如何从对将使用日志库的人的了解中受益。

# TDD 如何帮助构建日志库？

使用 TDD 来构建日志库，我们将获得的最大好处是客户关注。关于如何设计某物，很容易做出假设，尤其是在已经有许多类似解决方案的情况下。

这就像一条容易跟随的小径。这条小径可能会带你去你想去的地方，或者可能就在附近。如果目的地模糊或未知，那么小径就更容易跟随。但如果你确切地知道你想去哪里，那么你可以在方便的时候跟随小径，当它不再带你去你想去的地方时，你也可以离开小径。

TDD 鼓励我们思考我们想要如何使用我们正在构建的软件。这反过来又让我们能够定制解决方案，以最好地满足我们的需求。换句话说，它让我们知道何时离开小径，开始新的路径。

我们还从拥有可以验证软件行为的测试中受益，因为构建软件不像一次走过一条路。我们不是从起点开始，直接走到我们想要构建的最终软件或目的地。

相反，我们细化路径。这更像是从一个地图开始，画一条通往目的地的粗糙路径。也许这条路径与已知和现有的路径对齐，也许不对。一旦我们画出了粗糙的路径，我们就通过添加更多细节来细化它。有时细节可能会让我们改变路径。当我们完成时，我们已经走了很多次，以至于我们数不清了。

TDD 通过引导我们首先找到一个简单的解决方案并验证其是否有效来帮助我们。这就像地图上最初画出的粗糙路径。每次我们增强和细化解决方案时，我们都有测试来确保我们没有破坏任何东西。这就像检查我们是否仍然在正确的路径上。

有时，增强功能会导致需要设计变更。这就像发现一条在初始地图上没有出现的河流阻挡了我们的去路。我们需要找到一个不同的地方过河。路径改变了，但保持在新的路径上的需求仍然存在。这就是测试帮助我们的地方。我们有一个新的设计，它解决了未预见的问题，但我们仍然可以使用现有的测试来验证新的设计。我们对新的设计有信心，因为它在解决意外问题的同时，仍然按预期执行。

TDD 通过提供如何使用库的清晰和文档化的示例来帮助其他项目增加日志库的使用。这就像制作沿着路径行走的视频，以便未来的旅行者知道他们可以期待什么，以及他们是否想在开始之前跟随这条路径。在完全文档化和易于遵循的示例与声称提供相同结果但没有证据的类似库之间做出选择时，大多数人会倾向于我们的库。随着时间的推移，我们的解决方案将变得更好，因为我们吸收了用户的反馈。

让我们从思考我们想要的目的地开始。这将是我们为预期客户设计的理想日志库。那会是什么样子？这将形成我们将开始细化的第一条粗糙路径。

# 理想的日志库应该是什么样子？

在设计软件时，记住这一点是好的：如果你已经有了满足需求的常见解决方案，就不必设计全新的东西。仅仅为了与众不同而设计的新方案只会让人困惑。如果新的设计因为现有设计不太适用，而差异解决了真正的需求，那么这是好的。所以在我们开始梦想新的日志设计之前，让我们先看看常见的想法，看看我们是否真的需要新的东西。

要做到彻底彻底，我们也应该尝试使用 C++已经提供的功能。也许这就足够了，我们不需要一个库。假设我们有以下代码，尝试计算从 1 开始，将值翻倍三次的结果。正确答案应该是 8，但这段代码有一个错误：

```cpp
#include <iostream>
int main ()
{
    int result = 1;
    for (int i = 0; i <= 3; ++i)
    {
        result *= 2;
    }
    std::cout << "result=" << result << std::endl;
    return 0;
}
```

它打印的结果是 16 而不是 8。你可能已经看到了问题，但让我们想象一下，代码要复杂得多，问题并不明显。按照目前的代码编写方式，我们将通过循环四次而不是三次。

我们可以添加额外的输出，如这个，以帮助找到问题：

```cpp
    for (int i = 0; i <= 3; ++i)
    {
        std::cout << "entering loop" << std::endl;
        result *= 2;
    }
```

运行后，将产生以下输出：

```cpp
entering loop
entering loop
entering loop
entering loop
result=16
```

结果清楚地显示循环运行了四次，而不是仅仅三次。

我们通过在输出中添加额外文本来显示代码运行时的状态，所做的一切都是日志的核心。当然，我们可以添加更多功能或做更多。但我们需要问的问题是，这足够吗，这能满足我们的需求吗？

使用 `std::cout` 是不够的，并且由于几个原因，它不能满足我们的需求：

这个简单的例子已经使用了控制台输出来显示结果。通常，服务应该避免向控制台发送文本，因为没有人在屏幕上监视结果。

即使控制台是程序输出的期望目的地，我们也不应该将额外的日志输出与常规输出混合。

我们可以将日志输出发送到不同的流，例如 `std::cerr`，但这并不是一个完整的解决方案。日志输出总是错误吗？也许它有助于我们确定程序实际上正在正确运行，而问题可能出在其他地方。

记录额外信息是有用的，但并非总是如此。直接将输出发送到 `std::cout` 并不能给我们提供一种在不更改源代码和重新构建的情况下关闭输出的方法。

如果日志输出包括额外的信息，例如日期和时间，那会很好。我们可以添加这些额外信息，但这样我们就必须每次调用 `std::cout` 来记录信息时都添加它。

我们在设计上取得了进展，因为我们刚刚消除了一条可能的路径。在寻找其他解决方案之前，总是考虑你已经拥有的东西总是好的。

如果我们将日志放入一个函数中并调用该函数而不是直接使用 `std::cout`，代码可能看起来像这样：

```cpp
#include <fstream>
#include <iostream>
void log (std::string_view message)
{
    std::fstream logFile("application.log", std::ios::app);
    logFile << message << std::endl;
}
int main ()
{
    int result = 1;
    for (int i = 0; i <= 3; ++i)
    {
        log("entering loop");
        result *= 2;
    }
    std::cout << "result=" << result << std::endl;
    return 0;
}
```

这已经是一个很大的改进。尽管应用程序仍然使用 `std::cout` 来显示结果，但我们并没有通过更多的控制台输出为日志添加噪音。现在日志输出进入了一个文件。这也避免了将日志与常规结果混合。

我们甚至可以在 `log` 函数内部添加一个检查，以查看消息是否应该被记录或忽略。并且将所有内容封装在函数中也会使添加诸如日期和时间等常见信息变得容易。

理想解决方案仅仅是函数吗？

并非如此，因为我们还需要配置日志。上面显示的代码非常简单，并使用了固定的日志文件名。而且还缺少其他将改善日志体验的功能，例如：

+   代码目前为每条消息打开和关闭日志文件。

+   假设消息应该发送到文件。也许我们希望消息发送到其他地方或文件，以及其他地方。

+   消息是一个单独的文本字符串。

+   代码没有处理多个线程同时尝试记录消息的情况。

+   日志函数使主应用程序等待直到日志消息被写入，然后应用程序才能继续。

+   我们还没有为我们的目标客户，即微服务开发者，添加任何特定的功能，例如过滤消息的能力。

我们已经有一个很好的开始，这证实了有足够的必要来证明库的需求。

考虑其他类似解决方案也是一个好主意，而且有很多。一个著名的日志库来自 Boost C++ 库，称为 Boost.Log。这个库允许你以简单的方式开始向控制台记录日志。而且这个库是可扩展的，速度快。但它也很大。尽管它一开始很简单，但我花了好几天时间阅读文档。一件事引出另一件事，在我意识到之前，我正在学习日志库使用的其他技术。

虽然 Boost.Log 库可能一开始看起来很简单，但它很快就会要求你学习比预期多得多的内容。我希望创建一个使用起来仍然保持简单的东西。我们理想的日志库应该一开始就易于使用，并隐藏任何必要的复杂性，这样用户就不会被选项淹没。我们并不是试图构建一个可以做一切日志库。我们有一个特定的用户群体，并且将使用 TDD 来关注那个微服务开发者的需求。

下一节将开始创建日志库的过程。在我们开始编写测试之前，我们需要创建一个新的项目，下一节将解释这一点。

# 使用 TDD 开始一个项目

既然我们已经确定日志库是一个好主意，并且是合理的，那么是时候开始一个新的项目了。让我们从上一节中的 `log` 函数开始，创建一个新的项目。`log` 函数看起来是这样的：

```cpp
void log (std::string_view message)
{
    std::fstream logFile("application.log", std::ios::app);
    logFile << message << std::endl;
}
```

我们将把这个 `log` 函数放在哪里，测试项目的结构会是什么样子？在早期章节中，我们测试了单元测试库。这是我们第一次将单元测试库作为我们正在工作的实际项目之外的东西使用。项目结构将如下所示：

```cpp
MereMemo project root folder
    MereTDD folder
        Test.h
    MereMemo folder
        Log.h
        tests folder
            main.cpp
            Construction.cpp
```

新的结构使用一个名为 `MereMemo` 的包含文件夹作为项目根文件夹。就像单元测试库被称为 MereTDD 一样，我决定继续使用 mere 这个词，并将日志库命名为 MereMemo。其他选择已经被使用，而 memo 这个词代表写下某事以记住它的想法。

你可以看到，在根文件夹内部有一个名为 `MereTDD` 的文件夹，里面只有一个 `Test.h` 文件。我们不再需要包含单元测试库的测试。我们现在将使用单元测试库，而不是进一步开发它。如果我们以后需要修改单元测试库，那么我们将回到包含单元测试库测试的先前项目。

项目根文件夹为我们提供了一个放置单元测试库头文件（在它自己的文件夹中）和日志库（也在它自己的文件夹中）的地方。

在 `MereMemo` 文件夹内部有一个名为 `Log.h` 的文件。这就是我们将放置 `log` 函数的地方。还有一个名为 `tests` 的文件夹，它将包含日志库的单元测试。在 `tests` 文件夹内部，我们将找到 `main.cpp` 文件以及所有其他单元测试文件。目前，只有一个名为 `Construction.cpp` 的单元测试文件，它是空的，还没有包含任何测试。

我还应该提到，你不需要像这样将 `MereTDD` 文件夹放在你的项目根文件夹内。你可以将其放在任何你想要的位置。这就像在你的计算机上安装单元测试库一样。由于单元测试库实际上只是一个单独的头文件，所以没有需要安装的内容。只需要在计算机上的一个方便位置创建头文件，以便你知道路径。我们需要在开发工具的项目设置中添加路径，以便编译器知道在哪里找到 `Test.h`。我将在稍后解释这一步骤。

我们需要在 `Log.h` 中使用通常的 `include` 守卫，并在将 `log` 函数放入其中之后，`Log.h` 应该看起来像这样：

```cpp
#ifndef MEREMEMO_LOG_H
#define MEREMEMO_LOG_H
#include <fstream>
#include <iostream>
#include <string_view>
namespace MereMemo
{
inline void log (std::string_view message)
{
    std::fstream logFile("application.log", std::ios::app);
    logFile << message << std::endl;
}
} // namespace MereMemo
#endif // MEREMEMO_LOG_H
```

现在的 `log` 函数需要内联，因为它位于自己的头文件中，并且在项目中可能会被多次包含。

我们可以主要复制 `main.cpp` 文件的内容，从单元测试库项目使用它来运行日志库项目的单元测试。不过，我们需要对包含 `Test.h` 的方式做一点小的修改。`main.cpp` 文件应该看起来像以下示例：

```cpp
#include <MereTDD/Test.h>
#include <iostream>
int main ()
{
    return MereTDD::runTests(std::cout);
}
```

你可以看到，我们现在使用尖括号而不是引号来包含 `Test.h`。这是因为 `Test.h` 并不是日志库的直接部分；它现在是从另一个项目中包含的文件。从其他项目或库中包含文件的最佳方式是将它们保存在各自的文件夹中，并在你的开发工具中更改项目设置，以告诉编译器查找所需文件的路径。

对于我的开发工作，我正在使用 CodeLite **集成开发环境**（**IDE**），可以通过在项目上右键单击并选择**设置**菜单选项来访问项目设置。在弹出的对话框中，有一个用于编译器设置的选项。在编译器设置页面上，有一个选项可以指定包含路径。CodeLite 有一些预定义的路径，可以用来识别诸如当前项目路径之类的信息。我将包含路径设置为如下所示：

```cpp
.;$(ProjectPath)
```

包含路径由分号分隔。您可以看到指定了两个路径。第一个是一个点，表示在当前文件夹中查找包含的文件。这就是使用引号的项目特定包含文件被找到的方式。但我还添加了一个使用美元符号和括号的特殊语法路径，这告诉 CodeLite 在项目根目录中查找额外的包含文件。实际上发生的情况是，CodeLite 解释路径，包括其特殊预定义路径，如 ProjectPath，并将实际的文件系统路径发送给编译器。编译器对`ProjectPath`、括号或美元符号一无所知。

如果您决定将单元测试库放在您的计算机上的其他位置，您需要添加完整路径而不是使用 ProjectPath。如果您正在使用除 CodeLite 之外的 IDE，则过程将类似。所有 IDE 都有自己指定编译器使用包含路径的方式。设置通常总是在一个可以从项目打开的设置对话框中。

在完成所有这些设置和项目配置工作后，是时候开始编写一些测试了，下一节将开始。

# 记录和确认第一条消息

现在我们已经准备好了一个项目，我们可以开始编写一些测试，并设计日志库。我们已创建了一个名为`Construction.cpp`的空单元测试文件。我喜欢从一些简单的测试开始，确保类可以被构造。我们还可以使用它来确保简单函数可以被调用。本节将专注于创建一个测试来记录我们的第一条消息并确认一切正常。

我们已经有了之前的`log`函数，它打开一个文件并追加一条消息。让我们添加一个调用`log`并写入内容的测试。以下示例显示了如何编辑`Construction.cpp`以添加第一个测试：

```cpp
#include "../Log.h"
#include <MereTDD/Test.h>
TEST("Simple message can be logged")
{
    MereMemo::log("simple");
}
```

由于我们正在测试日志库，我们需要包含`Log.h`，它位于`Construction.cpp`所在的父目录中。我们使用引号来表示`Log.h`，因为它位于同一项目中。稍后，如果您想在自己的项目中使用日志库，只需将`Log.h`放在一个已知位置，并用尖括号包含它，就像我们现在用尖括号包含`Test.h`一样。

单个测试只是调用 `log` 函数。这实际上只是通过创建一个真实的项目并使用测试来代替直接在 `main` 中编写代码，重新组织了我们在这个章节开始时的代码。构建和运行项目向控制台显示了以下输出：

```cpp
Running 1 test suites
--------------- Suite: Single Tests
------- Test: Simple message can be logged
Passed
-----------------------------------
Tests passed: 1
Tests failed: 0
```

单个测试运行并通过了。但是，只要它不抛出异常，它就会通过。这是因为测试中没有确认。我们真正感兴趣的输出甚至没有出现在控制台上。相反，它全部都进入了名为 `application.log` 的日志文件。当我从 CodeLite IDE 运行项目时，它显示了类似的输出。但似乎 CodeLite 从一个临时文件夹中运行代码。其他 IDE 也做类似的事情，有时很难跟上临时位置。因此，你可能想使用你的 IDE 来构建项目，然后打开一个单独的终端窗口来手动运行测试应用程序。这样，你就可以完全控制应用程序的运行位置，并打开一个窗口来检查创建的日志文件。

我的程序在名为 `Debug` 的文件夹中构建，构建后该文件夹的内容包含可执行文件和用于创建最终可执行文件的对象文件。在运行测试应用程序项目之前，没有名为 `application.log` 的文件。一旦项目运行，`application.log` 文件可以像这样打印到控制台：

```cpp
$ cat application.log 
simple
```

在 `$` 提示符下，使用 `cat` 命令来显示 `application.log` 文件的内容，该文件包含一行简单的消息。如果我们再次运行项目，那么我们将新内容追加到同一个日志文件中，看起来像这样：

```cpp
$ cat application.log 
simple
simple
```

在运行应用程序两次之后，我们在日志文件中得到了两条消息。这两条消息完全相同，这将使得确定日志文件中是否添加了新内容变得困难。我们需要一种方法来创建唯一的消息，然后是验证特定消息是否出现在日志文件中的方法。这将使我们能够在测试中添加一个确认，以验证消息是否被记录，而无需每次运行测试时都手动检查日志文件。

其他测试可能需要生成唯一消息并验证日志文件内容的能力，我们可能希望将这些其他测试放在不同的 `test.cpp` 文件中。这意味着我们应该添加一个辅助文件来编写所需的代码，以便它可以与其他文件中的其他测试共享。

对于这种辅助文件，一个常见的名字是 `Util`。似乎每个项目都有 `Util.h` 和 `Util.cpp`，原因就在于此。这是一个放置可以在整个项目中共享的有用代码的好地方。

如果我们有这些辅助函数，测试看起来会是什么样子？将 `Construction.cpp` 改成以下截图的样子：

```cpp
#include "../Log.h"
#include "Util.h"
#include <MereTDD/Test.h>
TEST("Simple message can be logged")
{
    std::string message = "simple ";
    message += Util::randomString();
    MereMemo::log(message);
    bool result = Util::isTextInFile(message,          "application.log");
    CONFIRM_TRUE(result);
}
```

我们需要包含`Util.h`，然后我们可以通过附加从调用`randomString`获得的随机字符串来使消息唯一。完整的消息存储在一个变量中，这样我们就可以在记录和验证时使用它。记录消息后，我们调用另一个新函数`isTextInFile`来验证。

这个测试的一个问题是需要指定日志文件名。目前，日志文件名硬编码在`log`函数中。我们不会立即修复日志文件名的问题。在使用 TDD（测试驱动开发）时，我们一步一步来。如果你有一个问题跟踪系统，将日志文件名问题添加到跟踪系统中可以确保它不会被遗忘。

现在我们已经了解了实用函数的使用方式，让我们将这两个实用文件添加到`tests`文件夹中的项目中，并在`Util.h`中添加一些函数声明，如下所示：

```cpp
#ifndef MEREMEMO_TESTS_UTIL_H
#define MEREMEMO_TESTS_UTIL_H
#include <string>
#include <string_view>
struct Util
{
    static std::string randomString ();
    static bool isTextInFile (
        std::string_view text,
        std::string_view fileName);
};
#endif // MEREMEMO_TESTS_UTIL_H
```

第一个函数将允许我们生成一个随机字符串，我们可以用它来使消息唯一。总有可能得到重复的字符串，这可能导致我们错误地认为日志文件包含新的日志消息，而实际上我们看到的是使用了相同随机字符串的先前消息。在实践中，这不应该是一个问题，因为我们不会仅仅记录随机字符串。我们将随机字符串添加到其他文本中，这样每个测试都将具有唯一性。

当我最初开发这段代码时，我在许多测试中使用了相同的文本。添加到末尾的随机数使每个消息都是唯一的。或者至少，我没有注意到任何重复的消息。测试都进行得很顺利，直到我到达*第十五章*，*如何使用多线程进行测试*，并在一个测试中添加了 150 条新消息。问题并不是由于多线程引起的。问题始终存在，直到额外的消息增加了重复消息的概率才出现。我们将通过为每个测试使用唯一的基消息文本来避免这个问题。

第二个函数将允许我们确认某些文本确实存在于文件中，我们可以使用这个来验证特定消息是否存在于日志文件中。

我喜欢在结构体中将这样的函数定义为静态方法。这有助于确保实现与头文件中的声明相匹配。实现部分放在`Util.cpp`中，如下所示：

```cpp
#include "Util.h"
#include <fstream>
#include <random>
std::string Util::randomString ()
{
    return "1";
}
bool Util::isTextInFile (
    std::string_view text,
    std::string_view fileName)
{
    return false;
}
```

实现目前除了返回之外不做任何事情。但这让我们能够构建和验证测试失败。

我们为什么要确保测试失败呢？

因为这有助于在我们实际实现函数后验证通过的结果。失败确保测试被正确编写并且可以捕获失败。一旦我们实现了辅助函数，测试就会通过，我们可以确信通过是来自辅助实现，而不是一个无论如何都会通过的测试。

以下截图显示了运行项目时预期的失败情况：

```cpp
Running 1 test suites
--------------- Suite: Single Tests
------- Test: Simple message can be logged
Failed confirm on line 15
    Expected: true
-----------------------------------
Tests passed: 0
Tests failed: 1
```

尽管手动检查`application.log`文件显示预期的消息确实被写入日志文件的末尾：

```cpp
$ cat application.log 
simple
simple
simple 1
```

现在让我们修复`randomString`函数，以确保我们可以记录独特的消息。我们需要包含`chrono`来能够设置一个基于当前时间的随机数生成器。以下代码片段显示了`Util.cpp`中的相关代码：

```cpp
#include <chrono>
#include <fstream>
#include <random>
std::string Util::randomString ()
{
    static bool firstCall = true;
    static std::mt19937 rng;
    if (firstCall)
    {
        // We only need to set the seed once.
        firstCall = false;
        unsigned int seed = static_cast<int>(
            std::chrono::system_clock::now().
            time_since_epoch().count());
        rng.seed(seed);
    }
    std::uniform_int_distribution<std::mt19937::result_type> dist(1, 10000);
    return std::to_string(dist(rng));
}
```

因为这使用了随机数，所以每次都会得到不同的结果。测试仍然失败，但运行测试应用程序几次之后，我的`application.log`文件看起来像这样：

```cpp
$ cat application.log 
simple
simple
simple 1
simple 2030
simple 8731
```

消息现在相对独特，有轻微的重复日志消息的可能性。这对目前来说已经足够好，我们可以继续进行验证函数的工作。我们一直在测试应用程序运行之间保留日志文件，所以每次新的消息都会被附加。为了验证你的代码，一个真正的测试运行应该从一个干净的环境开始，没有任何来自之前运行的遗留文件。

我现在展示的是随机字符串和验证的代码，但没有完全解释一切。这是因为随机数和文件搜索是需要的，但它们并不完全在解释 TDD 的范围内。解释随机数的所有细节或甚至搜索文本文件以匹配字符串很容易跑题。

`isTextInFile`函数的实现如下：

```cpp
bool Util::isTextInFile (
    std::string_view text,
    std::string_view fileName)
{
    std::ifstream logfile(fileName.data());
    std::string line;
    while (getline(logfile, line))
    {
        if (line.find(text) != std::string::npos)
        {
            return true;
        }
    }
    return false;
}
```

这个函数所做的只是打开日志文件，读取每一行，并尝试找到文本。如果找到文本，则返回 true，如果在任何一行中找不到文本，则函数返回 false。

构建和运行项目现在显示测试通过如下：

```cpp
Running 1 test suites
--------------- Suite: Single Tests
------- Test: Simple message can be logged
Passed
-----------------------------------
Tests passed: 1
Tests failed: 0
```

我们现在有了一种将日志消息写入文件并确认消息出现在文件中的方法。代码可以更高效，因为目前它在查找文本时从日志文件的开始处搜索整个文件。但我们的目标不是编写最好的日志文件搜索工具。测试日志文件不太可能变得很大，所以简单的搜索方法应该可以很好地工作。

日志需要不仅仅是消息才能变得有用。下一节将向消息添加时间戳，添加日志库所需的最小功能集。

# 添加时间戳

单个日志文件仅通过消息可能提供一些价值，但记录每条日志消息的日期和时间会使它更有价值。一旦我们开始使用来自不同微服务的多个日志文件，按时间顺序排列日志消息的需求变得至关重要。

添加时间戳相当简单。我们只需要获取当前时间，将其格式化为一个标准的、消除年份、月份和日期之间误解的时间戳，然后将时间戳连同消息一起发送到日志中。调用者不需要做任何事情。

直接测试以确保其工作也是一项困难的工作。我们可以手动打开日志文件并查看时间戳；现在这已经足够了。我们不会为时间戳添加任何新的测试。

我们需要做的只是修改`Log.h`，使其看起来像这样：

```cpp
#include <chrono>
#include <ctime>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <string>
#include <string_view>
namespace MereMemo
{
inline void log (std::string_view message)
{
    auto const now = std::chrono::system_clock::now();
    std::time_t const tmNow =          std::chrono::system_clock::to_time_t(now);
    auto const ms = duration_cast<std::chrono::milliseconds>(
        now.time_since_epoch()) % 1000;
    std::fstream logFile("application.log", std::ios::app);
    logFile << std::put_time(std::gmtime(&tmNow),                "%Y-%m-%dT%H:%M:%S.")
               << std::setw(3) << std::setfill('0')                << std::to_string(ms.count())
               << " " << message << std::endl;
}
```

我们需要包含一些新的系统头文件，`chrono`、`ctime`、`iomanip`和`string`。一种更好的格式化日期和时间的办法是使用一个新的系统头文件`format`。不幸的是，尽管`format`是 C++20 的一部分，但它仍然没有被大多数标准库广泛实现。因此，这段代码使用了一种稍微旧一点的格式化方法，该方法使用了标准的`put_time`函数。

我们首先获取系统时间。然后我们需要将时间转换为一种较旧的格式，称为`time_t`。尽管我经常只提到时间，但我通常指的是时间和日期。

我们希望时间戳尽可能精确，仅仅记录到秒并不足够精确。因此，我们需要将时间转换为毫秒，然后除以 1,000 以得到所需的秒分数。

函数继续以前的方式打开日志文件。但现在，它使用`gmtime`调用`put_time`，我们可以确保在不同时区的机器上生成的日志将按正确顺序排列，因为所有时间都指的是同一个时区。

如果你使用的是微软的 Visual Studio 工具，你可能会在使用`gmtime`时遇到错误。我提到这是一个较旧的方法，一些编译器可能会抱怨`gmtime`可能是不安全的。推荐的替代方案是`gmtime_s`，但这个替代函数需要在代码中进行一些额外的检查以查看它是否可用。其他编译器也可能对`gmtime`提出抱怨，通常会在错误信息中告诉你如何修复问题。Visual Studio 的错误信息表示，如果我们想使用`gmtime`，我们需要在项目的 C++预处理器定义下定义`_CRT_SECURE_NO_WARNINGS`。

包含百分号和大小写字母的奇怪格式化方式告诉`put_time`如何格式化日期和时间的各个元素。我们希望按照**ISO-8601**标准格式化日期和时间。最重要的是，该标准规定年份首先出现，后面跟着四位数字，然后是两位数字的月份，最后是两位数字的日期。数字之间允许使用连字符。

没有这样的标准，像 10-07-12 这样的日期对不同的人可能意味着不同的日期。那是 2012 年 10 月 7 日？还是 7 月 10 日？或者是 2010 年 7 月 12 日？或者是 2010 年 12 月 7 日？我们唯一能达成共识的是，年份可能不是 2007 年。即使使用四位数的年份，月份和日期仍然可能混淆。通过使用 ISO-8601，我们所有人都同意年份首先出现，然后是月份，然后是日期。

在标准中接下来是大写字母 T。这仅仅是将日期部分与时间部分分开。时间接下来，因为我们都同意小时先来，然后是分钟，然后是秒。我们在显示分数毫秒之前在秒后放一个点。

在进行这些更改、删除旧的日志文件、构建和运行项目几次之后，我们可以看到日志文件看起来像这样：

```cpp
$ cat application.log 
2022-06-13T03:37:15.056 simple 8520
2022-06-13T03:37:17.288 simple 1187
2022-06-13T03:37:18.479 simple 2801
```

我们唯一没有做的是在时间戳中包含特定文本来显示时间是 UTC。我们可以添加特定时区信息，但这可能不是必需的。

我们有时间戳并且可以记录一段文本。下一节将允许我们记录多于一段文本。

# 使用流构建日志消息

有一个接受单个字符串以显示的`log`函数并不是最容易使用的函数。有时，我们可能想要记录更多信息。我们也可能想要记录不同类型的信息，而不仅仅是字符串。这就是我们可以使用 C++中广泛使用的强大流式传输能力的地方。

我们已经在`log`函数内部使用了一个流。我们只需要停止将单个消息文本发送到`log`函数内部的流，并返回流本身给调用者。然后调用者就可以自由地流式传输所需的内容。

我们可以通过首先修改测试来看到这将是什么样子；我们必须像它返回一个流一样使用`log`函数。修改后的测试看起来像这样：

```cpp
TEST("Simple message can be logged")
{
    std::string message = "simple ";
    message += Util::randomString();
    MereMemo::log() << message << " with more text.";
    bool result = Util::isTextInFile(message,          "application.log");
    CONFIRM_TRUE(result);
}
```

现在，我们调用`log`函数而不带任何参数。我们不是将`message`变量作为参数传递，而是使用`log`函数的返回值作为流，并将消息与另一段文本直接发送到流中。

注意我们如何在第二段文本前添加一个空格。这是为了防止文本与前一条消息连接在一起。就像任何流一样，确保文本不会连在一起的责任在于调用者。

我们需要解决一个轻微的问题。之前，当我们处理`log`函数内部的消息时，我们能够向消息末尾添加换行符。我们仍然希望日志消息在日志文件中单独一行显示。但我们也不希望调用者总是需要记住添加换行符。

我们的目标之一是使这个日志库易于使用。要求每次调用`log`时在末尾包含换行符使得使用变得繁琐。所以，一个简单的临时解决方案是让`log`函数在每条日志消息的开始处添加一个换行符。

这有一个奇怪的副作用。日志文件的第一行将是空的。最后一行将没有换行符。但整体效果仍然是每个日志消息都会出现在自己的行上。这正是我们想要保持的行为。这个临时解决方案将在下一章中得到适当的修复。

`Log.h` 中 `log` 函数的改变也很简单，看起来像这样：

```cpp
inline std::fstream log ()
{
    auto const now = std::chrono::system_clock::now();
    std::time_t const tmNow =          std::chrono::system_clock::to_time_t(now);
    auto const ms = duration_cast<std::chrono::milliseconds>(
        now.time_since_epoch()) % 1000;
    std::fstream logFile("application.log", std::ios::app);
    logFile << std::endl
        << std::put_time(std::gmtime(&tmNow),         "%Y-%m-%dT%H:%M:%S.")
        << std::setw(3) << std::setfill('0')         << std::to_string(ms.count())
        << " ";
    return logFile;
}
```

与返回 `void` 不同，这个新版本返回 `std::fstream`。你可以看到首先被发送到日志文件流的是 `std::endl`，这确保了每个日志消息在日志文件中都有其自己的行。返回 `std::fstream` 的整个想法是一个临时解决方案，将在下一章中得到增强。

然后，在发送时间戳之后，函数返回流而不是发送消息。这使得调用者可以将所需的任何值发送到流中。在时间戳之后添加一个空格，以确保时间戳不会遇到调用者通过流传输的额外文本。

关于返回类型的一个有趣的问题是函数返回后 fstream 会发生什么。我们在 `log` 函数内部构造 fstream，然后通过值返回流。在 C++11 之前，通过值返回流是不可能的，我们之所以能够这样做，是因为我们现在有了将流从 `log` 函数中 *移动* 出来的能力。代码不需要做任何特殊的事情来启用移动。它只是与现代 C++ 一起工作。我们将在下一章中再次遇到移动问题，那时我们将用新的换行符修复临时解决方案。

遵循 TDD（测试驱动开发）来设计软件鼓励工作解决方案得到增强，而不是一开始就试图设计出一个完美的设计。我可以从经验中告诉你，事先考虑每一个小设计问题是不可行的。需要沿途进行调整，这往往会使一个完美的设计变得不如最初。我喜欢 TDD，因为设计从最终用户的角度开始，增强功能围绕我们的换行问题等小问题进行。最终结果是比最初更好的。遵循 TDD 让设计保持对最重要的事物的真实，同时在需要的地方保持灵活性。

我们仍然需要考虑一旦流离开 `log` 函数后会发生什么。测试代码没有将流存储在局部变量中，因此它将被销毁。但它只会在创建它的表达式的末尾被销毁。让我们假设我们按照以下方式调用 `log`：

```cpp
    MereMemo::log() << message << " with more text.";
```

从 `log` 函数返回的 `std::fstream` 在行尾的分号之前保持有效。流的生存期需要保持有效，这样我们就可以继续使用它来发送消息和附加文本。

几次构建和运行项目显示每次只有一个测试通过。日志文件包含了额外的文本，如下面的截图所示：

```cpp
$ cat application.log 
2022-06-13T05:01:56.308 simple 5586 with more text.
2022-06-13T05:02:02.281 simple 2381 with more text.
2022-06-13T05:02:05.621 simple 8099 with more text.
```

你可以看到文件开头的空行。但每个消息仍然单独一行，调用者现在可以记录其他信息。让我们创建一个新的测试来确保这一点。新的测试将类似于以下示例：

```cpp
TEST("Complicated message can be logged")
{
    std::string message = "complicated ";
    message += Util::randomString();
    MereMemo::log() << message
        << " double=" << 3.14
        << " quoted=" << std::quoted("in quotes");
    bool result = Util::isTextInFile(message,     "application.log");
    CONFIRM_TRUE(result);
}
```

这个新的测试直接记录了双精度字面值，甚至记录了调用`std::quoted`函数的结果。`quoted`函数只是在其提供的文本周围加上引号。即使“引号中的文本”看起来已经有了引号，也要记住这些标记是为了让编译器知道文本的开始和结束。源代码中的引号实际上不是文本的一部分，就像其他字符串字面值（如“double=”）的引号不会出现在日志消息中一样。但因为我们调用了`std::quoted`，所以输出中会有引号。

`std::quoted`函数的有趣之处在于，其返回值实际上只能用于发送到流中。其实际类型由 C++标准未定义，唯一的要求是它可以发送到流。

构建和运行项目显示这两个测试都通过了。以下示例展示了在删除`application.log`文件并运行几次测试后，该文件看起来像什么：

```cpp
$ cat application.log 
2022-06-13T05:47:36.973 simple 6706 with more text.
2022-06-13T05:47:36.975 complicated 1025 double=3.14 quoted="in quotes"
2022-06-13T05:47:39.489 simple 4411 with more text.
2022-06-13T05:47:39.495 complicated 9375 double=3.14 quoted="in quotes"
```

现在我们有了创建带时间戳的日志消息、将它们保存到日志文件，并将我们想要发送到每个日志消息中的任何数据的能力。对于已经熟悉向`std::cout`等流发送信息的 C++开发者来说，这种用法简单直观。

# 摘要

在本章中，你学习了如何使用单元测试库通过 TDD（测试驱动开发）开始一个新的项目。尽管我们只有两个测试，但我们已经拥有了一个易于使用且任何 C++开发者都能理解的日志库。

这两个测试将有助于确保我们在后续章节扩展日志库时不会破坏本章开始时启动的简单设计。特别是下一章将扩展日志库以更好地满足我们目标用户（微服务开发者）的需求。我们将添加标记日志消息的能力，然后使用这些标记启用强大的过滤选项。
