

# 所需测试声明

如果我们要有一个**测试驱动开发**（**TDD**）的过程，我们需要测试。本章将解释测试将做什么，我们将如何编写它们，以及我们将如何使用它们。

我们将从一开始慢慢构建一个完整的库来帮助管理和运行测试，并且我们将使用测试库来帮助构建自己。最初，将只有一个测试。接下来的章节将添加更多功能并扩展测试库。

从最终目标开始考虑，我们首先会思考创建和使用测试会是什么样的。编写测试是 TDD 的一个重要部分，所以在我们能够创建和运行测试之前，考虑测试是有意义的。

TDD（测试驱动开发）是一个过程，它将帮助你设计更好的代码，然后在不破坏你已验证为按预期工作的部分的情况下修改你的代码。为了使这个过程有效，我们需要能够编写测试。本章将探讨测试能为我们做什么，以及我们如何编写它们。

本章将涵盖以下主要主题：

+   我们希望测试为我们做什么？

+   测试应该是什么样子？

+   测试需要哪些信息？

+   我们如何使用 C++编写测试？

+   第一份测试将如何被使用？

# 技术要求

本章中使用的所有代码都是基于标准的 C++，它构建在任何现代 C++ 17 或更高版本的编译器和标准库之上。未来的章节将需要 C++ 20，但到目前为止，只需要 C++ 17。数字指的是标准被批准和最终确定的那一年，因此 C++ 17 于 2017 年发布，C++ 20 于 2020 年发布。每次发布都会为语言添加新的功能和能力。

我们将工作的代码从一个空的控制台项目开始，该项目有一个名为`main.cpp`的单个源文件。

如果你的开发环境在启动新的命令行或控制台项目时给你一个“Hello, world！”项目，你可以删除`main.cpp`文件的内容，因为本章将从空文件开始从头开始。

你可以在以下 GitHub 仓库找到本章的所有代码：[`github.com/PacktPublishing/Test-Driven-Development-with-CPP`](https://github.com/PacktPublishing/Test-Driven-Development-with-CPP)。

# 我们希望测试为我们做什么？

在我们开始学习测试驱动开发、它是什么以及涉及的过程之前，让我们退一步思考我们想要什么。在不了解测试的所有细节的情况下，让我们问问自己我们的测试应该是什么样子。

我喜欢尽可能地将编程概念与日常经验联系起来。也许你有一个解决问题的想法，你注意到并想看看你的想法是否可行。如果你想在向世界宣布之前测试这个想法，你会怎么做？

你可能无法一次性测试你想法的所有方面。这又意味着什么呢？你可能会先考虑你想法的一些小部分。这些部分应该更容易测试，并且有助于阐明你的想法，让你思考其他可以测试的事情。

因此，让我们专注于简单地测试想法的小部分，无论它是什么。你想要设置好一切，然后开始一些行动或步骤，这些行动或步骤应该告诉你每个部分是否工作。一些测试可能工作得很好，而一些测试可能会让你重新思考你的想法。这肯定比在没有知道它是否可行的情况下跳入整个想法要好。

为了将这个概念应用到实际情境中，假设你有一个想法要制造一把更好的扫帚。这是一个模糊的想法，难以想象。然而，假设你在最近打扫地板时，注意到你的手臂酸痛，并认为肯定有更好的方法。思考实际问题是一个将模糊想法转化为更有实质性意义的好方法。

现在，你可能会开始考虑测试不同形状的扫帚柄、不同的握把或不同的扫地动作。这些都是可以测试的想法的小部分。你可以将每个握把或动作转换成一系列步骤或行动，以测试该部分，直到找到最佳的工作方式。

好吧，在编程中，一系列步骤可以是一个**函数**。现在这个函数做什么并不重要。我们可以将每个测试想象成一个函数。如果你可以调用一个函数并且它给出了预期的结果，那么你可以说测试通过了。我们将在整本书中基于这个想法进行构建。

既然我们已经决定使用函数来进行测试，它应该是什么样子呢？毕竟，编写函数有很多种方式。

# 测试应该是什么样子？

编写测试应该和声明和编写函数一样简单，我们应该能够进一步简化事情。一个普通函数可以有任何你想要的返回类型，一个名称，一组参数，以及一段代码体。

函数也是你编写的东西，以便其他代码可以调用它。这段代码应该知道函数做什么，它返回什么，以及需要传递什么参数。我们将保持测试函数的简单性，现在只关注名称。

我们希望每个测试函数都有自己的名称。否则，我们如何能够跟踪我们最终将要编写的所有各种测试呢？至于返回类型，我们还没有确定实际需求，所以我们将使用`void`。

你将在*第三章*《TDD 过程》中了解更多关于这个流程。在使用 TDD 时，不要急于求成。只做当时需要做的事情。就像`void`返回类型一样，我们也不会有任何参数。

这可能看起来太简单了，但这是一个好的开始。到目前为止，测试不过是一个函数，它不返回任何内容，也不接受任何参数。它有一个名称来识别它，并将包含运行测试所需的任何代码。

由于我们将开始使用 TDD 来帮助设计一个简单的测试库，我们的第一个测试应该确保我们可以创建一个测试。这是一个简单的开始，它定义了一个测试函数并从`main`中调用它。所有这些都在一个名为`main.cpp`的单个文件中：

```cpp
#include <iostream>
void testCanBeCreated ()
{
    std::cout << "testCanBeCreated" << std::endl;
}
int main ()
{
    testCanBeCreated();
    return 0;
}
```

你可能会想，这根本不是测试，而只是一个打印自己名称的函数，你是对的。我们将从头开始，以敏捷的方式构建它，只使用我们目前拥有的资源。现在，我们还没有可用的测试库。

然而，这已经开始类似于我们最终想要的样子了。我们希望测试就像编写一个函数一样。如果你现在构建并运行项目，输出应该是预期的：

```cpp
testCanBeCreated
Program ended with exit code: 0
```

这显示了运行程序时的输出。它显示了函数的名称。第二行的文本实际上来自我的开发工具，显示了程序的退出代码。退出代码是`main`函数返回的值。

这是一个开始，但可以改进。下一节将探讨测试需要哪些信息，例如其名称。

# 测试需要哪些信息？

当前的测试函数实际上并不知道自己的名称。我们希望测试有一个名称以便于识别，但这个名称真的需要是函数的名称吗？如果这个名称可以作为数据提供，以便在测试体内部不硬编码名称的情况下显示，那就更好了。

同样，当前的测试函数对成功或失败没有任何概念。我们故意忽略了测试结果，直到现在，但让我们考虑一下。一个测试函数返回状态是否足够？也许它需要一个`bool`返回类型，其中`true`表示成功，而`false`表示测试失败。

这可能有点过于简单化了。当然，现在可能足够了，但如果测试失败，了解失败的原因可能就很重要了。仅仅返回`bool`类型在以后可能就不够了。我们不需要设计整个解决方案，只需要弄清楚要做什么才能满足预期的需求。

既然我们已经知道我们需要一些数据来保存测试名称，那么我们现在是否可以在相同的位置添加简单的`bool`结果数据呢？这样我们可以保持测试函数的返回类型为`void`，并为以后更高级的解决方案留出空间。

让我们将测试函数改为`operator()`，如下所示：

```cpp
#include <iostream>
#include <string_view>
class Test
{
public:
    Test (std::string_view name)
    : mName(name), mResult(true)
    {}
    void operator () ()
    {
        std::cout << mName << std::endl;
    }
private:
    std::string mName;
    bool mResult;
};
Test test("testCanBeCreated");
int main ()
{
    test();
    return 0;
}
```

这个问题的最大问题是，我们不再有简单的方式来编写一个测试，就像它是一个简单的函数一样。通过提供`operator ()`，或者称为*函数调用操作符*，我们创建了一个可以让我们在`main`函数内部将类当作函数来调用的函数对象。然而，这需要编写更多的代码。它解决了测试名称的问题，为我们提供了一个简单的解决方案，这个方案可以稍后扩展，并且还解决了之前不明显的问题。

在我们之前在`main`函数中调用测试函数时，我们必须通过函数名来调用它。这是代码中调用函数的方式，对吧？这种新的设计通过创建一个名为`test`的`Test`函数对象的实例来消除这种耦合。现在，`main`不再关心测试名称。它只引用函数对象的实例。测试名称现在在代码中唯一出现的地方是在创建函数对象实例时。

我们可以通过使用*宏*来解决编写测试时所需的所有额外代码问题。宏在 C++中不再像以前那样需要，有些人甚至认为应该从语言中完全移除它们。它们仍然有一些好的用途，将代码*封装*到宏中就是其中之一。

我们最终会将宏定义放入一个单独的头文件中，这将成为测试库。我们想要做的是在宏中将所有函数对象代码封装起来，但将实际测试函数体的实现留给像正常函数一样编写。

首先，我们将对测试函数体的实现进行简单的修改，将其移出类定义之外，如下所示。需要移出的方法是函数调用操作符：

```cpp
class Test
{
public:
    Test (std::string_view name)
    : mName(name), mResult(true)
    {}
    void operator () ();
private:
    std::string mName;
    bool mResult;
};
Test test("testCanBeCreated");
void Test::operator () ()
{
    std::cout << mName << std::endl;
}
```

然后，类定义、实例声明和函数调用操作符的第一行可以被转换成一个宏。将以下代码与之前的代码进行比较，看看`Test`类是如何被转换成`TEST`宏的。仅凭这个宏本身是无法编译的，因为它将函数调用操作符留在了未完成的状态。这正是我们想要的，因为它允许代码像函数签名声明一样使用宏，并通过提供花括号和方法的实现来完成它：

```cpp
#define TEST class Test \
{ \
public: \
    Test (std::string_view name) \
    : mName(name), mResult(true) \
    {} \
    void operator () (); \
private: \
    std::string mName; \
    bool mResult; \
}; \
Test test("testCanBeCreated"); \
void Test::operator () ()
TEST
{
    std::cout << mName << std::endl;
}
```

因为宏定义跨越多行，除了最后一行之外，每一行都需要以反斜杠结尾。由于删除了空行，这个宏变得更加紧凑。这是一个个人选择，如果你想的话可以保留空行。但是，空行仍然需要反斜杠，这违背了保留空行的目的。

代码使用`TEST`宏和未完成的函数调用操作符，就像函数定义一样，然后通过提供花括号和方法实现来完成代码。

我们正在取得进展！可能很难看到，因为所有内容都在一个文件中。让我们通过创建一个名为 `Test.h` 的新文件并将宏定义移动到新文件来解决这个问题，如下所示：

```cpp
#ifndef TEST_H
#define TEST_H
#include <string_view>
#define TEST class Test \
{ \
public: \
    Test (std::string_view name) \
    : mName(name), mResult(true) \
    {} \
    void operator () (); \
private: \
    std::string mName; \
    bool mResult; \
}; \
Test test("testCanBeCreated"); \
void Test::operator () ()
#endif // TEST_H
```

现在，我们可以回到 `main.cpp` 中的简单代码，如下所示的下一段代码所示。我们只需要包含 `Test.h` 并使用宏：

```cpp
#include "Test.h"
#include <iostream>
TEST
{
    std::cout << mName << std::endl;
}
int main ()
{
    test();
    return 0;
}
```

现在我们有了一些开始看起来像我们最初开始时的简单函数，但 `TEST` 宏内部隐藏了大量的代码，使其看起来简单。

在下一节中，我们将解决 `main` 直接调用 `test()` 的需求。函数名 `test` 是一个不应该在宏之外知道细节，我们绝对不需要直接调用一个测试来运行它，无论它叫什么名字。

# 我们如何使用 C++ 编写测试？

直接调用测试可能现在看起来不是什么大问题，因为我们只有一个测试。然而，随着测试数量的增加，需要从 `main` 中逐个调用每个测试的需求将导致问题。你真的希望每次添加或删除测试时都要修改 `main` 函数吗？

C++ 语言没有添加额外自定义信息到函数或类的方法，这些信息可以用来识别所有测试。因此，没有方法可以遍历所有代码，自动找到所有测试并运行它们。

C++ 的一个原则是避免添加你可能不需要的语言特性，特别是那些在你不知情的情况下影响你代码的语言特性。其他语言可能允许你做其他事情，例如添加自定义属性，你可以使用这些属性来识别测试。C++ 定义了标准属性，这些属性旨在帮助编译器优化代码执行或改进代码的编译。标准的 C++ 属性不是我们可以用来识别测试的东西，而自定义属性将违反无需特性的原则。我喜欢 C++ 的这一点，即使这意味着我们必须更努力地找出要运行的测试。

我们需要做的只是让每个测试能够识别自己。这与编写试图找到测试的代码不同。找到测试需要以某种方式标记它们，例如使用属性，以便它们突出显示，但在 C++ 中这是不可能的。我们不是去*找到它们*，而是可以使用每个测试函数的构造函数，使它们*注册自己*。每个测试的构造函数将通过将指向自己的指针推送到集合中，将自己添加到注册表中。

一旦所有测试都通过添加到集合中进行了注册，我们就可以遍历集合并运行它们。我们已经简化了测试，以便它们都可以以相同的方式运行。

我们需要注意的一个复杂问题是。在 `TEST` 宏中创建的测试实例是全局变量，并且可以分布在许多不同的源文件中。目前，我们在单个 `main.cpp` 源文件中声明了一个测试。我们需要确保在开始尝试将测试添加到集合之前，将最终包含所有已注册测试的集合设置好并准备好。我们将使用一个函数来帮助协调设置。这是 `getTests` 函数，如下所示。`getTests` 的工作方式并不明显，将在下一部分代码之后进行更详细的描述。

现在也是开始考虑 `MereTDD` 的好时机。

这是 `Test.h` 文件的第一部分，其中添加了新的命名空间和注册代码。我们还应该更新 `include` 守卫，使其更加具体，例如 `MERETDD_TEST_H`，如下所示：

```cpp
#ifndef MERETDD_TEST_H
#define MERETDD_TEST_H
#include <string_view>
#include <vector>
namespace MereTDD
{
class TestInterface
{
public:
    virtual ~TestInterface () = default;
    virtual void run () = 0;
};
std::vector<TestInterface *> & getTests ()
{
    static std::vector<TestInterface *> tests;
    return tests;
}
} // namespace MereTDD
```

在命名空间内部，声明了一个新的 `TestInterface` 类，其中包含一个 `run` 方法。我决定放弃使用函数式对象，转而采用这种新设计，因为当我们需要稍后实际运行测试时，有一个名为 `run` 的方法看起来更直观、更容易理解。

测试集合存储在一个 `TestInterface` 指针的 *vector* 中。这是一个使用原始指针的好地方，因为没有隐含的所有权。集合将不会负责删除这些指针。向量在 `getTests` 函数内部声明为 *静态* 变量。这是为了确保向量得到适当的初始化，即使它首先是从另一个 `.cpp` 源文件编译单元访问的。

C++ 语言确保在 `main` 开始之前初始化 *全局变量*。这意味着我们在 `test` 实例构造函数中有代码在 `main` 开始之前运行。当我们有多个 `.cpp` 文件时，确保集合首先初始化变得很重要。如果集合是一个普通的全局变量，并且直接从另一个编译单元访问，那么可能是在测试尝试将自己推送到集合时，集合尚未准备好。尽管如此，通过通过 `getTests` 函数，我们避免了准备就绪问题，因为编译器将确保在 *函数第一次被调用时* 初始化静态向量。

我们需要在宏中使用时，将类和函数的引用限制在命名空间内。以下是 `Test.h` 的最后一部分，其中对宏进行了修改以使用命名空间：

```cpp
#define TEST \
class Test : public MereTDD::TestInterface \
{ \
public: \
    Test (std::string_view name) \
    : mName(name), mResult(true) \
    { \
        MereTDD::getTests().push_back(this); \
    } \
    void run () override; \
private: \
    std::string mName; \
    bool mResult; \
}; \
Test test("testCanBeCreated"); \
void Test::run ()
#endif // MERETDD_TEST_H
```

`Test` 构造函数现在通过调用 `getTests` 并将指向自身的指针推回到它获得的向量中来注册自己。现在编译的是哪个 `.cpp` 文件并不重要。一旦 `getTests` 返回向量，测试集合将被完全初始化。

`TEST` 宏仍然位于命名空间之外，因为它在这里不会被编译。它只有在宏被使用时才会被插入到其他代码中。这就是为什么在宏内部，现在需要使用 `MereTDD` 命名空间来限定 `TestInterface` 和 `getTests` 调用的原因。

在 `main.cpp` 中，唯一的变化是如何调用测试。我们不再直接引用测试实例，而是遍历所有测试并对每个测试调用 `run`。这就是我决定使用名为 `run` 的方法而不是函数调用操作符的原因：

```cpp
int main ()
{
    for (auto * test: MereTDD::getTests())
    {
        test->run();
    }
    return 0;
}
```

我们可以进一步简化这一点。`main` 中的代码似乎需要了解太多关于测试如何运行的信息。让我们创建一个名为 `runTests` 的新函数来包含 `for` 循环。我们可能以后需要增强 `for` 循环，这似乎应该是测试库内部的。以下是 `main` 现在应该看起来像什么：

```cpp
int main ()
{
    MereTDD::runTests();
    return 0;
}
```

我们可以通过在命名空间内添加 `runTests` 函数来启用此更改，如下所示：

```cpp
namespace MereTDD
{
class TestInterface
{
public:
    virtual ~TestInterface () = default;
    virtual void run () = 0;
};
std::vector<TestInterface *> & getTests ()
{
    static std::vector<TestInterface *> tests;
    return tests;
}
void runTests ()
{
    for (auto * test: getTests())
    {
        test->run();
    }
}
} // namespace MereTDD
```

在所有这些更改之后，我们有一个简化的 `main` 函数，它只是调用测试库来运行所有测试。它对运行了哪些测试或如何运行一无所知。尽管我们仍然只有一个测试，但我们正在创建一个能够支持多个测试的坚实设计。

下一节将解释如何通过查看第一个测试来使用测试。

# 首个测试将如何被使用？

到目前为止，我们有一个在运行时输出其名称的单个测试，并且这个测试是在 `main.cpp` 内部声明的。这不是你未来想要声明测试的方式。我提到了拥有多个 `.cpp` 文件，每个文件中都有多个测试。我们还没有准备好这样做，但我们至少可以将我们拥有的单个测试移动到它自己的 `.cpp` 文件中。

在多个 `.cpp` 文件中声明多个测试的整个目的是为了帮助你组织测试。将它们组合成有意义的类别。我们稍后会讨论多个测试。现在，我们单次测试的目的是什么？

这本应表明可以创建测试。我们可能对测试创建的其他方面也感兴趣。因此，创建一个专注于测试创建的 `.cpp` 文件可能是有意义的。在这个 `.cpp` 文件中，将包含所有与 *创建测试的不同方式* 相关的测试。

你可以按照自己的意愿组织测试。如果你正在处理一个拥有自己源文件集的项目，那么围绕源文件组织测试可能是有意义的。因此，你将会有一个包含许多测试的测试 `.cpp` 文件，这些测试都是为了测试你实际项目中的 `.cpp` 文件相关的所有内容。如果你的项目文件已经组织得很好，这样做是有意义的。

或者，你可能采取一种更函数式的方法来组织你的测试。由于我们只有一个名为 `Test.h` 的头文件需要测试，而不是也创建一个包含所有测试的单个 `.cpp` 文件，让我们采取一种函数式方法，根据测试的目的来分割测试。

让我们在项目中添加一个新的`.cpp`文件，命名为`Creation.cpp`，并将迄今为止的单个测试移动到新文件中。同时，让我们思考一下我们将来如何使用测试库。

我们正在构建的并不是一个会被编译并链接到其他项目的库。它只是一个名为`Test.h`的单个头文件，其他项目可以包含它。它仍然是一个库，只是它会在其他项目旁边编译。

我们甚至可以开始以这种方式处理我们现在的测试。在项目结构中，我们目前有`Test.h`和`main.cpp`。`main.cpp`文件类似于旨在测试`Test.h`包含文件的测试项目。让我们重新组织项目结构，使得`main.cpp`和新的`Creation.cpp`文件都在一个名为`tests`的文件夹中。这些将形成测试可执行文件的基础，该可执行文件将执行所有测试以测试`Test.h`。换句话说，我们正在将我们拥有的控制台项目转变为一个测试项目，该测试项目旨在测试测试库。测试库不是一个独立的项目，因为它只是一个作为其他项目一部分被包含的单个头文件。

在以后的项目中，你也可以做同样的事情。你将有一个包含所有源文件的主要项目。你还将有一个名为`tests`的子文件夹中的另一个测试项目，其中包含自己的`main.cpp`和所有测试文件。你的测试项目将包含测试库中的`Test.h`，但它不会尝试像我们现在这样测试测试库。它将专注于在主要项目文件夹中测试自己的项目。一旦我们将测试库调整到适合使用以创建不同项目的状态，你将看到这一切是如何工作的。在第二部分，我们将创建一个日志库，名为`Logging Library`。日志库将有一个名为`tests`的子文件夹，正如我刚才描述的那样。

回到我们现在的情况，让我们重新组织测试库的整体项目结构。你可以创建一个`tests`文件夹，并将`main.cpp`移动到其中。确保将新的`Creation.cpp`文件放入`tests`文件夹。项目结构应该看起来像这样：

```cpp
MereTDD project root folder
    Test.h
    tests folder
        main.cpp
        Creation.cpp
```

`main.cpp`文件可以通过移除测试并仅保留`main`来简化如下：

```cpp
#include "../Test.h"
int main ()
{
    MereTDD::runTests();
    return 0;
}
```

现在，新的`Creation.cpp`文件只包含迄今为止的单个测试，如下所示：

```cpp
#include "../Test.h"
#include <iostream>
TEST
{
    std::cout << mName << std::endl;
}
```

然而，现在以这种方式构建项目会导致链接错误，因为我们同时在`main.cpp`和`Creation.cpp`编译单元中包含`Test.h`。结果，我们有两个方法会产生重复的符号。为了删除重复的符号，我们需要将`getTests`和`runTests`都声明为内联，如下所示：

```cpp
inline std::vector<TestInterface *> & getTests ()
{
    static std::vector<TestInterface *> tests;
    return tests;
}
inline void runTests ()
{
    for (auto * test: getTests())
    {
        test->run();
    }
}
```

现在，一切又重新构建并运行，我们得到了之前相同的结果。输出显示了迄今为止的单个测试名称：

```cpp
testCanBeCreated
Program ended with exit code: 0
```

输出与之前保持不变。我们没有添加更多测试或更改当前测试的功能。我们改变了测试的注册和运行方式，并对项目结构进行了重组。

# 摘要

本章介绍了测试库，它由一个名为 `Test.h` 的单个头文件组成。它还向我们展示了如何创建一个测试项目，这是一个控制台应用程序，将用于测试测试库。

我们已经看到，它如何从简单的函数发展成为一个知道如何注册和运行测试的测试库。它还没有准备好。在测试库可以在 TDD 过程中使用来帮助您设计和测试自己的项目之前，我们还有很长的路要走。

通过观察测试库的发展，您将了解如何在您的项目中使用它。在下一章中，您将了解添加多个测试的挑战。我们至今只有一个测试是有原因的。下一章将涵盖启用多个测试和报告测试结果的内容。
