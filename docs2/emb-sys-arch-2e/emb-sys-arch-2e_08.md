# 8

# 电源管理和节能

能效一直是微控制器市场的主要因素之一。自 2000 年代初以来，专为极低功耗设计的信号处理 16 位 RISC 微控制器，如 MSP430，一直引领着嵌入式系统中超低功耗优化架构的发展。

在过去几年中，功能丰富且能够运行实时操作系统的更先进的 32 位 RISC 微控制器，其尺寸和功耗都得到了降低，并进入了低功耗和超低功耗领域。依赖能量收集技术的电池供电系统和设备在许多行业中变得越来越普遍。现在，许多连接平台提供低功耗无线通信，因此越来越多的物联网系统在设计时包括了低功耗和超低功耗的特性。

根据架构，微控制器提供不同的策略来降低运行时的功耗，并在激活时实现消耗极低能量的低功耗状态。

降低嵌入式系统的能耗通常是一个复杂的过程。实际上，如果未正确停用，板上的所有设备都可能消耗电力。生成高频时钟是最昂贵的操作之一，因此 CPU 和总线时钟只有在使用时才应启用。

研究理想的节能策略取决于在性能和节能之间可以做出的妥协。专为超低功耗应用设计的微控制器能够降低 CPU 频率，甚至达到休眠状态的不同变体，在这种状态下，所有时钟都停止，外部外围设备关闭以实现最大程度的节能。

通过适当的能量分析技术，并实施超低功耗策略，电池供电设备可以在需要更换之前运行数年。使用太阳能板、热转换设备或从周围环境获取能量的其他形式，只要外部条件允许，经过良好分析的嵌入式系统可以无限期运行。

在非常高速运行的先进微处理器通常不是设计用来实施有效的功耗优化，这也是为什么像 Cortex-M 这样的小型低功耗微控制器在所有那些要求小功耗的嵌入式系统中如此受欢迎。

在本章中，我们将强调在设计低功耗和超低功耗嵌入式系统时的一些关键实践。以 Cortex-M 微控制器的低功耗扩展为例，展示了在真实目标上实现低功耗优化的实际应用。本章分为三个部分：

+   系统配置

+   低功耗工作模式

+   测量功耗

+   设计低功耗嵌入式应用

到本章结束时，你将了解如何管理微控制器和外设的不同低功耗配置。

# 技术要求

本章的代码文件可在 GitHub 上找到，网址为[`github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter8`](https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter8)。

# 系统配置

一个在其规范中包含功耗约束的系统必须设计成在所有方面满足要求，包括硬件、软件和机械设计。组件和外设的选择必须考虑它们的能耗。外部外设通常是功耗最大的组件，因此当它们未被使用时，必须由微控制器中断它们的电源。

本节将描述有关外设配置、系统时钟设置和电压控制的最佳实践，以及它们对功耗的影响。

## 硬件设计

在低功耗嵌入式系统中，硬件设计必须包括使用 GPIO 引脚开启或关闭外设的可能性。这最好使用一个通常为低电平的线路来完成，以便在 GPIO 未被微控制器驱动时，可以使用无源元件将其拉低。MOSFETs 通常用于控制外部外设的供电，使用 GPIO 信号来控制栅极电压。

即使通过中断外设的电源线关闭外设，也可能有较小的电流通过连接到它们的其他信号泄漏，例如串行总线或其他控制信号。硬件设计必须在早期原型阶段能够检测和识别这些泄漏，以最大限度地减少由此造成的能量损失。

此外，如果省电策略包括将微处理器置于深度睡眠操作模式的可能性，输入信号的逻辑必须进行调整，以提供正确的唤醒事件来恢复正常操作。在睡眠模式下可能不会驱动的信号必须保持一个已知的逻辑值，并使用无源元件强制执行。

## 时钟管理

未使用的内部外围设备和接口也必须保持关闭状态。如果平台支持，时钟门控通常是用于选择性地控制系统上每个外围设备和接口的时钟源的一种机制。在系统时钟门控配置中启用的每条时钟线都会增加功耗。此外，从慢速振荡器生成 CPU 时钟所应用的缩放因子越高，PLL 所需的能量就越高。PLL 是系统中最耗能的组件之一，CPU 的功耗也与其时钟频率成正比。许多 CPU 被设计为以较低的时钟速度运行，提供性能和节能之间的一系列可能权衡。因此，PLL 通常可以在运行时重新配置以适应不同的配置文件。然而，对系统时钟的任何更改都需要重新配置当前所有正在使用的计时器和外围设备的所有时钟分频器。

在参考平台上，我们可以在运行时重新配置 CPU 频率，以便在系统不需要计算性能时节省大量电力。为此，`system.c`中的函数已被修改，允许选择两种不同的运行频率。在性能模式下，系统以最大频率 168 MHz 运行。如果`powersave`标志参数不为零，则配置时钟以 48 MHz 运行，以实现更节能的场景：

```cpp
void clock_pll_on(int powersave)
{
  uint32_t reg32, plln, pllm, pllq,
      pllp, pllr, hpre, ppre1, ppre2,
      flash_waitstates;
  if (powersave) {
    cpu_freq = 48000000;
    pllm = 8;
    plln = 96;
    pllp = 2;
    pllq = 2;
    pllr = 0;
    hpre = RCC_PRESCALER_DIV_NONE;
    ppre1 = RCC_PRESCALER_DIV_4;
    ppre2 = RCC_PRESCALER_DIV_2;
    flash_waitstates = 5;
  } else {
    cpu_freq = 168000000;
    pllm = 8;
    plln = 336;
    pllp = 2;
    pllq = 7;
    pllr = 0;
    hpre = RCC_PRESCALER_DIV_NONE;
    ppre1 = RCC_PRESCALER_DIV_4;
    ppre2 = RCC_PRESCALER_DIV_2;
    flash_waitstates = 3;
  }
```

闪存操作的等待状态数量也在此处进行了更改，因为根据 STM32F407 的文档，在 48 MHz 时，闪存只需要三个等待状态：

```cpp
 flash_set_waitstates(flash_waitstates);
```

设置系统时钟的步骤是常规的。首先，启用 HSI 并将其选为临时时钟源。之后，启用 8 MHz 外部振荡器，并准备好为 PLL 供电：

```cpp
 RCC_CR |= RCC_CR_HSION;
 DMB();
 while ((RCC_CR & RCC_CR_HSIRDY) == 0) {};
 reg32 = RCC_CFGR;
 reg32 &= ~((1 << 1) | (1 << 0));
 RCC_CFGR = (reg32 | RCC_CFGR_SW_HSI);
 DMB();
 RCC_CR |= RCC_CR_HSEON;
 DMB();
 while ((RCC_CR & RCC_CR_HSERDY) == 0)
    ;
```

为所选模式设置的时钟分频器和乘数参数设置在 PLL 配置寄存器中，并启用 PLL：

```cpp
 reg32 = RCC_CFGR;
 reg32 &= ~(0xF0);
 RCC_CFGR = (reg32 | (hpre << 4));
 DMB();
 reg32 = RCC_CFGR;
 reg32 &= ~(0x1C00);
 RCC_CFGR = (reg32 | (ppre1 << 10));
 DMB();
 reg32 = RCC_CFGR;
 reg32 &= ~(0x07 << 13);
 RCC_CFGR = (reg32 | (ppre2 << 13));
 DMB();
 reg32 = RCC_PLLCFGR;
 reg32 &= ~(PLL_FULL_MASK);
 RCC_PLLCFGR = reg32 | RCC_PLLCFGR_PLLSRC | pllm |
 (plln << 6) | (((pllp >> 1) - 1) << 16) | (pllq << 24);
}
```

更改 CPU 和系统时钟意味着必须重新配置使用这些时钟的所有外围设备。如果计时器正在运行，或者任何使用时钟作为参考的设备正在由应用程序使用，则必须根据时钟速度更新相应地调整用于提供时间参考的预分频寄存器。

以较低的速度运行系统提供了其他好处，例如，可以减少访问闪存所需的等待状态数量，并启用仅在系统未以全速运行时才可用的额外低功耗功能。

嵌入式平台通常包括低频时钟发生器，在 kHz 范围内，可以用作看门狗和**实时时钟**（**RTCs**）等时间保持设备的数据源。在低功耗操作模式下，外部或内部振荡器可以是活动的，并用于实现唤醒策略。

## 电压控制

微控制器的运行电压范围相对较宽。然而，供电较低的电压使得无法以全速运行 CPU，并且由于硬件的物理特性，闪存可能需要额外的等待状态。尽管如此，低电压容限的逻辑在某些情况下可以提高系统的整体经济性。

内部调节器通常可以配置为产生较低的核心信号电压，以便在 CPU 未以最大频率运行时在功耗和性能之间达到妥协。

常常被忽视的一个重要方面是数字输入逻辑中施密特触发器的功耗。当 GPIO 配置为数字输入，但没有通过外部无源组件强制到已知逻辑状态时，它们可能会在环境中的电磁场的影响下悬浮在平均值附近。这会导致输入信号被触发，从而在每个逻辑状态变化时损失少量能量。

# 低功耗操作模式

微控制器可以在不同的电源模式下执行，从全性能切换到完全休眠。正确理解微控制器的低功耗模式对于设计具有改进能源配置的系统是基本的。每个架构都提供特定的电源配置，其中 CPU 或其他总线和外设被禁用，以及系统软件用于进入和退出低功耗模式的适当机制。

在基于 ARM 的微控制器中，用于不同低功耗模式的术语可以总结如下：

+   **正常操作模式**：通过时钟门控选择活动组件，时钟以期望的频率运行。

+   **睡眠模式**：CPU 时钟暂时暂停，但所有外设保持与正常模式相同的功能。只要 CPU 不执行，在这种模式下可以节省明显的、即使是很小的电量。在接收到中断请求后可以恢复执行。这种模式也被一些芯片制造商称为*等待模式*。

+   **停止模式**：CPU 时钟和总线时钟被禁用。所有由微控制器供电的外设都关闭。内部 RAM 和 CPU 寄存器保留存储的值，因为主电压调节器仍然开启。功耗持续下降，但仍然可以通过外部中断或事件唤醒并恢复执行。这种模式通常也被称为深度睡眠模式，尽管实际上它是两种深度睡眠模式中的一种。

+   **待机模式**：所有电压稳压器都关闭，RAM 和寄存器的内容丢失。在待机阶段可能需要几微瓦的少量电力来保持备用电路的运行。唤醒仅在少数特定条件下才可能，例如外部供电的 RTC 或硬件预定义的唤醒事件引脚。当系统从待机唤醒时，将遵循正常的引导程序，并从复位服务例程恢复执行。

ARMv7 微代码提供了两条指令来进入低功耗操作模式：

+   **等待中断**（**WFI**）

+   **等待事件**（**WFE**）

这些指令可以在正常运行模式下随时调用。`WFI`会将系统置于低功耗模式，直到接收到下一个中断请求，而`WFE`则略有不同。只有系统中的少数事件，包括外部中断，可以配置为生成事件。如果系统处于使用`WFE`进入的睡眠或停止模式，则正常中断请求不会将系统放回正常运行模式。

调用后进入的低功耗模式取决于存储在`0xE000ED10`中的设置。SCR 仅提供 3 个有意义的 1 位标志字段：

+   `SLEEPONEXIT`（位 1）：当启用时，系统将在下一个中断处理程序执行结束时进入低功耗模式。

+   `SLEEPDEEP`（位 2）：确定在调用`WFI`或`WFE`或使用`SLEEPONEXIT`激活时返回中断时进入哪种模式。如果此位被清除，则选择睡眠模式。当此位激活时进入低功耗模式，系统将被置于停止或待机模式，具体取决于电源管理寄存器的配置。

+   `SEVONPEND`（位 4）：当此位激活时，在低功耗模式下任何挂起的中断都会引起唤醒事件，无论是否使用`WFI`或`WFE`指令进入睡眠模式或停止模式。

注意，位 0、位 3 以及位 5-31 是保留的（必须保持为 0）。

## 深度睡眠配置

要在停止模式和待机模式之间进行选择，并设置与深度睡眠模式相关的某些参数，我们的参考平台提供了一个电源控制器，映射在内部外围区域，地址为`0x40007000`。该控制器由两个寄存器组成：

+   `PWR_CR`（控制寄存器）偏移量为`0`

+   `PWR_SCR`（状态和控制寄存器）偏移量为`4`

可以在这两个寄存器中配置的相关参数如下：

+   `PWR_CR`位 14。当激活时，在正常运行模式下通过配置内部稳压器为 CPU 核心逻辑产生略低的电压来节省额外的电力。此功能仅在目标未以最大频率运行时可用。

+   `PWR_CR`位 9。如果进入深度睡眠模式时处于活动状态，则在系统睡眠期间将完全关闭闪存。这导致节省了适量的电量，但也会影响唤醒时间。

+   `PWR_CR`位 1。此位确定 CPU 进入深度睡眠时进入哪种模式。如果清除，则选择停止模式。如果设置，系统进入待机模式。

+   `PWR_CR`位 0。此位仅在停止模式下有效。如果启用，它通过在内部电压调节器中启用*欠压*模式，在深度睡眠期间略微减少能耗。电流以降低泄漏模式供应给核心逻辑，这仍然允许您保留内存和寄存器的内容。此功能仅在系统未以全速运行时才可用。

+   `PWR_CSR`位 4。此标志确定唤醒引脚是否可以用作正常 GPIO，或者是否保留用于在待机期间检测唤醒信号。与参考平台中此功能相关联的引脚是 PA0。

`PWR_CSR`位 0。将`1`写入`PWR_CR`位 2（`CWUF`）。

在 STM32F407 微控制器上，我们可以使用以下宏访问与低功耗模式和配置相关的寄存器：

```cpp
#define SCB_SCR (*(volatile uint32_t *)(0xE000ED10))
#define SCB_SCR_SEVONPEND (1 << 4)
#define SCB_SCR_SLEEPDEEP (1 << 2)
#define SCB_SCR_SLEEPONEXIT (1 << 1)
#define POW_BASE (0x40007000)
#define POW_CR (*(volatile uint32_t *)(POW_BASE + 0x00))
#define POW_SCR (*(volatile uint32_t *)(POW_BASE + 0x04))
#define POW_CR_VOS (1 << 14)
#define POW_CR_FPDS (1 << 9)
#define POW_CR_CWUF (1 << 2)
#define POW_CR_PDDS (1 << 1)
#define POW_CR_LPDS (1 << 0)
#define POW_SCR_WUF (1 << 0)
#define POW_SCR_EWUP (1 << 4)
```

对于低功耗模式的激活和自发生事件的生成，我们定义包含单个内联汇编指令的宏如下：

```cpp
#define WFI() asm volatile ("wfi")
#define WFE() asm volatile ("wfe")
```

如果通过`WFI`进入睡眠模式，系统将暂停执行，直到下一个中断。使用`WFE`进入睡眠模式确保只有选定的*事件*可以再次唤醒系统。可以启用系统上发生的不同类型的事件来唤醒`WFE`。

当进入`WFE`时，NVIC 中所有活动的中断仍将被计为事件，从而唤醒`WFE`调用。可以通过在 NVIC 中禁用相应的 IRQ 线来临时过滤掉中断。如果通过 NVIC 以这种方式过滤中断，它将保持挂起状态，并在系统返回正常运行模式时立即处理。

## 停止模式

每次调用`WFI`或`WFE`指令时，只要`SCB_SCR_SLEEPDEEP`保持关闭状态，就会进入睡眠模式。可以通过启用`SLEEPDEEP`标志来启用其他低功耗模式。要进入可用的深度睡眠模式之一，必须在调用`WFI`或`WFE`之前配置`SCB_SCR`和 POW 寄存器。根据配置，系统将进入两种深度睡眠模式之一，停止或待机。

在以下示例中，一个连续的 1 Hz 定时器使用`WFE`切换 LED 10 次，然后进入深度睡眠模式。在定时器中断之间，`main`循环保持在睡眠模式，使用`WFI`：

```cpp
void main(void) {
  int sleep = 0;
  pll_on(0);
  button_setup();
  led_setup();
  timer_init(CPU_FREQ, 1, 1000);
  while(1) {
    if (timer_elapsed) {
      WFE(); /* consume timer event */
      led_toggle();
      timer_elapsed = 0;
    }
    if (tim2_ticks > 10) {
      sleep = 1;
      tim2_ticks = 0;
    }
    if (sleep) {
      enter_lowpower_mode();
      WFE();
      sleep = 0;
      exit_lowpower_mode();
    } else
      WFI();
  }
}
```

定时器的中断服务例程将`tim2_ticks`计数器增加`1`并设置`timer_elapsed`标志，这将使`main`循环切换 LED 并消耗由定时器生成的事件：

```cpp
void isr_tim2(void) {
  nvic_irq_clear(NVIC_TIM2_IRQN);
  TIM2_SR &= ~TIM_SR_UIF;
  tim2_ticks++;
  timer_elapsed++;
}
```

`enter_lowpower_mode`过程负责根据所需的低功耗模式设置系统控制块和电源控制寄存器中的值，并相应地配置所有优化。

`enter_lowpower_mode`过程执行以下操作：

1.  关闭 LED。

1.  它设置`SCB_SCR`和电源寄存器中的值，以配置在`WFE`时将进入的低功耗模式。

1.  选择单个额外的电源优化。

实现如下：

```cpp
void enter_lowpower_mode(void)
{
  uint32_t scr = 0;
  led_off();
  scr = SCB_SCR;
  scr &= ~SCB_SCR_SEVONPEND;
  scr |= SCB_SCR_SLEEPDEEP;
  scr &= ~SCB_SCR_SLEEPONEXIT;
  SCB_SCR = scr;
  POW_CR |= POW_CR_CWUF | POW_CR_FPDS | POW_CR_LPDS;
}
```

在这种情况下，通过激活低功耗电压调节器设置（通过`POW_CR_LPDS`）和关闭闪存（通过`POW_CR_FPDS`）来配置停止模式以尽可能减少功耗。

现在通过`WFE()`调用进入低功耗模式。为了能够唤醒系统，我们配置一个与用户在板上按按钮相关的`EXTI`事件。为此，我们将`EXTI0`配置为对上升沿敏感，因为当按下时，PA0 引脚的逻辑值从`0`变为`1`。

由于我们并不特别关注中断本身，我们确保在`EXTI`中关闭了生成中断请求的标志。事件控制器将确保生成一个事件，因为与输入引脚相关的标志在`EXTI_EMR`寄存器中被强制执行。

用户按钮事件的初始配置如下：

```cpp
void button_setup(void)
{
  uint32_t reg;
  AHB1_CLOCK_ER |= GPIOA_AHB1_CLOCK_ER;
  APB2_CLOCK_ER |= SYSCFG_APB2_CLOCK_ER;
  GPIOA_MODE &= ~ (0x03 << (BUTTON_PIN * 2));
  EXTI_CR0 &= ~EXTI_CR_EXTI0_MASK;
  EXTI_IMR &= ~0x7FFFFF;
  reg = EXTI_EMR & ~0x7FFFFF;
  EXTI_EMR = reg | (1 << BUTTON_PIN);
  reg = EXTI_RTSR & ~0x7FFFFF;
  EXTI_RTSR = reg | (1 << BUTTON_PIN);
  EXTI_FTSR &= ~0x7FFFFF;
}
```

没有为按钮配置中断，因为事件本身足以在停止模式下唤醒板。

进入停止模式后，PLL 将被禁用，当系统回到正常运行模式时，HSI 将自动被选为时钟源。为了恢复时钟配置，在退出停止模式后需要执行以下几个步骤：

1.  清除`SCB_SCR_SLEEPDEEP`标志，以便下一次调用`WFI`或`WFE`不会触发另一个切换到停止模式。

1.  访问`POW_CR`寄存器以清除硬件在停止模式结束时设置的唤醒标志。

1.  由于时钟已恢复，PLL 再次被配置。

1.  打开 LED。

1.  再次启用`TIM2`中断，以便在正常运行模式下恢复定时器的功能：

    ```cpp
    void exit_lowpower_mode(void)
    ```

    ```cpp
    {
    ```

    ```cpp
      SCB_SCR &= ~SCB_SCR_SLEEPDEEP;
    ```

    ```cpp
      POW_CR |= POW_CR_CWUF | POW_CR_CSBF;
    ```

    ```cpp
      clock_pll_on(0);
    ```

    ```cpp
      timer_init(cpu_freq, 1, 1000);
    ```

    ```cpp
      led_on();
    ```

    ```cpp
    }
    ```

深度睡眠模式可以持续降低功耗，并且当系统必须保持当前运行状态但可以冻结更长时间时，这是理想的情况。

## 待机模式

在待机模式下，系统可以进入超低功耗模式，消耗仅几微安培的电流，同时等待外部事件重新初始化。进入待机模式需要你在调用`WFI`或`WFE`之前设置`SCB_SCR_PDDS`标志。当系统处于待机状态时，除了用于时钟独立看门狗定时器和实时时钟的低速振荡器外，所有电压调节器都关闭。

进入待机模式的步骤与进入停止模式的步骤略有不同。将`SCB_SCR_PDDS`标志设置为选择待机模式作为深度睡眠变体。在这种情况下，不激活标志`SCB_SCR_LPDS`，因为我们知道在待机模式下它没有效果：

```cpp
void enter_lowpower_mode(void)
{
  uint32_t scr = 0;
  led_off();
  scr = SCB_SCR;
  scr &= ~SCB_SCR_SEVONPEND;
  scr |= SCB_SCR_SLEEPDEEP;
  scr &= ~SCB_SCR_SLEEPONEXIT;
  SCB_SCR = scr;
  POW_CR |= POW_CR_CWUF | POW_CR_FPDS | POW_CR_PDDS;
  POW_SCR |= POW_CR_CSBF;
}
```

在这种情况下，为按钮按下设置`EXTI`事件是无用的，因为当微控制器处于待机模式时，GPIO 控制器将被禁用。退出此状态的最简单方法是配置实时时钟，在固定时间后生成一个唤醒事件。实际上，在待机阶段，只有少数外设会被保持激活，它们都被分组在时钟配置的特殊部分，即备份域。备份域包括实时时钟和一小部分时钟树，包含内部和外部低速振荡器。对备份域相关寄存器的写入访问由禁用备份域保护的标志，或`POW_CR_DPB`，位于`POW_CR`寄存器的第 8 位控制。

RTC 配置寄存器，从地址`0x40002870`开始映射在外设区域，由于电磁干扰而受到保护，这意味着在访问其他寄存器之前必须写入一个特殊的值序列。集成到参考平台中的 RTC 复杂且具有许多功能，例如跟踪日期和时间，以及设置自定义闹钟和常规时间戳事件。对于本例，我们只想使用唤醒事件，因此大多数 RTC 寄存器在此处未进行文档说明。

我们访问 RTC 的受限寄存器集如下：

+   控制寄存器（`RTC_CR`）暴露了 RTC 提供的各种功能配置。在示例中，我们使用与唤醒触发器相关的值，通过唤醒定时器中断使能标志`RTC_CR_WUTIE`启用中断，并使用`RTC_CR_WUTE`也启用唤醒定时器计数器。

+   在本例中，初始化和状态寄存器（`RTC_ISR`）用于通过特殊标志`RTC_ISR_WUTWF`在定时器设置期间检查唤醒定时器设置寄存器的写入状态。

+   唤醒定时器寄存器（`RTC_WUTR`）用于设置下一次唤醒事件之前的时间间隔。

+   写保护寄存器（`RTC_WPR`）用于在向该区域的其他寄存器写入之前传输解锁序列。

映射这些寄存器和有意义的字段的前置宏如下：

```cpp
#define RTC_BASE (0x40002800)
#define RTC_CR (*(volatile uint32_t *)(RTC_BASE + 0x08))
#define RTC_ISR (*(volatile uint32_t *)(RTC_BASE + 0x0c))
#define RTC_WUTR (*(volatile uint32_t *)(RTC_BASE + 0x14))
#define RTC_WPR (*(volatile uint32_t *)(RTC_BASE + 0x24))
#define RTC_CR_WUP (0x03 << 21)
#define RTC_CR_WUTIE (1 << 14)
#define RTC_CR_WUTE (1 << 10)
#define RTC_ISR_WUTF (1 << 10)
#define RTC_ISR_WUTWF (1 << 2)
```

初始化 RTC 以生成唤醒事件的步骤包括以下内容：

1.  如果尚未开启，请开启时钟门控以配置电源寄存器，以启用`POW_CR_DPB`标志，从而启动 RTC 的设置：

    ```cpp
    void rtc_init(void) {
    ```

    ```cpp
       APB1_CLOCK_ER |= PWR_APB1_CLOCK_ER_VAL;
    ```

    ```cpp
       POW_CR |= POW_CR_DPB;
    ```

1.  在 RCC 中，通过备份域寄存器配置中的位 15 启用 RTC。

    ```cpp
       RCC_BACKUP |= RCC_BACKUP_RTCEN;
    ```

1.  如果可用，启用备用时钟源，选择**低速内部**（**LSI**）振荡器或**低速外部**（**LSE**）振荡器。

1.  在此示例中，我们使用 LSI 振荡器，因为参考平台上没有 LSE 振荡器。然而，外部振荡器更准确，并且在可用时总是首选，用于可靠的计时。时钟启用后，该过程通过轮询状态寄存器中的一个位等待它变得就绪：

    ```cpp
       RCC_CSR |= RCC_CSR_LSION;
    ```

    ```cpp
       while (!(RCC_CSR & RCC_CSR_LSIRDY))
    ```

    ```cpp
         ;
    ```

1.  选择 LSI 作为 RTC 的源：

    ```cpp
      RCC_BACKUP |= (RCC_BACKUP_RTCSEL_LSI << 
    ```

    ```cpp
          RCC_BACKUP_RTCSEL_SHIFT);
    ```

1.  启用中断和事件生成，将 EXTI 的第 22 行关联到上升沿：

    ```cpp
      EXTI_IMR |= (1 << 22);
    ```

    ```cpp
      EXTI_EMR |= (1 << 22);
    ```

    ```cpp
      EXTI_RTSR |= (1 << 22);
    ```

1.  通过写入解锁序列到`RTC_WPR`解锁对 RTC 寄存器的写入：

    ```cpp
      RTC_WPR = 0xCA;
    ```

    ```cpp
      RTC_WPR = 0x53;
    ```

1.  禁用 RTC，以便允许写入配置寄存器。通过轮询`RTC_ISR_WUTWF`等待写入操作成为可能：

    ```cpp
       RTC_CR &= ~RTC_CR_WUTE;
    ```

    ```cpp
       DMB();
    ```

    ```cpp
       while (!(RTC_ISR & RTC_ISR_WUTWF))
    ```

    ```cpp
         ;
    ```

1.  在下一个唤醒事件之前设置间隔的值。LSI 频率为 32,768 Hz，唤醒间隔寄存器的默认分频器设置为 16，因此`RTC_WUTR`中的每个单位代表 1/2048 秒。要设置 5 秒的间隔，我们使用以下方法：

    ```cpp
      RTC_WUTR = (2048 * 5) – 1;
    ```

1.  启用唤醒事件：

    ```cpp
      RTC_CR |= RTC_CR_WUP;
    ```

1.  清除在从待机模式返回时可能设置的唤醒标志：

    ```cpp
      RTC_ISR &= ~RTC_ISR_WUTF;
    ```

1.  为了完成序列，我们将一个无效字节写入`RTC_WPR`。这样，RCC 寄存器的写保护再次开启：

    ```cpp
       RTC_WPR = 0xb0;
    ```

    ```cpp
    }
    ```

1.  在进入待机模式之前，启用 RTC，以下程序确保计时器处于活动状态并计数，唤醒事件的生成是活跃的：

    ```cpp
    void rtc_start(void)
    ```

    ```cpp
    {
    ```

    ```cpp
       RTC_WPR = 0xCA;
    ```

    ```cpp
       RTC_WPR = 0x53;
    ```

    ```cpp
       RTC_CR |= RTC_CR_WUTIE |RTC_CR_WUTE;
    ```

    ```cpp
       while (((RTC_ISR) & (RTC_ISR_WUTWF)))
    ```

    ```cpp
         ;
    ```

    ```cpp
       RTC_WPR = 0xb0;
    ```

    ```cpp
    }
    ```

如果在进入待机之前调用显示的流程，当唤醒事件发生时，系统将再次启动，但它不会从暂停的地方恢复执行，就像在其他低功耗模式中发生的那样。相反，它从复位中断处理程序重新开始，在中断向量表的开头。因此，此示例不需要为`exit_lowpower_mode`实现，将系统切换到待机模式的`WFE`指令永远不会返回到相同的执行上下文。最终，待机示例的`main`函数看起来如下：

```cpp
void main(void) {
  int sleep = 0;
  clock_pll_on(0);
  led_setup();
  rtc_init();
  timer_init(cpu_freq, 1, 1000);
  while(1) {
    if (timer_elapsed) {
      WFE(); /* Consume timer event */
      led_toggle();
      timer_elapsed = 0;
    }
    if (tim2_ticks > 10) {
      sleep = 1;
      tim2_ticks = 0;
    }
    if (sleep) {
      enter_lowpower_mode();
      rtc_start();
      WFE(); /* Never returns */
    }
    else
      WFI();
  }
}
```

## 唤醒间隔

在设计低功耗策略时需要考虑的一个重要方面是唤醒时间间隔，换句话说，系统在切换到低功耗模式后恢复执行所需的时间。具有实时要求的系统可能在功耗和反应性之间留出一些妥协的空间，但了解从不同低功耗模式唤醒操作的影响，以便预测最坏情况下的操作延迟是很重要的。唤醒时间在很大程度上取决于微控制器的硬件设计，并且很大程度上依赖于架构。

在我们的参考平台上，从睡眠模式唤醒需要少量 CPU 周期，但对于深度睡眠模式，情况就不同了。从停止模式唤醒需要几个微秒。在停止模式下激活的进一步优化，例如更改电压调节器或关闭闪存，会持续影响恢复到正常运行所需的时间。从待机模式唤醒后，唤醒间隔会更长，达到毫秒级别，因为系统在唤醒事件后应该完全重新启动，而启动代码执行时间会加到 CPU 唤醒所需的毫秒数中。

当设计低功耗系统时，必须考虑并正确测量这些唤醒时间，尤其是在系统必须处理实时约束的情况下。必须选择适合应用时序和能量配置文件要求的最佳低功耗模式，同时考虑到如果系统经常唤醒，这些间隔变得不可忽略时，离开低功耗模式产生的开销。

一旦系统设计为在适当的低功耗模式下运行，我们需要一个可靠的机制来测量系统运行时的功耗。下一节建议了一种常见的机制，通过跟踪测试电路中的电流值来测量微控制器的低功耗操作模式的影响，以及评估引入的所有节能优化。

# 测量功耗

可以在任何时候通过将电流表串联连接到设备来测量目标使用的电流。然而，这种机制并不能显示在时间间隔内值的所有振荡，这就是为什么通常使用示波器采样分流电阻两端的寄生电压值是有用的。

将分流电阻串联放置在目标设备与电源的两侧。其典型值相对较小，在几欧姆的范围内，以确保寄生电压保持较低，但仍可由示波器测量：

![图 8.1 – 使用示波器测量分流电阻上的电压以采样电流](img/B18730_08_01.jpg)

图 8.1 – 使用示波器测量分流电阻上的电压以采样电流

由于串联电路的特性，通过分流器的电流与目标系统使用的电流相同，因此分流电阻两端的电压相应地变化。

## 开发板

为了看到电源优化的效果，我们必须排除与系统无关的电子设备。例如，我们的参考板 STM32F407DISCOVERY 上有一个额外的微控制器，用于为主机提供调试接口，并且它使用相同的 USB 连接器供电。然而，开发套件通常提供一种方法来测量电流，排除无关硬件，使我们能够正确评估微控制器的低功耗特性，排除板上的开发相关电路。

在我们的参考板上，JP1 跳线可用于打开电源和微控制器电路之间的电路。通过将跳线替换为连接到两个引脚的电流表，我们可以测量实际系统使用的电流。同样，可以通过使用示波器采样分流电阻上的电压来应用分流电阻以监控电流。

一个配备可靠能量计量的实验室是评估低功耗实现和协助原型和设计阶段能量优化的良好起点。

# 设计低功耗嵌入式应用程序

在本节中，提出了一些设计模式，通过评估即将设计的系统所有组件的功耗和状态，以在目标设备上实现更好的能耗配置文件。一旦我们知道如何在目标设备上测量值，以及所选架构和微处理器系列中低功耗模式的详细信息，就可以编程应用程序，同时考虑其他参数，例如我们编写的软件的能量效率。

## 用睡眠模式替换忙碌循环

忙碌循环在爱好者中非常受欢迎的原因是它们非常容易实现。假设系统需要等待一个数字输入切换到低逻辑状态，并且这个输入映射到某个 GPIO。这可以通过以下一行代码轻松完成：

```cpp
while((GPIOX_IDR & (1 << INPUT_PINX)) != 0)
  ;
```

虽然这完全按预期工作，但它将迫使 CPU 进入一个 fetch-decode-execute 循环，并在相同的几个指令之间跳跃，直到条件变为 `false`。正如我们所见，微控制器使用的功率主要取决于 CPU 的运行速度。较低的频率对应于每条指令使用的功率较小。在无限循环中执行指令而不切换到低功耗模式，将 CPU 的功耗设定在其最高值，持续一定可测量的时间——在这种情况下，逻辑输入改变状态所需的时间。

如果没有启用中断，积极轮询值是唯一的方法。本书中的示例倾向于引导你走向适当的中断处理方法。正确处理等待逻辑切换的方法是预见与下一个操作相关的中断线的激活。在 GPIO 线的情况下，我们可以使用外部中断触发器在条件满足时唤醒主循环，并在等待事件时切换到低功耗模式，而不是循环等待。

在许多其他情况下，通过调查另一种访问当前阻止系统执行下一步操作的外设的方法，可以避免实现如前所述的循环。现代串行和网络控制器配备了中断信号，当我们访问的硬件没有这些信号时，总有其他方法通过外部中断线感知事件。当一个设备确实只能以轮询模式运行时，作为最后的手段，可以通过将操作与定时器中断关联来降低轮询频率，这样就可以每秒轮询几次，甚至偶尔一次，使用与实际外设速度更匹配的间隔。执行定时操作允许 CPU 在之间睡眠，并切换到低功耗模式，从而降低 CPU 在忙碌循环时所需的平均能量。

本章中多次提到的这个规则的例外情况是在激活系统组件后等待就绪标志。以下代码激活了内部低速振荡器，并在进入低速模式之前用于待机模式示例。CSR 寄存器被轮询，直到低速振荡器实际运行：

```cpp
RCC_CSR |= RCC_CSR_LSION;
while (!(RCC_CSR & RCC_CSR_LSIRDY))
   ;
```

在微控制器硅芯片中的集成外设上执行此类操作，具有几个 CPU 时钟周期的已知延迟，因此不会影响实时约束，因为类似内部操作的最大延迟通常在微控制器文档中提及。当轮询发生在状态和反应时间可能依赖于外部因素的不可预测的寄存器上时，情况就会改变，系统可能会出现长时间的忙碌循环。

## 在较长的非活动期间进行深度睡眠

如我们所知，待机模式允许系统以尽可能低的功耗冻结，处于超低功耗范围内。当设计对超低功耗有非常严格的要求，并且满足以下条件时，建议使用待机模式：

+   存在一种可行的唤醒策略，并且与当前的硬件设计兼容

+   系统可以在不依赖其先前状态的情况下恢复执行，因为 RAM 和 CPU 寄存器的内容已丢失，系统在唤醒时从复位服务例程重新启动

通常，较长的非活动期，例如，可以使用 RTC 在指定时间编程唤醒闹钟，更适合使用待机模式。这适用于在白天以编程间隔读取传感器和启用执行器、跟踪时间和一些状态变量等情况。

在大多数其他情况下，停止模式仍然可以节省足够的电量，并提供更短的唤醒间隔。停止模式的另一个主要优点是唤醒策略选项的灵活性增加。实际上，任何基于中断或可配置的事件都可以用来从微控制器的低功耗深度睡眠模式唤醒系统，因此它更适合与微控制器周围的外围设备和接口进行一些异步交互的状态。

## 选择时钟速度

平台提供的所有计算能力是否在所有时候都是必需的？

现今微处理器的处理性能与 20 年前的个人计算机相当，这些计算机已经能够进行快速操作，甚至处理实时多媒体内容。嵌入式应用并不总是需要 CPU 以全频率运行。特别是在访问外围设备时，而不是进行数值计算，CPU 和总线时钟的速度并不重要。当每次 CPU 性能不是执行管道的瓶颈时，无论是正常运行模式还是睡眠模式，所选频率降低时，两者所需的能量都大大减少。

许多微控制器被设计为降低 CPU 和内部总线的运行频率，这也通常允许系统以较低的电压供电。正如我们所见，时钟的改变可以在运行时进行，以在功率和性能方面做出相应的妥协。然而，这意味着所有使用时钟作为参考的设备都必须重新配置，因此这种改变在执行时间上有成本，不应滥用。将频率变化添加到系统设计的一个方便方法是，将两个或多个 CPU 频率缩放选项分离成自定义电源状态，并通过在性能和功耗之间淡入淡出切换到所需状态。

## 功率状态转换

考虑一个连接到传感器的系统，通过网络接口产生和传输数据。传感器被激活后，系统必须等待它准备好，这通常需要几秒钟。然后连续读取传感器多次，然后关闭。数据通过网络设备进行处理、加密和传输。接下来几小时系统保持空闲，然后重复相同的操作。状态机的初步粗略建模如下：

![图 8.2 – 假设的传感器读取系统的状态机](img/B18730_08_02.jpg)

图 8.2 – 假设的传感器读取系统的状态机

在连续两个周期之间预见的长时间空闲间隔表明，将系统大部分时间置于待机状态，并为系统编程一个 RTC 闹钟，以便在下次采集前自动唤醒，可能是一个好主意。

对于其他状态，也有可能进行其他不太明显的优化。在从传感器获取数据时，CPU 的完整计算能力可能从未被充分利用，因为系统大部分时间都在与传感器通信，或者等待，可能在睡眠模式下，直到接收到下一个值。在这种情况下，我们可以提供一个节能的运行模式，确保系统以较低的频率运行，这样在运行和睡眠模式之间交替时，两者都会受到较小的能量足迹的影响。只有在数据处理、转换并通过网络设备发送时，才需要更高的性能。在这种情况下，系统将被优化以更快地运行并在更短的时间内处理数据。如果传感器能够在准备开始数据采集时唤醒系统，则可以在传感器激活后预见一个停止阶段。

一旦每个阶段都与其优化的低功耗模式和选定的操作频率相关联，我们就可以在我们的设计文档中添加注释，以提醒我们低功耗优化将如何实现，以实现性能、能源经济和低延迟的最佳组合。以下图总结了阶段之间的转换及其相关的低功耗模式：

![图 8.3 – 每个运行和空闲状态下的功耗优化](img/B18730_08_03.jpg)

图 8.3 – 每个运行和空闲状态下的功耗优化

为嵌入式系统调整其最佳能效曲线是一个精细的过程，它对其他性能指标有重大影响，会引入延迟并减慢执行速度。在大多数情况下，它包括在提供可接受性能的同时，保持功耗和能量需求在期望范围内找到最佳折衷点。

# 摘要

现代嵌入式系统为低功耗甚至超低功耗设计打开了多种可能性。本章分析了针对参考微控制器可用的不同能效曲线，以及如何设计、集成和评估这些程序以控制能量感知嵌入式系统中的功耗。在理解了目标设备可用的几种选项后，实现低功耗模式和进一步节能技术是构建耐用且可靠的电池供电和能量收集设备的关键。

在下一章中，我们将转向介绍连接设备，并描述在嵌入式系统架构中处理网络协议和接口的影响。
