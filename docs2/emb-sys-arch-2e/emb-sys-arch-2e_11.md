

# 可信执行环境

微控制器硬件架构技术演变的 重要一步最近已经通过引入一种域分离机制而实现，这种机制在其他架构中已经存在，通常被称为**可信执行环境**（Trusted Execution Environment，简称 TEE）或**TEE**。

TEE 是一种抽象，它提供了两个或更多分离的执行域，或“世界”，它们具有不同的能力和权限来访问设备、资源和外围设备。

将一个或多个软件组件和模块的执行环境隔离出来，也通常被称为**沙盒技术**，包括限制它们对系统的“视图”，而不影响它们的性能和正常操作。这是计算机科学中许多用例和领域的需求，而不仅仅是提高嵌入式系统的安全性。

在其他域中类似的硬件辅助隔离机制是我们今天所知道的云服务器基础设施的构建块，以虚拟化扩展和安全隔离机制的形式存在，这些机制允许我们在同一硬件上同时运行多个“客户”虚拟机或容器。

本章分析的概念和技术如下：

+   沙盒技术

+   TrustZone-M

+   系统资源分离

+   构建和运行示例

到本章结束时，你将了解 TEE 以及如何配置和使用 TrustZone-M 在 Cortex-M 微控制器上以获得两个独立的执行域。

# 技术要求

为了运行本书存储库中提供的示例，需要一个 STM32L552 微控制器。TrustZone-M 技术仅由最新的 ARM Cortex-M 微控制器系列支持。STM32L552 是一款 Cortex-M33，完全支持 TrustZone-M，这使得它成为学习这项技术的便捷且经济实惠的选择。

本章的代码文件可在[`github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter11`](https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter11)找到。

# 沙盒技术

沙盒技术是计算机安全领域的一个通用概念，它指的是一系列硬件和软件措施，这些措施限制了一个或多个系统组件的“视图”，以限制系统因意外故障或故意制造的恶意攻击而受影响的区域，并防止它们在整个系统中传播。沙盒技术可以有不同的形式和实现方式，这些方式可能或可能不利用特定的硬件功能来提高安全性和有效性。

通过术语 TEE，我们指的是那些涉及 CPU 始终跟踪运行代码的安全状态的沙箱机制，而不会显著影响运行应用程序的性能。由于这些 TEE 机制与 CPU 设计内在绑定，因此沙箱中的 TEE 行为、管理和通信模型在不同异构平台之间有所不同，并且高度依赖于架构。此外，TEE 可用于不同的目的，通常与密码学结合使用，通过硬件信任根来保护软件的完整性和真实性。

在 2005 年，英特尔为 x86 处理器实现了第一套虚拟化指令（Intel VT），以便原生地运行隔离的虚拟机代码（而不是在宿主机器上的专用进程中模拟 CPU），通过提供核心组件（CPU、RAM 和外设）的硬件辅助虚拟化。英特尔 CPU 通过扩展现有的分层保护域（通常简称为**环**，已用于内核/用户空间分离）来限制客户虚拟机对真实硬件的访问。

虚拟机并不是 x86 处理器上 TEE 的唯一用例。英特尔**软件保护扩展**（**SGX**）是一组存在于许多 x86 CPU 中的安全相关指令，用于保护特定的内存区域或区域，防止未经授权的访问。尽管这些指令最近已从消费级英特尔 CPU 中移除，但它们仍然存在于云和商业硬件领域的特定微处理器中。SGX 可用于多种目的，例如提供一个安全的保险库来隐藏用于安全使用的秘密密钥。然而，最初，它们被引入是为了在 PC 上实现**数字版权管理**（**DRM**），这将通过仅授权预授权、签名的软件应用程序访问受保护的内容来强制执行媒体和专有软件内容的版权保护。在这种设置中，TEE 保护系统免受的对手是最终用户本身。

之后，AMD 为其 CPU 添加了特定的架构扩展，这些扩展被归类为一种称为**安全加密虚拟化**（**SEV**）的技术。除了为由虚拟机管理程序管理的虚拟机提供沙箱外，SEV 还使用硬件辅助加密来确保在执行过程中单个内存页面甚至 CPU 寄存器内容的机密性。

然而，英特尔架构并不是第一个引入 CPU 辅助、内置的安全扩展的。ARM 在 2000 年代初开始研究可信计算，并于 2003 年最终宣布支持名为 TrustZone 的技术。现代 ARM 微处理器，如 Cortex-A 系列中的那些，支持名为 TrustZone-A 的技术，该技术实现了两个独立的 Secure（S）和非 Secure（NS）世界，后者对实际系统有一个受限的预配置视图，而前者能够直接访问所有硬件资源。

要找到第一个实现 TEE 的微控制器，我们必须看看最近设计的 RISC-V 架构。RISC-V 家族中的微处理器和微控制器都提供了相互独立的完整沙盒，无论是在 32 位还是 64 位架构中实现“S”或“U”扩展。每个硬件辅助容器都提供系统上可用资源的一个子集，并运行自己的固件。

最后，ARM 最新的微控制器系列，ARMv8-M 系列，包括实现基于现有且成熟的 TrustZone 技术设计的安全和非安全执行域之间隔离所需的扩展和微代码。这个特性被称为 TrustZone-M，这是我们将在本章后面更详细地关注的特定技术。ARMv8-M 是作为本书前几章参考平台的 ARMv7-M 系列微控制器的直接演变。

本章的其余部分将专门介绍 TrustZone-M 以及如何在嵌入式系统中配置和开发组件，实现 ARMv8-M 系列微控制器上的 TEE。从现在起，术语 TrustZone 将专门指 TrustZone-M 技术。

# TrustZone-M

ARMv7-M 核心，如 Cortex-M0+和 Cortex-M4 微控制器，几十年来一直主导着嵌入式市场，并且仍然是许多嵌入式系统设计的首选。尽管已经发生了一些变化和增加，但新的 Cortex-M23 和 Cortex-M33 核心，以及更新的 M35P 和 M55，继承了并扩展了许多 Cortex-M0、Cortex-M4 和 Cortex-M7 微控制器的成功特性。

在典型的 TrustZone 用例中，软件开发的不同阶段可能涉及多个参与者。设备的所有者可能提供一个基础系统，该系统已经配备了在安全世界中授权运行的全部软件。这仍然为系统集成商提供了定制非安全部分的可能性，但视图受到安全域允许的资源配置的限制。在这种情况下，系统集成商接收到的系统部分锁定，TrustZone 已启用，并设置了闪存保护以保护其完整性。提供的安全软件监督非安全域中任何自定义软件的执行，同时保留安全世界中映射的资源，并限制运行应用程序的访问。没有授权访问安全执行域的系统集成商仍然可以在非安全世界中运行特权或非特权软件，从而包括访问授权接口的操作系统和设备驱动程序，这些接口可以是直接访问，也可以得到安全监督的一些帮助。

本章相关示例可以在参考平台上编译和运行。此示例基于在第*第四章*“启动过程”中介绍的引导加载程序示例。这是因为我们想要描述的基于 TrustZone 的解决方案的结构相似性，因为两个执行域的软件被分别打包到不同的二进制文件中。在 TrustZone 的情况下，引导加载程序代码在安全域中执行与在非安全世界中运行的应用程序之间的分离将帮助我们理解构建、配置和运行真实系统组件所使用的元素和工具。

下一个子节包含对参考平台的描述，然后我们将简要介绍安全和非安全域背后的执行模型，这将使我们进一步分析 TrustZone-M 单元和控制器在系统资源分离方面的调节。

## 参考平台

在示例中用作参考的微控制器是 STM32L552，这是一种 Cortex-M33 CPU，可以在方便的 Nucleo-144 格式开发板上找到。STM32L5 系列微控制器可能被认为是较老 STM32F4 系列的最新演变，通过结合低功耗模式和高性能来针对相同的市场份额。因此，本章选择该系列微控制器作为提供的示例的参考平台。然而，将要描述的大多数 TrustZone-M 技术和组件概念都适用于 ST Microelectronics 和其他几个芯片制造商提供的所有 ARMv8-M 系列微控制器。

在 STM32L552ZE 上，CPU 时钟可以配置为以 110 MHz 运行。微控制器配备了 256 KB 的 SRAM，分为两个银行 SRAM1 和 SRAM2，分别映射到不同的区域。512 KB 的闪存内存可以用作一个连续的空间，或者配置为两个独立的银行。ST 微控制器提供了特定于平台的库和工具，这些库和工具不包括在提供的示例中，通常这些示例基于一个全新的实现，从理解文档开始。在将要介绍的示例中，此方法的唯一例外是使用 STM32 编程命令行界面`STM32_Programmer_CLI`，该界面可以通过连接到 PC 的 USB 电缆并通过 ST-Link 调试器在板子上运行以下命令来显示可编程选项字节的当前值：

```cpp
STM32_Programmer_CLI -c port=swd -ob displ
```

此工具将用于设置开启和关闭 TrustZone 所需的**选项字节**以及设置其他用于分离闪存区域的选项。选项字节值存储在非易失性存储器中，且在板子断电后这些值将得以保留。

重要提示

通过编程工具修改一些可访问的选项字节可能是不可逆的，在某些情况下，可能会损坏您的设备。在更改任何选项之前，请参阅您的微控制器的参考手册和应用笔记。

其中一个选项字节包含`TZEN`标志，根据出厂默认设置，该标志应被禁用。只有在 TrustZone-M 配置完成后，我们才会在目标设备上启用它以上传和运行示例。安全世界中的引导加载程序部分将负责为作为不同二进制文件安装的应用程序设置环境，并在非安全域中执行它。我们将通过引入为此目的引入的新 ARMv8 汇编指令来演示两个世界之间的转换。

在下一小节中，我们将介绍 ARMv8-M 架构中用于执行代码和控制执行域的扩展。这些扩展是通用的，包含在所有支持 TrustZone 的 ARMv8-M 微控制器中，并且是分离域执行的核心组件。

## 安全和非安全执行域

在*第十章*“并行任务和调度”中，我们了解到，在内存分段的帮助下，线程之间以及线程和操作系统之间的资源分离是可能的。在 ARMv8-m 系列微控制器中，TrustZone-M 通常被称为安全扩展，因为它确实在目标上运行的应用程序软件组件之间增加了一个额外的权限分离级别。这些安全扩展并不取代我们在调度器的安全版本中之前实现的现有线程分离。相反，它们在现有的分离之上引入了一个额外的安全模式。

与没有这些扩展的操作系统强制执行线程模式和特权模式之间的分离，并可以使用 MPU 设置访问内存映射区域的边界类似，TrustZone-M 添加了**安全**（**S**）和**非安全**（**NS**）执行域（或“世界”），CPU 可以控制对单个资源的访问。

在这些世界中的每一个，仍然可以通过使用基于 CONTROL 位的现有机制来实现特权/线程分离。每个安全世界都可以有自己的特权和非特权执行模式。在 NS 世界中运行的操作系统仍然可以使用从之前的 ARMv7-M 架构继承的经典特权分离。这总共创建了四个可用的执行上下文，CPU 可以同时跟踪，如下表所示，为域和特权级别的组合：

| **安全域** | **非安全域** |
| --- | --- |
| 安全特权执行 | 非安全特权执行 |
| 安全线程执行 | 非安全线程执行 |

表 11.1 – 安全/非安全域中的可用执行模式

如我们在*第十章*，“并行任务与调度”中指出的，Cortex-M4 提供了两个独立的栈指针（MSP 和 PSP）来跟踪执行线程或内核代码时的不同上下文。在 Cortex-M33 中，总共有四个不同的栈指针，分别是 MSP_S、PSP_S、MSP_NS 和 PSP_NS。每个栈指针在执行期间都会根据当前域和上下文被映射到实际的 SP 寄存器。

当 CPU 上存在 MAIN 扩展时，ARMv8-M 架构增加了一个非常方便的功能，正如我们的参考平台所示。这四个栈指针中的每一个都有一个对应的**栈指针限制**（**SPLIM**）寄存器（分别称为 MSPLIM_S、PSPLIM_S、MSPLIM_NS 和 PSPLIM_NS）。这些寄存器指示四种情况下栈指针值的下限。这实际上是对*栈溢出*子节中分析的问题的有效对策，该子节在*第五章*，“内存管理”中。当发生这种情况时，CPU 将不断在运行时检查栈是否超过其内存中的下限，并生成异常。这种机制提供了一种比在*第五章*，“内存管理”中提出的示例中提出的在堆和栈分配的两个内存区域之间引入保护区域更好的硬件辅助方式来保护内存，防止意外栈溢出和与其他内存区域的冲突。

我们已经分析了如何在执行模式之间切换，以及如何在从系统调用返回时设置或清除 CONTROL 位在特权与线程执行模式之间的交易中扮演的角色。在安全和非安全世界之间切换安全和非安全执行机制是通过特定的汇编指令实现的，我们将在介绍资源分离之后进行解释。

为了更好地理解非安全世界运行的软件可能访问或无法访问的系统资源，下一节将详细介绍 TrustZone-M 控制器模块提供的不同可能性，以隔离和分离硬件资源。

# 系统资源隔离

当 TrustZone-M 启用时，所有映射到内存的区域，包括 RAM、外设，甚至 FLASH 存储器，都会获得一个新的安全属性。除了安全和非安全域之外，安全属性还可能假设第三个值，**非安全可调用**（**NSC**）。这个最后的属性定义了用于通过特定机制从非安全世界到安全世界执行交易的特定内存区域，该机制将在最后一节“构建和运行示例”中解释。NSC 区域用于提供类似系统调用的安全 API，具有新的功能。安全域公开服务例程，可以在访问其非安全对应方的安全资源时执行特定的受控操作。

## 安全属性和内存区域

Cortex-M33 微控制器提供各种级别的保护。这些级别效果的组合决定了与系统上资源相关的哪些内存映射区域对执行域可用，以及哪些仅从安全世界可访问。

启用 TrustZone-M 还会复制一些系统资源的表示。通常从地址 0x08000000 开始映射的闪存，在区域 0x0C000000 有一个别名，用于从安全世界访问相同的存储。许多系统寄存器是“分区的”，并在不同的内存位置有安全和非安全版本。例如，当 TrustZone 禁用时，GPIOA 控制器映射到地址 0x42020000。当 TrustZone 启用时，如果 GPIOA 控制器可以从非安全世界访问，则运行在非安全域的软件将使用相同的地址。然而，运行在安全域的软件将使用从地址 0x52020000 开始映射的相同控制器。相同的分区也适用于外设区域中的许多其他寄存器，这些寄存器有相同寄存器的安全和非安全版本映射到两个单独的区域。

在由其他 TrustZone 感知组件处理之前，每个内存访问都由负责配置属性的单元进行监控和过滤。这些是**安全属性单元**（**SAU**）和**实现定义属性单元**（**IDAU**）。这些单元影响整个内存映射的可访问性，而不管每个区域关联的资源类型如何。虽然 SAU 可以通过一组寄存器进行配置，但 IDAU 包含由芯片制造商强制执行的硬编码映射。IDAU 和 SAU 属性的组合影响每个内存映射区域的可访问性，特别是以下方面：

+   由 IDAU 映射为安全的区域不受 SAU 属性的影响，并且始终保持为安全映射

+   由 IDAU 映射为 NSC 的区域可以是安全的或 NSC，这取决于 SAU 属性

+   由 IDAU 映射为非安全的区域将遵循 SAU 映射

每个区域的属性及其结果映射总结在下表中：

| **IDAU 属性** | **SAU 属性** | **结果属性** |
| --- | --- | --- |
| 安全 | 安全、NSC 或非安全 | 安全 |
| NSC | 安全 | 安全 |
| 非安全 | 安全 | 安全 |
| NSC | NSC 或非安全 | NSC |
| 非安全 | NSC | NSC |
| 非安全 | 非安全 | 非安全 |

表 11.2 – IDAU 和 SAU 属性的组合

默认情况下，我们的 STM32L552 参考平台中的 IDAU 强制执行几个关键区域的保护/NSC 映射：

+   安全空间中的闪存映射，从地址`0x0C000000`开始

+   第二个 SRAM 银行，SRAM2，从地址`0x30000000`开始映射

+   地址`0x50000000`到`0x5FFFFFFF`之间的内存，保留用于安全外设的控制和配置

SAU 在复位时将所有区域设置为安全，并且默认情况下是禁用的。要执行非安全代码，我们必须在 IDAU 配置允许的间隔内定义至少两个非安全区域。

在我们的示例中，我们在启用 SAU 之前初始化了一些内存区域，以允许应用程序访问。SAU 通过四个主要的 32 位寄存器进行控制：

+   **SAU_CTRL**（SAU 控制）：用于激活 SAU。它包含一个标志来“反转”SAU 过滤器的逻辑，通过将所有内存区域设置为非安全。

+   **SAU_RNR**（SAU 区域号寄存器）：包含在配置内存区域时选择的区域号。对 SAU_RBAR 和 SAU_RLAR 的进一步写入将引用此编号区域。

+   **SAU_RBAR**（SAU 区域基址寄存器）：指示我们想要配置的区域的基本地址。

+   **SAU_RLAR**（SAU 区域限制地址寄存器）：包含要配置的区域结束地址。最低 5 位保留为标志位。位 1，当开启时，表示区域是安全的或非安全可调用的。位 0 启用区域，并指示其配置已完成。

在以下示例代码中，你可以找到`sau_init_region`便利函数。给定一个区域标识符、基址、结束地址和安全位值，它将相应地设置所有寄存器值：

```cpp
static void sau_init_region(uint32_t region,
    uint32_t start_addr,
    uint32_t end_addr,
    int secure)
{
  uint32_t secure_flag = 0;
  if (secure)
      secure_flag = SAU_REG_SECURE;
  SAU_RNR = region & SAU_REGION_MASK;
  SAU_RBAR = start_addr & SAU_ADDR_MASK;
  SAU_RLAR = (end_addr & SAU_ADDR_MASK)
      | secure_flag | SAU_REG_ENABLE;
}
```

这个函数由`secure_world_init`初始化函数调用，用于映射我们想要为此示例配置的四个 SAU 区域，具体如下：

+   `nsc_blue_led_toggle`，这是应用程序访问连接到 Nucleo 板上蓝色 LED 的否则仅限安全的 GPIO 的唯一方式。

+   `0x08040000`。这是我们的非安全应用程序代码将驻留的地方。

+   **区域 2**：SRAM1 银行的一个非安全部分，可以被非安全应用程序用于堆栈和变量。这是确保应用程序可以访问 RAM 地址的必要步骤。

+   `0x40000000`，包括非安全 GPIO 控制器。此区域将由非安全应用程序访问以设置系统时钟并控制示例中的绿色 LED。

示例中 SAU 初始化的代码如下：

```cpp
static void secure_world_init(void)
{
  /* Non-secure callable: NSC functions area */
  sau_init_region(0, 0x0C001000, 0x0C001FFF, 1);
  /* Non-secure: application flash area */
  sau_init_region(1, 0x08040000, 0x0804FFFF, 0);
  /* Non-secure RAM region in SRAM1 */
  sau_init_region(2, 0x20018000, 0x2002FFFF, 0);
  /* Non-secure: internal peripherals */
  sau_init_region(3, 0x40000000, 0x4FFFFFFF, 0);
```

此函数末尾的代码激活了 SAU 并启用了一个特定处理程序，用于检测安全故障：

```cpp
  /* Enable SAU */
  SAU_CTRL = SAU_INIT_CTRL_ENABLE;
  /* Enable securefault handler */
  SCB_SHCSR |= SCB_SHCSR_SECUREFAULT_EN;
}
```

默认情况下，启用 SAU 会将所有区域标记为安全，因此每个区域配置都会在可寻址内存空间内裁剪一个非安全或非安全可调用“窗口”。在我们的示例配置中，区域 0 是唯一带有 NSC 标志的区域，这意味着安全应用程序（稍后解释）将在这里安装 NSC 代码。区域 1、2 和 3 是当在启用 TrustZone-M 的非安全域中运行时唯一可能访问的内存区域。

如前所述，IDAU/SAU 只是 TrustZone-M 保护机制的第一个过滤级别。闪存和 RAM 通过额外的安全门进行保护，这些门可以是基于块的或基于水印的。STM32L552 微控制器配备了一个**全局 TrustZone 控制器**（**GTZC**），它包括一个基于水印的门控制器用于闪存和一个基于块的控制器用于定义安全/非安全 RAM 块。

## 闪存和安全的标志

在目标平台上，闪存可以配置为映射为一个单一的、连续的空间，或者通过激活双银行配置将其分成两半。为了我们的 TrustZone-M 示例，我们将保持闪存在一个单独的银行中。

在此配置中，当 TrustZone 启用时，我们可以在连续闪存空间的高半部分分配一个非安全区域，起始地址为 `0x08040000`。当闪存分为两个银行时，每个银行都可以配置其自己的独立安全水印。起始/结束地址之间的闪存区域被标记为安全，而所有未标记的区域都是非安全的。每个银行中的安全区域由选项字节 SECWMx_PSTRT 和 SECWMx_PEND 的值界定。如果界定符重叠——即 SECWMx_PEND 的值大于 SECWMx_PSTRT 的值——则整个区域被标记为非安全。

他们的值可以使用提供的程序员工具进行修改，如下所示：

```cpp
STM32_Programmer_CLI -c port=swd -ob SECWM1_PSTRT=0
   SECWM1_PEND=0x39
```

在单银行模式下，每个闪存扇区为 4096 B。通过设置这些选项字节，我们将前 64 个扇区（从 `0x00` 到 `0x39`）标记为安全，这留下了从地址 `0x08040000` 开始的闪存另一半，供我们的示例中的非安全应用程序使用。使用 `-ob displ` 选项启动的程序员工具将显示以下内容：

```cpp
   Secure Area 1:
     SECWM1_PSTRT : 0x0  (0x8000000)
     SECWM1_PEND  : 0x39  (0x8039000)
```

## GTZC 配置和基于块的 SRAM 保护

在参考平台的 TrustZone 控制器中存在一个用于控制访问的额外门。GTZC 的基于块的门组件允许我们配置仅安全位到 SRAM 的部分。STM32L552 上的 SRAM 分为两个主要银行：

+   SRAM1：192 KB 的 RAM 映射到地址 `0x08000000`

+   SRAM2：64 KB 的 RAM 映射到地址 `0x30000000` 并在 IDAU 中设置为 NSC

在我们的示例中，我们将 SRAM1 的高半部分标记为非安全，起始地址为 `0x2018000`。为此，GTZC 提供了两套寄存器，每套寄存器对应一个银行，以配置基于块的门到 RAM 的每一页。每个块代表 25 个 6B，每个 32 位寄存器通过每个块保留一个安全位，可以映射 32 页，也定义为 8 KB 的超级块。需要 24 个寄存器来映射 SRAM1 中的 24 个超级块，总共 192 KB，而映射 SRAM2 中的 64 KB 区域只需要 8 个。

就像 SAU 初始化一样，示例中采用的方法再次依赖于一个方便的宏，该宏给定一个内存区、超级块编号及其寄存器值，计算指向超级块的正确寄存器的地址，并生成正确的赋值语句：

```cpp
#define SET_GTZC_MPCBBx_S_VCTR(bank,n,val) \
(*((volatile uint32_t *)(GTZC_MPCBB##bank##_S_VCTR_BASE )\
           + n ))= val
```

这样我们就可以轻松地在循环中配置连续区域的基于块的门。安全世界应用程序示例使用以下函数来配置两个银行的基于块的门：

```cpp
 static void gtzc_init(void)
{
   int i;
  /* Configure lower half of SRAM1 as secure */
   for (i = 0; i < 12; i++) {
       SET_GTZC_MPCBBx_S_VCTR(1, i, 0xFFFFFFFF);
   }
   /* Configure upper half of SRAM1 as non-secure */
   for (i = 12; i < 24; i++) {
       SET_GTZC_MPCBBx_S_VCTR(1, i, 0x0);
   }
  /* Configure SRAM2 as secure */
   for (i = 0; i < 8; i++) {
       SET_GTZC_MPCBBx_S_VCTR(2, i, 0xFFFFFFFF);
   }
}
```

现在我们已经拥有了在系统上运行最简单的非安全应用程序所需的一切；我们在 SAU 中定义了非安全区域，设置了闪存分离的水印，并最终设置了基于块的门以启用对 SRAM1 高半部分的非安全访问。

然而，还有一个值得注意的方面，那就是配置对外围设备进行安全访问的可能性。

## 配置对外围设备的安全访问

在参考平台上，外围设备分为两类：

+   **可安全配置的外围设备**：外围设备不是直接连接到本地总线，而是通过由**TrustZone 安全控制器**（**TZSC**）控制的门系统连接

+   **信任区域感知的外围设备**：这些是与 TrustZone 机制集成的外围设备——例如，通过提供根据执行域提供单独接口来访问其资源

对于第一类外围设备，在安全和非安全域内配置安全访问和特权访问可以通过 GTZC 中的 TZSC 寄存器进行。在系统启动时，所有设备默认设置为安全，因此要启用对 UART、I2C、定时器和其他外围设备的访问，需要关闭与特定控制器关联的安全位。

信任区域感知的外围设备在安全域和非安全域都有寄存器银行。在下一个示例中，我们配置了三个 GPIO 控制器（`GPIOA`、`GPIOB`和`GPIOC`），这些控制器通过引脚 C7（绿色 LED）、B7（蓝色 LED）和 A9（红色 LED）连接到 Nucleo-144 板上的 LED。当启用 TrustZone 时，GPIO 控制器寄存器被分入两个区域。你会在示例代码中注意到安全和非安全应用程序中两个 LED 驱动接口之间的差异。在`led.h`的安全版本中，我们为 GPIO 控制器寄存器定义了以下地址基：

```cpp
#define GPIOA_BASE 0x52020000
#define GPIOB_BASE 0x52020400
#define GPIOC_BASE 0x52020800
```

在非安全世界应用程序中，相同的控制器映射到非安全外围设备地址空间：

```cpp
#define GPIOA_BASE 0x42020000
#define GPIOB_BASE 0x42020400
#define GPIOC_BASE 0x42020800
```

这确保了当在非安全域运行时，GPIO 配置只能通过分配给非安全空间的接口访问。

此外，每个 GPIO 控制器都提供了一个接口来安全地控制每个单个受控引脚。这是通过一个只写寄存器实现的，该寄存器控制安全和非安全访问，并带有对应每个引脚的标志。该寄存器称为 GPIOx_SECCFG，位于每个 GPIO 控制器空间的`0x24`偏移处。当在安全域运行时，该寄存器仅可写入。

在示例中，我们定义了设置/清除每个连接到三个 LED 的 GPIO 引脚的安全位的函数。例如，我们可以在将非安全应用程序部署到舞台之前设置红色 LED 的安全状态，通过调用`red_led_secure(1)`来禁止在应用程序中更改 LED 状态，该函数的实现如下：

```cpp
void red_led_secure(int onoff)
{
  if (onoff)
      GPIOA_SECCFG |= (1 << RED_LED);
  else
      GPIOA_SECCFG &= ~(1 << RED_LED);
}
```

我们的安全世界示例应用程序实际上在部署之前限制了蓝色和红色 LED 的访问，同时允许访问绿色 LED：

```cpp
    red_led_secure(1);
    green_led_secure(0);
    blue_led_secure(1);
```

在域切换之后，非安全应用将尝试开启所有三个 LED 灯，但实际上只有绿色 LED 灯会被点亮，其他 LED 灯将保持关闭状态，因为通过非安全接口的访问受到在安全世界中设置的 SECCFG 位的控制，并且对 GPIO 没有影响。

然而，闪烁蓝色 LED 仍然将使用一个特殊的非安全可调用接口来完成，这将在下一节“跨域转换”小节中解释。

在配置完所有可安全化和 TrustZone 感知的外设之后，我们最终准备好构建和安装两个域的固件镜像，并观察它们对系统的影响。

# 构建和运行示例

最后，我们将所学到的关于 TrustZone-M 的所有知识付诸实践，通过激活启用 TrustZone-M 所需的选项标志，并运行与执行域相关的两个软件组件。

## 启用 TrustZone-M

默认情况下，当我们的微控制器处于出厂状态时，TrustZone-M 是关闭的。开启 TrustZone 是一个单向操作，但通常不是不可逆的，除非结合其他硬件辅助保护机制，使得在嵌入式系统部署时无法禁用它。然而，一旦启用，禁用 TrustZone 需要比仅仅清除寄存器中的一个位更复杂的程序。

重要提示

请参考您的微控制器参考手册和应用笔记，并确保您理解启用或尝试禁用 TrustZone-M 在您的设备上的程序及其后果。

在参考平台上，为了启用 TrustZone，我们通过以下命令在选项字节中设置相关的标志：

```cpp
STM32_Programmer_CLI -c port=swd mode=hotplug -ob TZEN=1
```

一旦 TrustZone 被启用，我们就可以构建和安装安全固件。下一小节将突出构建系统安全部分时需要考虑的一些重要方面。

## 安全应用入口点

在安全世界链接脚本中定义的区域反映了安全固件所看到的系统资源。我们分配了一个覆盖 SRAM1 银行下半部分的 RAM 区域：

```cpp
    RAM (rwx) : ORIGIN = 0x20000000, LENGTH = 0x00018000
```

我们`.text`和`.data` LMS 最终位于 FLASH 区域，映射到其安全域地址：

```cpp
    FLASH (rx) : ORIGIN = 0x0C000000, LENGTH = 0x1000
```

在我们的简单示例中，4 KB 足以存储引导加载程序镜像。此外，我们定义了一个非安全可调用区域，该区域将包含我们安全 stub 的实现。这是一个专门用于从非安全世界通过预定义的跨域特殊功能调用来访问安全 API 的区域：

```cpp
    FLASH_NSC(rx): ORIGIN = 0x0C001000, LENGTH = 0x1000
```

参考平台上的安全应用入口点硬编码在选项字节中。在安装我们的镜像之前，我们必须确保`SECBOOTADD0`的选项字节配置为指向地址`0x0C000000`，这是安全系统视图下闪存的开始地址。如果由于任何原因该值已被修改，可以通过以下命令恢复：

```cpp
STM32_Programmer_CLI -c port=swd mode=hotplug -ob SECBOOTADD0=0x180000
```

这是因为`SECBOOTADD0`的粒度是 128 字节，所以设置`0x180000`的值将导致指向地址`0x0C000000`的指针。

最后这个值完成了选项字节的设置，因此我们最终准备好构建和安装安全应用程序。

一份选项字节及其值的列表，按顺序分配以配置示例代码的目标运行，可在本书的存储库中找到，在`Chapter11/option-bytes.txt`文件中。

## 编译和链接安全世界应用程序

如果你查看安全世界应用程序的 Makefile，你将注意到在构建过程中引入了两个新的标志。gcc 要求我们使用`-mcmse`标志来指示我们正在为 TrustZone 系统编译安全代码。通过添加此标志，我们告诉编译器生成`nsc_led.c`文件：

```cpp
void __attribute__((cmse_nonsecure_entry))
    nsc_blue_led_toggle(void)
{
  if ((GPIOB_ODR & (1 << BLUE_LED)) == (1 << BLUE_LED))
    blue_led_off();
  else
    blue_led_on();
}
```

`__attribute__((cmse_nonsecure_entry))`编译器属性告诉 gcc 为该函数生成 SG 存根。我们在链接器脚本中定义的`FLASH_NSC`部分用于存储我们配置的安全 API 的 SG 存根。SG 存根自动放置在名为`.gnu.sgstubs`的部分中，我们在示例链接器脚本中将它放置在`FLASH_NSC`区域：

```cpp
.gnu.sgstubs :
{
  . = ALIGN(4);
  *(.gnu.sgstubs*)   /* Secure Gateway stubs */
  . = ALIGN(4);
} >FLASH_NSC
```

额外的链接器标志`--cmse-implib`和`--out-implib=led_cmse.o`具有不同的目的，这不会直接影响安全域。当链接安全应用程序时，通过添加这些标志，我们要求链接器创建一个新的目标文件，这个文件将不会链接到最终的安全应用程序中。这个新的目标文件将链接到非安全世界应用程序中，并包含安全 API 的封装。这些封装准备从非安全到非安全可调用世界的跳转。换句话说，这个新的文件`led_cmse.o`是非安全世界对应的安全调用通过非安全可调用 SG 存根的实现。这些封装由链接器生成，并包含跳转到非安全可调用存根所需的代码。总结一下，为了构建安全应用程序，我们需要引入两组特定的标志：

+   `–mcmse`编译时标志，它告诉 gcc 我们正在为 TrustZone 生成安全代码，并为非安全入口点启用 SG 存根

+   `–cmse-implib`和`–out-implib=…`链接器标志，它们告诉链接器在目标文件格式中生成封装，这些封装随后将链接到非安全域以访问相关的安全 API 调用

一旦使用`make`构建，可以使用以下命令将安全固件映像上传到设备闪存：

```cpp
STM32_Programmer_CLI -c port=swd -d bootloader.bin 0x0C000000
```

微控制器的闪存现在已填充了安全固件，我们的增强型引导加载程序，它已准备好设置 TrustZone 控制器中的所有参数并准备非安全应用程序。显然的下一步是编译和安装非安全世界的对应版本。

## 编译和链接非安全应用程序

我们非安全应用的链接脚本定义了从非安全执行域看世界的边界。安全和 NSC 区域从这里无法访问。我们对闪存的看法仅限于其上半部分，可访问的 RAM 仅限于 SRAM1 银行的下半部分。非安全应用中的`target.ld`链接脚本如下定义这些区域：

```cpp
FLASH (rx) : ORIGIN = 0x08040000, LENGTH = 256K
RAM (rwx) :  ORIGIN = 0x20018000, LENGTH = 96K
```

从这一点开始，构建过程类似于构建没有 TrustZone 支持的正常应用。与它的安全对应物不同，非安全应用不需要任何特殊的编译器或链接器标志。

值得注意的是一个例外，即安全应用构建过程中生成的额外目标文件，允许非安全应用短暂地与安全世界交互。安全域和非安全域之间的合同由安全世界定义的安全 API 组成。在我们的例子中，我们只定义了一个单一的 secure 函数，`nsc_blue_led_toggle`。包含封装器（在我们的例子中称为`cmse_led.o`）的对象文件，在编译安全域代码时自动生成，并在非安全应用中链接，实际上它是满足安全应用中这些特殊符号符号依赖的代码。我们将在下一小节*跨域转换*中探讨此过程的细节。

一旦通过运行`make`构建了非安全应用，我们将非安全固件镜像上传到目标设备的内部闪存中，起始地址为`0x08040000`：

```cpp
STM32_Programmer_CLI -c port=swd -d image.bin 0x08040000
```

现在我们将更详细地研究从安全域到非安全域以及相反方向的转换，以了解新的 ARMv8-M 指令如何在转换操作中发挥作用，以及在这些情况下应该如何使用。

## 跨域转换

当我们的安全世界示例引导加载程序准备阶段非安全世界应用时，我们可以在准备 CPU 寄存器和执行跳转到非安全域的汇编代码中注意到一些差异。首先，当启用 TrustZone 时，`VTOR`系统寄存器被分页。这意味着有两个独立的寄存器分别保存向量表的偏移量，每个执行域一个——VTOR_S 和 VTOR_NS，分别对应安全域和非安全域。在跳转到非安全世界代码的入口点之前，VTOR_NS 寄存器应包含非安全世界应用的中断向量偏移量。正如我们所知，IV 位于二进制图像的起始处，因此引导加载程序`main`过程中的以下赋值确保最终我们的非安全域代码能够执行中断服务例程：

```cpp
  /* Update IV */
  VTOR_NS = ((uint32_t)app_IV);
```

在设置此系统寄存器之后，我们获取部署所需的两个重要指针，类似于我们为没有 TrustZone-M 功能的引导加载程序（如*第四章*中提出的）所做的那样，*启动过程*。这些指针存储在非安全应用二进制映像的前两个 32 位字中，分别是初始堆栈指针和包含`isr_reset`处理程序地址的实际入口点。在部署之前，我们将这两个地址读入局部堆栈变量中：

```cpp
  app_end_stack =
     (*((uint32_t *)(NS_WORLD_ENTRY_ADDRESS)));
  app_entry =
     (void *)(*((uint32_t *)(NS_WORLD_ENTRY_ADDRESS + 4)));
```

在我们的示例中，我们提前为非安全应用确定堆栈区域的大小，如下计算允许的堆栈最低地址：

```cpp
  app_stack_limit = app_end_stack - MAX_NS_STACK_SIZE;
```

然后，我们将此值赋给 MSPLIM_NS 寄存器。MSPLIM_NS 是一个特殊寄存器，因此，像往常一样，我们必须使用`msr`指令：

```cpp
  asm volatile("msr msplim_ns, %0" ::"r"(app_stack_limit));
```

然后，我们设置新堆栈指针的值，一旦域转换完成，它将替换 SP：

```cpp
  asm volatile("msr msp_ns, %0" ::"r"(app_end_stack));
```

实际跳转到非安全代码的地方与我们在*第四章*中介绍的先前引导加载程序有很大的不同，*启动过程*。首先，我们必须确保跳转的地址调整以符合 ARMv8 转换中使用的约定。我们从二进制映像中读取到`app_entry`局部变量的值实际上是奇数，这是在相同域内跳转时给 PC 寄存器分配新值时的经典要求——例如，在 ARMv7-M 中使用`mov pc, ...`指令，如*第四章*中示例引导加载程序中的那样。在 ARMv8-M 中，同时执行跳转和域转换到非安全世界的指令是`blxns`。然而，在调用`blxns`或任何暗示跳转到非安全地址的指令时，我们必须确保跳转的目标地址的最低有效位被关闭。因此，在执行`blxns`之前，我们将`app_entry`的值减一：

```cpp
  /* Jump to non-secure app_entry */
  asm volatile("mov r12, %0" ::"r"
     ((uint32_t)app_entry - 1));
  asm volatile("blxns   r12" );
```

这是在最终部署我们的非安全应用之前，在安全域中执行的最后一个指令。如果我们使用调试器在执行这些最后指令时检查寄存器的值，我们可以看到 CPU 寄存器的值正在更新，然后最终，SP 寄存器将指向非安全域中的新上下文。

从这一点开始，任何尝试跳回安全域的行为当然是不允许的，并且将生成一个异常。然而，正如我们之前提到的，放置在 NSC 区域中的函数的目的是为了从非安全域提供临时和受控的安全函数执行。

在我们的示例中，在过渡到非安全执行域之前，我们通过设置`GPIOx_SECCFG`寄存器中的相应位，对与三个 LED 相关的 GPIO 线的访问施加了一些限制，正如本章之前在*配置对外设的安全访问*小节中解释的那样。

当示例的两个映像都上传到目标平台时，我们可以通过观察三个 LED 来观察电源循环和效果。重启后，我们应该看到启动时打开并保持开启状态的红 LED，同时安全代码在引导加载程序中运行。经过任意数量的循环旋转后，给我们足够的时间检查 LED 状态，红 LED 将关闭并处于安全状态。蓝色 LED 也通过在部署前执行的`blue_led_secure(1)`调用而处于安全状态。绿色 LED 未处于安全状态，可以在非安全域中正常访问。

当非安全应用启动时，我们可以看到绿色 LED 常亮，而蓝色 LED 快速闪烁。后者之所以可能，是因为非安全应用可以访问安全 API 内的一个功能。

我们可以通过在安全世界的**elf**文件上运行`arm-none-eabi-objdump –D`来查看此函数生成的汇编代码。我们立即注意到生成的非安全可调用函数桩实际上是一个放置在非可调用部分开头的简短过程：

```cpp
0c001000 <nsc_blue_led_toggle>:
c001000:   e97f e97f   sg
c001004:   f7ff bdd2   b.w c000bac
              <__acle_se_nsc_blue_led_toggle>
```

在 NSC 区域运行的代码中最有趣的部分是使用特殊的汇编指令`sg`，这是 ARMv8-M 中引入的新指令，其特定目的是从非安全域实现安全调用。此指令准备将分支到安全空间中的安全调用，并且仅在从非安全可调用区域执行时才是合法的。

此外，请注意，实际实现实际上包含在由编译器生成的`__acle_se_nsc_blue_led_toggle`函数中，并放置在闪存的 S 区域。

通过将生成的对象包含在最终映像中并以相同方式反汇编非安全应用，生成的`nsc_blue_led_toggle`覆盖层的汇编代码应该看起来像以下这样：

```cpp
080408e8 <__nsc_blue_led_toggle_veneer>:
80408e8:   f85f f000   ldr.w   pc, [pc]    ; 80408ec \
                       <__nsc_blue_led_toggle_veneer+0x4>
80408ec:   0c001001
```

从非安全域调用安全函数的过程的结论位于实际安全函数切换蓝色 LED 的实现尾部，即`__acle_se_nsc_blue_led_toggle`：

```cpp
c000bee:   4774        bxns    lr
```

这应该对我们来说已经很熟悉了，因为它实际上是之前见过的`bxlns`指令的非链接版本，它执行跳转到存储在链接寄存器中的非安全覆盖层的返回地址，同时返回到非安全域。以下清单是本章示例中当从 NS 执行域调用安全函数时涉及步骤的回顾：

1.  非安全世界代码调用`nsc_blue_led_toggle`的包装器，该包装器在编译安全代码时实现，并在链接到非安全应用程序的`cmse_leds.o`对象中。

1.  包装器知道 NSC 区域中的 SG 占位符位置。这个区域可以从安全世界执行，同时被放置在安全固件中的特定区域。然后包装器继续跳转到 SG 占位符。

1.  SG 占位符调用`sg`指令，启动到安全世界的转换，然后跳转到实际实现，`__acle_se_nsc_blue_led_toggle`。现在它在安全域中执行，执行请求的操作（在我们的例子中，这是切换连接到蓝色 LED 的 GPIO 线的值）。

1.  当程序终止时，安全功能通过使用`bxns`指令返回到非安全世界，同时跳转回非安全世界原始调用者的地址。

尽管很简单，我们的例子展示了如何配置和使用所有需要的特性来分离两个执行域，以及用于实现两个世界之间交互的机制。在安全域中这些交互的设计将决定提供给非安全应用程序的能力。转换的边界和接口就像两部分之间的合同，由硬件本身强制执行，多亏了 TrustZone-M。

# 摘要

ARMv8-M 是 ARM 为现代微控制器定义的最新架构。它通过集成几个新功能扩展并完善了其前身 ARMv7-M 的能力。对于这种新型架构设计最重要的改进是实现 TEE 的可能性，通过分离执行域并创建一个沙盒环境来执行非安全应用程序。

在实际场景中，这为不同提供者的应用程序部署提供了灵活性，这些应用程序在访问系统上的功能和资源方面具有不同的信任级别。

在最后一章中，我们分析了 TrustZone-M 技术中可用的机制。TrustZone-M 可以在 ARMv8-M 系统上激活，目的是集成一个强大的、硬件辅助的解决方案，旨在保护系统组件免受安全域中运行的系统监督组件未明确授权的任何访问。
