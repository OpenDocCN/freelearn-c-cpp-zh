# 前言

程序通常需要分配和管理内存，无论它们是用哪种编程语言编写的。然而，为什么以及如何做这取决于语言和应用领域：实时系统、嵌入式系统、游戏和传统的桌面应用程序都有不同的需求和约束，并且没有一种单一的、通用的最佳方法可以解决所有问题。

本书展示了现代 C++如何让程序员编写更简单、更安全的程序，同时也展示了该语言如何使程序员能够控制内存分配机制，并确保程序遵守它们面临的约束。从语言的基本概念——对象的生存期和内存组织开始，你将学习如何编写自己的容器和分配器，以及如何调整分配操作符的行为以满足你的需求。根据你的需求，你将能够编写出更小、更快、更可预测……并且更安全的程序。

# 这本书面向的对象

这本书是为那些有一定编程经验并且喜欢高级和低级编程的个人所写的。如果你有泛型编程和并发编程的先验经验，将会使阅读体验更加愉快。

更具体地说，如果你（a）认为在 C++中管理内存很困难但愿意重新审视它，（b）希望更好地控制程序管理内存的方式，或者（c）希望程序更小、更快、更安全，那么这本书是为你写的。当然，如果你来自 C++背景，你可能会从这本书中受益，但即使你通常用其他语言编程，并想看看 C++允许你做什么，这本书也会很有帮助。这本书对任何程序员都有帮助，但如果你在受限制的环境中编程（如嵌入式系统或游戏机）或在其他需要严格控制资源分配机制的应用领域编程，你可能会发现它特别有用。谁知道呢，你可能甚至会喜欢它！

# 这本书涵盖的内容

*第一章*，*对象、指针和引用*，讨论了 C++语言中对象模型的基本概念，为我们提供了一个共同的基本词汇。

*第二章*，*需要注意的事项*，探讨了 C++的一些棘手方面，更具体地考察了可能导致我们陷入麻烦的低级编程技巧；我们将探讨这些技巧可能导致的麻烦类型。

*第三章*，*类型转换和 cv-限定符*，考察了我们可用的工具，这些工具可以强制类型系统满足我们的需求，并讨论了如何以合理的方式使用这些有时相当锋利的工具。

*第四章*，*使用析构函数*，探讨了 C++的这一个重要方面，它使得编写负责管理资源（尤其是内存）的对象成为可能。

*第五章*, *使用标准智能指针*，提供了如何从当代 C++编程的重要部分中受益的见解，这部分将内存管理的责任写入类型系统。

*第六章*, *编写智能指针*，探讨了编写标准智能指针的自制版本的方法，以及我们如何设计自己的智能指针来覆盖标准库尚未覆盖的领域。

*第七章*, *重载内存分配操作符*，展示了我们可以提供自己的内存分配操作符版本的各种方法，并解释了为什么这样做可能是个好主意。

*第八章*, *编写一个简单的内存泄漏检测器*，将我们新的内存管理技能应用于编写一个工作（尽管简单）的工具，以检测内存泄漏，这种方式对用户代码几乎是透明的。

*第九章*, *非典型分配机制*，探讨了标准内存分配操作符的一些不寻常的应用（和重载），包括非抛出版本和其他处理“奇异”内存的版本。

*第十章*, *基于区域的内存管理和其他优化*，使用我们的内存管理技能使程序执行得更快，行为更确定，并从特定领域或特定应用的知识中受益。

*第十一章*, *延迟回收*，探讨了我们可以编写程序，在程序执行过程中选择的时间点自动回收动态分配的对象。

*第十二章*, *使用显式内存管理编写通用容器*，解释了如何编写两个高效的通用容器，这些容器可以自己管理内存，并讨论了这种做法的异常安全性和复杂性权衡。

*第十三章*, *使用隐式内存管理编写通用容器*，回顾了上一章中编写的容器，以查看从显式内存管理方法转向依赖于智能指针的隐式方法的影响。

*第十四章*, *使用分配器支持编写通用容器*，回顾了我们自制的容器，以查看如何通过分配器定制内存管理，涵盖了从 C++11 之前的分配器到当代分配器，以及 PMR 分配器。 

*第十五章*, *当代问题*，展望了近未来的情况，并检查了 C++中一些最近（截至本书编写时）与内存管理相关的功能，以及 C++26 和 C++29 中语言的一些有趣的候选新增功能。

*附录**：您应该知道的事情*，提供了一些可以帮助您充分利用本书的技术背景，但这些可能不是众所周知的知识。根据需要参考它，它在那里为您服务！

# 为了充分利用本书

*您需要一个当代的 C++编译器，理想情况下至少支持 C++20，最好是 C++23。本书不需要其他工具，但您当然可以使用您喜欢的代码编辑器，并在您前进的过程中尝试您遇到的示例* *。

*为了保持标准的 C++，从可移植和安全的视角出发，我们特别留意。您会遇到一些使用非可移植代码的示例，这些示例会被明确标识* *。

*代码示例已在三个不同的编译器上进行了测试，本书 GitHub 仓库中的示例除了实际源代码外，还包含在线版本（在注释中）的链接，您可以对其进行修改和适配，以满足您的需求* *。

**如果您使用的是本书的数字版，我们建议您亲自输入代码或从本书的 GitHub 仓库（下一节中提供链接）获取代码。这样做将帮助您避免与代码的复制和粘贴相关的任何潜在错误** **。**

*我希望您享受这种体验，并发现示例是您自己探索的有意思的起点* *。

# 下载示例代码文件

您可以从 GitHub 下载本书的示例代码文件[`github.com/PacktPublishing/C-Plus-Plus-Memory-Management`](https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management)。如果代码有更新，它将在 GitHub 仓库中更新。

我们还有其他来自我们丰富图书和视频目录的代码包，可在[`github.com/PacktPublishing/`](https://github.com/PacktPublishing/)找到。查看它们吧！

# 使用的约定

本书使用了多种文本约定。

`文本中的代码`：表示文本中的代码单词、数据库表名、文件夹名、文件名、文件扩展名、路径名、虚拟 URL、用户输入和 Twitter 昵称。以下是一个示例：“在这种情况下，编译器可以合法地将整个`f()`函数重写为`return g(*p)`，将`return *p`语句转换为不可达代码。”

代码块设置如下：

```cpp
int g(int);
int f(int *p) {
   if(p != nullptr)
      return g(*p); // Ok, we know p is not null
   return *p; // oops, if p == nullptr this is UB
}
```

当我们希望您注意代码块中的特定部分时，相关的行或项目将以粗体显示：

```cpp
class X {
public:
   // #0 delegates to #1 which delegates to #0 which...
   X(float x) : X{ static_cast<int>(x) } { // #0
   }
```

任何命令行输入或输出都应如下编写：

```cpp
Verbose(0)
Verbose(2)
Verbose(6)
Verbose(7)
```

小贴士或重要提示

看起来像这样。

# 联系我们

读者反馈始终欢迎。

**一般反馈**：如果您对本书的任何方面有疑问，请通过电子邮件 customercare@packtpub.com 联系我们，并在邮件主题中提及书名。

**勘误表**：尽管我们已经尽一切努力确保内容的准确性，但错误仍然可能发生。如果你在这本书中发现了错误，我们将不胜感激，如果你能向我们报告这个错误。请访问[www.packtpub.com/support/errata](http://www.packtpub.com/support/errata)并填写表格。

**盗版**: 如果你在互联网上以任何形式遇到我们作品的非法副本，如果你能提供其位置地址或网站名称，我们将不胜感激。请通过版权@packt.com 与我们联系，并提供材料的链接。

**如果你有兴趣成为作者**：如果你在某个领域有专业知识，并且你感兴趣的是撰写或为书籍做出贡献，请访问[authors.packtpub.com](http://authors.packtpub.com)。

# 分享你的想法

一旦你阅读了*C++内存管理*，我们很乐意听听你的想法！请[点击此处直接进入此书的亚马逊评论页面](https://packt.link/r/1805129805)并分享你的反馈。

你的评论对我们和科技社区都很重要，并将帮助我们确保我们提供高质量的内容。

# 下载此书的免费 PDF 副本

感谢您购买此书！

你喜欢在路上阅读，但又无法携带你的印刷书籍到处走吗？

你的电子书购买是否与你的选择设备不兼容？

别担心，现在，每购买一本 Packt 书籍，你都可以免费获得该书的 DRM 免费 PDF 版本。

在任何地方、任何设备上阅读。直接从你最喜欢的技术书籍中搜索、复制和粘贴代码到你的应用程序中。

优惠远不止于此，你还可以获得独家折扣、时事通讯和每日免费内容的每日电子邮件。

按照以下简单步骤获取优惠：

1.  扫描下面的二维码或访问以下链接

![](img/B21071_QR_Free_PDF.jpg)

[`packt.link/free-ebook/978-1-80512-980-6`](https://packt.link/free-ebook/978-1-80512-980-6)

1.  提交你的购买证明

1.  就这些！我们将直接将免费 PDF 和其他优惠发送到你的邮箱

# 第一部分：C++中的内存

在本部分，我们将就 C++对象模型的一些关键方面建立一个常用词汇。这包括讨论诸如什么是对象、什么是引用以及 C++如何表示内存等观点；在编写底层代码时，我们需要进行一些有风险或微妙的操作（以及由此产生的后果）；以及如何以不会对我们造成伤害的方式强制类型系统满足我们的需求。本部分收集的知识将作为后续章节构建的基础。

本部分包含以下章节：

+   *第一章*，*对象、指针和引用*

+   *第二章*，*注意事项*

+   *第三章*，*类型转换和 cv-限定符*
