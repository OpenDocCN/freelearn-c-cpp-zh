# 第十一章：*第十章*

# 学习

## 引言

当你开始做这些事情时，无论是写 iPhone 应用、UNIX 迷你计算机软件还是未来编程的任何形式，你不知道如何做；你必须学习。也许你参加了一个培训课程，或者获得了计算机科学学位。也许你读了一两本书。无论如何，你开始时一无所知，最后……有一些知识。

这还没有结束。正如刘易斯·卡罗尔所说：

*你需要尽你所能奔跑，才能保持在原地。*

他是在谈论红后赛跑，但我在谈论学习和个人发展。如果你在读完第一本书后就停止了，你可能作为初学者程序员来说是“OK”的，但如果图书馆旁边的那位女士又读了一本书，那么她就会领先一步。

我们生活在一个经常被称为知识经济的时代。弗朗西斯·培根说，“知识就是力量”。如果你不学习，不根据你所学的东西来提升自己，那么你将落后于那些人。你的教育就像红后的赛跑，不断地奔跑以保持在原地。

## 尽可能多做

没有所谓的学习过多（尽管“工作不足”的真正问题有时会在大量学习附近被发现）。并非所有的教育都来自正式的设置，如培训或大学课程。（实际上，许多大学计算机科学课程的材料现在可以通过 iTunes U 和 Coursera 等计划免费获得。这可以成为一些有趣的午餐阅读，但我发现当我有一个教授课程的框架和提交截止日期的压力时，我学得更好。话虽如此，你不是我，你可能从更轻松的学习环境中受益。）在午餐时间阅读一本书、杂志文章或博客文章可能会有很大帮助，参加鸟类的开发者会议也是如此。

像培训课程和会议这样的大项目显然需要更大的时间投入。显然，有“工作不足”这样的事情，这是你需要解决的问题。如果你是自雇的，那么你需要平衡机会成本（通过参加课程，你将放弃多少工作？）和财务成本与收益（通过参加课程，你会变得多好？你将能够完成多少额外的工作？你将在会议上遇到哪些有价值的联系人？）。

当然，如果你有工作，这个决定可能是由你的经理为你做出的。如果你知道培训课程如何与公司的方向相匹配，你可以帮助这个决定……但我将把这个留给第十二章和第十三章关于商业和团队合作的章节。

## 不要局限于自己的学科

每个领域都有其拥护者和超级英雄：那些有成千上万名追随者的人，他们的博客文章总是被阅读和引用，并在所有会议上发言。人们会向这些拥护者寻求分析和建议，以指导他们的社区如何运作。通常，一个领域的领导者会被与“他们”，即另一个领域的领导者进行对比：那个在 iPhone 上编程的人是“我们”中的一员，而在另一个房间里发表演讲的 Android 程序员是在与“他们”对话。

这种“我们”和“他们”的定义毫无意义。它需要保持足够的流动性，以便总能找到新的“他们”。回顾我的历史小角落，我可以看到一些随着时间的推移而来又去的区别：Cocoa 与 Carbon；CodeWarrior 与 Project Builder；Mach-O 与 CFM；iPhone 与 Android；Windows 与 Mac；UNIX 与 VMS；BSD 与 System V；SuSE 与 Red Hat；RPM 与 dpkg；KDE 与 GNOME；Java 与 Objective-C；浏览器与本地；点与括号。

有时候，需要从不同领域的一个想法来给你自己工作带来新的视角。例如，我发现通过倾听函数式编程社区的人，我得到了很多关于编写面向对象代码的新想法。你可能会发现相反的情况是真实的，或者通过倾听一些 C#程序员，你可能会找到编写 Java 代码的新方法。

你甚至可能会发现，暂时放下程序员的工作，去其他领域学习一段时间会激发你的灵感——或者至少让你放松，之后以全新的状态回到编码。关键是，如果你只关注自己的狭窄学科，而排除所有其他学科，你最终会排除掉很多聪明的人和想法。

## 将其付诸实践

在历史的各个阶段，我学过各种语言，包括人际和计算机编程语言。我唯一记得的只是那些我经常使用的。

我预计这对你来说也是一样的。我之所以预计这一点，并不是因为我相信每个人都像我一样，而是因为这在理论上有依据。**科尔布学习周期**——[`www.businessballs.com/kolblearningstyles.htm`](http://www.businessballs.com/kolblearningstyles.htm)表明，有四个过程构成了学习的实践：

+   **具体经验**：实际上做某件事。

+   **反思观察**：分析你（或其他人）是如何做某件事的。

+   **抽象概念化**：构建一个模型，说明事情应该如何做。

+   **积极实验**：只是玩玩橡皮泥，看看会出来什么。

并非每个人都经历过这个循环中的所有项目，但大多数人都是从某个地方开始的，并至少通过几个点进行进步，可能按照展示的顺序（承认作为一个循环，它应该是循环的）。因此，几乎每个学到东西的人都会经历实验或构建经验：不尝试很难学到东西。

如果你不尝试，很难将你所学的知识适应到你所做的其他事情中。一个想法本身并不能真正做任何事情；当它付诸实践时，它就会与其他想法和技术相结合，增加一些有价值的东西。

## 协作并分享你所学的知识

分享你所学的东西有很多好处。首先，你分享给每个人的经历都不同，他们可以告诉你你所学的知识如何（或不如何）适用于他们的情境。这种洞察力可以给你一个更全面的了解你所学的知识，特别是它可能存在的局限性。会议演讲和书籍往往带有一种说服性的倾向——并不是因为作者在说谎，而是因为如果你离开后想要应用你所学的知识，材料会更有成功的机会。

听取那些在你想要做的事情在特定情况下是否有效（或无效）的人的意见，可以让你对某个概念及其应用有一个比仅仅依赖你最初发现的第一个来源更全面的了解。作为回报，你可能会向你交谈的人讲述你自己的经验和问题，这样你们双方都能学到东西。

这就是我热衷于共享学习的原因——每个人都受益。这包括如果你在一个正式的学习环境中，如培训课程或班级中合作，老师也会受益。即使你的经验比老师少得多，你也会有一些独特的见解和想法，这些见解和想法在公开场合比保持沉默更有用。

如 *Communications of the ACM* 这样的出版物经常涵盖与教学计算相关的问题。确实，在撰写时的当前期号中，**两篇文章**—[`cacm.acm.org/magazines/2012/11/156579-learning-to-teach-computer-science/fulltext **articles**—http://cacm.acm.org/blogs/blog-cacm/156531-why-isnt-there-more-computer-science-in-us-high-schools/fulltext`](http://cacm.acm.org/magazines/2012/11/156579-learning-to-teach-computer-science/fulltext articles—http://cacm.acm.org/blogs/blog-cacm/156531-why-isnt-there-more-computer-science-in-us-high-schools/fulltext) 讨论了计算机科学教学的短缺。我相信要解决这些问题，我们需要从新手而不是专家那里获得反馈（专家们设法通过了初始学习阶段——无论可用的资源多么糟糕）。我们需要更多地了解目前是什么让初学者难以取得进步，如果我们想要扩大行业规模，让新同事能够快速达到比我们做得更好的水平。

当然，如果新手在和我们交谈，那么倾听新手会是最有效的；具体来说，告诉我们在哪些方面做得好，哪些方面出了问题。鼓励这种做法的一个好方法是以身作则。不幸的是，这似乎并不受欢迎。在 Objective-C 编程的世界里，两个优秀的博客内容聚合器是 **Cocoa 文献列表**—[`cocoalit.com`](http://cocoalit.com) 和 **iOS Dev Weekly**—[`iosdevweekly.com/issues/`](http://iosdevweekly.com/issues/)。也许我只是变得过于挑剔，但似乎这两个网站上的大部分内容都是教程和指南。这些内容要么重复了第一方文档中涵盖的主题，要么展示了作者创建的一些包装类，而没有深入探讨达到那里的艰辛。

我们真正需要理解的是，无论是新手还是经验丰富的开发者，实际上更接近于 **Stack Overflow**—[`www.stackoverflow.com`](http://www.stackoverflow.com) 的内容，而不是博客圈的内容。如果许多缺乏经验的程序员在解决如何让两个对象进行通信（而且确实有很多——[`stackoverflow.com/questions/6494055/set-object-in-another-class`](http://stackoverflow.com/questions/6494055/set-object-in-another-class)）的问题上有困难，那么也许面向对象编程（OOP）不是适合编程新手的范式；或者也许需要改变其教学方法。

因此，这是一个对那些想要提升编程领域的人的请求，让他们挖掘 Stack Overflow 和相关网站，以了解常见的问题——试图决定任何用户的经验水平可能会很困难，所以将问题组织成“新手问题”与“专家问题”将会很困难。这也是对那些在 Stack Overflow 上发帖有困难的人的请求。原因是什么？

+   通常，在构思一个好问题的过程中，你最终也会弄清楚答案是什么。这种努力并没有浪费在 Stack Overflow 上；你可以在发布问题时回答自己的问题，然后每个人都可以看到问题和解决方案。

+   声望系统（第一次近似）奖励好的问题和答案，所以你得到有用答案的机会很高。

+   如上所述，可以挖掘这样的问题和答案。

当然，有缺点：

+   重复的问题不容易衡量，因为它们通常会被关闭，并且经常被删除。或者人们会发现现有的问题覆盖了相同的内容（按照“规则”应该是这样），因此不会提出重复的问题。投票系统和查看次数必须用作问题“流行度”的代理；这是一个不精确的系统。

+   投票系统往往奖励陈词滥调而不是新颖的想法或技术准确性；被点赞的答案是“受欢迎的”，但这并不意味着“正确”。

一个更好的编程教学系统应该基于所有编程课程中教师收到的所有反馈的总和。但我们不太可能得到这个。与此同时，Stack Overflow 相当不错。我的意思是，你不应该只分享你学到的知识，还应该分享你遇到的难题。

## 学习机会

那么，你的培训预算已经用完，你喜欢的会议在上个月举行，而且一年内不会再有；就这样吗？你什么时候还能有机会让自己进入学习状态？

*一直如此*。以下是我如何挤时间进行额外学习的一些例子：

+   我每天通勤大约一个小时。这意味着每天有两个播客剧集，每周十个。

+   每周一次，我的开发团队有“代码俱乐部”，这是一个小时的会议，其中一位成员做演示或引导讨论。其他所有人被邀请提问或分享他们的经验。

+   午餐时间可以读一些文章。

+   我每个月参加一到两个当地的开发者小组。

你不一定需要深入研究某些信息才能使用它。仅仅知道它存在，并且你可以再次找到它，就足以在你的思维抽屉中给它留一个位置。当你将来遇到相关问题时，你可能会记得你在*这篇文章*中读到过它，或者在 Evernote 中做了*那个*笔记。然后，你可以回去找到你需要的数据。

当然，会议和培训课程确实是学习大量知识的好地方。一个原因是你可以（在某种程度上）放下其他一切，专注于正在提供的内容。

#### 虽然有些抱怨

在会议上看到的最令人难过的事情之一是有人在笔记本电脑上做工作，而不是专注于会议。他们错过了——不仅内容，还有与其他代表在下一个休息期间讨论的共享经验。由于噪音和投影图像，这不是一个良好的工作环境，而且他们也没有从会议中获得任何东西。

## 重新发现失落的知识

你可能会认为，随着软件领域的快速发展，我们现在所做的一切都是基于去年所做的一切，归纳证明有一个连续不断的历史将当前实践与 20 世纪 40 年代的“ENIAC 女孩”和巨像鸟联系起来。事实上，真相几乎正好相反；被视为过时的做法，与被综合到现代实践中的做法一样，可能会被拒绝和遗忘。

以编程为例，我分享自己的经历。我出生在微型计算机革命时期，第一代家用电脑。在这些机器上教授的编程基于 20 世纪 60 年代的 BASIC 语言或使用汇编器。结构化编程、面向对象编程、过程编程和函数式编程的进步都被忽视或被认为是不适合微编程的高级主题。直到很久以后，我才接触到“新”的概念，比如 1973 年的 C 语言，并不得不掌握任何形式的代码组织或模块化。

拥有一本关于计算机编程的历史书或当代文献集，很容易看出，我不是唯一一个忽视或失去学科早期成果的人。毕竟，敏捷编程的“自我组织团队”不就是对 Weinberg 的**适应性编程**的再发明——[`dl.acm.org/citation.cfm?id=61465`](http://dl.acm.org/citation.cfm?id=61465)？是否存在清晰的血统，或者这个概念已经被重新发明？用户体验的“新”领域真的与 Boehm 的**软件工程经济学**的“人际关系方面”——[`dl.acm.org/citation.cfm?id=944370`](https://dl.acm.org/citation.cfm?id=944370)有什么不同？正如*第八章，文档*中所述，许多开发者不再使用 UML；多久之后 UML 会被发明来取代它？

## 软件创作的教学

对于上述重新发现问题的缓解，可能是你付出巨大的努力，从近 70 年的文献中找出什么，识别相关部分，并从那里综合出一个关于软件创作的观点。那将是疯狂的。但在短期内，这可能是一条唯一的途径。

和许多人一样，我是通过实验、阅读不同质量的书籍和杂志来学习编程的。这意味着，和许多程序员一样，我的形成性经验并没有受到一致的编程教学法理论的指导（或者根据你的立场，是被污染的）；实际上，我认为这样的理论并不存在。编程教学由专业培训师和大学系所进行，确实，同一所大学的不同系所也会以不同的方式教授编程（正如我在其中教授编程时发现的）。

没有一套一致的知识体系被应用或甚至被引用，不同的课程会教授非常不同的内容。我说的不是在语言习惯层面的差异，这种差异在所有类型的教学中都是真实的；你可能会从两位不同的老师那里学习同一种编程语言，并发现两组完全不同的概念集。

这与编程仅仅是一个解决问题的工具的想法是一致的；不同的课程会针对解决不同的问题而编写。但这意味着新手程序员之间没有共享的经验和知识集合；我们注定要在职业生涯的前几年重复别人的错误。

不幸的是，我并没有快速解决这个问题的方法：我所能做的就是让你意识到，在行业中很可能有大量的经验是你甚至没有能够加以利用的。你为了发现、理解和分享这些经验所付出的努力取决于你自己，但希望这一章已经说服了你，你与社区分享的知识越多，你的工作和整个社区的工作就会越好。

我所学习的特定材料在描述操作符的工作原理和如何使用语言的关键词方面内容丰富，但在组织、规划和可读性方面却显得不足（关于代码可读性的意义在*第十一章，批判性分析*中有论述）；也就是说，关于编写代码之外的一切，以及编写*可用的*代码的一切。是的，我学会了如何使用 GOSUB，但不知道*何时*使用 GOSUB。

在这些编码的其他方面，有很多好的资料。例如，在组织方面，即使在自我学习编程的时候，也有书籍解释了这些内容，并且做得很好：**《计算机程序的构造与解释》**——[`mitpress.mit.edu/sicp/full-text/book/book.html`](http://mitpress.mit.edu/sicp/full-text/book/book.html)；**面向对象编程：一种进化方法**——[`books.google.co.uk/books/about/Object_oriented_programming.html?id=U8AgAQAAIAAJ&redir_esc=y`](http://books.google.co.uk/books/about/Object_oriented_programming.html?id=U8AgAQAAIAAJ&redir_esc=y)；**面向对象软件构造**——[`docs.eiffel.com/book/method/object-oriented-software-construction-2nd-edition`](http://docs.eiffel.com/book/method/object-oriented-software-construction-2nd-edition)。问题不是信息不存在，而是我不知道我需要学习这些内容。如果你愿意，这是一个未知的未知。

你可以争论说，代码的组织是一个中级或高级话题，超出了入门书籍或培训课程的范畴。或者你可以争论说，虽然它确实是初学者应该知道的东西，但将它与“这是如何使用`+`运算符”的内容放在同一本书中，会使事情看起来过于复杂，可能会让人望而却步。

首先，让我提出一个立场，即这两个说法都不正确。我通过类比罗杰·彭罗斯的书籍《现实之路》——[`books.google.co.uk/books/about/The_Road_to_Reality.html?id=ykV8cZxZ80MC`](http://books.google.co.uk/books/about/The_Road_to_Reality.html?id=ykV8cZxZ80MC) 来进行论证，这本书从基本的数学（毕达哥拉斯定理、几何学等）开始，最终结束于量子引力和宇宙学。每一章都极具挑战性，比上一章更难，但只要理解了前面的内容，就可以理解。人们（包括我自己）都曾花费数年时间来研读这本书——在开始下一章之前，先完成每一章末尾的练习。然而，这仅仅是一本单本书，长度不超过 1,100 页。

对于计算来说，是否也可以做到同样的事情？是否可以有一本“虚拟现实之路”，将人们从编程入门带到软件创作的全面概述？我会这么说：这个领域的范围比理论物理学要小得多。

现在，这里有一个不同的论点。我会接受这个观点，即这个领域要么太大，要么太复杂，以至于无法全部放入一个地方，即使是对于有强烈动机的学习者来说也是如此。在这种情况下，需要的是一个课程：一个关于软件创作不同部分之间关系的指南，它们建立在其他部分之上，以及一个建议的学习顺序。

当然，这样的课程是存在的。在英国，**A-level 计算机科学**——[`www.cie.org.uk/qualifications/academic/uppersec/alevel/subject?assdef_id=738`](http://www.cie.org.uk/qualifications/academic/uppersec/alevel/subject?assdef_id=738)不仅教授编程，还教授如何识别可以用计算机解决的问题、设计并构建解决方案以及记录它。那么接下来该怎么做呢？能够估计构建解决方案的成本和风险会有所帮助；在由多个人构建的解决方案上工作；维护现有软件；测试拟议的解决方案……这些都是建立在所呈现主题之上的。它们由**软件工程研究生课程**——[`www.cs.ox.ac.uk/softeng/courses/subjects.html`](http://www.cs.ox.ac.uk/softeng/courses/subjects.html)涵盖；在学习如何编程和作为专业程序员提高之间似乎存在某种差距，在那里你只能依靠自己。

这些课程仅是为授课课程设计的。难道自学成才的程序员应该被排除在外吗？（该领域的某些人可能会说，是的；编程应该是一门只有专业人士才能从事的专业学科——或者至少应该有一个只有知情者才能获得的指定**头衔**，就像任何人都可以成为营养师，但只有合格的人才能称自己为营养师一样。这些人中的一些人自称“软件工程师”，认为软件应该是一个专属的职业，就像工程学科一样；其他人则自称“软件工匠”，并以中世纪的行会作为他们追求专属性的模式。我将把对这些立场的评价留到以后。但现在，值得反思的是，对**任何**关于我们工作的描述都伴随着隐含的负担。）

关于编程的书籍系列有很多：例如，**Kent Beck 签名系列**——[`www.informit.com/imprint/series_detail.aspx?ser=2175138`](http://www.informit.com/imprint/series_detail.aspx?ser=2175138)关于管理方法和测试方法，或者**Spring Into**——[`www.informit.com/imprint/series_detail.aspx?st=61172`](http://www.informit.com/imprint/series_detail.aspx?st=61172)系列简短介绍。

这些已发表的系列通常集中在初学者水平或深入且专注于寻求特定任务信息的经验丰富的开发者。无论是通过某个出版商的编辑策划还是作为外部资源，从一种水平到另一种水平都没有明确的路线。尝试在网络上搜索“应该阅读哪些编程书籍”，你会为每个对这一主题发表过意见的程序员得到多个结果——就像 Jeff Atwood 多次写过的那样。

构建课程是件困难的事情——比列出你读过的书单，或者假装你读过，然后告诉人们他们必须读过这些书才能成为程序员还要困难。你需要决定哪些内容真正相关，哪些可以省略。你需要弄清楚不同的材料是否与一致的学习理论相符；从一本书中获得价值的人是否可以从另一本书中获得什么。你需要决定人们需要获得更多经验的地方，在继续前进之前需要尝试的事情，以及他们的课程告诉他们这样做是否合适。你需要接受不同的人以不同的方式学习，并准备好你的课程不会对每个人都有效的事实。

所有这些意味着，尽管有 45 年的系统计算机科学教育，但在软件教学的课程设置上仍然有*多种*课程的空间；帮助下一代程序员避免我们（以及我们之前和之前的人）所犯的错误的可能性是开放的；在本节开头描述的“英雄般的努力”需要重做，但只需要做几次。

## 反思性学习

许多高等教育机构推广反思性学习的概念，即通过内省和回顾分析你所学的，决定哪些做得好，哪些不好，并计划做出改变，以使好的部分胜过不好的部分。考虑到我们在本章中看到的情况——即有无数的信息来源，不同的人从不同的媒介中学习得很好，反思性学习是整理所有这些信息并决定哪些对你有效的好方法。

这绝不是一个新颖的想法。在他的书《计算机编程心理学》——[`www.geraldmweinberg.com/Site/Home.html`](http://www.geraldmweinberg.com/Site/Home.html)中，Gerald M. Weinberg 描述了一些程序员如何从讲座、书籍和音频记录中学习得很好。有些人——正如我们在讨论 Kolb 循环时所看到的——想要从实验开始，而有些人则想要从理论开始。当他告诉我们尝试这些事情并发现哪些对我们最有益时，他实际上是在告诉我们要*反思*我们的学习经历，并利用这种反思来改进这些经历。

反思性学习也是从日常经验中汲取教训的好方法。我这里有一本小笔记本，大约 4 年前，我每天都会根据当天的工作写一段话。我会思考我遇到的问题，以及我是否可以采取任何措施来解决它们。我也会思考哪些事情做得很好，以及我是否可以从这些成功中提炼出一些普遍的东西。以下是一个例子：

*将我们的代码审查流程委托给[同事]。我是否给了他足够的信息，并解释了为什么给他这个任务？在我的代码中发现了一个常见问题，由于向集合中插入* `nil` *而导致多次崩溃。在许多 ObjC 中，* `nil` *对象可以像正常对象一样使用，但不能在集合中使用，而且我已经知道这一点。为什么我在编写代码时会忽略这一点？专注于确保未来的代码中处理失败条件，并在代码审查中获得帮助以查看它们。追逐一个与[产品]相关的问题，结果发现这是我已经在主干上修复了但没有集成到我的工作分支中的问题。我本可以做些什么来更早地识别这个问题？频繁地将主干上的修复集成到我的分支上本可以消除这个问题。*

你不一定要把你的反思写下来，尽管我发现保持日记或博客确实能让我比完全的内省更有条理。从某种意义上说，这本书本身就是我的一种反思性学习练习。我在思考在我的编程生活中我不得不做的事情，这些事情并不是直接关于编写代码，而是在记录这些事情。在这个过程中，我决定有些事情值得进一步调查，了解更多关于它们的信息，并撰写关于这些发现的报告。
