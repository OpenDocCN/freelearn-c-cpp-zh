- en: Multithreading Implementation on the Processor and OS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理器和操作系统上的多线程实现
- en: The foundation of any multithreaded application is formed by the implementation
    of the required features by the hardware of the processor, as well as by the way
    these features are translated into an API for use by applications by the operating
    system. An understanding of this foundation is crucial for developing an intuitive
    understanding of how to best implement a multithreaded application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 任何多线程应用程序的基础是由处理器硬件实现所需功能以及这些功能如何被操作系统转换为应用程序使用的API所形成的。了解这个基础对于开发对多线程应用程序的最佳实现方式至关重要。
- en: This chapter looks at how hardware and operating systems have evolved over the
    years to arrive at the current implementations and APIs as they are in use today.
    It shows how the example code of the previous chapter ultimately translates into
    commands to the processor and related hardware.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨多年来硬件和操作系统是如何演变到当前的实现和API的，展示了前一章的示例代码最终如何转换为对处理器和相关硬件的命令。
- en: 'Topics covered in this chapter include the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题包括以下内容：
- en: The evolution of processor hardware in order to support multithreading concepts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了支持多线程概念而发展的处理器硬件的演变
- en: How operating systems changed to use these hardware features
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统如何改变以使用这些硬件特性
- en: Concepts behind memory safety and memory models in various architectures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种架构中内存安全和内存模型背后的概念
- en: Differences between various process and threading models by OSes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统之间各种进程和线程模型的差异
- en: Defining processes and threads
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义进程和线程
- en: Essentially, to the **operating system** (**OS**), a process consists of one
    or more threads, each thread processing its own state and variables. One would
    regard this as a hierarchical configuration, with the OS as the foundation, providing
    support for the running of (user) processes. Each of these processes then consists
    of one or more threads. Communication between processes is handled by **inter-process
    communication** (**IPC**), which is provided by the operating system.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，对于**操作系统**（**OS**）来说，一个进程由一个或多个线程组成，每个线程处理自己的状态和变量。可以将其视为分层配置，操作系统作为基础，为（用户）进程的运行提供支持。然后，每个进程由一个或多个线程组成。进程之间的通信由操作系统提供的**进程间通信**（**IPC**）来处理。
- en: 'In a graphical view, this looks like the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在图形视图中，这看起来像下面这样：
- en: '![](img/00007.gif)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00007.gif)'
- en: Each process within the OS has its own state, with each thread in a process
    having its own state as well as the relative to the other threads within that
    same process. While IPC allows processes to communicate with each other, threads
    can communicate with other threads within the process in a variety of ways, which
    we'll explore in more depth in upcoming chapters. This generally involves some
    kind of shared memory between threads.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统中的每个进程都有自己的状态，进程中的每个线程也有自己的状态，相对于该进程中的其他线程。虽然IPC允许进程之间进行通信，但线程可以以各种方式与进程内的其他线程进行通信，我们将在接下来的章节中更深入地探讨这些方式。这通常涉及线程之间的某种共享内存。
- en: 'An application is loaded from binary data in a specific executable format such
    as, for example, **Executable and Linkable Format** (**ELF**) which is generally
    used on Linux and many other operating systems. With ELF binaries, the following
    number of sections should always be present:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序是从特定的可执行格式的二进制数据中加载的，例如，**可执行和可链接格式**（**ELF**），通常用于Linux和许多其他操作系统。对于ELF二进制文件，应该始终存在以下数量的部分：
- en: '`.bss`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.bss`'
- en: '`.data`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.data`'
- en: '`.rodata`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.rodata`'
- en: '`.text`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.text`'
- en: The `.bss` section is, essentially, allocated with uninitialized memory including
    empty arrays which thus do not take up any space in the binary, as it makes no
    sense to store rows of pure zeroes in the executable. Similarly, there is the
    `.data` section with initialized data. This contains global tables, variables,
    and the like. Finally, the `.rodata` section is like `.data`, but it is, as the
    name suggests, read-only. It contains things such as hardcoded strings.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`.bss`部分基本上是分配未初始化的内存，包括空数组，因此在可执行文件中不占用任何空间，因为在可执行文件中存储纯零行是没有意义的。类似地，还有`.data`部分包含初始化数据。其中包括全局表、变量等。最后，`.rodata`部分类似于`.data`，但正如其名称所示，是只读的。其中包含硬编码的字符串等内容。'
- en: 'In the `.text` section, we find the actual application instructions (code)
    which will be executed by the processor. The whole of this will get loaded by
    the operating system, thus creating a process. The layout of such a process looks
    like the following diagram:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在`.text`部分，我们找到实际的应用程序指令（代码），这些指令将由处理器执行。整个内容将被操作系统加载，从而创建一个进程。这样的进程布局如下图所示：
- en: '![](img/00008.gif)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00008.gif)'
- en: This is what a process looks like when launched from an ELF-format binary, though
    the final format in memory is roughly the same in basically any OS, including
    for a Windows process launched from a PE-format binary. Each of the sections in
    the binary are loaded into their respective sections, with the BSS section allocated
    to the specified size. The `.text` section is loaded along with the other sections,
    and its initial instruction is executed once this is done, which starts the process.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从ELF格式二进制文件启动时进程的样子，尽管在内存中的最终格式在基本上任何操作系统中都大致相同，包括从PE格式二进制文件启动的Windows进程。二进制文件中的每个部分都加载到它们各自的部分中，BSS部分分配给指定的大小。`.text`部分与其他部分一起加载，并且一旦完成，将执行其初始指令，从而启动进程。
- en: In system languages such as C++, one can see how variables and other program
    state information within such a process are stored both on the stack (variables
    exist within the scope) and heap (using the new operator). The stack is a section
    of memory (one allocated per thread), the size of which depends on the operating
    system and its configuration. One can generally also set the stack size programmatically
    when creating a new thread.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在诸如C++之类的系统语言中，可以看到在这样的进程中变量和其他程序状态信息是如何存储在堆栈（变量存在于作用域内）和堆（使用new运算符）中的。堆栈是内存的一部分（每个线程分配一个），其大小取决于操作系统及其配置。在创建新线程时，通常也可以通过编程方式设置堆栈大小。
- en: In an operating system, a process consists of a block of memory addresses, the
    size of which is constant and limited by the size of its memory pointers. For
    a 32-bit OS, this would limit this block to 4 GB. Within this virtual memory space,
    the OS allocates a basic stack and heap, both of which can grow until all memory
    addresses have been exhausted, and further attempts by the process to allocate
    more memory will be denied.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作系统中，一个进程由一块内存地址组成，其大小由其内存指针的大小限制。对于32位操作系统，这将限制该块为4GB。在这个虚拟内存空间中，操作系统分配了一个基本的堆栈和堆，两者都可以增长，直到所有内存地址都被耗尽，进程进一步尝试分配更多内存将被拒绝。
- en: The stack is a concept both for the operating system and for the hardware. In
    essence, it's a collection (stack) of so-called stack frames, each of which is
    composed of variables, instructions, and other data relevant to the execution
    frame of a task.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈对操作系统和硬件都是一个概念。本质上，它是一组所谓的堆栈帧的集合，每个堆栈帧由与任务的执行框架相关的变量、指令和其他数据组成。
- en: In hardware terms, the stack is part of the task (x86) or process state (ARM),
    which is how the processor defines an execution instance (program or thread).
    This hardware-defined entity contains the entire state of a singular thread of
    execution. See the following sections for further details on this.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从硬件角度来看，堆栈是任务（x86）或进程状态（ARM）的一部分，这是处理器定义执行实例（程序或线程）的方式。这个硬件定义的实体包含了一个线程的整个状态。有关此内容的更多详细信息，请参见以下各节。
- en: Tasks in x86 (32-bit and 64-bit)
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: x86（32位和64位）中的任务
- en: 'A task is defined as follows in the Intel IA-32 System Programming guide, Volume
    3A:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在Intel IA-32系统编程指南第3A卷中，任务定义如下：
- en: '*"A task is a unit of work that a processor can dispatch, execute, and suspend.
    It can be used to execute a program, a task or process, an operating-system service
    utility, an interrupt or exception handler, or a kernel or executive utility."*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: “任务是处理器可以分派、执行和挂起的工作单元。它可以用于执行程序、任务或进程、操作系统服务实用程序、中断或异常处理程序，或内核或执行实用程序。”
- en: '*"The IA-32 architecture provides a mechanism for saving the state of a task,
    for dispatching tasks for execution, and for switching from one task to another.
    When operating in protected mode, all processor execution takes place from within
    a task. Even simple systems must define at least one task. More complex systems
    can use the processor''s task management facilities to support multitasking applications."*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: “IA-32架构提供了一种保存任务状态、分派任务执行和从一个任务切换到另一个任务的机制。在保护模式下，所有处理器执行都是在任务内部进行的。即使是简单的系统也必须定义至少一个任务。更复杂的系统可以使用处理器的任务管理设施来支持多任务应用程序。”
- en: This excerpt from the IA-32 (Intel x86) manual summarizes how the hardware supports
    and implements support for operating systems, processes, and the switching between
    these processes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: IA-32（Intel x86）手册中的这段摘录总结了硬件如何支持和实现对操作系统、进程以及这些进程之间的切换的支持。
- en: It's important to realize here that, to the processor, there's no such thing
    as a process or thread. All it knows of are threads of execution, defined as a
    series of instructions. These instructions are loaded into memory somewhere, and
    the current position in these instructions is kept track of along with the variable
    data (variables) being created, as the application is executed within the data
    section of the process.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到，对于处理器来说，没有进程或线程这样的东西。它所知道的只是执行线程，定义为一系列指令。这些指令被加载到内存的某个地方，并且当前位置和变量数据（变量）的创建情况都在进程的数据部分中被跟踪，当应用程序在数据部分中执行时。
- en: Each task also runs within a hardware-defined protection ring, with the OS's
    tasks generally running on ring 0, and user tasks on ring 3\. Rings 1 and 2 are
    rarely used except for specific use cases with modern OSes on the x86 architecture.
    These rings are privilege-levels enforced by the hardware and allow for example
    for the strict separation of kernel and user-level tasks.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每个任务也在硬件定义的保护环中运行，操作系统的任务通常在环0上运行，用户任务在环3上运行。环1和2很少被使用，除非在x86架构的现代操作系统中有特定的用例。这些环是硬件强制执行的特权级别，例如严格分离内核和用户级任务。
- en: 'The task structure for both 32-bit and 64-bit tasks are quite similar in concept.
    The official name for it is the **Task State Structure** (**TSS**). It has the
    following layout for 32-bit x86 CPUs:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 32位和64位任务的任务结构在概念上非常相似。它的官方名称是**任务状态结构**（**TSS**）。对于32位x86 CPU，它的布局如下：
- en: '![](img/00009.gif)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00009.gif)'
- en: 'Following are the firlds:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是字段：
- en: '**SS0**: The first stack segment selector field'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SS0**：第一个堆栈段选择器字段'
- en: '**ESP0**: The first SP field'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ESP0**：第一个SP字段'
- en: 'For 64-bit x86_64 CPUs, the TSS layout looks somewhat different, since hardware-based
    task switching is not supported in this mode:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于64位x86_64 CPU，TSS布局看起来有些不同，因为在这种模式下不支持基于硬件的任务切换：
- en: '![](img/00010.gif)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00010.gif)'
- en: 'Here, we have similar relevant fields, just with different names:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有类似的相关字段，只是名称不同：
- en: '**RSPn**: SP for privilege levels 0 through 2'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RSPn**：特权级别0到2的SP'
- en: '**ISTn**: Interrupt stack table pointers'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ISTn**：中断堆栈表指针'
- en: Even though on x86 in 32-bit mode, the CPU supports hardware-based switching
    between tasks, most operating systems will use just a single TSS structure per
    CPU regardless of the mode, and do the actual switching between tasks in software.
    This is partially due to efficiency reasons (swapping out only pointers which
    change), partially due to features which are only possible this way, such as measuring
    CPU time used by a process/thread, and to adjust the priority of a thread or process.
    Doing it in software also simplifies the portability of code between 64-bit and
    32-bit systems, since the former do not support hardware-based task switching.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在32位模式下，x86 CPU支持任务之间的硬件切换，但大多数操作系统将每个CPU仅使用单个TSS结构，而不管模式如何，并且在软件中实际执行任务之间的切换。这部分是出于效率原因（仅交换变化的指针），部分是由于只有通过这种方式才可能的功能，例如测量进程/线程使用的CPU时间，并调整线程或进程的优先级。在软件中执行此操作还简化了代码在64位和32位系统之间的可移植性，因为前者不支持基于硬件的任务切换。
- en: During a software-based task switch (usually via an interrupt), the ESP/RSP,
    and so on are stored in memory and replaced with the values for the next scheduled
    task. This means that once execution resumes, the TSS structure will now have
    the **Stack Pointer** (**SP**), segment pointer(s), register contents, and all
    other details of the new task.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于软件的任务切换期间（通常通过中断），ESP/RSP等存储在内存中，并用下一个计划任务的值替换。这意味着一旦执行恢复，TSS结构现在将具有新任务的**堆栈指针**（**SP**）、段指针、寄存器内容和所有其他细节。
- en: The source of the interrupt can be based in hardware or software. A hardware
    interrupt is usually used by devices to signal to the CPU that they require attention
    by the OS. The act of calling a hardware interrupt is called an Interrupt Request,
    or IRQ.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 中断的来源可以是基于硬件或软件。硬件中断通常由设备用于向CPU发出信号，表示它们需要OS的注意。调用硬件中断的行为称为中断请求，或IRQ。
- en: A software interrupt can be due to an exceptional condition in the CPU itself,
    or as a feature of the CPU's instruction set. The action of switching tasks by
    the OS's kernel is also performed by triggering a software interrupt.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 软件中断可能是由CPU本身的异常条件引起的，也可能是CPU指令集的一个特性。OS内核通过触发软件中断来执行任务切换的操作。
- en: Process state in ARM
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ARM中的进程状态
- en: 'In ARM architectures, applications usually run in the unprivileged **Exception
    Level 0** (**EL0**) level, which is comparable to ring 3 on x86 architectures,
    and the OS kernel in EL1\. The ARMv7 (AArch32, 32-bit) architecture has the SP
    in the general purpose register 13\. For ARMv8 (AArch64, 64-bit), a dedicated
    SP register is implemented for each exception level: `SP_EL0`, `SP_EL1`, and so
    on.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在ARM架构中，应用程序通常在非特权的**异常级别0**（**EL0**）级别运行，这与x86架构上的ring 3相当，而OS内核在EL1中。ARMv7（AArch32，32位）架构将SP放在通用寄存器13中。对于ARMv8（AArch64，64位），为每个异常级别实现了一个专用的SP寄存器：`SP_EL0`，`SP_EL1`等。
- en: For task state, the ARM architecture uses **Program State Register** (**PSR**)
    instances for the **Current Program State Register** (**CPSR**) or the **Saved
    Program State Register** (**SPSR**) program state's registers. The PSR is part
    of the **Process State** (**PSTATE**), which is an abstraction of the process
    state information.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任务状态，ARM架构使用**程序状态寄存器**（**PSR**）实例来表示**当前程序状态寄存器**（**CPSR**）或**保存的程序状态寄存器**（**SPSR**）程序状态寄存器。PSR是**进程状态**（**PSTATE**）的一部分，它是进程状态信息的抽象。
- en: 'While the ARM architecture is significantly different from the x86 architecture,
    when using software-based task switching, the basic principle does not change:
    save the current task''s SP, register state, and put the next task''s detail in
    there instead before resuming processing.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然ARM架构与x86架构有很大不同，但在使用基于软件的任务切换时，基本原则并未改变：保存当前任务的SP，寄存器状态，并在恢复处理之前将下一个任务的详细信息放入其中。
- en: The stack
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆栈
- en: 'As we saw in the preceding sections, the stack together with the CPU registers
    define a task. As mentioned earlier, this stack consists of stack frames, each
    of which defines the (local) variables, parameters, data, and instructions for
    that particular instance of task execution. Of note is that although the stack
    and stack frames are primarily a software concept, it is an essential feature
    of any modern OS, with hardware support in many CPU instruction sets. Graphically,
    it can be be visualized like the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的部分中看到的，堆栈与CPU寄存器一起定义了一个任务。正如前面提到的，这个堆栈由堆栈帧组成，每个堆栈帧定义了该特定任务执行实例的（局部）变量、参数、数据和指令。值得注意的是，尽管堆栈和堆栈帧主要是软件概念，但它是任何现代操作系统的重要特性，在许多CPU指令集中有硬件支持。从图形上看，可以像下面这样进行可视化：
- en: '![](img/00011.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00011.jpeg)'
- en: The SP (ESP on x86) points to the top of the stack, with another pointer (**Extended
    Base Pointer** (**EBP**) for x86). Each frame contains a reference to the preceding
    frame (caller return address), as set by the OS.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: SP（x86上的ESP）指向堆栈顶部，另有另一个指针（x86上的扩展基指针（EBP））。每个帧包含对前一个帧的引用（调用者返回地址），由操作系统设置。
- en: When using a debugger with one's C++ application, this is basically what one
    sees when requesting the backtrack--the individual frames of the stack showing
    the initial stack frame leading up until the current frame. Here, one can examine
    each individual frame's details.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用调试器与C++应用程序时，当请求回溯时，基本上就是看到了堆栈的各个帧，显示了一直到当前帧的初始堆栈帧。在这里，可以检查每个单独帧的细节。
- en: Defining multithreading
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义多线程
- en: Over the past decades, a lot of different terms related to the way tasks are
    processed by a computer have been coined and come into common use. Many of these
    are also used interchangeably, correctly or not. An example of this is multithreading
    in comparison with multiprocessing.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几十年中，与计算机处理任务方式相关的许多不同术语已经被创造并广泛使用。其中许多也被交替使用，正确与否。其中一个例子是多线程与多处理的比较。
- en: 'Here, the latter means running one task per processor in a system with multiple
    physical processors, while the former means running multiple tasks on a singular
    processor simultaneously, thus giving the illusion that they are all being executed
    simultaneously:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，后者意味着在具有多个物理处理器的系统中每个处理器运行一个任务，而前者意味着在单个处理器上同时运行多个任务，从而产生它们都在同时执行的错觉：
- en: '![](img/00012.gif)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00012.gif)'
- en: Another interesting distinction between multiprocessing and multitasking is
    that the latter uses time-slices in order to run multiple threads on a single
    processor core. This is different from multithreading in the sense that in a multitasking
    system, no tasks will ever run in a concurrent fashion on the same CPU core, though
    tasks can still be interrupted.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 多处理和多任务之间的另一个有趣区别是，后者使用时间片来在单个处理器核上运行多个线程。这与多线程不同，因为在多任务系统中，没有任务会在同一CPU核上以并发方式运行，尽管任务仍然可以被中断。
- en: The concept of a process and a shared memory space between the threads contained
    within the said process is at the very core of multithreaded systems from a software
    perspective. Though the hardware is often not aware of this--seeing just a single
    task to the OS. However, such a multithreaded process contains two or many more
    threads. Each of these threads then perform its own series of tasks.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 从软件角度来看，进程和进程内的线程之间共享的内存空间的概念是多线程系统的核心。尽管硬件通常不知道这一点--只看到操作系统中的单个任务。然而，这样的多线程进程包含两个或多个线程。每个线程都执行自己的一系列任务。
- en: In other implementations, such as Intel's **Hyper-Threading** (**HT**) on x86
    processors, this multithreading is implemented in the hardware itself, where it's
    commonly referred to as SMT (see the section *Simultaneous multithreading (SMT)*
    for details). When HT is enabled, each physical CPU core is presented to the OS
    as being two cores. The hardware itself will then attempt to execute the tasks
    assigned to these so-called virtual cores concurrently, scheduling operations
    which can use different elements of a processing core at the same time. In practice,
    this can give a noticeable boost in performance without the operating system or
    application requiring any type of optimization.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他实现中，例如英特尔的x86处理器上的**超线程**（**HT**），这种多线程是在硬件中实现的，通常被称为SMT（有关详细信息，请参见*同时多线程（SMT）*部分）。启用HT后，每个物理CPU核被呈现给操作系统为两个核。硬件本身将尝试同时执行分配给这些所谓的虚拟核心的任务，并安排可以同时使用处理核心的不同元素的操作。实际上，这可以在不需要任何类型的优化的操作系统或应用程序的情况下显着提高性能。
- en: The OS can of course still do its own scheduling to further optimize the execution
    of task, since the hardware is not aware of many details about the instructions
    it is executing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，操作系统仍然可以进行自己的调度，以进一步优化任务的执行，因为硬件对其正在执行的指令的许多细节并不知情。
- en: 'Having HT enabled looks like this in the visual format:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 启用HT的外观如下所示：
- en: '![](img/00013.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00013.jpeg)'
- en: In this preceding graphic, we see the instructions of four different tasks in
    memory (RAM). Out of these, two tasks (threads) are being executed simultaneously,
    with the CPU's scheduler (in the frontend) attempting to schedule the instructions
    so that as many instructions as possible can be executed in parallel. Where this
    is not possible, so-called pipeline bubbles (in white) appear where the execution
    hardware is idle.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述图形中，我们看到内存（RAM）中四个不同任务的指令。其中两个任务（线程）同时执行，CPU的调度器（在前端）试图安排指令，以便尽可能多地并行执行指令。在这种情况下不可能时，会出现所谓的流水线气泡（白色），表示执行硬件处于空闲状态。
- en: Together with internal CPU optimizations, this leads to a very high throughput
    of instructions, also called **Instructions Per Second** (**IPC**). Instead of
    the GHz rating of a CPU, this IPC number is generally far more significant for
    determining the sheer performance of a CPU.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 加上内部CPU优化，这导致了非常高的指令吞吐量，也称为**每秒指令数**（**IPC**）。与CPU的GHz评级不同，这个IPC数字通常更重要，用于确定CPU的性能。
- en: Flynn's taxonomy
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弗林分类
- en: 'Different types of computer architecture are classified using a system which
    was first proposed by Michael J. Flynn, back in 1966\. This classification system
    knows four categories, defining the capabilities of the processing hardware in
    terms of the number of input and output streams:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 不同类型的计算机架构使用迈克尔·J·弗林在1966年首次提出的系统进行分类。这个分类系统有四个类别，根据处理硬件的输入和输出流的数量来定义其能力：
- en: '**Single Instruction, Single Data** (**SISD**): A single instruction is fetched
    to operate on a single data stream. This is the traditional model for CPUs.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单指令，单数据**（**SISD**）：单个指令被提取以操作单个数据流。这是CPU的传统模型。'
- en: '**Single Instruction, Multiple Data** (**SIMD**): With this model, a single
    instruction operates on multiple data streams in parallel. This is what vector
    processors such as **graphics processing units** (**GPUs**) use.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单指令，多数据**（**SIMD**）：使用这种模型，单个指令可以并行操作多个数据流。这是图形处理单元（**GPU**）等矢量处理器使用的模型。'
- en: '**Multiple Instruction, Single Data** (**MISD**): This model is most commonly
    used for redundant systems, whereby the same operation is performed on the same
    data by different processing units, validating the results at the end to detect
    hardware failure. This is commonly used by avionics systems and similar.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多指令，单数据**（**MISD**）：这个模型最常用于冗余系统，通过不同的处理单元对相同的数据执行相同的操作，最终验证结果以检测硬件故障。这通常由航空电子系统等使用。'
- en: '**Multiple Instruction, Multiple Data** (**MIMD**): For this model, a multiprocessing
    system lends itself very well. Multiple threads across multiple processors process
    multiple streams of data. These threads are not identical, as is the case with
    SIMD.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多指令，多数据**（**MIMD**）：对于这个模型，多处理系统非常适用。多个处理器上的多个线程处理多个数据流。这些线程不是相同的，就像SIMD一样。'
- en: An important thing to note with these categories is that they are all defined
    in terms of multiprocessing, meaning that they refer to the intrinsic capabilities
    of the hardware. Using software techniques, virtually any method can be approximated
    on even a regular SISD-style architecture. This is, however, part of multithreading.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，这些类别都是根据多处理来定义的，这意味着它们指的是硬件的固有能力。使用软件技术，几乎可以在甚至是常规的SISD架构上近似任何方法。然而，这是多线程的一部分。
- en: Symmetric versus asymmetric multiprocessing
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对称与非对称多处理
- en: Over the past decades, many systems were created which contained multiple processing
    units. These can be broadly divided into **Symmetric Multiprocessing** (**SMP**)
    and **Asymmetric Multiprocessing** (**AMP**) systems.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几十年中，许多系统都包含了多个处理单元。这些可以大致分为对称多处理（SMP）和非对称多处理（AMP）系统。
- en: AMP's main defining feature is that a second processor is attached as a peripheral
    to the primary CPU. This means that it cannot run control software, but only user
    applications. This approach has also been used to connect CPUs using a different
    architecture to allow one to, for example, run x86 applications on an Amiga, 68k-based
    system.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: AMP的主要特点是将第二处理器作为外围连接到主CPU。这意味着它不能运行控制软件，而只能运行用户应用程序。这种方法也被用于连接使用不同架构的CPU，以允许例如在Amiga，68k系统上运行x86应用程序。
- en: 'With an SMP system, each of the CPUs are peers having access to the same hardware
    resources, and set up in a cooperative fashion. Initially, SMP systems involved
    multiple physical CPUs, but later, multiple processor cores got integrated on
    a single CPU die:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在SMP系统中，每个CPU都是对等的，可以访问相同的硬件资源，并以合作的方式设置。最初，SMP系统涉及多个物理CPU，但后来，多个处理器核心集成在单个CPU芯片上：
- en: '![](img/00014.gif)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00014.gif)'
- en: With the proliferation of multi-core CPUs, SMP is the most common type of processing
    outside of embedded development, where uniprocessing (single core, single processor)
    is still very common.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 随着多核CPU的普及，SMP是嵌入式开发之外最常见的处理类型，其中单处理（单核，单处理器）仍然非常普遍。
- en: Technically, the sound, network, and graphic processors in a system can be considered
    to be asymmetric processors related to the CPU. With an increase in **General
    Purpose GPU** (**GPGPU**) processing, AMP is becoming more relevant.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，系统中的声音、网络和图形处理器可以被视为与CPU相关的非对称处理器。随着**通用GPU**（GPGPU）处理的增加，AMP变得更加相关。
- en: Loosely and tightly coupled multiprocessing
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 松散和紧密耦合的多处理
- en: A multiprocessing system does not necessarily have to be implemented within
    a single system, but can also consist of multiple systems which are connected
    in a network. Such a cluster is then called a loosely coupled multiprocessing
    system. We cover distributing computing in [Chapter 9](part0187.html#5IAP60-1ab5991b318547348fc444437bdacb24),
    *Multithreading with Distributed Computing*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 多处理系统不一定要在单个系统内实现，也可以由多个连接在网络中的系统组成。这样的集群被称为松散耦合的多处理系统。我们在[第9章](part0187.html#5IAP60-1ab5991b318547348fc444437bdacb24)中涵盖了分布式计算，*分布式计算中的多线程*。
- en: This is in contrast with a tightly coupled multiprocessing system, whereby the
    system is integrated on a single **printed circuit board** (**PCB**), using the
    same low-level, high-speed bus or similar.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这与紧密耦合的多处理系统形成对比，紧密耦合的多处理系统是通过单个印刷电路板（PCB）上使用相同的低级高速总线或类似的方式集成在一起。
- en: Combining multiprocessing with multithreading
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将多处理与多线程结合
- en: Virtually any modern system combines multiprocessing with multithreading, courtesy
    of multi-core CPUs, which combine two or more processing cores on a single processor
    die. What this means for an operating system is that it has to schedule tasks
    both across multiple processing cores while also scheduling them on specific cores
    in order to extract maximum performance.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何现代系统都结合了多处理和多线程，这要归功于多核CPU，它将两个或更多处理核心集成在单个处理器芯片上。对操作系统来说，这意味着它必须在多个处理核心之间调度任务，同时也必须在特定核心上调度它们，以提取最大性能。
- en: This is the area of task schedulers, which we will look at in a moment. Suffice
    it to say that this is a topic worthy of its own book.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是任务调度器的领域，我们稍后会看一下。可以说这是一个值得一本书的话题。
- en: Multithreading types
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程类型
- en: Like multiprocessing, there is not a single implementation, but two main ones.
    The main distinction between these is the maximum number of threads the processor
    can execute concurrently during a single cycle. The main goal of a multithreading
    implementation is to get as close to 100% utilization of the processor hardware
    as reasonably possible. Multithreading utilizes both thread-level and process-level
    parallelism to accomplish this goal.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与多处理类似，多线程也不是单一实现，而是两种主要实现。这两者之间的主要区别在于处理器在单个周期内可以同时执行的线程数量。多线程实现的主要目标是尽可能接近100%的处理器硬件利用率。多线程利用线程级和进程级并行性来实现这一目标。
- en: The are two types of multithreading, which we will cover in the following sections.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将介绍两种多线程类型。
- en: Temporal multithreading
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间多线程
- en: Also known as super-threading, the main subtypes for **temporal multithreading**
    (**TMT**) are coarse-grained and fine-grained (or interleaved). The former switches
    rapidly between different tasks, saving the context of each before switching to
    another task's context. The latter type switches tasks with each cycle, resulting
    in a CPU pipeline containing instructions from various tasks from which the term
    *interleaved* is derived.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 也被称为超线程，**时间多线程**（TMT）的主要子类型是粗粒度和细粒度（或交错）。前者在不同任务之间快速切换，保存每个任务的上下文，然后切换到另一个任务的上下文。后者在每个周期中切换任务，导致CPU流水线包含来自各种任务的指令，从中得到*交错*这个术语。
- en: The fine-grained type is implemented in barrel processors. They have an advantage
    over x86 and other architectures that they can guarantee specific timing (useful
    for hard real-time embedded systems) in addition to being less complex to implement
    due to assumptions that one can make.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 细粒度类型在桶处理器中实现。它们比x86和其他架构具有优势，因为它们可以保证特定的时间（对于硬实时嵌入式系统很有用），并且由于可以做出的假设较少，实现起来更不复杂。
- en: Simultaneous multithreading (SMT)
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同时多线程（SMT）
- en: SMT is implemented on superscalar CPUs (implementing instruction-level parallelism),
    which include the x86 and ARM architectures. The defining characteristic of SMT
    is also indicated by its name, specifically, its ability to execute multiple threads
    in parallel, per core.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: SMT实现在超标量CPU上（实现指令级并行性），其中包括x86和ARM架构。SMT的定义特征也由其名称指示，特别是其能够在每个核心中并行执行多个线程。
- en: Generally, two threads per core is common, but some designs support up to eight
    concurrent threads per core. The main advantage of this is being able to share
    resources among threads, with an obvious disadvantage of conflicting needs by
    multiple threads, which has to be managed. Another advantage is that it makes
    the resulting CPU more energy efficient due to a lack of hardware resource duplication.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，每个核心有两个线程是常见的，但某些设计支持每个核心最多八个并发线程。这样做的主要优势是能够在线程之间共享资源，明显的缺点是多个线程的冲突需得到管理。另一个优势是由于缺乏硬件资源重复，使得结果CPU更节能。
- en: Intel's HT technology is essentially Intel's SMT implementation, providing a
    basic two thread SMT engine starting with some Pentium 4 CPUs in 2002.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔的超线程技术本质上是英特尔的SMT实现，从2002年的一些奔腾4 CPU开始提供基本的双线程SMT引擎。
- en: Schedulers
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度程序
- en: A number of task-scheduling algorithms exist, each focusing on a different goal.
    Some may seek to maximize throughput, others minimize latency, while others may
    seek to maximize response time. Which scheduler is the optimal choice solely depends
    on the application the system is being used for.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多任务调度算法，每个算法都专注于不同的目标。有些可能寻求最大化吞吐量，其他人则最小化延迟，而其他人可能寻求最大化响应时间。哪种调度程序是最佳选择完全取决于系统所用于的应用程序。
- en: For desktop systems, the scheduler is generally kept as general-purpose as possible,
    usually prioritizing foreground applications over background applications in order
    to give the user the best possible desktop experience.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于桌面系统，调度程序通常尽可能保持通用，通常优先考虑前台应用程序，以便为用户提供最佳的桌面体验。
- en: For embedded systems, especially in real-time, industrial applications would
    instead seek to guarantee timing. This allows processes to be executed at exactly
    the right time, which is crucial in, for example, driving machinery, robotics,
    or chemical processes where a delay of even a few milliseconds could be costly
    or even fatal.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于嵌入式系统，特别是在实时、工业应用中，通常会寻求保证定时。这允许进程在恰当的时间执行，这在例如驱动机械、机器人或化工过程中至关重要，即使延迟几毫秒也可能成本高昂甚至致命。
- en: The scheduler type is also dependent on the multitasking state of the OS--a
    cooperative multitasking system would not be able to provide many guarantees about
    when it can switch out a running process for another one, as this depends on when
    the active process yields.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 调度程序类型还取决于操作系统的多任务状态--合作式多任务系统无法提供关于何时可以切换运行中进程的许多保证，因为这取决于活动进程何时让出。
- en: With a preemptive scheduler, processes are switched without them being aware
    of it, allowing the scheduler more control over when processes run at which time
    points.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用抢占式调度程序，进程在不知情的情况下进行切换，允许调度程序更多地控制进程在哪些时间点运行。
- en: Windows NT-based OSes (Windows NT, 2000, XP, and so on) use what is called a
    multilevel feedback queue, featuring 32 priority levels. This type of priority
    scheduler allows one to prioritize tasks over other tasks, allowing one to fine-tune
    the resulting experience.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Windows NT的操作系统（Windows NT，2000，XP等）使用所谓的多级反馈队列，具有32个优先级级别。这种类型的优先级调度程序允许对任务进行优先级排序，从而可以微调产生的体验。
- en: Linux originally (kernel 2.4) also used a multilevel feedback queue-based priority
    scheduler like Windows NT with an O(n) scheduler. With version 2.6, this was replaced
    with an O(1) scheduler, allowing processes to be scheduled within a constant amount
    of time. Starting with Linux kernel 2.6.23, the default scheduler is the **Completely
    Fair Scheduler** (**CFS**), which ensures that all tasks get a comparable share
    of CPU time.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Linux最初（内核2.4）也使用了基于多级反馈队列的优先级调度程序，类似于具有O(n)调度程序的Windows NT。在2.6版本中，这被替换为O(1)调度程序，允许进程在恒定的时间内被调度。从Linux内核2.6.23开始，默认调度程序是**完全公平调度程序**（**CFS**），它确保所有任务获得可比较的CPU时间份额。
- en: 'The type of scheduling algorithm used for a number of commonly used or well-known
    OSes is listed in this table:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些常用或知名操作系统使用的调度算法类型：
- en: '| **Operating System** | **Preemption** | **Algorithm** |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| **操作系统** | **抢占** | **算法** |'
- en: '| Amiga OS | Yes | Prioritized round-robin scheduling |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| Amiga OS | 是 | 优先级轮转调度 |'
- en: '| FreeBSD | Yes | Multilevel feedback queue |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| FreeBSD | 是 | 多级反馈队列 |'
- en: '| Linux kernel before 2.6.0 | Yes | Multilevel feedback queue |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| Linux内核2.6.0之前 | 是 | 多级反馈队列 |'
- en: '| Linux kernel 2.6.0-2.6.23 | Yes | O(1) scheduler |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| Linux内核2.6.0-2.6.23 | 是 | O(1)调度程序 |'
- en: '| Linux kernel after 2.6.23 | Yes | Completely Fair Scheduler |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| Linux内核2.6.23之后 | 是 | 完全公平调度程序 |'
- en: '| classic Mac OS pre-9 | None | Cooperative scheduler |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 经典Mac OS 9之前 | 无 | 合作式调度程序 |'
- en: '| Mac OS 9 | Some | Preemptive scheduler for MP tasks, and cooperative for
    processes and threads |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| Mac OS 9 | 一些 | 用于MP任务的抢占式调度程序，以及用于进程和线程的合作式调度程序 |'
- en: '| OS X/macOS | Yes | Multilevel feedback queue |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| OS X/macOS | 是 | 多级反馈队列 |'
- en: '| NetBSD | Yes | Multilevel feedback queue |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| NetBSD | 是 | 多级反馈队列 |'
- en: '| Solaris | Yes | Multilevel feedback queue |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| Solaris | 是 | 多级反馈队列 |'
- en: '| Windows 3.1x | None | Cooperative scheduler |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| Windows 3.1x | 无 | 合作式调度程序 |'
- en: '| Windows 95, 98, Me | Half | Preemptive scheduler for 32-bit processes, and
    cooperative for 16-bit processes |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| Windows 95, 98, Me | Half | 32位进程使用抢占式调度程序，16位进程使用合作式调度程序 |'
- en: '| Windows NT (including 2000, XP, Vista, 7, and Server) | Yes | Multilevel
    feedback queue |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| Windows NT（包括2000、XP、Vista、7和Server）| 是 | 多级反馈队列 |'
- en: '(Source: [https://en.wikipedia.org/wiki/Scheduling_(computing)](https://en.wikipedia.org/wiki/Scheduling_(computing)))'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: （来源：[https://en.wikipedia.org/wiki/Scheduling_(computing)](https://en.wikipedia.org/wiki/Scheduling_(computing))）
- en: The preemptive column indicates whether the scheduler is preemptive or not,
    with the next column providing further details. As one can see, preemptive schedulers
    are very common, and used by all modern desktop operating systems.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 抢占列指示调度程序是否具有抢占性，下一列提供了更多细节。可以看到，抢占式调度程序非常常见，所有现代桌面操作系统都使用它。
- en: Tracing the demo application
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪演示应用程序
- en: In the demonstration code of [Chapter 1](part0020.html#J2B80-1ab5991b318547348fc444437bdacb24),
    *Revisiting Multithreading*, we looked at a simple `c++11` application which used
    four threads to perform some processing. In this section, we will look at the
    same application, but from a hardware and OS perspective.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](part0020.html#J2B80-1ab5991b318547348fc444437bdacb24)的演示代码中，*重新审视多线程*，我们看了一个简单的`c++11`应用程序，它使用四个线程来执行一些处理。在本节中，我们将从硬件和操作系统的角度来看同一个应用程序。
- en: 'When we look at the start of the code in the `main` function, we see that we
    create a data structure containing a single (integer) value:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看`main`函数中的代码开头时，我们看到创建了一个包含单个（整数）值的数据结构：
- en: '[PRE0]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After the OS creates a new task and associated stack structure, an instance
    of a vector data structure (customized for integer types) is allocated on the
    stack. The size of this was specified in the binary file's global data section
    (BSS for ELF).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统创建新任务和相关的堆栈结构后，在堆栈上分配了一个向量数据结构的实例（针对整数类型进行了定制）。这个大小在二进制文件的全局数据部分（ELF的BSS）中指定。
- en: When the application's execution is started using its entry function (`main()`
    by default), the data structure is modified to contain the new integer value.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序使用其入口函数（默认为`main()`）开始执行时，数据结构被修改为包含新的整数值。
- en: 'Next, we create four threads, providing each with some initial data:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建四个线程，为每个线程提供一些初始数据：
- en: '[PRE1]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For the OS, this means creating new data structures, and allocating a stack
    for each new thread. For the hardware, this initially does not change anything
    if no hardware-based task switching is used.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于操作系统来说，这意味着创建新的数据结构，并为每个新线程分配一个堆栈。对于硬件来说，如果不使用基于硬件的任务切换，最初不会改变任何东西。
- en: At this point, the OS's scheduler and the CPU can combine to execute this set
    of tasks (threads) as efficiently and quickly as possible, employing features
    of the hardware including SMP, SMT, and so on.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，操作系统的调度程序和CPU可以结合起来尽可能高效和快速地执行这组任务（线程），利用硬件的特性，包括SMP、SMT等。
- en: 'After this, the main thread waits until the other threads stop executing:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，主线程等待其他线程停止执行：
- en: '[PRE2]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These are blocking calls, which mark the main thread as being blocked until
    these four threads (tasks) finish executing. At this point, the OS's scheduler
    will resume execution of the main thread.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是阻塞调用，标记主线程被阻塞，直到这四个线程（任务）执行完成。此时，操作系统的调度程序将恢复主线程的执行。
- en: 'In each newly created thread, we first output a string on the standard output,
    making sure that we lock the mutex to ensure synchronous access:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个新创建的线程中，我们首先在标准输出上输出一个字符串，确保锁定互斥锁以确保同步访问：
- en: '[PRE3]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A mutex, in essence, is a singular value being stored on the stack of heap,
    which then is accessed using an atomic operation. This means that some form of
    hardware support is required. Using this, a task can check whether it is allowed
    to proceed yet, or has to wait and try again.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥锁本质上是一个存储在堆栈或堆上的单个值，然后使用原子操作访问。这意味着需要某种形式的硬件支持。使用这个，任务可以检查它是否被允许继续，还是必须等待并再次尝试。
- en: In this last particular piece of code, this mutex lock allows us to output on
    the standard C++ output stream without other threads interfering.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段特定的代码中，这个互斥锁允许我们在标准C++输出流上输出，而不会受到其他线程的干扰。
- en: 'After this, we copy the initial value in the vector to a local variable, again
    ensuring that it''s done synchronously:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这之后，我们将向一个本地变量复制向量中的初始值，再次确保它是同步完成的：
- en: '[PRE4]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The same thing happens here, except now the mutex lock allows us to read the
    first value in the vector without risking another thread accessing or even changing
    it while we use it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的事情与之前相同，只是现在互斥锁允许我们读取向量中的第一个值，而不会在我们使用它时有其他线程访问甚至更改它的风险。
- en: 'This is followed by the generating of a random number as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接着生成一个随机数如下：
- en: '[PRE5]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This uses the `randGen()` method, which is as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了以下`randGen()`方法：
- en: '[PRE6]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This method is interesting due to its use of a thread-local variable. Thread-local
    storage is a section of a thread's memory which is specific to it, and used for
    global variables, which, nevertheless, have to remain limited to that specific
    thread.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法之所以有趣，是因为它使用了线程局部变量。线程局部存储是线程特有的内存部分，用于全局变量，但必须保持限制在特定线程中。
- en: This is very useful for a static variable like the one used here. That the `generator`
    instance is static is because we do not want to reinitialize it every single time
    we use this method, yet we do not want to share this instance across all threads.
    By using a thread-local, static instance, we can accomplish both goals. A static
    instance is created and used, but separately for each thread.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像这里使用的静态变量来说，这是非常有用的。`generator`实例是静态的，因为我们不希望每次使用这种方法时都重新初始化它，但我们也不希望在所有线程之间共享这个实例。通过使用线程局部的静态实例，我们可以实现这两个目标。为每个线程创建并使用一个静态实例。
- en: The `Thread` function then ends with the same series of mutexes being locked,
    and the new value being copied to the array.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread`函数最后以相同的一系列互斥锁结束，并将新值复制到数组中。'
- en: '[PRE7]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here we see the same synchronous access to the standard output stream, followed
    by synchronous access to the values data structure.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到对标准输出流的同步访问，然后是对值数据结构的同步访问。
- en: Mutual exclusion implementations
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互斥实现
- en: Mutual exclusion is the principle which underlies thread-safe access of data
    within a multithreaded application. One can implement this both in hardware and
    software. The **mutual exclusion** (**mutex**) is the most elementary form of
    this functionality in most implementations.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥是多线程应用程序中数据的线程安全访问的原则。可以在硬件和软件中实现这一点。**互斥**（**mutex**）是大多数实现中这种功能的最基本形式。
- en: Hardware
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件
- en: The simplest hardware-based implementation on a uniprocessor (single processor
    core), non-SMT system is to disable interrupts, and thus, prevent the task from
    being changed. More commonly, a so-called busy-wait principle is employed. This
    is the basic principle behind a mutex--due to how the processor fetches data,
    only one task can obtain and read/write an atomic value in the shared memory,
    meaning, a variable sized the same (or smaller) as the CPU's registers. This is
    further detailed in Chapter 8, *Atomic Operations - Working with the Hardware*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在单处理器（单处理器核心），非SMT系统上最简单的基于硬件的实现是禁用中断，从而防止任务被更改。更常见的是采用所谓的忙等待原则。这是互斥的基本原则--由于处理器获取数据的方式，只有一个任务可以获取和读/写共享内存中的原子值，即与CPU寄存器相同（或更小）大小的变量。这在第8章“原子操作-与硬件一起工作”中有进一步详细说明。
- en: 'When our code tries to lock a mutex, what this does is read the value of such
    an atomic section of memory, and try to set it to its locked value. Since this
    is a single operation, only one task can change the value at any given time. Other
    tasks will have to wait until they can gain access in this busy-wait cycle, as
    shown in this diagram:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的代码尝试锁定互斥锁时，这实际上是读取这样一个原子内存区域的值，并尝试将其设置为其锁定值。由于这是一个单操作，只有一个任务可以在任何给定时间更改该值。其他任务将不得不等待，直到它们可以在这个忙等待周期中获得访问，如图所示：
- en: '![](img/00015.jpeg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00015.jpeg)'
- en: Software
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件
- en: Software-defined mutual exclusion implementations are all based on busy-waiting.
    An example is **Dekker's** algorithm, which defines a system in which two processes
    can synchronize, employing busy-wait to wait for the other process to leave the
    critical section.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 基于忙等待的软件定义的互斥实现。一个例子是**Dekker**算法，它定义了一个系统，其中两个进程可以同步，利用忙等待等待另一个进程离开临界区。
- en: 'The pseudocode for this algorithm is as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法的伪代码如下：
- en: '[PRE8]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '(Referenced from: [https://en.wikipedia.org/wiki/Dekker''s_algorithm](https://en.wikipedia.org/wiki/Dekker''s_algorithm))'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: （引用自：[https://en.wikipedia.org/wiki/Dekker's_algorithm](https://en.wikipedia.org/wiki/Dekker's_algorithm)）
- en: In this preceding algorithm, processes indicate the intent to enter a critical
    section, checking whether it's their turn (using the process ID), then setting
    their intent to enter the section to false after they have entered it. Only once
    a process has set its intent to enter to true again will it enter the critical
    section again. If it wishes to enter, but `turn` does not match its process ID,
    it'll busy-wait until the condition becomes true.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述算法中，进程表明他们打算进入临界区，检查是否轮到他们（使用进程ID），然后在进入后将其意图设置为false。只有当进程再次将其意图设置为true时，它才会再次进入临界区。如果它希望进入，但`turn`与其进程ID不匹配，它将忙等待直到条件变为真。
- en: A major disadvantage of software-based mutual exclusion algorithms is that they
    only work if **out-of-order** (**OoO**) execution of code is disabled. OoO means
    that the hardware actively reorders incoming instructions in order to optimize
    their execution, thus changing their order. Since these algorithms require that
    various steps are executed in order, they no longer work on OoO processors.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 软件基础的互斥算法的一个主要缺点是，它们只在禁用代码的**乱序**（**OoO**）执行时才能工作。 OoO意味着硬件积极重新排序传入的指令，以优化它们的执行，从而改变它们的顺序。由于这些算法要求各个步骤按顺序执行，它们在OoO处理器上不再起作用。
- en: Summary
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we saw how processes and threads are implemented both in operating
    systems and in hardware. We also looked at various configurations of processor
    hardware and elements of operating systems involved in scheduling to see how they
    provide various types of task processing.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了进程和线程在操作系统和硬件中的实现方式。我们还研究了处理器硬件的各种配置以及涉及调度的操作系统元素，以了解它们如何提供各种类型的任务处理。
- en: Finally, we took the multithreaded program example of the previous chapter,
    and ran through it again, this time considering what happens in the OS and processor
    while it is being executed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们再次运行了上一章的多线程程序示例，并考虑了在执行过程中操作系统和处理器发生了什么。
- en: In the next chapter, we will take a look at the various multithreading APIs
    being offered via OS and library-based implementations, along with examples comparing
    these APIs.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看通过操作系统和基于库的实现提供的各种多线程API，以及比较这些API的示例。
