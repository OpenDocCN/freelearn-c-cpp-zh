- en: '*Chapter 12*: Layering Views and Implementing the HUD'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：分层视图和实现HUD'
- en: In this chapter, we will get to see the real value of SFML Views. We will add
    a large array of SFML `Text` objects and manipulate them, like we did before in
    the Timber!!! project and the Pong project. What's new is that we will draw the
    HUD using a second View instance. This way, the HUD will stay neatly positioned
    over the top of the main game action, regardless of what the background, player,
    zombies, and other game objects are doing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到SFML视图的真正价值。我们将添加一大堆SFML `Text`对象，并像在Timber!!!项目和Pong项目中之前做的那样操作它们。新的地方在于，我们将使用第二个视图实例来绘制HUD。这样，HUD将整齐地定位在主游戏动作的顶部，无论背景、玩家、僵尸和其他游戏对象在做什么。
- en: 'Here is what we will do in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做以下事情：
- en: Add text and a background to the home/game over screen
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为主/游戏结束屏幕添加文本和背景
- en: Add text to the level-up screen
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为等级提升屏幕添加文本
- en: Create the second View
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建第二个视图
- en: Add a HUD
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个HUD
- en: Adding all the Text and HUD objects
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加所有文本和HUD对象
- en: We will be manipulating a few strings in this chapter. We are doing this so
    we can format the HUD and the level-up screen with the necessary text.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将操作一些字符串。我们这样做是为了用必要的文本格式化HUD和等级提升屏幕。
- en: 'Add the extra `include` directive highlighted in the following code so that
    we can make some `sstream` objects to achieve this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中添加额外的`include`指令，以便我们可以创建一些`sstream`对象来实现这一点：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, add this rather lengthy, but easily explainable, piece of code. To help
    identify where you should add the code, the new code is highlighted, and the existing
    code is not:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加这段相当长但容易解释的代码。为了帮助识别你应该在哪里添加代码，新的代码被突出显示，而现有的代码没有被突出显示：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The previous code is very simple and nothing new. It basically creates a whole
    bunch of SFML `Text` objects. It assigns their colors and sizes and then formats
    their positions using functions we have seen before.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码非常简单，没有什么新意。它基本上创建了一大堆SFML `Text`对象。它为它们分配颜色和大小，然后使用我们之前见过的函数来格式化它们的位置。
- en: The most important thing to note is that we create another `View` object called
    `hudView` and initialize it to fit the resolution of the screen.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是要注意，我们创建了一个名为`hudView`的另一个`View`对象，并将其初始化以适应屏幕分辨率。
- en: As we have seen, the main `View` object scrolls around as it follows the player.
    In contrast, we will never move `hudView`. The result of this is that if we switch
    to this view before we draw the elements of the HUD, we will create the effect
    of allowing the game world to scroll by underneath while the player's HUD remains
    stationary.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，主要的`View`对象会随着玩家的移动而滚动。相比之下，我们永远不会移动`hudView`。结果是，如果我们在我们绘制HUD元素之前切换到这个视图，我们将产生一种效果，即允许游戏世界在玩家HUD保持静止的情况下在其下方滚动。
- en: Tip
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: As an analogy, you can think of laying a transparent sheet of plastic with some
    writing on it over a TV screen. The TV will carry on as normal with moving pictures,
    and the text on the plastic sheet will stay in the same place, regardless of what
    goes on underneath it. We will take this concept a step further in the next project
    when we split the screen and separate moving views of the game world.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 作为类比，你可以想象在电视屏幕上放置一张带有文字的透明塑料薄片。电视会继续播放移动的画面，而塑料薄片上的文字将保持在同一位置，无论下面发生什么。在下一个项目中，我们将进一步扩展这个概念，当时我们将分割屏幕并分离游戏世界的移动视图。
- en: The next thing to notice, however, is that the hi-score is not set in any meaningful
    way. We will need to wait until the next chapter, when we investigate file I/O,
    to save and retrieve the high score.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，接下来要注意的是，高分并没有以任何有意义的方式设置。我们需要等到下一章，当我们研究文件I/O时，才能保存和检索高分。
- en: Another point worth noting is that we declare and initialize a `RectangleShape`
    called `healthBar`, which will be a visual representation of the player's remaining
    health. This will work in almost the same way that the time-bar worked in the
    Timber!!! project, except it will represent health instead of time.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的点是，我们声明并初始化了一个名为`healthBar`的`RectangleShape`，它将表示玩家剩余的生命值。这几乎与Timber!!!项目中的时间条以相同的方式工作，除了它将代表生命值而不是时间。
- en: In the previous code, there is a new `Sprite` instance called `ammoIcon` that
    gives context to the bullet and clip statistics that we will draw next to it,
    at the bottom-left of the screen.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，有一个新的`Sprite`实例称为`ammoIcon`，它为我们将要绘制在屏幕左下角的子弹和弹夹统计信息提供了上下文。
- en: Although there is nothing new or technical about the large amount of code that
    we just added, be sure to familiarize yourself with the details – especially the
    variable names – to make the rest of this chapter easier to follow.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们添加的大量代码没有新的或技术性的内容，但请务必熟悉细节——特别是变量名称——以便使本章的其余部分更容易理解。
- en: Updating the HUD
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新HUD
- en: As you might expect, we will update the HUD variables in the update section
    of our code. We will not, however, do so every frame. The reason for this is that
    it is unnecessary, and it also slows our game loop down.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所预期的那样，我们将在代码的更新部分更新HUD变量。然而，我们不会在每一帧都这样做。这样做的原因是不必要的，而且还会减慢我们的游戏循环。
- en: As an example, consider the scenario when the player kills a zombie and gets
    some more points. It doesn't matter whether the `Text` object that holds the score
    is updated in one-thousandth, one-hundredth, or even one-tenth of a second. The
    player will discern no difference. This means there is no point rebuilding strings
    that we set for the `Text` objects every frame.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑玩家杀死僵尸并获得更多分数的场景。无论包含分数的`Text`对象是在千分之一、百分之一甚至十分之一秒内更新，玩家都不会察觉到任何区别。这意味着没有必要在每一帧重建我们为`Text`对象设置的字符串。
- en: 'Therefore, we can time when and how often we update the HUD. Add the following
    highlighted variables:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以记录何时以及多久更新一次HUD。添加以下高亮变量：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the previous code, we have variables to track how many frames it has been
    since the last time the HUD was updated, and the interval, measured in frames,
    we would like to wait between HUD updates.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有变量来跟踪自上次更新HUD以来经过的帧数，以及我们希望在HUD更新之间等待的帧间隔。
- en: Now, we can use these new variables and update the HUD each frame. We won't
    see all the HUD elements change, however, until we begin to manipulate the final
    variables, such as  `wave`, in the next chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用这些新变量并在每一帧更新HUD。然而，直到我们在下一章开始操作最终变量，例如`wave`，我们才不会看到所有HUD元素的变化。
- en: 'Add the following highlighted code in the update section of the game loop,
    as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏循环的更新部分添加以下高亮代码，如下所示：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the new code, we update the size of the `healthBar` sprite then increment
    the `framesSinceLastHUDUpdate` variable.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在新代码中，我们更新了`healthBar`精灵的大小，然后增加`framesSinceLastHUDUpdate`变量。
- en: Next, we start an `if` block that tests whether `framesSinceLastHUDUpdate` is
    greater than our preferred interval, which is stored in `fpsMeasurementFrameInterval`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始一个`if`块，测试`framesSinceLastHUDUpdate`是否大于我们存储在`fpsMeasurementFrameInterval`中的首选间隔。
- en: Inside this `if` block is where all the action takes place. First, we declare
    a `stringstream` object for each string that we need to set to a `Text` object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`if`块内部发生所有操作。首先，我们为需要设置到`Text`对象的每个字符串声明一个`stringstream`对象。
- en: Then, we use each of those `stringstream` objects in turn and use the `setString`
    function to set the result to the appropriate `Text` object.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们依次使用这些`stringstream`对象，并使用`setString`函数将结果设置到适当的`Text`对象中。
- en: Finally, before the `if` block is exited, `framesSinceLastHUDUpdate` is set
    back to zero so that the count can begin again.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在退出`if`块之前，将`framesSinceLastHUDUpdate`重置为零，以便计数可以重新开始。
- en: Now, when we redraw the scene, the new values will appear in the player's HUD.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们重新绘制场景时，新的值将出现在玩家的HUD中。
- en: Drawing the HUD, home, and level-up screens
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制HUD、主界面和升级屏幕
- en: All the code in the following three code blocks goes in the drawing phase of
    our game loop. All we need to do is draw the appropriate `Text` objects during
    the appropriate states, in the draw section of the main game loop.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三个代码块中的所有代码都放在我们的游戏循环的绘制阶段。我们所需做的只是在主游戏循环的绘制部分绘制适当的`Text`对象。
- en: 'In the `PLAYING` state, add the following highlighted code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PLAYING`状态中，添加以下高亮代码：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The vital thing to notice in the preceding block of code is that we switch views
    to the HUD view. This causes everything to be drawn at the precise screen positions
    we gave each of the elements of the HUD. They will never move.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中需要注意的重要一点是我们切换到HUD视图。这导致所有元素都绘制在我们在每个HUD元素中给出的精确屏幕位置。它们永远不会移动。
- en: 'In the `LEVELING_UP` state, add the following highlighted code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LEVELING_UP`状态中，添加以下高亮代码：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the `PAUSED` state, add the following highlighted code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PAUSED`状态中，添加以下高亮代码：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the `GAME_OVER` state, add the following highlighted code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GAME_OVER`状态中，添加以下高亮代码：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we can run the game and see our HUD update during gameplay:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行游戏并看到我们的HUD在游戏过程中更新：
- en: '![](img/B14278_12_01.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_12_01.jpg)'
- en: 'The following screenshot shows the high score and score on the home/game over
    screen:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了主/游戏结束屏幕上的高分和得分：
- en: '![](img/B14278_12_02.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_12_02.jpg)'
- en: 'Next, we see text that tells the player what their level-up options are, although
    these options don''t do anything yet:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到文本告诉玩家他们的升级选项是什么，尽管这些选项目前还没有任何作用：
- en: '![](img/B14278_12_03.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_12_03.jpg)'
- en: 'Here, we can see a helpful message on the pause screen:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们可以看到暂停屏幕上的一个有用的消息：
- en: '![](img/B14278_12_04.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_12_04.jpg)'
- en: Tip
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: SFML Views are more powerful than this simple HUD can demonstrate. For an insight
    into the potential of the SFML `View` class and how easy they are to use, look
    at the SFML website's tutorial on `View` at [https://www.sfml-dev.org/tutorials/2.5/graphics-view.php](https://www.sfml-dev.org/tutorials/2.5/graphics-view.php).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: SFML的`View`类比这个简单的HUD展示的功能更强大。要了解SFML `View`类的潜力以及它们的使用有多简单，请查看SFML网站上的`View`教程，链接为[https://www.sfml-dev.org/tutorials/2.5/graphics-view.php](https://www.sfml-dev.org/tutorials/2.5/graphics-view.php)。
- en: Summary
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This was a quick and simple chapter. We looked at how to display the values
    that are held by variables of different types using `sstream` and then learned
    how to draw them over the top of the main game action using a second SFML `View`
    object.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一章快速而简单的章节。我们学习了如何使用`sstream`显示不同类型变量所持有的值，然后学习了如何使用第二个SFML `View`对象在主游戏动作上方绘制它们。
- en: We are nearly done with Zombie Arena now. All the screenshots in this chapter
    show a small arena that doesn't take advantage of the full monitor.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在僵尸竞技场几乎完成了。本章中所有的截图都显示了一个小竞技场，没有充分利用整个显示器。
- en: In the next chapter, the final one for this project, we will put in some finishing
    touches, such as leveling up, sound effects, and saving the high score. The arena
    can then grow to the same size as the monitor and far beyond.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，也就是这个项目的最后一章，我们将添加一些收尾工作，比如升级、音效和保存高分。竞技场的大小可以扩展到与显示器相同，甚至更大。
- en: FAQ
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题解答
- en: 'Here is a question that might be on your mind:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个可能出现在你脑海中的问题：
- en: Q) Where can I see more of the power of the `View` class in action?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Q) 我在哪里可以看到`View`类更多实际应用的力量？
- en: 'A) Take a look at the enhanced edition of the Zombie Arena game, in the download
    bundle. You can use the cursor keyboard keys to spin and zoom the game. Warning!
    Spinning the scene makes the controls awkward, but you get to see some of the
    things that can be done with the View class:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: A) 在下载包中查看《僵尸竞技场》游戏的增强版。您可以使用光标键盘键来旋转和缩放游戏。警告！旋转场景会使控制变得笨拙，但您可以看到使用`View`类可以完成的一些事情：
- en: '![](img/B14278_12_05.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_12_05.jpg)'
- en: The zoom and rotate functionality were achieved with just a few lines of code
    in the input handling section of the main game loop. You can see the code in the
    `Zombie Arena Enhanced Version` folder of the download bundle or run the enhanced
    version from the `Runnable Games/Zombie Arena` folder.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放和旋转功能仅通过在主游戏循环的输入处理部分编写几行代码就实现了。您可以在下载包的`Zombie Arena Enhanced Version`文件夹中查看代码，或者从`Runnable
    Games/Zombie Arena`文件夹中运行增强版。
