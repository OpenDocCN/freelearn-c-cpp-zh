- en: Multithreading
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Creating a thread of execution
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建执行线程
- en: Syncing access to a common resource
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步访问共享资源
- en: Fast access to a common resource using atomics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原子快速访问共享资源
- en: Creating a work_queue class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个work_queue类
- en: Multiple-readers-single-writer lock
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多读单写锁
- en: Creating variables that are unique per thread
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建每个线程唯一的变量
- en: Interrupting a thread
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中断线程
- en: Manipulating a group of threads
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作一组线程
- en: Initializing a shared variable safely
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全初始化共享变量
- en: Locking multiple mutexes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个互斥锁
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we'll take care of threads and all the stuff connected with
    them. Basic knowledge of multithreading is encouraged.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将处理线程和与之相关的所有内容。鼓励具有多线程基础知识。
- en: '**Multithreading** means multiple threads of execution exist within a single
    process. Threads may share process resources and have their own resources. Those
    threads of execution may run independently on different CPUs, leading to faster
    and more responsible programs. The `Boost.Thread` library provides unification
    across operating system interfaces to work with threads. It is not a header-only
    library, so all the examples from this chapter need to link against the `libboost_thread`
    and `libboost_system` libraries.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**多线程**意味着单个进程中存在多个执行线程。线程可以共享进程资源并拥有自己的资源。这些执行线程可以在不同的CPU上独立运行，从而实现更快速和更负责任的程序。`Boost.Thread`库提供了跨操作系统接口的统一工作线程。它不是一个仅头文件的库，因此本章中的所有示例都需要链接到`libboost_thread`和`libboost_system`库。'
- en: Creating a thread of execution
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建执行线程
- en: 'On modern multi-core compilers, to achieve maximal performance (or just to
    provide a good user experience), programs usually use multiple threads of execution.
    Here is a motivating example in which we need to create and fill a big file in
    a thread that draws the user interface:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代多核编译器上，为了实现最大性能（或者只是提供良好的用户体验），程序通常使用多个执行线程。以下是一个激励性的例子，我们需要在一个线程中创建和填充一个大文件，该线程绘制用户界面：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe requires knowledge of `boost::bind` or `std::bind`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方需要了解`boost::bind`或`std::bind`。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Starting a thread of execution was never so easy:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 启动执行线程从未如此简单：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `boost::thread` variable accepts a functional object that can be called
    without parameters (we provided one using `boost::bind`) and creates a separate
    thread of execution. That functional object is copied into a constructed thread
    of execution and run there. The return value of the functional object is ignored.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::thread`变量接受一个可以无参数调用的函数对象（我们使用`boost::bind`提供了一个），并创建一个独立的执行线程。该函数对象被复制到构造的执行线程中并在那里运行。函数对象的返回值被忽略。'
- en: '![](img/00006.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00006.jpeg)'
- en: We are using version 4 of the `Boost.Thread` in all recipes (defined `BOOST_THREAD_VERSION`
    to `4`). Important differences between `Boost.Thread` versions are highlighted.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在所有配方中使用`Boost.Thread`的第4版（将`BOOST_THREAD_VERSION`定义为`4`）。`Boost.Thread`版本之间的重要区别已经突出显示。
- en: 'After that, we call the `detach()` function, which does the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们调用`detach()`函数，它会执行以下操作：
- en: The thread of execution is detached from the `boost::thread` variable but continues
    its execution
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行线程从`boost::thread`变量中分离，但继续执行
- en: The `boost::thread` variable starts to hold a `Not-A-Thread` state
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::thread`变量开始保持`Not-A-Thread`状态'
- en: Without a call to `detach()`, the destructor of `boost::thread` will notice
    that it still holds an OS thread and will call `std::terminate`. It terminates
    our program without calling destructors, freeing up resources and without other
    cleanup.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有调用`detach()`，`boost::thread`的析构函数将注意到它仍然持有一个OS线程，并将调用`std::terminate`。它会在不调用析构函数、释放资源和进行其他清理的情况下终止我们的程序。
- en: Default constructed threads also have a `Not-A-Thread` state, and they do not
    create a separate thread of execution.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造的线程也有一个`Not-A-Thread`状态，并且它们不会创建一个独立的执行线程。
- en: There's more...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'What if we want to make sure that a file was created and written before doing
    some other job? In that case, we need to join thread in the following way:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想确保在执行其他工作之前文件已创建并写入，那么我们需要以以下方式加入线程：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After the thread is joined, the `boost::thread` variable holds a `Not-A-Thread`
    state and its destructor does not call `std::terminate`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 线程加入后，`boost::thread`变量保持`Not-A-Thread`状态，其析构函数不会调用`std::terminate`。
- en: Remember that the thread must be joined or detached before its destructor is
    called. Otherwise, your program will terminate!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在调用其析构函数之前，线程必须被加入或分离。否则，您的程序将终止！
- en: With `BOOST_THREAD_VERSION=2` defined, the destructor of `boost::thread` calls
    `detach()`, which does not lead to `std::terminate`. But doing so breaks compatibility
    with `std::thread` and, some day, when your project is moving to the C++ standard
    library threads, or when `BOOST_THREAD_VERSION=2` isn't supported, this will give
    you a lot of surprises. Version 4 of `Boost.Thread` is more explicit and strong,
    which is usually preferable in C++ language.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用定义了`BOOST_THREAD_VERSION=2`，`boost::thread`的析构函数调用`detach()`，这不会导致`std::terminate`。但这样做会破坏与`std::thread`的兼容性，并且有一天，当您的项目转移到C++标准库线程时，或者当`BOOST_THREAD_VERSION=2`不受支持时，这将给您带来很多惊喜。`Boost.Thread`的第4版更加明确和强大，这在C++语言中通常更可取。
- en: Beware that `std::terminate()` is called when any exception that is not of type
    `boost::thread_interrupted` leaves a boundary of the functional object that was
    passed to the `boost::thread` constructor.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当任何不是`boost::thread_interrupted`类型的异常离开传递给`boost::thread`构造函数的功能对象时，将调用`std::terminate()`。
- en: 'There is a very helpful wrapper that works as a RAII wrapper around the thread
    and allows you to emulate the `BOOST_THREAD_VERSION=2` behavior; it is called
    `boost::scoped_thread<T>`, where `T` can be one of the following classes:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个非常有用的包装器，它作为一个RAII包装器围绕线程工作，并允许您模拟`BOOST_THREAD_VERSION=2`的行为；它被称为`boost::scoped_thread<T>`，其中`T`可以是以下类之一：
- en: '`boost::interrupt_and_join_if_joinable`: To interrupt and join a thread at
    destruction'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::interrupt_and_join_if_joinable`：在销毁时中断和加入线程'
- en: '`boost::join_if_joinable`: To join a thread at destruction'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::join_if_joinable`：在销毁时加入线程'
- en: '`boost::detach`: To detach a thread at destruction'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::detach`：在销毁时分离线程'
- en: 'Here is a short example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简短的例子：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `boost::thread` class was accepted as a part of the C++11 standard and you
    can find it in the `<thread>` header in the `std::` namespace. There is no big
    difference between the Boost's Version 4 and C++11 standard library versions of
    the `thread` class. However, `boost::thread` is available on the C++03 compilers,
    so its usage is more versatile.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::thread`类被接受为C++11标准的一部分，并且您可以在`std::`命名空间的`<thread>`头文件中找到它。Boost的版本4和C++11标准库版本的`thread`类之间没有太大的区别。但是，`boost::thread`在C++03编译器上可用，因此其使用更加灵活。'
- en: There is a very good reason for calling `std::terminate` instead of joining
    by default! C and C++ languages are often used in life critical software. Such
    software is controlled by other software, called **watchdog**. Those watchdogs
    can easily detect that an application has terminated but can not always detect
    deadlocks or detect them with longer delays. For example, for defibrillator software,
    it's safer to terminate, than hang on `join()` for a few seconds waiting for a
    watchdog reaction. Keep that in mind when designing such applications.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下调用`std::terminate`而不是加入有很好的理由！C和C++语言经常用于生命关键软件。这些软件由其他软件控制，称为**看门狗**。这些看门狗可以轻松检测到应用程序已终止，但并不总是能够检测到死锁，或者以更长的延迟检测到死锁。例如，对于除颤器软件，终止比等待几秒钟以等待看门狗反应更安全。在设计这类应用程序时请记住这一点。
- en: See also
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: All the recipes in this chapter use `Boost.Thread`. You may continue reading
    to get more information about the library.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的所有示例都使用了`Boost.Thread`。您可以继续阅读以获取有关该库的更多信息。
- en: The official documentation has a full list of the `boost::thread` methods and
    remarks about their availability in the C++11 standard library. Follow the link
    [http://boost.org/libs/thread](http://boost.org/libs/thread) for its official
    documentation.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方文档中列出了`boost::thread`方法的完整列表，并对它们在C++11标准库中的可用性进行了说明。请访问[http://boost.org/libs/thread](http://boost.org/libs/thread)获取官方文档。
- en: The *Interrupting a thread* recipe will give you an idea of what the `boost::interrupt_and_join_if_joinable`
    class does.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*中断线程*的示例将让您了解`boost::interrupt_and_join_if_joinable`类的作用。'
- en: Syncing access to a common resource
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步访问共享资源
- en: 'Now that we know how to start threads of execution, we want to have access
    to some common resources from different threads:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何启动执行线程，我们希望从不同的线程访问一些共享资源：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This `Oops!` is not written there accidentally. For some people, it may be
    a surprise, but there is a big chance that `shared_i` won''t be equal to `0`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`Oops!`不是无意写在那里的。对于一些人来说，这可能是一个惊喜，但`shared_i`不等于`0`的可能性很大：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Modern compilers and processors have a huge number of different tricky optimizations
    that can break the preceding code. We won't discuss them here, but there is a
    useful link in the *See also* section of the document that briefly describes them.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现代编译器和处理器有大量不同的棘手优化，可能会破坏前面的代码。我们不会在这里讨论它们，但在文档的*另请参阅*部分有一个有用的链接，简要描述了它们。
- en: Things get even worse in cases when a common resource is a non-trivial class;
    segmentation faults and memory leaks may (and will) occur.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当共享资源是一个非平凡的类时，情况变得更糟；分段错误和内存泄漏可能（并且将）发生。
- en: We need to change the code so that only one thread modifies the `shared_i` variable
    at a single moment of time and so that all the processor and compiler optimizations
    that inflict multithreaded code are bypassed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更改代码，以便只有一个线程在单个时间点修改`shared_i`变量，并且所有影响多线程代码的处理器和编译器优化都被绕过。
- en: Getting ready
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of threads is recommended for this recipe.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 建议具备基本的线程知识。
- en: How to do it...
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s see how we can fix the previous example and make `shared_i` equal at
    the end of the run:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何修复之前的例子，并在运行结束时使`shared_i`相等：
- en: 'First of all, we''ll need to create a **mutex**:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个**互斥锁**：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Put all the operations that modify or get data from the `shared_i` variable
    between the following:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将修改或获取`shared_i`变量数据的所有操作放在以下位置：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以及以下内容：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here''s how it should look:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该是这样的：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `boost::mutex` class takes care of all the synchronization stuff. When
    a thread tries to lock it via the `boost::lock_guard<boost::mutex>` variable and
    there is no other thread holding a lock, it successfully acquires unique access
    to the section of code until the lock is unlocked or destroyed. If some other
    thread already holds a lock, the thread that tried to acquire the lock waits until
    another thread unlocks the lock. All the locking/unlocking operations imply specific
    instructions so that the changes made in a critical section are visible to all
    threads. Also, you no longer need to:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::mutex`类负责所有同步工作。当一个线程尝试通过`boost::lock_guard<boost::mutex>`变量锁定它，并且没有其他线程持有锁时，它成功地获得对代码部分的唯一访问，直到锁被解锁或销毁。如果其他线程已经持有锁，尝试获取锁的线程将等待直到另一个线程解锁锁。所有的锁定/解锁操作都包含特定的指令，以便在关键部分所做的更改对所有线程可见。此外，您不再需要：'
- en: Make sure that modified values of resources are visible to all cores
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保资源的修改值对所有核心可见
- en: Make sure that values are not just modified in the processor's register
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保值不仅仅在处理器的寄存器中被修改
- en: Force the processor to not reorder the instructions
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制处理器不要重新排序指令
- en: Force the compiler to not reorder the instructions
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制编译器不要重新排序指令
- en: Force the compiler to not remove writes to storage that is not read
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制编译器不要删除对未读取的存储的写入
- en: A bunch of other nasty compiler/architecture specific stuff
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一堆其他讨厌的编译器/架构特定的东西
- en: If you have a variable that is used from different threads and at least one
    thread modifies that variable, usually, all the code that uses it must be treated
    as a critical section and secured by a mutex.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个变量被不同的线程使用，并且至少有一个线程修改该变量，通常情况下，使用它的所有代码必须被视为关键部分，并由互斥锁保护。
- en: The `boost::lock_guard` class is a very simple RAII class that stores a reference
    to the mutex, locks it in the single-parameter constructor, and unlocks it in
    the destructor.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::lock_guard`类是一个非常简单的RAII类，它存储互斥锁的引用，在单参数构造函数中锁定它，并在析构函数中解锁它。'
- en: In the curly bracket usage in the preceding example the `lock` variable is constructed
    inside them so that, on reaching the `// Critical section end.` closing bracket,
    the destructor for the `lock` variable is called and the mutex is unlocked. Even
    if some exception occurs in the critical section, the mutex is correctly unlocked.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，大括号的使用中`lock`变量是在其中构造的，以便在到达`//关键部分结束。`的闭括号时，将调用`lock`变量的析构函数并解锁互斥锁。即使在关键部分发生异常，互斥锁也会被正确解锁。
- en: '![](img/00007.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00007.jpeg)'
- en: If you initialize a common variable and then construct threads that only read
    it, then no mutex or other synchronization is required.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果初始化一个共享变量，然后构造只读取它的线程，那么不需要互斥锁或其他同步。
- en: There's more...
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Locking a mutex is potentially a very slow operation, which may stop your code
    for a long time, until some other thread releases a lock. Try to make critical
    sections as small as possible; try to have less of them in your code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定互斥锁可能是一个非常慢的操作，可能会使您的代码停止很长时间，直到其他线程释放锁。尝试使关键部分尽可能小；尽量减少代码中的关键部分。
- en: 'Let''s take a look at how some operating systems handle locking on a multicore
    CPU. When `thread #1`, running on CPU 1, tries to lock a mutex that is already
    locked by another thread, `thread #1` is stopped by the OS till the lock is released.
    The stopped thread does not eat processor resources, so the OS executes other
    threads on CPU 1\. Now, we have some threads running on CPU 1; some other thread
    releases the lock, and now the OS has to resume execution of a `thread #1`. So,
    it resumes its execution on a currently free CPU, for example, CPU2.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些操作系统如何处理多核CPU上的锁定。当运行在CPU 1上的`线程#1`尝试锁定已被另一个线程锁定的互斥锁时，`线程#1`被操作系统停止，直到锁被释放。停止的线程不会占用处理器资源，因此操作系统在CPU
    1上执行其他线程。现在，我们有一些线程在CPU 1上运行；一些其他线程释放了锁，现在操作系统必须恢复`线程#1`的执行。因此，它在当前空闲的CPU上恢复其执行，例如CPU2。
- en: This results in CPU cache misses, so the code runs slightly slower after mutex
    is released. Usually, things are not so bad because a good OS tries hard to resume
    the thread on the same CPU that it was using before. Unfortunately, such OS-specific
    optimizations are not always possible. Reduce the count of critical sections and
    their sizes to reduce the chance of thread suspending and cache misses.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致CPU缓存未命中，因此在释放互斥锁后，代码运行速度略慢。通常情况下，情况并不那么糟糕，因为一个好的操作系统会尽力在相同的CPU上恢复线程。不幸的是，这样的操作系统特定优化并不总是可能的。减少关键部分的数量和大小以减少线程暂停和缓存未命中的机会。
- en: Do not attempt to lock a `boost::mutex` variable twice in the same thread; it
    will lead to a **deadlock**. If locking a mutex multiple times from a single thread
    is required, use `boost::recursive_mutex` instead from the `<boost/thread/recursive_mutex.hpp>`
    header. Locking it multiple times does not lead to a deadlock. The `boost::recursive_mutex`
    releases the lock only after `unlock()` is called once for each `lock()` call.
    Avoid using `boost::recursive_mutex` when it is not required, because it is slower
    than `boost::mutex` and usually indicates bad code flow design.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 不要尝试在同一线程中两次锁定`boost::mutex`变量；这将导致**死锁**。如果需要从单个线程多次锁定互斥锁，请改用`<boost/thread/recursive_mutex.hpp>`头文件中的`boost::recursive_mutex`。多次锁定它不会导致死锁。`boost::recursive_mutex`只有在每次`lock()`调用后调用一次`unlock()`后才释放锁。当不需要时避免使用`boost::recursive_mutex`，因为它比`boost::mutex`慢，通常表示糟糕的代码流设计。
- en: The `boost::mutex`, `boost::recursive_mutex`, and `boost::lock_guard` classes
    were accepted to the C++11 standard library, and you may find them in the `<mutex>`
    header in the `std::` namespace. No big difference between Boost and standard
    library versions exists. The Boost version may have some extensions (which are
    marked in the official documentation as *EXTENSION*) and provide better portability
    because they can be used even on pre-C++11 compilers.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::mutex`、`boost::recursive_mutex`和`boost::lock_guard`类已被接受为C++11标准库，并且您可以在`std::`命名空间的`<mutex>`头文件中找到它们。Boost版本和标准库版本之间没有太大的区别。Boost版本可能具有一些扩展（在官方文档中标记为*EXTENSION*），并且提供更好的可移植性，因为它们甚至可以在C++11之前的编译器上使用。'
- en: See also
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The next recipe will give you ideas on how to make this example much faster
    (and shorter).
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个示例将为您提供有关如何使此示例更快（更短）的想法。
- en: Read the first recipe from this chapter to get more information about the `boost::thread`
    class. The official documentation at [http://boost.org/libs/thread](http://boost.org/libs/thread)
    may help you too.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读本章的第一个示例以获取有关`boost::thread`类的更多信息。官方文档[http://boost.org/libs/thread](http://boost.org/libs/thread)也可能对您有所帮助。
- en: 'To get more information about why the first example fails and how multiprocessors
    work with common resources, see *Memory Barriers: a Hardware View for Software
    Hackers* at [http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.07.23a.pdf](http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.07.23a.pdf).
    Note that this is a hard topic.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '要获取有关为什么第一个示例失败以及多处理器如何使用共享资源的更多信息，请参阅[http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.07.23a.pdf](http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.07.23a.pdf)上的*Memory
    Barriers: a Hardware View for Software Hackers*。请注意，这是一个难题。'
- en: Fast access to common resource using atomics
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原子操作快速访问共享资源
- en: 'In the previous recipe, we saw how to safely access a common resource from
    different threads. But in that recipe, we were doing two system calls (in locking
    and unlocking `mutex`) to just get the value from an integer:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个配方中，我们看到了如何安全地从不同线程访问一个共同的资源。但在那个配方中，我们只是做了两个系统调用（在锁定和解锁`mutex`中）来获取整数的值：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This looks lame and slow! Can we make the code from the previous recipe better?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很糟糕和慢！我们能让前一个配方中的代码更好吗？
- en: Getting ready
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Reading the first recipe is all you need to start with this one. Some basic
    knowledge of multithreading will be welcome.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读第一个配方就足够开始这个配方了。一些关于多线程的基本知识将会很有帮助。
- en: How to do it...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s see how to improve our previous example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何改进我们之前的例子：
- en: 'Now, we need different headers:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要不同的头文件：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Changing the type of `shared_i` is required:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要改变`shared_i`的类型：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Remove all the `boost::lock_guard` variables:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除所有的`boost::lock_guard`变量：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'That''s it! Now, it works:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就是这样！现在它可以工作了：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Processors provide specific **atomic operations** that cannot be interfered
    with by other processors or processor cores. These operations appear to occur
    instantaneously for a system. `Boost.Atomic` provides classes that wrap around
    system-specific atomic operations, cooperate with the compiler to disable optimizations
    that may break multithreaded work with a variable, and provide a unified portable
    interface to work with atomic operations. If two atomic operations on the same
    memory location start simultaneously from different threads, one of the operations
    waits till the other one finishes and then reuses the result of the previous operation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器提供特定的**原子操作**，不会受到其他处理器或处理器核心的干扰。这些操作对系统来说似乎是瞬间发生的。`Boost.Atomic`提供了包装系统特定原子操作的类，与编译器合作以禁用可能破坏变量的多线程工作的优化，并提供一个统一的可移植接口来处理原子操作。如果两个不同线程同时开始对同一内存位置的原子操作，其中一个操作会等待直到另一个操作完成，然后重用前一个操作的结果。
- en: '![](img/00008.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00008.jpeg)'
- en: 'In other words, it is safe to use the `boost::atomic<>` variables from different
    threads simultaneously. Each operation on the atomic variable is seen by the system
    as a single transaction. Series of operations on the atomic variables are treated
    by the system as a series of independent transactions:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，可以安全地同时从不同线程使用`boost::atomic<>`变量。系统中对原子变量的每个操作都被视为单个事务。系统中对原子变量的一系列操作被视为一系列独立的事务：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Never ever avoid synchronization for a variable that is modified from multiple
    threads. Even if the variable is a `bool` and all you do is read or write `true`/`false`
    to it! The compiler has all the rights to optimize away all the stores and reads,
    breaking your code in a million ways that nobody can even imagine. Guess whom
    a good employer would punish for such breakage? (The compiler is not the right
    answer to that question!)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要避免对多个线程修改的变量进行同步。即使变量是`bool`，你所做的只是读取或写入`true`/`false`！编译器有权利优化掉所有的存储和读取，以一百万种无法想象的方式破坏你的代码。猜猜一个好的雇主会惩罚谁？（编译器不是这个问题的正确答案！）
- en: There's more...
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `Boost.Atomic` library can work only with POD types; otherwise, behavior
    is undefined. Some platforms/processors do not provide atomic operations for some
    types, so `Boost.Atomic` emulates atomic behavior using `boost::mutex`. The atomic
    type does not use `boost::mutex` if the type specific macro is set to `2`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Atomic`库只能处理POD类型；否则，行为是未定义的。一些平台/处理器不提供某些类型的原子操作，因此`Boost.Atomic`使用`boost::mutex`来模拟原子行为。如果类型特定的宏设置为`2`，原子类型就不使用`boost::mutex`：'
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `boost::atomic<T>::is_lock_free` member function depends on runtime, so
    it is not good for compile-time checks but may provide a more readable syntax
    when the runtime check is enough:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::atomic<T>::is_lock_free`成员函数取决于运行时，因此不适合用于编译时检查，但在运行时检查足够时可能提供更可读的语法：'
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Atomics work much faster than mutexes but are still much slower than non-atomic
    operations. If we compare the execution time of a recipe that uses mutexes (0:00.08
    seconds) and the execution time of the preceding example in this recipe (0:00.02
    seconds), we'll see the difference (tested on 30,0000 iterations).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 原子操作比互斥锁快得多，但仍然比非原子操作慢得多。如果我们比较使用互斥锁的配方的执行时间（0:00.08秒）和本配方中前面示例的执行时间（0:00.02秒），我们会看到差异（在30,0000次迭代中进行测试）。
- en: All the known to the book author standard library implementations had issues
    with atomic operations. All of them! Do not write your own atomics. If you think
    that your own implementation of atomics would be better and you wish to waste
    some time--write it, check it using special tools, and think again. Repeat until
    you understand that you're wrong.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 所有已知的标准库实现都存在原子操作的问题。所有的都有！不要编写自己的原子操作。如果你认为你自己的原子操作实现会更好，而且你希望浪费一些时间--写下来，使用特殊工具进行检查，然后再考虑。直到你明白你错了。
- en: The C++11 compatible compilers should have all the atomic classes, `typedefs`,
    and macro in the `<atomic>` header in the `std::` namespace. Compiler-specific
    implementations of `std::atomic` may work faster than the Boost's version, if
    the compiler correctly supports the C++11 memory model and is specially trained
    to optimize `std::atomic` variables.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 符合C++11标准的编译器应该在`std::`命名空间的`<atomic>`头文件中具有所有原子类、`typedefs`和宏。如果编译器正确支持C++11内存模型并且专门训练以优化`std::atomic`变量，那么特定于编译器的`std::atomic`实现可能比Boost的版本更快。
- en: See also
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The official documentation at [http://boost.org/libs/atomic](http://boost.org/libs/atomic)
    may give you many more examples and some theoretical information on the topic.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://boost.org/libs/atomic](http://boost.org/libs/atomic)的官方文档可能会给你更多例子和一些关于这个主题的理论信息。'
- en: Creating work_queue class
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建work_queue类
- en: Let's call the functional object that takes no arguments (a task, for short).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们称没有参数的函数对象为任务。
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, imagine a situation where we have threads that post tasks and threads
    that execute posted tasks. We need to design a class that can be safely used by
    both types of those threads. This class must have functions for:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一种情况，我们有一些负责发布任务的线程和一些负责执行发布的任务的线程。我们需要设计一个可以安全地被这两种类型的线程使用的类。这个类必须具有以下函数：
- en: Getting a task or waiting for a task till it is posted by another thread
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取一个任务或等待任务直到被另一个线程发布
- en: Checking and getting a task if we have one (returning an empty task if no tasks
    remain)
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查并获取任务（如果有任务则返回一个空任务）
- en: Posting tasks
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布任务
- en: Getting ready
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Make sure that you feel comfortable with `boost::thread` or `std::thread` ,
    know basics of mutexes, and are aware of `boost::function` or `std::function`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你对`boost::thread`或`std::thread`感到舒适，了解互斥锁的基础知识，并且了解`boost::function`或`std::function`。
- en: How to do it...
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The class that we are going to implement is close by functionality to `std::queue<task_t>`
    but also has thread synchronization. Let''s start:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要实现的类与`std::queue<task_t>`的功能相似，但也具有线程同步。让我们开始：
- en: 'We need the following headers and members:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要以下的头文件和成员：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'A function for putting a task in a queue must look like this:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将任务放入队列的函数必须像这样：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A non-blocking function for getting a pushed task or an empty task (if no tasks
    remain):'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个非阻塞的函数，用于获取推送的任务或空任务（如果没有任务）
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Blocking function for getting a pushed task or for blocking while the task
    is pushed by another thread:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于获取推送的任务或在任务被另一个线程推送时阻塞的阻塞函数：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here''s how a `work_queue` class may be used:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`work_queue`类的使用方法：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this example, we see a new RAII class `boost::unique_lock`. It is just a
    `boost::lock_guard` class with additional functionality for explicit unlocking
    and locking mutexes.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们看到了一个新的RAII类`boost::unique_lock`。它只是一个`boost::lock_guard`类，具有额外的功能来显式解锁和锁定互斥锁。
- en: Back to our `work_queue` class. Let's start with the `pop_task()` function.
    In the beginning, we are acquiring a lock and checking for available tasks. If
    there is a task, we return it; otherwise, `cond_.wait(lock)` is called. This method
    atomically unlocks the lock and pauses the thread of execution till some other
    thread notifies the current thread.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`work_queue`类。让我们从`pop_task()`函数开始。一开始，我们会获取一个锁并检查是否有可用的任务。如果有任务，我们就返回它；否则，会调用`cond_.wait(lock)`。这个方法会原子性地解锁锁，并暂停执行线程，直到其他线程通知当前线程。
- en: Now, let's take a look at the `push_task` method. In it, we also acquire a lock,
    push a task in `tasks_.queue`, unlock the lock, and call `cond_.notify_one()`,
    which wakes up the thread (if any) waiting in `cond_.wait(lock)`. So, after that,
    if some thread is waiting on a conditional variable in a `pop_task()` method,
    the thread will continue its execution, call `lock.lock()` deep inside `cond_.wait(lock)`,
    and check `tasks_empty()` in `while`. Because we just added a task in `tasks_`,
    we'll get out from the `while` loop, unlock the `<mutex>` (the `lock` variable
    gets out of scope), and return a task.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下`push_task`方法。在这个方法中，我们也会获取一个锁，将任务推入`tasks_.queue`，解锁锁，并调用`cond_.notify_one()`，这会唤醒等待在`cond_.wait(lock)`中的线程（如果有的话）。因此，在这之后，如果有线程在`pop_task()`方法中等待条件变量，那么线程将继续执行，深入到`cond_.wait(lock)`中的`lock.lock()`，并在`while`中检查`tasks_empty()`。因为我们刚刚在`tasks_`中添加了一个任务，所以我们会从`while`循环中退出，解锁`<mutex>`（`lock`变量超出了作用域），并返回一个任务。
- en: '![](img/00009.jpeg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00009.jpeg)'
- en: You must check conditions in a loop, not just in an `if` statement! The `if`
    statement leads to errors, as the operating system sometimes may wake up the threads
    without any notify calls from the user.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须在循环中检查条件，而不仅仅是在`if`语句中！`if`语句会导致错误，因为操作系统有时可能会在没有用户的通知调用的情况下唤醒线程。
- en: There's more...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Note that we explicitly unlocked mutex before calling `notify_one()`. However,
    without unlocking, our example still works.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在调用`notify_one()`之前，我们明确解锁了互斥锁。然而，即使不解锁，我们的例子仍然可以工作。
- en: But, in that case, the thread that has woken up may be blocked once again during
    an attempt to call `lock.lock()` deep inside `cond_wait(lock)`, which leads to
    more context switches and worse performance.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在这种情况下，唤醒的线程可能在尝试在`cond_wait(lock)`中的`lock.lock()`时再次被阻塞，这会导致更多的上下文切换和更差的性能。
- en: 'With `tests_tasks_count` set to `3000000` and without explicit unlocking, this
    example runs for 7 seconds:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 将`tests_tasks_count`设置为`3000000`，并且不进行显式解锁，这个例子运行了7秒：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With explicit unlocking, this example runs for 5 seconds:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 进行显式解锁后，这个例子运行了5秒：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You may also notify all the threads waiting on a specific conditional variable
    using `cond_.notify_all()`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`cond_.notify_all()`来通知所有等待特定条件变量的线程。
- en: 'Some extremely exotic operating systems had an extremely rare issue with calling
    `notify_one()` outside the critical section (without holding a lock) on Boost
    before version 1.64 [https://github.com/boostorg/thread/pull/105](https://github.com/boostorg/thread/pull/105).
    It''s doubtful that you will ever work with those. But, anyway, to avoid issues
    on those platforms, you may add a `flush()` function to the `work_queue` class
    that holds a lock and calls `notify_all()`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一些极端的操作系统在Boost 1.64版本之前（https://github.com/boostorg/thread/pull/105）在临界区外（没有持有锁）调用`notify_one()`时可能会出现极为罕见的问题。你很少会遇到这种情况。但是，为了避免在这些平台上出现问题，你可以在`work_queue`类中添加一个`flush()`函数，它持有一个锁并调用`notify_all()`：
- en: '`void flush() {` `boost::lock_guard<boost::mutex> lock(tasks_mutex_);` `cond_.notify_all();`
    `}`'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`void flush() {` `boost::lock_guard<boost::mutex> lock(tasks_mutex_);` `cond_.notify_all();`
    `}`'
- en: Call `flush()` when you are done with pushing tasks in a queue to force the
    wakeup of all the threads.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成了将任务推入队列的操作时，请调用`flush()`来强制唤醒所有线程。
- en: The C++11 standard has `std::condition_variable` declared in the `<condition_variable>`
    header and `std::unique_lock` declared in the `<mutex>` header. Use the Boost
    version if you use C++03 compiler or just use some of the Boost's extensions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: C++11标准在`<condition_variable>`头文件中声明了`std::condition_variable`，在`<mutex>`头文件中声明了`std::unique_lock`。如果你使用C++03编译器，可以使用Boost版本，或者使用Boost的一些扩展。
- en: The `work_queue` class could be significantly improved by adding support for
    **rvalue references** and calling `std::move(tasks_.front())`. This will make
    the code in the critical section much faster, resulting in less threads, suspends,
    and wakeups, less cache misses and a much better performance.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加对**右值引用**的支持并调用`std::move(tasks_.front())`，`work_queue`类可以得到显着改进。这将使关键部分的代码更快，减少线程、挂起和唤醒，减少缓存未命中，从而提高性能。
- en: See also
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The first three recipes in this chapter provide a lot of useful information
    about `Boost.Thread`
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的前三个配方提供了关于`Boost.Thread`的许多有用信息
- en: The official documentation may give you many more examples and some theoretical
    information on the topic; it can be found at [http://boost.org/libs/thread](http://boost.org/libs/thread)
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方文档可能会给您更多的例子和一些关于这个主题的理论信息；它可以在[http://boost.org/libs/thread](http://boost.org/libs/thread)找到
- en: Multiple-readers-single-writer lock
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多读者单写者锁
- en: 'Imagine that we are developing some online services. We have an unordered map
    of registered users with some properties for each user. This set is accessed by
    many threads, but it is very rarely modified. All operations with the following
    set are done in a thread-safe manner:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们正在开发一些在线服务。我们有一个无序映射的注册用户，每个用户都有一些属性。这个集合被许多线程访问，但很少被修改。对以下集合的所有操作都是线程安全的：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Unfortunately, our online service is somehow slow and the profilers show that
    the problem is in the `users_online` class. Any operation acquires a unique lock
    on the `mutex_` variable, so even getting resources results in waiting on a locked
    mutex. As some of the resources are hard to copy, the critical sections consume
    a lot of time, slowing down any operation on the `users_online` class.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们的在线服务在某种程度上很慢，分析器显示问题出在`users_online`类中。任何操作都会在`mutex_`变量上获得独占锁，因此即使获取资源也会导致在锁定的互斥锁上等待。由于一些资源很难复制，关键部分消耗了大量时间，从而减慢了对`users_online`类的任何操作。
- en: Unfortunately, the project requirements do not allow us to redesign the class.
    Can we speed it up without interface changes?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，项目要求不允许我们重新设计类。我们能否在不更改接口的情况下加快速度？
- en: Getting ready
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Make sure that you feel comfortable with `boost::thread` or `std::thread` and
    know the basics of mutexes.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您对`boost::thread`或`std::thread`感到满意，并了解互斥锁的基础知识。
- en: How to do it...
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'This will probably help:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会有所帮助：
- en: 'Replace `boost::mutex` with `boost::shared_mutex`. Replace `boost::unique_locks`
    with `boost::shared_lock` for methods that do not modify data:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 用`boost::shared_mutex`替换`boost::mutex`。对于不修改数据的方法，用`boost::shared_lock`替换`boost::unique_locks`：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We can allow getting the data from multiple threads simultaneously if those
    threads do not modify data. We need to uniquely own the mutex only if we are going
    to modify the data protected by it. In all other situations, simultaneous access
    to data is allowed. And that is what `boost::shared_mutex` was designed for. It
    allows shared locking (read locking), which allows multiple simultaneous access
    to resources.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些线程不修改数据，我们可以允许多个线程同时从中获取数据。我们只需要独占拥有互斥锁，如果我们要修改由它保护的数据。在所有其他情况下，允许对数据进行同时访问。这就是`boost::shared_mutex`的设计目的。它允许共享锁定（读锁定），允许对资源进行多个同时访问。
- en: When we do try to unique lock a resource that is shared locked, operations will
    be blocked till there are no read locks remaining, and only after that resource
    is unique locked, forcing new shared locks to wait until the unique lock is released.
    `boost::shared_lock` locking for reading and writing is much slower than the usual
    `boost::mutex` locking. Do not use `boost::shared_lock` unless you are sure that
    there's no good way to redesign your code and you are sure that `boost::shared_lock`
    will speed things up.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试对共享锁定的资源进行独占锁定时，操作将被阻塞，直到没有剩余的读锁，然后才能对该资源进行独占锁定，迫使新的共享锁等待直到独占锁被释放。`boost::shared_lock`用于读取和写入的锁定比通常的`boost::mutex`锁定要慢得多。除非您确定没有好的方法重新设计您的代码，并且确定`boost::shared_lock`会加快速度，否则不要使用`boost::shared_lock`。
- en: Some readers may see the `mutable` keyword for the first time. This keyword
    can be applied to non-static and non-constant class members. The `mutable` data
    member can be modified in the constant member functions and is usually used for
    mutexes and other helper variables that are not directly related to the class
    logic.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一些读者可能是第一次看到`mutable`关键字。这个关键字可以应用于非静态和非常量的类成员。`mutable`数据成员可以在常量成员函数中修改，通常用于互斥锁和其他与类逻辑无直接关系的辅助变量。
- en: There's more...
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When you do need only unique locks, do not use `boost::shared_mutex` because
    it is slower than a usual `boost::mutex` class.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当您只需要独占锁时，不要使用`boost::shared_mutex`，因为它比通常的`boost::mutex`类更慢。
- en: Shared mutexes were not available in C++ until C++14\. `shared_timed_mutex`
    and `shared_lock` are defined in the `<shared_mutex>` header in `std::` namespace.
    They have performance characteristics close to the Boost versions, so apply all
    the preceding performance notes.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 直到C++14之前，C++中还没有共享互斥锁。`shared_timed_mutex`和`shared_lock`在`std::`命名空间的`<shared_mutex>`头文件中定义。它们的性能特征接近Boost版本，因此应用所有前面的性能注意事项。
- en: C++17 has a `shared_mutex` that may be slightly faster than `shared_timed_mutex`,
    because it dose not provide the means for timed locking. This may save you a few
    precious nanoseconds.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: C++17有一个`shared_mutex`，可能比`shared_timed_mutex`稍快，因为它不提供定时锁定的手段。这可能会节省一些宝贵的纳秒。
- en: See also
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: There is also a `boost::upgrade_mutex` class, which may be useful for cases
    when shared lock needs promotion to unique lock. See the `Boost.Thread` documentation
    at [http://boost.org/libs/thread](http://boost.org/libs/thread) for more information.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有一个`boost::upgrade_mutex`类，对于需要将共享锁提升为独占锁的情况可能会有用。有关更多信息，请参阅[http://boost.org/libs/thread](http://boost.org/libs/thread)上的`Boost.Thread`文档。
- en: Refer to [http://herbsutter.com/2013/01/01/video-you-dont-know-const-and-mutable/](http://herbsutter.com/2013/01/01/video-you-dont-know-const-and-mutable/)
    for more information about the mutable keyword.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关可变关键字的更多信息，请参阅[http://herbsutter.com/2013/01/01/video-you-dont-know-const-and-mutable/](http://herbsutter.com/2013/01/01/video-you-dont-know-const-and-mutable/)。
- en: Creating variables that are unique per thread
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建每个线程唯一的变量
- en: 'Let''s take a glance at the recipe *Creating* *work_queue class*. Each task
    there can be executed in one of the many threads and we do not know in which one.
    Imagine that we want to send the results of an executed task using some connection:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看*创建* *work_queue类*的配方。那里的每个任务都可以在许多线程中的一个中执行，我们不知道在哪一个中执行。想象一下，我们想使用某个连接发送执行任务的结果：
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We have the following solutions:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下解决方案：
- en: Open a new connection when we need to send the data (which is very slow)
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在需要发送数据时打开新连接（这非常慢）
- en: Have a single connection for all the threads and wrap them in mutex (which is
    also slow)
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个线程只有一个连接，并在互斥体中包装它们（这也很慢）
- en: Have a pool of connections, get a connection from it in a thread-safe manner,
    and use it (a lot of coding is required, but this solution is fast)
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有一个连接池，在线程安全的方式下从中获取连接并使用它（需要大量编码，但这种解决方案很快）
- en: Have a single connection per thread (fast and simple to implement)
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个线程只有一个连接（快速且简单实现）
- en: So, how can we implement the last solution?
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何实现最后的解决方案？
- en: Getting ready
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of threads is required.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 需要基本的线程知识。
- en: How to do it...
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'It is time to make a thread local variable. Declare a function in a header
    file after the `connection` class definition:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候创建一个线程本地变量了。在`connection`类定义之后的头文件中声明一个函数：
- en: '[PRE29]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Make your source file look like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使您的源文件看起来像这样：
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Done. Using a thread-specific resource was never so easy:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 完成。使用特定于线程的资源从未如此简单：
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `boost::thread_specific_ptr` variable holds a separate pointer for each
    thread. Initially, this pointer is equal to `nullptr`; that is why we check for
    `!p` and open a connection if it is `nullptr`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::thread_specific_ptr`变量为每个线程保存一个单独的指针。最初，此指针等于`nullptr`；这就是为什么我们检查`!p`并在其为`nullptr`时打开连接。'
- en: So, when we enter `get_connection()` from the thread that already initiated
    the pointer, `!p` return the value `false` and we return the already opened connection.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们从已经初始化指针的线程进入`get_connection()`时，`!p`返回值为`false`，我们返回已经打开的连接。
- en: '`delete` for the pointer stored inside the `connection_ptr` variable is called
    when the thread is exiting, so we do not need to worry about memory leaks.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在线程退出时调用存储在`connection_ptr`变量中的指针的`delete`，因此我们不需要担心内存泄漏。
- en: There's more...
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You may provide your own cleanup function that will be called instead of `delete`
    at thread exit. A cleanup function must have the `void (*cleanup_function)(T*)`
    signature and must be passed during the `boost::thread_specific_ptr` construction.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以提供自己的清理函数，该函数将在线程退出时调用，而不是调用`delete`。清理函数必须具有`void (*cleanup_function)(T*)`签名，并且必须在`boost::thread_specific_ptr`构造期间传递。
- en: C++11 has a special keyword, `thread_local`, to declare variables with thread
    local storage duration. C++11 has no `thread_specific_ptr` class, but you may
    use `thread_local T` or `thread_local std::unique_ptr<T>` to achieve the same
    behavior on compilers that support `thread_local`. `boost::thread_specific_ptr`
    works on pre-C++11 compilers, unlike `thread_local`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: C++11有一个特殊的关键字`thread_local`，用于声明具有线程本地存储期的变量。C++11没有`thread_specific_ptr`类，但您可以在支持`thread_local`的编译器上使用`thread_local
    T`或`thread_local std::unique_ptr<T>`来实现相同的行为。`boost::thread_specific_ptr`适用于C++11之前的编译器，而`thread_local`则不适用。
- en: C++17 has `inline` variables, and you may use `thread_local` with `inline` to
    declare thread local variables in header files.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: C++17有`inline`变量，您可以在头文件中使用`inline`和`thread_local`声明线程本地变量。
- en: See also
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The `Boost.Thread` documentation gives a lot of good examples on different cases;
    it can be found at [http://boost.org/libs/thread](http://boost.org/libs/thread)
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Thread`文档提供了许多不同情况下的良好示例；可以在[http://boost.org/libs/thread](http://boost.org/libs/thread)找到。'
- en: Reading this topic at [http://stackoverflow.com/questions/13106049/c11-gcc-4-8-thread-local-performance-penalty.html](http://stackoverflow.com/questions/13106049/c11-gcc-4-8-thread-local-performance-penalty.html)
    and about the GCCs `__thread` keyword at [http://gcc.gnu.org/onlinedocs/gcc-3.3.1/gcc/Thread-Local.html](http://gcc.gnu.org/onlinedocs/gcc-3.3.1/gcc/Thread-Local.html)
    may give you some ideas about how `thread_local` is implemented in compilers and
    how fast it is
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读此主题[http://stackoverflow.com/questions/13106049/c11-gcc-4-8-thread-local-performance-penalty.html](http://stackoverflow.com/questions/13106049/c11-gcc-4-8-thread-local-performance-penalty.html)以及关于GCC的`__thread`关键字[http://gcc.gnu.org/onlinedocs/gcc-3.3.1/gcc/Thread-Local.html](http://gcc.gnu.org/onlinedocs/gcc-3.3.1/gcc/Thread-Local.html)可能会给您一些关于`thread_local`在编译器中是如何实现以及有多快的想法
- en: Interrupting a thread
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中断线程
- en: 'Sometimes, we need to kill a thread that has eaten too many resources or that
    is just executing for too long. For example, some parser works in a thread (and
    actively uses `Boost.Thread`), but we have already got the required amount of
    data from it, so parsing can be stopped. Here''s the stub:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要终止消耗了太多资源或执行时间过长的线程。例如，某些解析器在一个线程中工作（并且积极使用`Boost.Thread`），但我们已经从中获取了所需数量的数据，因此可以停止解析。这是存根：
- en: '[PRE32]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How can we do it?
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何做？
- en: Getting ready
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Almost nothing is required for this recipe. You only need to have at least a
    basic knowledge of threads.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方几乎不需要任何东西。您只需要至少有基本的线程知识。
- en: How to do it...
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We can stop a thread by interrupting it:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过中断来停止线程：
- en: '[PRE33]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works...
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: '`Boost.Thread` provides some predefined **interruption points** in which the
    thread is checked for being interrupted via the `interrupt()` call. If the thread
    is interrupted, the exception `boost::thread_interrupted` is thrown. While the
    exception is propagated through the `do_parse()` internals, it calls destructors
    for all the resources, just like a typical exception does. `boost::thread_interrupted`
    exceptions are treated specially by the `Boost.Thread` library, and for that exception,
    it is allowed to leave the thread function (`do_parse()` in our example). When
    the exception leaves the thread function, it is caught by the `boost::thread`
    internals and treated as a request to cancel the thread.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Thread`在其中提供了一些预定义的**中断点**，线程通过`interrupt()`调用来检查是否被中断。如果线程被中断，将抛出异常`boost::thread_interrupted`。当异常通过`do_parse()`内部传播时，它会调用所有资源的析构函数，就像典型的异常一样。`boost::thread_interrupted`异常在`Boost.Thread`库中被特殊对待，对于该异常，允许离开线程函数（例如我们的示例中的`do_parse()`）。当异常离开线程函数时，它被`boost::thread`内部捕获，并被视为取消线程的请求。'
- en: '`boost::thread_interrupted` is not derived from `std::exception`! Interruptions
    work well if you catch exceptions by their type or by references to `std::exception`.
    But if you catch an exception by `catch (...)` and do not rethrow it, the interruptions
    won''t work.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::thread_interrupted`不是从`std::exception`派生的！如果通过类型或引用`std::exception`捕获异常，中断将有效。但是，如果通过`catch
    (...)`捕获异常并且不重新抛出它，中断将无效。'
- en: As we know from the first recipe in this chapter, if a function passed into
    a thread does not catch an exception and the exception leaves function bounds,
    the application terminates. `boost::thread_interrupted` is the only exception
    to that rule; it may leave function bounds and does not `std::terminate()` the
    application.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从本章的第一个示例中所知道的，如果传递给线程的函数没有捕获异常并且异常离开函数范围，应用程序将终止。`boost::thread_interrupted`是唯一的例外；它可以离开函数范围，并且不会`std::terminate()`应用程序。
- en: There's more...
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Interruption points of the `Boost.Thread` library are listed in official documentation.
    As a rule of a thumb everything that blocks checks for interruptions.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Thread`库的中断点在官方文档中列出。一般来说，一切阻塞都会检查中断。'
- en: 'We may also manually add interruption points at any place. All we need is to
    call `boost::this_thread::interruption_point()`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在任何地方手动添加中断点。我们只需要调用`boost::this_thread::interruption_point()`：
- en: '[PRE34]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If interruptions are not required for a project, defining `BOOST_THREAD_DONT_PROVIDE_INTERRUPTIONS`
    gives a small performance boost and totally disables thread interruptions.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目不需要中断，定义`BOOST_THREAD_DONT_PROVIDE_INTERRUPTIONS`会提供一点性能提升，并完全禁用线程中断。
- en: 'C++11 has no thread interruptions, but you can partially emulate them using
    atomic operations:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: C++11没有线程中断，但可以使用原子操作部分模拟它们：
- en: Create an atomic `bool` variable
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个原子`bool`变量
- en: Check the atomic variable in the thread and throw an exception if it has changed
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线程中检查原子变量，如果发生变化，则抛出异常
- en: Do not forget to catch that exception in the function passed to the thread (otherwise
    your application will terminate)
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要忘记在传递给线程的函数中捕获异常（否则你的应用程序将终止）
- en: However, this won't help you if the code is waiting somewhere in a conditional
    variable or in a sleep method.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果代码在条件变量或睡眠方法中等待，这将无济于事。
- en: See also
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The official documentation for `Boost.Thread` provides a list of predefined
    interruption points at [http://www.boost.org/doc/libs/1_64_0/doc/html/thread/thread_management.html#thread.thread_management.tutorial.interruption.predefined_interruption_points](http://www.boost.org/doc/libs/1_64_0/doc/html/thread/thread_management.html#thread.thread_management.tutorial.interruption.predefined_interruption_points)
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Thread`的官方文档提供了预定义的中断点列表，网址为[http://www.boost.org/doc/libs/1_64_0/doc/html/thread/thread_management.html#thread.thread_management.tutorial.interruption.predefined_interruption_points](http://www.boost.org/doc/libs/1_64_0/doc/html/thread/thread_management.html#thread.thread_management.tutorial.interruption.predefined_interruption_points)'
- en: As an exercise, see the other recipes from this chapter and think of where additional
    interruption points would improve the code
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为练习，查看本章的其他示例，并考虑在哪些地方添加额外的中断点会改善代码
- en: Reading other parts of the `Boost.Thread` documentation may be useful; go to
    [http://boost.org/libs/thread](http://boost.org/libs/thread)
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读`Boost.Thread`文档的其他部分可能会有用；请访问[http://boost.org/libs/thread](http://boost.org/libs/thread)
- en: Manipulating a group of threads
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作一组线程
- en: 'Those readers who were trying to repeat all the examples by themselves, or
    those who were experimenting with threads must already be bored with writing the
    following code to launch and join threads:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 那些试图自己重复所有示例或者试验线程的读者，可能已经厌倦了编写以下代码来启动和加入线程：
- en: '[PRE35]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Maybe there is a better way to do this?
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 也许有更好的方法来做这个？
- en: Getting ready
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of threads will be more than enough for this recipe.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 对线程的基本知识将足够应对这个问题。
- en: How to do it...
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We may manipulate a group of threads using the `boost::thread_group` class.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`boost::thread_group`类来操作一组线程。
- en: 'Construct a `boost::thread_group` variable:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造一个`boost::thread_group`变量：
- en: '[PRE36]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create threads into the preceding variable:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的变量中创建线程：
- en: '[PRE37]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, you may call functions for all the threads inside `boost::thread_group`:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以在`boost::thread_group`中为所有线程调用函数：
- en: '[PRE38]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works...
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `boost::thread_group` variable just holds all the threads constructed or
    moved to it and may send some calls to all the threads.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::thread_group`变量只是保存了所有构造或移动到其中的线程，并可以向所有线程发送一些调用。'
- en: There's more...
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: C++11 has no `thread_group` class; it's Boost specific.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: C++11没有`thread_group`类；这是Boost特有的。
- en: See also
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The official documentation of `Boost.Thread` may surprise you with a lot of
    other useful classes that are not described in this chapter; go to [http://boost.org/libs/thread](http://boost.org/libs/thread).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Thread`的官方文档可能会给你带来很多其他有用的类，这些类在本章节中没有描述；请访问[http://boost.org/libs/thread](http://boost.org/libs/thread)。'
- en: Initializing a shared variable safely
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全地初始化共享变量
- en: 'Imagine that we are designing a safety-critical class that is used from multiple
    threads, receives answers from a server, postprocesses them, and outputs the response:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们正在设计一个安全关键的类，该类从多个线程中使用，从服务器接收答案，对其进行后处理，并输出响应：
- en: '[PRE39]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Note the `return read_defaults();` line. There may be situations when server
    does not respond because of networking issues or some other problems. In those
    cases, we attempt to read defaults from file:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`return read_defaults();`这一行。可能会出现服务器由于网络问题或其他问题而无法响应的情况。在这种情况下，我们尝试从文件中读取默认值：
- en: '[PRE40]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'From the preceding code, we hit the problem: the server may be unreachable
    for some noticeable time, and for all that time we''ll be rereading the file on
    each `act` call. This significantly affects performance.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们遇到了问题：服务器可能在一段显著的时间内无法访问，并且在所有这段时间内，我们将在每次`act`调用时重新读取文件。这显著影响了性能。
- en: 'We can attempt to fix it by storing `default_` inside the class:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试通过在类内部存储`default_`来修复它：
- en: '[PRE41]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'That''s also not a perfect solution: we do not know how many instances of `postprocessor`
    class are constructed by the user and we are wasting memory on defaults that may
    not be required during the run.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这也不是一个完美的解决方案：我们不知道用户构造了多少个`postprocessor`类的实例，并且我们在可能在运行过程中不需要的默认值上浪费了内存。
- en: So, we have to concurrent-safely read and store the data in the current instance
    on the first remote server failure and do not read it again on the next failures.
    There are many ways to do that, but let's look at the most right one.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须在第一次远程服务器失败时并发安全地读取和存储数据，并且在下一次失败时不再读取。有许多方法可以做到这一点，但让我们看看最正确的方法。
- en: Getting ready
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: Basic knowledge of threads is more than enough for this recipe.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，基本的线程知识已经足够了。
- en: How to do it...
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We have to add variables for storing information that defaults were initialized
    and a variable for storing the defaults:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须添加变量来存储默认值已经初始化的信息，以及一个变量来存储默认值：
- en: '[PRE42]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Variables are `mutable` because we are going to modify them inside `const` member
    functions.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是`mutable`，因为我们将在`const`成员函数内部修改它们。
- en: 'Let''s initialize our variables:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们初始化我们的变量：
- en: '[PRE43]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, let''s change the `act` function:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们改变`act`函数：
- en: '[PRE44]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How it works...
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In short, `boost::call_once` and `boost::once_flag` make sure that the function
    passed as a second parameter is executed only once.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`boost::call_once`和`boost::once_flag`确保第二个参数作为函数只执行一次。
- en: The `boost::call_once` function synchronizes calls to the function *F* passed
    as a second argument. `boost::call_once` and `boost::once_flag` make sure that
    only one call to the function *F* progresses if there are two or more concurrent
    calls on the same `once_flag` and make sure that only once successful call to
    *F* is performed.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::call_once`函数同步调用作为第二个参数传递的函数*F*。`boost::call_once`和`boost::once_flag`确保在同一个`once_flag`上有两个或更多并发调用时，只有一个对函数*F*的调用会进行，确保只有一次对*F*的成功调用。'
- en: If the call to function *F* has not thrown exceptions that left the body of
    *F*, then `boost::call_once` assumes that the call was successful and stores that
    information inside the `boost::once_flag`. Any subsequent calls to `boost::call_once`
    with the same `boost::once_flag` do nothing.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对函数*F*的调用没有抛出异常离开*F*的主体，那么`boost::call_once`假定调用成功，并将该信息存储在`boost::once_flag`内。对具有相同`boost::once_flag`的`boost::call_once`的任何后续调用都不起作用。
- en: Do not forget to initialize the `boost::once_flag` with the `BOOST_ONCE_INIT`
    macro.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记使用`BOOST_ONCE_INIT`宏初始化`boost::once_flag`。
- en: There's more..
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `boost::call_once` may pass parameters to the function to call:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::call_once`可以将参数传递给要调用的函数：'
- en: '[PRE45]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, if we call `once_printer` function in a loop:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们在循环中调用`once_printer`函数：
- en: '[PRE46]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Only a single line will be in the output:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一行将被输出：
- en: '[PRE47]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: C++11 has a `std::call_once` and `std::once_flag` in the `<mutex>` header. Unlike
    the Boost version, the standard library version of the `once_flag` does not require
    initialization via a macro, it has a constexpr constructor. As usual, Boost version
    is usable on pre-C++11 compilers, so use it if you have to support old compilers.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: C++11在`<mutex>`头文件中有`std::call_once`和`std::once_flag`。与Boost版本不同，标准库版本的`once_flag`不需要通过宏进行初始化，它有一个constexpr构造函数。通常情况下，如果必须支持旧编译器，则可以使用Boost版本。
- en: Visual Studio before 2015 was shipping a suboptimal `std::call_once` implementation
    more than ten times slower than the Boost's version. Stick to the `boost::call_once`
    if you're not using modern compilers.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年之前的Visual Studio发行的`std::call_once`实现效率不佳，比Boost版本慢十多倍。如果不使用现代编译器，请使用`boost::call_once`。
- en: See also
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The `Boost.Thread` documentation gives a lot of good examples on different cases.
    It can be found at [http://boost.org/libs/thread.](http://boost.org/libs/thread)
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Thread`文档提供了许多不同情况下的很好的例子。可以在[http://boost.org/libs/thread](http://boost.org/libs/thread)找到。'
- en: Locking multiple mutexes
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锁定多个互斥体
- en: For the next few paragraphs, you'll be one of the people who write games. Congratulations,
    you can play at work!
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几段中，你将成为编写游戏的人之一。恭喜，你可以在工作中玩游戏！
- en: 'You''re developing a server and you have to write code for exchanging loot
    between two users:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在开发一个服务器，必须编写代码来在两个用户之间交换战利品：
- en: '[PRE48]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Each user action could be concurrently processed by different threads on a
    server, so you have to guard the resources by mutexes. The junior developer tried
    to deal with the problem, but his solution does not work:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用户操作都可能由服务器上的不同线程并发处理，因此您必须通过互斥体保护资源。初级开发人员试图解决问题，但他的解决方案不起作用：
- en: '[PRE49]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The issue in the preceding code is a well-known **ABBA deadlock** problem. Imagine
    that *thread 1* locks *mutex A* and *thread 2* locks *mutex B*. And now *thread
    1* attempts to lock the already locked *mutex B* and *thread 2* attempts to lock
    the already locked *mutex A*. This results in two threads locked for infinity
    by each other, as they need a resource locked by other thread to proceed while
    the other thread waits for a resource owned by the current thread.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 上面代码中的问题是一个众所周知的**ABBA死锁**问题。想象一下*线程1*锁定*互斥锁A*，*线程2*锁定*互斥锁B*。现在*线程1*尝试锁定已经被锁定的*互斥锁B*，而*线程2*尝试锁定已经被锁定的*互斥锁A*。这导致两个线程相互无限期地锁定，因为它们需要另一个线程拥有的资源才能继续，而另一个线程则在等待当前线程拥有的资源。
- en: Now, if user1 and user2 call `exchange_loot` for each other concurrently, then
    we may end up with a situation that `user1.exchange_loot(user2)` calls locked
    `user1.loot_mutex_` and `user2.exchange_loot(user1)` calls locked `user2.loot_mutex_`.
    `user1.exchange_loot(user2)` waits for infinity in attempt to lock `user2.loot_mutex_`
    and `user2.exchange_loot(user1)` waits for infinity in an attempt to lock `user1.loot_mutex_`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果`user1`和`user2`同时为对方调用`exchange_loot`，那么我们可能会出现这样的情况，即`user1.exchange_loot(user2)`调用锁定了`user1.loot_mutex_`，而`user2.exchange_loot(user1)`调用锁定了`user2.loot_mutex_`。`user1.exchange_loot(user2)`会无限等待尝试锁定`user2.loot_mutex_`，而`user2.exchange_loot(user1)`会无限等待尝试锁定`user1.loot_mutex_`。
- en: Getting ready
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of threads and mutexes is enough for this recipe.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 对线程和互斥锁的基本知识就足够了。
- en: How to do it...
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'There are two major out-of-the-box solutions to that problem:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 对此问题有两个主要的开箱即用的解决方案：
- en: 'The short one that requires variadic template support from the compiler:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要编译器支持可变模板的短模板：
- en: '[PRE50]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The same code using using `auto`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`auto`的相同代码：
- en: '[PRE51]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The portable solution:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可移植解决方案：
- en: '[PRE52]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works...
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The core idea is to order mutexes somehow and lock them always following that
    particular order. In that case, there's no ABBA problem possible, as all the threads
    would always lock mutex *A* before *B*. Usually, other deadlock avoidance algorithms
    are used but for the simplicity of the example here, we assume that the ordering
    of mutexes is used.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 核心思想是以某种方式对互斥锁进行排序，并始终按照特定顺序锁定它们。在这种情况下，不可能出现ABBA问题，因为所有线程在锁定互斥锁*A*之前始终会锁定互斥锁*B*。通常会使用其他死锁避免算法，但为了简单起见，我们假设了互斥锁的排序。
- en: In the first example, we used `boost::make_unique_locks` that always locks threads
    in some particular order and returns a tuple that holds the locks.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，我们使用了`boost::make_unique_locks`，它总是以特定顺序锁定线程并返回一个持有锁的元组。
- en: In the second example, we created the locks manually but have not locked them
    thanks to a passed `boost::defer_lock` parameter. The actual locking happened
    in the `boost::lock(l0, l1)` call, which locked the mutexes in some predefined
    order.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，我们手动创建了锁，但由于传递了`boost::defer_lock`参数，没有锁定它们。实际的锁定发生在`boost::lock(l0,
    l1)`调用中，它以预定义的顺序锁定了互斥锁。
- en: Now, if `user1` and `user2` call `exchange_loot` for each other concurrently,
    then both `user1.exchange_loot(user2)` and `user2.exchange_loot(user1)` calls
    will try to lock `user1.loot_mutex_` first or both will try to lock `user2.loot_mutex_`
    first. That depends on a runtime.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果`user1`和`user2`同时为对方调用`exchange_loot`，那么`user1.exchange_loot(user2)`和`user2.exchange_loot(user1)`的调用都会尝试首先锁定`user1.loot_mutex_`，或者两者都会尝试首先锁定`user2.loot_mutex_`。这取决于运行时。
- en: There's more...
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '`boost::make_unique_locks` and `boost::lock` functions may accept more than
    2 locks or mutexes, so you could use them in more advanced cases, where more than
    two mutexes must be locked simultaneously.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::make_unique_locks`和`boost::lock`函数可能接受超过2个锁或互斥锁，因此您可以在需要同时锁定两个以上互斥锁的更高级情况下使用它们。'
- en: C++11 has a `std::lock` function defined in the header `<mutex>` that behaves
    exactly like the `boost::lock` function.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: C++11在头文件`<mutex>`中定义了一个`std::lock`函数，其行为与`boost::lock`函数完全相同。
- en: 'C++17 has a much more beautiful solution:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: C++17有一个更美观的解决方案：
- en: '[PRE53]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the preceding code, `std::scoped_lock` is a class that accepts a variadic
    amount of locks. It has variadic template parameters that are automatically deduced
    from the C++17 deduction guide. The actual type of the `std::scoped_lock` from
    the preceding example is:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，`std::scoped_lock`是一个接受可变数量锁的类。它具有可变模板参数，这些参数可以从C++17的推导指南中自动推导出来。上面例子中`std::scoped_lock`的实际类型是：
- en: '[PRE54]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `std::scoped_lock` holds a lock to all the mutexes passed during construction
    and avoids deadlocks. In other words, it works like the first example, but looks
    slightly better.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::scoped_lock`在构造期间持有所有传递的互斥锁的锁，并避免了死锁。换句话说，它的工作原理类似于第一个例子，但看起来更好一些。'
- en: See also
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The official documentation of `Boost.Thread` may surprise you with a lot of
    other useful classes that were not described in this chapter; go to [http://boost.org/libs/thread.](http://boost.org/libs/thread)
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Thread`的官方文档可能会给您带来很多其他有用的类，这些类在本章中没有描述；请访问[http://boost.org/libs/thread.](http://boost.org/libs/thread)'
