- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Permutations, Partitions, and Heaps
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排列、分区和堆
- en: This chapter explores some of the most essential yet often overlooked aspects
    of the algorithmic library of the C++ **Standard Template Library** (**STL**).
    The chapter sheds light on sequence organization through partitioning, sequence
    variation via permutations, and the fascinating world of heap-based operations.
    These operations are the backbone of many advanced algorithms and data structures.
    By understanding and mastering them, developers can enhance the efficiency of
    their applications, optimize data handling, and ensure the integrity of their
    datasets.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了C++ **标准模板库**（**STL**）算法库中最基本且经常被忽视的一些方面。本章通过分区来阐明序列组织，通过排列来改变序列，以及基于堆的操作的迷人世界。这些操作是许多高级算法和数据结构的基础。通过理解和掌握它们，开发者可以提高其应用程序的效率，优化数据处理，并确保数据集的完整性。
- en: 'In this chapter, we will cover the following topics related to STL:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍与STL相关的一些主题：
- en: Partitioning
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分区
- en: Permutations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排列
- en: Heap operations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆操作
- en: Best practices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code in this chapter can be found on GitHub:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
- en: Partitioning
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分区
- en: '**Partitioning**, in its simplest form, is about organizing sequences based
    on specific criteria, ensuring that all elements for which the requirements hold
    true precede those for which it does not. It is about segregating data efficiently,
    optimizing its organization for rapid access, and enhancing computational efficiency.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**分区**，在其最简单的形式中，是关于根据特定标准组织序列的过程，确保所有满足要求的元素都排在那些不满足要求的元素之前。这是关于高效地隔离数据，优化其组织以实现快速访问，并提高计算效率。'
- en: The C++ STL offers a rich set of algorithms for partitioning tasks. While one
    might be tempted to use simple loops and conditionals to achieve such tasks, these
    STL functions are optimized, tested, and designed to offer the best performance.
    These algorithms are implemented by experts who have a deep understanding of the
    underlying system, handle the edge cases, and typically take advantage of compiler
    optimizations and even (potentially) parallelization.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: C++ STL为分区任务提供了一套丰富的算法。虽然有人可能会倾向于使用简单的循环和条件语句来完成这些任务，但这些STL函数经过了优化、测试和设计，以提供最佳性能。这些算法由对底层系统有深刻理解的专家实现，处理边缘情况，并通常利用编译器优化，甚至（潜在地）并行化。
- en: std::partition and its power
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: std::partition及其功能
- en: 'One of the most foundational functions in this category is `std::partition`.
    This function reorganizes elements in a range based on a predicate. It ensures
    that all elements satisfying the predicate come before those that don’t. But here’s
    a vital thing to remember: the order of the elements is not guaranteed to be preserved.
    If order matters to you, then `std::stable_partition` is your friend. While it
    may have a slightly higher overhead, it retains the relative order of the elements.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类别中最基础的功能之一是`std::partition`。这个函数根据谓词重新组织范围内的元素。它确保所有满足谓词的元素都排在那些不满足谓词的元素之前。但这里有一个需要记住的重要事情：元素的顺序不保证被保留。如果你关心顺序，那么`std::stable_partition`是你的朋友。虽然它可能有一些轻微的开销，但它保留了元素的相对顺序。
- en: 'Let’s look at an example. Consider a sequence of integers, and suppose you’d
    like to separate even numbers from odd ones. A call to `std::partition` with an
    appropriate lambda can swiftly complete the job, as shown in the following code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。考虑一个整数序列，假设你想要将偶数和奇数分开。使用适当的lambda表达式调用`std::partition`可以迅速完成这项工作，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After this operation, the iterator will iterate over the range of odd numbers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个操作之后，迭代器将遍历奇数的范围。
- en: Checking partitions with std::is_partitioned
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用std::is_partitioned检查分区
- en: Once a range is partitioned, it might be beneficial to ensure that the partitioning
    holds true, especially in larger systems or when integrating multiple algorithms.
    Enter `std::is_partitioned`, a handy function that checks whether a range is partitioned
    based on a given predicate. This can be particularly useful when building upon
    multiple operations, ensuring that assumptions about data layout hold firm.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦对范围进行了分区，确保分区正确可能是有益的，尤其是在较大的系统或集成多个算法时。这时，`std::is_partitioned` 函数就派上用场，它检查一个范围是否根据给定的谓词进行了分区。这在基于多个操作构建时尤其有用，确保关于数据布局的假设保持稳固。
- en: The utility of std::partition_point
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`std::partition_point` 的实用性'
- en: After partitioning, one might ask, *Where’s the dividing line?* That’s where
    `std::partition_point` comes into play. This function returns an iterator pointing
    to the first element in the newly partitioned range, which does not satisfy the
    predicate. It assumes the range is partitioned and leverages binary search, ensuring
    a swift response.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 分区之后，人们可能会问：“分界线在哪里？”这正是 `std::partition_point` 函数发挥作用的地方。该函数返回一个迭代器，指向新分区范围内不满足谓词的第一个元素。它假设范围已分区，并利用二分搜索，确保快速响应。
- en: Partitioning beyond basic sequences
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超越基本序列的分区
- en: While the preceding examples primarily use vectors, partitioning isn’t limited
    to them. One can employ these techniques on arrays, lists, and even more advanced
    containers. However, it is crucial to remember that the underlying container characteristics,
    such as random access capability, can influence the efficiency of these operations.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的例子主要使用向量，但分区并不局限于它们。可以在数组、列表以及更高级的容器上应用这些技术。然而，记住底层容器的特性，例如随机访问能力，可能会影响这些操作的效率。
- en: 'Combining these partitioning functions, one can build efficient, flexible,
    and highly organized systems that cater to diverse computational needs. Consider
    the following real-world applications:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 结合这些分区函数，可以构建高效、灵活且高度组织化的系统，以满足多样化的计算需求。考虑以下实际应用：
- en: '`std::is_partitioned` and `std::partition` can be used in various sorting algorithms
    such as Quicksort and Hoare partitioning. They help in efficiently partitioning
    elements based on a condition.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::is_partitioned` 和 `std::partition` 可以用于各种排序算法，如快速排序和豪尔分区。它们有助于根据条件高效地分区元素。'
- en: '`std::partition_point` can be used in binary search algorithms. It helps find
    the first element in a partitioned range that doesn’t satisfy a given condition.
    This can be useful for searching in sorted datasets.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::partition_point` 可以用于二分搜索算法。它有助于找到分区范围内不满足给定条件的第一个元素。这在搜索排序数据集时非常有用。'
- en: '`std::partition` can efficiently separate elements that meet a condition from
    those that do not; for example, filtering even and odd numbers from a list.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::partition` 可以高效地将满足条件的元素与不满足条件的元素分开；例如，从列表中过滤出偶数和奇数。'
- en: '`std::partition` can help separate elements into different partitions based
    on these criteria.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::partition` 可以帮助根据这些标准将元素分离到不同的分区中。'
- en: '`std::partition` can be used to efficiently divide the data based on certain
    conditions, improving parallelization.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::partition` 可以根据某些条件高效地划分数据，从而提高并行化。'
- en: '`std::partition` can be used to partition the data and then analyze the outliers
    separately.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::partition` 可以用来对数据进行分区，然后单独分析异常值。'
- en: '**Game development**: In game development, you might use partitioning to separate
    visible objects from hidden ones for rendering optimization.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏开发**：在游戏开发中，可能会使用分区来分离可见对象和隐藏对象，以优化渲染。'
- en: '**Database queries**: When querying a database, you can use partitioning to
    separate the data that matches specific filter conditions from the rest of the
    dataset.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库查询**：在查询数据库时，可以使用分区来将匹配特定筛选条件的数据与数据集的其余部分分开。'
- en: '**Resource management**: In resource management scenarios, such as memory allocation,
    you can use partitioning to efficiently segregate used and unused memory blocks
    efficiently. As developers, we constantly grapple with diverse data and its efficient
    handling. Partitioning offers a structured way to handle this, enabling optimized
    organization and rapid data access. While seemingly simple, it forms the backbone
    of many advanced algorithms.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源管理**：在资源管理场景中，例如内存分配，可以使用分区来高效地隔离已使用和未使用的内存块。作为开发者，我们不断与各种数据及其高效处理作斗争。分区提供了一种结构化的处理方式，使数据组织优化和快速数据访问成为可能。虽然看似简单，但它构成了许多高级算法的基础。'
- en: By mastering partitioning with the STL, one not only enhances individual operations
    but elevates the overall efficiency and structure of applications. As we progress
    to permutations and heap operations in subsequent sections, remember the foundational
    importance of efficient data organization.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过掌握 STL 中的分区技术，不仅可以提升单个操作的性能，还能提高应用程序的整体效率和结构。随着我们进入后续章节中的排列和堆操作，请记住高效数据组织的基础重要性。
- en: Permutations
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排列
- en: A journey into permutations is a journey into how the elements of a sequence
    can be arranged. With the vastness of the sequences and datasets handled by developers
    today, the ability to organize, shuffle, rotate, and switch elements around becomes
    a fascinating exercise and a critical requirement for many applications. The C++
    STL, with its power-packed permutation algorithms, offers a path to unlock this
    potential effortlessly. In this section, we will learn how to generate, manipulate,
    and rotate permutations, along with practical examples.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 排列的旅程是了解序列元素如何排列的旅程。随着开发者今天处理的序列和数据集的庞大，组织、打乱、旋转和切换元素的能力成为一项迷人的练习，也是许多应用的关键需求。C++
    STL 的强大排列算法提供了一条轻松解锁这种潜力的途径。在本节中，我们将学习如何生成、操作和旋转排列，以及实际示例。
- en: Generating permutations with std::next_permutation
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `std::next_permutation` 生成排列
- en: Imagine listing all possible permutations of a dataset, analyzing them, and
    perhaps using them for a brute-force solution to a problem. The STL provides `std::next_permutation`
    for this exact purpose. Given a range, this function rearranges its elements to
    the next lexicographically greater permutation. When all permutations have been
    exhausted, the function returns `false`, offering a clear signal to the developer.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 想象列出数据集的所有可能排列，分析它们，并可能使用它们作为问题的暴力解决方法。STL 提供了 `std::next_permutation` 用于此目的。给定一个范围，此函数将其元素重新排列为下一个字典序较大的排列。当所有排列都已耗尽时，函数返回
    `false`，为开发者提供清晰的信号。
- en: 'Consider a simple sequence: `{1, 2, 3}`. With successive calls to `std::next_permutation`,
    one can generate `{1, 3, 2}`, `{2, 1, 3}`, and so forth until the sequence loops
    back, as illustrated by the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个简单的序列：`{1, 2, 3}`。通过连续调用 `std::next_permutation`，可以生成 `{1, 3, 2}`、`{2, 1,
    3}` 等等，直到序列循环回，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Predecessor permutations with std::prev_permutation
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `std::prev_permutation` 进行前驱排列
- en: Sometimes, looking backward is essential, exploring permutations that precede
    the current arrangement. The twin to our previously discussed function, `std::prev_permutation`,
    does just that. It transforms the sequence into its immediate lexicographically
    smaller permutation.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，回顾过去是至关重要的，探索先于当前排列的排列。我们之前讨论过的函数 `std::prev_permutation` 的双胞胎就是这样做的。它将序列转换为它的下一个字典序较小的排列。
- en: Shuffling elements randomly with std::shuffle
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `std::shuffle` 随机排列元素
- en: While structured permutations have their place, there are times when randomness
    is the order of the day.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然结构化排列有其位置，但有时随机性才是当天的主题。
- en: Enter `std::shuffle`, an algorithm that rearranges elements in a completely
    random order. Paired with a robust random number generator, it ensures true randomness,
    which is crucial for many applications.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 `std::shuffle`，这是一个完全随机排列元素的算法。与一个强大的随机数生成器配对，它确保了真正的随机性，这对于许多应用至关重要。
- en: 'Real-world uses for `std::shuffle` include the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::shuffle` 的实际应用包括以下内容：'
- en: '`std::shuffle` can be used to achieve this randomness.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::shuffle` 可以用来实现这种随机性。'
- en: '`std::shuffle` can be used to shuffle the answer choices.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::shuffle` 可以用来打乱答案选项。'
- en: '`std::shuffle`, and then pick the first N elements.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::shuffle`，然后选择前 N 个元素。'
- en: '`std::shuffle` can help introduce randomness into the game.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::shuffle` 可以帮助将随机性引入游戏。'
- en: '`std::shuffle` to randomize the order of tracks, providing variety to the listeners.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::shuffle` 随机化轨道的顺序，为听众提供多样性。
- en: '`std::shuffle` can be used to shuffle inputs or events to test different code
    paths.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::shuffle` 可以用来打乱输入或事件，以测试不同的代码路径。'
- en: '**Machine learning and data science**: When training machine learning models
    or conducting experiments in data science, you may need to shuffle the dataset
    to ensure that the model doesn’t learn any order-related biases.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机器学习和数据科学**：在训练机器学习模型或进行数据科学实验时，您可能需要打乱数据集，以确保模型不会学习任何与顺序相关的偏差。'
- en: '`std::shuffle` can be used to generate the randomization needed for such algorithms.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::shuffle` 可以用来生成此类算法所需的随机化。'
- en: '`std::shuffle` to simulate random outcomes or the shuffling of cards or dice.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::shuffle` 模拟随机结果或卡牌或骰子的洗牌。
- en: '`std::shuffle` is unsuitable for cryptographic purposes, the concept of shuffling
    is crucial in cryptographic algorithms for purposes such as card-shuffling functionality
    for secure card games.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::shuffle` 不适合加密目的，但在加密算法中，洗牌的概念对于诸如安全卡牌游戏的卡洗功能等目的至关重要。'
- en: Rotating sequences with std::rotate
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `std::rotate` 旋转序列
- en: Not all permutations involve intricate rearrangements. Sometimes, it is about
    simple rotations. `std::rotate` moves elements so that the chosen element becomes
    the new first element. It’s like turning a dial where the numbers rotate around
    a central point.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的排列都涉及复杂的重新排列。有时，它只是简单的旋转。`std::rotate` 通过移动元素，使得选定的元素成为新的第一个元素。这就像转动一个旋钮，数字围绕一个中心点旋转。
- en: 'The following is a simple example demonstrating the use of `std::rotate`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的示例，展示了 `std::rotate` 的使用：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let us now look at the wide range of real-world applications of `std::rotate`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看 `std::rotate` 的广泛实际应用：
- en: '`std::rotate` can be used to reposition the text efficiently.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::rotate` 可以用来高效地重新定位文本。'
- en: '`std::rotate` can be used to swap or cycle image resources.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::rotate` 可以用来交换或循环图像资源。'
- en: '**Scheduling and time management**: In scheduling applications, you might want
    to shift a schedule by rotating the appointments or tasks for a day or a week
    to accommodate changes.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调度和时间管理**：在调度应用中，你可能希望通过旋转一天或一周的预约或任务来适应变化。'
- en: '`std::rotate` to efficiently manage the movement of data in and out of the
    buffer.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::rotate` 可以用来高效地管理数据在缓冲区内外移动。'
- en: '`std::rotate` can be used for such bit manipulation.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::rotate` 可以用于此类位操作。'
- en: '`std::rotate` as part of the sorting process to handle partially ordered data
    efficiently.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为排序过程的一部分的 `std::rotate`，可以有效地处理部分有序数据。
- en: '**Image processing**: In image processing, you might need to rotate pixel values
    to perform image transformations or manipulations.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像处理**：在图像处理中，你可能需要旋转像素值以执行图像变换或操作。'
- en: '`std::rotate` can be used to shift elements in vectors or arrays when solving
    equations or performing iterative calculations.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::rotate` 可以用来在解决方程或进行迭代计算时在向量或数组中移动元素。'
- en: '**Memory management**: In memory management scenarios, you might need to shift
    memory blocks to optimize memory allocation and defragmentation.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存管理**：在内存管理场景中，你可能需要移动内存块以优化内存分配和碎片整理。'
- en: '**Algorithm optimization**: In algorithm design, rotating elements can help
    improve the efficiency of certain operations by reducing the number of swaps or
    data movements.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**算法优化**：在算法设计中，旋转元素可以通过减少交换或数据移动的数量来帮助提高某些操作的效率。'
- en: '`std::rotate` can be used to simulate the rotation of puzzle pieces.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::rotate` 可以用来模拟拼图块的旋转。'
- en: '`std::rotate` can be employed to create animated effects by rotating or shifting
    data points.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::rotate` 可以用来通过旋转或移动数据点来创建动画效果。'
- en: Permutations with the STL bring forth an exciting blend of mathematical theory
    and practical computing. They embody the spirit of reorganization, viewing data
    from different perspectives and ensuring no stone (or sequence!) is left unturned.
    As we delve deeper into heaps and their operations in the following sections,
    remember this power of permutation, which can transform and re-envision sequences
    in countless ways.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 STL 的排列带来了数学理论与实际计算相结合的激动人心的混合体。它们体现了重组的精神，从不同的角度看待数据，确保没有遗漏任何一点（或序列！）。
- en: Heap operations
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆操作
- en: 'The journey into algorithmic wonders would be incomplete without exploring
    heaps. **Heaps** are unique structures prioritizing data in a specific order,
    ascending or descending. At the heart of a heap lies its promise: the element
    with the highest (or lowest) priority will always be at the top. With the C++
    STL, managing heaps becomes intuitive, lending efficiency and power to applications
    requiring priority-based operations.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不探索堆，算法奇妙的旅程将是不完整的。**堆**是一种独特的结构，它以特定的顺序（升序或降序）优先处理数据。堆的核心是其承诺：具有最高（或最低）优先级的元素始终位于顶部。使用
    C++ STL，堆的管理变得直观，为需要基于优先级操作的应用程序提供了效率和力量。
- en: Constructing heaps with std::make_heap
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `std::make_heap` 构建堆
- en: 'Creating a heap from a random data collection is the first step in the process.
    With `std::make_heap`, one can swiftly transform any sequence into a max heap,
    where the largest element is at the beginning. The following code demonstrates
    the use of `std::make_heap`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从随机数据集合创建堆是这个过程的第一步。使用 `std::make_heap`，可以迅速将任何序列转换为最大堆，其中最大元素位于开头。以下代码演示了 `std::make_heap`
    的使用：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With the simple call above, our `v` vector now holds a valid max heap. Based
    on the given comparator or default comparison, the most significant element will
    always be at the front.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上述简单调用，我们的 `v` 向量现在包含一个有效的最大堆。基于给定的比较器或默认比较，最重要的元素始终位于前端。
- en: Adding and removing elements – std::push_heap and std::pop_heap
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加和删除元素 – std::push_heap 和 std::pop_heap
- en: 'With heaps, the operations aren’t just about looking at the top element. Adding
    and removing data from the heap is fundamental. When a new element is added to
    the underlying sequence, `std::push_heap` ensures it is placed appropriately in
    the heap, as shown in the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用堆时，操作不仅仅是查看顶部元素。向堆中添加和删除数据是基本操作。当新元素添加到底层序列时，`std::push_heap` 确保它被适当地放置在堆中，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Conversely, to remove the top element, `std::pop_heap` is used. This function
    doesn’t erase the element but moves it to the end of the sequence, making it convenient
    for removal, as illustrated in the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，要删除顶部元素，使用 `std::pop_heap`。此函数不会删除元素，而是将其移动到序列的末尾，这使得删除变得方便，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Adding and removing elements from a heap is the core of heap-based operations.
    Now, let’s move on to something a bit more advanced: heap-based sorting.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从堆中添加和删除元素是堆操作的核心。现在，让我们继续探讨一些更高级的内容：基于堆的排序。
- en: Heap-based sorting – the power of std::sort_heap
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于堆的排序 – std::sort_heap 的力量
- en: 'Heaps are more than just priority management. Their structure allows for an
    efficient sorting mechanism. `std::sort_heap` turns the heap into a sorted range
    in ascending order, as shown in the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 堆不仅仅是优先级管理。其结构允许高效的排序机制。`std::sort_heap` 将堆转换为升序排序的范围，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It’s worth noting that heap-based sorting can be especially effective when dealing
    with datasets where insertion and extraction operations are frequent, making it
    a valuable tool in a developer’s toolkit.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，当处理插入和提取操作频繁的数据集时，基于堆的排序可以特别有效，使其成为开发者工具箱中的宝贵工具。
- en: Checking heap validity with std::is_heap
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 std::is_heap 检查堆的有效性
- en: 'Ensuring that a sequence maintains its heap properties is crucial. `std::is_heap`
    offers a quick validity check, returning `true` if the given range forms a heap
    and `false` otherwise, as shown in the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 确保一个序列保持其堆属性至关重要。`std::is_heap` 提供了快速的有效性检查，如果给定的范围形成一个堆则返回 `true`，否则返回 `false`，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This function is especially valuable when working with complex sequences, ensuring
    data operations haven’t disrupted the heap structure.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数在处理复杂序列时特别有价值，确保数据操作没有破坏堆结构。
- en: The significance of heaps in today’s computing
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 今天计算中堆的重要性
- en: Heaps are integral in modern-day computing, from task scheduling to network
    packet management. Their structure facilitates efficient priority management,
    making them indispensable in scenarios including simulations, event-driven programming,
    and more.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 堆在现代计算中至关重要，从任务调度到网络数据包管理。其结构促进了高效的优先级管理，使它们在包括模拟、事件驱动编程等场景中变得不可或缺。
- en: 'These heap-based operations can be used in many real-world scenarios:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基于堆的操作可用于许多实际场景：
- en: '`std::priority_queue` container employs a heap internally to effectively manage
    the highest-priority element at the fore.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::priority_queue` 容器内部使用堆来有效地管理最优先的元素。'
- en: '**Job scheduling**: In job scheduling algorithms, tasks or jobs often have
    associated priorities or deadlines. A min-heap can be used to prioritize and schedule
    tasks efficiently.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作业调度**：在作业调度算法中，任务或作业通常具有相关的优先级或截止日期。可以使用最小堆来有效地优先排序和调度任务。'
- en: '**Dijkstra’s shortest path algorithm**: Dijkstra’s algorithm for finding the
    shortest path in a weighted graph uses a priority queue implemented with a min-heap
    to select the next vertex to explore.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迪杰斯特拉最短路径算法**：迪杰斯特拉算法用于在加权图中找到最短路径，它使用最小堆实现的优先队列来选择下一个要探索的顶点。'
- en: '**Huffman coding**: A popular data compression technique, Huffman coding builds
    a binary tree with characters’ frequencies as weights. A min-heap can be used
    to efficiently merge nodes during tree construction.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Huffman 编码**：一种流行的数据压缩技术，Huffman 编码使用字符频率作为权重构建二叉树。在树构建过程中，最小堆可以用于有效地合并节点。'
- en: '**Heap sort**: Heap sort is a comparison-based sorting algorithm that uses
    a binary heap data structure to repeatedly extract the maximum (for a max-heap)
    or minimum (for a min-heap) element from an unsorted array, resulting in a sorted
    array. It is an in-place sorting algorithm with a time complexity of *O(n* *log
    n)*.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆排序**：堆排序是一种基于比较的排序算法，它使用二叉堆数据结构，通过反复从未排序的数组中提取最大（对于最大堆）或最小（对于最小堆）元素，从而得到一个排序数组。它是一种原地排序算法，时间复杂度为
    *O(n * log n)*。'
- en: '**Event scheduling**: In discrete event simulation or real-time systems, events
    often have associated timestamps. A min-heap can be used to schedule and process
    events in chronological order.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件调度**：在离散事件模拟或实时系统中，事件通常与时间戳相关联。可以使用最小堆来按时间顺序调度和处理事件。'
- en: '**Memory management**: Dynamic memory allocation and deallocation in some memory
    management systems use heaps to efficiently allocate and free memory blocks.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存管理**：在某些内存管理系统中，动态内存分配和释放使用堆来高效地分配和释放内存块。'
- en: '**Load balancing:** Tasks or processes are distributed among available resources
    in load balancing algorithms. A min-heap can help manage resource availability
    and task assignment.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载均衡**：在负载均衡算法中，任务或进程被分配到可用资源中。最小堆可以帮助管理资源可用性和任务分配。'
- en: '**Online median calculation**: When processing a continuous stream of data,
    you can maintain two heaps (a max-heap and a min-heap) to calculate the median
    of the data efficiently.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在线中值计算**：在处理连续数据流时，可以通过维护两个堆（一个最大堆和一个最小堆）来有效地计算数据的中值。'
- en: '**Merge sorted files**: When merging multiple sorted files or streams, a min-heap
    can be used to select the smallest element among all available elements, facilitating
    the merge process.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**合并排序文件**：在合并多个排序文件或流时，可以使用最小堆从所有可用元素中选择最小元素，从而促进合并过程。'
- en: '**Disk space management**: In file systems, managing free disk space efficiently
    often involves maintaining a heap of available disk blocks.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**磁盘空间管理**：在文件系统中，高效管理空闲磁盘空间通常涉及维护一个可用的磁盘块堆。'
- en: '**Job prioritization in print queues**: Print job queues can prioritize print
    jobs based on various factors such as user priority or document size, which can
    be efficiently managed using a priority queue implemented with a heap.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打印队列中的作业优先级**：打印作业队列可以根据用户优先级或文档大小等因素对打印作业进行优先级排序，这可以通过使用堆实现的优先队列来高效管理。'
- en: The heap operations provided by the C++ STL equip developers with the means
    to handle priority-driven tasks efficiently. They merge the theoretical elegance
    of data structures with practical utility. As we transition to best practices
    in the next section, it is essential to internalize the role heaps play in shaping
    efficient, responsive, and reliable applications.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: C++ STL提供的堆操作为开发者提供了高效处理优先级驱动任务的手段。它们将数据结构的理论优雅性与实用性相结合。在我们过渡到下一节的最佳实践时，理解堆在塑造高效、响应和可靠的应用中的作用至关重要。
- en: Best practices
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Navigating permutations, partitions, and heaps offers valuable insights into
    the capabilities of the C++ STL. These foundational elements can significantly
    boost application performance and reliability when used effectively. Following
    best practices is critical to maximizing these benefits and ensuring consistent,
    optimized data operations. These best practices include the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 探索排列、分区和堆可以为C++ STL的能力提供有价值的见解。当有效使用时，这些基础元素可以显著提高应用程序的性能和可靠性。遵循最佳实践对于最大化这些好处和确保一致、优化的数据操作至关重要。这些最佳实践包括以下内容：
- en: '**Simplify permutation tasks**: Though permutations provide a broad range of
    sequence variations, it’s important not to overcomplicate the process. Choose
    permutation operations that directly serve the task at hand. For intricate operations,
    breaking them down can help maintain clarity and focus.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化排列任务**：尽管排列提供了广泛的序列变体，但重要的是不要过度复杂化过程。选择直接服务于当前任务的排列操作。对于复杂的操作，将其分解可以帮助保持清晰和专注。'
- en: '`std::next_permutation` and `std::prev_permutation` to traverse permutations.
    Utilizing these functions eliminates the need to generate permutations manually
    and promotes efficient and error-free operations.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::next_permutation`和`std::prev_permutation`来遍历排列。利用这些函数可以消除手动生成排列的需要，并促进高效且无错误的操作。
- en: '**Optimal partitioning**: A precise and unambiguous predicate is essential
    when dividing data. Unclear criteria can yield unpredictable partitions and potentially
    decrease application efficiency. Being familiar with your data’s characteristics
    can aid in effective partitioning. If the data has inherent order or structure,
    it’s advantageous to factor that into the partitioning algorithms to enhance performance
    and reduce resource use.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最优分区**：在划分数据时，精确且明确的谓词是必不可少的。不明确的准则可能导致不可预测的分区并可能降低应用程序的效率。熟悉你的数据特性可以帮助有效分区。如果数据具有固有的顺序或结构，将其纳入分区算法中可以增强性能并减少资源使用。'
- en: '**Maintain comparator consistency**: For heap operations, using comparators
    consistently is crucial. Any inconsistency in their use can disturb the heap structure
    and lead to unexpected results. For example, suppose you use one comparator to
    build a max-heap and switch to a different comparator for extracting elements.
    In that case, the heap’s structure might be disturbed, and you might not get the
    expected maximum element.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持比较器一致性**：对于堆操作，使用比较器的一致性至关重要。任何使用上的不一致都可能破坏堆结构并导致意外结果。例如，假设你使用一个比较器来构建最大堆，然后切换到不同的比较器来提取元素，在这种情况下，堆的结构可能会被破坏，你可能无法得到预期的最大元素。'
- en: '`std::push_heap` and `std::pop_heap` to preserve heap integrity.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::push_heap`和`std::pop_heap`来保持堆的完整性。
- en: '`std::sort` may be more efficient for more static datasets.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::sort`可能对于更多静态数据集来说更有效率。'
- en: These partitioning, permutation, and heap concepts can significantly improve
    application performance and reliability. Simplifying permutation tasks to avoid
    complexity, utilizing STL permutation functions for efficiency, ensuring clear
    criteria for data partitioning, maintaining comparator consistency for heap operations,
    prioritizing heap access with appropriate functions, and choosing sorting methods
    based on the dataset’s characteristics and update frequency are all helpful. Following
    best practices in these areas is essential for maximizing the benefits of the
    C++ STL and ensuring consistent and optimized data operations in programming.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这些分区、排列和堆概念可以显著提高应用程序的性能和可靠性。简化排列任务以避免复杂性，利用STL排列函数以提高效率，确保数据分区有明确的准则，保持堆操作的比较器一致性，使用适当的函数优先访问堆，以及根据数据集的特征和更新频率选择排序方法，所有这些都有助于。在这些领域遵循最佳实践对于最大化C++
    STL的好处以及确保编程中数据操作的持续优化至关重要。
- en: Summary
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, we have covered the manipulation of sequences. We explored
    partitioning techniques, which organize data based on specific predicates, and
    examined various permutation algorithms that enable reordering elements within
    a range. We also investigated the heap operations provided by STL, which facilitate
    priority queue implementations and efficient sorting.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了序列的操作。我们探讨了基于特定谓词组织数据的分区技术，并检查了各种排列算法，这些算法允许在范围内重新排列元素。我们还研究了STL提供的堆操作，这些操作有助于实现优先队列和高效排序。
- en: Understanding these operations is essential for developers because they underpin
    many higher-level algorithms and are foundational to efficient data processing.
    Mastery of partitioning allows for quick segregation of data, permutations enable
    the exploration of all possible orderings of a dataset, and heaps provide a means
    to maintain a collection always sorted by priority. These tools are fundamental
    for tasks requiring optimized data retrieval, manipulation, and organization.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些操作对于开发者来说是至关重要的，因为它们是许多高级算法的基础，并且对于高效数据处理至关重要。掌握分区技术可以快速分离数据，排列允许探索数据集所有可能的排序，而堆提供了一种按优先级始终排序集合的方法。这些工具对于需要优化数据检索、操作和组织的任务是基本的。
- en: In the next chapter, we will explore the range concept, which offers a more
    expressive approach to handling sequences of elements. The chapter will discuss
    the advantages of range-based operations for sorting and searching algorithms,
    highlighting their enhanced composability and readability. As we progress into
    this chapter, we will gain insights into the practical application of these modern
    techniques, ensuring our continued growth as adept and contemporary C++ developers.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨范围概念，它为处理元素序列提供了一种更具有表现力的方法。本章将讨论基于范围的操作在排序和搜索算法中的优势，突出其增强的可组合性和可读性。随着我们进入本章，我们将深入了解这些现代技术的实际应用，确保我们作为熟练且当代的C++开发者的持续成长。
