- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Causes of Bad Code
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 糟糕代码的原因
- en: In the previous chapters, we discussed coding standards in C++ and the core
    development principles. As we delve into refactoring existing code, it is crucial
    to understand what leads to subpar or bad code. Recognizing these causes enables
    us to avoid repeating the same mistakes, address existing issues, and prioritize
    future improvements effectively.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了C++的编码标准和核心开发原则。当我们深入到重构现有代码时，理解导致代码质量低下或糟糕的原因至关重要。识别这些原因使我们能够避免重复相同的错误，解决现有问题，并有效地优先考虑未来的改进。
- en: Bad code can result from various factors, ranging from external pressures to
    internal team dynamics. One significant factor is the need to deliver the product
    quickly, especially in fast-paced environments such as start-ups. Here, the pressure
    to release features rapidly often leads to compromises in code quality as developers
    might cut corners or skip essential best practices to meet tight deadlines.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 恶劣代码可能由各种因素造成，从外部压力到内部团队动态。一个重要因素是快速交付产品的需求，尤其是在快节奏的环境，如初创公司。在这里，快速发布功能的压力往往导致代码质量的妥协，开发者可能会为了满足紧迫的截止日期而走捷径或跳过重要的最佳实践。
- en: Another contributing factor is the multiple ways of solving the same problem
    in C++. The language’s flexibility and richness, while powerful, can result in
    inconsistencies and difficulties in maintaining a coherent code base. Different
    developers might approach the same problem in various ways, leading to a fragmented
    and harder-to-maintain code base.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个影响因素是C++中解决同一问题的多种方式。语言的灵活性和丰富性，虽然强大，但可能导致不一致性和维护连贯代码库的困难。不同的开发者可能会以不同的方式处理相同的问题，导致代码库碎片化且难以维护。
- en: The developer’s personal taste also plays a role. Individual preferences and
    coding styles can impact the overall quality and readability of the code. What
    one developer considers elegant, another might find convoluted, leading to subjective
    differences that affect code consistency and clarity.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者的个人品味也起着作用。个人偏好和编码风格可能会影响代码的整体质量和可读性。一个开发者认为优雅的，另一个可能觉得复杂，导致主观差异影响代码的一致性和清晰度。
- en: Lastly, a lack of knowledge of modern C++ features can result in inefficient
    or error-prone code. As C++ evolves, it introduces new features and paradigms
    that require a deep understanding to be used effectively. When developers are
    not up to date with these advancements, they might fall back on outdated practices,
    missing out on improvements that can enhance code quality and performance.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对现代C++特性的缺乏可能导致代码效率低下或存在错误。随着C++的发展，它引入了新的特性和范式，这些特性需要深入理解才能有效使用。当开发者没有跟上这些进步时，他们可能会退回到过时的做法，错失可以提高代码质量和性能的改进。
- en: By exploring these aspects, we aim to provide a thorough understanding of the
    factors contributing to bad code. This knowledge is essential for any developer
    aiming to refactor and improve an existing code base effectively. Let’s dive in
    and uncover the root causes of bad code in C++ development.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过探讨这些方面，我们的目标是提供一个对导致糟糕代码的因素的全面理解。这种知识对于任何希望有效地重构和改进现有代码库的开发者来说都是必不可少的。让我们深入探讨，揭示C++开发中糟糕代码的根本原因。
- en: The need to deliver the product
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交付产品的需求
- en: When developers examine pre-existing code, they may question why it was written
    in a manner that is less elegant or lacks extensibility. It is often easy to criticize
    the job done by others, but it is crucial to understand the original developer’s
    circumstances. Suppose the project was originally developed in a start-up company.
    In that case, it is important to consider that start-up culture significantly
    emphasizes fast product delivery and the need to outpace competitors. While this
    can be advantageous, it can also lead to the development of bad code. One of the
    main reasons for this is the pressure to deliver quickly, which may cause developers
    to cut corners or skip essential coding practices (for example, the SOLID principles
    mentioned in previous chapters) in order to meet deadlines. This can result in
    code that lacks proper documentation, is difficult to maintain, and may be susceptible
    to errors.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者检查现有代码时，他们可能会质疑为什么代码以不那么优雅或缺乏可扩展性的方式编写。批评他人完成的工作通常很容易，但理解原始开发者的背景至关重要。假设项目最初是在一家初创公司开发的。在这种情况下，重要的是要考虑到初创文化显著强调快速产品交付和超越竞争对手的需求。虽然这可能是优势，但也可能导致糟糕的代码。其中一个主要原因是快速交付的压力，这可能导致开发者为了赶工期而走捷径或跳过必要的编码实践（例如，前几章中提到的
    SOLID 原则）。这可能导致代码缺乏适当的文档，难以维护，并且可能容易出错。
- en: Furthermore, the limited resources and small development teams of start-ups
    can exacerbate the need for speed, as developers may not have the manpower to
    focus on optimizing and refining the code base. As a result, the code can become
    cluttered and inefficient, leading to decreased performance and increased bugs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，初创公司有限的资源和小型开发团队可能会加剧对速度的需求，因为开发者可能没有足够的人手来专注于优化和精炼代码库。结果，代码可能会变得杂乱无章且效率低下，导致性能下降和错误增加。
- en: In addition, the focus on fast delivery in start-up culture can make it difficult
    for developers to keep up with the latest advancements in C++. This may result
    in outdated code that lacks important features, uses inefficient or deprecated
    functions, and is not optimized for performance.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，创业文化中注重快速交付的特点可能会让开发者难以跟上 C++ 语言的最新进展。这可能会导致代码过时，缺乏重要功能，使用低效或已弃用的函数，并且没有针对性能进行优化。
- en: The developer’s personal taste
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发者的个人品味
- en: Another significant factor contributing to bad code is the developer’s personal
    taste. Individual preferences and coding styles can vary widely, leading to subjective
    differences that impact code consistency and readability. For example, consider
    two developers, Bob and Alice. Bob prefers using concise, compact code that leverages
    advanced C++ features, while Alice favors more explicit and verbose code, prioritizing
    clarity and simplicity.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 导致糟糕代码的另一个重要因素是开发者的个人品味。个人偏好和编码风格可能差异很大，导致主观差异影响代码的一致性和可读性。例如，考虑两位开发者鲍勃和爱丽丝。鲍勃偏好使用简洁、紧凑的代码，利用高级
    C++ 特性，而爱丽丝则更喜欢更明确和冗长的代码，优先考虑清晰和简单。
- en: 'Bob might write a function using modern C++ features such as lambda expressions
    and the `auto` keyword:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 鲍勃可能会使用现代 C++ 特性，如 lambda 表达式和 `auto` 关键字来编写函数：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alice, on the other hand, might prefer a more traditional approach, avoiding
    lambdas and using explicit types:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，爱丽丝可能会偏好更传统的方法，避免使用 lambda 表达式并使用显式类型：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: While both approaches are valid and achieve the same result, the difference
    in style can lead to confusion and inconsistency within the code base. If Bob
    and Alice are working on the same project without adhering to a common coding
    standard, the code can become a patchwork of differing styles, making it harder
    to maintain and understand.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两种方法都是有效的，并且可以达到相同的结果，但风格上的差异可能导致代码库中的混淆和不一致。如果鲍勃和爱丽丝在没有遵循共同编码标准的情况下共同工作，代码可能会成为不同风格的大杂烩，使得维护和理解变得更加困难。
- en: Additionally, Bob’s use of modern features might introduce complexity that could
    be difficult for team members unfamiliar with these features, while Alice’s verbose
    style might be seen as overly simplistic and inefficient by those who prefer more
    concise code. These differences, rooted in personal taste, underscore the importance
    of establishing and following team-wide coding standards to ensure consistency
    and maintainability in the code base.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，鲍勃使用现代特性的做法可能会引入团队成员不熟悉这些特性时难以应对的复杂性，而爱丽丝的冗长风格可能会被那些偏好更简洁代码的人视为过于简单和低效。这些差异源于个人品味，强调了建立和遵循团队编码标准的重要性，以确保代码库的一致性和可维护性。
- en: By recognizing and addressing the impact of personal coding preferences, teams
    can work toward creating a cohesive and readable code base that aligns with best
    practices and enhances overall code quality.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过识别和解决个人编码偏好的影响，团队可以共同努力创建一个统一且易于阅读的代码库，与最佳实践保持一致，并提高整体代码质量。
- en: Multiple ways of solving the same problem in C++
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++中解决相同问题的多种方法
- en: C++ is a versatile language that offers multiple ways to solve the same problem,
    a characteristic that can both empower and confuse developers. This flexibility
    often leads to inconsistencies within a code base, especially when different developers
    have varying levels of expertise and preferences. In this chapter, we will show
    a few examples to illustrate how the same problem can be approached in different
    ways, highlighting the potential benefits and pitfalls of each method. As discussed
    in the *The developer’s personal taste* section, developers such as Bob and Alice
    might approach the same problem using different techniques, leading to a fragmented
    code base.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: C++是一种多才多艺的语言，提供了多种解决相同问题的方法，这一特性既能赋予开发者力量，也可能使他们感到困惑。这种灵活性往往会导致代码库中的不一致性，尤其是在不同开发者的专业水平和偏好不同时。在本章中，我们将展示一些示例，说明相同问题可以以不同的方式处理，突出每种方法的潜在优点和缺点。正如在*开发者的个人品味*部分所讨论的，像鲍勃和爱丽丝这样的开发者可能会使用不同的技术来处理相同的问题，从而导致代码库碎片化。
- en: Revisiting Bob and Alice’s example
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重温鲍勃和爱丽丝的例子
- en: To recap, Bob used modern C++ features such as lambda expressions and `auto`
    to process data concisely, while Alice preferred a more explicit and verbose approach.
    Both methods achieve the same result, but the difference in style can lead to
    confusion and inconsistency within the code base. While Bob’s approach is more
    compact and leverages modern C++ features, Alice’s method is straightforward and
    easier to understand for those unfamiliar with lambdas.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，鲍勃使用了现代C++特性，如lambda表达式和`auto`来简洁地处理数据，而爱丽丝则更喜欢更明确和冗长的方法。两种方法都能达到相同的结果，但风格上的差异可能导致代码库中的混淆和不一致。虽然鲍勃的方法更紧凑并利用了现代C++特性，但爱丽丝的方法对那些不熟悉lambda的人来说更易于理解。
- en: Raw pointers and C functions versus Standard Library functions
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始指针和C函数与标准库函数
- en: 'Consider a project that heavily uses raw pointers and C functions for copying
    data, a common practice in older C++ code bases:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个项目，它大量使用原始指针和C函数来复制数据，这是较老C++代码库中的常见做法：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This approach, while functional, is prone to errors such as buffer overflows
    and requires manual memory management. In contrast, a modern C++ approach would
    use standard library functions such as `std::copy`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法虽然可行，但容易发生缓冲区溢出等错误，并且需要手动管理内存。相比之下，现代C++方法会使用标准库函数，例如`std::copy`：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using `std::copy` not only simplifies the code but also leverages well-tested
    library functions that handle edge cases and improve safety.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`std::copy`不仅简化了代码，而且利用了经过良好测试的库函数，这些函数可以处理边缘情况并提高安全性。
- en: Inheritance versus templates
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承与模板
- en: 'Another area where C++ offers multiple solutions is code reuse and abstraction.
    Some projects prefer using inheritance, which can lead to a rigid and complex
    hierarchy:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: C++提供多种解决方案的另一个领域是代码重用和抽象。一些项目更喜欢使用继承，这可能导致僵化和复杂的层次结构：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'While inheritance provides a clear structure and allows polymorphic behavior,
    it can become cumbersome as the hierarchy grows. An alternative approach is to
    use templates to achieve polymorphism without the overhead of virtual functions.
    Here’s how templates can be used to achieve similar functionality:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然继承提供了清晰的架构并允许多态行为，但随着层次结构的增长，它可能会变得繁琐。一种替代方法是使用模板来实现多态，而不需要虚拟函数的开销。以下是模板如何实现类似功能的方法：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, `ShapeDrawer` uses templates to achieve polymorphic behavior.
    `ShapeDrawer` can work with any type that provides a `draw` method. This approach
    avoids the overhead associated with virtual function calls and can be more efficient,
    especially in performance-critical applications.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`ShapeDrawer`使用模板来实现多态行为。`ShapeDrawer`可以与任何提供`draw`方法的类型一起工作。这种方法避免了与虚拟函数调用相关的开销，并且可以更高效，尤其是在性能关键的应用中。
- en: Example – handling errors
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 - 处理错误
- en: 'Another example of solving the same problem in different ways is error handling.
    Consider a project where Bob uses a traditional error code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是不同方式解决相同问题，比如错误处理。考虑一个项目中鲍勃使用传统的错误码：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Alice, on the other hand, prefers using exceptions for error handling:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，爱丽丝更倾向于使用异常进行错误处理：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using exceptions can make the code cleaner by separating error handling from
    the main logic, but it requires an understanding of exception safety and handling.
    Error code, while simpler, can clutter the code with repetitive checks and may
    be less informative.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异常可以使代码更简洁，因为它将错误处理与主逻辑分离，但需要理解异常安全性和处理。错误代码虽然更简单，但可能会使代码因重复检查而变得杂乱，并且可能提供的信息较少。
- en: Projects using different approaches
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 采用不同方法的项目
- en: 'In real-world projects, you might encounter a mix of these approaches, reflecting
    the varied backgrounds and preferences of different developers, such as these
    examples:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的项目中，你可能会遇到这些方法的混合使用，反映了不同开发者的不同背景和偏好，例如以下示例：
- en: '**Project A** uses raw pointers and C functions for performance-critical sections,
    relying on the developers’ expertise to manage memory safely'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目A**在性能关键部分使用原始指针和C函数，依赖开发者的专业知识来安全地管理内存'
- en: '**Project B** prefers standard library containers and algorithms, prioritizing
    safety and readability over raw performance'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目B**更倾向于使用标准库容器和算法，优先考虑安全性和可读性，而不是原始性能'
- en: '**Project C** employs a deep inheritance hierarchy to model its domain, emphasizing
    clear relationships between entities'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目C**采用深度继承层次结构来建模其领域，强调实体之间的清晰关系'
- en: '**Project D** utilizes templates extensively to achieve high performance and
    flexibility, despite the steeper learning curve and potential complexity'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目D**广泛使用模板来实现高性能和灵活性，尽管学习曲线更陡峭，且可能更复杂'
- en: Each approach has its pros and cons, and choosing the right one depends on the
    project’s requirements, the team’s expertise, and the specific problem being solved.
    However, these multiple ways of solving the same problem can lead to a fragmented
    and inconsistent code base if not managed carefully.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每种方法都有其优缺点，选择正确的方法取决于项目的需求、团队的专长以及要解决的问题的具体性。然而，如果不小心管理，解决同一问题的多种方法可能会导致代码库碎片化和不一致。
- en: C++ provides multiple ways to solve the same problem, from raw pointers and
    C functions to standard library containers and templates. While this flexibility
    is powerful, it can also lead to inconsistencies and complexity in a code base.
    Understanding the strengths and weaknesses of each approach and striving for consistency
    through coding standards and team agreements is crucial for maintaining high-quality,
    maintainable code. By embracing modern C++ features and best practices, developers
    can write code that is both efficient and robust, reducing the likelihood of errors
    and improving overall code quality.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: C++提供了多种解决同一问题的方法，从原始指针和C函数到标准库容器和模板。虽然这种灵活性非常强大，但也可能导致代码库中的不一致性和复杂性。理解每种方法的优缺点，并通过编码标准和团队协议努力保持一致性，对于维护高质量、可维护的代码至关重要。通过采用现代C++特性和最佳实践，开发者可以编写既高效又健壮的代码，降低错误发生的可能性，并提高整体代码质量。
- en: Lack of knowledge in C++
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++知识不足
- en: One of the major contributors to bad code is a lack of knowledge in C++. C++
    is a complex and evolving language with a wide range of features, and staying
    updated with its latest standards requires continuous learning. Developers who
    are not familiar with modern C++ practices can inadvertently write inefficient
    or error-prone code. This section explores how gaps in understanding C++ can lead
    to various issues, using examples to illustrate common pitfalls.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 导致糟糕代码的一个主要原因是C++知识不足。C++是一种复杂且不断发展的语言，具有广泛的功能，保持对其最新标准的更新需要持续学习。不熟悉现代C++实践的开发者可能会无意中编写低效或容易出错的代码。本节探讨了C++理解上的差距如何导致各种问题，并使用示例来说明常见的陷阱。
- en: Consider two developers, Bob and Alice. Bob has extensive experience with older
    versions of C++ but hasn’t kept up with recent updates, while Alice is well versed
    in modern C++ features.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑两位开发者，鲍勃和爱丽丝。鲍勃对较老版本的C++有丰富的经验，但 hasn’t kept up with recent updates，而爱丽丝对现代C++特性非常熟悉。
- en: Using raw pointers and manual memory management
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用原始指针和手动内存管理
- en: 'Bob might use raw pointers and manual memory management, a common practice
    in older C++ code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 鲍勃可能会使用原始指针和手动内存管理，这是较老C++代码中的常见做法：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This approach is prone to errors such as memory leaks and undefined behavior
    if `delete[]` is missed or incorrectly matched with `new`. For instance, if an
    exception is thrown after the allocation but before `delete[]`, the memory will
    leak. Alice, familiar with modern C++, would use `std::vector` to manage memory
    safely and efficiently:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果错过或错误地匹配`delete[]`与`new`，这种方法容易出错，如内存泄漏和未定义行为。例如，如果在分配之后但在`delete[]`之前抛出异常，内存将会泄漏。爱丽丝熟悉现代C++，会使用`std::vector`来安全有效地管理内存：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Using `std::vector` eliminates the need for manual memory management, reducing
    the risk of memory leaks and making the code more robust and easier to maintain.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`std::vector`消除了手动内存管理的需要，降低了内存泄漏的风险，并使代码更健壮、更容易维护。
- en: Incorrect use of smart pointers
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 智能指针使用不当
- en: 'Bob tries to adopt modern practices but misuses `std::shared_ptr`, leading
    to potential performance issues:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 鲍勃试图采用现代实践，但错误地使用了`std::shared_ptr`，导致潜在的性能问题：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This approach involves two separate allocations: one for the integer and another
    for the control block of `std::shared_ptr`. Alice, knowing the benefits of `std::make_shared`,
    uses it to optimize memory allocation:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法涉及两个独立的分配：一个用于整数，另一个用于`std::shared_ptr`的控制块。爱丽丝了解到`std::make_shared`的好处，因此使用它来优化内存分配：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`std::make_shared` combines the allocations into a single memory block, improving
    performance and cache locality.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::make_shared`将分配合并到单个内存块中，提高了性能和缓存局部性。'
- en: Efficient use of move semantics
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动语义的有效使用
- en: 'Bob might not fully understand move semantics and how they can improve performance
    when dealing with temporary objects. Consider a function that appends elements
    to `std::vector`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 鲍勃可能不完全理解移动语义及其在处理临时对象时提高性能的能力。考虑一个将元素追加到`std::vector`的函数：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This approach involves copying each element from `source` to `target`, which
    can be inefficient. Alice, understanding move semantics, would optimize this by
    using `std::move`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法涉及将每个元素从`source`复制到`target`，这可能效率低下。爱丽丝了解移动语义，通过使用`std::move`来优化：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'By using `std::move`, Alice ensures that each element is moved rather than
    copied, which is more efficient. Additionally, Alice might also consider using
    `std::move` for the entire container if `source` is no longer needed:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`std::move`，爱丽丝确保每个元素是移动而不是复制，这更有效率。此外，如果`source`不再需要，爱丽丝还可能考虑对整个容器使用`std::move`：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This approach moves the elements of the entire container efficiently, leveraging
    move semantics to avoid unnecessary copying.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有效地移动整个容器的元素，利用移动语义来避免不必要的复制。
- en: Misusing const correctness
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: const正确性使用不当
- en: 'Bob might neglect const correctness, leading to potential bugs and unclear
    code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 鲍勃可能会忽视const的正确性，导致潜在的bug和不清晰的代码：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Without const correctness, it’s unclear whether `get_value` modifies the state
    of the object. Alice applies const correctness to clarify the intent and improve
    safety:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 没有const正确性，`get_value`是否修改对象的状态并不明确。爱丽丝应用const正确性来阐明意图并提高安全性：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Marking `get_value` as `const` guarantees that it does not modify the object,
    making the code clearer and preventing accidental modifications.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 将`get_value`标记为`const`确保它不会修改对象，使代码更清晰并防止意外修改。
- en: Inefficient string handling
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不高效的字符串处理
- en: 'Bob might handle strings using C-style character arrays, which can lead to
    buffer overflows and complex code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 鲍勃可能会使用C风格的字符数组来处理字符串，这可能导致缓冲区溢出和复杂的代码：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This approach is error-prone and difficult to manage. Alice, aware of the capabilities
    of `std::string`, simplifies the code and avoids potential errors:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法容易出错且难以管理。爱丽丝了解到`std::string`的能力，简化了代码并避免了潜在的错误：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Using `std::string` provides automatic memory management and a rich set of functions
    for string manipulation, making the code safer and more expressive.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`std::string`提供自动内存管理和丰富的字符串操作函数，使代码更安全、更易于表达。
- en: Undefined behavior with lambdas
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用lambda表达式时的未定义行为
- en: 'Lambda functions introduced in C++11 provide powerful capabilities, but they
    can lead to undefined behavior if not used correctly. Bob might write a lambda
    that captures a local variable by reference and returns it, leading to dangling
    references:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: C++11中引入的lambda函数提供了强大的功能，但如果不正确使用，可能会导致未定义行为。鲍勃可能会编写一个lambda函数，通过引用捕获局部变量并返回它，从而导致悬垂引用：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Alice, understanding the risks, captures the variable by value to ensure it
    remains valid:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 爱丽丝理解风险，通过值捕获变量以确保其有效性：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Capturing by value avoids the risk of dangling references and ensures the lambda
    remains safe to use.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过值捕获避免了悬垂引用的风险，并确保 lambda 可以安全使用。
- en: Misunderstanding undefined behavior
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对未定义行为的误解
- en: 'Bob might inadvertently write code that leads to undefined behavior by relying
    on uninitialized variables:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 鲍勃可能会无意中编写依赖于未初始化变量的代码，从而导致未定义的行为：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Accessing uninitialized variables can lead to unpredictable behavior and hard-to-debug
    issues. Alice, understanding the importance of initialization, ensures that all
    variables are properly initialized:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 访问未初始化的变量可能导致不可预测的行为和难以调试的问题。爱丽丝理解初始化的重要性，确保所有变量都得到适当的初始化：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Properly initializing variables prevents undefined behavior and makes the code
    more reliable.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正确初始化变量可以防止未定义的行为，并使代码更可靠。
- en: Misuse of C-style arrays
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C 风格数组的误用
- en: 'Using C-style arrays can lead to various issues, such as a lack of bounds checking
    and difficulty in managing array sizes. Consider the following example where a
    function creates a C array on the stack and returns it:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 C 风格数组可能导致各种问题，例如缺乏边界检查和管理数组大小的困难。考虑以下示例，其中函数在栈上创建一个 C 数组并返回它：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Returning a pointer to a local array leads to undefined behavior because the
    array goes out of scope when the function returns. A safer approach is to use
    `std::array`, which can be returned safely from a function. It provides the `size`
    method and is compatible with C++ algorithms such as `std::sort`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指向局部数组的指针会导致未定义的行为，因为数组在函数返回时超出作用域。一种更安全的方法是使用 `std::array`，它可以安全地从函数返回。它提供了
    `size` 方法，并与 C++ 算法（如 `std::sort`）兼容：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Using `std::array` not only avoids undefined behavior but also enhances safety
    and interoperability with the C++ Standard Library. For example, sorting an array
    becomes straightforward:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `std::array` 不仅避免了未定义的行为，还增强了安全性和与 C++ 标准库的互操作性。例如，排序数组变得简单：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Insufficient pointer usage
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针使用不足
- en: Modern C++ provides smart pointers such as `std::unique_ptr` and `std::shared_ptr`
    to manage dynamic memory more safely and efficiently. It’s generally better to
    use `std::unique_ptr` instead of raw pointers for exclusive ownership. When multiple
    actors need to share ownership of a resource, `std::shared_ptr` can be used. However,
    there are common issues related to the misuse of `std::shared_ptr`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现代C++提供了如 `std::unique_ptr` 和 `std::shared_ptr` 这样的智能指针，以更安全、更有效地管理动态内存。通常，使用
    `std::unique_ptr` 而不是原始指针来拥有独占所有权更好。当多个参与者需要共享资源的所有权时，可以使用 `std::shared_ptr`。然而，与
    `std::shared_ptr` 的误用相关的问题很常见。
- en: Building std::shared_ptr
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 `std::shared_ptr`
- en: 'Using the constructor of `std::shared_ptr` to create an object leads to separate
    allocations for the control block and the managed object:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `std::shared_ptr` 构造函数创建对象会导致控制块和管理对象分别进行分配：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'A better approach is to use `std::make_shared`, which combines the allocations
    into a single memory block, improving performance and cache locality:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是使用 `std::make_shared`，它将分配合并到单个内存块中，提高性能和缓存局部性：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Copying std::shared_ptr by value
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过值复制 `std::shared_ptr`
- en: 'Copying `std::shared_ptr` by value within the same thread stack is less efficient
    because the reference counter is atomic. It’s recommended to pass `std::shared_ptr`
    by reference:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一线程栈内通过值复制 `std::shared_ptr` 不是很高效，因为引用计数是原子的。建议通过引用传递 `std::shared_ptr`：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Cyclic dependencies with std::shared_ptr
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`std::shared_ptr` 的循环依赖'
- en: 'Cyclic dependencies can occur when two or more `std::shared_ptr` instances
    reference each other, preventing the reference count from reaching zero and causing
    memory leaks. Consider the following example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个或更多 `std::shared_ptr` 实例互相引用时，可能会发生循环依赖，阻止引用计数达到零并导致内存泄漏。考虑以下示例：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this scenario, `A` and `B` reference each other, creating a cycle that prevents
    their destruction. This issue can be resolved using `std::weak_ptr` to break the
    cycle:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`A` 和 `B` 互相引用，形成一个循环，阻止它们的销毁。这个问题可以使用 `std::weak_ptr` 来打破循环：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Checking the std::weak_ptr status
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查 `std::weak_ptr` 状态
- en: 'A common mistake when using `std::weak_ptr` is to check its status with `expired()`
    and then lock it, which is not thread-safe:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `std::weak_ptr` 的一个常见错误是使用 `expired()` 检查其状态，然后锁定它，这并不是线程安全的：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The correct approach is to lock `std::weak_ptr` and check that the returned
    `std::shared_ptr` is not `null`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的做法是锁定 `std::weak_ptr` 并检查返回的 `std::shared_ptr` 不是 `null`：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Lack of knowledge in C++ can lead to various issues, from memory management
    errors to inefficient and unreadable code. By staying updated with modern C++
    features and best practices, developers can write code that is safer, more efficient,
    and easier to maintain. Continuous learning and adaptation are key to overcoming
    these challenges and improving overall code quality. Bob and Alice’s examples
    highlight the importance of understanding and applying modern C++ practices to
    avoid common pitfalls and produce high-quality code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: C++知识的缺乏可能导致各种问题，从内存管理错误到低效且难以阅读的代码。通过保持对现代C++特性和最佳实践的更新，开发者可以编写更安全、更高效且易于维护的代码。持续学习和适应是克服这些挑战并提高整体代码质量的关键。Bob和Alice的例子突出了理解和应用现代C++实践的重要性，以避免常见陷阱并生成高质量的代码。
- en: Summary
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored various causes of bad code in C++ and how a lack
    of knowledge in modern C++ practices can lead to inefficient, error-prone, or
    undefined behavior. By examining specific examples, we highlighted the importance
    of continuous learning and adaptation to keep up with the evolving features of
    C++.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了C++中不良代码的多种原因，以及缺乏现代C++实践知识如何导致低效、易出错或未定义的行为。通过检查具体示例，我们强调了持续学习和适应以跟上C++功能演变的重要性。
- en: We began by discussing the pitfalls of using raw pointers and manual memory
    management, showing how modern C++ practices such as `std::vector` can eliminate
    the need for manual memory management and reduce the risk of memory leaks. The
    advantages of using `std::unique_ptr` for exclusive ownership and `std::shared_ptr`
    for shared ownership were emphasized, while common issues such as inefficient
    memory allocation, unnecessary copying, and cyclic dependencies were highlighted.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先讨论了使用原始指针和手动内存管理的陷阱，展示了现代C++实践，如`std::vector`如何消除手动内存管理的需求并降低内存泄漏的风险。强调了使用`std::unique_ptr`进行独占所有权和`std::shared_ptr`进行共享所有权的优势，同时突出了常见问题，如低效的内存分配、不必要的复制和循环依赖。
- en: In the context of `std::shared_ptr`, we demonstrated the benefits of using `std::make_shared`
    over the constructor to reduce memory allocations and improve performance. The
    efficiency gained by passing `std::shared_ptr` by reference rather than by value
    due to the atomic reference counter was also explained. We illustrated the problem
    of cyclic dependencies and how `std::weak_ptr` can be used to break cycles and
    prevent memory leaks. The correct way to check and use `std::weak_ptr` by locking
    it and checking the resulting `std::shared_ptr` to ensure thread safety was also
    covered.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在`std::shared_ptr`的上下文中，我们展示了使用`std::make_shared`而非构造函数来减少内存分配并提高性能的优势。由于原子引用计数器，通过引用而非值传递`std::shared_ptr`所获得的效率提升也得到了解释。我们还阐述了循环依赖的问题以及如何使用`std::weak_ptr`来打破循环并防止内存泄漏。同时，还介绍了通过锁定并检查结果`std::shared_ptr`来确保线程安全的正确方式。
- en: Efficient use of move semantics was discussed to optimize performance by reducing
    unnecessary copying of temporary objects. Using `std::move` and `std::make_move_iterator`
    can significantly enhance program performance. The importance of const correctness
    was highlighted, showing how applying `const` to methods can clarify intent and
    improve code safety.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论了有效使用移动语义来优化性能，通过减少临时对象的非必要复制。使用`std::move`和`std::make_move_iterator`可以显著提高程序性能。强调了const正确性的重要性，展示了将`const`应用于方法如何阐明意图并提高代码安全性。
- en: We addressed the dangers of using C-style character arrays and how `std::string`
    can simplify string handling, reduce errors, and provide better memory management.
    The misuse of C-style arrays was explored, and `std::array` was presented as a
    safer and more robust alternative. By using `std::array`, we can avoid undefined
    behavior and leverage C++ Standard Library algorithms such as `std::sort`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了使用C风格字符数组的危险，以及`std::string`如何简化字符串处理、减少错误并提供更好的内存管理。探讨了C风格数组的误用，并介绍了`std::array`作为更安全、更健壮的替代方案。通过使用`std::array`，我们可以避免未定义的行为，并利用C++标准库算法，如`std::sort`。
- en: Finally, the proper use of lambda functions was discussed, along with the potential
    pitfalls of capturing variables by reference, which can lead to dangling references.
    Capturing variables by value ensures that the lambda remains safe to use.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了lambda函数的正确使用，以及通过引用捕获变量可能导致的潜在陷阱，这可能导致悬垂引用。通过值捕获变量确保lambda函数的安全使用。
- en: Through these examples, we learned about the critical importance of adopting
    modern C++ features and best practices to write safer, more efficient, and maintainable
    code. By staying updated with the latest standards and continuously improving
    our understanding of C++, we can avoid common pitfalls and produce high-quality
    software.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些例子，我们了解到采用现代C++特性和最佳实践对于编写更安全、更高效和可维护的代码具有至关重要的意义。通过紧跟最新标准并不断深化我们对C++的理解，我们可以避免常见的陷阱，并生产出高质量的软件。
