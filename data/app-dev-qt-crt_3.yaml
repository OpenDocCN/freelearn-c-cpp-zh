- en: Chapter 3. Designing Your Application with Qt Designer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。使用Qt Designer设计您的应用程序
- en: Qt is perhaps best known as a cross-platform user interface toolkit, and only
    in the last few years has Qt Creator really evolved to be a full software development
    environment. Even in its early releases, however, Qt had an excellent facility
    for building user interfaces with Qt Designer, now part of Qt Creator. More recently,
    the developers building Qt have added Qt Quick as a second option for user interface
    development. Qt Quick extends the Qt libraries and the Qt Designer capabilities
    of Qt Creator to build fluid interfaces for touchscreens and set-top boxes and
    to facilitate the declarative nature of Qt Quick and **Qt Meta-object Language**
    (**QML**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Qt可能最为人所知的是一个跨平台用户界面工具包，直到最近几年，Qt Creator才真正发展成为一个完整的软件开发环境。然而，即使在早期版本中，Qt也具有了一个优秀的用于使用Qt
    Designer构建用户界面的工具，现在已经成为Qt Creator的一部分。最近，构建Qt的开发人员添加了Qt Quick作为用户界面开发的第二个选项。Qt
    Quick扩展了Qt库和Qt Creator的Qt Designer功能，用于构建触摸屏和机顶盒的流畅界面，并促进了Qt Quick和**Qt元对象语言**（**QML**）的声明性特性。
- en: 'In this chapter, we will learn how to create user interfaces using Qt Designer,
    the user interface builder in Qt Creator. We begin by introducing key concepts
    to understanding the Qt framework: **signals** and **slots**. Next, we revisit
    using Qt Designer to create application forms, the basis of your user interface
    when using Qt Widgets. We touch on how to add resources and access them in your
    application, an important facet of user interface design. Then, we return to the
    code for a bit and build on the fundamentals of QML you learned in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with Qt Creator"), *Getting Started with Qt Creator*.
    At the end of this chapter, you''ll be well equipped to decide whether your application
    should be written using Qt GUI or Qt Quick, and to build your application with
    the help of the documentation that accompanies Qt Creator.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用Qt Designer创建用户界面，Qt Designer是Qt Creator中的用户界面构建器。我们首先介绍了理解Qt框架的关键概念：**信号**和**槽**。接下来，我们重新使用Qt
    Designer创建应用程序表单，这是在使用Qt Widgets时用户界面的基础。我们还介绍了如何添加资源并在应用程序中访问它们，这是用户界面设计的重要方面。然后，我们回到代码中，构建了你在[第1章](ch01.html
    "第1章. 使用Qt Creator入门") *使用Qt Creator入门*中学到的QML基础知识。在本章结束时，你将能够决定你的应用程序应该使用Qt GUI还是Qt
    Quick，并且能够借助Qt Creator附带的文档构建你的应用程序。
- en: Code interlude – signals and slots
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码插曲 - 信号和槽
- en: In software systems, there is often the need to couple different objects. Ideally,
    this coupling should be loose, that is, not dependent on the system's compile-time
    configuration. This is especially obvious when you consider user interfaces; for
    example, a button press may adjust the contents of a text widget or cause something
    to appear or disappear. Many systems use events for this purpose; components offering
    data encapsulate that data in an event, and an event loop (or, more recently,
    an event listener) catches the event and performs some action.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件系统中，通常需要耦合不同的对象。理想情况下，这种耦合应该是松散的，即不依赖于系统的编译时配置。当考虑用户界面时，这一点尤为明显；例如，按钮按下可能会调整文本窗口的内容，或者导致某些东西出现或消失。许多系统使用事件来实现这一目的；提供数据的组件将数据封装在事件中，事件循环（或者最近更常见的事件监听器）捕获事件并执行某些操作。
- en: 'Qt offers a better way: signals and slots. Like an event, the sending component
    generates a signal—in Qt parlance, the object emits a signal—which recipient objects
    may receive in a slot for the purpose. Qt objects may emit more than one signal,
    and signals may carry arguments; in addition, multiple Qt objects can have slots
    connected to the same signal, making it easy to arrange one-to-many notifications.
    Equally important, if no object is interested in a signal, it can be safely ignored,
    and no slots connected to the signal. Any object that inherits from `QObject`,
    Qt''s base class for objects, can emit signals or provide slots for connection
    to signals. Under the hood, Qt provides extensions to C++ syntax for declaring
    signals and slots.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Qt提供了更好的方法：信号和槽。就像事件一样，发送组件生成一个信号—在Qt术语中，对象发出一个信号—接收对象可以在槽中接收这个信号以进行处理。Qt对象可以发出多个信号，信号可以携带参数；此外，多个Qt对象可以连接到相同的信号上的槽，这样可以轻松地安排一对多的通知。同样重要的是，如果没有对象对信号感兴趣，它可以被安全地忽略，没有连接到信号的槽。任何继承自`QObject`的对象，Qt的对象基类，都可以发出信号或提供用于连接到信号的槽。在底层，Qt为声明信号和槽提供了对C++语法的扩展。
- en: 'A simple example will help make this clear. The classic example you find in
    the Qt documentation is an excellent one, and we''ll use it again it here, with
    some extension''s. Imagine you have the need for a counter, that is, a container
    that holds an integer. In C++, you might write:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的例子将有助于澄清这一点。在Qt文档中找到的经典例子是一个很好的例子，我们将在这里再次使用它，并进行一些扩展。想象一下你需要一个计数器，即一个包含整数的容器。在C++中，你可能会这样写：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `Counter` class has a single private member, `m_value`, bearing its value.
    Clients can invoke the value to obtain the counter's value, or set its value by
    invoking `setValue` with a new value.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`Counter`类有一个私有成员`m_value`，存储它的值。客户端可以调用`value`来获取计数器的值，或者通过调用`setValue`来设置它的值为新值。'
- en: 'In Qt, using signals and slots, we write the class this way:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt中，使用信号和槽，我们这样写这个类：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This `Counter` class inherits from `QObject`, the base class for all Qt objects.
    All `QObject` subclasses must include the declaration `Q_OBJECT` as the first
    element of their definition; this macro expands to Qt code implementing the subclass-specific
    glue necessary for the Qt object and signal-slot mechanism. The constructor remains
    the same, initializing our private member to zero. Similarly, the accessor method
    value remains the same, returning the current value for the counter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Counter`类继承自`QObject`，这是所有Qt对象的基类。所有`QObject`子类必须在其定义的第一个元素中包含声明`Q_OBJECT`；这个宏会扩展为Qt代码，实现了特定于子类的粘合剂，这是Qt对象和信号槽机制所必需的。构造函数保持不变，将我们的私有成员初始化为零。同样，访问器方法`value`保持不变，返回计数器的当前值。
- en: 'An object''s slots must be public, and are declared using the Qt extension
    to C++ public slots. This code defines three slots: a `setValue` slot, which accepts
    a new value for the counter, and the `increment` and `decrement` slots, which
    increment and decrement the value of the counter. Slots may take arguments, but
    do not return them; the communication between a signal and its slots is one way,
    initiating with the signal and terminating with the slot(s) connected to the signal.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的槽必须是公共的，并且使用Qt对C++的扩展公共槽进行声明。这段代码定义了三个槽：一个`setValue`槽，它接受计数器的新值，以及`increment`和`decrement`槽，它们增加和减少计数器的值。槽可以接受参数，但不返回参数；信号和槽之间的通信是单向的，由信号发起并以连接到信号的槽终止。
- en: The counter offers a single signal. Like slots, signals are also declared using
    a Qt extension to C++, `signals`. In the example above, a `Counter` object emits
    the signal `valueChanged` with a single argument, which is the new value of the
    counter. A signal is a function signature, not a method; Qt's extensions to C++
    use the type signature of signals and slots to ensure type safety between signal-slot
    connections, a key advantage signals and slots have over other decoupled messaging
    schemes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 计数器提供了一个单一的信号。与槽一样，信号也是使用Qt对C++的扩展`signals`声明的。在上面的示例中，一个`Counter`对象发出带有单个参数的信号`valueChanged`，这个参数是计数器的新值。信号是一个函数签名，而不是一个方法；Qt对C++的扩展使用信号和槽的类型签名来确保信号-槽连接之间的类型安全，这是信号和槽相对于其他解耦的消息传递方案的一个关键优势。
- en: 'As the developers, it''s our responsibility to implement each slot in our class
    with whatever application logic makes sense. The `Counter` class''s slots look
    like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，我们有责任使用适当的应用逻辑在我们的类中实现每个槽。`Counter`类的槽看起来像这样：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We use the implementation of the `setValue` slot as a method, which is what
    all slots are at their heart. The `setValue` slot takes a new value and assigns
    the new value to the `Counter` class's private member variable if they aren't
    the same. Then, the signal emits the `valueChanged` signal, using the Qt extension
    `emit`, which triggers an invocation to the slots connected to the signal.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`setValue`槽的实现作为一个方法，这就是所有槽在本质上都是什么。`setValue`槽接受一个新值，并将新值赋给`Counter`类的私有成员变量，如果它们不相同的话。然后，信号发出`valueChanged`信号，使用Qt扩展`emit`，这会触发对连接到信号的槽的调用。
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'This is a common pattern for signals that handle object properties: testing
    the property to be set for equality with the new value, and only assigning and
    emitting a signal if the values are unequal.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是处理对象属性的信号的常见模式：测试要设置的属性是否与新值相等，只有在值不相等时才分配和发出信号。
- en: 'If we had a button, say `QPushButton`, we could connect its clicked signal
    to the `increment` or `decrement` slot, so that a click on the button incremented
    or decremented the counter. I''d do that using the `QObject::connect` method,
    like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个按钮，比如`QPushButton`，我们可以将它的clicked信号连接到`increment`或`decrement`槽，这样点击按钮就会增加或减少计数器。我会使用`QObject::connect`方法来做到这一点，就像这样：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We first create the `QPushButton` and `Counter` objects. The `QPushButton` constructor
    takes a string, the label for the button, which we denote to be the string `Increment`
    or its localized counterpart.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建`QPushButton`和`Counter`对象。`QPushButton`构造函数接受一个字符串，按钮的标签，我们将其表示为字符串`Increment`或其本地化对应物。
- en: Why do we pass this to each constructor? Qt provides a parent-child memory management
    between QObjects and their descendants, easing clean-up when you're done using
    an object. When you free an object, Qt also frees any children of the parent object,
    so you don't have to. The parent-child relationship is set at construction time;
    I'm signaling to the constructors that when the object invoking |this code is
    freed, the push button and counter may be freed as well. (Of course, the invoking
    method must also be a subclass of `QObject` for this to work.)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要将this传递给每个构造函数？Qt在QObjects和它们的后代之间提供了父子内存管理，简化了在使用对象时的清理工作。当您释放一个对象时，Qt也会释放父对象的任何子对象，因此您不必这样做。父子关系在构造时设置；我在构造函数中发出信号，当调用此代码的对象被释放时，按钮和计数器也可能被释放。（当然，调用方法也必须是`QObject`的子类才能起作用。）
- en: Next, I call `QObject::connect`, passing first the source object and the signal
    to be connected, and then the receiver object and the slot to which the signal
    should be sent. The types of the signal and the slot must match, and the signals
    and slots must be wrapped in the `SIGNAL` and `SLOT` macros, respectively.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我调用`QObject::connect`，首先传递源对象和要连接的信号，然后传递接收对象和应该发送信号的槽。信号和槽的类型必须匹配，并且信号和槽必须分别包装在`SIGNAL`和`SLOT`宏中。
- en: 'Signals can also be connected to signals, and when that happens, the signals
    are chained and trigger any slots connected to the downstream signals. For example,
    I could write:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 信号也可以连接到信号，当这种情况发生时，信号被链接在一起，并触发连接到下游信号的任何槽。例如，我可以这样写：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This connects the counter `b` with the counter `a`, so that any change in value
    to the counter `a` also changes the value of the counter `b`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这将计数器`b`与计数器`a`连接起来，这样对计数器`a`值的任何更改也会改变计数器`b`的值。
- en: Signals and slots are used throughout Qt, both for user interface elements and
    to handle asynchronous operations, such as the presence of data on network sockets
    and HTTP transaction results. Under the hood, signals and slots are very efficient,
    boiling down to function dispatch operations, so you shouldn't hesitate to use
    the abstraction in your own designs. Qt provides a special build tool, the meta-object
    compiler, which compiles the extensions to C++ that signals and slots require
    and generates the additional code necessary to implement the mechanism.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 信号和槽在Qt中被广泛使用，用于用户界面元素以及处理异步操作，比如网络套接字上的数据存在和HTTP事务结果。在底层，信号和槽非常高效，归结为函数调度操作，因此您不应该犹豫在自己的设计中使用这种抽象。Qt提供了一个特殊的构建工具，元对象编译器，它编译了信号和槽所需的C++扩展，并生成了实现机制所需的额外代码。
- en: Creating forms in Qt Designer
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Qt Designer中创建表单
- en: 'Let''s create a simple calculator application using Qt Designer and two forms:
    one form taking the arguments for an arithmetic operation, and a second dialog
    form for presenting the results. I''ll do this twice in this chapter, first showing
    you how to do this using Qt GUI, and again using Qt Quick. The example is contrived,
    but will show you how to create multiple user interface forms in both environments,
    and give you practice in working with signals and slots.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Qt Designer和两个表单创建一个简单的计算器应用程序：一个表单用于获取算术运算的参数，另一个对话框表单用于呈现结果。我将在本章中进行两次演示，首先向您展示如何使用Qt
    GUI进行此操作，然后再使用Qt Quick。这个例子是刻意构造的，但将向您展示如何在两种环境中创建多个用户界面表单，并让您练习处理信号和插槽。
- en: Creating the main form
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建主表单
- en: 'In [Chapter 1](ch01.html "Chapter 1. Getting Started with Qt Creator"), *Getting
    Started with Qt Creator*, you learned the basic elements of the Qt GUI Designer,
    including the palette of widgets you can use, the central edit pane, the tree
    of objects, and the property view. The following screenshot shows the Qt Designer
    again:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. 使用Qt Creator入门")中，*使用Qt Creator入门*，您学习了Qt GUI Designer的基本元素，包括可以使用的小部件调色板，中央编辑窗格，对象树和属性视图。以下屏幕截图再次显示了Qt
    Designer：
- en: '![Creating the main form](img/2319OS_03_01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![创建主表单](img/2319OS_03_01.jpg)'
- en: Qt Creator's Designer for Qt GUI applications
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Creator的Qt GUI应用程序设计器
- en: 'Working from left to right, the parts of the screen you see are:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右，您看到的屏幕部分依次是：
- en: The views selector, presently indicating that the Qt Designer view is active
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图选择器，目前指示Qt Designer视图处于活动状态
- en: The palette of possible widgets you can lay out on your form
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在表单上布局的可能小部件的调色板
- en: The form editor, above the connection editor, which lets you wire signals and
    slots between widgets
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单编辑器，在连接编辑器上方，可让您在小部件之间连接信号和插槽
- en: The object tree, indicating all of the objects that have been laid out on the
    form and showing their parent-child relationships through the use of nested lists
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象树，指示已在表单上布置的所有对象，并通过使用嵌套列表显示它们的父子关系
- en: Below the object tree is the property editor, where you can edit the compile-time
    properties of any item you select on the form editor
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对象树下方是属性编辑器，您可以在表单编辑器上选择的任何项目的编译时属性
- en: 'Let''s begin by creating a new Qt GUI project (select **Qt Gui Application**
    from the **New File or Projects…** dialog) naming the project `QtGuiCalculator`,
    and then follow these steps:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的Qt GUI项目开始（从**新文件或项目...**对话框中选择**Qt Gui Application**），将项目命名为`QtGuiCalculator`，然后按照以下步骤操作：
- en: In the **Forms** folder of the project, double-click on the `mainwindow.ui`
    file. The designer will open.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的**Forms**文件夹中，双击`mainwindow.ui`文件。设计器将打开。
- en: Drag out **Vertical Layout** from the palette.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从调色板中拖出**垂直布局**。
- en: Right-click on the layout and choose **Lay out**, then choose **Adjust Size**.
    The layout will shrink to a point.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击布局，选择**布局**，然后选择**调整大小**。布局将缩小到一个点。
- en: Drag two **Line Edit** widgets and drop them on the vertical layout in the object
    viewer (the far-right pane). You'll see the vertical layout grow to accept each
    of the line editors. You should now have something that looks like the following
    screenshot:![Creating the main form](img/2319OS_03_07.jpg)
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动两个**行编辑**小部件并将它们放在对象查看器中的垂直布局上（最右边的窗格）。您将看到垂直布局会扩展以接受每个行编辑器。您现在应该有类似以下屏幕截图的东西：![创建主表单](img/2319OS_03_07.jpg)
- en: Your layout after the first two text fields
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个两个文本字段后的布局
- en: Drag the **Horizontal Layout** and drop it on the vertical layout in the object
    viewer.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动**水平布局**并将其放在对象查看器中的垂直布局上。
- en: Drag-and-drop four **Push Button** widgets on the horizontal layout you just
    added.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您刚刚添加的水平布局上拖放四个**Push Button**小部件。
- en: Resize the containing window so that the entire layout is shown in the window.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整包含窗口的大小，以便整个布局显示在窗口中。
- en: Rename the buttons `plusButton`, `minusButton`, `timesButton`, and `divideButton`
    using the property browser in the lower-right corner. As you do so, scroll down
    to the **text** property (under **QAbstractButton**) and give each button a logical
    label like `+`, `-`, `*`, and `/`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用右下角的属性浏览器将按钮重命名为`plusButton`，`minusButton`，`timesButton`和`divideButton`。在这样做时，向下滚动到**text**属性（在**QAbstractButton**下）并为每个按钮赋予类似`+`，`-`，`*`和`/`的逻辑标签。
- en: Select the top input line and name it `argument1Input`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择顶部输入行并将其命名为`argument1Input`。
- en: Select the bottom input line and name it `argument2Input`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择底部输入行并将其命名为`argument2Input`。
- en: 'The next screenshot shows what you should see in the Qt Designer form editor
    pane so far. You can also manually arrange the buttons by breaking the layout
    and positioning them using the mouse, but that typically makes your layout less
    robust to window resizing, and is generally not a good idea:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个屏幕截图显示了到目前为止在Qt Designer表单编辑器窗格中应该看到的内容。您还可以通过打破布局并使用鼠标定位按钮来手动排列按钮，但这通常会使您的布局对窗口调整大小的鲁棒性降低，并且通常不是一个好主意：
- en: '![Creating the main form](img/2319OS_03_02.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![创建主表单](img/2319OS_03_02.jpg)'
- en: Our calculator user interface
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的计算器用户界面
- en: 'So far, this is pretty straightforward. We used a vertical layout and a horizontal
    layout to lay out the various controls; this takes advantage of Qt''s dynamic
    constraints on widget layout and sizing. All widgets have a minimum and a maximum
    size, which are used by layouts to determine the actual size a widget consumes.
    Some widgets are elastic; that is, they stretch to fill their contents. When specifying
    the actual size of a widget, you can specify that it takes one of the following
    values in each of the x and y axes:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这很简单。我们使用了垂直布局和水平布局来布置各种控件；这充分利用了Qt对小部件布局和大小的动态约束。所有小部件都有最小和最大尺寸，布局使用这些尺寸来确定小部件实际占用的大小。一些小部件是弹性的；也就是说，它们会拉伸以填充其内容。在指定小部件的实际大小时，您可以指定它在x和y轴上的以下值之一：
- en: The minimum size of the widget
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小部件的最小尺寸
- en: The maximum size of the widget
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小部件的最大尺寸
- en: A fixed size between its minimum and maximum
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其最小和最大之间的固定大小
- en: An expanding size, expanding to fit the contents of the widget
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个扩展大小，扩展以适应小部件内容的大小
- en: Qt provides four kinds of layouts, which you can mix and match as we just did.
    You've encountered the vertical and horizontal layouts; there's also a grid layout,
    which lets you organize things in an *m* × *n* grid, and a form layout, which
    organizes widgets in a manner similar to how the native platform enumerates fields
    on a form.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Qt提供了四种布局，您可以像我们刚刚做的那样混合和匹配。您已经遇到了垂直和水平布局；还有一个网格布局，它可以让您在*m*×*n*网格中组织事物，还有一个表单布局，它可以以类似于本机平台枚举表单字段的方式组织小部件。
- en: 'Right now, our layout''s a little bunched up. Let''s add some spacers to better
    fill the space in the window, and also add a button for an about box:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的布局有点拥挤。让我们添加一些间隔符，以更好地填充窗口中的空间，并添加一个关于框的按钮：
- en: Drag **Vertical Spacer** and drop it between the input lines, and a second vertical
    spacer between the horizontal layout containing the row of buttons and the input
    line.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动**垂直间隔符**，并将其放置在输入行之间，然后在包含按钮行的水平布局和输入行之间再添加一个垂直间隔符。
- en: Drag a **Tool Button** widget to the vertical layout, and add a spacer between
    the bottom line and the push button.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个**工具按钮**小部件拖到垂直布局中，并在底部行和按钮之间添加一个间隔符。
- en: Name the last push button `aboutButton` and give it the text `About`. We'll
    add an icon later.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将最后一个按钮命名为`aboutButton`，并给它文本`关于`。稍后我们将添加一个图标。
- en: 'The following screenshot shows the application as we''ve constructed it in
    the designer if you press the **Run** button:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下**运行**按钮，下面的屏幕截图显示了我们在设计师中构建的应用程序：
- en: '![Creating the main form](img/2319OS_03_03.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![创建主窗体](img/2319OS_03_03.jpg)'
- en: Our application's main window
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的主窗口
- en: 'Now, let''s make our result dialog. Right-click on the project and choose **Add
    New…**, then:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们制作我们的结果对话框。右键单击项目，选择**添加新内容…**，然后：
- en: In the dialog that appears, choose **Qt** on the left, and then **Qt Designer
    Form** in the middle. Click on **Choose**.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在出现的对话框中，选择左侧的**Qt**，然后在中间选择**Qt设计师表单**。点击**选择**。
- en: Choose a dialog style for your dialog; choose **Dialog with Buttons Bottom**
    and click on **Next**.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的对话框选择对话框样式；选择**底部带按钮的对话框**，然后点击**下一步**。
- en: Name the file `resultdialog.ui` and click on **Next**.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件命名为`resultdialog.ui`，然后点击**下一步**。
- en: Click on **Finish**.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**完成**。
- en: In the dialog that appears, drag out **Form Layout**. Right-click on it and
    choose **Lay out** and **Adjust size**.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在出现的对话框中，拖出**表单布局**。右键单击它，选择**布局**和**调整大小**。
- en: Add a **Label** widget to the form layout. Change its text to read `Result`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个**标签**小部件添加到表单布局中。将其文本更改为`结果`。
- en: Drag out another label, and name it `result`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖出另一个标签，并将其命名为`结果`。
- en: Now may be a good time for you to experiment with layouts and spacers, and style
    the dialog any way you wish.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可能是您尝试布局和间隔符，并以您希望的任何方式样式化对话框的好时机。
- en: Using application resources
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用应用程序资源
- en: 'Now, let''s add an icon to the application for the **About** button. You can
    draw one, or go to a website such as The *Noun Project* ([http://bit.ly/16n9bOk](http://bit.ly/16n9bOk))
    for a suitable icon. Icons can be PNG, JPEG, or other formats; a good choice is
    SVG, because SVG images are vector based and scale correctly to different sizes.
    Put the resource file in your project directory, and then:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为**关于**按钮向应用程序添加一个图标。您可以绘制一个，或者去The *Noun Project*（[http://bit.ly/16n9bOk](http://bit.ly/16n9bOk)）等网站寻找合适的图标。图标可以是PNG、JPEG或其他格式；一个不错的选择是SVG，因为SVG图像是基于矢量的，可以正确缩放到不同的大小。将资源文件放在您的项目目录中，然后：
- en: Choose the **Edit** view in Qt Creator.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Qt Creator中选择**编辑**视图。
- en: Right-click on the solution and click on **Add New…**; then, choose **Qt** and
    **Qt Resource File**.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击解决方案，然后点击**添加新内容…**；然后，选择**Qt**和**Qt资源文件**。
- en: Name the file `resources`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件命名为`资源`。
- en: Add it to the current project.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其添加到当前项目中。
- en: If `resources.qrc` isn't already open in the editor, double-click on it in the
    solution pane. The resource file editor will appear.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`resources.qrc`尚未在编辑器中打开，请在解决方案窗格中双击它。资源文件编辑器将出现。
- en: Click on **Add**, choose **Add prefix**, and prefix `/`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加**，选择**添加前缀**，并添加前缀`/`。
- en: Click on **Add** again, select **Add Files**, and choose your icon.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次点击**添加**，选择**添加文件**，然后选择您的图标。
- en: 'Icons are loaded in the read-only segment of your application through the Qt
    resource compiler. You can access them anywhere you''d access a file by prefixing
    the path and name of the resource with a colon. For example, we might place a
    text file in our application resources and then open the file for reading, like
    this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图标是通过Qt资源编译器加载到应用程序的只读段中的。您可以通过在资源的路径和名称前加上冒号来在任何地方访问它们，就像访问文件一样。例如，我们可以将一个文本文件放在我们的应用程序资源中，然后像这样打开文件进行读取：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Application resources are suitable for text and small media files such as icons
    or images. You should avoid using them for larger items like movies and large
    sounds, however, because they'll needlessly bloat the size of your application
    binary. For those purposes, it's better to package media files with your application
    and load them directly from the disk.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序资源适用于文本和小媒体文件，如图标或图像。但是，您应该避免将它们用于像电影和大型声音这样的较大项目，因为它们会不必要地膨胀应用程序二进制文件的大小。对于这些目的，最好将媒体文件与应用程序打包在一起，并直接从磁盘加载它们。
- en: In the next section, we'll use the resource you added, when we add our about
    box to the application.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，当我们向应用程序添加关于框时，我们将使用您添加的资源。
- en: Instantiating forms, message boxes, and dialogs in your application
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在您的应用程序中实例化表单、消息框和对话框
- en: 'The Qt Designer generates an XML-based layout file (which ends in `.ui`) for
    each form you create in the designer. At compile time, Qt Creator compiles the
    layout into a header file that constructs the components for your user interface
    layout. The pattern typically used by Qt applications is to construct a private
    layout class that is instantiated by a main window or dialog''s constructor, and
    then the user interface is instantiated. Here''s how it works for the main window:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Designer 为您在设计器中创建的每个表单生成基于 XML 的布局文件（以 `.ui` 结尾）。在编译时，Qt Creator 将布局编译为一个头文件，用于构建用户界面布局的组件。Qt
    应用程序通常使用的模式是构建一个私有布局类，该类由主窗口或对话框的构造函数实例化，然后实例化用户界面。以下是主窗口的工作原理：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `Ui::MainWindow` class is automatically constructed by the Qt Designer;
    by including its declaration in `mainwindow.cpp`, we create an instance of it
    and assign that instance to the `ui` field. Once initialized, we call its `setupUi`
    function, which creates the entire user interface you sketched out in Qt Designer.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ui::MainWindow` 类是由 Qt Designer 自动构建的；通过在 `mainwindow.cpp` 中包含它的声明，我们创建了一个实例并将该实例分配给
    `ui` 字段。一旦初始化，我们调用它的 `setupUi` 函数，该函数创建了您在 Qt Designer 中勾画出的整个用户界面。'
- en: 'The controls we laid out in Qt Designer are accessible as field names. For
    example, we can modify `mainwindow.cpp` to invoke an about box by adding a slot
    to `mainwindow.h` to handle the case when you click on the **About** button, and
    then add the code to invoke an about box in the implementation of the slot. To
    do that, follow these steps:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Qt Designer 中布置的控件可以作为字段名访问。例如，我们可以修改 `mainwindow.cpp`，通过在 `mainwindow.h`
    中添加一个槽来处理单击 **About** 按钮时的情况，并在槽的实现中添加代码来调用关于框。要做到这一点，请按照以下步骤进行：
- en: 'Add a `public slots` declaration to `mainwindow.h`, along with a slot named
    `aboutClicked`. It should now read:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `mainwindow.h` 中添加一个 `public slots` 声明，以及一个名为 `aboutClicked` 的槽。现在应该是这样的：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the implementation of the `aboutClicked` slot to `mainwindow.cpp`. This
    code constructs a `QMessageBox` object on the stack, and sets its icon to the
    icon you added in your resources earlier, the text of the dialog to `"Lorem ipsum"`,
    and the title of the message box to `"About"`. The `exec` method of the `QMessageBox`
    invocation opens the message box and blocks the application flow until you dismiss
    the message box. It should read:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `aboutClicked` 槽的实现添加到 `mainwindow.cpp`。此代码在堆栈上构造了一个 `QMessageBox` 对象，并将其图标设置为您之前添加的图标，对话框的文本设置为
    `"Lorem ipsum"`，消息框的标题设置为 `"About"`。`QMessageBox` 调用的 `exec` 方法打开消息框并阻塞应用程序流，直到您关闭消息框。它应该是这样的：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'At the top of `mainwindow.cpp`, add an `include` statement for the `QMessageBox`
    class:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `mainwindow.cpp` 的顶部，为 `QMessageBox` 类添加一个 `include` 语句：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the `MainWindow` constructor, connect the signal from the about button to
    the slot you just created. Your constructor should now read:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainWindow` 构造函数中，将关于按钮的信号连接到刚刚创建的槽。您的构造函数现在应该是这样的：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If we build the application, we now have a fully functioning about box, including
    the application icon you chose. The `connect` call is just like the previous signal-slot
    connections we've seen; it connects the `clicked` signal of `aboutButton` to your
    `aboutClicked` slot in the main window UI.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们构建应用程序，现在我们有一个完全功能的关于框，包括您选择的应用程序图标。`connect` 调用就像我们之前看到的信号槽连接一样；它将 `aboutButton`
    的 `clicked` 信号连接到主窗口 UI 中的 `aboutClicked` 槽。
- en: 'A word on naming signals and slots before we continue: a signal is typically
    named a verb in its past tense, denoting the semantics of the event that just
    occurred that it''s trying to signal. A slot should somehow match those semantics,
    preferably including more detail as to how the signal is being handled. So Qt
    names the button''s `clicked` signal logically, and I expand on this by giving
    a slot named `aboutClicked`. Of course, you can name your signals and slots whatever
    you like, but this is a good practice to follow.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们先来谈谈命名信号和槽：信号通常以动词的过去时命名，表示刚刚发生的事件的语义，它试图发出信号。槽应该以某种方式匹配这些语义，最好包括有关如何处理信号的更多细节。因此，Qt
    逻辑上将按钮的 `clicked` 信号命名，我通过给槽命名为 `aboutClicked` 来扩展这一点。当然，您可以根据自己的喜好命名信号和槽，但这是一个很好的实践方法。
- en: 'Before we wire up the other buttons and implement our calculator logic, we
    need to set up the class for our `results` dialog. We''ll follow the pattern of
    the `MainWindow` class, creating a private `ui` member that contains an instance
    of the compile-time generated object that constructs the UI for the results dialog.
    You can create the `ResultDialog` class using the **New File** wizard available
    by right-clicking on the project; choose **Qt Designer Form Class** and name it
    `ResultDialog`. The class itself should inherit from `QDialog`. The header file
    should look like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们连接其他按钮并实现计算器逻辑之前，我们需要为我们的 `results` 对话框设置类。我们将遵循 `MainWindow` 类的模式，创建一个包含编译时生成的构建结果对话框
    UI 的对象实例的私有 `ui` 成员。您可以通过右键单击项目并选择 **Qt Designer Form Class** 来使用 **New File**
    向导创建 `ResultDialog` 类，并将其命名为 `ResultDialog`。该类本身应该继承自 `QDialog`。头文件应该如下所示：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first thing we need to do is forward-declare the `Dialog` class created
    by the Qt Designer; we do this in the namespace `Ui`, so it doesn't conflict with
    any other code in my application. Then, we need to declare a pointer to an instance
    of that class as a private member variable; we name this pointer `ui`, as was
    done for the `MainWindow` class.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是在 `Ui` 命名空间中前向声明由 Qt Designer 创建的 `Dialog` 类；然后，我们需要将该类的实例的指针声明为私有成员变量；我们将这个指针命名为
    `ui`，就像对 `MainWindow` 类所做的那样。
- en: 'You can guess what our `ResultDialog` implementation looks like:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以猜到我们的 `ResultDialog` 实现是什么样的：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: At construction time, it makes an instance of our `Ui:Dialog` class, and then
    invokes its `setupUi` method to create an instance of the user interface at runtime.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造时，它创建了我们的 `Ui:Dialog` 类的一个实例，然后调用其 `setupUi` 方法，在运行时创建用户界面的实例。
- en: Wiring the Qt GUI application logic
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接 Qt GUI 应用程序逻辑
- en: 'The application logic for the calculator is simple: we add a property setter
    to the `ResultDialog` implementation that lets us set the `result` field of the
    dialog, and then wire up some arithmetic, signals, and slots in `MainWindow` to
    do the actual computation and show the dialog.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 计算器的应用逻辑很简单：我们在`ResultDialog`实现中添加了一个属性设置器，它让我们设置对话框的`result`字段，然后在`MainWindow`中连接一些算术、信号和槽，以进行实际计算并显示对话框。
- en: 'First, the change to `ResultDialog`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，更改`ResultDialog`：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This method takes a float, the value to show in the dialog, and formats the
    result as a string using Qt's default formatting. Qt is fully internationalized;
    if you do this in English-speaking locales, it will use a decimal point, while
    if you do it with a locale set to a region where a comma is used as the decimal
    separator, it will use a comma instead. The `number` method is a handy one, with
    overloads taking doubles and floats, as well as integers, and arguments to indicate
    the precision and exponentiation of the returned string.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法接受一个浮点数，显示在对话框中，并使用Qt的默认格式将结果格式化为字符串。Qt是完全国际化的；如果在使用英语的区域中进行此操作，它将使用小数点，而如果在区域设置为使用逗号作为小数分隔符的地区中进行此操作，它将使用逗号。`number`方法是一个方便的方法，它有多个重载，接受双精度和浮点数，以及整数，并带有参数来指示返回字符串的精度和指数。
- en: 'Now, the modified `MainWindow` class. First, the revised class declaration:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，修改后的`MainWindow`类。首先，修改后的类声明：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In addition to the base class `QMainWindow`, I now include `QPair`, a simple
    Qt template that lets us pass pairs of values. We'll use the `QPair` template,
    type-defined as `Arguments`, to pass around the pair of arguments for an arithmetic
    operation.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基类`QMainWindow`之外，我现在还包括`QPair`，这是一个简单的Qt模板，让我们可以传递一对值。我们将使用`QPair`模板，类型定义为`Arguments`，来传递算术操作的一对参数。
- en: 'I add a signal, computed, which the class triggers any time it performs an
    arithmetic operation. I also add slots for each of the arithmetic button clicks:
    `plusClicked`, `minusClicked`, `timesClicked`, and `dividedClicked`. Finally,
    I add a signal `showResult`, which shows the result when a computation occurs.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我添加了一个信号`computed`，这个类在执行算术操作时触发任何时间。我还为每个算术按钮点击添加了槽：`plusClicked`、`minusClicked`、`timesClicked`和`dividedClicked`。最后，我添加了一个`showResult`信号，当发生计算时显示结果。
- en: 'The constructor of `MainWindow` now needs to do a bunch of signal-slot wiring
    for all of our buttons, signals, and slots:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainWindow`的构造函数现在需要为所有按钮、信号和槽进行一堆信号-槽连接：'
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: After connecting the about button to the slot that shows the about dialog, I
    next connect the computed signal from `MainWindow` to its `showResult` slot. Note
    that this signal/slot carries an argument, the value to show. The remaining four
    connections connect each of the operation buttons with the code to perform a specific
    arithmetic operation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 将关于按钮连接到显示关于对话框的槽之后，我接下来将`MainWindow`的计算信号连接到其`showResult`槽。请注意，此信号/槽携带一个参数，要显示的值。剩下的四个连接将每个操作按钮与执行特定算术操作的代码连接起来。
- en: 'The `showResult` slot creates a new `ResultDialog` object if we don''t already
    have one, sets its result to the incoming value, and invokes the dialog:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`showResult`槽如果我们还没有一个，就创建一个新的`ResultDialog`对象，将其结果设置为传入的值，并调用对话框：'
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `arguments` method is a helper method used by each of the arithmetic functions,
    it fetches the values from each of the input lines, converts them from strings
    to floating-point numbers, and does a little bit of error checking to ensure that
    the entries are valid floating-point numbers:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments`方法是一个辅助方法，每个算术函数都使用它，它从每个输入行中获取值，将它们从字符串转换为浮点数，并进行一些错误检查，以确保条目是有效的浮点数。'
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `QString` method `toFloat` does just that: it converts a string to a floating-point
    number, returns the number, and sets the Boolean passed in to `true` if the conversion
    was successful, and `false` otherwise. The code does this for both argument input
    lines, then checks the resulting Boolean values, and reports an error if either
    argument is malformed, before returning a QPair of the arguments to the caller.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`QString`方法`toFloat`就是这样做的：它将一个字符串转换为浮点数，返回该数字，并且如果转换成功，则将传入的布尔值设置为`true`，否则设置为`false`。代码对两个参数输入行都这样做，然后检查生成的布尔值，并在任一参数格式错误时报告错误，然后将参数的QPair返回给调用者。'
- en: 'The remaining code actually performs the arithmetic, signaling that a computation
    has occurred when the operation is complete. For example, take the `plusClicked`
    slot:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的代码实际上执行算术运算，在操作完成时发出计算已完成的信号。例如，考虑`plusClicked`槽：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This obtains the arguments from the input lines using the `arguments` function,
    computes the sum, and then emits the computed signal with the summed value. Because
    we connected the computed signal to the `showResults` slot, this triggers a call
    to `showResults`, which creates the `ResultDialog` object if necessary, and shows
    the dialog with the computed result. The `minusClicked`, `timesClicked`, and `divideClicked`
    methods are all similar.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`arguments`函数从输入行获取参数，计算总和，然后发出带有总和值的计算信号。因为我们将计算信号连接到`showResults`槽，这将触发对`showResults`的调用，如果需要，它将创建`ResultDialog`对象，并显示带有计算结果的对话框。`minusClicked`、`timesClicked`和`divideClicked`方法都是类似的。
- en: Learning more about Qt GUI widgets
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习更多关于Qt GUI小部件
- en: 'There are whole books written about programming with the Qt GUI widget set:
    it''s a very rich widget set that includes just about everything you''d need to
    build the average Macintosh, Windows, or Linux application, and has the advantage
    that the UI controls are familiar to most computer users. To explore further,
    see the Qt documentation at [http://bit.ly/17stfw3](http://bit.ly/17stfw3).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用Qt GUI小部件集进行编程的整本书：这是一个非常丰富的小部件集，包括构建普通Macintosh、Windows或Linux应用程序所需的几乎所有内容，并且具有UI控件对大多数计算机用户来说都很熟悉的优势。要进一步探索，请参阅[http://bit.ly/17stfw3](http://bit.ly/17stfw3)上的Qt文档。
- en: Code interlude – Qt Quick and QML syntax
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码插曲-Qt Quick和QML语法
- en: 'Most of the programming you do at the lowest level is imperative: you describe
    how an algorithm should work ("take this value and square it", "search for the
    first occurrence of this string and replace it", "format this data this way",
    and so forth). With Qt Quick, your programming is largely declarative: instead
    of saying *how*, you say *what*. For example, in C++ with Qt, we might write code
    like this to draw a rectangle:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你在最低级别的大部分编程都是命令式的：你描述算法应该如何工作（“取这个值并平方”，“搜索这个字符串的第一个出现并替换它”，“以这种方式格式化这个数据”等）。在Qt
    Quick中，你的编程主要是声明式的：你不是说“如何”，而是说“什么”。例如，在C++中使用Qt，我们可能会写出这样的代码来绘制一个矩形：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This code creates a 16 x 16 pixel rectangle, allocates a `QPainter` object
    that does the drawing, tells the painter that its brush should be colored blue,
    and then tells the painter to draw the rectangle. In QML, I''d simply write the
    rectangle:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个16 x 16像素的矩形，分配了一个进行绘制的`QPainter`对象，告诉绘图者它的画笔应该是蓝色的，然后告诉绘图者绘制矩形。在QML中，我只需写下矩形：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The difference is obvious: I am just saying that there is a blue rectangle
    that''s 16 x 16 pixels. It''s up to the Qt Quick runtime to determine how to draw
    the rectangle.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 区别是显而易见的：我只是说有一个蓝色的16 x 16像素的矩形。由Qt Quick运行时决定如何绘制矩形。
- en: 'Qt Quick''s underlying language is QML. It is based heavily on JavaScript,
    and in fact, most things that you can write in JavaScript you can also express
    in QML. Expression syntax is essentially unchanged: assignments, arithmetic, and
    so forth are all the same, and the name-value system is functionally the same,
    although object frames may be preceded by a type declaration (as you see with
    the `Rectangle` example that I just showed you).'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick的基础语言是QML。它在很大程度上基于JavaScript，事实上，大多数你可以用JavaScript编写的东西也可以用QML表达。表达式语法基本上没有改变：赋值、算术等都是一样的，名称-值系统在功能上也是一样的，尽管对象框可能会在类型声明之前（就像我刚刚向你展示的`Rectangle`示例一样）。
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A key exception to the "what works in JavaScript works in QML" rule is the lack
    of a document object model (DOM) and things like the document root for global
    variables because there's no root context or DOM on which other things hang. If
    you're porting a web application to QML, be prepared to refactor those parts of
    your application's architecture.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: “在JavaScript中有效的在QML中也有效”规则的一个关键例外是缺乏文档对象模型（DOM）和像文档根这样的全局变量，因为没有根上下文或DOM，其他东西都挂在上面。如果你要将Web应用程序移植到QML，请准备好重构应用程序架构的这些部分。
- en: Objects in QML must be parented in the fashion of a tree; each QML file must
    contain an encapsulating object, and then can have child objects that have child
    objects. However, there must be a single root for the hierarchy at the top of
    the file. Often, this root is a rectangle, which draws a base rectangle on which
    its children are presented, or an item, which is a container for a more complex
    user interface element that doesn't actually draw anything. Each item may have
    a name, which is stored in its `id` property.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: QML中的对象必须以树的方式进行父子关系；每个QML文件必须包含一个封装对象，然后可以有具有子对象的子对象。但是，在文件的顶部必须有一个单一的层次结构根。通常，这个根是一个矩形，它绘制一个基本矩形，其子对象被呈现在上面，或者是一个项目，它是一个更复杂的用户界面元素的容器，实际上并不绘制任何东西。每个项目可能有一个名称，存储在其`id`属性中。
- en: Most visible QML items can have states; that is, a collection of properties
    that apply when a particular state is active. This lets you do things such as
    declare the difference between a button's dormant and pressed state; pressing
    the button just toggles between the states, and the button's color, shadow, and
    so on can all change with you, and there is no need to change each individual
    property.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数可见的QML项目都可以有状态；也就是说，当特定状态处于活动状态时，一组属性将应用。这使你可以声明按钮的静止和按下状态之间的差异；按下按钮只是在状态之间切换，按钮的颜色、阴影等都可以随之改变，而不需要更改每个单独的属性。
- en: 'A key concept in QML that''s not present in JavaScript is that of **binding**:
    if two QML object properties share the same value, changing one changes the other.
    Binding couples values with notifications about values is similar to how references
    work in C++, or how pass-by reference works in other languages, but this happens
    in QML at the level of the variable name being referenced. This is very handy
    in coding things such as animations, because you can use the value of one object
    as the value for another object, and when the underlying value changes in one
    place, both objects are updated.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在QML中一个关键概念是**绑定**：如果两个QML对象属性共享相同的值，改变一个会改变另一个。绑定将值与关于值的通知耦合在一起，类似于C++中引用的工作方式，或者其他语言中的按引用传递的方式，但在QML中，这发生在被引用的变量名的级别上。这在编写诸如动画之类的东西时非常方便，因为你可以使用一个对象的值作为另一个对象的值，当底层值在一个地方发生变化时，两个对象都会更新。
- en: 'QML files can depend on each other, or include files of JavaScript for business
    logic. You''ve already seen one example of this at the top of every QML file:
    the `import` directive instructs the runtime to include the indicated file and
    version, so when I write `import QtQuick 2.0`, the runtime finds the declaration
    of the QtQuick module Version 2.0 and includes its symbols when parsing the file.
    This is how you can encapsulate functionality. QML files in your project are included
    by default, while you can also include JavaScript files and assign them to a specific
    JavaScript variable. For example, we could have a JavaScript file `calculatorLogic.js`
    that implements all of the functionality of my calculator, and in the QML, write:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: QML文件可以相互依赖，或者包含JavaScript文件以进行业务逻辑。你已经在每个QML文件的顶部看到了一个例子：`import`指令指示运行时包含指定的文件和版本，所以当我写`import
    QtQuick 2.0`时，运行时会找到QtQuick模块版本2.0的声明，并在解析文件时包含其符号。这就是你可以封装功能的方式。项目中的QML文件默认包含，同时你也可以包含JavaScript文件并将其分配给特定的JavaScript变量。例如，我们可以有一个名为`calculatorLogic.js`的JavaScript文件，它实现了我的计算器的所有功能，在QML中写入：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The initial import loads JavaScript and assigns its value to the QML object
    `CalculatorLogic`; I can then dispatch methods and access properties of that object
    as if it were any other QML object.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 初始导入加载JavaScript并将其值分配给QML对象`CalculatorLogic`；然后我可以像处理其他QML对象一样调度方法和访问该对象的属性。
- en: 'Qt Quick declares a number of basic datatypes; these match closely with the
    datatypes you find in Qt when writing C++ code, although the syntax can differ.
    Some of the most important types you''ll encounter are:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick声明了许多基本数据类型；这些与您在编写C++代码时在Qt中找到的数据类型非常相似，尽管语法可能有所不同。您将遇到的一些最重要的类型包括：
- en: A point with the `x` and `y` properties
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有`x`和`y`属性的点
- en: A rectangle with the `x`, `y`, `width`, and `height` properties
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有`x`、`y`、`宽度`和`高度`属性的矩形
- en: A size with the `width` and `height` properties
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有`宽度`和`高度`属性的大小
- en: A color, which is a quoted string in HTML RGB notation or a named color from
    Qt's lexicon of colors (most colors you can think of have names in QML)
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 颜色，这是HTML RGB表示法中的带引号的字符串或Qt颜色词典中的命名颜色（您可以想到的大多数颜色在QML中都有名称）
- en: A 2D, 3D, or 4D vector
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个2D、3D或4D向量
- en: Basic types including Boolean values, strings, integers, and floating-point
    numbers
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括布尔值、字符串、整数和浮点数在内的基本类型
- en: There are also a lot of visible types for user interface construction; in this
    chapter, there's only room to touch on a few. For a detailed list of all QML types
    and the documentation about those types, see [http://bit.ly/17stfw3](http://bit.ly/17stfw3).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多用于用户界面构建的可见类型；在本章中，只有少数类型可以提及。有关所有QML类型的详细列表以及有关这些类型的文档，请参见[http://bit.ly/17stfw3](http://bit.ly/17stfw3)。
- en: Creating Qt Quick applications in Qt Designer
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Qt Designer中创建Qt Quick应用程序
- en: 'In [Chapter 1](ch01.html "Chapter 1. Getting Started with Qt Creator"), *Getting
    Started with Qt Creator*, you gained basic familiarity with the Qt Designer for
    Qt Quick applications. Let''s take another look before we recreate our calculator
    app in QML. The next screenshot shows the Qt Designer for the Qt Quick window:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章。使用Qt Creator入门")中，*使用Qt Creator入门*，您已经对Qt Designer进行了基本了解，用于Qt
    Quick应用程序。在我们重新在QML中创建计算器应用程序之前，让我们再看一遍。下一张截图显示了Qt Designer用于Qt Quick窗口：
- en: '![Creating Qt Quick applications in Qt Designer](img/2319OS_03_04.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![在Qt Designer中创建Qt Quick应用程序](img/2319OS_03_04.jpg)'
- en: The Qt Designer for Qt Quick
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Designer用于Qt Quick
- en: 'Working from the left again, we have the following components:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 再次从左边开始，我们有以下组件：
- en: The view selector, showing that the Qt Designer view is active
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图选择器，显示Qt Designer视图处于活动状态
- en: The object hierarchy for the file being edited, showing the parent-child relationship
    between visible items in that file
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在编辑的文件的对象层次结构，显示了该文件中可见项目之间的父子关系
- en: Below the object hierarchy is a palette of the items you can drag out onto the
    QML editor pane
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对象层次结构下方是可以拖动到QML编辑器窗格上的项目的调色板
- en: Next to the object hierarchy is a summary of the states for the object
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象状态的摘要
- en: Below the summary of states is the object editor for the QML file
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在状态摘要下方是QML文件的对象编辑器
- en: Finally, there's a property editor that lets you adjust the properties of the
    currently selected QML item
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，有一个属性编辑器，可以调整当前选定的QML项目的属性
- en: Tip
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Frankly, I find it easier to just write QML than to use the designer. The syntax
    takes a little getting used to, but what the designer is good for is previewing
    the QML you've written by hand and making minor adjustments to its layout.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 坦率地说，我觉得写QML比使用设计师更容易。语法需要一点时间来适应，但设计师擅长的是通过手写的QML预览你所写的QML，并对其布局进行微小调整。
- en: Speaking of layout, before we see our sample code in detail, it's worth noting
    that QML has a rich dynamic layout system. Visible items have an `anchor` property,
    and you can anchor an item's sides against that of its neighbors or the parent
    view. You saw this briefly in [Chapter 1](ch01.html "Chapter 1. Getting Started
    with Qt Creator"), *Getting Started with Qt Creator*, where we made `MouseArea`
    as big as its parent. We'll also use that to control the layout of the calculator
    argument input lines and operator buttons.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 说到布局，在我们详细查看示例代码之前，值得注意的是QML具有丰富的动态布局系统。可见项目具有`anchor`属性，您可以将项目的边缘锚定在其邻居或父视图的边缘上。您在[第1章](ch01.html
    "第1章。使用Qt Creator入门")中简要看到了这一点，我们将`MouseArea`设置为与其父级一样大。我们还将使用它来控制计算器参数输入行和操作按钮的布局。
- en: Start making our sample code now by choosing **New File or Project…** from the
    **File** menu, and walk through the wizard to create a Qt Quick 2.0 application.
    Name your application `QtQuickCalculator`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过从**文件**菜单中选择**新文件或项目…**开始制作我们的示例代码，并通过向导创建一个Qt Quick 2.0应用程序。将应用程序命名为`QtQuickCalculator`。
- en: Creating a reusable button
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建可重用按钮
- en: Our calculator has a button for each operation. While we could make each button
    a separate rectangle and `MouseArea`, it's far easier to make a single QML button
    that encapsulates the behavior of a button, including the change in appearance
    when you press on it, the placement of the button label, and so forth.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的计算器为每个操作都有一个按钮。虽然我们可以将每个按钮制作成单独的矩形和`MouseArea`，但更容易的方法是制作一个封装按钮行为的单个QML按钮，包括按下时外观的变化、按钮标签的放置等。
- en: 'Create a new QML file by right-clicking on the project and choosing **Add New…**,
    then from the Qt items, choose **QML File (Qt Quick 2)**. The button is a rectangle
    that contains a second rectangle, a `Text` label for the button, and a `MouseArea`
    region that handles button clicks. Name the file `Button.qml`, and edit it so
    that it reads as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过右键单击项目并选择**添加新内容…**，然后从Qt项目中选择**QML文件（Qt Quick 2）**来创建一个新的QML文件。该按钮是一个包含第二个矩形、按钮的`Text`标签和处理按钮点击的`MouseArea`区域的矩形。将文件命名为`Button.qml`，并编辑它，使其内容如下：
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Working from the top of the file code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件代码的顶部开始：
- en: Within the scope of this file, the button's ID is simply `button`.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此文件的范围内，按钮的ID只是`button`。
- en: It's 64 pixels in both width and height.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宽度和高度都是64像素。
- en: The button has a single property configurable by its clients, the `operation`
    property. That property is actually an alias, meaning it's automatically setting
    the value of the `buttonText.text` property instead of being a separate field.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮有一个由其客户端配置的属性，即`operation`属性。该属性实际上是一个别名，这意味着它自动设置`buttonText.text`属性的值，而不是作为一个单独的字段。
- en: The button emits a single signal, the `clicked` signal.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮发出一个信号，即`clicked`信号。
- en: The button's color is green.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮的颜色是绿色。
- en: There's a rectangle that fills the button that is colored black, but has opacity
    of zero, meaning in normal use it's not visible, it's transparent. As the button
    is pressed, I adjust the opacity of this rectangle, to shade the button darker
    when it's being pressed.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个填充按钮的矩形，颜色为黑色，但不透明度为零，意味着在正常使用中它是不可见的，是透明的。当按下按钮时，我调整这个矩形的不透明度，使按钮在被按下时变暗。
- en: The `text` label of the button is `16` points in size, colored white, and centered
    in the button itself.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮的`text`标签大小为`16`点，颜色为白色，并居中在按钮本身。
- en: The `MouseArea` region that accepts clicks for the button is the same size as
    the button and emits the clicked signal.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受按钮点击的`MouseArea`区域与按钮大小相同，并发出`clicked`信号。
- en: 'The button has two states: the default state, and a second state pressed that
    occurs when the `mouseArea.pressed` property is `true` (because you are pressing
    the mouse button in the mouse area). When the state is pressed, I request a single
    `PropertyChange` event, changing the rectangle''s opacity a bit to give a shadow
    over the button, darkening it.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮有两个状态：默认状态和第二个状态pressed，当`mouseArea.pressed`属性为`true`时（因为您正在按下鼠标区域中的鼠标按钮）发生。当状态为pressed时，我请求一个单一的`PropertyChange`事件，稍微改变矩形的不透明度，给按钮投上一层阴影，使其变暗。
- en: You can actually see the two states of the button if you enter the Qt Designer
    (see the following screenshot). A state is just a name, a `when` clause indicating
    when the state is active, and a collection of `PropertyChanges` indicating what
    properties should change when the state is active. All visible QML items have
    a `state` property, which is just the name of the currently active state.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，您可以在进入Qt Designer时看到按钮的两个状态（请参见以下屏幕截图）。状态只是一个名称，一个指示状态何时处于活动状态的`when`子句，以及一组`PropertyChanges`，指示状态处于活动状态时应更改哪些属性。所有可见的QML项都有一个`state`属性，它只是当前活动状态的名称。
- en: '![Creating a reusable button](img/2319OS_03_05.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![创建可重用按钮](img/2319OS_03_05.jpg)'
- en: The states of the button
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮的状态
- en: Note that QML uses signals and slots similar to Qt in C++, but there's no `emit`
    keyword. Instead, you declare the signal directly using the `signal` keyword and
    the name of the signal, and then you invoke the signal as if it were a function
    call. For each QML item's signal, the slot is named `on` followed by the signal
    name; for example, `onClicked`, `onPressed`, and so on. Thus, when we use the
    button, we write an `onClicked` handler for the `clicked` signal.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，QML使用类似于C++中的Qt的信号和槽，但没有`emit`关键字。相反，您可以直接使用`signal`关键字和信号的名称来声明信号，然后像调用函数一样调用信号。对于每个QML项的信号，槽的名称为`on`后跟信号名称；例如，`onClicked`，`onPressed`等。因此，当我们使用按钮时，我们为`clicked`信号编写一个`onClicked`处理程序。
- en: The calculator's main view
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算器的主视图
- en: 'Go back to the editor and edit `main.qml` directly. We''re going to declare
    our input lines, result line, and four operation buttons directly in code; you
    can do much of the same with the designer if you''d prefer, and then edit the
    code to match the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 返回编辑器，直接编辑`main.qml`。我们将在代码中直接声明我们的输入行、结果行和四个操作按钮；如果您愿意，您也可以在设计师中做类似的操作，然后编辑代码以匹配以下内容：
- en: '[PRE23]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The view has two `TextInput` lines, a read-only `text` result line, and then
    the `operation` buttons, wrapped in a `Row` item to give them a horizontal layout.
    The base view for the calculator is `grey`, and is in a window 360 × 200 pixels.
    The controls are positioned as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 视图有两个`TextInput`行，一个只读的`text`结果行，然后是`operation`按钮，包裹在`Row`项中，以给它们一个水平布局。计算器的基本视图是`grey`，位于360×200像素的窗口中。控件的位置如下：
- en: The first input line is anchored to the top left of the parent window, with
    margins of 10 pixels. It's 160 pixels long and the default height for an 18-point
    `TextInput` field.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个输入行锚定在父窗口的左上角，各有10像素的边距。它也是160像素长，是18点`TextInput`字段的默认高度。
- en: The second input line is anchored to the right side of the parent, with a margin
    of 10 pixels at the top and right. It's also 160 pixels long, and the default
    height of an 18-point `TextInput` field.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个输入行锚定在父级的右侧，顶部和右侧各有10像素的边距。它也是160像素长，是18点`TextInput`字段的默认高度。
- en: The result input line's top is anchored to the bottom of the input line, and
    to the left of the parent rectangle. It also has 10 pixels of margins on each
    side.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果输入行的顶部锚定在输入行的底部，并且锚定在父矩形的左侧。两侧也各有10像素的边距。
- en: The buttons are spaced 20 pixels apart in a `Row` item that's anchored to the
    bottom of the parent.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮在一个`Row`项中间隔20像素，该项锚定在父级的底部。
- en: These anchors let the view reflow nicely if you resize the application window;
    the input lines spread across the width of the window, and the button bar on the
    bottom moves down as the window enlarges.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这些锚点可以让视图在调整应用程序窗口大小时重新流动；输入行横跨窗口的宽度，底部的按钮栏随着窗口的放大而向下移动。
- en: 'Each of the buttons has a `click` slot that obtains the floating-point interpretation
    of each of the input lines and performs the appropriate arithmetic operation.
    They''re each instances of `Button`, the QML class I showed you in the previous
    section. Note the use of the JavaScript function `parseFloat` in the `onClicked`
    handlers: as you''d expect from what I mentioned before, there''s support for
    the functions in the JavaScript runtime in QML, so we can just invoke JavaScript
    functions directly.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 每个按钮都有一个`click`槽，用于获取每个输入行的浮点解释并执行适当的算术操作。它们都是我在上一节中向您展示的QML类`Button`的实例。请注意，在`onClicked`处理程序中使用了JavaScript函数`parseFloat`：正如我之前提到的，QML中的JavaScript运行时支持这些函数，因此我们可以直接调用JavaScript函数。
- en: 'The following screenshot shows the completed calculator application. Note,
    when running the app, if you mouse over a button and press down, you''ll see the
    shading darken (this isn''t shown in the screenshot). This reflects the two states
    in the button that I showed you in the previous section:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了完成的计算器应用程序。请注意，运行应用程序时，如果您将鼠标悬停在按钮上并按下，您会看到阴影变暗（这在屏幕截图中没有显示）。这反映了我在上一节中向您展示的按钮的两种状态：
- en: '![The calculator''s main view](img/2319OS_03_06.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![计算器的主视图](img/2319OS_03_06.jpg)'
- en: The completed Qt Quick calculator application
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的Qt Quick计算器应用程序
- en: Learning more about Qt Quick and QML
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习更多关于Qt Quick和QML
- en: Qt Quick was designed to create fluid applications that don't have a lot of
    deep widget complexity. Media hubs, photo viewers, phone dialers, web browsers,
    and other sorts of applications that don't need to match the look and feel of
    the host platform (or are on embedded systems where the host platform is all written
    in Qt Quick) are good examples of applications suiting the Qt Quick paradigm.
    For more information about Qt Quick with a plethora of examples that show you
    the breadth and power of the platform, see [http://bit.ly/16ULQ4V](http://bit.ly/16ULQ4V).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick旨在创建流畅的应用程序，不需要太多深层次的小部件复杂性。媒体中心、照片查看器、电话拨号器、网页浏览器等不需要与主机平台外观和感觉匹配（或者在主机平台完全使用Qt
    Quick编写）的应用程序是Qt Quick范例的好例子。有关Qt Quick的更多信息以及展示平台广度和功能的大量示例，请参阅[http://bit.ly/16ULQ4V](http://bit.ly/16ULQ4V)。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Qt comes with not one, but two complementary GUI toolkits: Qt GUI, which takes
    a traditional widget-based approach to GUI development, and Qt Quick, which provides
    a declarative approach better-suited for platform-agnostic user interfaces for
    media boxes, some cell phone applications, automobile dashboards, and other embedded
    environments. For both, Qt offers Qt Designer, a drag-and-drop environment that
    lets you construct, configure, and preview your user interface as you build your
    application.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Qt提供了不止一个GUI工具包：Qt GUI采用传统的基于小部件的GUI开发方法，而Qt Quick提供了一种声明性方法，更适合于媒体盒子、一些手机应用程序、汽车仪表板和其他嵌入式环境的跨平台用户界面。对于这两种方法，Qt都提供了Qt
    Designer，一个拖放环境，让您在构建应用程序时构建、配置和预览用户界面。
- en: Core to Qt is the notion of signals and slots, Qt's answer to callbacks and
    events for handling the late-binding required of today's GUI applications. Qt
    objects can emit signals, which are type-safe function declarations, and other
    objects can connect to those signals, triggering method calls when the signals
    are emitted.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Qt的核心是信号和槽的概念，是Qt对于处理当今GUI应用程序所需的延迟绑定的回调和事件的解决方案。Qt对象可以发出信号，这些信号是类型安全的函数声明，其他对象可以连接到这些信号，触发方法调用当信号被发出时。
- en: 'In the next chapter, you''ll take a break from learning about Qt Creator and
    graphical user interface development to focus on one key aspect of application
    development: localization. I''ll show you how to use Qt Linguist and Qt''s localization
    functions to localize your application.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将暂停学习Qt Creator和图形用户界面开发，专注于应用程序开发的一个关键方面：本地化。我将向您展示如何使用Qt Linguist和Qt的本地化功能来本地化您的应用程序。
