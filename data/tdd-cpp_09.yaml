- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Using Tests
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用测试
- en: Everything in this book until now has been about using TDD to design and build
    a unit test library. While that has been valuable, it’s been a bootstrap project
    where we’ve used TDD to help create a tool for TDD.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书的所有内容都是关于使用TDD来设计和构建一个单元测试库。虽然这很有价值，但它是一个自举项目，我们使用TDD来帮助创建一个TDD的工具。
- en: 'This chapter is different. For the first time, we’re going to use TDD to create
    something that will use a unit test library just like any other project you’ll
    be working on. This will still be a library that’s intended to be used by other
    projects. We’re going to create a logging library, and we’re going to use TDD
    and the unit test library to reach the following goals:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有所不同。我们将首次使用TDD来创建一个将使用单元测试库的项目。这仍然是一个旨在供其他项目使用的库。我们将创建一个日志库，并使用TDD和单元测试库来实现以下目标：
- en: Create a design that’s easy to use
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个易于使用的界面
- en: Improve the quality of the code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高代码质量
- en: Refactor the design as needed while maintaining confidence in the code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在保持对代码的信心的情况下，根据需要重构设计
- en: Create tests that help capture the requirements and document the usage of the
    library
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建帮助捕捉需求和记录库用法的测试
- en: The approach should be familiar by now. We’ll start out simple and get something
    working, before enhancing the design and adding new features. Each step will start
    with tests that will drive the design so that we can reach the goals.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法现在应该已经很熟悉了。我们将从简单开始，先让某个功能工作，然后再增强设计并添加新功能。每个步骤都将从测试开始，以驱动设计，从而实现目标。
- en: We’ll first think about why we are building a logging library. This is important
    to set the overall direction of the project. Then we’ll explore how TDD will help
    us and what the ideal logging library would look like. And then, we’ll start building
    the logging library.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先思考一下为什么我们要构建一个日志库。这对于确定项目的整体方向非常重要。然后我们将探讨TDD如何帮助我们，以及理想的日志库应该是什么样子。接着，我们将开始构建日志库。
- en: At the end of this chapter, you’ll have a simple logging library that you can
    use in your projects. But even more important is the skill you’ll gain by seeing
    exactly how to use TDD in a real project.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将拥有一个简单的日志库，你可以在自己的项目中使用。但更重要的是，通过看到如何在真实项目中使用TDD，你将获得一项技能。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All code in this chapter uses standard C++ that builds on any modern C++ 20
    or later compiler and Standard Library. The code uses the testing library from
    the previous chapters and will start a new project.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有代码都使用标准C++，它基于任何现代C++ 20或更高版本的编译器和标准库。代码使用前几章中的测试库，并将启动一个新的项目。
- en: 'You can find all the code for this chapter in the following GitHub repository:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下GitHub仓库中找到本章的所有代码：
- en: '[https://github.com/PacktPublishing/Test-Driven-Development-with-CPP](https://github.com/PacktPublishing/Test-Driven-Development-with-CPP)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Test-Driven-Development-with-CPP](https://github.com/PacktPublishing/Test-Driven-Development-with-CPP)'
- en: Why build a logging library?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么要构建一个日志库？
- en: There are already lots of choices available in other libraries for logging.
    So why build another logging library? Isn’t this supposed to be a book about TDD?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他库中已经有很多用于日志的选择了。那么为什么还要构建另一个日志库？这不是应该是一本关于TDD的书吗？
- en: This is a practical book that shows you how to use TDD in your own projects.
    And one of the best ways to do that is to use TDD to build a project. We needed
    a project for this book, and I thought that a logging library would be perfect
    because we can start out simple and enhance it along the way. A logging library
    is useful and practical in itself, which also fits the theme of this book.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一本实用的书，展示了如何在你的项目中使用TDD。而实现这一目标最好的方法之一就是使用TDD来构建一个项目。我们需要为这本书找一个项目，我认为日志库是完美的，因为我们可以从简单开始，并在过程中增强它。日志库本身既实用又实际，这也符合本书的主题。
- en: If you already have your own logging library or are using one you found elsewhere,
    then this book will still help you to better understand how it works. And you’ll
    also benefit from the process of building a logging library so that you can apply
    the same process to your own project.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经有了自己的日志库或者正在使用其他地方找到的日志库，那么这本书仍然能帮助你更好地理解它是如何工作的。你还可以从构建日志库的过程中受益，这样你就可以将同样的过程应用到自己的项目中。
- en: But we’re not going to settle for a logging library that does what all the other
    logging libraries do. Following a TDD approach, we need to have a good idea of
    how something will be used. We approach problems from a user’s point of view.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不会满足于一个只做所有其他日志库所做的事情的日志库。遵循TDD方法，我们需要有一个很好的想法，知道某物将如何被使用。我们从用户的角度来处理问题。
- en: We’re going to approach this as if we were building micro-services. Instead
    of building a software solution as one giant application that does everything
    needed, a micro-service architecture builds smaller applications that accept requests,
    perform some desired service, and return the results. One service can sometimes
    call other services to perform its function.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像构建微服务一样来处理这个问题。而不是构建一个作为单一应用程序的软件解决方案，这个应用程序能够完成所有需要的功能，微服务架构构建的是一些较小的应用程序，它们接受请求，执行一些期望的服务，并返回结果。有时一个服务可以调用其他服务来执行其功能。
- en: There are many benefits to an architecture such as this that this book will
    not go into. This architecture is being used to give us a specific use in mind
    as we employ TDD to design a logging library that will be uniquely suited to a
    micro-service environment.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构有许多好处，本书将不会深入探讨。这种架构正在被用来在我们应用TDD来设计日志库时，提供一个特定的用途，这个日志库将特别适合微服务环境。
- en: Without a focus on and knowledge of the specific user that will need the software
    you are designing, you face the risk of designing something that doesn’t meet
    the needs of that user. Our user for this book will be a software developer who
    is writing micro-services and needs to log what the services do. That’s the type
    of focus I encourage you to get to when designing your own software. Because without
    the focus just described, we might have jumped right into a logging library that
    does what most other logging libraries do. Our micro-service developer would look
    at a general-purpose logging library and find nothing special about it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有关注和了解将需要你设计的软件的具体用户，你面临的风险是设计出不符合该用户需求的东西。本书的用户将是一位编写微服务的软件开发者，需要记录服务做了什么。这就是我鼓励你在设计自己的软件时要达到的那种关注类型。因为没有这种关注，我们可能会直接跳入一个做大多数其他日志库所做的事情的日志库。我们的微服务开发者会看到一个通用目的的日志库，并发现它没有什么特别之处。
- en: Our goal instead is for that same micro-service developer to look at our logging
    library and immediately see the benefits and want to start using it. The next
    section will show how TDD benefits the most from an awareness of who will be using
    the logging library.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是让同一个微服务开发者看到我们的日志库，并立即看到其好处，并想要开始使用它。下一节将展示TDD如何从对将使用日志库的人的了解中受益。
- en: How will TDD help build a logging library?
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD如何帮助构建日志库？
- en: The biggest benefit we’ll get from using TDD to build a logging library is the
    customer focus. It’s easy to make assumptions about how something should be designed,
    especially when there are already many common solutions that do something similar.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TDD来构建日志库，我们将获得的最大好处是客户关注。关于如何设计某物，很容易做出假设，尤其是在已经有许多类似解决方案的情况下。
- en: It’s like a trail that’s easy to follow. The trail might take you someplace
    you want to go or maybe nearby. And if the destination is vague or unknown, then
    a trail becomes even easier to follow. But if you know exactly where you want
    to go, then you can follow a trail when convenient and leave the trail when it
    no longer takes you where you want to go.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像一条容易跟随的小径。这条小径可能会带你去你想去的地方，或者可能就在附近。如果目的地模糊或未知，那么小径就更容易跟随。但如果你确切地知道你想去哪里，那么你可以在方便的时候跟随小径，当它不再带你去你想去的地方时，你也可以离开小径。
- en: TDD encourages us to think about how we want to use the software that we’re
    building. This, in turn, lets us customize the solution to best fit our needs.
    In other words, it lets us know when to leave the trail and start a new path.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: TDD鼓励我们思考我们想要如何使用我们正在构建的软件。这反过来又让我们能够定制解决方案，以最好地满足我们的需求。换句话说，它让我们知道何时离开小径，开始新的路径。
- en: We also benefit from having tests that can verify the behavior of the software
    because building software is not like walking along a path one time. We don’t
    start at the beginning and walk directly to the destination or final software
    that we want to build.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还从拥有可以验证软件行为的测试中受益，因为构建软件不像一次走过一条路。我们不是从起点开始，直接走到我们想要构建的最终软件或目的地。
- en: Instead, we refine the path. It’s more like starting with a map and drawing
    a rough path to the destination. Maybe the path aligns with known and existing
    paths, and maybe not. Once we have the rough path drawn, we refine it by adding
    more details. Sometimes the details might make us change our path. By the time
    we’re done, we’ve walked the path so many times we’ve lost count.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们细化路径。这更像是从一个地图开始，画一条通往目的地的粗糙路径。也许这条路径与已知和现有的路径对齐，也许不对。一旦我们画出了粗糙的路径，我们就通过添加更多细节来细化它。有时细节可能会让我们改变路径。当我们完成时，我们已经走了很多次，以至于我们数不清了。
- en: TDD helps by guiding us to a simple solution first and verifying that it works.
    This is like the rough path initially drawn on the map. Each time we enhance and
    refine the solution, we have tests to make sure that we don’t break anything.
    This is like checking to make sure we are still on the path.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: TDD通过引导我们首先找到一个简单的解决方案并验证其是否有效来帮助我们。这就像地图上最初画出的粗糙路径。每次我们增强和细化解决方案时，我们都有测试来确保我们没有破坏任何东西。这就像检查我们是否仍然在正确的路径上。
- en: Sometimes, an enhancement results in the need for a design change. This is like
    discovering a river blocking our way that didn’t appear on the initial map. We
    need to go around it by finding a different place to cross. The path changes,
    but the need to stay on the new path remains. This is where the tests help us.
    We have a new design that fixes an unforeseen problem, but we can still use the
    existing tests to validate the new design. We have confidence in the new design
    because it fixes the unexpected problem while still performing as expected.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，增强功能会导致需要设计变更。这就像发现一条在初始地图上没有出现的河流阻挡了我们的去路。我们需要找到一个不同的地方过河。路径改变了，但保持在新的路径上的需求仍然存在。这就是测试帮助我们的地方。我们有一个新的设计，它解决了未预见的问题，但我们仍然可以使用现有的测试来验证新的设计。我们对新的设计有信心，因为它在解决意外问题的同时，仍然按预期执行。
- en: TDD will help increase the usage of the logging library by other projects by
    providing clear and documented examples of how to use the library. This would
    be like producing videos of walking along the path so that future travelers will
    know what to expect and whether they want to follow the path before starting.
    Given a choice between our fully documented and easy-to-follow examples versus
    a similar library that claims to offer the same results but without proof, most
    people will prefer our library. Over time, our solution will get even better as
    we incorporate feedback from users.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: TDD通过提供如何使用库的清晰和文档化的示例来帮助其他项目增加日志库的使用。这就像制作沿着路径行走的视频，以便未来的旅行者知道他们可以期待什么，以及他们是否想在开始之前跟随这条路径。在完全文档化和易于遵循的示例与声称提供相同结果但没有证据的类似库之间做出选择时，大多数人会倾向于我们的库。随着时间的推移，我们的解决方案将变得更好，因为我们吸收了用户的反馈。
- en: Let’s start by thinking about the destination we want. This would be the ideal
    logging library for our intended customers. What would that look like? This will
    form the first rough path that we’ll start to refine.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从思考我们想要的目的地开始。这将是我们为预期客户设计的理想日志库。那会是什么样子？这将形成我们将开始细化的第一条粗糙路径。
- en: What would the ideal logging library look like?
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理想的日志库应该是什么样子？
- en: When designing software, it’s good to remember that you don’t have to design
    something completely new if common solutions already meet your needs exactly.
    A new design that’s different just for the sake of being different is just going
    to confuse people. A new design that’s different because the existing designs
    don’t quite work and the differences solve a real need is good. So before we begin
    dreaming up new logging designs, let’s first look at common ideas and see if we
    really need something new.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计软件时，记住这一点是好的：如果你已经有了满足需求的常见解决方案，就不必设计全新的东西。仅仅为了与众不同而设计的新方案只会让人困惑。如果新的设计因为现有设计不太适用，而差异解决了真正的需求，那么这是好的。所以在我们开始梦想新的日志设计之前，让我们先看看常见的想法，看看我们是否真的需要新的东西。
- en: 'To be completely thorough, we should also try to use what C++ already provides.
    Maybe that is enough and we don’t need a library. Let’s say we have the following
    code that tries to calculate the result of starting with 1 and doubling the value
    three times. The correct answer should be 8, but this code has a bug:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到彻底彻底，我们也应该尝试使用C++已经提供的功能。也许这就足够了，我们不需要一个库。假设我们有以下代码，尝试计算从1开始，将值翻倍三次的结果。正确答案应该是8，但这段代码有一个错误：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It prints a result of 16 instead of 8\. You probably already see the problem,
    but let’s imagine that the code is a lot more complicated, and the problem was
    not obvious. As the code is currently written, we’ll go through the loop four
    times instead of just three times.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 它打印的结果是 16 而不是 8。你可能已经看到了问题，但让我们想象一下，代码要复杂得多，问题并不明显。按照目前的代码编写方式，我们将通过循环四次而不是三次。
- en: 'We could add extra output such as this to help find the problem:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加额外的输出，如这个，以帮助找到问题：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Which, when run, produces the following output:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 运行后，将产生以下输出：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The results clearly show that the loop was run four times instead of just three.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 结果清楚地显示循环运行了四次，而不是仅仅三次。
- en: What we just did by adding extra text to the output that showed what was happening
    while running the code is the core of logging. Sure, we can add more features
    or do more. But the questions we need to ask are is this enough, and will this
    meet our needs?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在输出中添加额外文本来显示代码运行时的状态，所做的一切都是日志的核心。当然，我们可以添加更多功能或做更多。但我们需要问的问题是，这足够吗，这能满足我们的需求吗？
- en: 'Using `std::cout` is not enough and will not meet our needs for several reasons:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `std::cout` 是不够的，并且由于几个原因，它不能满足我们的需求：
- en: This simple example already used the console output to display the results.
    Normally, services should avoid sending text to the console because there won’t
    be anybody watching the screen for the results.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子已经使用了控制台输出来显示结果。通常，服务应该避免向控制台发送文本，因为没有人在屏幕上监视结果。
- en: Even if the console was the desired destination for the program output, we shouldn’t
    mix the extra logging output with the regular output.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 即使控制台是程序输出的期望目的地，我们也不应该将额外的日志输出与常规输出混合。
- en: We could send the logging output to a different stream, such as `std::cerr`,
    but this is not a full solution. Is the logging output always an error? Maybe
    it helps us identify that our program is actually running correctly and that the
    problem must be somewhere else.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将日志输出发送到不同的流，例如 `std::cerr`，但这并不是一个完整的解决方案。日志输出总是错误吗？也许它有助于我们确定程序实际上正在正确运行，而问题可能出在其他地方。
- en: Logging extra information is useful, but not all the time. Sending output directly
    to `std::cout` doesn’t give us a way to turn it off without changing the source
    code and rebuilding.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 记录额外信息是有用的，但并非总是如此。直接将输出发送到 `std::cout` 并不能给我们提供一种在不更改源代码和重新构建的情况下关闭输出的方法。
- en: And it would be nice if the logging output included extra information, such
    as the date and time. We could add this extra information, but then we’d have
    to add it every time we called `std::cout` to log information.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果日志输出包括额外的信息，例如日期和时间，那会很好。我们可以添加这些额外信息，但这样我们就必须每次调用 `std::cout` 来记录信息时都添加它。
- en: We’re making progress in the design because we’ve just eliminated one possible
    path. It’s always good to think about what you already have available before looking
    for a solution elsewhere.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在设计上取得了进展，因为我们刚刚消除了一条可能的路径。在寻找其他解决方案之前，总是考虑你已经拥有的东西总是好的。
- en: 'What if we put the logging into a function and called that function instead
    of using `std::cout` directly? The code might look like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将日志放入一个函数中并调用该函数而不是直接使用 `std::cout`，代码可能看起来像这样：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is a big improvement already. Even though the application is still using
    `std::cout` to display the result, we’re not adding to the noise with even more
    console output for logging. Now the logging output goes into a file. This also
    avoids mixing the logging with the regular results.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经是一个很大的改进。尽管应用程序仍然使用 `std::cout` 来显示结果，但我们并没有通过更多的控制台输出为日志添加噪音。现在日志输出进入了一个文件。这也避免了将日志与常规结果混合。
- en: We could even add a check inside the `log` function to see if the message should
    be logged or ignored. And having everything wrapped up in a function would also
    make it easy to add common information such as the date and time.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以在 `log` 函数内部添加一个检查，以查看消息是否应该被记录或忽略。并且将所有内容封装在函数中也会使添加诸如日期和时间等常见信息变得容易。
- en: Is the ideal solution just a function?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 理想解决方案仅仅是函数吗？
- en: 'Not really, because we also need to configure the logging. The code just shown
    was very simple and used a fixed log filename. And other features are missing
    that will improve the logging experience, for example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 并非如此，因为我们还需要配置日志。上面显示的代码非常简单，并使用了固定的日志文件名。而且还缺少其他将改善日志体验的功能，例如：
- en: The code currently opens and closes the log file for each message.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码目前为每条消息打开和关闭日志文件。
- en: There is an assumption that the message should go to a file. Maybe we want the
    message to go somewhere else or to a file, in addition to somewhere else.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设消息应该发送到文件。也许我们希望消息发送到其他地方或文件，以及其他地方。
- en: The message is a single text string.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息是一个单独的文本字符串。
- en: The code does not handle multiple threads trying to log messages at the same
    time.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码没有处理多个线程同时尝试记录消息的情况。
- en: The log function makes the main application wait until the log message has been
    written before the application can proceed.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志函数使主应用程序等待直到日志消息被写入，然后应用程序才能继续。
- en: We haven’t added anything specific to our desired customer, the micro-service
    developer, such as the ability to filter messages.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还没有为我们的目标客户，即微服务开发者，添加任何特定的功能，例如过滤消息的能力。
- en: What we have is a good start, confirming that there are enough requirements
    to justify the need for a library.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个很好的开始，这证实了有足够的必要来证明库的需求。
- en: Looking at other similar solutions is also a good idea, and there are many.
    One well-known logging library comes from the Boost C++ libraries and is called
    Boost.Log. This library allows you to start logging to the console in a simple
    way. And the library is extensible and fast. It’s also big. Even though it starts
    out simple, I’ve spent days reading through the documentation. One thing leads
    to another and before I knew it, I was learning about other technologies that
    the logging library uses.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑其他类似解决方案也是一个好主意，而且有很多。一个著名的日志库来自 Boost C++ 库，称为 Boost.Log。这个库允许你以简单的方式开始向控制台记录日志。而且这个库是可扩展的，速度快。但它也很大。尽管它一开始很简单，但我花了好几天时间阅读文档。一件事引出另一件事，在我意识到之前，我正在学习日志库使用的其他技术。
- en: While the Boost.Log library might start out simple, it can quickly require you
    to learn a lot more than expected. I’d like to create something that stays simple
    to use. Our ideal logging library should start out simple to use and hide any
    necessary complexity so that the user is not buried in options. We’re not trying
    to build a logging library that can do everything. We have a specific user in
    mind and will use TDD to focus on the needs of that micro-service developer.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Boost.Log 库可能一开始看起来很简单，但它很快就会要求你学习比预期多得多的内容。我希望创建一个使用起来仍然保持简单的东西。我们理想的日志库应该一开始就易于使用，并隐藏任何必要的复杂性，这样用户就不会被选项淹没。我们并不是试图构建一个可以做一切日志库。我们有一个特定的用户群体，并且将使用
    TDD 来关注那个微服务开发者的需求。
- en: The next section will begin the process of creating a logging library. Before
    we begin writing tests, we’ll need to create a new project, which the next section
    explains.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将开始创建日志库的过程。在我们开始编写测试之前，我们需要创建一个新的项目，下一节将解释这一点。
- en: Starting a project using TDD
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 TDD 开始一个项目
- en: 'Now that we’ve determined that a logging library is a good idea and is justified,
    it’s time to start a new project. Let’s start with the `log` function from the
    previous section and create a new project. The `log` function looks like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经确定日志库是一个好主意，并且是合理的，那么是时候开始一个新的项目了。让我们从上一节中的 `log` 函数开始，创建一个新的项目。`log`
    函数看起来是这样的：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Where will we put this `log` function, and what will the test project structure
    look like? In the earlier chapters, we tested the unit test library. This is the
    first time we’ll be using the unit test library as something outside the actual
    project we’re working on. The project structure will look like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个 `log` 函数放在哪里，测试项目的结构会是什么样子？在早期章节中，我们测试了单元测试库。这是我们第一次将单元测试库作为我们正在工作的实际项目之外的东西使用。项目结构将如下所示：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The new structure uses a containing folder called the `MereMemo` project root
    folder. Like the unit test library is called MereTDD, I decided to continue the
    theme with the word mere and call the logging library MereMemo. Other choices
    were already in use, and the word memo represents the idea of writing something
    down to remember it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 新的结构使用一个名为 `MereMemo` 的包含文件夹作为项目根文件夹。就像单元测试库被称为 MereTDD 一样，我决定继续使用 mere 这个词，并将日志库命名为
    MereMemo。其他选择已经被使用，而 memo 这个词代表写下某事以记住它的想法。
- en: You can see that inside the root folder is a folder called `MereTDD` with only
    the `Test.h` file. We no longer need to include the tests for the unit test library.
    We’re going to use the unit test library now instead of developing it further.
    If we ever do need to make changes to the unit test library, then we’ll go back
    to the previous project that contains the tests for the unit test library.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，在根文件夹内部有一个名为 `MereTDD` 的文件夹，里面只有一个 `Test.h` 文件。我们不再需要包含单元测试库的测试。我们现在将使用单元测试库，而不是进一步开发它。如果我们以后需要修改单元测试库，那么我们将回到包含单元测试库测试的先前项目。
- en: The project root folder gives us a place to put both the unit test library header
    file in its own folder and the logging library also in its own folder.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 项目根文件夹为我们提供了一个放置单元测试库头文件（在它自己的文件夹中）和日志库（也在它自己的文件夹中）的地方。
- en: Inside the `MereMemo` folder is a file called `Log.h`. This is where we’ll put
    the `log` function. And there is also a folder called `tests`, which will contain
    the unit tests for the logging library. Inside the `tests` folder is where we
    will find the `main.cpp` file and all the other unit test files. For now, there
    is just one unit test file called `Construction.cpp`, which is empty and doesn’t
    contain any tests yet.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MereMemo` 文件夹内部有一个名为 `Log.h` 的文件。这就是我们将放置 `log` 函数的地方。还有一个名为 `tests` 的文件夹，它将包含日志库的单元测试。在
    `tests` 文件夹内部，我们将找到 `main.cpp` 文件以及所有其他单元测试文件。目前，只有一个名为 `Construction.cpp` 的单元测试文件，它是空的，还没有包含任何测试。
- en: I should also mention that you don’t need to put the `MereTDD` folder inside
    your project root folder like this. You can put it anywhere you want. This is
    like installing the unit test library on your computer. Since the unit test library
    is really just a single header file, there isn’t anything that needs to be installed.
    The header file just needs to exist somewhere on your computer in a convenient
    place so that you know the path. We’ll need to add the path to the project settings
    in your development tools so that the compiler knows where to find `Test.h`. I’ll
    explain more about this step in just a moment.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我还应该提到，你不需要像这样将 `MereTDD` 文件夹放在你的项目根文件夹内。你可以将其放在任何你想要的位置。这就像在你的计算机上安装单元测试库一样。由于单元测试库实际上只是一个单独的头文件，所以没有需要安装的内容。只需要在计算机上的一个方便位置创建头文件，以便你知道路径。我们需要在开发工具的项目设置中添加路径，以便编译器知道在哪里找到
    `Test.h`。我将在稍后解释这一步骤。
- en: 'We need the usual `include` guards in `Log.h`, and after putting the `log`
    function inside, then `Log.h` should look like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 `Log.h` 中使用通常的 `include` 守卫，并在将 `log` 函数放入其中之后，`Log.h` 应该看起来像这样：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `log` function now needs to be inline since it is in its own header file
    and could be included multiple times in a project.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的 `log` 函数需要内联，因为它位于自己的头文件中，并且在项目中可能会被多次包含。
- en: 'We can mostly copy the contents of `main.cpp` from the unit test library project
    and use it to run the unit tests for the logging library project too. We need
    to make a minor change to how we include `Test.h`, though. The `main.cpp` file
    should look like the following example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以主要复制 `main.cpp` 文件的内容，从单元测试库项目使用它来运行日志库项目的单元测试。不过，我们需要对包含 `Test.h` 的方式做一点小的修改。`main.cpp`
    文件应该看起来像以下示例：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can see that we now include `Test.h` using angle brackets instead of quotation
    marks. This is because `Test.h` is not directly part of the logging library; it’s
    now a file being included from another project. The best way to include files
    from other projects or libraries is to keep them separate in their own folders
    and change your project settings in your development tools to tell the compiler
    where to find the files needed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们现在使用尖括号而不是引号来包含 `Test.h`。这是因为 `Test.h` 并不是日志库的直接部分；它现在是从另一个项目中包含的文件。从其他项目或库中包含文件的最佳方式是将它们保存在各自的文件夹中，并在你的开发工具中更改项目设置，以告诉编译器查找所需文件的路径。
- en: 'For my development work, I’m using the CodeLite **integrated development environment**
    (**IDE**), and the project settings are available by right-clicking on the project
    and choosing the **Settings** menu option. Inside the pop-up dialog, there is
    a section for the compiler settings. And on the compiler settings page, there’s
    an option to specify the include paths. CodeLight has some predefined paths that
    can be used to identify things such as the path to the current project. I set
    the include paths to look like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我的开发工作，我正在使用CodeLite **集成开发环境**（**IDE**），可以通过在项目上右键单击并选择**设置**菜单选项来访问项目设置。在弹出的对话框中，有一个用于编译器设置的选项。在编译器设置页面上，有一个选项可以指定包含路径。CodeLite有一些预定义的路径，可以用来识别诸如当前项目路径之类的信息。我将包含路径设置为如下所示：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The include paths are separated by semicolons. You can see there are two paths
    specified. The first is a single dot, which means to look for included files in
    the current folder. This is how the project-specific include files that use quotation
    marks are found. But I also added a path with the special syntax using the dollar
    sign and parentheses, which tells CodeLite to look in the project root folder
    for additional include files. What actually happens is that CodeLite interprets
    the paths, including its special predefined paths, such as ProjectPath, and sends
    the real filesystem paths to the compiler. The compiler doesn’t know anything
    about `ProjectPath`, parentheses, or dollar signs.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 包含路径由分号分隔。您可以看到指定了两个路径。第一个是一个点，表示在当前文件夹中查找包含的文件。这就是使用引号的项目特定包含文件被找到的方式。但我还添加了一个使用美元符号和括号的特殊语法路径，这告诉CodeLite在项目根目录中查找额外的包含文件。实际上发生的情况是，CodeLite解释路径，包括其特殊预定义路径，如ProjectPath，并将实际的文件系统路径发送给编译器。编译器对`ProjectPath`、括号或美元符号一无所知。
- en: If you decide to place the unit test library somewhere else on your computer,
    you will need to add the full path instead of using ProjectPath. And if you’re
    using a different IDE instead of CodeLite, then the process will be similar. All
    IDEs have their own way of specifying the include paths to be used by the compiler.
    The settings are almost always in a settings dialog that you can open from the
    project.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定将单元测试库放在您的计算机上的其他位置，您需要添加完整路径而不是使用ProjectPath。如果您正在使用除CodeLite之外的IDE，则过程将类似。所有IDE都有自己指定编译器使用包含路径的方式。设置通常总是在一个可以从项目打开的设置对话框中。
- en: With all this setup and project configuration work done, it’s time to start
    writing some tests, beginning in the next section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有这些设置和项目配置工作后，是时候开始编写一些测试了，下一节将开始。
- en: Logging and confirming the first message
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录和确认第一条消息
- en: Now that we have a project ready, we can begin writing some tests and designing
    the logging library. We already created an empty unit tests file called `Construction.cpp`.
    I like to start with some simple tests that ensure classes can be constructed.
    We can also use this to make sure that simple functions can be called. This section
    will focus on creating a single test to log our first message and confirm that
    it all works.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了一个项目，我们可以开始编写一些测试，并设计日志库。我们已创建了一个名为`Construction.cpp`的空单元测试文件。我喜欢从一些简单的测试开始，确保类可以被构造。我们还可以使用它来确保简单函数可以被调用。本节将专注于创建一个测试来记录我们的第一条消息并确认一切正常。
- en: 'We already have the `log` function from earlier, which opens a file and appends
    a message. Let’s add a test that calls `log` and writes something. The following
    example shows how to edit `Construction.cpp` to add the first test:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了之前的`log`函数，它打开一个文件并追加一条消息。让我们添加一个调用`log`并写入内容的测试。以下示例显示了如何编辑`Construction.cpp`以添加第一个测试：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Because we’re testing the logging library, we need to include `Log.h`, which
    is found in the parent directory where `Construction.cpp` is located. We use quotation
    marks for `Log.h` because it’s in the same project. Later, if you want to use
    the logging library for your own project, you’ll just need to put `Log.h` in a
    known location and include it with angle brackets, just like how we now include
    `Test.h` with angle brackets.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在测试日志库，我们需要包含`Log.h`，它位于`Construction.cpp`所在的父目录中。我们使用引号来表示`Log.h`，因为它位于同一项目中。稍后，如果您想在自己的项目中使用日志库，只需将`Log.h`放在一个已知位置，并用尖括号包含它，就像我们现在用尖括号包含`Test.h`一样。
- en: 'The single test just calls the `log` function. This really just reorganizes
    the code we started in this chapter by creating a real project and using tests
    instead of directly writing code in `main`. Building and running the project shows
    the following output to the console:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 单个测试只是调用 `log` 函数。这实际上只是通过创建一个真实的项目并使用测试来代替直接在 `main` 中编写代码，重新组织了我们在这个章节开始时的代码。构建和运行项目向控制台显示了以下输出：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The single test ran and passed. But it will pass no matter what as long as it
    doesn’t throw an exception. That’s because we don’t have any confirmations in
    the test. The real output that we’re interested in doesn’t even appear in the
    console. Instead, it all goes to the log file called `application.log`. When I
    run the project from the CodeLite IDE, it shows a similar output. But it seems
    that CodeLite runs the code from a temporary folder. Other IDEs also do something
    similar, and it can be hard sometimes to keep up with the temporary locations.
    So instead, you might want to use your IDE to build the project and then open
    a separate terminal window to run the test application manually. This way, you
    are in full control over where the application is run and have a window open that
    you can use to examine the log file that gets created.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 单个测试运行并通过了。但是，只要它不抛出异常，它就会通过。这是因为测试中没有确认。我们真正感兴趣的输出甚至没有出现在控制台上。相反，它全部都进入了名为
    `application.log` 的日志文件。当我从 CodeLite IDE 运行项目时，它显示了类似的输出。但似乎 CodeLite 从一个临时文件夹中运行代码。其他
    IDE 也做类似的事情，有时很难跟上临时位置。因此，你可能想使用你的 IDE 来构建项目，然后打开一个单独的终端窗口来手动运行测试应用程序。这样，你就可以完全控制应用程序的运行位置，并打开一个窗口来检查创建的日志文件。
- en: 'My application gets built in a folder called `Debug`, and the contents of that
    folder after building contain the executable file and the object files that are
    used to create the final executable. There is no file called `application.log`
    until the test application project is run. Once the project is run, the `application.log`
    file can be printed to the console like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我的程序在名为 `Debug` 的文件夹中构建，构建后该文件夹的内容包含可执行文件和用于创建最终可执行文件的对象文件。在运行测试应用程序项目之前，没有名为
    `application.log` 的文件。一旦项目运行，`application.log` 文件可以像这样打印到控制台：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'At the `$` prompt, the `cat` command is used to display the contents of the
    `application.log` file, which contains a single line with a simple message. If
    we run the project again, then we’ll append new content to the same log file,
    which looks like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `$` 提示符下，使用 `cat` 命令来显示 `application.log` 文件的内容，该文件包含一行简单的消息。如果我们再次运行项目，那么我们将新内容追加到同一个日志文件中，看起来像这样：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After running the application twice, we get two messages in the log file. Both
    messages are identical, which is going to make it hard to determine whether anything
    new was added to the log file or not. We need a way to create unique messages
    and then a way to verify that a particular message is found in the log file. This
    will let us add a confirmation to the test to verify that a message was logged
    without needing to manually examine the log file each time the test is run.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行应用程序两次之后，我们在日志文件中得到了两条消息。这两条消息完全相同，这将使得确定日志文件中是否添加了新内容变得困难。我们需要一种方法来创建唯一的消息，然后是验证特定消息是否出现在日志文件中的方法。这将使我们能够在测试中添加一个确认，以验证消息是否被记录，而无需每次运行测试时都手动检查日志文件。
- en: Other tests might need the ability to generate unique messages and then verify
    the contents of the log file, and we might want to put these other tests in different
    `test.cpp` files. So that means we should add a helper file to write the required
    code so that it can be shared with other tests in other files.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 其他测试可能需要生成唯一消息并验证日志文件内容的能力，我们可能希望将这些其他测试放在不同的 `test.cpp` 文件中。这意味着我们应该添加一个辅助文件来编写所需的代码，以便它可以与其他文件中的其他测试共享。
- en: A common name for a helper file like this is `Util`. It seems like every project
    has `Util.h` and `Util.cpp`, and this is why. It’s a good place to put useful
    code that can be shared throughout a project.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种辅助文件，一个常见的名字是 `Util`。似乎每个项目都有 `Util.h` 和 `Util.cpp`，原因就在于此。这是一个放置可以在整个项目中共享的有用代码的好地方。
- en: 'What would the test look like if we had these helper functions? Change `Construction.cpp`
    to look like the following screenshot:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有这些辅助函数，测试看起来会是什么样子？将 `Construction.cpp` 改成以下截图的样子：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We need to include `Util.h`, and then we can make the message unique by appending
    a random string we get from calling `randomString`. The full message is stored
    in a variable so that we can use it when logging and verifying. After logging
    the message, we call the other new function, `isTextInFile`, to verify.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要包含`Util.h`，然后我们可以通过附加从调用`randomString`获得的随机字符串来使消息唯一。完整的消息存储在一个变量中，这样我们就可以在记录和验证时使用它。记录消息后，我们调用另一个新函数`isTextInFile`来验证。
- en: One problem with this test is the need to specify the log filename. Right now,
    the log filename is hardcoded in the `log` function. We’re not going to fix the
    log filename problem right away. With TDD, we take things one step at a time.
    If you have an issue tracking system, adding the log filename problem to the tracking
    system will make sure it isn’t forgotten.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试的一个问题是需要指定日志文件名。目前，日志文件名硬编码在`log`函数中。我们不会立即修复日志文件名的问题。在使用TDD（测试驱动开发）时，我们一步一步来。如果你有一个问题跟踪系统，将日志文件名问题添加到跟踪系统中可以确保它不会被遗忘。
- en: 'Now that we have an idea of how the utility functions will be used, let’s add
    both utility files to the project in the `tests` folder and add a couple of function
    declarations in `Util.h` like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了实用函数的使用方式，让我们将这两个实用文件添加到`tests`文件夹中的项目中，并在`Util.h`中添加一些函数声明，如下所示：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first function will let us generate a random string that we can use to make
    the messages unique. There’s always a possibility that we’ll get duplicate strings,
    which could cause us to think that a log file contains a new log message when,
    in fact, we see a previous message that used the same random string. In practice,
    this shouldn’t be a problem because we won’t just be logging random strings. We’ll
    be adding random strings to other text that will be unique for each test.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数将允许我们生成一个随机字符串，我们可以用它来使消息唯一。总有可能得到重复的字符串，这可能导致我们错误地认为日志文件包含新的日志消息，而实际上我们看到的是使用了相同随机字符串的先前消息。在实践中，这不应该是一个问题，因为我们不会仅仅记录随机字符串。我们将随机字符串添加到其他文本中，这样每个测试都将具有唯一性。
- en: When I was originally developing this code, I used the same text for many of
    the tests. The random number added to the end makes each message unique. Or, at
    least, I didn’t notice any duplicate messages. The tests all worked great until
    I got to [*Chapter 15*](B18567_15.xhtml#_idTextAnchor149), *How to Test With Multiple
    Threads*, and added 150 new messages in a single test. The problem wasn’t due
    to multiple threads. The problem was always a possibility and didn’t appear until
    the extra messages increased the probability of duplicate messages. We’re going
    to avoid the problem by using unique base message text for each test.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我最初开发这段代码时，我在许多测试中使用了相同的文本。添加到末尾的随机数使每个消息都是唯一的。或者至少，我没有注意到任何重复的消息。测试都进行得很顺利，直到我到达[*第15章*](B18567_15.xhtml#_idTextAnchor149)，*如何使用多线程进行测试*，并在一个测试中添加了150条新消息。问题并不是由于多线程引起的。问题始终存在，直到额外的消息增加了重复消息的概率才出现。我们将通过为每个测试使用唯一的基消息文本来避免这个问题。
- en: The second function will let us confirm that some text actually exists in a
    file, and we can use this to verify that a particular message exists in the log
    file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数将允许我们确认某些文本确实存在于文件中，我们可以使用这个来验证特定消息是否存在于日志文件中。
- en: 'I like to make functions like this static methods in a struct. This helps to
    make sure that the implementations match the declarations in the header file.
    The implementation goes in `Util.cpp` like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢在结构体中将这样的函数定义为静态方法。这有助于确保实现与头文件中的声明相匹配。实现部分放在`Util.cpp`中，如下所示：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The implementations don’t do anything other than return for now. But this lets
    us build and verify that the test fails.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 实现目前除了返回之外不做任何事情。但这让我们能够构建和验证测试失败。
- en: Why would we want to make sure that the test fails?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么要确保测试失败呢？
- en: Because it helps to validate a passing result once we actually implement the
    functions. A failure ensures that the test is written correctly and can catch
    a failure. Once we implement the helper functions, then the test will pass, and
    we can be sure that the pass is coming from the helper implementation and not
    just a test that will always pass anyway.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这有助于在我们实际实现函数后验证通过的结果。失败确保测试被正确编写并且可以捕获失败。一旦我们实现了辅助函数，测试就会通过，我们可以确信通过是来自辅助实现，而不是一个无论如何都会通过的测试。
- en: 'The following screenshot shows the expected failure when running the project:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了运行项目时预期的失败情况：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Even though a manual check of the `application.log` file shows that the expected
    message did get written to the end of the log file:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管手动检查`application.log`文件显示预期的消息确实被写入日志文件的末尾：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s fix the `randomString` function now to ensure we can get unique messages
    logged. We’ll need to include `chrono` to be able to set up a random number generator
    with a seed based on the current time. The following code snippet shows the relevant
    code in `Util.cpp`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们修复`randomString`函数，以确保我们可以记录独特的消息。我们需要包含`chrono`来能够设置一个基于当前时间的随机数生成器。以下代码片段显示了`Util.cpp`中的相关代码：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Because this uses random numbers, you’ll get different results each time. The
    test still fails, but after running the test application a couple more times,
    my `application.log` file looks like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这使用了随机数，所以每次都会得到不同的结果。测试仍然失败，但运行测试应用程序几次之后，我的`application.log`文件看起来像这样：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The message is now somewhat unique, with a slight chance of duplicate log messages.
    That’s good enough for now, and we can move on to getting the verification function
    working. We’ve been keeping the log file between test application runs, so the
    new message is appended each time. A real test run to verify your code should
    start with a clean environment with no leftover files from a previous run.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 消息现在相对独特，有轻微的重复日志消息的可能性。这对目前来说已经足够好，我们可以继续进行验证函数的工作。我们一直在测试应用程序运行之间保留日志文件，所以每次新的消息都会被附加。为了验证你的代码，一个真正的测试运行应该从一个干净的环境开始，没有任何来自之前运行的遗留文件。
- en: I’m showing the code for both the random string and the verification without
    fully explaining everything. That’s because random numbers and file searches are
    needed but are not completely in scope for explaining TDD. It’s easy to get off
    topic by explaining all the details about random numbers or even searching text
    files for matching strings.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在展示的是随机字符串和验证的代码，但没有完全解释一切。这是因为随机数和文件搜索是需要的，但它们并不完全在解释TDD的范围内。解释随机数的所有细节或甚至搜索文本文件以匹配字符串很容易跑题。
- en: 'The implementation of the `isTextInFile` function looks like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`isTextInFile`函数的实现如下：'
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: All this function does is open the log file, read each line, and try to find
    the text. If the text is found, then it returns true, and the function returns
    false if it cannot find the text in any line.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数所做的只是打开日志文件，读取每一行，并尝试找到文本。如果找到文本，则返回true，如果在任何一行中找不到文本，则函数返回false。
- en: 'Building and running the project now shows the test passes like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和运行项目现在显示测试通过如下：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We now have a way to write log messages to a file and confirm that the message
    appears in the file. The code could be more efficient because, right now, it searches
    through the entire log file starting at the beginning when looking for the text.
    But our goal is not to write the best log file searching tool. The test log files
    will not likely grow too big, so a simple approach to searching should work well.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了一种将日志消息写入文件并确认消息出现在文件中的方法。代码可以更高效，因为目前它在查找文本时从日志文件的开始处搜索整个文件。但我们的目标不是编写最好的日志文件搜索工具。测试日志文件不太可能变得很大，所以简单的搜索方法应该可以很好地工作。
- en: A log needs more than just messages to be useful. The following section will
    add timestamps to the messages, adding the minimum set of features needed for
    a logging library.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 日志需要不仅仅是消息才能变得有用。下一节将向消息添加时间戳，添加日志库所需的最小功能集。
- en: Adding timestamps
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加时间戳
- en: A single log file might provide some value with just messages, but recording
    the date and time of each log message makes it much more valuable. And once we
    start working with multiple log files from different micro-services, the need
    to order the log messages by time becomes critical.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 单个日志文件仅通过消息可能提供一些价值，但记录每条日志消息的日期和时间会使它更有价值。一旦我们开始使用来自不同微服务的多个日志文件，按时间顺序排列日志消息的需求变得至关重要。
- en: It’s fairly simple to add timestamps. All we need to do is get the current time,
    format it into a standard timestamp that eliminates misunderstanding between the
    year, month, and day, and then send the timestamp to the log along with the message.
    The caller doesn’t need to do anything.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 添加时间戳相当简单。我们只需要获取当前时间，将其格式化为一个标准的、消除年份、月份和日期之间误解的时间戳，然后将时间戳连同消息一起发送到日志中。调用者不需要做任何事情。
- en: It’s also difficult to test directly to make sure it works. We can manually
    open the log file and see the timestamps; that will be enough for now. We’re not
    going to add any new tests for the timestamps.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 直接测试以确保其工作也是一项困难的工作。我们可以手动打开日志文件并查看时间戳；现在这已经足够了。我们不会为时间戳添加任何新的测试。
- en: 'All we need to do is modify `Log.h` so it looks like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的只是修改`Log.h`，使其看起来像这样：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We need to include some new system headers, `chrono`, `ctime`, `iomanip`, and
    `string`. A better way to format dates and times involves a new system header
    file called `format`. Unfortunately, even though `format` is part of C++20, it’s
    still not widely implemented by most standard libraries. So this code uses a slightly
    older way to do the formatting that uses the standard `put_time` function.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要包含一些新的系统头文件，`chrono`、`ctime`、`iomanip`和`string`。一种更好的格式化日期和时间的办法是使用一个新的系统头文件`format`。不幸的是，尽管`format`是C++20的一部分，但它仍然没有被大多数标准库广泛实现。因此，这段代码使用了一种稍微旧一点的格式化方法，该方法使用了标准的`put_time`函数。
- en: We start by getting the system time. Then we need to convert the time to an
    older time format called `time_t`. Even though I often only mention time, I usually
    mean both time and date.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取系统时间。然后我们需要将时间转换为一种较旧的格式，称为`time_t`。尽管我经常只提到时间，但我通常指的是时间和日期。
- en: We want the timestamps to be fairly precise and just logging the time down to
    the seconds is not nearly precise enough. So, we need to cast the time to milliseconds
    and divide by 1,000 to get the fraction of a second we need.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望时间戳尽可能精确，仅仅记录到秒并不足够精确。因此，我们需要将时间转换为毫秒，然后除以1,000以得到所需的秒分数。
- en: The function continues to open the log file as before. But now, it calls `put_time`
    with the `gmtime`, we can ensure that logs generated on machines in different
    time zones will be ordered correctly because all the times refer to the same time
    zone.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 函数继续以前的方式打开日志文件。但现在，它使用`gmtime`调用`put_time`，我们可以确保在不同时区的机器上生成的日志将按正确顺序排列，因为所有时间都指的是同一个时区。
- en: If you’re using the Visual Studio tools from Microsoft, you’ll likely get an
    error with the use of `gmtime`. I mentioned this is an older solution, and some
    compilers will complain that `gmtime` could be unsafe. The recommended replacement
    is `gmtime_s`, but this replacement function requires some extra checks in the
    code to see if it is available. Other compilers might also complain about `gmtime`
    and normally tell you in the error message what needs to be done to fix the problem.
    The error message from Visual Studio says that if we want to use `gmtime`, we
    need to define `_CRT_SECURE_NO_WARNINGS` in the project settings under C++ preprocessor
    definitions.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是微软的Visual Studio工具，你可能会在使用`gmtime`时遇到错误。我提到这是一个较旧的方法，一些编译器可能会抱怨`gmtime`可能是不安全的。推荐的替代方案是`gmtime_s`，但这个替代函数需要在代码中进行一些额外的检查以查看它是否可用。其他编译器也可能对`gmtime`提出抱怨，通常会在错误信息中告诉你如何修复问题。Visual
    Studio的错误信息表示，如果我们想使用`gmtime`，我们需要在项目的C++预处理器定义下定义`_CRT_SECURE_NO_WARNINGS`。
- en: The strange formatting involving percent signs and uppercase and lowercase letters
    tells `put_time` how to format the various elements of the date and time. We want
    to format the date and time according to the **ISO-8601** standard. The most important
    part is that the standard says that the year comes first with four digits followed
    by the two-digit month, and then the two-digit day. Dashes are allowed between
    the numbers.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 包含百分号和大小写字母的奇怪格式化方式告诉`put_time`如何格式化日期和时间的各个元素。我们希望按照**ISO-8601**标准格式化日期和时间。最重要的是，该标准规定年份首先出现，后面跟着四位数字，然后是两位数字的月份，最后是两位数字的日期。数字之间允许使用连字符。
- en: Without a standard like this, a date such as 10-07-12 could mean different dates
    to different people. Is that October 7, 2012? Or July 10, 2012? Or July 12, 2010?
    Or December 7, 2010? About the only thing we can all agree on is that the year
    is probably not 2007\. Even using a four-digit year still leaves room for the
    month and day to get mixed up. By using ISO-8601, we all agree that the year is
    first, then the month, and then the day.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这样的标准，像10-07-12这样的日期对不同的人可能意味着不同的日期。那是2012年10月7日？还是7月10日？或者是2010年7月12日？或者是2010年12月7日？我们唯一能达成共识的是，年份可能不是2007年。即使使用四位数的年份，月份和日期仍然可能混淆。通过使用ISO-8601，我们所有人都同意年份首先出现，然后是月份，然后是日期。
- en: Next in the standard is the capital letter T. All this does is separate the
    date from the time portion. The time comes next and is much less confusing because
    we all agree that the hour comes first, then the minutes, and then the seconds.
    We put a dot after the seconds before displaying the fractional milliseconds.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准中接下来是大写字母T。这仅仅是将日期部分与时间部分分开。时间接下来，因为我们都同意小时先来，然后是分钟，然后是秒。我们在显示分数毫秒之前在秒后放一个点。
- en: 'After making these changes, deleting the old log file, and building and running
    the project a few times, we can see that the log file looks something like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这些更改、删除旧的日志文件、构建和运行项目几次之后，我们可以看到日志文件看起来像这样：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The only thing we’re not doing is including specific text in the timestamp that
    shows the time is UTC. We could add specific time zone information, but this should
    not be needed.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一没有做的是在时间戳中包含特定文本来显示时间是UTC。我们可以添加特定时区信息，但这可能不是必需的。
- en: We have timestamps and can log a single string of text. The next section will
    let us log more than a single piece of text.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有时间戳并且可以记录一段文本。下一节将允许我们记录多于一段文本。
- en: Constructing log messages with streams
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用流构建日志消息
- en: Having a `log` function that accepts a single string to display is not the easiest
    function to use. Sometimes, we might want to log more information. We might also
    want to log different types and not just strings. This is where we can use the
    powerful streaming ability used extensively in C++.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个接受单个字符串以显示的`log`函数并不是最容易使用的函数。有时，我们可能想要记录更多信息。我们也可能想要记录不同类型的信息，而不仅仅是字符串。这就是我们可以使用C++中广泛使用的强大流式传输能力的地方。
- en: We’re already using a stream inside the `log` function. All we need to do to
    give the full power of the stream to the caller is to stop sending the single
    message text to the stream inside the `log` function and instead return the stream
    itself to the caller. The caller will then be free to stream whatever is needed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`log`函数内部使用了一个流。我们只需要停止将单个消息文本发送到`log`函数内部的流，并返回流本身给调用者。然后调用者就可以自由地流式传输所需的内容。
- en: 'We can see what this will look like by first modifying the test; we have to
    use the `log` function as if it returned a stream. The modified test looks like
    this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过首先修改测试来看到这将是什么样子；我们必须像它返回一个流一样使用`log`函数。修改后的测试看起来像这样：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We now call the `log` function without any arguments. Instead of passing the
    `message` variable as an argument, we use the `log` function’s return value as
    a stream and directly send the message along with another piece of text to the
    stream.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们调用`log`函数而不带任何参数。我们不是将`message`变量作为参数传递，而是使用`log`函数的返回值作为流，并将消息与另一段文本直接发送到流中。
- en: Notice how we need to make sure to add a space before the second piece of text.
    This is to prevent the text from joining up with the message that comes before
    it. As with any stream, it’s up to the caller to ensure the text doesn’t run together.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何在第二段文本前添加一个空格。这是为了防止文本与前一条消息连接在一起。就像任何流一样，确保文本不会连在一起的责任在于调用者。
- en: There is a slight problem we need to work out. Previously, when we were handling
    the message inside the `log` function, we were able to add a newline to the end
    of the message. We still want log messages to appear on their own lines in the
    log file. But we also don’t want the caller to always have to remember to add
    a newline.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要解决一个轻微的问题。之前，当我们处理`log`函数内部的消息时，我们能够向消息末尾添加换行符。我们仍然希望日志消息在日志文件中单独一行显示。但我们也不希望调用者总是需要记住添加换行符。
- en: One of our goals is to make this logging library easy to use. Requiring each
    call to `log` to include a newline at the end makes the use tedious. So instead,
    a simple temporary solution is for the `log` function to add a newline to the
    *beginning* of each log message.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标之一是使这个日志库易于使用。要求每次调用`log`时在末尾包含换行符使得使用变得繁琐。所以，一个简单的临时解决方案是让`log`函数在每条日志消息的开始处添加一个换行符。
- en: This has a strange side effect. The very first line in a log file will be empty.
    And the last line will not have a newline. But the overall effect is still that
    each log message will appear on its own line. And that’s the behavior that we
    want to keep. This temporary solution will be fixed properly in the following
    chapter.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个奇怪的副作用。日志文件的第一行将是空的。最后一行将没有换行符。但整体效果仍然是每个日志消息都会出现在自己的行上。这正是我们想要保持的行为。这个临时解决方案将在下一章中得到适当的修复。
- en: 'The change to the `log` function in `Log.h` is also simple and looks like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`Log.h` 中 `log` 函数的改变也很简单，看起来像这样：'
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Instead of returning `void`, this new version returns `std::fstream`. You can
    see that the first thing that gets sent to the log file stream is `std::endl`,
    which ensures each log message gets its own line in the log file. The entire idea
    of returning `std::fstream` is a temporary solution that will be enhanced in the
    next chapter.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 与返回 `void` 不同，这个新版本返回 `std::fstream`。你可以看到首先被发送到日志文件流的是 `std::endl`，这确保了每个日志消息在日志文件中都有其自己的行。返回
    `std::fstream` 的整个想法是一个临时解决方案，将在下一章中得到增强。
- en: Then, instead of sending a message to the stream, the function returns the stream
    after sending the timestamp. This lets the caller send whatever values are needed
    to the stream. An empty space is added after the timestamp to make sure that the
    timestamp doesn’t run into additional text that gets streamed by the caller.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在发送时间戳之后，函数返回流而不是发送消息。这使得调用者可以将所需的任何值发送到流中。在时间戳之后添加一个空格，以确保时间戳不会遇到调用者通过流传输的额外文本。
- en: An interesting thing to consider about the return type is what will happen to
    fstream once the function returns. We construct fstream inside the `log` function
    and then return the stream by value. Returning a stream by value was not possible
    before C++11, and we can do this only because we now have the ability to *move*
    the stream out of the `log` function. The code doesn’t need to do anything special
    to enable the move. It just works with modern C++. We will run into the move issue
    again in the next chapter when we fix the temporary solution with newlines.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 关于返回类型的一个有趣的问题是函数返回后 fstream 会发生什么。我们在 `log` 函数内部构造 fstream，然后通过值返回流。在 C++11
    之前，通过值返回流是不可能的，我们之所以能够这样做，是因为我们现在有了将流从 `log` 函数中 *移动* 出来的能力。代码不需要做任何特殊的事情来启用移动。它只是与现代
    C++ 一起工作。我们将在下一章中再次遇到移动问题，那时我们将用新的换行符修复临时解决方案。
- en: Following TDD to design software encourages working solutions that get enhanced
    instead of trying to come up with a perfect design in the beginning. I can tell
    you from experience that it’s not possible to think of every little design issue
    ahead of time. Adjustments need to be made along the way, which tends to turn
    a perfect design into something less than it was. I like TDD because designs start
    with the end user in mind and the enhancements work around small issues such as
    our newline problem. The end result is better than what it was in the beginning.
    Following TDD lets the design stay true to the things that matter the most while
    being flexible where needed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循 TDD（测试驱动开发）来设计软件鼓励工作解决方案得到增强，而不是一开始就试图设计出一个完美的设计。我可以从经验中告诉你，事先考虑每一个小设计问题是不可行的。需要沿途进行调整，这往往会使一个完美的设计变得不如最初。我喜欢
    TDD，因为设计从最终用户的角度开始，增强功能围绕我们的换行问题等小问题进行。最终结果是比最初更好的。遵循 TDD 让设计保持对最重要的事物的真实，同时在需要的地方保持灵活性。
- en: 'We still need to consider what happens to the stream once it leaves the `log`
    function. The test code is not storing the stream in a local variable, so it will
    get destroyed. But it will only get destroyed at the end of the expression in
    which it was created. Let’s say we call `log`, as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要考虑一旦流离开 `log` 函数后会发生什么。测试代码没有将流存储在局部变量中，因此它将被销毁。但它只会在创建它的表达式的末尾被销毁。让我们假设我们按照以下方式调用
    `log`：
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `std::fstream` that gets returned from the `log` function remains valid
    until the semicolon at the end of the line. The lifetime of the stream needs to
    remain valid so that we can continue to use it to send the message and the additional
    text.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `log` 函数返回的 `std::fstream` 在行尾的分号之前保持有效。流的生存期需要保持有效，这样我们就可以继续使用它来发送消息和附加文本。
- en: 'Building and running the project a few times shows that the single test passes
    each time. And the log file contains the extra text, as displayed in the following
    screenshot:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 几次构建和运行项目显示每次只有一个测试通过。日志文件包含了额外的文本，如下面的截图所示：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can see the empty line at the beginning of the file. But each message is
    still on its own line, and the caller can now log other information. Let’s create
    a new test to make sure. The new test will look like the following example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到文件开头的空行。但每个消息仍然单独一行，调用者现在可以记录其他信息。让我们创建一个新的测试来确保这一点。新的测试将类似于以下示例：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This new test logs a double literal value directly and even logs the result
    of calling the `std::quoted` function. The `quoted` function just puts quotation
    marks around what is given to it. Even though the text “in quotes” already looks
    like it has quotation marks, remember that these marks are for the compiler to
    know when the text begins and ends. The quotation marks in the source code are
    not actually part of the text, just like how the quotation marks from the other
    string literals such as “double=” don’t appear in the log message. But because
    we call `std::quoted`, we will get quotation marks in the output.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的测试直接记录了双精度字面值，甚至记录了调用`std::quoted`函数的结果。`quoted`函数只是在其提供的文本周围加上引号。即使“引号中的文本”看起来已经有了引号，也要记住这些标记是为了让编译器知道文本的开始和结束。源代码中的引号实际上不是文本的一部分，就像其他字符串字面值（如“double=”）的引号不会出现在日志消息中一样。但因为我们调用了`std::quoted`，所以输出中会有引号。
- en: The interesting thing about `std::quoted` is that the return value can really
    only be used to send to a stream. The actual type is undefined by the C++ standard,
    and the only requirement is that it can be sent to a stream.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::quoted`函数的有趣之处在于，其返回值实际上只能用于发送到流中。其实际类型由C++标准未定义，唯一的要求是它可以发送到流。'
- en: 'Building and running the project shows that both tests pass. The following
    example shows what the `application.log` file looks like after deleting it and
    running the tests a couple of times:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和运行项目显示这两个测试都通过了。以下示例展示了在删除`application.log`文件并运行几次测试后，该文件看起来像什么：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We now have the ability to create log messages with timestamps, save them to
    a log file, and can send whatever data we want to each log message. The usage
    is simple and intuitive for C++ developers who are already familiar with sending
    information to a stream such as `std::cout`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了创建带时间戳的日志消息、将它们保存到日志文件，并将我们想要发送到每个日志消息中的任何数据的能力。对于已经熟悉向`std::cout`等流发送信息的C++开发者来说，这种用法简单直观。
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to use the unit test library to begin a new
    project using TDD. Even though we only have two tests, we already have a working
    logging library that is easy to use and understandable by any C++ developer.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用单元测试库通过TDD（测试驱动开发）开始一个新的项目。尽管我们只有两个测试，但我们已经拥有了一个易于使用且任何C++开发者都能理解的日志库。
- en: The two tests will help ensure we don’t break the simple design started in this
    chapter as we extend the logging library in later chapters. The next chapter,
    in particular, will extend the logging library to better fit the needs of our
    intended user, a micro-services developer. We’ll be adding the ability to tag
    log messages and then use the tags to enable powerful filtering options.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个测试将有助于确保我们在后续章节扩展日志库时不会破坏本章开始时启动的简单设计。特别是下一章将扩展日志库以更好地满足我们目标用户（微服务开发者）的需求。我们将添加标记日志消息的能力，然后使用这些标记启用强大的过滤选项。
