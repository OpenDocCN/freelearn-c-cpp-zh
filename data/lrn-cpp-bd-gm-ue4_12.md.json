["```cpp\nUCLASS()\nclass GOLDENEGG_API AMonsterAIController : public AAIController\n{\n    GENERATED_BODY()\n\npublic:\n    //Start following the player\n    void StartFollowingPlayer();\n};\n```", "```cpp\nvoid AMonsterAIController::StartFollowingPlayer()\n{\n    AActor *player = Cast<AActor>(\n        UGameplayStatics::GetPlayerPawn(GetWorld(), 0));\n    FVector playerPos = player->GetActorLocation();\n    MoveToLocation(playerPos);\n}\n```", "```cpp\nAddMovementInput(toPlayer, Speed*DeltaSeconds);\n```", "```cpp\n\n        if (GetController() != nullptr)\n        {\n            Cast<AMonsterAIController>(GetController())-\n            >StartFollowingPlayer();\n        }\n```", "```cpp\nUCLASS()\nclass GOLDENEGG_API UBTTask_FollowPlayer : public UBTTaskNode\n{\n    GENERATED_BODY()\n\n    virtual EBTNodeResult::Type ExecuteTask(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory) override;\n    virtual void OnGameplayTaskActivated(UGameplayTask& Task) override {}\n};\n```", "```cpp\n#include \"BTTask_FollowPlayer.h\"\n#include \"MonsterAIController.h\"\n\nEBTNodeResult::Type UBTTask_FollowPlayer::ExecuteTask(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory)\n{\n    AMonsterAIController* Controller = Cast<AMonsterAIController>(OwnerComp.GetAIOwner());\n    if (Controller == nullptr)\n    {\n        return EBTNodeResult::Failed;\n    }\n\n    Controller->StartFollowingPlayer();\n\n    return EBTNodeResult::Succeeded;\n}\n```", "```cpp\nUCLASS()\nclass GOLDENEGG_API AMonsterAIController : public AAIController\n{\n    GENERATED_BODY()\n\npublic:\n    AMonsterAIController(const FObjectInitializer& ObjectInitializer);\n\n    virtual void Possess(class APawn* InPawn) override;\n\n    virtual void UnPossess() override;\n\n    UBehaviorTreeComponent* BehaviorTreeCmp;\n\n    UBlackboardComponent* BlackboardCmp;\n\n    //Start following the player\n    void StartFollowingPlayer();\n    void SetFollowRange(bool val);\n    void SetAttackRange(bool val);\n};\n```", "```cpp\nAMonsterAIController::AMonsterAIController(const class FObjectInitializer& ObjectInitializer)\n    : Super(ObjectInitializer)\n{\n    BehaviorTreeCmp = ObjectInitializer.CreateDefaultSubobject<UBehaviorTreeComponent>(this, TEXT(\"MonsterBT\"));\n    BlackboardCmp = ObjectInitializer.CreateDefaultSubobject<UBlackboardComponent>(this, TEXT(\"MonsterBlackboard\"));\n}\n\nvoid AMonsterAIController::Possess(class APawn* InPawn)\n{\n    Super::Possess(InPawn);\n\n    AMonster* Monster = Cast<AMonster>(InPawn);\n    if (Monster)\n    {\n        if (Monster->BehaviorTree->BlackboardAsset)\n        {\n            BlackboardCmp->InitializeBlackboard(*Monster->BehaviorTree->BlackboardAsset);\n        }\n\n        BehaviorTreeCmp->StartTree(*Monster->BehaviorTree);\n    }\n}\n\nvoid AMonsterAIController::UnPossess()\n{\n    Super::UnPossess();\n\n    BehaviorTreeCmp->StopTree();\n}\n\nvoid AMonsterAIController::SetFollowRange(bool val)\n{\n    BlackboardCmp->SetValueAsBool(\"IsInFollowRange\", val);\n}\n\nvoid AMonsterAIController::SetAttackRange(bool val)\n{\n    BlackboardCmp->SetValueAsBool(\"IsInAttackRange\", val);\n}\n```", "```cpp\n#include \"Monster.h\"\n#include \"BehaviorTree/BehaviorTree.h\"\n#include \"BehaviorTree/BlackboardComponent.h\"\n```", "```cpp\n    UPROPERTY(EditDefaultsOnly, Category = \"AI\")\n        class UBehaviorTree* BehaviorTree;\n```", "```cpp\n// Called every frame\nvoid AMonster::Tick(float DeltaSeconds)\n{\n    Super::Tick(DeltaSeconds);\n\n    // move the monster towards the player \n    AAvatar *avatar = Cast<AAvatar>(\n        UGameplayStatics::GetPlayerPawn(GetWorld(), 0));\n    if (!avatar) return;\n\n    FVector playerPos = avatar->GetActorLocation();\n    FVector toPlayer = playerPos - GetActorLocation();\n    float distanceToPlayer = toPlayer.Size();\n    AMonsterAIController* controller = Cast<AMonsterAIController>(GetController());\n\n    // If the player is not the SightSphere of the monster, \n    // go back \n    if (distanceToPlayer > SightSphere->GetScaledSphereRadius())\n    {\n        // If the player is OS, then the enemy cannot chase \n        if (controller != nullptr)\n        {\n            controller->SetAttackRange(false);\n            controller->SetFollowRange(false);\n        }\n        return;\n    }\n\n    toPlayer /= distanceToPlayer;  // normalizes the vector \n\n                                   // At least face the target \n                                   // Gets you the rotator to turn something \n                                   // that looks in the `toPlayer` direction \n    FRotator toPlayerRotation = toPlayer.Rotation();\n    toPlayerRotation.Pitch = 0; // 0 off the pitch \n    RootComponent->SetWorldRotation(toPlayerRotation);\n\n    if (isInAttackRange(distanceToPlayer))\n    {\n        if (controller != nullptr)\n        {\n            controller->SetAttackRange(true);\n        }\n\n        // Perform the attack \n        if (!TimeSinceLastStrike)\n        {\n            Attack(avatar);\n        }\n\n        TimeSinceLastStrike += DeltaSeconds;\n        if (TimeSinceLastStrike > AttackTimeout)\n        {\n            TimeSinceLastStrike = 0;\n        }\n\n        return;  // nothing else to do \n    }\n    else\n    {\n        // not in attack range, so walk towards player \n        //AddMovementInput(toPlayer, Speed*DeltaSeconds);\n\n        if (controller != nullptr)\n        {\n            controller->SetAttackRange(false);\n            controller->SetFollowRange(true);\n        }\n    }\n}\n```"]