- en: '*Chapter 2*: General STL Features'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：通用STL功能'
- en: This chapter is a general potpourri of STL features and techniques. These are
    mostly new features introduced over the past few years, which may not yet be widely
    used. These are useful techniques that will improve the simplicity and readability
    of your code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是STL功能和技术的综合。这些大多是过去几年中引入的新功能，可能尚未得到广泛应用。这些有用的技术将提高你代码的简洁性和可读性。
- en: 'In this chapter we will cover the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Use the new `span` class to make your C-arrays safer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新的`span`类使你的C数组更安全
- en: Use structured binding to return multiple values
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用结构化绑定返回多个值
- en: Initialize variables within `if` and `switch` statements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`if`和`switch`语句中初始化变量
- en: Use template argument deduction for simplicity and clarity
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模板参数推导以简化并清晰
- en: Use `if constexpr` to simplify compile-time decisions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`if constexpr`简化编译时决策
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code for this chapter on GitHub at [https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap02](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap02).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章的代码：[https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap02](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap02)。
- en: Use the new span class to make your C-arrays safer
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用新的`span`类使你的C数组更安全
- en: New for C++20, the `std::span` class is a simple wrapper that creates a view
    over a contiguous sequence of objects. The `span` doesn't own any of its own data,
    it refers to the data in the underlying structure. Think of it as `string_view`
    for C-arrays. The underlying structure may be a *C-array*, a `vector`, or an STL
    `array`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: C++20新增的`std::span`类是一个简单的包装器，它创建了对连续对象序列的视图。`span`不拥有自己的数据，它引用底层结构中的数据。将其视为C数组的`string_view`。底层结构可能是一个*C数组*、一个`vector`或STL的`array`。
- en: How to do it…
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'You can create a span from any compatible contiguous-storage structure. The
    most common use case will involve a C-array. For example, if you try to pass a
    C-array directly to a function, the array is demoted to a pointer and the function
    has no easy way to know the size of the array:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从任何兼容的连续存储结构创建`span`。最常见的情况将涉及C数组。例如，如果你尝试直接将C数组传递给一个函数，数组将被降级为指针，函数没有简单的方法知道数组的大小：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you define your function with a `span` parameter, you can pass it a C-array
    and it will be promoted to `span`. Here''s a template function that takes a `span`
    and prints out the size in elements and in bytes:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`span`参数定义你的函数，你可以传递一个C数组，它将被提升为`span`。以下是一个模板函数，它接受一个`span`并打印出元素数量和字节数：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can pass a C-array to this function and it''s automatically promoted to
    `span`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将C数组传递给这个函数，它将自动提升为`span`：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Output:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The purpose of `span` is to encapsulate the raw data to provide a measure of
    safety and utility, with a minimum of overhead.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`span`的目的在于封装原始数据，以提供一定程度的保护和实用性，同时最小化开销。'
- en: How it works…
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `span` class itself doesn't own any data. The data belongs to the underlying
    data structure. The `span` is essentially a view over the underlying data. It
    also provides some useful member functions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`span`类本身不拥有任何数据。数据属于底层数据结构。`span`本质上是对底层数据的视图。它还提供了一些有用的成员函数。'
- en: 'Defined in the `<span>` header, the `span` class looks something like:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 定义在`<span>`头文件中，`span`类看起来像这样：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `Extent` parameter is a constant of type `constexpr size_t`, which is computed
    at compile time. It''s either the number of elements in the underlying data or
    the `std:: dynamic_extent` constant, which indicates that the size is variable.
    This allows `span` to use an underlying structure like a `vector`, which may not
    always be the same size.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Extent`参数是一个`constexpr size_t`类型的常量，它在编译时计算。它要么是底层数据中的元素数量，要么是`std::dynamic_extent`常量，表示大小是可变的。这允许`span`使用底层结构，如`vector`，其大小可能不是固定的。'
- en: 'All member functions are `constexpr` and `const` qualified. Member functions
    include:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所有成员函数都是`constexpr`和`const`修饰的。成员函数包括：
- en: '![](img/B18267_02_Table_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18267_02_Table_01.jpg)'
- en: Important Note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `span` class is but a simple wrapper that performs no bounds checking. So,
    if you try to access element *n*+1 in a `span` of *n* elements, the result is
    *undefined*, which is tech for, "Bad. Don't do that."
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`span`类只是一个简单的包装器，不执行边界检查。所以，如果你尝试在包含*n*个元素的`span`中访问第*n*+1个元素，结果是未定义的，这在技术上意味着“不好。不要这样做。”'
- en: Use structured binding to return multiple values
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用结构化绑定返回多个值
- en: '*Structured binding* makes it easy to unpack the values of a structure into
    separate variables, improving the readability of your code.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*结构化绑定*使将结构值解包到单独的变量变得容易，从而提高了代码的可读性。'
- en: 'With structured binding you can directly assign the member values to variables
    like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用结构化绑定，你可以直接将成员值赋给变量，如下所示：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Output:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How to do it…
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: '*Structured binding* works with `pair`, `tuple`, `array`, and `struct`. Beginning
    with C++20, this includes bit-fields. This example uses a C-array:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*结构化绑定*与`pair`、`tuple`、`array`和`struct`一起工作。从C++20开始，这包括位域。此示例使用C数组：'
- en: '[PRE7]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Because the structured binding uses *automatic type deduction*, its type must
    be `auto`. The names of the individual variables are within the square brackets,
    `[ a, b, c, d, e ]`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因为结构化绑定使用*自动类型推导*，它的类型必须是`auto`。个别变量的名称位于方括号内，`[ a, b, c, d, e ]`。
- en: In this example the `int` C-array `nums` holds five values. These five values
    are assigned to the variables (`a`, `b`, `c`, `d`, and `e`) using *structured
    binding*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`int` C数组`nums`包含五个值。这五个值使用*结构化绑定*分配给变量（`a`、`b`、`c`、`d`和`e`）。
- en: 'This also works with an STL `array` object:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这也适用于STL `array`对象：
- en: '[PRE9]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Output:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Or you can use it with a `tuple`:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，你可以用它与`tuple`一起使用：
- en: '[PRE11]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Output:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When you use it with a `struct` it will take the variables in the order they''re
    defined:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你与`struct`一起使用时，它将按照定义的顺序获取变量：
- en: '[PRE13]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Output:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can use a reference with a structured binding, which allows you to modify
    the values in the bound container, while avoiding duplication of the data:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用引用与结构化绑定一起使用，这允许你修改绑定容器中的值，同时避免数据重复：
- en: '[PRE15]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Output:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Because the variables are bound as a reference, you can assign a value to `c`
    and it will change the value in the array as well (`nums[2]`).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因为变量作为引用绑定，你可以将值赋给`c`，这将改变数组中的值（`nums[2]`）。
- en: 'You can declare the array `const` to prevent values from being changed:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以声明数组为`const`以防止值被更改：
- en: '[PRE17]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Or you can declare the binding `const` for the same effect, while allowing
    the array to be changed elsewhere and still avoid copying data:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以声明绑定为`const`以获得相同的效果，同时允许在其他地方更改数组，并且仍然避免复制数据：
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works…
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Structured binding uses *automatic type deduction* to unpack the structure into
    your variables. It determines the type of each value independently, and assigns
    a corresponding type to each variable.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化绑定使用*自动类型推导*将结构解包到你的变量中。它独立确定每个值的类型，并为每个变量分配相应的类型。
- en: 'Because structured binding uses automatic type deduction, you cannot specify
    a type for the binding. You must use `auto`. You should get a reasonable error
    message if you try to use a type for the binding:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为结构化绑定使用自动类型推导，你不能为绑定指定类型。你必须使用`auto`。如果你尝试为绑定使用类型，你应该会得到一个合理的错误信息：
- en: '[PRE19]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Output:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Above is the error from GCC when I try to use `int` with the structured binding
    declaration.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 上面是当我尝试使用`int`与结构化绑定声明时GCC产生的错误。
- en: 'It''s common to use structured binding for a return type from a function:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用结构化绑定作为函数的返回类型很常见：
- en: '[PRE21]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE22]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Because the `map` container classes return a pair for each element, it can
    be convenient to use structured binding to retrieve key/value pairs:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为`map`容器类为每个元素返回一个对，所以使用结构化绑定检索键/值对很方便：
- en: '[PRE23]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Output:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE24]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Using structured binding to unpack structures should make your code clearer
    and easier to maintain.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用结构化绑定解包结构可以使你的代码更清晰且易于维护。
- en: Initialize variables within if and switch statements
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在if和switch语句中初始化变量
- en: Beginning with C++17, `if` and `switch` now have initialization syntax, much
    like the `for` loop has had since C99\. This allows you to limit the scope of
    variables used within the condition.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从C++17开始，`if`和`switch`现在有了初始化语法，就像C99以来的`for`循环一样。这允许你限制条件内使用的变量的作用域。
- en: How to do it…
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'You may be accustomed to code like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能习惯于这样的代码：
- en: '[PRE25]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This leaves the variable `pos` exposed outside the scope of the conditional
    statement, where it needs to be managed, or it can collide with other attempts
    to use the same symbol.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得变量`pos`暴露在条件语句的作用域之外，需要在这里进行管理，或者它可能与其他尝试使用相同符号的尝试发生冲突。
- en: 'Now you can put the initialization expression inside the `if` condition:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在`if`条件中放置初始化表达式：
- en: '[PRE26]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now the scope of the `pos` variable is confined to the scope of the conditional.
    This keeps your namespace clean and manageable.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`pos`变量的作用域被限制在条件的作用域内。这保持了你的命名空间干净且易于管理。
- en: How it works…
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The initializer expression can be used in either `if` or `switch` statements.
    Here are some examples of each.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化器表达式可以用于 `if` 或 `switch` 语句。以下是每个的示例。
- en: 'Use an initializer expression with an `if` statement:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `if` 语句的初始化器表达式：
- en: '[PRE27]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The variable defined in the initializer expression is visible within the scope
    of the entire `if` statement, including the `else` clause. Once control flows
    out of the `if` statement scope, the variable will no longer be visible, and any
    relevant destructors will be called.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化器表达式中定义的变量在整个 `if` 语句的作用域内可见，包括 `else` 子句。一旦控制流离开 `if` 语句的作用域，该变量将不再可见，并且将调用任何相关的析构函数。
- en: 'Use an initializer expression with a `switch` statement:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `switch` 语句的初始化器表达式：
- en: '[PRE28]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The variable defined in the initializer expression is visible within the scope
    of the entire `switch` statement, including all the `case` clauses and the `default`
    clause, if included. Once control flows out of the `switch` statement scope, the
    variable will no longer be visible, and any relevant destructors will be called.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化器表达式中定义的变量在整个 `switch` 语句的作用域内可见，包括所有的 `case` 子句和可选的 `default` 子句。一旦控制流离开
    `switch` 语句的作用域，该变量将不再可见，并且将调用任何相关的析构函数。
- en: There's more…
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'One interesting use case is to limit the scope of a `lock_guard` that''s locking
    a mutex. This becomes simple with an initializer expression:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的用例是限制锁定互斥锁的 `lock_guard` 的作用域。使用初始化器表达式可以使这变得简单：
- en: '[PRE29]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `lock_guard` locks the mutex in its constructor and unlocks it in its destructor.
    Now the `lock_guard` will be automatically destroyed when it runs out of the scope
    of the `if` statement. In the past you would have had to delete it or enclose
    the whole `if` statement in an extra block of braces.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`lock_guard` 在其构造函数中锁定互斥锁，并在析构函数中解锁。现在，当 `lock_guard` 超出 `if` 语句的作用域时，它将被自动销毁。在过去，你可能需要删除它或将整个
    `if` 语句包围在一个额外的花括号块中。'
- en: 'Another use case could be using a legacy interface that uses output parameters,
    like this one from SQLite:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用例可能是使用使用输出参数的遗留接口，例如 SQLite 中的这个：
- en: '[PRE30]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here I can keep the statement handle and the error code localized to the scope
    of the `if` statement. Otherwise, I would need to manage those objects globally.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我可以将语句句柄和错误代码局部化到 `if` 语句的作用域内。否则，我需要全局管理这些对象。
- en: Using initializer expressions will help keep your code tight and uncluttered,
    more compact, and easier to read. Refactoring and managing your code will also
    become easier.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用初始化器表达式将有助于使你的代码紧凑且无杂乱，更紧凑，更容易阅读。重构和管理你的代码也将变得更加容易。
- en: Use template argument deduction for simplicity and clarity
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模板参数推导以简化并清晰
- en: Template argument deduction occurs when the *types* of the arguments to a template
    function, or class template constructor (beginning with C++17), are clear enough
    to be understood by the compiler without the use of template arguments. There
    are certain rules to this feature, but it's mostly intuitive.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 模板参数推导发生在模板函数的参数类型或类模板构造函数（从 C++17 开始）的类型足够清晰，以至于编译器无需使用模板参数就能理解时。这个特性有一些规则，但主要是直观的。
- en: How to do it…
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: In general, template argument deduction happens automatically when you use a
    template with clearly compatible arguments. Let's consider some examples.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你使用与模板明显兼容的参数的模板时，模板参数推导会自动发生。让我们考虑一些例子。
- en: 'In a function template, argument deduction usually looks something like this:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数模板中，参数推导通常看起来像这样：
- en: '[PRE31]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Output:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE32]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Because the types are easily discernable there is no reason to specify a template
    parameter like `f<int>(47)` in the function call. The compiler can deduce the
    `<int>` type from the argument.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因为类型很容易识别，所以在函数调用中不需要指定模板参数，例如 `f<int>(47)`。编译器可以从参数中推导出 `<int>` 类型。
- en: Note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The above output shows meaningful type names where most compilers will use shorthand,
    like `i` for `int` and `PKc` for `const char *`, and so on.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出显示了大多数编译器将使用缩写的有意义类型名称，例如 `int` 的 `i` 和 `const char *` 的 `PKc` 等。
- en: 'This works just as well for multiple template parameters:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这同样适用于多个模板参数：
- en: '[PRE33]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Output:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE34]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here the compiler is deducing types for both `T1` and `T2`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，编译器正在推断 `T1` 和 `T2` 的类型。
- en: 'Notice that the types must be compatible with the template. For example, you
    cannot take a reference from a literal:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，类型必须与模板兼容。例如，你不能从字面量中取引用：
- en: '[PRE35]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Beginning with C++17 you can also use template parameter deduction with classes.
    So now this will work:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 C++17 开始，你也可以使用模板参数推导与类。所以现在这将工作：
- en: '[PRE36]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This eliminates the need for `std::make_pair()` and `std::make_tuple()` as you
    can now initialize these classes directly without the explicit template parameters.
    The `std::make_*` helper functions will remain available for backward compatibility.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这消除了对 `std::make_pair()` 和 `std::make_tuple()` 的需要，因为你现在可以直接初始化这些类，而无需显式模板参数。`std::make_*`
    辅助函数将保持可用，以保持向后兼容性。
- en: How it works…
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Let''s define a class so we can see how this works:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个类，这样我们就可以看到它是如何工作的：
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is a template class with three types and three corresponding data members.
    It has a `print()` function, which returns a formatted string with the three type
    names.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个具有三种类型和三个相应数据成员的模板类。它有一个 `print()` 函数，该函数返回包含三个类型名称的格式化字符串。
- en: 'Without template parameter deduction, I would have to instantiate an object
    of this type like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 没有模板参数推导的情况下，我必须这样实例化这个类型的对象：
- en: '[PRE38]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now I can do it like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我可以这样做：
- en: '[PRE39]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is both simpler and less error prone.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这既简单又不易出错。
- en: 'When I call the `print()` function on the `thing1` object, I get this result:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在 `thing1` 对象上调用 `print()` 函数时，我得到这个结果：
- en: '[PRE40]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Output:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Of course, your compiler may report something effectively similar.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你的编译器可能会报告类似的内容。
- en: 'Before C++17, template parameter deduction didn''t apply to classes, so you
    needed a helper function, which may have looked like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++17 之前，模板参数推导不适用于类，因此你需要一个辅助函数，它可能看起来像这样：
- en: '[PRE42]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE43]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The STL includes a few of these helper functions, like `make_pair()` and `make_tuple()`,
    etc. These are now obsolescent, but will be maintained for compatibility with
    older code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: STL 包含了一些这些辅助函数，例如 `make_pair()` 和 `make_tuple()` 等。这些函数现在已过时，但为了与旧代码保持兼容性，将会继续维护。
- en: There's more…
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'Consider the case of a constructor with a parameter pack:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑具有参数包的构造函数的情况：
- en: '[PRE44]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Notice the *fold expression* in the constructor `(values + ...)`. This is a
    C++17 feature that applies an operator to all the members of a parameter pack.
    In this case, it initializes `v` to the sum of the parameter pack.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意构造函数中的 *折叠表达式* `(values + ...)`。这是一个 C++17 特性，它将运算符应用于参数包的所有成员。在这种情况下，它将 `v`
    初始化为参数包的总和。
- en: 'The constructor for this class accepts an arbitrary number of parameters, where
    each parameter may be a different class. For example, I could call it like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的构造函数接受任意数量的参数，其中每个参数可能属于不同的类。例如，我可以这样调用它：
- en: '[PRE45]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This, of course, doesn''t compile. The template argument deduction fails to
    find a common type for all those different parameters. We get an error message
    to the effect of:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这无法编译。模板参数推导未能为所有这些不同的参数找到一个共同类型。我们得到一个类似以下错误信息的消息：
- en: '[PRE46]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can fix this with a *template deduction guide*. A deduction guide is a helper
    pattern to assist the compiler with a complex deduction. Here''s a guide for our
    constructor:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一个 *模板推导指南* 来解决这个问题。推导指南是一种辅助模式，用于帮助编译器处理复杂的推导。这是我们的构造函数的指南：
- en: '[PRE47]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This tells the compiler to use the `std::common_type_t` trait, which attempts
    to find a common type for all the parameters in the pack. Now our argument deduction
    works and we can see what types it settled on:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉编译器使用 `std::common_type_t` 特性，它试图为包中的所有参数找到一个共同类型。现在我们的参数推导工作正常，我们可以看到它选择了哪些类型：
- en: '[PRE48]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Output:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE49]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Use if constexpr to simplify compile-time decisions
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `if constexpr` 简化编译时决策
- en: An `if constexpr(`*condition*`)` statement is used where code needs to be executed
    based on a compile-time condition. The *condition* may be any `constexpr` expression
    of type `bool`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要根据编译时条件执行代码的地方使用 `if constexpr(`*条件*)` 语句。*条件* 可以是任何类型为 `bool` 的 `constexpr`
    表达式。
- en: How to do it…
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何去做…
- en: Consider the case where you have a template function that needs to operate differently
    depending upon the type of the template parameter.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一个情况，你有一个需要根据模板参数类型执行不同操作的模板函数。
- en: '[PRE50]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Output:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE51]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The type of the template parameter `T` is available at compile time. The `constexpr
    if` statement allows the code to easily distinguish between a pointer and a value.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 模板参数 `T` 的类型在编译时是可用的。`constexpr if` 语句允许代码轻松区分指针和值。
- en: How it works…
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The `constexpr if` statement works like a normal `if` statement except it''s
    evaluated at *compile time*. The *runtime code* will not contain any branch statements
    from a `constexpr if` statement. Consider our branch statement from above:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`constexpr if`语句的工作方式与普通的`if`语句类似，除了它在*编译时*进行评估。*运行时代码*将不会包含来自`constexpr if`语句的任何分支语句。考虑我们上面的分支语句：'
- en: '[PRE52]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The condition `is_pointer_v<T>` tests a template parameter, which is not available
    at runtime. The `constexpr` keyword tells the compiler that this `if` statement
    needs to evaluate at compile time, while the template parameter `<T>` is available.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 条件`is_pointer_v<T>`测试一个模板参数，该参数在运行时不可用。`constexpr`关键字告诉编译器这个`if`语句需要在编译时评估，而模板参数`<T>`是可用的。
- en: This should make a lot of meta programming situations much easier. The `if constexpr`
    statement is available in C++17 and later.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会使许多元编程场景变得更加简单。`if constexpr`语句在C++17及以后的版本中可用。
