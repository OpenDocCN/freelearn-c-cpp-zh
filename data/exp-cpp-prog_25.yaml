- en: STL Algorithm Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: STL算法基础
- en: 'We will cover the following recipes in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将涵盖以下内容：
- en: Copying items from containers to other containers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将项目从一个容器复制到另一个容器
- en: Sorting containers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对容器进行排序
- en: Removing specific items from containers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从容器中删除特定项目
- en: Transforming the contents of containers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换容器的内容
- en: Finding items in ordered and unordered vectors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在有序和无序向量中查找项目
- en: Limiting the values of a vector to a specific numeric range with `std::clamp`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::clamp`将向量的值限制在特定的数值范围内
- en: Locating patterns in strings with `std::search` and choosing the optimal implementation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::search`在字符串中查找模式并选择最佳实现
- en: Sampling large vectors
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对大型向量进行抽样
- en: Generating permutations of input sequences
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成输入序列的排列
- en: Implementing a dictionary merging tool
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现字典合并工具
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: The STL does not only contain data structures but also *algorithms*, of course.
    While data structures help *store* and *maintain* data in different ways with
    different motivations and targets, algorithms apply specific *transformations*
    to the data in such data structures.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: STL不仅包含数据结构，还包括*算法*。数据结构帮助以不同的方式和不同的动机和目标*存储*和*维护*数据，而算法则对这些数据进行特定的*转换*。
- en: 'Let''s have a look at a standard task, such as summing up items from a vector.
    This can be done easily by looping over the vector and summing up all the items
    into an accumulator variable called `sum`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个标准任务，比如对向量中的项目求和。这可以通过循环遍历向量并将所有项目累加到一个名为`sum`的累加器变量中轻松完成：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'But because this is quite a standard task, there is also an STL algorithm for
    this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 但是因为这是一个相当标准的任务，所以也有一个STL算法可以完成这个任务：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this case, the handcrafted loop variant is not much longer, and it is also
    not significantly harder to read than a one-liner which says what it does: `accumulate`.
    In a lot of cases, however, it is awkward to read a 10-line code loop just to
    realize, "Did I just have to study the whole loop in order to understand that
    it does a standard task, X?", rather than seeing one line of code, which uses
    a standard algorithm whose name clearly states what it does, such as `accumulate`,
    `copy`, `move`, `transform`, or `shuffle`.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，手工制作的循环变体并不比一行代码长多少，而且也不比一个一行代码难以阅读：`accumulate`。然而，在很多情况下，阅读一个10行代码的循环是很尴尬的，"我刚刚是否不得不研究整个循环才能理解它执行了一个标准任务X？"，而不是看到一行代码，它使用了一个清楚说明它的名字的标准算法，比如`accumulate`、`copy`、`move`、`transform`或`shuffle`。
- en: The basic idea is to provide a rich variety of algorithms that can be used by
    programmers on a daily basis in order to reduce the need to repeatedly reimplement
    them. This way, programmers can just use off the shelf algorithm implementations
    and concentrate on the *new* problems, instead of wasting time on problems that
    *already have been solved* by the STL. Another perspective is correctness--if
    a programmer implements the same thing again and again for a hundred times, there
    is some probability that this may introduce a slight *error* in one or the other
    attempt. This would be completely unnecessary and also very *embarrassing* if,
    for example, it is pointed out by a colleague during code review, whereas at the
    same time, a standard algorithm could have been used.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 基本思想是提供丰富多样的算法，供程序员在日常工作中使用，以减少重复实现它们的需要。这样，程序员可以直接使用现成的算法实现，并集中精力解决*新*问题，而不是浪费时间在STL已经解决的问题上。另一个角度是正确性--如果程序员一遍又一遍地实现相同的东西，那么有可能在一次或另一次尝试中引入一点*错误*。这是完全不必要的，而且如果在代码审查期间被同事指出，这也是非常*尴尬*的，而与此同时，可以使用标准算法。
- en: Another important point of STL algorithms is *efficiency*. Many STL algorithms
    provide multiple *specialized* implementations of the same algorithm, which do
    things differently, depending on the *iterator type* they are being used with.
    For example, if all the elements in a vector of integers should be zeroed, this
    can be done with the STL algorithm `std::fill`. Because the iterator of a vector
    can already tell the compiler that it iterates over *contiguous* memory, it can
    select the implementation of `std::fill` which uses the C procedure `memset`.
    If the programmer changes the container type from `vector` to `list`, then the
    STL algorithm cannot use `memset` any longer and has to iterate over the list
    in order to zero the items individually. In case the programmer uses `memset`
    himself, the implementation would be unnecessarily hardcoded to using vectors
    or arrays because most other data structures do not save their data in contiguous
    memory chunks. In most cases, it makes little sense to try to be smart, as the
    implementers of the STL may already have implemented the same ideas, which can
    be used for free.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: STL算法的另一个重要点是*效率*。许多STL算法提供了相同算法的多个*专门*实现，这些实现根据它们所使用的*迭代器类型*的不同而执行不同的操作。例如，如果一个整数向量中的所有元素都应该被置零，可以使用STL算法`std::fill`来完成。因为向量的迭代器已经可以告诉编译器它是在*连续*内存上迭代，它可以选择使用使用C过程`memset`的`std::fill`实现。如果程序员将容器类型从`vector`更改为`list`，那么STL算法就不能再使用`memset`，而必须逐个迭代列表以将项目置零。如果程序员自己使用`memset`，那么实现将不必要地硬编码为使用向量或数组，因为大多数其他数据结构不会将它们的数据保存在连续的内存块中。在大多数情况下，试图变得聪明几乎没有意义，因为STL的实现者可能已经实现了相同的想法，这些想法可以免费使用。
- en: 'Let''s summarize the preceding points. Using STL algorithms is good for:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结前面的观点。使用STL算法有以下好处：
- en: '**Maintainability**: The names of the algorithms already state in a straightforward
    manner what they do. Explicit loops are rarely both better to read and as data-structure
    agnostic as standard algorithms.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：算法的名称已经清楚地说明了它们的功能。显式循环很少有比标准算法更易读且与数据结构无关的情况。'
- en: '**Correctness**: The STL has been written and reviewed by experts, and used
    and tested by so many people that you are pretty unlikely to reach the same degree
    of correctness when reimplementing the complex parts of it.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正确性**：STL已经由专家编写和审查，并且被如此多的人使用和测试，以至于在重新实现其复杂部分时，你很难达到相同的正确性程度。'
- en: '**Efficiency**: STL algorithms are, by default, at least as efficient as most
    handcrafted loops.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**：STL算法默认至少与大多数手工编写的循环一样有效。'
- en: Most algorithms work on *iterators*. The concept of how iterators work is already
    explained in [Chapter 20](28942573-9c26-46c7-a1de-be9e941ed82f.xhtml), *Iterators*.
    In this chapter, we'll concentrate on using STL algorithms for different problems
    in order to get a feeling of how they can be profitably put to use. Showing *all*
    STL algorithms would blow up this book to a very boring C++ reference, although
    there is already a C++ reference publicly available.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数算法都在*迭代器*上工作。关于迭代器如何工作的概念已经在[第20章](28942573-9c26-46c7-a1de-be9e941ed82f.xhtml)中解释过了，*迭代器*。在本章中，我们将集中讨论使用STL算法解决不同问题，以便对它们如何有利地利用有所感触。展示*所有*STL算法会使这本书变成一个非常无聊的C++参考资料，尽管已经有一个C++参考资料公开可用。
- en: The best way to become an STL ninja is having the C++ reference always at hand
    or, at least, saved in a browser bookmark. When solving a task, every programmer
    should have a look at it with the question back in his mind, "Is there an STL
    algorithm for my problem?", before writing code himself.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 成为STL忍者的最佳方法是始终随身携带C++参考资料，或者至少将其保存在浏览器书签中。在解决问题时，每个程序员都应该在脑海中回想一下这个问题，“我的问题是否有STL算法？”，然后再自己编写代码。
- en: 'A very good and complete C++ reference is available for online viewing at:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常好而完整的C++参考资料可以在线查看：
- en: '[http://cppreference.com](http://cppreference.com)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://cppreference.com](http://cppreference.com)'
- en: It can also be downloaded for offline viewing.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以下载以供离线查看。
- en: In job interviews, good fluency with the STL algorithms is often regarded as
    an indicator of a strong knowledge of C++.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作面试中，熟练掌握STL算法通常被视为对C++知识的强大指标。
- en: Copying items from containers to other containers
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从容器复制项目到其他容器
- en: The most important STL data structures have iterator support. This means that
    it is at least possible to get iterators via `begin()` and `end()` functions,
    which point to the data structure's underlying payload data and allow to iterate
    over that data. The iteration always looks the same, no matter what kind of data
    structure is iterated over.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的STL数据结构都有迭代器支持。这意味着至少可以通过`begin()`和`end()`函数获取迭代器，这些迭代器指向数据结构的基础有效负载数据，并允许对该数据进行迭代。迭代总是看起来一样，无论迭代的是什么类型的数据结构。
- en: We can get iterators from vectors, lists, deques, maps, and so on. Using iterator
    adaptors, we can even get iterators as an interface to files, standard input,
    and standard output. Moreover, as we saw in the previous chapter, we can even
    wrap iterator interfaces around algorithms. Now, where we can access everything
    with iterators, we can combine them with STL algorithms, which accept iterators
    as parameters.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从向量、列表、双端队列、地图等获取迭代器。使用迭代器适配器，我们甚至可以将迭代器作为文件、标准输入和标准输出的接口。此外，正如我们在上一章中看到的，我们甚至可以将迭代器接口包装在算法周围。现在，在我们可以使用迭代器访问所有内容的地方，我们可以将它们与接受迭代器作为参数的STL算法结合使用。
- en: A really nice way to show how iterators help abstract the nature of different
    data structures away is the `std::copy` algorithm, which just copies items from
    one set of iterators to an output iterator. Where such algorithms are used, the
    nature of the underlying data structure is not really relevant any longer. In
    order to demonstrate this, we will play a bit with `std::copy`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 展示迭代器如何将不同数据结构的本质抽象化的一个非常好的方法是`std::copy`算法，它只是将项目从一组迭代器复制到输出迭代器。在使用这样的算法时，底层数据结构的本质不再真正相关。为了证明这一点，我们将稍微使用一下`std::copy`。
- en: How to do it...
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we will use different variants of `std::copy`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用`std::copy`的不同变体：
- en: 'Let''s first include all headers we need for the data structures we use. Additionally,
    we declare that we use the `std` namespace:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先包括我们使用的数据结构所需的所有头文件。此外，我们声明我们使用`std`命名空间：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will use pairs of integer and string values in the following. In order to
    nicely print them, we should first overload the `<<` stream operator for them:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们将使用整数和字符串值的对。为了漂亮地打印它们，我们应该首先为它们重载`<<`流操作符：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the `main` function, we fill a `vector` of integer-string pairs with some
    default values. And we declare a `map` variable, which associates integer values
    with string values:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们用一些默认值填充了一个整数-字符串对的`vector`。然后我们声明了一个`map`变量，它将整数值与字符串值关联起来：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we use `std::copy_n` to copy exactly three integer-string pairs from the
    front of the vector to the map. Because vectors and maps are completely different
    data structures, we need to transform the items from the vector using the `insert_iterator`
    adapter. The `std::inserter` function produces such an adapter for us. Please
    be always aware that using algorithms like `std::copy_n` combined with insert
    iterators is the most *generic* way to copy/insert items to other data structures,
    but not the *fastest*. Using the data structure-specific member functions for
    inserting items is usually the most efficient way:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用`std::copy_n`从向量的前面精确地复制三个整数-字符串对到地图中。因为向量和地图是完全不同的数据结构，我们需要使用`insert_iterator`适配器来转换向量中的项目。`std::inserter`函数为我们生成这样的适配器。请始终注意，使用`std::copy_n`等算法与插入迭代器结合使用是将项目复制/插入到其他数据结构的最*通用*方法，但不是*最快*的方法。使用数据结构特定的成员函数来插入项目通常是最有效的方法：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s print what''s in the map afterward. Throughout the book, we have often
    been printing a container''s content using the `std::copy` function. The `std::ostream_iterator`
    helps a lot in that regard because it allows us to treat the user shell''s standard
    output as *another container* we can copy data into:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打印一下映射之后的内容。在整本书中，我们经常使用`std::copy`函数打印容器的内容。`std::ostream_iterator`在这方面非常有帮助，因为它允许我们将用户shell的标准输出视为*另一个容器*，我们可以将数据复制到其中：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s clear the map again for the next experiment. This time, we *move* items
    from the vector to the map, and this time, it''s *all* the items:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次清空映射以进行下一个实验。这一次，我们将项目*从*向量*移动*到映射中，而且这一次，是*所有*项目：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We print the new content of the map again. Moreover, as `std::move` is an algorithm
    that also alters the data *source*, we will print the source vector too. This
    way, we can see what happened to it when it acted as a move source:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们再次打印映射的新内容。此外，由于`std::move`是一个也会改变数据*源*的算法，我们也将打印源向量。这样，我们就可以看到它在充当移动源时发生了什么：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s compile and run the program and see what it says. The first two lines
    are simple. They reflect what the map contained after applying the `copy_n` and
    `move` algorithms. The third line is interesting because it shows that the strings
    in the vector that we used as move source are now empty. This is because the content
    of the strings has not been copied but efficiently *moved* (which means that the
    map uses the string data in heap memory that was previously referenced by the
    string objects in the vector*)*. We should usually not access items that were
    a move source before we reassigned them, but let''s ignore that for the sake of
    this experiment:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编译并运行程序，看看它说了什么。前两行很简单。它们反映了应用`copy_n`和`move`算法后映射包含的内容。第三行很有趣，因为它显示了我们用作移动源的向量中的字符串现在为空。这是因为字符串的内容没有被复制，而是被有效地*移动*（这意味着映射使用了先前由向量中的字符串对象引用的堆内存中的字符串数据*）。我们通常不应该访问在重新分配之前作为移动源的项目，但为了这个实验，让我们忽略这一点：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As `std::copy` is one of the simplest STL algorithms, its implementation is
    very short. Let''s have a look at how it could be implemented:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`std::copy`是STL算法中最简单的之一，因此其实现非常简短。让我们看看它是如何实现的：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This looks exactly as one would implement the copying of items from one iterable
    range to the other by hand, naively. At this point, one could also ask, "So why
    not implementing it by hand, the loop is simple enough and I don't even need the
    return value?", which is, of course, a good question.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来确切地像一个人会天真地手动实现从一个可迭代范围到另一个可迭代范围的项目复制。在这一点上，人们也可以问，“那么为什么不手动实现它，循环足够简单，我甚至不需要返回值？”，这当然是一个很好的问题。
- en: 'While `std::copy` is not the best example for making code significantly shorter,
    a lot of other algorithms with more complex implementations are. What is not obvious
    is the hidden automatic optimization of such STL algorithms. If we happen to use
    `std::copy` with data structures that store their items in contiguous memory (as
    `std::vector` and `std::array` do), *and* the items themselves are *trivially
    copy assignable*, then the compiler will select a completely different implementation
    (which assumes the iterator types to be pointers):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`std::copy`不是使代码显著缩短的最佳示例，但许多其他具有更复杂实现的算法是。不明显的是这些STL算法的隐藏自动优化。如果我们碰巧使用存储其项目在连续内存中的数据结构（如`std::vector`和`std::array`）*和*项目本身是*平凡复制可分配的*，那么编译器将选择完全不同的实现（假设迭代器类型为指针）：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is a simplified version of how the `memmove` variant of the `std::copy`
    algorithm can look in a typical STL implementation. It is *faster* than the standard
    loop version, and *this time*, it is also not as nice to read. But nevertheless,
    `std::copy` users automatically profit from it if their argument types comply
    with the requirements of this optimization. The compiler selects the fastest implementation
    possible for the chosen algorithm, while the user code nicely expresses *what*
    the algorithm does without tainting the code with too many details of the *how*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`std::copy`算法的`memmove`变体在典型的STL实现中的简化版本。它比标准循环版本*更快*，而且*这一次*，它也不那么容易阅读。但是，如果参数类型符合此优化的要求，`std::copy`用户会自动从中受益。编译器为所选择的算法选择可能的最快实现，而用户代码则很好地表达了算法的*做什么*，而没有用太多的*如何*细节来污染代码。
- en: STL algorithms often simply provide the best trade-off between *readability*
    and *optimal implementation*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: STL算法通常提供了*可读性*和*最佳实现*之间的最佳权衡。
- en: Types are usually trivially copy assignable if they only consist of one or multiple
    (wrapped by a class/struct) scalar types or classes, which can safely be moved
    using `memcopy`/`memmove` without the need to invoke a user-defined copy assignment
    operator.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类型只包含一个或多个（由类/结构体包装）标量类型或类，通常可以将其视为平凡的可复制可分配类型，这些类型可以安全地使用`memcopy`/`memmove`进行移动，而无需调用用户定义的复制分配运算符。
- en: We also used `std::move`. It works exactly like `std::copy`, but it applies
    `std::move(*it)` to the source iterator in the loop in order to cast *lvalues*
    to *rvalues*. This makes the compiler select the move assignment operator of the
    target object instead of the copy assignment operator. For a lot of complex objects,
    this *performs* better but *destroys* the source object.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了`std::move`。它的工作原理与`std::copy`完全相同，但它在循环中将`std::move(*it)`应用于源迭代器，以将*lvalues*转换为*rvalues*。这使得编译器选择目标对象的移动赋值运算符，而不是复制赋值运算符。对于许多复杂对象，这样做*性能*更好，但*破坏*了源对象。
- en: Sorting containers
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序容器
- en: Sorting values is quite a standard task, and it can be done in various ways.
    Every computer science student who was tortured with having to learn a majority
    of existing sorting algorithms (together with their performance and stability
    trade-offs for exams) knows that.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对值进行排序是一个相当标准的任务，可以用多种方式完成。每个被迫学习大多数现有排序算法（以及它们的性能和稳定性权衡）的计算机科学学生都知道这一点。
- en: Because this is a solved problem, programmers should not waste their time in
    solving it *again*, except if it is for learning purposes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一个解决的问题，程序员不应该浪费时间再次解决它，除非是为了学习目的。
- en: How to do it...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we are going to play with `std::sort` and `std::partial_sort`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用`std::sort`和`std::partial_sort`：
- en: 'First, we include all that''s necessary and declare that we use the `std` namespace:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们包括所有必要的内容，并声明我们使用`std`命名空间：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will print the state of a vector of integers multiple times, so let''s abbreviate
    this task by writing a small procedure:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将多次打印整数向量的状态，因此让我们通过编写一个小程序来简化这个任务：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We begin with a vector that contains some example numbers:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从一个包含一些示例数字的向量开始：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Because we will shuffle the vector multiple times in order to play with different
    sort functions, we need a random number generator:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们将多次对向量进行洗牌，以便使用不同的排序函数，所以我们需要一个随机数生成器：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `std::is_sorted` function tells us if the content of a container is sorted.
    This line should print `1`:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::is_sorted`函数告诉我们容器的内容是否已排序。这行应该打印`1`：'
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With `std::shuffle`, we shake around the content of the vector in order to
    sort it again later. The first two arguments denote the range that will be shuffled
    and the third argument is the random number generator:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`std::shuffle`，我们摇动向量的内容，以便稍后再次对其进行排序。前两个参数表示将被洗牌的范围，第三个参数是随机数生成器：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `is_sorted` function should now return `false` so that `0` is printed,
    and the values in the vector should be the same but in a different order. We will
    see after we have printed both again to the shell:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`is_sorted`函数现在应该返回`false`，以便打印`0`，向量中的值应该相同，但顺序不同。我们将在将它们再次打印到shell后看到：'
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we reestablish the original item ordering by using `std::sort`. The same
    prints to the terminal should now again give us the sorted ordering from the beginning:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用`std::sort`重新建立原始项目排序。现在，终端上的相同打印应该再次给我们从一开始的排序顺序：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Another interesting function is `std::partition`. Maybe, we do not want to
    fully sort the list because it is sufficient to just have the items that are smaller
    than some value at the front. So, let''s *partition* the vector in order to move
    all the items that are smaller than `5` to the front and print it:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个有趣的函数是`std::partition`。也许，我们不想完全对列表进行排序，因为只需将小于某个值的项目放在前面就足够了。因此，让我们*分区*向量，以便将所有小于`5`的项目移到前面并打印它：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The next sort-related function is `std::partial_sort`. We can use it to sort
    the content of a container, but only to some extent. It will put the `N` smallest
    of all vector elements in the first half of the vector in a sorted order. The
    rest will reside in the second half, which will not be sorted:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个与排序相关的函数是`std::partial_sort`。我们可以使用它来对容器的内容进行排序，但只能在某种程度上。它将所有向量元素中的`N`个最小元素放在向量的前半部分，并按排序顺序排列。其余的将驻留在第二半部分，不会排序：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'What if we want to sort a data structure that has *no* comparison operator?
    Let''s define one and make a vector of such items:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想对没有比较运算符的数据结构进行排序怎么办？让我们定义一个并创建这样项目的向量：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `std::sort` function optionally accepts a comparison function as its third
    argument. Let''s use that and provide it with such a function. Just to show that
    this is possible, we compare them by their *second* field, `b`. This way, they
    will appear in the order of `mystruct::b` and not `mystruct::a`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::sort`函数可选地接受一个比较函数作为其第三个参数。让我们使用它，并提供一个这样的函数。只是为了显示这是可能的，我们通过它们的*第二*字段`b`进行比较。这样，它们将按照`mystruct::b`的顺序而不是`mystruct::a`的顺序出现：'
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The last step is printing the sorted vector of `mystruct` items:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是打印排序后的`mystruct`项目向量：
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Let's compile and run our program.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编译并运行我们的程序。
- en: The first `1` results from the `std::is_sorted` call after initializing the
    sorted vector. Then, we shuffled the vector and got a `0` from the second `is_sorted`
    call. The third line shows all the vector items after the shuffling. The next
    `1` is the result of the `is_sorted` call after sorting it again with `std::sort`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`1`是在初始化排序向量后对`std::is_sorted`的调用的结果。然后，我们洗牌了向量，并从第二个`is_sorted`调用中得到了`0`。第三行显示了洗牌后的所有向量项目。下一个`1`是使用`std::sort`再次对其进行排序后的`is_sorted`调用的结果。
- en: Then, we shuffled the whole vector again and *partitioned* it using `std::partition`.
    We can see that all the items that are less than `5` are also to the left of `5`
    in the vector. All items that are greater than `5` are to its right. Apart from
    that, they seem shuffled.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们再次洗牌整个向量，并使用`std::partition`进行*分区*。我们可以看到所有小于`5`的项目也在向量中的`5`的左边。所有大于`5`的项目在其右边。除此之外，它们似乎被洗牌了。
- en: The second last line shows the result of `std::partial_sort`. All items up to
    the middle appear strictly sorted but the rest do not.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 倒数第二行显示了`std::partial_sort`的结果。直到中间的所有项目都严格排序，但其余的没有。
- en: 'In the last line, we can see our vector of `mystruct` instances. They are strictly
    sorted by their *second* member values:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行，我们可以看到我们的`mystruct`实例向量。它们严格按照它们的*第二*成员值排序：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We have used different algorithms, which have to do with sorting:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了与排序有关的不同算法：
- en: '| **Algorithm** | **Purpose** |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| **算法** | **目的** |'
- en: '| `std::sort` | Accepts a range as arguments and simply sorts it. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `std::sort` | 接受一个范围作为参数并简单地对其进行排序。'
- en: '| `std::is_sorted` | Accepts a range as argument and tells *if* that range
    is sorted. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '`std::is_sorted` | 接受一个范围作为参数，并告诉*是否*该范围已排序。'
- en: '| `std::shuffle` | This is, kind of, the *reverse* operation to sorting; it
    accepts a range as arguments and *shuffles* its items around. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `std::shuffle` | 这在某种程度上是与排序相反的操作；它接受一个范围作为参数并*洗牌*其项目。|'
- en: '| `std::partial_sort` | Accepts a range as arguments and another iterator,
    which tells until where the input range should be sorted. Behind that iterator,
    the rest of the items appear unsorted. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `std::partial_sort` | 接受一个范围作为参数和另一个迭代器，告诉输入范围应排序到哪里。在该迭代器后面，其余项目将未排序。'
- en: '| `std::partition` | Accepts a range and a *predicate function*. All items
    for which the predicate function returns `true` are moved to the front of the
    range. The rest is moved to the back. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `std::partition` | 接受一个范围和一个*谓词函数*。谓词函数返回`true`的所有项目都移动到范围的前面。其余的移动到后面。|'
- en: For objects that do not have a comparison operator `<` implementation, it is
    possible to provide custom comparison functions. These should always have a signature
    such as `bool function_name(const T &lhs, const T &rhs)` and should not have any
    side effects during execution.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有比较运算符`<`实现的对象，可以提供自定义比较函数。这些函数应该始终具有`bool function_name(const T &lhs, const
    T &rhs)`这样的签名，并且在执行过程中不应该有任何副作用。
- en: There are also other algorithms such as `std::stable_sort`, which also sort
    but preserve the order of items with the same sort key and `std::stable_partition`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他算法，比如`std::stable_sort`，它也可以排序，但保留具有相同排序键的项目的顺序，以及`std::stable_partition`。
- en: '`std::sort` has different implementations for sorting. Depending on the nature
    of the iterator arguments, it is implemented as selection sort, insertion sort,
    merge sort, or completely optimized for a smaller number of items. On the user
    side, we usually do not even need to care.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::sort`有不同的实现用于排序。根据迭代器参数的性质，它被实现为选择排序，插入排序，归并排序，或者完全针对较少数量的项目进行优化。在用户端，我们通常甚至不需要关心。'
- en: Removing specific items from containers
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从容器中删除特定项目
- en: Copying, transforming, and filtering are perhaps the most common operations
    on ranges of data. In this section, we concentrate on filtering items.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 复制，转换和过滤可能是数据范围上最常见的操作。在本节中，我们集中在过滤项目上。
- en: Filtering items out of data structures, or simply removing specific ones, works
    completely differently for different data structures. In linked lists (such as
    `std::list`), for example, a node can be removed by making its predecessor point
    to its successor. After a node is removed from the link chain in this way, it
    can be given back to the allocator. In contiguously storing data structures (`std::vector`,
    `std::array`, and, to some extent, `std::deque`), items can only be removed by
    overwriting them with other items. If an item slot is marked to be removed, all
    the items that are behind it must be moved one slot further to the front in order
    to fill the gap. This sounds like a lot of hassle, but if we want to simply remove
    whitespace from a string, for example, this should be achievable without much
    code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据结构中过滤项目，或者简单地删除特定项目，对于不同的数据结构来说完全不同。例如，在链表中（如`std::list`），可以通过使其前驱指向其后继来删除节点。以这种方式从链接链中删除节点后，可以将其返回给分配器。在连续存储数据结构（`std::vector`，`std::array`，以及在某种程度上`std::deque`）中，只能通过用其他项目覆盖它们来删除项目。如果标记要删除的项目槽，那么在它后面的所有项目必须向前移动一个槽，以填补空白。这听起来很麻烦，但是如果我们想要从字符串中简单地删除空格，这应该可以在不多的代码的情况下实现。
- en: When having either data structure at hand, we do not really want to care *how*
    to remove an item. It should just happen. This is what `std::remove` and `std::remove_if`
    can do for us.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当手头有任何一种数据结构时，我们实际上并不想关心如何删除一个项目。它应该只是发生。这就是`std::remove`和`std::remove_if`可以为我们做的事情。
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will transform a vector''s content by removing items in different ways:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过不同的方式删除向量的内容：
- en: 'Let''s import all the needed headers and declare that we use the `std` namespace:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入所有需要的头文件，并声明我们使用`std`命名空间：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'A short print helper function will print our vector:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个简短的打印辅助函数将打印我们的向量：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We''ll begin with an example vector containing some simple integer values.
    We''ll also print it, so we can see how it changes with the function we apply
    to it later:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从一个包含一些简单整数值的示例向量开始。我们也会打印它，这样我们就可以看到它在稍后应用于它的函数中如何改变：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now let''s remove all the items with the value `2` from the vector. `std::remove`
    moves the other items in a way that the one value `2` we actually have in the
    vector vanishes. Because the vector''s actual content is shorter after removing
    items, `std::remove` returns us an iterator pointing to the *new end*. The items
    between the new end iterator and the old end iterator are to be considered garbage,
    so we tell the vector to *erase* them. We surround the two removal lines with
    a new scope because the `new_end` iterator is invalidated afterward anyway, so
    it can go out of scope immediately:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们从向量中删除值为`2`的所有项目。`std::remove`以一种使实际上在向量中消失的值`2`的方式移动其他项目。因为在删除项目后向量的实际内容变短了，`std::remove`会返回一个指向*新结尾*的迭代器。新结尾迭代器和旧结尾迭代器之间的项目应被视为垃圾，因此我们告诉向量*擦除*它们。我们将两行删除代码放在一个新的作用域中，因为`new_end`迭代器在之后无论如何都会失效，所以它可以立即超出作用域：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now let''s remove all the *odd* numbers. In order to do so, we implement a
    predicate, which tells us if a number is odd and feed it into the `std::remove_if`
    function, which accepts such predicates:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们删除所有*奇数*。为了做到这一点，我们实现一个谓词，告诉我们一个数字是否是奇数，并将其输入到`std::remove_if`函数中，该函数接受这样的谓词：
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The next algorithm we try out is `std::replace`. We use it to overwrite all
    values of `4` with the value `123`. The `std::replace` function also exists as
    `std::replace_if`, which also accepts predicate functions:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们尝试的下一个算法是`std::replace`。我们使用它来用值`123`覆盖所有值为`4`的值。`std::replace`函数也存在为`std::replace_if`，它也接受谓词函数：
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s pump completely new values into the vector and create two new empty
    vectors in order to do another experiment with those:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们完全将新值注入向量，并创建两个新的空向量，以便对它们进行另一个实验：
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, we implement a predicate for odd numbers again and another predicate
    function, which tells the opposite if a number is even:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们再次实现一个奇数的谓词和另一个谓词函数，告诉我们一个数字是否是偶数：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The next two lines do exactly the same thing. They copy *even* values to the
    vectors, `v2` and `v3`. The first line does this with the `std::remove_copy_if`
    algorithm, which copies everything from a source container to another container
    which does *not* fulfill the predicate constraint. The other line uses `std::copy_if`,
    which copies everything that *does* fulfill the predicate constraint:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的两行做了完全相同的事情。它们将*偶数*值复制到向量`v2`和`v3`。第一行使用`std::remove_copy_if`算法，它将来自源容器的所有内容复制到另一个容器，该容器不满足谓词约束。另一行使用`std::copy_if`，它复制满足谓词约束的所有内容：
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Printing both the vectors should now result in the same output:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打印这两个向量应该得到相同的输出：
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Let's compile and run the program. The first output line shows the vector after
    its initialization. The second line shows it after removing all the values of
    `2`. The next line shows the result of removing all the odd numbers. Before the
    fourth line, we replaced all the values of `4` with `123`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编译并运行程序。第一行输出显示了向量在初始化后的状态。第二行显示了删除所有值为`2`后的状态。下一行显示了删除所有奇数后的结果。在第四行之前，我们用`123`替换了所有值为`4`的值。
- en: 'The last two lines show vectors `v2` and `v3`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两行显示了向量`v2`和`v3`：
- en: '[PRE36]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We have used different algorithms, which have to do with filtering:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了不同的算法，这些算法与过滤有关：
- en: '| **Algorithm** | **Purpose** |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| **算法** | **目的** |'
- en: '| `std::remove` | Accepts a range and a value as arguments and removes any
    occurrence of the value. Returns a new end iterator of the modified range. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `std::remove` | 接受范围和值作为参数，并删除该值的任何出现。返回修改后范围的新结束迭代器。'
- en: '| `std::replace` | Accepts a range and two values as arguments and replaces
    all the occurrences of the first value with the second value. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `std::replace` | 接受范围和两个值作为参数，并用第二个值替换所有第一个值的出现。'
- en: '| `std::remove_copy` | Accepts a range, an output iterator, and a value as
    arguments and copies all the values that are *not* equal to the given value from
    the range to the output iterator. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `std::remove_copy` | 接受范围、输出迭代器和值作为参数，并将不等于给定值的所有值从范围复制到输出迭代器。'
- en: '| `std::replace_copy` | Works similar to `std::replace` but analogous to `std::remove_copy`.
    The source range is not altered. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '`std::replace_copy`工作原理类似于`std::replace`，但类似于`std::remove_copy`。源范围不会被改变。'
- en: '| `std::copy_if` | Works like `std::copy` but additionally accepts a predicate
    function as an argument in order to copy only the values that the predicate accepts,
    which makes it a *filter* function. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `std::copy_if` | 类似于`std::copy`，但还接受谓词函数作为参数，以便仅复制谓词接受的值，这使它成为一个*过滤*函数。'
- en: For every one of the listed algorithms, there also exists an `*_if` version,
    which accepts a predicate function instead of a value, which then decides which
    values are to be removed or replaced.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于列出的每个算法，还存在一个`*_if`版本，它接受谓词函数而不是值，然后决定要删除或替换哪些值。
- en: Transforming the contents of containers
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换容器的内容
- en: If `std::copy` is the simplest STL algorithm for application on ranges, `std::transform`
    is the second simplest STL algorithm. Just as `copy`, it copies items from one
    range to another but additionally accepts a transformation function. This transformation
    function can alter the value of the input type before it is assigned to an item
    in the destination range. Furthermore, it can even construct a completely different
    type, which is useful if the source range and destination range differ in their
    payload item types. It is simple to use but still very useful, which makes it
    an ordinary standard component used in portable day-to-day programs.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`std::copy`是应用于范围的最简单的STL算法，那么`std::transform`就是第二简单的STL算法。就像`copy`一样，它将项目从一个范围复制到另一个范围，但还接受一个转换函数。这个转换函数可以在分配给目标范围中的项目之前改变输入类型的值。此外，它甚至可以构造一个完全不同的类型，这在源范围和目标范围的有效负载项目类型不同的情况下非常有用。它很简单但仍然非常有用，这使得它成为可移植日常程序中使用的普通标准组件。
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'In this section, we are going to use `std::transform` in order to modify the
    items of a vector while copying them:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用`std::transform`来修改向量的项目并将它们复制：
- en: 'As always, we first need to include all the necessary headers and to spare
    us some typing, we declare that we use the `std` namespace:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与往常一样，我们首先需要包含所有必要的头文件，并为了节省一些输入，声明我们使用`std`命名空间：
- en: '[PRE37]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'A vector with some simple integers will do the job as an example source data
    structure:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个包含一些简单整数的向量将作为示例源数据结构：
- en: '[PRE38]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we copy all the items to an `ostream_iterator` adapter in order to print
    them. The `transform` function accepts a function object, which accepts items
    of the container payload type and transforms them during each copy operation.
    In this case, we calculate the *square* of each number item, so the code will
    print the squares of the items in the vector without us having to store them anywhere:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将所有项目复制到`ostream_iterator`适配器中以进行打印。`transform`函数接受一个函数对象，该函数对象在每次复制操作期间接受容器有效负载类型的项目并对其进行转换。在这种情况下，我们计算每个数字项目的*平方*，因此代码将打印向量中项目的平方，而无需将它们存储在任何地方：
- en: '[PRE39]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s do another transformation. From the number `3`, for example, we could
    generate a nicely readable string such as `3^2 = 9`. The following `int_to_string`
    function object does just that using the `std::stringstream` object:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们进行另一个转换。例如，从数字`3`，我们可以生成一个易于阅读的字符串，如`3^2 = 9`。以下的`int_to_string`函数对象就是使用`std::stringstream`对象实现了这一点：
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The function we just implemented returns us string values from integer values.
    We could also say it *maps* from integers to strings. Using the `transform` function,
    we can copy all such mappings from the integer vector into a string vector:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们刚刚实现的函数从整数值返回字符串值。我们还可以说它从整数到字符串的*映射*。使用`transform`函数，我们可以将所有这样的映射从整数向量复制到字符串向量中：
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After printing those, we''re done:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印完这些之后，我们就完成了：
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let''s compile and run the program:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编译并运行程序：
- en: '[PRE43]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works...
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `std::transform` function works exactly like `std::copy` but while copy-assigning
    the values from the source iterator to the destination iterator, it applies the
    user-provided transformation function to the value before assigning the result
    to the destination iterator.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::transform`函数的工作方式与`std::copy`完全相同，但在将源迭代器的值复制分配到目标迭代器时，它会在将结果分配给目标迭代器之前应用用户提供的转换函数到该值。'
- en: Finding items in ordered and unordered vectors
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在有序和无序向量中查找项目
- en: Often, we need to tell *if* some kind of item exists within some range. And
    if it does, we often also need to modify it or to access other data associated
    with it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们需要告诉*是否*某种类型的项目存在于某个范围内。如果存在，我们通常还需要修改它或访问与之关联的其他数据。
- en: There are different strategies for finding items. If the items are present in
    a sorted order, then we can do a binary search, which is faster than linearly
    going through the items one by one. If it is not sorted, we are stuck with linear
    traversal again.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的策略来查找项目。如果项目按排序顺序出现，那么我们可以进行二进制搜索，这比逐个遍历项目要快。如果没有排序，我们又被困在线性遍历中。
- en: The typical STL search algorithms can do both for us, so it's good to know them
    and their characteristics. This section is about the simple linear search algorithm
    `std::find`, the binary search version `std::equal_range`, and their variants.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的STL搜索算法都可以为我们做这两件事，因此了解它们及其特性是很好的。本节介绍了简单的线性搜索算法`std::find`，二进制搜索版本`std::equal_range`及其变体。
- en: How to do it...
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we are going to use linear and binary search algorithms on
    a small example data set:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在一个小例子数据集上使用线性和二进制搜索算法：
- en: 'We first include all the necessary headers and declare that we use the `std`
    namespace:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先包括所有必要的头文件，并声明我们使用`std`命名空间：
- en: '[PRE44]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Our data set will consist of `city` structs, which just save a city''s name,
    and its population count:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的数据集将由`city`结构组成，它只保存城市的名称和人口数量：
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Search algorithms need to be able to compare one item to the other, so we overload
    the `==` operator for the `city` struct instances:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索算法需要能够将一个项目与另一个项目进行比较，因此我们为`city`结构实例重载了`==`运算符：
- en: '[PRE46]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We also want to print the `city` instances, so we overload the stream operator,
    `<<`:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还想打印`city`实例，因此我们重载了流运算符`<<`：
- en: '[PRE47]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Search functions typically return iterators. These iterators point to the item
    if they found it or, otherwise, to the end iterator of the underlying container.
    In the last case, we are not allowed to access such an iterator. Because we are
    going to print our search results, we implement a function that returns us another
    function object, which encapsulates the end iterator of a data structure. When
    used for printing, it will compare its iterator argument against the end iterator
    and then print the item or, otherwise, just `<end>`:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索函数通常返回迭代器。这些迭代器指向找到的项目，否则指向底层容器的结束迭代器。在最后一种情况下，我们不允许访问这样的迭代器。因为我们将打印我们的搜索结果，我们实现了一个函数，它返回另一个函数对象，该函数对象封装了数据结构的结束迭代器。在用于打印时，它将比较其迭代器参数与结束迭代器，然后打印项目，否则只是`<end>`：
- en: '[PRE48]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We start with an example vector of some German cities:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从一些德国城市的示例向量开始：
- en: '[PRE49]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Using this helper, we build a city printer function, which captures the end
    iterator of our city vector `c`:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个帮助程序，我们构建了一个城市打印函数，它捕获了我们城市向量`c`的结束迭代器：
- en: '[PRE50]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We use `std::find` to find the item in the vector, which saves the city item
    of Cologne. At first, this search looks pointless because we get exactly the item
    we searched for. But we did not know its position in the vector before, and the
    `find` function returns us just that. However, we could, for example, make the
    operator `==` of the `city` struct that we overloaded only compare the city name,
    then we could search just using the city name, without even knowing its population.
    But that would not be a good design. In the next step, we will do it differently:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`std::find`在向量中查找项目，该项目保存了科隆的城市项目。起初，这个搜索看起来毫无意义，因为我们确切地得到了我们搜索的项目。但是在此之前，我们不知道它在向量中的位置，`find`函数只返回了这一点。然而，我们可以，例如，使我们重载的`city`结构的`==`运算符只比较城市名称，然后我们可以只使用城市名称进行搜索，甚至不知道它的人口。但这不是一个好的设计。在下一步中，我们将以不同的方式进行：
- en: '[PRE51]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Without knowing the population count of a city, and also without tampering
    with its `==` operator, we can search only by comparing its name with the vector''s
    content. The `std::find_if` function accepts a predicate function object instead
    of a specific value. This way, we can search for the Cologne city item when we
    only know its name:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不知道城市的人口数量，也不干扰其`==`运算符的情况下，我们只能通过比较其名称与向量的内容来搜索。`std::find_if`函数接受一个谓词函数对象，而不是特定的值。这样，我们可以在只知道其名称的情况下搜索科隆市的项目：
- en: '[PRE52]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In order to make searching a bit prettier and expressive, we can implement
    predicate builders. The `population_higher_than` function object accepts a population
    size and returns us a function that tells if a `city` instance has a larger population
    than the captured value. Let''s use it to search for a German city with more than
    two million inhabitants in our small example set. Within the given vector, that
    city is only Berlin:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使搜索更加美观和表达力强，我们可以实现谓词构建器。`population_higher_than`函数对象接受一个人口规模，并返回一个告诉我们`city`实例是否比捕获的值具有更大人口的函数。让我们使用它来搜索我们小例子集中拥有两百万以上居民的德国城市。在给定的向量中，那个城市只有柏林：
- en: '[PRE53]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The search functions we just used, traverse our containers linearly. Thus they
    have a runtime complexity of *O(n)*. The STL also has binary search functions,
    which work within *O(log(n))*. Let''s generate a new example data set, which just
    consists of some integer values, and build another `print` function for that:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们刚刚使用的搜索函数遍历了我们的容器。因此它们的运行时复杂度为*O(n)*。STL还有二进制搜索函数，它们在*O(log(n))*内工作。让我们生成一个新的例子数据集，它只包含一些整数值，并为此构建另一个`print`函数：
- en: '[PRE54]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `std::binary_search` function returns boolean values and just tells us
    *if* it found an item, but it does *not* return the item itself. It is important
    that the container we are searching in is *sorted* because otherwise, binary search
    doesn''t work correctly:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::binary_search`函数返回布尔值，只告诉我们*是否*找到了一个项目，但它*不*返回项目本身。重要的是，我们正在搜索的容器是*排序*的，否则，二进制搜索就无法正确工作：'
- en: '[PRE55]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In order to get the items we are searching for, we need other STL functions.
    One of them is `std::equal_range`. It does not return an iterator for the item
    we found, but a *pair* of iterators. The first iterator points to the first item
    that is *not smaller* than the value we''ve been looking for. The second iterator
    points to the first item that is *larger* than it. In our range, which goes from
    `1` to `10`, the first iterator points to the actual `7`, because it is the first
    item, that is not smaller than `7`. The second iterator points to the `8` because
    it''s the first item that is larger than `7`. If we had multiple values of `7`,
    both the iterators would, in fact, represent a *subrange* of items:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了得到我们正在搜索的项目，我们需要其他STL函数。其中之一是`std::equal_range`。它不返回我们找到的项目的迭代器，而是一对迭代器。第一个迭代器指向第一个不小于我们正在寻找的值的项目。第二个迭代器指向第一个大于它的项目。在我们的范围内，从`1`到`10`，第一个迭代器指向实际的`7`，因为它是第一个不小于`7`的项目。第二个迭代器指向`8`，因为它是第一个大于`7`的项目。如果我们有多个值为`7`，那么这两个迭代器实际上代表*项目的子范围*：
- en: '[PRE56]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If we just need one iterator; we can use `std::lower_bound` or `std::upper_bound`.
    The `lower_bound` function only returns an iterator to the first item that is
    not smaller than what we searched. The `upper_bound` function returns an iterator
    to the first item that is larger than what we searched for:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们只需要一个迭代器；我们可以使用`std::lower_bound`或`std::upper_bound`。`lower_bound`函数只返回一个迭代器，指向第一个不小于我们搜索的项目。`upper_bound`函数返回一个迭代器，指向第一个大于我们搜索的项目：
- en: '[PRE57]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let''s compile and run the program to see if the output matches our assumptions:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编译并运行程序，看看输出是否符合我们的假设：
- en: '[PRE58]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: How it works...
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'These are the search algorithms we have used in this recipe:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们在这个配方中使用的搜索算法：
- en: '| **Algorithm** | **Purpose** |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| **算法** | **目的** |'
- en: '| `std::find` | Accepts a search range and a comparison value as arguments.
    Returns an iterator that points to the first item equal to the comparison value.
    Searches linearly. |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `std::find` | 接受搜索范围和比较值作为参数。返回一个指向与比较值相等的第一个项目的迭代器。进行线性搜索。|'
- en: '| `std::find_if` | Works like `std::find` but uses a predicate function instead
    of a comparison value. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `std::find_if` | 类似于`std::find`，但使用谓词函数而不是比较值。|'
- en: '| `std::binary_search` | Accepts a search range and a comparison value as arguments.
    Performs a binary search and returns `true` if the range contains that value.
    |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `std::binary_search` | 接受搜索范围和比较值作为参数。执行二进制搜索，如果范围包含该值，则返回`true`。|'
- en: '| `std::lower_bound` | Accepts a search range and a comparison value, and then
    performs a binary search for the first item that is *not smaller* than the comparison
    value. Returns an iterator pointing to that item. |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `std::lower_bound` | 接受搜索范围和比较值，然后对第一个*不小于*比较值的项目执行二进制搜索。返回指向该项目的迭代器。|'
- en: '| `std::upper_bound` | Works like `std::lower_bound` but returns an iterator
    to the first item that is *larger* than the comparison value. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `std::upper_bound` | 类似于`std::lower_bound`，但返回一个指向第一个*大于*比较值的项目的迭代器。|'
- en: '| `std::equal_range` | Accepts a search range and a comparison value and, then,
    returns a pair of iterators. The first iterator is the result of `std::lower_bound`
    and the second iterator is the result of `std::upper_bound`. |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `std::equal_range` | 接受搜索范围和比较值，然后返回一对迭代器。第一个迭代器是`std::lower_bound`的结果，第二个迭代器是`std::upper_bound`的结果。|'
- en: All these functions accept custom comparison functions as an optional additional
    argument. This way, the search can be customized, as we did in the recipe.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数都接受自定义比较函数作为可选的附加参数。这样，搜索可以被定制，就像我们在配方中所做的那样。
- en: 'Let''s have a closer look at how `std::equal_range` works. Imagine that we
    have a vector, `v = {0, 1, 2, 3, 4, 5, 6, 7, 7, 7, 8}`, and call `equal_range(begin(v),
    end(v), 7);` in order to perform a binary search for the value `7`. As `equal_range`
    returns us a pair of lower bound and upper bound iterators, these should afterward
    denote the range `{7, 7, 7}`, as there are so many values of `7` in the sorted
    vector. Check out the following diagram for more clarity:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看`std::equal_range`是如何工作的。假设我们有一个向量，`v = {0, 1, 2, 3, 4, 5, 6, 7, 7,
    7, 8}`，并调用`equal_range(begin(v), end(v), 7);`来对值`7`执行二进制搜索。由于`equal_range`给我们返回了一个下界和一个上界迭代器的一对，因此这些之后应该表示范围`{7,
    7, 7}`，因为在排序向量中有这么多值为`7`。查看以下图表以获得更清晰的解释：
- en: '![](img/8e00c5a5-38e8-4902-95ad-566642ea317b.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e00c5a5-38e8-4902-95ad-566642ea317b.png)'
- en: At first, `equal_range` uses the typical binary search approach until it trips
    into the range of values *not smaller* than the search value. Then, it splits
    up to a `lower_bound` call and an `upper_bound` call in order to bundle their
    return values in a pair as the return value.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`equal_range`使用典型的二进制搜索方法，直到它遇到*不小于*搜索值的值范围。然后，它分成一个`lower_bound`调用和一个`upper_bound`调用，以将它们的返回值捆绑成一对作为返回值。
- en: 'In order to get a binary search function, which just returns the first item
    that fits the requirements, we could implement the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到一个二进制搜索函数，它只返回符合要求的第一个项目，我们可以实现以下内容：
- en: '[PRE59]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This function uses `std::lower_bound` in order to find the first item not smaller
    than `value`. The resulting `potential_match` can then have three different cases
    it points to:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数使用`std::lower_bound`来找到第一个不小于`value`的项目。然后，得到的`potential_match`可以指向三种不同的情况：
- en: No item is not smaller than `value`. In this case, it is identical to `end_it`.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有项目比`value`小。在这种情况下，它与`end_it`相同。
- en: The first item that is not smaller than `value` is also *larger* than `value`.
    Therefore we must signal that we did *not* find it by returning `end_it`.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个不小于`value`的项目也*大于*`value`。因此，我们必须通过返回`end_it`来表示我们*没有*找到它。
- en: The item that `potential_match` points to is equal to `value`. So, it is not
    only a *potential* match, but it is an *actual* match. Therefore we can return
    it.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`potential_match`指向的项目等于`value`。因此，它不仅是一个*potential*匹配，而且是一个*actual*匹配。因此我们可以返回它。'
- en: If our type `T` does not support the `==` operator, it must at least support
    the `<` operator for the binary search. Then, we can rewrite the comparison to
    `!(value < *potential_match) && !(*potential_match < value)`. If it is neither
    smaller, nor larger, then it must be equal.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的类型`T`不支持`==`运算符，那么它至少必须支持二分搜索的`<`运算符。然后，我们可以将比较重写为`!(value < *potential_match)
    && !(*potential_match < value)`。如果既不小也不大，那么它必须相等。
- en: One potential reason why the STL does not provide such a function out of the
    box is the missing knowledge about the possibility that there are multiple hits,
    as in the diagram where we have multiple values of `7`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: STL没有提供这样一个函数的一个潜在原因是缺乏关于可能存在多个命中的可能性的知识，就像在我们有多个值为`7`的图表中一样。
- en: Note that data structures such as `std::map`, `std::set`, and so on have their
    *own* `find` functions. These are, of course, faster than the more general algorithms
    because they are tightly coupled with the data structure's implementation and
    data representation.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，诸如`std::map`、`std::set`等的数据结构都有它们*自己的*`find`函数。当然，这些函数比更通用的算法更快，因为它们与数据结构的实现和数据表示紧密耦合。
- en: Limiting the values of a vector to a specific numeric range with std::clamp
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用std::clamp将向量的值限制在特定的数值范围内
- en: In a lot of applications, we get numeric data from somewhere. Before we can
    plot or otherwise process it, it may need to be normalized because the values
    differ randomly far from each other.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多应用程序中，我们从某处获得数值数据。在我们可以绘制或以其他方式处理它之前，可能需要对其进行归一化，因为这些值之间的差异可能是随机的。
- en: Usually, this would mean a little `std::transform` call over the data structure
    that holds all these values, combined with a simple *scaling* function. But if
    we *do not know* how large or small the values are, we need to go through the
    data first in order to find the right *dimensions* for the scaling function.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这意味着对保存所有这些值的数据结构进行一次小的`std::transform`调用，结合一个简单的*scaling*函数。但是，如果我们*不知道*值有多大或多小，我们需要先通过数据找到合适的*dimensions*来进行缩放函数。
- en: 'The STL contains useful functions for this purpose: `std::minmax_element` and
    `std::clamp`. Using these and combining them with some lambda expression glue,
    we can perform such a task easily.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: STL包含了用于此目的的有用函数：`std::minmax_element`和`std::clamp`。使用这些函数，并将它们与一些lambda表达式粘合在一起，我们可以轻松地执行这样的任务。
- en: How to do it...
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we will normalize the values of a vector from an example numeric
    range to a normalized one in two different ways, one of them using `std::minmax_element`
    and one using `std::clamp`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将以两种不同的方式将向量的值从示例数值范围归一化为归一化范围，其中一种使用`std::minmax_element`，另一种使用`std::clamp`：
- en: 'As always, we first need to include the following headers and declare that
    we use the `std` namespace:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与往常一样，我们首先需要包括以下头文件并声明我们使用`std`命名空间：
- en: '[PRE60]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We implement a function for later use, which accepts the minimum and maximum
    values of a range, and a new maximum so that it can project values from the old
    range to a smaller range that we want to have. The function object takes such
    values and returns another function object, which does exactly that transformation.
    For the sake of simplicity, the new minimum is `0`, so no matter what offset the
    old data had, its normalized values will always be relative to `0`. For the sake
    of readability, we ignore the possibility that `max` and `min` could be of the
    same value, which would lead to a division by zero:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实现了一个供以后使用的函数，它接受范围的最小值和最大值，以及一个新的最大值，以便它可以将旧范围的值投影到我们想要的较小范围。函数对象接受这样的值，并返回另一个函数对象，该函数对象正是进行这种转换。为了简单起见，新的最小值是`0`，因此无论旧数据有什么偏移，其归一化值始终相对于`0`。为了可读性，我们忽略了`max`和`min`可能具有相同值的可能性，这将导致除以零：
- en: '[PRE61]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Another function object builder called `clampval` returns a function object
    that captures the `min` and `max` values and calls `std::clamp` on values with
    those values, in order to limit their values to this range:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个函数对象构建器称为`clampval`返回一个函数对象，该函数对象捕获`min`和`max`值，并在具有这些值的值上调用`std::clamp`，以限制它们的值在此范围内：
- en: '[PRE62]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The data we are going to normalize is a vector of varying values. This could
    be, for example, some kind of heat data, landscape height, or stock prices over
    time:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要归一化的数据是一个包含不同值的向量。例如，这可能是某种热量数据，地形高度或随时间变化的股票价格：
- en: '[PRE63]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In order to be able to normalize the data, we need the *highest* and *lowest*
    values. The `std::minmax_element` function is of a great help here. It returns
    us a pair of iterators to exactly those two values:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够归一化数据，我们需要*最高*和*最低*值。`std::minmax_element`函数在这里非常有帮助。它为我们返回了一个指向这两个值的迭代器对：
- en: '[PRE64]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We will copy all the values from the first vector to a second one. Let''s instantiate
    the second vector and prepare it to accept as many new items as we have in the
    first vector:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将所有值从第一个向量复制到第二个向量。让我们实例化第二个向量，并准备接受与第一个向量中的新项目一样多的新项目：
- en: '[PRE65]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Using `std::transform`, we copy the values from the first vector to the second.
    While copying the items, they will be transformed with our normalization helper.
    The minimum and maximum values of the old vector are `0` and `1000`. The minimum
    and maximum values after normalization are `0` and `255`:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`std::transform`，我们将值从第一个向量复制到第二个向量。在复制项目的同时，它们将使用我们的归一化辅助函数进行转换。旧向量的最小值和最大值分别为`0`和`1000`。归一化后的最小值和最大值分别为`0`和`255`：
- en: '[PRE66]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Before we implement the other normalization strategy, we print what we have
    by now:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们实现另一种归一化策略之前，我们先打印一下我们现在有的东西：
- en: '[PRE67]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We reuse the same normalized vector with the other helper `clampval`, which
    *clamps* the old range to the range with the minimum of `0` and the maximum of
    `255`:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用另一个名为`clampval`的辅助函数重用相同的归一化向量，它*将*旧范围限制为最小值为`0`和最大值为`255`的范围：
- en: '[PRE68]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'After printing these values too, we''re done:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印这些值后，我们就完成了：
- en: '[PRE69]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Let''s compile and run the program. Having the values reduced to values from
    `0` to `255`, we could use them as brightness values for RGB color codes, for
    example:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编译并运行程序。将值减少到`0`到`255`的值，我们可以将它们用作RGB颜色代码的亮度值，例如：
- en: '[PRE70]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'When we plot the data, we get the following graphs. As we can see, the approach
    where we *divide* the values by the difference between the min and max values
    is a linear transformation of the original data. The *clamped* graph loses some
    information. Both variations can be useful in different situations:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们绘制数据时，我们得到以下图表。正如我们所看到的，*将*值除以最小值和最大值之间的差异的方法是原始数据的线性转换。*夹紧*图表丢失了一些信息。不同的情况下，这两种变化都可能有用：
- en: '![](img/f35fa700-2874-4d52-a587-32e53adebcf0.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f35fa700-2874-4d52-a587-32e53adebcf0.png)'
- en: How it works...
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Apart from `std::transform` we used two algorithms:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`std::transform`，我们使用了两种算法：
- en: '`std::minmax_element` simply accepts the begin and end iterators of an input
    range. It loops through the range and records the largest and the smallest element
    on the way to its end. These values are returned in a pair, which we then used
    for our scaling function.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::minmax_element`只接受输入范围的开始和结束迭代器。它遍历范围并记录最大和最小的元素，然后返回这些值的一对，我们用于我们的缩放函数。'
- en: 'The `std::clamp` function, in contrast, does not operate on an iterable range.
    It accepts three values: an input value, a min value, and a max value. The output
    of this function is the input value cut-off in a way that it lies between the
    allowed minimum and maximum. We could also write `max(min_val, min(max_val, x))`
    instead of `std::clamp(x, min_val, max_val)`.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相反，`std::clamp`函数不适用于可迭代范围。它接受三个值：输入值、最小值和最大值。这个函数的输出是输入值被截断，以便它位于允许的最小值和最大值之间。我们也可以写`max(min_val,
    min(max_val, x))`而不是`std::clamp(x, min_val, max_val)`。
- en: Locating patterns in strings with std::search and choosing the optimal implementation
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用std::search在字符串中定位模式并选择最佳实现
- en: Searching for a string in a string is a slightly different problem than finding
    *one* object in a range. On the one hand, a string is, of course, an iterable
    range (of characters) too. On the other hand, finding a string in a string means
    finding a range in *another* range. And this comes along with multiple comparisons
    per potential match position, so we need some other algorithm for that.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串中搜索字符串与在范围中查找*一个*对象是一个略有不同的问题。一方面，字符串当然也是一个可迭代范围（字符）；另一方面，在字符串中查找字符串意味着在*另一个*范围中查找一个范围。这伴随着每个潜在匹配位置的多次比较，因此我们需要一些其他的算法。
- en: '`std::string` already contains a `find` function, which can do exactly what
    we are talking about; nevertheless we''ll concentrate on `std::search` in this
    section. Although `std::search` might be used on strings mostly, it works on all
    kinds of containers. The more interesting feature of `std::search` is that since
    C++17, it has a slightly different additional interface and allows for simply
    exchanging the search algorithm itself. These algorithms are optimized and can
    be freely chosen by the user, depending on what is better in which use case. Additionally,
    we could implement our own search algorithms and plug them into `std::search`
    if we ever come up with anything better than what is already provided.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::string`已经包含一个`find`函数，它可以做我们正在谈论的事情；尽管如此，我们将在本节集中讨论`std::search`。尽管`std::search`可能主要用于字符串，但它适用于所有类型的容器。`std::search`更有趣的特性是，自C++17以来，它具有稍微不同的附加接口，并且允许简单地交换搜索算法本身。这些算法是经过优化的，可以根据使用情况自由选择。此外，如果我们能想出比已提供的更好的东西，我们还可以实现自己的搜索算法并将它们插入`std::search`。'
- en: How to do it...
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will use the new `std::search` function with strings and try its different
    variations with searcher objects:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用新的`std::search`函数与字符串，并尝试其不同的变体与搜索器对象：
- en: 'First, we will include all the necessary headers and declare that we use the
    `std` namespace:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将包括所有必要的标头，并声明我们使用`std`命名空间：
- en: '[PRE71]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We will print substrings from the positions the search algorithm returns to
    us, so let''s implement a little helper for that:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将打印搜索算法返回给我们的位置的子字符串，因此让我们为此实现一个小助手：
- en: '[PRE72]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'A *lorem-ipsum style* string will work as our example string, within which
    we will search a substring. In this case, this is `"elitr"`:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个*lorem-ipsum风格*的字符串将作为我们的示例字符串，我们将在其中搜索一个子字符串。在这种情况下，这是`"elitr"`：
- en: '[PRE73]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The old `std::search` interface accepts the begin/end iterators of the string
    within which we are searching a specific substring and the begin/end iterators
    of the substring. It then returns an iterator pointing to the substring it was
    able to find. If it didn''t find the string, the returned iterator will be the
    end iterator:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旧的`std::search`接口接受我们正在搜索特定子字符串的字符串的开始/结束迭代器以及子字符串的开始/结束迭代器。然后返回一个指向它能够找到的子字符串的迭代器。如果没有找到字符串，返回的迭代器将是结束迭代器：
- en: '[PRE74]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The C++17 version of `std::search` does not accept two pairs of iterators but
    one pair of begin/end iterators and a *searcher* object. The `std::default_searcher`
    takes the begin/end pair of iterators of the substring that we are searching for
    in the larger string:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C++17版本的`std::search`不接受两对迭代器，而是接受一对开始/结束迭代器和一个*searcher*对象。`std::default_searcher`接受我们在较大字符串中搜索的子字符串的开始/结束迭代器对：
- en: '[PRE75]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The point of this change is that it is easy to switch the search algorithm
    this way. The `std::boyer_moore_searcher` uses the *Boyer-Moore search algorithm*
    for a faster search:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种改变的重点是这样很容易切换搜索算法。`std::boyer_moore_searcher`使用*Boyer-Moore搜索算法*进行更快的搜索：
- en: '[PRE76]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The C++17 STL comes with three different searcher object implementations. The
    third one is the B*oyer-Moore-Horspool search algorithm* implementation:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C++17 STL带有三种不同的搜索器对象实现。第三个是B*oyer-Moore-Horspool搜索算法*实现：
- en: '[PRE77]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Let''s compile and run our program. We should see the same string everywhere
    if it runs correctly:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编译并运行我们的程序。如果运行正确，我们应该在任何地方看到相同的字符串：
- en: '[PRE78]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: How it works...
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We utilized four different ways to use `std::search` in order to get exactly
    the same result. Which one should we prefer in what situation?
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了四种不同的方法来使用`std::search`，以获得完全相同的结果。在什么情况下应该使用哪种？
- en: Let's assume our large string within which we search the pattern is called `s`,
    and the pattern is called `p`. Then, `std::search(begin(s), end(s), begin(p),
    end(p));` and `std::search(begin(s), end(s), default_searcher(begin(p), end(p));`
    do exactly the same thing.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在其中搜索模式的大字符串称为`s`，模式称为`p`。然后，`std::search(begin(s), end(s), begin(p), end(p));`和`std::search(begin(s),
    end(s), default_searcher(begin(p), end(p));`做的事情完全一样。
- en: 'The other searcher function objects are implemented with more sophisticated
    search algorithms:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 其他搜索函数对象是使用更复杂的搜索算法实现的。
- en: '`std::default_searcher`: This redirects to legacy `std::search` implementation'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::default_searcher`：这将重定向到传统的`std::search`实现'
- en: '`std::boyer_moore_searcher`: This uses the *Boyer-Moore* search algorithm'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::boyer_moore_searcher`：这使用*Boyer-Moore*搜索算法'
- en: '`std::boyer_moore_horspool_searcher`: This analogously uses the *Boyer-Moore-Horspool*
    algorithm'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::boyer_moore_horspool_searcher`：这类似地使用*Boyer-Moore-Horspool*算法'
- en: 'What makes the other algorithms so special? The Boyer-Moore algorithm was developed
    with a specific idea--the search pattern is compared with the string, beginning
    at the pattern''s *end*, from right to left. If the character in the search string
    *differs* from the character in the pattern at the overlay position and does *not
    even occur* in the pattern, then it is clear that the pattern can be shifted over
    the search string by its *full length*. Have a look at the following diagram,
    where this happens in step 1\. If the character being currently compared differs
    from the pattern''s character at this position but is *contained* by the pattern,
    then the algorithm knows by how many characters the pattern needs to be shifted
    to the right in order to correctly align to at least that character, and then,
    it starts over with the right-to-left comparison. In the diagram, this happens
    in step 2\. This way, the Boyer-Moore algorithm can omit a whole lot of *unnecessary*
    comparisons, compared with a naive search implementation:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 其他算法有什么特别之处？Boyer-Moore算法是根据一个特定的想法开发的——搜索模式与字符串进行比较，从右到左从模式的*末尾*开始。如果搜索字符串中的字符与覆盖位置处模式中的字符*不同*，并且在模式中*甚至不存在*，那么很明显，模式可以通过其*完整长度*移动到搜索字符串上。看一下下面的图表，在步骤1中发生了这种情况。如果当前比较的字符与该位置处模式的字符不同，但*包含*在模式中，则算法知道模式需要向右移动多少个字符才能正确对齐至少该字符，然后，它重新开始右到左的比较。在图表中，这在步骤2中发生。这样，与朴素的搜索实现相比，Boyer-Moore算法可以省略很多*不必要*的比较：
- en: '![](img/2cefec94-bb6d-48ce-af86-cb86df918853.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2cefec94-bb6d-48ce-af86-cb86df918853.png)'
- en: Of course, this would have become the new default search algorithm if it hadn't
    brought its own *trade-offs*. It is faster than the default algorithm, but it
    needs fast lookup data structures in order to determine which characters are contained
    in the search pattern and at which offset they are located. The compiler will
    select differently complex implementations of those, depending on the underlying
    types of which the pattern consists (varying between hash maps for complex types
    and primitive lookup tables for types such as `char`). In the end, this means
    that the default search implementation will be faster if the search string is
    not too large. If the search itself takes some significant time, then the Boyer-Moore
    algorithm can lead to performance gains in the dimension of a *constant factor*.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果它没有带来自己的*权衡*，这将成为新的默认搜索算法。它比默认算法更快，但它需要快速查找数据结构，以确定哪些字符包含在搜索模式中，以及它们位于哪个偏移量。编译器将根据模式由哪些基础类型组成（在复杂类型之间变化为哈希映射，对于`char`等类型的基本查找表）选择不同复杂的实现。最终，这意味着如果搜索字符串不太大，则默认搜索实现将更快。如果搜索本身需要一些显着的时间，那么Boyer-Moore算法可以在*常数因子*的维度上带来性能增益。
- en: The **Boyer-Moore-Horspool** algorithm is a simplification of the Boyer-Moore
    algorithm. It drops the *bad character* rule, which leads to shifts of the whole
    pattern width if a search string character that does not occur in the pattern
    string is found. The trade-off of this decision is that it is *slightly slower*
    than the unmodified version of Boyer-Moore, but it also needs *fewer data structures*
    for its operation.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**Boyer-Moore-Horspool**算法是Boyer-Moore算法的简化。它放弃了*坏字符*规则，这导致整个模式宽度的移位，如果找到一个搜索字符串字符，它在模式字符串中不存在。这个决定的权衡是它比未修改的Boyer-Moore稍慢，但它也需要*更少的数据结构*来进行操作。'
- en: Do not try to *reason* about which algorithm *should* be faster in a specific
    case. Always *measure* the performance of your code with data samples that are
    typical for your users and base your decision on the *results*.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 不要试图*推断*在特定情况下哪种算法*应该*更快。始终使用对您的用户典型的数据样本*测量*代码的性能，并根据*结果*做出决定。
- en: Sampling large vectors
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽样大向量
- en: When there are *very* large amounts of numeric data that need to be processed
    in some situations, it may not be possible to process it all in feasible time.
    In such situations, the data could be *sampled* in order to reduce the total amount
    of data for further processing, which then *speeds up* the whole program. In other
    situations, this might be done not to reduce the amount of work for processing
    but for *saving* or *transferring* the data.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要处理非常大量的数字数据时，在某些情况下，可能无法在可行的时间内处理所有数据。在这种情况下，可以对数据进行*抽样*，以减少进一步处理的总数据量，从而*加快*整个程序。在其他情况下，这可能不是为了减少处理工作量，而是为了*保存*或*传输*数据。
- en: A naive idea of sampling could be to only pick every *N^(th)* data point. This
    might be fine in a lot of cases, but in signal processing, for example, it *could*
    lead to a mathematical phenomenon called **aliasing**. If the distance between
    every sample is varied by a small random offset, aliasing can be reduced. Have
    a look at the following diagram, which shows an *extreme case* just to illustrate
    the point--while the original signal consists of a sine wave, the triangle points
    on the graph are sampling points that are sampled at exactly every *100th* data
    point. Unfortunately, the signal has the *same y-value* at these points! The graph
    which results from connecting the dots looks like a perfectly straight *horizontal
    line*. The square points, however, show what we get when we sample every `100
    + random(-15, +15)` points. Here, the signal still looks very different from the
    original signal, but it is at least not completely *gone* as in the fixed step
    size sampling case.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 抽样的一个天真的想法可能是只选择每第*N*个数据点。在许多情况下这可能是可以的，但在信号处理中，例如，它*可能*会导致一种称为**混叠**的数学现象。如果每个样本之间的距离受到小的随机偏移的影响，混叠可以被减少。看一下下面的图表，它展示了一个*极端情况*，只是为了说明这一点--原始信号由正弦波组成，图表上的三角形点是在每个*100*个数据点处进行抽样的抽样点。不幸的是，这些点的信号在这些点上具有*相同的y值*！然而，方形点显示了当我们抽样每`100
    + random(-15, +15)`个点时我们得到的结果。在这里，信号看起来仍然与原始信号非常不同，但至少不像固定步长抽样情况下完全*消失*。
- en: 'The `std::sample` function does not add random alterations to sample points
    with fixed offset but chooses completely random points; therefore, it works a
    bit differently from this example:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::sample`函数不会对固定偏移的样本点进行随机更改，而是选择完全随机的点；因此，它的工作方式与这个例子有些不同：'
- en: '![](img/9f2aae52-6c69-479c-9d10-af4a807faf4e.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f2aae52-6c69-479c-9d10-af4a807faf4e.png)'
- en: How to do it...
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will sample a very large vector of random data. This random data shows a
    normal distribution. After sampling it, the resulting points should still show
    a normal distribution, which we will check:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对一个非常大的随机数据向量进行抽样。这些随机数据显示正态分布。在对其进行抽样后，结果点应该仍然显示出正态分布，我们将进行检查：
- en: 'First, we need to include everything we use and declare that we use the `std`
    namespace in order to spare us some typing:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要包括我们使用的所有内容，并声明我们使用`std`命名空间，以节省一些输入：
- en: '[PRE79]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'It is easier to play around with the code if we configure specific characteristics
    of our algorithm in their own constant variables. These are the size of the large
    random vector and the number of samples that we are going to take from it:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们在它们自己的常量变量中配置我们算法的特定特征，那么就更容易玩弄代码。这些是大型随机向量的大小和我们将从中获取的样本数量：
- en: '[PRE80]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The large, randomly filled vector should get numbers from a random number generator,
    which gives out numbers from a normal distribution. Any normal distribution can
    be characterized by the mean value and the standard deviation from the mean value:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大型的、随机填充的向量应该从随机数生成器中获得数字，该生成器从正态分布中输出数字。任何正态分布都可以由平均值和与平均值的标准偏差来描述：
- en: '[PRE81]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now, we set up the random generator. First, we instantiate a random device
    and call it once to get a seed for the constructor of a random generator. Then,
    we instantiate a distribution object that applies normal distribution to the random
    output:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们设置随机生成器。首先，我们实例化一个随机设备，并调用它一次以获得用于随机生成器构造函数的种子。然后，我们实例化一个应用正态分布于随机输出的分布对象：
- en: '[PRE82]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now, we instantiate a vector of integers and fill it with a lot of random numbers.
    This is achieved using the `std::generate_n` algorithm, which will call a generator
    function object to feed its return value into our vector using a `back_inserter`
    iterator. The generator function object just wraps around the `d(gen)` expression,
    which gets a random number from the random device and feeds it into the distribution
    object:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们实例化一个整数向量，并用大量随机数填充它。这是通过使用`std::generate_n`算法实现的，该算法将调用一个生成器函数对象，将其返回值馈送到我们的向量中，使用`back_inserter`迭代器。生成器函数对象只是包装在`d(gen)`表达式周围，该表达式从随机设备获取随机数，并将其馈送到分布对象中：
- en: '[PRE83]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now, we instantiate another vector that will contain the much smaller set of
    samples:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们实例化另一个向量，它将包含较小的样本集：
- en: '[PRE84]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The `std::sample` algorithm works similar to `std::copy`, but it takes two
    additional parameters: the *number of samples*, which it shall take from the input
    range, and a *random number generator* object, which it will consult to get random
    sampling positions:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::sample`算法类似于`std::copy`，但它需要两个额外的参数：*样本数量*，它应该从输入范围中获取的样本数量，以及一个*随机数生成器*对象，它将用于获取随机抽样位置：'
- en: '[PRE85]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We''re already done with the sampling. The rest of the code is for displaying
    purposes. The input data has a normal distribution, and if the sampling algorithm
    works well, then the sampled vector should show a normal distribution too. To
    see how much of a normal distribution is left, we will print a *histogram* of
    the values:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经完成了抽样。其余的代码是为了显示目的。输入数据具有正态分布，如果抽样算法运行良好，那么抽样向量应该也显示正态分布。为了查看剩下多少正态分布，我们将打印值的*直方图*：
- en: '[PRE86]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Finally, we loop over all the items in order to print our histogram:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们循环遍历所有项目以打印我们的直方图：
- en: '[PRE87]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'After compiling and running the program, we see that the sampled vector still
    roughly shows the characteristics of a normal distribution:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行程序后，我们看到抽样向量仍然大致显示出正态分布的特征：
- en: '![](img/429739c2-32fd-4b71-8557-d1af399d9b7d.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![](img/429739c2-32fd-4b71-8557-d1af399d9b7d.png)'
- en: How it works...
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的工作原理是...
- en: 'The `std::sample` algorithm is a new algorithm, which came with C++17\. Its
    signature looks like this:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::sample`算法是一个新算法，它随C++17一起推出。它的签名如下：'
- en: '[PRE88]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The input range is denoted by the `first` and `last` iterators, while `out`
    is the output operator. These iterators have exactly the same function as in `std::copy`;
    items are copied from one range to the other. The `std::sample` algorithm is special
    in the regard that it will copy only a part of the input range because it samples
    only `n` items. It uses uniform distribution internally, so every data point in
    the source range gets chosen with the same probability.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 输入范围由`first`和`last`迭代器表示，而`out`是输出操作符。这些迭代器的功能与`std::copy`中的功能完全相同；项从一个范围复制到另一个范围。`std::sample`算法在这方面是特殊的，因为它只会复制输入范围的一部分，因为它只对`n`个项进行抽样。它在内部使用均匀分布，因此源范围中的每个数据点都以相同的概率被选择。
- en: Generating permutations of input sequences
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成输入序列的排列
- en: When testing code that must deal with sequences of inputs where the order of
    the arguments is not important, it is beneficial to test whether it results in
    the same output for *all* possible permutations of that input. Such a test could,
    for example, check whether a self-implemented *sort* algorithm sorts correctly.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试必须处理输入序列的代码时，如果参数的顺序不重要，测试它是否对该输入的*所有*可能的排列产生相同的输出是有益的。例如，这样的测试可以检查自己实现的*排序*算法是否正确排序。
- en: No matter for what reason we need all permutations of some value range, `std::next_permutation`
    can conveniently do it for us. We can invoke it on a modifiable range, and it
    changes the *order* of its items to the next *lexicographical permutation*.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 无论出于什么原因，我们需要某个值范围的所有排列，`std::next_permutation`可以方便地为我们做到这一点。我们可以在可修改的范围上调用它，它会改变其项的*顺序*到下一个*字典序排列*。
- en: How to do it...
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we will write a program that reads multiple word strings from
    a standard input, and then we will use `std::next_permutation` to generate and
    print all the permutations of those strings:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个程序，从标准输入中读取多个单词字符串，然后我们将使用`std::next_permutation`来生成并打印这些字符串的所有排列：
- en: 'First things first again; we include all the necessary headers and declare
    that we use the `std` namespace:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先还是先来一些基础工作；我们包含所有必要的头文件，并声明我们使用`std`命名空间：
- en: '[PRE89]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'We begin with a vector of strings, which we feed with the whole standard input.
    The next step is *sorting* the vector:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从一个字符串向量开始，我们用整个标准输入来填充它。下一步是*排序*向量：
- en: '[PRE90]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Now, we print the vector''s content on the user terminal. Afterward, we call
    `std::next_permutation`. It systematically shuffles the vector to generate a permutation
    of its items, which we then print again. The `next_permutation` will return `false`
    as soon as the *last* permutation was reached:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们在用户终端上打印向量的内容。之后，我们调用`std::next_permutation`。它会系统地洗牌向量以生成其项的排列，然后我们再次打印。当达到*最后*一个排列时，`next_permutation`会返回`false`：
- en: '[PRE91]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Let''s compile and run the function with some example input:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们用一些示例输入编译并运行该函数：
- en: '[PRE92]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: How it works...
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `std::next_permutation` algorithm is a bit weird to use. This is because
    it accepts only a begin/end pair of iterators and then returns `true` if it is
    able to find the next permutation. Otherwise, it returns `false`. But what does
    the *next permutation* even mean?
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::next_permutation`算法使用起来有点奇怪。这是因为它只接受一个迭代器的开始/结束对，然后如果能找到下一个排列就返回`true`。否则，返回`false`。但是*下一个排列*到底是什么意思呢？'
- en: 'The algorithm with which `std::next_permutation` finds the next lexicographical
    order of the items, works as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::next_permutation`用于找到项的下一个字典序排列的算法工作如下：'
- en: Find the largest index `i` such that `v[i - 1] < v[i]`. If there is none, then
    return `false`.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到最大的索引`i`，使得`v[i - 1] < v[i]`。如果没有，则返回`false`。
- en: Now, find the largest index `j` such that `j >= i` and `v[j] > v[i - 1]`.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，找到最大的索引`j`，使得`j >= i`且`v[j] > v[i - 1]`。
- en: '*Swap* the items at position `j` and position `i - 1`.'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在位置`j`和位置`i - 1`交换项。
- en: Reverse the order of the items from position `i` to the end of the range.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反转从位置`i`到范围末尾的项的顺序。
- en: Return `true`.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回`true`。
- en: The individually permuted orders we get out of this will always appear in the
    same sequence. In order to see all the possible permutations, we sorted the array
    first, because if we entered `"c b a"`, for example, the algorithm would terminate
    *immediately*, as this already *is* the last lexicographic order of the elements.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从中得到的各自排列的顺序总是相同的。为了看到所有可能的排列，我们首先对数组进行排序，因为如果我们输入了`"c b a"`，例如，算法会立即终止，因为这已经是元素的最后字典序排列。
- en: Implementing a dictionary merging tool
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现字典合并工具
- en: Imagine that we have a sorted list of things, and someone else comes up with
    *another* sorted list of things, and we want to share the lists with each other.
    The best idea is to combine both the lists. The combination of both the lists
    should be sorted too, as this way, it is easy to look it up for specific items.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们有一个排好序的东西列表，然后另外有人提出了*另一个*排好序的东西列表，我们想要彼此分享这些列表。最好的主意是将这两个列表合并。这两个列表的组合也应该是排好序的，这样，查找特定项就很容易了。
- en: 'Such an operation is also called a **merge**. In order to merge two sorted
    ranges of items, we would intuitively create a new range and feed it with items
    from both the lists. For every item transfer, we would have to compare the frontmost
    items of our input ranges in order to always select the *smallest* one from what
    is left from the input. Otherwise, the output range would not be sorted any longer.
    The following diagram illustrates it better:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的操作也被称为**合并**。为了合并两个排好序的项范围，我们直观地会创建一个新范围，并从两个列表中的项中获取它。对于每个项的转移，我们必须比较输入范围的最前面的项，以便始终选择剩下的输入中的*最小*项。否则，输出范围将不再是排好序的。下面的图示更好地说明了这一点：
- en: '![](img/a6528449-cc62-4b3f-b4bd-1900646d9175.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6528449-cc62-4b3f-b4bd-1900646d9175.png)'
- en: The `std::merge` algorithm can do exactly that for us, so we do not need to
    fiddle around too much. In this section, we will see how to use the algorithm.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::merge`算法可以为我们做到这一点，所以我们不需要太多地摆弄。在本节中，我们将看到如何使用这个算法。'
- en: How to do it...
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We are going to build up a cheap dictionary of one-to-one mappings from English
    words to their German translations, and store them in `std::deque` structures.
    The program will read such a dictionary from a file and one from standard input,
    and print one large merged dictionary on the standard output again.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将建立一个廉价的字典，从英语单词到它们的德语翻译的一对一映射，并将它们存储在`std::deque`结构中。程序将从文件和标准输入中读取这样的字典，并再次在标准输出上打印一个大的合并字典。
- en: 'There are a lot of headers to include this time, and we declare that we use
    the `std` namespace:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次需要包含很多头文件，并且我们声明使用`std`命名空间：
- en: '[PRE93]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'A dictionary entry should consist of a symmetric mapping from a string in one
    language to a string in another language:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个字典条目应该包括从一种语言的字符串到另一种语言的字符串的对称映射：
- en: '[PRE94]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We are going to both print such pairs to the terminal and read them from user
    input, so we need to overload the `<<` and `>>` operators:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将同时将这样的对打印到终端并从用户输入中读取，因此我们需要重载`<<`和`>>`运算符：
- en: '[PRE95]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'A helper function that accepts any input stream object will help us in building
    a dictionary from it. It constructs `std::deque` of dictionary entry pairs, and
    they are all read from the input stream until it is empty. Before returning it,
    we sort it:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个接受任何输入流对象的辅助函数将帮助我们构建一个字典。它构造了一个字典条目对的`std::deque`，并且它们都从输入流中读取，直到输入流为空。在返回之前，我们对它进行排序：
- en: '[PRE96]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'We create two individual dictionary data structures from different input streams.
    One input stream is opened from the `dict.txt` file, which we assume to exist.
    It contains word pairs, line by line. The other stream is the standard input:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从不同的输入流中创建了两个单独的字典数据结构。一个输入流是从`dict.txt`文件中打开的，我们假设它存在。它包含逐行的单词对。另一个流是标准输入：
- en: '[PRE97]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'As the helper function, `from_instream`, has already sorted both the dictionaries
    for us, we can feed them directly into the `std::merge` algorithm. It accepts
    two input ranges via its begin/end iterator pairs, and one output. The output
    will be the user shell:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于辅助函数`from_instream`已经为我们对这两个字典进行了排序，我们可以直接将它们输入`std::merge`算法。它通过它的开始/结束迭代器对接受两个输入范围，并且一个输出。输出将是用户的shell：
- en: '[PRE98]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'We can compile the program now, but before running it, we should create the
    `dict.txt` file with some example content. Let''s fill it with some English words
    and their translations to German:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以编译程序了，但在运行之前，我们应该创建一个`dict.txt`文件，并填充一些示例内容。让我们用一些英语单词和它们的德语翻译来填充它：
- en: '[PRE99]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Now, we can launch the program while piping some English-German translations
    into its standard input. The output is a merged and still sorted dictionary, which
    contains the translations of both the inputs. We could create a new dictionary
    file from that:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以启动程序，同时将一些英语-德语翻译传递给它的标准输入。输出是一个合并且仍然排序的字典，其中包含了两个输入的翻译。我们可以从中创建一个新的字典文件：
- en: '[PRE100]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: How it works...
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `std::merge` algorithm accepts two pairs of begin/end iterators, which denote
    the input ranges. These ranges must be *sorted*. The fifth parameter is an output
    iterator that accepts the incoming items during the merge.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::merge`算法接受两对开始/结束迭代器，表示输入范围。这些范围必须是*排序*的。第五个参数是一个输出迭代器，接受合并过程中传入的项目。'
- en: 'There is also a variant called `std::inplace_merge`. This algorithm does the
    same as the other, but it does not need an output iterator because it works *in
    place*, as the name already suggests. It takes three parameters: a *begin* iterator,
    a *middle* iterator, and an *end* iterator. These iterators must all reference
    data in the same data structure. The middle iterator is at the same time the end
    iterator of the first range, and the begin iterator of the second range. This
    means that this algorithm handles a single range, which actually consists of two
    consecutive ranges, such as, for example, `{A, C, B, D}`. The first subrange is
    `{A, C}` and the second subrange is `{B, D}`. The `std::inplace_merge` algorithm
    can then merge both within the same data structure, which results in `{A, B, C,
    D}`.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种叫做`std::inplace_merge`的变体。这个算法和其他算法一样，但它不需要输出迭代器，因为它是*原地*工作的，正如它的名字所暗示的那样。它接受三个参数：一个*开始*迭代器，一个*中间*迭代器和一个*结束*迭代器。这些迭代器必须都引用相同数据结构中的数据。中间迭代器同时也是第一个范围的结束迭代器，以及第二个范围的开始迭代器。这意味着这个算法处理一个单一范围，实际上包括两个连续的范围，比如，例如`{A,
    C, B, D}`。第一个子范围是`{A, C}`，第二个子范围是`{B, D}`。然后`std::inplace_merge`算法可以在同一个数据结构中合并两者，结果是`{A,
    B, C, D}`。
