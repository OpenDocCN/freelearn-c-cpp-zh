["```cpp\n/* nonconcurrent.cpp */\n#include <iostream>\n\nvoid Print1(void) {\n  for(int i=0; i<5; i++) {\n    std::cout << \"[Print1] Line: \" << i << \"\\n\";\n  }\n}\n\nvoid Print2(void) {\n  for(int i=0; i<5; i++) {\n    std::cout << \"[Print2] Line: \" << i << \"\\n\";\n  }\n}\n\nint main(void) {\n  Print1();\n  Print2();\n  return 0;\n}\n```", "```cpp\ng++ -Wall -ansi nonconcurrent.cpp -o nonconcurrent\n\n```", "```cpp\n/* concurrent.cpp */\n#include <boost/thread.hpp>\n#include <boost/chrono.hpp>\n#include <iostream>\n\nvoid Print1() {\n  for (int i=0; i<5; i++) {\n    boost::this_thread::sleep_for(boost::chrono::milliseconds{500});\n    std::cout << \"[Print1] Line: \" << i << '\\n';\n  }\n}\n\nvoid Print2() {\n  for (int i=0; i<5; i++) {\n    boost::this_thread::sleep_for(boost::chrono::milliseconds{500});\n    std::cout << \"[Print2] Line: \" << i << '\\n';\n  }\n}\n\nint main(void) {\n  boost::thread_group threads;\n  threads.create_thread(Print1);\n  threads.create_thread(Print2);\n  threads.join_all();\n}\n```", "```cpp\ng++ -ansi -std=c++11 -I ../boost_1_58_0 concurrent.cpp -o concurrent -L ../boost_1_58_0/stage/lib -lboost_system-mgw49-mt-1_58 -lws2_32 -l boost_thread-mgw49-mt-1_58 -l boost_chrono-mgw49-mt-1_58\n\n```", "```cpp\n/* unblocked.cpp */\n#include <boost/asio.hpp>\n#include <iostream>\n\nint main(void) {\n  boost::asio::io_service io_svc;\n\n  io_svc.run();\n\n  std::cout << \"We will see this line in console window.\" << std::endl;\n\n  return 0;\n}\n```", "```cpp\ng++ -Wall -ansi -I ../boost_1_58_0 unblocked.cpp -o unblocked -L ../boost_1_58_0/stage/lib -l boost_system-mgw49-mt-1_58 -l ws2_32\n\n```", "```cpp\nWe will see this line in console window.\n\n```", "```cpp\n/* blocked.cpp */\n#include <boost/asio.hpp>\n#include <iostream>\n\nint main(void) {\n  boost::asio::io_service io_svc;\n  boost::asio::io_service::work worker(io_svc);\n\n  io_svc.run();\n\n  std::cout << \"We will not see this line in console window :(\" << std::endl;\n\n  return 0;\n}\n```", "```cpp\ng++ -Wall -ansi -I ../boost_1_58_0 blocked.cpp -o blocked -L ../boost_1_58_0/stage/lib -l boost_system-mgw49-mt-1_58 -l ws2_32\n\n```", "```cpp\nboost::asio::io_service::work work(io_svc);\n\n```", "```cpp\n/* poll.cpp */\n#include <boost/asio.hpp>\n#include <iostream>\n\nint main(void) {\n  boost::asio::io_service io_svc;\n\n  for(int i=0; i<5; i++) {\n    io_svc.poll();\n    std::cout << \"Line: \" << i << std::endl;\n  }\n\n  return 0;\n}\n```", "```cpp\ng++ -Wall -ansi -I ../boost_1_58_0 poll.cpp -o poll -L ../boost_1_58_0/stage/lib -l boost_system-mgw49-mt-1_58 -l ws2_32\n\n```", "```cpp\n/* pollwork.cpp */\n#include <boost/asio.hpp>\n#include <iostream>\n\nint main(void) {\n  boost::asio::io_service io_svc;\n  boost::asio::io_service::work work(io_svc);\n\n  for(int i=0; i<5; i++) {\n    io_svc.poll();\n    std::cout << \"Line: \" << i << std::endl;\n  }\n\n  return 0;\n}\n```", "```cpp\ng++ -Wall -ansi -I ../boost_1_58_0 pollwork.cpp -o pollwork -L ../boost_1_58_0/stage/lib -l boost_system-mgw49-mt-1_58 -l ws2_32\n\n```", "```cpp\nboost::asio::io_service::work work(io_svc);\n\n```", "```cpp\n/* removework.cpp */\n#include <boost/asio.hpp>\n#include <boost/shared_ptr.hpp>\n#include <iostream>\n\nint main(void) {\n  boost::asio::io_service io_svc;\n  boost::shared_ptr<boost::asio::io_service::work> worker(\n    new boost::asio::io_service::work(io_svc)\n  );\n\n  worker.reset();\n\n  io_svc.run();\n\n  std::cout << \"We will not see this line in console window :(\" << std::endl;\n\n  return 0;\n}\n```", "```cpp\ng++ -Wall -ansi -I ../boost_1_58_0 removework.cpp -o removework -L ../boost_1_58_0/stage/lib -l boost_system-mgw49-mt-1_58 -l ws2_32\n\n```", "```cpp\n/* multithreads.cpp */\n#include <boost/asio.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/thread.hpp>\n#include <iostream>\n\nboost::asio::io_service io_svc;\nint a = 0;\n\nvoid WorkerThread() {\n  std::cout << ++a << \".\\n\";\n  io_svc.run();\n  std::cout << \"End.\\n\";\n}\n\nint main(void) {\n  boost::shared_ptr<boost::asio::io_service::work> worker(\n    new boost::asio::io_service::work(io_svc)\n  );\n\n  std::cout << \"Press ENTER key to exit!\" << std::endl;\n\n  boost::thread_group threads;\n  for(int i=0; i<5; i++)\n    threads.create_thread(WorkerThread);\n\n  std::cin.get();\n\n  io_svc.stop();\n\n  threads.join_all();\n\n  return 0;\n}\n```", "```cpp\ng++ -Wall -ansi -I ../boost_1_58_0 multithreads.cpp -o multithreads -L ../boost_1_58_0/stage/lib -l boost_system-mgw49-mt-1_58 -l ws2_32 -l boost_thread-mgw49-mt-1_58\n\n```", "```cpp\nfor(int i=0; i<5; i++)\n threads.create_thread(WorkerThread);\n\n```", "```cpp\nstd::cout << ++a << \".\\n\";\nio_svc.run();\n\n```", "```cpp\nstd::cin.get();\n\n```", "```cpp\nio_svc.stop();\n\n```", "```cpp\nstop() function will notify the io_service object that all the work should be stopped. This means that the program will stop the five threads that we have:\n```", "```cpp\nthreads.join_all();\n\n```", "```cpp\nWorkerThread() block:\n```", "```cpp\nstd::cout << \"End.\\n\";\n\n```", "```cpp\n/* uncalledbind.cpp */\n#include <boost/bind.hpp>\n#include <iostream>\n\nvoid func() {\n  std::cout << \"Binding Function\" << std::endl;\n}\n\nint main(void) {\n  boost::bind(&func);\n  return 0;\n}\n```", "```cpp\ng++ -Wall -ansi -I ../boost_1_58_0 uncalledbind.cpp -o uncalledbind\n\n```", "```cpp\n/* calledbind.cpp */\n#include <boost/bind.hpp>\n#include <iostream>\n\nvoid func() {\n  std::cout << \"Binding Function\" << std::endl;\n}\n\nint main(void) {\n  boost::bind(&func)();\n  return 0;\n}\n```", "```cpp\ng++ -Wall -ansi -I ../boost_1_58_0 calledbind.cpp -o calledbind\n\n```", "```cpp\nboost::bind(&func)();\n\n```", "```cpp\nNow, let's use the function that has arguments to pass. We will use boost::bind for this purpose in the following code:\n```", "```cpp\n/* argumentbind.cpp */\n#include <boost/bind.hpp>\n#include <iostream>\n\nvoid cubevolume(float f) {\n  std::cout << \"Volume of the cube is \" << f * f * f << std::endl;\n}\n\nint main(void) {\n  boost::bind(&cubevolume, 4.23f)();\n  return 0;\n}\n```", "```cpp\ng++ -Wall -ansi -I ../boost_1_58_0 argumentbind.cpp -o argumentbind\n\n```", "```cpp\nVolume of the cube is 75.687\n\n```", "```cpp\n/* signaturebind.cpp */\n#include <boost/bind.hpp>\n#include <iostream>\n#include <string>\n\nvoid identity(std::string name, int age, float height) {\n  std::cout << \"Name   : \" << name << std::endl;\n  std::cout << \"Age    : \" << age << \" years old\" << std::endl;\n  std::cout << \"Height : \" << height << \" inch\" << std::endl;\n}\n\nint main(int argc, char * argv[]) {\n  boost::bind(&identity, \"John\", 25, 68.89f)();\n  return 0;\n}\n```", "```cpp\ng++ -Wall -ansi -I ../boost_1_58_0 signaturebind.cpp -o signaturebind\n\n```", "```cpp\n/* classbind.cpp */\n#include <boost/bind.hpp>\n#include <iostream>\n#include <string>\n\nclass TheClass {\npublic:\n  void identity(std::string name, int age, float height) {\n    std::cout << \"Name   : \" << name << std::endl;\n    std::cout << \"Age    : \" << age << \" years old\" << std::endl;\n    std::cout << \"Height : \" << height << \" inch\" << std::endl;\n  }\n};\n\nint main(void) {\n  TheClass cls;\n  boost::bind(&TheClass::identity, &cls, \"John\", 25, 68.89f)();\n  return 0;\n}\n```", "```cpp\ng++ -Wall -ansi -I ../boost_1_58_0 classbind.cpp -o classbind\n\n```", "```cpp\nboost::bind(&TheClass::identity, &cls, \"John\", 25, 68.89f)();\n\n```", "```cpp\nboost:bind arguments with the class and function name, object of the class, and parameter based on the function signature.\n```", "```cpp\n/* ioservicebind.cpp */\n#include <boost/asio.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/thread.hpp>\n#include <boost/bind.hpp>\n#include <iostream>\n\nvoid WorkerThread(boost::shared_ptr<boost::asio::io_service> iosvc, int counter) {\n  std::cout << counter << \".\\n\";\n  iosvc->run();\n  std::cout << \"End.\\n\";\n}\n\nint main(void) {\n  boost::shared_ptr<boost::asio::io_service> io_svc(\n    new boost::asio::io_service\n  );\n\n  boost::shared_ptr<boost::asio::io_service::work> worker(\n    new boost::asio::io_service::work(*io_svc)\n  );\n\n  std::cout << \"Press ENTER key to exit!\" << std::endl;\n\n  boost::thread_group threads;\n  for(int i=1; i<=5; i++)\n    threads.create_thread(boost::bind(&WorkerThread, io_svc, i));\n\n  std::cin.get();\n\n  io_svc->stop();\n\n  threads.join_all();\n\n  return 0;\n}\n```", "```cpp\ng++ -Wall -ansi -I ../boost_1_58_0 ioservicebind.cpp -o ioservicebind \u2013L ../boost_1_58_0/stage/lib -l boost_system-mgw49-mt-1_58 -l ws2_32 -l boost_thread-mgw49-mt-1_58\n\n```", "```cpp\nboost::shared_ptr<boost::asio::io_service> io_svc(\n new boost::asio::io_service\n);\n\n```", "```cpp\nvoid WorkerThread(boost::shared_ptr<boost::asio::io_service> iosvc, int counter)\n\n```", "```cpp\nio_service object can be passed to the function. We do not need to define an int global variable as we did in the multithreads.cpp code snippet, since we can also pass the int argument to the WorkerThread() function:\n```", "```cpp\nstd::cout << counter << \".\\n\";\n\n```", "```cpp\nfor loop in the main block.\n```", "```cpp\n/* mutexbind.cpp */\n#include <boost/asio.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/thread.hpp>\n#include <boost/bind.hpp>\n#include <iostream>\n\nboost::mutex global_stream_lock;\n\nvoid WorkerThread(boost::shared_ptr<boost::asio::io_service> iosvc, int counter) {\n  global_stream_lock.lock();\n  std::cout << counter << \".\\n\";\n  global_stream_lock.unlock();\n\n  iosvc->run();\n\n  global_stream_lock.lock();\n  std::cout << \"End.\\n\";\n  global_stream_lock.unlock();\n}\n\nint main(void) {\n  boost::shared_ptr<boost::asio::io_service> io_svc(\n    new boost::asio::io_service\n  );\n\n  boost::shared_ptr<boost::asio::io_service::work> worker(\n    new boost::asio::io_service::work(*io_svc)\n  );\n\n  std::cout << \"Press ENTER key to exit!\" << std::endl;\n\n  boost::thread_group threads;\n  for(int i=1; i<=5; i++)\n    threads.create_thread(boost::bind(&WorkerThread, io_svc, i));\n\n  std::cin.get();\n\n  io_svc->stop();\n\n  threads.join_all();\n\n  return 0;\n}\n```", "```cpp\ng++ -Wall -ansi -I ../boost_1_58_0 mutexbind.cpp -o mutexbind -L ../boost_1_58_0/stage/lib -l boost_system-mgw49-mt-1_58 -l ws2_32 -l boost_thread-mgw49-mt-1_58\n\n```", "```cpp\nboost::mutex global_stream_lock;\n\n```", "```cpp\n/* post.cpp */\n#include <boost/asio.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/thread.hpp>\n#include <boost/bind.hpp>\n#include <iostream>\n\nboost::mutex global_stream_lock;\n\nvoid WorkerThread(boost::shared_ptr<boost::asio::io_service> iosvc, int counter) {\n  global_stream_lock.lock();\n  std::cout << counter << \".\\n\";\n  global_stream_lock.unlock();\n\n  iosvc->run();\n\n  global_stream_lock.lock();\n  std::cout << \"End.\\n\";\n  global_stream_lock.unlock();\n}\n\nsize_t fac(size_t n) {\n  if ( n <= 1 ) {\n    return n;\n  }\n  boost::this_thread::sleep(\n    boost::posix_time::milliseconds(1000)\n  );\n  return n * fac(n - 1);\n}\n\nvoid CalculateFactorial(size_t n) {\n  global_stream_lock.lock();\n  std::cout << \"Calculating \" << n << \"! factorial\" << std::endl;\n  global_stream_lock.unlock();\n\n  size_t f = fac(n);\n\n  global_stream_lock.lock();\n  std::cout << n << \"! = \" << f << std::endl;\n  global_stream_lock.unlock();\n}\n\nint main(void) {\n  boost::shared_ptr<boost::asio::io_service> io_svc(\n    new boost::asio::io_service\n  );\n\n  boost::shared_ptr<boost::asio::io_service::work> worker(\n    new boost::asio::io_service::work(*io_svc)\n  );\n\n  global_stream_lock.lock();\n  std::cout << \"The program will exit once all work has finished.\" << std::endl;\n  global_stream_lock.unlock();\n\n  boost::thread_group threads;\n  for(int i=1; i<=5; i++)\n    threads.create_thread(boost::bind(&WorkerThread, io_svc, i));\n\n  io_svc->post(boost::bind(CalculateFactorial, 5));\n  io_svc->post(boost::bind(CalculateFactorial, 6));\n  io_svc->post(boost::bind(CalculateFactorial, 7));\n\n  worker.reset();\n\n  threads.join_all();\n\n  return 0;\n}\n```", "```cpp\ng++ -Wall -ansi -I ../boost_1_58_0 post.cpp -o post -L ../boost_1_58_0/stage/lib -l boost_system-mgw49-mt-1_58 -l ws2_32 -l boost_thread-mgw49-mt-1_58\n\n```", "```cpp\nsize_t fac(size_t n) {\n if (n <= 1) {\n return n;\n }\n boost::this_thread::sleep(\n boost::posix_time::milliseconds(1000)\n );\n return n * fac(n - 1);\n}\n\n```", "```cpp\nio_svc->post(boost::bind(CalculateFactorial, 5));\nio_svc->post(boost::bind(CalculateFactorial, 6));\nio_svc->post(boost::bind(CalculateFactorial, 7));\n\n```", "```cpp\n/* dispatch.cpp */\n#include <boost/asio.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/thread.hpp>\n#include <boost/bind.hpp>\n#include <iostream>\n\nboost::mutex global_stream_lock;\n\nvoid WorkerThread(boost::shared_ptr<boost::asio::io_service> iosvc) {\n  global_stream_lock.lock();\n  std::cout << \"Thread Start.\\n\";\n  global_stream_lock.unlock();\n\n  iosvc->run();\n\n  global_stream_lock.lock();\n  std::cout << \"Thread Finish.\\n\";\n  global_stream_lock.unlock();\n}\n\nvoid Dispatch(int i) {\n  global_stream_lock.lock();\n  std::cout << \"dispath() Function for i = \" << i <<  std::endl;\n  global_stream_lock.unlock();\n}\n\nvoid Post(int i) {\n  global_stream_lock.lock();\n  std::cout << \"post() Function for i = \" << i <<  std::endl;\n  global_stream_lock.unlock();\n}\n\nvoid Running(boost::shared_ptr<boost::asio::io_service> iosvc) {\n  for( int x = 0; x < 5; ++x ) {\n    iosvc->dispatch(boost::bind(&Dispatch, x));\n    iosvc->post(boost::bind(&Post, x));\n    boost::this_thread::sleep(boost::posix_time::milliseconds(1000));\n  }\n}\n\nint main(void) {\n  boost::shared_ptr<boost::asio::io_service> io_svc(\n    new boost::asio::io_service\n  );\n\n  boost::shared_ptr<boost::asio::io_service::work> worker(\n    new boost::asio::io_service::work(*io_svc)\n  );\n\n  global_stream_lock.lock();\n  std::cout << \"The program will exit automatically once all work has finished.\" << std::endl;\n  global_stream_lock.unlock();\n\n  boost::thread_group threads;\n\n  threads.create_thread(boost::bind(&WorkerThread, io_svc));\n\n  io_svc->post(boost::bind(&Running, io_svc));\n\n  worker.reset();\n\n  threads.join_all();\n\n  return 0;\n}\n```", "```cpp\ng++ -Wall -ansi -I ../boost_1_58_0 dispatch.cpp -o dispatch -L ../boost_1_58_0/stage/lib -l boost_system-mgw49-mt-1_58 -l ws2_32 -l boost_thread-mgw49-mt-1_58\n\n```", "```cpp\niosvc->dispatch(boost::bind(&Dispatch, x));\niosvc->post(boost::bind(&Post, x));\n\n```", "```cpp\nRunning() function, we expect to get the ordered output between the dispatch() and post() functions. However, when we see the output, we find that the result is different because the dispatch() function is called first and the post() function is called after it. This happens because the dispatch() function can be invoked from the current worker thread, while the post() function has to wait until the handler of the worker is complete before it can be invoked. In other words, the dispatch() function's events can be executed from the current worker thread even if there are other pending events queued up, while the post() function's events have to wait until the handler completes the execution before being allowed to be executed.\n```"]