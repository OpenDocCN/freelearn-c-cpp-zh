- en: Using Noise in Shaders
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在着色器中使用噪声
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Creating a noise texture using GLM
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GLM创建噪声纹理
- en: Creating a seamless noise texture
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建无缝噪声纹理
- en: Creating a cloud-like effect
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建类似云的效果
- en: Creating a wood-grain effect
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建木纹效果
- en: Creating a disintegration effect
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建碎片化效果
- en: Creating a paint-spatter effect
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建喷溅效果
- en: Creating a rusted metal effect
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建生锈金属效果
- en: Creating a night-vision effect
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建夜视效果
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: It's easy to use shaders to create a smooth-looking surface, but that is not
    always the desired goal. If we want to create realistic-looking objects, we need
    to simulate the imperfections of real surfaces. That includes things such as scratches,
    rust, dents, and erosion. It is somewhat surprising how challenging it can be
    to make surfaces look like they have really been subjected to these natural processes.
    Similarly, we sometimes want to represent natural surfaces such as wood grain
    or natural phenomena such as clouds to be as realistic as possible without giving
    the impression of them being synthetic or exhibiting a repetitive pattern or structure.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用着色器创建看起来平滑的表面很容易，但这并不总是我们想要的目标。如果我们想要创建看起来逼真的对象，我们需要模拟真实表面的不完美。这包括刮痕、锈迹、凹痕和侵蚀。令人惊讶的是，使表面看起来真的经历了这些自然过程是多么具有挑战性。同样，我们有时想要尽可能真实地表示自然表面，如木纹或自然现象，如云，而不给人以它们是合成的或表现出重复模式或结构的印象。
- en: 'Most effects or patterns in nature exhibit a certain degree of randomness and
    non-linearity. Therefore, you might imagine that we could generate them by simply
    using random data. However, random data such as the kind that is generated from
    a pseudo-random number generator is not very useful in computer graphics. There
    are two main reasons:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 自然界中的大多数效果或模式都表现出一定程度的随机性和非线性。因此，你可能想象我们可以通过简单地使用随机数据来生成它们。然而，如伪随机数生成器生成的随机数据在计算机图形学中并不很有用。有两个主要原因：
- en: First, we need data that is repeatable, so that the object will render in the
    same way during each frame of the animation. (We could achieve this by using an
    appropriate seed value for each frame, but that only solves half of the problem.)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们需要可重复的数据，这样对象在动画的每一帧中都会以相同的方式渲染。（我们可以通过为每一帧使用适当的种子值来实现这一点，但这只解决了问题的一半。）
- en: Second, in order to model most of these natural phenomena, we actually need
    data that is continuous, but still gives the appearance of randomness. Continuous
    data more accurately represents many of these natural materials and phenomena.
    Purely random data does not have this continuity property. Each value has no dependence
    on the previous value.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，为了模拟大多数这些自然现象，我们实际上需要连续的数据，但仍然具有随机的外观。连续数据更准确地表示了许多这些自然材料和现象。纯随机数据不具有这种连续性属性。每个值与前面的值没有依赖关系。
- en: 'Thanks to the groundbreaking work of Ken Perlin, we have the concept of **noise**
    (as it applies to computer graphics). His work defined noise as a function that
    has certain qualities such as the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了Ken Perlin的开创性工作，我们有了**噪声**（在计算机图形学中的应用）的概念。他的工作将噪声定义为具有以下某些特性的函数：
- en: It is a continuous function
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个连续函数
- en: It is repeatable (generates the same output from the same input)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是可重复的（从相同的输入生成相同的输出）
- en: It can be defined for any number of dimensions
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以定义任何数量的维度
- en: It does not have any regular patterns and gives the appearance of randomness
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它没有任何规则模式，给人一种随机的外观
- en: Such a noise function is a valuable tool for computer graphics and it can be
    used to create an endless array of interesting effects. For instance, in this
    chapter, we'll use noise to create clouds, wood, disintegration, and other effects.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的噪声函数是计算机图形学中的一个宝贵工具，它可以用来创建一系列无穷无尽的有趣效果。例如，在本章中，我们将使用噪声来创建云、木材、碎片化以及其他效果。
- en: '**Perlin ****noise** is the noise function originally defined by Ken Perlin
    (see [http://mrl.nyu.edu/~perlin/doc/oscar.html](http://mrl.nyu.edu/~perlin/doc/oscar.html)).
    A full discussion of the details behind Perlin noise is outside the scope of this
    book.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**Perlin 噪声**是由Ken Perlin最初定义的噪声函数（见[http://mrl.nyu.edu/~perlin/doc/oscar.html](http://mrl.nyu.edu/~perlin/doc/oscar.html)）。关于Perlin噪声背后的详细讨论超出了本书的范围。'
- en: 'To use Perlin noise within a shader, we have the following three main choices:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要在着色器中使用Perlin噪声，我们有以下三个主要选择：
- en: We can use the built-in GLSL noise functions
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用内置的GLSL噪声函数
- en: We can create our own GLSL noise functions
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建自己的GLSL噪声函数
- en: We can use a texture map to store pre-computed noise data
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用纹理图来存储预计算的噪声数据
- en: At the time of writing this book, the GLSL noise functions are not implemented
    in some of the commercial OpenGL drivers, and therefore cannot be relied upon
    to be available, so I have decided not to use them in this chapter. As creating
    our own noise functions is a bit beyond the scope of this book, and because choice
    three in the preceding list gives the best performance on modern hardware, the
    recipes in this chapter will use the third approach (using a pre-computed noise
    texture).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，GLSL噪声函数尚未在部分商业OpenGL驱动程序中实现，因此不能保证可用，所以我决定在本章中不使用它们。由于创建自己的噪声函数超出了本书的范围，并且因为列表中的第三个选项在现代硬件上提供了最佳性能，本章中的配方将使用第三种方法（使用预计算的噪声纹理）。
- en: Many books use a 3D noise texture rather than a 2D one, to provide another dimension
    of noise that is available to the shaders. To keep things simple, and to focus
    on using surface texture coordinates, I've chosen to use a 2D noise texture in
    the recipes within this chapter. If desired, it should be straightforward to extend
    these recipes to use a 3D source of noise.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 许多书籍使用3D噪声纹理而不是2D纹理，以提供另一个维度，该维度可供着色器使用。为了保持简单，并专注于使用表面纹理坐标，我选择在本章的配方中使用2D噪声纹理。如果需要，应该可以轻松地将这些配方扩展到使用3D噪声源。
- en: We'll start out with two recipes that demonstrate how to generate a noise texture
    using GLM. Then, we'll move on to several examples that use noise textures to
    produce natural and artificial effects such as wood grain, clouds, electrical
    interference, splattering, and erosion.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从两个配方开始，展示如何使用GLM生成噪声纹理。然后，我们将继续展示几个使用噪声纹理来产生自然和人工效果（如木纹、云、电干扰、飞溅和侵蚀）的例子。
- en: The recipes in this chapter are meant to be a starting point for you to experiment
    with. They are certainly not intended to be the definitive way of implementing
    any of these effects. One
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的配方旨在为您提供一个实验的起点。它们绝对不是实现任何这些效果的最终方法。一个
- en: of the best things about computer graphics is the element of creativity. Try
    tweaking the shaders in these recipes to produce similar results and then try
    creating your own effects. Most of all, have fun!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机图形学最令人兴奋的元素之一就是其创造性。尝试调整这些配方中的着色器以产生类似的结果，然后尝试创建你自己的效果。最重要的是，享受乐趣！
- en: 'Refer to the the book *Texturing and Modeling: A Procedural Approach*, by Ken
    Musgrave et al., for more information on the topic.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此主题的更多信息，请参阅Ken Musgrave等人所著的《纹理和建模：过程方法》一书。
- en: Creating a noise texture using GLM
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GLM创建噪声纹理
- en: To create a texture for use as a source of noise, we need some way to generate
    noise values. Implementing a proper noise generator from scratch can be a fairly
    daunting task. Luckily, GLM provides some functions for noise generation that
    are straightforward and easy to use.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个用作噪声源的纹理，我们需要一种生成噪声值的方法。从头开始实现一个合适的噪声生成器可能是一项相当艰巨的任务。幸运的是，GLM提供了一些简单易用的噪声生成函数。
- en: In this recipe, we'll use GLM to generate a 2D texture of noise values created
    using a **Perlin ****noise** generator. GLM can generate 2D, 3D, and 4D Perlin
    noise via the `glm::perlin` function.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用GLM生成一个使用**Perlin**噪声生成器创建的2D噪声值纹理。GLM可以通过`glm::perlin`函数生成2D、3D和4D
    Perlin噪声。
- en: It is a common practice to use Perlin noise by summing the values of the noise
    function with increasing frequencies and decreasing amplitudes. Each frequency
    is commonly referred to as an **octave** (double the frequency). For example,
    in the following image, we show the results of the 2D Perlin noise function sampled
    at four different octaves. The sampling frequencies increase from left to right.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Perlin噪声是一种常见的做法，通过将噪声函数的值与增加的频率和减少的振幅相加。每个频率通常被称为**八度**（频率的两倍）。例如，在以下图像中，我们展示了在四个不同八度下采样的2D
    Perlin噪声函数的结果。采样频率从左到右增加。
- en: 'The leftmost image in the following image is the function sampled at our base
    frequency, and each image to the right shows the function sampled at twice the
    frequency of the one to its left:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像中最左侧的图像是在基本频率下采样的函数，而每个右侧的图像都显示了在左侧图像频率的两倍下采样的函数：
- en: '![](img/542e5eee-8f2c-4118-a67e-1b00df85a67d.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/542e5eee-8f2c-4118-a67e-1b00df85a67d.png)'
- en: 'In mathematical terms, if our coherent 2D Perlin noise function is *P(x, y)*,
    then each previous image represents the following equation:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 用数学术语来说，如果我们的相干2D Perlin噪声函数是 *P(x, y)*，那么每个前面的图像代表以下方程：
- en: '![](img/cccbbb5d-cded-4734-9220-a2a1afeaba44.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cccbbb5d-cded-4734-9220-a2a1afeaba44.png)'
- en: Here, *i* = 0, 1, 2, and 3 from left to right.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*i* = 0, 1, 2, 和 3 从左到右。
- en: 'As mentioned previously, the common practice is to sum octaves together to
    get the final result. We add each octave to the previous equation, scaling the
    amplitude down by some factor. So, for *N* octaves, we have the following sum:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，常见的做法是将倍频相加以获得最终结果。我们将每个倍频添加到前面的方程中，并按某个因子降低振幅。因此，对于 *N* 个倍频，我们有以下和：
- en: '![](img/4e6eb96d-6c33-4855-8aad-34049d09cfcf.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4e6eb96d-6c33-4855-8aad-34049d09cfcf.png)'
- en: '*a* and *b* are tuneable constants. The following image shows the sum of 2,
    3, and 4 octaves (left to right) with *a* = 1 and *b* = 2:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*a* 和 *b* 是可调常数。以下图像显示了2, 3, 和 4 个倍频（从左到右）的和，其中 *a* = 1 和 *b* = 2：'
- en: '![](img/f018bd99-aff3-460d-8ffc-ebd57b5af090.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f018bd99-aff3-460d-8ffc-ebd57b5af090.png)'
- en: Summed noise involving higher octaves will have more high-frequency variation
    than noise involving only lower octaves. However, it is possible to quickly reach
    frequencies that exceed the resolution of the buffer used to store the noise data,
    so care must be taken not to do unnecessary computation.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 包含更高倍频的噪声总和将比只包含更低倍频的噪声具有更多的高频变化。然而，有可能快速达到超过用于存储噪声数据的缓冲区分辨率的频率，因此必须小心不要进行不必要的计算。
- en: In practice, it is both an art and a science. The previous equation can be used
    as a starting point; feel free to tweak it until you get the desired effect.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这既是艺术也是科学。前面的方程可以作为起点；请随意调整它，直到得到期望的效果。
- en: We'll store four noise values in a single 2D texture. We'll store Perlin noise
    with one octave in the first component (red channel), two octaves in the green
    channel, three octaves in the blue channel, and four octaves in the alpha channel.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在单个2D纹理中存储四个噪声值。我们将使用第一个分量（红色通道）存储一个倍频的Perlin噪声，绿色通道存储两个倍频，蓝色通道存储三个倍频，alpha通道存储四个倍频。
- en: Getting ready
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure that you have the GLM library installed and placed in the include
    path.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经安装了GLM库并将其放置在包含路径中。
- en: How to do it...
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To create a 2D noise texture with GLM, perform the following steps:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用GLM创建2D噪声纹理，请执行以下步骤：
- en: 'Include the GLM header that includes the noise functions:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含包含噪声函数的GLM头文件：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Generate the noise data using the previous equation:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前面的方程生成噪声数据：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Load the data into an OpenGL texture:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据加载到OpenGL纹理中：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The GLM library provides 2D, 3D, and 4D coherent noise via the `glm::perlin`
    function. It returns a float roughly between -1 and 1\. We start by allocating
    a buffer named `data` to hold the generated noise values.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: GLM库通过 `glm::perlin` 函数提供2D、3D和4D相干噪声。它返回大约在-1和1之间的浮点数。我们首先分配一个名为 `data` 的缓冲区来存储生成的噪声值。
- en: Next, we loop over each texel and compute the `x` and `y` coordinates (normalized).
    Then, we loop over octaves. Here, we compute the sum of the previous equation,
    storing the first term in the first component, the first two terms in the second,
    and so on. The value is scaled into the range from 0 to 1, then multiplied by
    255 and cast to a byte.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们遍历每个texel并计算 `x` 和 `y` 坐标（归一化）。然后，我们遍历倍频。在这里，我们计算前面方程的和，将第一个项存储在第一个分量中，前两个项在第二个分量中，依此类推。该值被缩放到0到1的范围内，然后乘以255并转换为字节。
- en: The next few lines of code should be familiar. Texture memory is allocated with
    `glTexStorage2D` and the data is loaded into GPU memory using `glTexSubImage2D`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下几行代码应该很熟悉。使用 `glTexStorage2D` 分配纹理内存，并使用 `glTexSubImage2D` 将数据加载到GPU内存中。
- en: Finally, the array named `data` is deleted, as it is no longer needed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，删除名为 `data` 的数组，因为它不再需要。
- en: There's more...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Rather than using unsigned byte values, we could get more resolution in our
    noise data by using a floating-point texture. This might provide better results
    if the effect needs a high degree of fine detail. The preceding code needs relatively
    few changes to achieve this. Just use an internal format of `GL_RGBA32F` instead
    of `GL_RGBA`, use the `GL_FLOAT` type, and don't multiply by 255 when storing
    the noise values in the array.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用无符号字节值相比，我们可以通过使用浮点纹理在我们的噪声数据中获得更高的分辨率。如果效果需要高度精细的细节，这可能会提供更好的结果。为了实现这一点，需要相对较少的代码更改。只需使用内部格式
    `GL_RGBA32F` 而不是 `GL_RGBA`，使用 `GL_FLOAT` 类型，并且在将噪声值存储在数组中时不要乘以255。
- en: GLM also provides periodic Perlin noise via an overload of the `glm::perlin`
    function. This makes it easy to create noise textures that tile without seams.
    We'll see how to use this in the next recipe.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: GLM还通过`glm::perlin`函数的重载提供了周期性的Perlin噪声。这使得创建无缝拼接的噪声纹理变得容易。我们将在下一个配方中看到如何使用它。
- en: See also
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter09/noisetex.cpp` file in the example code
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter09/noisetex.cpp`文件
- en: For general information about coherent noise, take a look at the book *Graphics **Shaders* by
    Mike Bailey and Steve Cunningham
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于连贯噪声的一般信息，请参阅Mike Bailey和Steve Cunningham合著的《图形**着色器**》一书
- en: The *Applying **a 2D texture* recipe in [Chapter 5](a5d0db76-6dbb-470d-8685-42ab8ae077b1.xhtml), *Using
    Textures*
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第5章](a5d0db76-6dbb-470d-8685-42ab8ae077b1.xhtml)中的*应用2D纹理*配方，*使用纹理*'
- en: The *Creating a seamless noise texture* recipe
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建无缝噪声纹理*的配方'
- en: Creating a seamless noise texture
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建无缝噪声纹理
- en: It can be particularly useful to have a noise texture that tiles well. If we
    simply create a noise texture as a finite slice of noise values, then the values
    will not wrap smoothly across the boundaries of the texture. This can cause hard
    edges (seams) to appear in the rendered surface if the texture coordinates extend
    outside of the range of zero to one.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个拼接良好的噪声纹理特别有用。如果我们仅仅创建一个噪声纹理作为噪声值的有限切片，那么这些值将不会在纹理的边界处平滑地环绕。如果纹理坐标超出零到一的范围内，这可能会导致渲染表面出现硬边（拼接线）。
- en: Fortunately, GLM provides a periodic variant of Perlin noise that can be used
    to create a seamless noise texture.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，GLM提供了一个周期性的Perlin噪声变体，可以用来创建无缝噪声纹理。
- en: 'The following image shows an example of regular (left) and periodic (right)
    four-octave Perlin noise. Note that in the left image, the seams are clearly visible,
    while they are hidden in the right image:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了常规（左）和周期性（右）四频带Perlin噪声的示例。注意，在左边的图像中，拼接线清晰可见，而在右边的图像中则被隐藏：
- en: '![](img/7be4a130-dfa7-4a19-9a47-198d3b3d780b.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7be4a130-dfa7-4a19-9a47-198d3b3d780b.png)'
- en: In this example, we'll modify the code from the previous recipe to produce a
    seamless noise texture.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将修改前一个配方的代码以生成无缝噪声纹理。
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we'll start with the code from the previous *Creating a noise
    texture using GLM* recipe.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将从上一个*使用GLM创建噪声纹理*配方中的代码开始。
- en: How to do it...
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Modify the code from the previous recipe in the following way.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式修改前一个配方中的代码。
- en: 'Within the innermost loop, instead of calling `glm::perlin`, we''ll instead
    call the overload that provides periodic Perlin noise. You will need to replace
    the following statement:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在最内层循环中，我们不会调用`glm::perlin`，而是调用提供周期性Perlin噪声的重载。你需要替换以下语句：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Replace it with the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下内容替换它：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The second parameter to `glm::perlin` determines the period in `x` and `y` of
    the noise values. We use `freq` as the period because we are sampling the noise
    in the range from `0` to `freq` for each octave.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`glm::perlin`的第二个参数决定了噪声值在`x`和`y`方向上的周期。我们使用`freq`作为周期，因为我们为每个频带在每个范围内从`0`到`freq`采样噪声。'
- en: See also
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter09/noisetex.cpp` file in the example code
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter09/noisetex.cpp`文件
- en: The *Creating a noise texture using GLM* recipe
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用GLM创建噪声纹理*配方'
- en: Creating a cloud-like effect
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建类似云的效果
- en: To create a texture that resembles a sky with clouds, we can use the noise values
    as a blending factor between the sky color and the cloud color. As clouds usually
    have large-scale structure, it makes sense to use low-octave noise. However, the
    large-scale structure often has higher frequency variations, so some contribution
    from higher octave noise may be desired.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个类似天空带有云的纹理，我们可以使用噪声值作为天空颜色和云颜色之间的混合因子。由于云通常具有大规模结构，使用低频噪声是有意义的。然而，大规模结构通常具有更高的频率变化，因此可能需要一些高频噪声的贡献。
- en: 'The following image shows an example of clouds generated by the technique in
    this recipe:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了本配方中技术生成云的示例：
- en: '![](img/585061c8-f96f-4a78-aeb1-e95f212df5de.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/585061c8-f96f-4a78-aeb1-e95f212df5de.png)'
- en: To create this effect, we take the cosine of the noise value and use the result
    as the blending factor between the cloud color.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建这种效果，我们取噪声值的余弦值，并将结果用作云颜色之间的混合因子。
- en: Getting ready
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Set up your program to generate a seamless noise texture and make it available
    to the shaders through the `NoiseTex` uniform sampler variable.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 设置你的程序以生成无缝噪声纹理，并通过`NoiseTex`均匀采样器变量将其提供给着色器。
- en: 'There are two uniforms in the fragment shader that can be assigned from the
    OpenGL program:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器中有两种制服可以从OpenGL程序中分配：
- en: '`SkyColor`: The background sky color'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SkyColor`：背景天空颜色'
- en: '`CloudColor`: The color of the clouds'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CloudColor`：云彩的颜色'
- en: How to do it...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To build a shader program that uses a noise texture to create a cloud-like
    effect, perform the following steps:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个使用噪声纹理创建类似云彩效果的着色器程序，请执行以下步骤：
- en: Set up your vertex shader to pass the texture coordinates to the fragment shader
    via the `TexCoord` variable.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置您的顶点着色器，通过`TexCoord`变量将纹理坐标传递给片段着色器。
- en: 'Use the following code for the fragment shader:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码作为片段着色器：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We start by retrieving the noise value from the noise texture (the `noise` variable).
    The green channel contains two octave noises, so we use the value stored in that
    channel (`noise.g`). Feel free to try out other channels and determine what looks
    right to you.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从噪声纹理（`noise`变量）中检索噪声值。绿色通道包含两个八度噪声，所以我们使用该通道中存储的值（`noise.g`）。您可以随意尝试其他通道，并确定哪种看起来更适合您。
- en: We use a cosine function to make a sharper transition between the cloud and
    sky color. The noise value will be between zero and one, and the cosine of that
    value will range between -1 and 1, so we add 1.0 and divide by 2.0\. The result
    that is stored in `t` should again range between zero and one. Without this cosine
    transformation, the clouds look a bit too spread out over the sky. However, if
    that is the desired effect, one could remove the cosine and just use the noise
    value directly.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用余弦函数来使云彩和天空颜色之间的过渡更加尖锐。噪声值将在零和一之间，该值的余弦将在-1和1之间，所以我们添加1.0并除以2.0。存储在`t`中的结果应该再次在零和一之间。如果没有这个余弦变换，云彩看起来在天空上分布得有点太散。然而，如果这是期望的效果，可以移除余弦并直接使用噪声值。
- en: Next, we mix the sky color and the cloud color using the value of `t`. The result
    is used as the final output fragment color.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`t`的值混合天空颜色和云彩颜色。结果被用作最终输出片段颜色。
- en: There's more...
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'If you desire less clouds and more sky, you could translate and clamp the value
    of `t` prior to using it to mix the cloud and sky colors. For example, you could
    use the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要更少的云彩和更多的天空，您可以在使用`t`值混合云彩和天空颜色之前将其值进行平移和钳位。例如，您可以使用以下代码：
- en: '[PRE6]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This causes the cosine term to shift down (toward negative values), and the
    `clamp` function sets all negative values to zero. This has the effect of increasing
    the amount of sky and decreasing the size and intensity of the clouds.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致余弦项向下（向负值）移动，而`clamp`函数将所有负值设置为零。这会增加天空的量，并减少云彩的大小和强度。
- en: See also
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter09/scenesky.cpp` file in the example code
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter09/scenesky.cpp`文件
- en: 'Further reading on cloud generation: [http://vterrain.org/Atmosphere/Clouds/](http://vterrain.org/Atmosphere/Clouds/)'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于云彩生成的进一步阅读：[http://vterrain.org/Atmosphere/Clouds/](http://vterrain.org/Atmosphere/Clouds/)
- en: The *Creating a seamless noise texture* recipe
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建无缝噪声纹理*配方'
- en: Creating a wood-grain effect
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建木纹效果
- en: To create the look of wood, we can start by creating a virtual "log" with perfectly
    cylindrical growth rings. Then, we'll take a slice of the log and perturb the
    growth rings using noise from our noise texture.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建木纹效果，我们可以首先创建一个具有完美圆柱形生长环的虚拟“树干”。然后，我们将切下一块树干，并使用噪声纹理中的噪声扰动生长环。
- en: 'The following diagram illustrates our virtual *log*. It is aligned with the
    *y *axis, and extends infinitely in all directions. The growth rings are aligned
    with integer distances from the *y* axis. Each ring is given a darker color, with
    a lighter color in-between rings. Each growth ring spans a narrow distance around
    the integer distances:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了我们的虚拟*树干*。它与*y*轴对齐，并向所有方向无限延伸。生长环与*y*轴的整数距离对齐。每个环都被赋予较深的颜色，环之间是较浅的颜色。每个生长环跨越整数距离周围的狭窄距离：
- en: '![](img/4273364f-9fa6-4596-8769-e44db96d8713.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4273364f-9fa6-4596-8769-e44db96d8713.png)'
- en: 'To take a "slice," we''ll simply define a 2D region of the log''s space based
    on the texture coordinates. Initially, the texture coordinates define a square
    region, with coordinates ranging from zero to one. We''ll assume that the region
    is aligned with the x-y plane, so that the *s* coordinate corresponds to *x*,
    the *t* coordinate corresponds to *y*, and the value of *z* is zero. We can then
    transform this region in any way that suits our fancy, to create an arbitrary
    2D slice. After defining the slice, we''ll determine the color based on the distance
    from the *y* axis. However, before doing so, we''ll perturb that distance based
    on a value from the noise texture. The result has a general look that is similar
    to real wood. The following image shows an example of this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行“切片”，我们只需根据纹理坐标定义原木空间的二维区域。最初，纹理坐标定义一个坐标范围从零到一的方形区域。我们假设该区域与 x-y 平面对齐，因此
    *s* 坐标对应于 *x*，*t* 坐标对应于 *y*，而 *z* 的值为零。然后我们可以以任何适合我们的方式变换这个区域，以创建任意二维切片。在定义切片后，我们将根据到
    *y* 轴的距离确定颜色。然而，在这样做之前，我们将基于噪声纹理中的一个值扰动这个距离。结果看起来与真实木材相似。以下图像显示了此示例：
- en: '![](img/d8a0660c-31d6-43ed-920a-74e44a0f07e5.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d8a0660c-31d6-43ed-920a-74e44a0f07e5.png)'
- en: Getting ready
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Set up your program to generate a noise texture and make it available to the
    shaders through the uniform variable `NoiseTex`. There are three uniforms in the
    fragment shader that can be assigned from the OpenGL program. They are as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 设置你的程序以生成噪声纹理，并通过 `NoiseTex` 常量变量使其对着色器可用。片段着色器中有三个可以从 OpenGL 程序分配的常量。它们如下所示：
- en: '`LightWoodColor`: The lightest wood color'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LightWoodColor`：最浅的木色'
- en: '`DarkWoodColor`: The darkest wood color'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DarkWoodColor`：最深的木色'
- en: '`Slice`: A matrix that defines the slice of the virtual "log" and transforms
    the default region defined by the texture coordinates to some other arbitrary
    rectangular region'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Slice`：一个定义虚拟“原木”切片的矩阵，并将默认由纹理坐标定义的区域变换为其他任意矩形区域'
- en: How to do it...
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create a shader program that generates a wood-grain effect using a noise
    texture, perform the following steps:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个使用噪声纹理生成木纹效果的着色器程序，请执行以下步骤：
- en: Set up your vertex shader to pass the texture coordinate to the fragment shader
    via the `TexCoord` variable.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置你的顶点着色器，通过 `TexCoord` 变量将纹理坐标传递给片段着色器。
- en: 'Use the following code for the fragment shader:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码进行片段着色器：
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first line of the `main` function within the fragment shader expands the
    texture coordinates to a 3D (homogeneous) value with a *z* coordinate of zero
    (s, t, 0, 1), and then transforms the value via the `Slice` matrix. This matrix
    can scale, translate, and/or rotate the texture coordinates to define the 2D region
    of the virtual *log*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器中 `main` 函数的第一行将纹理坐标扩展为具有零 *z* 坐标的3D（齐次）值（s, t, 0, 1），然后通过 `Slice` 矩阵变换该值。这个矩阵可以缩放、平移和/或旋转纹理坐标，以定义虚拟
    *原木* 的二维区域。
- en: One way to visualize this is to think of the slice as a 2D unit square embedded
    in the log with its lower-left corner at the origin. The matrix is then used to
    transform that square within the log to define a slice through the log. For example,
    I might just translate the square by (-0.5, -0.5, -0.5) and scale by 20 in *x*
    and *y* to get a slice through the middle of the log.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可视化这个方法是将切片想象成一个嵌入在原木中的二维单位正方形，其左下角位于原点。然后使用矩阵将这个正方形在原木内进行变换，以定义一个穿过原木的切片。例如，我可能只将正方形平移（-0.5,
    -0.5, -0.5）并在 *x* 和 *y* 方向上缩放20倍，以得到穿过原木中间的切片。
- en: 'Next, the distance from the *y* axis is determined by using the built-in `length`
    function (`length(cyl.xz)`). This will be used to determine how close we are to
    a growth ring. The color will be a light wood color if we are between growth rings,
    and a dark color when we are close to a growth ring. However, before determining
    the color, we perturb the distance slightly using a value from our noise texture
    by using the following line of code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用内置的 `length` 函数（`length(cyl.xz)`）确定到 *y* 轴的距离。这将用来确定我们距离生长环有多近。如果我们处于生长环之间，颜色将是浅木色；当我们接近生长环时，颜色将变深。然而，在确定颜色之前，我们使用以下代码行通过噪声纹理中的一个值稍微扰动这个距离：
- en: '[PRE8]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The next step is just a bit of numerical trickery to determine the color based
    on how close we are to a whole number. We start by taking the fractional part
    of the distance (`fract(dist)`), multiplying by two, subtracting one, and taking
    the absolute value. As `fract(dist)` is a value between zero and one, multiplying
    by two, subtracting one, and taking the absolute value will result in a value
    that is also between zero and one. However, the value will range from 1.0 when
    `dist` is 0.0, to 0.0 when `dist` is 0.5, and back to 1.0 when `dist` is 1.0 (a
    `v` shape).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步只是一个基于我们离整数有多近来确定颜色的数值技巧。我们首先取距离的分数部分（`fract(dist)`），乘以二，减去一，然后取绝对值。由于`fract(dist)`是一个介于零和一之间的值，乘以二，减去一，然后取绝对值将得到一个同样介于零和一之间的值。然而，这个值将在`dist`为0.0时为1.0，当`dist`为0.5时为0.0，当`dist`为1.0时又回到1.0（一个`v`形状）。
- en: We then invert the `v` by subtracting from one, and storing the result in `t`.
    Next, we use the `smoothstep` function to create a somewhat sharp transition between
    the light and dark colors. In other words, we want a dark color when `t` is less
    than 0.2, a light color when it is greater than 0.5, and a smooth transition in
    between. The result is used to mix the light and dark colors via the GLSL `mix`
    function.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后通过从一减去`v`来反转它，并将结果存储在`t`中。接下来，我们使用`smoothstep`函数在亮色和暗色之间创建一个相对尖锐的过渡。换句话说，我们希望在`t`小于0.2时得到暗色，在`t`大于0.5时得到亮色，并在两者之间有一个平滑的过渡。结果用于通过GLSL的`mix`函数混合亮色和暗色。
- en: The `smoothstep( a, b, x )` function works in the following way. It returns
    `0.0` when `x <= a`, `1.0` when `x >= b`, and uses Hermite interpolation between
    0 and 1 when `x` is between `a` and `b`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`smoothstep(a, b, x)`函数的工作方式如下。当`x <= a`时返回`0.0`，当`x >= b`时返回`1.0`，当`x`在`a`和`b`之间时使用Hermite插值在0和1之间。'
- en: The result of all of this is a narrow band of the dark color around integer
    distances, and a light color in-between, with a rapid but smooth transition. Finally,
    we simply apply the final color to the fragment.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些的结果是在整数距离周围出现一条狭窄的深色带，中间是浅色，并且颜色过渡快速而平滑。最后，我们只需将最终颜色应用到碎片上。
- en: There's more...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'A book-matched pair of boards is a pair that is cut from the same log and then
    glued together. The result is a larger board that has symmetry in the grain from
    one side to the other. We can approximate this effect by mirroring the texture
    coordinate. For example, we could use the following in place of the first line
    of the preceding `main` function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一对书匹配的木板是从同一根原木上切割出来然后粘合在一起的一对。结果是更大的木板，从一侧到另一侧的纹理具有对称性。我们可以通过镜像纹理坐标来近似这种效果。例如，我们可以用以下代码替换前面`main`函数的第一行：
- en: '[PRE9]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following image shows an example of the results:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了结果示例：
- en: '![](img/eb282a0b-77f8-4f56-a01f-10628999a0df.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eb282a0b-77f8-4f56-a01f-10628999a0df.png)'
- en: See also
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter09/scenewood.cpp` file in the example code
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter09/scenewood.cpp`文件
- en: The *Creating a noise texture using GLM* recipe
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GLM创建噪声纹理的配方
- en: Creating a disintegration effect
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建分解效果
- en: It is straightforward to use the GLSL `discard` keyword in combination with
    noise to simulate erosion or decay. We can simply discard fragments that correspond
    to a noise value that is above or below a certain threshold. The following image
    shows a teapot with this effect.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GLSL的`discard`关键字与噪声结合来模拟侵蚀或衰变是直接的。我们可以简单地丢弃与噪声值高于或低于某个阈值对应的碎片。以下图像显示了具有这种效果的茶壶。
- en: 'Fragments are discarded when the noise value corresponding to the texture coordinate
    is outside a certain threshold range:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当与纹理坐标对应的噪声值超出某个阈值范围时，丢弃碎片：
- en: '![](img/9a768420-0b98-49df-9d73-909cf90796ff.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9a768420-0b98-49df-9d73-909cf90796ff.png)'
- en: Getting ready
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Set up your OpenGL program to provide position, normal, and texture coordinates
    to the shader. Make sure that you pass the texture coordinate along to the fragment
    shader. Set up any uniforms needed to implement the shading model of your choice.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 设置你的OpenGL程序以向着色器提供位置、法线和纹理坐标。确保将纹理坐标传递到片段着色器。设置实现所选着色模型的任何uniforms。
- en: Create a seamless noise texture (see *Creating a seamless noise texture*), and
    place it in the appropriate texture channel.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个无缝噪声纹理（见*创建无缝噪声纹理*），并将其放置在适当的纹理通道中。
- en: 'The following uniforms are defined in the fragment shader, and should be set
    via the OpenGL program:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下uniforms在片段着色器中定义，并且应该通过OpenGL程序设置：
- en: '`NoiseTex`: The noise texture'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NoiseTex`：噪声纹理'
- en: '`LowThreshold`: Fragments are discarded if the noise value is below this value'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LowThreshold`: 如果噪声值低于此值，则片段将被丢弃'
- en: '`HighThreshold`: Fragments are discarded if the noise value is above this value'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HighThreshold`: 如果噪声值高于此值，则片段将被丢弃'
- en: How to do it...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a shader program that provides a disintegration effect, perform the
    following steps:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个提供分解效果的着色器程序，请执行以下步骤：
- en: Create a vertex shader that sends the texture coordinate to the fragment shader
    via the `TexCoord` output variable. It should also pass the position and normal
    to the fragment shader through the `Position` and `Normal` variables.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个顶点着色器，通过`TexCoord`输出变量将纹理坐标发送到片段着色器。它还应该通过`Position`和`Normal`变量将位置和法线传递给片段着色器。
- en: 'Use the following code for the fragment shader:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码作为片段着色器：
- en: '[PRE10]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The fragment shader starts by retrieving a noise value from the noise texture
    (`NoiseTex`), and storing the result in the `noise` variable. We want noise that
    has a large amount of high-frequency fluctuation, so we choose four-octave noise,
    which is stored in the alpha channel (`noise.a`).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器首先从噪声纹理（`NoiseTex`）中检索噪声值，并将结果存储在`noise`变量中。我们希望噪声具有大量高频波动，所以我们选择四倍频噪声，它存储在alpha通道（`noise.a`）中。
- en: We then discard the fragment if the noise value is below `LowThreshold` or above
    `HighThreshold`. As the `discard` keyword causes the execution of the shader to
    stop, the rest of the shader will not execute if the fragment is discarded.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果噪声值低于`LowThreshold`或高于`HighThreshold`，则丢弃片段。由于`discard`关键字会导致着色器执行停止，如果丢弃片段，则着色器的其余部分将不会执行。
- en: The discard operation can have a performance impact due to how it might affect
    early depth tests.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它可能影响早期深度测试，丢弃操作可能会对性能产生影响。
- en: Finally, we compute the shading model and apply the result to the fragment.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们计算着色模型并将结果应用于片段。
- en: See also
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter09/scenedecay.cpp` file in the example code
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter09/scenedecay.cpp`文件
- en: The *Creating a seamless noise texture* recipe
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建无缝噪声纹理*配方'
- en: Creating a paint-spatter effect
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建喷溅效果
- en: 'Using high-frequency noise, it is easy to create the effect of random spatters
    of paint on the surface of an object. The following image shows an example of
    this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用高频噪声，很容易在物体表面创建随机喷溅油漆的效果。以下图像显示了此效果的示例：
- en: '![](img/87f51c07-6e29-4b3b-85d0-76a84f36df03.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/87f51c07-6e29-4b3b-85d0-76a84f36df03.png)'
- en: We use the noise texture to vary the color of the object, with a sharp transition
    between the base color and the paint color. We'll use either the base color or
    paint color as the diffuse reflectivity of the shading model. If the noise value
    is above a certain threshold, we'll use the paint color; otherwise, we'll use
    the base color of the object.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用噪声纹理来改变物体的颜色，在基本颜色和喷漆颜色之间有一个尖锐的过渡。我们将使用基本颜色或喷漆颜色作为着色模型的漫反射反射率。如果噪声值高于某个阈值，我们将使用喷漆颜色；否则，我们将使用物体的基本颜色。
- en: Getting ready
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Start with a basic setup for rendering using the Phong shading model (or whatever
    model you prefer). Include texture coordinates and pass them along to the fragment
    shader.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从使用Phong着色模型（或您喜欢的任何模型）的基本渲染设置开始。包括纹理坐标并将它们传递给片段着色器。
- en: 'There are a couple of uniform variables that define the parameters of the paint
    spatters:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个统一变量定义了喷溅油漆的参数：
- en: '`PaintColor`: The color of the paint spatters'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PaintColor`: 喷溅油漆的颜色'
- en: '`Threshold`: The minimum noise value where a spatter will appear'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Threshold`: 喷溅出现的最小噪声值'
- en: Create a noise texture with high-frequency noise.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个高频噪声的噪声纹理。
- en: Make your noise texture available to the fragment shader via the `NoiseTex` uniform
    sampler variable.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`NoiseTex`统一采样器变量使噪声纹理对片段着色器可用。
- en: How to do it...
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a shader program that generates a paint-spatter effect, perform the
    following steps:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个生成喷溅效果的着色器程序，请执行以下步骤：
- en: Create a vertex shader that sends the texture coordinates to the fragment shader
    via the `TexCoord` output variable. It should also pass the position and normal
    to the fragment shader through the variables `Position` and `Normal`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个顶点着色器，通过`TexCoord`输出变量将纹理坐标发送到片段着色器。它还应该通过`Position`和`Normal`变量将位置和法线传递给片段着色器。
- en: 'Use the following code for the fragment shader:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码作为片段着色器：
- en: '[PRE11]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The main function of the fragment shader retrieves a noise value from `NoiseTex` and
    stores it in the `noise` variable. The next two lines set the variable `color`
    to either the base diffuse reflectivity (`Material.Kd`) or `PaintColor`, depending
    on whether or not the noise value is greater than the threshold value (`Threshold`).
    This will cause a sharp transition between the two colors, and the size of the
    spatters will be related to the frequency of the noise.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器的主要功能是从`NoiseTex`中检索噪声值并将其存储在`noise`变量中。接下来的两行将变量`color`设置为基本漫反射率(`Material.Kd`)或`PaintColor`，具体取决于噪声值是否大于阈值值(`Threshold`)。这将导致两种颜色之间的急剧过渡，喷溅的大小将与噪声的频率相关。
- en: Finally, the Phong shading model is evaluated using `color` as the diffuse reflectivity.
    The result is applied to the fragment.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用`color`作为漫反射率评估Phong着色模型。结果应用于片段。
- en: There's more...
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As indicated in the *Creating a noise texture using GLM* recipe, using lower
    frequency noise will cause the spatters to be larger in size and more spread out.
    A lower threshold will also increase the size without it spreading over the surface,
    but as the threshold gets lower, it starts to look more uniform and less like
    random spattering.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如*使用GLM创建噪声纹理*配方中所示，使用较低频率的噪声会导致喷溅更大且分布更广。较低的阈值也会增加大小，但不会扩散到表面，但随着阈值的降低，它开始看起来更均匀，更像随机喷溅。
- en: See also
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter09/scenepaint.cpp` file in the example code
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter09/scenepaint.cpp`文件
- en: The *Creating a seamless noise texture* recipe
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建无缝噪声纹理*配方'
- en: Creating a rusted metal effect
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建锈蚀金属效果
- en: This recipe combines a noise texture with the reflection effect covered in [Chapter
    5](a5d0db76-6dbb-470d-8685-42ab8ae077b1.xhtml), *Using Textures* to create a simple
    rusted metal effect.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方结合了一个噪声纹理和[第5章](a5d0db76-6dbb-470d-8685-42ab8ae077b1.xhtml)中介绍的反射效果，*使用纹理*来创建简单的锈蚀金属效果。
- en: '![](img/2c249282-60fa-4e06-9a82-fdb9951af278.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2c249282-60fa-4e06-9a82-fdb9951af278.png)'
- en: This technique is very similar to the previous recipe, *Creating a paint-spatter
    effect*.  We'll use our noise texture to modulate the reflection from the teapot.
    If the noise is above a certain threshold, we'll use the rust color, otherwise,
    we'll use the reflected color.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术与之前的配方*创建喷溅效果*非常相似。我们将使用我们的噪声纹理来调制茶壶的反射。如果噪声值高于某个阈值，我们将使用锈色，否则，我们将使用反射颜色。
- en: Getting ready
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll combine the technique described in the *Simulating reflection with cube
    maps* recipe in [Chapter 5](a5d0db76-6dbb-470d-8685-42ab8ae077b1.xhtml), *Using
    Textures*, with a noise texture. Start with the shaders from that recipe.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将[第5章](a5d0db76-6dbb-470d-8685-42ab8ae077b1.xhtml)中*使用纹理*的配方中描述的*使用立方体贴图模拟反射*技术与噪声纹理相结合。从该配方中的着色器开始。
- en: How to do it...
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In the fragment shader, we''ll access our noise texture and if the value is
    below the threshold value `Threshold`, we''ll use the reflected color (from the
    cube map), otherwise, we''ll use a rust color:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段着色器中，我们将访问我们的噪声纹理，如果值低于阈值值`Threshold`，我们将使用反射颜色（来自立方体贴图），否则，我们将使用锈色：
- en: '[PRE12]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We start by accessing the noise texture, and store it's value in the variable
    `noise`. The variable `scale` will store a value that is either zero or one. We
    use the `floor` function to set it to zero if the value of `noise` is less than
    `Threshold` and to one otherwise.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先访问噪声纹理，并将其值存储在变量`noise`中。变量`scale`将存储一个零或一的值。我们使用`floor`函数将`noise`的值小于`Threshold`时设置为零，否则设置为
    一。
- en: Next, we access the cube map to get the reflected color and apply a gamma correction.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们访问立方体贴图以获取反射颜色并应用伽玛校正。
- en: We compute `rustColor` by mixing `MaterialColor` with a dark color (nearly black)
    using the noise texture as a scale. This should give some additional variation
    in the rust color.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将`MaterialColor`与深色（几乎为黑色）混合来计算`rustColor`，使用噪声纹理作为比例。这应该会给锈色带来一些额外的变化。
- en: Finally, we use `scale` to mix the `cubeMapColor` with `rustColor` and apply
    the result to the fragment.  Since the value of `scale` will be either zero or
    one, we will get a sharp transition between the reflected color and the rust color.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`scale`将`cubeMapColor`与`rustColor`混合，并将结果应用于片段。由于`scale`的值将是零或一，因此我们将得到反射颜色和锈色之间的尖锐过渡。
- en: See also
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter09/scenerust.cpp` file in the example code
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter09/scenerust.cpp`文件
- en: Creating a night-vision effect
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建夜视效果
- en: 'Noise can be useful to simulate static or other kinds of electronic interference
    effects. This recipe is a fun example of that. We''ll create the look of night-vision
    goggles with some noise thrown in to simulate some random static in the signal.
    Just for fun, we''ll also outline the scene in the classic *binocular* view. The
    following image shows an example of this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 噪声可以用来模拟静态或其他类型的电子干扰效果。这个配方是一个有趣的例子。我们将通过添加一些噪声来模拟信号中的随机静态，以创建夜视镜的外观。为了好玩，我们还将以经典的
    *双筒望远镜* 视图勾勒场景。以下图片展示了这个例子：
- en: '![](img/1c83dd2b-fb39-410b-ac67-f8122cb53127.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1c83dd2b-fb39-410b-ac67-f8122cb53127.png)'
- en: We'll apply the night-vision effect as a second pass to the rendered scene.
    The first pass will render the scene to a texture (see [Chapter 5](a5d0db76-6dbb-470d-8685-42ab8ae077b1.xhtml),
    *Using Textures*), and the second pass will apply the night-vision effect.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将作为第二次遍历将夜视效果应用于渲染的场景。第一次遍历将场景渲染到纹理中（见[第5章](a5d0db76-6dbb-470d-8685-42ab8ae077b1.xhtml)，*使用纹理*），第二次遍历将应用夜视效果。
- en: Getting ready
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: Create a **framebuffer object** (**FBO**) for the first pass. Attach a texture
    to the first color attachment of the FBO. For more information on how to do this,
    see [Chapter 5](a5d0db76-6dbb-470d-8685-42ab8ae077b1.xhtml), *Using Textures*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为第一次遍历创建一个 **帧缓冲对象**（**FBO**）。将纹理附加到FBO的第一个颜色附加项。有关如何操作的更多信息，请参阅[第5章](a5d0db76-6dbb-470d-8685-42ab8ae077b1.xhtml)，*使用纹理*。
- en: 'Create and assign any uniform variables needed for the shading model. Set the
    following uniforms defined in the fragment shader:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并分配所需的任何着色模型统一变量。设置片段着色器中定义的以下统一变量：
- en: '`Width`: The width of the viewport in pixels'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Width`: 视口宽度（以像素为单位）'
- en: '`Height`: The height of the viewport in pixels'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Height`: 视口高度（以像素为单位）'
- en: '`Radius`: The radius of each circle in the *binocular* effect (in pixels)'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Radius`: 双筒望远镜效果中每个圆的半径（以像素为单位）'
- en: '`RenderTex`: The texture containing the render from the first pass'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RenderTex`: 包含第一次遍历渲染的纹理'
- en: '`NoiseTex`: The noise texture'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NoiseTex`: 噪声纹理'
- en: '`RenderPass`: The subroutine uniform used to select the functionality for each
    pass'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RenderPass`: 用于选择每个遍历功能性的子程序统一变量'
- en: Create a noise texture with high-frequency noise and make it available to the
    shader via `NoiseTex`. Associate the texture with the FBO available via `RenderTex`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个具有高频噪声的噪声纹理，并通过 `NoiseTex` 使其可用于着色器。将纹理与通过 `RenderTex` 可用的FBO关联。
- en: How to do it...
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create a shader program that generates a night-vision effect, perform the
    following steps:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建生成夜视效果的着色器程序，执行以下步骤：
- en: Set up your vertex shader to pass along the position, normal, and texture coordinates
    via the `Position`, `Normal`, and `TexCoord` variables, respectively.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置你的顶点着色器，通过 `Position`、`Normal` 和 `TexCoord` 变量分别传递位置、法线和纹理坐标。
- en: 'Use the following code for the fragment shader:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码作为片段着色器：
- en: '[PRE13]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the render function of your OpenGL program, perform the following steps:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的OpenGL程序的渲染函数中，执行以下步骤：
- en: Bind to the FBO that you set up for rendering the scene to a texture.
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绑定到用于将场景渲染到纹理的FBO。
- en: Select the `pass1` subroutine function in the fragment shader via `RenderPass`.
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 `RenderPass` 选择片段着色器中的 `pass1` 子程序函数。
- en: Render the scene.
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染场景。
- en: Bind to the default FBO.
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绑定到默认的FBO。
- en: Select the `pass2` subroutine function in the fragment shader via `RenderPass`.
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 `RenderPass` 选择片段着色器中的 `pass2` 子程序函数。
- en: Draw a single quad that fills the viewport using texture coordinates that range
    from 0 to 1 in each direction.
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用纹理坐标（每个方向的范围为0到1）绘制一个填充视口的单个四边形。
- en: How it works...
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The fragment shader is broken into two subroutine functions, one for each pass.
    Within the `pass1` function, we simply apply the Phong shading model to the fragment.
    The result is written to the FBO, which contains a texture to be used in the second
    pass.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器被分成两个子程序函数，每个遍历一个。在 `pass1` 函数中，我们只是将Phong着色模型应用于片段。结果写入FBO，其中包含用于第二次遍历的纹理。
- en: In the second pass, the `pass2` function is executed. We start by retrieving
    a noise value (`noise`), and the color from the render texture from the first
    pass (`color`). Then, we compute the `luminance` value for the color and store
    that result in the `green` variable. This will eventually be used as the green
    component of the final color.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次遍历中，执行 `pass2` 函数。我们首先检索一个噪声值（`noise`），以及来自第一次遍历的渲染纹理中的颜色（`color`）。然后，我们计算颜色的
    `luminance` 值并将其存储在 `green` 变量中。这最终将被用作最终颜色的绿色分量。
- en: We use the same texture coordinates here, assuming that the noise texture is
    the same size as the render texture. It would be more space efficient to use a
    smaller noise texture and tile it across the surface.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用相同的纹理坐标，假设噪声纹理与渲染纹理大小相同。使用较小的噪声纹理并在表面上进行平铺会更节省空间。
- en: The next step involves determining whether or not the fragment is inside the
    *binocular* lenses. We compute the distance to the center of the left lens (`dist1`),
    which is located in the viewport halfway from top to bottom and one quarter of
    the way from left to right. The right lens is located at the same vertical location,
    but three quarters of the way from left to right. The distance from the center
    of the right-hand lens is stored in `dist2`. If both `dist1` and `dist2` are greater
    than the radius of the virtual lenses, then we set `green` to `0`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步涉及确定片段是否位于**双目**镜头内。我们计算到左侧镜头中心的距离（`dist1`），它位于视口从上到下的中间位置，从左到右的四分之一处。右侧镜头位于相同的垂直位置，但从左到右的三分之四处。右侧镜头中心的距离存储在`dist2`中。如果`dist1`和`dist2`都大于虚拟镜头的半径，则将`green`设置为`0`。
- en: Finally, we return the final color, which has only a `green` component; the
    other two are set to zero. The value of `green` is multiplied by the noise value
    in order to add some noise to the image to simulate random interference in the
    signal. We add `0.25` to the noise value and clamp it between zero and one, in
    order to brighten the overall image. I have found that it appears a bit too dark
    if the noise value isn't biased in this way.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们返回最终颜色，它只有`green`分量；其他两个设置为零。`green`的值乘以噪声值，以便向图像添加一些噪声，以模拟信号中的随机干扰。我们将噪声值加`0.25`并将其夹在零和一之间，以使整体图像变亮。我发现如果噪声值没有以这种方式偏置，它看起来会稍微暗一些。
- en: There's more...
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It would make this shader even more effective if the noise varied in each frame
    during animation to simulate interference that is constantly changing. We can
    accomplish this roughly by modifying the texture coordinates used to access the
    noise texture in a time-dependent way. See the blog post mentioned in the following *See
    also* section for an example.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果噪声在动画的每一帧中变化，以模拟不断变化的干扰，这将使这个着色器更加有效。我们可以通过以时间依赖的方式修改用于访问噪声纹理的纹理坐标来大致实现这一点。请参阅以下*参见*部分中提到的博客文章以获取示例。
- en: See also
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter09/scenenightvision.cpp` file in the example code
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter09/scenenightvision.cpp`文件
- en: The *Rendering to a texture* recipe in [Chapter 5](a5d0db76-6dbb-470d-8685-42ab8ae077b1.xhtml),
    *Using Textures*
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第5章](a5d0db76-6dbb-470d-8685-42ab8ae077b1.xhtml)中的**将渲染输出到纹理**配方，*使用纹理*'
- en: The *Creating a noise texture using GLM* recipe
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用GLM创建噪声纹理**配方'
- en: This recipe was inspired by a blog post by Wojciech Toman (no longer publicly
    available)
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个配方灵感来源于Wojciech Toman的一篇博客文章（现已不再公开可用）
