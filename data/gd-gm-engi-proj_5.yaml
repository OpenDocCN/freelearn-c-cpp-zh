- en: Jungle Jump (Platformer)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jungle Jump (平台游戏)
- en: 'In this chapter, you''ll build a classic *platform*, style game in the tradition
    of *Super Mario Bros.* Platform games are a very popular genre, and understanding
    how they work can help you make a variety of different game styles. The physics
    of platformers can be deceptively complex, and you''ll see how Godot''s `KinematicBody2D`
    physics node has features to help you implement the character controller features
    you need for a satisfying experience. Take a look at the following screenshot:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将构建一个经典的*平台*风格游戏，遵循*超级马里奥兄弟*的传统。平台游戏是一个非常受欢迎的类型，了解它们的工作原理可以帮助您制作各种不同的游戏风格。平台游戏的物理可能具有欺骗性的复杂性，您将看到Godot的`KinematicBody2D`物理节点具有帮助您实现所需的角色控制器功能的特性。请看以下截图：
- en: '![](img/00106.jpeg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00106.jpeg)'
- en: 'In this project, you will learn about:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目，您将了解：
- en: Using the `KinematicBody2D` physics node
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`KinematicBody2D`物理节点
- en: Combining animations and user input to produce complex character behavior
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合动画和用户输入以产生复杂的角色行为
- en: Creating an infinitely scrolling background using ParallaxLayers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ParallaxLayers创建无限滚动的背景
- en: Organizing your project and planning for expansion
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织您的项目并规划扩展
- en: Project setup
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目设置
- en: 'Create a new project. Before you download the assets from the link that follows,
    you need to prepare the import settings for the game art. The art assets for this
    project use a *pixel art* style, which means they look best when not filtered,
    which is Godot''s default setting for textures. **Filtering** is a method by which
    the pixels of an image are smoothed. It can improve the look of some art, but
    not pixel-based images:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的项目。在您从以下链接下载资源之前，您需要为游戏艺术准备导入设置。本项目使用的艺术资源采用*像素艺术*风格，这意味着它们在没有过滤的情况下看起来最好，这是Godot为纹理的默认设置。*过滤*是一种通过平滑图像像素的方法。它可以改善某些艺术作品的外观，但不是基于像素的图像：
- en: '![](img/00107.jpeg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00107.jpeg)'
- en: 'It''s inconvenient to have to disable this for every image, so Godot allows
    you to customize the default import settings. Click on the `icon.png` file in
    the FileSystem dock, then click the Import tab next to the Scene tab on the right.
    This window allows you to change the import settings for the file you''ve selected.
    Uncheck the Filter property, then click Preset and choose Set as Default for ''Texture''.
    This way, all images will be imported with filtering disabled. Refer to the following
    screenshot:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个图像都必须禁用此功能是不方便的，因此Godot允许您自定义默认导入设置。在文件系统浮动窗口中单击`icon.png`文件，然后单击右侧场景标签旁边的导入标签。此窗口允许您更改所选文件的导入设置。取消选中过滤属性，然后单击预设并选择将“纹理”设置为默认值。这样，所有图像都将导入时禁用过滤。请参考以下截图：
- en: '![](img/00108.jpeg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00108.jpeg)'
- en: If you've already imported images, their import settings won't be updated automatically.
    After changing the default, you'll have to reimport any existing images. You can
    select multiple files in the FileSystem dock and click the Reimport button to
    apply the settings to many files at once.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经导入了图像，它们的导入设置不会自动更新。在更改默认设置后，您必须重新导入任何现有图像。您可以在文件系统浮动窗口中选择多个文件，然后单击重新导入按钮，一次性应用设置到多个文件。
- en: Now, you can download the game assets from the following link and unzip them
    in your project folder. Godot will import all the images with the new default
    settings, [https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases](https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以从以下链接下载游戏资源，并在您的项目文件夹中解压缩它们。Godot将使用新的默认设置导入所有图像，[https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases](https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases)
- en: Next, open Project | Project Settingsand under Rendering/Quality, set Use Pixel
    Snap to `On`. This will ensure that all images will be aligned properly—something
    that will be very important when you're designing your game's levels.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开项目 | 项目设置，在渲染/质量下，将使用像素捕捉设置为`开启`。这将确保所有图像都能正确对齐——这在您设计游戏关卡时将非常重要。
- en: While you have the settings window open, go to the Display/Window section and
    change Stretch/Mode to `2d` and Aspect to `expand`. These settings will allow
    the user to resize the game window while preserving the image's quality. Once
    the project has been completed, you'll be able to see the effects of this setting.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当您打开设置窗口时，转到显示/窗口部分，将拉伸/模式更改为`2d`并将纵横比更改为`expand`。这些设置将允许用户在保持图像质量的同时调整游戏窗口的大小。一旦项目完成，您将能够看到此设置的效果。
- en: 'Next, set up the collision layer names so that it will be more convenient to
    set up collisions between different types of objects. Go to Layer Names/2d Physics and
    name the first four layers like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，设置碰撞层名称，以便更方便地设置不同类型对象之间的碰撞。转到“层名称/2d Physics”并按如下方式命名前四个层：
- en: '![](img/00109.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00109.jpeg)'
- en: 'Finally, add the following actions for the player controls in the Input Map
    tab under Project | Project Settings:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在“输入映射”选项卡下“项目”|“项目设置”中为玩家控制添加以下动作：
- en: '| **Action Name** | **Key(s)** |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **动作名称** | **按键(s)** |'
- en: '| right | D, → |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 向右 | D, → |'
- en: '| left | A, ← |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 向左 | A, ← |'
- en: '| jump | Space |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 跳跃 | 空格 |'
- en: '| crouch | S, ↓ |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 蹲下 | S, ↓ |'
- en: '| climb | W, ↑ |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 爬升 | W, ↑ |'
- en: Introducing kinematic bodies
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍运动学体
- en: A platform game requires gravity, collisions, jumping, and other physics behavior,
    so you might think that `RigidBody2D` would be the perfect choice to implement
    the character's movement. In practice, however, you'll find that the *realistic*
    physics of the rigid body are not desirable for a platform character. To the player,
    realism is less important than responsive control and an *action* feel. As the
    developer, you therefore want to have precise control over the character's movements
    and collision response. For this reason, a kinematic body is usually the better
    choice for a platform character.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 平台游戏需要重力、碰撞、跳跃和其他物理行为，因此您可能会认为 `RigidBody2D` 是实现角色移动的完美选择。然而，在实践中，您会发现刚体的**真实**物理特性对于平台角色来说并不理想。对于玩家来说，真实感不如响应控制和**动作**感重要。因此，作为开发者，您希望对角色的移动和碰撞响应有精确的控制。因此，对于平台角色来说，运动学体通常是更好的选择。
- en: The `KinematicBody2D` node is designed for implementing bodies that are to be
    controlled directly by the user or via code. These nodes detect collisions with
    other bodies when moving, but are not affected by global physics properties like
    gravity or friction. This doesn't mean that a kinematic body can't be affected
    by gravity and other forces, just that you must calculate those forces and their
    effects in code; the engine will not move a kinematic body automatically.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`KinematicBody2D` 节点是为了实现那些需要由用户直接控制或通过代码控制的物体而设计的。这些节点在移动时检测与其他物体的碰撞，但不受全局物理属性（如重力或摩擦）的影响。这并不意味着运动学体不能受到重力和其他力的作用，只是您必须在代码中计算这些力和它们的效果；引擎不会自动移动运动学体。'
- en: When moving `KinematicBody2D`, as with `RigidBody2D`, you should not set its
    `position` directly. Instead, you use either the `move_and_collide()` or `move_and_slide()` methods.
    These methods move the body along a given vector and instantly stop if a collision
    is detected with another body. After `KinematicBody2D` has collided, any *collision
    response* must be coded manually.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当移动 `KinematicBody2D` 时，与 `RigidBody2D` 类似，您不应直接设置其 `position`。相反，您可以使用 `move_and_collide()`
    或 `move_and_slide()` 方法。这些方法沿着给定的向量移动身体，并在检测到与其他物体的碰撞时立即停止。在 `KinematicBody2D`
    碰撞后，任何碰撞响应都必须手动编码。
- en: Collision response
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞响应
- en: After a collision, you may want the body to bounce, to slide along a wall, or
    to alter the properties of the object it hit. The way you handle collision response
    depends on which method you used to move the body.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在碰撞后，您可能希望物体弹跳、沿墙壁滑动或改变它撞击物体的属性。您处理碰撞响应的方式取决于您用于移动物体的方法。
- en: move_and_collide
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: move_and_collide
- en: When using `move_and_collide()`, the function returns a `KinematicCollision2D`
    object upon collision. This object contains information about the collision and
    the colliding body. You can use this information to determine the response. Note
    that the function returns `null` when the movement was completed successfully
    with no collision.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `move_and_collide()` 时，在碰撞发生时，该函数返回一个 `KinematicCollision2D` 对象。此对象包含有关碰撞和碰撞体的信息。您可以使用这些信息来确定响应。请注意，当运动成功完成且没有碰撞时，函数返回
    `null`。
- en: 'For example, if you want the body to bounce off of the colliding object, you
    could use the following script:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您想让物体从碰撞对象上弹开，可以使用以下脚本：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: move_and_slide
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: move_and_slide
- en: Sliding is a very common option for collision response. Imagine a player moving
    along walls in a top-down game or running up and down slopes in a platformer.
    While it's possible to code this response yourself after using `move_and_collide()`,
    `move_and_slide()` provides a convenient way to implement sliding movement. When
    using this method, the body will automatically slide along the colliding surface.
    In addition, sliding collisions allow you to use methods like `is_on_floor()`
    to detect the orientation of the colliding surface.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 滑动是碰撞响应中一个非常常见的选项。想象一下玩家在俯视游戏中沿着墙壁移动或在平台游戏中上下跑斜坡。虽然在使用`move_and_collide()`后可以自己编写这个响应的代码，但`move_and_slide()`提供了一个方便的方式来实现滑动移动。当使用这种方法时，物体将自动沿着碰撞表面滑动。此外，滑动碰撞允许你使用`is_on_floor()`等方法来检测碰撞表面的方向。
- en: Since this project will require not just moving along the ground, but also running
    up and down slopes, `move_and_slide()` is going to play a large role in your player's
    movement. You'll see how it works as you build up the player object.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个项目不仅需要在地面上移动，还需要在斜坡上跑上跑下，`move_and_slide()` 函数将在你的玩家移动中扮演重要角色。当你构建玩家对象时，你会看到它是如何工作的。
- en: Player scene
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家场景
- en: Open a new scene and add a `KinematicBody2D` object named `Player` as the root
    and save the scene (don't forget to click the Make children unselectable button).
    When saving the `Player` scene, you should also create a new folder to contain
    it. This will help keep your project folder organized as you add more scenes and
    scripts.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的场景，并将名为`Player`的`KinematicBody2D`对象作为根添加到场景中，并保存场景（别忘了点击“使子对象不可选择”按钮）。当保存`Player`场景时，你还应该创建一个新的文件夹来包含它。这将有助于在你添加更多场景和脚本时保持你的项目文件夹组织有序。
- en: As you've done in other projects, you'll include all the nodes that the player
    character needs to function in the `Player` scene. For this game, that means handling
    collisions with various game objects, including platforms, enemies, and collectibles;
    displaying animations for actions, such as running or jumping; and a camera to
    follow the player around the level.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你在其他项目中做的那样，你将在`Player`场景中包含玩家角色需要的功能节点。对于这个游戏，这意味着处理与各种游戏对象的碰撞，包括平台、敌人和可收集物品；显示跑步或跳跃等动作的动画；以及一个跟随玩家在关卡中移动的摄像头。
- en: Scripting the various animations can quickly become unmanageable, so you'll
    use a *finite state machine* to manage and track the player's state. See [Chapter
    3](part0079.html#2BASE0-5809b3bef8d2453086d97dfad17b2ee2), *Escape the Maze*,
    to review how the simplified FSM was built. You'll follow a similar pattern for
    this project.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 编写各种动画可能会很快变得难以管理，所以你会使用一个*有限状态机*来管理和跟踪玩家的状态。参见[第3章](part0079.html#2BASE0-5809b3bef8d2453086d97dfad17b2ee2)，*逃离迷宫*，回顾如何构建简化的FSM。你将遵循类似的项目模式。
- en: Collision Layer/Mask
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞层/掩码
- en: A body's collision layer property sets what layer(s) the body is found on. `Player` needs
    to be assigned to the player layer you named in Project Settings.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一个物体的碰撞层属性设置了这个物体所在的层。`Player`需要分配到你在项目设置中命名的玩家层。
- en: 'The Collision/Mask property allows you to set what types of objects the body
    will detect. Set the Player layer to `player` and its mask to environment, enemies,
    and collectibles (`1`, `3`, and `4`):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞/掩码属性允许你设置身体将检测的对象类型。将`Player`层设置为`player`，其掩码设置为环境、敌人和可收集物品（`1`、`3`和`4`）：
- en: '![](img/00110.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00110.jpeg)'
- en: Sprite
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精灵
- en: 'Add a Sprite node to `Player`. Drag the `res://assets/player_sheet.png` file
    from the FileSystem dock and drop it in the Texture property of the `Sprite`.
    The player animation is saved in the form of a sprite sheet:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Player`中添加一个Sprite节点。从FileSystem面板拖动`res://assets/player_sheet.png`文件并将其放入`Sprite`的Texture属性中。玩家动画以精灵图集的形式保存：
- en: '![](img/00111.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00111.jpeg)'
- en: 'You''ll use `AnimationPlayer` to handle the animations, so in the Animation properties
    of `Sprite`, set Vframes to `1` and Hframes to `19`. Set Frame to `7` to begin,
    as this is the frame that shows the character standing still (it''s the first
    frame of the `idle` animation):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用`AnimationPlayer`来处理动画，所以在`Sprite`的Animation属性中，将Vframes设置为`1`，将Hframes设置为`19`。将Frame设置为`7`开始，因为这个帧显示了角色静止不动（它是`idle`动画的第一帧）：
- en: '![](img/00112.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00112.jpeg)'
- en: Collision shape
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞形状
- en: As with other physics bodies, `KinematicBody2D` needs a shape assigned to define
    its collision bounds. Add a `CollisionShape2D` object and create a new `RectangleShape2D` object
    inside it. When sizing the rectangle, you want it to reach the bottom of the image
    but not be quite as wide. In general, making the collision shape a bit smaller
    than the image will result in a better *feel* when playing, avoiding the experience
    of hitting something that looks like it wouldn't result in a collision.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他物理体一样，`KinematicBody2D`需要一个形状来定义其碰撞边界。添加一个`CollisionShape2D`对象并在其中创建一个新的`RectangleShape2D`对象。在调整矩形大小时，您希望它达到图像的底部，但不要那么宽。一般来说，使碰撞形状比图像略小，在游戏时会有更好的*感觉*，避免击中看起来不会导致碰撞的东西的体验。
- en: 'You''ll also need to offset the shape a small amount to make it fit. Setting Position to
    `(0, 5)` works well. When you''re done, it should look approximately like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要稍微偏移形状以使其适合。将位置设置为`(0, 5)`效果很好。完成时，它应该看起来大约是这样的：
- en: '![](img/00113.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00113.jpeg)'
- en: Shapes
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 形状
- en: 'Some developers prefer a capsule shape over a rectangle shape for sidescrolling
    characters. A capsule is a pill-shaped collision that''s rounded on both ends:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者更喜欢胶囊形状而不是矩形形状用于横版滚动角色。胶囊是一种两端圆润的药片形状碰撞：
- en: '![](img/00114.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00114.jpeg)'
- en: However, while this shape might seem to *cover* the sprite better, it can lead
    to difficulties when implementing platformer-style movement. For example, when
    standing too near the edge of a platform, the character may slide off due to the
    rounded bottom, which can be very frustrating for the player.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，虽然这个形状可能看起来能更好地*覆盖*精灵，但在实现平台式移动时可能会遇到困难。例如，当站在平台边缘太近时，角色可能会因为圆润的底部而滑落，这对玩家来说可能非常令人沮丧。
- en: In some cases, depending on the complexity of your character and its interactions
    with other objects, you may want to add multiple shapes to the same object. You
    might have one shape at the character's feet to detect ground collisions, another
    on its body to detect damage (sometimes called a hurtbox), and yet another covering
    the player's front to detect contact with walls.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，根据您角色的复杂性和与其他对象的交互，您可能需要将多个形状添加到同一个对象中。您可能需要在角色的脚下放置一个形状以检测地面碰撞，另一个在其身体上以检测伤害（有时称为受伤框），还有一个覆盖玩家前方以检测与墙壁接触。
- en: It's recommended that you stick to `RectangleShape2D`, as shown in the preceding
    screenshot, for this character. However, once you've finished the project, you
    should try changing the player's collision shape to `CapsuleShape2D` and observing
    the resulting behavior. If you like it better, feel free to use it instead.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您坚持使用如图所示的前一个屏幕截图中的`RectangleShape2D`。然而，一旦您完成了项目，您应该尝试将玩家的碰撞形状更改为`CapsuleShape2D`并观察其行为。如果您更喜欢它，请随时使用它代替。
- en: Animations
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画
- en: 'Add an `AnimationPlayer` node to the `Player` scene. You''ll use this node
    to change the Frame property on `Sprite` to display the character''s animations.
    Start by making a new animation named `idle`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 将`AnimationPlayer`节点添加到`Player`场景中。您将使用此节点来更改`Sprite`上的帧属性以显示角色的动画。首先创建一个名为`idle`的新动画：
- en: '![](img/00115.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00115.jpeg)'
- en: 'Set Length to `0.4` seconds and keep Step at `0.1` seconds. Change the Frame of `Sprite`
    to `7` and click the Add keyframe button next to the Frame property to create
    a new animation track, then press it again, noting that it automatically increments
    the Frame property:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将长度设置为`0.4`秒，并保持步长为`0.1`秒。将`Sprite`的帧更改为`7`，然后点击帧属性旁边的添加关键帧按钮以创建一个新的动画轨道，然后再次点击它，注意它会自动增加帧属性：
- en: '![](img/00116.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00116.jpeg)'
- en: 'Continue pressing it until you have frames `7` through `10`. Finally, click
    the Enable/Disable looping button to enable looping and then press Play to view
    your animation. Your animation setup should look like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 持续按住它，直到您有帧`7`到`10`。最后，点击启用/禁用循环按钮以启用循环，然后按播放以查看您的动画。您的动画设置应如下所示：
- en: '![](img/00117.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00117.jpeg)'
- en: 'Now you need to repeat the process for the other animations. See the following
    table for a list of settings:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您需要为其他动画重复此过程。以下表格列出了设置列表：
- en: '| **name** | **length** | **frames** | **looping** |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **长度** | **帧** | **循环** |'
- en: '| `idle` | `0.4` | `7, 8, 9 ,10` | on |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `idle` | `0.4` | `7, 8, 9 ,10` | on |'
- en: '| `run` | `0.5` | `13, 14, 15, 16, 17, 18` | on |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `run` | `0.5` | `13, 14, 15, 16, 17, 18` | on |'
- en: '| `hurt` | `0.2` | `5, 6` | on |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `hurt` | `0.2` | `5, 6` | on |'
- en: '| `jump_up` | `0.1` | `11` | off |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `jump_up` | `0.1` | `11` | off |'
- en: '| `jump_down` | `0.1` | `12` | 0ff |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `jump_down` | `0.1` | `12` | 0ff |'
- en: Finishing up the scene tree
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成场景树
- en: Add `Camera2D` to the `Player` scene. This node will keep the game window centered
    on the player as it moves around the level. You can also use it to zoom in on
    the player, since the pixel art is relatively small. Remember, since you set filtering
    off in the import settings, the player's texture will remain pixelated and blocky
    when zoomed in.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Camera2D` 添加到 `Player` 场景中。这个节点将在玩家在关卡中移动时保持游戏窗口在玩家中心。你还可以使用它来放大玩家，因为像素艺术相对较小。记住，由于你在导入设置中关闭了过滤，当放大时，玩家的纹理将保持像素化和块状。
- en: To enable the camera, click the Current property to `On`, then set the Zoom property
    to `(0.4, 0.4)`. Values smaller than one zoom the camera in, while larger values
    zoom it out.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用相机，点击当前属性将其设置为 `On`，然后设置缩放属性为 `(0.4, 0.4)`。小于一的值会使相机拉近，而大于一的值会使相机拉远。
- en: Player states
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家状态
- en: The player character has a wide variety of behaviors, such as jumping, running,
    and crouching. Coding such behaviors can become very complex and hard to manage.
    One solution is to use Boolean variables (`is_jumping` or `is_running`, for example),
    but this leads to possibly confusing states (what if `is_crouching` and `is_jumping`
    are both `true`?) and quickly leads to spaghetti code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家角色有多种行为，如跳跃、奔跑和蹲下。编写这样的行为可能会变得非常复杂且难以管理。一种解决方案是使用布尔变量（例如 `is_jumping` 或 `is_running`），但这可能导致可能令人困惑的状态（如果
    `is_crouching` 和 `is_jumping` 都为 `true` 会怎样？）并且很快就会导致代码混乱。
- en: A better solution to this problem is to use a state machine to handle the player's
    current state and control the transitions to other states. Finite state machines
    were discussed in [Chapter 3](part0079.html#2BASE0-5809b3bef8d2453086d97dfad17b2ee2), *Escape
    the Maze*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的更好方法是使用状态机来处理玩家的当前状态并控制到其他状态的转换。有限状态机在第 3 章[逃离迷宫](part0079.html#2BASE0-5809b3bef8d2453086d97dfad17b2ee2)中进行了讨论。
- en: 'Here is a diagram of the player''s states and the transitions between them:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是玩家状态及其之间转换的图示：
- en: '![](img/00118.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00118.jpeg)'
- en: As you can see, state machine diagrams can become quite complex, even with a
    relatively small number of states.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，状态机图可以变得相当复杂，即使状态数量相对较少。
- en: Note that while the spritesheet contains animations for them, the CROUCH and
    CLIMB animations are not included here. This is to keep the number of states manageable
    at the beginning of the project. Later, you'll have the opportunity to add them
    to the player's state machine.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然精灵表包含它们的动画，但蹲下和攀爬动画不包括在内。这是为了在项目开始时保持状态数量可管理。稍后，你将有机会将它们添加到玩家的状态机中。
- en: Player script
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家脚本
- en: 'Attach a new script to the `Player` node. Add the following code to create
    the player''s state machine:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个新的脚本附加到 `Player` 节点上。添加以下代码以创建玩家的状态机：
- en: '[PRE1]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once again, you''re using `enum` to list the allowed states for the system.
    When you want to change the player''s state, you''ll call `change_state()`, for
    example: `change_state(IDLE)`. For now, the script only changes the animation
    value, but you''ll add more state functionality later.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，你正在使用 `enum` 来列出系统允许的状态。当你想要改变玩家的状态时，你会调用 `change_state()`，例如：`change_state(IDLE)`。目前，脚本只改变动画值，但之后你将添加更多状态功能。
- en: You may be asking, *why not just play the animation when the state changes?
    Why this new_anim business?* This is because when you call `play()` on `AnimationPlayer`,
    it starts the animation from the beginning. If you did that while running, for
    example, you'd only see the first frame of the run animation as it restarted every
    frame. By using the `new_anim` variable, you can let the current animation continue
    to play smoothly until you want it to change.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，为什么不在状态改变时直接播放动画？为什么要引入新的动画业务？这是因为当你对 `AnimationPlayer` 调用 `play()` 时，它会从动画的开始处开始播放。如果你在运行时这样做，例如，你将只能看到跑步动画的第一帧，因为每一帧都会重新开始。通过使用
    `new_anim` 变量，你可以让当前动画继续平滑播放，直到你想要改变它。
- en: Player movement
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家移动
- en: 'The player needs three controls—left, right, and jump. The combination of the
    current state plus which keys are pressed will trigger a state change if the transition
    is allowed by the state rules. Add the `get_input()` function to process the inputs
    and determine the result:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家需要三个控制键——左、右和跳跃。当前状态与按下的键的组合将触发状态改变，如果状态规则允许转换的话。添加 `get_input()` 函数来处理输入并确定结果：
- en: '[PRE2]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that the jump check is using `is_action_just_pressed()` rather than `is_action_pressed()`.
    While the latter always returns `true` as long as the key is held down, the former
    is only `true` in the frame after the key was pressed. This means that the player
    must press the jump key each time they want to jump.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，跳跃检查使用的是`is_action_just_pressed()`而不是`is_action_pressed()`。虽然后者只要按键按下就会始终返回`true`，但前者只有在按键按下后的帧中才是`true`。这意味着玩家必须每次想要跳跃时都按下跳跃键。
- en: 'Now, call this function from `_physics_process()`, add the pull of gravity
    to the player''s `velocity`, and call the `move_and_slide()` method to move the
    body:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从`_physics_process()`函数中调用此函数，将重力拉力添加到玩家的`velocity`中，然后调用`move_and_slide()`方法来移动身体：
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The second parameter of `move_and_slide()` is a *normal* vector, indicating
    what surface direction the engine should consider to be the ground. In physics
    and geometry, a *normal* is a vector perpendicular to a surface, defining the
    direction a surface is facing. Using `(0, -1)`, which is a vector pointing upwards,
    the top of a horizontal surface will be considered as ground. Refer to the following
    screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`move_and_slide()`的第二个参数是一个*法线*向量，表示引擎应考虑为地面的表面方向。在物理学和几何学中，*法线*是一个垂直于表面的向量，定义了表面的朝向方向。使用`(0,
    -1)`，这是一个向上指的向量，水平表面的顶部将被视为地面。请参考以下截图：'
- en: '![](img/00119.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00119.jpeg)'
- en: 'After moving with `move_and_slide()`, the physics engine will use this information
    to set the value of the `is_on_floor()`, `is_on_wall()` and `is_on_ceiling` methods.
    You can use this fact to detect when the jump ends by adding this after the move:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`move_and_slide()`移动后，物理引擎将使用这些信息来设置`is_on_floor()`、`is_on_wall()`和`is_on_ceiling`方法。你可以在移动后添加以下内容来检测跳跃何时结束：
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, the jump will look better if the animation switches from `jump_up`
    to `jump_down` when falling:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果动画在下落时从`jump_up`切换到`jump_down`，跳跃看起来会更好：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: At this point, it would be a good idea to test out the movement and make sure
    everything is working. You can't just run the player scene though, because the
    player will just start falling without a surface to stand on.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，测试移动并确保一切正常工作是个好主意。但你不能只是运行玩家场景，因为玩家会因为没有站立表面而开始下落。
- en: 'Create a new scene and add a `Node` called `Main` (later, this will become
    your real main scene). Add an instance of the `Player`, then add a `StaticBody2D`
    with a rectangular `CollisionShape2D`. Stretch the collision shape horizontally
    so that it''s wide enough to walk back and forth on (like a platform) and place
    it below the character:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景并添加一个名为`Main`的`Node`（稍后，这将成为你的真实主场景）。添加一个`Player`实例，然后添加一个带有矩形`CollisionShape2D`的`StaticBody2D`。将碰撞形状水平拉伸，使其足够宽，可以来回走动（就像一个平台）并将其放置在角色下方：
- en: '![](img/00120.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00120.jpeg)'
- en: Press Play Scene and you should see the player stop falling and run the `idle`
    animation when it hits the static body.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 按下“播放场景”，你应该看到玩家在撞击静态身体时停止下落并运行`idle`动画。
- en: Before moving on, make sure that all the movement and animations are working
    correctly. Run and jump in all directions and check that the correct animations
    are playing whenever the state changes. If you find any problems, review the previous
    sections and make sure you didn't miss a step.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保所有移动和动画都正常工作。在所有方向上跑和跳，并检查状态改变时是否播放了正确的动画。如果你发现任何问题，请回顾前面的部分，并确保你没有错过任何步骤。
- en: 'Later, once the level is complete, the player will be passed a spawn location.
    To handle this, add this function to the `Player.gd` script:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，一旦关卡完成，玩家将获得一个出生位置。为了处理这个问题，将此函数添加到`Player.gd`脚本中：
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Player health
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家健康
- en: Eventually, the player is going to encounter danger, so you should add a damage
    system. The player will start with three *hearts* and lose one each time they
    are damaged.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，玩家会遇到危险，因此你应该添加一个伤害系统。玩家将开始时有三个*心形*，每次受伤都会失去一个。
- en: 'Add the following to the top of the script:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到脚本顶部：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `life_changed` signal will be emitted whenever the value of `life` changes,
    notifying the display to update. `dead` will be emitted when `life` reaches `0`.
    Add these two lines to the `start()` function:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当`life`的值改变时，`life_changed`信号将被发出，通知显示更新。当`life`达到`0`时，将发出`dead`。将这两行添加到`start()`函数中：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There are two possible ways for the player to be hurt: running into a *spike*
    object in the environment, or being hit by an enemy. In either event, the following
    function can be called:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家受伤有两种可能的方式：在环境中撞到*尖刺*对象，或者被敌人击中。在任何一种情况下，都可以调用以下函数：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is being nice to the player: if they''re already hurt, they can''t get
    hurt again (at least for the brief time until the *hurt* animation has stopped
    playing).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对玩家的一种友好行为：如果他们已经受伤，他们就不能再次受伤（至少在*受伤*动画停止播放的短暂时间内）。
- en: 'There are several things to do when the state changes to `HURT` in `change_state()`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当`change_state()`中的状态变为`HURT`时，需要执行几件事情：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Not only does does the player lose a life, but they are also bounced up and
    away from the damaging object. After a short time, the state changes back to `IDLE`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅玩家会失去生命，他们还会被弹起并远离造成伤害的对象。经过一段时间后，状态会变回`IDLE`。
- en: 'Also, input will be disabled while the player is in the `HURT` state. Add this
    to the beginning of `get_input()`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当玩家处于`HURT`状态时，将禁用输入。将以下内容添加到`get_input()`的开始部分：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, the player is ready to take damage once the rest of the game is set up.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当游戏的其他部分设置完毕后，玩家就可以开始承受伤害了。
- en: Collectible items
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可收集物品
- en: 'Before you start making the level, you need to create some pickups for the
    player to collect, since those will be part of the level as well. The `assets/sprites`
    folder contains sprite sheets for two types of collectibles: cherries and gems.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始制作关卡之前，你需要为玩家创建一些可收集的物品，因为那些也将是关卡的一部分。`assets/sprites`文件夹包含两种类型可收集物品的精灵图集：樱桃和宝石。
- en: 'Rather than make separate scenes for each type of item, you can use a single
    scene and merely swap out the sprite sheet texture. Both objects will have the
    same behavior: animating in place and disappearing (that is, being collected)
    when contacted by the player. You can also add a `Tween` animation for the pickup
    (see [Chapter 1](part0022.html#KVCC0-5809b3bef8d2453086d97dfad17b2ee2), *Introduction*,
    for an example).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是为每种类型的物品创建单独的场景，你可以使用一个单一的场景，只需更换精灵图集纹理即可。这两个对象将具有相同的行为：在原地动画并在被玩家接触时消失（即被收集）。你还可以为拾取动作添加一个`Tween`动画（参见[第1章](part0022.html#KVCC0-5809b3bef8d2453086d97dfad17b2ee2)，*简介*，以获取示例）。
- en: Collectible scene
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可收集场景
- en: Start the new scene with an `Area2D` and name it `Collectible`. An area is a
    good choice for these objects because you want to detect when the player contacts
    them (using the `body_entered` signal), but you don't need collision response
    from them. In the Inspector, set the Collision/Layer to collectibles (layer 4)
    and the Collision/Mask to player (layer 2). This will ensure that only the `Player`
    node will be able to collect an item while the enemies will pass right through.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Area2D`启动新场景并将其命名为`Collectible`。区域是这些对象的好选择，因为你想要检测玩家何时接触它们（使用`body_entered`信号），但你不需要从它们那里获得碰撞响应。在检查器中，将碰撞/层设置为可收集物品（层4）和碰撞/掩码设置为玩家（层2）。这将确保只有`Player`节点能够收集物品，而敌人将直接穿过。
- en: 'Add three child nodes: `Sprite`, `CollisionShape2D`, and `AnimationPlayer`,
    then drag the `res://assets/cherry.png` Sprite sheet into the Sprite''s Texture.
    Set the Vframes to `1` and Hframes to `5`. Add a rectangle shape to `CollisionShape2D`
    and size it appropriately.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 添加三个子节点：`Sprite`、`CollisionShape2D`和`AnimationPlayer`，然后将`res://assets/cherry.png`精灵图集拖放到精灵的纹理中。将Vframes设置为`1`，Hframes设置为`5`。向`CollisionShape2D`添加一个矩形形状并适当调整其大小。
- en: As a general rule, you should size your objects' collision shapes so that they
    benefit the player. This means that enemy hitboxes should generally be a little
    smaller than the image while the hitboxes of beneficial items should be slightly
    oversized. This reduces player frustration and results in a better gameplay experience.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，你应该调整你的对象的碰撞形状，以便它们对玩家有益。这意味着敌人的击中框应该通常比图像略小，而有益物品的击中框应该略微放大。这减少了玩家的挫败感，并导致更好的游戏体验。
- en: Add a new animation to `AnimationPlayer` (you only need one, so you can just
    name it `anim`). Set the Length to `1.6` seconds and the Step to `0.2` seconds.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 向`AnimationPlayer`添加一个新的动画（你只需要一个，所以你可以直接命名为`anim`）。将长度设置为`1.6`秒，步长设置为`0.2`秒。
- en: 'Set the Sprite''s Frame property to `0` and click the keyframe button to create
    the track. When you reach frame number four, start reversing the order back down
    to `1`. The full sequence of keyframes should be:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将精灵的帧属性设置为`0`并单击关键帧按钮以创建轨迹。当你达到第四帧时，开始按顺序反向回到`1`。完整的关键帧序列应该是：
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Enable looping and press the Play button. Now, you have a nicely animated cherry!
    Drag `res://assets/gem.png` into the texture and check that it animates as well.
    Finally, click the Autoplay on Load button to ensure the animation will play automatically
    when the scene begins. Refer to the following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 启用循环并按下播放按钮。现在，你有一个漂亮的樱桃动画了！将`res://assets/gem.png`拖入纹理中，并检查它是否也进行了动画处理。最后，点击“加载时自动播放”按钮，以确保动画将在场景开始时自动播放。请参考以下截图：
- en: '![](img/00121.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/00121.jpeg)'
- en: Collectible script
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可收集物品脚本
- en: 'The Collectible''s script needs to do two things:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 可收集物品的脚本需要完成两件事：
- en: Set the start conditions (`texture` and `position`)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置起始条件（`texture`和`position`）
- en: Detect when the player enters the area
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测玩家何时进入区域
- en: 'For the first part, add the following code to the new script:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一部分，将以下代码添加到新脚本中：
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `pickup` signal will be emitted when the player collects the item. In the
    `textures` dictionary, you have a list of the item types and their corresponding
    texture locations. Note that you can quickly paste those file paths by right-clicking
    on the file in the FileSystem dock and choosing Copy Path:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家收集物品时，将发出`pickup`信号。在`textures`字典中，你有一个物品类型及其对应纹理位置的列表。请注意，你可以通过在FileSystem窗口中右键单击文件并选择“复制路径”来快速粘贴这些文件路径：
- en: '![](img/00122.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/00122.jpeg)'
- en: Next, you have an `init()` function that sets the `texture` and `position` to
    the given values. The level script will use this function to spawn all the collectibles
    that you add to your level map.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你有一个`init()`函数，它将`texture`和`position`设置为给定的值。级别脚本将使用此函数来生成你添加到级别地图中的所有可收集物品。
- en: 'Finally, you need the object to detect when it''s been picked up. Click on
    the `Area2D` and connect its `body_entered` signal. Add the following code to
    the created function:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要检测物体何时被拾起。点击`Area2D`并连接其`body_entered`信号。将以下代码添加到创建的函数中：
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Emitting the signal will allow the game's script to react appropriately to the
    item pickup. It can add to the score, increase the player's speed, or whatever
    other effect you want the item to apply.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 发出信号将允许游戏脚本适当地对物品拾取做出反应。它可以增加分数、提高玩家的速度，或者实现你希望物品产生的任何其他效果。
- en: Designing the level
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计级别
- en: It wouldn't be a platformer without jumps. For most readers, this section will
    take up the largest chunk of time. Once you start designing a level, you'll find
    it's a lot of fun to lay out all the pieces, creating challenging jumps, secret
    paths, and dangerous encounters.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有跳跃，那就不是平台游戏。对于大多数读者来说，这一部分将占用最多的时间。一旦你开始设计一个级别，你会发现布置所有部件、创建挑战性的跳跃、秘密路径和危险遭遇非常有趣。
- en: First, you'll create a generic `Level` scene containing all the nodes and code
    that is common to all levels. You can then create any number of level scenes that
    inherit from this master level.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将创建一个通用的`Level`场景，包含所有级别共有的节点和代码。然后你可以创建任意数量的级别场景，这些场景继承自这个主级别。
- en: TileSet configuration
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TileSet配置
- en: 'In the `assets` folder you downloaded at the beginning of the project is a
    `tilesets` folder. It contains three ready-made `TileSet` resources using the
    16x16 art for the game:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目开始时下载的`assets`文件夹中有一个`tilesets`文件夹。它包含三个使用16x16艺术风格的预制的`TileSet`资源：
- en: '`tiles_world.tres`: Ground and platform tiles'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tiles_world.tres`：地面和平台瓦片'
- en: '`tiles_items.tres`: Decorative items, foreground objects, and collectibles'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tiles_items.tres`：装饰物品、前景物体和可收集物品'
- en: '`tiles_spikes.tres`: Danger items'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tiles_spikes.tres`：危险物品'
- en: It is recommended that you use these tile sets to create the levels for this
    project. However, if you would rather make them yourself, the original art is
    in `res://assets/environment/layers`. See [Chapter 2](part0036.html#12AK80-5809b3bef8d2453086d97dfad17b2ee2),
    *Coin Dash*, to review how to create a `TileSet` resource.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 建议你使用这些瓦片集来创建本项目的级别。然而，如果你更愿意自己制作，原始艺术作品在`res://assets/environment/layers`中。参见[第2章](part0036.html#12AK80-5809b3bef8d2453086d97dfad17b2ee2)，*Coin
    Dash*，以复习如何创建`TileSet`资源。
- en: Base-level setup
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础级别设置
- en: Create a new scene and add a `Node2D` named `Level`. Save the scene in a new
    folder called `levels`. This is where you'll save any other levels you create,
    after inheriting from `Level.tscn`. The node hierarchy will be the same for all
    levels—only the layout will be different.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景并添加一个名为`Level`的`Node2D`。将场景保存在名为`levels`的新文件夹中。这是你保存从`Level.tscn`继承的所有其他级别的位置。所有级别的节点层次结构都将相同——只有布局会有所不同。
- en: 'Next, add a `TileMap` and set its Cell/Size to `(16, 16)`, then duplicate it
    three times (press *Ctrl* + *D* to duplicate a node). These will be the layers
    of your level, holding different tiles and information about the layout. Name
    the four `TileMap` instances as follows and drag-and-drop the corresponding `TileSet`
    into the Tile Set property of each. Refer to the following table:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加一个`TileMap`并将其单元格/大小设置为`(16, 16)`，然后将其复制三次（按*Ctrl* + *D*复制节点）。这些将是你的关卡层，包含不同的瓦片和布局信息。将四个`TileMap`实例命名为以下名称，并将相应的`TileSet`拖放到每个的“Tile
    Set”属性中。请参考以下表格：
- en: '| **TileMap** | **Tile Set** |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| **TileMap** | **Tile Set** |'
- en: '| `World` | `tiles_world.tres` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `World` | `tiles_world.tres` |'
- en: '| `Objects` | `tiles_items.tres` |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `Objects` | `tiles_items.tres` |'
- en: '| `Pickups` | `tiles_items.tres` |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `Pickups` | `tiles_items.tres` |'
- en: '| `Danger` | `tiles_spikes.tres` |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `Danger` | `tiles_spikes.tres` |'
- en: It's a good idea to press the Lock button on your `TileMap` nodes to prevent
    accidentally moving them while you're working on your map.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在你制作地图时按下`TileMap`节点的锁定按钮是个好主意，以防止意外移动它们。
- en: 'Next, add an instance of the `Player` scene and a `Position2D` named `PlayerSpawn`.
    Click the hide button on the `Player`—you''ll use `show()` in the level script
    to make the player appear when it starts. Your scene tree should now look like
    this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加一个`Player`场景和一个名为`PlayerSpawn`的`Position2D`。点击`Player`上的隐藏按钮——你将在关卡脚本中使用`show()`使玩家在开始时出现。你的场景树现在应该看起来像这样：
- en: '![](img/00123.jpeg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00123.jpeg)'
- en: 'Attach a script to the `Level` node:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将脚本附加到`Level`节点：
- en: '[PRE15]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Later, you'll be scanning the `Pickups` map to spawn collectible items in the
    designated locations. This map layer itself shouldn't be seen, but rather than
    set it as hidden in the scene tree, which is easy to forget before you run the
    game, you can make sure it's always hidden during gameplay by doing so in `_ready()`.
    Because there will be many references to the node, storing the result of `$Pickups`
    in the `pickups` variable will cache the result. (Remember, `$NodeName` is the
    same as writing `get_node("NodeName")`.)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你将扫描`Pickups`地图以在指定位置生成可收集物品。这个地图层本身不应该被看到，但与其在场景树中将它设置为隐藏，这很容易在运行游戏之前忘记，你可以在`_ready()`中确保它在游戏过程中始终隐藏。因为将会有许多对节点的引用，将`$Pickups`的结果存储在`pickups`变量中会缓存结果。（记住，`$NodeName`与写入`get_node("NodeName")`相同。）
- en: Designing the first level
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计第一个关卡
- en: Now, you're ready to start drawing the level! Click Scene | New Inherited Scene
    and choose `Level.tscn`. Name the new node `Level01` and save it (still in the
    `levels` folder).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你准备好开始绘制关卡了！点击“场景”|“新建继承场景”并选择`Level.tscn`。将新节点命名为`Level01`并保存（仍在`levels`文件夹中）。
- en: Start with the `World` map and be creative. Do you like lots of jumps, or twisty
    tunnels to explore? Long runs, or careful upward climbs?
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 从`World`地图开始，发挥创意。你喜欢很多跳跃，还是曲折的隧道去探索？长跑，还是小心翼翼的向上攀登？
- en: Before going too far in your design, experiment with jump distance. You can
    change the Player's `jump_speed`, `run_speed`, and `gravity` properties to alter
    how high and how far they can jump. Set up some different gap sizes and run the
    scene to try them out. Don't forget to drag the `PlayerSpawn` node to the place
    you want the character to start.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入设计之前，尝试跳跃距离。你可以通过更改玩家的`jump_speed`、`run_speed`和`gravity`属性来改变他们可以跳多高和多远。设置一些不同的间隙大小并运行场景来尝试它们。别忘了将`PlayerSpawn`节点拖到你想让角色开始的位置。
- en: 'For example, can the player make this jump? Take a look at the following screenshot:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，玩家能否完成这个跳跃？请查看以下截图：
- en: '![](img/00124.jpeg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00124.jpeg)'
- en: How you set the player's movement properties will have a big impact on how your
    level should be laid out. Make sure you're happy with your settings before spending
    too much time on the full design.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你设置玩家运动属性的方式将对你的关卡布局产生重大影响。在花费太多时间在完整设计之前，确保你对设置满意。
- en: Once you have the `World` layer set up, use the `Objects` layer to place decorations
    and accents like plants, rocks, and vines.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你设置了`World`层，使用`Objects`层放置装饰和点缀，如植物、岩石和藤蔓。
- en: 'Use the `Pickups` layer to mark the locations you''ll spawn collectible items
    at. There are two kinds: gems and cherries. The tiles that spawn them are drawn
    with a magenta background to make them stand out. Remember, they''ll be replaced
    at runtime by the actual items and the tiles themselves won''t be seen.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Pickups`层标记你将生成可收集物品的位置。有两种类型：宝石和樱桃。生成它们的瓦片以洋红色背景绘制，以便突出显示。记住，它们将在运行时被实际物品替换，而瓦片本身将不会被看到。
- en: 'Once you have your level laid out, you can limit the horizontal scrolling of
    the player camera to match the size of the map (plus a 5 tile buffer on each end):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你布置好你的关卡，你可以限制玩家相机的水平滚动以匹配地图的大小（并在每端各加5个方块缓冲区）：
- en: '[PRE16]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The script also needs to scan the `Pickups` layer and look for the item markers:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本还需要扫描`Pickups`层并查找物品标记：
- en: '[PRE17]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This function uses `get_used_cells()` to get an array of the tiles that are
    in use on the `Pickups` map. The `TileMap` sets each tile's value to an `id` that
    references the individual tile object in the `TileSet`. You can then query the
    `TileSet` for the tile's name using `tile_set.tile_get_name()`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用`get_used_cells()`获取`Pickups`地图上使用的瓦片的数组。`TileMap`将每个瓦片的值设置为引用`TileSet`中单个瓦片对象的`id`。然后你可以使用`tile_set.tile_get_name()`查询`TileSet`以获取瓦片的名称。
- en: 'Add `spawn_pickups()` to `_ready()` and add the following at the top of the
    script:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 将`spawn_pickups()`添加到`_ready()`中，并在脚本顶部添加以下内容：
- en: '[PRE18]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Try running your level and you should see your gems and/or cherries appear where
    you placed them. Also check that they disappear when you run into them.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行你的关卡，你应该能看到你放置的宝石和/或樱桃出现在那里。同时检查它们在你遇到它们时是否会消失。
- en: Scrolling background
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滚动背景
- en: 'There are two background images in the `res://assets/environment/layers` folder:
    `back.png` and `middle.png`, for the far and near background, respectively. By
    placing these images behind the tilemap and scrolling them at different speeds
    relative to the camera, you can create an attractive illusion of depth in the
    background.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在`res://assets/environment/layers`文件夹中有两个背景图像：`back.png`和`middle.png`，分别用于远背景和近背景。通过将这些图像放置在瓦片地图后面并以相对于相机的不同速度滚动，你可以在背景中创建一个吸引人的深度错觉。
- en: To start, add a `ParallaxBackground` node to the `Level` scene. This node works
    automatically along with the camera to create a scrolling effect. Drag this node
    to the top of the scene tree so that it will be drawn behind the rest of the nodes.
    Next, add a `ParallaxLayer` node as a child—`ParallaxBackground` can have any
    number of `ParallaxLayer` as children, allowing you to make many independently
    scrolling layers. Add a `Sprite` node as a child to the `ParallaxLayer` and drag
    the `res://assets/environment/layers/back.png` image into the Texture. Important—uncheck
    the box next to the Centered property of the Sprite.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将`ParallaxBackground`节点添加到`Level`场景中。此节点与相机自动协同工作，以创建滚动效果。将此节点拖动到场景树顶部，以便它将在其余节点之后绘制。接下来，将`ParallaxLayer`节点作为子节点添加——`ParallaxBackground`可以有任意数量的`ParallaxLayer`子节点，允许你创建多个独立滚动的层。将`Sprite`节点作为子节点添加到`ParallaxLayer`，并将`res://assets/environment/layers/back.png`图像拖动到纹理中。 重要——取消选中精灵旁边`Centered`属性旁边的框。
- en: The background image is a little small, so set the Sprite's Scale to `(1.5,
    1.5)`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 背景图像有点小，所以将精灵的缩放设置为`(1.5, 1.5)`。
- en: On the `ParallaxLayer`, set the Motion/Scale to `(0.2, 1)`. This setting controls
    how fast the background scrolls in relation to the camera. By setting it to a
    low number, the background will only move a small amount as the player moves left
    and right.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ParallaxLayer`上，将运动/缩放设置为`(0.2, 1)`。此设置控制背景相对于相机的滚动速度。通过将其设置为低数值，背景将在玩家左右移动时仅移动一小段距离。
- en: Next, you want to be sure the image repeats if your level is very wide, so set
    Mirroring to `(576, 0)`. This is exactly the width of the image (`384` times `1.5`),
    so the image will be repeated when it has moved by that amount.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你想要确保如果你的关卡非常宽，图像会重复，所以将镜像设置为`(576, 0)`。这正是图像的宽度（`384`乘以`1.5`），所以当图像移动了这么多距离时，图像将会重复。
- en: Note that this background is best for wide rather than tall levels. If you jump
    too high, you'll reach the top of the background image and suddenly see the grey
    emptiness again. You can fix this by setting the top limit of the camera. If you
    haven't moved it, the upper-left corner of the image will be at `(0, 0)`, so you
    can set the Top limit on the camera to `0`. If you've moved the `ParallaxLayer`,
    you can find the correct value by looking at the `y` value of the node's Position.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这种背景最适合宽关卡而不是高关卡。如果你跳得太高，你会到达背景图像的顶部，然后突然看到灰色的空白。你可以通过设置相机的顶部限制来修复这个问题。如果你没有移动它，图像的左上角将位于`(0,
    0)`，因此你可以将相机的顶部限制设置为`0`。如果你已经移动了`ParallaxLayer`，你可以通过查看节点的`y`值来找到正确的值。
- en: Now, add another `ParallaxLayer` (as a sibling of the first) for the middle
    background layer and give it a `Sprite` child. This time, use the `res://assets/environment/layers/middle.png`
    texture. This texture is much narrower than the cloud/sky image, so you'll need
    to do a little extra adjustment to make it repeat properly. This is because the
    `ParallaxBackground` needs to have images that are at least as big as the viewport
    area.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为中间背景层添加另一个`ParallaxLayer`（作为第一个的兄弟），并给它一个`Sprite`子项。这次，使用`res://assets/environment/layers/middle.png`纹理。这个纹理比云/天空图像窄得多，所以你需要做一些额外的调整来使其正确重复。这是因为`ParallaxBackground`需要具有至少与视口区域一样大的图像。
- en: 'First, click on the texture in the FileSystem dock and select the Import tab.
    Change the Repeat property to Mirrored, and check `On` for Mipmaps. Press Reimport.
    Now, the texture can be repeated to fill the screen (and the parallax system will
    repeat it after that):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在FileSystem窗口中点击纹理，并选择导入标签。将重复属性更改为镜像，并勾选Mipmaps。按重新导入。现在，纹理可以重复以填充屏幕（并且透视系统将在之后重复它）：
- en: '![](img/00125.jpeg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00125.jpeg)'
- en: 'The image''s original size is `176x368`, and it needs to be repeated horizontally.
    In the `Sprite` properties, click On for Region Enabled. Next, set the Rect property
    to `(0, 0, 880, 368)` (880 is 176 times 5, so you should now see five repetitions
    of the image). Move the `ParallaxLayer` so that the image overlaps the bottom
    half of the ocean/cloud image:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图片的原始大小是`176x368`，需要水平重复。在`Sprite`属性中，点击启用区域。接下来，将矩形属性设置为`(0, 0, 880, 368)`（880是176乘以5，所以你现在应该看到五次图片的重复）。移动`ParallaxLayer`，使图片与海洋/云图片的下半部分重叠：
- en: 'Set the `ParallaxLayer` Motion/Scale to `(0.6, 1)` and the Mirroring to `(880,
    0)`. Using a higher scale factor means this layer will scroll a little faster
    than the cloud layer behind it, giving a satisfying effect of depth, as shown
    in the following screenshot:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 将`ParallaxLayer`的Motion/Scale设置为`(0.6, 1)`，将镜像设置为`(880, 0)`。使用更高的缩放因子意味着这个层将比后面的云层滚动得更快，从而产生令人满意的深度效果，如以下截图所示：
- en: '![](img/00126.jpeg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00126.jpeg)'
- en: Once you're sure everything is working, try adjusting the Scale value for both
    layers and see how it changes. For example, try a value of `(1.2, 1)` on the middle
    layer for a much different visual effect.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确定一切正常工作，尝试调整两个层的缩放值，看看它如何变化。例如，尝试在中间层使用`(1.2, 1)`的值，以获得非常不同的视觉效果。
- en: 'Your main scene''s tree should now look like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你主场景的树现在应该看起来像这样：
- en: '![](img/00127.jpeg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00127.jpeg)'
- en: Dangerous objects
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 危险物品
- en: The Danger map layer is meant to hold the spike objects that will harm the player
    if they're touched. Try placing a few of them on your map where you can easily
    test running into them. Note that because of the way TileMaps work, colliding
    with *any* tile on this layer will cause damage to the player!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 危险地图层是用来存放如果被触摸会伤害玩家的尖刺对象的。尝试在你的地图上放置几个它们，这样你可以轻松测试撞到它们。注意，由于TileMaps的工作方式，与这个层上的任何瓷砖发生碰撞都会对玩家造成伤害！
- en: About slide collisions
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于滑动碰撞
- en: When a `KinematicBody2D` is moved with `move_and_slide()`, it may collide with
    more than one object in a given frame. For example, when running into a corner,
    the character may hit the wall and the floor at the same time. You can use the
    `get_slide_count()` method to find out how many collisions occurred, and then
    get information about each collision with `get_slide_collision()`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`move_and_slide()`移动`KinematicBody2D`时，它可能在给定帧内与多个对象发生碰撞。例如，当撞到角落时，角色可能会同时撞到墙和地板。你可以使用`get_slide_count()`方法找出发生了多少次碰撞，然后使用`get_slide_collision()`获取每次碰撞的信息。
- en: 'In the case of the `Player`, you want to detect when a collision occurs against
    the Danger `TileMap` object. You can do this just after using `move_and_slide()`
    in `Player.gd`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Player`的情况下，你想要检测当与危险`TileMap`对象发生碰撞时。你可以在使用`Player.gd`中的`move_and_slide()`之后这样做：
- en: '[PRE19]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Before checking for a collision with `Danger`, you can check whether the player
    is already in the `HURT` state and skip checking if it is. Next, you must use
    `get_slide_count()` to iterate through any collisions that may have occurred.
    For each, you can check whether the `collider.name` is `Danger`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查与`Danger`的碰撞之前，你可以检查玩家是否已经处于`HURT`状态，如果是的话就跳过检查。接下来，你必须使用`get_slide_count()`来遍历可能发生的任何碰撞。对于每一个，你可以检查`collider.name`是否为`Danger`。
- en: Run the scene and try running into one of the spike objects. Just like you wrote
    in the `hurt()` function previously, you should see the player change to the `HURT`
    state for a brief time before returning to `IDLE`. After three hits, the player
    enters the `DEAD` state, which currently sets the visibility to hidden.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 运行场景，并尝试撞到其中一个尖刺对象。就像你之前在`hurt()`函数中写的，你应该看到玩家在短时间内变为`HURT`状态，然后返回到`IDLE`状态。经过三次打击后，玩家进入`DEAD`状态，当前设置可见性为隐藏。
- en: Enemies
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敌人
- en: Currently, the map is very lonely, so it's time to add some enemies to liven
    things up.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，地图非常空旷，所以是时候添加一些敌人来活跃一下气氛了。
- en: There are many different behaviors you could create for an enemy. For this project,
    the enemy will walk along a platform in a straight line and reverse direction
    when hitting an obstacle.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为敌人创建许多不同的行为。对于这个项目，敌人将沿着平台直线行走，并在碰到障碍物时改变方向。
- en: Scene setup
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景设置
- en: 'Start with `KinematicBody2D` with three children: `Sprite`, `AnimationPlayer`,
    and `CollisionShape2D`. Save the scene as `Enemy.tscn` in a new folder called
    `enemies`. If you decide to add more enemy types to the game, you can save them
    all here.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 从`KinematicBody2D`开始，有三个子节点：`Sprite`、`AnimationPlayer`和`CollisionShape2D`。将场景保存为`enemies`文件夹中的`Enemy.tscn`。如果你决定为游戏添加更多敌人类型，你都可以在这里保存。
- en: Set the body's collision layer to `enemies` and its collision masks to `environment`,
    `player`, and `enemies`. It's also useful to group the enemies, so click on the
    Node tab and add the body to a group called `enemies`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 将身体的碰撞层设置为`enemies`，并将其碰撞掩码设置为`environment`、`player`和`enemies`。将敌人分组也是有用的，因此点击节点标签页，并将身体添加到名为`enemies`的组中。
- en: 'Add the `res://assets/opossum.png` sprite sheet to the Sprite''s Texture. Set
    Vframes to `1` and Hframes to `6`. Add a rectangular collision shape that covers
    most (but not all) of the image, making sure that the bottom of the collision
    shape is aligned with the bottom of the image''s feet:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 将`res://assets/opossum.png`精灵图集添加到精灵的纹理。将Vframes设置为`1`，Hframes设置为`6`。添加一个矩形碰撞形状，覆盖图像的大部分（但不是全部），确保碰撞形状的底部与图像脚部的底部对齐：
- en: '![](img/00128.jpeg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00128.jpeg)'
- en: Add a new animation to the `AnimationPlayer` called `walk`. Set the Length to
    `0.6` seconds and the Step to `0.1` seconds. Turn on Looping and Autoplay.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 向`AnimationPlayer`添加一个新的动画，命名为`walk`。将长度设置为`0.6`秒，步长设置为`0.1`秒。开启循环和自动播放。
- en: 'The `walk` animation will have two tracks: one that sets the Texture property
    and one that changes the Frame property. Click the Add keyframe button next to
    Texture once to add the first track, then click the one next to Frame and repeat
    until you have frames `0` through `5`. Press Play and verify that the walk animation
    is playing correctly. The Animation panel should look like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`walk`动画将有两个轨道：一个设置纹理属性，一个更改帧属性。点击纹理旁边的添加关键帧按钮一次以添加第一个轨道，然后点击帧旁边的按钮并重复，直到你有`0`到`5`的帧。按播放并验证行走动画是否正确播放。动画面板应该看起来像这样：'
- en: '![](img/00129.jpeg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00129.jpeg)'
- en: Script
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本
- en: 'Add the following script:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下脚本：
- en: '[PRE20]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this script, the `facing` variable tracks the direction of movement (`1`
    or `-1`). As with the player, when moving, you iterate through the slide collisions.
    If the colliding object is the `Player`, you call its `hurt()` function.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，`facing`变量跟踪移动方向（`1`或`-1`）。与玩家一样，在移动时，你遍历滑动碰撞。如果碰撞的对象是`Player`，你调用它的`hurt()`函数。
- en: Next, you can check whether the colliding body's normal vector has an `x` component
    that isn't `0`. This means it points to the left or right (that is, it is a wall,
    crate, or other obstacle). The direction of the *normal* is used to set the new
    facing. Finally, giving the body a small upward velocity will make the reverse
    transition look more appealing.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以检查碰撞体的法线向量是否有非`0`的`x`分量。这意味着它指向左边或右边（即，它是一堵墙、一个箱子或其他障碍物）。*法线*的方向用于设置新的朝向。最后，给身体一个小的向上速度会使反向过渡看起来更有吸引力。
- en: Lastly, if, for some reason, the enemy does fall off a platform, you don't want
    the game to have to track it falling forever, so delete any enemy whose *y* coordinate
    becomes too big.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果由于某种原因，敌人从平台上掉落，你不想让游戏永远跟踪它的掉落，所以删除任何`y`坐标变得太大的敌人。
- en: Set Speed to `50` and Gravity to `900` in the Inspector, and then create an
    `Enemy` in your level scene. Make sure it has an obstacle on either side, and
    play the scene. Check that the enemy walks back and forth between the obstacles.
    Try putting the player in its path and verify that the player's `hurt()` method
    is getting called.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查器中将速度设置为`50`，重力设置为`900`，然后在你的关卡场景中创建一个`Enemy`。确保它两侧都有一个障碍物，并播放场景。检查敌人是否在障碍物之间来回走动。尝试将玩家放在它的路径上，并验证玩家的`hurt()`方法是否被调用。
- en: Damaging the enemy
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 损害敌人
- en: It's not fair if the player can't strike back, so in the tradition of Super
    Mario Bros., jumping on top of the enemy will defeat it.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家不能反击，那就太不公平了，所以按照超级马里奥兄弟的传统，跳到敌人的上面可以击败它。
- en: Start by adding a new animation to the `AnimationPlayer` of the `Enemy` and
    name it `death`. Set the Length to `0.3` seconds and the Step to `0.05`. *Don't*
    turn on looping for this animation.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，向`Enemy`的`AnimationPlayer`添加一个新的动画，命名为`death`。将长度设置为`0.3`秒，步长设置为`0.05`。**不要**为这个动画开启循环。
- en: This animation will also set the Texture and Frame. This time, drag the `res://assets/enemy-death.png` image
    into the Sprite's Texture before adding the keyframe for that property. As before,
    keyframe all the `Frame` values from `0` through `5`. Press Play to see the death
    animation run.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个动画还将设置纹理和帧。这次，在添加该属性的帧之前，将`res://assets/enemy-death.png`图像拖入精灵的纹理中。和之前一样，将所有`帧`值从`0`到`5`全部设置为关键帧。按播放键查看死亡动画的运行情况。
- en: 'Add the following code to the Enemy''s script:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`Enemy`的脚本中：
- en: '[PRE21]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When the `Player` hits the `Enemy` under the right conditions, it will call
    `take_damage()`, which plays the `death` animation. It also disables collision
    and movement for the duration of the animation.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Player`在正确条件下击中`Enemy`时，它将调用`take_damage()`，这将播放`death`动画。它还禁用了动画期间的碰撞和移动。
- en: 'When the `death` animation finishes, it''s OK to remove the enemy, so connect
    the `animation_finished()` signal of `AnimationPlayer`. This signal is called
    every time an animation finishes, so you need to check that it''s the correct
    one:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当`death`动画完成后，可以移除敌人，因此连接`AnimationPlayer`的`animation_finished()`信号。这个信号在每次动画完成后都会被调用，所以你需要检查它是否正确：
- en: '[PRE22]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To complete the process, go to the `Player.gd` script and add the following
    to the collision checks in the `_physics_process()` method:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个过程，转到`Player.gd`脚本，并在`_physics_process()`方法中的碰撞检查中添加以下内容：
- en: '[PRE23]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code checks the *y* coordinate of the player's feet (that is, the bottom
    of its collision shape) against the enemy's *y* coordinate. If the player is higher,
    the enemy is hurt; otherwise, the player is.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码检查玩家的脚的y坐标（即碰撞形状的底部）与敌人的y坐标。如果玩家更高，敌人会受到伤害；否则，玩家会受到伤害。
- en: Run the level and try jumping on the enemy to make sure all is working as expected.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 运行关卡并尝试跳到敌人身上，以确保一切按预期工作。
- en: HUD
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HUD
- en: The purpose of the HUD is to display the information the player needs to know
    during gameplay. Collecting items will increase the player's score, so that information
    needs to be displayed. The player also needs to see their remaining life value,
    which will be displayed as a series of hearts.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: HUD的目的是在游戏过程中显示玩家需要知道的信息。收集物品会增加玩家的分数，因此需要显示这一信息。玩家还需要看到他们剩余的生命值，这将以一系列心形图案显示。
- en: Scene setup
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景设置
- en: 'Create a new scene with a `MarginContainer` node. Name it `HUD` and save in
    the `ui` folder. Set the Layout to Top Wide. In the Custom Constants section of
    Inspector, set the following values:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景，并使用`MarginContainer`节点。将其命名为`HUD`并保存在`ui`文件夹中。将布局设置为顶部宽。在检查器的自定义常量部分，设置以下值：
- en: 'Margin Right: `50`'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右侧边距：`50`
- en: 'Margin Top: `20`'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶部边距：`20`
- en: 'Margin Left: `50`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左侧边距：`50`
- en: 'Margin Bottom: `20`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 底部边距：`20`
- en: 'Add an `HBoxContainer`. This node will contain all the UI elements and keep
    them aligned. It will have two children:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`HBoxContainer`节点。这个节点将包含所有UI元素并保持它们的对齐。它将有两个子节点：
- en: '`Label`: `ScoreLabel`'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Label`：`ScoreLabel`'
- en: '`HBoxContainer`: `LifeCounter`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HBoxContainer`：`LifeCounter`'
- en: On the `ScoreLabel`, set the Text property to `1`, and under Size Flags, set
    Horizontal to Fill and Expand. Add a custom `DynamicFont` using `res://assets/Kenney
    Thick.ttf` from the `assets` folder, with a font size of `48`. In the Custom Colors section,
    set the Font Color to `white` and the Font Color Shadow to `black`. Finally, under
    Custom Constants, set Shadow Offset X, Shadow Offset Y, and Shadow As Outline all
    to `5`. You should see a large white 1 with a black outline.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ScoreLabel` 上设置文本属性为 `1`，并在大小标志下设置水平为填充和扩展。使用 `res://assets/Kenney Thick.ttf`
    从 `assets` 文件夹添加一个自定义 `DynamicFont`，字体大小为 `48`。在自定义颜色部分，将字体颜色设置为 `white`，字体颜色阴影设置为
    `black`。最后，在自定义常量下，将阴影偏移 X、阴影偏移 Y 和阴影轮廓都设置为 `5`。你应该看到一个带有黑色轮廓的大白数字 `1`。
- en: 'For the `LifeCounter`, add a `TextureRect` and name it `L1`. Drag `res://assets/heart.png` into
    its Textureand set Stretch Mode to `Keep Aspect Centered`. Click on the node and
    press *Ctrl* + *D* four times so that you have a row of five hearts:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `LifeCounter`，添加一个 `TextureRect` 并命名为 `L1`。将 `res://assets/heart.png` 拖入其纹理中，并将拉伸模式设置为
    `Keep Aspect Centered`。点击节点并按 *Ctrl* + *D* 四次，以便得到一排五颗心：
- en: '![](img/00130.jpeg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00130.jpeg)'
- en: 'When finished, your HUD should look like this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你的 HUD 应该看起来像这样：
- en: '![](img/00131.jpeg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00131.jpeg)'
- en: Script
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本
- en: 'Here is the script for the `HUD`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `HUD` 的脚本：
- en: '[PRE24]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: First, you make an array of references to the five heart indicators. Then, in
    `_on_Player_life_changed()`, which will be called when the player gets hurt or
    healed, you calculate how many hearts to display by setting `visible` to `false`
    if the number of the heart is less than the life amount.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你创建一个包含五个生命指示器的引用数组。然后，在 `_on_Player_life_changed()` 方法中，当玩家受伤或恢复时会被调用，你通过设置
    `visible` 为 `false` 来计算显示多少颗心，如果心形数量少于生命值。
- en: '`_on_score_changed()` is similar, changing the value of the `ScoreLabel` when
    called.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`_on_score_changed()` 类似，当被调用时改变 `ScoreLabel` 的值。'
- en: Attaching the HUD
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 HUD
- en: Open `Level.tscn` (the base-level scene, *not* your `Level01` scene) and add
    a `CanvasLayer` node. Instance the `HUD` scene as a child of this `CanvasLayer`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `Level.tscn`（基础关卡场景，*不是*你的 `Level01` 场景）并添加一个 `CanvasLayer` 节点。将 `HUD` 场景作为其子节点实例化。
- en: 'Click on the `Player` node and connect its `life_changed` signal to the HUD''s
    `_on_Player_life_changed()` method:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 `Player` 节点，将其 `life_changed` 信号连接到 HUD 的 `_on_Player_life_changed()` 方法：
- en: '![](img/00132.jpeg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00132.jpeg)'
- en: Next, do the same with the `score_changed` signal of the `Level` node, connecting
    it to the HUD's `_on_score_changed`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，用 `Level` 节点的 `score_changed` 信号做同样的事情，将其连接到 HUD 的 `_on_score_changed`。
- en: '**Alternative method: **Note that if you don''t want to use the scene tree
    to connect the signals, or if you find the signal connection window confusing,
    you can accomplish the same thing in code by adding these two lines to the `_ready()`
    function of `Level.gd`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**另一种方法：**注意，如果你不想使用场景树来连接信号，或者如果你觉得信号连接窗口令人困惑，你可以在 `Level.gd` 的 `_ready()`
    函数中添加这两行代码来完成相同的事情：'
- en: '[PRE25]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Run your level and verify that you gain points when collecting items and lose
    hearts when getting hurt.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的关卡，并验证在收集物品时获得分数，在受伤时失去生命值。
- en: Title screen
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标题屏幕
- en: The title screen is the first scene the player will see. When the player dies,
    the game will return to this scene and allow you to restart.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 标题屏幕是玩家看到的第一个场景。当玩家死亡时，游戏将返回此场景并允许你重新开始。
- en: Scene setup
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景设置
- en: Start with a `Control` node and set the Layout to Full Rect.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个 `Control` 节点开始，并将布局设置为全矩形。
- en: Add a `TextureRect`. Set its Texture to `res://assets/environment/layers/back.png`,
    Layout to Full Rect, and Stretch Mode to Keep Aspect Covered.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个 `TextureRect`。将其纹理设置为 `res://assets/environment/layers/back.png`，布局为全矩形，拉伸模式为保持纵横比。
- en: Add another `TextureRect`, this time with the Texture using `res://assets/environment/layers/middle.png` and
    the Stretch Mode set to Tile. Drag the width of the rectangle until it's wider
    than the screen and arrange it so it covers the bottom half of the screen.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 添加另一个 `TextureRect`，这次使用 `res://assets/environment/layers/middle.png` 作为纹理，并将拉伸模式设置为平铺。将矩形的宽度拖动到比屏幕宽，并调整它以覆盖屏幕下半部分。
- en: 'Next, add two `Label` nodes (`Title` and `Message`) and set their Custom Font settings
    using the same options you used earlier for the score label. Set their Text properties
    to Jungle Jump and Press Space to Play, respectively. When you''re finished, the
    screen should look like this:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加两个 `Label` 节点（`Title` 和 `Message`），并使用之前为分数标签使用的相同选项设置它们的自定义字体设置。将它们的文本属性分别设置为
    Jungle Jump 和 Press Space to Play。完成时，屏幕应该看起来像这样：
- en: '![](img/00133.jpeg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00133.jpeg)'
- en: To make the title screen a bit more interesting, add an `AnimationPlayer` node
    and create a new animation. Name it `anim` and set it to autoplay. In this animation,
    you can animate the various components of the screen to make them move, appear,
    fade in, or any other effect you like.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要使标题屏幕更有趣，添加一个`AnimationPlayer`节点并创建一个新的动画。将其命名为`anim`并设置为自动播放。在这个动画中，您可以动画化屏幕的各种组件，使它们移动、出现、淡入或您喜欢的任何其他效果。
- en: Drag the Title label to a position above the top of the screen and add a keyframe.
    Then, drag it back (or manually type the values in Position) and set another keyframe
    at around `0.5` seconds. Feel free to add tracks that are animating the other
    nodes' properties.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 将标题标签拖动到屏幕顶部的上方并添加一个关键帧。然后，将其拖回（或手动输入位置值）并在大约`0.5`秒处设置另一个关键帧。您可以自由添加动画其他节点属性的轨道。
- en: 'For example, here is an animation that drops the title down, fades in the two
    textures, and then makes the message appear (note the names of the properties
    that are modified by each track):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里有一个动画，它将标题下拉，淡入两个纹理，然后显示消息（注意每个轨道修改的属性名称）：
- en: '![](img/00134.jpeg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00134.jpeg)'
- en: Main scene
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主场景
- en: 'Delete the extra nodes you added to your temporary `Main.tscn` (the `Player`
    instance and the test `StaticBody2D`). This scene will now be responsible for
    loading the current level. Before it can do that, however, you need an Autoload
    script to track the game state: variables such as `current_level` and other data
    that needs to be carried from scene to scene.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 删除您添加到临时`Main.tscn`（`Player`实例和测试`StaticBody2D`）中的额外节点。现在这个场景将负责加载当前等级。然而，在它能够这样做之前，您需要一个Autoload脚本来跟踪游戏状态：例如`current_level`和其他需要从场景到场景携带的数据。
- en: 'Add a new script called `GameState.gd` in the Script editor and add the following
    code:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本编辑器中添加一个新的脚本`GameState.gd`，并添加以下代码：
- en: '[PRE26]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that you should set `num_levels` to the number of levels you've made in
    the `levels` folder. Make sure to name them consistently (`Level01.tscn`, `Level02.tscn`,
    and so on) and then you can automatically load the next one in the sequence.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您应该将`num_levels`设置为在`levels`文件夹中制作的等级数量。确保它们命名一致（`Level01.tscn`、`Level02.tscn`等），然后您可以自动加载序列中的下一个。
- en: 'Add this script in the AutoLoad tab of Project Settings, and add this script
    to `Main`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目设置的Autoload标签中添加此脚本，并将其添加到`Main`：
- en: '[PRE27]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, whenever the `Main` scene is loaded, it will load the level scene corresponding
    to `GameState.current_level`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当加载`Main`场景时，它将加载与`GameState.current_level`对应的等级场景。
- en: 'The title screen needs to transition to the game scene, so attach this script
    to the `TitleScreen` node:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 标题屏幕需要过渡到游戏场景，因此将此脚本附加到`TitleScreen`节点：
- en: '[PRE28]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can also call the restart function when the player dies by adding it to
    the method in `Level.gd`:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过将重启函数添加到`Level.gd`中的方法来在玩家死亡时调用它：
- en: '[PRE29]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Level transitions
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等级过渡
- en: Your levels now need a way to transition from one to the next. In the `res://assets/environment/layers/props.png` sprite
    sheet, there is an image of a door that you can use for your level's exit. Finding
    and walking into the door will result in the player moving to the next level.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 您的等级现在需要一种从一级过渡到下一级的方式。在`res://assets/environment/layers/props.png`精灵图中，有一个可以用于您等级出口的门图像。找到并走进门，玩家将移动到下一级。
- en: Door scene
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 门场景
- en: Make a new scene with an `Area2D` named `Door` and save it in the `items` folder.
    Add a `Sprite` and use the `res://assets/environment/layers/props.png` sprite
    sheet along with the *Region* setting to select the door image, then attach a
    rectangular `CollisionShape2D`. This scene doesn't need a script, because you're
    just going to use the area's `body_entered` signal.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景，命名为`Area2D`的`Door`，并将其保存在`items`文件夹中。添加一个`Sprite`，使用`res://assets/environment/layers/props.png`精灵图，并使用`Region`设置选择门图像，然后附加一个矩形的`CollisionShape2D`。这个场景不需要脚本，因为您只是将要使用区域的`body_entered`信号。
- en: Put the door on the `collectibles` layer and set its mask to only scan the `player`
    layer.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 将门放在`collectibles`层上，并设置其遮罩只扫描`player`层。
- en: 'Instance this door scene in your first level and put it somewhere that the
    player can reach. Click on the `Door` node and connect the `body_entered` signal
    to the `Level.gd` script where you can add this code:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的第一个等级中实例化此门场景，并将其放置在玩家可以到达的地方。单击`Door`节点，将`body_entered`信号连接到您可以添加此代码的`Level.gd`脚本：
- en: '[PRE30]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Run the game and try running into the door to check that it immediately transfers
    to the next level.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏并尝试撞上门以检查它是否立即转移到下一级。
- en: Finishing touches
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后的修饰
- en: Now that you've completed the structure of the game, you can consider some additions
    so that you can add more game features, more visual effects, additional enemies,
    or other ideas you might have. In this section, there are a few suggested features—add
    them as-is or adjust them to your liking.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了游戏的结构，你可以考虑添加一些内容，以便你可以添加更多游戏功能、更多视觉效果、额外的敌人或你可能有的其他想法。在本节中，有一些建议的功能——直接添加或根据你的喜好进行调整。
- en: Sound effects
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声音效果
- en: 'As with the previous projects, you can add audio effects and music to improve
    the gameplay experience. In the `res://assets/audio` folder, you''ll find a number
    of files you can use for various game events, such as player jump, enemy hit and
    pickup. There are also two music files: Intro Theme for the title screen and Grasslands
    Theme for the level scenes.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的项目一样，你可以添加音效和音乐来提升游戏体验。在`res://assets/audio`文件夹中，你可以找到用于各种游戏事件（如玩家跳跃、敌人击中和拾取）的多个文件。还有两首音乐文件：标题屏幕的Intro
    Theme和关卡场景的Grasslands Theme。
- en: 'Adding these to the game will be left to you, but here are a few tips:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些添加到游戏中将由你来完成，但这里有一些提示：
- en: Make sure the sound effects have Loop set to Off while the music files have
    it On in the Import settings tab.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保在导入设置选项卡中，音效的Loop设置为Off，而音乐文件的Loop设置为On。
- en: You may find it helpful to adjust the volume of individual sounds. This can
    be set with the Volume Db property. Setting a negative value will reduce the sound's
    volume.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能会发现调整单个声音的音量很有帮助。这可以通过Volume Db属性来设置。设置负值将降低声音的音量。
- en: You can attach music to the master `Level.tscn` and that music will be used
    for all levels (set the `AudioStreamPlayer` to Autoplay).
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将音乐附加到主`Level.tscn`，并且该音乐将用于所有关卡（将`AudioStreamPlayer`设置为自动播放）。
- en: You an also attach separate music to individual levels if you want to set a
    certain mood.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要为单个关卡设置特定的氛围，你也可以为它们附加单独的音乐。
- en: Infinite falling
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无限坠落
- en: 'Depending on how you''ve designed your levels, it may be possible for the player
    to fall off the level entirely. Typically, you want to design things so that this
    isn''t possible by using walls that are too high to jump, spikes at the bottom
    of pits, and so on. However, in case it does happen, add the following code to
    the player''s `_physics_process()` method:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你如何设计你的关卡，玩家可能完全掉出关卡。通常，你希望通过使用太高而无法跳跃的墙壁、坑底的尖刺等方式来设计，使得这种情况不可能发生。但是，如果确实发生了，请将以下代码添加到玩家的`_physics_process()`方法中：
- en: '[PRE31]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note that if you've designed a level that extends below a `y` of `1000`, you'll
    need to increase the value to prevent accidental death.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你设计的关卡延伸到了`y`坐标的`1000`以下，你需要增加该值以防止意外死亡。
- en: Double jump
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双重跳跃
- en: Double-jumps are a popular platforming feature. The player gets a second, usually
    smaller, upwards boost if they press the jump key a second time while in the air.
    To implement this feature, you need to add a few things to the player script.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 双重跳跃是平台游戏中的一个流行功能。如果玩家在空中按下跳跃键第二次，他们会获得第二次，通常是较小的向上推力。要实现这个功能，你需要向玩家脚本中添加一些内容。
- en: 'First, you will need two variables to track the state:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要两个变量来跟踪状态：
- en: '[PRE32]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When entering the `JUMP` state, reset the number of jumps:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当进入`JUMP`状态时，重置跳跃次数：
- en: '[PRE33]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, in `get_input()`, allow the jump if it meets the conditions:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`get_input()`函数中，如果满足条件则允许跳跃：
- en: '[PRE34]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that this makes the second jump 2/3 the upward speed of the normal jump.
    You can adjust this according to your preferences.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这会使第二次跳跃的速度是正常跳跃的2/3。你可以根据你的喜好进行调整。
- en: Dust particles
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 灰尘颗粒
- en: Dust particles at the character's feet are a low-effort effect that can add
    a lot of character to your player's movements. In this section, you'll add a small
    puff of dust to the player's feet that is emitted whenever they land on the ground.
    This adds a sense of weight and impact to the player's jumps.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 角色脚下的灰尘颗粒是一种低成本的特效，可以为玩家的动作增添许多特色。在本节中，你将为玩家的脚部添加一小股灰尘，每当他们落地时都会释放出来。这为玩家的跳跃增添了重量感和冲击感。
- en: 'Add a `Particles2D` node and name it `Dust`. Note the warning that a process
    material must be added. First, however, set the properties of the `Dust` node:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`Particles2D`节点，并将其命名为`Dust`。注意，必须添加一个过程材质。然而，首先，你需要设置`Dust`节点的属性：
- en: '| **Property** | **Value** |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **值** |'
- en: '| Amount | `20` |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| 数量 | `20` |'
- en: '| Lifetime | `0.45` |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| 生命周期 | `0.45` |'
- en: '| One Shot | `On` |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| 单次播放 | `On` |'
- en: '| Speed Scale | `2` |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| 速度比例 | `2` |'
- en: '| Explosiveness | `0.7` |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| 爆发力 | `0.7` |'
- en: '| Local Coords | `Off` |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| 本地坐标 | `Off` |'
- en: '| Position | `(-2, 15)` |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| 位置 | `(-2, 15)` |'
- en: '| Rotation | `-90` |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| 旋转 | `-90` |'
- en: 'Now, under Process Material, add a new `ParticlesMaterial`. Click on it and
    you''ll see all the particle settings. Here are the ones you need for the dust
    effect:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在处理材质下添加一个新的`ParticlesMaterial`。点击它，你会看到所有的粒子设置。以下是实现尘埃效果所需的设置：
- en: '| **Particle Property** | **Value** |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| **粒子属性** | **值** |'
- en: '| Emission Shape | `Box` |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| 发射形状 | `Box` |'
- en: '| Box Extents | `(1, 6, 1)` |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| 箱体范围 | `(1, 6, 1)` |'
- en: '| Gravity | `(0, 0, 0)` |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| 重力 | `(0, 0, 0)` |'
- en: '| Initial Velocity | `10` |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| 初始速度 | `10` |'
- en: '| Velocity Random | `1` |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| 速度随机 | `1` |'
- en: '| Scale | `5` |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| 尺度 | `5` |'
- en: '| Scale Random |  `1` |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| 尺度随机 | `1` |'
- en: The default particle color is white, but the dust effect will look better as
    a tan shade. It should also fade away so that it appears to dissipate. This can
    be accomplished with a `ColorRamp`. Next to Color Ramp, click on New GradientTexture.
    In the `GradientTexture` properties, choose a new `Gradient`.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 默认粒子颜色为白色，但作为棕褐色调的尘埃效果看起来会更好。它也应该逐渐消失，看起来像是消散了。这可以通过一个`ColorRamp`来实现。在颜色渐变旁边，点击新建`GradientTexture`。在`GradientTexture`属性中，选择一个新的`Gradient`。
- en: 'The `Gradient` has two colors: a start color on the left and an end color on
    the right. These are selected by the small rectangles at the ends of the gradient.
    Clicking on the square on the right allows you to set the color:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`Gradient`有两种颜色：左侧的起始颜色和右侧的结束颜色。这些颜色由渐变两端的矩形选择。点击右侧的方块可以设置颜色：'
- en: '![](img/00135.jpeg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00135.jpeg)'
- en: Set the start color to a tan shade, and set the end color to the same color,
    but with the alpha value set to `0` (transparent). You can test how it looks by
    checking the Emitting box in the Inspector. Because the node is set to One Shot,
    there will only be one puff of particles and you have to check the box again to
    emit them.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 将起始颜色设置为棕褐色调，并将结束颜色设置为相同的颜色，但将alpha值设置为`0`（透明）。你可以通过检查检查器中的发射框来测试其外观。因为节点设置为一次性，所以只有一个粒子云团，你必须再次勾选框来发射它们。
- en: 'Feel free to alter the properties from what is listed here. Experimenting with
    `Particles2D` settings can be great fun, and often you''ll stumble on to a very
    nice effect just by tinkering. Once you''re happy with the appearance, add the
    following to the Player''s `_physics_process()` code:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 随意更改属性，从以下列出的内容中。实验`Particles2D`设置可以非常有趣，而且你可能会通过调整得到一个非常棒的效果。一旦你对外观满意，将以下内容添加到玩家的`_physics_process()`代码中：
- en: '[PRE35]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Run the game and every time your character lands on the ground, a small puff
    of dust will appear.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏，每次你的角色落地时，都会出现一小团尘埃。
- en: Crouching state
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蹲下状态
- en: 'The crouching state is useful if you have enemies or projectiles that the player
    needs to dodge by ducking under them. The sprite sheet contains a two-frame animation
    for this state:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 蹲下状态在玩家需要通过蹲下躲避敌人或投射物时很有用。精灵图集中包含这个状态的二帧动画：
- en: '![](img/00136.jpeg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00136.jpeg)'
- en: Add a new animation called crouch to the player's `AnimationPlayer`. Set its
    Length to `0.2` and add a track for the Frame property that changes the value
    from `3` to `4`. Set the animation to loop.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个新的动画称为蹲下添加到玩家的`AnimationPlayer`中。将其长度设置为`0.2`并为帧属性添加一个轨道，将值从`3`变为`4`。将动画设置为循环。
- en: 'In the player''s script, add the new state to the `enum` and state change:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩家的脚本中，将新状态添加到`enum`和状态转换中：
- en: '[PRE36]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the `get_input()` method, you need to handle the various state transitions.
    When on the ground, the down input should transition to `CROUCH`. When in `CROUCH`,
    releasing the down input should transition to `IDLE`. Finally, if in the `CROUCH`
    state and left or right is pressed, the state should change to `RUN`:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在`get_input()`方法中，你需要处理各种状态转换。当在地面时，向下输入应转换为`CROUCH`。当处于`CROUCH`状态时，释放向下输入应转换为`IDLE`。最后，如果在`CROUCH`状态并且按下左右键，状态应更改为`RUN`：
- en: '[PRE38]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You also need to change this line:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要更改这一行：
- en: '[PRE39]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To this:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 变成这样：
- en: '[PRE40]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: That's it! Run the game and try out your new animation state.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！运行游戏并尝试你的新动画状态。
- en: Climbing ladders
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 爬梯子
- en: 'The player animation also includes frames for a *climbing* action, and the
    tileset contains ladders. Currently, the ladder tiles do nothing: in the TileSet,
    they do not have any collision shape assigned. That''s fine, because you don''t
    want the player to collide with the ladders; you want to be able to move up and
    down on them.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家动画还包括爬行动作的帧，并且图块集中包含梯子。目前，梯子图块没有任何作用：在图块集中，它们没有分配任何碰撞形状。这是可以的，因为你不希望玩家与梯子碰撞；你希望能够在上面上下移动。
- en: Player code
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家代码
- en: Start by clicking on the player's `AnimationPlayer` and adding a new animation
    named `climb`. Its Length should be set to `0.4` seconds and the Frame values
    for the `Sprite` are `0, 1, 0, 2`. Set the animation to loop.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，点击玩家的 `AnimationPlayer` 并添加一个名为 `climb` 的新动画。其长度应设置为 `0.4` 秒，`Sprite` 的帧值是
    `0, 1, 0, 2`。将动画设置为循环。
- en: 'Now, go to `Player.gd` and add a new state, `CLIMB`, to the state enum. In
    addition, add two new variables to the declarations at the top:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到 `Player.gd` 并在状态枚举中添加一个新的状态 `CLIMB`。此外，在顶部声明中添加两个新变量：
- en: '[PRE41]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`is_on_ladder` will be used to tell if the player is on a ladder or not. Using
    this, you can decide whether the up arrow should have any effect. In the Inspector,
    set Climb Speed to `50`.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_on_ladder` 将用于判断玩家是否在梯子上。使用这个功能，你可以决定向上箭头是否应该有作用。在检查器中，将爬升速度设置为 `50`。'
- en: 'In `change_state()`, add a condition for the new state:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `change_state()` 中，为新的状态添加一个条件：
- en: '[PRE42]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, in `_get_input()`, you need to add the `climb` input action and add the
    code to determine when to trigger the new state. Add the following:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `_get_input()` 中，你需要添加 `climb` 输入动作，并添加代码以确定何时触发新状态。添加以下内容：
- en: '[PRE43]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, you have three new conditions to check. First, if the player is not in
    the `CLIMB` state, but is on a ladder, then pressing up should start make the
    player start climbing. Next, if the player is climbing, then up and down should
    move them accordingly, but halt movement if no keys are pressed. Finally, if the
    player leaves the ladder while climbing, it will leave the `CLIMB` state.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你有三个新的条件需要检查。首先，如果玩家不在 `CLIMB` 状态，但站在梯子上，那么按下向上键应该开始让玩家开始攀爬。接下来，如果玩家正在攀爬，那么上下键应该相应地移动他们，但如果没有按键则停止移动。最后，如果玩家在攀爬时离开梯子，它将离开
    `CLIMB` 状态。
- en: 'The one remaining issue is you need gravity to stop pulling the player downwards
    when climbing. Add the following condition to the gravity code in `_physics_process()`:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的一个问题是你需要重力在攀爬时停止将玩家向下拉。在 `_physics_process()` 中的重力代码中添加以下条件：
- en: '[PRE44]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now, the player is ready, and you can add some ladders to your level map.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，玩家已经准备好了，你可以在你的关卡地图中添加一些梯子。
- en: Level code
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关卡代码
- en: 'Place a few ladder tiles somewhere on your map, then add a Ladder `Area2D`
    to the level scene. Give this node a `CollisionShape2D` with a rectangular shape.
    The best way to size the area is to use grid snapping. Turn this on via the menu
    and use Configure Snap... to set the grid step to `(4, 4)`:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的地图上某个地方放置几个梯子瓦片，然后向关卡场景添加一个梯子 `Area2D`。给这个节点一个具有矩形形状的 `CollisionShape2D`。调整区域大小最好的方法是使用网格吸附。通过菜单打开它，并使用配置吸附...将网格步长设置为
    `(4, 4)`：
- en: '![](img/00137.jpeg)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00137.jpeg)'
- en: Adjust the collision shape so that it covers the center portion of the ladder
    from top to bottom. If you make the shape fully as wide as the ladder, the player
    will still count as climbing even when hanging off the side. You may find that
    this looks a bit odd, so making the shape a bit smaller than the width of the
    ladder will prevent this.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 调整碰撞形状，使其从上到下覆盖梯子的中心部分。如果你使形状与梯子一样宽，那么即使玩家悬挂在侧面，也会被视为正在攀爬。你可能觉得这看起来有点奇怪，所以将形状做得比梯子略小可以防止这种情况。
- en: 'Connect the `body_entered` and `body_exited` signals of the `Ladder` and add
    the following code to have them set the Player''s ladder variable:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Ladder` 的 `body_entered` 和 `body_exited` 信号连接起来，并添加以下代码以使它们设置玩家的梯子变量：
- en: '[PRE45]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now you can give it a try. You should be able to walk to the ladder and climb
    up and down it. Note that if you are at the top of a ladder and step onto it,
    you'll fall to the bottom rather than climb down (although pressing up as you
    fall will grab the ladder). If you prefer to automatically transition to the climbing
    state, you can add an additional falling check in `_physics_process()`.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以尝试一下。你应该能够走到梯子旁边并上下攀爬。注意，如果你站在梯子的顶部并踏上它，你会掉到下面而不是向下攀爬（尽管在掉落时按下向上键可以抓住梯子）。如果你希望自动过渡到攀爬状态，你可以在
    `_physics_process()` 中添加一个额外的掉落检查。
- en: Moving platforms
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动平台
- en: 'Make a new scene with a `KinematicBody2D` root node. Add a `Sprite` child and
    use the `res://assets/environment/layers/tileset.png` sprite sheet as the Texture
    with Region enabled so you can choose one particular tile. You probably want your
    platform to be wider than one tile, so duplicate the `Sprite` as many times as
    you like. Turn grid snapping on so that the sprites can be aligned in a row:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景，并添加一个`KinematicBody2D`根节点。添加一个`Sprite`子节点，并使用`res://assets/environment/layers/tileset.png`精灵图集作为纹理，启用区域功能以便你可以选择特定的瓦片。你可能希望你的平台比一个瓦片宽，所以你可以根据需要多次复制`Sprite`。开启网格吸附，以便精灵可以按行对齐：
- en: '![](img/00138.jpeg)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/00138.jpeg)'
- en: 'A grid setting of `(8, 8)` works well for aligning the tiles. Add a rectangular
    `CollisionShape2D` that covers the image:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '`(8, 8)`的网格设置对于对齐瓦片很有效。添加一个覆盖图像的矩形`CollisionShape2D`：'
- en: '![](img/00139.jpeg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](img/00139.jpeg)'
- en: Platform movement can be made very complex (following paths, changing speeds,
    and so on), but this example will stick with a platform that moves horizontally
    back and forth between two objects.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 平台运动可以变得非常复杂（跟随路径、改变速度等），但这个例子将坚持使用在两个物体之间水平来回移动的平台。
- en: 'Here is the platform''s script:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是平台的脚本：
- en: '[PRE46]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This time, you''re using `move_and_collide()` to move the kinematic body. This
    is a better choice since the platform shouldn''t slide when it collides with another
    wall. Instead, it bounces off the colliding body. As long as your collision shapes
    are rectangular (as the `TileMap` bodies are), this method will work fine. If
    you have a rounded object, the bounce may send the platform off in a strange direction,
    in which case you should use something like the following to keep the motion horizontal:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，你使用`move_and_collide()`来移动刚体。这是一个更好的选择，因为平台在与其他墙壁碰撞时不应该滑动。相反，它应该从碰撞体上弹回。只要你的碰撞形状是矩形的（就像`TileMap`刚体一样），这种方法就会很好用。如果你有一个圆形物体，弹跳可能会使平台以奇怪的方向移动，在这种情况下，你应该使用以下类似的方法来保持运动水平：
- en: '[PRE47]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Set the *Velocity* in the Inspector to `(50, 0)`, then go to your level scene
    and instance one of these objects somewhere in your level. Make sure it is between
    two objects so that it can move back and forth between them.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查器中将*速度*设置为`(50, 0)`，然后转到你的关卡场景并在你的关卡中的某个位置实例化这些物体之一。确保它在两个物体之间，这样它就可以在它们之间来回移动。
- en: Run the scene and try jumping on the moving platform. Since the Player is using
    `move_and_slide()`, they will automatically move along with the platform if you
    stand on it.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 运行场景并尝试在移动平台上跳跃。由于玩家使用了`move_and_slide()`，如果你站在平台上，他们会自动随着平台移动。
- en: Add as many of these objects as you like to your level. They will even bounce
    off each other, so you can make chains of moving platforms that cover a large
    distance and require careful timing of the player's jumps.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的关卡中添加尽可能多的这些物体。它们甚至可以相互弹跳，因此你可以制作覆盖大距离的移动平台链，并需要玩家跳跃的精确时间。
- en: Summary
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you learned how to use the `KinematicBody2D` node to create
    arcade-style physics. You also used the `AnimationPlayer` to create a variety
    of animations for character behavior, and made extensive use of what you learned
    in earlier projects to tie everything together. Hopefully, by this point, you
    have a good grasp of the scene system and how a Godot project is structured.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用`KinematicBody2D`节点创建街机风格的物理效果。你还使用了`AnimationPlayer`来为角色行为创建各种动画，并广泛地使用了你在早期项目中学到的知识来整合一切。希望到这一点，你已经很好地掌握了场景系统以及Godot项目的结构。
- en: Remember the Stretch Mode and Aspect properties you set in the Project Settings at
    the beginning? Run the game and observe what happens when you resize the game
    window. These settings are the best for this style of game, but try changing the Stretch
    Mode to Viewport instead, then make your game window very wide or tall. Experiment
    with the other settings to see the effect of the different resizing options.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 记得你在项目设置中最初设置的“拉伸模式”和“方面”属性吗？运行游戏并观察当你调整游戏窗口大小时会发生什么。这些设置对于这种类型的游戏来说是最优的，但尝试将“拉伸模式”改为视口，然后使你的游戏窗口非常宽或高。尝试调整其他设置以查看不同缩放选项的效果。
- en: Once again, before moving on, take a few moments to play your game and look
    through its various scenes and scripts to review how you built it. Review any
    sections of this chapter that you found particularly tricky.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，在继续之前，花几分钟时间玩你的游戏并查看其各种场景和脚本，以回顾你是如何构建它的。回顾本章中你认为特别棘手的任何部分。
- en: In the next chapter, you'll make the jump to 3D!
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将进入3D世界！
