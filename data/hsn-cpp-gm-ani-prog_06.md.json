["```cpp\n    class Shader {\n    private:\n    \u00a0\u00a0\u00a0\u00a0unsigned int mHandle;\n    \u00a0\u00a0\u00a0\u00a0std::map<std::string, unsigned int> mAttributes;\n    \u00a0\u00a0\u00a0\u00a0std::map<std::string, unsigned int> mUniforms;\n    ```", "```cpp\n    private:\n    \u00a0\u00a0\u00a0\u00a0Shader(const Shader&);\n    \u00a0\u00a0\u00a0\u00a0Shader& operator=(const Shader&);\n    ```", "```cpp\n    private:\n    \u00a0\u00a0\u00a0\u00a0std::string ReadFile(const std::string& path);\n    \u00a0\u00a0\u00a0\u00a0unsigned int CompileVertexShader(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 const std::string& vertex);\n    \u00a0\u00a0\u00a0\u00a0unsigned int CompileFragmentShader(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 const std::string& fragment);\n    \u00a0\u00a0\u00a0\u00a0bool LinkShaders(unsigned int vertex, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 unsigned int fragment);\n    \u00a0\u00a0\u00a0\u00a0void PopulateAttributes();\n    \u00a0\u00a0\u00a0\u00a0void PopulateUniforms();\n    ```", "```cpp\n    public:\n    \u00a0\u00a0\u00a0\u00a0Shader();\n    \u00a0\u00a0\u00a0\u00a0Shader(const std::string& vertex, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 const std::string& fragment);\n    \u00a0\u00a0\u00a0\u00a0~Shader();\n    \u00a0\u00a0\u00a0\u00a0void Load(const std::string& vertex, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const std::string& fragment);\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0void Bind();\n    \u00a0\u00a0\u00a0\u00a0void UnBind();\n    \u00a0\u00a0\u00a0\u00a0unsigned int GetAttribute(const std::string& name);\n    \u00a0\u00a0\u00a0\u00a0unsigned int GetUniform(const std::string& name);\n    \u00a0\u00a0\u00a0\u00a0unsigned int GetHandle();\n    };\n    ```", "```cpp\n    Shader::Shader() {\n    \u00a0\u00a0\u00a0\u00a0mHandle = glCreateProgram();\n    }\n    Shader::Shader(const std::string& vertex, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 const std::string& fragment) {\n    \u00a0\u00a0\u00a0\u00a0mHandle = glCreateProgram();\n    \u00a0\u00a0\u00a0\u00a0Load(vertex, fragment);\n    }\n    Shader::~Shader() {\n    \u00a0\u00a0\u00a0\u00a0glDeleteProgram(mHandle);\n    }\n    ```", "```cpp\n    std::string Shader::ReadFile(const std::string& path) {\n    \u00a0\u00a0\u00a0\u00a0std::ifstream file;\n    \u00a0\u00a0\u00a0\u00a0file.open(path);\n    \u00a0\u00a0\u00a0\u00a0std::stringstream contents;\n    \u00a0\u00a0\u00a0\u00a0contents << file.rdbuf();\n    \u00a0\u00a0\u00a0\u00a0file.close();\n    \u00a0\u00a0\u00a0\u00a0return contents.str();\n    }\n    ```", "```cpp\n    unsigned int Shader::CompileVertexShader(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 const string& vertex) {\n    \u00a0\u00a0\u00a0\u00a0unsigned int v = glCreateShader(GL_VERTEX_SHADER);\n    \u00a0\u00a0\u00a0\u00a0const char* v_source = vertex.c_str();\n    \u00a0\u00a0\u00a0\u00a0glShaderSource(v, 1, &v_source, NULL);\n    \u00a0\u00a0\u00a0\u00a0glCompileShader(v);\n    \u00a0\u00a0\u00a0\u00a0int success = 0;\n    \u00a0\u00a0\u00a0\u00a0glGetShaderiv(v, GL_COMPILE_STATUS, &success);\n    \u00a0\u00a0\u00a0\u00a0if (!success) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0char infoLog[512];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0glGetShaderInfoLog(v, 512, NULL, infoLog);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Vertex compilation failed.\\n\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"\\t\" << infoLog << \"\\n\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0glDeleteShader(v);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0;\n    \u00a0\u00a0\u00a0\u00a0};\n    \u00a0\u00a0\u00a0\u00a0return v;\n    }\n    ```", "```cpp\n    unsigned int Shader::CompileFragmentShader(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const std::string& fragment) {\n    \u00a0\u00a0\u00a0\u00a0unsigned int f = glCreateShader(GL_FRAGMENT_SHADER);\n    \u00a0\u00a0\u00a0\u00a0const char* f_source = fragment.c_str();\n    \u00a0\u00a0\u00a0\u00a0glShaderSource(f, 1, &f_source, NULL);\n    \u00a0\u00a0\u00a0\u00a0glCompileShader(f);\n    \u00a0\u00a0\u00a0\u00a0int success = 0;\n    \u00a0\u00a0\u00a0\u00a0glGetShaderiv(f, GL_COMPILE_STATUS, &success);\n    \u00a0\u00a0\u00a0\u00a0if (!success) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0char infoLog[512];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0glGetShaderInfoLog(f, 512, NULL, infoLog);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Fragment compilation failed.\\n\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"\\t\" << infoLog << \"\\n\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0glDeleteShader(f);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0;\n    \u00a0\u00a0\u00a0\u00a0};\n    \u00a0\u00a0\u00a0\u00a0return f;\n    }\n    ```", "```cpp\n    bool Shader::LinkShaders(unsigned int vertex, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 unsigned int fragment) {\n    \u00a0\u00a0\u00a0\u00a0glAttachShader(mHandle, vertex);\n    \u00a0\u00a0\u00a0\u00a0glAttachShader(mHandle, fragment);\n    \u00a0\u00a0\u00a0\u00a0glLinkProgram(mHandle);\n    \u00a0\u00a0\u00a0\u00a0int success = 0;\n    \u00a0\u00a0\u00a0\u00a0glGetProgramiv(mHandle, GL_LINK_STATUS, &success);\n    \u00a0\u00a0\u00a0\u00a0if (!success) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0char infoLog[512];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0glGetProgramInfoLog(mHandle, 512, NULL, infoLog);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"ERROR: Shader linking failed.\\n\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"\\t\" << infoLog << \"\\n\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0glDeleteShader(vertex);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0glDeleteShader(fragment);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0glDeleteShader(vertex);\n    \u00a0\u00a0\u00a0\u00a0glDeleteShader(fragment);\n    \u00a0\u00a0\u00a0\u00a0return true;\n    }\n    ```", "```cpp\n    void Shader::PopulateAttributes() {\n    \u00a0\u00a0\u00a0\u00a0int count = -1;\n    \u00a0\u00a0\u00a0\u00a0int length;\n    \u00a0\u00a0\u00a0\u00a0char name[128];\n    \u00a0\u00a0\u00a0\u00a0int size;\n    \u00a0\u00a0\u00a0\u00a0GLenum type;\n    \u00a0\u00a0\u00a0\u00a0glUseProgram(mHandle);\n    \u00a0\u00a0\u00a0\u00a0glGetProgramiv(mHandle, GL_ACTIVE_ATTRIBUTES, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 &count);\n    \u00a0\u00a0\u00a0\u00a0for (int i = 0; i < count; ++i) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0memset(name, 0, sizeof(char) * 128);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0glGetActiveAttrib(mHandle, (GLuint)i, 128, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&length, &size, &type, name);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int attrib = glGetAttribLocation(mHandle, name);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (attrib >= 0) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mAttributes[name] = attrib;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0glUseProgram(0);\n    }\n    ```", "```cpp\n    void Shader::PopulateUniforms() {\n    \u00a0\u00a0\u00a0\u00a0int count = -1;\n    \u00a0\u00a0\u00a0\u00a0int length;\n    \u00a0\u00a0\u00a0\u00a0char name[128];\n    \u00a0\u00a0\u00a0\u00a0int size;\n    \u00a0\u00a0\u00a0\u00a0GLenum type;\n    \u00a0\u00a0\u00a0\u00a0char testName[256];\n    \u00a0\u00a0\u00a0\u00a0glUseProgram(mHandle);\n    \u00a0\u00a0\u00a0\u00a0glGetProgramiv(mHandle, GL_ACTIVE_UNIFORMS, &count);\n    \u00a0\u00a0\u00a0\u00a0for (int i = 0; i < count; ++i) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0memset(name, 0, sizeof(char) * 128);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0glGetActiveUniform(mHandle, (GLuint)i, 128, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 &length, &size, &type, name);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int uniform=glGetUniformLocation(mHandle, name);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (uniform >= 0) { // Is uniform valid?\n    ```", "```cpp\n    std::string uniformName = name;\n    // if name contains [, uniform is array\n    std::size_t found = uniformName.find('[');\n    if (found != std::string::npos) {\n    ```", "```cpp\n    uniformName.erase(uniformName.begin() + \n    \u00a0\u00a0\u00a0\u00a0 found, uniformName.end());\n    \u00a0\u00a0\u00a0\u00a0 unsigned int uniformIndex = 0;\n    \u00a0\u00a0\u00a0\u00a0 while (true) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 memset(testName,0,sizeof(char)*256);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 sprintf(testName, \"%s[%d]\", \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 uniformName.c_str(), \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 uniformIndex++);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 int uniformLocation = \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 glGetUniformLocation(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 mHandle, testName);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if (uniformLocation < 0) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 mUniforms[testName]=uniformLocation;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mUniforms[uniformName] = uniform;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0glUseProgram(0);\n    }\n    ```", "```cpp\n    void Shader::Load(const std::string& vertex, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const std::string& fragment) {\n    \u00a0\u00a0\u00a0\u00a0std::ifstream f(vertex.c_str());\n    \u00a0\u00a0\u00a0\u00a0bool vertFile = f.good();\n    \u00a0\u00a0\u00a0\u00a0f.close();\n    \u00a0\u00a0\u00a0\u00a0f = std::ifstream(vertex.c_str());\n    \u00a0\u00a0\u00a0\u00a0bool fragFile = f.good();\n    \u00a0\u00a0\u00a0\u00a0f.close();\n    \u00a0\u00a0\u00a0\u00a0std::string v_source = vertex;\n    \u00a0\u00a0\u00a0\u00a0if (vertFile) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0v_source = ReadFile(vertex);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0std::string f_source = fragment;\n    \u00a0\u00a0\u00a0\u00a0if (fragFile) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0f_source = ReadFile(fragment);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0unsigned int vert = CompileVertexShader(v_source);\n    \u00a0\u00a0\u00a0\u00a0unsigned int f = CompileFragmentShader(f_source);\n    \u00a0\u00a0\u00a0\u00a0if (LinkShaders(vert, frag)) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0PopulateAttributes();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0PopulateUniforms();\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    void Shader::Bind() {\n    \u00a0\u00a0\u00a0\u00a0glUseProgram(mHandle);\n    }\n    void Shader::UnBind() {\n    \u00a0\u00a0\u00a0\u00a0glUseProgram(0);\n    }\n    unsigned int Shader::GetHandle() {\n    \u00a0\u00a0\u00a0\u00a0return mHandle;\n    }\n    ```", "```cpp\n    unsigned int Shader::GetAttribute(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const std::string& name) {\n    \u00a0\u00a0\u00a0\u00a0std::map<std::string, unsigned int>::iterator it =\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mAttributes.find(name);\n    \u00a0\u00a0\u00a0\u00a0if (it == mAttributes.end()) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"Bad attrib index: \" << name << \"\\n\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return it->second;\n    }\n    ```", "```cpp\n    unsigned int Shader::GetUniform(const std::string& name){\n    \u00a0\u00a0\u00a0\u00a0std::map<std::string, unsigned int>::iterator it =\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mUniforms.find(name);\n    \u00a0\u00a0\u00a0\u00a0if (it == mUniforms.end()) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"Bad uniform index: \" << name << \"\\n\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return it->second;\n    }\n    ```", "```cpp\n    template<typename T>\n    class Attribute {\n    protected:\n    \u00a0\u00a0\u00a0\u00a0unsigned int mHandle;\n    \u00a0\u00a0\u00a0\u00a0unsigned int mCount;\n    private:\n    \u00a0\u00a0\u00a0\u00a0Attribute(const Attribute& other);\n    \u00a0\u00a0\u00a0\u00a0Attribute& operator=(const Attribute& other);\n    ```", "```cpp\n    void SetAttribPointer(unsigned int slot);\n    ```", "```cpp\n    public:\n    \u00a0\u00a0\u00a0\u00a0Attribute();\n    \u00a0\u00a0\u00a0\u00a0~Attribute();\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0void Set(T* inputArray, unsigned int arrayLength);\n    \u00a0\u00a0\u00a0\u00a0void Set(std::vector<T>& input);\n    \u00a0\u00a0\u00a0\u00a0void BindTo(unsigned int slot);\n    \u00a0\u00a0\u00a0\u00a0void UnBindFrom(unsigned int slot);\n    \u00a0\u00a0\u00a0\u00a0unsigned int Count();\n    \u00a0\u00a0\u00a0\u00a0unsigned int GetHandle();\n    };\n    ```", "```cpp\n    template Attribute<int>;\n    template Attribute<float>;\n    template Attribute<vec2>;\n    template Attribute<vec3>;\n    template Attribute<vec4>;\n    template Attribute<ivec4>;\n    ```", "```cpp\n    template<typename T>\n    Attribute<T>::Attribute() {\n    \u00a0\u00a0\u00a0\u00a0glGenBuffers(1, &mHandle);\n    \u00a0\u00a0\u00a0\u00a0mCount = 0;\n    }\n    template<typename T>\n    Attribute<T>::~Attribute() {\n    \u00a0\u00a0\u00a0\u00a0glDeleteBuffers(1, &mHandle);\n    }\n    ```", "```cpp\n    template<typename T>\n    unsigned int Attribute<T>::Count() {\n    \u00a0\u00a0\u00a0\u00a0return mCount;\n    }\n    template<typename T>\n    unsigned int Attribute<T>::GetHandle() {\n    \u00a0\u00a0\u00a0\u00a0return mHandle;\n    }\n    ```", "```cpp\n    template<typename T>\n    void Attribute<T>::Set(T* inputArray, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 unsigned int arrayLength) {\n    \u00a0\u00a0\u00a0\u00a0mCount = arrayLength;\n    \u00a0\u00a0\u00a0\u00a0unsigned int size = sizeof(T);\n    \u00a0\u00a0\u00a0\u00a0glBindBuffer(GL_ARRAY_BUFFER, mHandle);\n    \u00a0\u00a0\u00a0\u00a0glBufferData(GL_ARRAY_BUFFER, size * mCount, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 inputArray, GL_STREAM_DRAW);\n    \u00a0\u00a0\u00a0\u00a0glBindBuffer(GL_ARRAY_BUFFER, 0);\n    }\n    template<typename T>\n    void Attribute<T>::Set(std::vector<T>& input) {\n    \u00a0\u00a0\u00a0\u00a0Set(&input[0], (unsigned int)input.size());\n    }\n    ```", "```cpp\n    template<>\n    void Attribute<int>::SetAttribPointer(unsigned int s) {\n    \u00a0\u00a0 glVertexAttribIPointer(s, 1, GL_INT, 0, (void*)0);\n    }\n    template<>\n    void Attribute<ivec4>::SetAttribPointer(unsigned int s){\n    \u00a0\u00a0 glVertexAttribIPointer(s, 4, GL_INT, 0, (void*)0);\n    }\n    template<>\n    void Attribute<float>::SetAttribPointer(unsigned int s){\n    \u00a0\u00a0 glVertexAttribPointer(s,1,GL_FLOAT,GL_FALSE,0,0);\n    }\n    ```", "```cpp\n    template<>\n    void Attribute<vec2>::SetAttribPointer(unsigned int s) {\n    \u00a0\u00a0 glVertexAttribPointer(s,2,GL_FLOAT,GL_FALSE,0,0);\n    }\n    template<>\n    void Attribute<vec3>::SetAttribPointer(unsigned int s){\n    \u00a0\u00a0 glVertexAttribPointer(s,3,GL_FLOAT,GL_FALSE,0,0);\n    }\n    template<>\n    void Attribute<vec4>::SetAttribPointer(unsigned int s){\n    \u00a0\u00a0 glVertexAttribPointer(s,4,GL_FLOAT,GL_FALSE,0,0);\n    }\n    ```", "```cpp\n    template<typename T>\n    void Attribute<T>::BindTo(unsigned int slot) {\n    \u00a0\u00a0\u00a0\u00a0glBindBuffer(GL_ARRAY_BUFFER, mHandle);\n    \u00a0\u00a0\u00a0\u00a0glEnableVertexAttribArray(slot);\n    \u00a0\u00a0\u00a0\u00a0SetAttribPointer(slot);\n    \u00a0\u00a0\u00a0\u00a0glBindBuffer(GL_ARRAY_BUFFER, 0);\n    }\n    template<typename T>\n    void Attribute<T>::UnBindFrom(unsigned int slot) {\n    \u00a0\u00a0\u00a0\u00a0glBindBuffer(GL_ARRAY_BUFFER, mHandle);\n    \u00a0\u00a0\u00a0\u00a0glDisableVertexAttribArray(slot);\n    \u00a0\u00a0\u00a0\u00a0glBindBuffer(GL_ARRAY_BUFFER, 0);\n    }\n    ```", "```cpp\ntemplate <typename T>\nclass Uniform {\nprivate:\n\u00a0\u00a0Uniform();\n\u00a0\u00a0Uniform(const Uniform&);\n\u00a0\u00a0Uniform& operator=(const Uniform&);\n\u00a0\u00a0~Uniform();\npublic:\n\u00a0\u00a0static void Set(unsigned int slot, const T& value);\n\u00a0\u00a0static void Set(unsigned int slot,T* arr,unsigned int len);\n\u00a0\u00a0static void Set(unsigned int slot, std::vector<T>& arr);\n};\n```", "```cpp\n    template Uniform<int>;\n    template Uniform<ivec4>;\n    template Uniform<ivec2>;\n    template Uniform<float>;\n    template Uniform<vec2>;\n    template Uniform<vec3>;\n    template Uniform<vec4>;\n    template Uniform<quat>;\n    template Uniform<mat4>;\n    ```", "```cpp\n    template <typename T>\n    void Uniform<T>::Set(unsigned int slot,const T& value){\n    \u00a0\u00a0\u00a0\u00a0Set(slot, (T*)&value, 1);\n    }\n    template <typename T>\n    void Uniform<T>::Set(unsigned int s,std::vector<T>& v){\n    \u00a0\u00a0\u00a0\u00a0Set(s, &v[0], (unsigned int)v.size());\n    }\n    ```", "```cpp\n    #define UNIFORM_IMPL(gl_func, tType, dType) \\\n    template<> void Uniform<tType>::Set(unsigned int slot,\\\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 tType* data, unsigned int length) {\\\n    \u00a0\u00a0\u00a0\u00a0gl_func(slot, (GLsizei)length, (dType*)&data[0]); \\\n    }\n    ```", "```cpp\n    UNIFORM_IMPL(glUniform1iv, int, int)\n    UNIFORM_IMPL(glUniform4iv, ivec4, int)\n    UNIFORM_IMPL(glUniform2iv, ivec2, int)\n    UNIFORM_IMPL(glUniform1fv, float, float)\n    UNIFORM_IMPL(glUniform2fv, vec2, float)\n    UNIFORM_IMPL(glUniform3fv, vec3, float)\n    UNIFORM_IMPL(glUniform4fv, vec4, float)\n    UNIFORM_IMPL(glUniform4fv, quat, float)\n    ```", "```cpp\n    template<> void Uniform<mat4>::Set(unsigned int slot, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat4* inputArray, unsigned int arrayLength) {\n    \u00a0\u00a0\u00a0\u00a0glUniformMatrix4fv(slot, (GLsizei)arrayLength, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 false, (float*)&inputArray[0]);\n    }\n    ```", "```cpp\nclass IndexBuffer {\npublic:\n\u00a0\u00a0\u00a0\u00a0unsigned int mHandle;\n\u00a0\u00a0\u00a0\u00a0unsigned int mCount;\nprivate:\n\u00a0\u00a0\u00a0\u00a0IndexBuffer(const IndexBuffer& other);\n\u00a0\u00a0\u00a0\u00a0IndexBuffer& operator=(const IndexBuffer& other);\npublic:\n\u00a0\u00a0\u00a0\u00a0IndexBuffer();\n\u00a0\u00a0\u00a0\u00a0~IndexBuffer();\n\u00a0\u00a0\u00a0\u00a0void Set(unsigned int* rr, unsigned int len);\n\u00a0\u00a0\u00a0\u00a0void Set(std::vector<unsigned int>& input);\n\u00a0\u00a0\u00a0\u00a0unsigned int Count();\n\u00a0\u00a0\u00a0\u00a0unsigned int GetHandle();\n};\n```", "```cpp\n    IndexBuffer::IndexBuffer() {\n    \u00a0\u00a0\u00a0\u00a0glGenBuffers(1, &mHandle);\n    \u00a0\u00a0\u00a0\u00a0mCount = 0;\n    }\n    IndexBuffer::~IndexBuffer() {\n    \u00a0\u00a0\u00a0\u00a0glDeleteBuffers(1, &mHandle);\n    }\n    ```", "```cpp\n    unsigned int IndexBuffer::Count() {\n    \u00a0\u00a0\u00a0\u00a0return mCount;\n    }\n    unsigned int IndexBuffer::GetHandle() {\n    \u00a0\u00a0\u00a0\u00a0return mHandle;\n    }\n    ```", "```cpp\n    void IndexBuffer::Set(unsigned int* inputArray, unsigned int arrayLengt) {\n    \u00a0\u00a0\u00a0\u00a0mCount = arrayLengt;\n    \u00a0\u00a0\u00a0\u00a0unsigned int size = sizeof(unsigned int);\n    \u00a0\u00a0\u00a0\u00a0glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mHandle);\n    \u00a0\u00a0\u00a0\u00a0glBufferData(GL_ELEMENT_ARRAY_BUFFER, size * mCount, inputArray, GL_STATIC_DRAW);\n    \u00a0\u00a0\u00a0\u00a0glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n    }\n    void IndexBuffer::Set(std::vector<unsigned int>& input) {\n    \u00a0\u00a0\u00a0\u00a0Set(&input[0], (unsigned int)input.size());\n    }\n    ```", "```cpp\n    enum class DrawMode {\n    \u00a0\u00a0\u00a0\u00a0Points,\n    \u00a0\u00a0\u00a0\u00a0LineStrip,\n    \u00a0\u00a0\u00a0\u00a0LineLoop,\n    \u00a0\u00a0\u00a0\u00a0Lines,\n    \u00a0\u00a0\u00a0\u00a0Triangles,\n    \u00a0\u00a0\u00a0\u00a0TriangleStrip,\n    \u00a0\u00a0\u00a0\u00a0TriangleFan\n    };\n    ```", "```cpp\n    void Draw(IndexBuffer& inIndexBuffer, DrawMode mode);\n    void Draw(unsigned int vertexCount, DrawMode mode);\n    ```", "```cpp\n    void DrawInstanced(IndexBuffer& inIndexBuffer, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 DrawMode mode, unsigned int instanceCount);\n    void DrawInstanced(unsigned int vertexCount, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 DrawMode mode, unsigned int numInstances);\n    ```", "```cpp\n    static GLenum DrawModeToGLEnum(DrawMode input) {\n    \u00a0\u00a0\u00a0\u00a0switch (input) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case DrawMode::Points: return\u00a0\u00a0GL_POINTS;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case DrawMode::LineStrip: return GL_LINE_STRIP;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case DrawMode::LineLoop: return\u00a0\u00a0GL_LINE_LOOP;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case DrawMode::Lines: return\u00a0\u00a0GL_LINES;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case DrawMode::Triangles: return\u00a0\u00a0GL_TRIANGLES;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case DrawMode::TriangleStrip: \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return\u00a0\u00a0GL_TRIANGLE_STRIP;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case DrawMode::TriangleFan: \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return\u00a0\u00a0 GL_TRIANGLE_FAN;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0cout << \"DrawModeToGLEnum unreachable code hit\\n\";\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    void Draw(unsigned int vertexCount, DrawMode mode) {\n    \u00a0\u00a0\u00a0\u00a0glDrawArrays(DrawModeToGLEnum(mode), 0, vertexCount);\n    }\n    void DrawInstanced(unsigned int vertexCount, \n    \u00a0\u00a0\u00a0\u00a0 DrawMode mode, unsigned int numInstances) {\n    \u00a0\u00a0\u00a0\u00a0glDrawArraysInstanced(DrawModeToGLEnum(mode), \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00, vertexCount, numInstances);\n    }\n    ```", "```cpp\n    void Draw(IndexBuffer& inIndexBuffer, DrawMode mode) {\n    \u00a0\u00a0\u00a0\u00a0unsigned int handle = inIndexBuffer.GetHandle();\n    \u00a0\u00a0\u00a0\u00a0unsigned int numIndices = inIndexBuffer.Count();\n    \u00a0\u00a0\u00a0\u00a0glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, handle);\n    \u00a0\u00a0\u00a0\u00a0glDrawElements(DrawModeToGLEnum(mode), \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 numIndices, GL_UNSIGNED_INT, 0);\n    \u00a0\u00a0\u00a0\u00a0glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n    }\n    void DrawInstanced(IndexBuffer& inIndexBuffer, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 DrawMode mode, unsigned int instanceCount) {\n    \u00a0\u00a0\u00a0\u00a0unsigned int handle = inIndexBuffer.GetHandle();\n    \u00a0\u00a0\u00a0\u00a0unsigned int numIndices = inIndexBuffer.Count();\n    \u00a0\u00a0\u00a0\u00a0glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, handle);\n    \u00a0\u00a0\u00a0\u00a0glDrawElementsInstanced(DrawModeToGLEnum(mode),\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0numIndices, GL_UNSIGNED_INT, 0, instanceCount);\n    \u00a0\u00a0\u00a0\u00a0glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n    }\n    ```", "```cpp\n#define STB_IMAGE_IMPLEMENTATION\n#include \"stb_image.h\"\n```", "```cpp\nclass Texture {\nprotected:\n\u00a0\u00a0\u00a0\u00a0unsigned int mWidth;\n\u00a0\u00a0\u00a0\u00a0unsigned int mHeight;\n\u00a0\u00a0\u00a0\u00a0unsigned int mChannels;\n\u00a0\u00a0\u00a0\u00a0unsigned int mHandle;\nprivate:\n\u00a0\u00a0\u00a0\u00a0Texture(const Texture& other);\n\u00a0\u00a0\u00a0\u00a0Texture& operator=(const Texture& other);\npublic:\n\u00a0\u00a0\u00a0\u00a0Texture();\n\u00a0\u00a0\u00a0\u00a0Texture(const char* path);\n\u00a0\u00a0\u00a0\u00a0~Texture();\n\u00a0\u00a0\u00a0\u00a0void Load(const char* path);\n\u00a0\u00a0\u00a0\u00a0void Set(unsigned int uniform, unsigned int texIndex);\n\u00a0\u00a0\u00a0\u00a0void UnSet(unsigned int textureIndex);\n\u00a0\u00a0\u00a0\u00a0unsigned int GetHandle();\n};\n```", "```cpp\n    Texture::Texture() {\n    \u00a0\u00a0\u00a0\u00a0mWidth = 0;\n    \u00a0\u00a0\u00a0\u00a0mHeight = 0;\n    \u00a0\u00a0\u00a0\u00a0mChannels = 0;\n    \u00a0\u00a0\u00a0\u00a0glGenTextures(1, &mHandle);\n    }\n    Texture::Texture(const char* path) {\n    \u00a0\u00a0\u00a0\u00a0glGenTextures(1, &mHandle);\n    \u00a0\u00a0\u00a0\u00a0Load(path);\n    }\n    Texture::~Texture() {\n    \u00a0\u00a0\u00a0\u00a0glDeleteTextures(1, &mHandle);\n    }\n    ```", "```cpp\n    void Texture::Load(const char* path) {\n    \u00a0\u00a0\u00a0\u00a0glBindTexture(GL_TEXTURE_2D, mHandle);\n    \u00a0\u00a0\u00a0\u00a0int width, height, channels;\n    \u00a0\u00a0\u00a0\u00a0unsigned char* data = stbi_load(path, &width, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&height, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&channels, 4);\n    \u00a0\u00a0\u00a0\u00a0glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);\n    \u00a0\u00a0\u00a0\u00a0glGenerateMipmap(GL_TEXTURE_2D);\n    \u00a0\u00a0\u00a0\u00a0stbi_image_free(data);\n    \u00a0\u00a0\u00a0\u00a0glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0GL_REPEAT);\n    \u00a0\u00a0\u00a0\u00a0glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0GL_REPEAT);\n    \u00a0\u00a0\u00a0\u00a0glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0GL_NEAREST_MIPMAP_LINEAR);\n    \u00a0\u00a0\u00a0\u00a0glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0GL_LINEAR);\n    \u00a0\u00a0\u00a0\u00a0glBindTexture(GL_TEXTURE_2D, 0);\n    \u00a0\u00a0\u00a0\u00a0mWidth = width;\n    \u00a0\u00a0\u00a0\u00a0mHeight = height;\n    \u00a0\u00a0\u00a0\u00a0mChannels = channels;\n    }\n    ```", "```cpp\n    void Texture::Set(unsigned int uniformIndex, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int textureIndex) {\n    \u00a0\u00a0\u00a0\u00a0glActiveTexture(GL_TEXTURE0 + textureIndex);\n    \u00a0\u00a0\u00a0\u00a0glBindTexture(GL_TEXTURE_2D, mHandle);\n    \u00a0\u00a0\u00a0\u00a0glUniform1i(uniformIndex, textureIndex);\n    }\n    void Texture::UnSet(unsigned int textureIndex) {\n    \u00a0\u00a0\u00a0\u00a0glActiveTexture(GL_TEXTURE0 + textureIndex);\n    \u00a0\u00a0\u00a0\u00a0glBindTexture(GL_TEXTURE_2D, 0);\n    \u00a0\u00a0\u00a0\u00a0glActiveTexture(GL_TEXTURE0);\n    }\n    ```", "```cpp\n    unsigned int Texture::GetHandle() {\n    \u00a0\u00a0\u00a0\u00a0return mHandle;\n    }\n    ```", "```cpp\n#version 330 core\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 projection;\nin vec3 position;\nin vec3 normal;\nin vec2 texCoord;\nout vec3 norm;\nout vec3 fragPos;\nout vec2 uv;\nvoid main() {\n\u00a0\u00a0\u00a0\u00a0gl_Position = projection * view * model * \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vec4(position, 1.0);\n\n\u00a0\u00a0\u00a0\u00a0fragPos = vec3(model * vec4(position, 1.0));\n\u00a0\u00a0\u00a0\u00a0norm = vec3(model * vec4(normal, 0.0f));\n\u00a0\u00a0\u00a0\u00a0uv = texCoord;\n}\n```", "```cpp\n#version 330 core\nin vec3 norm;\nin vec3 fragPos;\nin vec2 uv;\nuniform vec3 light;\nuniform sampler2D tex0;\nout vec4 FragColor;\nvoid main() {\n\u00a0\u00a0\u00a0\u00a0vec4 diffuseColor = texture(tex0, uv);\n\u00a0\u00a0\u00a0\u00a0vec3 n = normalize(norm);\n\u00a0\u00a0\u00a0\u00a0vec3 l = normalize(light);\n\u00a0\u00a0\u00a0\u00a0float diffuseIntensity = clamp(dot(n, l), 0, 1);\n\u00a0\u00a0\u00a0\u00a0FragColor = diffuseColor * diffuseIntensity;\n}\n```"]