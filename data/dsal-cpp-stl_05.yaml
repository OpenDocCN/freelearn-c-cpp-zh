- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Making a Case for std::vector
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 `std::vector` 辩护
- en: This chapter discusses the reasons behind `std::vector`’s popularity by examining
    the performance metrics and real-world applications that make it a go-to container
    for many developers. By comparing `std::vector` against other containers, you
    will clearly understand its strengths and recognize scenarios where alternatives
    might be more suitable. Such insights will empower C++ developers to make informed
    container choices, leading to more efficient and effective code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过检查使 `std::vector` 成为许多开发者首选容器的性能指标和实际应用，讨论了 `std::vector` 流行背后的原因。通过将 `std::vector`
    与其他容器进行比较，你将清楚地了解其优势，并识别出替代方案可能更适合的场景。这样的见解将使 C++ 开发者能够做出明智的容器选择，从而编写更高效、更有效的代码。
- en: 'In this chapter, we will cover the following topics as they relate to `std::vector`:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下与 `std::vector` 相关的主题：
- en: Performance considerations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能考虑
- en: Practical use cases
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际用例
- en: Versatility and efficiency
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多样性和效率
- en: Performance considerations
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能考虑
- en: When choosing a data container in C++, performance often ranks at the top of
    considerations. Naturally, the allure of `std::vector` doesn’t solely rest on
    its ease of use, but mainly on its efficiency. In this section, we’ll delve deep
    into the performance mechanics of `std::vector`, comparing it with other C++ containers
    and shedding light on where it truly shines.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 C++ 中选择数据容器时，性能通常排在考虑因素的首位。自然地，`std::vector` 的吸引力并不仅仅在于其易用性，而主要在于其效率。在本节中，我们将深入探讨
    `std::vector` 的性能机制，将其与其他 C++ 容器进行比较，并揭示它在哪些方面真正出色。
- en: 'At its core, `std::vector` is a dynamic array. This means that its elements
    are stored in contiguous memory locations. This adjacent nature gives `std::vector`
    a performance edge in many scenarios, such as the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，`std::vector` 是一个动态数组。这意味着其元素存储在连续的内存位置中。这种相邻性质使得 `std::vector` 在许多场景中具有性能优势，例如以下情况：
- en: '`std::vector` as fast as a raw array regarding direct element access.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector` 在直接元素访问方面与原始数组一样快。'
- en: '`std::vector` often results in better cache locality, making data access faster
    due to fewer cache misses.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector` 通常会导致更好的缓存局部性，这使得数据访问更快，因为缓存未命中更少。'
- en: '`std::vector` container is typically an *O(1)* operation. While occasional
    resizing may turn this into an *O(n)* operation, the amortized time remains constant.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector` 容器通常是 *O(1)* 操作。虽然偶尔的调整大小可能会将其变成 *O(n)* 操作，但平均时间保持不变。'
- en: 'However, no container is universally the best, and `std::vector` has its limitations,
    too, which are as follows:'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，没有容器是普遍最佳的，`std::vector` 也有其局限性，具体如下：
- en: '`std::list` because of the cache-friendliness of `std::vector`.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::list` 因为 `std::vector` 的缓存友好性。'
- en: '**Deletions**: Similar to insertions, deleting an element from anywhere other
    than the end necessitates shifting, making it an *O(n)* operation.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除**：与插入类似，从除末尾之外的位置删除元素需要移动，这使得它是一个 *O(n)* 操作。'
- en: Comparison with other containers
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与其他容器的比较
- en: '`std::list`: This is a doubly linked list, which means that insertions and
    deletions at any position are *O(1)*. However, it lacks the cache locality of
    `std::vector`, making element access slower. Random access in a list is an *O(n)*
    operation, whereas it is *O(1)* in a vector.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::list`：这是一个双向链表，这意味着在任何位置进行插入和删除都是 *O(1)*。然而，它缺乏 `std::vector` 的缓存局部性，使得元素访问变慢。在列表中的随机访问是一个
    *O(n)* 操作，而在向量中是 *O(1)*。'
- en: '`std::deque`: A double-ended queue that supports efficient insertions and deletions
    at both ends. While it provides a similar random access time as `std::vector`,
    its non-contiguous nature might lead to more cache misses during certain operations.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::deque`：一个支持在两端进行高效插入和删除的双端队列。虽然它提供了与 `std::vector` 相似的随机访问时间，但其非连续性可能在某些操作期间导致更多的缓存未命中。'
- en: '`std::array`: A static array with a fixed size. It offers similar performance
    characteristics as `std::vector` for direct access but lacks dynamic resizing.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::array`：一个具有固定大小的静态数组。它为直接访问提供了与 `std::vector` 相似的性能特征，但缺乏动态调整大小。'
- en: So, when should you choose `std::vector` over these? If your primary operations
    are random access and insertion/removal at the end, `std::vector` is often the
    best choice due to its *O(1)* complexities and excellent cache performance. However,
    if you frequently insert into or delete from the middle, other containers such
    as `std::list` might be more efficient for large data. As always, measure performance
    in your specific use case to guide your decision.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在什么情况下你应该选择`std::vector`而不是其他容器呢？如果你的主要操作是随机访问以及在末尾插入/删除，由于`std::vector`的*O(1)*复杂性和优秀的缓存性能，它通常是最佳选择。然而，如果你经常在中间插入或删除，其他容器如`std::list`可能对大数据集来说更有效率。始终测量你特定用例的性能，以指导你的决策。
- en: The memory advantage
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记忆优势
- en: '`std::vector` manages its memory efficiently. As you add elements, it intelligently
    resizes, often doubling its capacity to minimize the number of allocations. This
    dynamic resizing ensures that while the memory is used optimally, there’s minimal
    overhead in allocations, leading to faster operations.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector`高效地管理其内存。随着你添加元素，它会智能地调整大小，通常将其容量加倍以最小化分配次数。这种动态调整大小确保了内存得到最优使用，同时分配的开销最小，从而加快操作速度。'
- en: The takeaway
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 经验总结
- en: Performance isn’t just about raw speed; it is about choosing the right tool
    for the right job. While `std::vector` offers outstanding performance in many
    scenarios, understanding its strengths and weaknesses is vital. When you match
    your problem’s requirements with the intrinsic strengths of `std::vector`, you
    don’t just write code—you craft optimized solutions ready to meet the demands
    of modern computing.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 性能不仅仅是关于原始速度；它关于选择适合正确工作的工具。虽然`std::vector`在许多场景下提供出色的性能，但了解其优势和劣势至关重要。当你将问题的需求与`std::vector`的内在优势相匹配时，你不仅编写代码——你创造优化解决方案，以应对现代计算的需求。
- en: In the forthcoming sections, we’ll explore the practicality of `std::vector`
    in real-world applications and dive deeper into its versatility, equipping you
    with the knowledge needed to harness its full power.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨`std::vector`在现实世界中的应用的实用性，并深入了解其多功能性，为你提供利用其全部功能所需的知识。
- en: Practical use cases
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际应用案例
- en: While understanding the theoretical and performance advantages of `std::vector`
    is essential, it is often in real-world applications that the strength of a tool
    becomes evident. As we dive into practical use cases, you’ll see why `std::vector`
    is frequently the container of choice for many developers and why, sometimes,
    other options might be more fitting.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然理解`std::vector`的理论和性能优势是必要的，但通常在实际应用中，一个工具的优势才会变得明显。随着我们深入实际用例，你将看到为什么`std::vector`经常是许多开发者的首选容器，有时为什么其他选项可能更合适。
- en: A resizable dynamic array at heart
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心是可调整大小的动态数组
- en: Imagine developing a simulation program that models the behavior of particles
    in a chamber. The number of particles can vary drastically as they split or merge.
    Here, using `std::vector` would be ideal due to its dynamic nature. The program
    would benefit from the constant-time direct access for particle updates, and its
    resizing capability would easily handle varying particle numbers.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下开发一个模拟程序，该程序模拟一个容器中粒子的行为。粒子的数量可能会因为分裂或合并而有很大变化。在这里，由于`std::vector`的动态特性，使用`std::vector`将是理想的。程序将受益于对粒子更新的常数时间直接访问，并且其调整大小能力可以轻松处理变化的粒子数量。
- en: Data processing and analytics
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据处理和分析
- en: Data analytics often involves reading large datasets, processing them, and extracting
    information. Consider a scenario where you’re tasked with reading sensor temperatures
    for an entire year. The data is vast, but once read, it is processed sequentially—calculating
    averages, detecting peaks, and so on. `std::vector`, with its contiguous memory
    and excellent cache locality, becomes a top pick, allowing for faster sequential
    processing of such vast datasets.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 数据分析通常涉及读取大量数据集，处理它们，并提取信息。考虑一个场景，你被要求读取一整年的传感器温度。数据量庞大，但一旦读取，它将按顺序进行处理——计算平均值、检测峰值等。`std::vector`由于其连续的内存和优秀的缓存局部性，成为首选，允许对如此庞大的数据集进行更快的顺序处理。
- en: Graphics and game development
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图形和游戏开发
- en: In game development, objects such as bullets, enemies, and items can be represented
    using `std::vector`. For instance, bullets fired in a shooter game can be stored
    in `std::vector`. As the bullets move or are destroyed, the vector resizes. The
    direct access capability of `std::vector` allows efficient updates to each bullet’s
    position.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，可以使用 `std::vector` 来表示子弹、敌人以及物品等对象。例如，在射击游戏中发射的子弹可以存储在 `std::vector`
    中。随着子弹的移动或被销毁，向量会自动调整大小。`std::vector` 的直接访问能力使得对每个子弹位置的更新变得高效。
- en: Beyond just containers
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不仅仅是容器
- en: The choice of container also depends on the broader architecture of the application.
    For instance, in distributed systems, data might be better represented in structures
    optimized for serialization and deserialization, even if within a single node,
    `std::vector` might seem the best choice.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的选择也取决于应用的更广泛架构。例如，在分布式系统中，数据可能更适合用优化序列化和反序列化的结构来表示，即使在一个节点内，`std::vector`
    可能看起来是最好的选择。
- en: In conclusion, the utility of `std::vector` in real-world applications cannot
    be overstated. Its dynamic nature and the advantages of direct access and cache-friendly
    design make it a powerhouse. However, as with all tools, its effectiveness is
    best realized when matched with the right task. Knowing when to use `std::vector`
    and when to consider alternatives is a testament to a developer’s understanding
    and adaptability. As we move on to explore the versatility and efficiency of `std::vector`,
    you’ll gain even deeper insights into the world of this remarkable container.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，`std::vector` 在实际应用中的效用不容小觑。其动态特性和直接访问以及缓存友好设计的优势使其成为一股强大的力量。然而，就像所有工具一样，其有效性最好是在与正确任务匹配时才能得到体现。知道何时使用
    `std::vector` 以及何时考虑替代方案是对开发者理解和适应能力的证明。随着我们继续探索 `std::vector` 的多功能性和效率，你将更深入地了解这个非凡容器的世界。
- en: Versatility and efficiency
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多功能性及效率
- en: The C++ `std::vector` stands out, often serving as the default choice for many
    C++ developers. Its wide acceptance isn’t a mere chance but a consequence of its
    versatility and efficiency.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 的 `std::vector` 独具特色，常常成为许多 C++ 开发者的默认选择。它的广泛接受并非偶然，而是其多功能性和效率的结果。
- en: A testament to versatility
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多功能性的证明
- en: 'The fundamental design of `std::vector` allows it to serve many programming
    needs. It’s a dynamic array that can grow or shrink, offering the best of both
    worlds: the direct access of arrays and the flexibility of linked lists. This
    means that whether you’re storing data temporarily, manipulating large datasets,
    or simply using it as a buffer, `std::vector` lends itself gracefully.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector` 的基本设计使其能够满足许多编程需求。它是一个可以增长或缩小的动态数组，提供了两全其美的特性：数组的直接访问和链表的灵活性。这意味着无论你是临时存储数据、操作大型数据集，还是仅仅将其用作缓冲区，`std::vector`
    都能优雅地适应。'
- en: For many applications, especially those not bound by specific complexities,
    the first container that developers reach for is `std::vector`. It’s not just
    because of tradition or familiarity; it is because, in a vast majority of cases,
    `std::vector` does the job, and it does it well.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多应用来说，尤其是那些不受特定复杂性限制的应用，开发者首先会想到的是 `std::vector`。这不仅仅是因为传统或熟悉，而是因为在绝大多数情况下，`std::vector`
    都能胜任工作，并且做得很好。
- en: Efficiency isn’t just about speed
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 效率不仅仅是关于速度
- en: While we have delved into the performance aspects, it’s worth noting that efficiency
    is not solely about raw speed. `std::vector`’s continuous memory layout offers
    cache-friendliness and simplifies memory management, reducing fragmentation. Its
    predictable behavior in terms of growth ensures minimal surprise overheads.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经深入探讨了性能方面，但值得注意的是，效率并不仅仅是关于原始速度。`std::vector` 的连续内存布局提供了缓存友好性，简化了内存管理，减少了碎片化。它在增长方面的可预测行为确保了最小化的意外开销。
- en: Moreover, its simple interface, mirrored by many other STL containers, reduces
    the learning curve. Developers can effortlessly switch to `std::vector` from other
    containers or even from arrays. The ease of use and its powerful capabilities
    make `std::vector` a tool that amplifies developer productivity.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它简单易用的接口，与其他许多 STL 容器类似，降低了学习曲线。开发者可以轻松地从其他容器或数组切换到 `std::vector`。易用性和其强大的功能使
    `std::vector` 成为提高开发者生产力的工具。
- en: A safe default, but not the only option
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全的默认选项，但并非唯一选择
- en: One of the hallmarks of a mature developer is knowing the tools at their disposal
    and choosing the right one for the job. `std::vector` is an incredible tool and
    it is versatile enough to be a safe default for many scenarios. Its direct access,
    dynamic sizing, and cache locality strengths make it a general-purpose powerhouse.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 成熟的开发者的一大标志是了解他们可用的工具，并选择适合工作的正确工具。`std::vector` 是一个不可思议的工具，它足够灵活，可以成为许多场景下的安全默认选择。它的直接访问、动态大小和缓存局部性优势使其成为一款通用型强大工具。
- en: However, this does not mean it’s always the right choice. There are situations
    where `std::deque`, `std::list`, or perhaps `std::set` might be more fitting.
    But what sets `std::vector` apart is that when you’re unsure which container to
    start with, it is often a safe bet to begin with `std::vector`. As development
    progresses and needs become more apparent, transitioning to another, more specialized
    container, if required, becomes a strategic decision rather than a necessity.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不意味着它总是正确的选择。在某些情况下，`std::deque`、`std::list` 或可能是 `std::set` 可能更适合。但 `std::vector`
    区别于其他容器的在于，当您不确定从哪个容器开始时，通常从 `std::vector` 开始是一个安全的赌注。随着开发进程的推进和需求变得更加明显，如果需要，过渡到另一个更专业的容器，这成为一个战略决策而不是必需的选择。
- en: Summary
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**总结**'
- en: '`std::vector` embodies the spirit of C++ in many ways. It represents a balance
    of performance and flexibility, serving as a testament to the language’s ethos
    of not sacrificing efficiency for high-level abstraction.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector` 以多种方式体现了 C++ 的精神。它代表了性能和灵活性的平衡，是对语言不牺牲效率以实现高级抽象的伦理的证明。'
- en: As we conclude this chapter, it’s clear that `std::vector` is more than just
    another container in the STL. It’s a cornerstone. By now, you should appreciate
    its significance in C++ and feel confident in harnessing its capabilities. As
    you venture further into C++ development, let the lessons of this part of the
    book guide your container choices, leaning on the strengths of `std::vector` when
    apt and branching out to other STL offerings when the situation demands it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章时，很明显 `std::vector` 不仅仅是 STL 中的另一个容器。它是基石。到现在，您应该欣赏它在 C++ 中的重要性，并对自己利用其能力充满信心。随着您进一步深入
    C++ 开发，让本书这一部分的教训指导您的容器选择，在适当的时候利用 `std::vector` 的优势，并在需要时转向其他 STL 提供的选项。
- en: '*Part II* of this book will look at all STL data structures. Armed with the
    knowledge you have gained in *Part I*, you can compare and contrast `std::vector`
    to its many alternatives.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 本书**第二部分**将探讨所有 STL 数据结构。在掌握了**第一部分**的知识后，您可以比较和对比 `std::vector` 和其众多替代品。
- en: 'Part 2: Understanding STL Data Structures'
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**第二部分：理解 STL 数据结构**'
- en: This part of the book is a detailed reference to the versatile world of STL
    data structures. We commence with the sequential containers—`std::array`, `std::vector`,
    `std::deque`, `std::list`, `std::forward_list`, and `std::string`—providing you
    with a granular understanding of their design, usage, and performance nuances.
    Each container’s purpose and suitability are assessed, alongside discussions on
    their ideal use cases and performance characteristics. You will learn about the
    finer points of memory management and thread safety and how to interact with STL
    algorithms effectively.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本书这一部分是对 STL 数据结构丰富世界的详细参考。我们从顺序容器开始——`std::array`、`std::vector`、`std::deque`、`std::list`、`std::forward_list`
    和 `std::string`——为您提供对这些容器设计、使用和性能细微差别的深入理解。每个容器的目的和适用性都会被评估，同时还会讨论它们的理想用例和性能特征。您将了解内存管理和线程安全的高级要点，以及如何有效地与
    STL 算法交互。
- en: We then focus on the ordered and unordered associative containers—`std::set`,
    `std::map`, `std::multiset`, `std::multimap`, and their unordered counterparts.
    The exploration continues with container adaptors such as `std::stack`, `std::queue`,
    and `std::priority_queue`, detailing their use cases and performance insights.
    We also introduce newer additions like `std::flat_set` and `std::flat_map`, which
    offer a balance between sequence and associative containers.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着关注有序和无序关联容器——`std::set`、`std::map`、`std::multiset`、`std::multimap` 以及它们的无序对应物。探索继续到容器适配器，如
    `std::stack`、`std::queue` 和 `std::priority_queue`，详细说明它们的用例和性能见解。我们还介绍了新的添加项，如
    `std::flat_set` 和 `std::flat_map`，它们在序列和关联容器之间提供了平衡。
- en: Concluding with container views like `std::span` and `std::mdspan`, this part
    equips you with the knowledge to select and manipulate the most fitting STL container
    for your data structure challenges while employing best practices and understanding
    exceptions and customization.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '以`std::span`和`std::mdspan`等容器视图作为总结，本部分为你提供了选择和操作最适合你数据结构挑战的STL容器所需的知识，同时采用最佳实践并理解异常和定制。 '
- en: As the chapters in this part are a series of reference chapters, they are structured
    in a slightly different manner with no *Summary* section at the end.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本部分章节是一系列参考章节，它们的结构略有不同，没有*总结*部分。
- en: By the end of this part, you will comprehend the full capabilities of STL containers
    and be proficient in applying them to create efficient and effective C++ applications.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 到本部分结束时，你将理解STL容器的全部功能，并能够熟练地将它们应用于创建高效且有效的C++应用程序。
- en: 'This part has the following chapters:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 6*](B21945_06.xhtml#_idTextAnchor142)*: Advanced Sequence Container
    Usage*'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B21945_06.xhtml#_idTextAnchor142)*：高级序列容器使用*'
- en: '[*Chapter 7*](B21945_07.xhtml#_idTextAnchor235)*: Advanced Ordered Associative
    Container Usage*'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B21945_07.xhtml#_idTextAnchor235)*：高级有序关联容器使用*'
- en: '[*Chapter 8*](B21945_08.xhtml#_idTextAnchor298)*: Advanced Unordered Associative
    Container Usage*'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B21945_08.xhtml#_idTextAnchor298)*：高级无序关联容器使用*'
- en: '[*Chapter 9*](B21945_09.xhtml#_idTextAnchor361)*: Container Adaptors*'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B21945_09.xhtml#_idTextAnchor361)*：容器适配器*'
- en: '[*Chapter 10*](B21945_10.xhtml#_idTextAnchor465)*: Container Views*'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B21945_10.xhtml#_idTextAnchor465)*：容器视图*'
