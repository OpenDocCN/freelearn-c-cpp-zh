- en: '*Chapter 4*: Working with Targets'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：使用目标'
- en: The most basic target we can build in CMake is a single binary executable file
    that encompasses an entire application. It can be made out of a single piece of
    source code, such as the classic `helloworld.cpp`. Or it can be something complex
    – built with hundreds or even tens of thousands of files. This is what many beginner
    projects look like – create a binary with one source file, add another, and, before
    you know it, everything is linked to a single binary without any structure whatsoever.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在CMake中，我们可以构建的最基本目标是一个单一的二进制可执行文件，它包含了一个完整的应用程序。它可以由单一片源代码组成，如经典的`helloworld.cpp`。或者它可以更复杂——由数百个甚至数千个文件构建而成。这就是许多初学者项目的外观——用一个源文件创建一个二进制文件，再添加另一个，在不知不觉中，一切都被链接到一个没有结构可言的二进制文件中。
- en: 'As software developers, we deliberately draw boundaries and designate components
    to group one or more units of translation (`.cpp` files). We do it for multiple
    reasons: to increase code readability, manage coupling and connascence, speed
    up the build process, and finally, extract the reusable components.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件开发者，我们故意划设定界线，并将组件指定为将一个或多个翻译单元（`.cpp`文件）分组在一起。我们这样做有多个原因：增加代码的可读性，管理耦合和connascence，加快构建过程，最后，提取可重用的组件。
- en: Every project that is big enough will push you to introduce some form of partitioning.
    A target in CMake is an answer to exactly that problem – a high-level logical
    unit that forms a single objective for CMake. A target may depend on other targets,
    and they are produced in a declarative way. CMake will take care of determining
    in what order targets have to be built and then execute the necessary steps one
    by one. As a general rule, building a target will produce an artifact that will
    be fed into other targets or delivered as a final product of the build.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 每一个足够大的项目都会推动你引入某种形式的分区。CMake中的目标正是为了解决这个问题——一个高级逻辑单元，为CMake形成一个单一目标。一个目标可能依赖于其他目标，它们以声明性方式生成。CMake将负责确定目标需要以什么顺序构建，然后逐个执行必要的步骤。作为一个一般规则，构建一个目标将生成一个artifact，这个artifact将被输送到其他目标中，或作为构建的最终产品交付。
- en: 'I deliberately use the inexact word *artifact* because CMake doesn''t limit
    you to producing executables or libraries. In reality, we can use generated buildsystems
    to create many kinds of output: more source files, headers, *object files*, archives,
    and configuration files – anything really. All we need is a command-line tool
    (such as a compiler), optional input files, and an output path.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我故意使用不确切的词汇*artifact*，因为CMake并没有限制你只能生成可执行文件或库。实际上，我们可以使用生成的构建系统来创建许多类型的输出：更多的源文件、头文件、*对象文件*、归档文件和配置文件——任何真正需要的。我们需要的只是一个命令行工具（如编译器）、可选的输入文件和一个输出路径。
- en: Targets are a very powerful concept and simplify building a project greatly.
    It is key to understand how they work and how to configure them in the most elegant
    and clean way.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是一个非常强大的概念，极大地简化了项目的构建。理解它们如何工作以及如何以最优雅、最清洁的方式配置它们是关键。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: The concept of a target
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标概念
- en: Writing custom commands
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自定义命令
- en: Understanding generator expressions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解生成器表达式
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files that are present in this chapter on GitHub at [https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter04](https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter04).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章中存在的代码文件，地址为[https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter04](https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter04)。
- en: 'To build examples provided in this book always use recommended commands:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建本书中提供的示例，始终使用推荐的命令：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Be sure to replace placeholders `<build tree>` and `<source tree>` with appropriate
    paths. As a reminder: **build tree** is the path to target/output directory, **source
    tree** is the path at which your source code is located.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保将占位符`<build tree>`和`<source tree>`替换为适当的路径。作为提醒：**build tree**是目标/输出目录的路径，**source
    tree**是源代码所在的位置路径。
- en: The concept of a target
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目标概念
- en: If you have ever used GNU Make, you will have already seen the concept of a
    target. Essentially, it's a recipe that a buildsystem uses to compile a list of
    files into another file. It can be a `.cpp` implementation file compiled into
    an `.o` *object file*, a group of `.o` files packaged into an `.a` static library,
    and many other combinations.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过GNU Make，你已经看到了目标的概念。本质上，它是一个构建系统用来将一组文件编译成另一个文件的食谱。它可以是一个`.cpp`实现文件编译成一个`.o`*对象文件*，一组`.o`文件打包成一个`.a`静态库，还有许多其他组合。
- en: 'CMake, however, allows you to save time and skip the intermediate steps of
    those recipes; it works on a higher level of abstraction. It understands how to
    build an executable directly from source files. So, you don''t need to write an
    explicit recipe to compile any *object files*. All that''s required is an `add_executable()`
    command with the name of the executable target and a list of the files that are
    to be its elements:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: CMake允许你节省时间并跳过那些食谱的中间步骤；它在更高的抽象级别上工作。它理解如何直接从源文件构建可执行文件。所以，你不需要编写显式的食谱来编译任何*对象文件*。所需的就是一个`add_executable()`命令，带有可执行目标的名字和要作为其元素的文件列表：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We already used this command in previous chapters and we already know how executable
    targets are used in practice – during the generation step, CMake will create a
    buildsystem and fill it with recipes to compile each of the source files and link
    them together into a single binary executable.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的章节中已经使用了这个命令，并且我们已经知道如何在实践中使用可执行目标——在生成步骤中，CMake将创建一个构建系统并为其填充编译每个源文件并将它们链接在一起成一个单一的二进制可执行文件的食谱。
- en: 'In CMake, we can create a target using one of three commands:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在CMake中，我们可以使用三个命令之一创建一个目标：
- en: '`add_executable()`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_executable()`'
- en: '`add_library()`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_library()`'
- en: '`add_custom_target()`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_custom_target()`'
- en: The first two are pretty self-explanatory; we briefly used them already in previous
    chapters to build executables and libraries (and we'll discuss them in depth in
    [*Chapter 5*](B17205_05_Final_JC_ePub.xhtml#_idTextAnchor126), *Compiling C++
    Sources with CMake*). But what are those custom targets?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个相对容易解释；我们已经在之前的章节中简要使用过它们来构建可执行文件和库（我们将在[第5章](B17205_05_Final_JC_ePub.xhtml#_idTextAnchor126)深入讨论它们，*使用CMake编译C++源代码*）。但那些自定义目标是什么？
- en: 'They allow you to specify your own command line that will be executed *without
    checking whether the produced output is up to date*, for example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 它们允许你指定自己的命令行，该命令行将被执行*而不检查产生的输出是否是最新的*，例如：
- en: Calculate the checksums of other binaries.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算其他二进制文件的校验和。
- en: Run the code-sanitizer and collect the results.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行代码净化器并收集结果。
- en: Send a compilation report to the data processing pipeline.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将编译报告发送到数据处理管道。
- en: 'Here''s the full signature of the `add_custom_target()` command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`add_custom_target()`命令的完整签名：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We won't discuss every option here, as we want to quickly move on to other targets,
    but let's just say that custom targets don't necessarily have to produce tangible
    artifacts in the form of files.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里讨论每一个选项，因为我们想快速继续其他目标，但可以说自定义目标不必一定以文件形式产生有形工件。
- en: 'One good use case for custom targets might be the need to remove specific files
    on every build – for example, to make sure that code-coverage reports don''t contain
    stale data. All we need to do is define a custom target like so:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义目标的一个好用例可能是需要在每次构建时删除特定文件的需求——例如，确保代码覆盖报告不包含过时数据。我们只需要像这样定义一个自定义目标：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding command will search for all files with a `.gcda` extension and
    remove them. There is one catch though; unlike executable and library targets,
    custom targets won't be built until they are added to a dependency graph. Let's
    find out what that is.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将搜索所有具有`.gcda`扩展名的文件并将它们删除。但是有一个问题；与可执行文件和库目标不同，自定义目标只有在它们被添加到依赖图时才会构建。我们来了解一下那是怎么回事。
- en: Dependency graph
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖图
- en: 'Mature applications are often built from many components, and I don''t mean
    external dependencies here. Specifically, I''m talking about internal libraries.
    Adding them to the project is useful from a structural perspective, as related
    things are packaged together in a single logical entity. And they can be linked
    with other targets – another library or an executable. This is especially convenient
    when multiple targets are using the same library. Take a look at *Figure 4.1*,
    which describes an exemplary dependency graph:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 成熟的应用程序通常由许多组件组成，我这里不是指外部依赖。具体来说，我指的是内部库。从结构上讲，将它们添加到项目中是有用的，因为相关的事物被包装在单一的逻辑实体中。并且它们可以与其他目标链接——另一个库或一个可执行文件。当多个目标使用同一个库时，这尤其方便。看看*图4.1*，它描述了一个示例依赖关系图：
- en: '![Figure 4.1 – Order of building dependencies in the BankApp project'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1 – BankApp项目中依赖关系的构建顺序'
- en: '](img/Figure_4.1_B17205.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.1_B17205.jpg)'
- en: Figure 4.1 – Order of building dependencies in the BankApp project
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – BankApp项目中依赖关系的构建顺序
- en: 'In this project, we have two libraries, two executables, and a custom target.
    Our use case here is to provide a banking application with a nice GUI for users
    (**GuiApp**), and a command-line version to be used as part of an automated script
    (**TerminalApp**). Both executables are depending on the same **Calculations**
    library, but only one of them needs the **Drawing** library. To guarantee that
    our app wasn''t modified when it was downloaded from the internet by an end user,
    we''ll calculate a checksum, store it in a file, and distribute it through separate
    secure channels. CMake is pretty flexible when it comes to writing list files
    for such a solution:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们有两个库，两个可执行文件和一个自定义目标。我们的用例是提供一个带有漂亮GUI的用户银行应用程序（**GuiApp**），以及一个作为自动化脚本一部分的命令行版本（**TerminalApp**）。两个可执行文件都依赖于同一个**Calculations**库，但只有其中一个需要**Drawing**库。为了确保我们的应用程序在用户从互联网下载时没有被修改，我们将计算一个校验和，将其存储在文件中，并通过单独的安全渠道分发它。CMake在编写此类解决方案的列表文件方面相当灵活：
- en: chapter04/01-targets/CMakeLists.txt
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04/01-targets/CMakeLists.txt
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We connect our libraries with executables by using the `target_link_libraries()`
    command. Without it, the compilation for executables would fail because of undefined
    symbols. Have you noticed that we invoked this command before actually declaring
    any of the libraries? When CMake configures the project, it collects the information
    about targets and their properties – their names, dependencies, source files,
    and other details.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`target_link_libraries()`命令将库和可执行文件连接起来。没有它，可执行文件的编译会失败，因为存在未定义的符号。你注意到我们在这个命令在实际上声明了任何库之前就调用了吗？当CMake配置项目时，它会收集有关目标和它们属性的信息——它们的名称、依赖关系、源文件和其他详细信息。
- en: After parsing all the files, CMake will attempt to build a dependency graph.
    And like with all valid dependency graphs, they're directional acyclic graphs.
    This means that there is a clear direction of which target depends on which, and
    such dependencies cannot form cycles.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析完所有文件后，CMake将尝试构建一个依赖关系图。和所有有效的依赖关系图一样，它们都是有向无环图。这意味着有一个明确的方向，即哪个目标依赖于哪个目标，并且这样的依赖关系不能形成循环。
- en: 'When we execute `cmake` in build mode, the generated buildsystem will check
    what top-level targets we have defined and recursively build their dependencies.
    Let''s consider our example from *Figure 4.1*:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们以构建模式执行`cmake`时，生成的构建系统将检查我们定义了哪些顶层目标，并递归地构建它们的依赖关系。让我们考虑一下来自*图4.1*的例子：
- en: Start from the top, and build both libraries in group 1.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从顶部开始，为组1构建两个库。
- en: When the **Calculations** and **Drawing** libraries are complete, build group
    2 – **GuiApp** and **TerminalApp**.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当**Calculations**和**Drawing**库完成后，构建组2——**GuiApp**和**TerminalApp**。
- en: Build a checksum target; run specified command lines to generate checksums (`cksum`
    is a Unix checksum tool).
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个校验和目标；运行指定的命令行生成校验和（`cksum`是一个Unix校验和工具）。
- en: 'There''s a slight issue though – the preceding solution doesn''t guarantee
    that a checksum target will be built after executables. CMake doesn''t know that
    a checksum depends on the executable binaries being present, so it''s free to
    start building it first. To resolve this problem, we can put the `add_dependencies()`
    command at the end of the file:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 不过有一个小问题——前面的解决方案并不能保证校验和目标在可执行文件之后构建。CMake不知道校验和依赖于可执行二进制文件的存在，所以它可以先开始构建它。为了解决这个问题，我们可以把`add_dependencies()`命令放在文件的末尾：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will ensure that CMake understands the relation between the Checksum target
    and the executables.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保CMake理解Checksum目标与可执行文件之间的关系。
- en: That's great, but what's the difference between `target_link_libraries()` and
    `add_dependencies()`? The first is intended to be used with actual libraries and
    allows you to control property propagation. The second is meant to be used only
    with top-level targets to set their build order.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，但`target_link_libraries()`和`add_dependencies()`之间有什么区别？第一个是用来与实际库一起使用，并允许你控制属性传播。第二个仅适用于顶级目标以设置它们的构建顺序。
- en: As projects grow in complexity, the dependency tree gets harder to understand.
    How can we simplify this process?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 随着项目复杂性的增加，依赖树变得越来越难以理解。我们如何简化这个过程？
- en: Visualizing dependencies
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化依赖关系
- en: Even small projects can be difficult to reason about and share with other developers.
    The easiest way to do so is through a nice diagram. After all, a picture is worth
    a thousand words. We can do the work and draw a diagram ourselves, just like I
    did in *Figure 4.1*. But this is tedious and would require constant updates. Luckily,
    CMake has a great module to generate dependency graphs in the `dot/graphviz` format.
    And it supports both internal and external dependencies!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 即使小型项目也难以推理和与其他开发人员共享。最简单的方法之一是通过一个好的图表。毕竟，一张图片胜过千言万语。我们可以自己动手绘制图表，就像我在*图4.1*中做的那样。但这很繁琐，并且需要不断更新。幸运的是，CMake有一个很好的模块，可以在`dot/graphviz`格式中生成依赖图。而且它支持内部和外部依赖！
- en: 'To use it, we can simply execute this command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，我们可以简单地执行这个命令：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The module will produce a text file that we can import to the Graphviz visualization
    software, which can render an image or produce a PDF or SVG file that can be stored
    as part of the software documentation. Everybody loves great documentation, but
    hardly anyone likes to create it – now, you don't need to!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块将生成一个文本文件，我们可以将其导入到Graphviz可视化软件中，该软件可以渲染图像或生成PDF或SVG文件，作为软件文档的一部分。每个人都喜欢伟大的文档，但几乎没有人喜欢创建它——现在，你不需要！
- en: 'If you''re in a rush, you can even run Graphviz straight from your browser
    at this address:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你急于求成，甚至可以直接从你的浏览器中运行Graphviz，地址如下：
- en: '[https://dreampuf.github.io/GraphvizOnline/](https://dreampuf.github.io/GraphvizOnline/)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://dreampuf.github.io/GraphvizOnline/](https://dreampuf.github.io/GraphvizOnline/)'
- en: Important Note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Custom targets are not visible by default and we need to create a special configuration
    file, `CMakeGraphVizOptions.cmake`, that will allow us to customize the graph.
    One handy customization command is `set(GRAPHVIZ_CUSTOM_TARGETS TRUE)`; add it
    to the special configuration file to enable reporting custom targets in your graph.
    You can find more options in the documentation for the module.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义目标默认是不可见的，我们需要创建一个特殊的配置文件`CMakeGraphVizOptions.cmake`，它将允许我们自定义图表。一个方便的自定义命令是`set(GRAPHVIZ_CUSTOM_TARGETS
    TRUE)`；将其添加到特殊配置文件中以在您的图表中启用报告自定义目标。您可以在模块的文档中找到更多选项。
- en: All you need to do is copy and paste the contents of the `test.dot` file into
    the window on the left and your project will be visualized. Quite convenient,
    isn't it?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要将`test.dot`文件的内容复制并粘贴到左侧窗口中，你的项目就会被可视化。非常方便，不是吗？
- en: '![Figure 4.2 – A visualization of the BankApp example in Graphviz'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2 —— BankApp示例的Graphviz可视化'
- en: '](img/Figure_4.2_B17205.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.2_B17205.jpg)'
- en: Figure 4.2 – A visualization of the BankApp example in Graphviz
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 —— 使用Graphviz可视化的BankApp示例
- en: I have removed the automatically generated legend section from the preceding
    figure for clarity.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，我已经从前面的图中移除了自动生成的图例部分。
- en: Using this method, we can quickly see all the explicitly defined targets. Now
    that we have this global perspective, let's do a deep dive and see how to configure
    them.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们可以快速查看所有明确定义的目标。现在我们有了这个全局视角，让我们深入了解一下如何配置它们。
- en: Target properties
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标属性
- en: 'Targets have properties that work in a similar way to fields of C++ objects.
    We can modify some of these properties and others are read-only. CMake defines
    a large list of "known properties" (see the *Further reading* section) that are
    available depending on the type of the target (executable, library, or custom).
    You can also add your own properties if you like. Use the following commands to
    manipulate the properties of a target:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 目标具有类似于C++对象字段的工作方式属性。我们可以修改其中的一些属性，而其他属性是只读的。CMake定义了一个大量的“已知属性”（参见*进一步阅读*部分），这些属性取决于目标类型（可执行文件、库或自定义）。如果你愿意，你也可以添加你自己的属性。使用以下命令来操作目标属性：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To print a target property on screen, we first need to store it in the `<var>`
    variable and then `message()` it to the user; we have to read them one by one.
    On the other hand, setting properties on a target allows us to specify multiple
    properties at the same time, on multiple targets.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在屏幕上打印目标属性，我们首先需要将其存储在`<var>`变量中，然后将其传递给用户；我们必须一个一个地读取它们。另一方面，为目标设置属性允许我们同时指定多个属性，在多个目标上。
- en: 'The concept of properties isn''t unique to targets; CMake supports setting
    properties of other scopes as well: `GLOBAL`, `DIRECTORY`, `SOURCE`, `INSTALL`,
    `TEST`, and `CACHE`. To manipulate all kinds of properties, there are general
    `get_property()` and `set_property()` commands. You can use these low-level commands
    to do exactly what the `set_target_properties()` command does, just with a bit
    more work:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 属性概念不仅限于目标；CMake也支持设置其他范围属性的：`GLOBAL`、`DIRECTORY`、`SOURCE`、`INSTALL`、`TEST`和`CACHE`。为了操作各种各样的属性，有通用的`get_property()`和`set_property()`命令。你可以使用这些底层命令来做与`set_target_properties()`命令完全相同的事情，只是需要更多的工作：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Generally, it's better to use as many high-level commands as you can. CMake
    offers more of these, even narrower in their scope, such as setting specific properties
    on a target. For example, `add_dependencies(<target> <dep>)` is appending dependencies
    to the `MANUALLY_ADDED_DEPENDENCIES` target property. In this case, we can query
    it with `get_target_property()` exactly as with any other property. However, we
    can't use `set_target_property()` to change it (it's read-only), as CMake insists
    on using the `add_dependencies()` command to restrict operations to appending
    only.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，尽可能使用许多高级命令是更好的。CMake提供更多这些，甚至范围更窄，例如为目标设置特定属性。例如，`add_dependencies(<target>
    <dep>)`是在`MANUALLY_ADDED_DEPENDENCIES`目标属性上添加依赖项。在这种情况下，我们可以用`get_target_property()`查询它，就像查询任何其他属性一样。然而，我们不能用`set_target_property()`来更改它（它是只读的），因为CMake坚持使用`add_dependencies()`命令来限制操作只是添加。
- en: We'll introduce more property setting commands when we discuss compiling and
    linking in upcoming chapters. Meanwhile, let's focus on how the properties of
    one target can transition to another.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中讨论编译和链接时，我们将介绍更多的属性设置命令。同时，让我们关注一个目标的属性如何传递到另一个目标。
- en: What are transitive usage requirements?
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递使用要求是什么？
- en: Let's just agree that naming is hard, and sometimes one ends up with a result
    that's hard to understand. "Transitive usage requirements" is, unfortunately,
    one of those cryptic titles that you will encounter in the online CMake documents.
    Let's untangle this strange name and perhaps propose a term easier to understand.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们姑且同意命名是困难的，有时最终得到的结果很难理解。“传递使用要求”不幸之一，那些你在在线CMake文档中遇到的神秘标题。让我们解开这个奇怪的名字，也许提出一个更容易理解的术语。
- en: I'll start by clarifying the middle bit of this puzzle. As we previously discussed,
    one target may depend on another. CMake documentation sometimes refers to such
    dependency as *usage*, as in one target *uses* another. This was straightforward,
    so on to the next one.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我将先澄清这个谜题的中间部分。正如我们之前讨论的，一个目标可能依赖于另一个目标。CMake文档有时将这种依赖性称为*使用*，即一个目标*使用*另一个目标。这很简单，所以继续下一个。
- en: 'There will be cases when such a used target has specific *requirements* that
    a using target has to meet: link some libraries, include a directory, or require
    specific compile features. All of these are in fact requirements, so documentation
    is correct in a sense. The issue is that they aren''t called requirements in any
    other context in the documentation. When you specify the same requirements for
    a single target, you set *properties* or *dependencies*. Therefore, the last part
    of the name should perhaps be simply "properties."'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，这样的使用目标必须满足一些特定的*要求*：链接一些库，包含一个目录，或者需要特定的编译特性。所有这些都是要求，所以在某种意义上文档是正确的。问题是，在文档的其他任何上下文中，它们都不被称为要求。当你为一个单一目标指定同样的要求时，你设置*属性*或*依赖项*。因此，名称的最后部分也许应该简单地称为“属性”。
- en: The last part is –*transitive*. This one I believe is correct (maybe a bit too
    smart). CMake appends some properties/requirements of used targets to properties
    of targets using them. You can say that some properties can transition (or simply
    propagate) across targets implicitly, so it's easier to express dependencies.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个是–*传递的*。我相信这是正确的（也许有点太聪明了）。CMake将在使用它们的目标的某些属性/要求附加到使用它们的目标的属性上。你可以说是有些属性可以隐式地传递（或简单地传播）跨目标，所以更容易表达依赖关系。
- en: Simplifying this whole concept, I see it as *propagated properties* between
    *the source target* (targets that gets used) and *destination targets* (targets
    that use other targets).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 简化这个概念，我认为这就像是*传播属性*，在*源目标*（被使用的目标）和*目标目标*（使用其他目标的目标）之间。
- en: 'Let''s look at a concrete example to understand why it''s there and how it
    works:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个具体的例子来了解它为什么存在以及它是如何工作的：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This target command will populate the `COMPILE_DEFINITIONS` property of a `<source>`
    target. *Compile definitions* are simply `-Dname=definition` flags passed to the
    compiler that configure the C++ preprocessor definitions (we'll get to that in
    [*Chapter 5*](B17205_05_Final_JC_ePub.xhtml#_idTextAnchor126), *Compiling C++
    Sources with CMake*). The interesting part here is the second argument. We need
    to specify one of three values, `INTERFACE`, `PUBLIC`, or `PRIVATE`, to control
    which targets the property should be passed to. Now, don't confuse these with
    C++ access specifiers – this is something else.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个目标命令将填充`<source>`目标的`COMPILE_DEFINITIONS`属性。编译定义仅仅是传递给编译器的`-Dname=definition`标志，用于配置C++预处理器定义（我们将在[第5章](B17205_05_Final_JC_ePub.xhtml#_idTextAnchor126)，*使用CMake编译C++源代码*中讨论这个）。这里有趣的部分是第二个参数。我们需要指定三个值之一，`INTERFACE`，`PUBLIC`或`PRIVATE`，以控制属性应该传递给哪些目标。现在，不要将这些与C++访问修饰符混淆——这完全是另一回事。
- en: 'Propagation keywords work like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 传播关键字按如下方式工作：
- en: '`PRIVATE` sets the property of the source target.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PRIVATE` 用于设置源目标属性。'
- en: '`INTERFACE` sets the property of the destination targets.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INTERFACE` 用于设置目标目标属性。'
- en: '`PUBLIC` sets the property of the source and destination targets.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUBLIC` 用于设置源目标和目标目标属性。'
- en: When a property is not to be transitioned to any destination targets, set it
    to `PRIVATE`. When such a transition is needed, go with `PUBLIC`. If you're in
    a situation where the source target doesn't use the property in its implementation
    (`.cpp` files) and only in headers, and these are passed to the consumer targets,
    `INTERFACE` is the answer.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个属性不应该传递给任何目标目标时，将其设置为`PRIVATE`。当需要这样的传递时，选择`PUBLIC`。如果你处于这样的情况，源目标在其实现中（`.cpp`文件）不使用属性，只在头文件中使用，并且这些被传递给消费者目标，那么`INTERFACE`就是答案。
- en: How does this work under the hood? To manage those properties, CMake provides
    a few commands such as the aforementioned `target_compile_definitions()`. When
    you specify a `PRIVATE` or `PUBLIC` keyword, CMake will store provided values
    in the property of the target matching the command – in this case, `COMPILE_DEFINITIONS`.
    Additionally, if a keyword was `INTERFACE` or `PUBLIC`, it will store the value
    in property with an `INTERFACE_` prefix – `INTERFACE_COMPILE_DEFINITIONS`. During
    the configuration stage, CMake will read the interface properties of source targets
    and append their contents to destination targets. There you have it – propagated
    properties, or transitive usage requirements – as CMake calls them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个机制是如何工作的呢？为了管理这些属性，CMake提供了一些命令，比如前面提到的`target_compile_definitions()`。当你指定一个`PRIVATE`或`PUBLIC`关键字时，CMake将在与命令匹配的目标属性中存储提供的值——在这个例子中，是`COMPILE_DEFINITIONS`。另外，如果关键字是`INTERFACE`或`PUBLIC`，它将在带有`INTERFACE_`前缀的属性中存储值——`INTERFACE_COMPILE_DEFINITIONS`。在配置阶段，CMake将读取源目标的对接口属性并将它们的内容附加到目标目标。就这样——传播属性，或者按CMake的说法，传递使用要求。
- en: 'In CMake 3.20, there are 12 such properties managed with appropriate commands
    such as `target_link_options()` or directly with the `set_target_properties()`
    command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在CMake 3.20中，有12个这样的属性通过适当的命令（如`target_link_options()`）或直接通过`set_target_properties()`命令进行管理：
- en: '`AUTOUIC_OPTIONS`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AUTOUIC_OPTIONS`'
- en: '`COMPILE_DEFINITIONS`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMPILE_DEFINITIONS`'
- en: '`COMPILE_FEATURES`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMPILE_FEATURES`'
- en: '`COMPILE_OPTIONS`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMPILE_OPTIONS`'
- en: '`INCLUDE_DIRECTORIES`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INCLUDE_DIRECTORIES`'
- en: '`LINK_DEPENDS`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LINK_DEPENDS`'
- en: '`LINK_DIRECTORIES`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LINK_DIRECTORIES`'
- en: '`LINK_LIBRARIES`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LINK_LIBRARIES`'
- en: '`LINK_OPTIONS`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LINK_OPTIONS`'
- en: '`POSITION_INDEPENDENT_CODE`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POSITION_INDEPENDENT_CODE`'
- en: '`PRECOMPILE_HEADERS`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PRECOMPILE_HEADERS`'
- en: '`SOURCES`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOURCES`'
- en: 'We''ll discuss most of these options in the following pages, but remember that
    all of these options are, of course, described in the CMake manual. Find them
    on their own page under a URL in this format (replace `<PROPERTY>` with a property
    that interests you):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的页面中讨论这些选项的大部分，但请记住，所有这些选项当然都在CMake手册中有描述。在以下URL格式（将`<PROPERTY>`替换为你感兴趣的属性）的页面中找到它们：
- en: '`https://cmake.org/cmake/help/latest/prop_tgt/<PROPERTY>.html`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://cmake.org/cmake/help/latest/prop_tgt/<PROPERTY>.html`'
- en: The next question that comes to mind is how far this propagation goes. Are the
    properties set just on the first destination target, or are they sent to the very
    top of the dependency graph? Actually, you get to decide.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的问题是这种传播到底有多远。属性只设置在第一个目的地目标上，还是发送到依赖图的顶部？实际上，您可以决定。
- en: 'To create a dependency between targets, we use the `target_link_libraries()`
    command. The full signature of this command requires a propagation keyword:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建目标之间的依赖关系，我们使用`target_link_libraries()`命令。这个命令的完整签名需要一个传播关键词：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, this signature also specifies a propagation keyword, but this
    one controls where properties from the source target get stored in the destination
    target. *Figure 4.3* shows what happens to a propagated property during the generation
    stage (after the configuration stage is completed):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个签名也指定了传播关键词，但这个关键词控制着源目标中的属性在目的目标中的存储位置。*图4.3* 展示了在生成阶段（在配置阶段完成后）传播属性会发生什么：
- en: '![Figure 4.3 – How properties are propagated to destination targets'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.3 – 属性如何传播到目标目标'
- en: '](img/Figure_4.3_B17205.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.3_B17205.jpg)'
- en: Figure 4.3 – How properties are propagated to destination targets
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 属性如何传播到目标目标
- en: 'Propagation keywords work like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 传播关键词是这样工作的：
- en: '`PRIVATE` appends the source value to the *private* property of the destination.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PRIVATE`将源值附加到目的地的*私有*属性。'
- en: '`INTERFACE` appends the source value to the *interface* property of the destination.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INTERFACE`将源值追加到目的地的*接口*属性。'
- en: '`PUBLIC` appends to both properties of the destination.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUBLIC`追加到目的地的两个属性。'
- en: As we discussed before, interface properties are only used to propagate the
    properties further down the chain, and the destination target won't use them in
    its build process.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，接口属性只用于将属性传播到链的更低层，目的目标在构建过程中不会使用它们。
- en: The basic `target_link_libraries(<target> <item>...)` command that we used before
    implicitly specifies the `PUBLIC` keyword.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用的基本的`target_link_libraries(<target> <item>...)`命令隐式地指定了`PUBLIC`关键词。
- en: If you correctly set propagation keywords for your source targets, properties
    will be automatically placed on destination targets for you – unless there's a
    conflict…
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正确地为您的源目标设置了传播关键词，属性将自动放置在目的目标上——除非有冲突…
- en: Dealing with conflicting propagated properties
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理冲突的传播属性
- en: 'When one target depends on multiple other targets, there may be a situation
    where propagated properties are in outright conflict with each other. Say that
    one used target specifies the `POSITION_INDEPENDENT_CODE` property as `true` and
    the other as `false`. CMake understands this as a conflict and will print an error
    similar to this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个目标依赖于多个其他目标时，可能会出现传播属性彼此之间直接冲突的情况。比如说，一个使用目标将`POSITION_INDEPENDENT_CODE`属性设置为`true`，而另一个设置为`false`。CMake理解这是一个冲突，并将打印一个类似于这样的错误：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It is useful to receive such a message, as we explicitly know that we introduced
    this conflict and we need to resolve it. CMake has its own properties that have
    to "agree" between source and destination targets.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 收到这样的消息很有用，因为我们明确知道我们引入了这场冲突，我们需要解决它。CMake有自己的属性，这些属性必须在源目标和目标目标之间“一致”。
- en: On rare occasions, this may become important – for example, if you're building
    software using the same library in multiple targets that are then linked to a
    single executable. If these source targets are using different versions of the
    same library, you may run into problems.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在少数情况下，这可能变得很重要——例如，如果您在构建使用相同库的多个目标，然后将它们链接到一个单一的可执行文件。如果这些源目标使用不同版本的同一库，您可能会遇到问题。
- en: To make sure that we're only using the same specific version, we can create
    a custom interface property, `INTERFACE_LIB_VERSION`, and store the version there.
    This is not enough to solve the problem, as CMake won't propagate custom properties
    by default. We have to explicitly add a custom property to a list of "compatible"
    properties.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们只使用同一个具体版本，我们可以创建一个自定义接口属性`INTERFACE_LIB_VERSION`，并将版本存储在那里。这不足以解决问题，因为CMake默认不会传播自定义属性。我们必须明确地将自定义属性添加到“兼容”属性的列表中。
- en: 'Each target has four such lists:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 每个目标都有四个这样的列表：
- en: '`COMPATIBLE_INTERFACE_BOOL`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMPATIBLE_INTERFACE_BOOL`'
- en: '`COMPATIBLE_INTERFACE_STRING`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMPATIBLE_INTERFACE_STRING`'
- en: '`COMPATIBLE_INTERFACE_NUMBER_MAX`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMPATIBLE_INTERFACE_NUMBER_MAX`'
- en: '`COMPATIBLE_INTERFACE_NUMBER_MIN`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMPATIBLE_INTERFACE_NUMBER_MIN`'
- en: Appending your property to one of them will trigger propagation and compatibility
    checks. The `BOOL` list will check whether all properties propagated to the destination
    target evaluate to the same Boolean value. Analogically, `STRING` will evaluate
    to a string. `NUMBER_MAX` and `NUMBER_MIN` are a bit different – propagated values
    don't have to match, but the destination target will just receive the highest
    or the lowest value instead.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的属性添加到其中的一个，将触发传播和兼容性检查。`BOOL`列表将检查传播到目标目标的所有属性是否评估为相同的布尔值。类似地，`STRING`将评估为字符串。`NUMBER_MAX`和`NUMBER_MIN`有点不同——传播的值不必匹配，但目标目标将只是接收最高或最低的值。
- en: 'This example will help us to understand how to apply this in practice:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将帮助我们理解如何在实践中应用这一点：
- en: chapter04/02-propagated/CMakeLists.txt
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04/02-propagated/CMakeLists.txt
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We create three targets here; for simplicity, all are using the same empty source
    file. On both of the source targets, we specify our custom property with the `INTERFACE_`
    prefix. And we set them to the same matching library version. Both of the source
    targets are linked to the destination target. Finally, we specify a `STRING` compatibility
    requirement as a property for `source1` (we don't add the `INTERFACE_` prefix
    here).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们创建了三个目标；为了简单起见，所有这些都使用了同一个空源文件。在两个源目标上，我们用`INTERFACE_`前缀指定了我们的自定义属性。并将它们设置为相同的匹配库版本。两个源目标都被链接到目标目标。最后，我们为`source1`指定了一个`STRING`兼容性要求作为属性（这里我们没有添加`INTERFACE_`前缀）。
- en: CMake will propagate this custom property to the destination target and check
    whether the version of all the source targets is an exact match (the compatibility
    property can be set on just one target).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: CMake会将这个自定义属性传播到目标目标，并检查所有源目标的版本是否完全匹配（兼容性属性可以设置在一个目标上）。
- en: Now that we understand what targets are, let's take a look at other things that
    look like targets, smell like targets, and sometimes act like targets but, as
    it turns out, aren't the real deal.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了目标是什么，那么让我们来看看其他看起来像目标、闻起来像目标、有时表现得像目标的东西，但最终发现，它们并不是真正的目标。
- en: Meet the pseudo targets
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍伪目标
- en: The concept of a target is so useful that it would be great if some of its behaviors
    could be borrowed for other things too. This is, specifically, things that do
    not represent outputs of the buildsystem but rather inputs – external dependencies,
    aliases, and so on. These are the pseudo targets, or targets that don't make it
    to the generated buildsystem.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 目标的概念如此有用，以至于如果能够将其一些行为借鉴到其他事物上也很好。具体来说，这些事物不是构建系统的输出，而是输入——外部依赖项、别名等等。这些都是伪目标，或者没有包含在生成的构建系统中的目标。
- en: Imported targets
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入的目标
- en: If you skimmed the table of contents, you know that we'll be talking about how
    CMake manages external dependencies – other projects, libraries, and so on. `IMPORTED`
    targets are essentially products of this process. CMake can define them as a result
    of the `find_package()` command.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你浏览了目录，你知道我们将讨论CMake如何管理外部依赖项——其他项目、库等等。`IMPORTED`目标本质上就是这一过程的产物。CMake可以通过`find_package()`命令定义它们。
- en: 'You can adjust the target properties of such a target: *compile definitions*,
    *compile* *options*, *include directories*, and so on – and they will even support
    transitive usage requirements. However, you should treat them as immutable; don''t
    change their sources or dependencies.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以调整此类目标的目标属性：*编译定义*、*编译* *选项*、*包含目录*等——并且它们甚至支持传递性使用要求。然而，你应该将它们视为不可变的；不要更改它们的源代码或依赖关系。
- en: The scope of the definition of an `IMPORTED` target can be global or local to
    the directory where it was defined (visible in subdirectories but not in parent
    directories).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`IMPORTED`目标定义的范围可以是全局的或局部的（在定义它的目录中可见，但在父目录中不可见）。'
- en: Alias targets
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 别名目标
- en: 'Alias targets do exactly what you expect – they create another reference to
    a target under a different name. You can create alias targets for executables
    and libraries with the following commands:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 别名目标正好做了你应该期望的事情——它们以不同的名称创建了另一个目标引用。您可以使用以下命令为可执行文件和库创建别名目标：
- en: '[PRE13]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Properties of alias targets are read-only, and you cannot install or export
    aliases (they aren't visible in the generated buildsystem).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 别名目标的属性是只读的，并且你不能安装或导出别名（它们在生成的构建系统中不可见）。
- en: So, what is the reason to have aliases at all? They come in handy in scenarios
    where some part of a project (such as a subdirectory) requires a target with a
    specific name, and the actual implementation may be available under different
    names depending on circumstances. For example, you may wish to build a library
    shipped with your solution or import it based on a user's choice.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么要有别名呢？它们在某些场景中非常有用，比如一个项目的某个部分（如子目录）需要一个具有特定名称的目标，而实际实现可能根据情况不同而有不同的名称。例如，你可能希望构建一个随解决方案一起分发的库，或者根据用户的选择来导入它。
- en: Interface libraries
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接口库
- en: This is an interesting construct – a library that doesn't compile anything but
    instead serves as a utility target. Its whole concept is built around propagated
    properties (transitive usage requirements).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有趣的构造——一个不编译任何内容而是作为工具目标的库。它的整个概念都是围绕传播属性（传递使用要求）构建的。
- en: Interface libraries have two primary uses – to represent header-only libraries
    and to bundle a bunch of propagated properties into a single logical unit.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接口库有两个主要用途——代表仅头文件的库，以及将一堆传播属性捆绑到单个逻辑单元中。
- en: 'Header-only libraries are fairly easy to create with `add_library(INTERFACE)`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`add_library(INTERFACE)`可以相对容易地创建仅头文件库：
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding snippet, we created an Eigen interface library with three headers.
    Next, with generator expressions (explained in the last section of this chapter),
    we set its *include directories* to be `${CMAKE_CURRENT_SOURCE_DIR}/src` when
    a target is exported and `include/Eigen` when it's installed (which will also
    be explained at the end of this chapter).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们创建了一个包含三个头文件的 Eigen 接口库。接下来，使用生成表达式（在本章最后部分解释），我们将其*包含目录*设置为当目标导出时为`${CMAKE_CURRENT_SOURCE_DIR}/src`，安装时为`include/Eigen`（这将在本章最后解释）。
- en: 'To use such a library, we just have to link it:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这样的库，我们只需要链接它：
- en: '[PRE15]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: No actual linking occurs here, but CMake will understand this command as a request
    to propagate all the `INTERFACE` properties to the `executable` target.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里实际上并不发生链接，但 CMake 会理解这个命令为一个请求，将所有的`INTERFACE`属性传播到`executable`目标。
- en: 'The second use case leverages exactly the same mechanism but for a different
    purpose – it creates a logical target that can be a placeholder for propagated
    properties. We can then use this target as a dependency for other targets and
    set properties in a clean, convenient way. Here''s an example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个用例正好利用了相同的机制，但目的不同——它创建了一个逻辑目标，可以作为传播属性的占位符。我们随后可以用这个目标作为其他目标依赖，并以一种清晰、方便的方式设置属性。这是一个例子：
- en: '[PRE16]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `add_library(INTERFACE)` command creates a logical `warning_props` target
    that is used to set *compile options* specified in the second command on the `executable`
    target. I recommend using these `INTERFACE` targets, as they improve the readability
    and reusability of your code. Think of it as refactoring a bunch of magic values
    to a well-named variable. I also suggest using the `_props` suffix to easily differentiate
    interface libraries from the regular ones.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_library(INTERFACE)`命令创建了一个逻辑`warning_props`目标，用于在第二个命令中设置*编译选项*在`executable`目标上。我建议使用这些`INTERFACE`目标，因为它们可以提高代码的可读性和可重用性。把它看作是将一串魔法值重构为命名良好的变量。我还建议使用`_props`后缀以便于区分接口库和常规库。'
- en: Are pseudo targets exhausting the concept of the target? Of course not! That
    would simply be too easy. We still need to understand how these targets translate
    to produced buildsystems.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 伪目标是否穷尽了目标的概念？当然不是！那将会太简单了。我们还需要理解这些目标如何翻译成生成的构建系统。
- en: Build targets
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建目标
- en: Target is a bit of a loaded word. It means different things in the context of
    a project and the context of generated buildsystems. When CMake generates a buildsystem,
    it "compiles" list files from CMake language to the language of a chosen build
    tool; perhaps it creates a Makefile for GNU Make. Such Makefiles have their own
    targets – some of them are direct conversions of list file targets, and others
    are created implicitly.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 目标这个词有点含义丰富。在项目上下文和生成的构建系统上下文中，它的意思不同。当 CMake 生成一个构建系统时，它将CMake语言的列表文件“编译”成所选构建工具的语言；也许它为
    GNU Make 创建了一个 Makefile。这样的 Makefile 有自己的目标——其中一些是列表文件目标的直接转换，其他的是隐式创建的。
- en: One such buildsystem target is `ALL`, which CMake generates by default to contain
    all top-level list file targets, such as executables and libraries (not necessarily
    custom targets). `ALL` is built when we run `cmake --build <build tree>` without
    choosing a concrete target. As you might remember from the first chapter, you
    can choose one by adding the `--target <name>` parameter to the preceding command.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个构建系统目标是`ALL`，CMake默认生成的包含所有顶层列表文件目标的构建系统，如可执行文件和库（不一定是自定义目标）。当我们运行`cmake
    --build <build tree>`命令而没有选择一个具体的目标时，会构建`ALL`。正如您可能还记得第一章的内容，您可以通过向 preceding
    command添加`--target <name>`参数来选择一个。
- en: 'Some executables or libraries might not be needed in every build, but we''d
    like to keep them as part of the project for those rare occasions when they come
    in useful. To optimize our default build, we can exclude them from the `ALL` target
    like so:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 有些可执行文件或库可能不是每个构建都需要，但我们希望将它们作为项目的一部分，以便在那些罕见的情况下它们有用。为了优化我们的默认构建，我们可以像这样将它们从`ALL`目标中排除：
- en: '[PRE17]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Custom targets work the other way around – by default, they're excluded from
    the `ALL` target unless you explicitly define them with an `ALL` keyword, as we
    did in the BankApp example.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义目标的工作方式与默认方式相反——默认情况下，它们被排除在`ALL`目标之外，除非你明确用`ALL`关键字定义它们，就像我们在BankApp示例中做的那样。
- en: Another implicitly defined build target is `clean`, which simply removes produced
    artifacts from the build tree. We use it to get rid of all old files and build
    everything from scratch. It's important though to understand that it don't just
    simply delete everything in the build directory. This means that for `clean` to
    work correctly, you need to manually specify any files that your custom targets
    might create as `BYPRODUCTS` (see the BankApp example).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个隐式定义的构建目标是`clean`，它简单地从构建树中删除生成的工件。我们用它来清除所有旧文件，从头开始构建一切。不过，重要的是要理解它并不是简单地删除构建目录中的所有内容。这意味着，为了让`clean`正确工作，你需要手动指定任何自定义目标可能创建的文件作为`BYPRODUCTS`（参见BankApp示例）。
- en: There's also an interesting non-target mechanism to create custom artifacts
    that can be used in all *actual targets* – custom commands.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种有趣的自定义非目标机制可以创建可以在所有*实际目标*中使用的自定义工件——自定义命令。
- en: Writing custom commands
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自定义命令
- en: 'Using custom targets has one drawback – as soon as you add them to the `ALL`
    target or start depending on them for other targets, they will be built every
    single time (you may still enable them in an `if` block to limit that). Sometimes,
    this is what you want, but there are cases when custom behavior is necessary to
    produce files that shouldn''t be recreated without reason:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义目标有一个缺点——一旦你把它们添加到`ALL`目标中，或者开始让它们为其他目标提供依赖，它们将会在每次构建时都被构建（你仍然可以在`if`块中启用它们以限制这种情况）。有时，这正是你所需要的，但在某些情况下，需要自定义行为来生成不应该在没有理由的情况下重新创建的文件：
- en: Generating a source code file that another target depends on
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成另一个目标依赖的源代码文件
- en: Translating another language into C++
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将另一种语言翻译成C++
- en: Executing a custom action immediately before or after another target was built
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在另一个目标构建之前或之后立即执行自定义操作
- en: 'There are two signatures for a custom command. The first one is an extended
    version of `add_custom_target()`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义命令有两个签名。第一个是`add_custom_target()`的扩展版本：
- en: '[PRE18]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you might have guessed, a custom command doesn't create a logical target,
    but just like custom targets, it has to be added to a dependency graph. There
    are two ways of doing that – using its output artifact as a source for an executable
    (or library), or explicitly adding it to a `DEPENDS` list for a custom target.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能猜到的那样，自定义命令不会创建一个逻辑目标，但与自定义目标一样，它也必须添加到依赖图中。这样做有两种方式——使用其输出工件作为可执行文件（或库）的源，或者明确将其添加到自定义目标的一个`DEPENDS`列表中。
- en: Using a custom command as a generator
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将自定义命令作为生成器使用
- en: 'Admittedly, not every project needs to generate C++ code from other files.
    One such occasion might be a compilation of `.proto` files. If you''re not familiar
    with this library, protobuf is a platform-neutral binary serializer for structured
    data. To keep it cross-platform and fast at the same time, Google''s engineers
    invented their own protobuf format that defines models in `.proto` files, such
    as this one:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，不是每个项目都需要从其他文件生成C++代码。一个这样的场合可能是`.proto`文件的编译。如果你不熟悉这个库，protobuf是一个适用于结构化数据的平台中立二进制序列化器。为了同时保持跨平台和快速，谷歌的工程师们发明了他们自己的protobuf格式，该格式在`.proto`文件中定义模型，例如这个：
- en: '[PRE19]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Such a file can be then shared across multiple languages – C++, Ruby, Go, Python,
    Java, and so on. Google provides compilers that read `.proto` files and output
    structure and serialization code valid for the chosen language. Smart engineers
    don't check those compiled files into a repository but will use the original protobuf
    format and add it to the build chain.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的文件可以跨多种语言共享——C++、Ruby、Go、Python、Java等等。Google提供了编译器，用于读取`.proto`文件并输出适用于所选语言的结构和序列化代码。明智的工程师不会将编译后的文件提交到仓库，而是会使用原始的protobuf格式，并将其添加到构建链中。
- en: 'We don''t know yet how to detect whether (and where) a protobuf compiler is
    available on the target host (we''ll learn that in [*Chapter 7*](B17205_07_Final_JC_ePub.xhtml#_idTextAnchor162),
    *Managing Dependencies with CMake*). So, for now, let''s just assume that the
    compiler''s `protoc` command is residing in a location known to the system. We
    have prepared a `person.proto` file and we know that the protobuf compiler will
    output `person.pb.h` and `person.pb.cc` files. Here''s how we would define a custom
    command to compile them:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚不知道如何检测目标主机上是否可用的protobuf编译器（我们将在[第7章](B17205_07_Final_JC_ePub.xhtml#_idTextAnchor162)中学习，*使用CMake管理依赖*）。所以，现在，让我们假设编译器的`protoc`命令位于系统知道的某个位置。我们已经准备了一个`person.proto`文件，并且知道protobuf编译器将输出`person.pb.h`和`person.pb.cc`文件。下面是我们定义一个自定义命令来编译它们的示例：
- en: '[PRE20]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, to allow serialization in our executable, we can just add output files
    to the sources:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了允许我们的可执行文件进行序列化，我们只需将输出文件添加到源文件中：
- en: '[PRE21]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Assuming we dealt correctly with the inclusion of header files and linking the
    protobuf library, everything will compile and update automatically when we introduce
    changes to the `.proto` file.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正确处理了头文件的包含和protobuf库的链接，当我们对`.proto`文件进行更改时，一切都会自动编译和更新。
- en: 'A simplified (and much less practical) example would be to create the necessary
    header by copying it from another location:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简化（且实用性远小于）的例子可能是通过从另一个位置复制来创建所需的头文件：
- en: chapter04/03-command/CMakeLists.txt
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04/03-command/CMakeLists.txt
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Our "compiler", in this case, is the `cp` command. It fulfills a dependency
    of the `main` target by creating a `constants.h` file in the build tree root,
    simply by copying it from the source tree.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的“编译器”是`cp`命令。它通过从源树复制到构建树根目录创建一个`constants.h`文件，从而满足`main`目标的依赖关系。
- en: Using a custom command as a target hook
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义命令作为目标钩子
- en: 'The second version of the `add_custom_command()` command introduces a mechanism
    to execute commands before or after building a target:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_custom_command()`命令的第二版引入了一种在构建目标之前或之后执行命令的机制：'
- en: '[PRE23]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We specify what target we''d like to "enhance" with new behavior in the first
    argument and under the following conditions:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在第一个参数中指定我们希望用新行为“增强”的目标，并在以下条件下进行：
- en: '`PRE_BUILD` will run before any other rules for this target (Visual Studio
    generators only; for others, it behaves like `PRE_LINK`).'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PRE_BUILD`会在执行此目标的其他规则之前运行（仅限Visual Studio生成器；对于其他生成器，它表现得像`PRE_LINK`）。'
- en: '`PRE_LINK` binds the command to be run just after all sources have been compiled
    but before the linking (or archiving) the target. It doesn''t work for custom
    targets.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PRE_LINK`在所有源文件编译完成后，但在链接（或归档）目标之前运行命令。它不适用于自定义目标。'
- en: '`POST_BUILD` will run after all other rules have been executed for this target.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST_BUILD`将在执行完此目标的的所有其他规则后运行。'
- en: 'Using this version of `add_custom_command()`, we can replicate the generation
    of the checksum from the previous BankApp example:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个版本的`add_custom_command()`，我们可以复制之前BankApp示例中的校验和生成：
- en: chapter04/04-command/CMakeLists.txt
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04/04-command/CMakeLists.txt
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After the build of the `main` executable completes, CMake will execute `cksum`
    with provided arguments. But what is happening in the first argument? It's not
    a variable, as it would be wrapped in curly braces (`${}`), not in angle brackets
    (`$<>`). It's a generator expression evaluating a full path to the target's binary
    file. This mechanism is useful in the context of many target properties.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`可执行文件的构建完成后，CMake将执行`cksum`命令，并提供参数。但第一个参数中发生了什么？它不是一个变量，因为它会被大括号（`${}`）包围，而不是尖括号（`$<>`）。它是一个生成表达式，评估目标二进制文件的完整路径。这种机制在许多目标属性上下文中很有用。
- en: Understanding generator expressions
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解生成表达式
- en: CMake builds the solution in three stages – configuration, generation, and running
    the build tool. Generally, we have all the required data during the configuration
    stage. But every once in a while, we encounter the chicken and the egg problem.
    Take an example from the previous section – a target needs to know the path of
    a binary artifact of another target. But that information is only available after
    all the list files are parsed and the configuration stage is complete.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: CMake解决方案的构建分为三个阶段——配置、生成和运行构建工具。通常，我们在配置阶段拥有所有必需的数据。但是偶尔，我们会遇到鸡和蛋的问题。拿前面小节的一个例子来说——一个目标需要知道另一个目标的可执行文件路径。但是这些信息在所有列表文件被解析和配置阶段完成后才可用。
- en: How do we deal with that kind of problem? We could create a placeholder for
    that information and postpone its evaluation to the next stage – the generation
    stage.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何处理这类问题呢？我们可以为这些信息创建一个占位符，并将其评估推迟到下一阶段——生成阶段。
- en: This is what generator expressions (sometimes called genexes) do. They are built
    around target properties such as `LINK_LIBRARIES`, `INCLUDE_DIRECTORIES`, `COMPILE_DEFINITIONS`,
    propagated properties, and many others, but not all. They follow rules similar
    to conditional statements and variable evaluation.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是生成器表达式（有时被称为genexes）所做的。它们围绕目标属性（如`LINK_LIBRARIES`、`INCLUDE_DIRECTORIES`、`COMPILE_DEFINITIONS`）构建，传播属性和许多其他内容，但并非全部。它们遵循与条件语句和变量评估类似的规则。
- en: It's worth noting that expressions are generally evaluated in the context of
    the target using the expression (unless explicitly stated otherwise).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，表达式通常是在使用表达式的目标上下文中评估的（除非有明确的说明否则）。
- en: Important Note
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Generator expressions will be evaluated at the generation stage (when the configuration
    is complete and the buildsystem is created), which means that you can''t capture
    their output into a variable and print it to the console very easily. To debug
    them, you can use either of these methods:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式将在生成阶段评估（当配置完成且构建系统被创建时），这意味着你无法很容易地将它们的输出捕获到一个变量中并打印到控制台。要调试它们，你可以使用以下任一方法：
- en: '• Write it to a file (this specific version of the `file()` command supports
    generator expressions): `file(GENERATE OUTPUT filename CONTENT "$<...>")`'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: • 将其写入文件（这个特定的`file()`命令支持生成器表达式）：`file(GENERATE OUTPUT filename CONTENT "$<...>")`
- en: '• Add a custom target and build it explicitly from the command line: `add_custom_target(gendbg
    COMMAND ${CMAKE_COMMAND} -E echo "$<...>")`'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: • 从命令行显式添加一个自定义目标并构建它：`add_custom_target(gendbg COMMAND ${CMAKE_COMMAND} -E
    echo "$<...>")`
- en: General syntax
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一般语法
- en: 'Let''s take the simplest possible example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们拿最简单的例子来说：
- en: '[PRE25]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding command adds a `-D` definition flag to the compiler's arguments
    (ignore `PUBLIC` for now) that sets the `BAR` preprocessor definition to the **path
    of the binary artifact of the foo target**.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令向编译器参数添加了一个`-D`定义标志（现在忽略`PUBLIC`）来设置`BAR`预处理器定义为**foo目标的可执行文件路径**。
- en: How is the generator expression formed?
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式是如何形成的？
- en: '![Figure 4.4 – The syntax of a generator expression'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4 – 生成器表达式的语法'
- en: '](img/Figure_4.4_B17205.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.4_B17205.jpg)'
- en: Figure 4.4 – The syntax of a generator expression
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – 生成器表达式的语法
- en: 'As you can see in *Figure 4.4*, the structure seems fairly simple and readable:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在*图4.4*中看到的，结构似乎相当简单和易读：
- en: Open with a dollar and a bracket (`$<`).
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用美元符号和方括号（`$<`）打开。
- en: Add the `EXPRESSION` name.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加`EXPRESSION`名称。
- en: If an expression requires arguments, add a colon (`:`) and provide the `arg1`,
    `arg2`, and `arg3` values, separated with a comma (`,`).
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个表达式需要参数，请添加冒号（`:`）并提供`arg1`、`arg2`和`arg3`的值，用逗号（`,`）分隔。
- en: Close the expression with `>`.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用`>`关闭表达式。
- en: There are even expressions that do not require any arguments, such as `$<PLATFORM_ID>`.
    However, generator expressions can quickly become very confusing and complicated
    when using their more advanced features.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些不需要任何参数的表达式，例如`$<PLATFORM_ID>`。然而，当使用它们的更高级功能时，生成器表达式可能会迅速变得非常令人困惑和复杂。
- en: Nesting
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌套
- en: 'Let''s start with the ability to pass a general expression as an argument to
    another expression or, in other words, general expression nesting:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从能够将一般表达式作为另一个表达式的参数开始，或者换句话说，一般表达式的嵌套：
- en: '[PRE26]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This isn't a very complex example, but it's easy to imagine what happens when
    we increase nesting levels and work with commands using multiple arguments.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子并不复杂，但很容易想象当我们增加嵌套级别并使用多个参数的命令时会发生什么。
- en: 'As if that''s not enough, you can technically add a variable expansion to this
    mix:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 更甚者，你技术上可以在这个混合中添加一个变量展开：
- en: '[PRE27]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: A variable will be expanded at the configuration stage and a generation expression
    at the generation stage. There are some rare uses for this feature, but I strongly
    recommend avoiding it.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 变量将在配置阶段展开，生成表达式在生成阶段展开。这个特性有些少见的使用场景，但我强烈建议避免使用。
- en: Conditional expressions
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件表达式
- en: 'Boolean logic is supported in generator expressions. It''s a great feature,
    but for legacy reasons, its syntax is inconsistent and can be hard to read. It''s
    available in two forms. The first form supports both happy and sad paths:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 生成表达式中支持布尔逻辑。这是一个很好的特性，但由于历史原因，其语法不一致且可能很难阅读。它有两种形式。第一种形式支持快乐路径和悲伤路径：
- en: '[PRE28]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The syntax here is aligned with all other expressions and, like all expressions,
    nesting is allowed. So, you can replace any of the arguments with another expression
    and produce some very complex evaluations – you can even nest one condition in
    another. This form requires exactly three arguments, so we can''t omit anything.
    Our best option to skip a value in case of an unmet condition is the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的语法与其他所有表达式对齐，像所有表达式一样，嵌套是允许的。所以，你可以用另一个表达式替换任何一个参数，产生一些非常复杂的评估——你甚至可以将一个条件嵌套在另一个条件中。这种形式需要恰好三个参数，所以我们不能省略任何东西。在条件未满足的情况下跳过值的最好方法是：
- en: '[PRE29]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The second form is a shorthand for the preceding; it will only expand to a
    string if the condition is met:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种形式是对前一种的简写；只有当条件满足时，它才会展开成一个字符串：
- en: '[PRE30]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As you can see, it breaks the convention of providing the `EXPRESSION` name
    as the first token. I assume that the intention here was to shorten the expression
    and skip those precious three characters, but the outcome can be really hard to
    rationalize. Here''s one example from the CMake documentation:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，它打破了将 `EXPRESSION` 名称作为第一个标记提供的一致性约定。我假设这里的意图是为了缩短表达式，省去那宝贵的三个字符，但结果可能真的很难找到合理的理由。以下是从
    CMake 文档中举的一个例子：
- en: '[PRE31]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: I wish the syntax was aligned with conditions for the regular `IF` command,
    but sadly that's not the case.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望语法能与常规 `IF` 命令的条件对齐，但遗憾的是并非如此。
- en: Types of evaluation
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估类型
- en: Generator expressions are evaluated to one of two types – Boolean or string.
    Boolean is represented by `1` (true) and `0` (false). Everything else is just
    a string.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 生成表达式评估为两种类型之一——布尔值或字符串。布尔值用 `1`（真）和 `0`（假）表示。其他所有都是字符串。
- en: It's important to remember that nested expressions passed as conditions in conditional
    expressions are explicitly required to evaluate to Boolean.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，嵌套表达式作为条件在条件表达式中是明确要求评估为布尔值的。
- en: There's an explicit logical operator to convert strings to Boolean, but Boolean
    types can be converted to strings implicitly.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个显式的逻辑运算符将字符串转换为布尔值，但布尔类型可以隐式地转换为字符串。
- en: Now that we know the basic syntax, let's take a look at what we can do with
    it.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了基本语法，那么让我们来看看我们能用它做些什么。
- en: Evaluation to Boolean
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 评估为布尔值
- en: We started discussing conditional expressions in the previous section. I want
    to get the whole concept covered right off the bat so that there's no need to
    return to it later. There are three categories of expressions that get evaluated
    to Boolean.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节开始讨论条件表达式。我想一开始就彻底覆盖这个概念，这样就不用以后再回来了。有三种表达式评估为布尔值。
- en: Logical operators
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: 'There are four logical operators:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个逻辑运算符：
- en: '`$<NOT:arg>` negates the Boolean argument.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<NOT:arg>` 否定布尔参数。'
- en: '`$<AND:arg1,arg2,arg3...>` returns `1` if all the arguments are `1`.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<AND:arg1,arg2,arg3...>` 如果所有参数都是 `1`，则返回 `1`。'
- en: '`$<OR:arg1,arg2,arg3...>` returns `1` if any of the arguments is `1`.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<OR:arg1,arg2,arg3...>` 如果任意一个参数是 `1`，则返回 `1`。'
- en: '`$<BOOL:string_arg>` converts arguments from a string to a Boolean type.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<BOOL:string_arg>` 将字符串参数转换为布尔类型。'
- en: 'String conversion will evaluate to `1` if none of these conditions are met:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串转换将评估为 `1`，如果这些条件没有满足：
- en: The string is empty.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串为空。
- en: The string is a case-insensitive equivalent of `0`, `FALSE`, `OFF`, `N`, `NO`,
    `IGNORE`, or `NOTFOUND`.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串是 `0`、`FALSE`、`OFF`、`N`、`NO`、`IGNORE` 或 `NOTFOUND` 的不区分大小写等价物。
- en: The string ends in the `-NOTFOUND` suffix (case-sensitive).
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串以 `-NOTFOUND` 后缀结尾（区分大小写）。
- en: String comparison
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串比较
- en: 'Comparisons will evaluate to `1` if their condition is met and `0` otherwise:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 比较如果满足其条件则评估为 `1`，否则为 `0`：
- en: '`$<STREQUAL:arg1,arg2>` is a case-sensitive string comparison.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<STREQUAL:arg1,arg2>` 是一个区分大小写的字符串比较。'
- en: '`$<EQUAL:arg1,arg2>` converts a string to a number and compares equality.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<EQUAL:arg1,arg2>`将字符串转换为数字并比较相等性。'
- en: '`$<IN_LIST:arg,list>` checks whether the `arg` element is in the `list` list
    (case-sensitive).'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<IN_LIST:arg,list>`检查`arg`元素是否在`list`列表中（区分大小写）。'
- en: '`$<VERSION_EQUAL:v1,v2>`, `$<VERSION_LESS:v1,v2>`, `$<VERSION_GREATER:v1,v2>`,
    `$<VERSION_LESS_EQUAL:v1,v2>`, and `$<VERSION_GREATER_EQUAL:v1,v2>` are component-wise
    version comparisons.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<VERSION_EQUAL:v1,v2>`、`$<VERSION_LESS:v1,v2>`、`$<VERSION_GREATER:v1,v2>`、`$<VERSION_LESS_EQUAL:v1,v2>`和`$<VERSION_GREATER_EQUAL:v1,v2>`是逐组件的版本比较。'
- en: Variable queries
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 变量查询
- en: There are plenty of variables that contain Boolean-typed values. They also will
    evaluate to `1` if their condition is met and `0` otherwise.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多包含布尔值变量。如果它们满足条件，它们也将评估为`1`，否则为`0`。
- en: 'There is one simple query:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个简单的查询：
- en: '`$<TARGET_EXISTS:arg>` – does the `arg` target exist?'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_EXISTS:arg>` - `arg`目标存在吗？'
- en: 'There are multiple queries scanning passed arguments for a specific value:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个查询扫描传递的参数以查找特定值：
- en: '`$<CONFIG:args>` is the current config (`Debug`, `Release`, and so on) in `args`
    (case-insensitive).'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<CONFIG:args>`是`args`中的当前配置（`Debug`、`Release`等）（不区分大小写）。'
- en: '`$<PLATFORM_ID:args>` is the current platform ID in `args`.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<PLATFORM_ID:args>`是`args`中的当前平台ID。'
- en: '`$<LANG_COMPILER_ID:args>` is CMake''s `LANG` compiler ID in `args`, where
    `LANG` is one of `C`, `CXX`, `CUDA`, `OBJC`, `OBJCXX`, `Fortran`, or `ISPC`.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<LANG_COMPILER_ID:args>`是`args`中的CMake`LANG`编译器ID，其中`LANG`是`C`、`CXX`、`CUDA`、`OBJC`、`OBJCXX`、`Fortran`或`ISPC`之一。'
- en: '`$<LANG_COMPILER_VERSION:args>` is the CMake''s `LANG` compiler version in
    `args`, where `LANG` is one of `C`, `CXX`, `CUDA`, `OBJC`, `OBJCXX`, `Fortran`,
    or `ISPC`.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<LANG_COMPILER_VERSION:args>`是`args`中的CMake`LANG`编译器版本，其中`LANG`是`C`、`CXX`、`CUDA`、`OBJC`、`OBJCXX`、`Fortran`或`ISPC`之一。'
- en: '`$<COMPILE_FEATURES:features>` will return `true` if `features` is supported
    by the compiler for this target.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<COMPILE_FEATURES:features>`如果`features`被编译器支持，将返回`true`。'
- en: '`$<COMPILE_LANG_AND_ID:lang,compiler_id1,compiler_id2...>` is the language
    of this `lang` target and is the compiler used for this target present in the
    `compiler_ids` list. This expression is useful to specify details of a configuration
    for specific compilers:'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<COMPILE_LANG_AND_ID:lang,compiler_id1,compiler_id2...>`是这个`lang`目标的`lang`和在这个目标中使用的编译器是否存在于`compiler_ids`列表中。这个表达式用于指定特定编译器的配置细节：'
- en: '[PRE32]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding example, if we compile the `CXX` compiler with `AppleClang`
    or `Clang`, the `-DCXX_CLANG` definition will be set. For the `CXX` compiler from
    Intel, the `-DCXX_INTEL` definition flag will be set. Lastly, for the `C` and
    `Clang` compiler, we'll get a `-DC_CLANG` definition.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中，如果我们用`AppleClang`或`Clang`编译`CXX`编译器，将设置`-DCXX_CLANG`定义。对于来自Intel的`CXX`编译器，将设置`-DCXX_INTEL`定义标志。最后，对于`C`和`Clang`编译器，我们将得到一个`-DC_CLANG`定义。
- en: '`$<COMPILE_LANGUAGE:args>` if a language is used for the compilation of this
    target in `args`. This can be used to provide language-specific flags to the compiler:'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<COMPILE_LANGUAGE:args>`如果在这个目标中使用`args`编译指定语言。这可以用来为编译器提供语言特定的标志：'
- en: '[PRE33]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If we compile `CXX`, the compiler will use the `-fno-exceptions` flag.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编译`CXX`，编译器将使用`-fno-exceptions`标志。
- en: '`$<LINK_LANG_AND_ID:lang,compiler_id1,compiler_id2...>` works similarly to
    `COMPILE_LANG_AND_ID` but checks the language used for the link step instead.
    Use this expression to specify link libraries, link options, link directories,
    and link dependencies of a particular language and a linker combination in a target.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<LINK_LANG_AND_ID:lang,compiler_id1,compiler_id2...>`与`COMPILE_LANG_AND_ID`类似，但检查链接步骤使用的语言。使用此表达式指定特定语言和链接器组合的目标的链接库、链接选项、链接目录和链接依赖项。'
- en: '`$<LINK_LANGUAGE:args>` is the language used for the link step in `args`.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<LINK_LANGUAGE:args>`是`args`中链接步骤使用的语言。'
- en: Evaluation to a string
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 评估为字符串
- en: There are plenty of expressions that get evaluated to a string. We can output
    them directly to the placeholder of the target or consume as an argument to another
    expression. We already learned about one – conditional expression evaluates to
    a string. What else is available?
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多表达式被评估为字符串。我们可以直接将它们输出到目标的占位符中，或者作为另一个表达式的参数。我们已经学习了其中一个 - 条件表达式评估为字符串。还有哪些可用？
- en: Variable queries
  id: totrans-286
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 变量查询
- en: 'These expressions will evaluate to a specific value at the generation stage:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这些表达式在生成阶段将评估为一个特定的值：
- en: '`$<CONFIG>` – the configuration (`Debug` and `Release`) name.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<CONFIG>` - 配置（`Debug`和`Release`）名称。'
- en: '`$<PLATFORM_ID>` – the current system''s CMake platform ID (`Linux`, `Windows`,
    or `Darwin`). We discussed platform in the previous chapter, in the *Scoping the
    environment* section.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<PLATFORM_ID>` – 当前系统的CMake平台ID（`Linux`、`Windows`或`Darwin`）。我们在上一章的*环境范围*部分讨论了平台。'
- en: '`$<LANG_COMPILER_ID>` – CMake''s compiler ID of the `LANG` compiler used, where
    `LANG` is one of `C`, `CXX`, `CUDA`, `OBJC`, `OBJCXX`, `Fortran`, or `ISPC`.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<LANG_COMPILER_ID>` – 这是用于`LANG`编译器的CMake编译器ID，其中`LANG`是`C`、`CXX`、`CUDA`、`OBJC`、`OBJCXX`、`Fortran`或`ISPC`中的一个。'
- en: '`$<LANG_COMPILER_VERSION>` – CMake''s compiler version of the `LANG` compiler
    used, where `LANG` is one of `C`, `CXX`, `CUDA`, `OBJC`, `OBJCXX`, `Fortran`,
    or `ISPC`.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<LANG_COMPILER_VERSION>` – 这是用于`LANG`编译器的CMake编译器版本，其中`LANG`是`C`、`CXX`、`CUDA`、`OBJC`、`OBJCXX`、`Fortran`或`ISPC`中的一个。'
- en: '`$<COMPILE_LANGUAGE>` – the compiled language of source files when evaluating
    *compile options*.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`'
- en: '`$<LINK_LANGUAGE>` – the link language of a target when evaluating link options.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<LINK_LANGUAGE>` – 在评估链接选项时，目标的语言。'
- en: Target-dependent queries
  id: totrans-294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 目标依赖查询
- en: 'With the following queries, you can evaluate properties of an executable or
    library target. Note that since CMake 3.19, for most expressions querying a target
    in the context of another target no longer creates an automated dependency between
    these targets (as was happening before 3.19):'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下查询，您可以评估可执行文件或库目标属性。请注意，自CMake 3.19以来，对于在另一个目标上下文中查询大多数目标表达式，不再创建这些目标之间的自动依赖关系（如3.19之前所发生的那样）：
- en: '`$<TARGET_NAME_IF_EXISTS:target>` – the target name of `target` if it exists;
    it is an empty string otherwise.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_NAME_IF_EXISTS:target>` – 如果存在，则是`target`的目标名称；否则为空字符串。'
- en: '`$<TARGET_FILE:target>` – the full path to the `target` binary file.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_FILE:target>` – `target`二进制文件的完整路径。'
- en: '`$<TARGET_FILE_NAME:target>` – the `target` filename.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_FILE_NAME:target>` – `target`文件名。'
- en: '`$<TARGET_FILE_BASE_NAME:target>` – the base name of `target`, or `$<TARGET_FILE_NAME:target>`
    without a prefix and suffix. For `libmylib.so`, the base name would be `mylib`.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_FILE_BASE_NAME:target>` – `target`的基础文件名，或者没有前缀和后缀的`$<TARGET_FILE_NAME:target>`。对于`libmylib.so`，基础名将是`mylib`。'
- en: '`$<TARGET_FILE_PREFIX:target>` – the prefix of the `target` filename (`lib`).'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_FILE_PREFIX:target>` – `target`文件名的前缀（`lib`）。'
- en: '`$<TARGET_FILE_SUFFIX:target>` – the suffix (or extension) of the `target`
    filename (`.so`, `.exe`).'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_FILE_SUFFIX:target>` – `target`文件名的后缀（或扩展名）（`.so`、`.exe`）。'
- en: '`$<TARGET_FILE_DIR:target>` – the directory of the `target` binary file.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_FILE_DIR:target>` – `target`二进制文件的目录。'
- en: '`$<TARGET_LINKER_FILE:target>` – the file used when linking to the `target`
    target. Usually, it is the library that `target` represents (`.a`, `.lib`, `.so`)
    on platforms with `.lib` import library.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_LINKER_FILE:target>` – 链接到`target`目标时使用的文件。通常，它是`target`表示的库（在具有`.lib`导入库的平台上的`.a`、`.lib`、`.so`）。'
- en: '`TARGET_LINKER_FILE` offers the same family of expressions as the regular `TARGET_FILE`
    expression:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`TARGET_LINKER_FILE`提供了与常规`TARGET_FILE`表达式相同的系列表达式：'
- en: '`$<TARGET_LINKER_FILE_NAME:target>`, `$<TARGET_LINKER_FILE_BASE_NAME:target>`,
    `$<TARGET_LINKER_FILE_PREFIX:target>`, `$<TARGET_LINKER_FILE_SUFFIX:target>`,
    `$<TARGET_LINKER_FILE_DIR:target>`'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`$<TARGET_LINKER_FILE_NAME:target>`、`$<TARGET_LINKER_FILE_BASE_NAME:target>`、`$<TARGET_LINKER_FILE_PREFIX:target>`、`$<TARGET_LINKER_FILE_SUFFIX:target>`、`$<TARGET_LINKER_FILE_DIR:target>`'
- en: '`$<TARGET_SONAME_FILE:target>` – the full path to a file with a soname (`.so.3`).'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_SONAME_FILE:target>` – 具有soname的文件的完整路径（`.so.3`）。'
- en: '`$<TARGET_SONAME_FILE_NAME:target>` – the name of a file with a soname.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_SONAME_FILE_NAME:target>` – 具有soname的文件名称。'
- en: '`$<TARGET_SONAME_FILE_DIR:target>` – the directory of a file with a soname.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_SONAME_FILE_DIR:target>` – 具有soname的文件的目录。'
- en: '`$<TARGET_PDB_FILE:target>` – the full path to the linker generated program
    database file (`.pdb`) for `target`.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_PDB_FILE:target>` – 链接器生成的程序数据库文件（`.pdb`）的完整路径，用于`target`。'
- en: 'PDB files offer the same expressions as a regular `TARGET_FILE`: `$<TARGET_PDB_FILE_BASE_NAME:target>`,
    `$<TARGET_PDB_FILE_NAME:target>`, `$<TARGET_PDB_FILE_DIR:target>.`'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: PDB文件提供了与常规`TARGET_FILE`相同的表达式：`$<TARGET_PDB_FILE_BASE_NAME:target>`、`$<TARGET_PDB_FILE_NAME:target>`、`$<TARGET_PDB_FILE_DIR:target>`。
- en: '`$<TARGET_BUNDLE_DIR:target>` – the full path to the bundle (Apple–specific
    package) directory (`my.app`, `my.framework`, or `my.bundle`) for `target`.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_BUNDLE_DIR:target>` – 目标（target）的全路径到捆绑包（Apple特定的包）目录（`my.app`、`my.framework`或`my.bundle`）。'
- en: '`$<TARGET_BUNDLE_CONTENT_DIR:target>` – the full path to the bundle content
    directory for `target`. On macOS, it''s `my.app/Contents`, `my.framework`, or
    `my.bundle/Contents`. Other `my.app`, `my.framework`, or `my.bundle`.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_BUNDLE_CONTENT_DIR:target>` – `target`的全路径的捆绑内容目录。在macOS上，它是`my.app/Contents`，`my.framework`或`my.bundle/Contents`。其他的`my.app`，`my.framework`或`my.bundle`。'
- en: '`$<TARGET_PROPERTY:target,prop>` – the `prop` value for `target`.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_PROPERTY:target,prop>` – `target`的`prop`值。'
- en: '`$<TARGET_PROPERTY:prop>` – the `prop` value for `target` for which the expression
    is being evaluated.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_PROPERTY:prop>` – 正在评估的表达式的`target`的`prop`值。'
- en: '`$<INSTALL_PREFIX>` – the install prefix when the target is exported with `install(EXPORT)`
    or when evaluated in `INSTALL_NAME_DIR`; otherwise, it is empty.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<INSTALL_PREFIX>` – 当目标用`install(EXPORT)`导出时或在`INSTALL_NAME_DIR`中评估时，安装前缀为；否则，为空。'
- en: Escaping
  id: totrans-316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 转义
- en: 'On a rare occasion, you may need to pass a character to a generator expression
    that has a special meaning. To escape this behavior, use the following expressions:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在很少的情况下，您可能需要向具有特殊意义的生成器表达式传递一个字符。为了逃避这种行为，请使用以下表达式：
- en: '`$<ANGLE-R>` – a literal `>` symbol (which compares strings containing `>`)'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<ANGLE-R>` – 字面上的`>`符号（比较包含`>`的字符串）'
- en: '`$<COMMA>` – a literal `,` symbol (which compares strings containing `,`)'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<COMMA>` – 字面上的`,`符号（比较包含`,`的字符串）'
- en: '`$<SEMICOLON>` – a literal `;` symbol (which prevents a list expansion on an
    argument with `;`)'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<SEMICOLON>` – 字面上的`；`符号（防止在带有`；`的参数上进行列表展开）'
- en: String transformations
  id: totrans-321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串转换
- en: 'Working with strings in the generator stage is possible with the following
    expressions:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成器阶段处理字符串是可能的，使用以下表达式：
- en: '`$<JOIN:list,d>` – join a semicolon-separated `list` using a `d` delimiter.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<JOIN:list,d>` – 使用`d`分隔符将分号分隔的`list`连接起来。'
- en: '`$<REMOVE_DUPLICATES:list>` – remove duplicates without sorting `list`.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<REMOVE_DUPLICATES:list>` – 不排序地删除`list`中的重复项。'
- en: '`$<FILTER:list,INCLUDE|EXCLUDE,regex>` – include/exclude items from a list
    using a `regex` regular expression.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<FILTER:list,INCLUDE|EXCLUDE,regex>` – 使用`regex`正则表达式从列表中包含/排除项。'
- en: '`$<LOWER_CASE:string>`, `$<UPPER_CASE:string>` – convert the string to another
    case.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<LOWER_CASE:string>`，`$<UPPER_CASE:string>` – 将字符串转换为另一种大小写。'
- en: '`$<GENEX_EVAL:expr>` – evaluate the `expr` string as a nested expression in
    the context of the current target. This is useful when an evaluation of a nested
    expression returns another expression (they aren''t evaluated recursively).'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<GENEX_EVAL:expr>` – 以当前目标的嵌套表达式的上下文评估`expr`字符串。当嵌套表达式的评估返回另一个表达式时（它们不是递归评估的），这很有用。'
- en: '`$<TARGET_GENEX_EVAL:target,expr>` – evaluate `expr` similarly to the `GENEX_EVAL`
    transformation but in the context of `target`.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_GENEX_EVAL:target,expr>` – 以与`GENEX_EVAL`转换类似的方式评估`expr`，但在`target`的上下文中。'
- en: Output-related expressions
  id: totrans-329
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出相关表达式
- en: CMake documentation fails to provide a good explanation of what "output-related
    expressions" are. That leaves us a little lost; how are they related to output?
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: CMake文档未能提供对“输出相关表达式”的好解释。这让我们有些迷茫；它们与输出有什么关系？
- en: As per the v3.13 documentation (removed in newer revisions), *"These expressions
    generate output, in some cases depending on an input."*
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 根据v3.13文档（在较新的版本中被删除），“这些表达式生成输出，在某些情况下取决于输入。”
- en: It turns out that they are a little bit of everything really. Some are a legacy
    version of the shorthand conditional expression. Others are just a string transformation
    expression that hadn't yet made its way into the other section.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 结果它们真的是点点滴滴。一些是缩写条件表达式的遗留版本。其他的只是尚未进入其他部分的字符串转换表达式。
- en: 'The following expressions will return their first arguments if a specific condition
    is met and an empty string otherwise:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表达式如果满足特定条件将返回其第一个参数，否则返回空字符串：
- en: '`$<LINK_ONLY:deps>` – sets implicitly with `target_link_libraries()` to store
    `PRIVATE` `deps` link dependencies, which won''t be propagated as usage requirements'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<LINK_ONLY:deps>` – 在`target_link_libraries()`中隐式设置以存储`PRIVATE` `deps`链接依赖项，这些依赖项不会作为使用要求传播。'
- en: '`$<INSTALL_INTERFACE:content>` – returns `content` if used with `install(EXPORT)`'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<INSTALL_INTERFACE:content>` – 如果用于`install(EXPORT)`，则返回`content`。'
- en: '`$<BUILD_INTERFACE:content>` – returns `content` if used with an `export()`
    command or by another target in the same buildsystem'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<BUILD_INTERFACE:content>` – 如果与`export()`命令一起使用或在与同一构建系统中的另一个目标一起使用时，返回`content`。'
- en: 'The following output expressions will perform a string transformation on their
    arguments:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出表达式将对其参数执行字符串转换：
- en: '`$<MAKE_C_IDENTIFIER:input>` – converts to a C identifier following the same
    behavior as `string(MAKE_C_IDENTIFIER)`.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<MAKE_C_IDENTIFIER:input>` – 转换为遵循与`string(MAKE_C_IDENTIFIER)`相同行为的C标识符。'
- en: '`$<SHELL_PATH:input>` – converts an absolute path (or list of paths) to a shell
    path style matching the target OS. Slashes are converted to backslashes in Windows
    shells and drive letters are converted to POSIX paths in MSYS shells.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<SHELL_PATH:input>` – 将绝对路径（或路径列表）转换为与目标操作系统匹配的壳路径样式。在Windows壳中，反斜杠被转换为斜杠，在MSYS壳中，驱动器字母被转换为POSIX路径。'
- en: 'Finally, we have a stray variable query expression:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个游离变量查询表达式：
- en: '`$<TARGET_OBJECTS:target>` – returns a list of *object files* from a `target`
    object library'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_OBJECTS:target>` – 从`target`对象库返回一个*对象文件*列表'
- en: Examples to try out
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下的例子
- en: 'Everything is easier to grasp when there''s a good practical example to support
    the theory. Here are some of the uses for generator expressions:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 当有一个好的实际例子来支持理论时，一切都会更容易理解。以下是生成器表达式的一些用途：
- en: Build configurations
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建配置
- en: 'In the first chapter, we discussed build type specifying which configuration
    we are building – `Debug`, `Release`, and so on. There may be cases where you''d
    like to act differently based on what kind of build you''re making. A simple and
    easy way to do so is utilizing the `$<CONFIG>` generator expression:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们讨论了指定我们要构建的配置的构建类型 – `Debug`、`Release`等。可能会有这样的情况，基于你正在进行的构建类型，你希望采取不同的行动。实现这一目标的一种简单方法是使用`$<CONFIG>`生成器表达式：
- en: '[PRE34]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding example checks whether the config equals `DEBUG`; if that's the
    case, the nested expression is evaluated to `1`. The outer shorthand `if` expression
    then becomes `true`, and our `-ginline-points` debug flag gets added to the options.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个示例检查`config`是否等于`DEBUG`；如果是这样，嵌套表达式被评估为`1`。外部的简写`if`表达式 then 变为`true`，我们的`-ginline-points`调试标志被添加到选项中。
- en: System-specific one-liners
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特定于系统的单行命令
- en: 'Generator expressions can also be used to compact verbose `if` commands into
    neat one-liners. Let''s suppose we have the following code:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式还可以用来将冗长的`if`命令压缩成整洁的一行。假设我们有以下代码：
- en: '[PRE35]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It tells the compiler to add `-DLINUX=1` to the arguments if this is the target
    system. While this isn''t terribly long, it could be easily replaced with an elegant
    expression:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 它告诉编译器如果这是目标系统，则将`-DLINUX=1`添加到参数中。虽然这并不是特别长，但它可以很容易地用一个优雅的表达式替换：
- en: '[PRE36]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Such code works well, but there's a limit to how much you can pack into a generator
    expression until it becomes too hard to read. In that case, it's better to stick
    to the long conditional blocks.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的代码工作得很好，但是你能在生成器表达式中放入多少内容，直到它变得难以阅读，有一个限度。在这种情况下，最好还是使用长的条件块。
- en: Interface libraries with compiler-specific flags
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与编译器特定标志相关的接口库
- en: 'Interface libraries, as we discussed earlier in this chapter, can be used to
    provide flags to match the compiler:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这章开头讨论的，接口库可以用来提供与编译器匹配的标志：
- en: '[PRE37]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Even in such a simple example, we can already see what happens when we nest
    too many generator expressions. Unfortunately, sometimes this is the only way
    to achieve the desired effect. Here''s what happens:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这个简单的例子中，我们也可以看到当我们嵌套太多生成器表达式时会发生什么。不幸的是，有时这是实现所需效果的唯一方法。这里发生了什么：
- en: We check whether `COMPILER_ID` is `GNU`; if that's the case, we evaluate `OR`
    to `1`.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们检查`COMPILER_ID`是否为`GNU`；如果是这样，我们将`OR`评估为`1`。
- en: If it's not, we check whether `COMPILER_ID` is `Clang`, and evaluate `OR` to
    `1`. Otherwise, evaluate `OR` to `0`.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不是，我们检查`COMPILER_ID`是否为`Clang`，并将`OR`评估为`1`。否则，将`OR`评估为`0`。
- en: If `OR` is evaluated to `1`, add `-rtti` to the `enable_rtti` *compile options*.
    Otherwise, do nothing.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`OR`被评估为`1`，则将`-rtti`添加到`enable_rtti`*编译选项*。否则，什么都不做。
- en: Next, we can link our libraries and executables with the `enable_rtti` interface
    library. CMake will add the `-rtti` flag if a compiler supports it.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以用`enable_rtti`接口库链接我们的库和可执行文件。如果编译器支持，CMake将添加`-rtti`标志。
- en: Nested generator expressions
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌套生成器表达式
- en: Sometimes, it's not obvious what happens when we try to nest elements in a generator
    expression. We can debug the expressions by generating a test output to a debug
    file.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在尝试在生成器表达式中嵌套元素时，不清楚会发生什么。我们可以通过生成测试输出到调试文件来调试这些表达式。
- en: 'Let''s try out a few things and see what happens:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一些东西，看看会发生什么：
- en: chapter04/04-genex/CMakeLists.txt (fragment)
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04/04-genex/CMakeLists.txt（片段）
- en: '[PRE38]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output is as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE39]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This is how each line works:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是每行的工作方式：
- en: The `PLATFORM_ID` output value is regular case `Linux`.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PLATFORM_ID`输出值是常规大小写`Linux`。'
- en: The output from the nested value will get transformed correctly to uppercase
    `LINUX`.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 嵌套值的输出将被正确转换为大写`LINUX`。
- en: We can transform plain strings.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以转换普通字符串。
- en: We can transform the content of configuration-stage variables.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以转换配置阶段变量的内容。
- en: Variables will be interpolated first, and closing angle brackets (`>`) will
    be interpreted as part of the genex, in that only part of the string will get
    capitalized.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量将首先被插值，闭合尖括号（`>`）将被解释为生成器表达式的一部分，在这种情况下，只有字符串的一部分将被大写。
- en: In other words, be aware that the content of variables may affect the behavior
    of your genex expansions. If you need an angle bracket in a variable, use `$<ANGLE-R>`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，要意识到变量的内容可能会影响您的生成器表达式的行为。如果您需要在变量中使用尖括号，请使用`$<ANGLE-R>`。
- en: The difference between a conditional expression and the evaluation of BOOL operator
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件表达式与BOOL运算符评估之间的区别
- en: 'Generator expressions can be a little confusing when it comes to evaluating
    Boolean types to strings. It is important to understand how they differ from regular
    conditional expressions, starting with an explicit `IF` keyword:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式在评估布尔类型到字符串时可能会有些令人困惑。理解它们与普通的条件表达式有何不同是很重要的，尤其是从一个显式的`IF`关键字开始：
- en: chapter04/04-genex/CMakeLists.txt (fragment)
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04/04-genex/CMakeLists.txt（片段）
- en: '[PRE40]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This produces a file like this:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生一个文件，像这样：
- en: '[PRE41]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let''s examine the output for each line:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查每行的输出：
- en: This is a Boolean expansion, where `BOOL` is `0`; therefore, the `TRUE` string
    isn't written.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个布尔展开，其中`BOOL`是`0`；因此，没有写入`TRUE`字符串。
- en: This is a typical mistake – the author intended to print `TRUE` or `FALSE` depending
    on the `BOOL` value, but since it is a Boolean `false` expansion as well, two
    arguments are treated as one and not printed.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个典型的错误——作者本意是想根据`BOOL`值的`TRUE`或`FALSE`打印，但由于它也是一个布尔的`false`展开，两个参数被视为一个，因此没有打印。
- en: This is the same mistake for a reversed value – it is a Boolean `true` expansion
    that has both arguments written in a single line.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个反转值的相同错误——它是一个布尔`true`展开，在单行中写入两个参数。
- en: This is a proper conditional expression starting with `IF` – it prints `FALSE`
    because the first argument is `0`.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个从`IF`开始的正确条件表达式——它打印`FALSE`，因为第一个参数是`0`。
- en: This is the incorrect usage of a conditional expression – when we don't need
    to write values for Boolean `false`, we should use the first form.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是条件表达式的错误用法——当我们需要为布尔`false`不写值时，我们应该使用第一种形式。
- en: Generator expressions are known for their convoluted syntax. The differences
    mentioned in this example can confuse even experienced builders. If in doubt,
    copy such an expression to another file and break it apart with added indentation
    and whitespace to understand it better.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式以其复杂的语法而闻名。本例中提到的区别即使是经验丰富的构建者也会感到困惑。如果有疑问，将这样的表达式复制到另一个文件中，通过增加缩进和空格来拆分它，以便更好地理解。
- en: Summary
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Understanding targets is critical to writing clean, modern CMake projects. In
    this chapter, we not only discussed what constitutes a target and how targets
    depend on each other but also how to present that information in a diagram using
    the Graphviz module. With this general understanding, we were able to learn about
    the key feature of targets – properties (all kinds of properties). We not only
    went through a few commands to set regular properties on targets; we also solved
    the mystery of transitive usage requirements or propagated properties. This was
    a hard one to solve, as we not only needed to control which properties get propagated
    but also how to reliably propagate them to selected, further targets. Furthermore,
    we discovered how to guarantee that those propagated properties are compatible
    when they arrive from multiple sources.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 理解目标对于编写干净、现代的CMake项目至关重要。在本章中，我们不仅讨论了构成目标以及目标如何相互依赖，还学习了如何使用Graphviz模块在图表中呈现这些信息。有了这个基本的了解，我们能够学习目标的关键特性——属性（各种各样的属性）。我们不仅介绍了几个设置目标常规属性的命令，还解决了传递属性或传播属性的谜团。解决这个问题很困难，因为我们不仅需要控制哪些属性被传播，还需要可靠地将它们传播到选定的、更远的靶子。此外，我们还发现了如何确保当属性来自多个来源时，它们传播后仍然是兼容的。
- en: We then briefly discussed pseudo targets – imported targets, alias targets,
    and interface libraries. All of them will come in handy in our projects, especially
    when we know how to connect them with propagated properties for our benefit. Then,
    we talked about generated build targets and how they are the immediate effect
    of our actions during the configuration stage. Afterward, we focused on custom
    commands (how they can generate files that can be consumed by other targets, compiled,
    translated, and so on) and their hook function – executing additional steps when
    a target is built.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后简要讨论了伪目标——导入的目标、别名目标和接口库。它们都将会在我们的项目中派上用场，特别是当我们知道如何将它们与传播属性结合起来以造福我们的项目时。然后，我们谈到了生成的构建目标和它们在配置阶段我们行动的直接结果。之后，我们重点关注自定义命令（它们如何生成可以被其他目标消费、编译、翻译等的文件）以及它们的钩子函数——在目标构建时执行额外步骤。
- en: The last part of the chapter was dedicated to the concept of a generator expression,
    or genex for short. We explained its syntax, nesting, and how its conditional
    expressions work. Then, we went through two types of evaluation – to Boolean and
    to string. Each had its own set of expressions, which we explored and commented
    on in detail. In addition, we have presented a few usage examples and clarified
    how they work in practice.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后部分致力于生成表达式（genex）的概念。我们解释了其语法、嵌套以及条件表达式的工作原理。然后，我们介绍了两种类型的评估——布尔值和字符串。每种都有它自己的一套表达式，我们详细探索并评论了这些表达式。此外，我们还提供了一些使用示例，并澄清了它们在实际中是如何工作的。
- en: With such a solid foundation, we are ready for the next topic – compiling C++
    sources to executables and libraries.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这样一个坚实的基础，我们准备好进入下一个主题——将C++源代码编译成可执行文件和库。
- en: Further reading
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information, use the following sites:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请访问以下网站：
- en: '*Graphviz module documentation:*'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Graphviz模块文档：**'
- en: '[https://gitlab.kitware.com/cmake/community/-/wikis/doc/cmake/Graphviz](https://gitlab.kitware.com/cmake/community/-/wikis/doc/cmake/Graphviz)'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '[CMake社区文档中的Graphviz部分](https://gitlab.kitware.com/cmake/community/-/wikis/doc/cmake/Graphviz)'
- en: '[https://cmake.org/cmake/help/latest/module/CMakeGraphVizOptions.html](https://cmake.org/cmake/help/latest/module/CMakeGraphVizOptions.html)'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '[CMakeGraphVizOptions模块文档](https://cmake.org/cmake/help/latest/module/CMakeGraphVizOptions.html)'
- en: '*Graphviz software:*'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Graphviz软件：**'
- en: '[https://graphviz.org](https://graphviz.org)'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '[Graphviz.org](https://graphviz.org)'
- en: '*CMake target properties:*'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CMake目标属性：**'
- en: https://cmake.org/cmake/help/latest/manual/cmake-properties.7.html#properties-on-targets
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '[CMake目标属性](https://cmake.org/cmake/help/latest/manual/cmake-properties.7.html#properties-on-targets)'
- en: '*Transitive usage requirements:*'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传递性使用要求：**'
- en: https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#transitive-usage-requirements
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '[CMake构建系统](https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#transitive-usage-requirements)的传递性使用要求'
