- en: Assessments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: This section contains answers to the questions from all chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含所有章节的问题答案。
- en: Chapter 6, Extending the Preprocessor
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章，扩展预处理器
- en: Most of the time tokens are harvested from the provided source code, but in
    some cases, tokens might be generated dynamically inside the `Preprocessor`. For
    example, the `__LINE__` built-in macro is expanded to the current line number,
    and the `__DATE__` macro is expanded to the current calendar date. How does Clang
    put that generated textual content into the `SourceManager`'s source code buffer?
    How does Clang assign `SourceLocation` to these tokens?
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数情况下，标记是从提供的源代码中收集的，但在某些情况下，标记可能会在 `Preprocessor` 内部动态生成。例如，内置宏 `__LINE__`
    被展开为当前行号，而宏 `__DATE__` 被展开为当前的日历日期。Clang 如何将这些生成的文本内容放入 `SourceManager` 的源代码缓冲区？Clang
    如何将这些 `SourceLocation` 分配给这些标记？
- en: Developers can leverage the `clang::ScratchBuffer` class to insert dynamic `Token`
    instances.
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者可以利用 `clang::ScratchBuffer` 类来插入动态的 `Token` 实例。
- en: When we were talking about implementing a custom `PragmaHandler`, we were using
    `Preprocessor::Lex` to fetch tokens followed after the pragma name, until we hit
    the `eod` token type. Can we keep lexing *beyond* the `eod` token? What interesting
    thing will you do if you can consume arbitrary tokens follow after the `#pragma`
    directive?
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们讨论实现自定义的 `PragmaHandler` 时，我们使用 `Preprocessor::Lex` 来获取紧随 `pragma` 名称之后的标记，直到遇到
    `eod` 标记类型。我们能否在 `eod` 标记之后继续进行词法分析？如果你可以消费 `#pragma` 指令之后任意跟随的标记，你将做些什么有趣的事情？
- en: 'Yes, we can keep lexing beyond the `eod` token. It simply consumes the contents
    following the `#pragma` line. In this way, you can create a custom `#pragma` that
    allows you to write *arbitrary* content (below it) – for instance, writing programming
    languages that are not supported by Clang. Here is an example:'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是的，我们可以在 `eod` 标记之后继续进行词法分析。它只是消费了 `#pragma` 行之后的内 容。这样，你可以创建一个自定义的 `#pragma`，允许你写入
    *任意* 内容（在其下方）——例如，编写 Clang 不支持的编程语言。以下是一个示例：
- en: '[PRE0]'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the `macro guard` project from the *Developing custom preprocessor plugins
    and callbacks* section, the warning message has the format of `[WARNING] In <source
    location>: ….`. Apparently, this is not the typical compiler warning we see from
    `Clang`, which looks like `<source location>: warning: …`:'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在 *开发自定义预处理器插件和回调* 部分的 `macro guard` 项目中，警告消息的格式为 `[WARNING] In <source location>:
    ….`。显然，这不是我们从 `Clang` 看到的典型编译器警告，其格式看起来像 `<source location>: warning: …`：'
- en: '[PRE1]'
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `warning` string is even colored in supported terminals. How can we print
    a warning message like that? Is there an infrastructure in Clang for doing that?
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`warning` 字符串甚至在支持的终端中着色。我们如何打印这样的警告消息？Clang 中是否有用于此目的的基础设施？'
- en: Developers can use the diagnostics framework in Clang to print messages like
    this. In the *Printing diagnostics messages* section of [*Chapter 7*](B14590_07_Final_JC_ePub.xhtml#_idTextAnchor093)*,
    Handling AST*, we will show you some of the usages of this framework.
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者可以使用 Clang 中的诊断框架来打印此类消息。在 [*第 7 章*](B14590_07_Final_JC_ePub.xhtml#_idTextAnchor093)
    的 *打印诊断消息* 部分，即 *处理 AST*，我们将向您展示该框架的一些用法。
- en: Chapter 8, Working with Compiler Flags and Toolchains
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章，与编译器标志和工具链一起工作
- en: It is common to override the assembling and linking stage, since different platforms
    tend to support different assemblers and linkers. But is it possible to override
    the *compiling* stage (which is Clang)? If it is possible, how do we do it? What
    might be the possible reasons for people to do that?
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖汇编和链接阶段是很常见的，因为不同的平台通常支持不同的汇编器和链接器。但是，是否可以覆盖 *编译* 阶段（即 Clang）？如果可以，我们该如何做？人们可能出于什么原因这样做？
- en: 'You can override the `ToolChain::SelectTool` method and provide an alternative
    `Tool` instance (which represents the compilation stage) according to the argument.
    Here is an example:'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以覆盖 `ToolChain::SelectTool` 方法并提供一个替代的 `Tool` 实例（它代表编译阶段），根据参数提供。以下是一个示例：
- en: '[PRE2]'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When we were working on `tools::zipline::Linker::ConstructJob`, we simply use
    `llvm_unreachable` to bail out the compilation process if the user provides an
    unsupported compressor name through the `-fuse-ld` flag. Can we replace it with
    Clang's `Driver` class provides a shortcut to access the diagnostic framework.
    Inside a derived class of `Tool`, you can use `getToolChain().getDriver()` to
    get a `Driver` instance, then print out the diagnostic message using the `Driver::Diag`
    method.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们处理 `tools::zipline::Linker::ConstructJob` 时，我们简单地使用 `llvm_unreachable` 来通过
    `-fuse-ld` 标志退出编译过程，如果用户提供了不支持的压缩器名称。我们可以用 Clang 的 `Driver` 类提供的快捷方式来替换它，访问诊断框架。在一个
    `Tool` 的派生类中，您可以使用 `getToolChain().getDriver()` 来获取一个 `Driver` 实例，然后使用 `Driver::Diag`
    方法打印出诊断信息。
- en: Just like we can use `-Xclang` to pass flags directly to the frontend, we can
    also pass assembler-specific or linker-specific flags directly to the assembler
    or linker using driver flags such as `-Wa` (for assembler) and `-Wl` (for linker).
    How do we consume those flags in our custom assembler and linker stages within
    Zipline?
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们可以使用 `-Xclang` 将标志直接传递给前端一样，我们也可以通过驱动器标志（如 `-Wa` 用于汇编器，`-Wl` 用于链接器）将汇编器特定或链接器特定的标志直接传递给汇编器或链接器。我们如何在
    Zipline 的自定义汇编器和链接器阶段消耗这些标志？
- en: 'Inside the `ConstructJob` method, you can read the value of `options::OPT_Wa_COMMA`
    and `options::OPT_Wl_COMMA` to retrieve assembler- and linker-specific command
    line flags, respectively. Here is an example:'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `ConstructJob` 方法内部，您可以读取 `options::OPT_Wa_COMMA` 和 `options::OPT_Wl_COMMA`
    的值，分别检索汇编器和链接器特定的命令行标志。以下是一个示例：
- en: '[PRE3]'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Chapter 9, Working with PassManager and AnalysisManager
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章，使用 PassManager 和 AnalysisManager
- en: In the StrictOpt example in the *Writing a LLVM Pass for the new PassManager*
    section, how do we write a Pass without deriving the `PassInfoMixin` class?
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 *Writing a LLVM Pass for the new PassManager* 部分的 StrictOpt 示例中，我们如何编写一个不继承
    `PassInfoMixin` 类的 Pass？
- en: 'The `PassInfoMixin` class only defines a utility function for you, `name`,
    which returns the name of this Pass. Therefore, you can easily create one by yourself.
    Here is an example:'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PassInfoMixin` 类仅为您定义了一个实用函数 `name`，该函数返回此 Pass 的名称。因此，您可以轻松地自己创建一个。以下是一个示例：'
- en: '[PRE4]'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'How do we develop custom instrumentation for the new PassManager? How do we
    do it without modifying the LLVM source tree? (Hint: Use the Pass plugin we learned
    in this chapter.)'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何为新的 PassManager 开发自定义的仪器？我们如何在不修改 LLVM 源树的情况下完成它？（提示：使用本章中我们学习过的 Pass 插件。）
- en: 'Pass instrumentation is a piece of code that runs before and/or after an LLVM
    Pass. This blog post shows an example of developing a custom Pass instrumentation
    via the Pass plugin: [https://medium.com/@mshockwave/writing-pass-instrument-for-llvm-newpm-f17c57d3369f](mailto:https://medium.com/@mshockwave/writing-pass-instrument-for-llvm-newpm-f17c57d3369f).'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pass 仪器是一段在 LLVM Pass 之前和/或之后运行的代码。这篇博客文章展示了通过 Pass 插件开发自定义 Pass 仪器的一个示例：[https://medium.com/@mshockwave/writing-pass-instrument-for-llvm-newpm-f17c57d3369f](mailto:https://medium.com/@mshockwave/writing-pass-instrument-for-llvm-newpm-f17c57d3369f)。
