- en: '*Chapter 1*: Introduction to Performance and Concurrency'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第1章*：性能和并发简介'
- en: Motivation is a key ingredient of learning; thus, you must understand why, with
    all the advances in computing, a programmer still has to struggle to get adequate
    performance from their code and why success requires a deep understanding of computing
    hardware, programming language, and compiler capabilities. The aim of this chapter
    is to explain why this understanding is still necessary today.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 动机是学习的关键因素；因此，您必须了解为什么在计算机技术取得了所有进步的情况下，程序员仍然必须努力使其代码获得足够的性能，以及成功需要深刻理解计算硬件、编程语言和编译器能力。本章的目的是解释为什么今天仍然需要这种理解。
- en: This chapter talks about the reasons we care about the performance of programs,
    specifically about the reasons good performance doesn't *just happen*. We will
    learn why, in order to achieve the best performance, or sometimes even adequate
    performance, it is important to understand the different factors affecting performance,
    and the reasons for a particular behavior of the program, whether it is fast execution
    or slow.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了我们关心程序性能的原因，特别是关于良好性能并非“自然而然”发生的原因。我们将了解为什么为了实现最佳性能，有时甚至是足够的性能，重要的是要了解影响性能的不同因素，以及程序特定行为的原因，无论是快速执行还是缓慢执行。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Why performance matters
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能为什么重要
- en: Why performance requires the programmer's attention
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么性能需要程序员的注意？
- en: What do we mean by performance?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能是什么意思？
- en: How to evaluate the performance
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何评估性能
- en: Learning about high performance
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习高性能
- en: Why focus on performance?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么要关注性能？
- en: In the early days of computing, programming was hard. The processors were slow,
    the memory was limited, the compilers were primitive, and nothing could be achieved
    without a major effort. The programmer had to know the architecture of the CPU,
    the layout of the memory, and when the compiler did not cut it, the critical code
    had to be written in assembler.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机早期，编程是困难的。处理器速度慢，内存有限，编译器原始，没有付出重大努力就无法取得任何成就。程序员必须了解CPU的架构，内存的布局，当编译器无法胜任时，关键代码必须用汇编语言编写。
- en: 'Then things got better. The processors were getting faster every year, the
    number that used to be the capacity of a huge hard drive became the size of the
    main memory in an average PC, and the compiler writers learned a few tricks to
    make programs faster. The programmers could spend more time actually solving problems.
    This was reflected in the programming languages and design styles: between the
    higher-level languages and evolving design and programming practices, the programmers''
    focus shifted from *what* they wanted to say in code to *how* they wanted to say
    it.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然后情况变得好转。处理器每年都在变得更快，曾经是巨大硬盘容量的数字变成了普通PC主存储器的大小，编译器编写者学会了一些技巧来加快程序速度。程序员可以花更多时间解决问题。这反映在编程语言和设计风格上：在更高级的语言和不断发展的设计和编程实践之间，程序员的关注重点从代码中想要表达的内容转移到了如何表达这些内容。
- en: Formerly common knowledge, such as exactly how many registers the CPU has and
    what their names are, became esoteric, arcane matter. A "large code base" used
    to be one that needed both hands to lift the card deck; now, it was one that taxed
    the capacity of the version control system. There was hardly ever a need to write
    code specialized for a particular processor or a memory system, and portable code
    became the norm.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以前的常识，比如CPU有多少寄存器以及它们的名称是什么，变得神秘而深奥。曾经，“大型代码库”是指需要用双手才能搬动的卡片组；现在，“大型代码库”是指超出版本控制系统容量的代码库。以前几乎不需要为特定处理器或内存系统编写专门的代码，可移植代码成为了常态。
- en: As for assembler, it was actually difficult to outperform the compiler-generated
    code, a task well out of reach for most programmers. For many applications, and
    those writing them, there was "enough performance," and other aspects of the programmers'
    trade became more important (to be clear, the fact that the programmers could
    focus on the readability of their code without worrying whether adding a function
    with a meaningful name would make the program unacceptably slow was a good thing).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 至于汇编语言，实际上很难超越编译器生成的代码，这对大多数程序员来说是难以企及的任务。对于许多应用程序及其编写者来说，已经有了“足够的性能”，程序员职业的其他方面变得更加重要（明确地说，程序员可以专注于代码的可读性，而不必担心添加一个有意义名称的函数是否会使程序变得无法接受地慢）。
- en: Then, and rather suddenly, the free lunch of "performance taking care of itself"
    was over. The seemingly unstoppable progress of the ever-growing computing power
    just … stopped.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，突然间，“性能自行解决”的免费午餐结束了。看似不可阻挡的计算能力不断增长的进展突然停止了。
- en: '![Figure 1.1 – Charting 35 years of microprocessor evolution'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.1 - 绘制35年微处理器演变历程'
- en: (Refer to https://github.com/karlrupp/microprocessor-trend-data and https://github.com/karlrupp/microprocessor-trend-data/blob/master/LICENSE.txt)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: （参见https://github.com/karlrupp/microprocessor-trend-data和https://github.com/karlrupp/microprocessor-trend-data/blob/master/LICENSE.txt）
- en: '](img/Figure_1.1_B16229.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.1_B16229.jpg)'
- en: Figure 1.1 – Charting 35 years of microprocessor evolution (Refer to https://github.com/karlrupp/microprocessor-trend-data
    and https://github.com/karlrupp/microprocessor-trend-data/blob/master/LICENSE.txt)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 - 绘制35年微处理器演变历程（参见https://github.com/karlrupp/microprocessor-trend-data和https://github.com/karlrupp/microprocessor-trend-data/blob/master/LICENSE.txt）
- en: Around the year 2005, the computing power of a single CPU reached saturation.
    To a large extent, this was directly related to the CPU frequency, which also
    stopped growing. The frequency, in turn, was limited by several factors, one of
    which was power consumption (if the frequency trend continued unchanged, today's
    CPUs would pack more power per square millimeter than the great jet engines that
    lift rockets into space).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 大约在2005年左右，单个CPU的计算能力达到了饱和。在很大程度上，这与CPU频率直接相关，而CPU频率也停止增长。而频率受到多种因素的限制，其中之一是功耗（如果频率趋势保持不变，今天的CPU每平方毫米的功率将比将火箭送入太空的大型喷气发动机还要高）。
- en: 'It is evident from the preceding figure that not every measure of progress
    stalled in 2005: the number of transistors packed into a single chip kept growing.
    So, what were they doing if not making chips faster? The answer is two-fold, and
    part of it is revealed by the bottom curve: instead of making the single processor
    larger, the designers had to settle for putting several processor cores on the
    same die. The computing power of all these cores together, of course, increased
    with the number of cores, but only if the programmer knew how to use them. The
    second part of the "great transistor mystery" (where do all the transistors go?)
    is that they went into various very advanced enhancements to the processor capabilities,
    enhancements that can be used to improve performance, but again, only if the programmer
    makes an effort to use them.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图表可以明显看出，不是所有的进展措施在2005年停滞不前：单芯片上的晶体管数量不断增加。那么，如果不是让芯片变得更快，他们在做什么呢？答案是双重的，其中一部分由底部曲线揭示：设计师不是让单个处理器变得更大，而是不得不将多个处理器核心放在同一块芯片上。当然，所有这些核心的计算能力随着核心数量的增加而增加，但前提是程序员知道如何使用它们。"伟大的晶体管之谜"的第二部分（所有的晶体管都去哪了？）是它们进入了处理器能力的各种非常先进的增强功能，这些增强功能可以用来提高性能，但同样，只有程序员努力利用它们。
- en: The change in the progress of processors that we have just seen is often held
    as the reason that concurrent programming has entered the mainstream. But the
    change was even more profound than that. You will learn throughout this book how,
    in order to obtain the best performance, the programmer once again needs to understand
    the intricacies of the processor and memory architecture and their interactions.
    Great performance doesn't "just happen" anymore. At the same time, the progress
    we have made in writing code that clearly expresses what needs to be done, rather
    than how it's done, is not to be rolled back. We still want to write readable
    and maintainable code, and (*and* not *but*) we want it to be efficient as well.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到的处理器进展的变化通常被认为是并发编程进入主流的原因。但这种变化甚至更加深刻。在本书中，您将了解到，为了获得最佳性能，程序员再次需要了解处理器和内存架构及其相互作用的复杂性。出色的性能不再是“自然而然”发生的。与此同时，我们在编写清晰表达需要完成的任务而不是如何完成的代码方面取得的进展不应该被撤销。我们仍然希望编写可读性强、易于维护的代码，而且（*而且*不是*但是*）我们也希望它高效。
- en: To be sure, for many applications there is still *enough performance* in modern
    CPUs, but performance is getting more attention than it used to, in large part
    because of the change in CPU development we just discussed and because we want
    to do more computing in more applications that do not necessarily have access
    to the best computing resources (for example, a portable medical device today
    may have a full neural network in it).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 可以肯定的是，对于许多应用程序来说，现代CPU仍然具有*足够的性能*，但性能比以前更受关注，这在很大程度上是因为我们刚刚讨论的CPU发展的变化，以及因为我们希望在更多的应用程序中进行更多的计算，这些应用程序并不一定能够获得最佳的计算资源（例如，今天的便携式医疗设备可能会内置完整的神经网络）。
- en: Fortunately, we do not have to rediscover some *lost art of performance* by
    digging through piles of decaying punch cards in a dark storage room. At any time,
    there were still hard problems, and the phrase *there is never enough computing
    power* was true for many programmers. As computing power grew exponentially, so
    did the demands on it. The art of *extreme performance* was kept alive in those
    few domains that needed it. An example of one such domain may be instructive and
    inspiring at this point.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不必通过在黑暗的存储室里翻阅腐烂的穿孔卡片堆来重新发现一些*失落的性能艺术*。任何时候，仍然存在着困难的问题，短语*计算能力永远不够*对许多程序员来说是真实的。随着计算能力的指数增长，对它的需求也在增加。*极限性能*的艺术在那些需要它的领域中得以保持。在这一点上，一个这样的领域的例子可能是有启发性和有启发性的。
- en: Why performance matters
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么性能很重要
- en: To find such an example of an area where the focus on performance never really
    waned, let us examine the evolution of the computing that goes into making computing
    itself possible, which is the **electronic design automation** (**EDA**) tools
    that are used to design computers themselves.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到一个关于性能关注从未真正减弱的领域的例子，让我们来研究使计算本身成为可能的计算的演变，即用于设计计算机本身的**电子设计自动化**（**EDA**）工具。
- en: 'If we took the computations that went into designing, simulating, or verifying
    a particular microchip in 2010 and ran the same workload every year since, we
    would see something like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将2010年用于设计、模拟或验证特定微芯片的计算，并自那时起每年运行相同的工作负载，我们会看到类似于这样的情况：
- en: '![Figure 1.2 – Processing time, in hours, for a particular EDA computation,
    over the years'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.2 - 某个EDA计算的处理时间（以小时为单位），随着年份的变化'
- en: '](img/Figure_1.2_B16229.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.2_B16229.jpg)'
- en: Figure 1.2 – Processing time, in hours, for a particular EDA computation, over
    the years
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 - 某个EDA计算的处理时间（以小时为单位），随着年份的变化
- en: 'What took 80 hours to compute in 2010 took less than 10 hours in 2018 (and
    even less today). Where does the improvement come from? Several sources at once:
    in part, computers become faster, but also software becomes more efficient, better
    algorithms are invented, the optimizing compilers become more effective.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 2010年需要80小时计算的工作，在2018年只需要不到10小时（甚至今天更少）。这种改进是从哪里来的？有几个来源：部分是计算机变得更快，但也有软件变得更有效率，发明了更好的算法，优化编译器变得更加有效。
- en: 'Unfortunately, we are not building 2010 version microchips in 2021: it stands
    to reason that as computers become more powerful, building newer and better ones
    becomes harder. The more interesting question, then, is how long does it take
    to do the same work every year for the new microchip we''re building that year:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们在2021年并没有制造2010年版本的微芯片：可以说，随着计算机变得更加强大，制造更新和更好的微芯片变得更加困难。因此，更有趣的问题是，每年制造当年的新微芯片需要多长时间来完成相同的工作：
- en: '![Figure 1.3 – Run time, in hours, for a particular design step for the latest
    microchip every year'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.3 - 每年最新微芯片特定设计步骤的运行时间（以小时为单位）'
- en: '](img/Figure_1.3_B16229.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.3_B16229.jpg)'
- en: Figure 1.3 – Run time, in hours, for a particular design step for the latest
    microchip every year
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 - 每年最新微芯片的特定设计步骤的运行时间（以小时为单位）
- en: The actual computations done each year are not the same, but they serve the
    same purpose, for example, *verify that the chip performs as intended*, for the
    latest and greatest chip we built every year. We can see from this chart that
    the most powerful processors of the current generation, running the best tools
    available, take roughly the same time to design and model the processor of the
    next generation every year. We are holding our own, but we are not making any
    headway.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每年实际完成的计算并不相同，但它们都为同一个目的服务，例如*验证芯片是否按预期运行*，对于我们每年制造的最新和最好的芯片。从这张图表中我们可以看到，当前一代最强大的处理器，运行最好的可用工具，每年都需要大致相同的时间来设计和建模下一代处理器。我们保持着自己的位置，但并没有取得任何进展。
- en: 'But the truth is even worse than that, and the chart above does not show everything.
    It is true that from 2010 to 2018, the largest processor to be made that year
    could be verified overnight (some 12 hours) using the computer equipped with the
    largest processors made last year. But we forgot to ask *how many of these processors?*
    Well, here is the full truth now:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 但事实甚至比这更糟，上面的图表并没有显示一切。从2010年到2018年，当年制造的最大处理器可以在一夜之间（大约12小时）得到验证，使用的是去年制造的最大处理器的计算机。但我们忘了问*有多少这样的处理器？*好吧，现在是完整的真相：
- en: '![Figure 1.4 – The preceding figure, annotated with the CPU count for each
    computation'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.4 - 前一图表，标注了每次计算的CPU数量'
- en: '](img/Figure_1.4_B16229.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.4_B16229.jpg)'
- en: Figure 1.4 – The preceding figure, annotated with the CPU count for each computation
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 - 前一图表，标注了每次计算的CPU数量
- en: Every year, the most powerful computers, equipped with the ever-growing number
    of the latest, most powerful processors, running the latest software versions
    (optimized to leverage increasingly more processors and to use each one more efficiently),
    do the work needed to build the next year's most powerful computers, and every
    year, this task is balanced on the edge of what is barely possible. That we do
    not fall off this edge is largely the achievement of the hardware and the software
    engineers, as the former supply the growing compute power, and the latter use
    it with maximum efficiency. This book will help you to learn the skills for the
    latter.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 每年，配备着不断增长数量的最新、最强大处理器的最强大计算机，运行着最新的软件版本（经过优化以利用越来越多的处理器并更有效地使用每一个处理器），完成了建造下一年最强大计算机所需的工作，而每年，这项任务都处于几乎不可能的边缘。我们没有掉下这个边缘，这在很大程度上是硬件和软件工程师的成就，前者提供了不断增长的计算能力，后者以最大效率使用它。本书将帮助您学习后者的技能。
- en: We now understand the importance of the subject of the book. Before we can delve
    into the details, it would help to do a high-level overview; a review of the map
    of the territory where the exploration campaign will unfold, so to speak.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在理解了本书的主题的重要性。在我们深入细节之前，进行高层次的概述会有所帮助；可以说是对勘探活动将展开的领域的地图的审查。
- en: What is performance?
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能是什么？
- en: We have talked about the performance of programs; we mentioned high-performance
    software. But what do we mean when we say that? Intuitively, we understand that
    a high-performance program is faster than a program with poor performance, but
    it doesn't mean that a faster program always has *good* performance (both programs
    may have poor performance).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经谈论了程序的性能；我们提到了高性能软件。但是当我们说这个词时，我们是什么意思呢？直观地，我们理解高性能程序比性能差的程序更快，但这并不意味着更快的程序总是具有*好*的性能（两个程序可能都性能差）。
- en: We have also mentioned efficient programs, but is efficiency the same as high
    performance? While efficiency is *related* to performance, it is not exactly the
    same. Efficiency deals with using resources optimally and not wasting them. An
    efficient program makes good use of the computational hardware.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也提到了高效的程序，但效率和高性能是一回事吗？虽然效率与性能*相关*，但并不完全相同。效率涉及最佳地使用资源而不浪费它们。高效的程序充分利用计算硬件。
- en: 'On the one hand, an efficient program does not leave available resources idle:
    if you have a computation that needs to be done and a processor that is not doing
    anything, that processor should be executing the code that is waiting to be executed.
    The idea goes deeper: processors have many computing resources in them, and an
    efficient program tries to make use of as many of these resources as possible
    at the same time. On the other hand, an efficient program does not waste resources
    doing unnecessary work: it does not perform computations that do not need to be
    done, does not waste memory to store data that is never going to be used, does
    not send data over the network if it''s not needed, and so on. In short, an efficient
    program does not leave the available hardware idle and does not do any work that
    doesn''t have to be done.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，高效的程序不会让可用资源空闲：如果有一个需要完成的计算和一个空闲的处理器，那么该处理器应该执行等待执行的代码。这个想法更深入：处理器内部有许多计算资源，高效的程序试图尽可能同时利用这些资源。另一方面，高效的程序不会浪费资源做不必要的工作：它不会执行不需要完成的计算，不会浪费内存来存储永远不会被使用的数据，不会发送不需要的数据到网络等等。简而言之，高效的程序不会让可用的硬件空闲，也不会做任何不必要的工作。
- en: Performance, on the other hand, always relates to some metrics. The most common
    one is "speed," or how fast the program is. The more rigorous way to define this
    metric is the throughput, which is the amount of computations the program does
    in a given time. The inverse metric that is often used for the same purpose is
    the turnaround time or how much time is needed to compute a particular result.
    However, this is not the only possible definition of performance.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，性能总是与某些指标相关。最常见的是“速度”，或者程序有多快。更严格定义这个指标的方式是吞吐量，即程序在给定时间内执行的计算量。通常用于相同目的的反向指标是周转时间，或者计算特定结果需要多长时间。然而，这并不是性能的唯一可能定义。
- en: Performance as throughput
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为吞吐量的性能
- en: 'Let''s consider four programs that use different implementations to compute
    the same end result. Here are the run times of all four programs (units are relative;
    the actual numbers don''t matter as we''re interested in relative performance):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑四个使用不同实现来计算相同结果的程序。这是所有四个程序的运行时间（单位是相对的；实际数字并不重要，因为我们关心的是相对性能）：
- en: '![Figure 1.5 – Run times of four different implementations of the same algorithm
    (relative units)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.5 - 相同算法的四种不同实现的运行时间（相对单位）'
- en: '](img/Figure_1.5_B16229.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.5_B16229.jpg)'
- en: Figure 1.5 – Run times of four different implementations of the same algorithm
    (relative units)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 - 相同算法的四种不同实现的运行时间（相对单位）
- en: 'It seems obvious that Program B has the highest performance: it finished before
    the other three programs, in half the time it took the slowest program to compute
    the same result. In many situations, this would be all the data we need to choose
    the best implementation.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，程序B具有最高的性能：它在其他三个程序之前完成了，用了一半的时间来计算与最慢程序相同的结果。在许多情况下，这将是我们选择最佳实现所需的所有数据。
- en: But the context of the problem matters, and we neglected to mention that the
    program is running on a battery-powered device, such as a cell phone, and the
    power consumption matters as well.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 但问题的上下文很重要，我们忽略了该程序是在手机等电池供电设备上运行，功耗也很重要。
- en: Performance as power consumption
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能作为功耗
- en: 'Here is the power consumed by all four programs during the course of the computation:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是四个程序在计算过程中消耗的功率：
- en: '![Figure 1.6 – Power consumption of four different implementations of the same
    algorithm (relative units)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.6 - 相同算法的四种不同实现的功耗（相对单位）'
- en: '](img/Figure_1.6_B16229.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.6_B16229.jpg)'
- en: Figure 1.6 – Power consumption of four different implementations of the same
    algorithm (relative units)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 - 相同算法的四种不同实现的功耗（相对单位）
- en: Despite taking longer to get the result, Program C used less power overall.
    So, which program has the best performance?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管花费更长时间来获得结果，程序C总体上消耗的功率更少。那么，哪个程序性能最好呢？
- en: 'Again, this is a trick question without knowing the full context. The program
    not only runs on a mobile device but performs a real-time computation: it is used
    in audio processing. This should put a premium on getting the results back faster
    in real time, right? Not exactly.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这是一个诡计问题，如果不知道完整的上下文。该程序不仅在移动设备上运行，而且执行实时计算：它用于音频处理。这应该更注重实时更快地获得结果，对吗？并不完全是这样。
- en: Performance for real-time applications
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实时应用的性能
- en: A real-time program must keep up with the events it is processing at all times.
    An audio processor must keep up with speech, in particular. If the program can
    process audio ten times faster than a person can speak, it does us no good, and
    we may as well turn our attention to power consumption.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 实时程序必须始终跟上它正在处理的事件。音频处理器必须特别跟上语音。如果程序可以比人说话的速度快十倍处理音频，那对我们毫无用处，我们可能还不如把注意力转向功耗。
- en: On the other hand, if the program occasionally falls behind, some sounds or
    even words will be dropped. This suggests that the real time, or speed, matters
    up to a point, but it must be delivered in a predictable manner.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果程序偶尔落后，一些声音甚至单词将被丢弃。这表明实时或速度在一定程度上很重要，但必须以可预测的方式交付。
- en: 'There is, of course, a performance metric for that as well: the latency tail.
    The latency is the delay, in our case, between the time the data is ready (voice
    recorded) and the time when the processing is completed. The throughput metric
    we saw earlier reflects the average time to process the sound: if we speak for
    one hour into the phone, how long will it take for the audio processor to do all
    the computations it needs to do? But what really matters in this context is that
    each little computation for every sound is done on time.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这也有一个性能指标：延迟尾部。延迟是在我们的情况下数据准备好（录音）和处理完成之间的延迟。我们之前看到的吞吐量指标反映了处理声音的平均时间：如果我们在手机上说话一个小时，音频处理器需要多长时间来完成所有需要做的计算？但在这种情况下真正重要的是，每个声音的每个小计算都按时完成。
- en: 'At a low level, the computation speed fluctuates: sometimes, the computation
    finishes faster, and sometimes it takes longer. As long as the average speed is
    acceptable, what matters are the rare long delays.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在低级别上，计算速度会波动：有时计算会更快完成，有时会花费更长时间。只要平均速度可接受，重要的是罕见的长时间延迟。
- en: 'The latency tail metric is computed as a particular percentile of the delay,
    for example, at the 95th percentile: if *t* is the 95th percentile latency, then
    95% of all computations take less time than *t*. The metric itself is the ratio
    of the 95th percentile time *t* to the average compute time *t*0 (it is often
    expressed as a percentage as well, so a 30% latency at the 95th percentile means
    that *t* is 30% greater than *t*0):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟尾部指标是计算作为延迟的特定百分位数的，例如，在95th百分位数：如果*t*是95th百分位数的延迟，那么95%的所有计算所花费的时间都比*t*少。指标本身是95th百分位时间*t*与平均计算时间*t*0的比率（通常也以百分比表示，因此95th百分位数的30%延迟意味着*t*比*t*0大30%）：
- en: '![Figure 1.7 – 95% latency of four different implementations of the same algorithm
    (percents)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.7 - 相同算法的四种不同实现的95%延迟（百分比）'
- en: '](img/Figure_1.7_B16229.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.7_B16229.jpg)'
- en: Figure 1.7 – 95% latency of four different implementations of the same algorithm
    (percents)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 - 相同算法的四种不同实现的95%延迟（百分比）
- en: 'We now see that **Program B**, which computes the results faster than any other
    implementation, on average, also delivers the most unpredictable run time results,
    while **Program D**, which never stood out before, computes like clockwork and
    takes practically the same time to do a given computation, every time. As we have
    already observed, program D also has the worst power consumption. This is, unfortunately,
    not uncommon because the techniques that make the program more power-efficient,
    on average, are probabilistic in nature: they speed up the computations most of
    the time, but not every time.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在看到，**程序B**比任何其他实现平均计算结果更快，但也提供了最不可预测的运行时间结果，而**程序D**以前从未突出，却像钟表一样计算，并且每次执行给定的计算几乎需要相同的时间。正如我们已经观察到的，程序D还具有最糟糕的功耗。不幸的是，这并不罕见，因为使程序在平均情况下更节能的技术通常具有概率性质：它们大多数时候加快计算速度，但并非每次都是如此。
- en: So, which program is the best? The answer, of course, depends on the application
    and even then may be non-obvious.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，哪个程序最好？当然，答案取决于应用，甚至在这种情况下可能并不明显。
- en: Performance as dependent on context
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能取决于上下文
- en: 'If this was simulation software that runs in a large data center and takes
    days to compute, the throughput would be the king. On a battery-powered device,
    power consumption is usually the most important. In a more complex environment,
    such as our real-time audio processor, it is the combination of multiple factors.
    The average run time matters, of course, but only until it becomes "fast enough."
    If the speaker cannot notice the delays, then making it even faster has no reward.
    Latency tail matters: users hate it when a word is dropped from the conversation
    every now and then. Once the latency is good enough that the call quality is limited
    by other factors, improving it further gives very little benefit; we would be
    better off conserving power at this point.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是在大型数据中心运行并需要数天来计算的仿真软件，吞吐量将是关键。在电池供电设备上，功耗通常是最重要的。在更复杂的环境中，比如我们的实时音频处理器，它是多个因素的组合。平均运行时间当然很重要，但只有在变得“足够快”之前才重要。如果听众察觉不到延迟，那么使其更快也没有奖励。延迟尾部很重要：用户讨厌每隔一段时间会有一个词从对话中丢失。一旦延迟足够好，通话质量受到其他因素的限制，进一步改善将带来很少的好处；在这一点上，我们最好节约功耗。
- en: We now understand that, unlike efficiency, performance is always defined with
    respect to specific metrics, that these metrics depend on the application and
    the problem we're solving, and that for some metrics, there is such a thing as
    "good enough" when other metrics come to the foreground. The efficiency, which
    reflects the utilization of the computational resources, is one of the ways to
    achieve good performance, the most common way, perhaps, but not the only one.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在明白，与效率不同，性能总是针对特定的度量标准定义的，这些度量标准取决于我们正在解决的应用和问题，对于某些度量标准来说，存在“足够好”的概念，当其他度量标准成为前景时。效率，反映了计算资源的利用，是实现良好性能的方式之一，也许是最常见的方式，但不是唯一的方式。
- en: Evaluating, estimating, and predicting performance
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估、估计和预测性能
- en: 'As we have just seen, the notion of metrics is fundamental to the concept of
    performance. With metrics, there is always the implied possibility and necessity
    of measurements: if we say "we have a metric," it implies that we have a way of
    quantifying and measuring something, and the only way to find out the value of
    the metric is to measure it.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚刚看到的，度量的概念对性能概念至关重要。有了度量，总是隐含着测量的可能性和必要性：如果我们说“我们有一个度量”，那就意味着我们有一种量化和测量某事的方法，而了解度量的值的唯一方法就是测量它。
- en: The importance of measuring performance cannot be overstated. It is often said
    that the first law of performance is never to guess about performance. The very
    next chapter in this book is dedicated to performance measurements, measurement
    tools, how to use them, and how to interpret the results.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 测量性能的重要性不言而喻。人们常说，性能的第一定律是永远不要猜测性能。本书的下一章专门讨论性能测量、测量工具、如何使用它们以及如何解释结果。
- en: 'Guessing about performance is, unfortunately, all too widespread. So are overly
    general statements like "avoid using virtual functions in C++, they are slow."
    The problem with such statements is not that they are imprecise, that is, they
    do not reference a metric of how much slower a virtual function is, compared to
    a non-virtual one. As an exercise for the reader, here are several answers to
    choose from, all quantified:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，对性能的猜测太过普遍。像“避免在C++中使用虚函数，它们很慢”这样过于笼统的陈述也是如此。这类陈述的问题不在于它们不精确，即它们没有提及虚函数相对于非虚函数慢多少的度量标准。作为读者的练习，这里有几个可供选择的量化答案：
- en: A virtual function is 100% slower
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚函数慢100%
- en: A virtual function is about 15-20% slower
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚函数大约慢15-20%
- en: A virtual function is negligibly slower
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚函数几乎没有慢
- en: A virtual function is 10-20% faster
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚函数快10-20%
- en: A virtual function is 100 times slower
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚函数慢100倍
- en: 'Which is the right answer? If you selected any one of these answers, congratulations:
    you have chosen the correct answer. That is right, each of these answers is correct
    under certain circumstances and within a specific context (to learn why, you will
    have to wait until [*Chapter 9*](B16229_09_Epub_AM.xhtml#_idTextAnchor149), *High-Performance
    C++*).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个答案是正确的？如果您选择了其中任何一个答案，恭喜您：您选择了正确答案。没错，每个答案在特定情况和特定上下文中都是正确的（要了解原因，您将不得不等到[*第9章*](B16229_09_Epub_AM.xhtml#_idTextAnchor149)，*高性能C++*）。
- en: 'Unfortunately, by accepting the truth that it is almost impossible to intuit
    or guess about performance, we risk falling into another trap: using it as an
    excuse to write inefficient code "to be optimized later" because *we don''t guess
    about performance*. While true, the latter maxim can be taken too far, just like
    the popular dictum *do not optimize prematurely*.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，通过接受几乎不可能直觉或猜测性能的真相，我们面临着另一个陷阱：将其作为写出效率低下的代码的借口“以后进行优化”的借口，因为*我们不猜测性能*。虽然这是真的，但后一种最大化可能会走得太远，就像流行的格言*不要过早优化*一样。
- en: 'Performance cannot be added to the program later, so it should not be an afterthought
    during the initial design and development. Performance considerations and targets
    have their place at the design stage, just like other design goals. There is a
    definite tension between these early performance-related goals and the rule to
    never guess about performance. We have to find the right compromise, and a good
    way to describe what we really want to accomplish at the design stage with regard
    to performance is this: while it''s almost impossible to predict the best optimizations
    in advance, it is possible to identify design decisions that would make subsequent
    optimizations very hard or even unfeasible.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 性能不能后期添加到程序中，因此在初始设计和开发过程中不应该被忽视。性能考虑和目标在设计阶段有其位置，就像其他设计目标一样。早期与性能相关的目标与永远不要猜测性能之间存在明显的紧张关系。我们必须找到正确的折衷方案，描述我们在设计阶段真正想要实现的关于性能的目标的一个好方法是：虽然几乎不可能预测最佳的优化，但可以确定会使后续优化非常困难甚至不可行的设计决策。
- en: 'The same holds later, during program development: it is foolish to spend long
    hours optimizing a function that ends up being called once a day and takes only
    a second. On the other hand, it is very wise to encapsulate this code into a function
    in the first place, so if the use patterns change as the program evolves, it *can*
    be optimized later without rewriting the rest of the program.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的情况也适用于程序开发过程中：在优化一个每天只调用一次且只需要一秒钟的函数上花费很长时间是愚蠢的。另一方面，最好一开始就将这段代码封装成一个函数，这样如果程序发展时使用模式发生变化，它*可以*在不重写程序的情况下进行优化。
- en: Another way to describe the limitations of the *do not optimize prematurely*
    rule is to qualify it by saying *yes, but do not pessimize intentionally either*.
    Recognizing the difference between the two requires knowledge of good design practices
    as well as an understanding of different aspects of programming for high performance.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 描述“不要过早优化”的规则的限制的另一种方法是通过说“是的，但也不要故意使性能变差”。识别两者之间的区别需要对良好设计实践的了解，以及对高性能编程的不同方面的理解。
- en: So, what do you, as a developer/programmer, need to learn and understand in
    order to become proficient in developing high-performance applications? In the
    next section, we will start with an abbreviated list of these goals before diving
    into each of them in detail.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，作为开发人员/程序员，为了精通开发高性能应用程序，您需要学习和了解什么？在下一节中，我们将从一个简略的目标列表开始，然后详细讨论每个目标。
- en: Learning about high performance
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习高性能
- en: 'What makes a program high-performing? We could say "efficiency," but, first
    of all, this is not always true (although often it is), and second, it just begs
    the question, because the next obvious question becomes, OK, what makes the program
    efficient? And what do we need to learn in order to write efficient or high-performing
    programs? Let''s make a general list of the required skills and knowledge:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 什么使程序高性能？我们可以说“效率”，但首先，这并不总是正确的（尽管通常是），其次，这只是在回避问题，因为下一个明显的问题是，好吧，什么使程序高效？我们需要学习什么才能编写高效或高性能的程序？让我们列出所需的技能和知识：
- en: Choosing the right algorithm
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择正确的算法
- en: Using CPU resources effectively
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效地利用CPU资源
- en: Using memory effectively
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效地使用内存
- en: Avoiding unnecessary computations
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免不必要的计算
- en: Using concurrency and multi-threading effectively
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效地使用并发和多线程
- en: Using the programming language effectively, avoiding inefficiencies
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效地使用编程语言，避免低效率
- en: Measuring performance and interpreting results
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 衡量性能和解释结果
- en: The most important factor in achieving high performance is choosing a good algorithm.
    One cannot "fix" a bad algorithm by optimizing the implementation. However, this
    is also the one factor that is outside of the scope of this book. The algorithms
    are problem-specific, and this is not a book on algorithms. You will have to do
    your own research to find the best ones for the problem you are facing.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 实现高性能最重要的因素是选择一个好的算法。不能通过优化实现来“修复”一个糟糕的算法。然而，这也是本书范围之外的因素。算法是特定于问题的，这不是一本关于算法的书。您将不得不进行自己的研究，以找到最适合您所面临问题的最佳算法。
- en: 'The methods and techniques to achieve high performance, on the other hand,
    are largely problem-agnostic. They do depend on the performance metrics, of course:
    for example, the optimization of real-time systems is a highly specific area with
    many idiosyncratic problems. In this book, we largely focus on the metrics of
    performance in the high-performance computing sense: doing a lot of computations
    as fast as possible.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，实现高性能的方法和技术在很大程度上与问题无关。当然，它们确实取决于性能指标：例如，实时系统的优化是一个具有许多特殊问题的高度特定领域。在本书中，我们主要关注高性能计算意义上的性能指标：尽快进行大量计算。
- en: 'In order to succeed in this quest, we have to learn to use as much of the available
    computing hardware as possible. This goal has a spatial and temporal component:
    in terms of space, we''re talking about utilizing more of the transistors that
    the processor has in such huge numbers. The processors are becoming larger, if
    not faster. What is the added area used for? Presumably, it adds some new computing
    capabilities that we could use. In terms of time, we mean that we should be using
    as much hardware as possible at every time. Either way, computing resources are
    of no use to us if they are idle, so the goal is to avoid that. At the same time,
    busywork does not pay off, and we want to avoid doing anything we don''t absolutely
    need to. This is not as obvious as it sounds; there are a lot of subtle ways your
    program could be doing computations you do not need.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在这个探索中取得成功，我们必须尽可能多地利用可用的计算硬件。这个目标有一个空间和时间的组成部分：在空间方面，我们谈论的是利用处理器中如此庞大数量的晶体管。处理器变得更大，如果不是更快。额外的区域用于什么？可能是增加了一些新的计算能力，我们可以利用。在时间方面，我们的意思是我们应该尽可能多地利用每个时间的硬件。无论如何，如果计算资源处于空闲状态，对我们来说是没有用的，所以目标是避免这种情况。与此同时，繁重的工作并不划算，我们希望避免做任何我们绝对不需要做的事情。这并不像听起来那么明显；你的程序可能以很多微妙的方式进行计算，而这些计算是你不需要的。
- en: In this book, we will start with a single processor and learn to use its computational
    resources efficiently. We will then expand our view to include not just the processor
    but also its memory. Then, naturally, we will look at using multiple processors
    at once.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将从单个处理器开始，学会高效地利用其计算资源。然后，我们将扩大视野，不仅包括处理器，还包括其内存。然后，自然地，我们将研究如何同时使用多个处理器。
- en: 'But using the hardware efficiently is only one of the necessary qualities of
    a high-performing program: it does us no good to efficiently do the work that
    could have been avoided in the first place. The key to not creating unnecessary
    work is the effective use of the programming language, in our case, C++ (most
    of what we learn about the hardware can be applied to any language, but some of
    the language optimization techniques are very specific to C++). Furthermore, the
    compilers stand between the language that we write in and the hardware that we
    use, so we must learn how to use the compilers to produce the most efficient code.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，高性能程序的必要品质之一是高效地使用硬件：高效地完成本来可以避免的工作对我们没有好处。不创造不必要的工作的关键是有效地使用编程语言，对我们来说是C++（我们学到的大部分关于硬件的知识都可以应用到任何语言，但一些语言优化技术非常特定于C++）。此外，编译器位于我们编写的语言和我们使用的硬件之间，因此我们必须学会如何使用编译器来生成最有效的代码。
- en: 'Finally, the only way to quantify the degree of success for any of the goals
    we just listed is to measure it: how much of the CPU resources are we using? How
    much time do we spend waiting for memory? What is the performance gain achieved
    by adding another thread? And so on. Obtaining good quantitative performance data
    is not easy; it requires a thorough understanding of the measurement tools. Interpreting
    the results is often even harder.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，衡量我们刚才列出的任何目标的成功程度的唯一方法是对其进行测量：我们使用了多少CPU资源？我们花了多少时间等待内存？增加另一个线程带来了多少性能提升？等等。获得良好的定量性能数据并不容易；这需要对测量工具有深入的了解。解释结果通常更加困难。
- en: You can expect to learn these skills from this book. We will learn about the
    hardware architecture, and what is hidden behind some programming language features,
    and how to see our code the way the compilers see it. These skills are important,
    but what is even more important is to understand why things work the way they
    do. The computing hardware changes fairly often, the languages evolve, and new
    optimization algorithms for the compilers are invented. Thus, the specific knowledge
    in any of these areas has a fairly short shelf life. However, if you understand
    not just the best ways to use a particular processor or compiler but also the
    ways in which we have arrived at this knowledge, you will be well prepared to
    repeat this process of discovery and, therefore, continue to learn.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从这本书中学到这些技能。我们将学习硬件架构，以及一些编程语言特性背后的隐藏内容，以及如何像编译器一样看待我们的代码。这些技能很重要，但更重要的是理解为什么事情会以这样的方式运作。计算硬件经常发生变化，语言不断发展，编译器的新优化算法也在不断发明。因此，任何这些领域的具体知识都有相当短的保质期。然而，如果你不仅理解了使用特定处理器或编译器的最佳方法，还理解了我们得出这些知识的方式，你将能够很好地准备重复这个发现过程，因此继续学习。
- en: Summary
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this introductory chapter, we have discussed why the interest in software
    performance and efficiency is on the rise despite the rapid advances in the raw
    computational power of modern computers. Specifically, we have learned why, in
    order to understand the factors limiting performance and how to overcome them,
    we need to return to the basic elements of computing and understand how computers
    and programs work at a low level: understanding the hardware and using it efficiently,
    understanding concurrency, understanding the C++ language features and the compiler
    optimizations, and their impact on performance.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个介绍性的章节中，我们讨论了为什么尽管现代计算机的原始计算能力迅速增长，但对软件性能和效率的兴趣却在上升。具体来说，我们了解了为什么为了理解限制性能的因素以及如何克服它们，我们需要回到计算的基本元素，并了解计算机和程序在低级别上的工作方式：理解硬件并高效地使用它，理解并发性，理解C++语言特性和编译器优化，以及它们对性能的影响。
- en: 'This low-level knowledge is necessarily very detailed and specific, but we
    have a plan for dealing with that: as we learn specific facts about the processors
    or compilers, we will also learn the process by which we have arrived at these
    conclusions. Thus, at its deepest level, this book is about learning how to learn.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这种低级知识必然非常详细和具体，但我们有一个处理这个问题的计划：当我们学习处理器或编译器的具体事实时，我们也会学习到我们得出这些结论的过程。因此，从最深层次来看，这本书是关于学习如何学习的。
- en: We have further understood that the notion of performance is meaningless without
    defining the metrics by which this performance is measured. The need to evaluate
    the performance against the specific metrics implies that any work on performance
    is driven by data and measurements. Indeed, the next chapter is dedicated to measuring
    performance.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进一步了解到，如果不定义衡量绩效的指标，绩效的概念就毫无意义。对特定指标评估绩效的需要意味着任何绩效工作都是由数据和测量驱动的。事实上，下一章将专门讨论绩效的测量。
- en: Questions
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why is program performance important despite advances in processing power?
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管处理能力有所提高，为什么程序绩效仍然重要？
- en: Why does understanding software performance require low-level knowledge of the
    computing hardware and programming languages?
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么理解软件绩效需要对计算硬件和编程语言有低层次的了解？
- en: What is the difference between performance and efficiency?
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绩效和效率之间有什么区别？
- en: Why must performance be defined with respect to specific metrics?
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么绩效必须根据特定指标来定义？
- en: How can we judge whether the performance-related goals for specific metrics
    are accomplished?
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何判断特定指标的绩效目标是否已经实现？
