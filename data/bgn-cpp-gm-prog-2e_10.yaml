- en: '*Chapter 9*: C++ References, Sprite Sheets, and Vertex Arrays'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：C++引用、精灵图集和顶点数组'
- en: In [*Chapter 4*](B14278_04_Final_AG_ePub.xhtml#_idTextAnchor110), *Loops, Arrays,
    Switches, Enumerations, and Functions – Implementing Game Mechanics*, we talked
    about scope. This is the concept that variables declared in a function or inner
    block of code only have scope (that is, can be *seen* or used) in that function
    or block. Using only the C++ knowledge we have currently, this can cause a problem.
    What do we do if we need to work on a few complex objects that are needed in the
    `main` function? This could imply all the code must be in the `main` function.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B14278_04_Final_AG_ePub.xhtml#_idTextAnchor110)，“循环、数组、开关、枚举和函数 – 实现游戏机制”中，我们讨论了作用域的概念。这个概念是指函数或代码内部块中声明的变量只在该函数或块中具有作用域（即，可以被*看到*或使用）。仅使用我们目前所拥有的C++知识，这可能会导致问题。如果我们需要在`main`函数中处理几个复杂的对象，我们会怎么做？这可能意味着所有代码都必须放在`main`函数中。
- en: In this chapter, we will explore C++ **references**, which allow us to work
    on variables and objects that are otherwise out of scope. In addition to this,
    these references will help us avoid having to pass large objects between functions,
    which is a slow process. It is slow because each time we do this, a copy of the
    variable or object must be made.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨C++ **引用**，它允许我们处理那些通常超出作用域的变量和对象。此外，这些引用将帮助我们避免在函数之间传递大型对象，这是一个缓慢的过程。这是因为每次我们这样做时，都必须制作变量或对象的副本。
- en: Armed with this new knowledge of references, we will look at the SFML `VertexArray`
    class, which allows us to build up a large image that can be quickly and efficiently
    drawn to the screen using multiple parts in a single image file. By the end of
    this chapter, we will have a scalable, random, scrolling background that's been
    made using references and a `VertexArray` object.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 带着对引用的新知识，我们将探讨SFML的`VertexArray`类，它允许我们构建一个大型图像，可以通过单个图像文件中的多个部分快速有效地绘制到屏幕上。到本章结束时，我们将拥有一个可缩放的、随机的、滚动的背景，它是通过引用和`VertexArray`对象制作的。
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: C++ references
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++引用
- en: SFML vertex arrays
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SFML顶点数组
- en: Coding a random, scrolling background
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写随机滚动的背景
- en: C++ references
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++引用
- en: When we pass values to a function or return values from a function, that is
    exactly what we are doing – passing/returning by **value**. What happens is that
    a copy of the value held by the variable is made and then sent to the function,
    where it is used.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将值传递给函数或从函数返回值时，这正是我们所做的——通过**值**传递/返回。发生的情况是，变量所持有的值的副本被制作并发送到函数，在那里它被使用。
- en: 'The significance of this is twofold:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这的重要性有两方面：
- en: If we want the function to make a permanent change to a variable, this system
    is no good to us.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们希望函数对变量进行永久性更改，这个系统对我们来说毫无用处。
- en: When a copy is made to pass in as an argument or returned from the function,
    processing power and memory are consumed. For a simple `int`, or even perhaps
    a `Sprite`, this is insignificant. However, for a complex object, perhaps an entire
    game world (or background), the copying process will seriously affect our game's
    performance.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当复制值作为参数传递或从函数返回时，会消耗处理能力和内存。对于简单的`int`，甚至可能是一个`Sprite`，这微不足道。然而，对于复杂的对象，比如整个游戏世界（或背景），复制过程将严重影响我们的游戏性能。
- en: 'References are the solution to these two problems. A **reference** is a special
    type of variable. A reference *refers* to another variable. Here is an example
    to help you understand this better:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献是解决这两个问题的方案。**引用**是一种特殊的变量类型。引用*指向*另一个变量。以下是一个例子，帮助您更好地理解这一点：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, we declare and initialize a regular `int` called `numZombies`.
    We then declare and initialize an `int` reference called `rNumZombies`. The reference
    operator, `&`, which follows the type, determines that a reference is being declared.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明并初始化了一个名为`numZombies`的普通`int`变量。然后我们声明并初始化了一个名为`rNumZombies`的`int`引用。引用操作符`&`位于类型之后，表明正在声明一个引用。
- en: Tip
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `r` prefix at the front of the reference name is optional but is useful
    for remembering that we are dealing with a reference.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 引用名称前面的`r`前缀是可选的，但有助于记住我们正在处理一个引用。
- en: Now, we have an `int` variable called `numZombies`, which stores the value 100,
    and an `int` reference called `rNumZombies`, which refers to `numZombies`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个名为`numZombies`的`int`变量，它存储的值是100，还有一个名为`rNumZombies`的`int`引用，它指向`numZombies`。
- en: 'Anything we do to `numZombies` can be seen through `rNumZombies`, and anything
    we do to `rNumZombies` we are actually doing to `numZombies`. Take a look at the
    following code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 `numZombies` 所做的任何操作都可以通过 `rNumZombies` 看到并且我们对 `rNumZombies` 所做的任何操作实际上是对
    `numZombies` 的操作。看看以下代码：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the previous code, we declare an `int` called `score`. Next, we declare an
    `int` reference called `rScore` that refers to `score`. Remember that anything
    we do to `score` can be seen by `rScore` and anything we do to `rScore` is actually
    being done to `score`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们声明了一个名为 `score` 的 `int` 变量。接下来，我们声明了一个名为 `rScore` 的 `int` 引用，它指向 `score`。记住，我们对
    `score` 所做的任何操作都可以被 `rScore` 看到并且我们对 `rScore` 所做的任何操作实际上是对 `score` 的操作。
- en: 'Therefore, consider what happens when we increment `score` like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，考虑当我们这样增加 `score` 时会发生什么：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `score` variable now stores the value 11\. In addition to this, if we were
    to output `rScore`, it would also output 11\. The next line of code is as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`score` 变量现在存储的值是 11。除此之外，如果我们输出 `rScore`，它也会输出 11。下一行代码如下：'
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, `score` actually holds the value 12 because anything we do to `rScore`
    is actually done to `score`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`score` 实际上持有值 12，因为我们对 `rScore` 所做的任何操作实际上是对 `score` 的操作。
- en: Tip
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want to know *how* this works, then more will be revealed in the next
    chapter when we discuss **pointers**. But simply put, you can consider a reference
    as storing a place/address in the computer's memory. That place in memory is the
    same place where the variable it refers to stores its value. Therefore, an operation
    on either the reference or the variable has exactly the same effect.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道 *它是如何工作的*，那么在下一章中我们将讨论 **指针** 时会有更多的揭示。简单来说，你可以将引用视为存储在计算机内存中的位置/地址。这个内存中的位置与它所引用的变量存储其值的位置相同。因此，对引用或变量的操作具有完全相同的效果。
- en: 'For now, it is much more important to talk about the *why* of references. There
    are two reasons to use references, and we have already mentioned them. Here they
    are, summarized again:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，更重要的是讨论引用的 *原因*。使用引用有两个原因，我们已经在前面提到了。这里它们是，再次总结：
- en: Changing/reading the value of a variable/object in another function, which is
    otherwise out of scope.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个函数中更改/读取变量的值/对象，该函数否则不在作用域内。
- en: Passing/returning to/from a function without making a copy (and, therefore,
    more efficiently).
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不进行复制（因此更高效）地传递/返回函数。
- en: 'Study the following code and then we will discuss it:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 研究以下代码，然后我们将讨论它：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The previous code begins with the prototypes of two functions: `add` and `referenceAdd`.
    The `add` function takes three `int` variables while the `referenceAdd` function
    takes two `int` variables and an `int` reference.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码以两个函数的原型开始：`add` 和 `referenceAdd`。`add` 函数接受三个 `int` 变量，而 `referenceAdd`
    函数接受两个 `int` 变量和一个 `int` 引用。
- en: When the `add` function is called and the `number1`, `number2`, and `answer`
    variables are passed in, a copy of the values is made and new variables local
    to `add` (that is, `n1`, `n2`, and `a`) are manipulated. As a result of this,
    `answer`, back in `main`, remains at zero.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `add` 函数时，将 `number1`、`number2` 和 `answer` 变量传递进去，会制作值的副本，并操作 `add` 函数中局部的新变量（即
    `n1`、`n2` 和 `a`）。因此，`main` 中的 `answer` 保持为零。
- en: When the `referenceAdd` function is called, `number1` and `number2` are again
    passed by value. However, `answer` is passed by reference. When the value of `n1`
    that's added to `n2` is assigned to the reference, `a`, what is really happening
    is that the value is assigned to `answer` back in the `main` function.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `referenceAdd` 函数时，`number1` 和 `number2` 再次按值传递。然而，`answer` 是按引用传递的。当将加到
    `n2` 上的 `n1` 的值赋给引用 `a` 时，实际上发生的是这个值被赋回到 `main` 函数中的 `answer`。
- en: It is probably obvious that we would never need to use a reference for something
    this simple. It does, however, demonstrate the mechanics of passing by reference.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，我们永远不会需要为这样简单的事情使用引用。然而，这确实演示了按引用传递的机制。
- en: Let's summarize what we know about references.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下我们对引用的了解。
- en: References summary
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用总结
- en: The previous code demonstrated how a reference can be used to alter the value
    of a variable in one scope using code in another. As well as being extremely convenient,
    passing by reference is also very efficient because no copy is made. Our example,
    that is, using a reference to an `int`, is a bit ambiguous because, as an `int`
    is so small, there is no real efficiency gain. Later on in this chapter, we will
    use a reference to pass an entire level layout and the efficiency gain will be
    significant.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码演示了如何使用引用通过在另一个作用域中的代码来改变变量的值。除了非常方便之外，通过引用传递也非常高效，因为它没有进行复制。我们的例子，即使用引用来传递一个
    `int`，有点含糊不清，因为作为一个 `int` 非常小，所以没有真正的效率提升。在本章后面，我们将使用引用来传递整个关卡布局，效率提升将是显著的。
- en: Tip
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: There is one gotcha with references! You must assign the reference to a variable
    at the time you create it. This means it is not completely flexible. Don't worry
    about this for now. We will explore references further alongside their more flexible
    (and slightly more complicated) relations, such as **pointers**, in the next chapter.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 关于引用有一个需要注意的地方！您必须在创建引用时将其分配给一个变量。这意味着它并不完全灵活。现在不用担心这个问题。我们将在下一章进一步探讨引用，以及它们更灵活（并且稍微复杂一些）的关系，例如**指针**。
- en: This is largely irrelevant for an `int`, but potentially significant for a large
    object of a class. We will use this exact technique when we implement the scrolling
    background of the Zombie Arena game later on in this chapter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于 `int` 类型来说在很大程度上是不相关的，但对于一个大型类对象来说可能具有潜在的重要性。在我们本章后面实现僵尸竞技场游戏的滚动背景时，我们将使用这种精确的技术。
- en: SFML vertex arrays and sprite sheets
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SFML 顶点数组和精灵表
- en: We are nearly ready to implement the scrolling background. We just need to learn
    about SFML vertex arrays and sprite sheets.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎准备好实现滚动背景了。我们只需要了解 SFML 顶点数组和精灵表。
- en: What is a sprite sheet?
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是精灵表？
- en: 'A **sprite sheet** is a set of images, either frames of animation, or totally
    individual graphics contained in one image file. Take a closer look at this sprite
    sheet, which contains four separate images that will be used to draw the background
    in our Zombie Arena game:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵表**是一组图像，可以是动画帧，也可以是包含在一个图像文件中的完全独立的图形。仔细看看这个精灵表，它包含四个单独的图像，这些图像将被用来在我们的僵尸竞技场游戏中绘制背景：'
- en: '![](img/B14278_09_01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14278_09_01.jpg)'
- en: SFML allows us to load a sprite sheet as a regular texture, in the same way
    we have done for every texture in this book so far. When we load multiple images
    as a single texture, the GPU can handle it much more efficiently.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: SFML 允许我们将精灵表加载为常规纹理，就像我们在这本书中迄今为止为每个纹理所做的那样。当我们将多个图像作为单个纹理加载时，GPU 可以更高效地处理它。
- en: Tip
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Actually, a modern PC could handle these four textures without using a sprite
    sheet. It is worth learning these techniques, however, as our games are going
    to start getting progressively more demanding on our hardware.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，现代 PC 可以不使用精灵表就处理这四个纹理。然而，学习这些技术是值得的，因为我们的游戏将开始对我们的硬件提出越来越高的要求。
- en: 'What we need to do when we draw an image from the sprite sheet is make sure
    we refer to the precise pixel coordinates of the part of the sprite sheet we require,
    like so:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从精灵表中绘制图像时，我们需要确保我们引用的是所需的精灵表部分的精确像素坐标，如下所示：
- en: '![](img/B14278_09_02.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14278_09_02.jpg)'
- en: The previous diagram labels each part/tile with the coordinates and their position
    within the sprite sheet. These coordinates are called **texture coordinates**.
    We will use these texture coordinates in our code to draw just the right parts
    that we require.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的图例用坐标和它们在精灵表中的位置标记了每个部分/瓦片。这些坐标被称为**纹理坐标**。我们将在我们的代码中使用这些纹理坐标来绘制所需的正确部分。
- en: What is a vertex array?
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是顶点数组？
- en: First, we need to ask, what is a vertex? A **vertex** is a single graphical
    point, that is, a coordinate. This point is defined by a horizontal and vertical
    position. The plural of vertex is vertices. A vertex array, then, is a whole collection
    of vertices.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要问，什么是顶点？**顶点**是一个单独的图形点，即一个坐标。这个点由水平和垂直位置定义。顶点的复数形式是 vertices。因此，顶点数组就是顶点的整个集合。
- en: In SFML, each vertex in a vertex array also has a color and a related additional
    vertex (that is, a pair of coordinates) called **texture coordinates**. Texture
    coordinates are the position of the image we want to use in terms of a sprite
    sheet. Later, we will see how we can position graphics and choose a part of the
    sprite sheet to display at each position, all with a single vertex array.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在SFML中，顶点数组中的每个顶点都有一个颜色和相关的附加顶点（即一对坐标），称为**纹理坐标**。纹理坐标是我们想要在精灵图中使用的图像的位置。稍后，我们将看到我们如何使用单个顶点数组来定位图形和选择精灵图中要显示的每个位置的部分。
- en: The SFML `VertexArray` class can hold different types of vertex sets. But each
    `VertexArray` should only hold one type of set. We use the type of set that suits
    the occasion.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: SFML的`VertexArray`类可以持有不同类型的顶点集。但每个`VertexArray`只能持有一种类型的集。我们使用适合场合的集类型。
- en: 'Common scenarios in video games include, but are not limited to, the following
    **primitive** types:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 视频游戏中的常见场景包括但不限于以下**原语**类型：
- en: '**Point**: A single vertex per point.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**点**: 每个点一个顶点。'
- en: '**Line**: Two vertices per set that define the start and endpoint of the line.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线**: 每组有两个顶点，定义了线的起点和终点。'
- en: '**Triangle**: Three vertices per point. This is the most commonly used (in
    the thousands) for complex 3D models, or in pairs to create a simple rectangle
    such as a sprite.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**三角形**: 每个点有三个顶点。这是在复杂3D模型中最常用（成千上万）的，或者成对使用来创建一个简单的矩形，如精灵。'
- en: '**Quad**: Four vertices per set. This is a convenient way to map rectangular
    areas from a sprite sheet.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**四边形**: 每组有四个顶点。这是从精灵图中映射矩形区域的一种方便方式。'
- en: We will use quads in this project.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本项目中使用四边形。
- en: Building a background from tiles
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从瓷砖构建背景
- en: The Zombie Arena background will be made up of a random arrangement of square
    images. You can think of this arrangement like tiles on a floor.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 僵尸竞技场背景将由随机排列的方形图像组成。你可以将这种排列想象成地板上的瓷砖。
- en: In this project, we will be using vertex arrays with **quad** sets. Each vertex
    will be part of a set of four (that is, a quad). Each vertex will define one corner
    of a tile from our background, while each texture coordinate will hold an appropriate
    value based on a specific image from the sprite sheet.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目中，我们将使用带有**四边形**集的顶点数组。每个顶点将是一个由四个顶点组成的集合的一部分（即一个四边形）。每个顶点将定义背景中的一个瓷砖的角落，而每个纹理坐标将根据精灵图中的特定图像持有适当的值。
- en: Let's look at some code to get us started. This isn't the exact code we will
    use in the project, but it is close and allows us to study vertex arrays before
    we move on to the actual implementation we will use.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些代码以帮助我们开始。这不是我们在项目中将使用的确切代码，但它很接近，并允许我们在进行实际实现之前研究顶点数组。
- en: Building a vertex array
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建顶点数组
- en: 'As we do when we create an instance of a class, we declare our new object.
    The following code declares a new object of the `VertexArray` type, called `background`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在创建类实例时做的那样，我们声明我们的新对象。以下代码声明了一个新的`VertexArray`类型的对象，名为`background`：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We want to let our instance of `VertexArray` know which type of primitive we
    will be using. Remember that points, lines, triangles, and quads all have a different
    number of vertices. By setting the `VertexArray` instance to hold a specific type,
    it will be possible to know the start of each primitive. In our case, we want
    quads. Here is the code that will do this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望让我们的`VertexArray`实例知道我们将使用哪种类型的原语。记住，点、线、三角形和四边形都有不同数量的顶点。通过将`VertexArray`实例设置为特定类型，将能够知道每个原语的开始。在我们的情况下，我们想要四边形。以下是实现这一点的代码：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As with regular C++ arrays, a `VertexArray` instance needs to be set to a particular
    size. The `VertexArray` class is more flexible than a regular array, however.
    It allows us to change its size while the game is running. The size could be configured
    at the same time as the declaration, but our background needs to expand with each
    wave. The `VertexArray` class provides this functionality with the `resize` function.
    Here is the code that would set the size of our arena to a 10 by 10 tile size:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 就像常规C++数组一样，`VertexArray`实例需要设置到特定的大小。然而，`VertexArray`类比常规数组更灵活。它允许我们在游戏运行时更改其大小。大小可以在声明时配置，但我们的背景需要随着每一波而扩展。`VertexArray`类通过`resize`函数提供了这种功能。以下是设置我们的竞技场大小为10x10瓷砖大小的代码：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the previous line of code, the first `10` is the width, the second `10` is
    the height, and 4 is the number of vertices in a quad. We could have just passed
    in 400, but showing the calculation like this makes it clear what we are doing.
    When we code the project for real, we will go a step further to aid clarity and
    declare variables for each part of the calculation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行代码中，第一个 `10` 是宽度，第二个 `10` 是高度，4 是四边形中的顶点数。我们本可以直接传递 400，但这样展示计算过程可以使我们清楚我们在做什么。当我们真正编写项目代码时，我们将进一步采取步骤以增加清晰度，并为计算的每个部分声明变量。
- en: 'We now have a `VertexArray` instance ready to have its hundreds of vertices
    configured. Here is how we set the position coordinates on the first four vertices
    (that is, the first quad):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个 `VertexArray` 实例，可以配置其数百个顶点。以下是我们在前四个顶点上设置位置坐标的方法（即第一个四边形）：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is how we set the texture coordinates of these same vertices to the first
    image in the sprite sheet. These coordinates in the image file are from 0,0 (in
    the top-left corner) to 49,49 (in the bottom-right corner):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了我们如何将这些相同顶点的纹理坐标设置到精灵图中的第一张图片。这些坐标在图片文件中是从 0,0（在左上角）到 49,49（在右下角）：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we wanted to set the texture coordinates to the second image in the sprite
    sheet, we would have written the code like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将纹理坐标设置到精灵图中的第二张图片，我们会像这样编写代码：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Of course, if we define each and every vertex like this individually, then we
    are going to be spending a long time configuring even a simple 10 by 10 arena.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们像这样逐个定义每个顶点，那么即使是简单的 10x10 场地配置也将花费很长时间。
- en: When we implement our background for real, we will devise a set of nested `for`
    loops that loop through each quad, pick a random background image, and assign
    the appropriate texture coordinates.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们真正实现背景时，我们将设计一组嵌套的 `for` 循环，遍历每个四边形，随机选择一个背景图片，并分配适当的纹理坐标。
- en: The code will need to be quite smart. It will need to know when it is an edge
    tile so that it can use the wall image from the sprite sheet. It will also need
    to use appropriate variables that know the position of each background tile in
    the sprite sheet, as well as the overall size of the required arena.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 代码需要相当智能。它需要知道何时是边缘瓦片，以便可以使用精灵图中的墙壁图像。它还需要使用适当的变量，这些变量知道精灵图中每个背景瓦片的位置，以及所需竞技场的整体大小。
- en: We will make this complexity manageable by putting all the code in both a separate
    function and a separate file. We will make the `VertexArray` instance usable in
    `main` by using a C++ reference.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过将所有代码放入一个单独的函数和一个单独的文件中来使这种复杂性变得可管理。我们将通过使用 C++ 引用来使 `VertexArray` 实例在
    `main` 中可用。
- en: We will examine these details later. You may have noticed that at no point have
    we associated a texture (the sprite sheet with the vertex array). Let's see how
    to do that now.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后检查这些细节。你可能已经注意到，我们从未在任何地方将纹理（带有顶点数组的精灵图）关联起来。现在让我们看看如何做到这一点。
- en: Using the vertex array to draw
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用顶点数组绘制
- en: 'We can load the sprite sheet as a texture in the same way that we load any
    other texture, as shown in the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像加载任何其他纹理一样加载精灵图作为纹理，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can then draw the entire `VertexArray` with one call to `draw`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一次调用 `draw` 来绘制整个 `VertexArray`：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The previous code is much more efficient than drawing every tile as an individual
    sprite.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码比逐个绘制每个瓦片作为单独的精灵要高效得多。
- en: Important note
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Before we move on, notice the slightly odd-looking `&` notation before the `textureBackground`
    code. Your immediate thought might be that this has something to do with references.
    What is going on here is we are passing the address of the `Texture` instance
    instead of the actual `Texture` instance. We will learn more about this in the
    next chapter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，注意 `textureBackground` 代码前面的 `&` 符号看起来有点奇怪。你可能会立即想到这与引用有关。这里发生的事情是我们正在传递
    `Texture` 实例的地址而不是实际的 `Texture` 实例。我们将在下一章中了解更多关于这一点。
- en: We are now able to use our knowledge of references and vertex arrays to implement
    the next stage of the Zombie Arena project.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够利用我们对引用和顶点数组的了解来实现僵尸竞技场项目的下一阶段。
- en: Creating a randomly generated scrolling background
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建随机生成的滚动背景
- en: In this section, we will create a function that makes a background in a separate
    file. We will ensure the background will be available (in scope) to the `main`
    function by using a vertex array reference.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个函数，在单独的文件中创建背景。我们将通过使用顶点数组引用来确保背景对 `main` 函数可用（在作用域内）。
- en: As we will be writing other functions that share data with the `main` function,
    we will write them all in their own `.cpp` files. We will provide prototypes for
    these functions in a new header file that we will include (with an `#include`
    directive) in `ZombieArena.cpp`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将编写其他与 `main` 函数共享数据的函数，我们将它们都写入它们自己的 `.cpp` 文件中。我们将在一个新的头文件中提供这些函数的原型，并将该头文件（通过
    `#include` 指令）包含在 `ZombieArena.cpp` 中。
- en: To achieve this, let's make a new header file called `ZombieArena.h`. We are
    now ready to code the header file for our new function.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，让我们创建一个新的头文件 `ZombieArena.h`。我们现在准备好编写我们新函数的头文件了。
- en: 'In this new `ZombieArena.h` header file, add the following highlighted code,
    including the function prototype:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新的 `ZombieArena.h` 头文件中，添加以下突出显示的代码，包括函数原型：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The previous code allows us to write the definition of a function called `createBackground`.
    To match the prototype, the function definition must return an `int` value, and
    receive a `VertexArray` reference and an `IntRect` object as parameters.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码允许我们编写一个名为 `createBackground` 的函数的定义。为了与原型匹配，函数定义必须返回一个 `int` 值，并接收一个 `VertexArray`
    引用和一个 `IntRect` 对象作为参数。
- en: Now, we can create a new `.cpp` file in which we will code the function definition.
    Create a new file called `CreateBackground.cpp`. We are now ready to code the
    function definition that will create our background.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在新的 `.cpp` 文件中创建一个新的文件，我们将在这个文件中编写函数定义。创建一个名为 `CreateBackground.cpp`
    的新文件。我们现在准备好编写创建我们背景的函数定义了。
- en: 'Add the following code to the `CreateBackground.cpp` file, and then we will
    review it:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `CreateBackground.cpp` 文件中，然后我们将对其进行审查：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the previous code, we write the function signature as well as the opening
    and closing curly brackets that mark the function body.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们写下了函数签名以及标记函数体的开始和结束的大括号。
- en: Within the function body, we declare and initialize three new `int` constants
    to hold values that we will need to refer to throughout the rest of the function.
    They are `TILE_SIZE`, `TILE_TYPES`, and `VERTS_IN_QUAD`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内部，我们声明并初始化了三个新的 `int` 常量来保存我们需要在函数的其余部分引用的值。它们是 `TILE_SIZE`、`TILE_TYPES`
    和 `VERTS_IN_QUAD`。
- en: The `TILE_SIZE` constant refers to the size in pixels of each tile within the
    sprite sheet. The `TILE_TYPES` constant refers to the number of different tiles
    within the sprite sheet. We could add more tiles into our sprite sheet and change
    `TILE_TYPES` to match the change, and the code we are about to write would still
    work. `VERTS_IN_QUAD` refers to the fact that there are four vertices in every
    quad. It is less error-prone to use this constant compared to always typing the
    number `4`, which is less clear.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`TILE_SIZE` 常量指的是精灵图中每个瓦片的大小（以像素为单位）。`TILE_TYPES` 常量指的是精灵图中不同瓦片的数量。我们可以将更多瓦片添加到我们的精灵图中，并更改
    `TILE_TYPES` 以匹配更改，而我们即将编写的代码仍然可以工作。`VERTS_IN_QUAD` 指的是每个四边形中都有四个顶点。使用这个常量比总是输入数字
    `4` 更不容易出错，因为 `4` 更不清晰。'
- en: 'We then declare and initialize two `int` variables: `worldWidth` and `worldHeight`.
    These variables might appear obvious as to their use. They are betrayed by their
    names, but it is worth pointing out that they refer to the width and height of
    the world in the number of tiles, not pixels. The `worldWidth` and `worldHeight`
    variables are initialized by dividing the height and width of the passed-in arena
    by the `TILE_SIZE` constant.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明并初始化两个 `int` 变量：`worldWidth` 和 `worldHeight`。这些变量的用途可能看起来很明显。它们的名字揭示了这一点，但值得指出的是，它们指的是世界宽度和高度，以瓦片数量而非像素为单位。`worldWidth`
    和 `worldHeight` 变量是通过将传入的竞技场的高度和宽度除以 `TILE_SIZE` 常量来初始化的。
- en: Next, we get to use our reference for the first time. Remember that anything
    we do to `rVA`, we are really doing to the variable that was passed in, which
    is in scope in the `main` function (or will be when we code it).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们第一次使用我们的引用。记住，我们对 `rVA` 所做的任何操作实际上都是对在 `main` 函数中（或当我们编写它时）作用域内的变量所做的操作。
- en: Then, we prepare the vertex array to use quads using `rVA.setType` and then
    we make it just the right size by calling `rVA.resize`. To the `resize` function,
    we pass in the result of `worldWidth * worldHeight * VERTS_IN_QUAD`, which equates
    to exactly the number of vertices that our vertex array will have when we are
    done preparing it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `rVA.setType` 来准备使用四边形的顶点数组，然后通过调用 `rVA.resize` 来使其达到正确的大小。我们将 `resize`
    函数的参数传递为 `worldWidth * worldHeight * VERTS_IN_QUAD` 的结果，这正好等于我们在准备完成后顶点数组将拥有的顶点数量。
- en: The last line of code declares and initializes `currentVertex` to zero. We will
    use `currentVertex` as we loop through the vertex array, initializing all the
    vertices.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后一句声明并初始化 `currentVertex` 为零。我们将使用 `currentVertex` 在遍历顶点数组时初始化所有顶点。
- en: 'We can now write the first part of a nested `for` loop that will prepare the
    vertex array. Add the following highlighted code and, based on what we have learned
    about vertex arrays, try and work out what it does:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写嵌套 `for` 循环的第一部分，该循环将准备顶点数组。添加以下突出显示的代码，并根据我们对顶点数组所了解的内容，尝试弄清楚它做了什么：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The code that we just added steps through the vertex array by using a nested
    `for` loop, which first steps through the first four vertices: `currentVertex
    + 1`, `currentVertex + 2`, and so on.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加的代码通过使用嵌套的 `for` 循环遍历顶点数组，首先遍历前四个顶点：`currentVertex + 1`、`currentVertex
    + 2`，依此类推。
- en: We access each vertex in the array using the array notation, `rvA[currentVertex
    + 0]..`, and so on. Using the array notation, we call the `position` function,
    `rvA[currentVertex + 0].position...`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用数组表示法访问数组中的每个顶点，例如 `rvA[currentVertex + 0]..`，依此类推。使用数组表示法，我们调用 `position`
    函数，`rvA[currentVertex + 0].position...`。
- en: To the `position` function, we pass the horizontal and vertical coordinates
    of each vertex. We can work these coordinates out programmatically by using a
    combination of `w`, `h`, and `TILE_SIZE`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 向 `position` 函数传递每个顶点的水平和垂直坐标。我们可以通过组合使用 `w`、`h` 和 `TILE_SIZE` 来程序化地计算出这些坐标。
- en: At the end of the previous code, we position `currentVertex`, ready for the
    next pass through the nested `for` loop by advancing it four places (that is,
    adding four) with the code, that is, `currentVertex = currentVertex + VERTS_IN_QUAD`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一段代码的末尾，我们定位 `currentVertex`，为嵌套 `for` 循环的下一轮迭代做准备，通过将其增加四个位置（即加四）来实现，即 `currentVertex
    = currentVertex + VERTS_IN_QUAD`。
- en: Of course, all this does is set the coordinates of our vertices; it doesn't
    assign a texture coordinate from the sprite sheet. This is what we will do next.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，所有这些只是设置了我们的顶点坐标；它并没有从精灵图中分配纹理坐标。这是我们接下来要做的。
- en: 'To make it absolutely clear where the new code goes, I have shown it in context,
    along with all the code that we wrote a moment ago. Add and study the following
    highlighted code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使新代码的位置绝对清晰，我在上下文中展示了它，包括我们刚才写的所有代码。添加并学习以下突出显示的代码：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding highlighted code sets up the coordinates within the sprite sheet
    that each vertex is related to. Notice the somewhat long `if` condition. The condition
    checks whether the current quad is either one of the very first or the very last
    quads in the arena. If it is (one of the first or last), then this means it is
    part of the boundary. We can then use a simple formula using `TILE_SIZE` and `TILE_TYPES`
    to target the wall texture from the sprite sheet.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 上述突出显示的代码设置了与每个顶点相关的精灵图中的坐标。注意那个相对较长的 `if` 条件。该条件检查当前四边形是否是竞技场中非常第一个或最后一个四边形之一。如果是（第一个或最后一个之一），那么这意味着它是边界的一部分。然后我们可以使用一个简单的公式，结合
    `TILE_SIZE` 和 `TILE_TYPES`，从精灵图中定位墙纹理。
- en: The array notation and the `texCoords` member are initialized for each vertex,
    in turn, to assign the appropriate corner of the wall texture within the sprite
    sheet.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 数组表示法和 `texCoords` 成员依次初始化，为每个顶点分配精灵图中墙纹理的适当角落。
- en: 'The following code is wrapped in an `else` block. This means that it will run
    through the nested `for` loop each time the quad does not represent a border/wall
    tile. Add the following highlighted code among the existing code, and then we
    will examine it:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码被包裹在一个 `else` 块中。这意味着每次四边形不表示边界/墙砖时，它都会通过嵌套的 `for` 循环运行。在现有代码中添加以下突出显示的代码，然后我们将检查它：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding highlighted code starts by seeding the random number generator
    with a formula that will be different in each pass through the loop. Then, the
    `mOrG` variable is initialized with a number between 0 and `TILE_TYPES`. This
    is just what we need to pick one of the tile types randomly.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 上述突出显示的代码首先使用一个公式初始化随机数生成器，该公式在每次循环迭代中都会不同。然后，`mOrG` 变量被初始化为一个介于 0 和 `TILE_TYPES`
    之间的数字。这正是我们随机选择一个砖块类型所需要的。
- en: Important note
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '`mOrG` stands for "mud or grass". The name is arbitrary.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`mOrG` 代表“泥或草”。这个名字是任意的。'
- en: Now, we declare and initialize a variable called `verticalOffset` by multiplying
    `mOrG` by `TileSize`. We now have a vertical reference point within the sprite
    sheet to the starting height of the randomly chosen texture for the current quad.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们通过将 `mOrG` 乘以 `TileSize` 来声明并初始化一个名为 `verticalOffset` 的变量。我们现在在精灵图中有一个垂直参考点，指向随机选择的当前四边形的纹理的起始高度。
- en: Now, we use a simple formula involving `TILE_SIZE` and `verticalOffset` to assign
    the precise coordinates of each corner of the texture to the appropriate vertex.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用一个涉及 `TILE_SIZE` 和 `verticalOffset` 的简单公式来分配纹理每个角落的确切坐标到相应的顶点。
- en: We can now put our new function to work in the game engine.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在游戏引擎中使用我们的新函数了。
- en: Using the background
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用背景
- en: 'We have done the tricky stuff, so this will be simple. There are three steps,
    as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了复杂的部分，所以接下来的步骤将会很简单。共有三个步骤，如下：
- en: Create a `VertexArray`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `VertexArray`。
- en: Initialize it after leveling up each wave.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每一波升级后初始化它。
- en: Draw it in each frame.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每一帧中绘制它。
- en: 'Add the following highlighted code to declare a `VertexArray` instance called
    `background` and load the `background_sheet.png` file as a texture:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下加粗的代码添加到声明名为 `background` 的 `VertexArray` 实例中，并加载 `background_sheet.png`
    文件作为纹理：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add the following code to call the `createBackground` function, passing in
    `background` as a reference and `arena` by value. Notice that, in the highlighted
    code, we have also modified the way that we initialize the `tileSize` variable.
    Add the highlighted code exactly as shown:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码来调用 `createBackground` 函数，传入 `background` 作为引用和 `arena` 作为值。注意，在加粗的代码中，我们还修改了初始化
    `tileSize` 变量的方式。请按照所示添加加粗的代码：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that we have replaced the `int tileSize = 50` line of code because we get
    the value directly from the return value of the `createBackground` function.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经替换了 `int tileSize = 50` 这行代码，因为我们直接从 `createBackground` 函数的返回值中获取值。
- en: Tip
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: For the sake of future code clarity, you should delete the `int tileSize = 50`
    line of code and its related comment. I just commented it out to give the new
    code a clearer context.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了未来代码的清晰性，你应该删除 `int tileSize = 50` 这行代码及其相关注释。我只是将其注释掉，以便为新代码提供一个更清晰的上下文。
- en: 'Finally, it is time to do the drawing. This is really simple. All we do is
    call `window.draw` and pass the `VertexArray` instance, along with the `textureBackground`
    texture:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是时候进行绘制了。这真的很简单。我们只是调用 `window.draw` 并传递 `VertexArray` 实例以及 `textureBackground`
    纹理：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Tip
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you are wondering what is going on with the odd-looking `&` sign in front
    of `textureBackground`, then all will be made clear in the next chapter.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道 `textureBackground` 前面那个看起来奇怪的 `&` 符号是什么意思，那么所有的问题将在下一章中变得清晰。
- en: 'You can now run the game. You will see the following output:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以运行游戏了。你将看到以下输出：
- en: '![](img/B14278_09_03.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_09_03.jpg)'
- en: Here, note how the player sprite glides and rotates smoothly within the arena's
    confines. Although the current code in the `main` function draws a small arena,
    the `CreateBackground` function can create an arena of any size. We will see arenas
    bigger than the screen in [*Chapter 13*](B14278_13_Final_AG_ePub.xhtml#_idTextAnchor279),
    *Sound Effects, File I/O, and Finishing the Game*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，注意玩家精灵如何在竞技场范围内平滑地滑行和旋转。尽管当前 `main` 函数中的代码绘制了一个小竞技场，但 `CreateBackground`
    函数可以创建任何大小的竞技场。我们将在 [*第13章*](B14278_13_Final_AG_ePub.xhtml#_idTextAnchor279) 中看到比屏幕更大的竞技场，*声音效果、文件输入/输出和完成游戏*。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discovered C++ references, which are special variables that
    act as an alias to another variable. When we pass a variable by reference instead
    of by value, then anything we do on the reference happens to the variable back
    in the calling function.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们发现了 C++ 引用，它们是作为另一个变量的别名而存在的特殊变量。当我们通过引用而不是值传递变量时，我们对引用所做的任何操作都会影响到调用函数中的变量。
- en: We also learned about vertex arrays and created a vertex array full of quads
    to draw the tiles from a sprite sheet as a background.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了关于顶点数组的内容，并创建了一个充满四边形的顶点数组，用于从精灵图中绘制作为背景的瓦片。
- en: The elephant in the room, of course, is that our zombie game doesn't have any
    zombies. We'll fix that in the next chapter by learning about C++ pointers and
    the **Standard Template Library** (**STL**).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，房间里的大象是我们这款僵尸游戏没有僵尸。我们将在下一章通过学习 C++ 指针和**标准模板库**（**STL**）来解决这个问题。
- en: FAQ
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题解答
- en: 'Here are some questions that might be on your mind:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些可能出现在你脑海中的问题：
- en: Q) Can you summarize these references again?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Q) 你能再次总结这些引用吗？
- en: A) You must initialize a reference immediately, and it cannot be changed to
    reference another variable. Use references with functions so you are not working
    on a copy. This is good for efficiency because it avoids making copies and helps
    us abstract our code into functions more easily.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: A) 您必须立即初始化引用，并且不能将其更改为引用另一个变量。使用引用与函数一起使用，这样您就不是在处理副本。这对效率有好处，因为它避免了复制，并有助于我们更容易地将代码抽象为函数。
- en: Q) Is there an easy way to remember the main benefit of using references?
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Q) 有没有简单的方法来记住使用引用的主要好处？
- en: 'A) To help you remember what a reference is used for, consider this short rhyme:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: A) 为了帮助您记住引用的用途，请考虑以下简短的韵文：
- en: '*        Moving large objects can make our games choppy,*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*        移动大对象可能会使我们的游戏变得卡顿，*'
- en: '*        passing by reference is faster than copy.*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*        通过引用传递比复制更快。*'
