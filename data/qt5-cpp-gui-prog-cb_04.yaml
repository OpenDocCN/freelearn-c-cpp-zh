- en: Chapter 4. OpenGL Implementation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。OpenGL实现
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Setting up OpenGL in Qt
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Qt中设置OpenGL
- en: Hello World!
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你好，世界！
- en: Rendering 2D shapes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染2D形状
- en: Rendering 3D shapes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染3D形状
- en: Texturing in OpenGL
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL中的纹理
- en: Lighting and texture filter in OpenGL
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL中的光照和纹理滤镜
- en: Moving an object using keyboard controls
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用键盘控制移动对象
- en: 3D Canvas in QML
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QML中的3D画布
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we will learn how to use **Open Graphics Library** (**OpenGL**),
    a powerful rendering **Application Program Interface** (**API**), and combine
    it with Qt. OpenGL is a cross-language, cross platform API for drawing 2D and
    3D graphics on screen through the **Graphics Processing Unit** (**GPU**) within
    our computer's graphics chip. In this chapter, we will be learning OpenGL 2.x
    instead of 3.x, because the fixed-function pipeline is easier for beginners to
    grasp compared to the newer programmable pipeline. Qt supports both versions,
    so there should be no problem switching over to OpenGL 3.x and above once you
    have learned the basic concepts of OpenGL rendering.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用**开放图形库**（**OpenGL**），这是一个强大的渲染**应用程序编程接口**（**API**），并将其与Qt结合使用。OpenGL是一个跨语言、跨平台的API，用于通过计算机的图形芯片内的**图形处理单元**（**GPU**）在屏幕上绘制2D和3D图形。在本章中，我们将学习OpenGL
    2.x而不是3.x，因为对于初学者来说，固定功能管线比较新的可编程管线更容易理解。Qt支持这两个版本，因此一旦您学会了OpenGL渲染的基本概念，切换到OpenGL
    3.x及以上版本就不会有问题。
- en: Setting up OpenGL in Qt
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Qt中设置OpenGL
- en: In this recipe, we will learn how to set up OpenGL in Qt.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何在Qt中设置OpenGL。
- en: How to do it…
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作方法…
- en: First, let's create a new Qt widgets application by going to **File** | **New
    File or Project**.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们通过转到**文件** | **新建文件或项目**来创建一个新的Qt小部件应用程序。
- en: Next, we will remove the `mainwindow.ui` file because we are not going to use
    it in this example. Right-click on the `mainwindow.ui` file and select **Remove
    File** from the drop-down menu. Then, a message box will appear and ask for your
    confirmation. Tick **Delete file permanently** and press the **OK** button.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将删除`mainwindow.ui`文件，因为我们在本示例中不会使用它。右键单击`mainwindow.ui`文件，然后从下拉菜单中选择**删除文件**。然后，将出现一个消息框并要求您确认。选中**永久删除文件**并按**确定**按钮。
- en: 'After that, open up your project file (`.pro`) and add the OpenGL module to
    your project by adding an `opengl` keyword behind `QT +=`, like so:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，打开您的项目文件（`.pro`），并通过在`QT +=`后面添加`opengl`关键字来将OpenGL模块添加到您的项目中，如下所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You also need to add another line in your project file so that it will load
    both the OpenGL and **GLu** (**OpenGL Utilities**) libraries during startup. Without
    these two libraries, you program will not be able to run:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还需要在项目文件中添加另一行，以便在启动时加载OpenGL和**GLu**（**OpenGL实用程序**）库。没有这两个库，您的程序将无法运行：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, open up `mainwindow.h` and remove several things from it:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，打开`mainwindow.h`并从中删除一些内容：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, add the following code to your `mainwindow.h`:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将以下代码添加到您的`mainwindow.h`中：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once you have done that, we will proceed to the source file, which is `mainwindow.cpp`.
    Functions that we have just added to the header, such as `initializeGL()`, `resizeGL()`,
    and so on, can be left empty for now; we will only use these in the next section:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，我们将继续进行源文件，即`mainwindow.cpp`。我们刚刚添加到头文件中的函数，如`initializeGL()`、`resizeGL()`等，现在可以暂时留空；我们将在下一节中使用这些函数：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Lastly, set a title for the main window and resize it to 640x480 by adding
    the following code to your `main.cpp` file:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过将以下代码添加到您的`main.cpp`文件中，为主窗口设置标题并将其调整大小为640x480：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you compile and run the project now, you will see an empty window with a
    black background. Don't worry about it, your program is now running on OpenGL!![How
    to do it…](img/B02820_04_01.jpg)
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您现在编译并运行项目，您将看到一个带有黑色背景的空窗口。不要担心，您的程序现在正在使用OpenGL运行！[操作方法…](img/B02820_04_01.jpg)
- en: How it works...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The OpenGL module must be added to the project file (`.pro`) in order to access
    header files that are related to OpenGL, such as QtOpenGL, QOpenGLFunctions, and
    so on. We used the `QOpenGLWindow` class instead of `QMainWindow` for the main
    window because it's designed to easily create windows that perform OpenGL rendering,
    and it offers better performance compared to QOpenGLWidget due to the fact that
    it has no dependencies in its widget module. We must call `setSurfaceType(QWindow::OpenGLSurface`)
    to tell Qt we prefer to use OpenGL to render the images to screen, instead of
    QPainter. The `QOpenGLWindow` class provides several virtual functions (`initializeGL()`,
    `resizeGL()`, `paintGL()`, and so on) for us to conveniently set up OpenGL and
    perform graphics rendering.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 必须在项目文件（`.pro`）中添加OpenGL模块，以便访问与OpenGL相关的头文件，如QtOpenGL、QOpenGLFunctions等。我们使用了`QOpenGLWindow`类而不是`QMainWindow`用于主窗口，因为它被设计为轻松创建执行OpenGL渲染的窗口，并且与QOpenGLWidget相比具有更好的性能，因为它在其小部件模块中没有依赖项。我们必须调用`setSurfaceType(QWindow::OpenGLSurface)`来告诉Qt我们更喜欢使用OpenGL来将图像渲染到屏幕上，而不是使用QPainter。`QOpenGLWindow`类为我们提供了几个虚拟函数（`initializeGL()`、`resizeGL()`、`paintGL()`等），方便我们设置OpenGL并执行图形渲染。
- en: There's more…
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: OpenGL is a cross-language, cross-platform API for drawing 2D and 3D graphics
    on screen through the **Graphics Processing Unit** (**GPU**) within our computer's
    graphics chip.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL是一个跨语言、跨平台的API，用于通过计算机的图形芯片内的**图形处理单元**（**GPU**）在屏幕上绘制2D和3D图形。
- en: Computer graphics technology has been evolving rapidly over the years, so rapidly
    that the software industry can hardly keep up with its pace. In 2008, Khronos
    Group, the company that maintains and develops OpenGL, announced the release of
    the OpenGL 3.0 specification, which created a huge uproar and controversy throughout
    the industry. That was mainly because OpenGL 3.0 was supposed to deprecate the
    entire fixed-function pipeline from the OpenGL API, and it was simply an impossible
    task for the big players to make the sudden switch overnight from a fixed-function
    pipeline to a programmable pipeline. This resulted in two different major versions
    of OpenGL being maintained concurrently by the Khronos Group, namely OpenGL 2.x
    and 3.x.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机图形技术多年来发展迅速，以至于软件行业几乎无法跟上其步伐。2008年，维护和开发OpenGL的Khronos Group公司宣布发布OpenGL
    3.0规范，这在整个行业中引起了巨大的轰动和争议。这主要是因为OpenGL 3.0应该废弃OpenGL API中的整个固定功能流水线，对于大公司来说，从固定功能流水线一夜之间转换为可编程流水线是不可能的任务。这导致Khronos
    Group同时维护两个不同的OpenGL主要版本，即OpenGL 2.x和3.x。
- en: In this chapter, we will be learning OpenGL 2.x instead of 3.x, because the
    fixed-function pipeline is easier for beginners to grasp than the programmable
    pipeline. It's very straightforward and less confusing for learning the basics
    of computer graphics programming. Qt supports both versions, so there should be
    no problem switching over to OpenGL 3.x (and above) once you have learned the
    basic concepts of OpenGL rendering.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习OpenGL 2.x而不是3.x，因为对于初学者来说，固定功能流水线比可编程流水线更容易理解。对于学习计算机图形编程的基础知识来说，这是非常直接和不容易混淆的。Qt支持这两个版本，因此一旦学会了OpenGL渲染的基本概念，切换到OpenGL
    3.x（及以上版本）应该没有问题。
- en: Qt uses OpenGL internally whenever it sees fit. Moreover, the new Qt Quick 2
    renderer is based on OpenGL and is now a core part of Qt's graphical offering.
    That makes OpenGL more compatible with Qt than any other graphics APIs, such as
    DirectX.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Qt在适当时候内部使用OpenGL。此外，新的Qt Quick 2渲染器基于OpenGL，现在是Qt图形提供的核心部分。这使得OpenGL与Qt的兼容性比其他任何图形API（如DirectX）都更好。
- en: Hello world!
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你好世界！
- en: In this recipe, we will learn about the pipeline of OpenGL and how to render
    a simple shape to the window. We will continue from the example project used in
    the previous recipe.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习OpenGL的流水线以及如何将简单的形状渲染到窗口中。我们将继续使用上一个示例项目中的示例。
- en: How to do it…
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: 'First of all, go to `mainwindow.h` and add the following headers at the top
    of the source code:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，转到`mainwindow.h`并在源代码顶部添加以下头文件：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, declare two private variables in `mainwindow.h`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`mainwindow.h`中声明两个私有变量：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After that, move over to `mainwindow.cpp` and set the surface format to compatibility
    profile. We also set the OpenGL version to 2.1 and create the OpenGL context using
    the format we just declared. Then, use the context we just created to access the
    OpenGL functions that are relevant only to the OpenGL version we have just set,
    by calling `context->functions()`:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，转到`mainwindow.cpp`并将表面格式设置为兼容性配置文件。我们还将OpenGL版本设置为2.1，并使用我们刚刚声明的格式创建OpenGL上下文。然后，使用我们刚刚创建的上下文来访问仅与我们刚刚设置的OpenGL版本相关的OpenGL函数，通过调用`context->functions()`：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we will start adding some code to the `paintGL()` function:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将开始向`paintGL()`函数中添加一些代码：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Nothing will appear on the screen yet until we call `paintGL()` in the `paintEvent()`
    function:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`paintEvent()`函数中调用`paintGL()`之前，屏幕上不会出现任何内容：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you compile and run the project now, you should be able to see a white rectangle
    being drawn in front of a blue background:![How to do it…](img/B02820_04_02.jpg)
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果现在编译并运行项目，您应该能够看到一个白色矩形在蓝色背景前被绘制出来：![操作步骤…](img/B02820_04_02.jpg)
- en: How it works...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: We must set the OpenGL version to 2.1 and the surface format to compatibility
    profile so that we can access the fixed-function pipeline, which no longer exists
    in the newer version. Alternatively, you can set the surface format to `QSurfaceFormat::CoreProfile`
    if you want to use OpenGL 3.x and above.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将OpenGL版本设置为2.1，并将表面格式设置为兼容性配置文件，以便访问在较新版本中不再存在的固定功能流水线。或者，如果要使用OpenGL 3.x及以上版本，可以将表面格式设置为`QSurfaceFormat::CoreProfile`。
- en: We called `glClearColor()` and `glClear(GL_COLOR_BUFFER_BIT)` to remove the
    previous `render buffer` (or in layman's terms, the previous frame) and fill the
    entire canvas with the color we provided. We will repeat this step after an image
    has been rendered so that it clears the entire screen before we proceed to the
    next frame. We called `glBegin(GL_QUAD)` to tell OpenGL we are about to draw a
    quad on the screen. After that, we provided the positions of all the vertices
    (or points) to OpenGL so that it will know how the quad should be positioned on
    the screen by calling `glVertex2f()` four times, because a quad can only be constructed
    by connecting four different points. Then, we called `glEnd()` to inform OpenGL
    that we are done with the quad.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用了`glClearColor()`和`glClear(GL_COLOR_BUFFER_BIT)`来清除先前的`渲染缓冲区`（或者通俗地说，上一个帧），并用我们提供的颜色填充整个画布。在渲染图像后，我们将重复这一步骤，以便在进行下一帧之前清除整个屏幕。我们调用了`glBegin(GL_QUAD)`来告诉OpenGL我们将在屏幕上绘制一个四边形。之后，我们向OpenGL提供了所有顶点（或点）的位置，以便它知道如何将四边形放置在屏幕上，通过四次调用`glVertex2f()`，因为四边形只能通过连接四个不同的点来构造。然后，我们调用了`glEnd()`来告诉OpenGL我们已经完成了四边形。
- en: Always call `glFlush()` once you are done drawing images on screen so that OpenGL
    clears away all the unwanted information from the memory to give space to the
    next drawing.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成屏幕上的图像绘制后，始终调用`glFlush()`，以便OpenGL清除内存中的所有不需要的信息，为下一次绘制腾出空间。
- en: Lastly, we must call `paintGL()` in the `paintEvent()` function, or else nothing
    will be drawn on the screen. Just like what we have learned in the previous chapters,
    all drawings happen within the `paintEvent()` function, and it will only be called
    by Qt when it thinks it's necessary to refresh the screen. To force Qt to update
    the screen, call `update()` manually.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`paintEvent()`函数中必须调用`paintGL()`，否则屏幕上将什么都不会被绘制。就像我们在前几章中学到的那样，所有的绘图都发生在`paintEvent()`函数中，只有在Qt认为有必要刷新屏幕时才会调用它。要强制Qt更新屏幕，需要手动调用`update()`。
- en: Rendering 2D shapes
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染2D形状
- en: Since we have already learned how to draw our first rectangle on the screen,
    we will further enhance it in this section. We will take the previous example
    and continue from there.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经学会了如何在屏幕上绘制第一个矩形，我们将在本节中进一步增强它。我们将采用前面的例子，并从那里继续。
- en: How to do it…
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, go to the `paintGL()` function in `mainwindow.cpp` and replace the quad
    in the previous example with new code. This time, we draw a quad together with
    a triangle:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，转到`mainwindow.cpp`中的`paintGL()`函数，并用新代码替换上一个示例中的四边形。这次，我们画了一个四边形和一个三角形：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, in the `resizeGL()` function, add the following code to adjust the viewport
    and orthographic view so that the rendered image correctly follows the window''s
    aspect ratio:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`resizeGL()`函数中，添加以下代码来调整视口和正交视图，以便渲染的图像正确地遵循窗口的纵横比：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, in the `resizeEvent()` function, call the `resize()` function and force
    the main window to refresh the screen:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`resizeEvent()`函数中，调用`resize()`函数并强制主窗口刷新屏幕：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After that, in the `initializeGL()` function, we call `resizeGL()` once so
    that the aspect ratio of the first rendered image is correct (before any window
    resize event is triggered):'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，在`initializeGL()`函数中，我们调用`resizeGL()`一次，以便第一个渲染的图像的纵横比是正确的（在任何窗口调整大小事件触发之前）：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once you're done with that, compile and run the program. You should see something
    like this:![How to do it…](img/B02820_04_03.jpg)
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，编译并运行程序。你应该会看到类似这样的东西：![如何做...](img/B02820_04_03.jpg)
- en: How it works...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The geometric primitive types supported by OpenGL are points, lines, linestrips,
    line loops, polygons, quads, quad strips, triangles, triangle strips, and triangle
    fans. In this example, we drew a quad and a triangle, where each of the shapes
    is provided with a set of vertices and colors so that OpenGL knows how the shapes
    should be rendered. The rainbow color is created by giving a different color to
    each of the vertices. OpenGL will automatically interpolate the colors between
    each vertex and display it onscreen. The shape that gets rendered later will always
    appear in front of other shapes. In this case, the triangle is being rendered
    later and hence it appears in front of the rectangle.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL支持的几何基元类型包括点、线、线条、线环、多边形、四边形、四边形条带、三角形、三角形条带和三角形扇形。在这个例子中，我们画了一个四边形和一个三角形，每个形状都提供了一组顶点和颜色，以便OpenGL知道如何渲染形状。彩虹色是通过给每个顶点赋予不同的颜色来创建的。OpenGL会自动在每个顶点之间插值颜色并在屏幕上显示。稍后渲染的形状将始终出现在其他形状的前面。在这种情况下，三角形稍后被渲染，因此它出现在矩形的前面。
- en: We need to calculate the aspect ratio of the main window every time it's resized,
    so that the rendered image will not be stretched and result in an odd appearance.
    Always reset the projection matrix by calling `glMatrixMode()` and `glLoadIdentity()`
    before calling `glViewport()` and `glOrtho()` so that the shapes are being rendered
    correctly when resizing the main window. Without resetting the projection matrix,
    we will be using the matrices from the previous frame and hence producing the
    wrong projection.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在每次调整大小时计算主窗口的纵横比，以便渲染的图像不会被拉伸，导致奇怪的外观。在调用`glViewport()`和`glOrtho()`之前，始终通过调用`glMatrixMode()`和`glLoadIdentity()`重置投影矩阵，以便在调整主窗口大小时正确渲染形状。如果不重置投影矩阵，我们将使用上一帧的矩阵，从而产生错误的投影。
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember to call `update()` when the window is being resized, otherwise the
    screen will not be updated.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在调整窗口大小时调用`update()`，否则屏幕将不会更新。
- en: Render 3D shapes
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染3D形状
- en: We have learned how to draw simple 2D shapes onscreen in the previous section.
    However, to fully utilize the OpenGL API, we also need to learn how to use it
    to render 3D images. In a nutshell, 3D images are simply an illusion created using
    2D shapes stacked in a way that makes them look like 3D.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们已经学会了如何在屏幕上绘制简单的2D形状。然而，为了充分利用OpenGL API，我们还需要学习如何使用它来渲染3D图像。简而言之，3D图像只是使用堆叠的2D形状创建的一种幻觉，使它们看起来像3D。
- en: The main ingredient here is the depth value, which determines which shapes should
    appear in front or at the back of the other shapes. The primitive shape that is
    positioned behind another surface (with a shallower depth than another shape)
    will not be rendered (or partially rendered). OpenGL provides a simple way to
    achieve this, without too much technical hassle.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要成分是深度值，它决定了哪些形状应该出现在其他形状的前面或后面。位于另一个表面后面（深度比另一个形状浅）的基本形状将不会被渲染（或部分渲染）。OpenGL提供了一种简单的方法来实现这一点，而不需要太多的技术麻烦。
- en: How to do it…
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, add the `QTimer` header to your `mainwindow.h`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在你的`mainwindow.h`中添加`QTimer`头文件：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, add a private variable to your `MainWindow` class:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在你的`MainWindow`类中添加一个私有变量：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We also add a public slot to `mainwindow.h` for later use:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还在`mainwindow.h`中添加了一个公共槽，以备后用：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After that, enable depth testing by adding `glEnable(GL_DEPTH_TEST)` to the
    `initializeGL()` function in `mainwindow.cpp`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，在`mainwindow.cpp`的`initializeGL()`函数中添加`glEnable(GL_DEPTH_TEST)`以启用深度测试：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we will alter the `resizeGL()` function so that it uses the perspective
    view instead of the orthogonal view:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将修改`resizeGL()`函数，以便使用透视视图而不是正交视图：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After that, we need to alter the `paintGL()` function as well. First, add `GL_DEPTH_BUFFER_BIT`
    to the `glClear()` function, because we also need to clear the depth information
    for the previous frame before we proceed to render the next frame. Then, remove
    the code we used in the previous example, which rendered a quad and a triangle
    on the screen:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们还需要修改`paintGL()`函数。首先，将`GL_DEPTH_BUFFER_BIT`添加到`glClear()`函数中，因为我们还需要清除上一帧的深度信息，然后再渲染下一帧。然后，删除我们在之前示例中使用的代码，该代码在屏幕上渲染了一个四边形和一个三角形：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, before calling `glFlush()`, we will add the following code to draw a
    3D cube:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在调用`glFlush()`之前，我们将添加以下代码来绘制一个3D立方体：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once you are done with that, add a timer to the construction of the `MainWindow`
    class, like so:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，向`MainWindow`类的构造函数中添加一个定时器，如下所示：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Lastly, we increase the rotation variable by 10 every time the `updateAnimation()`
    slot is called by the timer. We also manually call the `update()` function to
    update the screen:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，每当定时器调用`updateAnimation()`槽时，我们将旋转变量增加10。我们还手动调用`update()`函数来更新屏幕：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you compile and run the program now, you should see a spinning cube in your
    main window!![How to do it…](img/B02820_04_04.jpg)
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果现在编译并运行程序，您应该会在主窗口中看到一个旋转的立方体！[如何做...](img/B02820_04_04.jpg)
- en: How it works...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In any 3D rendering, depth is very important and thus we need to enable the
    depth testing feature in OpenGL by calling `glEnable(GL_DEPTH_TEST)`. When we
    clear the buffer, we also must specify `GL_DEPH_BUFFER_BIT` so that the depth
    information is also being cleared, in order for the next image to be rendered
    correctly.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何3D渲染中，深度非常重要，因此我们需要通过调用`glEnable(GL_DEPTH_TEST)`在OpenGL中启用深度测试功能。当我们清除缓冲区时，我们还必须指定`GL_DEPH_BUFFER_BIT`，以便深度信息也被清除，以便下一幅图像能够正确渲染。
- en: 'We use `gluPerspective()` to set up a perspective projection matrix so that
    the graphics appear to have depth and distance. The opposite to the perspective
    view is the orthographic view, which is the default view in OpenGL, and we have
    used it in our previous example. Orthographic projection is a form of parallel
    projection where objects appear to be flat and do not suggest depth and distance:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`gluPerspective()`来设置透视投影矩阵，以便图形看起来具有深度和距离。透视视图的相反是正交视图，这是OpenGL中的默认视图，我们在之前的示例中使用过。正交投影是一种平行投影，其中物体看起来是平的，不具有深度和距离的概念：
- en: '![How it works...](img/B02820_04_05.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/B02820_04_05.jpg)'
- en: In this example, we used a timer to increase the rotation value by 10 every
    100 milliseconds (0.1 second). The rotation value is then applied to the cube
    by calling `glRotatef()` before supplying the vertex data to OpenGL. We also called
    `glTranslatef()` to move the cube slightly to the back so that it's not too close
    to the camera view.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了一个定时器，每100毫秒（0.1秒）增加旋转值10。然后在将顶点数据提供给OpenGL之前，通过调用`glRotatef()`将旋转值应用于立方体。我们还调用了`glTranslatef()`将立方体稍微向后移动，以便它不会太靠近相机视图。
- en: Remember to call `update()` manually so that the screen gets refreshed, otherwise
    the cube will not be animated.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 记得手动调用`update()`，以便屏幕得到刷新，否则立方体将不会被动画化。
- en: Texturing in OpenGL
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenGL中的纹理
- en: OpenGL allows us to map an image (also referred to as a texture) to a 3D shape
    or polygon. This process is also called texture mapping. Qt appears to be the
    best combination with OpenGL in this case because it provides an easy way to load
    images that belong to one of the common formats (BMP, JPEG, PNG, TARGA, TIFF,
    and so on) and you don't have to implement it by yourself. We will use the previous
    example with a spinning cube and try to map it with a texture!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL允许我们将图像（也称为纹理）映射到3D形状或多边形上。这个过程也被称为纹理映射。在这种情况下，Qt似乎是与OpenGL最佳组合，因为它提供了一种简单的方式来加载属于常见格式（BMP、JPEG、PNG、TARGA、TIFF等）的图像，而不需要自己实现。我们将使用旋转立方体的先前示例，并尝试将其与纹理映射！
- en: How to do it…
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First of all, open up `mainwindow.h` and add the following header to it:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开`mainwindow.h`并将以下标题添加到其中：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, declare an array that stores the texture IDs created by OpenGL. We will
    be using it later when it comes to rendering:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，声明一个数组，用于存储由OpenGL创建的纹理ID。在渲染时我们将使用它：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After that, open up `mainwindow.cpp` and add the following code to `initializeGL()`
    to load the texture file:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，打开`mainwindow.cpp`并将以下代码添加到`initializeGL()`中以加载纹理文件：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, add the following code to the `paintGL()` function to apply the texture
    to the 3D cube:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将以下代码添加到`paintGL()`函数中，将纹理应用到3D立方体上：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you compile and run the program now, you should see a brick cube rotating
    around the screen!![How to do it…](img/B02820_04_06.jpg)
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果现在编译并运行程序，您应该会看到一个围绕屏幕旋转的砖块立方体！[如何做...](img/B02820_04_06.jpg)
- en: How it works...
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The variable `GLuint texID[1]` is an array that stores the texture ID generated
    by OpenGL when we call `glGenTexture()`, which OpenGL uses to allocate the texture
    from the memory during rendering. In this case, we set the size of the array to
    `1` because we are only using a single texture in this example. We must tell OpenGL
    to enable texturing by calling `glEnable(GL_TEXTURE_2D)` before doing anything
    related to texturing. We used two `QImage` classes to load the texture, the first
    one called `image` was used to load the image file, and the second one called
    `texture` was used to convert the image to an OpenGL-compatible format. Then we
    called `glGenTextures()` to generate an empty texture using OpenGL, and after
    that, we called `glBindTexture()` to select that particular texture. This step
    was needed so that the functions called after that will be applied to the texture
    that we just selected.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`GLuint texID[1]`是一个数组，用于存储由OpenGL在我们调用`glGenTexture()`时生成的纹理ID，OpenGL在渲染期间使用它来从内存中分配纹理。在这种情况下，我们将数组的大小设置为`1`，因为在这个示例中我们只使用一个纹理。我们必须告诉OpenGL通过调用`glEnable(GL_TEXTURE_2D)`来启用纹理处理，然后再进行与纹理相关的任何操作。我们使用了两个`QImage`类来加载纹理，第一个称为`image`用于加载图像文件，第二个称为`texture`用于将图像转换为OpenGL兼容格式。然后我们调用`glGenTextures()`使用OpenGL生成一个空纹理，之后我们调用`glBindTexture()`来选择特定的纹理。这一步是必要的，以便之后调用的函数将应用于我们刚刚选择的纹理。
- en: Next, we called `glTexParameteri()` twice to set both the texture minifying
    and texture magnification settings to point sampling. This will tell OpenGL how
    the texture should be rendered. More about that later. After that, we called `glTexImage2D()`
    to supply the pixel information from the texture file loaded by Qt to the empty
    OpenGL texture we just created. Call `glEnabled(GL_TEXTURE_2D)` and `glBindTexture()`
    to enable texturing in OpenGL and select the texture we wanted to use before we
    start rendering the 3D cube. Then, we must call `glTexCoord2f()` before calling
    `glVertex3f()` to tell OpenGL how the texture should be mapped. We supply the
    coordinates for the texture and OpenGL will figure out the rest for us.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用了两次`glTexParameteri()`来将纹理缩小和纹理放大设置为点采样。这将告诉OpenGL纹理应该如何渲染。之后，我们调用了`glTexImage2D()`来提供由Qt加载的纹理文件中的像素信息到我们刚刚创建的空OpenGL纹理中。在开始渲染3D立方体之前，调用`glEnabled(GL_TEXTURE_2D)`和`glBindTexture()`来启用OpenGL中的纹理处理并选择我们想要使用的纹理。然后，在调用`glVertex3f()`之前，我们必须调用`glTexCoord2f()`来告诉OpenGL纹理应该如何映射。我们提供纹理的坐标，OpenGL会为我们解决其余的问题。
- en: Once you're done, call `glDisable(GL_TEXTURE_2D)` to disable texturing.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，调用`glDisable(GL_TEXTURE_2D)`来禁用纹理处理。
- en: Lighting and texture filter in OpenGL
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenGL中的照明和纹理滤镜
- en: In this example, we will learn how to apply different types of filtering effects
    such as point sampling, bilinear interpolation, and trilinear interpolation to
    the textures we use in OpenGL.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何在OpenGL中对我们使用的纹理应用不同类型的滤镜效果，如点采样、双线性插值和三线性插值。
- en: How to do it…
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Again, we will use the previous example and add a light near the spinning cube.
    Open up `mainwindow.cpp` and add the following code to the `initializeGL()` function:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们将使用之前的示例，并在旋转的立方体附近添加一个光源。打开`mainwindow.cpp`并将以下代码添加到`initializeGL()`函数中：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, go to the `paintGL()` function and add the following code:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到`paintGL()`函数并添加以下代码：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you compile and run the program now, you should see the lighting in action!![How
    to do it…](img/B02820_04_07.jpg)
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果现在编译并运行程序，您应该看到照明效果的应用！![如何做...](img/B02820_04_07.jpg)
- en: How it works...
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the fixed pipeline, it''s extremely easy to add lights to your scene. First,
    we need to choose which shading model we want OpenGL to use. In our case, we chose
    the smooth shading model by calling `glShaderModel(GL_SMOOTH)`. Alternatively,
    you can also pick the flat shading model by calling `glShaderModel(GL_FLAT)`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在固定管线中，向场景中添加光源非常容易。首先，我们需要选择OpenGL要使用的着色模型。在我们的情况下，我们通过调用`glShaderModel(GL_SMOOTH)`选择了平滑着色模型。或者，您也可以通过调用`glShaderModel(GL_FLAT)`选择平面着色模型：
- en: '![How it works...](img/B02820_04_08.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/B02820_04_08.jpg)'
- en: 'After that, enable the first light in OpenGL by calling `glEnable(GL_LIGHT1)`.
    Since there is a limited number of lights allowed in the fixed pipeline, the names
    of the lights are all static: `GL_LIGHT1`, `GL_LIGHT2`, `GL_LIGHT3`, and so on.
    Next, we created three arrays that store the color of the ambient light, the color
    of the diffuse light, and the position of the diffuse light. Ambient light is
    the environment lighting, which affects the entire scene and has no position.
    Diffuse light, on the other hand, has a position and area of light influence.
    We then supply this information to OpenGL by calling the `glLightfv()` functions.
    Then, in `paintGL()`, we must enable the lighting by calling `glEnable(GL_LIGHTING)`
    before we start rendering the cube. Without it, you won''t see any lighting effects
    applied to the cube.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，通过调用`glEnable(GL_LIGHT1)`来启用OpenGL中的第一个光源。由于固定管线中允许的光源数量有限，光源的名称都是静态的：`GL_LIGHT1`，`GL_LIGHT2`，`GL_LIGHT3`等等。接下来，我们创建了三个数组，用于存储环境光的颜色、漫射光的颜色和漫射光的位置。环境光是环境照明，影响整个场景，没有位置。另一方面，漫射光具有位置和光影响区域。然后，我们通过调用`glLightfv()`函数将这些信息提供给OpenGL。然后，在`paintGL()`中，在开始渲染立方体之前，我们必须通过调用`glEnable(GL_LIGHTING)`来启用照明。如果没有它，你将看不到应用于立方体的任何照明效果。
- en: Other than that, we also need to add a surface normal value to every surface
    of the cube. Surface normal indicates where the surface is facing and is used
    for lighting calculations. Don't forget to disable lighting once you're done with
    it by calling `glDisable(GL_LIGHTING)`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们还需要为立方体的每个表面添加一个表面法线值。表面法线指示表面朝向何处，并用于光照计算。完成后，不要忘记通过调用`glDisable(GL_LIGHTING)`来禁用照明。
- en: Besides adding a light to the scene, we also changed the texture filtering setting
    to trilinear interpolation by calling `glTexParameteri()`, which makes the texture
    looks smoother. You can also try out the other two types of filtering, point filtering
    and bilinear filtering, by uncommenting the code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 除了向场景添加光照外，我们还通过调用`glTexParameteri()`将纹理过滤设置为三线性插值，使纹理看起来更加平滑。您还可以尝试其他两种过滤，点过滤和双线性过滤，只需取消注释代码即可。
- en: 'The following image shows the distinction between three different types of
    filtering:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了三种不同类型的过滤之间的区别：
- en: '![How it works...](img/B02820_04_09.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/B02820_04_09.jpg)'
- en: Bilinear and trilinear filtering require a mipmap in order to work, which we
    can ask OpenGL to generate by calling `glTexParameteri(GL_TEXTURE_2D, GL_GENERATE_MIPMAP,
    GL_TRUE)`. Mipmaps are pre-calculated, optimized sequences of textures, each of
    which is a progressively lower resolution representation of the same image. OpenGL
    will switch the texture of an object to a lower resolution mipmap when moving
    further away from the camera, which is effective for avoiding visual artifacts.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 双线性和三线性过滤需要mipmap才能工作，我们可以通过调用`glTexParameteri(GL_TEXTURE_2D, GL_GENERATE_MIPMAP,
    GL_TRUE)`来要求OpenGL生成。Mipmaps是预先计算的、优化的纹理序列，每个纹理都是同一图像的逐渐降低分辨率的表示。当远离摄像机移动时，OpenGL会将物体的纹理切换到分辨率较低的mipmap，这对于避免视觉伪影非常有效。
- en: There's more…
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: In a 3D scene, lighting is a very important aspect that helps to define the
    3D shape of an object. A light doesn't just make the surfaces facing the light
    become brighter, but it also makes other surfaces that are blocked become darker.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在3D场景中，光照是一个非常重要的方面，它有助于定义物体的3D形状。光不仅使面对光的表面变得更亮，而且还使其他被阻挡的表面变暗。
- en: In OpenGL, at least in the fixed-function pipeline, you can only add a limited
    number of lights to the scene. The number of lights is limited by the graphics
    chip – some support up to four lights, some support up to eight, and some support
    up to 16\. However, since the fixed-function pipeline is slowly being phased out
    and people are starting to use the programmable pipeline, this problem has been
    solved. In the programmable pipeline, you can have any number of lights in the
    scene; however, the lighting model will need to be coded entirely by you in the
    shaders, which is not an easy task.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL中，至少在固定功能管道中，您只能向场景中添加有限数量的灯光。灯光的数量受图形芯片的限制-有些支持多达四个灯光，有些支持多达八个，有些支持多达16个。然而，由于固定功能管道正在逐渐被淘汰，人们开始使用可编程管道，这个问题已经得到解决。在可编程管道中，您可以在场景中拥有任意数量的灯光；然而，光照模型将需要完全由您在着色器中编码，这并不是一项容易的任务。
- en: In the fixed-function pipeline, if you want to add more lights than what your
    graphics chip supports, what you can do is to turn off lights that are further
    away from the camera view and only turn on a few that are closer to your camera
    view. The disadvantage of this method is that you may see the lights popping on
    and off while walking along a maze, for example.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在固定功能管道中，如果要添加的灯光多于图形芯片支持的数量，可以关闭远离摄像机视图的灯光，并只打开靠近摄像机视图的一些灯光。这种方法的缺点是，例如在迷宫中行走时，可能会看到灯光不断闪烁。
- en: Moving an object using keyboard controls
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用键盘控制移动对象
- en: In this topic we'll be looking at is how to move an object in OpenGL using keyboard
    controls. Qt provides an easy way to detect keyboard events using virtual functions,
    namely `keyPressEvent()` and `keyReleaseEvent()`. We will be using the previous
    example and adding to it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本主题中，我们将学习如何使用键盘控制在OpenGL中移动对象。Qt提供了一种简单的方法来检测键盘事件，即使用虚拟函数`keyPressEvent()`和`keyReleaseEvent()`。我们将使用之前的示例并进行扩展。
- en: How to do it…
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Open up `mainwindow.h` and declare two floating point numbers called `moveX`
    and `moveZ`:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`mainwindow.h`并声明两个名为`moveX`和`moveZ`的浮点数：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After that, declare the `keyPressEvent()` function, like so:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，声明`keyPressEvent()`函数，如下所示：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, open up `mainwindow.cpp` and set the default values for the two variables
    we just declared:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，打开`mainwindow.cpp`并设置我们刚刚声明的两个变量的默认值：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, we will implement the `keyPressEvent()` function:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将实现`keyPressEvent()`函数：
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After that, we call `glTranslatef()` before drawing the 3D cube and putting
    both `moveX` and `moveZ` into the function. Also, we disabled the rotation so
    that it''s easier to see the movement:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，在绘制3D立方体之前调用`glTranslatef()`，并将`moveX`和`moveZ`都放入函数中。此外，我们禁用了旋转，以便更容易看到移动：
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you compile and run the program now, you should be able to move the cube
    around by pressing *W*, *A*, *S* and *D*:![How to do it…](img/B02820_04_10.jpg)
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果现在编译并运行程序，您应该能够通过按*W*、*A*、*S*和*D*来移动立方体：![如何做…](img/B02820_04_10.jpg)
- en: How it works...
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Basically, what we did here was add or subtract the `moveX` and `moveZ` values
    when a key is pressed. In `keyPressEvent()`, we checked whether the keyboard button
    pressed was *W*, *A*, *S*, or *D*. Then, we add or subtract 0.2 from the variables
    accordingly. To get the full list of key names used by Qt, visit [http://doc.qt.io/qt-5/qt.html#Key-enum](http://doc.qt.io/qt-5/qt.html#Key-enum).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们在这里所做的是在按下键时添加或减去`moveX`和`moveZ`的值。在`keyPressEvent()`中，我们检查键盘按下的按钮是否是*W*、*A*、*S*或*D*。然后，我们相应地从变量中添加或减去0.2。要获取Qt使用的键名称的完整列表，请访问[http://doc.qt.io/qt-5/qt.html#Key-enum](http://doc.qt.io/qt-5/qt.html#Key-enum)。
- en: When we hold down the same key and don't release it, Qt will repeat the key
    press event after an interval. The keyboard input interval varies between different
    operating systems. You can set the interval by calling `QApplication::setKeyboardInterval()`,
    but this may not work in every operating system. We called `glTranslatef(moveX,
    0.0, moveZ)` before drawing the cube, which moves the cube around when we press
    *W*, *A*, *S*, or *D*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们按住相同的键不放时，Qt会在一段时间后重复按键事件。键盘输入间隔在不同的操作系统之间有所不同。您可以通过调用`QApplication::setKeyboardInterval()`来设置间隔，但这可能在每个操作系统中都不起作用。我们在绘制立方体之前调用了`glTranslatef(moveX,
    0.0, moveZ)`，这会在按下*W*、*A*、*S*或*D*时移动立方体。
- en: 3D canvas in QML
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QML中的3D画布
- en: In this recipe, we will learn how to render 3D images using Qt's powerful QML
    scripting language.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何使用Qt强大的QML脚本语言呈现3D图像。
- en: How to do it…
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Let's start this example by creating a new project in Qt Creator. This time
    around, we will create **Qt Canvas 3D Application** and not the other options
    that we chose in all previous examples:![How to do it…](img/B02820_04_11.jpg)
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过在Qt Creator中创建一个新项目来开始这个示例。这一次，我们将创建**Qt Canvas 3D应用程序**，而不是我们在所有先前示例中选择的其他选项：![如何做…](img/B02820_04_11.jpg)
- en: After that, Qt Creator will ask you whether to create a project that is based
    on `three.js`. Leave the option checked and press the **Next** button to proceed:![How
    to do it…](img/B02820_04_12.jpg)
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，Qt Creator会询问您是否要创建一个基于`three.js`的项目。保持选项选中，然后按**下一步**按钮继续：![如何做…](img/B02820_04_12.jpg)
- en: Once the project is created, you will notice there are some JavaScript (`.js`)
    files already added to your project's resources. This is normal as the Qt Canvas
    3D application uses JavaScript and WebGL technology to render 3D images on screen.
    In this case, it's running a WebGL-based rendering library called three.js, which
    makes our programming job simpler and easier compare to writing pure WebGL code:![How
    to do it…](img/B02820_04_13.jpg)
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建项目后，您会注意到一些JavaScript（`.js`）文件已经添加到项目的资源中。这是正常的，因为Qt Canvas 3D应用程序使用JavaScript和WebGL技术在屏幕上呈现3D图像。在这种情况下，它正在运行一个基于WebGL的渲染库称为three.js，这使我们的编程工作与编写纯WebGL代码相比更简单和更容易：![如何做…](img/B02820_04_13.jpg)
- en: Next, add an image file to our project resources as we'll be using it in this
    example. Open up `qml.qrc` with Qt Creator by right-clicking on it in the **Projects**
    pane and select **Open in Editor**. Once the resources file is opened by Qt Creator,
    click the **Add** button, followed by the **Add File** button, then select the
    image file you want from your computer. In my case, I've added a `bricks.png`
    image, which will be used as the surface texture for our 3D object:![How to do
    it…](img/B02820_04_14.jpg)
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，向我们的项目资源中添加一个图像文件，因为我们将在此示例中使用它。通过在**项目**窗格中右键单击`qml.qrc`，然后选择**在编辑器中打开**，以使用Qt
    Creator打开`qml.qrc`。一旦Qt Creator打开了资源文件，点击**添加**按钮，然后点击**添加文件**按钮，然后从计算机中选择要使用的图像文件。在我的情况下，我添加了一个名为`bricks.png`的图像，它将用作我们的3D对象的表面纹理：![如何做…](img/B02820_04_14.jpg)
- en: After that, open up `glcode.js` using Qt Creator. You will see there is already
    plenty of code written in the file. What ithis does is basically render a simple
    3D cube on screen using the `three.js` library. You can build the project right
    away and run it to see what it looks like. However, we will change the code a
    little bit to customize its output.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，使用Qt Creator打开`glcode.js`。您会看到文件中已经有大量的代码编写。这基本上是使用`three.js`库在屏幕上渲染一个简单的3D立方体。您可以立即构建项目并运行它，看看它的样子。但是，我们将稍微更改代码以自定义其输出。
- en: 'In the `initializeGL()` function, we''ll add a directional light to the scene,
    load the texture file we just added to our project resources, and then apply the
    texture to the material that defines the surface properties of the 3D cube. Also,
    we will make the scale of the cube slightly bigger by setting its scale to `3`
    in all dimensions:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`initializeGL（）`函数中，我们将向场景添加一个定向光，加载刚刚添加到项目资源中的纹理文件，然后将纹理应用于定义3D立方体表面属性的材质。此外，我们将通过将其在所有维度上的比例设置为`3`，使立方体的比例略微变大：
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, in the `paintGL()` function, add an extra line of code to rotate the
    3D cube before rendering the scene:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`paintGL（）`函数中，添加一行额外的代码来在渲染场景之前旋转3D立方体：
- en: '[PRE36]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'I personally find the window size is a little too large, so I also changed
    the width and height of the window in `main.qml` file:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我个人觉得窗口大小有点太大，所以我还在`main.qml`文件中更改了窗口的宽度和高度：
- en: '[PRE37]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Once you're done, let's build and run the project. You should be able to see
    a 3D cube with a brick texture, spinning slowly on the screen:![How to do it…](img/B02820_04_15.jpg)
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，让我们构建并运行项目。您应该能够在屏幕上看到一个带有砖纹理的3D立方体，缓慢旋转：![如何做…](img/B02820_04_15.jpg)
- en: How it works...
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Originally, `three.js` was a cross-browser JavaScript library/API that used
    WebGL technology to display animated 3D computer graphics in a web browser. Qt
    Canvas 3D, however, also uses web technology, specifically the WebGL technology,
    to render 3D images like it would on a web browser. This means that not only is
    `three.js` supported on Qt Canvas 3D, but all the different types of library that
    are based on WebGL technology will work flawlessly on Qt Canvas 3D. However, Qt
    Canvas 3D only works on QML-based projects and does not work in C++.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，`three.js`是一个跨浏览器的JavaScript库/ API，它使用WebGL技术在Web浏览器中显示动画的3D计算机图形。然而，Qt Canvas
    3D也使用Web技术，特别是WebGL技术，来呈现3D图像，就像在Web浏览器上一样。这意味着不仅`three.js`在Qt Canvas 3D上受到支持，而且所有基于WebGL技术的不同类型的库都将在Qt
    Canvas 3D上无缝运行。但是，Qt Canvas 3D仅适用于基于QML的项目，不适用于C ++。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you're interested to learn more about `three.js`, check out their website
    at [http://threejs.org](http://threejs.org).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有兴趣了解更多关于`three.js`的信息，请访问他们的网站[http://threejs.org](http://threejs.org)。
