- en: Chapter 10
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章
- en: Unix – History and Architecture
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unix – 历史 和 架构
- en: You might have asked yourself why there should be a chapter about Unix in the
    middle of a book about expert-level C. If you have not, I invite you to ask yourself,
    how can these two topics, C and Unix, be related in such a way that there's a
    need for two dedicated chapters (this and the next chapter) in the middle of a
    book that should talk about C?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '您可能已经问过自己，为什么在关于专家级 C 语言的书中会有关于 Unix 的章节。如果您还没有，我邀请您思考，C 语言和 Unix 这两个主题是如何相关联的，以至于在本书中间需要两个专门的章节（这个和下一章）来讨论
    C 语言？ '
- en: 'The answer is simple: if you think they are unrelated, then you are making
    a big mistake. The relationship between the two is simple; Unix is the first operating
    system that is implemented with a fairly high-level programming language, C, which
    is designed for this purpose, and C got its fame and power from Unix. Of course,
    our statement about C being a high-level programming language is not true anymore,
    and C is no longer considered to be so high-level.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 答案很简单：如果您认为它们无关，那么您犯了一个大错误。这两个之间的关系很简单；Unix 是第一个使用相当高级的编程语言 C（专为这个目的设计）实现的操作系统，C
    语言从 Unix 中获得了声誉和力量。当然，我们关于 C 是一种高级编程语言的陈述现在已经不再正确，C 语言也不再被认为具有如此高级。
- en: 'Back in the 1970s and 1980s, if the Unix engineers at Bell Labs had decided
    to use another programming language, instead of C, to develop a new version of
    Unix, then we would be talking about that language today, and this book wouldn''t
    be *Extreme C* anymore. Let''s pause for a minute to read this quote from Dennis
    M. Ritchie, one of the pioneers of C, about the effect of Unix on the success
    of C:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 20 世纪 70 年代和 80 年代，如果贝尔实验室的 Unix 工程师决定使用另一种编程语言（而不是 C 语言）来开发 Unix 的新版本，那么我们现在就会在谈论那种语言了，这本书也不再是
    *Extreme C* 了。让我们暂停一下，阅读一下 C 语言先驱之一 Dennis M. Ritchie 关于 Unix 对 C 语言成功影响的这段引言：
- en: '"Doubtless, the success of Unix itself was the most important factor; it made
    the language available to hundreds of thousands of people. Conversely, of course,
    Unix''s use of C and its consequent portability to a wide variety of machines
    was important in the system''s success."'
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"毫无疑问，Unix 本身的成功是最重要的因素；它使这种语言对成千上万的人变得可用。当然，反过来，Unix 使用 C 语言及其随后在各种机器上的可移植性对系统的成功也很重要。"'
- en: '- Dennis M. Ritchie – The Development of the C Language'
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '- Dennis M. Ritchie – C 语言的发展'
- en: Available at [https://www.bell-labs.com/usr/dmr/www/chist.html](https://www.bell-labs.com/usr/dmr/www/chist.html).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 可在 [https://www.bell-labs.com/usr/dmr/www/chist.html](https://www.bell-labs.com/usr/dmr/www/chist.html)
    找到。
- en: 'As part of this chapter, we cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的一部分，我们涵盖了以下主题：
- en: We briefly talk about the history of Unix and how the invention of C happened.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们简要地谈论了 Unix 的历史以及 C 语言的发明是如何发生的。
- en: We explain how C has been developed based on B and BCPL.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们解释了 C 语言是如何基于 B 语言和 BCPL 开发的。
- en: We discuss the Unix onion architecture and how it was designed based on the
    Unix philosophy.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论 Unix 的洋葱架构以及它是如何基于 Unix 哲学设计的。
- en: We describe the user application layer together with shell ring and how the
    programs consume the API exposed by the shell ring. The SUS and POSIX standards
    are explained as part of this section.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们描述了用户应用层以及 shell 环，以及程序是如何消耗 shell 环暴露的 API 的。SUS 和 POSIX 标准在本节中得到了解释。
- en: We discuss the kernel layer and what features and functionalities should be
    present in a Unix kernel.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论内核层以及 Unix 内核应具备哪些特性和功能。
- en: We talk about the Unix devices and how they can be used in a Unix system.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论 Unix 设备及其在 Unix 系统中的使用方式。
- en: Let's start the chapter by talking about the Unix history.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从谈论 Unix 的历史开始本章。
- en: Unix history
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unix 历史
- en: In this section, we are going to give a bit of history about Unix. This is not
    a history book, so we're going to keep it short and straight to the point, but
    the goal here is to gain some hints of history in order to develop a basis for
    having Unix side by side with C forever in your minds.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要介绍 Unix 的历史。这不是一本历史书，所以我们将尽量简短并直截了当，但这里的目的是为了在您的脑海中为 Unix 和 C 永远并排存在打下一些历史基础。
- en: Multics OS and Unix
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Multics 操作系统和 Unix
- en: Even before having Unix, we had the Multics OS. It was a joint project launched
    in 1964 as a cooperative project led by MIT, General Electric, and Bell Labs.
    Multics OS was a huge success because it could introduce the world to a real working
    and secure operating system. Multics was installed everywhere from universities
    to government sites. Fast-forward to 2019, and every operating system today is
    borrowing some ideas from Multics indirectly through Unix.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在拥有 Unix 之前，我们已经有了 Multics 操作系统。这是一个于 1964 年启动的联合项目，由麻省理工学院、通用电气和贝尔实验室合作领导。Multics
    操作系统取得了巨大成功，因为它向世界介绍了一个真正的工作和安全的操作系统。Multics 在从大学到政府网站的所有地方都得到了安装。快进到 2019 年，今天所有的操作系统都在通过
    Unix 间接借鉴 Multics 的某些想法。
- en: In 1969, because of the various reasons that we will talk about shortly, some
    people at Bell Labs, especially the pioneers of Unix, such as Ken Thompson and
    Dennis Ritchie, gave up on Multics and, subsequently, Bell Labs quit the Multics
    project. But this was not the end for Bell Labs; they had designed their simpler
    and more efficient operating system, which was called Unix.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 1969 年，由于我们将很快讨论的各种原因，贝尔实验室的一些人，特别是 Unix 的先驱，如 Ken Thompson 和 Dennis Ritchie，放弃了
    Multics，随后贝尔实验室退出了 Multics 项目。但这并不是贝尔实验室的终点；他们设计了一个更简单、更高效的操作系统，这就是 Unix。
- en: 'You can read more about Multics and its history her[e: https://multicians.org/history.](https://multicians.org/history.html)html,
    where you can get a breakdown of the history of Multics.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中了解更多关于 Multics 及其历史的信息：[Multics 和其历史](https://multicians.org/history.html)。
- en: 'The following link: [https://www.quora.com/Why-did-Unix-succeed-and-not-Multics](https://www.quora.com/Why-did-Unix-succeed-and-not-Multics),
    is also a good one that explains why Unix continued to live while Multics became
    discontinued.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接：[Unix 为什么成功而 Multics 为什么失败](https://www.quora.com/Why-did-Unix-succeed-and-not-Multics)，也是一个很好的解释
    Unix 为什么能够继续存在而 Multics 则被废弃的链接。
- en: 'It is worthwhile to compare the Multics and Unix operating systems. In the
    following list, you will see similarities and differences found while comparing
    Multics and Unix:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 比较 Multics 和 Unix 操作系统是很有意义的。在下面的列表中，你将看到在比较 Multics 和 Unix 时发现的相似之处和不同之处：
- en: '**Both follow the onion architecture as their internal structure**. We mean
    that they both have more or less the same rings in their onion architecture, especially
    kernel and shell rings. Therefore, programmers could write their own programs
    on top of the shell ring. Also, Unix and Multics expose a list of utility programs
    such as `ls` and `pwd`. In the following sections, we will explain the various
    rings found in the Unix architecture.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**两者都遵循洋葱架构作为其内部结构**。我们的意思是，它们在洋葱架构中都有或多或少相同的环，特别是内核和外壳环。因此，程序员可以在外壳环上编写自己的程序。此外，Unix
    和 Multics 提供了一系列实用程序，如 `ls` 和 `pwd`。在以下章节中，我们将解释 Unix 架构中发现的各个环。'
- en: '**Multics needed expensive resources and machines to be able to work**. It
    was not possible to install it on ordinary commodity machines, and that was one
    of the main drawbacks that let Unix thrive and finally made Multics obsolete after
    about 30 years.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Multics** 需要昂贵的资源和机器才能运行。它无法安装在普通商品机器上，这是 Unix 兴盛并最终在约 30 年后使 Multics 过时的主要缺点之一。'
- en: '**Multics was complex by design**. This was the reason behind the frustration
    of Bell Labs employees and, as we said earlier, the reason why they left the project.
    But Unix tried to remain simple. In the first version, it was not even multitasking
    or multi-user!'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Multics 的设计本身就非常复杂**。这是贝尔实验室员工感到沮丧的原因，正如我们之前所说的，这也是他们离开项目的原因。但 Unix 试图保持简单。在第一个版本中，它甚至不是多任务或多用户操作！'
- en: You can read more about Unix and Multics online, and follow the events that
    happened in that era. Both were successful projects, but Unix has been able to
    thrive and survive to this day.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在网上了解更多关于 Unix 和 Multics 的信息，并关注那个时代发生的事件。这两个项目都取得了成功，但 Unix 能够繁荣至今并生存下来。
- en: 'It is worth sharing that Bell Labs has been working on a new distributed operating
    system called *Plan 9*, which is based on the Unix project. You can read more
    about it at Wik[ipedia: https://en.wikipedia.org/wiki/Plan_9_from_B](https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs)ell_Labs.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 值得分享的是，贝尔实验室一直在开发一个新的分布式操作系统，名为 *Plan 9*，该系统基于 Unix 项目。你可以在维基百科上了解更多信息：[贝尔实验室的
    Plan 9](https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs)。
- en: '![](img/B11046_10_01.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B11046_10_01.png)'
- en: 'Figure 10-1: Plan 9 from Bell Labs (from Wikipedia)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-1：贝尔实验室的 Plan 9（来自维基百科）
- en: I suppose that it is enough for us to know that Unix was a simplification of
    the ideas and innovations that Multics presented; it was not something new, and
    so, I can quit talking about Unix and Multics history at this point.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我想我们只需要知道Unix是对Multics提出的思想和创新的简化；它不是什么新东西，因此，我可以在这一点上停止谈论Unix和Multics的历史。
- en: So far, there are no traces of C in the history because it has not been invented
    yet. The first versions of Unix were purely written using assembly language. Only
    in 1973 was Unix version 4 written using C.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，C语言在历史上没有留下痕迹，因为它尚未被发明。Unix的第一个版本完全是使用汇编语言编写的。直到1973年，Unix版本4才使用C语言编写。
- en: Now, we are getting close to discussing C itself, but before that, we must talk
    about BCPL and B because they have been the gateway to C.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们即将讨论C语言本身，但在那之前，我们必须谈谈BCPL和B语言，因为它们是通往C语言的门户。
- en: BCPL and B
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BCPL和B
- en: BCPL was created by Martin Richards as a programming language invented for the
    purpose of writing compilers. The people from Bell Labs were introduced to the
    language when they were working as part of the Multics project. After quitting
    the Multics project, Bell Labs first started to write Unix using assembly programming
    language. That's because, back then, it was an anti-pattern to develop an operating
    system using a programming language other than assembly!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: BCPL是由Martin Richards创建的，作为一种为编写编译器而发明的编程语言。当贝尔实验室的人作为Multics项目的一部分工作时，他们接触到了这种语言。在离开Multics项目后，贝尔实验室首先开始使用汇编语言编写Unix。那是因为，在当时，使用除汇编语言之外的语言开发操作系统是一种反模式！
- en: For instance, it was strange that the people at the Multics project were using
    PL/1 to develop Multics but, by doing that, they showed that operating systems
    could be successfully written using a higher-level programming language other
    than assembly. So, because of that, Multics became the main inspiration for using
    another language for developing Unix.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Multics项目组的人使用PL/1来开发Multics系统，这本身很奇怪，但通过这种方式，他们证明了操作系统可以用除了汇编语言之外的高级编程语言成功编写。因此，Multics成为了使用另一种语言开发Unix的主要灵感来源。
- en: The attempt to write operating system modules using a programming language other
    than assembly remained with Ken Thompson and Dennis Ritchie at Bell Labs. They
    tried to use BCPL, but it turned out that they needed to apply some modifications
    to the language to be able to use it in minicomputers such as the DEC PDP-7\.
    These changes led to the B programming language.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用除汇编语言之外的语言编写操作系统模块的努力，一直伴随着贝尔实验室的Ken Thompson和Dennis Ritchie。他们尝试使用BCPL，但最终发现需要对语言进行一些修改才能在像DEC
    PDP-7这样的小型计算机上使用。这些变化导致了B编程语言的出现。
- en: 'We are going to avoid going too deep into the properties of the B language
    here, but you can read more about it and the way it was developed in the following
    links:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将避免深入探讨B语言的特点，但你可以通过以下链接了解更多关于它及其发展方式的信息：
- en: The B Programmin[g Language, at https://en.wikipedia.org/wiki/B_(progra](https://en.wikipedia.org/wiki/B_(programming_language))mming_language)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: B编程语言，请访问[https://en.wikipedia.org/wiki/B_(programming_language)](https://en.wikipedia.org/wiki/B_(programming_language))
- en: '*The Development of the* [*C Language*, at https://www.bell-labs.com/usr/dmr](https://www.bell-labs.com/usr/dmr/www/chist.html)/www/chist.html'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C语言的发展*，请访问[https://www.bell-labs.com/usr/dmr/www/chist.html](https://www.bell-labs.com/usr/dmr/www/chist.html)'
- en: Dennis Ritchie authored the latter article himself, and it is a good way to
    explain the development of the C programming language while still sharing valuable
    information about B and its characteristics.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Dennis Ritchie亲自撰写了后一篇文章，这是解释C编程语言发展的好方法，同时分享了关于B语言及其特性的宝贵信息。
- en: B also had its shortcomings in terms of being a system programming language.
    B was typeless, which meant that it was only possible to work with a *word* (not
    a byte) in each operation. This made it hard to use the language on machines with
    a different word length.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: B语言在作为系统编程语言方面也存在不足。B语言是无类型的，这意味着在每次操作中只能处理一个*字*（而不是一个字节）。这使得在具有不同字长的机器上使用该语言变得困难。
- en: This is why, over time, further modifications were made to the language until
    it led to developing the **NB** (**New B**) language, and later it derived the
    structures from the B language. These structures were typeless in B, but they
    became typed in C. Finally, in 1973, the fourth version of Unix could be developed
    using C, in which there were still many assembly codes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，随着时间的推移，对语言的进一步修改导致了**NB**（**New B**）语言的开发，后来它从B语言中继承了结构。这些结构在B语言中是无类型的，但在C语言中变成了有类型的。最终，在1973年，第四版Unix可以使用C语言开发，其中仍然包含许多汇编代码。
- en: In the next section, we talk about the differences between B and C, and why
    C is a top-notch modern system programming language for writing an operating system.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论B语言和C语言之间的差异，以及为什么C语言是编写操作系统的顶级现代系统编程语言。
- en: The way to C
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C语言之路
- en: I do not think we can find anyone better than Dennis Ritchie himself to explain
    why C was invented after the difficulties met with B. In this section, we're going
    to list the causes that made Dennis Ritchie, Ken Thompson, and others create a new
    programming language instead of using B for writing Unix.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我们找不到比丹尼斯·里奇本人更好的解释者来解释为什么在遇到B语言的困难之后发明了C语言。在本节中，我们将列出导致丹尼斯·里奇、肯·汤普森（Ken
    Thompson）和其他人创造一种新的编程语言而不是使用B语言编写Unix的原因。
- en: 'Following is the list of flaws found in B, which led to the creation of C:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是发现B语言中的缺陷列表，这些缺陷导致了C语言的诞生：
- en: '**B could only work with words in memory**: Every single operation should have
    been performed in terms of words. Back then, having a programming language that
    was able to work with bytes was a dream. This was because of the available hardware
    at the time, which was addressing the memory in a word-based scheme.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**B语言只能处理内存中的字**：每个操作都应该以字为单位进行。在当时，有一种能够处理字节的编程语言是一个梦想。这是因为当时的硬件，它以字为基础对内存进行寻址。'
- en: '**B was typeless**: The more accurate statement we could say is that B was
    a single-type language. All variables were from the same type: word. So, if you
    had a string with 20 characters (21 plus the null character at the end), you had
    to divide it up by words and store it in more than one variable. For example,
    if a word was 4 bytes, you would have 6 variables to store 21 characters of the
    string.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**B语言无类型**：更准确的说法是，B语言是一种单类型语言。所有变量都属于同一类型：字。因此，如果你有一个包含20个字符的字符串（加上末尾的空字符），你必须将其分成多个字并存储在多个变量中。例如，如果字是4字节，你将需要6个变量来存储21个字符的字符串。'
- en: '**Being typeless meant that multiple byte-oriented algorithms, such as string
    manipulation algorithms, were not efficiently written with B**: This was because
    B was using the memory words not bytes, and they could not be used efficiently
    to manage multi-byte data types such as integers and strings.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无类型意味着多个字节导向的算法，例如字符串操作算法，无法用B语言高效编写**：这是因为B语言使用的是内存字而不是字节，它们不能被有效地用于管理多字节数据类型，如整数和字符串。'
- en: '**B was not supporting floating-point operations**: At the time, these were
    becoming increasingly available on the new hardware, but there was no support
    for that in the B language.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**B语言不支持浮点运算**：在当时，这些运算在新的硬件上越来越普遍，但在B语言中并没有支持。'
- en: 'Through the availability of machines such as PDP-1, which were able to address
    memory on a byte basis, B showed that it could be inefficient in addressing bytes
    of memory: This became even clearer with B pointers, which could only address
    the words in the memory, and not the bytes. In other words, for a program wanting
    to access a specific byte or a byte range in the memory, more computations had
    to be done to calculate the corresponding word indexes.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着像PDP-1这样的机器的出现，这些机器能够按字节寻址内存，B语言显示了它在寻址内存字节方面的低效：这一点在B语言指针中变得更加明显，这些指针只能寻址内存中的字，而不能是字节。换句话说，对于想要访问内存中特定字节或字节范围的程序，必须进行更多的计算来计算相应的字索引。
- en: The difficulties with B, particularly its slow development and execution on
    machines that were available at the time, forced Dennis Ritchie to produce a new
    language. This new language was called NB, or New B at first, but it eventually
    turned out to be C.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: B语言在当时的困难，尤其是其缓慢的开发和在可用机器上的执行，迫使丹尼斯·里奇（Dennis Ritchie）创造了一种新的语言。这种新语言最初被称为NB，即New
    B，但最终演变成了C语言。
- en: This newly developed language, C, tried to cover the difficulties and flaws
    of B and became a *de facto* programming language for system development, instead
    of the assembly language. In less than 10 years, newer versions of Unix were completely
    written in C, and all newer operating systems that were based on Unix got tied
    with C and its crucial presence in the system.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新开发的语言 C，试图克服 B 语言的困难和缺陷，并成为系统开发的*事实上的*编程语言，而不是汇编语言。在不到 10 年的时间里，Unix 的新版本完全是用
    C 语言编写的，所有基于 Unix 的新操作系统都与 C 语言及其在系统中的关键作用紧密相连。
- en: As you can see, C was not born as an ordinary programming language, but instead,
    it was designed by having a complete set of requirements in mind and, nowadays,
    it has no competitor. You may consider languages such as Java, Python, and Ruby
    to be higher-level languages, but they cannot be considered as direct competitors
    as they are different and serve different purposes. For instance, you cannot write
    a device driver or a kernel module with Java or Python, and they themselves have
    been built on top of a layer written in C.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，C 语言并非作为一种普通编程语言而生，而是通过考虑一套完整的需求来设计的，如今它没有竞争对手。你可能认为 Java、Python 和 Ruby
    等语言是高级语言，但它们不能被视为直接竞争对手，因为它们不同，服务于不同的目的。例如，你不能用 Java 或 Python 编写设备驱动程序或内核模块，而且它们自身也是建立在用
    C 语言编写的层之上的。
- en: Unlike many programming languages, C is standardized by ISO, and if it is required
    to have a certain feature in the future, then the standard can be modified to
    support the new feature.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多编程语言不同，C 语言由 ISO 标准化，如果未来需要添加某些特性，那么标准可以被修改以支持新特性。
- en: In the next section, we'll discuss Unix architecture. This is a fundamental
    concept in understanding how a program evolves within the Unix environment.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论 Unix 架构。这是理解程序在 Unix 环境中如何演变的一个基本概念。
- en: Unix architecture
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unix 架构
- en: In this section, we are going to explore the philosophy that the Unix creators
    had in mind and what they were expecting it to be when they created the architecture.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 Unix 创造者心中的哲学思想以及他们在创建架构时对它的期望。
- en: As we've explained in the previous section, the people involved in Unix from
    Bell Labs were working for the Multics project. Multics was a big project, the
    proposed architecture was complex, and it was tuned to be used on expensive hardware.
    But we should remember that despite all the difficulties, Multics had big goals.
    The ideas behind the Multics project revolutionized the way we were thinking about
    the operating systems.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中解释的，贝尔实验室参与 Unix 的人们当时正在 Multics 项目工作。Multics 是一个大型项目，其提出的架构复杂，并且是为了在昂贵的硬件上使用而调整的。但我们应该记住，尽管困难重重，Multics
    有着宏伟的目标。Multics 项目背后的思想彻底改变了我们思考操作系统的方式。
- en: Despite the challenges and difficulties discussed previously the ideas presented
    in the project were successful because Multics managed to live for around 40 years,
    until the year 2000\. Not only that, but the project created a huge revenue stream
    for its owner company.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管之前讨论了挑战和困难，但该项目提出的思想之所以成功，是因为 Multics 项目的寿命达到了大约 40 年，直到 2000 年。不仅如此，该项目还为它的所有者公司创造了一个巨大的收入来源。
- en: People such as Ken Thompson and his colleagues brought ideas into Unix even
    though Unix was, initially, supposed to be simple. Both Multics and Unix tried
    to bring in similar architecture, but they had two vastly different fates. Multics,
    since the turn of the century, has started to be forgotten, while Unix, and the
    operating system families based on it such as BSD, have been growing since then.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Unix 最初的设计意图是简单，但像 Ken Thompson 和他的同事这样的人还是将思想引入了 Unix。Multics 和 Unix 都试图引入类似的架构，但它们有着截然不同的命运。Multics
    自世纪之交开始逐渐被人们遗忘，而 Unix 以及基于它的操作系统家族，如 BSD，自那时起一直在不断发展。
- en: We're going to move on to talk about the Unix philosophy. It is simply a set
    of high-level requirements that the design of Unix is based on. After that, we're
    going to talk about the Unix multi-ring, onion-like architecture and the role
    of each ring in the overall behavior of the system.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将接着讨论 Unix 哲学。这仅仅是一套高级要求，Unix 的设计就是基于这些要求的。之后，我们将讨论 Unix 的多环、洋葱状架构以及每个环在系统整体行为中的作用。
- en: Philosophy
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哲学
- en: The philosophy of Unix has been explained several times by its founders. As
    such, a thorough breakdown of the entire topic is beyond the scope of this book.
    What we will do is summarize all of the main viewpoints.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 的哲学已经被其创始人多次解释。因此，对整个主题的彻底分析超出了本书的范围。我们将要做的是总结所有的主要观点。
- en: 'Before we do that, I''ve listed below some great external literature that could
    help you on the subject of Unix philosophy:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这样做之前，我列出了以下一些关于 Unix 哲学主题的出色外部文献，这可能有助于您：
- en: 'Wikipedia, *Unix philosophy*: [https://en.wikipedia.org/wiki/Unix_philosophy](https://en.wikipedia.org/wiki/Unix_philosophy
    )'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科，*Unix 哲学*：[https://en.wikipedia.org/wiki/Unix_philosophy](https://en.wikipedia.org/wiki/Unix_philosophy)
- en: '*The Unix Philosophy: A Brief Introduction*: [http://www.linfo.org/unix_philosophy.html](http://www.linfo.org/unix_philosophy.html)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Unix 哲学：简要介绍*：[http://www.linfo.org/unix_philosophy.html](http://www.linfo.org/unix_philosophy.html)'
- en: 'Eric Steven Raymond, *The Art of Unix Programming*: [https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html](https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eric Steven Raymond，*Unix 编程艺术*：[https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html](https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html)
- en: 'Equally, in the following link, you''ll see a quite angry opposite view to
    the Unix philosophy. I''ve included this because it''s always great to know both
    sides since, intrinsically, nothing is perfect:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在以下链接中，您将看到对 Unix 哲学的相当愤怒的反面观点。我包括这个链接，因为了解双方的观点总是很好的，因为本质上，没有什么是不完美的：
- en: '*The Colla*[*pse of UNIX Philosophy*: https://kukuruku.co/post/the-collapse](https://kukuruku.co/post/the-collapse-of-the-unix-philosophy/)-of-the-unix-philosophy/'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Unix 哲学的衰落*：[https://kukuruku.co/post/the-collapse-of-the-unix-philosophy/](https://kukuruku.co/post/the-collapse-of-the-unix-philosophy/)'
- en: 'To summarize these viewpoints, I''ve grouped the key Unix philosophies as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结这些观点，我将主要的 Unix 哲学归纳如下：
- en: '**Unix is mainly designed and developed to be used by programmers and not ordinary
    end users**: Therefore, many considerations addressing user interface and user
    experience requirements are not part of the Unix architecture.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unix 主要设计和开发是为了供程序员使用，而不是普通终端用户使用**：因此，许多涉及用户界面和用户体验要求的考虑因素不是 Unix 架构的一部分。'
- en: '**A Unix system is made up of many small and simple programs**: Each of them
    is designed to perform a small and simple task. There are lots of examples of
    these small and simple programs, such as `ls`, `mkdir`, `ifconfig`, `grep`, and
    `sed`.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unix 系统由许多小型和简单的程序组成**：每个程序都是设计来执行一个小型简单任务的。有很多这样的小型简单程序的例子，例如 `ls`、`mkdir`、`ifconfig`、`grep`
    和 `sed`。'
- en: '**A complex task can be performed by executing a sequence of these small and
    simple programs in a chain**: It means that essentially more than one program
    is involved in a big and complex task and that, together, each of the programs
    could be executed multiple times in order to accomplish the task. A good example
    of this is to use shell scripts instead of writing a program from scratch. Note
    that shell scripts are often portable between Unix systems, and Unix encourages
    programmers to break down their big and complex programs into small and simple
    programs.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可以通过执行一系列这些小型和简单的程序来执行复杂任务**：这意味着在执行一个大型和复杂的任务时，本质上涉及到多个程序，并且这些程序可以一起执行多次以完成任务。一个很好的例子是使用
    shell 脚本而不是从头开始编写程序。请注意，shell 脚本通常在 Unix 系统之间是可移植的，Unix 鼓励程序员将他们的大型和复杂程序分解成小型和简单的程序。'
- en: '**Each small and simple program should be able to pass its output as the input
    of another program, and this chain should continue**: This way, we can use small
    programs in a chain that has the potential to perform complex tasks. In this chain,
    each program can be considered as a transformer that receives the output of the
    previous program, transforms it based on its logic, and passes it to the next
    program in the chain. A particularly good example of this is *piping* between
    Unix commands, which is denoted by a vertical bar, such as `ls -l | grep a.out`.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每个小型和简单的程序都应该能够将其输出作为另一个程序的输入，并且这个链应该继续下去**：这样，我们可以使用小型程序形成一个具有执行复杂任务潜力的链。在这个链中，每个程序都可以被视为一个转换器，它接收前一个程序的输出，根据其逻辑进行转换，并将其传递给链中的下一个程序。一个特别好的例子是在
    Unix 命令之间的 *管道*，它由一个垂直线表示，例如 `ls -l | grep a.out`。'
- en: '**Unix is very text-oriented**: All configurations are text files, and it has
    a textual command line. Shell scripts are also text files that use simple grammar
    to write an algorithm that executes other Unix shell programs.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unix非常注重文本**: 所有配置都是文本文件，它有一个文本命令行。Shell脚本也是文本文件，使用简单的语法编写算法来执行其他Unix shell程序。'
- en: '**Unix suggests choosing simplicity over perfection**: For example, if a simple
    solution is working in most cases, don''t design a complicated solution that only
    works marginally better.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unix建议选择简单而非完美**：例如，如果简单的解决方案在大多数情况下都能工作，就不需要设计一个复杂得多的解决方案，而该解决方案仅略微优于简单解决方案。'
- en: '**Programs written for a certain Unix-compliant operating system should be
    easily usable in other Unix systems**: This is mainly satisfied by having a single
    code base that can be built and executed on various Unix-compliant systems.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为特定Unix兼容操作系统编写的程序应该易于在其他Unix系统中使用**：这主要通过拥有一个单一的代码库来实现，该代码库可以在各种Unix兼容系统中构建和执行。'
- en: The points we've just listed have been extracted and interpreted by different
    people, but in general, they've been agreed upon as the main principles driving
    Unix philosophy and, as a result, have shaped the design of Unix.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才列出的一些观点已经被不同的人提取和解释，但总的来说，它们已经被普遍认为推动Unix哲学的主要原则，并因此塑造了Unix的设计。
- en: If you have had experience with a Unix-like operating system, for example, Linux,
    then you'll be able to align your experience with the preceding statements. As
    we explained in the previous section regarding the history of Unix, it was supposed
    to be a simpler version of Multics, with the experiences the Unix founders had
    with Multics leading them to the preceding philosophies.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有过Unix类似操作系统的经验，例如Linux，那么你将能够将你的经验与前面的陈述相匹配。正如我们在上一节关于Unix历史的解释中提到的，Unix原本打算是一个更简单的Multics版本，Unix创始人对Multics的经验引导他们形成了前面的理念。
- en: But back to the topic of C. You may be asking how C has been contributing to
    the preceding philosophy? Well, almost all of the essential things reflected in
    the preceding statements are written in C. In other words, the abovementioned
    small and simple programs that propel much of Unix are all written in C.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 但回到C的话题。你可能想知道C是如何贡献于前面的理念的？好吧，前面陈述中反映的几乎所有基本事物都是用C编写的。换句话说，推动Unix大部分工作的上述小型简单程序都是用C编写的。
- en: 'It''s often better to show rather than simply tell. So, let''s look at an example.
    The C source code for the ls program in NetBSD [can be found here: http://cvsweb.netbsd.org/bsdweb.cgi/~checkout~](http://cvsweb.netbsd.org/bsdweb.cgi/~checkout~/src/bin/ls/ls.c?rev=1.67)/src/bin/ls/ls.c?rev=1.67\.
    As you should know, the ls program lists the contents of a directory and does
    nothing more than that, and this simple logic has been written in C as you can
    see in the link. But this is not the only contribution of C in Unix. We will explain
    more about this in future sections while talking about the C Standard Library.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，展示比简单讲述更好。所以，让我们来看一个例子。NetBSD中ls程序的C源代码[可以在这里找到：http://cvsweb.netbsd.org/bsdweb.cgi/~checkout~/src/bin/ls/ls.c?rev=1.67](http://cvsweb.netbsd.org/bsdweb.cgi/~checkout~/src/bin/ls/ls.c?rev=1.67)。正如你所知，ls程序列出目录内容，仅此而已，这种简单的逻辑已经用C语言编写，你可以通过链接看到。但C语言在Unix中的贡献不止于此。我们将在未来的章节中详细解释，当谈到C标准库时。
- en: Unix onion
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unix洋葱
- en: Now, it is time to explore the Unix architecture. An *onion model*, as we briefly
    mentioned before, can describe the Unix overall architecture. It is onion-like
    because it consists of a few *rings*, each of which acts as a wrapper for internal
    rings.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候探索Unix架构了。正如我们之前简要提到的，洋葱模型可以描述Unix的整体架构。它之所以像洋葱，是因为它由几个*环*组成，每个环都作为内部环的包装器。
- en: '*Figure 10-2* demonstrates the proposed famous onion model for the Unix architecture:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-2*展示了Unix架构提出的著名洋葱模型：'
- en: '![](img/B11046_10_02.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B11046_10_02.png)'
- en: 'Figure 10-2: The onion model of Unix architecture'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-2：Unix架构的洋葱模型
- en: The model looks quite simple at first glance. However, to understand it fully
    requires you to write a few programs in Unix. Only after that can you understand
    what each ring is really doing. We're going to try and explain the model as simply
    as possible in order to develop an initial foundation before moving forward with
    writing real examples.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型乍一看很简单。然而，要完全理解它，你需要编写一些Unix程序。只有在那之后，你才能真正理解每个环究竟在做什么。我们将尽可能地简单解释这个模型，以便在编写真实示例之前建立一个初步的基础。
- en: Let's explain the onion model from the innermost ring.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最内层环开始解释洋葱模型。
- en: At the core of the preceding model is **Hardware**. As we know, the main task
    of an operating system is to allow the user to interact with and use the hardware.
    That's why hardware is at the core of the model in *Figure 10-2*. This simply
    shows us that one of the main goals of Unix is to make hardware available to the
    programs willing to have access to it. Everything that we've read about the Unix
    philosophy in the previous section focuses upon delivering these services in the
    best possible manner.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面模型的核心是 **硬件**。众所周知，操作系统的主要任务是允许用户与硬件交互并使用它。这就是为什么硬件是模型中 *图 10-2* 的核心。这仅仅表明
    Unix 的一个主要目标是使硬件对希望访问它的程序可用。我们在上一节中关于 Unix 哲学的所有阅读都集中在以最佳方式提供这些服务。
- en: The ring around the hardware is the **Kernel**. The kernel is the most important
    part of an operating system. This is because it is the closest layer to the hardware,
    and it acts as a wrapper to expose the functionalities of the attached hardware
    directly. Because of this direct access, the kernel has the highest privilege
    to use the whole available resources in a system. This unlimited access to everything
    is the best justification for having other rings in the architecture that don't
    have that unlimited access. In fact, this was behind the separation between the
    *kernel space* and the *user space*. We discuss this in further detail in this
    chapter and the following one.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕硬件的环是 **内核**。内核是操作系统的最重要部分。这是因为它是离硬件最近的一层，并充当包装层以直接暴露连接硬件的功能。由于这种直接访问，内核拥有使用系统内所有可用资源的最高权限。对一切的无限制访问是架构中存在没有这种无限制访问的其他环的最佳理由。事实上，这正是内核空间和用户空间分离背后的原因。我们将在本章和下一章中进一步详细讨论这一点。
- en: Note that writing the kernel takes most of the effort needed when writing a
    new Unix-like operating system, and, as you can see, its ring is drawn thicker
    than the other rings. There are many different units inside a Unix kernel, and
    each of them are playing a vital role in the Unix ecosystem. Later on in this
    chapter, we will explain more about the internal structure of a Unix kernel.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，编写内核是编写新的类 Unix 操作系统时所需的大部分努力，正如你所看到的，它的环比其他环画得更粗。Unix 内核内部有许多不同的单元，每个单元都在
    Unix 生态系统中发挥着至关重要的作用。在本章的后面部分，我们将解释更多关于 Unix 内核内部结构的内容。
- en: The next ring is called **Shell**. It is simply a shell around the kernel that
    allows user applications to interact with the kernel and use its many services.
    Take note that the shell ring alone brings mainly most of the requirements addressed
    by the Unix philosophy that we explained in the previous section. We will elaborate
    more on this in the upcoming paragraphs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个环被称为 **Shell**。它只是围绕内核的一个壳，允许用户应用与内核交互并使用其许多服务。请注意，仅壳层环就带来了我们在上一节中解释的 Unix
    哲学中大部分提到的需求。我们将在接下来的段落中进一步阐述这一点。
- en: The shell ring consists of many small programs, which, together, form a set
    of tools that allows a user or an application to use the kernel services. It also
    contains a set of libraries, all written in C, which will allow a programmer to
    write a new application for Unix.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 壳层环由许多小型程序组成，这些程序共同形成一套工具，允许用户或应用程序使用内核服务。它还包含一组库，所有这些库都是用 C 语言编写的，这将允许程序员为
    Unix 编写新的应用程序。
- en: Based on the libraries found in **Simple Unix Specification** (**SUS**), the
    shell ring must expose a standard and a precisely defined interface for programmers.
    Such standardizations will make Unix programs portable, or at least compilable,
    on various Unix implementations. We will reveal some shocking secrets about this
    ring in the following sections!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 **简单 Unix 规范**（**SUS**）中找到的库，壳层环必须为程序员提供一个标准和精确定义的接口。这种标准化将使 Unix 程序在各种 Unix
    实现上可移植，或者至少可编译。我们将在接下来的几节中揭示这个环的一些惊人的秘密！
- en: Finally, the outermost ring, **User Applications**, consists of all of the actual
    applications written to be used on Unix systems, such as database services, web
    services, mail services, web browsers, worksheet programs, and word editor programs.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最外层环，**用户应用**，包括所有为在 Unix 系统上使用而编写的实际应用，例如数据库服务、网络服务、邮件服务、网络浏览器、电子表格程序和文字编辑程序。
- en: These applications should use the APIs and tools provided by the shell ring
    instead of accessing the kernel directly (via *system calls*, which we will discuss
    shortly) to accomplish their tasks. This is done because of the portability principle
    in the Unix philosophy. Note that in our current context, by the term *user*,
    we usually mean the user applications, and not necessarily the people working
    with these applications.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应用应该使用shell环提供的API和工具，而不是直接访问内核（通过我们将在稍后讨论的系统调用）来完成它们的任务。这是由于Unix哲学中的可移植性原则。请注意，在我们当前的环境中，术语*用户*通常指的是用户应用，而不一定是使用这些应用的人。
- en: Being restricted to use just the shell ring also helps these applications to
    be compliable on various Unix-like operating systems that are not true Unix-compliant
    operating systems. The best example is the various Linux distributions, which
    are just Unix-like. We like to have big pieces of software available on both Unix-compliant
    and Unix-like operating systems with a single code base. As we progress, you find
    out more about the differences between Unix-like and Unix-compliant systems.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 仅限于使用shell环也有助于这些应用在各种非真正的Unix兼容操作系统中兼容。最好的例子是各种Linux发行版，它们只是Unix-like。我们希望大型软件可以在Unix兼容和非Unix兼容的操作系统中都可用，并且使用单个代码库。随着我们的进展，你会了解到Unix-like系统和Unix兼容系统之间的更多差异。
- en: One general theme in the Unix onion is the fact that the inner rings should
    provide some interface for the outer rings in order to let them use their services.
    In fact, these interfaces between the rings are more important than the rings
    themselves. For example, we are more interested in knowing how to use the existing
    kernel services rather than just digging down the kernel, which is different from
    one Unix implementation to another.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix洋葱中，一个普遍的主题是内环应该为外环提供一些接口，以便它们可以使用其服务。实际上，这些环之间的接口比环本身更重要。例如，我们更感兴趣的是了解如何使用现有的内核服务，而不是仅仅深入内核，因为不同的Unix实现之间是不同的。
- en: The same could be said of the shell ring and the interface it exposes to the
    user applications. In fact, these interfaces are our main subject focus across
    these two chapters while looking at Unix. In the following sections, we're going
    to talk about each ring individually and discuss its exposed interface in some
    detail.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这也可以适用于shell环及其向用户应用暴露的界面。实际上，这些界面是我们在这两章讨论Unix时的主要关注点。在接下来的部分，我们将分别讨论每个环，并详细讨论其暴露的界面。
- en: Shell interface to user applications
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shell界面到用户应用
- en: A *human user* either uses a Terminal or a specific GUI program such as a web
    browser to use the functionalities available on a Unix system. Both are referred
    to as user applications, or just simply applications or programs, that allow the
    hardware to be used through the shell ring. Memory, CPU, network adapter, and
    hard drives are typical examples of hardware that are usually used by most Unix
    programs through the API provided by the shell ring. The API provided is one of
    the topics that we are going to talk about.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**人类用户**要么使用终端，要么使用特定的GUI程序，如网页浏览器，来使用Unix系统上可用的功能。这两者都被称为用户应用，或者简单地称为应用或程序，它们允许通过shell环使用硬件。内存、CPU、网络适配器和硬盘是典型的例子，大多数Unix程序通常通过shell环提供的API使用这些硬件。我们将会讨论的API是其中的一个主题。
- en: From a developer's perspective, there is not much difference between an application
    and a program. But from a human user's perspective, an application is a program
    that has a means such as a **Graphical User interface** (**GUI**) or **Command-Line
    Interface** (**CLI**) to interact with the user, but a program is a piece of software
    running on a machine that has no UI, such as a running service. This book does
    not distinguish between programs and applications, and we use the terms interchangeably.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发者的角度来看，应用和程序之间并没有太大的区别。但从一个人类用户的角度来看，应用是一种程序，它具有诸如**图形用户界面**（**GUI**）或**命令行界面**（**CLI**）等与用户交互的手段，而程序则是在没有用户界面（UI）的机器上运行的软件片段，例如正在运行的服务。本书不对程序和应用进行区分，我们使用这些术语是通用的。
- en: There is a wide range of programs that have been developed for Unix in C. Database
    services, web servers, mail servers, games, office applications, and many others
    are among various types of programs that exist in a Unix environment. There is
    one common feature among these applications, and that is that their code is portable
    on most Unix and Unix-like operating systems with some slight changes. But how
    is that possible? How can you write a program in C that can be built on various
    versions of Unix and through various types of hardware?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 已经为Unix开发了各种C程序。数据库服务、Web服务器、邮件服务器、游戏、办公应用程序等等，都是Unix环境中存在的各种程序类型之一。这些应用程序中有一个共同的特点，那就是它们的代码可以在大多数Unix和Unix-like操作系统上移植，只需进行一些小的修改。但这是如何实现的？如何编写一个可以在各种Unix版本和不同类型的硬件上构建的程序？
- en: 'The answer is simple: all Unix systems expose the same **Application Programming
    Interface** (**API**) from their shell ring. A piece of C source code that is
    only using the exposed standard interface can be built and run across all Unix
    systems.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 答案很简单：所有Unix系统都从它们的壳环中暴露了相同的**应用程序编程接口**（**API**）。仅使用暴露的标准接口的C源代码可以在所有Unix系统上构建和运行。
- en: But what exactly do we mean by exposing an API? An API, as we have explained
    before, is a bunch of header files that contain a set of declarations. In Unix,
    these headers, and the declared functions in them, are the same throughout all
    Unix systems, but the implementation of those functions, in other words the static
    and dynamic libraries written for each UNIX-compliant system, can be unique and
    different from others.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们究竟意味着什么通过暴露一个API？正如我们之前所解释的，API是一组包含一系列声明的头文件。在Unix中，这些头文件以及其中声明的函数在所有Unix系统中都是相同的，但那些函数的实现，换句话说，为每个UNIX兼容系统编写的静态和动态库，可能是独特的并且与其他的不同。
- en: Note that we are looking at Unix as a standard and not an operating system.
    There are systems that are built fully compatible with the Unix standard, and
    we call them *Unix-compliant systems*, such as BSD Unix, while there are systems
    that partly comply with the Unix standard, and which are called *Unix-like systems*,
    such as Linux.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们是在将Unix视为一个标准而不是一个操作系统。有一些系统完全符合Unix标准，我们称之为*Unix兼容系统*，例如BSD Unix，而有一些系统部分符合Unix标准，我们称之为*Unix-like系统*，例如Linux。
- en: The same API is being exposed from the shell ring in more or less all Unix systems.
    As an example, the `printf` function must always be declared in the `stdio.h`
    header file, as specified by the Unix standard. Whenever you want to print something
    to the standard output in a Unix-compliant system, you should use `printf` or
    `fprintf` from the `stdio.h` header file.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Unix系统都从壳环中暴露了相同的API。例如，`printf`函数必须始终在Unix标准指定的`stdio.h`头文件中声明。无论何时你想要在Unix兼容系统中将某些内容打印到标准输出，你应该使用`stdio.h`头文件中的`printf`或`fprintf`。
- en: In fact, `stdio.h` is not part of C even though all C books explain this header
    and the declared functions in it. It's part of the C standard library specified
    in the SUS standard. A C program written for Unix is not aware of the actual implementation
    of a specific function, such as `printf` or `fopen`. In other words, the shell
    ring is seen as a black box by the programs in the outer ring.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`stdio.h`虽然所有C书籍都解释了这个头文件及其声明的函数，但它并不是C的一部分。它是SUS标准中指定的C标准库的一部分。为Unix编写的C程序并不知道特定函数的实际实现，例如`printf`或`fopen`。换句话说，壳环被外环中的程序视为一个黑盒。
- en: The various APIs exposed by the shell ring are collected under the SUS standard.
    This standard is maintained by **The Open Group** consortium and has had multiple
    iterations since the creation of Unix. The most recent version is SUS version
    4, which goes back to 2008\. However, the most recent version has itself some
    revisions in 2013, 2016, and finally in 2018.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 壳环暴露的各种API被收集在SUS标准之下。这个标准由**开放集团**联盟维护，并且自Unix创建以来已经经历了多次迭代。最新版本是SUS版本4，它追溯到2008年。然而，最新版本本身在2013年、2016年和最终在2018年进行了修订。
- en: 'The following link will take you to the document explaini[ng the exposed interfaces
    in SUS version](http://www.unix.org/version4/GS5_APIs.pdf) 4: [http://www.unix.org/version4/GS5_APIs.pdf](http://www.unix.org/version4/GS5_APIs.pdf).
    As you can see in the link, there are different kinds of APIs that are exposed
    by the shell ring. Some of these are mandatory, and some others are optional.
    The following is the list of APIs found in SUS v4:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '以下链接将带您进入解释SUS版本中暴露接口的文档[解释SUS版本中暴露的接口](http://www.unix.org/version4/GS5_APIs.pdf)
    4: [http://www.unix.org/version4/GS5_APIs.pdf](http://www.unix.org/version4/GS5_APIs.pdf)。如链接所示，shell环暴露了不同种类的API。其中一些是强制性的，而另一些则是可选的。以下是在SUS
    v4中找到的API列表：'
- en: '**System interfaces**: This is a list of all functions that should be usable
    by any C program. SUS v4 has 1,191 functions that need to be implemented by a
    Unix system. The table also describes the fact that a specific function either
    is mandatory or optional for a specific version of C. Take note that the version
    we are interested in is C99.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统接口**：这是一个所有C程序都应能使用的函数列表。SUS v4有1,191个函数需要Unix系统实现。表格还描述了特定函数对于特定版本的C是强制性的还是可选性的。请注意，我们感兴趣的是C99版本。'
- en: '**Header interfaces**: This is a list of header files that can be available
    in an SUS v4-compatible Unix system. In this version of SUS, there are 82 header
    files that can be accessible to all C programs. If you go through the list, you
    will find many famous header files, such as `stdio.h`, `stdlib.h`, `math.h`, and
    `string.h`. Based on the Unix version and the C version used, some of them are
    mandatory, while others are optional. The optional headers could be missing in
    a Unix system, but mandatory header files certainly exist somewhere in the filesystem.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头文件接口**：这是一个在SUS v4兼容的Unix系统中可能可用的头文件列表。在这个版本的SUS中，有82个头文件对所有C程序都是可访问的。如果您查看列表，您会发现许多著名的头文件，例如`stdio.h`、`stdlib.h`、`math.h`和`string.h`。根据Unix版本和使用的C版本，其中一些是强制性的，而另一些则是可选的。可选的头文件可能在Unix系统中缺失，但强制性的头文件肯定存在于文件系统中某个地方。'
- en: '**Utility interfaces**: This is a list of utility programs, or command-line
    programs, that should be available in a SUS v4-compatible Unix system. If you
    go through the tables, you will see lots of commands that are familiar to you,
    for example, `mkdir`, `ls`, `cp`, `df`, `bc`, and many more, which make up to
    160 utility programs. Note that these are usually programs that must have already
    been written by a specific Unix vendor before shipping as part of its installation
    bundle.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实用程序接口**：这是一个在SUS v4兼容的Unix系统中应可用的实用程序列表，或命令行程序列表。如果您查看表格，您会看到许多您熟悉的命令，例如`mkdir`、`ls`、`cp`、`df`、`bc`等等，这些构成了多达160个实用程序。请注意，这些通常是必须在Unix供应商发货时作为其安装包一部分之前已经编写好的程序。'
- en: These utility programs are mostly used in Terminals or in shell scripts and
    are not often called by another C program. These utility programs usually use
    the same system interfaces that are exposed to an ordinary C program written in
    the user application ring.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些实用程序主要在终端或shell脚本中使用，并且通常不会被其他C程序调用。这些实用程序通常使用与在用户应用环中编写的普通C程序暴露的相同系统接口。
- en: As an example, the following is a link to the `mkdir` utility program's source
    code written for macOS High Sierra 10.13.6, which is a Berkeley Software Distribution
    (BSD) - based Unix system. The source code is published on the Apple Open Source
    website, macOS High Sierra (10.13.6), and is available at [https://opensource.apple.com/source/file_cmds/file_cmds-272/mkdir/mkdir.c](https://opensource.apple.com/source/file_cmds/file_cmds-272/mkdir/mkdir.c).
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，以下是一个指向为基于伯克利软件发行版（BSD）的Unix系统macOS High Sierra 10.13.6编写的`mkdir`实用程序源代码的链接。该源代码发布在Apple开源网站上，macOS
    High Sierra (10.13.6)，可在[https://opensource.apple.com/source/file_cmds/file_cmds-272/mkdir/mkdir.c](https://opensource.apple.com/source/file_cmds/file_cmds-272/mkdir/mkdir.c)找到。
- en: If you open the link and go through the source, you see that it is using `mkdir`
    and `umask` functions declared as part of the system interfaces.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您打开链接并查看源代码，您会发现它使用了作为系统接口一部分声明的`mkdir`和`umask`函数。
- en: '**Scripting interface**: This interface is a language that is used to write
    *shell scripts*. It is mainly used for writing automated tasks that are using
    utility programs. This interface is usually denoted as a *shell scripting language*
    or a *shell command language*.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**脚本接口**：这种接口是一种用于编写*shell脚本*的语言。它主要用于编写使用实用程序的自动化任务。这个接口通常被称为*shell脚本语言*或*shell命令语言*。'
- en: '**XCURSES interfaces**: XCURSES is a set of interfaces that allow a C program
    to interact with the user in a minimalistic text-based GUI.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XCURSES 接口**：XCURSES 是一套接口，允许 C 程序以最小化文本界面方式与用户交互。'
- en: In the following screenshot, you can see an example of the GUI that has been
    written using `ncurses` that is an implementation for XCURSES.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，你可以看到一个使用 `ncurses` 编写的 GUI 示例，而 `ncurses` 是 XCURSES 的一个实现。
- en: In SUS v4, there are 379 functions located in 3 headers, together with 4 utility
    programs, which make up the XCURSES interface.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 SUS v4 中，有 379 个函数分布在 3 个头文件中，以及 4 个实用程序，这些共同构成了 XCURSES 接口。
- en: Many programs today are still using XCURSES to interact with the user through
    a better interface. It's worth noting that, by using XCURSES-based interfaces,
    you don't need to have a graphics engine. Likewise, it is usable over remote connections
    such as **Secure Shell** (**SSH**) as well.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 许多程序今天仍在使用 XCURSES 通过更好的界面与用户交互。值得注意的是，通过使用基于 XCURSES 的接口，你不需要拥有图形引擎。同样，它也可以通过远程连接，如
    **Secure Shell**（**SSH**）进行使用。
- en: '![](img/B11046_10_03.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B11046_10_03.png)'
- en: 'Figure 10-3: A config menu based on ncurses (Wikipedia)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-3：基于 ncurses 的配置菜单（维基百科）
- en: As you can see, SUS doesn't talk about the filesystem hierarchy and the place
    where header files should be found. It only states which headers should be available
    and present in the system. A widely used convention for the path of standard header
    files says that these headers should be found in either `/usr/include` or `/usr/local/include`,
    but it is still up to the operating system and the user to make the final decision.
    These are the default paths for the header files. However, systems can be configured
    to use other paths instead of default ones.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，SUS 没有讨论文件系统层次结构和头文件应该找到的位置。它只说明了哪些头文件应该存在于系统中。一个广泛使用的标准头文件路径约定是，这些头文件应该位于
    `/usr/include` 或 `/usr/local/include` 中，但这最终还是取决于操作系统和用户来做出最终决定。这些是头文件的默认路径。然而，系统可以被配置为使用其他路径而不是默认路径。
- en: If we put system interfaces and header interfaces together with the implementation
    of the exposed functions, which are different in each Unix flavor (or implementation),
    then we get the **C Standard Library** or **libc**. In other words, libc is a
    set of functions placed in specific header files, all according to SUS, together
    with the static and shared libraries containing the implementation of the exposed
    functions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将系统接口和头文件接口与每个 Unix 版本（或实现）中暴露函数的实现结合起来，那么我们就得到了 **C 标准库** 或 **libc**。换句话说，libc
    是一组函数，这些函数放置在特定的头文件中，所有这些都根据 SUS 规范，以及包含暴露函数实现的静态和共享库。
- en: The definition of libc is entangled tightly with standardizations of Unix systems.
    Every C program being developed in a Unix system uses libc for communicating further
    down to the kernel and the hardware levels.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: libc 的定义与 Unix 系统的标准紧密相连。在 Unix 系统中开发的每个 C 程序都使用 libc 来与内核和硬件级别进行通信。
- en: It's important to remember that not all operating systems are Unix fully compatible
    systems. Microsoft Windows and operating systems using the Linux kernel, for example,
    Android, are examples of that. These operating systems are not Unix-compliant
    systems, but they can be Unix-like systems. We have used the terms Unix-compliant
    and Unix-like across earlier chapters without explaining their true meanings,
    but now we are going to define them carefully.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，并非所有操作系统都是完全兼容 Unix 的系统。例如，Microsoft Windows 和使用 Linux 内核的操作系统，如 Android，就是这样的例子。这些操作系统不是
    Unix 兼容系统，但它们可以是类似 Unix 的系统。我们在前面的章节中使用了 Unix 兼容和类似 Unix 的术语，但没有解释它们的真正含义，但现在我们将仔细定义它们。
- en: A Unix-compliant system is fully compliant to SUS standards, but this isn't
    true of a Unix-like system that is only partially compliant with the standard.
    What this means is that the Unix-like systems are only conforming to a specific
    subset of SUS standards and not all of them. This means, theoretically, that the
    programs developed for a Unix-compliant system are supposed to be portable to other
    Unix-compatible systems, but may not be ported to a Unix-like operating system.
    This is especially the case regarding the programs being ported from Linux to,
    or to Linux from, other Unix-compliant systems.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 符合 Unix 标准的系统完全符合 SUS 标准，但符合 Unix 标准的类似系统只部分符合该标准。这意味着类似 Unix 的系统只符合 SUS 标准的特定子集，而不是全部。这意味着，理论上，为符合
    Unix 标准的系统开发的程序应该可以移植到其他 Unix 兼容系统，但可能无法移植到类似 Unix 的操作系统。这尤其适用于从 Linux 移植到其他符合
    Unix 标准的系统，或从其他符合 Unix 标准的系统移植到 Linux 的程序。
- en: Having lots of Unix-like operating systems developed, especially after the birth
    of Linux, became the basis for giving this subset of SUS standards a specific
    name. They called it the **Portable Operating System Interface** (**POSIX**).
    We can say that POSIX is a subset of SUS standards that Unix-like systems chose
    to comply with.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Linux 诞生后类似 Unix 操作系统的开发增多，这个子集的 SUS 标准得到了一个特定的名称。它们称之为 **可移植操作系统接口**（**POSIX**）。我们可以这样说，POSIX
    是 Unix 类似系统选择遵守的 SUS 标准的子集。
- en: 'In the following link, you can find all of the diffe[rent interfaces that should
    be exposed in a POSI](http://pubs.opengroup.org/onlinepubs/9699919799/)X system:
    [http://pubs.opengroup.org/onlinepubs/9699919799/](http://pubs.opengroup.org/onlinepubs/9699919799/).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下链接中，您可以找到所有应在 POSIX 系统中公开的不同接口：[POSIX 系统中应公开的不同接口](http://pubs.opengroup.org/onlinepubs/9699919799/)：[POSIX
    系统中应公开的不同接口](http://pubs.opengroup.org/onlinepubs/9699919799/).
- en: As you can see in the link, there are similar interfaces in POSIX, just like
    there are in SUS. The standards are remarkably similar, but POSIX has enabled
    Unix standards to be applicable to a broader range of operating systems.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如链接中所示，POSIX 中有类似的接口，就像 SUS 中一样。这些标准非常相似，但 POSIX 使 Unix 标准适用于更广泛的操作系统。
- en: Unix-like operating systems, such as most Linux distributions, are POSIX-compliant
    from the beginning. That's why if you've worked with Ubuntu, you can work with
    FreeBSD Unix in the same manner.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 类 Unix 操作系统，如大多数 Linux 发行版，从一开始就符合 POSIX 标准。这就是为什么如果你使用过 Ubuntu，你同样可以用相同的方式使用
    FreeBSD Unix。
- en: However, that's not true for some operating systems such as Microsoft Windows.
    Microsoft Windows cannot be considered as POSIX-compliant, but further tools can be
    installed to make it a POSIX operating system, for example, *Cygwin*¸ a POSIX-compatible
    environment that runs natively on the Windows operating system.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于一些操作系统，如微软 Windows，情况并非如此。微软 Windows 不能被认为是 POSIX 兼容的，但可以安装额外的工具使其成为一个
    POSIX 操作系统，例如，*Cygwin*，这是一个在 Windows 操作系统上本地运行的 POSIX 兼容环境。
- en: This again shows that POSIX compatibility is about having a standard shell ring
    and not the kernel.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这再次表明，POSIX 兼容性关乎拥有一个标准的 shell 环境而不是内核。
- en: On a slight tangent, it was quite the story when Microsoft Windows became POSIX-compliant
    in the 1990s. However, over time, that support became deprecated.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微偏一下题，当微软 Windows 在 1990 年代成为 POSIX 兼容时，那真是一个故事。然而，随着时间的推移，这种支持已经过时了。
- en: Both SUS and POSIX standards dictate the interfaces. They both state what should
    be available, but they don't talk about how it should become available. Each Unix
    system has its own implementation of POSIX or SUS implementation. These implementations
    are then put in libc libraries that are part of the shell ring. In other words,
    in a Unix system, the shell ring contains a libc implementation that is exposed
    in a standard way. Subsequently, the shell ring will pass the request further
    down to the kernel ring to be processed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: SUS 和 POSIX 标准都规定了接口。它们都说明了应该有什么，但并没有讨论如何实现。每个 Unix 系统都有自己的 POSIX 或 SUS 实现。这些实现随后被放入
    shell 环境的 libc 库中。换句话说，在 Unix 系统中，shell 环境包含一个以标准方式公开的 libc 实现。随后，shell 环境会将请求进一步传递到内核环境以进行处理。
- en: Kernel interface to shell ring
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核到 shell 环境的接口
- en: In the previous section, we explained that the shell ring in a Unix system exposes
    the interfaces defined in the SUS or POSIX standard. There are mainly two ways
    to invoke a certain logic in the shell ring, either through the libc or using
    shell utility programs. A user application should either get linked with libc
    libraries to execute shell routines, or it should execute an existing utility
    program that's available in the system.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们解释了 Unix 系统中的 shell 环暴露了 SUS 或 POSIX 标准中定义的接口。在 shell 环中调用特定逻辑主要有两种方式，要么通过
    libc，要么使用 shell 实用程序。一个用户应用程序应该与 libc 库链接以执行 shell 例程，或者它应该执行系统中可用的现有实用程序。
- en: Note that the existing utility programs are themselves using the libc libraries.
    Therefore, we can generalize and state that all shell routines can be found in
    libc libraries. This gives even more importance to standard C libraries. If you
    want to create a new Unix system from scratch, you must write your own libc after
    having the kernel up and ready.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现有的实用程序程序本身正在使用 libc 库。因此，我们可以概括地说，所有 shell 例程都可以在 libc 库中找到。这使标准 C 库的重要性更加突出。如果你要从头开始创建一个新的
    Unix 系统，你必须在使用并准备好内核之后编写自己的 libc。
- en: If you have followed the flow of this book and have read the previous chapters,
    you'll see that pieces of the puzzle are coming together. We needed to have a
    compilation pipeline and a linking mechanism to be able to design an operating
    system that exposes an interface and has been implemented using a set of library
    files. At this point, you are able to see that every feature of C is acting in
    favor of having Unix. The more you understand about the relationship between C
    and Unix, the more you find them tied together.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经跟随了这本书的流程并阅读了前面的章节，你会发现拼图碎片正在拼凑在一起。我们需要有一个编译管道和链接机制，以便能够设计一个暴露接口并使用一系列库文件实现的操作系统。在这个阶段，你能够看到
    C 的每个特性都在有利于 Unix。你对 C 和 Unix 之间关系的理解越深，你会发现它们联系得越紧密。
- en: Now that the relationship between user applications and the shell ring is clear,
    we need to see how the shell ring (or libc) communicates with the kernel ring.
    Before we go any further, note that, in this section, we are not going to explain
    what a kernel is. Instead, we are going to look at it as a black box exposing
    certain functionalities.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户应用程序和 shell 环之间的关系已经清楚，我们需要看看 shell 环（或 libc）是如何与内核环通信的。在我们继续之前，请注意，在本节中，我们不会解释什么是内核。相反，我们将将其视为一个暴露某些功能的黑盒。
- en: The main mechanism that libc (or the functions in shell ring) uses to consume
    a kernel functionality is through using *system calls*. To explain this mechanism,
    we need to have an example to follow down the rings of the onion model in order
    to find the place where system calls are used to do certain things.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: libc（或 shell 环中的函数）用来消耗内核功能的主要机制是通过使用 *系统调用*。为了解释这个机制，我们需要有一个例子来跟随洋葱模型的层级，以便找到系统调用用于执行某些操作的地方。
- en: We also need to choose a real libc implementation, so we can track down the
    sources and find the system calls. We choose FreeBSD for further investigations.
    FreeBSD is a Unix-like operating system branched from the BSD [Unix.](https://github.com/freebsd/freebsd0)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要选择一个真实的 libc 实现，这样我们就可以追踪源代码并找到系统调用。我们选择 FreeBSD 进行进一步的研究。FreeBSD 是一个从
    BSD [Unix](https://github.com/freebsd/freebsd0) 分支出来的类 Unix 操作系统。
- en: '[**Note**:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[**注意**：'
- en: 'The Git repository of FreeBSD can be found here: https://github.com/freebsd/freebsd.
    This repository contains the sources for FreeBSD''s kernel and shell rings. The
    sources for FreeBSD libc can be found in the `lib/libc` directory.](https://github.com/freebsd/freebsd0)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 的 Git 仓库可以在以下位置找到：https://github.com/freebsd/freebsd。这个仓库包含了 FreeBSD
    内核和 shell 环的源代码。FreeBSD libc 的源代码可以在 `lib/libc` 目录中找到。](https://github.com/freebsd/freebsd0)
- en: Let's start with the following example. *Example 10.1* is a simple program that
    just waits for one second. Likewise, the program is considered to be in the application
    ring, which means it is a user application, even though it is remarkably simple.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下示例开始。*示例 10.1* 是一个简单的程序，它仅仅等待一秒钟。同样，该程序被认为是处于应用环中，这意味着它是一个用户应用程序，尽管它非常简单。
- en: 'So, let''s first look at the source code of *example 10.1*:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们首先看看 *示例 10.1* 的源代码：
- en: '[PRE0]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Code Box 10-1 [ExtremeC_examples_chapter10_1.c]: Example 10.1 calling the sleep
    function included from the shell ring'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 10-1 [ExtremeC_examples_chapter10_1.c]：示例 10.1 调用来自 shell 环的 sleep 函数
- en: As you can see, the code includes the `unistd.h` header file and calls the `sleep`
    function, both of which are part of the SUS exposed interfaces. But then what
    happens next, especially in the `sleep` function? As a C programmer, you may have
    never asked yourself this question before, but knowing it can enhance your understanding
    of a Unix system.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，代码包含了`unistd.h`头文件，并调用了`sleep`函数，这两者都是SUS公开接口的一部分。但接下来会发生什么，尤其是在`sleep`函数中？作为一个C程序员，你可能以前从未问过自己这个问题，但了解这一点可以增强你对Unix系统的理解。
- en: We have always used functions such as `sleep`, `printf`, and `malloc`, without
    knowing how they work internally, but now we want to take a leap of faith and
    discover the mechanism that libc uses to communicate with the kernel.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直使用`sleep`、`printf`和`malloc`等函数，而不了解它们内部是如何工作的，但现在我们想要迈出一大步，发现libc与内核通信的机制。
- en: We know that system calls, or *syscalls* for short, are being triggered by the
    codes written in a libc implementation. In fact, this is the way that kernel routines
    are triggered. In SUS, and subsequently in POSIX-compatible systems, there is
    a program that is used to trace system calls when a program is running.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，系统调用，或简称为*syscalls*，是由libc实现中编写的代码触发的。实际上，这就是触发内核例程的方式。在SUS中，以及随后的POSIX兼容系统中，有一个程序用于在程序运行时跟踪系统调用。
- en: We are almost certain that a program that doesn't call system calls literally
    cannot do anything. So, as a result, we know that every program that we write
    has to use system calls through calling the libc functions.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎可以肯定，一个没有调用系统调用的程序实际上什么都不能做。因此，结果是，我们知道我们编写的每个程序都必须通过调用libc函数来使用系统调用。
- en: 'Let''s compile the preceding example and find out the system calls that it
    triggers. We can start this process by running:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译前面的示例，找出它所触发的系统调用。我们可以通过运行以下命令开始这个过程：
- en: '[PRE1]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Shell Box 10-1: Building and running example 10.1 using truss to trace the
    system calls that it invokes'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 10-1：使用truss跟踪调用系统调用的10.1示例的构建和运行
- en: 'As you can see in *Shell Box 10-1*, we have used a utility program called `truss`.
    The following text is an excerpt from the FreeBSD''s manual page for `truss`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如*Shell Box 10-1*中所示，我们使用了一个名为`truss`的实用程序。以下文本是FreeBSD的`truss`手册页的摘录：
- en: '"The truss utility traces the system calls called by the specified process
    or program. The output is to the specified output file or standard error by default.
    It does this by stopping and restarting the process being monitored via ptrace(2)."'
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"truss实用程序跟踪指定进程或程序调用的系统调用。默认情况下，输出到指定的输出文件或标准错误。它是通过ptrace(2)停止和重新启动被监控的进程来实现的。"'
- en: As the description implies, `truss` is a program for seeing all system calls
    that a program has invoked during the execution. Utilities similar to truss are
    available in most Unix-like systems. For instance, `strace` can be used in Linux
    systems.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如描述所暗示的，`truss`是一个程序，用于查看程序在执行过程中所调用的所有系统调用。大多数类Unix系统中都有类似truss的实用程序。例如，Linux系统中可以使用`strace`。
- en: 'The following shell box shows the output of `truss` being used to monitor the
    system calls invoked by the preceding example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下shell框展示了使用`truss`监控前一个示例所调用的系统调用的输出：
- en: '[PRE2]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Shell Box 10-2: Output of truss showing the system calls invoked by example
    10.1'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 10-2：truss的输出，显示了10.1示例调用的系统调用
- en: As you can see in the preceding output, there are many system calls initiated
    by our simple example, with some of them being about loading shared object libraries,
    especially when initializing the process. The first system call shown in bold
    opens the `libc.so.7` shared object library file. This shared object library contains
    the actual implementation of FreeBSD's libc.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述输出所示，我们的简单示例触发了许多系统调用，其中一些是关于加载共享对象库的，尤其是在初始化进程时。第一个以粗体显示的系统调用是打开`libc.so.7`共享对象库文件。这个共享对象库包含了FreeBSD的libc的实际实现。
- en: In the same shell box, you can see that the program is calling the `nanosleep`
    system call. The value passed to this system call is 1000000000 nanoseconds, which
    is equivalent to 1 second.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个shell框中，你可以看到程序正在调用`nanosleep`系统调用。传递给这个系统调用的值是1000000000纳秒，相当于1秒。
- en: System calls are like function calls. Note that each system call has a dedicated
    and predetermined constant number, and subsequently, together with that, it has
    a specific name, and a list of arguments. Each system call also performs a specific
    task. In this case, `nanosleep` makes the calling thread sleep for the specified
    number of nanoseconds.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用就像函数调用一样。请注意，每个系统调用都有一个专用且预定的常数值，并且随后，与该值一起，它有一个特定的名称和参数列表。每个系统调用也执行特定的任务。在这种情况下，`nanosleep`使调用线程休眠指定的纳秒数。
- en: 'More information regarding the system calls can be found in the FreeBSD *system
    calls manual*. The following shell box shows the page dedicated to the `nanosleep`
    system call in the manual:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 关于系统调用的更多信息可以在FreeBSD的*系统调用手册*中找到。以下shell box显示了手册中专门针对`nanosleep`系统调用的页面：
- en: '[PRE3]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Shell Box 10-3: The manual page dedicated to the nanosleep system call'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 10-3：专门针对nanosleep系统调用的手册页
- en: 'The preceding manual page describes the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的手册页描述如下：
- en: '`nanosleep` is a system call.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nanosleep`是一个系统调用。'
- en: The system call is accessible through calling the `nanosleep` and `clock_nanosleep`
    functions from the shell ring defined in `time.h`. Note that we used the `sleep`
    function from `unitsd.h`. We could also use the preceding two functions from `time.h`.
    It's also worth noting that both header files and all of the preceding functions,
    together with the functions actually used, are part of SUS and POSIX.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统调用可以通过从`time.h`中定义的shell环调用`nanosleep`和`clock_nanosleep`函数来访问。请注意，我们使用了`unitsd.h`中的`sleep`函数。我们也可以使用`time.h`中的前两个函数。还值得注意的是，这两个头文件以及所有前面的函数，以及实际使用的函数，都是SUS和POSIX的一部分。
- en: If you want to be able to call these functions, you need to link your executable
    against libc by passing the `-lc` option to your linker. This might be specific
    to FreeBSD only.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想要能够调用这些函数，您需要通过将`-lc`选项传递给链接器来将可执行文件链接到libc。这可能仅适用于FreeBSD。
- en: This manual page doesn't talk about the system call itself, but it talks about
    the standard C API, which is exposed from the shell ring. These manuals are written
    for application developers and, as such, they won't discuss the systems calls
    and kernel internals often. Instead, they focus on the APIs exposed from the shell
    ring.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个手册页没有讨论系统调用本身，而是讨论了从shell环公开的标准C API。这些手册是为应用程序开发者编写的，因此它们不会经常讨论系统调用和内核内部。相反，它们专注于从shell环公开的API。
- en: 'Now, let''s find the place in libc where the system call is actually invoked.
    We will be using FreeBSD sources on GitHub. The commit hash we are using is `bf78455d496`
    from the master branch. In order to clone and use the proper commit from the repository,
    run the following commands:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们找到在libc中实际调用系统调用的位置。我们将使用GitHub上的FreeBSD源代码。我们使用的提交哈希是来自master分支的`bf78455d496`。为了从存储库克隆并使用正确的提交，请运行以下命令：
- en: '[PRE4]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Shell Box 10-4: Cloning the FreeBSD project and going to a specific commit'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 10-4：克隆FreeBSD项目并转到特定的提交
- en: 'It is also possibl[e to navigate the FreeBSD project on the GitHub website](https://github.com/freebsd/freebsd/tree/bf78455d496)
    itself using the following link: [https://github.com/freebsd/freebsd/tree/bf78455d496](https://github.com/freebsd/freebsd/tree/bf78455d496).
    No matter what method you use to navigate the project, you should be able to find
    the following line of codes.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用以下链接在GitHub网站上导航FreeBSD项目本身：[https://github.com/freebsd/freebsd/tree/bf78455d496](https://github.com/freebsd/freebsd/tree/bf78455d496)。无论您使用什么方法导航项目，您都应该能够找到以下代码行。
- en: 'If you go into the `lib/libc` directory and do a `grep` for `sys_nanosleep`,
    you will find the following file entries:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您进入`lib/libc`目录并使用`grep`搜索`sys_nanosleep`，您将找到以下文件条目：
- en: '[PRE5]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Shell Box 10-5: Finding the entries related to the nanosleep system call in
    FreeBSD libc files'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 10-5：在FreeBSD libc文件中查找与nanosleep系统调用相关的条目
- en: As you can see in the `lib/libc/sys/interposing_table.c` file, the `nanosleep`
    function is mapped to the `__sys_nanosleep` function. Therefore, any function
    call targeted at `nanosleep` will cause `__sys_nanosleep` to be invoked.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在`lib/libc/sys/interposing_table.c`文件中所见，`nanosleep`函数映射到`__sys_nanosleep`函数。因此，任何针对`nanosleep`的函数调用都会导致`__sys_nanosleep`被调用。
- en: The functions starting with `__sys` are actual system call functions in FreeBSD
    convention. Note that this is part of the libc implementation, and the used naming
    convention and other implementation-related configurations are highly specific
    to FreeBSD.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以`__sys`开头的函数是FreeBSD约定中的实际系统调用函数。请注意，这是libc实现的一部分，使用的命名约定和其他与实现相关的配置对FreeBSD来说非常具体。
- en: Having said all of that there's also another interesting point in the preceding
    shell box. The `lib/libc/include/libc_private.h` file contains the private and
    internal function declarations required for the wrapper functions around the system
    calls.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这么多，前一个shell框中还有一个有趣的观点。`lib/libc/include/libc_private.h`文件包含了围绕系统调用所需的私有和内部函数声明。
- en: So far, we have seen how shell rings route the function calls made to libc to
    the inner rings by using system calls. But why do we need system calls in the
    first place? Why is it called a system call and not a function call? When looking
    at an ordinary function in a user application or libc, how is it different from
    a system call in the kernel ring? In *Chapter 11*, *System Calls and Kernels*,
    we will discuss this further by giving a more concrete definition of a system
    call.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了shell环是如何通过系统调用来将libc中的函数调用路由到内环的。但为什么我们最初需要系统调用呢？为什么它被称为系统调用而不是函数调用？当我们查看用户应用程序或libc中的普通函数时，它与内核环中的系统调用有何不同？在*第11章*，*系统调用与内核*中，我们将通过给出系统调用的更具体定义来进一步讨论这个问题。
- en: The next section is about the kernel ring and its internal units, which are
    common in kernels used by most Unix-compliant and Unix-like systems.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节是关于内核环及其内部单元，这些单元在大多数符合Unix和Unix-like系统的内核中很常见。
- en: Kernel
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核
- en: 'The main purpose of the kernel ring is to manage the hardware attached to a
    system and expose its functionalities as system calls. The following diagram shows
    how a specific hardware functionality is exposed through different rings before
    a user application can finally use it:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 内核环的主要目的是管理连接到系统的硬件，并通过系统调用暴露其功能。以下图表显示了在用户应用程序最终可以使用之前，特定硬件功能是如何通过不同的环暴露的：
- en: '![](img/B11046_10_04.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B11046_10_04.png)'
- en: 'Figure 10-4: Function calls and system calls made between various Unix rings
    in order to expose a hardware functionality'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-4：在各个Unix环之间进行的函数调用和系统调用，以暴露硬件功能
- en: The preceding diagram shows a summary of what we have explained so far. In this
    section, we are going to focus on the kernel itself and see what the kernel is.
    A kernel is a process that, like any other processes that we know, executes a
    sequence of instructions. But a **kernel process** is fundamentally different
    from an ordinary process, which we know as a **user process**.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表展示了我们到目前为止所解释的内容的总结。在本节中，我们将专注于内核本身，看看内核是什么。内核是一个像我们所知道的任何其他进程一样执行一系列指令的进程。但**内核进程**与我们所知的**用户进程**在本质上是有区别的。
- en: The following list compares a kernel process and a user process. Note that our
    comparison is biased to a monolithic kernel such as Linux. We will explain the
    different types of kernels in the next chapter.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表比较了内核进程和用户进程。请注意，我们的比较是有偏见的，偏向于像Linux这样的单核内核。我们将在下一章解释不同类型的内核。
- en: A kernel process is the first thing that is loaded and executed, but user processes
    need to have the kernel process loaded and running before being spawned.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核进程是首先被加载和执行的东西，但用户进程在创建之前需要内核进程被加载并运行。
- en: We only have one kernel process, but we can have many user processes working
    at the same time.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只有一个内核进程，但我们可以同时运行许多用户进程。
- en: The kernel process is created by copying a kernel image into the main memory
    by the boot loader, but a user process is created using the `exec` or `fork` system
    calls. These system calls exist in most Unix systems.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核进程是由引导加载程序将内核镜像复制到主内存中创建的，但用户进程是通过`exec`或`fork`系统调用创建的。这些系统调用存在于大多数Unix系统中。
- en: The kernel process handles and executes system calls, but a user process invokes
    the system call and waits for its execution handled by the kernel process. This
    means that, when a user process demands the execution of a system call, the flow
    of execution is transferred to the kernel process and it is the kernel itself
    that executes the system call's logic on behalf of the user process. We will clarify
    this in the second part of our look into Unix, *Chapter 11*, *System Calls and
    Kernel*.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核进程处理和执行系统调用，但用户进程调用系统调用并等待由内核进程处理的执行。这意味着，当用户进程要求执行系统调用时，执行流程会转移到内核进程，并且是内核本身代表用户进程执行系统调用的逻辑。我们将在第二部分关于
    Unix 的探讨中阐明这一点，即第 11 章，*系统调用和内核*。
- en: The kernel process sees the physical memory and all of the attached hardware
    in a *privileged* mode, but a user process sees the virtual memory, which is mapped
    to a portion of physical memory, where the user process doesn't know anything
    about the physical memory layout. Likewise, the user process has controlled and
    supervised access to resources and hardware. We can say that the user process
    is being executed in a sandbox simulated by the operating system. This also implies
    that a user process cannot see the memory of another user process.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核进程以 *特权* 模式看到物理内存和所有连接的硬件，但用户进程看到的是虚拟内存，它是映射到物理内存的一部分，用户进程对物理内存布局一无所知。同样，用户进程对资源和硬件拥有受控制和受监督的访问。我们可以这样说，用户进程是在操作系统模拟的沙盒中执行的。这也意味着一个用户进程无法看到另一个用户进程的内存。
- en: As it is understood from the preceding comparison, we have two different execution
    modes in an operating system's runtime. One of them is dedicated to the kernel
    process, and the other is dedicated to the user processes.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的比较所理解的那样，在操作系统的运行时中，我们有两种不同的执行模式。其中一种是为内核进程专用的，另一种是为用户进程专用的。
- en: The former execution mode is called *kernel land* or *kernel space*, and the
    latter is called *user land* or *user space*. Calling system calls by user processes
    is a way to bring these two lands together. Basically, we invented the system
    calls because we needed to isolate the kernel space and the user space from each
    other. Kernel space has the most privileged access to the system resources, and
    the user space has the least privileged and supervised access.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 前者执行模式被称为 *内核空间* 或 *内核地带*，后者被称为 *用户空间* 或 *用户地带*。用户进程通过调用系统调用来将这两个地带连接起来。基本上，我们发明系统调用是因为我们需要将内核空间和用户空间相互隔离。内核空间对系统资源拥有最高权限的访问，而用户空间拥有最低权限且受监督的访问。
- en: 'The internal structure of a typical Unix kernel can be discerned by the tasks
    a kernel performs. In fact, managing the hardware is not the only task that a
    kernel performs. The following is the list of a Unix kernel''s responsibilities.
    Note that we have included the hardware management tasks as well in the following
    list:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 典型 Unix 内核的内部结构可以通过内核执行的任务来识别。实际上，管理硬件并不是内核执行的唯一任务。以下是一个 Unix 内核职责的列表。请注意，我们在以下列表中也包括了硬件管理任务：
- en: '**Process management**: User processes are created by the kernel via a system
    call. Allocating memory for a new process and loading its instructions are some
    of the operations, among all of the operations, that should be performed before
    running a process.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程管理**：内核通过系统调用来创建用户进程。为新进程分配内存和加载其指令是运行进程之前应执行的操作之一。'
- en: '**Inter-Process Communication** (**IPC**): User processes on the same machine
    can use different methods for exchanging data among them. Some of these methods
    are shared memories, pipes, and Unix domain sockets. These methods should be facilitated
    by the kernel, and some of them need the kernel to control the exchange of data.
    We will explain these methods in *Chapter 19*, *Single Host IPC and Sockets*,
    while talking about IPC techniques.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程间通信**（**IPC**）：同一台机器上的用户进程可以使用不同的方法在它们之间交换数据。这些方法中的一些是共享内存、管道和 Unix 域套接字。这些方法应由内核提供便利，其中一些需要内核控制数据的交换。我们将在第
    19 章，*单主机 IPC 和套接字*中解释这些方法，同时讨论 IPC 技术。'
- en: '**Scheduling**: Unix has always been known as a multi-tasking operating system.
    The kernel manages access to CPU cores and tries to balance access to them. Scheduling
    is a name given to the task that shares the CPU time among many processes based
    on their priority and importance. We will explain more about multi-tasking, multithreading,
    and multi-processing in the following chapters.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调度**：Unix一直以多任务操作系统而闻名。内核管理对CPU核心的访问，并试图平衡对它们的访问。调度是根据它们的优先级和重要性在多个进程之间共享CPU时间的任务名称。我们将在接下来的章节中更详细地解释多任务、多线程和多进程。'
- en: '**Memory management**: Without doubt, this is one of the key tasks of a kernel.
    The kernel is the only process that sees the whole physical memory and has superuser
    access to it. So, the task of breaking it into allocatable pages, assigning new
    pages to the processes in case of Heap allocation, freeing the memory, and many
    more memory-related tasks besides, should be performed and managed by the kernel.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存管理**：毫无疑问，这是内核的关键任务之一。内核是唯一可以看到整个物理内存并对其具有超级用户访问权限的进程。因此，将内存分割成可分配的页面、在堆分配的情况下为新进程分配新页面、释放内存以及许多其他与内存相关的任务，都应该由内核执行和管理。'
- en: '**System startup**: Once the kernel image is loaded into the main memory and
    the kernel process is started, it should initialize the user space. This is usually
    done by creating the first user process with the **Process Identifier** (**PID**)
    1\. In some Unix systems such as Linux, this process is called *init*. After having
    this process started, further services and daemons will be started by it.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统启动**：一旦内核映像被加载到主内存中并且内核进程启动，它应该初始化用户空间。这通常是通过创建第一个用户进程，即带有**进程标识符**（**PID**）1的进程来完成的。在一些Unix系统，如Linux中，这个进程被称为*init*。在启动了这个进程之后，它将启动更多的服务和守护进程。'
- en: '**Device management**: Apart from the CPU and memory, the kernel should be
    able to manage hardware through an abstraction made over all of them. A *device*
    is a real or virtual hardware attached to a Unix system. A typical Unix system
    uses the `/dev` path to store mapped device files. All attached hard drives, network
    adapters, USB devices, etc. are mapped to files found in the `/dev` path. These
    device files can be used by user processes to communicate with these devices.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备管理**：除了CPU和内存之外，内核应该能够通过在所有这些硬件上创建的抽象来管理硬件。*设备*是连接到Unix系统的真实或虚拟硬件。典型的Unix系统使用`/dev`路径来存储映射的设备文件。所有连接的硬盘驱动器、网络适配器、USB设备等都被映射到`/dev`路径下找到的文件。这些设备文件可以被用户进程用来与这些设备通信。'
- en: 'The following diagram shows the most common internal structure of a Unix kernel
    based on the preceding list:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示显示了基于上述列表的Unix内核最常见的内部结构：
- en: '![](img/fig10-5.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fig10-5.png)'
- en: 'Figure 10-5: Internal structure of different rings in the Unix architecture'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-5：Unix架构中不同环的内部结构
- en: The preceding figure is a detailed illustration of Unix rings. It clearly shows
    that, in the shell ring, we have three parts that are exposed to the user applications.
    It also shows a detailed inner structure of the kernel ring.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示是Unix环的详细说明。它清楚地显示了在shell环中，我们有三个暴露给用户应用的组成部分。它还显示了内核环的详细内部结构。
- en: At the top in the kernel ring, we have the system call interface. As is clear
    in the figure, all of the preceding units that are in the user space must communicate
    with the bottom units only through the system call interface. This interface is
    like a gate or a barrier between user and kernel spaces.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核环的最顶部，我们有系统调用接口。如图所示，所有位于用户空间的前置单元必须仅通过系统调用接口与底部的单元进行通信。这个接口就像用户和内核空间之间的一个门或障碍。
- en: There are various units in the kernel such as the **Memory Management unit**
    (**MMU**) that manages the available physical memory. The **Process Management
    unit** creates processes in the user space and allocates resources for them. It
    also makes IPC available to processes. The diagram also shows the **Character**
    and **Block devices** that are mediated by the **Device Drivers** to expose the
    various I/O functionalities. We explain character and block devices in the following
    section. The **File System** unit is an essential part of the kernel, which is
    an abstraction over the block and character devices and lets the processes and
    the kernel itself use the same shared file hierarchy.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 内核中有各种单元，例如负责管理可用物理内存的**内存管理单元**（**MMU**）。**进程管理单元**在用户空间创建进程并为它们分配资源。它还使进程间通信（IPC）对进程可用。该图还显示了由**设备驱动程序**介导的**字符设备**和**块设备**，它们暴露了各种
    I/O 功能。我们将在下一节中解释字符和块设备。**文件系统**单元是内核的一个基本部分，它是对块设备和字符设备的抽象，并允许进程和内核本身使用相同的共享文件层次结构。
- en: In the next section, we are going to talk about hardware.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论硬件。
- en: Hardware
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件
- en: The final purpose of every operating system is to allow the user and the applications
    to be able to use and interact with hardware. Unix also aims to provide access
    to the attached hardware in an abstract and transparent way, using the same set
    of utility programs and commands in all existing and future platforms.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作系统的最终目的是允许用户和应用程序能够使用和与硬件交互。Unix 也旨在以抽象和透明的方式提供对连接硬件的访问，使用相同的实用程序和命令集在所有现有和未来的平台上。
- en: By having this transparency and abstraction, Unix abstracts all of the different
    hardware to be a number of devices attached to a system. So, the term *device*
    is centric in Unix, and every connected piece of hardware is considered to be
    a device connected to the Unix system.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种透明性和抽象，Unix 将所有不同的硬件抽象为连接到系统的一组设备。因此，*设备*在 Unix 中是核心的，每个连接的硬件部件都被认为是连接到
    Unix 系统的设备。
- en: 'The hardware attached to a computer can be categorized into two different categories:
    *mandatory* and *peripheral*. The CPU and main memory are mandatory devices attached
    to a Unix system. All other hardware such as the hard drive, network adapter,
    mouse, monitor, graphics card, and Wi-Fi adapter, are peripheral devices.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到计算机的硬件可以分为两个不同的类别：*必需*和*外围*。CPU 和主内存是连接到 Unix 系统的必需设备。所有其他硬件，如硬盘、网络适配器、鼠标、显示器、显卡和
    Wi-Fi 适配器，都是外围设备。
- en: A Unix machine cannot work without mandatory hardware, but you can have a Unix
    machine that doesn't have a hard drive or a network adapter. Note that having
    a filesystem, which is essential for a Unix kernel to operate, doesn't necessarily
    require a hard disk!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 机器没有必需的硬件是无法工作的，但你可以有一个没有硬盘或网络适配器的 Unix 机器。请注意，虽然文件系统对于 Unix 内核的运行是必需的，但这并不一定需要硬盘！
- en: A Unix kernel completely hides the CPU and physical memory. They are managed
    directly by the kernel, and no access is allowed to be made from the user space.
    The **Memory Management** and **Scheduler** units in a Unix kernel are responsible
    for managing the physical memory and the CPU, respectively.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 内核完全隐藏了 CPU 和物理内存。它们直接由内核管理，不允许用户空间进行访问。Unix 内核中的**内存管理**和**调度器**单元分别负责管理物理内存和
    CPU。
- en: This is not the case with other peripheral devices connected to a Unix system.
    They are exposed through a mechanism called *device files*. You can see these
    files in a Unix system as part of the `/dev` path.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 系统中连接的其他外围设备并非如此。它们通过称为*设备文件*的机制暴露出来。你可以在 Unix 系统的 `/dev` 路径下看到这些文件。
- en: 'The following is the list of files that can be found on an ordinary Linux machine:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在普通 Linux 机器上可以找到的文件列表：
- en: '[PRE6]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Shell Box 10-6: Listing the content of /dev on a Linux machine'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 10-6：在 Linux 机器上列出 /dev 的内容
- en: As you can see, it is quite a list of devices attached to the machine. But of
    course, not all of them are physical. The abstraction over the hardware devices
    in Unix has given it the ability to have *virtual devices*.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这是一份连接到机器的设备列表。但当然，并非所有这些设备都是物理的。Unix 对硬件设备的抽象使其能够拥有*虚拟设备*。
- en: For example, you can have a virtual network adapter that has no physical counterpart,
    but is able to perform additional operations on the network data. This is one
    of the ways that VPNs are being used in Unix-based environments. The physical
    network adapter brings the real network functionality, and the virtual network
    adapter gives the ability to transmit the data through a secure tunnel.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以有一个没有物理对应物的虚拟网络适配器，但它能够对网络数据进行额外的操作。这是VPN在基于Unix的环境中应用的一种方式。物理网络适配器提供了真实的网络功能，而虚拟网络适配器则赋予了通过安全隧道传输数据的能力。
- en: As is clear from the preceding output, each device has its own file in the `/dev`
    directory. The lines starting with `c` and `b` are device files representing character
    devices and block devices, respectively. Character devices are supposed to deliver
    and consume data byte by byte. Examples of such devices are serial ports, and
    parallel ports. Block devices are supposed to deliver and consume chunks of data
    that have more than one byte. Hard disks, network adapters, cameras, and so on
    are examples of block devices. In the preceding shell box, the lines starting
    with 'l' are symbolic links to other devices, and the lines starting with d represent
    directories that may contain other device files.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的输出所示，每个设备在`/dev`目录下都有自己的文件。以`c`和`b`开头的行分别代表字符设备和块设备。字符设备应该按字节逐个交付和消耗数据。此类设备的例子有串行端口和并行端口。块设备应该交付和消耗超过一个字节的数据块。硬盘、网络适配器、摄像头等都是块设备的例子。在前面的shell框中，以`l`开头的行是其他设备的符号链接，以`d`开头的行代表可能包含其他设备文件的目录。
- en: User processes use these device files in order to access the corresponding hardware.
    These files can be written or can be read in order to send or receive data to
    and from the device.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 用户进程使用这些设备文件来访问相应的硬件。这些文件可以被写入或读取，以便向设备发送或从设备接收数据。
- en: In this book, we won't go deeper than this, but if you are curious to know more
    about devices and device drivers, you should read more around this subject. In
    the next chapter, *Chapter 11*, *System Calls and Kernels*, we continue our talk
    about system calls in greater detail, and we will add a new system call to an
    existing Unix kernel.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们不会深入到这个程度，但如果你对设备和设备驱动程序感兴趣，你应该阅读更多关于这个主题的内容。在下一章，即第11章“系统调用与内核”中，我们将更详细地讨论系统调用，并将一个新的系统调用添加到现有的Unix内核中。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started to discuss Unix and how it is interrelated with
    C. Even in non-Unix operating systems, you see some traces of a similar design
    to Unix systems.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始讨论Unix及其与C的相互关系。即使在非Unix操作系统中，你也能看到一些与Unix系统类似的设计痕迹。
- en: 'As part of this chapter, we went through the history of the early 1970s and
    explained how Unix appeared from Multics and how C was derived from the B programming
    language. After that, we talked about the Unix architecture, an onion-like architecture
    that consists of four layers: user applications, the shell, the kernel, and hardware.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的一部分，我们回顾了20世纪70年代初的历史，并解释了Unix是如何从Multics演变而来，以及C语言是如何从B语言派生出来的。之后，我们讨论了Unix架构，这是一个类似洋葱的四层结构：用户应用、shell、内核和硬件。
- en: We briefly went over the various layers in the Unix onion model and provided
    detailed explanations of the shell layer. We introduced the C standard library
    and how it is used through POSIX and SUS standards to give programmers the ability
    to write programs that can be built on various Unix systems.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要地介绍了Unix洋葱模型中的各个层次，并详细解释了shell层。我们介绍了C标准库及其如何通过POSIX和SUS标准使用，为程序员提供编写可以在各种Unix系统上构建的程序的能力。
- en: In the second part of our look into Unix, *Chapter 11*, *System Calls and Kernels*,
    we will continue our discussion about Unix and its architecture, and we will provide
    explanations of the kernel and the system call interface surrounding it in greater depth.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们关于Unix的第二部分探讨中，即第11章“系统调用与内核”，我们将继续讨论Unix及其架构，并更深入地解释内核及其周围的系统调用接口。
