- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Integrating Third-Party Libraries and Dependency Management
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成第三方库和依赖管理
- en: So far in this book, we have covered how to build and install our own code with
    **CMake**. In this chapter, we will look at how to use files, libraries, and programs
    that are not part of a CMake project. The first part of the chapter will be about
    how to find those things in general, while the latter part will focus on how to
    manage dependencies to build your CMake project.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，在本书中，我们已经介绍了如何使用**CMake**构建和安装我们自己的代码。在本章中，我们将探讨如何使用那些不是 CMake 项目一部分的文件、库和程序。本章的第一部分将讲解如何一般性地查找这些内容，而后半部分将专注于如何管理依赖关系，以便构建你的
    CMake 项目。
- en: One of the biggest advantages of using CMake is that it has built-in dependency
    management for the discovery of many third-party libraries. In this chapter, we
    will look at how to integrate libraries that are installed on your system and
    locally downloaded dependencies. Additionally, you will learn how third-party
    libraries can be downloaded and used as binaries and, alternatively, how they
    can be built from source directly out of a CMake project.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CMake 的一个最大优势是，它内置了依赖管理功能，用于发现许多第三方库。在本章中，我们将探讨如何集成已安装在系统上的库和本地下载的依赖项。此外，你还将学习如何将第三方库作为二进制文件下载并使用，或者如何从源代码直接在
    CMake 项目中构建它们。
- en: 'We will look at how to write instructions for CMake to reliably find almost
    any library on your system. Finally, we will take a look at how to use package
    managers such as Conan and vcpkg with CMake. The practices for dependency management,
    as covered in this chapter, will help you to create stable and portable builds
    with CMake. It doesn’t matter if you are using precompiled binaries or compiling
    them in place from scratch, setting up CMake to handle dependencies in a structured
    and consistent way will reduce the time spent fixing broken builds in the future.
    Here’s the list of main topics that we’ll cover in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何为 CMake 编写指令，以便可靠地查找系统上的几乎任何库。最后，我们将看看如何在 CMake 中使用 Conan 和 vcpkg 等包管理器。依赖管理的实践，如本章所述，将帮助你创建稳定和可移植的
    CMake 构建。不管你是使用预编译的二进制文件，还是从头开始编译它们，设置 CMake 以结构化且一致的方式处理依赖关系，将减少未来修复损坏构建时所花费的时间。以下是我们将在本章中讨论的主要主题：
- en: Finding files, programs, and paths with CMake
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CMake 查找文件、程序和路径
- en: Using third-party libraries in your CMake project
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 CMake 项目中使用第三方库
- en: Using package managers with CMake
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 CMake 中使用包管理器
- en: Getting the dependencies as source code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取依赖项作为源代码
- en: Dependency providers – a new way of getting dependencies
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖提供者 – 获取依赖的新方式
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As with the previous chapters, all the examples are tested with CMake 3.24
    and run on any of the following compilers:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，所有示例都使用 CMake 3.24 进行测试，并能在以下任何编译器上运行：
- en: GCC 9 or newer
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCC 9 或更新版本
- en: Clang 12 or newer
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clang 12 或更新版本
- en: MSVC 19 or newer
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MSVC 19 或更新版本
- en: Additionally, some examples will need OpenSSL 3 installed to be able to compile.
    Some examples pull dependencies from various online locations, so an internet
    connection is also required. All of the examples and source code are available
    from the GitHub repository for this book, which can be found at [https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition/](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition/).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一些示例需要安装 OpenSSL 3 才能编译。某些示例从各种在线位置拉取依赖项，因此还需要互联网连接。所有示例和源代码都可以从本书的 GitHub
    仓库获得，地址是 [https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition/](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition/)。
- en: 'The examples for the external package managers require Conan (version 1.40
    or newer) and vcpkg installed on your system to run. You can get the software
    here:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 外部包管理器的示例需要在系统上安装 Conan（版本 1.40 或更新）和 vcpkg 才能运行。你可以在这里获取这些软件：
- en: '**Conan**: [https://conan.io/](https://conan.io/)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Conan**: [https://conan.io/](https://conan.io/)'
- en: '**Vcpkg**: [https://github.com/microsoft/vcpkg](https://github.com/microsoft/vcpkg)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Vcpkg**: [https://github.com/microsoft/vcpkg](https://github.com/microsoft/vcpkg)'
- en: Finding files, programs, and paths with CMake
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CMake 查找文件、程序和路径
- en: Most projects quickly grow to a size and complexity where they depend on files,
    libraries, and perhaps even programs that are managed outside the project. CMake
    provides built-in commands to find these things. At first glance, the process
    of searching and finding things appears to be quite simple. However, on closer
    analysis, there are quite a few things to consider. First, we must handle the
    search order of where to find the files or programs we are looking for. Then,
    we might want to add more locations where the file might be, and finally, we must
    account for the differences between different operating systems.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数项目很快会增长到一个规模和复杂性，依赖于项目外部管理的文件、库，甚至可能是程序。CMake 提供了内置命令来查找这些内容。乍一看，搜索和查找内容的过程似乎非常简单。然而，经过仔细分析，实际上需要考虑很多因素。首先，我们必须处理查找文件或程序时的搜索顺序。然后，我们可能需要添加更多可能包含文件的位置，最后，还必须考虑不同操作系统之间的差异。
- en: On an abstraction level higher than the individual files, CMake can find whole
    packages that define targets, include paths, and package-specific variables. Refer
    to the *Using third-party libraries in your CMake project* section for more detail.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在比单个文件更高的抽象层级上，CMake 可以查找定义了目标、包含路径和特定于包的变量的整个包。更多细节请参见*在 CMake 项目中使用第三方库*一节。
- en: 'There are five `find_...` commands that share very similar options and behaviors:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有五个 `find_...` 命令，它们共享非常相似的选项和行为：
- en: '`find_file`: This locates a single file'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_file`：用于定位单个文件'
- en: '`find_path`: This finds a directory containing a specific file'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_path`：用于查找包含特定文件的目录'
- en: '`find_library`: This finds library files'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_library`：用于查找库文件'
- en: '`find_program`: This finds executable programs'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_program`：用于查找可执行程序'
- en: '`find_package`: This finds complete sets of packages'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_package`：用于查找完整的包集合'
- en: All of these commands work similarly, but there are some small but important
    differences when it comes to where they look for things. In particular, `find_package`
    does more than just locate files; it not only looks for packages but makes the
    file content available for easy use in the CMake project. In this chapter, first,
    we will look at the simpler `find` functions before we cover how to find complex
    packages.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令的工作方式类似，但在查找位置方面有一些小但重要的差异。特别是，`find_package` 不仅仅是定位文件；它不仅查找包，还将文件内容提供给
    CMake 项目，方便使用。在本章中，我们将首先介绍较简单的 `find` 函数，然后再讲解如何查找复杂的包。
- en: Finding files and paths
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找文件和路径
- en: 'The most low-level and basic things to find are files and paths. The `find_file`
    and `find_path` functions share the same signature. The only difference between
    them is that `find_path` stores the directory in which a file is found in the
    result, while `find_file` stores the full path including the filename. The signature
    of the `find_file` command is shown as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 查找最底层和最基本的内容是文件和路径。`find_file` 和 `find_path` 函数具有相同的签名。它们的唯一区别是，`find_path`
    将文件找到的目录存储在结果中，而 `find_file` 会存储包括文件名在内的完整路径。`find_file` 命令的签名如下所示：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding command either searches for a single file, if the name has been
    passed directly, or for a list of likely names if the `NAMES` option has been
    used. The resulting path is stored in the variable passed as `<VAR>`. If the file
    cannot be found, the variable will contain `<VARIABLENAME>-NOTFOUND`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令要么直接搜索单个文件（如果名称已直接传递），要么搜索可能的名称列表（如果使用了 `NAMES` 选项）。结果路径会存储在传递的 `<VAR>`
    变量中。如果文件无法找到，变量将包含 `<VARIABLENAME>-NOTFOUND`。
- en: Passing a list of names is useful if the files being searched for have variations
    in their names such as different capitalizations or naming conventions that may
    or may not include version numbers and so on. When passing a list of names, the
    names should be ordered in a preferred way, as the search stops once the first
    file has been found.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 传递一个名称列表在搜索文件时非常有用，特别是当文件名存在变体时，例如大小写不同或命名约定不同，可能包含或不包含版本号等。传递名称列表时，名称应按首选顺序排序，因为一旦找到第一个文件，搜索就会停止。
- en: Searching for files containing version numbers
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索包含版本号的文件
- en: It is recommended that you search for filenames without version numbers before
    searching for those that contain some form of version numbering. This is so that
    locally built files are preferred to the ones installed by the operating system.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐在搜索包含版本号的文件之前，先搜索没有版本号的文件名。这是为了确保本地构建的文件优先于操作系统安装的文件。
- en: The `HINTS` and `PATHS` options contain additional locations to the default
    locations where the file is searched for. `PATH_SUFFIXES` could contain several
    subdirectories that are searched below each of the other locations.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`HINTS` 和 `PATHS` 选项包含附加的位置，文件将在这些位置下进行搜索。`PATH_SUFFIXES` 可以包含几个子目录，这些子目录将在其他位置下进行搜索。'
- en: 'The `find_…` commands search for things in defined places and within a defined
    order. The `NO_..._PATH` arguments of the commands can be used to skip the respective
    location. The following table shows the order of the search locations and the
    options for skipping a location:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_…` 命令在定义的地方并按定义的顺序搜索内容。命令的 `NO_..._PATH` 参数可用于跳过相应的路径。下表显示了搜索位置的顺序以及跳过位置的选项：'
- en: '| **Location** | **The skip option in** **the command** |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| **位置** | **命令中的跳过选项** |'
- en: '| Package root variables | `NO_PACKAGE_ROOT_PATH` |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 包根变量 | `NO_PACKAGE_ROOT_PATH` |'
- en: '| CMake-specific cache variables | `NO_CMAKE_PATH` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| CMake 特定的缓存变量 | `NO_CMAKE_PATH` |'
- en: '| CMake-specific environment variables | `NO_CMAKE_ENVIRONMENT_PATH` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| CMake 特定的环境变量 | `NO_CMAKE_ENVIRONMENT_PATH` |'
- en: '| Paths from the `HINTS` option |  |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 来自 `HINTS` 选项的路径 |  |'
- en: '| System-specific environment variables | `NO_SYSTEM_ENVIRONMENT_PATH` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 系统特定的环境变量 | `NO_SYSTEM_ENVIRONMENT_PATH` |'
- en: '| System-specific cache variables | `NO_CMAKE_SYSTEM_PATH` |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 系统特定的缓存变量 | `NO_CMAKE_SYSTEM_PATH` |'
- en: '| Paths from the `PATHS` option |  |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 来自 `PATHS` 选项的路径 |  |'
- en: 'Let’s look at the search order more closely along with what the different locations
    mean:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下搜索顺序以及不同位置的含义：
- en: '`find_file` is used as part of the `find_package` command. Please refer to
    the *Using third-party libraries in your CMake project* section for an in-depth
    discussion.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_file` 是 `find_package` 命令的一部分。有关详细讨论，请参考 *在 CMake 项目中使用第三方库* 部分。'
- en: '`CMAKE_PREFIX_PATH`, `CMAKE_INLCUDE_PATH`, and `CMAKE_FRAMEWORK_PATH` cache
    variables for macOS. Generally, setting the `CMAKE_PREFIX_PATH` cache variable
    is preferred over the other two types, as this is used for all of the `find_`
    commands. The prefix path is the base point for any searches under which the common
    file structures such as `bin`, `lib`, `include`, and more are located. `CMAKE_PREFIX_PATH`
    is a list of paths, and for each entry, `find_file` will search `<prefix>/include`
    or `<prefix>/include/${CMAKE_LIBRARY_ARCHITECTURE}` if the respective variable
    has been set. Generally, Cmake sets the variables automatically, and they should
    not be changed by the developers. Architecture-specific paths take precedence
    over generic paths.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_PREFIX_PATH`、`CMAKE_INCLUDE_PATH` 和 `CMAKE_FRAMEWORK_PATH` 是 macOS 的缓存变量。通常，设置
    `CMAKE_PREFIX_PATH` 缓存变量比其他两种类型更为优选，因为它用于所有的 `find_` 命令。前缀路径是进行搜索的基准点，常见的文件结构如
    `bin`、`lib`、`include` 等都位于该路径下。`CMAKE_PREFIX_PATH` 是路径列表，对于每个条目，`find_file` 将在
    `<prefix>/include` 或 `<prefix>/include/${CMAKE_LIBRARY_ARCHITECTURE}` 下搜索（如果相应的变量已被设置）。通常，CMake
    会自动设置这些变量，开发人员不应更改它们。特定架构的路径优先于通用路径。'
- en: The `CMAKE_INCLUDE_PATH` and `CMAKE_FRAMEWORK_PATH` cache variables should only
    be used if the standard directory structure is not applicable. They do not add
    additional `include` suffixes to the paths.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果标准目录结构不适用，则应仅使用 `CMAKE_INCLUDE_PATH` 和 `CMAKE_FRAMEWORK_PATH` 缓存变量。它们不会在路径中添加额外的
    `include` 后缀。
- en: Searching these paths can be skipped by passing the `NO_CMAKE_PATH` option to
    the command or, globally, by setting the `CMAKE_FIND_USE_PATH` variable to `false`.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将 `NO_CMAKE_PATH` 选项传递给命令，或者通过全局设置 `CMAKE_FIND_USE_PATH` 变量为 `false`，可以跳过这些路径的搜索。
- en: '`CMAKE_PREFIX_PATH`, `CMAKE_INCLUDE_PATH`, and `CMAKE_FRAMEWORK_PATH` system
    environment variables. The variables work in the same way as the cache variables,
    but they are usually set from outside the call to CMake.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_PREFIX_PATH`、`CMAKE_INCLUDE_PATH` 和 `CMAKE_FRAMEWORK_PATH` 是系统环境变量。这些变量的工作方式与缓存变量相同，但通常是从
    CMake 调用外部设置的。'
- en: Note that, on Unix platforms, the lists are separated by colons (`:`) instead
    of semicolons (`;`)to conform to the platform-specific environment variables.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请注意，在 Unix 平台上，列表是通过冒号 (`:`) 分隔的，而不是分号 (`;`)，以符合平台特定的环境变量。
- en: Paths from the `HINTS` option are the additional search locations that are manually
    specified. They could be constructed from other values such as property values,
    or they could depend on a previously found file or path.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 `HINTS` 选项的路径是手动指定的附加搜索位置。它们可以从其他值（如属性值）构造，或者可能依赖于先前找到的文件或路径。
- en: '`INCLUDE` and `PATH` environment variables could each contain a list of directories
    to be searched. Again, on Unix platforms, the list is separated by colons (`:`)
    instead of semicolons (`;`).'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INCLUDE` 和 `PATH` 环境变量每个都可以包含一个目录列表供查找。再者，在 Unix 平台上，列表用冒号 (`:`) 分隔，而不是分号
    (`;`)。'
- en: On Windows, the `PATHS` entries are handled in a more complex manner. For each
    entry, a base path is extracted by dropping any trailing `bin` or `sbin` directory.
    If `CMAKE_LIBRARY_ARCHITECTURE` is set, the `include/${CMAKE_LIBRARY_ARCHITECTURE}`
    subdirectory is added as the priority for each path. After that, `include` (without
    a postfix) is searched. Only then, the original path, which might or might not
    end in `bin` or `sbin`, is searched. Passing either the `NO_SYSTEM_ENVIRONMENT_PATH`
    variable or setting the `CMAKE_FIND_USE_CMAKE_SYSTEM_PATH` variable to `false`
    will skip the locations in the environment variables.
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Windows 上，`PATHS` 条目的处理方式更为复杂。对于每个条目，通过删除任何尾部的 `bin` 或 `sbin` 目录来提取基础路径。如果设置了
    `CMAKE_LIBRARY_ARCHITECTURE`，则会将 `include/${CMAKE_LIBRARY_ARCHITECTURE}` 子目录作为每个路径的优先级进行添加。之后，会搜索
    `include`（不带后缀）。然后，再搜索原始路径，这个路径可能以 `bin` 或 `sbin` 结尾，也可能不以其结尾。如果传递了 `NO_SYSTEM_ENVIRONMENT_PATH`
    变量或将 `CMAKE_FIND_USE_CMAKE_SYSTEM_PATH` 变量设置为 `false`，将跳过环境变量中的位置。
- en: 'Assuming that the `PATH` option contains `C:\myfolder\bin;C:\yourfolder`, and
    `CMAKE_LIBRARY_ARCHITECTURE` is set to `x86_64`, the search order will be as follows:'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设 `PATH` 选项包含 `C:\myfolder\bin;C:\yourfolder`，并且设置了 `CMAKE_LIBRARY_ARCHITECTURE`
    为 `x86_64`，则搜索顺序如下：
- en: '`C:\myfolder\include\x86_64`'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`C:\myfolder\include\x86_64`'
- en: '`C:\myfolder\include\`'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`C:\myfolder\include\`'
- en: '`C:\myfolder\bin`'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`C:\myfolder\bin`'
- en: '`C:\yourfolder\include\x86_64`'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`C:\yourfolder\include\x86_64`'
- en: '`C:\yourfolder\include\`'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`C:\yourfolder\include\`'
- en: '`C:\yourfolder\`'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`C:\yourfolder\`'
- en: '`CMAKE_SYSTEM_PREFIX_PATH` and `CMAKE_SYSTEM_FRAMEWORK_PATH` variables work
    similarly to the CMake-specific cache variables. These variables are not supposed
    to be changed by the developer but are configured when CMake sets up the platform
    toolchain. One exception here is if a toolchain file is provided, such as when
    using sysroot or cross-compiling, as explained in [*Chapter 12*](B30947_12.xhtml#_idTextAnchor182),
    *Cross-Platform Compiling and* *Custom Toolchains*.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_SYSTEM_PREFIX_PATH` 和 `CMAKE_SYSTEM_FRAMEWORK_PATH` 变量的作用类似于 CMake 特定的缓存变量。这些变量不应由开发者修改，而是当
    CMake 设置平台工具链时进行配置。唯一的例外是当提供了工具链文件时，例如使用 sysroot 或进行交叉编译时，如在 [*第 12 章*](B30947_12.xhtml#_idTextAnchor182)
    中解释的，*跨平台编译与* *自定义工具链*。'
- en: In addition to the `NO_CMAKE_SYSTEM_PATH` option, the `CMAKE_FIND_USE_CMAKE_SYSTEM_PATH`
    variable can be set to `false` to skip searching in locations provided by the
    system-specific cache variables.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了 `NO_CMAKE_SYSTEM_PATH` 选项，`CMAKE_FIND_USE_CMAKE_SYSTEM_PATH` 变量可以设置为 `false`，以跳过系统特定缓存变量提供的位置。
- en: In the same way as the `HINTS` option, paths specified in the `PATHS` option
    are additional search locations that are manually provided. Although not technically
    prevented, it is the convention that the `PATHS` variables should be fixed paths
    and not depend on other values.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 `HINTS` 选项一样，`PATHS` 选项中指定的路径是手动提供的附加搜索位置。虽然技术上没有禁止，按照惯例，`PATHS` 变量应是固定路径，不应依赖于其他值。
- en: If only the locations provided by `HINTS` or `PATHS` are to be searched, adding
    the `NO_DEFAULT_PATH` option skips all the other locations.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只希望搜索由 `HINTS` 或 `PATHS` 提供的位置，添加 `NO_DEFAULT_PATH` 选项将跳过所有其他位置。
- en: Occasionally, you might want to ignore particular paths for searching. In such
    cases, a list of paths might be specified in `CMAKE_IGNORE_PATH` or `CMAKE_SYSTEM_IGNORE_PATH`.
    Both of these variables were designed with cross-compiling scenarios in mind and
    are rarely used in other circumstances.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能希望忽略某些特定的搜索路径。在这种情况下，可以在 `CMAKE_IGNORE_PATH` 或 `CMAKE_SYSTEM_IGNORE_PATH`
    中指定路径列表。这两个变量是为交叉编译场景设计的，其他情况下很少使用。
- en: Searching for files when cross-compiling
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找交叉编译时的文件
- en: When cross-compiling, the process of searching for files is often different
    because cross-compilation toolchains are collected under their own self-contained
    directory structure, which does not mix with the system toolchain. Generally,
    first, you will want to look inside the toolchain’s directory for files. By setting
    the `CMAKE_FIND_ROOT` variable, the origin for all searches can be changed to
    a new location.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 进行交叉编译时，查找文件的过程通常有所不同，因为交叉编译工具链被收集在其自身的独立目录结构下，这与系统工具链不混合。通常，首先你会想要在工具链的目录中查找文件。通过设置
    `CMAKE_FIND_ROOT` 变量，可以将所有查找的源更改为新位置。
- en: Additionally, the `CMAKE_SYSROOT`, `CMAKE_SYSROOT_COMPILE`, and `CMAKE_SYSROOT_LINK`
    variables affect the search locations, but they should only be set in a toolchain
    file, not by a project itself. If any of the regular search locations are already
    under the sysroot or the location specified by `CMAKE_FIND_ROOT`, they will not
    be changed. Any path that starts with a tilde (`~`), and is passed to the `find_`
    commands, will not be changed to avoid skipping directories that are under the
    user’s home directory.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`CMAKE_SYSROOT`、`CMAKE_SYSROOT_COMPILE`和`CMAKE_SYSROOT_LINK`变量会影响搜索位置，但它们只应在工具链文件中设置，而不是由项目本身设置。如果任何常规搜索位置已经在sysroot中或由`CMAKE_FIND_ROOT`指定的位置下，它们将不会被更改。任何以波浪号（`~`）开头的路径，并传递给`find_`命令时，不会被更改，以避免跳过位于用户主目录下的目录。
- en: By default, first, CMake searches in the locations provided by any of the variables
    from the preceding paragraph and then continues to search the host system. This
    behavior can be changed globally by setting the `CMAKE_FIND_ROOT_PATH_MODE_INCLUDE`
    variable to either `BOTH`, `NEVER`, or `ONLY`. Alternatively, you can set the
    `CMAKE_FIND_ROOT_PATH_BOTH` option, the `ONLY_CMAKE_FIND_ROOT_PATH` option, or
    the `NO_CMAKE_FIND_ROOT_PATH` option to `find_file`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，CMake首先在前述段落中提供的任何变量指定的位置进行搜索，然后继续搜索主机系统。通过将`CMAKE_FIND_ROOT_PATH_MODE_INCLUDE`变量设置为`BOTH`、`NEVER`或`ONLY`，可以全局更改此行为。或者，您可以将`find_file`的`CMAKE_FIND_ROOT_PATH_BOTH`选项、`ONLY_CMAKE_FIND_ROOT_PATH`选项或`NO_CMAKE_FIND_ROOT_PATH`选项进行设置。
- en: 'The following table shows the search order when setting either of the options
    or the variables in the different search modes:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了在不同搜索模式下设置任何选项或变量时的搜索顺序：
- en: '| **Mode** | **Option** | **Search order** |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| **模式** | **选项** | **搜索顺序** |'
- en: '| --- | --- | --- |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `BOTH` | `CMAKE_FIND_ROOT_PATH_BOTH` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `BOTH` | `CMAKE_FIND_ROOT_PATH_BOTH` |'
- en: '`CMAKE_FIND_ROOT_PATH`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_FIND_ROOT_PATH`'
- en: '`CMAKE_SYSROOT_COMPILE`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_SYSROOT_COMPILE`'
- en: '`CMAKE_SYSROOT_LINK`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_SYSROOT_LINK`'
- en: '`CMAKE_SYSROOT`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_SYSROOT`'
- en: All regular search locations
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有常规搜索位置
- en: '|'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `NEVER` | `NO_CMAKE_FIND_ROOT_PATH` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `NEVER` | `NO_CMAKE_FIND_ROOT_PATH` |'
- en: All regular search locations
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有常规搜索位置
- en: '|'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `ONLY` | `ONLY_CMAKE_FIND_ROOT_PATH` | `CMAKE_FIND_ROOT_PATH`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '| `ONLY` | `ONLY_CMAKE_FIND_ROOT_PATH` | `CMAKE_FIND_ROOT_PATH`'
- en: '`CMAKE_SYSROOT_COMPILE`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_SYSROOT_COMPILE`'
- en: '`CMAKE_SYSROOT_LINK`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_SYSROOT_LINK`'
- en: '`CMAKE_SYSROOT`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_SYSROOT`'
- en: Any regular paths, one of the other locations, or under `CMAKE_STAGING_PREFIX`
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何常规路径，其他位置之一，或`CMAKE_STAGING_PREFIX`下
- en: '|'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The `CMAKE_STAGING_PREFIX` variable is used to provide installation paths for
    cross-compiling. `CMAKE_SYSROOT` should not be changed by installing things into
    it. Setting up cross-compilation toolchains will be covered in detail in [*Chapter
    12*](B30947_12.xhtml#_idTextAnchor182), *Cross-Platform Compiling and Custom Toolchains*,
    where we talk about cross-compiling.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMAKE_STAGING_PREFIX`变量用于为交叉编译提供安装路径。通过安装内容到其中，`CMAKE_SYSROOT`不应被更改。关于交叉编译工具链的设置，我们将在[*第12章*](B30947_12.xhtml#_idTextAnchor182)，“*跨平台编译与自定义工具链*”中详细讨论。'
- en: Finding programs
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找程序
- en: Finding executables is very similar to finding files and paths, and the `find_program`
    command has almost the same signature as `find_file`. Additionally, `find_program`
    has the `NAMES_PER_DIR` option, which tells the command to search one directory
    at a time and search for all provided filenames in each directory instead of searching
    through each directory for each file.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 查找可执行文件与查找文件和路径非常相似，`find_program`命令的签名几乎与`find_file`相同。此外，`find_program`有`NAMES_PER_DIR`选项，指示命令一次只搜索一个目录，并在每个目录中搜索所有提供的文件名，而不是在每个文件中搜索每个目录。
- en: On Windows, the `.exe` and `.com` file extensions are automatically added to
    the filenames provided, but not `.bat` or `.cmd`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，`.exe`和`.com`文件扩展名会自动添加到提供的文件名中，但`.bat`或`.cmd`不会。
- en: 'The cache variables used by `find_program` are slightly different from the
    ones used by `find_file`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_program`使用的缓存变量与`find_file`使用的缓存变量略有不同：'
- en: '`find_program` automatically adds `bin` and `sbin` to the search locations
    provided by `CMAKE_PREFIX_PATH`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_program`会自动将`bin`和`sbin`添加到由`CMAKE_PREFIX_PATH`提供的搜索位置中'
- en: Values in `CMAKE_LIBRARY_ARCHITECTURE` are ignored and have no effect
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_LIBRARY_ARCHITECTURE`中的值会被忽略，并且没有任何效果'
- en: '`CMAKE_PROGRAM_PATH` is used instead of `CMAKE_INCLUDE_PATH`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_PROGRAM_PATH`替代了`CMAKE_INCLUDE_PATH`'
- en: '`CMAKE_APPBUNDLE_PATH` is used instead of `CMAKE_FRAMEWORK_PATH`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_APPBUNDLE_PATH`替代了`CMAKE_FRAMEWORK_PATH`'
- en: '`CMAKE_FIND_ROOT_PATH_MODE_PROGRAM` is used to change the mode for searching
    programs'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_FIND_ROOT_PATH_MODE_PROGRAM`用于更改查找程序的模式'
- en: As with the other `find` commands, `find_program` will set the `<varname>-NOTFOUND`
    variable if CMake is unable to find the program. This is often handy to determine
    whether a custom build step that depends on a certain external program should
    be enabled or not.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他`find`命令一样，`find_program`会在CMake无法找到程序时设置`<varname>-NOTFOUND`变量。这通常对于判断是否启用某个依赖特定外部程序的自定义构建步骤非常有用。
- en: Finding libraries
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找库
- en: Finding libraries is a special case of finding files, so the `find_library`
    command supports the same set of options as `find_file`. Also, similar to the
    `find_program` command, it has the additional `NAMES_PER_DIR` option that checks
    for all filenames first, before moving to the next directory. The difference between
    finding regular files and finding libraries is that `find_library` automatically
    applies platform-specific naming conventions to the filenames. On Unix platforms,
    the names will be prefixed with `lib`, while on Windows, the `.dll` or `.lib`
    extensions will be added.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 查找库是查找文件的一种特殊情况，因此`find_library`命令支持与`find_file`相同的选项集。此外，与`find_program`命令类似，它还有额外的`NAMES_PER_DIR`选项，该选项会首先检查所有文件名，然后再进入下一个目录。查找常规文件和查找库之间的区别在于，`find_library`会自动根据平台特定的命名约定来处理文件名。在Unix平台上，文件名前会加上`lib`，而在Windows上，会添加`.dll`或`.lib`扩展名。
- en: 'Again, the cache variables are slightly different from the ones used in `find_file`
    and `find_program`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，缓存变量与`find_file`和`find_program`中使用的变量略有不同：
- en: '`find_library` adds `lib` to the search locations by `CMAKE_PREFIX_PATH`, and
    it uses `CMAKE_LIBRARY_PATH` instead of `CMAKE_INCLUDE_PATH` to find libraries.
    The `CMAKE_FRAMEWORK_PATH` variable is used similarly to `find_file`. The `CMAKE_LIBRARY_ARCHITECTURE`
    variable works the same as in `find_file`.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_library`通过`CMAKE_PREFIX_PATH`将`lib`添加到搜索路径中，并使用`CMAKE_LIBRARY_PATH`代替`CMAKE_INCLUDE_PATH`来查找库。`CMAKE_FRAMEWORK_PATH`变量的使用方式类似于`find_file`。`CMAKE_LIBRARY_ARCHITECTURE`变量与`find_file`中的用法相同。'
- en: This is done by appending the respective folders to the search paths. `find_library`
    searches the locations in the `PATH` environment variable in the same way as `find_file`,
    but it appends `lib` to each prefix. Also, it uses the `LIB` environment variable
    if this has been set instead of the `INCLUDE` variable.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将相应的文件夹附加到搜索路径来实现此操作。`find_library`以与`find_file`相同的方式搜索`PATH`环境变量中的位置，但会在每个前缀中附加`lib`。另外，如果已设置`LIB`环境变量，它将使用该变量，而不是使用`INCLUDE`变量。
- en: '`CMAKE_FIND_ROOT_PATH_MODE_LIBRARY` is used to change the mode for searching
    libraries.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_FIND_ROOT_PATH_MODE_LIBRARY`用于更改搜索库的模式。'
- en: CMake is generally aware of conventions regarding 32-bit and 64-bit search locations
    such as platforms using the `lib32` and `lib64` folders for different libraries
    of the same name. The behavior is controlled by the `FIND_LIBRARY_USE_LIB[32|64|X32]_PATHS`
    variables, which control what should be searched first. Additionally, projects
    can define their own suffix using the `CMAKE_FIND_LIBRARY_CUSTOM_LIB_SUFFIX` variable,
    which overrides the behavior of the other variables. However, the need to do this
    is very rare, and tampering with the search order inside a `CMakeLists.txt` file
    quickly makes projects hard to maintain and heavily impacts the portability between
    systems.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: CMake通常会识别32位和64位搜索位置的命名约定，例如某些平台使用`lib32`和`lib64`文件夹来存放同名的不同库。此行为由`FIND_LIBRARY_USE_LIB[32|64|X32]_PATHS`变量控制，该变量决定了应先搜索什么。项目还可以使用`CMAKE_FIND_LIBRARY_CUSTOM_LIB_SUFFIX`变量定义自己的后缀，从而覆盖其他变量的行为。然而，通常情况下不需要这样做，修改`CMakeLists.txt`文件中的搜索顺序会迅速使项目变得难以维护，并且对不同系统之间的可移植性产生重大影响。
- en: Finding static or shared libraries
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找静态库或共享库
- en: 'In most cases, simply passing the base name of a library to CMake works well
    enough, but sometimes, the behavior has to be overridden. One reason for this
    is that on some platforms, the static version of a library should be preferred
    over the shared one or vice versa. The best way to do this is to split up the
    `find_library` call into two calls instead of trying to achieve this in a single
    call. It is more robust if the static library is in a different directory from
    the dynamic one:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，直接将库的基本名称传递给CMake就足够了，但有时需要覆盖默认行为。这样做的原因之一是，在某些平台上，应该优先使用库的静态版本而不是共享版本，或者反之。最好的方法是将`find_library`调用拆分为两个调用，而不是试图在一个调用中实现此目标。如果静态库和动态库位于不同的目录中，这样的做法更为稳健：
- en: '[PRE1]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: On Windows, this approach cannot be used, as static libraries and import libraries
    for DLLs do have the same `.lib` suffix, so they are not distinguishable by name.
    The `find_file`, `find_path`, `find_program`, and `find_library` commands are
    often handy when looking for specific things. On the other hand, finding dependencies
    happens on a higher level. This is where CMake excels by providing the `find_package`
    methods. With `find_package`, we do not need to, first, search for all the `include`
    files, followed by all the library files, and then add them manually to each target
    and, in the end, account for all platform-specific behaviors. Let’s dive into
    the process of how to find dependencies next.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，这种方法无法使用，因为静态库和 DLL 的导入库具有相同的 `.lib` 后缀，因此无法通过名称区分它们。`find_file`、`find_path`、`find_program`
    和 `find_library` 命令在查找特定内容时非常有用。另一方面，查找依赖项发生在更高的层次。这正是 CMake 擅长的地方，通过提供 `find_package`
    方法。使用 `find_package`，我们无需首先查找所有的 `include` 文件，再查找所有的库文件，然后手动将它们添加到每个目标中，最后还要考虑所有平台特有的行为。接下来，让我们深入了解如何查找依赖项的过程。
- en: Using third-party libraries in your CMake project
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 CMake 项目中使用第三方库
- en: If you’re writing software in earnest, sooner or later, you will hit the point
    where your project will rely on libraries from outside your project. Instead of
    looking for individual library files or header files, the recommended way to integrate
    third-party code into CMake-projects is to use the `find_package` command to use
    CMake packages. Packages provide a set of information about dependencies for CMake
    and the generated build systems. They can be integrated into a project in two
    forms, either by their configuration details (also called *config packages*),
    or as so-called `find` module packages. Config packages are usually provided by
    the upstream project, while packages using `find` modules are usually defined
    either by CMake itself or by the project using the package. Both types can be
    found by using `find_package`, and the result is a set of imported targets and/or
    a set of variables containing information that is relevant to the build system.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在认真实践软件开发，迟早你会遇到项目依赖外部库的情况。与其寻找单独的库文件或头文件，推荐的将第三方代码集成到 CMake 项目的方式是使用 `find_package`
    命令来使用 CMake 包。包为 CMake 和生成的构建系统提供了有关依赖项的一系列信息。它们可以以两种形式集成到项目中，分别是通过它们的配置详情（也称为
    *config 包）或所谓的 `find` 模块包。配置包通常由上游项目提供，而使用 `find` 模块的包通常由 CMake 本身或使用该包的项目定义。两种类型的包都可以通过
    `find_package` 查找，结果是一组导入的目标和/或一组包含与构建系统相关的信息的变量。
- en: The `findPkgConfig` module, which uses the `pkg-config` tool provided by [freedesktop.org](https://www.freedesktop.org/wiki/)
    to find the relevant meta-information for a dependency, also provides indirect
    support for packages.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`findPkgConfig` 模块使用 [freedesktop.org](https://www.freedesktop.org/wiki/) 提供的
    `pkg-config` 工具查找依赖项的相关元信息，也间接地支持包。'
- en: Typically, `find` modules are used for locating dependencies, for instance,
    when the upstream does not provide the necessary information for package configuration.
    They are not to be confused with CMake utility modules, which are used with `include()`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`find` 模块用于定位依赖项，例如当上游没有提供包配置所需的信息时。它们不应与 CMake 工具模块混淆，后者是与 `include()` 一起使用的。
- en: Use packages provided from upstream over find modules
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量使用上游提供的包，而不是使用 `find` 模块。
- en: Whenever possible, use a package provided by the upstream source instead of
    creating a `find` module. If the upstream project lacks the necessary information,
    try to fix it at the source rather than writing a new `find` module.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能，使用上游来源提供的包，而不是创建 `find` 模块。如果上游项目缺少必要的信息，尽量在源头上修复，而不是编写一个新的 `find` 模块。
- en: 'Note that the `find_package` command has two signatures: a basic or short signature
    and a full or long signature. In almost all scenarios, using the short signature
    is sufficient for finding the packages we’re looking for, and it should be preferred
    because it is easier to maintain. The short form supports both the module and
    config packages, but the long form only supports configuration mode.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`find_package` 命令有两种签名：基本的或简短的签名和完整的或长的签名。在几乎所有场景中，使用简短的签名就足够找到了我们需要的包，并且它应该更受青睐，因为它更容易维护。简短形式支持模块包和配置包，而长形式仅支持配置模式。
- en: 'The signature of the short mode is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 简短模式的签名如下：
- en: '[PRE2]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let’s suppose we want to write a program that converts a string into a SHA-256
    hash by using the appropriate functionality of the OpenSSL library. To compile
    and link this example, we have to inform CMake that this project needs the OpenSSL
    library and then attach it to the target. For the moment, let’s assume that the
    necessary libraries have been installed at a default location on your system;
    for example, by using a regular package manager such as apt, RPM, or similar for
    Linux, Chocolatey for Windows, or brew for macOS.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想编写一个程序，通过使用 OpenSSL 库的适当功能将字符串转换为 SHA-256 哈希。为了编译和链接这个例子，我们必须告诉 CMake 项目需要
    OpenSSL 库，然后将其附加到目标上。暂时假设所需的库已经通过默认位置安装在您的系统上；例如，通过使用 Linux 的常规包管理器如 apt、RPM 或类似的工具，Windows
    的 Chocolatey，或 macOS 的 brew。
- en: 'A sample `CMakeLists.txt` file might look like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一个样例 `CMakeLists.txt` 文件可能如下所示：
- en: '[PRE3]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding example does the following things:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 前述示例执行以下操作：
- en: On the first line in the example, there is a `find_package(OpenSSL REQUIRED
    COMPONENTS SSL)` call. This tells CMake that we’re looking for a set of libraries
    and header files for OpenSSL. Specifically, we’re looking for the *SSL* component
    and ignoring any other components provided by the OpenSSL package. The `REQUIRED`
    keyword tells CMake that finding this package is required to build this project.
    If the package is not found, CMake will fail with an error.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在示例的第一行中，有一个 `find_package(OpenSSL REQUIRED COMPONENTS SSL)` 调用。这告诉 CMake 我们正在寻找
    OpenSSL 的一组库和头文件。具体来说，我们正在寻找 *SSL* 组件，并忽略 OpenSSL 包提供的任何其他组件。`REQUIRED` 关键字告诉
    CMake 找到此包对于构建此项目是必需的。如果找不到该包，CMake 将失败并显示错误。
- en: Once the package has been found, we tell CMake to link the library to the target
    using `target_link_libary`. Specifically, we tell CMake to link the `OpenSSL::SSL`
    target provided by the package OpenSSL.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦找到了包，我们告诉 CMake 使用 `target_link_libary` 将库链接到目标。具体地，我们告诉 CMake 链接由 OpenSSL
    包提供的 `OpenSSL::SSL` 目标。
- en: 'If a dependency has to be of a certain version, it can be specified either
    as a single version of the `major[.minor[.patch[.tweak]]]` format or as a version
    range with the `versionMin..[<]versionMax` format. For version ranges, both `versionMin`
    and `versionMax` should have the same format, and by specifying `<`, the upper
    version will be excluded. In this case, the `find_package` call will look something
    like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个依赖项必须是特定版本，则可以指定为 `major[.minor[.patch[.tweak]]]` 格式的单个版本，或者作为 `versionMin..[<]versionMax`
    格式的版本范围。对于版本范围，`versionMin` 和 `versionMax` 应具有相同的格式，通过指定 `<`，将排除上限版本。在这种情况下，`find_package`
    调用将看起来像这样：
- en: '[PRE4]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will tell CMake to look for any version 3.0.x of OpenSSL. In this case,
    the number of the patch level will be ignored to match the version number. If
    the version should match exactly, the `EXACT` keyword can be specified, however,
    this is rarely used.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉 CMake 查找任何版本为 3.0.x 的 OpenSSL。在这种情况下，补丁级别的数字将被忽略以匹配版本号。如果版本需要精确匹配，可以指定
    `EXACT` 关键字，但这很少使用。
- en: 'Unfortunately, as of May 2024, CMake cannot query the modules for the available
    components. So, we have to rely on the documentation of the modules or library
    providers to find out which components are available. The available modules can
    be queried with the following commands:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，截至 2024 年 5 月，CMake 无法查询模块以获取可用的组件。因此，我们必须依赖于模块或库提供者的文档来查找可用的组件。可以使用以下命令查询可用的模块：
- en: '[PRE5]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A list of modules shipped with CMake can be found at [https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html](https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 [https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html](https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html)
    找到一系列与 CMake 一起提供的模块。
- en: Finding individual libraries and files
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 查找单独的库和文件
- en: It is possible to look for individual libraries and files, but the preferred
    way is to use packages. Finding individual files and making them available to
    CMake will be covered in the *Writing your own find* *module* section.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 可以查找单独的库和文件，但首选方式是使用包。在 *编写您自己的查找模块* 部分将介绍如何查找单独的文件并使其可用于 CMake。
- en: When run in module mode, the `find_package` command searches for files called
    `Find<PackageName>.cmake`; this occurs, first, in the paths specified by `CMAKE_MODULE_PATH`
    and then among the `find` modules provided by the CMake installation. If you wish
    to learn how to create CMake packages, head over to [*Chapter 4*](B30947_04.xhtml#_idTextAnchor071),
    *Packaging, Deploying, and Installing a* *CMake Project*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块模式下运行时，`find_package` 命令会查找名为 `Find<PackageName>.cmake` 的文件；首先在由 `CMAKE_MODULE_PATH`
    指定的路径中查找，然后在 CMake 安装提供的 `find` 模块中查找。如果你想了解如何创建 CMake 包，可以查看 [*第4章*](B30947_04.xhtml#_idTextAnchor071)，*CMake项目的打包、部署与安装*。
- en: 'When run in config mode, `find_package` searches for files called after any
    of the following patterns:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置模式下运行时，`find_package` 会按照以下模式查找文件：
- en: '`<``lowercasePackageName>-config.cmake`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<``小写包名>-config.cmake`'
- en: '`<``PackageName>Config.cmake`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<``PackageName>Config.cmake`'
- en: '`<lowercasePackageName>-config-version.cmake` (if the version details were
    specified)'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<小写包名>-config-version.cmake`（如果指定了版本详情）'
- en: '`<PackageName>ConfigVersion.cmake` (if the version details were specified)'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<PackageName>ConfigVersion.cmake`（如果指定了版本详情）'
- en: 'All searches will be conducted over a set of locations in a well-defined order;
    if needed, some of the locations can be skipped by passing the respective option
    to CMake. `find_package` contains a few more options than the other `find_` commands.
    The following table shows the search order from a high level:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 所有搜索将按照一组明确定义的顺序进行；如果需要，某些位置可以通过将相应的选项传递给 CMake 来跳过。`find_package` 比其他 `find_`
    命令包含更多选项。下表显示了搜索顺序的高级概述：
- en: '| **Location** | **Skip option in** **the command** |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| **位置** | **命令中的跳过选项** |'
- en: '| Package root variables | `NO_PACKAGE_ROOT_PATH` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 包根变量 | `NO_PACKAGE_ROOT_PATH` |'
- en: '| CMake-specific cache variables | `NO_CMAKE_PATH` |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| CMake特定缓存变量 | `NO_CMAKE_PATH` |'
- en: '| CMake-specific environment variables | `NO_CMAKE_ENVIRONMENT_PATH` |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| CMake特定环境变量 | `NO_CMAKE_ENVIRONMENT_PATH` |'
- en: '| Paths specified in the `HINTS` option |  |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 在 `HINTS` 选项中指定的路径 |  |'
- en: '| System-specific environment variables | `NO_SYSTEM_ENVIRONMENT_PATH` |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 系统特定环境变量 | `NO_SYSTEM_ENVIRONMENT_PATH` |'
- en: '| User package registry | `NO_CMAKE_PACKAGE_REGISTRY` |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 用户包注册表 | `NO_CMAKE_PACKAGE_REGISTRY` |'
- en: '| System-specific cache variables | `NO_CMAKE_SYSTEM_PATH` |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 系统特定缓存变量 | `NO_CMAKE_SYSTEM_PATH` |'
- en: '| System package registry | `NO_CMAKE_SYSTEM_PACKAGE_REGISTRY` |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 系统包注册表 | `NO_CMAKE_SYSTEM_PACKAGE_REGISTRY` |'
- en: '| Paths specified in the `PATHS` option |  |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 在 `PATHS` 选项中指定的路径 |  |'
- en: 'Let’s look at the search order and search locations more closely:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看搜索顺序和搜索位置：
- en: '`find_package` call is stored in a variable called `<PackageName>_ROOT`. They
    are the priority for searching files belonging to a package. The package root
    variables work in the same way as `CMAKE_PREFIX_PATH`, not just for the call to
    `find_package` but for all other `find_` calls that might happen inside the `find`
    module belonging to the package.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_package` 调用会存储在名为 `<PackageName>_ROOT` 的变量中。它们是搜索属于某个包的文件的优先级。包根变量的作用与
    `CMAKE_PREFIX_PATH` 相同，不仅适用于 `find_package` 的调用，也适用于在该包的 `find` 模块中可能发生的所有其他 `find_`
    调用。'
- en: '`CMAKE_PREFIX_PATH`. For macOS, the `CMAKE_FRAMEWORK_PATH` variable is also
    considered a search location.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_PREFIX_PATH`。对于 macOS，还会考虑将 `CMAKE_FRAMEWORK_PATH` 变量作为搜索位置。'
- en: By setting the `CMAKE_FIND_USE_CMAKE_PATH` variable to `false`, the locations
    from the CMake-specific cache variables will be skipped.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将 `CMAKE_FIND_USE_CMAKE_PATH` 变量设置为 `false`，可以跳过 CMake 特定缓存变量中的位置。
- en: '`CMAKE_PREFIX_PATH` and `CMAKE_FRAMEWORK_PATH` as cache variables, CMake will
    also consider them if they are set as environment variables.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_PREFIX_PATH` 和 `CMAKE_FRAMEWORK_PATH` 作为缓存变量时，CMake 也会考虑它们是否被设置为环境变量。'
- en: Setting the `CMAKE_FIND_USE_ENVIRONMENT_PATH` variable to `false` will disable
    this behavior.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `CMAKE_FIND_USE_ENVIRONMENT_PATH` 变量设置为 `false` 会禁用此行为。
- en: '`HINTS` from `find_package` is an optional path passed to `find_package`.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_package` 中的 `HINTS` 是一个可选路径，传递给 `find_package`。'
- en: '`PATH` environment variable is used to look for packages and files and the
    trailing `bin` and `sbin` directories are removed. The default locations for each
    system, such as `/usr`, `/lib`, and similar locations, are usually searched at
    this point.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATH` 环境变量用于查找包和文件，并且会去除末尾的 `bin` 和 `sbin` 目录。此时，系统的默认位置，如 `/usr`、`/lib` 等，通常会被搜索。'
- en: '`CMAKE_PREFIX_PATH` option. Package registries are another way to tell CMake
    where to look for dependencies. Package registries are special locations where
    collections of packages reside. The user registry is valid for the current user
    account, while the system package registry is valid system-wide. On Windows, the
    location for the user package registry is stored in the Windows registry under
    the following:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_PREFIX_PATH`选项。包注册表是告诉CMake在哪里查找依赖项的另一种方式。包注册表是包含一组包的特殊位置。用户注册表对当前用户账户有效，而系统包注册表在系统范围内有效。在Windows上，用户包注册表的位置存储在Windows注册表中，路径如下：'
- en: '`HKEY_CURRENT_USER\Software\Kitware\CMake\Packages\<packageName>\`'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HKEY_CURRENT_USER\Software\Kitware\CMake\Packages\<packageName>\`'
- en: 'On the Unix platform, it is stored in the user’s home directory as follows:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Unix平台上，它被存储在用户的主目录中，路径如下：
- en: '`~/.``cmake/packages/<PackageName>`'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~/.``cmake/packages/<PackageName>`'
- en: '`find_package`, the platform-specific `CMAKE_SYSTEM_PREFIX_PATH`, `CMAKE_SYSTEM_FRAMEWORK_PATH`,
    and `CMAKE_SYSTEM_APPBUNDLE_PATH` cache variables work similarly to the other
    find calls. They are set by CMake itself and should not be changed by the project.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_package`、平台特定的`CMAKE_SYSTEM_PREFIX_PATH`、`CMAKE_SYSTEM_FRAMEWORK_PATH`和`CMAKE_SYSTEM_APPBUNDLE_PATH`缓存变量的工作方式与其他查找调用类似。它们由CMake本身设置，不应由项目修改。'
- en: '`HKEY_LOCAL_MACHINE\Software\Kitware\CMake\Packages\<packageName>\`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HKEY_LOCAL_MACHINE\Software\Kitware\CMake\Packages\<packageName>\`'
- en: Unix systems do not provide a system package registry.*   `PATHS` from `find_package`
    is an optional path that is passed to `find_package`. Usually, the `HINTS` options
    are computed from other values or depend on variables, whereas the `PATHS` options
    are fixed paths.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unix系统不提供系统包注册表。* `PATHS`来自`find_package`，是传递给`find_package`的可选路径。通常，`HINTS`选项是根据其他值计算的，或者依赖于变量，而`PATHS`选项是固定路径。
- en: 'Specifically, when looking for packages in config mode, CMake will look for
    the following file structure under the various prefixes:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在配置模式下查找包时，CMake将会在各种前缀下查找以下文件结构：
- en: '[PRE6]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'On macOS platforms, the following folders are also searched:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS平台上，还会搜索以下文件夹：
- en: '[PRE7]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can find out more about packages in the official CMake documentation at
    [https://cmake.org/cmake/help/latest/manual/cmake-packages.7.html](https://cmake.org/cmake/help/latest/manual/cmake-packages.7.html).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方CMake文档中了解有关包的更多信息，链接：[https://cmake.org/cmake/help/latest/manual/cmake-packages.7.html](https://cmake.org/cmake/help/latest/manual/cmake-packages.7.html)。
- en: In terms of modules, so far, we’ve only covered how to find existing modules.
    But what happens if we want to look for dependencies that are neither integrated
    into CMake, nor in the standard places, or they do not provide configuration instructions
    for CMake? Well, let’s find out about that in the next section.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 就模块而言，到目前为止，我们只讨论了如何查找现有的模块。但是如果我们想查找那些既没有集成到CMake中，也不在标准位置，或者没有为CMake提供配置说明的依赖项怎么办呢？好吧，让我们在下一节中了解一下。
- en: Writing your own find module
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写您自己的查找模块
- en: While CMake is almost an industry standard, there are still lots of libraries
    out there that are not managed with CMake or that are managed with CMake but do
    not export a CMake package. If they can be installed in the default location of
    a system or when using a package manager, finding these libraries is usually not
    a problem. Unfortunately, this is not always possible. A common case is when using
    a proprietary third-party library that is only needed for a certain project or
    that uses a different version of a library to build from the one that is installed
    by the systems package manager or if the package is not available in that package
    manager.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管CMake几乎已成为行业标准，但仍然有许多库没有使用CMake进行管理，或者虽然使用CMake管理，但没有导出CMake包。如果它们能够安装到系统的默认位置或使用包管理器时，这些库通常不成问题。不幸的是，这并非总是可行。一个常见的情况是使用专有的第三方库，该库只为某个特定项目所需，或者使用与系统包管理器安装的版本不同的库进行构建，或者该包在包管理器中不可用。
- en: If you’re developing multiple projects side by side, you might want to handle
    the dependencies locally for each project. Either way, it is good practice to
    set up your project in a way so that dependencies are managed locally and do not
    depend too much on what is installed on the system. For this reason, using package
    managers such as Conan or vcpkg as described in the *Using package managers with
    CMake* section is preferred over writing your own `find` modules.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在同时开发多个项目，可能希望为每个项目在本地处理依赖项。无论哪种方式，最好将项目设置成这样：依赖项在本地管理，而不是过度依赖系统中已安装的内容。因此，使用包管理工具（如Conan或vcpkg），如*在CMake中使用包管理工具*章节中所述，优于自己编写`find`模块。
- en: Creating fully reproducible builds is described in [*Chapter 12*](B30947_12.xhtml#_idTextAnchor182),
    *Cross-Platform Compiling and Custom Toolchains*; however, knowing how to write
    your own `find` module is handy and gives good insights into how CMake’s packages
    work. If no module and no configuration file exist for a dependency, often, writing
    your so-called `find` module is the quickest solution. The goal is to provide
    enough information so that, later, we can use any package by using `find_package`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完全可重现的构建在[*第12章*](B30947_12.xhtml#_idTextAnchor182)中有描述，*跨平台编译与自定义工具链*；不过，了解如何编写自己的`find`模块很有用，并且能帮助我们深入了解CMake的包如何工作。如果没有模块或配置文件用于某个依赖项，通常编写自己的所谓`find`模块是最快的解决方法。目标是提供足够的信息，以便稍后我们可以通过`find_package`使用任何包。
- en: '`find` modules are instructions for CMake on how to find the necessary header
    and binary files for a library and which create imported targets for CMake to
    use. As described earlier in this chapter, when invoking `find_package` in module
    mode, CMake searches for files called `Find<PackageName>.cmake` in `CMAKE_MODULE_PATH`.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`模块是CMake的指令，告诉它如何找到库所需的头文件和二进制文件，并创建供CMake使用的导入目标。如本章前面所述，在模块模式下调用`find_package`时，CMake会在`CMAKE_MODULE_PATH`中搜索名为`Find<PackageName>.cmake`的文件。'
- en: 'Let’s assume that we’re building a project where the dependencies have already
    been downloaded or built and have been placed into a folder called `dep` before
    we use them. For this example, let’s assume we use a library called `obscure`;
    in this case, the `find` module would be called `FindObscure.cmake`. So, the project
    structure might look like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在构建一个项目，其中依赖项已经被下载或构建，并已放入一个名为`dep`的文件夹中，然后再使用它们。在这个示例中，假设我们使用一个名为`obscure`的库；在这种情况下，`find`模块将被命名为`FindObscure.cmake`。因此，项目结构可能如下所示：
- en: '[PRE8]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The first thing we have to do is to add the `cmake` folder to the `CMAKE_MODULE_PATH`,
    which is a list. So, first, we add the following line to the `CMakeLists.txt`
    file:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的就是将`cmake`文件夹添加到`CMAKE_MODULE_PATH`中，这其实是一个列表。因此，首先我们在`CMakeLists.txt`文件中添加以下行：
- en: '[PRE9]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This tells CMake that it should look for `find` modules in the `cmake` folder.
    Typically, a `find` module does things in the following order:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉CMake，它应该在`cmake`文件夹中查找`find`模块。通常，`find`模块按以下顺序执行：
- en: It looks for files belonging to the package.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它查找属于该包的文件。
- en: It sets up variables containing the `include` and `library` directories for
    the packages.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它为包设置包含目录和库目录的变量。
- en: It sets up targets for the imported package.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它为导入的包设置目标。
- en: It sets properties for the targets.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它为目标设置属性。
- en: 'A simple `FindModules.cmake` for a library called `obscure` might look like
    this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的`FindModules.cmake`文件，用于名为`obscure`的库，可能如下所示：
- en: '[PRE10]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When looking at the example, we can observe that the following things happen:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 看这个示例时，我们可以观察到以下几件事情：
- en: First, the actual `library` file belonging to the dependency is searched for
    using the `find_library` command. If found, the path to it, including the actual
    filename, is stored in the `OBSCURE_LIBRARY` variable. It is a common practice
    to name the `<PACKAGENAME>_LIBRARY` variable. The `NAMES` argument is a list of
    possible names for the library. The names are automatically extended with common
    prefixes and extensions. So, although, in the preceding example, we look for a
    file named `obscure`, a file named `libobscure.so` or `obscure.dll` will be found.
    More details about the search order, hints, and paths will be covered later in
    this section.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用`find_library`命令搜索属于依赖项的实际`library`文件。如果找到，文件的路径（包括实际文件名）将存储在`OBSCURE_LIBRARY`变量中。通常做法是将变量命名为`<PACKAGENAME>_LIBRARY`。`NAMES`参数是一个可能的库名称列表。这些名称会自动扩展为常见的前缀和扩展名。因此，尽管在前面的示例中我们寻找的是名为`obscure`的文件，但实际上会找到一个名为`libobscure.so`或`obscure.dll`的文件。关于搜索顺序、提示和路径的更多细节将在本节后面讲解。
- en: Next, the `find` module attempts to locate the `include` path. This is done
    by finding a known path pattern of the library, usually one of the public header
    files. The result is stored in the `OBSCURE_INCLUDE_DIR` variable. Again, the
    common practice is to name this variable `<PACKAGENAME>_INCLUDE_DIR`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，`find`模块尝试定位`include`路径。这是通过找到库的已知路径模式来完成的，通常是公共头文件之一。结果存储在`OBSCURE_INCLUDE_DIR`变量中。同样的，常见做法是将该变量命名为`<PACKAGENAME>_INCLUDE_DIR`。
- en: 'Since handling all the requirements for a `find` module can be tedious and
    is often very repetitive, CMake provides the `FindPackageHandleStandardArgs` module,
    which provides a handy function to handle all the common cases. It provides the
    `find_package_handle_standard_args` function, which handles `REQUIRED`, `QUIET`,
    and the version-related arguments of `find_package`. `find_package_handle_standard_args`
    has a short signature and a long signature. In the example, the short signature
    is used:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于处理`find`模块的所有要求可能会非常繁琐且重复，CMake提供了`FindPackageHandleStandardArgs`模块，它提供了一个便捷的函数来处理所有常见情况。它提供了`find_package_handle_standard_args`函数，处理`REQUIRED`、`QUIET`以及`find_package`的版本相关参数。`find_package_handle_standard_args`有简短签名和长签名两种形式。在这个例子中，使用了简短签名：
- en: '[PRE11]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For most cases, the short form of `find_package_handle_standard_args` is sufficient.
    In the short form, the `find_package_handle_standard_args` function takes the
    package name as the first argument and a list of variables that are required for
    the package. The `DEFAULT_MSG` argument tells it to print default messages on
    success or failure, depending on whether `find_package` was invoked with `REQUIRED`
    or `QUIET`. The message can be customized, but we recommend that you stick to
    the default messages whenever possible. That way, the messages are consistent
    for all the `find_package` commands. In the preceding example, `find_package_handle_standard_args`
    checks whether the `OBSCURE_LIBRARY` and `OBSCURE_INCLUDE_DIR` variables that
    have been passed are valid. If that is the case, the `<PACKAGENAME>_FOUND` variable
    is set.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于大多数情况，`find_package_handle_standard_args`的简写形式已足够使用。在简写形式中，`find_package_handle_standard_args`函数将包名作为第一个参数，并传递该包所需的变量列表。`DEFAULT_MSG`参数指定在成功或失败时打印默认消息，这取决于`find_package`是否使用`REQUIRED`或`QUIET`选项被调用。消息可以自定义，但我们建议尽可能使用默认消息。这样，所有`find_package`命令的消息保持一致。在前面的示例中，`find_package_handle_standard_args`检查传入的`OBSCURE_LIBRARY`和`OBSCURE_INCLUDE_DIR`变量是否有效。如果有效，`<PACKAGENAME>_FOUND`变量会被设置。
- en: If all goes well, the `find` module defines the target. Before we do this, it
    is helpful to check whether the target we are trying to create does not already
    exist (to avoid overwriting it in the case that we have multiple calls to `find_package`
    for the same dependency). Creating the target is done with `add_library`. Since
    we cannot be sure whether it is a static or dynamic library, the type is `UNKNOWN`
    and the `IMPORTED` flag is set.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，`find`模块定义了目标。在此之前，最好检查一下我们尝试创建的目标是否已经存在（以避免在多次调用`find_package`查找相同依赖时覆盖已有目标）。创建目标是通过`add_library`完成的。由于我们无法确定它是静态库还是动态库，因此类型设为`UNKNOWN`并设置`IMPORTED`标志。
- en: Finally, the properties for the library are set. The minimum setting that we
    recommend is the `IMPORTED_LOCATION` property and the location of the `include`
    files in `INTERFACE_INCLUDE_DIR`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，库的属性被设置。我们推荐的最小设置是`IMPORTED_LOCATION`属性和`INTERFACE_INCLUDE_DIR`中`include`文件的位置。
- en: 'If everything works as expected, the library can then be used like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切按预期工作，那么可以像这样使用库：
- en: '[PRE15]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So, now we understand how other libraries are added to your projects if they
    are already available for use. But how do we get the libraries into our system
    in the first place? Let’s find that out in the next section.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们了解了如何将其他库添加到项目中，如果它们已经可用。那么，我们如何将这些库首先引入到系统中呢？我们将在下一节中解决这个问题。
- en: Using package managers with CMake
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CMake的包管理器
- en: The easiest way to get dependencies into your project is to regularly install
    them using `apt-get`, brew, or Chocolatey. The downside of installing everything
    is that you can pollute your system with many different versions of libraries
    and the version you are looking for might not be available at all. This is especially
    true if you are working on multiple projects with different requirements regarding
    the dependencies side by side. Often, a developer downloads the dependencies locally
    for each project so that each project can work independently. A very good way
    to handle dependencies is by using package managers such as Conan or vcpkg.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 将依赖项加入项目的最简单方法是通过 `apt-get`、brew 或 Chocolatey 定期安装它们。安装所有内容的缺点是，你可能会污染系统，导致存在多个不同版本的库，并且你需要的版本可能根本无法找到。特别是在你同时处理多个具有不同依赖要求的项目时，这种情况尤为严重。开发者通常会为每个项目本地下载依赖项，以确保每个项目能够独立工作。处理依赖项的一个非常好的方法是使用像
    Conan 或 vcpkg 这样的包管理器。
- en: Using a dedicated package manager has many advantages when it comes to dependency
    management. Two of the more popular ones for handling C++ dependencies are Conan
    and vcpkg. Both can handle complex build systems and mastering them would require
    whole books on their own, so we will only cover the bare necessities to start
    working with them here. In this book, we will focus on using packages that are
    already available in your CMake project, rather than on creating your own packages.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用专门的包管理器在依赖管理方面有许多优点。处理 C++ 依赖项时，两个更受欢迎的包管理器是 Conan 和 vcpkg。它们都能处理复杂的构建系统，要掌握它们需要单独写一本书，因此我们这里只介绍入门所需的基本内容。在本书中，我们将重点介绍如何使用
    CMake 项目中已有的包，而不是如何创建自己的包。
- en: Since version 3.24, CMake has supported a concept called `find_package` or `FetchContent_MakeAvailable`
    to call external programs or scripts to locate or install the dependency. Dependency
    providers must be set before the first call to the project function with `CMAKE_PROJECT_TOP_LEVEL_INCLUDES`,
    which typically should happen over the command line or by using a CMake preset.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 3.24 开始，CMake 支持一个叫做 `find_package` 或 `FetchContent_MakeAvailable` 的概念，用于调用外部程序或脚本以定位或安装依赖项。依赖提供者必须在第一次调用项目函数时通过
    `CMAKE_PROJECT_TOP_LEVEL_INCLUDES` 进行设置，这通常应该通过命令行或使用 CMake 预设来完成。
- en: Although the concept is relatively new to CMake at the time of writing, it looks
    very promising. Conan 2.0 has experimental support for dependency providers, while
    vcpkg does not yet have it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个概念在写作时对 CMake 来说相对较新，但它看起来非常有前景。Conan 2.0 对依赖提供者提供了实验性的支持，而 vcpkg 目前还没有此功能。
- en: Using Conan to get dependencies
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Conan 获取依赖项
- en: Over the last few years, the Conan package manager gained much popularity, and
    it integrates very well with CMake. **Conan** is a decentralized package manager
    that has been built on a client/server architecture. This means that the local
    client fetches or uploads packages to one or more remote servers. In February
    2023, the team behind Conan released Conan 2, which is no longer compatible with
    Conan 1\. If you are using Conan 1, we recommend that you migrate to Conan 2 as
    it introduces several improvements and changes over Conan 1.x, including better
    integration with CMake, improved package creation and management, and enhanced
    user experience.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，Conan 包管理器获得了很高的关注度，并且与 CMake 的集成非常好。**Conan** 是一个去中心化的包管理器，基于客户端/服务器架构。这意味着本地客户端从一个或多个远程服务器获取或上传包。2023
    年 2 月，Conan 团队发布了 Conan 2，它与 Conan 1 不再兼容。如果你还在使用 Conan 1，我们建议你迁移到 Conan 2，因为它在多个方面对
    Conan 1.x 进行了改进和变化，包括与 CMake 的更好集成、改进的包创建和管理功能，以及提升的用户体验。
- en: One of the most powerful features of Conan is that it can create and manage
    binary packages for multiple platforms, configurations, and versions. When creating
    packages, they are described with a `conanfile.py` file that lists all dependencies,
    sources, and build instructions.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Conan 最强大的功能之一是它可以为多个平台、配置和版本创建并管理二进制包。在创建包时，这些包会通过一个 `conanfile.py` 文件进行描述，文件列出了所有依赖项、源代码和构建指令。
- en: The packages are built and uploaded to the remote server with the Conan client.
    This has an additional benefit that if no binary package that fits your local
    configuration can be found, the package can be built locally from its sources.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包通过 Conan 客户端构建并上传到远程服务器。这还有一个额外的好处，即如果没有适合你本地配置的二进制包，包可以从源代码本地构建。
- en: 'A basic workflow of using Conan with CMake works like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Conan 与 CMake 的基本工作流程如下：
- en: Create a `conanfile.txt` in your project that contains the list of dependencies
    and settings.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目中创建一个 `conanfile.txt`，其中包含依赖项和设置的列表。
- en: Install the dependencies using Conan and use the generators provided by Conan
    to create the files that CMake can use to find and link the dependencies.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Conan 安装依赖项，并使用 Conan 提供的生成器来创建 CMake 可以使用的文件，以便查找和链接依赖项。
- en: Run CMake and integrate the information generated by Conan to build the project.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 CMake 并整合 Conan 生成的信息来构建项目。
- en: There are two important core concepts of Conan. The first one is `conanfile`.
    Profiles are usually located in the user’s home directory, there can be several
    different profiles but most often one uses the default profile.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Conan 有两个重要的核心概念。第一个是 `conanfile`。配置文件通常位于用户的主目录中，可以有多个不同的配置文件，但最常使用的是默认配置文件。
- en: 'To create a new profile, you can use the `conan profile` `new` command:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新的配置文件，可以使用 `conan profile` `new` 命令：
- en: '[PRE16]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This will create a new profile from the standard compiler detected on your
    system. If the `--name` argument is omitted, the default profile will be created.
    The resulting profile file might look like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从系统上检测到的标准编译器创建一个新的配置文件。如果省略 `--name` 参数，将创建默认的配置文件。生成的配置文件可能如下所示：
- en: '[PRE17]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For different compiler settings, the profiles can be customized as needed.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不同的编译器设置，配置文件可以根据需要进行自定义。
- en: The other core concept of Conan is `CMakeDeps` and `CMakeToolchain`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Conan 的另一个核心概念是 `CMakeDeps` 和 `CMakeToolchain`。
- en: '`CMakeDeps` generates information to be used with `find_package` and offers
    more flexibility, and `CMakeToolchain` is somewhat more convenient to use but
    has some limitations regarding configuration.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMakeDeps` 生成供 `find_package` 使用的信息，并提供更多灵活性，而 `CMakeToolchain` 更方便使用，但在配置方面有一些限制。'
- en: The `CMakeToolchain` generator works well for small, standalone projects. For
    bigger projects, or if cross-compilation toolchains are involved, we recommend
    using the`CMakeDeps` generator.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMakeToolchain` 生成器适用于小型独立项目。对于较大的项目，或者涉及交叉编译工具链时，建议使用 `CMakeDeps` 生成器。'
- en: There are two main ways to use Conan with CMake. One is to call Conan on its
    own and let it generate package information to be consumed by CMake or insert
    it as a CMake dependency provider. Which way works best depends on personal preference
    and the project setup. While calling Conan on its own gives you the maximum amount
    of freedom regarding the configuration of Conan, it might limit some options regarding
    toolchains and presets on the CMake side. Using Conan as a dependency provider
    is more convenient and gives you access to the full range of CMake features, but
    it limits the number of Conan configurations available. From a CMake perspective,
    one upside of using Conan as a dependency provider is that one does not need to
    specify all the Conan profiles for all the different build configurations up front,
    but that we can use the normal CMake definitions to create them on the fly. Let’s
    first look at how to use Conan as a dependency provider.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Conan 与 CMake 集成有两种主要方式。一种是单独调用 Conan，让它生成 CMake 消耗的包信息，另一种是将其作为 CMake 的依赖项提供者插入。哪种方式最适合取决于个人偏好和项目设置。虽然单独调用
    Conan 可以在配置 Conan 时提供最大的自由度，但它可能会限制 CMake 方面工具链和预设选项的选择。将 Conan 作为依赖项提供者更加方便，并且可以访问
    CMake 的全部功能，但它限制了可用的 Conan 配置数量。从 CMake 的角度来看，使用 Conan 作为依赖项提供者的一个优点是，不需要为所有不同的构建配置预先指定所有
    Conan 配置文件，而是可以使用正常的 CMake 定义动态创建它们。首先，让我们看看如何将 Conan 作为依赖项提供者使用。
- en: Using Conan as a dependency provider
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 Conan 用作依赖项提供者
- en: 'To use Conan as a dependency provider, we need two things:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Conan 作为依赖项提供者，我们需要两件事：
- en: '`conanfile.txt` to list the dependencies'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`conanfile.txt` 用于列出依赖项'
- en: The dependency provider definition for Conan
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Conan 的依赖项提供者定义
- en: 'First, `conanfile.txt` is placed next to the `CMakeLists.txt`, resulting in
    a project structure something like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`conanfile.txt` 被放置在 `CMakeLists.txt` 旁边，结果项目结构类似于以下内容：
- en: '[PRE18]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Inside `conanfile.txt`, we list the dependencies we want to use and tell Conan
    to use the `CMakeDeps` generator to generate package information for the dependencies:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `conanfile.txt` 中，我们列出了要使用的依赖项，并告诉 Conan 使用 `CMakeDeps` 生成器来生成依赖项的包信息：
- en: '[PRE19]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: First, the `[requires]` section describes which packages are to be imported;
    in this case, the `fmt` version *10.2.1* package is imported.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`[requires]` 部分描述了要导入哪些包；在这种情况下，导入了 `fmt` 版本 *10.2.1* 包。
- en: The `[generators]` section describes which generators may be used. For using
    Conan as a dependency provider, the `CMakeDeps` generator is used.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`[generators]` 部分描述了可以使用的生成器。对于将 Conan 作为依赖项提供程序，使用 `CMakeDeps` 生成器。'
- en: 'To use the dependency in CMake, we can use the `find_package` command as illustrated
    earlier, so a `CMakeLists.txt` might look like this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 CMake 中使用该依赖项，可以使用前面所示的 `find_package` 命令，因此 `CMakeLists.txt` 文件可能如下所示：
- en: '[PRE20]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that using Conan packages is no different than using “normal” CMake packages
    and no Conan-specific code needs to be added to `CMakeLists.txt`, which helps
    keep it portable between different systems
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用 Conan 包与使用“常规” CMake 包没有区别，不需要在 `CMakeLists.txt` 中添加任何特定于 Conan 的代码，这有助于在不同系统之间保持可移植性。
- en: 'With that, we are almost ready. The next thing is to tell CMake to use Conan
    as a dependency provider. For this, the definition files for the CMake dependency
    provider for Conan can be obtained from here: [https://github.com/conan-io/cmake-conan](https://github.com/conan-io/cmake-conan)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里，我们差不多准备好了。接下来需要告诉 CMake 使用 Conan 作为依赖项提供程序。为此，CMake 依赖项提供程序的定义文件可以从这里获取：[https://github.com/conan-io/cmake-conan](https://github.com/conan-io/cmake-conan)
- en: Inside this repository, there is a `conan_provider.cmake` file, which can either
    be downloaded manually or the Git repository can be used as a submodule, whichever
    is preferable to you. In the GitHub repository containing the examples, the file
    is included as a submodule. You can get it by cloning the repository and then
    calling `git submodule update --``init --recursive`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个仓库中，有一个 `conan_provider.cmake` 文件，可以手动下载该文件，或者可以将 Git 仓库用作子模块，选择最适合你的方式。在包含示例的
    GitHub 仓库中，文件作为子模块包含。你可以通过克隆该仓库并调用 `git submodule update --init --recursive` 来获取它。
- en: 'With this file, we have everything we need to start building. By passing this
    file as `CMAKE_PROJECT_TOP_LEVEL_INCLUDES` to CMake, the dependency provider is
    automatically installed and any call to `find_package()` is routed through Conan
    first to see whether the dependency is listed in `conanfile.txt`. The resulting
    call to CMake might look like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个文件，我们就拥有了开始构建所需的一切。通过将此文件作为 `CMAKE_PROJECT_TOP_LEVEL_INCLUDES` 传递给 CMake，依赖项提供程序会自动安装，任何对
    `find_package()` 的调用都会首先通过 Conan，看看依赖项是否列在 `conanfile.txt` 中。最终调用 CMake 可能如下所示：
- en: '[PRE21]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By default, the Conan dependency provider will autodetect any profile information
    and pass it to Conan. If no default profile exists, it will create one. If the
    binary package is not available in the Conan repository for the chosen build configuration
    or compiler, Conan will try to build the package locally, which might take some
    time, depending on the package size.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Conan 依赖项提供程序会自动检测任何配置文件信息并将其传递给 Conan。如果没有默认配置文件，它将创建一个。如果所选的构建配置或编译器在
    Conan 仓库中没有可用的二进制包，Conan 会尝试在本地构建该包，这可能会花费一些时间，具体取决于包的大小。
- en: Although using Conan as a dependency provider is the recommended way, some people
    might like to have more control over Conan and use Conan on its own with CMake.
    Let’s look at how this might work.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管推荐将 Conan 用作依赖项提供程序，但有些人可能希望对 Conan 有更多的控制权，独立使用 Conan 并与 CMake 配合使用。让我们来看看这如何实现。
- en: Using Conan with CMake
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 CMake 中使用 Conan
- en: To use Conan with CMake effectively, we can leverage the `CMakeDeps` and `CMakeToolchain`
    generators. These generators help bridge the gap between Conan’s dependency management
    and CMake’s build system configuration.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地与 CMake 一起使用 Conan，我们可以利用 `CMakeDeps` 和 `CMakeToolchain` 生成器。这些生成器帮助弥合
    Conan 的依赖项管理和 CMake 的构建系统配置之间的差距。
- en: If Conan is used on its own, a Conan profile has to be created for each build
    configuration that is usable for CMake.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单独使用 Conan，则必须为每个可以与 CMake 配合使用的构建配置创建一个 Conan 配置文件。
- en: 'First, let’s install the dependencies and have Conan create the necessary files
    for using it with CMake. The library and header files will be installed into the
    Conan cache in the users’ home directory, but we can tell Conan where to install
    the package definition for CMake. This can be any directory, but in practice,
    it is often convenient to have this generated into the build directory of CMake:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们安装依赖项，并让 Conan 创建用于与 CMake 配合使用的必要文件。库和头文件将安装到用户主目录中的 Conan 缓存中，但我们可以告诉
    Conan 将 CMake 的包定义安装到哪里。可以是任何目录，但实际上通常将其生成到 CMake 构建目录中会更方便：
- en: '[PRE22]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will install all the dependencies listed in the `conanfile.txt` and create
    a bunch of files in the build folder. We also pass the `build=missing` flag. If
    the binary package is not available in the Conan repository, Conan will try to
    build the package locally. We also pass the build type for which we want to install
    the package here. If that is omitted, only the configuration in the default profile
    will be installed, which might make package detection fail for other configurations.
    It is generally a good idea to specify the build types explicitly by using `-DCMAKE_BUILD_TYPE=Debug`,
    but with Conan, this becomes mandatory to avoid headaches because the dependencies
    are not found.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装 `conanfile.txt` 中列出的所有依赖项，并在构建文件夹中创建一堆文件。我们还传递了 `build=missing` 标志。如果 Conan
    仓库中没有可用的二进制包，Conan 将尝试在本地构建该包。我们还传递了我们希望安装该包的构建类型。如果省略此选项，则仅会安装默认配置文件中的配置，这可能会导致其他配置的包检测失败。通常，最好显式指定构建类型，使用
    `-DCMAKE_BUILD_TYPE=Debug`，但在使用 Conan 时，这变得是强制性的，以避免因找不到依赖项而带来的麻烦。
- en: 'If we’re only using the `CMakeDeps` generator from Conan, this will create
    the necessary files to be used with `find_package()` in the build folder. The
    preferred way is setting this by passing the build folder to `CMAKE_PREFIX_PATH`
    either over the command line or a prefix like this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只使用 Conan 的 `CMakeDeps` 生成器，这将创建必要的文件，供在构建文件夹中使用 `find_package()`。首选方法是通过命令行将构建文件夹传递给
    `CMAKE_PREFIX_PATH`，或者使用类似以下的前缀：
- en: '[PRE23]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Alternatively, it can also be appended inside `CMakeLists.txt` like this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它也可以像这样追加到 `CMakeLists.txt` 文件中：
- en: '[PRE24]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With that, the CMake project can be built, and the dependency can be used. In
    most cases, the `CMakeDeps` generator is what you want to use, as it provides
    a good compromise of using the benefits of CMake when it comes to cross-compiling
    while having the convenience of package handling from Conan.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，CMake 项目就可以构建，并且可以使用依赖项。在大多数情况下，`CMakeDeps` 生成器是您希望使用的，因为它在交叉编译时利用了 CMake
    的优势，同时又能享受 Conan 管理包的便利。
- en: If you want to hand over the build configuration entirely to Conan, the `CMakeToolchain`
    generator for Conan can be used. This generator will not just create the package
    information, but also generate a CMake toolchain definition and presets for using
    them. CMake toolchains are covered in detail in [*Chapter 9*](B30947_09.xhtml#_idTextAnchor146),
    *Creating Reproducible* *Build Environments*.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望将构建配置完全交给 Conan 处理，可以使用 Conan 的 `CMakeToolchain` 生成器。这个生成器不仅会创建包信息，还会生成一个
    CMake 工具链定义和用于使用它们的预设。CMake 工具链的详细内容可以参考 [*第 9 章*](B30947_09.xhtml#_idTextAnchor146)，*创建可重复的构建环境*。
- en: 'Again, installing the Conan packages happens with the following command:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，安装 Conan 包的命令如下：
- en: '[PRE25]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Using the `CMakeToolchain` generator will create a toolchain file in the build
    folder that contains all the information to resolve the dependencies. Additionally,
    `CMakeUserPresets.json` will be created containing a preset to use the resulting
    toolchain. After running Conan, the preset can be used with the following command:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `CMakeToolchain` 生成器将在构建文件夹中创建一个工具链文件，其中包含解析依赖项的所有信息。此外，还将创建 `CMakeUserPresets.json`，其中包含用于使用生成的工具链的预设。运行
    Conan 后，可以使用以下命令使用该预设：
- en: '[PRE26]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This will configure the CMake project with the toolchain generated from Conan.
    While this appears very convenient to use, it has the downside that all the configurations
    of the build environment have to be done over Conan profiles or flags on the `conan
    install` command. Using existing configuration options from CMake becomes much
    harder. Notably, if a project or a developer has already defined their own presets,
    they get overwritten by the presets generated from Conan. Because of this, using
    the `CMakeToolchain` generator is only recommended for small standalone projects
    that have relatively simple requirements regarding the build environment.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用从 Conan 生成的工具链配置 CMake 项目。虽然这看起来非常方便，但它的缺点是所有构建环境的配置都必须通过 Conan 配置文件或 `conan
    install` 命令的标志来完成。使用现有的 CMake 配置选项变得更加困难。特别是，如果项目或开发人员已经定义了自己的预设，这些预设会被 Conan
    生成的预设覆盖。因此，建议仅在具有相对简单构建环境要求的小型独立项目中使用 `CMakeToolchain` 生成器。
- en: While Conan is a very powerful package manager that offers a very good integration
    with CMake, it is not the only one. Another frequently used package manager is
    vcpkg from Microsoft. Let’s have a closer look at it.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Conan是一个非常强大的包管理器，并且与CMake的集成非常好，但它并不是唯一的选择。另一个常用的包管理器是来自微软的vcpkg。让我们更详细地了解一下它。
- en: Using vcpkg for dependency management
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用vcpkg进行依赖管理
- en: 'Another popular open-source package manager is **vcpkg** from Microsoft. It
    works similarly to Conan in the way that it is set up as a client/server architecture.
    It was originally built to work with the Visual Studio compiler environment, and
    CMake was added later. Packages can either be installed manually, by calling vcpkg
    in the so-called **classic mode**, or directly out of CMake in the so-called **manifest
    mode**. The command to install packages with vcpkg in the classic mode is as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个流行的开源包管理器是**vcpkg**，来自微软。它的工作方式类似于Conan，都是以客户端/服务器架构的形式进行设置。最初，它是为与Visual
    Studio编译器环境一起使用而构建的，后来才添加了CMake支持。包可以通过手动安装，调用vcpkg的所谓**经典模式**，或者直接通过CMake以**清单模式**安装。使用vcpkg经典模式安装包的命令如下：
- en: '[PRE27]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When run in manifest mode, the dependencies of a project are defined in a `vcpkg.json`
    file in the root of the project. The manifest mode has a big advantage in that
    it integrates better with CMake, so whenever possible, use manifest mode. A vcpkg
    manifest might look like this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当以清单模式运行时，项目的依赖项在项目根目录下的`vcpkg.json`文件中定义。清单模式有一个很大的优势，就是它与CMake的集成更加顺畅，因此在可能的情况下，建议使用清单模式。一个vcpkg清单可能如下所示：
- en: '[PRE28]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For CMake to find the packages, a vcpkg toolchain file must be passed to CMake,
    so the call to CMake will be as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让CMake找到包，必须将vcpkg工具链文件传递给CMake，因此调用CMake的命令如下所示：
- en: '[PRE29]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If they are run in manifest mode, the packages specified in the `vcpkg.json`
    file will be automatically downloaded and installed locally. If they are run in
    classic mode, the packages have to be manually installed before running CMake.
    When passing the vcpkg toolchain file, the installed packages can be used, as
    usual, by using `find_package` and `target_link_libraries`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以清单模式运行，`vcpkg.json`文件中指定的包将会自动下载并本地安装。如果以经典模式运行，则必须在运行CMake之前手动安装这些包。当传递vcpkg工具链文件时，已安装的包可以像往常一样使用，方法是使用`find_package`和`target_link_libraries`。
- en: Microsoft recommends that you install vcpkg as a submodule in the repository
    at the same level as the CMake root project, but it can be installed almost everywhere.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 微软建议将vcpkg安装为与CMake根项目处于同一级别的子模块，但它几乎可以安装在任何地方。
- en: 'Setting the toolchain file might cause problems when cross-compiling, as `CMAKE_TOOLCHAIN_FILE`
    might point to a different file already. In this case, a second toolchain file
    can be passed with the `VCPKG_CHAINLOAD_TOOLCHAIN_FILE` variable. Then, the call
    to CMake would look something like this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 设置工具链文件可能会在交叉编译时导致问题，因为`CMAKE_TOOLCHAIN_FILE`可能已经指向了另一个文件。在这种情况下，可以通过`VCPKG_CHAINLOAD_TOOLCHAIN_FILE`变量传递第二个工具链文件。然后，调用CMake的命令可能如下所示：
- en: '[PRE30]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Conan and vcpkg are just two package managers for C++ and CMake that are popular.
    Of course, there are many more, but it would require a separate book to describe
    them all. Especially when projects get more complex, we highly advise that you
    use package managers.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Conan和vcpkg只是C++和CMake中流行的两个包管理器。当然，还有许多其他包管理器，但要描述它们所有，恐怕需要一本专门的书。特别是当项目变得更加复杂时，我们强烈建议使用包管理器。
- en: Which package manager you choose will depend on the context a project is being
    developed and your personal preference. Conan has a slight advantage over vcpkg
    in that it is supported on more platforms as it runs everywhere Python runs. In
    terms of features and ability for cross-compiling, both are roughly equal. Overall,
    Conan offers more advanced configuration options and control over the packages,
    which comes at the price of more complex handling. Another way to work with local
    dependencies is to create fully isolated environments by using containers, sysroot,
    and more. This will be covered in [*Chapter 9*](B30947_09.xhtml#_idTextAnchor146),
    *Creating Reproducible Build* *Environments*. For the moment, let’s assume we’re
    running CMake with your standard system installation.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 选择哪个包管理器取决于项目开发的背景和个人偏好。Conan 相比 vcpkg 有一个轻微的优势，因为它在更多平台上受支持，因为它可以在所有 Python
    支持的地方运行。在功能和跨编译能力方面，两者大致相等。总体来说，Conan 提供了更多的高级配置选项和对包的控制，但代价是需要更复杂的处理。另一种处理本地依赖的方法是通过使用容器、sysroot
    等创建完全隔离的环境。这将在[*第9章*](B30947_09.xhtml#_idTextAnchor146)中讨论，*创建可重现的构建* *环境*。暂时我们假设我们正在使用标准系统安装运行
    CMake。
- en: Using package managers for dependency management is the recommended thing to
    do when working with project-specific dependencies. However, sometimes, package
    managers are not an option. This might be because of mysterious company policies
    or some other reason. In these cases, CMake also supports downloading dependencies
    as the source and integrating them into the project as external targets.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理项目特定的依赖时，使用包管理器进行依赖管理是推荐的做法。然而，有时包管理器不可用，这可能是因为一些神秘的公司政策或其他原因。在这种情况下，CMake
    也支持将依赖项作为源代码下载并将其集成到项目中作为外部目标。
- en: Getting the dependencies as source code
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取依赖作为源代码
- en: There are several ways to get dependencies as sources into your project. A relatively
    straightforward but dangerous way is to manually download or clone them into a
    subfolder inside your project and then add this folder with `add_subdirectory`.
    While this works and is fast, it quickly becomes tedious and hard to maintain.
    So, this should be automated as soon as possible.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以将依赖项作为源代码添加到项目中。一种相对简单但危险的方法是手动下载或克隆它们到项目中的子文件夹，然后使用`add_subdirectory`将此文件夹添加进来。虽然这种方法有效且速度较快，但很快会变得乏味且难以维护。因此，应尽早将其自动化。
- en: The practice of downloading and integrating a copy of third-party software directly
    into a product is called **vendoring**. While it has the advantage that it often
    makes building software easy, it creates issues with packaging libraries. Vendoring
    is avoided by either using a package manager or by installing third-party software
    into a location on your system.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 直接将第三方软件的副本下载并集成到产品中的做法称为**供应商集成**。虽然这种方式的优点是通常使构建软件变得简单，但它会在打包库时产生问题。通过使用包管理器或将第三方软件安装到系统中的某个位置，可以避免供应商集成。
- en: Downloading dependencies as the source using pure CMake
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过纯 CMake 下载依赖作为源代码
- en: At the base of getting external content is the CMake `ExternalProject` module
    and the more sophisticated `FetchContent` module, which is built on `ExternalProject`.
    While `ExternalProject` offers more flexibility, `FetchContent` is often more
    convenient to use, especially if the downloaded project is also built using CMake.
    Both of them download projects as source files and can be used to build them.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 获取外部内容的基础是 CMake 的`ExternalProject`模块和更复杂的`FetchContent`模块，后者是建立在`ExternalProject`基础上的。虽然`ExternalProject`提供了更多的灵活性，但`FetchContent`通常更方便使用，尤其是当下载的项目本身也使用
    CMake 构建时。它们都可以将项目作为源文件下载并用于构建。
- en: Using FetchContent
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 FetchContent
- en: For external projects that use CMake to build, using the `FetchContent` module
    is the best way to add source dependencies. For binary dependencies, using `find_package`
    and `find` modules is still the preferred way. One of the main differences between
    `ExternalProject` and `FetchContent` is that `FetchContent` downloads and configures
    external projects during configuration time, while `ExternalProject` does everything
    during the build step. The drawback to this is that the source and its configuration
    are not available during configuration time.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用 CMake 构建的外部项目，使用`FetchContent`模块是添加源依赖的最佳方式。对于二进制依赖，仍然首选使用`find_package`和`find`模块。`ExternalProject`和`FetchContent`的主要区别之一是，`FetchContent`在配置时下载并配置外部项目，而`ExternalProject`则在构建步骤中完成所有操作。这个缺点是，在配置时无法使用源代码及其配置。
- en: Before `FetchContent`, you would have used Git submodules to manually download
    the dependencies and then add them using `add_subdirectory`. This works in some
    cases, but it can be rather inconvenient and cumbersome to maintain.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `FetchContent` 之前，你会使用 Git 子模块来手动下载依赖项，然后通过 `add_subdirectory` 将其添加。这在某些情况下有效，但维护起来可能会显得不方便且繁琐。
- en: '`FetchContent` provides a list of functions to pull in source dependencies,
    mainly `FetchContent_Declare`, which defines the parameters for downloading and
    building `FetchContent_MakeAvailable`, which populates the targets of the dependency
    and makes them available for the build. In the following example, the `bertrand`
    library for design by contract is pulled from Git using GitHub and made available
    for use:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`FetchContent` 提供了一系列函数，用于拉取源代码依赖，主要是 `FetchContent_Declare`，它定义了下载和构建的参数，以及
    `FetchContent_MakeAvailable`，它将依赖的目标填充并使其可用于构建。在以下示例中，`bertrand` 这个用于契约设计的库通过
    GitHub 从 Git 拉取并使其可供使用：'
- en: '[PRE31]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When fetching dependencies as sources, the sequence of `FetchContent_Declare`
    followed by `FetchContent_MakeAvailable` should be used whenever possible because
    it makes code bases very maintainable due to their simplicity. `FetchContent`
    can download sources from HTTP/S, Git, SVN, Mercurial, and CVS, and the same best
    practices, such as specifying MD5 hashes for the downloaded content or using Git
    hashes, apply.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取依赖源时，应该尽可能使用 `FetchContent_Declare` 紧跟着 `FetchContent_MakeAvailable`，因为它使代码库更加易于维护，且其简洁性带来更多的可维护性。`FetchContent`
    可以从 HTTP/S、Git、SVN、Mercurial 和 CVS 下载源代码，使用这些方法时，最好遵循最佳实践，如为下载的内容指定 MD5 校验和或使用
    Git 哈希值等。
- en: '`FetchContent_MakeAvailable` is the recommended way to make external CMake-based
    projects available, but if you want to have more control over your external projects,
    it is also possible to populate the projects manually. The following example does
    the same as the previous example but in a more verbose way:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`FetchContent_MakeAvailable` 是使外部基于 CMake 的项目可用的推荐方式，但如果你希望对外部项目有更多控制，也可以手动填充项目。以下示例与前面的示例效果相同，但方法更加冗长：'
- en: '[PRE32]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`FetchContent_Populate` has additional options to be specified to control the
    build more closely. The signature is as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`FetchContent_Populate` 具有其他选项，可以更精细地控制构建。其签名如下：'
- en: '[PRE33]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let’s look at the `FetchContent_Populate` options:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 `FetchContent_Populate` 的选项：
- en: '`QUIET`: This can be specified to suppress the output of the population if
    it succeeds. If the command fails, the output will be shown even if the option
    is specified to allow for debugging.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QUIET`：如果指定了此选项，成功时将抑制填充输出。如果命令失败，输出将会显示，即使指定了该选项也会显示出来，以便进行调试。'
- en: '`SUBBUILD_DIR`: This specifies where the external project will be located.
    The default is `${CMAKE_CURRENT_BINARY_DIR}/<name>-subbuild`. Generally, this
    option should be left as it is.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SUBBUILD_DIR`：此选项指定外部项目的位置。默认值为 `${CMAKE_CURRENT_BINARY_DIR}/<name>-subbuild`。通常，这个选项应保持默认设置。'
- en: '`SOURCE_DIR` and `BINARY_DIR` change where the source and build directories
    of the external project are located. The default settings are `${CMAKE_CURRENT_BINARY_DIR}/<lcName>-src`
    for `SOURCE_DIR` and `${CMAKE_CURRENT_BINARY_DIR}/<lcName>-build` for `BINARY_DIR`'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOURCE_DIR` 和 `BINARY_DIR` 改变了外部项目源代码和构建目录的位置。默认设置为 `${CMAKE_CURRENT_BINARY_DIR}/<lcName>-src`
    作为 `SOURCE_DIR`，以及 `${CMAKE_CURRENT_BINARY_DIR}/<lcName>-build` 作为 `BINARY_DIR`。'
- en: Under the hood, `FetchContent` is using the older `ExternalProject` module,
    which is described in the next section. Any additional parameters added will be
    passed on to the underlying `ExternalProject_Add`. However, `FetchContent` prohibits
    you from editing the commands for the different steps, so attempts to tamper with
    `CONFIGURE_COMMAND`, `BUILD_COMMAND`, `INSTALL_COMMAND`, and `TEST_COMMAND` will
    cause `FetchContent_Populate` to fail with an error.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在后台，`FetchContent` 使用的是较早的 `ExternalProject` 模块，下一节将介绍该模块。任何额外添加的参数都将传递给底层的
    `ExternalProject_Add`。然而，`FetchContent` 禁止你编辑不同步骤的命令，因此如果试图修改 `CONFIGURE_COMMAND`、`BUILD_COMMAND`、`INSTALL_COMMAND`
    或 `TEST_COMMAND`，将导致 `FetchContent_Populate` 失败并报错。
- en: Note
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you find yourself in a situation where you need to pass options to the underlying
    `ExternalProject_Add`, consider using `ExternalProject` directly instead of first
    going through `FetchContent`. More details on how to use `ExternalProject` can
    be found in the next section.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己需要向底层的 `ExternalProject_Add` 传递选项，考虑直接使用 `ExternalProject`，而不是先通过 `FetchContent`。有关如何使用
    `ExternalProject` 的更多细节，请参阅下一节。
- en: Information about the source and build directories, along with whether a project
    has been populated, can be retrieved either by reading the `<name>_SOURCE_DIR`,
    `<name>_BINARY_DIR`, and `<name>_POPULATED` variables or by calling `FetchContent_GetProperties`.
    Note that `<name>` will always be available in all caps and all lowercase. This
    is so that CMake can identify the packages despite different capitalizations.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 关于源目录和构建目录的信息，以及项目是否已被填充，可以通过读取 `<name>_SOURCE_DIR`、`<name>_BINARY_DIR` 和 `<name>_POPULATED`
    变量，或者调用 `FetchContent_GetProperties` 获取。请注意，`<name>` 将始终以大写字母和小写字母的形式提供。这样，CMake
    即使面对不同的大小写形式，也能识别这些包。
- en: Another big advantage of `FetchContent` is that it can handle cases where external
    projects share common dependencies and prevent them from being downloaded and
    built multiple times. The first time a dependency is defined over `FetchContent`,
    the details are cached, and any further definitions will be silently ignored.
    The benefit of this is that a parent project can overrule the dependencies of
    the child projects.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`FetchContent` 的另一个重要优点是，它能够处理外部项目共享公共依赖项的情况，避免它们被多次下载和构建。第一次通过 `FetchContent`
    定义依赖项时，相关信息会被缓存，任何进一步的定义都会被默默忽略。这样做的好处是，父项目可以覆盖子项目的依赖关系。'
- en: 'Let’s assume we have a top project called `MyProject` that fetches two external
    projects, `Project_A` and `Project_B`, with each depending on a third external
    project called `AwesomeLib`, but on a different minor version. In most cases,
    we do not want to download and use two versions of `AwesomeLib` but only one to
    avoid conflicts. The following diagram shows what the dependency graph might look
    like:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个顶层项目叫做 `MyProject`，它获取了两个外部项目 `Project_A` 和 `Project_B`，每个项目都依赖于一个第三方外部项目
    `AwesomeLib`，但依赖的是不同的小版本。在大多数情况下，我们不希望下载并使用两个版本的 `AwesomeLib`，而是只使用一个版本以避免冲突。下面的图示展示了依赖关系图可能的样子：
- en: '![Figure 5.1 – Both Project_A and Project_B depend on different versions of
    AwesomeLib](img/B30947_05_01.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 项目 Project_A 和项目 Project_B 依赖于不同版本的 AwesomeLib](img/B30947_05_01.jpg)'
- en: Figure 5.1 – Both Project_A and Project_B depend on different versions of AwesomeLib
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 项目 Project_A 和项目 Project_B 依赖于不同版本的 AwesomeLib
- en: 'To resolve this, we can specify which version of `AwesomeLib` to pull by placing
    a `FetchContent_Declare` call for `AwesomeLib` in the top-level `CMakeLists.txt`
    file. The order of the declaration inside the `CMakeLists.txt` file is not relevant
    here, only the level on which it is declared. Since both `Project_A` and `Project_B`
    contain the code to populate `AwesomeLib`, the top-level project does not need
    to use `FetchContent_MakeAvailable` or `FetchContent_Populate`. The resulting
    top-level `CMakeLists.txt` file might appear as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以通过在顶层的 `CMakeLists.txt` 文件中添加 `FetchContent_Declare` 调用来指定拉取哪个版本的
    `AwesomeLib`。声明的顺序在 `CMakeLists.txt` 文件中并不重要，重要的是它的声明级别。由于 `Project_A` 和 `Project_B`
    都包含填充 `AwesomeLib` 的代码，顶层项目不需要使用 `FetchContent_MakeAvailable` 或 `FetchContent_Populate`。最终生成的顶层
    `CMakeLists.txt` 文件可能如下所示：
- en: '[PRE34]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will force `AwesomeLib` to be pinned to version 1.2 for all projects.
    Of course, this only works if the interface between the versions required by `Project_A`
    and `Project_B` are compatible, resulting in a dependency graph, as illustrated
    in the following diagram:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这将强制所有项目将 `AwesomeLib` 锁定为版本 1.2。当然，这仅在 `Project_A` 和 `Project_B` 所需的版本接口兼容的情况下有效，从而生成如下所示的依赖关系图：
- en: '![Figure 5.2 – The corrected dependency graph after MyProject declares the
    version of AwesomeLib](img/B30947_05_02.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – MyProject 声明 AwesomeLib 版本后的修正依赖关系图](img/B30947_05_02.jpg)'
- en: Figure 5.2 – The corrected dependency graph after MyProject declares the version
    of AwesomeLib
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – MyProject 声明 AwesomeLib 版本后的修正依赖关系图
- en: Adding dependencies as sources has some advantages, but it comes with major
    drawbacks in that it increases configuration and build time considerably. In [*Chapter
    10*](B30947_10.xhtml#_idTextAnchor158),*Handling Distributed Repositories and
    Dependencies in a Super-Build*, we will tackle superbuilds with distributed repositories
    and provide more information about how to handle source dependencies.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 将依赖项作为源代码添加有一些优点，但也有一个主要缺点，那就是它会显著增加配置和构建时间。在 [*第 10 章*](B30947_10.xhtml#_idTextAnchor158)，《处理超构建中的分布式仓库和依赖关系》中，我们将讨论超构建和分布式仓库，并提供有关如何处理源代码依赖项的更多信息。
- en: At the beginning of the chapter, we looked at `find_package`, which can be used
    to include binary dependencies, but we did not talk about how to conveniently
    download local binary dependencies using CMake. While `FetchContent` can be used
    for that, it is not its purpose. Instead, dedicated package managers such as Conan
    and vcpkg will be better suited. Internally, `FetchContent` is using the older
    and more complicated `ExternalProject` module. While `ExternalProject` offers
    more control, it is also harder to use. Let’s have a look at how to use it next.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开始时，我们查看了`find_package`，它可以用来包含二进制依赖项，但我们没有讨论如何方便地使用CMake下载本地二进制依赖项。虽然可以使用`FetchContent`来完成此操作，但这并不是它的目的。相反，像Conan和vcpkg这样的专用包管理器更为适合。`FetchContent`在内部使用的是较旧且更复杂的`ExternalProject`模块。虽然`ExternalProject`提供了更多控制权，但使用起来也更复杂。接下来，我们来看一下如何使用它。
- en: Using ExternalProject
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用ExternalProject
- en: 'The `ExternalProject` module is used to download and build external projects
    that are not fully integrated into the main project. When building an external
    project, the build is fully isolated, meaning that it will not automatically take
    over any settings regarding architecture or platforms. This isolation can come
    in handy to avoid clashes in the naming of targets or components. The external
    project creates a primary target and several child targets that contain the following
    isolated build steps:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExternalProject`模块用于下载并构建那些没有完全集成到主项目中的外部项目。在构建外部项目时，构建是完全隔离的，这意味着它不会自动继承任何与架构或平台相关的设置。这种隔离可以避免目标或组件命名冲突。外部项目会创建一个主要目标和几个子目标，包含以下隔离的构建步骤：'
- en: '`ExternalProject` can download content in several ways such as through pure
    HTTPS downloads or by accessing versioning systems such as Git, Subversion, Mercurial,
    and CVS. If the contents are archived, the download step will also unpack them.'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ExternalProject`可以通过多种方式下载内容，比如纯HTTPS下载，或通过访问版本控制系统，如Git、Subversion、Mercurial和CVS。如果内容是归档文件，下载步骤也会将其解压。'
- en: '**Updating and patching**: The downloaded source code can either be patched
    or updated to the newest version if the content is pulled from **source code**
    **management** (**SCM**).'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**更新和修补**：如果内容是从**源代码管理**（**SCM**）中拉取的，下载的源代码可以被修补或更新到最新版本。'
- en: '**Configure**: If the downloaded source uses CMake, the configure step is executed
    on it. For non-CMake projects, a custom command that does the configuration can
    be provided.'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**配置**：如果下载的源代码使用CMake，则执行配置步骤。对于非CMake项目，可以提供一个自定义命令来进行配置。'
- en: '**Build**: By default, the same build tool that is used in the main project
    is used to build the dependency, but a custom command can be provided if this
    is not desired. If a custom build command is supplied, it is up to the user to
    ensure that the necessary compiler flags are passed on so that the results are
    ABI compatible.'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**构建**：默认情况下，依赖项使用与主项目相同的构建工具进行构建，但如果不希望如此，可以提供自定义命令。如果提供了自定义构建命令，则用户需要确保传递必要的编译器标志，以确保结果与ABI兼容。'
- en: '**Install**: The isolated build can be installed locally, usually somewhere
    in the build tree of the main project.'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**安装**：可以将隔离的构建安装到本地，通常是主项目的构建树中的某个位置。'
- en: '**Test**: If the external content comes with a set of tests, the main project
    might choose to run them. By default, the tests are not run.'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试**：如果外部内容附带了一组测试，主项目可以选择运行这些测试。默认情况下，不会运行测试。'
- en: All the steps, including downloading, run at build time. So, depending on the
    external project, this can increase the build time quite significantly. CMake
    caches the downloads and builds, so unless the external project has been changed,
    the overhead is primarily for the first run. The possibility of adding more steps
    to the external build does exist, but for most projects, the default steps are
    sufficient. The steps can be customized or omitted, as we will discover later.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 所有步骤，包括下载，都在构建时执行。因此，根据外部项目的不同，这可能会显著增加构建时间。CMake会缓存下载和构建内容，因此除非外部项目已更改，否则额外的开销主要是第一次运行时的开销。虽然可以为外部构建添加更多步骤，但对于大多数项目，默认步骤已经足够。稍后我们将看到，步骤可以根据需要进行自定义或省略。
- en: 'In the following example, the `bertrand` library for using the design by contract
    is downloaded over HTTPS and locally installed in the current `build` directory:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，使用契约设计的`bertrand`库通过HTTPS下载并在当前的`build`目录中本地安装：
- en: '[PRE35]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that the `ExternalProject` module is not available by default and has to
    be included in the first line with `include(ExternalProject)`. As the external
    library is installed in the local build directory, the `INSTALL_DIR` option is
    specified. Since `bertrand` itself is a CMake project, the installation directory
    is passed as `<INSTALL_DIR>` by using the `CMAKE_INSTALL_PREFIX` variable to build
    the project. `<INSTALL_DIR>` is a placeholder that points back to the `INSTALL_DIR`
    option. `ExternalProject` knows placeholders for the various directories such
    as `<SOURCE_DIR>`, `<BINARY_DIR>`, and `<DOWNLOAD_DIR>`. For a complete list,
    please consult the module documentation at [https://cmake.org/cmake/help/latest/module/ExternalProject.html](https://cmake.org/cmake/help/latest/module/ExternalProject.html).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`ExternalProject` 模块默认不可用，必须在第一行使用 `include(ExternalProject)` 引入。由于外部库安装在本地构建目录中，因此指定了
    `INSTALL_DIR` 选项。由于 `bertrand` 本身是一个 CMake 项目，安装目录通过使用 `CMAKE_INSTALL_PREFIX`
    变量传递给 `<INSTALL_DIR>` 以构建该项目。`<INSTALL_DIR>` 是一个占位符，指向 `INSTALL_DIR` 选项。`ExternalProject`
    知道各种目录的占位符，如 `<SOURCE_DIR>`、`<BINARY_DIR>` 和 `<DOWNLOAD_DIR>`。有关完整列表，请查阅模块文档 [https://cmake.org/cmake/help/latest/module/ExternalProject.html](https://cmake.org/cmake/help/latest/module/ExternalProject.html)。
- en: Verify your downloads
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 验证你的下载
- en: It is highly recommended that you add the download hash to any URL, as this
    sends you a notification if the contents of an artifact change.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议你在任何 URL 中添加下载哈希值，因为这样如果文件内容发生变化，你会收到通知。
- en: 'For this to work, any target that depends on `bertrand` has to be built after
    the external dependency. As `bertrand` is a header-only library, we want to add
    the `include` path to a target. Using the external project for another target
    in CMake could look similar to the following:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其生效，任何依赖于 `bertrand` 的目标必须在外部依赖项构建之后构建。由于 `bertrand` 是一个仅包含头文件的库，我们希望将 `include`
    路径添加到目标中。在 CMake 中为另一个目标使用外部项目可能类似如下所示：
- en: '[PRE36]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the first line, the installation directory is retrieved with `ExternalProject_Get_Property`
    and stored in the `INSTALL_DIR` variable. Unfortunately, the variable name is
    always the same as the property, so it is recommended that you store it immediately
    after retrieval in a variable with a unique name that expresses its use better.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，通过 `ExternalProject_Get_Property` 获取安装目录并存储在 `INSTALL_DIR` 变量中。不幸的是，变量名总是与属性名称相同，因此建议你在获取后立即将其存储在一个唯一名称的变量中，以便更好地表达其用途。
- en: Next, the target we want to build is created and made dependent on the target
    created by `ExternalProject_Add`. This is necessary to enforce the correct build
    order.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建要构建的目标，并使其依赖于 `ExternalProject_Add` 创建的目标。这是强制正确构建顺序所必需的。
- en: Finally, the path to the local installation is added to the target with `target_include_directories`.
    Additionally, we could import the CMake targets provided by the external library,
    but the purpose of this is to illustrate how this could work if the external project
    is not built by CMake.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 `target_include_directories` 将本地安装路径添加到目标中。此外，我们还可以导入外部库提供的 CMake 目标，但本示例的目的是说明当外部项目不是由
    CMake 构建时，如何实现这一操作。
- en: 'Downloading from SCM systems happens with the respective options. For Git,
    this usually looks like the following:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 从 SCM 系统下载时会使用相应的选项。对于 Git，这通常如下所示：
- en: '[PRE37]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that `GIT_TAG` can be any valid revision number for Git, including tag
    names and long and short hashes. If `GIT_TAG` is omitted, the latest version of
    the default branch—usually called main or master—is downloaded. We highly recommend
    that you always specify the version to download. The most robust way is to define
    a commit hash, as tags can be moved around, although they rarely are in practice.
    Downloading from SVN is similar to downloading from Git. For additional details,
    please consult the official documentation for `ExternalProject`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`GIT_TAG` 可以是 Git 的任何有效修订号，包括标签名称和长短哈希。如果省略 `GIT_TAG`，将下载默认分支的最新版本—通常叫做
    main 或 master。我们强烈建议你始终指定要下载的版本。最稳健的方法是定义提交哈希，因为标签有可能被移动，尽管在实践中这种情况很少发生。从 SVN
    下载与从 Git 下载类似。有关更多详情，请查阅 `ExternalProject` 的官方文档。
- en: Using non-CMake projects and cross-compiling
  id: totrans-334
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用非 CMake 项目和交叉编译
- en: 'A common use case for `ExternalProject` is to build dependencies that are not
    handled by CMake but by Autotools or Automake instead. In that case, you would
    need to specify the configuration and build commands as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExternalProject` 的常见用例是构建那些不是由 CMake 处理而是由 Autotools 或 Automake 处理的依赖项。在这种情况下，你需要指定配置和构建命令，如下所示：'
- en: '[PRE38]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Note that the first `find_program` command is used to find a version of `make`
    and store it in the `MAKE_EXECUTABLE` variable. A common issue with external projects
    is that you have to closely control where the dependencies are installed. Most
    projects want to install to a default system location, which often requires root
    privileges and could accidentally pollute a system. So, passing the necessary
    options to the configuration or a build step is often necessary. Another way to
    handle this is to avoid the installation process entirely by replacing `INSTALL_COMMAND`
    with an empty string as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第一个 `find_program` 命令用于查找 `make` 的版本并将其存储在 `MAKE_EXECUTABLE` 变量中。外部项目的一个常见问题是，你必须仔细控制依赖项的安装位置。大多数项目希望将其安装到默认的系统位置，这通常需要管理员权限，并且可能会不小心污染系统。因此，通常需要将必要的选项传递给配置或构建步骤。另一种处理方式是完全避免安装过程，通过将
    `INSTALL_COMMAND` 替换为空字符串，如下所示：
- en: '[PRE39]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: One problem with using non-CMake projects such as this is that they do not define
    the necessary targets for using the dependency directly. So, to use an externally
    built library in another target, you often have to add the full library name to
    the `target_link_libraries` calls. The major drawback of this is that you have
    to manually maintain the different names and locations of the files for the various
    platforms. The `find_library` or `find_file` calls are of little use because they
    happen at configuration time, while `ExternalProject` only creates the necessary
    files at build time.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非 CMake 项目（例如这个项目）的一大问题是，它们没有定义直接使用依赖项所需的目标。因此，要在另一个目标中使用外部构建的库，通常需要将完整的库名称添加到
    `target_link_libraries` 调用中。这个方法的主要缺点是，你需要手动维护不同平台上文件的名称和位置。`find_library` 或 `find_file`
    调用几乎没什么用处，因为它们发生在配置时，而 `ExternalProject` 只会在构建时创建所需的文件。
- en: 'Another common use case is to use `ExternalProject` to build the contents of
    an existing source directory for a different target platform. In this case, the
    parameter that handles the downloading is simply omitted. If the external project
    is using CMake to build, the toolchain file can be passed as a CMake option to
    the external project. More information about toolchain files is available in [*Chapter
    12*](B30947_12.xhtml#_idTextAnchor182), *Cross-Platform Compiling and Custom Toolchains*.
    A very common pitfall here is that `ExternalProject` will not recognize any changes
    to the sources of the external projects, so CMake might not rebuild them. For
    this reason, the `BUILD_ALWAYS` option should be passed, which has the downside
    of often making the build time considerably longer:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的用例是使用 `ExternalProject` 为不同的目标平台构建现有源目录的内容。在这种情况下，处理下载的参数可以直接省略。如果外部项目使用
    CMake 构建，可以将工具链文件作为 CMake 选项传递给外部项目。关于工具链文件的更多信息，请参阅 [*第 12 章*](B30947_12.xhtml#_idTextAnchor182)，*跨平台编译和自定义工具链*。一个常见的陷阱是，`ExternalProject`
    不会识别外部项目源代码的任何变化，因此 CMake 可能不会重新构建它们。为了避免这种情况，应该传递 `BUILD_ALWAYS` 选项，但这会导致构建时间显著增加：
- en: '[PRE40]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Managing the steps in ExternalProject
  id: totrans-342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 管理 ExternalProject 中的步骤
- en: 'As mentioned in the preceding section, the steps of `ExternalProject` can be
    configured further and used in a more granular way. `ExternalProject` can be told
    to create regular targets for each step either by passing the `STEP_TARGETS` option
    or by calling `ExternalProject_Add_StepsTargets`. The following calls expose both
    the configure step and the build step of an external project as targets:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所述，`ExternalProject` 的步骤可以进一步配置，并以更细粒度的方式使用。可以通过传递 `STEP_TARGETS` 选项或调用
    `ExternalProject_Add_StepsTargets` 来告诉 `ExternalProject` 为每个步骤创建常规目标。以下调用将外部项目的配置步骤和构建步骤暴露为目标：
- en: '[PRE41]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The targets are named after `<mainName>-step`. In the preceding example, two
    additional targets, `MyProject-configure` and `MyProject-build`, will be created.
    Creating step targets has two main uses: you can create custom steps that are
    sorted in the order of the download, configure, build, install, and test sequence,
    or you can make the steps dependent on other targets. These can either be regular
    targets, created by `add_executable`, `add_library`, or `add_custom_target`, or
    targets from other add executables. A common case is when external projects depend
    on each other, so the configuration step of one has to depend on the other. In
    the next example, the configuration step of `ProjectB` will depend on the completion
    of `ProjectA`:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 目标命名为 `<mainName>-step`。在上述示例中，将创建两个额外的目标：`MyProject-configure` 和 `MyProject-build`。创建步骤目标有两个主要用途：你可以创建按下载、配置、构建、安装和测试顺序排序的自定义步骤，或者可以使步骤依赖于其他目标。这些目标可以是常规目标，由
    `add_executable`、`add_library` 或 `add_custom_target` 创建，或者是来自其他可执行文件的目标。一个常见的情况是外部项目相互依赖，因此一个项目的配置步骤必须依赖于另一个项目。在下一个示例中，`ProjectB`
    的配置步骤将依赖于 `ProjectA` 的完成：
- en: '[PRE42]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, we can also create custom steps to be interjected into an external
    project. The process of adding steps is done with the `ExternalProject_Add_Step`
    command. Custom steps cannot be named the same as any of the predefined steps
    (such as `mkdir`, `download`, `update`, `patch`, `configure`, `build`, `install`,
    or `test`). The following example will create a step that adds the license information
    of an external project to a specific `tar` file after building:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还可以创建自定义步骤并插入到外部项目中。添加步骤的过程通过 `ExternalProject_Add_Step` 命令完成。自定义步骤不能与任何预定义的步骤同名（如
    `mkdir`、`download`、`update`、`patch`、`configure`、`build`、`install` 或 `test`）。以下示例将在构建后创建一个步骤，将外部项目的许可证信息添加到特定的
    `tar` 文件中：
- en: '[PRE43]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: All in all, `ExternalProject` is a very powerful tool; however, it can become
    very complex to manage. Often, it is that flexibility that also makes `ExternalProject`
    hard to use. While it can help isolate builds, it often forces the project maintainer
    to manually expose any information from the inner workings of the external project
    to CMake, which, ironically, is what CMake is supposed to help with in the first
    place.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，`ExternalProject` 是一个非常强大的工具；然而，它的管理可能会变得非常复杂。通常，正是这种灵活性使得 `ExternalProject`
    难以使用。虽然它可以帮助隔离构建，但它常常迫使项目维护者手动将外部项目内部工作的信息暴露给 CMake，这与 CMake 原本应当解决的问题相矛盾。
- en: Summary
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered a general approach to finding files, libraries,
    and programs, along with the more complex search for CMake packages. You learned
    how to create an imported package definition if it cannot be found automatically
    by providing your own `find` module. We looked at source-code-based dependencies
    with `ExternalProject` and `FetchContent` and how even non-CMake projects can
    be built using CMake.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了查找文件、库和程序的一般方法，以及更复杂的 CMake 包查找。你学会了如何在 CMake 无法自动找到包时，创建一个导入的包定义，方法是提供你自己的
    `find` 模块。我们还探讨了基于源代码的依赖关系，使用 `ExternalProject` 和 `FetchContent`，以及即使是非 CMake
    项目也可以通过 CMake 构建。
- en: Additionally, if you want to become even more sophisticated with your dependency
    management, we introduced Conan and vcpkg as two package handlers that integrate
    very well with CMake.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你希望在依赖管理方面更加复杂，我们介绍了 Conan 和 vcpkg 作为两种与 CMake 集成非常好的包管理工具。
- en: Dependency management is a tough topic to cover and can be tedious at times.
    Nevertheless, it pays off to take the time to set it up correctly with the techniques
    described in this chapter. The versatility of CMake and its various ways of finding
    dependencies are its greatest strengths but also its greatest weaknesses. By using
    the various `find_` commands, `FetchContent`, `ExternalProject`, or integrating
    any of the available package managers with CMake, almost any dependency can be
    integrated into a project. However, with so many methods to choose from, finding
    the best one can be tough. Nevertheless, we recommend using `find_package` whenever
    possible. The more popular CMake becomes, the better the chances are that other
    projects can be seamlessly integrated.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖管理是一个难以涵盖的复杂话题，有时可能令人感到繁琐。然而，花时间按照本章所述的技巧正确设置依赖管理是值得的。CMake 的多功能性以及它寻找依赖的多种方式是其最大优点，也是其最大弱点。通过使用各种
    `find_` 命令、`FetchContent`、`ExternalProject` 或将任何可用的包管理器与 CMake 集成，几乎可以将任何依赖集成到项目中。然而，选择合适的方法可能会非常困难。尽管如此，我们还是建议尽可能使用
    `find_package`。随着 CMake 越来越受欢迎，其他项目无缝集成的机会也会增大。
- en: In the next chapter, you will learn how to automatically generate and package
    documentation for your code.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何自动生成并打包你的代码文档。
- en: Questions
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which `find_` programs exist in CMake?
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CMake 中存在哪些 `find_` 程序？
- en: Which properties should be set for targets imported by a `find` module?
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应为由 `find` 模块导入的目标设置哪些属性？
- en: When finding things, which option takes precedence, `HINTS` or `PATHS`?
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在查找内容时，`HINTS` 和 `PATHS` 哪个选项优先？
- en: What is the order of preference of techniques to use for dependency management?
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 依赖管理技术的优先顺序是什么？
- en: At what stage does `ExternalProject` download the external content?
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ExternalProject` 在哪个阶段下载外部内容？'
- en: At what stage does `FetchContent` download the external content?
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FetchContent` 在哪个阶段下载外部内容？'
- en: Answers
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: The answer is `find_file`, `find_path`, `find_library`, `find_program`, and
    `find_package`.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 答案是 `find_file`、`find_path`、`find_library`、`find_program` 和 `find_package`。
- en: The `IMPORTED_LOCATION` and `INTERFACE_INCLUDE_DIRECTORIES` properties.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IMPORTED_LOCATION` 和 `INTERFACE_INCLUDE_DIRECTORIES` 属性。'
- en: '`HINTS` takes precedence over `PATHS`.'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`HINTS` 优先于 `PATHS`。'
- en: Package managers as dependency providers are the most recommended way to handle
    dependencies, then using standalone package managers, then `FetchContent`, and
    then, only if all else fails, `ExternalProject` should be used.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包管理器作为依赖提供者是最推荐的处理依赖的方式，其次是使用独立的包管理器，然后是 `FetchContent`，最后，只有在其他方法都失败时，才应使用
    `ExternalProject`。
- en: '`ExternalProject` downloads external content at build time.'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ExternalProject` 在构建时下载外部内容。'
- en: '`FetchContent` downloads external content at configuration time.'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FetchContent` 在配置时下载外部内容。'
