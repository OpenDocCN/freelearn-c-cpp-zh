["```cpp\n// Prerequisite\nstruct Point { /* ... */ }; \nstruct Line { /* ... */ };  \nauto lines_are_parallel(Line a, Line b) -> bool { /* ... */ }\nauto compute_intersection(Line a, Line b) -> Point { /* ... */ }\nauto get_intersection(const Line& a, const Line& b) \n  -> std::optional<Point> \n{\n  if (lines_are_parallel(a, b))\n    return std::optional{compute_intersection(a, b)};\n  else\n    return {};\n} \n```", "```cpp\nauto set_magic_point(Point p) { /* ... */ }\nauto intersection = get_intersection(line0, line1);\nif (intersection.has_value()) {\n  set_magic_point(*intersection);\n} \n```", "```cpp\nstruct Hat { /* ... */ };\nclass Head {\npublic:\n  Head() { assert(!hat_); }      // hat_ is empty by default\n  auto set_hat(const Hat& h) { \n    hat_ = h; \n  }\n  auto has_hat() const { \n    return hat_.has_value(); \n  }\n  auto& get_hat() const { \n    assert(hat_.has_value()); \n    return *hat_; \n  }\n  auto remove_hat() { \n    hat_ = {};        // Hat is cleared by assigning to {}\n  } \nprivate:\n  std::optional<Hat> hat_;\n}; \n```", "```cpp\nenum class Color { red, blue, none };  // Don't do this! \n```", "```cpp\nauto get_color() -> Color; // Returns an optional color \n```", "```cpp\nenum class Color { red, blue };\nauto get_color() -> std::optional<Color>; \n```", "```cpp\nauto set_color(Color c) { /* c is a valid color, now use it ... */ } \n```", "```cpp\nauto a = std::optional<int>{};\nauto b = std::optional<int>{};\nauto c = std::optional<int>{4};\nassert(a == b);\nassert(b != c); \n```", "```cpp\nauto a = std::optional<int>{};\nauto b = std::optional<int>{4};\nauto c = std::optional<int>{5};\nassert(a < b);\nassert(b < c); \n```", "```cpp\nauto c = std::vector<std::optional<int>>{{3}, {}, {1}, {}, {2}};\nstd::sort(c.begin(), c.end());\n// c is {}, {}, {1}, {2}, {3} \n```", "```cpp\nstd::pair<int, int> v = std::minmax({4, 3, 2, 4, 5, 1});\nstd::cout << v.first << \" \" << v.second;     // Outputs: \"1 5\" \n```", "```cpp\nauto scores = std::map<std::string, int>{};\nscores.insert(std::pair{\"Neo\", 12}); // Correct but ineffecient\nscores.emplace(\"Tri\", 45);           // Use emplace() instead\nscores.emplace(\"Ari\", 33);\nfor (auto&& it : scores) { // \"it\" is a std::pair\n  auto key = it.first;\n  auto val = it.second;\n  std::cout << key << \": \" << val << '\\n';\n} \n```", "```cpp\nauto scores = std::map<std::string, int> {\n  {\"Neo\", 12},                            // Initializer lists\n  {\"Tri\", 45},\n  {\"Ari\", 33}\n};\nfor (auto&& [key, val] : scores) {       // Structured bindings\n  std::cout << key << \": \" << val << '\\n';\n} \n```", "```cpp\nauto t = std::tuple<int, std::string, bool>{}; \n```", "```cpp\nauto t = std::tuple{0, std::string{}, false}; \n```", "```cpp\nstruct Tuple {\n  int data0_{};\n  std::string data1_{};\n  bool data2_{};\n}; \n```", "```cpp\nauto t = std::make_tuple(42, std::string{\"hi\"}, true); \n```", "```cpp\nauto a = std::get<0>(t);     // int\nauto b = std::get<1>(t);     // std::string\nauto c = std::get<2>(t);     // bool \n```", "```cpp\ntemplate <size_t Index, typename Tuple>\nauto& get(const Tuple& t) {\n  if constexpr(Index == 0) {\n    return t.data0_;\n  } else if constexpr(Index == 1) {\n    return t.data1_;\n  } else if constexpr(Index == 2) {\n    return t.data2_;\n  }\n} \n```", "```cpp\nauto t = std::tuple(42, true);\nauto v = std::get<0>(t); \n```", "```cpp\n// The Tuple class is generated first:\nclass Tuple { \n  int data0_{};\n  bool data1_{};\npublic:\n  Tuple(int v0, bool v1) : data0_{v0}, data1_{v1} {} \n};\n// get<0>(Tuple) is then generated to something like this:\nauto& get(const Tuple& tpl) { return data0_; }\n\n// The generated function is then utilized:\nauto t = Tuple(42, true); \nauto v = get(t); \n```", "```cpp\nauto number = std::get<int>(tuple);\nauto str = std::get<std::string>(tuple); \n```", "```cpp\nauto t = std::tuple(1, true, std::string{\"Jedi\"});\nfor (const auto& v : t) {\n  std::cout << v << \" \";\n} \n```", "```cpp\nauto t = std::tuple(1, true, std::string{\"Jedi\"});\nstd::cout << std::get<0>(t) << \" \";\nstd::cout << std::get<1>(t) << \" \";\nstd::cout << std::get<2>(t) << \" \";\n// Prints \"1 true Jedi\" \n```", "```cpp\ntemplate <size_t Index, typename Tuple, typename Func> \nvoid tuple_at(const Tuple& t, Func f) {\n  const auto& v = std::get<Index>(t);\n  std::invoke(f, v);\n} \n```", "```cpp\nauto t = std::tuple{1, true, std::string{\"Jedi\"}};\nauto f = [](const auto& v) { std::cout << v << \" \"; };\ntuple_at<0>(t, f);\ntuple_at<1>(t, f);\ntuple_at<2>(t, f);\n// Prints \"1 true Jedi\" \n```", "```cpp\ntemplate <typename Tuple, typename Func, size_t Index = 0> void tuple_for_each(const Tuple& t, const Func& f) {\n  constexpr auto n = std::tuple_size_v<Tuple>;\n  if constexpr(Index < n) {\n    tuple_at<Index>(t, f);\n    tuple_for_each<Tuple, Func, Index+1>(t, f);\n  }\n} \n```", "```cpp\nauto t = std::tuple{1, true, std::string{\"Jedi\"}};\ntuple_for_each(t, [](const auto& v) { std::cout << v << \" \"; });\n// Prints \"1 true Jedi\" \n```", "```cpp\ntemplate <typename Tuple, typename Func, size_t Index = 0> \nauto tuple_any_of(const Tuple& t, const Func& f) -> bool { \n  constexpr auto n = std::tuple_size_v<Tuple>; \n  if constexpr(Index < n) { \n    bool success = std::invoke(f, std::get<Index>(t)); \n    if (success) {\n      return true;\n    }\n    return tuple_any_of<Tuple, Func, Index+1>(t, f); \n  } else { \n    return false; \n  } \n} \n```", "```cpp\nauto t = std::tuple{42, 43.0f, 44.0}; \nauto has_44 = tuple_any_of(t, [](auto v) { return v == 44; }); \n```", "```cpp\n// Prerequisite \nusing namespace std::string_literals;  // \"...\"s\nauto make_saturn() { return std::tuple{\"Saturn\"s, 82, true}; }\nint main() {\n  // Using std::get<N>()\n  {\n    auto t = make_saturn();\n    auto name = std::get<0>(t);\n    auto n_moons = std::get<1>(t);\n    auto rings = std::get<2>(t);\n    std::cout << name << ' ' << n_moons << ' ' << rings << '\\n';\n    // Output: Saturn 82 true   }\n    // Using std::tie()\n  {\n    auto name = std::string{};\n    auto n_moons = int{};\n    auto rings = bool{};\n    std::tie(name, n_moons, rings) = make_saturn();\n    std::cout << name << ' ' << n_moons << ' ' << rings << '\\n';\n  }\n} \n```", "```cpp\nconst auto& [name, n_moons, rings] = make_saturn();\nstd::cout << name << ' ' << n_moons << ' ' << rings << '\\n'; \n```", "```cpp\nauto planets = { \n  std::tuple{\"Mars\"s, 2, false}, \n  std::tuple{\"Neptune\"s, 14, true} \n};\nfor (auto&& [name, n_moons, rings] : planets) { \n   std::cout << name << ' ' << n_moons << ' ' << rings << '\\n'; \n} \n// Output:\n// Mars 2 false \n// Neptune 14 true \n```", "```cpp\nauto make_earth() {\n  struct Planet { std::string name; int n_moons; bool rings; };\n  return Planet{\"Earth\", 1, false}; \n}\n// ...\nauto p = make_earth(); \nstd::cout << p.name << ' ' << p.n_moons << ' ' << p.rings << '\\n'; \n```", "```cpp\nauto [name, num_moons, has_rings] = make_earth(); \n```", "```cpp\nauto make_string(const auto& v0) { \n  auto ss = std::ostringstream{}; \n  ss << v0; \n  return ss.str(); \n} \nauto make_string(const auto& v0, const auto& v1) { \n   return make_string(v0) + \" \" + make_string(v1); \n}\nauto make_string(const auto& v0, const auto& v1, const auto& v2) { \n  return make_string(v0, v1) + \" \" + make_string(v2); \n} \n// ... and so on for as many parameters we might need \n```", "```cpp\nauto str0 = make_string(42);\nauto str1 = make_string(42, \"hi\");\nauto str2 = make_string(42, \"hi\", true); \n```", "```cpp\ntemplate<typename ...Ts> \nauto f(Ts... values) {\n  g(values...);\n} \n```", "```cpp\ntemplate <typename ...Ts>\nauto expand_pack(const Ts& ...values) {\n   auto tuple = std::tie(values...);\n} \n```", "```cpp\nexpand_pack(42, std::string{\"hi\"}); \n```", "```cpp\nauto expand_pack(const int& v0, const std::string& v1) {\n  auto tuple = std::tie(v0, v1);\n} \n```", "```cpp\ntemplate <typename ...Ts> \nauto make_string(const Ts& ...values) { \n  auto ss = std::ostringstream{}; \n  // Create a tuple of the variadic parameter pack \n  auto tuple = std::tie(values...); \n  // Iterate the tuple \n  tuple_for_each(tuple, [&ss](const auto& v) { ss << v; }); \n  return ss.str();\n}\n// ...\nauto str = make_string(\"C++\", 20);  // OK: str is \"C++\" \n```", "```cpp\ntemplate <typename ...Ts>\nauto make_string(const Ts& ...values) {\n  auto ss = std::ostringstream{};\n  auto a = std::array{values...};     // Only supports one type\n  for (auto&& v : a) { ss << v; }\n  return ss.str();\n}\n// ...\nauto a = make_string(\"A\", \"B\", \"C\");  // OK: Only one type\nauto b = make_string(100, 200, 300);  // OK: Only one type\nauto c = make_string(\"C++\", 20);      // Error: Mixed types \n```", "```cpp\nauto container = std::vector<std::any>{42, \"hi\", true}; \n```", "```cpp\nfor (const auto& a : container) {\n  if (a.type() == typeid(int)) {\n    const auto& value = std::any_cast<int>(a);\n    std::cout << value;\n  }\n  else if (a.type() == typeid(const char*)) {\n    const auto& value = std::any_cast<const char*>(a);\n    std::cout << value;\n  }\n  else if (a.type() == typeid(bool)) {\n    const auto& value = std::any_cast<bool>(a);\n    std::cout << value;\n  }\n} \n```", "```cpp\nfor (const auto& a : container) { \n  std::cout << a;                // Does not compile\n} \n```", "```cpp\nusing VariantType = std::variant<int, std::string, bool>; \nVariantType v{}; \nstd::holds_alternative<int>(v);  // true, int is first alternative\nv = 7; \nstd::holds_alternative<int>(v);  // true\nv = std::string{\"Anne\"};\nstd::holds_alternative<int>(v);  // false, int was overwritten \nv = false; \nstd::holds_alternative<bool>(v); // true, v is now bool \n```", "```cpp\nstd::cout << \"VariantType: \"<< sizeof(VariantType) << '\\n';\nstd::cout << \"std::string: \"<< sizeof(std::string) << '\\n';\nstd::cout << \"std::size_t: \"<< sizeof(std::size_t) << '\\n'; \n```", "```cpp\nVariantType: 32\nstd::string: 24\nstd::size_t: 8 \n```", "```cpp\nstruct Widget {\n  explicit Widget(int) {    // Throwing constructor\n    throw std::exception{};\n  }\n};\nauto var = std::variant<double, Widget>{1.0};\ntry {\n  var.emplace<1>(42); // Try to construct a Widget instance\n} catch (...) {\n  std::cout << \"exception caught\\n\";\n  if\u00a0(var.valueless_by_exception()) {  // var may or may not \n    std::cout << \"valueless\\n\";        // be valueless\n  } else {\n    std::cout << std::get<0>(var) << '\\n';\n  }\n} \n```", "```cpp\nauto var = std::variant<int, bool, float>{};\nstd::visit([](auto&& val) { std::cout << val; }, var); \n```", "```cpp\nstruct GeneratedFunctorImpl {\n  auto operator()(int&& v)   { std::cout << v; }\n  auto operator()(bool&& v)  { std::cout << v; }\n  auto operator()(float&& v) { std::cout << v; }\n}; \n```", "```cpp\ntemplate<class... Lambdas>\nstruct Overloaded : Lambdas... {\n  using Lambdas::operator()...;\n}; \n```", "```cpp\ntemplate<class... Lambdas> \nOverloaded(Lambdas...) -> Overloaded<Lambdas...>; \n```", "```cpp\nauto overloaded_lambdas = Overloaded{\n  [](int v)   { std::cout << \"Int: \" << v; },\n  [](bool v)  { std::cout << \"Bool: \" << v; },\n  [](float v) { std::cout << \"Float: \" << v; }\n}; \n```", "```cpp\noverloaded_lambdas(30031);    // Prints \"Int: 30031\"\noverloaded_lambdas(2.71828f); // Prints \"Float: 2.71828\" \n```", "```cpp\nauto var = std::variant<int, bool, float>{42};\nstd::visit(Overloaded{\n  [](int v)   { std::cout << \"Int: \" << v; },\n  [](bool v)  { std::cout << \"Bool: \" << v; },\n  [](float v) { std::cout << \"Float: \" << v; }\n}, var);\n// Outputs: \"Int: 42\" \n```", "```cpp\nusing VariantType = std::variant<int, std::string, bool>;\nauto container = std::vector<VariantType>{}; \n```", "```cpp\ncontainer.push_back(false);\ncontainer.push_back(\"I am a string\"s);\ncontainer.push_back(\"I am also a string\"s);\ncontainer.push_back(13); \n```", "```cpp\ncontainer.pop_back();\nstd::reverse(container.begin(), container.end());\n// etc... \n```", "```cpp\n    using VariantType = std::variant<int, std::string, bool>;\n    auto v = std::vector<VariantType>{ 42, \"needle\"s, true }; \n    ```", "```cpp\n    for (const auto& item : v) { \n      std::visit([](const auto& x) { std::cout << x << '\\n';}, item);\n    } \n    ```", "```cpp\n    auto num_bools = std::count_if(v.begin(), v.end(),\n                                   [](auto&& item) {\n      return std::holds_alternative<bool>(item);\n    }); \n    ```", "```cpp\n    auto contains = std::any_of(v.begin(), v.end(),\n                                [](auto&& item) {\n      return std::holds_alternative<std::string>(item) &&\n        std::get<std::string>(item) == \"needle\";\n    }); \n    ```", "```cpp\nstruct Player {\n  std::string name_{};\n  int level_{};\n  int score_{};\n  // etc...\n};\nauto players = std::vector<Player>{};\n// Add players here... \n```", "```cpp\nauto cmp = [](const Player& lhs, const Player& rhs) {\n  if (lhs.level_ == rhs.level_) {\n    return lhs.score_ < rhs.score_;\n  }\n  else {\n    return lhs.level_ < rhs.level_;\n  }\n};\nstd::sort(players.begin(), players.end(), cmp); \n```", "```cpp\nauto cmp = [](const Player& lhs, const Player& rhs) {\n  auto p1 = std::tie(lhs.level_, lhs.score_); // Projection\n  auto p2 = std::tie(lhs.level_, lhs.score_); // Projection\n  return p1 < p2;\n};\nstd::sort(players.begin(), players.end(), cmp); \n```", "```cpp\nstd::ranges::sort(players, std::less{}, [](const Player& p) {\n  return std::tie(p.level_, p.score_); \n}); \n```", "```cpp\nclass Player {\npublic:\n  Player(std::string name, int level, int score)\n      : name_{std::move(name)}, level_{level}, score_{score} {}\n\n  auto reflect() const {\n    return std::tie(name_, level_, score_);\n  } \nprivate:\n  std::string name_;\n  int level_{};\n  int score_{};\n}; \n```", "```cpp\nauto& operator<<(std::ostream& ostr, const Player& p) { \n  tuple_for_each(p.reflect(), [&ostr](const auto& m) { \n    ostr << m << \" \"; \n  }); \n  return ostr; \n} \n```", "```cpp\nauto v = Player{\"Kai\", 4, 2568}; \nstd::cout << v;                  // Prints: \"Kai 4 2568 \" \n```", "```cpp\ntemplate <typename T> \nconcept Reflectable = requires (T& t) {\n  t.reflect();\n}; \n```", "```cpp\nauto& operator<<(std::ostream& os, const Reflectable auto& v) {\n  tuple_for_each(v.reflect(), [&os](const auto& m) {\n    os << m << \" \";\n  });\n  return os;\n} \n```", "```cpp\nint main() {\n  auto kai = Player{\"Kai\", 4, 2568}; \n  auto ari = Player{\"Ari\", 2, 1068}; \n\n  std::cout << kai; // Prints \"Kai 4 2568\" \n  std::cout << ari; // Prints \"Ari 2 1068\" \n} \n```"]