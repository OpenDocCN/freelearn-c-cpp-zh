- en: Chapter 2. Understanding the Networking Concepts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。理解网络概念
- en: 'Before we start coding a network application, it is better for us to understand
    how a network works. In this chapter, we will dig up network concepts with their
    contents. The topics that we''ll cover in this chapter are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写网络应用程序之前，最好先了解一下网络是如何工作的。在本章中，我们将探讨网络概念及其内容。本章将涵盖的主题如下：
- en: Distinguishing between the OSI model and the TCP/IP model
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区分OSI模型和TCP/IP模型
- en: Exploring IP addresses in both IPv4 and IPv6
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索IPv4和IPv6中的IP地址
- en: Troubleshooting TCP/IP problems using various tools
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用各种工具排除TCP/IP问题
- en: An introduction to networking systems
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络系统简介
- en: Network architecture is structured with layers and protocols. Each **layer**
    in the architecture has its own role, while its main purpose is to offer a certain
    service to the higher layer and communicate with the adjoining layers. However,
    a **protocol** is a collection of rules and conventions that are used by all the
    communicating parties to standardize the communication process. For instance,
    when the layer *n* in a device communicates with another layer *n* in another
    device, for the communication to take place, they have to use the same protocol.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 网络架构是由层和协议构成的。架构中的每个**层**都有自己的作用，其主要目的是向更高层提供某种服务，并与相邻的层进行通信。然而，**协议**是一组规则和约定，被所有通信方使用以标准化通信过程。例如，当设备中的*n*层与另一个设备中的*n*层进行通信时，为了进行通信，它们必须使用相同的协议。
- en: 'There are two popular network architectures that are used nowadays: the **Open
    Systems Interconnection** (**OSI**) and **TCP/IP** reference models. We will dig
    deeper to understand each reference model with its advantages and disadvantages
    so that we can decide which model should be used in our network application.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如今有两种流行的网络架构：**开放系统互连**（**OSI**）和**TCP/IP**参考模型。我们将深入了解每个参考模型及其优缺点，以便决定在我们的网络应用程序中应该使用哪种模型。
- en: The OSI reference model
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OSI参考模型
- en: The OSI model is used to connect to the open systems—these are the systems that
    are open and communicate with other systems. By using this model, we do not depend
    on an operating system anymore, so we are allowed to communicate with any operating
    system on any computer. This model contains seven layers, where each layer has
    a specific function and defines the way data is handled on certain different layers.
    The seven layers that are contained in this model are the **Physical layer**,
    **Data Link layer**, **Network layer**, **Transport layer**, **Session layer**,
    **Presentation layer**, and the **Application layer**.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: OSI模型用于连接到开放系统-这些系统是开放的，并与其他系统通信。通过使用这个模型，我们不再依赖于操作系统，因此可以与任何计算机上的任何操作系统进行通信。这个模型包含七个层，每个层都有特定的功能，并定义了数据在不同层上的处理方式。包含在这个模型中的七个层分别是**物理层**、**数据链路层**、**网络层**、**传输层**、**会话层**、**表示层**和**应用层**。
- en: The Physical layer
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 物理层
- en: This is the first layer in the OSI model and contains a definition of the network's
    physical specification, including the physical media (cables and connectors) and
    basic devices (repeaters and hubs). The layer is responsible for the input raw
    bits transmission data stream into zeros and for the ones that are on the communication
    channel. It then places the data onto the physical media. It is concerned with
    data transmission integrity and makes sure that the bits that are sent from one
    device are exactly the same as the data that is received by the other device.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是OSI模型中的第一层，包含了网络的物理规范的定义，包括物理介质（电缆和连接器）和基本设备（中继器和集线器）。该层负责将输入的原始比特传输数据流转换为零，并将位于通信通道上的数据。然后将数据放置到物理介质上。它关注数据传输的完整性，并确保从一个设备发送的比特与另一个设备接收到的数据完全相同。
- en: The Data Link layer
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据链路层
- en: The main role of the Data Link layer is to provide a link for raw data transmission.
    Before the data is transmitted, it is broken up into data frames, and the Data
    Link layer transmits them consecutively. The receiver will send back an *acknowledge
    frame* for each frame that has been sent if the service is reliable.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 数据链路层的主要作用是提供原始数据传输的链路。在数据传输之前，它将数据分成数据帧，并连续传输数据帧。如果服务是可靠的，接收方将为每个已发送的帧发送一个*确认帧*。
- en: 'This layer consists of two sublayers: **Logical Link Control** (**LLC**) and
    **Media Access Control** (**MAC**). The LLC sublayer is responsible for transmission
    error checking and deals with frame transmission, while the MAC sublayer defines
    how to retrieve data from the physical media or store data in the physical media.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层包括两个子层：**逻辑链路控制**（**LLC**）和**媒体访问控制**（**MAC**）。LLC子层负责传输错误检查和帧传输，而MAC子层定义了如何从物理介质中检索数据或将数据存储在物理介质中。
- en: 'We can also find the MAC address, also called as the **physical address**,
    in this layer. The MAC address is used to identify every device that connects
    to the network because it is unique for each device. Using Command Prompt, we
    can obtain the address by typing the following command in the console window:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在这一层找到MAC地址，也称为**物理地址**。MAC地址用于识别连接到网络的每个设备，因为每个设备的MAC地址都是唯一的。通过命令提示符，我们可以通过在控制台窗口中输入以下命令来获取地址：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will get the console output, as follows, after ignoring all other information
    except **Windows IP Configuration** and **Wireless LAN adapter Wi-Fi**. We can
    find the MAC address in the **Physical Address** section, which is **80-19-34-CB-BF-FB**
    for my own environment. You will get a different result since the MAC address
    is unique for every device:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到控制台输出，如下所示，忽略除**Windows IP Configuration**和**无线局域网适配器Wi-Fi**之外的所有其他信息。我们可以在**物理地址**部分找到MAC地址，对于我的环境来说是**80-19-34-CB-BF-FB**。由于MAC地址对每个设备都是唯一的，您将得到不同的结果：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The MAC address contains twelve hexadecimal characters, where two digits are
    paired with each other. The first six digits represent the **organizationally
    unique identifier** and the remaining digits represent the **manufacturer serial
    number**. If you are really curious to know what this number means, you can go
    to [www.macvendorlookup.com](http://www.macvendorlookup.com) and fill the text
    box with our MAC address to know more about it. In my own system, I got Intel
    Corporate as the vendor company name, which is the same as the brand of my installed
    network card.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: MAC地址包含十二个十六进制字符，其中两个数字成对出现。前六位数字代表组织唯一标识符，剩下的数字代表制造商序列号。如果你真的很好奇想知道这个数字的含义，你可以去[www.macvendorlookup.com](http://www.macvendorlookup.com)并在文本框中填写我们的MAC地址以了解更多信息。在我的系统中，我得到了英特尔公司作为供应商公司名称，这与我安装的网络卡品牌相同。
- en: The Network layer
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络层
- en: 'The Network layer is responsible for defining the best way to route the packets
    from a source to the destination device. It will generate routing tables using
    **Internet Protocol** (**IP**) as the routing protocol, and the IP address is
    used to make sure that the data gets its route to the required destination. There
    are two versions of IP nowadays: **IPv4** and **IPv6**. In IPv4, we use 32-bit
    addresses to address the protocol and we use 128-bit addresses in IPv6\. You are
    going to learn more about Internet Protocol, IPv4, and IPv6 in the next topic.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层负责定义从源到目的地设备的数据包的最佳路由方式。它将使用**Internet协议**（**IP**）作为路由协议生成路由表，并使用IP地址确保数据到达所需目的地的路由。如今有两个版本的IP：**IPv4**和**IPv6**。在IPv4中，我们使用32位地址来寻址协议，在IPv6中使用128位地址。您将在下一个主题中了解更多关于Internet协议、IPv4和IPv6的信息。
- en: The Transport layer
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传输层
- en: The Transport layer is responsible for transferring data from a source to destination.
    It will split up the data into smaller parts, or in this case **segments**, and
    then will join all the segments to restore the data to its initial form in the
    destination.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 传输层负责将数据从源传输到目的地。它将数据分割成较小的部分，或在这种情况下称为**段**，然后将所有段连接起来，将数据恢复到目的地的初始形式。
- en: 'There are two main protocols that work in this layer: the **Transmission Control
    Protocol** (**TCP**) and the **User Datagram Protocol** (**UDP**). TCP supplies
    the delivery of data by establishing a session. The data will not be transmitted
    until a session is established. TCP is also known as the **connection-oriented
    protocol**, which means that the session has to be established before transmitting
    the data. UDP is a method of delivering data with the best efforts, but does not
    give a guaranteed delivery because it does not establish a session. Therefore,
    UDP is also known as the **connection-less protocol**. In-depth explanation about
    TCP and UDP can be found in the next topic.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一层中有两种主要的协议：**传输控制协议**（**TCP**）和**用户数据报协议**（**UDP**）。TCP通过建立会话来提供数据传输。在建立会话之前，数据不会被传输。TCP也被称为**面向连接的协议**，这意味着在传输数据之前必须建立会话。UDP是一种尽最大努力传输数据的方法，但不提供保证的传输，因为它不建立会话。因此，UDP也被称为**无连接的协议**。关于TCP和UDP的深入解释可以在下一个主题中找到。
- en: The Session layer
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传输层
- en: The Session layer is responsible for the establishment, maintenance, and termination
    of the session. We can analogize the session like a connection between two devices
    on the network. For example, if we want to send a file from a computer to another,
    this layer will establish the connection first before the file can be sent. This
    layer will then make sure that the connection is still up until the file is sent
    completely. Finally, this layer will terminate the connection if it is no longer
    needed. The connection we talk about is the session.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 会话层负责建立、维护和终止会话。我们可以将会话类比为网络上两个设备之间的连接。例如，如果我们想要从一台计算机向另一台计算机发送文件，这一层将在发送文件之前首先建立连接。然后，这一层将确保连接仍然保持到文件完全发送。最后，如果不再需要，这一层将终止连接。我们谈论的连接就是会话。
- en: This layer also makes sure that the data from a different application is not
    interchanged. For example, if we run the Internet browser, chat application, and
    download manager at the same time, this layer will be responsible for establishing
    the session for every single application and ensure that they remain separated
    from other applications.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层还确保来自不同应用程序的数据不会互相交换。例如，如果我们同时运行互联网浏览器、聊天应用程序和下载管理器，这一层将负责为每个应用程序建立会话，并确保它们与其他应用程序保持分离。
- en: 'There are three communication methods that are used by this layer: the **simplex**,
    **half-duplex**, or **full-duplex** method. In the simplex method, data can only
    be transferred by one party, so the other cannot transfer any data. This method
    is no longer common in use, since we need applications that can interact with
    each other. In the half-duplex method, any data can be transferred to all the
    involved devices, but only one device can transfer the data in the time, after
    it completes the sending process. Then, the others can also send and transfer
    data. The full-duplex method can transfer data to all the devices at the same
    time. To send and receive data, this method uses different paths.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层使用了三种通信方法：**单工**，**半双工**或**全双工**方法。在单工方法中，数据只能由一方传输，因此另一方无法传输任何数据。由于我们需要可以相互交互的应用程序，这种方法已经不再常用。在半双工方法中，任何数据都可以传输到所有涉及的设备，但只有一个设备可以在某个时间传输数据，完成发送过程后，其他设备也可以发送和传输数据。全双工方法可以同时向所有设备传输数据。为了发送和接收数据，这种方法使用不同的路径。
- en: The Presentation layer
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表示层
- en: The Presentation layer role is used to determine the data that has been sent,
    to translate the data into the appropriate format, and then to present it. For
    example, we send an MP3 file over the network and the file is split up into several
    segments. Then, using the header information on the segment, this layer will construct
    the file by translating the segments.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 表示层的作用是确定已发送的数据，将数据转换为适当的格式，然后呈现出来。例如，我们通过网络发送一个MP3文件，文件被分成几个段。然后，使用段上的头信息，这一层将通过翻译段来构建文件。
- en: Moreover, this layer is responsible for data compression and decompression because
    all the data transmitted over the Internet is compressed to save the bandwidth.
    This layer is also responsible for data encryption and decryption in order to
    secure communication between two devices.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这一层负责数据压缩和解压缩，因为所有在互联网上传输的数据都经过压缩以节省带宽。这一层还负责数据加密和解密，以确保两个设备之间的通信安全。
- en: The Application layer
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用层
- en: 'The Application layer deals with the computer application that is used by a
    user. Only the application that connects to a network will connect to this layer.
    This layer contains several protocols that are needed by a user, which are as
    follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层处理用户使用的计算机应用程序。只有连接到网络的应用程序才会连接到这一层。这一层包含用户需要的几个协议，如下所示：
- en: '**The Domain Name System** (**DNS**): This protocol is the one that finds the
    hostname of an IP address. With this system, we do not need to memorize every
    IP address any longer, just the hostname. We can easily remember a word in the
    hostname instead of a bunch of numbers in the IP address.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**域名系统**（**DNS**）：这个协议是用来找到IP地址的主机名的。有了这个系统，我们不再需要记住每个IP地址，只需要记住主机名。我们可以更容易地记住主机名中的单词，而不是IP地址中的一堆数字。'
- en: '**The Hypertext Transfer Protocol** (**HTTP**): This protocol is the one that
    transmits data over the Internet on web pages. We also have the HTTPS format that
    is used to send encrypted data for security issues.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超文本传输协议**（**HTTP**）：这个协议用于在网页上在互联网上传输数据。我们还有HTTPS格式，用于发送加密数据以解决安全问题。'
- en: '**The File Transfer Protocol** (**FTP**): This protocol is the one that is
    used to transfer files from or to an FTP server.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件传输协议**（**FTP**）：这个协议用于从FTP服务器传输文件或到FTP服务器传输文件。'
- en: '**The Trivial FTP** (**TFTP**): This protocol is similar to FTP, which is used
    to send smaller files.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单文件传输协议**（**TFTP**）：这个协议类似于FTP，用于发送较小的文件。'
- en: '**The Dynamic Host Configuration Protocol** (**DHCP**): This protocol is a
    method that is used to assign the TCP/IP configuration dynamically.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态主机配置协议**（**DHCP**）：这个协议是用于动态分配TCP/IP配置的方法。'
- en: '**The Post Office Protocol** (**POP3**): This protocol is an electronic mail
    protocol used to get back e-mails from POP3 servers. The server is usually hosted
    by an **Internet Service Provider** (**ISP**).'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**邮局协议**（**POP3**）：这个协议是用于从POP3服务器获取电子邮件的电子邮件协议。服务器通常由**互联网服务提供商**（**ISP**）托管。'
- en: '**The Simple Mail Transfer Protocol** (**SMTP**): This protocol is in contrast
    with POP3 and is used to send electronic mails.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单邮件传输协议**（**SMTP**）：这个协议与POP3相反，用于发送电子邮件。'
- en: '**The Internet Message Access Protocol** (**IMAP**): This protocol is used
    to receive e-mail messages. With this protocol, users can save their e-mail messages
    on their folder on a local computer.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互联网消息访问协议**（**IMAP**）：这个协议用于接收电子邮件。使用这个协议，用户可以将他们的电子邮件消息保存在本地计算机上的文件夹中。'
- en: '**The Simple Network Management Protocol** (**SNMP**): This protocol is used
    to manage network devices (routers and switches) and detect problems to report
    them before they become significant.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单网络管理协议**（**SNMP**）：这个协议用于管理网络设备（路由器和交换机）并在问题变得重大之前检测并报告问题。'
- en: '**The Server Message Block** (**SMB**): This protocol is an FTP that is used
    on Microsoft networks primarily for file and printer sharing.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器消息块**（**SMB**）：这个协议是主要用于文件和打印机共享的Microsoft网络上的FTP。'
- en: This layer also decides whether enough network resources are available for network
    access. For instance, if you want to surf the Internet using an Internet browser,
    the Application layer decides whether access to the Internet is available using
    HTTP.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层还决定了是否有足够的网络资源可供网络访问。例如，如果您想使用互联网浏览器上网，应用层会决定是否可以使用HTTP访问互联网。
- en: 'Let''s see the following figure to see which all protocols are included in
    the OSI layer:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看下面的图，看看OSI层中包含了哪些协议：
- en: '![The Application layer](img/00011.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![应用层](img/00011.jpeg)'
- en: 'We can divide all the seven layers into two section layers: the **Upper Layer**
    and **Lower Layer**. The upper layer is responsible for interacting with the user
    and is less concerned about the low-level details, whereas the lower layer is
    responsible for transferring data over the network, such as formatting and encoding.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将所有七层分为两个部分层：**上层**和**下层**。上层负责与用户交互，对低级细节不太关心，而下层负责在网络上传输数据，如格式化和编码。
- en: The format of data traveling is different for each layer. There are bits for
    the Physical layer, frame for the Data Link layer, and so on.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每一层传输的数据格式都不同。物理层有比特，数据链路层有帧，依此类推。
- en: The TCP/IP reference model
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP/IP参考模型
- en: 'The TCP/IP model was created before the OSI model. This model works in a similar
    way to the OSI model, except that it just contains four layers. Each layer on
    the TCP/IP model corresponds to the layers of the OSI model. The TCP/IP Application
    layer maps the 5, 6, and 7 layers of the OSI model. The TCP/IP Transport layer
    maps the layer 4 of the OSI model. The TCP/IP Internet layer maps the layer 3
    of the OSI model. The TCP/IP Link layer maps the layers 1 and 2 of the OSI model.
    Let''s see the following figure for further details:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP模型是在OSI模型之前创建的。这个模型的工作方式与OSI模型类似，只是它只包含四层。TCP/IP模型的每一层对应于OSI模型的层。TCP/IP应用层映射OSI模型的第5、6和7层。TCP/IP传输层映射OSI模型的第4层。TCP/IP互联网层映射OSI模型的第3层。TCP/IP链路层映射OSI模型的第1和2层。让我们看下图以了解更多细节：
- en: '![The TCP/IP reference model](img/00012.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![TCP/IP参考模型](img/00012.jpeg)'
- en: 'These are the main roles of each layer in the TCP/IP model:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是TCP/IP模型中每个层的主要作用：
- en: The Link layer is responsible for determining the protocols and physical devices
    that are used in the data transmission process.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链路层负责确定在数据传输过程中使用的协议和物理设备。
- en: The Internet layer is responsible for determining the best routing for the data
    transmission process by addressing the packet.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网层负责通过寻址数据包确定最佳的数据传输路由。
- en: The Transport layer is responsible for establishing the communication between
    the two devices and sending the packet.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传输层负责建立两个设备之间的通信并发送数据包。
- en: The Application layer is responsible for providing services to applications
    that run on a computer. Because of the absence of the session and presentation
    layers, applications have to be included in any required session and presentation
    functions.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用层负责为计算机上运行的应用程序提供服务。由于缺少会话和表示层，应用程序必须包含任何所需的会话和表示功能。
- en: 'Here are the protocols and devices that are involved in the TCP/IP model:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是涉及TCP/IP模型的协议和设备：
- en: '| Layer | Protocol | Device |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 层 | 协议 | 设备 |'
- en: '| --- | --- | --- |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Application | HTTP, HTTPS, SMTP, POP3, and DNS | Proxy Server and Firewall
    |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 应用 | HTTP、HTTPS、SMTP、POP3和DNS | 代理服务器和防火墙 |'
- en: '| Transport | TCP and UDP | - |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 传输 | TCP和UDP | - |'
- en: '| Internet | IP and ICMP | Router |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 互联网 | IP和ICMP | 路由器 |'
- en: '| Link | Ethernet, Token Ring, and Frame Relay | Hub, Modem, and Repeater |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 链路 | 以太网、令牌环和帧中继 | 集线器、调制解调器和中继器 |'
- en: Understanding TCP and UDP
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解TCP和UDP
- en: As we discussed earlier in this chapter in the *Transport layer* section, TCP
    and UDP are the main protocols that are used to transfer data across a network.
    The delivery mechanisms that they have are different from each other. TCP has
    acknowledgments, sequence numbers, and flow control in transferring data process
    to provide a guaranteed delivery, whereas UDP does not provide a guaranteed delivery
    but provides a delivery with best efforts.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章的*传输层*部分中讨论的那样，TCP和UDP是用于在网络中传输数据的主要协议。它们的传输机制彼此不同。TCP在传输数据过程中提供了确认、序列号和流量控制以提供可靠的传输，而UDP不提供可靠的传输，但尽最大努力提供传输。
- en: Transmission Control Protocol
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传输控制协议
- en: 'TCP performs a three-way handshaking process before the protocol establishes
    the session. This is done in order to provide a guaranteed delivery. Refer to
    the following figure to understand the three-way handshaking process:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在协议建立会话之前，TCP执行三次握手过程。这是为了提供可靠的传输。请参考下图了解三次握手过程：
- en: '![Transmission Control Protocol](img/00013.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![传输控制协议](img/00013.jpeg)'
- en: From the preceding image, imagine that Carol's device wants to transfer data
    to Bryan's device and that they need to perform a three-way handshaking process.
    First, Carol's device sends a packet to Bryan's device with the **synchronize**
    (**SYN**) flag enabled. Once Bryan's device receives the packet, it replies with
    sending another packet that has both the SYN and **acknowledge** (**ACK**) flags
    enabled. Lastly, Carol's device completes the handshaking process by sending a
    third packet with the ACK flag enabled. Now, both devices have an established
    session and an assurance that the other device is working. The data transmission
    is then ready to take place after the session is established.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从上图中可以想象，Carol的设备想要向Bryan的设备传输数据，并且它们需要执行三次握手过程。首先，Carol的设备发送一个带有**同步**（SYN）标志的数据包到Bryan的设备。一旦Bryan的设备接收到数据包，它会回复发送另一个带有SYN和**确认**（ACK）标志的数据包。最后，Carol的设备通过发送一个带有ACK标志的第三个数据包完成握手过程。现在，两个设备都建立了会话，并确保对方正在工作。会话建立后，数据传输就准备好进行了。
- en: Tip
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In the security area, we know the term "SYN-Flood", which is a denial-of-service
    attack, where an attacker sends a succession of SYN requests to a target's system
    in an attempt to consume enough server resources to make the system unresponsive
    to legitimate traffic. The attacker just sends SYN without sending the expected
    ACK, causing the server to send the SYN-ACK to a falsified IP address—which will
    not send an ACK because it "knows" that it never sent the SYN.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在安全领域，我们知道“SYN-Flood”这个术语，它是一种拒绝服务攻击，攻击者向目标系统发送一系列SYN请求，试图消耗足够的服务器资源使系统对合法流量无响应。攻击者只发送SYN而不发送预期的ACK，导致服务器向伪造的IP地址发送SYN-ACK，而伪造的IP地址不会发送ACK，因为它“知道”它从未发送过SYN。
- en: TCP also splits up the data into smaller segments and uses sequence numbers
    to track these segments. Each separated segment is assigned different sequence
    numbers, such as 1 to 20\. The destination device then receives each segment and
    uses the sequence numbers to reassemble the file based on the order of the sequence.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: TCP还将数据分割成较小的段，并使用序列号来跟踪这些段。每个分离的段被分配不同的序列号，比如1到20。目标设备接收每个段，并使用序列号根据序列的顺序重新组装文件。
- en: For instance, consider that Carol wants to download a JPEG image file from Bryan's
    device. After establishing the session in a three-way handshaking process, the
    two devices determine how big the single segment is and how many segments need
    to be sent between acknowledgments. The total number of segments that can be sent
    at a time is known as the TCP **sliding window**. The data in the segment is not
    valid anymore if a single bit is broken or lost in transmission. TCP uses **Cyclical
    Redundancy** **Check** (**CRC**) to identify the broken or lost data by verifying
    that the data is intact in each segment. If there is any corrupt or missing segment
    in transmission, Carol's device will send a **negative acknowledge** (**NACK**)
    packet and then will request the corrupt or missing segment; otherwise, Carol's
    device will send an ACK packet and request the next segment.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设Carol想要从Bryan的设备下载一个JPEG图像文件。在进行三次握手的过程中建立会话后，两个设备确定单个段的大小以及在确认之间需要发送多少个段。可以同时发送的段的总数称为TCP滑动窗口。如果在传输过程中有一个位损坏或丢失，段中的数据将不再有效。TCP使用循环冗余检查（CRC）来识别损坏或丢失的数据，通过验证每个段中的数据是否完整。如果传输中有任何损坏或丢失的段，Carol的设备将发送一个负确认（NACK）数据包，然后请求损坏或丢失的段；否则，Carol的设备将发送一个ACK数据包并请求下一个段。
- en: User Datagram Protocol
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户数据报协议
- en: UDP does not perform any handshaking process before sending data. It just sends
    the data directly to the destination device; however, it puts in its best effort
    to forward the messages. Imagine that we are waiting to receive a message from
    our friend. We call his/her phone to receive our message. If our call is not answered,
    we can send the e-mail or text message to inform our friend. If our friend does
    not reply to our e-mail or text messages, we can send regular e-mails. However,
    all techniques that we talked about do not give any assurance that our message
    was received. But still, we make our best efforts to forward the message until
    this works. This our best effort in analogy of sending e-mails is similar with
    best-effort term for UDP. It will give its best effort to ensure that the data
    is received by the receiver, even though there is no assurance that the data was
    received.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: UDP在发送数据之前不执行任何握手过程。它只是直接将数据发送到目标设备；但是，它会尽最大努力转发消息。想象一下，我们正在等待朋友的消息。我们打电话给他/她来接收我们的消息。如果我们的电话没有接听，我们可以发送电子邮件或短信通知我们的朋友。如果我们的朋友没有回复我们的电子邮件或短信，我们可以发送常规电子邮件。然而，我们讨论的所有技术都不能保证我们的消息已被接收。但是，我们仍然尽最大努力转发消息，直到成功为止。我们在发送电子邮件的类比中的最大努力类似于UDP的最大努力术语。它将尽最大努力确保接收方接收到数据，即使不能保证数据已被接收。
- en: So, why is UDP used even though it is not reliable? Sometimes we need a communication
    which has fast speed data transfer even though has a little bit data corruption.
    For instance, streaming audio, streaming video, and **Voice over IP** (**VoIP**)
    use UDP to make sure that they have fast speed data transfer. Although the UDP
    must have had lost packets, we are still able to get all the messages clearly.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么即使UDP不可靠也会使用它呢？有时我们需要进行快速数据传输的通信，即使有一点数据损坏也可以。例如，流媒体音频、流媒体视频和VoIP使用UDP来确保它们具有快速的数据传输速度。尽管UDP可能会丢失数据包，我们仍然能够清晰地接收所有消息。
- en: However, although UDP does not check the connection before transmitting data,
    it actually uses a checksum to validate the data. The checksum can check whether
    the received data is altered or not by comparing the checksum value.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管UDP在传输数据之前不检查连接，但它实际上使用校验和来验证数据。校验和可以通过比较校验和值来检查接收到的数据是否被更改。
- en: Understanding ports
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解端口
- en: In computer networking, a **port** is an endpoint to send or receive data. A
    port is recognized by its **port number**, which contains a 16-bit number. The
    logical port number is used by both TCP and UDP to trace the contents of a packet
    and helps TCP/IP obtain the packet of the application or service that will process
    the data when it is received by the device.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机网络中，端口是发送或接收数据的端点。端口通过其端口号来识别，其中包含一个16位数字。逻辑端口号被TCP和UDP用来跟踪数据包的内容，并在设备接收到数据时帮助TCP/IP获取将处理数据的应用程序或服务的数据包。
- en: 'There are a total of `65536` TCP ports and `65536` UDP ports. We can divide
    the TCP ports into three port ranges, which are:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: TCP端口总共有65536个，UDP端口也有65536个。我们可以将TCP端口分为三个端口范围，分别是：
- en: Well-known ports from `0` to `1023` are ports that have been registered by the
    **Internet** **Assigned Numbers Authority** (**IANA**) to associate with specific
    protocols or applications.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从0到1023的众所周知的端口是由IANA注册的，用于与特定协议或应用程序相关联。
- en: Registered ports from `1024` to `49151` are ports that have been registered
    by IANA for a specific protocol, but unused ports in this range can be assigned
    by computer applications.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从1024到49151的注册端口是由IANA注册的，用于特定协议，但在此范围内未使用的端口可以由计算机应用程序分配。
- en: Dynamic ports from `49152` to `65535` are unregistered ports and can be assigned
    for any purpose.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从49152到65535的动态端口是未注册的端口，可以用于任何目的。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To get more details about all the ports in TCP and UDP, we can go to [en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers](http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers).
    Also, to know about all the assigned ports that have been registered by IANA,
    go to [www.iana.org/assignments/port-numbers](http://www.iana.org/assignments/port-numbers).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取有关TCP和UDP中所有端口的更多详细信息，可以访问[en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers](http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers)。此外，要了解所有已由IANA注册的已分配端口，请访问[www.iana.org/assignments/port-numbers](http://www.iana.org/assignments/port-numbers)。
- en: 'To understand the port concept, consider that we have an e-mail client installed
    in our computer, such as Thunderbird or Microsoft Outlook. Now, we want to send
    an e-mail to the Gmail server and then grab all the incoming e-mails from the
    server to save them on our local computer. The steps to send an e-mail are as
    follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解端口的概念，可以考虑我们的计算机上安装了电子邮件客户端，如Thunderbird或Microsoft Outlook。现在，我们想要将电子邮件发送到Gmail服务器，然后从服务器上获取所有传入的电子邮件并将其保存在我们的本地计算机上。发送电子邮件的步骤如下：
- en: Our computer assigns a random unused port number, such as `48127`, to send the
    e-mail to the Gmail SMTP server to the port `25`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的计算机会分配一个随机未使用的端口号，比如`48127`，用来将电子邮件发送到Gmail SMTP服务器的端口`25`。
- en: When the e-mail arrives at the SMTP server, it recognizes that the data has
    come from the port `25` and then forwards the data to the SMTP, which handles
    the service.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当电子邮件到达SMTP服务器时，它会识别数据来自端口`25`，然后将数据转发到处理该服务的SMTP。
- en: Once the e-mail is received, the server sends the acknowledgement to the port
    `48127` in our computer to inform the computer that the e-mail has been received.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦电子邮件被接收，服务器会将确认发送到我们计算机上的端口`48127`，以通知计算机已经接收到电子邮件。
- en: After our computer completely receives the acknowledgement from the port `48127`,
    it sends an e-mail to the e-mail client, and the e-mail client then moves the
    e-mail from Outbox to the Sent folder.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的计算机完全接收到来自端口`48127`的确认后，它会将电子邮件发送到电子邮件客户端，然后电子邮件客户端将电子邮件从发件箱移动到已发送文件夹。
- en: 'Similar to the steps for sending an e-mail, to receive an e-mail, we have to
    deal with a port. The steps for which are as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与发送电子邮件的步骤类似，要接收电子邮件，我们必须处理一个端口。接收电子邮件的步骤如下：
- en: Our computer assigns a random unused port number, such as `48128`, to send a
    request to the Gmail POP3 server to the port `110`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的计算机会分配一个随机未使用的端口号，比如`48128`，用来向Gmail POP3服务器发送请求到端口`110`。
- en: When the e-mail arrives at the POP3 server, it recognizes that the data has
    come from the port `110` and then forwards the data to POP3, which handles the
    service.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当电子邮件到达POP3服务器时，它会识别数据来自端口`110`，然后将数据转发到处理该服务的POP3。
- en: The POP3 server then sends an e-mail to our computer on the port `48128`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，POP3服务器会在端口`48128`向我们的计算机发送电子邮件。
- en: After our computer receives the e-mail from the port `48128`, it sends the e-mail
    to our e-mail client and then moves it to the Inbox folder. It also automatically
    saves the mail to the local computer.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的计算机从端口`48128`接收到电子邮件后，它会将电子邮件发送到我们的电子邮件客户端，然后将其移动到收件箱文件夹。它还会自动将邮件保存到本地计算机。
- en: Exploring the Internet Protocol
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Internet协议
- en: IP is a primary communication protocol that is used to deliver a datagram across
    networks. The datagram itself is a transfer unit associated with a packet-switched
    network. The role of IP is to deliver packets from the host to the host based
    on the IP address, which is stated in the packet's header. There are two versions
    of IP that are commonly used nowadays, which are IPv4 and IPv6.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: IP是一种主要的通信协议，用于在网络上传递数据报。数据报本身是与分组交换网络相关联的传输单元。IP的作用是根据数据包头部中指定的IP地址，从主机传递数据包到主机。目前常用的IP版本有两个，即IPv4和IPv6。
- en: Internet Protocol Version 4 – IPv4
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Internet协议版本4 - IPv4
- en: IPv4 has become the standard IP address since 1980s and is used to obtain TCP/IP
    traffic from a computer to another over the network. An IP address is unique for
    every device connected over the Internet, and all devices can communicate with
    each other over the Internet as long as they have a valid IP address.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 自1980年代以来，IPv4已成为标准IP地址，并用于在网络上从一台计算机到另一台获取TCP/IP流量。每个连接到互联网的设备都有唯一的IP地址，只要它们有有效的IP地址，所有设备都可以在互联网上相互通信。
- en: A valid IP address is constructed by four decimal numbers that are separated
    by three dots. The address only contains a decimal number from `0` to `255`. We
    can say that `10.161.4.25` is a valid IP address since it contains four decimal
    numbers between `0` to `255` and is separated by three dots, while `192.2.256.4`
    is an invalid IP address because it contains decimal numbers greater than `255`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的IP地址由四个十进制数构成，用三个点分隔。地址只包含从`0`到`255`的十进制数。我们可以说`10.161.4.25`是一个有效的IP地址，因为它包含了从`0`到`255`的四个十进制数，并用三个点分隔，而`192.2.256.4`是一个无效的IP地址，因为它包含了大于`255`的十进制数。
- en: The decimal numbers actually convert the result from 8 binary digits. So, for
    the maximum 8-bit number, we will have 1111 1111 or 255 in decimal. This is why
    the range of a decimal number in an IP address is from 0 (0000 0000) to 255 (1111
    1111).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制数实际上将结果从8位二进制数字转换而来。因此，对于最大的8位数，我们将得到1111 1111或者十进制的255。这就是为什么IP地址中十进制数的范围是从0（0000
    0000）到255（1111 1111）。
- en: 'To know our IP address configuration, we can use the `ipconfig /all` command
    again in our Command Prompt window. Then, it will display the output as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解我们的IP地址配置，我们可以在命令提示符窗口中再次使用`ipconfig /all`命令。然后，它将显示以下输出：
- en: '[PRE2]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The output will show the IP address in the IPv4 address and the IPv6 address.
    We can also see that in my device, `10.1.6.1` is used as a default gateway of
    the system. The `Default Gateway` parameter is a point on the computer network
    that is used to provide a path for the unmatched IP address or subnets.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将显示IPv4地址和IPv6地址中的IP地址。我们还可以看到在我的设备中，`10.1.6.1`被用作系统的默认网关。`默认网关`参数是计算机网络上的一个点，用于为不匹配的IP地址或子网提供路径。
- en: 'An IP address must contain these two components: a **network ID** to identify
    the subnetwork or subnet where the computer is located and a **host ID** to identify
    the computer within that subnet. Every network ID indicates a group of hosts on
    a subnet of a network. Devices that have the same network IDs must have unique
    host IDs. If two or more devices have the same host ID and the same network ID
    (the IP address is the same for all four decimal numbers), there will be an IP
    address conflict.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: IP地址必须包含这两个组件：**网络ID**用于识别计算机所在的子网络或子网，**主机ID**用于识别该子网中的计算机。每个网络ID表示网络子网上的一组主机。具有相同网络ID的设备必须具有唯一的主机ID。如果两个或更多设备具有相同的主机ID和相同的网络ID（所有四个十进制数的IP地址相同），则会发生IP地址冲突。
- en: 'For local networks, the **subnet mask** is used to identify the portion of
    a network ID and a host ID in the IP address. The following are a few common subnet
    masks:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本地网络，**子网掩码**用于识别IP地址中的网络ID和主机ID部分。以下是一些常见的子网掩码：
- en: '`255.0.0.0`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`255.0.0.0`'
- en: '`255.255.0.0`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`255.255.0.0`'
- en: '`255.255.255.0`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 255.255.255.0
- en: 'Imagine that we have the IP address `190.23.4.51` and the subnet mask `255.255.0.0`.
    Now, we can find the network ID using the Boolean `AND` logic for each bit of
    the IP address corresponding to the subnet mask. The following table will convert
    the IP address and subnet mask into a binary digit and then use the Boolean `AND`
    logic to find out the network ID:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有IP地址`190.23.4.51`和子网掩码`255.255.0.0`。现在，我们可以使用每个与子网掩码对应的IP地址位的布尔“AND”逻辑来找到网络ID。以下表将IP地址和子网掩码转换为二进制数字，然后使用布尔“AND”逻辑来找出网络ID：
- en: '|   | 1st Octet | 2nd Octet | 3rd Octet | 4th Octet |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '|   | 第一组 | 第二组 | 第三组 | 第四组 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 190.23.4.51 | 1011 1110 | 0001 0111 | 0000 0100 | 0011 0011 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 190.23.4.51 | 1011 1110 | 0001 0111 | 0000 0100 | 0011 0011 |'
- en: '| 255.255.0.0 | 1111 1111 | 1111 1111 | 0000 0000 | 0000 0000 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 255.255.0.0 | 1111 1111 | 1111 1111 | 0000 0000 | 0000 0000 |'
- en: '| **Network ID:** | 1011 1110 | 0001 0111 | 0000 0000 | 0000 0000 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| **网络ID：** | 1011 1110 | 0001 0111 | 0000 0000 | 0000 0000 |'
- en: From the preceding table, we can obtain the network ID, which is `190.23.0.0`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 从上表中，我们可以得到网络ID，即`190.23.0.0`。
- en: The adjacent maximum number has to be applied in a subnet mask. This means that
    if the first zero is decided to be used, the remaining numbers have to be zero.
    So, a subnet mask of `255.0.255.0` is invalid. A subnet mask is also not allowed
    to begin with zero. This means that a subnet mask of `0.255.0.0` is invalid as
    well.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 相邻的最大数字必须应用于子网掩码。这意味着如果决定使用第一个零，剩下的数字必须为零。因此，子网掩码`255.0.255.0`是无效的。子网掩码也不允许以零开头。这意味着子网掩码`0.255.0.0`也是无效的。
- en: 'IPv4 can be classified into three primary address classes: Class A, Class B,
    and Class C. The class of the address is defined by the first number in the IP
    address and the subnet mask is predefined for each class. Here are the three ranges
    for each class:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4可以分为三个主要地址类：A类、B类和C类。地址的类由IP地址中的第一个数字和每个类的预定义子网掩码来定义。以下是每个类的三个范围：
- en: '| Class | The first number | Range of the IP address | Subnet mask |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 第一个数字 | IP地址范围 | 子网掩码 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Class A | 1 to 126 | 1.0.0.0 to 126.255.255.254 | 255.0.0.0 |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| A类 | 1至126 | 1.0.0.0至126.255.255.254 | 255.0.0.0 |'
- en: '| Class B | 128 to 191 | 128.0.0.0 to 191.255.255.254 | 255.255.0.0 |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| B类 | 128至191 | 128.0.0.0至191.255.255.254 | 255.255.0.0 |'
- en: '| Class C | 192 to 223 | 192.0.0.0 to 223.255.255.254 | 255.255.255.0 |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| C类 | 192至223 | 192.0.0.0至223.255.255.254 | 255.255.255.0 |'
- en: 'Our computer is able to determine the class of the IP address by just looking
    at the first two bits after converting the first decimal number in the IP address.
    For instance, in Class A with the range 1 to 126, the binary digit is between
    0000 0001 to 0111 1110\. The first two bits might be 0 and 0 or 0 and 1\. Class
    B with the range from 128 to 191 has the range in binary digits from 1000 0000
    to 1011 1111\. This means that the highest first bit is always 1 and the second
    is always 0\. Class C with the range from 192 to 223 has the range in binary digits
    from 1100 0000 to 1101 1111\. The bits will be all 1 for the first two bits. Refer
    to the following table to conclude how a computer determines the class of an IP
    address by just checking the first two bits of the IP address (here, X is ignored
    and can be any hexadecimal character):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的计算机可以通过转换IP地址中第一个十进制数后的前两位比特来确定IP地址的类。例如，在A类中，范围为1至126，二进制数字在0000 0001至0111
    1110之间。前两位可能是0和0或0和1。B类的范围从128到191，二进制数字范围为1000 0000至1011 1111。这意味着最高的第一位始终为1，第二位始终为0。C类的范围从192到223，二进制数字范围为1100
    0000至1101 1111。前两位将是所有1。请参考以下表格，以了解计算机如何通过检查IP地址的前两位来确定IP地址的类（这里，X被忽略，可以是任何十六进制字符）：
- en: '| Class | First number in binary digits |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 二进制数字中的第一个数字 |'
- en: '| --- | --- |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Class A | 00XXXXXX01XXXXXX |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| A类 | 00XXXXXX01XXXXXX |'
- en: '| Class B | 10XXXXXX |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| B类 | 10XXXXXX |'
- en: '| Class C | 11XXXXXX |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| C类 | 11XXXXXX |'
- en: 'By classifying the IP address, we can also determine the subnet mask by just
    looking at the IP address because each class has a different subnet mask, shown
    as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对IP地址进行分类，我们还可以通过查看IP地址来确定子网掩码，因为每个类都有不同的子网掩码，如下所示：
- en: '| Class | Range | Subnet Mask |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 范围 | 子网掩码 |'
- en: '| --- | --- | --- |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Class A addresses | 0 -126 | 255.0.0.0 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| A类地址 | 0-126 | 255.0.0.0 |'
- en: '| Class B addresses | 128 to 191 | 255.255.0.0 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| B类地址 | 128至191 | 255.255.0.0 |'
- en: '| Class C addresses | 192 to 223 | 255.255.255.0 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| C类地址 | 192至223 | 255.255.255.0 |'
- en: 'By knowing the subnet mask, we can easily know the network ID. Suppose that
    we have these three IP addresses:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过了解子网掩码，我们可以轻松知道网络ID。假设我们有以下三个IP地址：
- en: '`174.12.1.8`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`174.12.1.8`'
- en: '`192.168.1.15`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`192.168.1.15`'
- en: '`10.70.4.13`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10.70.4.13`'
- en: 'Now, we can determine the network ID as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以按以下方式确定网络ID：
- en: '| The IP address | Class | Subnet mask | The Network ID |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| IP地址 | 类 | 子网掩码 | 网络ID |'
- en: '| --- | --- | --- | --- |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 174.12.1.8 | Class B | 255.255.0.0 | 174.12.0.0 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 174.12.1.8 | B类 | 255.255.0.0 | 174.12.0.0 |'
- en: '| 192.168.1.15 | Class C | 255.255.255.0 | 192.168.1.0 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 192.168.1.15 | C类 | 255.255.255.0 | 192.168.1.0 |'
- en: '| 10.70.4.13 | Class A | 255.0.0.0 | 10.0.0.0 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 10.70.4.13 | A类 | 255.0.0.0 | 10.0.0.0 |'
- en: 'A subnet mask is also able to reference with an indicator known as **Classless
    Inter-Domain Routing** (**CIDR**), which is defined based on the number of bits.
    For instance, the subnet mask `255.0.0.0` uses 8 bits (a bit with the value of
    `0` is considered as unused bits), so it is referenced as /8\. Similarly, the
    subnet mask 255.255.0.0 uses 16 bits and can be referenced as /16, and the subnet
    mask 255.255.255.0 uses 24 bits and can be referenced as /24\. These are the CIDR
    notations for our previous IP address sample:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 子网掩码还可以使用一个称为无类别域间路由（CIDR）的指示器来引用，它是根据位数定义的。例如，子网掩码“255.0.0.0”使用8位（值为“0”的位被视为未使用的位），因此被引用为/8。同样，子网掩码255.255.0.0使用16位，可以被引用为/16，子网掩码255.255.255.0使用24位，可以被引用为/24。这些是我们之前IP地址示例的CIDR表示法：
- en: '| IP address | Subnet mask | CIDR notation |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| IP地址 | 子网掩码 | CIDR表示法 |'
- en: '| --- | --- | --- |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 174.12.1.8 | 255.255.0.0 | 174.12.1.8 /16 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 174.12.1.8 | 255.255.0.0 | 174.12.1.8 /16 |'
- en: '| 192.168.1.15 | 255.255.255.0 | 192.168.1.15 /24 |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 192.168.1.15 | 255.255.255.0 | 192.168.1.15 /24 |'
- en: '| 10.70.4.13 | 255.0.0.0 | 10.70.4.13 /8 |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: 10.70.4.13 | 255.0.0.0 | 10.70.4.13 /8
- en: Internet Protocol Version 6 – IPv6
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 互联网协议第6版 - IPv6
- en: IPv6 contains 128 bits and is launched to improve IPv4, which only consists
    32 bits. With 32 bits in IPv4, it can address 4,294,967,296 addresses. The number
    was very high at the beginning, but now it has become insufficient because there
    are many devices that need an IP address. IPv6 is created to solve the problem
    because it can address more than 340,000,000,000,000,000,000,000,000,000,000,000,000,
    or about *3.4028e+38*, which is more than enough—at least for now.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6包含128位，是为了改进IPv4而推出的，IPv4只有32位。在IPv4中，32位可以寻址4,294,967,296个地址。一开始这个数字很高，但现在已经不够用了，因为有很多设备需要IP地址。IPv6被创建来解决这个问题，因为它可以寻址超过340,000,000,000,000,000,000,000,000,000,000,000,000个地址，或约*3.4028e+38*，这已经足够多了——至少目前是这样。
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: IPv5 had been developed so that it consisted of 64 bits, but it was never adopted
    because it was believed that the Internet would run out of IP addresses quickly
    if it was used.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: IPv5曾经被开发为64位，但从未被采用，因为人们认为如果使用IPv5，互联网很快就会用完IP地址。
- en: The prominent difference between the IPv4 address and IPv6 address is that instead
    of displaying the IP address in decimal numbers, IPv6 expresses the address in
    hexadecimal characters. We can determine whether it is IPv4 or IPv6 at first sight
    by just looking at this format number. We can call the `ipconfig /all` command
    to know our IPv6 address and see it in the Ethernet Adapter Network. I have `fe80::f14e:d5e6:aa0a:5855%3`,
    but yours must be different. The address itself is `fe80::f14e:d5e6:aa0a:5855`,
    and the last `%3` variable is a zone index that is used to identify the network
    interface card. The number `fe80` in the first IPv6 address is stated as a link-local
    address, which is an IP address that is automatically assigned on the network
    because it is not automatically configured by DHCP or has not been manually configured
    yet.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4地址和IPv6地址之间的显着区别在于，IPv6不是用十进制数字表示IP地址，而是用十六进制字符表示。我们可以通过一眼就看到的这种格式数字来确定它是IPv4还是IPv6。我们可以调用“ipconfig
    /all”命令来了解我们的IPv6地址，并在以太网适配器网络中查看它。我的是“fe80::f14e:d5e6:aa0a:5855%3”，但你的肯定不一样。地址本身是“fe80::f14e:d5e6:aa0a:5855”，最后的“%3”变量是一个区域索引，用于标识网络接口卡。第一个IPv6地址中的数字“fe80”被称为链路本地地址，这是一个在网络上自动分配的IP地址，因为它没有通过DHCP自动配置，也没有手动配置。
- en: 'As we know, IPv6 is actually a set of 128 bits and converts its bits into a
    hexadecimal character in order to simplify its notation. Consider that we have
    a set of binary digits that form IPv6, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，IPv6实际上是一组128位，并将其位转换为十六进制字符，以简化其表示。考虑到我们有一组二进制数字形成IPv6，如下所示：
- en: '[PRE3]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Instead of memorizing all these digits, it is easier if we convert it into
    the IPv6 address format. First, we convert each four digits group into a hexadecimal
    character and we will get these hexadecimal characters:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 与其记住所有这些数字，不如将其转换为IPv6地址格式。首先，我们将每个四位数字组转换为十六进制字符，我们将得到这些十六进制字符：
- en: '[PRE4]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Second, we separate each set of four characters with a colon, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们用冒号分隔每组四个字符，如下所示：
- en: '[PRE5]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Third, we can throw out the leading zero in each four digit collection, as
    follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，我们可以去掉每个四位数字集合中的前导零，如下所示：
- en: '[PRE6]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Fourth, we collapse the consecutive zero groups into an empty group, shown
    as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 第四，我们将连续的零组合并成一个空组，如下所示：
- en: '[PRE7]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now it is easier for us to memorize this IPv6 address.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们更容易记住这个IPv6地址。
- en: Note
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An empty group, which is indicated by two colons (`::`), means inserting as
    many as zeros as needed to form this address into 128 bits. IPv6 address is not
    allowed to have more than one empty group since it will be confusing for us to
    determine how many zeros there are in each empty group.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一个空组，由两个冒号（::）表示，意味着插入尽可能多的零以形成128位的地址。IPv6地址不允许有多个空组，因为这样会让我们难以确定每个空组中有多少个零。
- en: 'Similarly, with IPv4, which classifies the IP address by looking at the first
    number (the first two bit actually), the type of IPv6 can also be identified by
    looking at its **prefix**. This is how we write all the addresses that have a
    network ID `2001:04fe` that begins with a 32-bit prefix:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于IPv4，它通过查看第一个数字（实际上是前两位）来对IP地址进行分类，IPv6的类型也可以通过查看其前缀来确定。这就是我们如何写入所有具有以32位前缀开头的网络ID“2001:04fe”的地址：
- en: '[PRE8]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This means that the first 32 bits of all addresses are 0010 0000 0000 0001 000
    0100 1111 1110\. However, to ease the reading of this address, we use a hexadecimal
    character instead.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着所有地址的前32位是0010 0000 0000 0001 000 0100 1111 1110。然而，为了方便阅读这个地址，我们使用十六进制字符。
- en: Using TCP/IP tools for troubleshooting
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TCP/IP工具进行故障排除
- en: Some of the following commands can be used to track any TCP/IP errors. The commands
    can be used to examine whether or not any router is down or any connection is
    established. It will then help us a lot to decide on the proper solution.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令可以用来跟踪任何TCP/IP错误。这些命令可以用来检查是否有任何路由器宕机或是否建立了任何连接。然后，它将帮助我们决定适当的解决方案。
- en: The ipconfig command
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ipconfig命令
- en: We used the `ipconfig` command earlier to identify the MAC address and the IP
    address. In addition to this, we can use this command to check the TCP/IP configuration.
    We can also use this command as explained in the upcoming sections.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用`ipconfig`命令来识别MAC地址和IP地址。除此之外，我们还可以使用此命令来检查TCP/IP配置。我们还可以根据即将介绍的部分来使用此命令。
- en: Displaying the full configuration information
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示完整的配置信息
- en: 'To display the configuration information completely, we can call the following
    command on the console:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全显示配置信息，我们可以在控制台上调用以下命令：
- en: '[PRE9]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: All the configuration information about the network adapter will be displayed
    for us, such as the network interface card, wireless card, and Ethernet adapter,
    like we have already tried in *The Data Link layer* section in this chapter when
    we looked for MAC Address.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 关于网络适配器的所有配置信息都将显示给我们，例如网络接口卡、无线网卡和以太网适配器，就像我们在本章的*数据链路层*部分中已经尝试过的那样，当我们寻找MAC地址时。
- en: Displaying DNS
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示DNS
- en: 'The following command will display the content of the DNS Resolver Cache using
    the following option:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将使用以下选项显示DNS解析器缓存的内容：
- en: '[PRE10]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'By calling the preceding command, we will be provided with the information
    about DNS in our local system, as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用上述命令，我们将得到本地系统中DNS的信息，如下所示：
- en: '[PRE11]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The meaning of each field in the output of displaying DNS is as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 显示DNS输出中每个字段的含义如下：
- en: '**Record Name**: This is the name of the DNS that is to be associated with
    the IP address.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记录名称**：这是要与IP地址关联的DNS名称。'
- en: '**Record Type**: This is the type of the record and is represented as a number.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记录类型**：这是记录的类型，表示为一个数字。'
- en: '**Time To Live**: This is the cache expired time in seconds.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生存时间**：这是缓存过期时间，以秒为单位。'
- en: '**Data Length**: This is the size of the memory to store the text of a record
    value in byte.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据长度**：这是以字节为单位存储记录值文本的内存大小。'
- en: '**Section**: If the value is `Answer`, this means that it replies the actual
    query, but if the value is `Additional`, this means that it contains information
    that will be needed to find the actual answer.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部分**：如果值为`Answer`，这意味着它回复了实际查询，但如果值为`Additional`，这意味着它包含了查找实际答案所需的信息。'
- en: '**A (Host) Record**: This is the place where the actual value is stored.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A（主机）记录**：这是实际值存储的位置。'
- en: Flushing DNS
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刷新DNS
- en: 'The following command is used to remove the resolved DNS server item but not
    the item in a cache. Type the following command in the command prompt:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令用于移除已解析的DNS服务器项目，但不会移除缓存中的项目。在命令提示符中输入以下命令：
- en: '[PRE12]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once it successfully flushes the DNS Resolver Cache, we will be showed this
    message in the console:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦成功刷新DNS解析器缓存，我们将在控制台中看到此消息：
- en: '[PRE13]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we call the `ipconfig /displaydns` command again, the resolved DNS server
    has been removed and remaining are the item in the cache.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次调用`ipconfig /displaydns`命令，已解析的DNS服务器已被移除，剩下的是缓存中的项目。
- en: Renewing the IP address
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新IP地址
- en: 'There are two commands that can be used to renew an IP address, which are:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个命令可以用来更新IP地址，它们是：
- en: '[PRE14]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding command will renew the lease process of IPv4 from a DHCP server,
    while the following command will renew the lease process of IPv6:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将从DHCP服务器更新IPv4的租约过程，而以下命令将更新IPv6的租约过程：
- en: '[PRE15]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Releasing the IP address
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 释放IP地址
- en: 'Use the following two commands to release the lease process of IPv4 and IPv6
    respectively, which is obtained from the DHCP server:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下两个命令分别释放从DHCP服务器获取的IPv4和IPv6的租约过程：
- en: '[PRE16]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These commands only affect the DHCP-assigned (automatically assigned) IP address.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令只影响由DHCP分配（自动分配）的IP地址。
- en: The ping command
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ping命令
- en: 'The `ping` command is used to examine the connectivity with other computers.
    It uses **Internet Control Message Protocol** (**ICMP**) to send a message to
    target computers. We can use the IP address and hostname to ping the target. Suppose
    we have a device whose hostname is `HOST1`, to ping itself, we can use the following
    command:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`ping`命令用于检查与其他计算机的连接。它使用**Internet控制消息协议**（**ICMP**）向目标计算机发送消息。我们可以使用IP地址和主机名来ping目标。假设我们有一个名为`HOST1`的设备，要ping自己，我们可以使用以下命令：'
- en: '[PRE17]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we will get the following output in our console window:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将在控制台窗口中得到以下输出：
- en: '[PRE18]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we get the IPv6 address and we want to display it in the IPv4 address instead,
    we can use the `-4` option to force the use of an IPv4 address, as shown in the
    following code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们得到了IPv6地址，而我们想要显示IPv4地址，我们可以使用`-4`选项来强制使用IPv4地址，如下所示：
- en: '[PRE19]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we will get the output, as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将得到以下输出：
- en: '[PRE20]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, what if we are displayed the IPv4 address and we need to get inside
    the IPv6 address instead? We can use the `-6` option to force the use of an IPv6
    address, as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们显示了IPv4地址，而我们需要获取IPv6地址，我们可以使用`-6`选项来强制使用IPv6地址，如下所示：
- en: '[PRE21]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'From the `ping` command, there are two points that occur. First, the computer
    named `HOST1` is resolved to the IP address `10.1.6.165`. If the hostname resolution
    does not work, we will get an error like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 从`ping`命令中，有两个发生的点。首先，名为`HOST1`的计算机解析为IP地址`10.1.6.165`。如果主机名解析不起作用，我们将得到如下错误：
- en: '[PRE22]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Second, this command sends four packets to `HOST1` and receives four packets.
    This reply expresses that the computer named `HOST1` is working properly and is
    able to respond to the command request. If `HOST1` does not work or is disabled
    to respond to the request, we will see an output as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，该命令向`HOST1`发送四个数据包并接收四个数据包。这个回复表示名为`HOST1`的计算机正常工作，并能够响应命令请求。如果`HOST1`不工作或无法响应请求，我们将看到以下输出：
- en: '[PRE23]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There is some error information that we may encounter when we send the `ping`
    command, some of which are as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们发送ping命令时，可能会遇到一些错误信息，其中一些如下：
- en: '**Destination Host Unreachable**: This indicates that there is a problem with
    the routing. This might be because of the misconfiguration of the default gateway
    in the local computer or remote computer.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标主机不可达**：这表示路由存在问题。这可能是因为本地计算机或远程计算机默认网关的错误配置。'
- en: '**TTL Expired in Transit**: This indicates that the ping process has passed
    through the number of routers that is greater than the TTL (Time To Live) value.
    Every time the ping passes through a router, the TTL value will be decremented.
    If the total number of router that a ping has to pass through is more than the
    TTL value, this error message will be displayed.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传输中的TTL已过期**：这表示ping过程已经通过的路由器数量大于TTL（生存时间）值。每次ping通过一个路由器，TTL值都会减少。如果ping必须通过的路由器总数大于TTL值，将显示此错误消息。'
- en: 'Another option that we can use in the ping command is `–t`. With this option,
    instead of sending four packets, the `ping` command will continue to send packets
    until the user stops the same by pressing *Ctrl* + *C*. This is usually used when
    we wait for the disconnect status to turn to the connected status. We can send
    the command to the console, as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在ping命令中，我们可以使用另一个选项`-t`。使用此选项，ping命令将持续发送数据包，直到用户按下*Ctrl* + *C*停止。通常在等待断开状态转为连接状态时使用。我们可以通过以下方式将命令发送到控制台：
- en: '[PRE24]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The tracert command
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: tracert命令
- en: 'When we have more than one router, we can use the `tracert` command to trace
    the path that is taken by the packets. The `tracert` command is similar to the
    `ping` command, except that `tracert` has the information about the router between
    the source device and the destination device. Here is the command that I used
    to trace the communication track from my device to [google.com](http://google.com):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有多个路由器时，可以使用`tracert`命令跟踪数据包的路径。`tracert`命令类似于ping命令，不同之处在于`tracert`包含了源设备和目标设备之间的路由器信息。以下是我用于跟踪从我的设备到[google.com](http://google.com)的通信轨迹的命令：
- en: '[PRE25]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'I got this output in my console window:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我在控制台窗口中得到了这个输出：
- en: '[PRE26]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As you can see, there are 14 rows, and each row represents a **hop** (a circumstance
    in which the `ping` command passes the router). If we divide one row by a column,
    for instance the fourth row, we will get the following table:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有14行，每行代表一个**跳数**（`ping`命令通过路由器的情况）。如果我们将一行除以一列，例如第四行，我们将得到以下表格：
- en: '| Hop # | RTT1 | RTT2 | RTT3 | Name/IP address |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 跳数 | RTT1 | RTT2 | RTT3 | 名称/IP地址 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 4 | 293 ms | 76 ms | 84 ms | 73.171.94.61.in-addr.arpa [61.94.171.73] |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 293毫秒 | 76毫秒 | 84毫秒 | 73.171.94.61.in-addr.arpa [61.94.171.73] |'
- en: 'The explanation of each row is as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 每行的解释如下：
- en: '**The Hop number**: This is the first column and is just the number of hops
    along the route.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跳数**：这是第一列，只是路由路径上的跳数。'
- en: '**RTT columns**: This is the **Round Trip Time** (**RTT**) for our packet to
    reach that destination and return to our computer. The RRT is bifurcated into
    three columns because the `tracecert` command sends three separate signal packets.
    This is to display the consistency, or a lack of it thereof, in the route.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RTT列**：这是数据包到达目的地并返回到我们的计算机的**往返时间**（RTT）。RTT分为三列，因为`tracecert`命令发送三个单独的信号数据包。这是为了显示路由的一致性或不一致性。'
- en: '**The domain/IP column**: This is the IP address of the router. The domain
    name will also be informed if it is available.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**域名/IP列**：这是路由器的IP地址。如果可用，还将提供域名。'
- en: The pathping command
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: pathping命令
- en: The `pathping` command is used to verify the routed path. It examines the route
    of two devices just like the `tracert` command does, and then checks the connectivity
    in each router like the `ping` command does. The `pathping` command sends 100
    request commands to each router and expects to get 100 replies back. For every
    request that is not replied, the `pathping` command will count it as 1 percent
    data loss. So if, for instance, there are ten requests that do not reply back,
    there will be 10 percent data loss. The smaller the percentage of data loss, the
    better connection we have.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`pathping`命令用于验证路由路径。它类似于`tracert`命令，检查两个设备的路由路径，然后像`ping`命令一样检查每个路由器的连接性。`pathping`命令向每个路由器发送100个请求命令，并期望得到100个回复。对于每个未回复的请求，`pathping`命令将计为1％的数据丢失。因此，例如，如果有十个请求没有回复，就会有10％的数据丢失。数据丢失的百分比越小，连接越好。'
- en: 'We will try to send the `pathping` command to [google.com](http://google.com)
    with the help of the following command:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试使用以下命令向[google.com](http://google.com)发送`pathping`命令：
- en: '[PRE27]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'By doing this, we will get the output as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们将得到以下输出：
- en: '[PRE28]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the 10th and 11th rows, we get 100 percent packet loss because 100 of the
    packets sent to the network were lost. However, this is not likely because the
    data does not arrive at the destination router as ICMP is blocked by the routers.
    With this command, we can identify in which specific router we will encounter
    the large percentage of data loss, especially in a large network with many routers
    connected.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在第10和第11行，我们得到了100％的数据包丢失，因为发送到网络的100个数据包丢失了。然而，这不太可能是因为数据未到达目标路由器，而是因为路由器阻止了ICMP。通过这个命令，我们可以确定在哪个具体的路由器上会遇到大量数据丢失，特别是在连接了许多路由器的大型网络中。
- en: 'We can also change the number of requests to be sent to the router using the
    `–q` option. We just need to state the new number of requests after the option,
    as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`-q`选项来更改发送到路由器的请求数量。我们只需要在选项后面说明新的请求数量，如下所示：
- en: '[PRE29]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will send ten requests to the router instead of 100 requests and will be
    faster.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这将发送十个请求到路由器，而不是100个请求，速度会更快。
- en: The netstat command
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: netstat命令
- en: 'The `netstat` (stands for **network statistics**) command is used to view the
    TCP/IP statistics by displaying all the information about the TCP/IP connection
    in the current device. It will show information about connections, ports, and
    applications that are involved in the network. We can use this command by typing
    it in the console window:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`netstat`（代表**网络统计**）命令用于查看TCP/IP统计信息，显示当前设备上关于TCP/IP连接的所有信息。它将显示有关网络中涉及的连接、端口和应用程序的信息。我们可以通过在控制台窗口中输入该命令来使用它：'
- en: '[PRE30]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After this, we will get something as shown in the following output:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将得到以下输出：
- en: '[PRE31]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can see that there are four columns in the `netstat` command''s output.
    The explanation of each column is as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`netstat`命令的输出中有四列。每列的解释如下：
- en: '**Proto**: This displays the name of the protocol, which is TCP or UDP.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Proto**：显示协议的名称，即TCP或UDP。'
- en: '**Local Address**: This displays the IP address of the local computer along
    with the port number being used. If the server is listening on all interfaces,
    the asterisk symbol (`*`) will be shown as the hostname. If the port has not been
    established yet, the port number will be shown as an asterisk as well.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Local Address**：显示本地计算机的IP地址以及正在使用的端口号。如果服务器正在监听所有接口，主机名将显示为星号（`*`）。如果端口尚未建立，端口号也将显示为星号。'
- en: '**Foreign Address**: This displays the IP address and port number of the remote
    computer to which the socket is connected. If the port has not been established
    yet, the port number will be shown as an asterisk (`*`).'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Foreign Address**：显示套接字连接到的远程计算机的IP地址和端口号。如果端口尚未建立，端口号将显示为星号（`*`）。'
- en: '**State**: This indicates the state of a TCP connection. The possible states
    that we will get are as follows:'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**State**：表示TCP连接的状态。我们将得到的可能状态如下：'
- en: '**SYN_SEND**: This indicates active open systems.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SYN_SEND**：表示主动打开系统。'
- en: '**SYN_RECEIVED**: This indicates that the server just received SYN from the
    client.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SYN_RECEIVED**：表示服务器刚刚收到来自客户端的SYN。'
- en: '**ESTABLISHED**: This indicates that the client received the server''s SYN
    and that the session is established.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ESTABLISHED**：表示客户端收到了服务器的SYN，会话已建立。'
- en: '**LISTEN**: This indicates that the server is ready to accept the connection.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LISTEN**：表示服务器准备接受连接。'
- en: '**FIN_WAIT_1**: This indicates active close systems.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FIN_WAIT_1**：表示主动关闭系统。'
- en: '**TIMED_WAIT**: This indicates that the client enters this state after active
    close.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TIMED_WAIT**：表示客户端在主动关闭后进入此状态。'
- en: '**CLOSE_WAIT**: This indicates passive close, which means that the server just
    received its first FIN from a client.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CLOSE_WAIT**：表示被动关闭，即服务器刚刚收到来自客户端的第一个FIN。'
- en: '**FIN_WAIT_2**: This indicates that the client just received an acknowledgment
    of its first FIN from the server.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FIN_WAIT_2**：表示客户端刚刚收到来自服务器的第一个FIN的确认。'
- en: '**LAST_ACK**: This indicates that the server is in this state when it sends
    its own FIN.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LAST_ACK**：表示服务器在发送自己的FIN时处于此状态。'
- en: '**CLOSED**: This indicates that the server received ACK from the client and
    that the connection is now closed.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CLOSED**：表示服务器已收到来自客户端的ACK，连接现在已关闭。'
- en: For more details and information about these states, you can go to [tools.ietf.org/html/rfc793](http://tools.ietf.org/html/rfc793)
    and refer to [Chapter 3](part0025_split_000.html#page "Chapter 3. Introducing
    the Boost C++ Libraries"), *Functional Specification*.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 有关这些状态的更多详细信息，您可以访问[tools.ietf.org/html/rfc793](http://tools.ietf.org/html/rfc793)并参考[第3章](part0025_split_000.html#page
    "第3章。介绍Boost C++库")*功能规范*。
- en: The telnet command
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: telnet命令
- en: The `telnet` (stands for **Terminal Network**) command is used to access remote
    computers over the TCP/IP network. In Windows, there are two Telnet features,
    which are the Telnet Server and Telnet Client. The former is used to configure
    Windows in order to listen for incoming connections and allow others to use it.
    Whereas, the latter is used to connect through Telnet with any server.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`telnet`（代表**终端网络**）命令用于通过TCP/IP网络访问远程计算机。在Windows中，有两个Telnet功能，即Telnet服务器和Telnet客户端。前者用于配置Windows以侦听传入连接并允许其他人使用它。而后者用于通过Telnet与任何服务器连接。'
- en: 'By default, Telnet is not installed on the Windows system because of the security
    risks. It is more secure to keep Telnet disabled since an attacker can check the
    opening port on the system using Telnet. However, no one can stop us from installing
    it in our system. We can by do so by performing these steps:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Telnet在Windows系统上未安装，因为存在安全风险。保持Telnet禁用更安全，因为攻击者可以使用Telnet检查系统上的开放端口。然而，没有人能阻止我们在系统中安装它。我们可以通过执行以下步骤来安装Telnet。
- en: Open the **Run** window by pressing *Windows* + *R*, type `%SYSTEMROOT%\System32\OptionalFeatures.exe`
    in the text box, and then press the **OK** button. The **Windows Features** window
    will open then.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按下*Windows* + *R*打开**运行**窗口，输入`%SYSTEMROOT%\System32\OptionalFeatures.exe`，然后按下**确定**按钮。**Windows功能**窗口将随即打开。
- en: Check **Telnet Client** and **Telnet Server** options, and then press the **OK**
    button to confirm the change. The checked option will look like the following
    screenshot:![The telnet command](img/00014.jpeg)
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选**Telnet客户端**和**Telnet服务器**选项，然后按下**确定**按钮以确认更改。勾选的选项将看起来像下面的截图：![The telnet
    command](img/00014.jpeg)
- en: 'Telnet should be installed by now on our computer. Open the Command Prompt
    window and run the following command to start Telnet:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Telnet现在应该已经安装在我们的计算机上了。打开命令提示窗口，并运行以下命令来启动Telnet：
- en: '[PRE32]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After pressing *Enter*, you will be showed the following output with the blinking
    cursor at the end:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*Enter*键后，您将看到以下输出，并在末尾闪烁的光标：
- en: '[PRE33]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, Telnet is ready to receive our command. To test it, we can run various
    commands in it. The complete list of the commands that are available in telnet
    can be found at [windows.microsoft.com/en-us/windows/telnet-commands](http://windows.microsoft.com/en-us/windows/telnet-commands).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Telnet已准备好接收我们的命令。为了测试它，我们可以在其中运行各种命令。Telnet中可用的命令的完整列表可以在[windows.microsoft.com/en-us/windows/telnet-commands](http://windows.microsoft.com/en-us/windows/telnet-commands)找到。
- en: Summary
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we came to know the main role of each layer in both the OSI
    and TCP/IP models when we talked about network architecture. We explored the Internet
    Protocol and were able to distinguish the difference between IPv4 and IPv6\. We
    were also able to determine the subnet mask and classify the IP address. Moreover,
    we were able to detect whether an error occurs using various TCP/IP tools.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，当我们谈论网络架构时，我们了解了OSI和TCP/IP模型中每个层的主要作用。我们探讨了Internet Protocol，并能够区分IPv4和IPv6之间的区别。我们还能够确定子网掩码并对IP地址进行分类。此外，我们能够使用各种TCP/IP工具检测错误是否发生。
- en: In the next chapter, we are going to talk about the Boost C++ library, which
    is the library that will make us more productive in the C++ programming. Now,
    let's prepare our programming tool and go to the next chapter.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论Boost C++库，这个库将使我们在C++编程中更加高效。现在，让我们准备好我们的编程工具，进入下一章。
