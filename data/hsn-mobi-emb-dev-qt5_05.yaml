- en: Input and Touch
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入和触摸
- en: Not all devices have a readily available keyboard. With a touchscreen device,
    users can easily use buttons and other **User Interface** (**UI**) features. What
    do you do when there is no keyboard or mouse, like on a kiosk or interactive signage?
    Virtual keyboards and touch interaction define mobile and embedded applications
    these days.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有设备都配备了现成的键盘。使用触摸屏设备，用户可以轻松使用按钮和其他 **用户界面** (**UI**) 功能。当没有键盘或鼠标时，例如在展台或交互式标牌上，您该怎么办？虚拟键盘和触摸交互定义了当今的移动和嵌入式应用程序。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: We will discover Qt's graphical solutions to incorporating user input.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将发现 Qt 的图形解决方案来整合用户输入。
- en: The reference Qt Virtual Keyboard will be examined.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将检查参考 Qt 虚拟键盘。
- en: We will demonstrate Touch components, such as `TouchPoints`, `Flickable`, and
    `PinchArea`.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将演示触摸组件，例如 `TouchPoints`、`Flickable` 和 `PinchArea`。
- en: What to do when there's no keyboard
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有键盘时怎么办
- en: Dude, where's my keyboard?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，我的键盘在哪里？
- en: Computer information kiosks and cars do not usually come with keyboard inputs.
    They use virtual inputs, such as a virtual keyboard, voice inputs, or even gesture
    recognition.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机信息亭和汽车通常不配备键盘输入。它们使用虚拟输入，例如虚拟键盘、语音输入，甚至手势识别。
- en: People at the Qt Company have created a virtual input method they named **Qt
    Virtual Keyboard** (**QtVK**). It's more than just an onscreen keyboard, as it
    also has handwriting recognition. It is available under a commercial license as
    well as the open source GPL version 3.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 公司的人创建了一个名为 **Qt 虚拟键盘** (**QtVK**) 的虚拟输入法。它不仅仅是一个屏幕键盘，因为它还具有手写识别功能。它既提供商业许可证，也提供开源的
    GPL 版本 3。
- en: There are other virtual keyboards that will work with Qt apps. On a desktop
    computer that also has a touchscreen, such as a two-in-one laptop, the system
    might already have a virtual keyboard. These should work as an input method for
    Qt apps, although they may or may not automatically pop up when the user wants
    to input into a text area.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他虚拟键盘可以与 Qt 应用程序一起使用。在具有触摸屏的台式计算机上，例如二合一笔记本电脑，系统可能已经内置了虚拟键盘。这些应该作为 Qt 应用的输入方法，尽管它们可能在用户想要在文本区域输入时自动弹出或不弹出。
- en: 'There are two ways to integrate Qt''s Virtual Keyboard:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式集成 Qt 的虚拟键盘：
- en: '| Desktop system | Fully integrated into applications |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 桌面系统 | 完全集成到应用程序中 |'
- en: '| Application | Qt Widget apps: Set environmental `QT_IM_MODULE=qtvirtualkeyboard`
    variableQt Quick: Use `InputPanel` in your application |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 应用程序 | Qt Widget 应用程序：设置环境变量 `QT_IM_MODULE=qtvirtualkeyboard`Qt Quick：在您的应用程序中使用
    `InputPanel` |'
- en: I have a Raspberry Pi setup here for Boot to Qt, which is fully integrated into
    the Qt Creator, so I can build and run Qt apps on the Raspberry Pi from the Qt
    Creator. You can also grab the sources and build it yourself from `git://code.qt.io/qt/qtvirtualkeyboard.git`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里有一个用于 Boot to Qt 的 Raspberry Pi 设置，它完全集成到 Qt Creator 中，因此我可以在 Qt Creator
    中构建和运行 Raspberry Pi 上的 Qt 应用程序。您也可以从 `git://code.qt.io/qt/qtvirtualkeyboard.git`
    获取源代码并自行构建。
- en: 'To build the QtVK, download the following source:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建 QtVK，请下载以下源代码：
- en: '`git clone git://code.qt.io/qt/qtvirtualkeyboard.git`'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`git clone git://code.qt.io/qt/qtvirtualkeyboard.git`'
- en: 'QtVK build can be configured by `qmake`, using `CONFIG+=<configuration>` and
    the following configuration options:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过 `qmake` 配置 QtVK 构建，使用 `CONFIG+=<配置>` 和以下配置选项：
- en: '`lang <code>`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lang <code>`'
- en: '`form of language_country`'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`language_country 的形式`'
- en: Language is lowercase, a two-letter language code
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言为小写，为两个字母的语言代码
- en: Country is uppercase, a two-letter country code
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国家名称为大写，为两个字母的国家代码
- en: '`lang-all`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lang-all`'
- en: '`handwriting`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handwriting`'
- en: Handles custom engines
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理自定义引擎
- en: Arrow-key navigation
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头键导航
- en: For example, to configure only Australian-English and add handwriting support,
    you would run `qmake CONFIG+=lang-en_AU CONFIG+=handwriting` and then `make &&
    make install`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要仅配置澳大利亚英语并添加手写支持，您将运行 `qmake CONFIG+=lang-en_AU CONFIG+=handwriting` 然后执行
    `make && make install`。
- en: There are many other configurations available. You can disable layouts for creating
    a custom layout and desktop integration, among other configurations.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他配置可用。您可以通过禁用布局来创建自定义布局和桌面集成，以及其他配置。
- en: 'QtVK can be used in C++ or QML. Let''s start by using Qt Quick by ticking the
    Use Qt Virtual Keyboard in the Qt Creator project wizard when creating a new Qt
    Quick Application from a template:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: QtVK 可以在 C++ 或 QML 中使用。让我们从使用 Qt Quick 开始，在创建新的 Qt Quick 应用程序模板时，在 Qt Creator
    项目向导中勾选“使用 Qt 虚拟键盘”：
- en: '![](img/3a8ba860-c0ee-4071-a651-76cb98a33e95.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3a8ba860-c0ee-4071-a651-76cb98a33e95.png)'
- en: 'This is the boiler plate code you get when you use Boot to Qt for Device Creation:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当你使用Boot to Qt for Device Creation时得到的样板代码：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The source code can be found on the Git repository under the `Chapter04-1` directory,
    in the `cp4` branch.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在Git仓库的`Chapter04-1`目录下的`cp4`分支中找到。
- en: 'Let''s add something that takes text as input, such as a `TextField` element:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一些接受文本输入的东西，比如一个`TextField`元素：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `anchors` here are used to resize this `TextField` element when QtVK is
    opened automatically when the user taps on `TextField`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`anchors`用于在用户点击`TextField`时自动打开QtVK时调整此`TextField`元素的大小。
- en: 'Here is what this should look like:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该是这样的：
- en: '![](img/8ace3bbe-11dc-4241-8646-63059ba98f12.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ace3bbe-11dc-4241-8646-63059ba98f12.png)'
- en: Implementing a touch screen can have many benefits, which we can do by using
    the Qt event loop. Let's look in detail at using touch screens as an input.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 实现触摸屏可以带来许多好处，我们可以通过使用Qt事件循环来实现。让我们详细看看如何使用触摸屏作为输入。
- en: Using touch input
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用触摸输入
- en: Touch screens are ubiquitous these days. They are everywhere. While essential
    in a mobile phone or tablet, you can also get a laptop or desktop computer with
    one. Refrigerators and cars also commonly have touchscreens. Knowing how to utilize
    these in your Qt app is also essential.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 触摸屏如今无处不在。它们无处不在。虽然在手机或平板电脑中是必不可少的，但你也可以得到带有触摸屏的笔记本电脑或台式电脑。冰箱和汽车也通常配备触摸屏。知道如何在Qt应用程序中利用这些也是必不可少的。
- en: On mobile phone and tablet platforms, touchscreen support comes from the system
    and is often built-in. If you are creating your own embedded device, you will
    most likely need to tell Qt how to use the touchscreen. Qt has support for various
    touchscreen systems on embedded devices.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动手机和平板电脑平台上，触摸屏支持来自系统，通常是内置的。如果你正在创建自己的嵌入式设备，你很可能需要告诉Qt如何使用触摸屏。Qt支持嵌入式设备上的各种触摸屏系统。
- en: QEvent
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QEvent
- en: '`QEvent` is the way to get access to the touch input events in C++. It comes
    through an event filter you can add to your application. There are a few different
    ways to access this data.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`QEvent`是获取C++中触摸输入事件的方式。它通过你可以添加到应用程序的事件过滤器来实现。有几种不同的方式来访问这些数据。'
- en: We can use an event filter or an event loop. We will start by looking at an
    event filter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用事件过滤器或事件循环。我们将首先查看事件过滤器。
- en: Event filter
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件过滤器
- en: 'One way you can access the event loop is by using an event filter. You first
    need to call the following function:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用事件过滤器来访问事件循环。首先需要调用以下函数：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The source code can be found on the Git repository under the `Chapter04-2` directory
    in the `cp4` branch.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在Git仓库的`Chapter04-2`目录下的`cp4`分支中找到。
- en: 'You then need to override the function named `eventFilter(QObject* obj, QEvent*
    event)`, which returns a `bool `value:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你需要重写名为`eventFilter(QObject* obj, QEvent* event)`的函数，它返回一个`bool`值：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You will then receive any and all events. You can also handle these touch events
    by using the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你将接收到任何和所有的事件。你也可以通过以下方式处理这些触摸事件：
- en: '`QEvent::TouchBegin`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QEvent::TouchBegin`'
- en: '`QEvent::TouchCancel`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QEvent::TouchCancel`'
- en: '`QEvent::TouchEnd`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QEvent::TouchEnd`'
- en: '`QEvent::TouchUpdate`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QEvent::TouchUpdate`'
- en: 'Using a `switch` statement in a `eventFilter` is an effective way to go through
    different options:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在`eventFilter`中使用`switch`语句是遍历不同选项的有效方式：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Be sure to pass these events on to the parent class unless you need to intercept
    them. To not pass these on, return `true`. Using an event loop is another way
    to access events. Let's take a look.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你需要拦截它们，否则请确保将这些事件传递给父类。要阻止传递，请返回`true`。使用事件循环是访问事件的另一种方式。让我们看看。
- en: Event loop
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件循环
- en: 'To use the event loop, you need to override `event(QEvent *ev)`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用事件循环，你需要重写`event(QEvent *ev)`：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You also need to add `setAttribute(Qt::WA_AcceptTouchEvents, true);` to the
    class constructor, otherwise your application will not receive touch events.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要在类构造函数中添加`setAttribute(Qt::WA_AcceptTouchEvents, true);`，否则你的应用程序将不会接收到触摸事件。
- en: Let's take a look at how touchscreen support is handled in Qt and how you can
    use Qt to access a lower level of the touchscreen input stack.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Qt如何处理触摸屏支持以及如何使用Qt访问触摸屏输入堆栈的更低级别。
- en: Touchscreen support
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触摸屏支持
- en: Touchscreen support for Qt is done through the **Qt Platform Abstraction** (**QPA)** platform
    plugins.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Qt对触摸屏的支持是通过**Qt平台抽象**（**QPA**）平台插件实现的。
- en: Qt configure will auto-detect the correct platform and determine whether or
    not the development files are installed. If it finds the development files, it
    will use them.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Qt配置将自动检测正确的平台并确定是否已安装开发文件。如果找到开发文件，它将使用它们。
- en: Let's see how touchscreens work for various operating systems, starting out
    with mobile phones.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看各种操作系统中的触摸屏是如何工作的，从移动电话开始。
- en: Windows, iOS and Android
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows、iOS 和 Android
- en: On Windows, iOS and Android, touchscreens are supported through the Qt Event
    system.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows、iOS 和 Android 上，触摸屏通过 Qt 事件系统得到支持。
- en: Using the Qt event system and allowing the platform plugins to do the scanning
    and reading, we can use `QEvent` if we need access to those events.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Qt 事件系统并允许平台插件进行扫描和读取，如果我们需要访问这些事件，我们可以使用 `QEvent`。
- en: Let's look at how we can access a low level of the input system using Qt on
    embedded Linux.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 Qt 在嵌入式 Linux 上访问输入系统的底层。
- en: Linux
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux
- en: On the Linux operating system there are a variety of input systems that can
    be used with Qt.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 操作系统中，有各种可以使用 Qt 的输入系统。
- en: 'Qt has built-in support for these types of touchscreen interfaces:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 内置了对这些类型的触摸屏接口的支持：
- en: '`evdev`: an event device interface'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`evdev`: 一个事件设备接口'
- en: '`libinput`: a library to handle input devices'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libinput`: 一个用于处理输入设备的库'
- en: '`tslib`: a typescript runtime library'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tslib`: 一个 TypeScript 运行时库'
- en: We will start by learning about the Linux `evdev` system to read the device
    files directly.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先学习关于 Linux `evdev` 系统的知识，以便直接读取设备文件。
- en: evdev
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: evdev
- en: Qt has built-in support for the `evdev` standard event-handling system for Linux
    and embedded Linux . This is what you will get by default if no other system is
    configured or detected. It handles keyboard, mouse, and touch. You can then use
    Qt as normal with respect to keyboard, touch, and mouse events.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 内置了对 Linux 和嵌入式 Linux 的 `evdev` 标准事件处理系统的支持。如果没有配置或检测到其他系统，您将默认获得这个系统。它处理键盘、鼠标和触摸。然后您可以使用
    Qt 正常处理键盘、触摸和鼠标事件。
- en: 'You can assign startup parameters, such as device file path and default rotation
    of the screen, like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以分配启动参数，例如设备文件路径和屏幕默认旋转，如下所示：
- en: '`QT_QPA_EVDEV_TOUCHSCREEN_PARAMETERS=/dev/input/input2:rotate=90`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`QT_QPA_EVDEV_TOUCHSCREEN_PARAMETERS=/dev/input/input2:rotate=90`'
- en: Other parameters available are `invertx` and `inverty`. Of course, you do not
    need to reply on Qt for these input events, and can access them directly in the
    stack below Qt. I call them raw events, but they are really just reading the special
    Linux kernel device files.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的其他参数包括 `invertx` 和 `inverty`。当然，您不需要依赖于 Qt 来处理这些输入事件，可以直接在 Qt 以下的堆栈中访问它们。我称它们为原始事件，但实际上它们只是读取特殊的
    Linux 内核设备文件。
- en: Let's take a look at handling these `evdev` input events yourself while using
    Qt. This is low-level system file access, so you might need root or administrator
    permissions to run the applications that use it this way.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在使用 Qt 时如何自己处理这些 `evdev` 输入事件。这是低级系统文件访问，因此您可能需要 root 或管理员权限来运行使用这种方式的应用程序。
- en: Input events on Linux are accessed through the kernel's `dev` nodes, typically
    found at `/dev/input`, but they could be anywhere under the `/dev` directory tree,
    depending on the driver. `QFile` should not be used for actually reading from
    these special device node files.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，可以通过内核的 `dev` 节点访问输入事件，通常位于 `/dev/input`，但它们可能位于 `/dev` 目录树下的任何位置，具体取决于驱动程序。`QFile`
    不应用于实际读取这些特殊的设备节点文件。
- en: '`QFile` is not suited for reading Unix device node files. This is because `QFile`
    has no signals and the device node files report a size of zero and only have data
    when you read them.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`QFile` 不适合读取 Unix 设备节点文件。这是因为 `QFile` 没有信号，而设备节点文件报告的大小为零，并且只有当您读取它们时才有数据。'
- en: 'The main `include` file to read input nodes is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 读取输入节点的主体 `include` 文件如下：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The source code can be found on the Git repository under the `Chapter04-3` directory
    in the `cp4` branch.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在 Git 仓库的 `cp4` 分支下的 `Chapter04-3` 目录中找到。
- en: You will want to scan the device files to detect which file the touchscreen
    produces. In Linux, these device nodes are named dynamically, so you need to use
    some other method to discern the correct file other than just the filename. So,
    you have to open the file and ask it to tell you its name.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您将想要扫描设备文件以检测触摸屏产生的哪个文件。在 Linux 中，这些设备节点是动态命名的，因此您需要使用其他方法来识别正确的文件，而不仅仅是文件名。因此，您必须打开文件并要求它告诉您其名称。
- en: 'We can use `QDir` and its filters to at least filter out some of the files
    we know are not what we are looking for:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `QDir` 和其过滤器至少过滤掉一些我们知道不是我们想要的文件：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Be sure to include the `O_NONBLOCK` argument for `open`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `open` 时务必包含 `O_NONBLOCK` 参数。
- en: 'At this point, we have a list of the names for the different input devices.
    You might have to just guess which name to use and then do a `String` compare
    to find the correct device. Sometimes, the driver will have correct `id` information,
    which can be obtained using `EVIOCGID` like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有了一个不同输入设备名称的列表。你可能只需要猜测使用哪个名称，然后进行 `String` 比较，以找到正确的设备。有时，驱动程序将具有正确的
    `id` 信息，可以使用 `EVIOCGID` 获取，如下所示：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Sometimes, you can detect certain features using `EVIOCGBIT`. This will tell
    us which buttons or keys the hardware driver supports. The touchscreen driver
    outputs a keycode of `0x14a (BTN_TOUCH)` when you touch it, so we can use this
    to detect which input event will be our touchscreen:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可以使用 `EVIOCGBIT` 检测某些功能。这将告诉我们硬件驱动程序支持哪些按钮或键。当触摸触摸屏时，触摸屏驱动程序输出键码 `0x14a
    (BTN_TOUCH)`，因此我们可以使用这个来检测哪个输入事件将是我们的触摸屏：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can now be fairly certain that we have the proper device file. Now, we can
    set up a `QSocketNotifier` object to notify us when that file is activated, and
    then we can read it to get the `X` and `Y` values of the touch. We use the `QSocketNotifier` class
    because we cannot use `QFile`, as it doesn''t have any signals to tell us when
    the Linux device files get changed, so this makes it much easier:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以相当确信我们已经有了正确的设备文件。现在，我们可以设置一个 `QSocketNotifier` 对象来通知我们该文件何时被激活，然后我们可以读取它以获取触摸的
    `X` 和 `Y` 值。我们使用 `QSocketNotifier` 类，因为我们不能使用 `QFile`，因为它没有任何信号来告诉我们 Linux 设备文件何时更改，这使得它更容易：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We also use the standard `read()` function instead of `QFile` to read this.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也使用标准的 `read()` 函数而不是 `QFile` 来读取这个。
- en: The `BTN_TOUCH` event value tells us when the touchscreen was pressed or released.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`BTN_TOUCH` 事件值告诉我们触摸屏何时被按下或释放。'
- en: The `ABS_MT_POSITION_X` value will be the touchscreen's `X` position, and the `ABS_MT_POSITION_Y`
    value will be the `Y` position.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`ABS_MT_POSITION_X` 值将是触摸屏的 `X` 位置，而 `ABS_MT_POSITION_Y` 值将是 `Y` 位置。'
- en: There is a library that can be used to do the very same thing, which might be
    a little easier.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个库可以用来做同样的事情，可能稍微容易一些。
- en: libevdev
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: libevdev
- en: When you use the library `libevdev`, you won't have to access such low level
    filesystem functions like a `QSocketNotifier` and read files yourself.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用库 `libevdev` 时，你不需要访问像 `QSocketNotifier` 这样的低级文件系统函数，也不需要自己读取文件。
- en: To use `libevdev`, we start by adding to the `LIBS` entry in our projects `.pro`
    file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `libevdev`，我们首先在我们的项目 `.pro` 文件中添加到 `LIBS` 条目。
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The source code can be found on the Git repository under the `Chapter04-4` directory
    in the `cp4` branch.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在 Git 仓库的 `cp4` 分支下的 `Chapter04-4` 目录中找到。
- en: 'This allows `qmake` to set up proper linker arguments. The `include` header
    would be as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许 `qmake` 设置正确的链接器参数。`include` 头文件如下所示：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can borrow the initial code to scan the directory for device files from
    the preceding code, but the `isTouchDevice` function gets cleaner code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从前面的代码中借用扫描目录以查找设备文件的初始代码，但 `isTouchDevice` 函数的代码会更简洁：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`Libevdev` has the nice `libevdev_has_event_code` function that can be used
    to easily detect whether or not the device has a certain event code. This is just
    what we needed to identify the touchscreen! Notice the `libevdev_free` function,
    which will free the memory being used that we do not need.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Libevdev` 有一个很好的 `libevdev_has_event_code` 函数，可以用来轻松检测设备是否具有某个事件代码。这正是我们需要用来识别触摸屏的！注意
    `libevdev_free` 函数，它将释放我们不需要使用的内存。'
- en: 'The `doScan` function loses the call to read, but substitutes a call to `libevdev_next_event`
    instead. It can also output a nice message with the actual name of the event code
    by calling `libevdev_event_code_get_name`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`doScan` 函数去掉了读取的调用，而是用 `libevdev_next_event` 的调用代替。它还可以通过调用 `libevdev_event_code_get_name`
    输出有关实际事件代码的漂亮消息：'
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The library `libinput` also uses `evdev`, and is a bit more up to date than
    the others.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 库 `libinput` 也使用 `evdev`，并且比其他库更新一些。
- en: libinput
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: libinput
- en: 'The `libinput` library is the input handling for Wayland compositors and X.Org
    window system. Wayland is a display server protocol a bit like a newer version
    of the ancient Unix standard X11\. `Libinput` depends on `libudev` and supports
    the following input types:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`libinput` 库是 Wayland 合成器和 X.Org 窗口系统的输入处理。Wayland 是一种显示服务器协议，类似于古老 Unix 标准的
    X11 的新版本。`Libinput` 依赖于 `libudev` 并支持以下输入类型：'
- en: '`Keyboard`: Standard hardware keyboard'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Keyboard`: 标准硬件键盘'
- en: '`Gesture`: Touch gestures'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Gesture`: 触摸手势'
- en: '`Pointer`: Mouse events'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pointer`: 鼠标事件'
- en: '`Touch`: Touchscreen events'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Touch`: 触摸屏事件'
- en: '`Switch`: Laptop lid switch events'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Switch`: 笔记本电脑盖子开关事件'
- en: '`Tablet`: Tablet tool events'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tablet`: 平板工具事件'
- en: '`Tablet pad:` Tablet pad events'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tablet pad:` 平板垫事件'
- en: The `libinput` library has a build-time dependency upon `libudev ` ; therefore, to
    configure Qt, you will need `libudev` as well as the `libinput` development files
    or packages installed. If you need hardware keyboard support, the `xcbcommon`
    package is also needed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`libinput` 库在构建时依赖于 `libudev`；因此，为了配置 Qt，你需要安装 `libudev` 以及 `libinput` 的开发文件或包。如果你需要硬件键盘支持，还需要安装
    `xcbcommon` 包。'
- en: Yet another touch library is `tslib`, which is specifically used in embedded
    devices, as it has a small filesystem footprint and minimal dependencies.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个触摸屏库是 `tslib`，它专门用于嵌入式设备，因为它具有小的文件系统占用和最小的依赖。
- en: Tslib
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tslib
- en: '`Tslib` is a library used to access and filter touchscreen events on Linux
    devices; it supports multi-touch and Qt has support for using it. You will need
    to have the `tslib` development files installed. Qt will auto-detect this, or
    you can explicitly configure Qt with the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tslib` 是一个用于访问和过滤 Linux 设备上触摸屏事件的库；它支持多点触控，Qt 也支持使用它。你需要安装 `tslib` 的开发文件。Qt
    会自动检测这一点，或者你可以使用以下方式显式配置 Qt：'
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It can then be enabled by setting `QT_QPA_EGLFS_TSLIB` or `QT_QPA FB_TSLIB` to
    `1`. You can change the actual device file path by setting the environmental variable
    called `TSLIB_TSDEVICE` to the path of the device node like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将环境变量 `QT_QPA_EGLFS_TSLIB` 或 `QT_QPA_FB_TSLIB` 设置为 `1` 来启用它。你可以通过将环境变量 `TSLIB_TSDEVICE`
    设置为设备节点路径来更改实际的设备文件路径，如下所示：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let's now move on to see how we can use higher level APIs in Qt to utilize the
    touchscreen.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来探讨如何使用 Qt 的高级 API 来利用触摸屏。
- en: Using the touchscreen
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用触摸屏
- en: There are two ways the Qt backend uses the touchscreen. The events come in as a
    mouse using a point with `click` and `drag` events, or as multi-point touch-to-handle
    gestures, such as `pinch` and `swipe`. Let's get a better understanding about multi-point
    touch.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 后端使用触摸屏有两种方式。事件以鼠标的形式传入，使用 `click` 和 `drag` 事件，或者作为多点触摸到处理的手势，例如 `pinch`
    和 `swipe`。让我们更好地了解多点触摸。
- en: MultiPointTouchArea
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MultiPointTouchArea
- en: As I have mentioned earlier, to use multi-point touchscreens in QML, there is
    the `MultiPointTouchArea` type. If you want to use gestures in QML, you either
    have to use`MultiPointTouchArea` and do it yourself, or use `QGesture` in your
    C++ and handle custom signals in your QML components.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所述，要在 QML 中使用多点触摸屏，有 `MultiPointTouchArea` 类型。如果你想在 QML 中使用手势，你或者必须使用 `MultiPointTouchArea`
    并自己处理，或者在你的 C++ 中使用 `QGesture` 并在 QML 组件中处理自定义信号。
- en: The source code can be found on the Git repository under the `/Chapter04-5`
    directory in the cp4 branch.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在 Git 仓库的 cp4 分支下的 `/Chapter04-5` 目录中找到。
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You declare the `touchPoints` property of `MultiPointTouchArea` with a `TouchPoint` element
    for each finger you want to deal with. Here, we are using five-finger points.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用 `TouchPoint` 元素声明 `MultiPointTouchArea` 的 `touchPoints` 属性，为每个你想要处理的手指声明一个元素。在这里，我们使用五指点。
- en: 'You can use the `x` and `y` properties to move things around:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `x` 和 `y` 属性来移动对象：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can also use touchscreen gestures in your app.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在你的应用程序中使用触摸屏手势。
- en: Qt Gestures
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt 手势
- en: 'Gestures are a great way of utilizing user input. As I mentioned gestures in [Chapter
    2](ab2105ed-232b-4c99-8fd8-4ca295f6f5f9.xhtml), *Fluid UI with Qt Quick*, I will
    mention the C++ API here, which is much more feature-rich than gestures in QML.
    Keep in mind that these are touchscreen gestures and not device or sensor gestures,
    which I will examine in a later chapter. `QGesture` supports the following built-in
    gestures:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 手势是利用用户输入的绝佳方式。正如我在 [第 2 章](ab2105ed-232b-4c99-8fd8-4ca295f6f5f9.xhtml) 中提到的，*使用
    Qt Quick 的流畅 UI*，我将在下面提到 C++ API，它比 QML 中的手势功能更丰富。请记住，这些是触摸屏手势，而不是设备或传感器手势，这些我将在后面的章节中探讨。`QGesture`
    支持以下内置手势：
- en: '`QPanGesture`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QPanGesture`'
- en: '`QPinchGesture`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QPinchGesture`'
- en: '`QSwipeGesture`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QSwipeGesture`'
- en: '`QTapGesture`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QTapGesture`'
- en: '`QTapAndHoldGesture`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QTapAndHoldGesture`'
- en: QGesture is an event-based API, so it will come through the event filter, which
    means you need to re-implement your `event(QEvent *event)` widgets as the gesture
    will target your widget. It also supports custom gestures by subclassing `QGestureRecognizer`
    and re-implementing `recognize`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: QGesture 是一个基于事件的 API，所以它将通过事件过滤器传递，这意味着你需要重新实现你的 `event(QEvent *event)` 小部件，因为手势将针对你的小部件。它还支持通过子类化
    `QGestureRecognizer` 并重新实现 `recognize` 来自定义手势。
- en: 'To use gestures in your app, you need to first tell Qt that you want to receive
    touch events. If you are using built-in gestures, this is done internally by Qt,
    but if you have custom gestures, you need to do this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的应用中使用手势，你首先需要告诉 Qt 你想要接收触摸事件。如果你使用的是内置手势，这是由 Qt 内部完成的，但如果你有自定义手势，你需要这样做：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To accept touch events, you then need to call `QGraphicsItem::setAcceptTouchEvent(bool)` with
    `true` as the argument.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了接受触摸事件，你需要调用 `QGraphicsItem::setAcceptTouchEvent(bool)` 并将参数设置为 `true`。
- en: If you want to use unhandled mouse events for touch events, you can also set
    the `Qt::WA_SynthesizeTouchEventsForUnhandledMouseEvents` attribute.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用未处理的鼠标事件作为触摸事件，你也可以设置 `Qt::WA_SynthesizeTouchEventsForUnhandledMouseEvents`
    属性。
- en: 'You then need to define to Qt that you want to use certain gestures by calling
    the `grabGesture` function of your `QWidget` or `QGraphicsObject`class:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要通过调用你的 `QWidget` 或 `QGraphicsObject` 类的 `grabGesture` 函数来告诉 Qt 你想要使用某些手势：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`QGesture` events are delivered to a specific `QWidget` class and not the current
    `QWidget` class that holds the focus like a mouse event would.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`QGesture` 事件被发送到特定的 `QWidget` 类，而不是像鼠标事件那样发送到当前拥有焦点的 `QWidget` 类。'
- en: 'In your `QWidget` derived class, you need to re-implement the `event` function
    and then handle the `gesture` event when it happens:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `QWidget` 派生类中，你需要重新实现 `event` 函数，并在发生手势事件时处理 `gesture` 事件：
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Since we are handling only one `QGesture` type, we know it is our target gesture.
    You can check whether or not this event is caused by a certain gesture by checking
    for its `pointer` using the `gesture` function that is defined as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只处理一种 `QGesture` 类型，我们知道这是我们目标的手势。你可以通过检查其 `pointer` 来确定这个事件是否由某种手势引起，该
    `pointer` 是通过以下定义的 `gesture` 函数来检查的：
- en: '`QGesture * QGestureEvent::gesture(Qt::GestureType type) const`'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`QGesture * QGestureEvent::gesture(Qt::GestureType type) const`'
- en: 'This can be implemented by the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过以下方式实现：
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If the `QGesture` object called `swipe` is `nullptr`, then this event is not
    our target gesture.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用 `swipe` 的 `QGesture` 对象是 `nullptr`，那么这个事件不是我们的目标手势。
- en: 'It is also a good idea to check on the gesture''s `state()`, which can be one
    of the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 还是一个好主意去检查手势的 `state()`，它可以是指以下任何一个：
- en: '`Qt::NoGesture`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qt::NoGesture`'
- en: '`Qt::GestureStarted`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qt::GestureStarted`'
- en: '`Qt::GestureUpdated`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qt::GestureUpdated`'
- en: '`Qt::GestureFinished`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qt::GestureFinished`'
- en: '`Qt::GestureCanceled`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qt::GestureCanceled`'
- en: 'You can create your own gesture using `QGestureRecognizer` by sub-classing
    `QGestureRecognizer` and re-implementing `recognize()`. This is where most of
    the work will be, as you will need to detect your gesture and are more likely
    detect what is not your gesture. Your `recognize()` function will need to return
    one of the values of the `enum` value, `QGestureRecognizer::Result`, which can
    be any of the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `QGestureRecognizer` 通过派生 `QGestureRecognizer` 并重新实现 `recognize()` 来创建自己的手势。大部分的工作将在这里进行，因为你需要检测你的手势，更有可能检测到不是你的手势。你的
    `recognize()` 函数需要返回 `enum` 值 `QGestureRecognizer::Result` 中的一个，它可以是指以下任何一个：
- en: '`QGestureRecognizer::Ignore`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QGestureRecognizer::Ignore`'
- en: '`QGestureRecognizer::MayBeGesture`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QGestureRecognizer::MayBeGesture`'
- en: '`QGestureRecognizer::TriggerGesture`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QGestureRecognizer::TriggerGesture`'
- en: '`QGestureRecognizer::FinishGesture`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QGestureRecognizer::FinishGesture`'
- en: '`QGestureRecognizer::CancelGesture`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QGestureRecognizer::CancelGesture`'
- en: '`QGestureRecognizer::ConsumeEventHint`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QGestureRecognizer::ConsumeEventHint`'
- en: There are heaps of edge cases you need to handle here to discern exactly what
    is and what is not your gesture. Do not be afraid if this function is complicated
    or long.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你需要处理大量的边缘情况，以准确判断哪些是你的手势，哪些不是。如果这个函数复杂或长，不要害怕。
- en: Another form of input that is becoming more popular is using your voice. Let's
    look at that next.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种越来越受欢迎的输入形式是使用你的声音。让我们接下来看看这个。
- en: Voice as input
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语音作为输入
- en: Voice recognition and Qt has been around for a while now. IBM's ViaVoice was
    ported to KDE and was being ported to Trolltech's phone software suite Qtopia
    at the time that I became the Qtopia Community Liaison in 2003\. Consequently,
    it was worked on by the same developer who later dreamed-up what became Qt Quick.
    While the concept has essentially stayed the same, the technology has gotten better,
    and now you can find voice control in many different devices, including automobiles.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 语音识别和 Qt 已经存在了一段时间。在 2003 年我成为 Qtopia 社区联络员的时候，IBM 的 ViaVoice 被移植到了 KDE，并且正在被移植到
    Trolltech 的手机软件套件 Qtopia。因此，它是同一个开发者后来梦想成真成为 Qt Quick 的东西。虽然概念本质上保持不变，但技术已经得到了改进，现在你可以在许多不同的设备中找到语音控制，包括汽车。
- en: There are many competing systems, such as Alexa, Google Voice, Cortana, and
    Siri, as well as some open source APIs. Combined with voice search, voice input
    is an invaluable tool.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多竞争系统，例如 Alexa、Google Voice、Cortana 和 Siri，以及一些开源 API。结合语音搜索，语音输入是一种无价工具。
- en: At the time of writing, Qt Company and one of its partners, **Integrated Computer
    Solutions** (**ICS**), have announced that they are working together on integrating
    the Amazon Alexa system with Qt. I have been told that it will be called `QtAlexaAuto`
    and be released under the lgpl v3 license. Since this has not been released at
    the time of writing, I cannot go into very much detail about how to use this implementation
    just yet. I am sure that, if or when it gets released, the API will be quite easy
    to use.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Qt 公司及其合作伙伴之一 **Integrated Computer Solutions**（**ICS**）已宣布他们正在合作将亚马逊的
    Alexa 系统集成到 Qt 中。我被告知这将被称为 `QtAlexaAuto` 并在 lgpl v3 许可下发布。由于在撰写本文时尚未发布，我无法详细介绍如何使用此实现。我相信，如果或当它发布时，API
    将非常易于使用。
- en: Amazon's **Alexa Voice Service** (**AVS**) **Software Development Kit** (**SDK**)
    works on Windows, Linux, Android and MacOS. You can even use a mic array component,
    such as the MATRIX creator with the Raspberry Pi.  Siri works on iOS and MacOS.
    Cortana works on Windows.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊的 **Alexa Voice Service**（**AVS**）**软件开发工具包**（**SDK**）支持 Windows、Linux、Android
    和 MacOS。您甚至可以使用麦克风阵列组件，例如与 Raspberry Pi 配合使用的 MATRIX creator。 Siri 在 iOS 和 MacOS
    上运行。Cortana 在 Windows 上运行。
- en: While none of these voice systems are integrated into Qt, they can be used with
    a custom integration. It is worth looking into them, depending on what your application
    will be doing and what device it will run on.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些语音系统都没有集成到 Qt 中，但它们可以通过自定义集成来使用。根据您的应用程序将执行的操作和它将在哪种设备上运行，值得对其进行研究。
- en: 'Alexa, Google Assistant, and Cortana have C++ APIs, and Siri can be used as
    well with its Objective-C API:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Alexa、Google Assistant 和 Cortana 提供了 C++ API，Siri 也可以使用其 Objective-C API：
- en: Alexa: [https://github.com/alexa/avs-device-sdk.git](https://github.com/alexa/avs-device-sdk.git)
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alexa: [https://github.com/alexa/avs-device-sdk.git](https://github.com/alexa/avs-device-sdk.git)
- en: Google Assistant: [https://developers.google.com/assistant/sdk/guides/library/python/embed/install-sample](https://developers.google.com/assistant/sdk/guides/library/python/embed/install-sample)
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Assistant: [https://developers.google.com/assistant/sdk/guides/library/python/embed/install-sample](https://developers.google.com/assistant/sdk/guides/library/python/embed/install-sample)
- en: 'Cortana: [https://developer.microsoft.com/en-us/cortana](https://developer.microsoft.com/en-us/cortana)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Cortana: [https://developer.microsoft.com/en-us/cortana](https://developer.microsoft.com/en-us/cortana)'
- en: 'Siri: [https://developer.apple.com/sirikit/](https://developer.apple.com/sirikit/)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Siri: [https://developer.apple.com/sirikit/](https://developer.apple.com/sirikit/)'
- en: QtAlexaAuto
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QtAlexaAuto
- en: QtAlexaAuto is a module created by Integrated Computer Solutions (ICS) and the
    Qt Company to enable the use of Amazon's Alexa Voice Service (AVS) from within
    Qt and QtQuick applications. You can use Raspberry Pi, Linux, Android, or other
    machines to prototype an application that uses voice as input.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: QtAlexaAuto 是由 Integrated Computer Solutions（ICS）和 Qt 公司共同创建的一个模块，用于在 Qt 和 QtQuick
    应用程序中启用亚马逊的 Alexa Voice Service（AVS）的使用。您可以使用 Raspberry Pi、Linux、Android 或其他机器来原型化一个使用语音作为输入的应用程序。
- en: At the time of writing this book, QtAlexaAuto is yet to be released, so you
    will need to search the internet for the url to download the source code. Some
    things may have changed in the official release from what it written in this book.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，QtAlexaAuto 尚未发布，因此您需要在网上搜索下载源代码的 URL。官方发布的内容可能与本书中所述的内容有所不同。
- en: 'You will need to download, build and install the following SDKs from Amazon:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要从亚马逊下载、构建和安装以下 SDK：
- en: 'AVS Device SDK: git clone -b v1.9 [https://github.com/alexa/avs-device-sdk](https://github.com/alexa/avs-device-sdk)'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'AVS Device SDK: git clone -b v1.9 [https://github.com/alexa/avs-device-sdk](https://github.com/alexa/avs-device-sdk)'
- en: 'Alexa Auto SDK: git clone -b 1.2.0 [https://github.com/alexa/aac-sdk](https://github.com/alexa/aac-sdk)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Alexa Auto SDK: git clone -b 1.2.0 [https://github.com/alexa/aac-sdk](https://github.com/alexa/aac-sdk)'
- en: 'To build these you should follow instructions for your platform from this URL:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 构建这些时，您应遵循此 URL 上的平台说明：
- en: '[https://github.com/alexa/avs-device-sdk/wiki](https://github.com/alexa/avs-device-sdk/wiki)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/alexa/avs-device-sdk/wiki](https://github.com/alexa/avs-device-sdk/wiki)'
- en: 'The basic steps for building QtAlexaAuto are the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 构建 QtAlexaAuto 的基本步骤如下：
- en: Sign-up for an Amazon developer account, and register a product. [https://developer.amazon.com/docs/alexa-voice-service/register-a-product.html](https://developer.amazon.com/docs/alexa-voice-service/register-a-product.html)
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册亚马逊开发者账户，并注册一个产品。[https://developer.amazon.com/docs/alexa-voice-service/register-a-product.html](https://developer.amazon.com/docs/alexa-voice-service/register-a-product.html)
- en: Add your clientID and productID
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加你的 clientID 和 productID
- en: Install the requirements mentioned in the Alexa wiki
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Alexa wiki 中提到的需求
- en: Apply patches as detailed in install_aac_sdk.md
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照 install_aac_sdk.md 中的详细说明应用补丁。
- en: Build and install AVS Device SDK
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并安装 AVS 设备 SDK
- en: Build and install Alexa Auto SDK
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并安装 Alexa Auto SDK
- en: Edit AlexaSamplerConfig.json
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 AlexaSamplerConfig.json
- en: Build QtAlexaAuto
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建 QtAlexaAuto
- en: There are a few patches you need to apply. Luckily there are instructions in
    install_aac_sdk.md, which instruct you on how to apply the patches from aac-sdk
    to the avs-device-sdk.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要应用几个补丁。幸运的是，install_aac_sdk.md 中有说明，指导你如何将补丁从 aac-sdk 应用到 avs-device-sdk。
- en: The file AlexaSamplerConfig.json needs to be edited and renamed to  AlexaClientSDKConfig_new_version_linux.json
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 需要编辑并重命名文件 AlexaSamplerConfig.json 为 AlexaClientSDKConfig_new_version_linux.json
- en: The file then needs to be put into the directory where you are running the example
    from.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将文件放入你从其中运行示例的目录中。
- en: The QtAlexaAuto main QML component is named alexaApp, which corresponds to the
    QtAlexaAuto class.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: QtAlexaAuto 的主要 QML 组件名为 alexaApp，它对应于 QtAlexaAuto 类。
- en: When you run the example app, you will need to sign in to your Amazon developer
    account and link this application by entering a code the application gives you
    when you start it for the first time. These can be provided to the user by calling
    acctLinkUrl() and acctLinkCode(), or in QML by the alexaApp properties named accountLinkCode
    and accountLinkUrl.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行示例应用程序时，你需要登录到你的亚马逊开发者账户，并通过输入应用程序在首次启动时给出的代码来关联此应用程序。这些可以通过调用 acctLinkUrl()
    和 acctLinkCode() 或在 QML 中通过名为 accountLinkCode 和 accountLinkUrl 的 alexaApp 属性提供给用户。
- en: Once this is linked to an account, you use voice input and the Alexa Voice Service
    by tapping on the button.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦此功能与账户关联，你就可以通过点击按钮使用语音输入和 Alexa 语音服务。
- en: The function that runs when the user presses the talk button is tapToTalk(),
    and the startTapToTalk signal gets emitted.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下说话按钮时运行的函数是 tapToTalk()，并且会发出 startTapToTalk 信号。
- en: '![](img/2267a64d-0f9e-4de9-86fd-0edb84f65ade.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2267a64d-0f9e-4de9-86fd-0edb84f65ade.png)'
- en: AVS has a notion of a RenderTemplate, which gets passed from the service so
    the application will be able to show the user visual information about the response.
    QtAlexaAuto handles Weather, media player templates, as well as some generic multipurpose
    templates. The RenderTemplate gets emitted as JSON documents and shown in the
    example application using QML components, which then parse and display the data.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: AVS 有一个 RenderTemplate 的概念，它从服务传递过来，这样应用程序就能向用户展示关于响应的视觉信息。QtAlexaAuto 处理天气、媒体播放器模板以及一些通用多用途模板。RenderTemplate
    以 JSON 文档的形式发出，并在示例应用程序中使用 QML 组件显示，然后解析并显示数据。
- en: This was just a quick look at QtAlexaAuto, as I did not have enough time to
    really dig into this new API before the publication of this book.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对 QtAlexaAuto 的快速浏览，因为我没有足够的时间在本书出版前真正深入研究这个新 API。
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: User input is important, and there are various ways for users to interact with
    applications. If you are creating your own embedded device, you will need to decide
    what input methods to use. Touchscreens can increase usability because touching
    things is a very natural thing to do. Babies and even cats can use touchscreen
    devices! Gestures are a fantastic way to use touch input and you can even develop
    custom gestures for your application. Voice input is taking off right now. Whilst
    adding support for it might take a little work, it can be the right thing to do
    on some devices that require hands-free usage.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入很重要，用户与应用程序交互的方式有很多。如果你正在创建自己的嵌入式设备，你需要决定使用哪些输入方法。触摸屏可以提高可用性，因为触摸东西是非常自然的事情。婴儿甚至猫都可以使用触摸屏设备！手势是使用触摸输入的绝佳方式，你甚至可以为你的应用程序开发自定义手势。语音输入现在正在兴起。虽然添加对其的支持可能需要一点工作，但在一些需要免提使用的设备上，这可能是一件正确的事情。
- en: In the following chapter, we will learn about networking and its features.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习网络及其功能。
