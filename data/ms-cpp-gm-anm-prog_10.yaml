- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Enhancing Animation Controls
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升动画控制
- en: Welcome to *Chapter 7*! In the previous chapter, we added some camera functions.
    We started by implementing support for multiple camera objects and added new camera
    types. We also set keyboard shortcuts to allow the simple selection of the existing
    cameras. As the last step, we added an orthogonal camera configuration, which
    enabled us to create entirely different views of the model instances and the virtual
    worlds.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到**第7章**！在前一章中，我们添加了一些相机功能。我们首先实现了对多个相机对象的支持，并添加了新的相机类型。我们还设置了键盘快捷键，以便简单地选择现有的相机。作为最后一步，我们添加了一个正交相机配置，这使得我们能够创建模型实例和虚拟世界的完全不同的视图。
- en: In this chapter, we will update animation blending and controls to a new level.
    First, we will implement blending between two animations in the existing transformation
    compute shader. Also, we will move the calculation of translation, scaling, and
    rotation for each node to lookup tables onto the GPU. Next, we will add new instance
    states to the code, storing the kind of actions the instance could do, like walking,
    running, and jumping, plus the direction of movement. Then, we will create UI
    controls, allowing us to map the existing animation clips to instance actions.
    Finally, we will add the logic for the mapping between animations and actions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更新动画混合和控制到一个新的水平。首先，我们将在现有的变换计算着色器中实现两个动画之间的混合。此外，我们将每个节点的平移、缩放和旋转的计算移动到查找表上，并在GPU上执行。接下来，我们将向代码中添加新的实例状态，存储实例可能执行的动作类型，如行走、跑步和跳跃，以及移动方向。然后，我们将创建用户界面控件，使我们能够将现有的动画剪辑映射到实例动作。最后，我们将添加动画和动作之间的映射逻辑。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Blending between animations with style
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以风格混合动画
- en: Adding new states to the code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向代码中添加新状态
- en: Linking states and animations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接状态和动画
- en: Saving and loading the states
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存和加载状态
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The example code in the `chapter07` folder, in the `01_opengl_animations` folder
    for OpenGL and the `02_vulkan_animations` folder for Vulkan.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chapter07`文件夹中的`01_opengl_animations`文件夹和`02_vulkan_animations`文件夹中的示例代码。
- en: Blending between animations with style
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以风格混合动画
- en: If you solved the second and third tasks in the *Practical sessions* section
    in [*Chapter 2*](Chapter_2.xhtml) and moved more parts of the animation blending
    to the GPU, parts of this section may be familiar to you. But do not worry if
    you skipped the tasks, as the process of moving the transformation data to lookup
    tables and doing the interpolation calculations on the GPU is straightforward.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你解决了[*第2章*](Chapter_2.xhtml)中“实践环节”部分的第二个和第三个任务，并将动画混合的部分转移到GPU上，那么本节的部分内容可能对你来说很熟悉。但如果你跳过了这些任务，也不要担心，因为将变换数据移动到查找表并在GPU上进行插值计算的过程非常直接。
- en: Let’s start with the lookup table data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查找表数据开始。
- en: The power of lookup tables
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找表的力量
- en: Currently, the data for the animation keyframes and the corresponding node transformations
    is extracted during model loading, and all the data is stored in arrays inside
    `AssimpAnimChannel` objects.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，动画关键帧和相应的节点变换的数据在模型加载时提取，并且所有数据都存储在`AssimpAnimChannel`对象内部的数组中。
- en: For every node in every frame, six lookups are needed to extract the translation,
    scaling, and rotation for the previous and current keyframe time. Then, the values
    are interpolated pairwise to calculate the final transformation for the specified
    node.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一帧中的每个节点，需要六次查找来提取前一个和当前关键帧时间的平移、缩放和旋转。然后，这些值成对插值以计算指定节点的最终变换。
- en: However, doing the same calculations repeatedly is time-consuming. A better
    solution is to generate all the interpolated transforms when the model is loaded,
    and only do a lookup of the final transform value when playing the animation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重复进行相同的计算是耗时的。更好的解决方案是在模型加载时生成所有插值变换，并且在播放动画时只进行最终变换值的查找。
- en: 'The trade-off here is clear: GPU memory versus CPU computing power. Setting
    the size of the lookup tables too small will cause visible artifacts, while setting
    the size of the lookup table data too large will waste precious GPU memory without
    having any visual benefits. You can experiment with the lookup table size, but
    ~1,000 elements for the transform values should be a good balance between visuals
    and memory size.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的权衡很明显：GPU内存与CPU计算能力。将查找表的大小设置得太小会导致可见的伪影，而将查找表数据的大小设置得太大则会浪费宝贵的GPU内存，而没有任何视觉上的好处。您可以尝试查找表的大小，但对于变换值来说，大约1,000个元素应该在视觉效果和内存大小之间达到良好的平衡。
- en: An alternative lookup solution
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一种替代的查找解决方案
- en: A more memory-friendly version of the lookup table can be achieved by creating
    a table for the keyframe times and using the extracted data as the index into
    the original transformation data. You may use this variation if you have a lot
    of nodes and animation clips to save GPU memory. Or you could use these sparser
    lookups if there are only a few keyframes per animation. On the downside of this
    version, you need to calculate the pair-wise interpolations between the values
    per keyframe again, adding more computing load to the GPU.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为关键帧时间创建一个表并使用提取的数据作为原始变换数据的索引，可以创建一个更节省内存的查找表版本。如果您有很多节点和动画片段需要节省GPU内存，可以使用这种变体。或者，如果您每个动画只有少数关键帧，也可以使用这些稀疏的查找。然而，这种版本的缺点是需要再次计算每个关键帧之间的成对插值，这会增加GPU的计算负担。
- en: In addition to the new transform data storage, we will scale all animation clips
    to have the same time length. Without the need to scale the length of two animation
    clips, blending between two clips becomes much simpler.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了新的变换数据存储之外，我们还将所有动画片段的时间长度进行缩放，使其具有相同的时间长度。无需缩放两个动画片段的长度，两个片段之间的混合变得更加简单。
- en: Creating the lookup tables
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建查找表
- en: 'As preparation for the lookup tables, we must find the maximum length of all
    animation clips. Before adding the animation clips to the `loadModel()` method
    of the `AssimpModel` class, we iterate over all animations and store the maximum
    length in a new `private` member variable called `mMaxClipDuration`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 作为查找表的准备，我们必须找到所有动画片段的最大长度。在将动画片段添加到`AssimpModel`类的`loadModel()`方法之前，我们遍历所有动画并将最大长度存储在一个新的`private`成员变量`mMaxClipDuration`中：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, the maximum value is used as an additional parameter to the `addChannels()`
    call:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，最大值被用作`addChannels()`调用的附加参数：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, inside the `addChannels()` method, we hand over the maximum duration
    to every channel we are extracting:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`addChannels()`方法内部，我们将最大持续时间传递给我们要提取的每个通道：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Creating the lookup table data itself will be shown in the following code snippets
    by using the code to create the translation data as an example. For scaling and
    rotation, the same principle applies.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 创建查找表数据本身将通过以下代码片段展示，以创建平移数据作为示例。对于缩放和旋转，同样适用。
- en: 'The first step for every lookup table is the extraction of the minimum and
    the maximum keyframe times:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每个查找表的第一步是提取最小和最大关键帧时间：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we calculate three scaling factors:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们计算三个缩放因子：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'These include:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包括：
- en: The first variable, `translateScaleFactor`, stores the ratio between the maximum
    clip duration and the maximum keyframe time. We need the first scaling factor
    when we advance the time in the lookup table data creation.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个变量`translateScaleFactor`存储最大片段持续时间与最大关键帧时间的比率。在查找表数据创建中前进时间时，我们需要第一个缩放因子。
- en: In `mTranslateTimeScaleFactor`, we calculate the ratio between the maximum clip
    duration and the size of our lookup table. The second scaling factor is simply
    the keyframe time step width of the lookup table entries.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`mTranslateTimeScaleFactor`中，我们计算最大片段持续时间与我们的查找表大小的比率。第二个缩放因子是查找表条目关键帧时间步宽度的简单值。
- en: As the last scaling factor, `mInvTranslateTimeScaleFactor` stores the inverse
    of the `mTranslateTimeScaleFactor` value. We will use the third scaling factor
    in the compute shader to calculate the right index position in the lookup table
    from the keyframe time.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为最后一个缩放因子，`mInvTranslateTimeScaleFactor`存储了`mTranslateTimeScaleFactor`值的倒数。我们将使用计算着色器中的第三个缩放因子来根据关键帧时间计算查找表中的正确索引位置。
- en: 'Next, we set a helper variable named `timeIndex` to `0` and iterate over our
    lookup table entries:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将一个名为`timeIndex`的辅助变量设置为`0`，并遍历我们的查找表条目：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For every lookup table entry, we extract the translation data from the `mPositionKeys`
    array of the `aNodeAnim` object for the current and next keyframe times into a
    `glm::vec4`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个查找表条目，我们从 `aNodeAnim` 对象的 `mPositionKeys` 数组中提取当前和下一个关键帧时间的平移数据到一个 `glm::vec4`：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Even though we only need the first three values for the translation, a four-element
    vector is used for proper data alignment in the Shader Storage Buffer Object.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们只需要平移的前三个值，但使用四元素向量是为了在着色器存储缓冲对象中正确对齐数据。
- en: 'Now, we extract the time values for the current and next keyframes, plus the
    current time of the animation:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们提取当前和下一个关键帧的时间值，以及动画的当前时间：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For the current time, two scaling factors are used.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于当前时间，使用两个缩放因子。
- en: 'By using the two translation vectors and the time values, we can create an
    interpolated `glm::vec4` of the two translations at the time stamp of the lookup
    table entry:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用两个平移向量和时间值，我们可以在查找表条目的时间戳处创建两个平移的插值 `glm::vec4`：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, we check whether the current time of the lookup table entry is longer
    than the time of the next keyframe. If it is, we increment our time index:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们检查查找表条目的当前时间是否长于下一个关键帧的时间。如果是，我们增加我们的时间索引：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `mTranslations` vector now contains interpolated translation values for
    every time point of the animation clip in a step width defined by `mTranslateTimeScaleFactor`,
    and by using the inverse value, `mInvTranslateTimeScaleFactor`, we can access
    the corresponding lookup table entry if we know the replay time of the clip.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`mTranslations` 向量现在包含了动画剪辑每个时间点的插值平移值，步长由 `mTranslateTimeScaleFactor` 定义，通过使用倒数值
    `mInvTranslateTimeScaleFactor`，如果我们知道剪辑的回放时间，我们可以访问相应的查找表条目。'
- en: Uploading the data tables to the GPU
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据表上传到GPU
- en: Once all animation clips have been converted to lookup tables, we can upload
    the array data to an SSBO. The buffer preparation part is longer as we must ensure
    all nodes are initialized properly, even the non-animated nodes. We will only
    explore the translation steps here since the logic for scaling and rotation is
    mostly identical. The biggest difference is the already known utilization of a
    four-element vector to transport the quaternion data of the rotations to the compute
    shader.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有动画剪辑都转换为查找表，我们就可以将数组数据上传到SSBO。缓冲区准备部分较长，因为我们必须确保所有节点都正确初始化，即使是非动画节点。在这里，我们只探讨平移步骤，因为缩放和旋转的逻辑大部分是相同的。最大的不同是，已经知道使用四元素向量来传输旋转的四元数数据到计算着色器。
- en: 'As the first step, we create a `std::vector` of `glm::vec4` to hold the data
    for all node transformations:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们创建一个 `std::vector` 的 `glm::vec4` 来存储所有节点变换的数据：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we define the size of the lookup table data:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义查找表数据的大小：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The addition of `1023` and `1` instead of the number `1024` is a hint of what
    happens next:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `1023` 和 `1` 而不是数字 `1024` 的添加是一个暗示接下来会发生什么：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We create an empty vector of `LOOKUP_SIZE` length and initialize the vector
    with a zeroed four-element vector. Using zeroes for the translation makes sure
    non-animated nodes will have no translational transformations.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个长度为 `LOOKUP_SIZE` 的空向量，并用一个零值的四元素向量初始化该向量。使用零值进行平移确保非动画节点不会有平移变换。
- en: At the first position of the vector, we do another explicit setting to zero
    for documentation purposes because we will use the `x` component of the first
    position in every lookup table to store the `mTranslateTimeScaleFactor`. It may
    look a bit redundant to store the inverse scale factor in every vector, but because
    we integrated the value directly into the lookup data, the compute shader will
    find all the data in one place.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在向量的第一个位置，我们为了文档目的再次显式地将值设置为零，因为我们将在每个查找表的第一个位置的 `x` 分量中存储 `mTranslateTimeScaleFactor`。在每个向量中存储倒数缩放因子可能看起来有点冗余，但因为我们直接将值集成到查找数据中，计算着色器将在一个地方找到所有数据。
- en: 'After creating appropriate empty vectors for scaling and rotation, we create
    a triplet of translation, rotation, and scaling for every bone in the bone list:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建适当的空向量用于缩放和旋转之后，我们为骨骼列表中的每个骨骼创建一个平移、旋转和缩放的组合：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By using the full number of bones in the array we may waste a couple of kilobytes,
    but we don’t need to add extra logic inside the compute shader to choose between
    animated and non-animated logic.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用数组中的全部骨骼数量，我们可能会浪费几个千字节，但不需要在计算着色器内部添加额外的逻辑来选择动画和非动画逻辑。
- en: 'Now we loop over all animation clips, and for every clip, over all channels.
    Since we have already initialized all the data with default values, we only need
    to upload the data for the animated bones:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们遍历所有动画剪辑，并对每个剪辑的所有通道进行遍历。由于我们已使用默认值初始化了所有数据，我们只需上传动画骨骼的数据：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `offset` value is calculated by using the bone list size and `LOOKUP_SIZE`
    to find the position of the translation data for the channel’s bone in the current
    animation clip:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`offset`值是通过使用骨骼列表大小和`LOOKUP_SIZE`来找到当前动画剪辑中通道骨骼的平移数据位置来计算的：'
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we set the `mTranslateTimeScaleFactor` value of the channel at the `x`
    component of the first position, get the translation data for the channel, and
    copy the data into the lookup data vector:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置第一个位置`x`组件的通道的`mTranslateTimeScaleFactor`值，获取通道的平移数据，并将数据复制到查找数据向量中：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, the `offset` value is advanced to the next lookup data position before
    storing the next transformation data:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将`offset`值推进到下一个查找数据位置，在存储下一个变换数据之前：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After all the translation, scaling, and rotation data is stored in the `animLookupData`
    vector, we can upload the data to the SSBO:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在将所有平移、缩放和旋转数据存储在`animLookupData`向量之后，我们可以将数据上传到SSBO：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, the animation lookup data for the loaded model is available on the GPU.
    When we need to access the transformation data in the compute shader, we can simply
    bind the SSBO.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，加载的模型的动画查找数据已可在GPU上使用。当我们需要在计算着色器中访问变换数据时，我们可以简单地绑定SSBO。
- en: Adjusting the renderer code and the compute shader
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整渲染器代码和计算着色器
- en: 'To be able to tell the compute shader which animation to play and/or blend,
    we define a new `struct` called `PerInstanceAnimData` in the `OGLRenderData.h`
    file in the `opengl` folder for OpenGL:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够告诉计算着色器播放哪个动画以及/或混合，我们在`opengl`文件夹中的`OGLRenderData.h`文件中定义了一个新的`struct`，称为`PerInstanceAnimData`，用于OpenGL：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For Vulkan, the file is named `VkRenderData.h` and resides in the `vulkan` folder.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Vulkan，文件名为`VkRenderData.h`，位于`vulkan`文件夹中。
- en: Here, we simply store the first clip number plus the timestamp of the current
    frame we want to render from the first clip. Also, a possible second animation
    clip, the time stamp for the second clip, and the blending factor between the
    two clips can be sent to the compute shader.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们简单地存储第一个剪辑编号加上我们想要从第一个剪辑渲染的当前帧的时间戳。此外，还可以发送可能的第二个动画剪辑、第二个剪辑的时间戳以及两个剪辑之间的混合因子到计算着色器。
- en: 'In the renderer, we define two new `private` data members:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染器中，我们定义了两个新的`private`数据成员：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `mPerInstanceAnimData` variable stores the clip numbers, time stamp, and
    blending factor for every instance, and `mPerInstanceAnimDataBuffer` is the CPU-side
    handle for the animation data SSBO.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`mPerInstanceAnimData`变量存储每个实例的剪辑编号、时间戳和混合因子，而`mPerInstanceAnimDataBuffer`是动画数据SSBO的CPU端句柄。'
- en: 'Then, in the instance loop in the `draw()` call of the renderer, we update
    the per-instance animation data with the values of the instances:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在渲染器的`draw()`调用中的实例循环中，我们使用实例的值更新每个实例的动画数据：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When preparing the first compute shader, we bind the animation lookup data
    and upload the instance animation data:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当准备第一个计算着色器时，我们绑定动画查找数据并上传实例动画数据：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, all the data we need for the compute shader is ready to be computed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们为计算着色器所需的所有数据都已准备好进行计算。
- en: 'In the `assimp_instance_transform.comp` compute shader, in the `shader` folder,
    we also need to define the `PerInstanceAnimData` `struct` to be able to access
    the SSBO:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在`assimp_instance_transform.comp`计算着色器中，在`shader`文件夹中，我们还需要定义`PerInstanceAnimData`
    `struct`以能够访问SSBO：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And we declare the two buffer bindings using the same binding points as in
    the renderer code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 并且我们使用与渲染器代码中相同的绑定点声明两个缓冲区绑定：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the `main()` method of the compute shader, we define the same lookup table
    size and offset calculation as in the `AssimpModel` class:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算着色器的`main()`方法中，我们定义与`AssimpModel`类中相同的查找表大小和偏移量计算：
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can now access all the animation settings for each instance by using the
    `instance` variable as the index in the `InstanceAnimData` SSBO:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过使用`instance`变量作为`InstanceAnimData` SSBO中的索引来访问每个实例的所有动画设置：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For instance, to get the `mTranslateTimeScaleFactor` value for the translation
    data, we must use the same formula as in C++ to access the first element of the
    translation lookup data for the clip:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要获取平移数据的`mTranslateTimeScaleFactor`值，我们必须使用与C++中相同的公式来访问剪辑的平移查找数据的第一个元素：
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Even slight differences between C++ and shader formulae or data types could
    lead to discrepancies in the transferred data, so we need to be strict here to
    do exactly the same operations and use the same data types.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 即使C++和着色器公式或数据类型之间有细微的差异，也可能导致传输数据的不一致，因此我们需要在这里非常严格，确保执行完全相同的操作并使用相同的数据类型。
- en: 'Then, we use the inverse time scale factor to calculate the correctly scaled
    index in the translation lookup data:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用逆时间缩放因子来计算在平移查找数据中的正确缩放索引：
- en: '[PRE28]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The per-node translation data for the first and second animation clip can also
    be calculated as in C++:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第一和第二个动画剪辑的每个节点的平移数据也可以像在C++中那样计算：
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now we can interpolate between the two animation clip translations:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在两个动画剪辑的平移之间进行插值：
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We do the same lookup and interpolation for the scaling values. For rotation,
    the same code as the GLM implementation for SLERP is used.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对缩放值进行相同的查找和插值。对于旋转，使用与GLM实现中SLERP相同的代码。
- en: 'Finally, the product of all three transformation matrices is stored in the
    SSBO containing the resulting TRS matrices of all instances:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，所有三个变换矩阵的乘积存储在包含所有实例结果的TRS矩阵的SSBO中：
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: At this point, the `mShaderTRSMatrixBuffer` SSBO in the renderer contains the
    same data as we had with the CPU-based transformation calculations.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，渲染器中的`mShaderTRSMatrixBuffer` SSBO包含与我们使用基于CPU的变换计算时相同的数据。
- en: 'But all we need to upload to the compute shader is the data of the animations
    we want to draw. So, the transformation calculation in the `updateAnimation()`
    method of the `AssimpInstance` class can be removed, leaving the following three
    lines to be executed when we update the animation of the instance:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们只需要上传到计算着色器的就是我们想要绘制的动画数据。因此，`AssimpInstance`类的`updateAnimation()`方法中的变换计算可以移除，留下以下三条在更新实例动画时执行的代码：
- en: '[PRE32]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We simply advance the clip time by the delta time and update the instance root
    matrix.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单地通过时间增量来推进剪辑时间，并更新实例根矩阵。
- en: If you compile and run the code now, the only visible difference is a much lower
    matrix generation time when the number of instances goes up. For a recent computer
    model, reaching 10,000 or even 20,000 animated instances of the basic model should
    be no problem. We don’t need so many instances in the virtual world, but the lower
    CPU usage for animations and animation blending gives us more freedom to implement
    more features in the remaining chapters of the book.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在编译并运行代码，唯一可见的差异是当实例数量增加时矩阵生成时间的显著降低。对于最新的计算机模型，达到10,000个甚至20,000个基本模型的动画实例应该没有问题。在虚拟世界中我们不需要这么多实例，但动画和动画混合的CPU使用率降低，这让我们在本书剩余章节中实现更多功能有了更多的自由度。
- en: Now that we have a fast and easy-to-use animation calculation, we can implement
    a state-based system to organize the behavior of each instance. By defining different
    states, like a movement direction or an action the instance will do, we create
    the first steps on the path to an animation system where we can control the instance
    as we would do in a simple game.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了快速且易于使用的动画计算，我们可以实现一个基于状态的系统来组织每个实例的行为。通过定义不同的状态，如移动方向或实例将要执行的动作，我们迈出了通往可以像在简单游戏中一样控制实例的动画系统的第一步。
- en: So, let’s continue by adding new instance states.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们继续添加新的实例状态。
- en: Adding new states to the code
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在代码中添加新状态
- en: 'Our future game character should be able to perform typical actions for a character
    in a game: wait idle for player input, walk in all four main directions, run forward,
    plus a bunch of other actions. Depending on the available animations, we could
    add a state for jumping or rolling, punching, or waving.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们未来的游戏角色应该能够执行游戏角色典型的动作：等待玩家输入，向四个主要方向行走，向前奔跑，以及许多其他动作。根据可用的动画，我们可以添加跳跃或翻滚、出拳或挥手的动作状态。
- en: For maximum flexibility, we will allow characters of all models to perform all
    the configured actions. Then we can use the UI to map an animation clip to each
    action we want to use for a specific model. Without a mapped animation clip, the
    requested action will be simply ignored.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得最大的灵活性，我们将允许所有模型的角色执行所有配置的动作。然后我们可以使用UI将动画剪辑映射到我们想要为特定模型使用的每个动作。如果没有映射的动画剪辑，请求的动作将被简单地忽略。
- en: Using bit fields and plain enums
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用位字段和平面枚举
- en: 'We will add two different `enum` `class` definitions to the `Enums.h` file.
    The first `enum` called `moveDirection` is a bit field:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`Enums.h`文件中添加两个不同的`enum` `class`定义。第一个名为`moveDirection`的`enum`是一个位字段：
- en: '[PRE33]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: For every direction, a different bit can be set in a variable. A bit field is
    needed when multiple values can appear at the same time. In our case, it would
    be normal to have the character running forward and to the left at the same time.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个方向，可以在一个变量中设置一个不同的位。当多个值可以同时出现时，需要位字段。在我们的情况下，角色同时向前和向左跑是正常的。
- en: The two additional `enum` values, `none` and `any`, are special placeholders.
    If the character is just idling, forcing a direction for the idle state would
    be strange since the character cannot “idle forward” or “idle to the left.” So,
    the separate `enum` value `none` for not moving at all will help us to keep the
    code a bit simpler. The value `any` can be used as a wildcard or fallback for
    walking states. For example, we could set a generic walk animation for all directions,
    and instead of configuring all four directions with identical animation clips,
    we use the `any` direction to use this one clip for all walk movements.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 两个额外的`enum`值`none`和`any`是特殊的占位符。如果角色只是闲置，强制为闲置状态设置方向会显得很奇怪，因为角色不能“向前闲置”或“向左闲置”。因此，为完全不移动设置单独的`enum`值`none`将有助于使代码更简单。值`any`可以用作通配符或回退值，用于行走状态。例如，我们可以为所有方向设置一个通用的行走动画，而不是为所有四个方向配置相同的动画剪辑，我们使用`any`方向来使用这个剪辑的所有行走动作。
- en: 'To be able to work with the values of the `moveDirection` `enum` in a real
    bit field manner, we have to define the bitwise Boolean operators `OR` and `AND`
    for the new data type. The declaration is short and simple, as the following code
    for the logical `AND` operator between two movement directions shows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在真正的位字段方式下使用`moveDirection` `enum`的值，我们必须为新的数据类型定义位运算符`OR`和`AND`。声明是简短且简单的，如下面的代码所示，这是两个移动方向之间的逻辑`AND`运算符：
- en: '[PRE34]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'A second `enum` `class` named `moveState` takes care of the possible character
    actions:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个名为`moveState`的`enum` `class`负责处理可能的角色动作：
- en: '[PRE35]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, no bit field is needed. We may be able to `run` and `jump` at the same
    time and will handle these cases in the code. But most of the actions cannot be
    executed at the same time.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，不需要位字段。我们可能能够同时`run`和`jump`，这些情况将在代码中处理。但大多数动作不能同时执行。
- en: We simply list all possible movement states in the `moveState` `enum` `class`.
    The final value, `NUM`, can be utilized to iterate over all the `enum` values
    in a `for` loop, i.e., starting from the first action with the value zero (`idle`)
    and ending at the last valid action `wave`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单地列出所有可能的移动状态在`moveState` `enum` `class`中。最终的值`NUM`可以被用来在`for`循环中迭代所有的`enum`值，即从第一个动作（值为零的`idle`）开始，到最后一个有效的动作`wave`结束。
- en: 'Having not just numbers for movement directions and state will become handy
    in the UI and for debug messages, so we add two new maps from the `enum` `class`
    values to strings in the `ModelInstanceCamData` struct in the `ModelInstanceCamData.h`
    file:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数字之外，对于移动方向和状态，在UI和调试消息中将变得很有用，所以我们向`ModelInstanceCamData.h`文件中的`ModelInstanceCamData`结构体添加了两个从`enum`
    `class`值到字符串的新映射：
- en: '[PRE36]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We will fill the two state maps in the `init()` method of the renderer with
    appropriate string values. Next, we must extend the settings structs for instances
    and models.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在渲染器的`init()`方法中填充两个状态映射，使用适当的字符串值。接下来，我们必须扩展实例和模型的设置结构体。
- en: Extending model and instance settings
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展模型和实例设置
- en: 'The special handling of the idle, walk, and run animation clips requires a
    new `struct` called `IdleWalkRunBlending` in a new `ModelSettings.h` file in the
    `model` folder:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 闲置、行走和跑步动画剪辑的特殊处理需要一个名为`IdleWalkRunBlending`的新`struct`，位于`model`文件夹中的新`ModelSettings.h`文件中：
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we simply store the clip numbers and replay speeds for the three movements.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们简单地存储三个动作的剪辑编号和回放速度。
- en: 'The new `IdleWalkRunBlending` struct will be added to another new `struct`
    called `ModelSettings`, along with the model’s name and file name:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`IdleWalkRunBlending`结构体将被添加到另一个新的`struct`中，称为`ModelSettings`，以及模型名称和文件名：
- en: '[PRE38]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `AssimpModel` class needs a new `private` data member of type `ModelSettings`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`AssimpModel`类需要一个新类型的`private`数据成员`ModelSettings`：'
- en: '[PRE39]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Both the model’s file name and name will be relocated from the `AssimpModel`
    class to the new `ModelSettings` `struct` to have all the “variable” parts of
    a model accessible with simple getter and setter calls, similar to the instances.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的文件名和名称将从`AssimpModel`类重新定位到新的`ModelSettings` `struct`，以便可以通过简单的getter和setter调用访问模型的“变量”部分，类似于实例。
- en: 'Before we can use the new states and animation features in an instance, we
    must add variables of the two new `enum` `class` types to the `InstanceSettings`
    `struct` in the `InstanceSettings.h` file in the `model` folder:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以在实例中使用新的状态和动画功能之前，我们必须将两个新的`enum` `class`类型变量添加到`model`文件夹中`InstanceSettings.h`文件中的`InstanceSettings`
    `struct`中：
- en: '[PRE40]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In addition, we must adjust the instance settings for the animation clips.
    Since we can have two different animations plus animation blending, we need two
    clip variables instead of only one, and the blending factor as a per-instance
    setting:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还必须调整动画剪辑的实例设置。由于我们可以有两个不同的动画加上动画混合，我们需要两个剪辑变量而不是一个，以及作为每个实例设置的混合因子：
- en: '[PRE41]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We also store the values for the speed and acceleration of the instance:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还存储实例的速度和加速度值：
- en: '[PRE42]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The speed of the specific instance will be used to select the correct idle,
    walk, or run animation clip. By using an acceleration-based movement, we achieve
    a more natural appearance of the character instances. In real life, we also accelerate
    and decelerate while moving, instead of jumping directly from idle to run speed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 特定实例的速度将用于选择正确的空闲、行走或跑步动画剪辑。通过使用基于加速度的运动，我们实现了角色实例更自然的外观。在现实生活中，我们在移动时也会加速和减速，而不是直接从空闲状态跳到跑步速度。
- en: Adding the idle/walk/run logic
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加空闲/行走/跑步逻辑
- en: The blending logic for idle/walk/run animation clips is defined in the method
    called `playIdleWalkRunAnimation()` in the `AssimpInstance` class.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 空闲/行走/跑步动画剪辑的混合逻辑定义在`AssimpInstance`类中名为`playIdleWalkRunAnimation()`的方法中。
- en: 'After a sanity check for the model of the instance, we calculate the absolute
    speed of the instance, read the model settings containing a map with the blending
    settings, and create a new, empty variable blend of type `IdleWalkRunBlending`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在对实例模型进行合理性检查之后，我们计算实例的绝对速度，读取包含混合设置的映射模型设置，并创建一个新的、空的`IdleWalkRunBlending`类型变量`blend`：
- en: '[PRE43]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, we check whether we have configured direction-specific animation clips:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查是否已配置方向特定的动画剪辑：
- en: '[PRE44]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If such a direction clip is found, the blend variable is filled with the appropriate
    settings. If no direction-specific clip was found, we check for the special `any`
    and `none` directions too, trying to use a generic animation for all directions.
    And if we don’t find the generic animation clips, we return from the method. Without
    a configured clip for idle/walk/run, it makes no sense to play any animation.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到了这样的方向剪辑，混合变量将填充适当的设置。如果没有找到特定方向剪辑，我们也检查特殊的`any`和`none`方向，尝试为所有方向使用通用动画。如果我们找不到通用动画剪辑，我们就从方法中返回。如果没有配置空闲/行走/跑步的剪辑，播放任何动画都没有意义。
- en: 'Controlling whether to blend between idle and walk or between walk and run
    animations is done by using the `instanceSpeed` variable:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`instanceSpeed`变量来控制是否在空闲和行走之间或行走和跑步动画之间进行混合：
- en: '[PRE45]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, we scale speed factors and blend between the idle and walk animations
    based on the `instanceSpeed` value. By using a value of `0.0f` for idle and `1.0f`
    (inclusive) for full walk speed, the animation will be blended smoothly between
    the instance standing still and walking around.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们根据`instanceSpeed`值缩放速度因子，并在空闲和行走动画之间进行混合。通过使用空闲的`0.0f`值和完整行走速度的`1.0f`（包括）值，动画将在实例静止不动和四处走动之间平滑混合。
- en: 'To blend the instance animations from walking to running, we use an `instanceSpeed`
    range between `1.0f` (exclusive) and `2.0f`. The logic stays the same; we must
    only subtract `1.0f` from the speed factor and the blending for the linear interpolation
    between the walk and run clips:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要混合从行走到跑步的实例动画，我们使用一个`instanceSpeed`范围在`1.0f`（不包括）和`2.0f`之间。逻辑保持不变；我们只需从速度因子和行走与跑步剪辑之间的线性插值混合中减去`1.0f`：
- en: '[PRE46]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `instanceSpeed` values of `1.0f` for walk speed and `2.0f` for run speed
    were chosen because they work best for linear interpolation between the clips.
    Any other ranges are possible; you just must adjust the scaling for the animation
    blending accordingly.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 选择行走速度的`1.0f`和跑步速度的`2.0f`的`instanceSpeed`值是因为它们在剪辑之间的线性插值中效果最佳。任何其他范围都是可能的；你只需相应地调整动画混合的缩放即可。
- en: Using acceleration and deceleration
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用加速度和减速度
- en: As our instances should move in the virtual world, we need to control the speed
    of the instance we control. But instead of using the speed directly, we will go
    for an acceleration-based speed model. Using a separate acceleration value to
    speed up or slow down the instance gives more natural results. Like real physical
    bodies, our model instances in the virtual world have their inertia working against
    speed changes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的实例应在虚拟世界中移动，我们需要控制我们所控制的实例的速度。但不是直接使用速度，我们将采用基于加速度的速度模型。使用单独的加速度值来加速或减速实例可以产生更自然的结果。像真实的物理物体一样，我们的虚拟世界中的模型实例具有惯性，这种惯性会抵抗速度变化。
- en: 'First, the `AssimpInstance` class needs three new `private` `float` variables
    named `MAX_ACCEL`, `MAX_ABS_SPEED`, and `MIN_STOP_SPEED`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`AssimpInstance` 类需要三个新的 `private` `float` 变量，分别命名为 `MAX_ACCEL`、`MAX_ABS_SPEED`
    和 `MIN_STOP_SPEED`：
- en: '[PRE47]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In `MAX_ACCEL`, we store the maximum acceleration our model can achieve, and
    `MAX_ABS_SPEED` limits the speed of the instance. Acceleration and speed are three-component
    vectors, and moving in different directions may add up to larger values. Limiting
    both values helps to prevent instances from moving too fast in the virtual world.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MAX_ACCEL` 中，我们存储模型可以达到的最大加速度，而 `MAX_ABS_SPEED` 限制了实例的速度。加速度和速度是三分量向量，向不同方向移动可能会产生更大的值。限制这两个值有助于防止实例在虚拟世界中移动得太快。
- en: 'An acceleration-based model has a major drawback: stopping an instance can
    become difficult. Since we only add and subtract the acceleration values from
    the speed, reaching the exact value of zero is hard. To achieve a full stop, we
    define a minimal speed in the `MIN_STOP_SPEED` variable. If the current speed
    of the instance is lower than the value of `MIN_STOP_SPEED`, we set acceleration
    and speed to zero, eventually stopping the instance.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 基于加速度的模型有一个主要缺点：停止实例可能变得困难。因为我们只从速度中添加和减去加速度值，达到精确的零值是困难的。为了实现完全停止，我们在 `MIN_STOP_SPEED`
    变量中定义一个最小速度。如果实例的当前速度低于 `MIN_STOP_SPEED` 的值，我们将加速度和速度设置为零，最终停止实例。
- en: 'Instance acceleration is controlled in the `updateInstanceState()` method of
    `AssimpInstance` class. Basically, we check for a movement direction and set the
    corresponding `x` or `z` components of `isAccel`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 实例加速度由 `AssimpInstance` 类的 `updateInstanceState()` 方法控制。基本上，我们检查移动方向并设置 `isAccel`
    的相应 `x` 或 `z` 分量：
- en: '[PRE48]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If a direction key is pressed, we set `isMoveKeyPressed` to true and apply the
    acceleration.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下方向键，我们将 `isMoveKeyPressed` 设置为 true 并应用加速度。
- en: 'When we release all movement keys, the deceleration of the instance kicks in.
    The slowdown logic happens in the `updateInstanceSpeed()` method of the `AssimpInstance`
    class:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们释放所有移动键时，实例的减速开始。减速逻辑发生在 `AssimpInstance` 类的 `updateInstanceSpeed()` 方法中：
- en: '[PRE49]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We also save the maximum speed of the instance locally. Using a `static` variable
    helps to keep track of accelerating and slowing down the instance between walk
    and run speed.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还本地保存实例的最大速度。使用 `static` 变量有助于在步行和奔跑速度之间跟踪加速和减速实例。
- en: 'First, we calculate the length of the 3-component `isSpeed` vector. The resulting
    length is then used to check whether we are still moving when no movement key
    is being pressed:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们计算三分量 `isSpeed` 向量的长度。然后，使用这个结果长度来检查在未按下任何移动键时我们是否仍在移动：
- en: '[PRE50]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: For the possible move directions of the instance, we check whether any speed
    is left and use an acceleration in the opposite direction of the speed to slow
    down the instance.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实例的可能移动方向，我们检查是否还有剩余速度，并使用与速度相反方向的加速度来减速实例。
- en: 'And if we are slower than `MIN_STOP_SPEED`, we forcibly set speed and acceleration
    to zero, movement state to `idle`, and move direction to `none`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的速度低于 `MIN_STOP_SPEED`，我们将强制将速度和加速度设置为零，移动状态设置为 `idle`，移动方向设置为 `none`：
- en: '[PRE51]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Limiting speed and acceleration to the maximum values is a two-step process.
    If we exceed the maximum value, we normalize the vector:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 限制速度和加速度到最大值是一个两步过程。如果我们超过最大值，我们将向量归一化：
- en: '[PRE52]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now the length of the `isAccel` vector equals `1.0f`. Then, we scale the vector
    to the maximum length:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `isAccel` 向量的长度等于 `1.0f`。然后，我们将向量缩放到最大长度：
- en: '[PRE53]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: After the multiplication, all three components of `isAccel` are scaled down
    to a resulting length of `MAX_ACCEL`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在乘法之后，`isAccel` 的所有三个分量都缩放到结果长度 `MAX_ACCEL`。
- en: 'Updating the instance speed is done by adding the `deltaTime` fraction of the
    acceleration in `isAccel` to `isSpeed`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 更新实例速度是通过将 `isAccel` 中的加速度的 `deltaTime` 分数加到 `isSpeed` 上来完成的：
- en: '[PRE54]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To reach run speed, we double the `maxSpeed` value:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要达到跑步速度，我们将`maxSpeed`值加倍：
- en: '[PRE55]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If we no longer run but are over `maxSpeed`, we slow down to walk speed:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不再跑步但超过`maxSpeed`，我们将减速到行走速度：
- en: '[PRE56]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The example code uses a simple linear interpolation to reach the desired instance
    speed. You might want to experiment with other techniques like ease-in/ease-out
    curves, or cubic curves to adjust the interpolation between different instance
    speeds.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码使用简单的线性插值来达到所需的实例速度。您可能想尝试其他技术，如缓动/非缓动曲线或三次曲线，以调整不同实例速度之间的插值。
- en: 'And if we are faster than `maxSpeed` while accelerating to walk or run speed,
    we limit the instance speed `isSpeed` to `maxSpeed`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在加速到行走或跑步速度时比`maxSpeed`更快，我们将实例速度`isSpeed`限制为`maxSpeed`：
- en: '[PRE57]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: At this point, the currently selected instance would move smoothly from the
    idle animation clip to the walk animation clip, and even get a speedup to the
    run animation if we switch to the `run` state. Sadly, we cannot see anything yet
    since there is no mapping between movement states, directions, and animation clips.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，当前选定的实例将从空闲动画片段平滑地移动到行走动画片段，甚至如果我们切换到`run`状态，还可以加速到跑步动画。遗憾的是，我们目前什么也看不到，因为没有在运动状态、方向和动画片段之间建立映射。
- en: So, let’s link the animation clips to existing states.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们将动画片段链接到现有状态。
- en: Linking states and animations
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接状态和动画
- en: We start with the connections between the three states (idle, walk, and run),
    and map the corresponding model animation clips to these three states. The `IdleWalkRunBlending`
    `struct` and the `msIWRBlendings` member variable in the `ModelSettings` `struct`
    are already in place, so we only have to take care of the UI.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从三个状态（空闲、行走和跑步）之间的连接开始，并将相应的模型动画片段映射到这三个状态。`IdleWalkRunBlending` `struct`和`ModelSettings`
    `struct`中的`msIWRBlendings`成员变量已经就位，所以我们只需要注意UI。
- en: Mapping idle/walk/run animations
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空闲/行走/跑步动画映射
- en: '*Figure 7.1* shows the mapping section of the **Control** window for the three
    states: idle, walk, and run:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.1* 展示了**控制**窗口中三个状态（空闲、行走和跑步）的映射部分：'
- en: '![](img/Figure_7.1_B22428.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_7.1_B22428.png)'
- en: 'Figure 7.1: Mapping between move direction, move state, and animation clip'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：移动方向、移动状态和动画片段之间的映射
- en: 'We will step through the control elements from top to bottom and explore the
    new code in the `createSettingsWindow()` method of the `UserInterface` class:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从上到下逐步浏览控制元素，并探索`UserInterface`类中的`createSettingsWindow()`方法中的新代码：
- en: The **Dir** combo box shows the names of the available entries of the `moveDirection`
    `enum` `class`. The combo box is filled by using the `micMoveDirectionMap` map
    from the `ModelInstanceCamData` `struct`. We store the selected entry in a `static`
    `moveDirection` type variable to retain the value.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方向**组合框显示了`moveDirection` `enum` `class`的可用条目名称。组合框是通过使用`ModelInstanceCamData`
    `struct`中的`micMoveDirectionMap`映射来填充的。我们将选中的条目存储在一个`static` `moveDirection`类型变量中，以保留该值。'
- en: For the three combo boxes named **Idle**, **Walk**, and **Run**, we extract
    the animation clips from the model of the instance and store the selected clip
    in a `static` `int` for each state. The replay speed slider allows us to set individual
    replay speeds for every clip. We had the same combo box/float slider combination
    in the (now removed) **Animations** part of the **Control** window.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于名为**空闲**、**行走**和**跑步**的三个组合框，我们从实例模型中提取动画片段，并将每个状态选中的片段存储在一个`static` `int`中。回放速度滑块允许我们为每个片段设置单独的回放速度。我们曾在（现已删除的）**控制**窗口的**动画**部分有相同的组合框/浮点滑块组合。
- en: To store the current combination of direction, clips, and speeds, press the
    **Save** button. The `UserInterface` code simply creates or updates the `msIWRBlendings`
    entry for the selected direction.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要存储当前的方向、片段和速度组合，请按**保存**按钮。`UserInterface`代码只是简单地创建或更新所选方向的`msIWRBlendings`条目。
- en: Below the combo boxes, all saved mappings are listed. If you press the **Edit**
    button on one of the entries, the corresponding line will be loaded into the combo
    boxes and speed sliders. By pressing **Remove**, the entry will be deleted.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组合框下方，列出了所有已保存的映射。如果您按其中一个条目的**编辑**按钮，相应的行将被加载到组合框和速度滑块中。通过按**删除**，条目将被删除。
- en: To enable a preview for the current mappings, check the **Enable Preview** checkbox.
    In testing mode, the active mapping settings are used to animate the currently
    selected instance and blend between the three states. Make sure to disable preview
    mode once you have found good settings for the mappings.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要启用当前映射的预览，请勾选**启用预览**复选框。在测试模式下，活动映射设置用于动画当前选定的实例并在三种状态之间混合。一旦找到了映射的良好设置，请确保禁用预览模式。
- en: Above the **Test** slider, the names of the three animation clips for the three
    states, idle/walk/run, are shown. You can see the names changing if you select
    a different animation clip in any of the combo boxes. The **Test** slider allows
    you to preview the animation blending between the three selected clips when the
    test mode is enabled in the **Model** section. Moving the slider to the left plays
    the idle animation clip; if the slider is in the middle position, the walk animation
    clip is shown; and on the right, the run animation is played. Between these three
    slider positions, linear interpolations between idle and walk as well as between
    walk and run are generated and drawn.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**测试**滑块上方，显示了三种状态（空闲/行走/跑步）的三个动画剪辑的名称。如果您在任一组合框中选择不同的动画剪辑，您可以看到名称的变化。**测试**滑块允许您在**模型**部分启用测试模式时预览三个选定剪辑之间的动画混合。将滑块向左移动播放空闲动画剪辑；如果滑块位于中间位置，则显示行走动画剪辑；在右侧，播放跑步动画。在这三个滑块位置之间，生成并绘制空闲和行走之间以及行走和跑步之间的线性插值。
- en: 'One interesting addition to the `UserInterface` code is the automated creation
    of button IDs for every mapping by using `ImGui::PushID()` and `ImGui::PopID()`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserInterface`代码中的一个有趣新增是使用`ImGui::PushID()`和`ImGui::PopID()`自动为每个映射创建按钮ID：'
- en: '[PRE58]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: ImGui needs a unique identifier for every control element. Failing to provide
    a unique ID leads to unwanted results, since triggering one control element also
    triggers the other element(s) containing the same ID.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ImGui需要为每个控件元素提供一个唯一的标识符。未能提供唯一ID会导致不希望的结果，因为触发一个控件元素也会触发包含相同ID的其他元素。
- en: By using an incrementing integer value as an identifier, every mapping line
    will have unique **Edit** and **Remove** buttons, and the buttons will only affect
    *their* mapping line.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用递增的整数值作为标识符，每个映射行都将有唯一的**编辑**和**删除**按钮，并且按钮只会影响**它们**的映射行。
- en: 'Another nice ImGui feature is the ability to close a `CollapsingHeader` element
    from another part of the code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个ImGui的不错特性是能够从代码的另一部分关闭`CollapsingHeader`元素：
- en: '[PRE59]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The internal state storage of ImGui saves information about the elements of
    the current ImGui window. With the `SetInt()` call and the `CollapsingHeader`
    name, we can control the open/close state of any header in the current ImGui window.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ImGui的内部状态存储保存了当前ImGui窗口中元素的信息。通过`SetInt()`调用和`CollapsingHeader`名称，我们可以控制当前ImGui窗口中任何标题的打开/关闭状态。
- en: This way, we forcibly close the other two mapping `CollapsingHeader` elements.
    We are changing the animation clip settings in all three mapping headers, and
    ImGui applies the settings multiple times, leading to unwanted results.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们强制关闭了其他两个映射`CollapsingHeader`元素。我们在所有三个映射标题中更改动画剪辑设置，ImGui多次应用这些设置，导致不希望的结果。
- en: After all idle/walk/run animation clips have been set, we continue with the
    actions.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置完所有空闲/行走/跑步动画剪辑后，我们继续处理动作。
- en: Mapping actions to animation clips
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将动作映射到动画剪辑
- en: 'In the `moveState` `enum` `class`, we have defined several actions for the
    instances, next to the already configured `idle`, `walk`, and `run` states. Depending
    on the animations in a model file, not all actions may be available for all models.
    But there is no need to worry: the code will ignore actions without a configured
    animation. Pressing the action key will result in no animation or action.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在`moveState` `enum` `class`中，我们在实例旁边定义了几个动作，包括已经配置的`idle`、`walk`和`run`状态。根据模型文件中的动画，并非所有动作都适用于所有模型。但无需担心：代码会忽略未配置动画的动作。按下动作键将不会产生动画或动作。
- en: 'All configured action mappings are saved to the `ModelSettings` `struct` in
    the `ModelSettings.h` file in a new map called `msActionClipMappings`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 所有配置的动作映射都保存到`ModelSettings.h`文件中的`ModelSettings` `struct`的新映射`msActionClipMappings`中：
- en: '[PRE60]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The new `ActionAnimation` `struct` contains the clip number and the replay
    speed:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`ActionAnimation` `struct`包含剪辑编号和重放速度：
- en: '[PRE61]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We will start again with the UI part. In *Figure 7.2*, the `CollapsingHeader`
    for the action mapping is shown:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次从UI部分开始。在*图7.2*中，展示了动作映射的`CollapsingHeader`：
- en: '![](img/Figure_7.2_B22428.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_7.2_B22428.png)'
- en: 'Figure 7.2: Mapping movement states to animation clips and speeds'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：将运动状态映射到动画剪辑和速度
- en: 'The `UserInterface` code for this mapping type is similar to the idle/walk/run
    mapping as we do essentially the same kind of mapping. We have the following elements:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种映射类型，`UserInterface`代码与空闲/行走/跑步映射类似，因为我们实际上执行的是同种类型的映射。我们有以下元素：
- en: A combo box for the elements of the `moveState` `enum` `class`, filled with
    the values of the `micMoveStateMap` map
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于`moveState` `enum` `class`元素的组合框，填充了`micMoveStateMap`映射的值
- en: A second combo box for the clips, generated from the animation clips of the
    model
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个用于剪辑的组合框，由模型的动画剪辑生成
- en: A speed slider defining the replay speed of the clip
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个定义剪辑重放速度的速度滑块
- en: A **Save** button to add the current mapping to the `msActionClipMappings` map
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**保存**按钮，用于将当前映射添加到`msActionClipMappings`映射中
- en: A list of saved mappings, and every mapping line has two buttons to **Edit**
    or **Remove** the current line
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个保存的映射列表，并且每个映射行都有两个按钮来**编辑**或**删除**当前行
- en: The note from the idle/walk/run mapping also applies here. When a mapping for
    the `none` movement direction exists in the **Model Idle/Walk/Run Blendings**
    section, the currently selected clip is *not* playing. To see a preview of the
    animation clip, you need to temporarily remove the `none` direction.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 空闲/行走/跑步映射的说明也适用于此处。当**模型空闲/行走/跑步混合**部分中存在`none`移动方向的映射时，当前选定的剪辑*不会*播放。要预览动画剪辑，您需要暂时移除`none`方向。
- en: 'To blend between the idle/walk/run state and any action in the `AssimpInstance`
    class, we can use the clip number and replay speed from the `msActionClipMappings`
    map and use the clip as the destination clip for a blending operation:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要在空闲/行走/跑步状态之间以及`AssimpInstance`类中的任何动作之间进行混合，我们可以使用`msActionClipMappings`映射中的剪辑编号和重放速度，并将剪辑用作混合操作的目标剪辑：
- en: '[PRE62]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If we want our model to change to an action, we call the `setNextInstanceState()`
    method of the `AssimpInstance` class. The renderer uses this call in the `handleMovementKeys()`
    method to request a state change of the selected instance:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让我们的模型改变到一个动作，我们调用`AssimpInstance`类的`setNextInstanceState()`方法。渲染器在`handleMovementKeys()`方法中使用此调用来请求所选实例的状态变化：
- en: '[PRE63]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Before we dive into the animation blending logic, let’s finish the UI part by
    looking at how to set allowed clip sequences.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究动画混合逻辑之前，让我们通过查看如何设置允许的剪辑序列来完成UI部分。
- en: Defining allowed state changes
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义允许的状态变化
- en: While previewing the different animation clips of the models, you will notice
    that some clips only work when the instance stands still, while other animations
    are only usable if the instance is walking or running.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在预览模型的不同的动画剪辑时，您会注意到有些剪辑只有在实例静止时才有效，而其他动画只有在实例行走或跑步时才可用。
- en: To prevent unwanted and unnatural transitions between clips, for instance, from
    an idle model to a full-speed jump animation, we define which action state changes
    are allowed. The **Destination** state can only be triggered when the **Source**
    state is the current active state.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止剪辑之间出现不希望和不自然的过渡，例如，从空闲模型到全速跳跃动画，我们定义哪些动作状态变化是允许的。**目标**状态只能在**源**状态是当前活动状态时触发。
- en: '*Figure 7.3* shows some allowed state changes:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.3* 展示了一些允许的状态变化：'
- en: '![](img/Figure_7.3_B22428.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_7.3_B22428.png)'
- en: 'Figure 7.3: Allowed state changes of a model'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：模型的允许状态变化
- en: 'The state order is saved in the `ModelSettings` `struct` using a `std::set`
    containing `std::pair` elements of `moveState` entries:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 状态顺序被保存在使用包含`std::pair`元素的`moveState`条目的`std::set`的`ModelSettings` `struct`中：
- en: '[PRE64]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: A `std::map` would not work here as we need to configure multiple destination
    states for the same source state.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`std::map`在这里不起作用，因为我们需要为相同的源状态配置多个目标状态。
- en: After all the states are mapped to animation clips and the dependencies between
    states have been configured, we will explore the way the model actions are concatenated
    to give (mostly) smooth blending and transition effects.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有状态都映射到动画剪辑并且配置了状态之间的依赖关系之后，我们将探讨模型动作如何连接起来以给出（主要是）平滑的混合和过渡效果。
- en: Using a finite state machine to control the animation flow
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用有限状态机来控制动画流程
- en: The task of maintaining states over time and transitions from one state to another
    state after an event can be solved best by using a **finite state machine**. And
    in C++, such a state machine can be modeled with a simple `switch`/`case` statement.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 维护状态随时间的变化以及事件发生后从一个状态到另一个状态的转换，最佳方法是使用**有限状态机**。在C++中，这样的状态机可以用简单的`switch`/`case`语句来建模。
- en: 'Before we start the implementation, let’s look at the states and transitions
    of the state machine in *Figure 7.4*:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实现之前，让我们看看*图7.4*中状态机的状态和转换：
- en: '![](img/Figure_7.4_B22428.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_7.4_B22428.png)'
- en: 'Figure 7.4: State machine of the `mAnimState` variable in the `AssimpInstance`
    class'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：`AssimpInstance`类中`mAnimState`变量的状态机
- en: 'These five states and the transitions between the states can be explained as
    follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这五个状态以及状态之间的转换可以解释如下：
- en: We start at the state machine at `playIdleWalkRun`. Here, the default, instance-speed-based
    blending between the movement states, idle, walk, and run, is played.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`playIdleWalkRun`状态机开始。在这里，默认的、基于实例速度的移动状态（空闲、行走和奔跑）之间的混合被播放。
- en: Once an action is requested, we check whether source (current state) and destination
    (action state) are in the `msAllowedStateOrder` map. If yes, we prepare the directional
    clips and change to the `transitionFromIdleWalkRun` state.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦请求了动作，我们检查源（当前状态）和目标（动作状态）是否在`msAllowedStateOrder`映射中。如果是，我们准备方向剪辑并切换到`transitionFromIdleWalkRun`状态。
- en: The `transitionFromIdleWalkRun` state is needed to smooth the transition from
    idle/walk/run to the requested action. Most animation clips start from a similar
    pose of body, arms, and legs. By blending the current idle, walk, or run animation
    to the starting point of the same animation clip, the instance is adjusted back
    to its starting pose. After reaching the starting pose, we advance to the `transitionToAction`
    state.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`transitionFromIdleWalkRun`状态是必要的，用于平滑地从空闲/行走/奔跑到请求的动作的过渡。大多数动画剪辑都是从身体、手臂和腿的类似姿势开始的。通过将当前的空闲、行走或奔跑动画与相同动画剪辑的起始点混合，实例被调整回其起始姿势。达到起始姿势后，我们进入`transitionToAction`状态。'
- en: In `transitionToAction`, we blend from the initial pose of the idle, walk, or
    run animation clip to the action state animation clip. This transition is only
    a few frames long and adds a smooth blending to the action clip. Once the transition
    to the action clip is done, we change to `playActionAnim`.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`transitionToAction`中，我们从空闲、行走或奔跑动画剪辑的初始姿势混合到动作状态动画剪辑。这种转换只有几帧长，并为动作剪辑添加了平滑的混合。一旦动作剪辑的转换完成，我们就切换到`playActionAnim`。
- en: Once we are in `playActionAnim`, the animation for the requested action state
    is played at the configured replay speed until the end of the clip is reached.
    When the action animation clip is played, keyboard requests to switch to other
    animation clips or to return to the idle/walk/run cycle are ignored. Once the
    action animation clip is finished and no new requests for an action have been
    issued, the state is changed to `transitionToIdleWalkRun`.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们处于`playActionAnim`状态，请求的动作状态动画将在配置的重放速度下播放，直到剪辑结束。当动作动画剪辑播放时，键盘请求切换到其他动画剪辑或返回到空闲/行走/奔跑循环将被忽略。一旦动作动画剪辑完成且没有发出新的动作请求，状态将更改为`transitionToIdleWalkRun`。
- en: Similar to `transitionToAction`, the `transitionToIdleWalkRun` state is used
    to blend between the action clip and the idle/walk/run clip. The destination clip
    (idle, walk, or run) is chosen via the instance speed. For a smooth animation
    cycle, the positions of the body, arms, and legs are the same as the start and
    end of the clip. By blending the end of the action clip with the start of an idle/walk/run
    clip, we have a smooth transition back to the initial state. After the blending
    is finished, we change the state back to `playIdleWalkRun`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 与`transitionToAction`类似，`transitionToIdleWalkRun`状态用于在动作剪辑和空闲/行走/奔跑剪辑之间混合。目标剪辑（空闲、行走或奔跑）通过实例速度选择。为了实现平滑的动画循环，身体、手臂和腿的位置与剪辑的开始和结束相同。通过将动作剪辑的结束与空闲/行走/奔跑剪辑的开始混合，我们实现了回到初始状态的平滑过渡。混合完成后，我们将状态改回`playIdleWalkRun`。
- en: 'For the animation clip transitions, we create a new `enum` `struct` called
    `animationState` in the `Enums.h` file containing the states of the finite state
    machine:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 对于动画剪辑的过渡，我们在`Enums.h`文件中创建了一个新的`enum struct`，名为`animationState`，其中包含有限状态机的状态：
- en: '[PRE65]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The state machine is defined in the `updateAimStateMachine()` method of the
    `AssimpInstance` class. The states are built as switch/case statements moving
    forward on the conditions outlined in *Figure 7.4*:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机在`AssimpInstance`类的`updateAimStateMachine()`方法中定义。状态是通过在*图7.4*中概述的条件上的switch/case语句构建的：
- en: '[PRE66]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'You can check the details of the finite state machine in the `updateAnimStateMachine()`
    method of the `AssimpInstance` class. The code is simple and straightforward:
    we just replay and blend between various animation clips.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`AssimpInstance`类的`updateAnimStateMachine()`方法中查看有限状态机的详细信息。代码简单直接：我们只是重放并混合各种动画片段。
- en: With the blending code and the finite state machine in place, you can change
    to the view mode of the application by pressing `F10`. If you press a key for
    an action while you are at an allowed source state, the action clip will be played.
    Right after the action clip, the instance goes back to the previous idle/walk/run
    state.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置了混合代码和有限状态机之后，你可以通过按`F10`键切换到应用程序的视图模式。如果你在允许的源状态下按下一个动作键，动作片段将被播放。在动作片段之后，实例将回到之前的空闲/行走/跑步状态。
- en: To complete this chapter’s features, we need to make the state and clip mappings
    permanent by adding the contents of the `ModelSettings` `struct` and all related
    custom data types to the configuration file.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章的功能，我们需要通过将`ModelSettings` `struct`的内容和所有相关自定义数据类型添加到配置文件中，使状态和剪辑映射永久化。
- en: Saving and loading the states
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存和加载状态
- en: We can reuse some of the save and load code we created in the previous chapters
    when saving and loading the current state of custom data types. The `moveState`
    and `moveDirection` `enum` `class` types will be stored as integer values in the
    YAML configuration file of the application. The three new `struct` types, `IdleWalkRunBlending`,
    `ActionAnimation`, and `ModelSettings`, are deconstructed into their elements
    when saving them to the configuration file and reassembled when reading the values.
    The C++ maps and sets are created by using the known combination of YAML sequences
    and YAML maps.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当保存和加载自定义数据类型的当前状态时，我们可以重用之前章节中创建的一些保存和加载代码。`moveState`和`moveDirection` `enum`
    `class`类型将被存储为整数值在应用程序的YAML配置文件中。三个新的`struct`类型，`IdleWalkRunBlending`、`ActionAnimation`和`ModelSettings`，在保存到配置文件时被分解为其元素，在读取值时重新组装。C++的map和set是通过使用已知的YAML序列和YAML映射的组合来创建的。
- en: Storing the new data types
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储新的数据类型
- en: 'For the `moveState` and `moveDirection` structs, we create a new `convert`
    template in the `YamlParserTypes.h` file in the `tools` folder that will simply
    cast to `int` and back:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`moveState`和`moveDirection` `struct`，我们在`tools`文件夹中的`YamlParserTypes.h`文件中创建了一个新的`convert`模板，它将简单地转换为`int`并返回：
- en: '[PRE67]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The YAML emitter overloads for `moveState` and `moveDirection` in the `YamlParser.cpp`
    file in the `tools` folder are also casting the values to `int`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`tools`文件夹中的`YamlParser.cpp`文件中`moveState`和`moveDirection`的YAML发射器重载也将值转换为`int`：'
- en: '[PRE68]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Now we can read and write the new data types like every other type when we generate
    or parse our YAML configuration file.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们在生成或解析YAML配置文件时，我们可以像处理其他类型一样读取和写入新的数据类型。
- en: 'Both struct types, `IdleWalkRunBlending` and `ActionAnimation`, only use int
    and float values, so the main task here is to find good names for the YAML nodes.
    For example, the `ActionAnimation` values are stored as `clip` and `clip-speed`
    in the YAML file:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 两种`struct`类型，`IdleWalkRunBlending`和`ActionAnimation`，只使用int和float值，所以这里的任务是找到好的YAML节点名称。例如，`ActionAnimation`值在YAML文件中存储为`clip`和`clip-speed`：
- en: '[PRE69]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Saving the contents of the `ModelSettings` `struct` is also straightforward.
    We simply output all the values and iterate over the `msIWRBlendings` and `msActionClipMappings`
    maps and the `msAllowedStateOrder` set by using `for` loops:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 保存`ModelSettings` `struct`的内容也是简单的。我们只是输出所有值，并使用`for`循环遍历`msIWRBlendings`和`msActionClipMappings`映射以及`msAllowedStateOrder`集合：
- en: '[PRE70]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Reading back the `ModelSettings` is done in the `getModelConfigs()` method
    of the `YamlParser` class. The YAML parsing inside `getModelConfigs()` method
    is identical to the parsing of the `InstanceSettings` or `CameraSettings` `struct`.
    By using the `convert` template, all we must do is instruct `yaml-cpp` to use
    the correct data type when filling the temporary `modeSettings` vector:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在`YamlParser`类的`getModelConfigs()`方法中读取`ModelSettings`。`getModelConfigs()`方法中的YAML解析与`InstanceSettings`或`CameraSettings`
    `struct`的解析相同。通过使用`convert`模板，我们只需指示`yaml-cpp`在填充临时的`modeSettings`向量时使用正确的数据类型：
- en: '[PRE71]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Parsing the C++ maps and sets is a bit tricky. We need to iterate over the
    node containing the sequence, get every entry as a `std::map`, and add the map
    to the corresponding map of the `ModelSettings` type:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 解析C++的映射和集合有点棘手。我们需要遍历包含序列的节点，将每个条目作为`std::map`获取，并将映射添加到`ModelSettings`类型的相应映射中：
- en: '[PRE72]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Reading back the model settings in the renderer
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在渲染器中回读模型设置
- en: 'Saving the model settings is entirely done by the YAML emitter; no changes
    to the `saveConfigFile()` method of the renderer are needed. To get the model
    settings back into the application in the `loadConfigFile()` method, we use the
    `getModelConfigs()` method of the YAML parser:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 保存模型设置完全由YAML发射器完成；不需要对渲染器的`saveConfigFile()`方法进行任何更改。要在`loadConfigFile()`方法中将模型设置恢复到应用程序中，我们使用YAML解析器的`getModelConfigs()`方法：
- en: '[PRE73]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Then, we loop over the contents of the vector and we try to add the models
    using the file name and path found in the loaded model settings:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们遍历向量的内容，并尝试使用在加载的模型设置中找到的文件名和路径添加模型：
- en: '[PRE74]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: If the model cannot be loaded, we stop the loading process. If we want to have
    more relaxed file handling in case of errors, we can store the models that failed
    to load, skip the instances of the failed models, and inform the user in a dialog
    that an error has occurred.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模型无法加载，我们停止加载过程。如果我们希望在出错时对文件处理更加宽松，我们可以存储加载失败的模型，跳过失败模型的实例，并在对话框中通知用户发生了错误。
- en: 'Next, we get the model by the file name again and restore the model settings:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们再次通过文件名获取模型，并恢复模型设置：
- en: '[PRE75]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Finally, we restore the model that was selected when the configuration was
    saved:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们恢复保存配置时选择的模型：
- en: '[PRE76]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Now, all animation clip mappings and the state sequences are restored. The application
    user can take a break from creating a virtual world at any time without losing
    progress.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有动画剪辑映射和状态序列都已恢复。应用程序用户可以在任何时候暂停创建虚拟世界而不会丢失进度。
- en: With the additions from this chapter, we can bring the instances on the screen
    to life. Depending on the available animations in the model file, the instance
    can not only walk and run, but also do additional actions like jumping up or forward,
    rolling around, punching targets, waving, or interacting with the environment.
    The animations are also blended between the different movements and actions, creating
    a game-like feeling.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的添加，我们可以使屏幕上的实例栩栩如生。根据模型文件中可用的动画，实例不仅可以行走和奔跑，还可以执行额外的动作，如跳跃、向前冲、滚动、击打目标、挥手或与环境交互。这些动画还会在不同的运动和动作之间混合，营造出类似游戏的感觉。
- en: Summary
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we improved animation processing efficiency and added gameplay-like
    controls to map animation clips to the current animation state. We started by
    moving the computational work of animation blending from the CPU to the GPU and
    created lookup tables to reduce the amount of work for the GPU (at the cost of
    memory usage). Then, we added the different movement states to the code, including
    a UI-based mapping between states and animation clips. As the last step, we added
    the new mappings to the YAML configuration file, allowing us to save and restore
    the mappings.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们提高了动画处理效率，并添加了类似游戏玩法控制，将动画剪辑映射到当前动画状态。我们首先将动画混合的计算工作从CPU移动到GPU，并创建了查找表以减少GPU的工作量（以内存使用为代价）。然后，我们将不同的运动状态添加到代码中，包括基于UI的状态与动画剪辑之间的映射。最后一步，我们将新的映射添加到YAML配置文件中，使我们能够保存和恢复映射。
- en: In the next chapter, we will take a closer look at collision detection. After
    we can move the instance in the virtual world, we need to avoid just *running
    through* other instances on the screen. As the first step, we will explore the
    theoretical background of collision detection and discuss the problems of a naive
    implementation. Then, we will add spatial partitioning to the virtual world and
    instance simplifications to reduce the complexity of the collision detection checks.
    Finally, we will implement multi-level collision detection, allowing us to detect
    collisions between instances with minimal costs.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更详细地探讨碰撞检测。在我们能够在虚拟世界中移动实例之后，我们需要避免只是*穿过*屏幕上的其他实例。作为第一步，我们将探讨碰撞检测的理论背景，并讨论简单实现中存在的问题。然后，我们将空间分区添加到虚拟世界中，并将实例简化以减少碰撞检测检查的复杂性。最后，我们将实现多级碰撞检测，以最小成本检测实例之间的碰撞。
- en: Practical sessions
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践环节
- en: 'There are some additions you could make to the code:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在代码中添加一些内容：
- en: Use root motion to control instance movement.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用根运动来控制实例的移动。
- en: Instead of moving the position of the instances around the virtual world and
    playing the animation at a specific rate, so-called **Root Motion** can be used
    to let the animation clips control the movement of the character. In root motion,
    the movement of the model’s root bone is coordinated by the animation and not
    by us, allowing a better sync of the feet on the ground. However, root motion
    data must be baked into model animations to work. Updating the animations is beyond
    the scope of the book.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 与在虚拟世界中移动实例的位置并以特定速率播放动画不同，所谓的**根运动**可以用来让动画片段控制角色的移动。在根运动中，模型的根骨骼的运动是由动画协调的，而不是由我们控制，这允许地面上的脚步有更好的同步。然而，根运动数据必须烘焙到模型动画中才能工作。更新动画超出了本书的范围。
- en: Add a second direction for the idle/walk/run mapping.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加空闲/行走/跑步映射的第二个方向。
- en: Right now, only animations for the four main directions (forward, backward,
    left, and right) plus the special wildcards `none` and `any` can be configured.
    Moving diagonally may look a bit awkward when the feet are not synchronized with
    the instance movement.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，只能配置四个主要方向的动画（向前、向后、向左、向右）以及特殊的通配符`none`和`any`。当脚步没有与实例移动同步时，以对角线移动可能会显得有些笨拙。
- en: Add animation blending for diagonal movement.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加对角运动的动画混合。
- en: Similarly to the previous task, instead of adding multiple directions, you can
    try to blend between the forward/backward and left/right animation clips when
    the instance is moving in a diagonal direction.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个任务类似，而不是添加多个方向，当实例以对角方向移动时，你可以尝试在正向/反向和左/右动画片段之间进行混合。
- en: Add a preview for the state order configuration.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加对状态顺序配置的预览。
- en: To preview the transition from **Source** to **Destination** state, the finite
    state machine would need to be adjusted with some sort of testing mode. The source
    state must be set and played for a while, i.e., until the animation clip is restarted.
    Then, the transition to the destination state must be triggered. Plus, we need
    to forbid the instance from moving; all transitions must happen without changing
    the world position of the instance.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 为了预览从**源**状态到**目标**状态的过渡，有限状态机需要通过某种测试模式进行调整。源状态必须设置并播放一段时间，即直到动画片段重新开始。然后，必须触发到目标状态的过渡。此外，我们需要禁止实例移动；所有过渡都必须在不改变实例世界位置的情况下发生。
- en: Allow animation clips to be played in the reverse direction.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许动画片段以反向方向播放。
- en: The woman model has a clip with a **sit-down** animation. To make the instance
    stand up again, you could add a Boolean to play the clip either forward or in
    reverse direction.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 女性模型有一个包含**坐下**动画的片段。为了使实例再次站立，你可以添加一个布尔值来播放片段的正向或反向方向。
- en: Add more speed interpolation functions and make them selectable.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加更多速度插值函数，并使它们可选择。
- en: As mentioned in the *Using acceleration and deceleration* section, the interpolation
    between different speeds is done by a simple linear interpolation. Try to add
    more advanced interpolation variants here, like separate ease-in and ease-out
    functions based on curves. You could also add an extra field to the model settings
    that stores the interpolation function and make additional fields in the UI to
    choose an interpolation to use.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在*使用加速和减速*章节中提到的，不同速度之间的插值是通过简单的线性插值完成的。尝试在此处添加更多高级的插值变体，例如基于曲线的独立加速和减速函数。你还可以在模型设置中添加一个额外的字段来存储插值函数，并在UI中添加额外的字段来选择要使用的插值。
- en: Use a graphical tool to draw nodes and connections.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用图形工具绘制节点和连接。
- en: The **Graph Editor** from ImGuizmo (see the link in the *Addition resources*
    section) adds nodes and connections to ImGui. You could change the mapping configurations
    to have nodes for states and animation clips and use the connections to define
    mappings.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: ImGuizmo（见*附加资源*章节中的链接）的**图形编辑器**向ImGui添加节点和连接。你可以更改映射配置，以便有状态和动画片段的节点，并使用连接来定义映射。
- en: Additional resources
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加资源
- en: 'ImGuizmo GitHub repo: [https://github.com/CedricGuillemet/ImGuizmo](https://github.com/CedricGuillemet/ImGuizmo)'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ImGuizmo GitHub仓库：[https://github.com/CedricGuillemet/ImGuizmo](https://github.com/CedricGuillemet/ImGuizmo)
- en: Join our community on Discord
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://packt.link/cppgameanimation](https://packt.link/cppgameanimation)'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的社区Discord空间，与作者和其他读者进行讨论：[https://packt.link/cppgameanimation](https://packt.link/cppgameanimation)
- en: '![A qr code with black squares  AI-generated content may be incorrect.](img/QR_code_Discord.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![带有黑色方块的二维码 AI生成的内容可能不正确。](img/QR_code_Discord.png)'
