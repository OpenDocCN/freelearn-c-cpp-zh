["```cpp\nFileCheckStatus check_file(const char* name)\n{\n\u00a0\u00a0FILE* fptr{fopen(name,\"r\")};\n\u00a0\u00a0if ( fptr == nullptr)\n\u00a0\u00a0\u00a0\u00a0return FileCheckStatus::NotFound;\n\u00a0\u00a0char buffer[30];\n\u00a0\u00a0auto numberRead = fread(buffer, 1, 30, fptr);\n\u00a0\u00a0fclose(fptr);\n\u00a0\u00a0if (numberRead != 30)\n\u00a0\u00a0\u00a0\u00a0return FileCheckStatus::IncorrectSize;\n\u00a0\u00a0if(is_valid(buffer))\n\u00a0\u00a0\u00a0\u00a0return FileCheckStatus::InvalidContents;\n\u00a0\u00a0return FileCheckStatus::Good;\n}\n```", "```cpp\nInt divide(Int a, Int b )\n{\n\u00a0\u00a0\u00a0\u00a0if (b.m_value == 0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0throw std::domain_error(\"divide by zero error!\");\n\u00a0\u00a0\u00a0\u00a0return a.m_value/b.m_value;\n}\n```", "```cpp\n    #define EXERCISE1_STEP\u00a0\u00a014\n    ```", "```cpp\n    ASSERT_THROW(({Fraction f1{1,0}; }), std::domain_error);\n    ```", "```cpp\n    #include <stdexcept> \n    ```", "```cpp\n    Fraction::Fraction(int numerator, int denominator) \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: m_numerator{numerator}, m_denominator{denominator}\n    {\n    \u00a0\u00a0\u00a0\u00a0if(m_denominator == 0) \n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0throw std::domain_error(\"Zero Denominator\");\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    #define EXERCISE1_STEP\u00a0\u00a020\n    ```", "```cpp\n    Fraction& Fraction::operator/=(const Fraction& rhs)\n    {\n    \u00a0\u00a0\u00a0\u00a0if (rhs.m_numerator == 0)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0throw std::runtime_error(\"Fraction Divide By Zero\");\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0Fraction tmp(m_numerator*rhs.m_denominator, \n    m_denominator*rhs.m_numerator);\n    \u00a0\u00a0\u00a0\u00a0*this = tmp;\n    \u00a0\u00a0\u00a0\u00a0return *this;\n    }\n    ```", "```cpp\n    #define EXERCISE1_STEP\u00a0\u00a027\n    ```", "```cpp\n    void pop()\n    {\n    \u00a0\u00a0\u00a0\u00a0if(empty())\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0throw std::underflow_error(\"Pop from empty stack\");\n    \u00a0\u00a0\u00a0\u00a0m_stack.pop_back();\n    } \n    ```", "```cpp\n    #define EXERCISE1_STEP\u00a0\u00a031\n    ```", "```cpp\n    reference top()\n    {\n    \u00a0\u00a0\u00a0\u00a0if(empty())\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0throw std::underflow_error(\"Top from empty stack\");\n    \u00a0\u00a0\u00a0\u00a0return m_stack.back();\n    }\n    ```", "```cpp\n    #define EXERCISE1_STEP\u00a0\u00a035\n    ```", "```cpp\n    const_reference top() const\n    {\n    \u00a0\u00a0\u00a0\u00a0if(empty())\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0throw std::underflow_error(\"Top from empty stack\");\n    \u00a0\u00a0\u00a0\u00a0return m_stack.back();\n    }\n    ```", "```cpp\nthrow expression;\n```", "```cpp\nvoid SomeFunction()\n{\n\u00a0\u00a0try {\n\u00a0\u00a0\u00a0\u00a0// code under exception inspection\n\u00a0\u00a0}\n\u00a0\u00a0catch(myexception e)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// first handler \u2013 catch by value\n\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0// some error handling steps\n\u00a0\u00a0}\n\u00a0\u00a0catch(std::exception* e)\u00a0\u00a0\u00a0\u00a0\u00a0// second handler \u2013 catch by pointer\n\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0// some other error handling steps\n\u00a0\u00a0}\n\u00a0\u00a0catch(std::runtime_error& e) // third handler \u2013 catch by reference\n\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0// some other error handling steps\n\u00a0\u00a0}\n\u00a0\u00a0catch(...)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// default exception handler \u2013 catch any exception\n\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0// some other error handling steps\n\u00a0\u00a0}\n\u00a0\u00a0// Normal programming continues from here\n}\n```", "```cpp\ntarget_compile_options(L3Exercise2 PRIVATE $<$<CXX_COMPILER_ID:GNU>:-fpermissive>)\n```", "```cpp\nvoid do_something()\n{\n\u00a0\u00a0\u00a0\u00a0FILE* out{};\n\u00a0\u00a0\u00a0\u00a0FILE* in = fopen(\"input.txt\", \"r\");\n\u00a0\u00a0\u00a0\u00a0try \n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (in != nullptr)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// UNSAFE \u2013 an exception here will create a resource leak\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0out = fopen(\"output.txt\", \"w\");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (out != nullptr)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Do some work\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// UNSAFE \u2013 an exception here will create resource leaks\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0fclose(out);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0fclose(in);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0catch(std::exception& e)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Respond to the exception\n\u00a0\u00a0\u00a0\u00a0}\n}\n```", "```cpp\nclass File {\npublic:\n\u00a0\u00a0\u00a0\u00a0File(const char* name, const char* access) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_file = fopen(name, access);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (m_file == nullptr) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0throw std::ios_base::failure(\"failed to open file\");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0~File() {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0fclose(m_file);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0operator FILE*() {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return m_file;\n\u00a0\u00a0\u00a0\u00a0}\nprivate:\n\u00a0\u00a0\u00a0\u00a0FILE* m_file{};\n};\n```", "```cpp\nvoid do_something()\n{\n\u00a0\u00a0\u00a0\u00a0try \n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0File in(\"input.txt\", \"r\");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0File out(\"output.txt\", \"w\");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Do some work\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0catch(std::exception& e)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Respond to the exception\n\u00a0\u00a0\u00a0\u00a0}\n}\n```", "```cpp\n    class File {\n    public:\n    \u00a0\u00a0\u00a0\u00a0File(const char* name, const char* access) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_file = fopen(name, access);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (m_file == nullptr) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0throw std::ios_base::failure(\"\"failed to open file\"\");\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0~File() {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0fclose(m_file);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0operator FILE*() {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return m_file;\n    \u00a0\u00a0\u00a0\u00a0}\n    private:\n    \u00a0\u00a0\u00a0\u00a0FILE* m_file{};\n    };\n    ```", "```cpp\n    void LeakFiles()\n    {\n    \u00a0\u00a0\u00a0\u00a0File fh1{\"HelloB1.txt\", \"w\"};\n    \u00a0\u00a0\u00a0\u00a0fprintf(fh1, \"Hello B2\\n\");\n    \u00a0\u00a0\u00a0\u00a0File fh2{\"HelloB2.txt\", \"w\"};\n    \u00a0\u00a0\u00a0\u00a0fprintf(fh2, \"Hello B1\\n\");\n    }\n    ```", "```cpp\n    class CharPointer\n    {\n    public:\n    \u00a0\u00a0\u00a0\u00a0void allocate(size_t size)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_memory = new char[size];\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0operator char*() { return m_memory;}\n    private:\n    \u00a0\u00a0\u00a0\u00a0char* m_memory{};\n    };\n    ```", "```cpp\n    void LeakPointers()\n    {\n    \u00a0\u00a0\u00a0\u00a0CharPointer memory[5];\n    \u00a0\u00a0\u00a0\u00a0for (auto i{0} ; i<5 ; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0memory[i].allocate(20); \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"allocated 20 bytes @ \" << (void *)memory[i] << \"\\n\";\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    ~CharPointer()\n    {\n    \u00a0\u00a0\u00a0\u00a0delete [] m_memory;\n    }\n    ```", "```cpp\nclass BufferedWriter\n{\npublic:\n\u00a0\u00a0\u00a0\u00a0BufferedWriter(const char* filename);\n\u00a0\u00a0\u00a0\u00a0~BufferedWriter();\n\u00a0\u00a0\u00a0\u00a0bool write(const char* data, size_t length);\nprivate:\n\u00a0\u00a0\u00a0\u00a0const size_t BufferSize{4096};\n\u00a0\u00a0\u00a0\u00a0FILE* m_file{nullptr};\n\u00a0\u00a0\u00a0\u00a0size_t m_writePos{0};\n\u00a0\u00a0\u00a0\u00a0char* m_buffer{new char[BufferSize]};\n};\n```", "```cpp\n#include <iostream>\ntemplate<class T>\nclass smart_ptr\n{\npublic:\n\u00a0\u00a0smart_ptr(T* ptr = nullptr) :m_ptr(ptr)\n\u00a0\u00a0{\n\u00a0\u00a0}\n\u00a0\u00a0~smart_ptr()\n\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0delete m_ptr;\n\u00a0\u00a0}\n\u00a0\u00a0// Copy constructor --> Do deep copy\n\u00a0\u00a0smart_ptr(const smart_ptr& a)\n\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0m_ptr = new T;\n\u00a0\u00a0\u00a0\u00a0*m_ptr = *a.m_ptr;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// use operator=() to do deep copy\n\u00a0\u00a0}\n\u00a0\u00a0// Copy assignment --> Do deep copy \n\u00a0\u00a0smart_ptr& operator=(const smart_ptr& a)\n\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0// Self-assignment detection\n\u00a0\u00a0\u00a0\u00a0if (&a == this)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return *this;\n\u00a0\u00a0\u00a0\u00a0// Release any resource we're holding\n\u00a0\u00a0\u00a0\u00a0delete m_ptr;\n\u00a0\u00a0\u00a0\u00a0// Copy the resource\n\u00a0\u00a0\u00a0\u00a0m_ptr = new T;\n\u00a0\u00a0\u00a0\u00a0*m_ptr = *a.m_ptr;\n\u00a0\u00a0\u00a0\u00a0return *this;\n\u00a0\u00a0}\n\u00a0\u00a0T& operator*() const { return *m_ptr; }\n\u00a0\u00a0T* operator->() const { return m_ptr; }\n\u00a0\u00a0bool is_null() const { return m_ptr == nullptr; }\nprivate:\n\u00a0\u00a0T* m_ptr{nullptr};\n};\nclass Resource\n{\npublic:\n\u00a0\u00a0Resource() { std::cout << \"Resource acquired\\n\"; }\n\u00a0\u00a0~Resource() { std::cout << \"Resource released\\n\"; }\n};\nsmart_ptr<Resource> createResource()\n{\n\u00a0\u00a0\u00a0\u00a0smart_ptr<Resource> res(new Resource);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Step 1\n\u00a0\u00a0\u00a0\u00a0return res; // return value invokes the copy constructor\u00a0\u00a0\u00a0\u00a0\u00a0// Step 2\n}\nint main()\n{\n\u00a0\u00a0smart_ptr<Resource> the_res;\n\u00a0\u00a0the_res = createResource(); // assignment invokes the copy assignment Step 3/4\n\n\u00a0\u00a0return 0; // Step 5\n}\n```", "```cpp\n// Move constructor --> transfer resource\nsmart_ptr(smart_ptr&& a) : m_ptr(a.m_ptr)\n{\n\u00a0\u00a0a.m_ptr = nullptr;\u00a0\u00a0\u00a0\u00a0// Put into safe state\n}\n// Move assignment --> transfer resource\nsmart_ptr& operator=(smart_ptr&& a)\n{\n\u00a0\u00a0// Self-assignment detection\n\u00a0\u00a0if (&a == this)\n\u00a0\u00a0\u00a0\u00a0return *this;\n\u00a0\u00a0// Release any resource we're holding\n\u00a0\u00a0delete m_ptr;\n\u00a0\u00a0// Transfer the resource\n\u00a0\u00a0m_ptr = a.m_ptr;\n\u00a0\u00a0a.m_ptr = nullptr;\u00a0\u00a0\u00a0\u00a0// Put into safe state\n\u00a0\u00a0return *this;\n}\n```", "```cpp\nthe_res = createResource(); // assignment invokes the copy assignment Step 3/4\n```", "```cpp\n// Move constructor --> transfer resource\nsmart_ptr(smart_ptr&& a) \n{\n\u00a0\u00a0std::swap(this->m_ptr, a.m_ptr);\n}\n```", "```cpp\nsmart_ptr(const smart_ptr& a) = delete;\nsmart_ptr& operator=(const smart_ptr& a) = delete;\n```", "```cpp\n#include <iostream>\n#include <memory>\nclass Resource\n{\npublic:\n\u00a0\u00a0Resource() { std::cout << \"Resource acquired\\n\"; }\n\u00a0\u00a0~Resource() { std::cout << \"Resource released\\n\"; }\n};\nstd::unique_ptr<Resource> createResource()\n{\n\u00a0\u00a0std::unique_ptr<Resource> res(new Resource);\n\u00a0\u00a0return res; \n}\nint main()\n{\n\u00a0\u00a0std::unique_ptr<Resource> the_res;\n\u00a0\u00a0the_res = createResource(); // assignment invokes the copy assignment\n\u00a0\u00a0return 0;\n}\n```", "```cpp\nstd::unique_ptr<Resource> createResource()\n{\n\u00a0\u00a0return std::make_unique<Resource>(); \n}\n```", "```cpp\nsome_function(std::unique_ptr<T>(new T), std::unique_ptr<U>(new U));\n```", "```cpp\nstd::unique_ptr<MyClass> unique_obj = std::make_unique<MyClass>();\nstd::shared_ptr<MyClass> shared_obj = unique_obj;\n```", "```cpp\n#include <iostream>\n#include <memory>\nstruct ScrollBar;\nstruct TextWindow;\nstruct Panel\n{\n\u00a0\u00a0\u00a0\u00a0~Panel() {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"--Panel destroyed\\n\";\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0void setScroll(const std::shared_ptr<ScrollBar> sb) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_scrollbar = sb;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0void setText(const std::shared_ptr<TextWindow> tw) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_text = tw;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0std::weak_ptr<ScrollBar> m_scrollbar;\n\u00a0\u00a0\u00a0\u00a0std::shared_ptr<TextWindow> m_text;\n};\nstruct ScrollBar\n{\n\u00a0\u00a0\u00a0\u00a0~ScrollBar() {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"--ScrollBar destroyed\\n\";\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0void setPanel(const std::shared_ptr<Panel> panel) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_panel=panel;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0std::shared_ptr<Panel> m_panel;\n};\nstruct TextWindow\n{\n\u00a0\u00a0\u00a0\u00a0~TextWindow() {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"--TextWindow destroyed\\n\";\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0void setPanel(const std::shared_ptr<Panel> panel) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_panel=panel;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0std::shared_ptr<Panel> m_panel;\n};\nvoid run_app()\n{\n\u00a0\u00a0\u00a0\u00a0std::shared_ptr<Panel> panel = std::make_shared<Panel>();\n\u00a0\u00a0\u00a0\u00a0std::shared_ptr<ScrollBar> scrollbar = std::make_shared<ScrollBar>();\n\u00a0\u00a0\u00a0\u00a0std::shared_ptr<TextWindow> textwindow = std::make_shared<TextWindow>();\n\u00a0\u00a0\u00a0\u00a0scrollbar->setPanel(panel);\n\u00a0\u00a0\u00a0\u00a0textwindow->setPanel(panel);\n\u00a0\u00a0\u00a0\u00a0panel->setScroll(scrollbar);\n\u00a0\u00a0\u00a0\u00a0panel->setText(textwindow);\n}\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0std::cout << \"Starting app\\n\";\n\u00a0\u00a0\u00a0\u00a0run_app();\n\u00a0\u00a0\u00a0\u00a0std::cout << \"Exited app\\n\";\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\ndo_something(Resource* resource);\ndo_something(Resource& resource);\ndo_something(Resource resource);\n```", "```cpp\ndo_something(std::unique_ptr<Resource> resource);\nauto res = std::make_unique<Resource>();\ndo_something (std::move(res));\n```", "```cpp\ndo_something(std::unique_ptr<Resource>& resource);\n```", "```cpp\n#include <iostream>\n#include <memory>\n#include <string>\n#include <sstream>\nclass Resource\n{\npublic:\n\u00a0\u00a0Resource() { std::cout << \"+++Resource acquired [\"<< m_id <<\"]\\n\"; }\n\u00a0\u00a0~Resource() { std::cout << \"---Resource released [\"<< m_id <<\"]\\n\"; }\n\u00a0\u00a0std::string name() const {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::ostringstream ss;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ss << \"the resource [\" << m_id <<\"]\";\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return ss.str();\n\u00a0\u00a0}\n\u00a0\u00a0int m_id{++m_count};\n\u00a0\u00a0static int m_count;\n};\nint Resource::m_count{0};\nvoid use_resource(Resource& res)\n{\n\u00a0\u00a0\u00a0\u00a0std::cout << \"Enter use_resource\\n\";\n\u00a0\u00a0\u00a0\u00a0std::cout << \"...using \" << res.name() << \"\\n\";\n\u00a0\u00a0\u00a0\u00a0std::cout << \"Exit use_resource\\n\";\n}\nvoid take_ownership(std::unique_ptr<Resource> res)\n{\n\u00a0\u00a0\u00a0\u00a0std::cout << \"Enter take_ownership\\n\";\n\u00a0\u00a0\u00a0\u00a0if (res)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"...taken \" << res->name() << \"\\n\";\n\u00a0\u00a0\u00a0\u00a0std::cout << \"Exit take_ownership\\n\";\n}\nvoid reseat(std::unique_ptr<Resource>& res)\n{\n\u00a0\u00a0\u00a0\u00a0std::cout << \"Enter reseat\\n\";\n\u00a0\u00a0\u00a0\u00a0res.reset(new Resource);\n\u00a0\u00a0\u00a0\u00a0if (res)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"...reseated \" << res->name() << \"\\n\";\n\u00a0\u00a0\u00a0\u00a0std::cout << \"Exit reseat\\n\";\n}\nint main()\n{\n\u00a0\u00a0std::cout << \"Starting...\\n\";\n\u00a0\u00a0auto res = std::make_unique<Resource>();\n\u00a0\u00a0// Use - pass resource by reference\n\u00a0\u00a0use_resource(*res);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0if (res)\n\u00a0\u00a0\u00a0\u00a0std::cout << \"We HAVE the resource \" << res->name() << \"\\n\\n\";\n\u00a0\u00a0else\n\u00a0\u00a0\u00a0\u00a0std::cout << \"We have LOST the resource\\n\\n\";\n\u00a0\u00a0// Pass ownership - pass smart pointer by value\n\u00a0\u00a0take_ownership(std::move(res));\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0if (res)\n\u00a0\u00a0\u00a0\u00a0std::cout << \"We HAVE the resource \" << res->name() << \"\\n\\n\";\n\u00a0\u00a0else\n\u00a0\u00a0\u00a0\u00a0std::cout << \"We have LOST the resource\\n\\n\";\n\u00a0\u00a0// Replace (reseat) resource - pass smart pointer by reference\n\u00a0\u00a0reseat(res);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0if (res)\n\u00a0\u00a0\u00a0\u00a0std::cout << \"We HAVE the resource \" << res->name() << \"\\n\\n\";\n\u00a0\u00a0else\n\u00a0\u00a0\u00a0\u00a0std::cout << \"We have LOST the resource\\n\\n\";\n\u00a0\u00a0std::cout << \"Exiting...\\n\";\n\u00a0\u00a0return 0;\n}\n```", "```cpp\n    std::unique_ptr<ISensor>\n    createSensor(SensorType type)\n    {\n    \u00a0\u00a0\u00a0\u00a0std::unique_ptr<ISensor> sensor;\n    \u00a0\u00a0\u00a0\u00a0if (type == SensorType::Light)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sensor.reset(new LightSensor);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0else if (type == SensorType::Temperature)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sensor.reset(new TemperatureSensor);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0else if (type == SensorType::Pressure)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sensor.reset(new PressureSensor);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return sensor;\n    }\n    ```", "```cpp\n    #define EXERCISE4_STEP\u00a0\u00a05\n    ```", "```cpp\n    SensorSPtr light2 = std::move(light);\n    ```", "```cpp\n    template<typename SP>\n    void printSharedPointer(SP sp, const char* message)\n    ```", "```cpp\n    #define EXERCISE4_STEP\u00a0\u00a012\n    ```", "```cpp\n    #define EXERCISE4_STEP\u00a0\u00a015\n    ```", "```cpp\n    void testArrays()\n    {\n    \u00a0\u00a0\u00a0\u00a0std::unique_ptr<int []> board = std::make_unique<int []>(8*8);\n    \u00a0\u00a0\u00a0\u00a0for(int i=0\u00a0\u00a0; i<8 ; i++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(int j=0 ; j<8 ; j++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0board[i*8+j] = 10*(i+1)+j+1;\n    \u00a0\u00a0\u00a0\u00a0for(int i=0\u00a0\u00a0; i<8 ; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0char sep{' '};\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(int j=0 ; j<8 ; j++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << board[i*8+j] << sep;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"\\n\";\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    auto board = std::make_unique<int []>(8*8);\n    ```", "```cpp\nstruct NoResourceToManage\n{\n\u00a0\u00a0\u00a0\u00a0// use compiler generated copy & move constructors and operators\n};\nstruct CopyOnlyResource\n{\n\u00a0\u00a0\u00a0\u00a0~CopyOnlyResource()\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{/* defined */ }\n\u00a0\u00a0\u00a0\u00a0CopyOnlyResource(const CopyOnlyResource& rhs)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{/* defined */ }\n\u00a0\u00a0\u00a0\u00a0CopyOnlyResource& operator=(const CopyOnlyResource& rhs) {/* defined */ }\n\u00a0\u00a0\u00a0\u00a0CopyOnlyResource(CopyOnlyResource&& rhs) = delete;\n\u00a0\u00a0\u00a0\u00a0CopyOnlyResource& operator=(CopyOnlyResource&& rhs) = delete;\n};\nstruct MoveOnlyResource\n{\n\u00a0\u00a0\u00a0\u00a0~MoveOnlyResource()\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{/* defined */ }\n\u00a0\u00a0\u00a0\u00a0MoveOnlyResource(const MoveOnlyResource& rhs)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= delete;\n\u00a0\u00a0\u00a0\u00a0MoveOnlyResource& operator=(const MoveOnlyResource& rhs)\u00a0\u00a0= delete;\n\u00a0\u00a0\u00a0\u00a0MoveOnlyResource(MoveOnlyResource&& rhs)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{/* defined */ }\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0MoveOnlyResource& operator=(MoveOnlyResource&& rhs)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{/* defined */ }\n};\nstruct NoMoveOrCopyResource\n{\n\u00a0\u00a0\u00a0\u00a0~NoMoveOrCopyResource()\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{/* defined */ }\n\u00a0\u00a0\u00a0\u00a0NoMoveOrCopyResource(const NoMoveOrCopyResource& rhs)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= delete;\n\u00a0\u00a0\u00a0\u00a0NoMoveOrCopyResource& operator=(const NoMoveOrCopyResource& rhs)\u00a0\u00a0= delete;\n\u00a0\u00a0\u00a0\u00a0NoMoveOrCopyResource(NoMoveOrCopyResource&& rhs)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= delete;\n\u00a0\u00a0\u00a0\u00a0NoMoveOrCopyResource& operator=(NoMoveOrCopyResource&& rhs)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= delete;\n};\n```", "```cpp\nfunc(a, b);\n```", "```cpp\n#include <iostream>\n#include <string>\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0std::string welcome{\"Hello there\"};\n\u00a0\u00a0\u00a0\u00a0std::cout << welcome;\n\u00a0\u00a0\u00a0\u00a0endl(std::cout);\n}\n```", "```cpp\n$ ./adl.exe\nHello there\n$\n```", "```cpp\n#include <iostream>\n#include <string>\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0std::string welcome{\"Hello there\"};\n\u00a0\u00a0\u00a0\u00a0std::cout << welcome << std::endl;\n}\n```", "```cpp\n#include <iostream>\nnamespace mylib \n{\nvoid is_substring(std::string superstring, std::string substring)\n{\n\u00a0\u00a0\u00a0\u00a0std::cout << \"mylib::is_substring()\\n\";\n}\nvoid contains(std::string superstring, const char* substring) {\n\u00a0\u00a0\u00a0\u00a0is_substring(superstring, substring);\n}\n}\nint main() {\n\u00a0\u00a0\u00a0\u00a0mylib::contains(\"Really long reference\", \"included\");\n}\n```", "```cpp\nnamespace std {\nvoid is_substring(std::string superstring, const char* substring)\n{\n\u00a0\u00a0\u00a0\u00a0std::cout << \"std::is_substring()\\n\";\n}\n}\n```", "```cpp\n    template<class T>\n    bool empty(const T& x)\n    {\n    \u00a0\u00a0\u00a0\u00a0return x.empty();\n    }\n    template<class T>\n    int size(const T& x)\n    {\n    \u00a0\u00a0\u00a0\u00a0return x.size();\n    }\n    ```", "```cpp\n    set_property(TARGET L3Exercise5 PROPERTY CXX_STANDARD 14)\n    ```", "```cpp\n#include <iostream>\nclass Real\n{\npublic:\n\u00a0\u00a0\u00a0\u00a0Real(double value) : m_value{value} {}\n\u00a0\u00a0\u00a0\u00a0operator float() {return m_value;}\n\u00a0\u00a0\u00a0\u00a0float getValue() const {return m_value;}\nprivate:\n\u00a0\u00a0\u00a0\u00a0double m_value {0.0};\n};\nvoid test(bool result)\n{\n\u00a0\u00a0\u00a0\u00a0std::cout << std::boolalpha;\n\u00a0\u00a0\u00a0\u00a0std::cout << \"Test => \" << result << \"\\n\";\n}\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0Real real{3.14159};\n\u00a0\u00a0\u00a0\u00a0test(real);\n\u00a0\u00a0\u00a0\u00a0if ( real ) \n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"true: \" << real.getValue() << \"\\n\";\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0else\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"false: \" << real.getValue() << \"\\n\";\n\u00a0\u00a0\u00a0\u00a0}\n}\n```", "```cpp\nexplicit operator float() {return m_value;}\n```", "```cpp\noperator bool() {return m_value == 0.0;}\n```", "```cpp\nexplicit operator bool() {return m_value == 0.0;}\n```", "```cpp\n    struct Voltage\n    {\n    \u00a0\u00a0\u00a0\u00a0explicit Voltage(float emf) : m_emf(emf) \n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0float m_emf;\n    };\n    ```", "```cpp\n    void calculate(Voltage& v)\n    ```", "```cpp\n    use_float(volts);\n    ```", "```cpp\n    operator float() const\n    {\n    \u00a0\u00a0\u00a0\u00a0return m_emf;\n    }\n    ```", "```cpp\n    use_float(static_cast<float>(volts));\n    ```"]