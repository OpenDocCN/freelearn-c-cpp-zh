- en: 5 Working with Geometry Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 与几何数据一起工作
- en: Join our book community on Discord
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 书籍社区
- en: '![](img/file40.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/file40.png)'
- en: '[https://packt.link/unitydev](https://packt.link/unitydev)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/unitydev](https://packt.link/unitydev)'
- en: Previously, we tried different ad hoc approaches to storing and handling 3D
    geometry data in our graphical applications. The mesh data layout for vertex and
    index buffers was hardcoded in each of our demo apps. This way it was easier to
    focus on other important parts of the graphics pipeline. As we go into the territory
    of more complex graphics applications, we require additional control over the
    storage of different 3D meshes in system memory and GPU buffers. However, our
    focus still remains on guiding you through the main principles and practices rather
    than on pure efficiency.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们尝试了不同的临时方法来存储和处理我们的图形应用程序中的 3D 几何数据。每个演示应用程序中的网格数据布局（顶点和索引缓冲区）都是硬编码的。这样，我们更容易关注图形管线中的其他重要部分。随着我们进入更复杂的图形应用程序领域，我们需要对系统内存和
    GPU 缓冲区中不同 3D 网格的存储有更多的控制。然而，我们的重点仍然是在指导您了解主要原理和实践，而不是纯粹的效率。
- en: 'In this chapter, we will learn how to store and handle mesh geometry data in
    a more organized way. We will cover the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何以更组织化的方式存储和处理网格几何数据。我们将涵盖以下食谱：
- en: Generating level-of-detail meshes using MeshOptimizer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 MeshOptimizer 生成细节级别网格
- en: Implementing programmable vertex pulling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现可编程顶点提取
- en: Rendering instanced geometry
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染实例几何
- en: Implementing instanced meshes with compute shaders
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用计算着色器实现实例网格
- en: Implementing an infinite grid GLSL shader
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现无限网格 GLSL 着色器
- en: Integrating tessellation into the graphics pipeline
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将细分集成到图形管线中
- en: Organizing the mesh data storage
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织网格数据存储
- en: Implementing automatic geometry conversion
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现自动几何转换
- en: Indirect rendering in Vulkan
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vulkan 中的间接渲染
- en: Generating textures in Vulkan using compute shaders
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用计算着色器在 Vulkan 中生成纹理
- en: Implementing computed meshes
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现计算网格
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: To run the code from this chapter on your Linux or Windows PC, you’ll require
    a GPU with up-to-date drivers that support Vulkan 1.3\. The source code can be
    downloaded from [https://github.com/PacktPublishing/3D-Graphics-Rendering-Cookbook](https://github.com/PacktPublishing/3D-Graphics-Rendering-Cookbook).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的 Linux 或 Windows PC 上运行本章的代码，您需要一个支持 Vulkan 1.3 的最新驱动程序的 GPU。源代码可以从 [https://github.com/PacktPublishing/3D-Graphics-Rendering-Cookbook](https://github.com/PacktPublishing/3D-Graphics-Rendering-Cookbook)
    下载。
- en: To run the demo applications from this chapter, you are advised to download
    and unpack the entire Amazon Lumberyard Bistro dataset from the McGuire Computer
    Graphics Archive [http://casual-effects.com/data/index.xhtml](http://casual-effects.com/data/index.xhtml).
    You can do it automatically by running the `deploy_deps.py` script.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章的演示应用程序，建议您从 McGuire 计算机图形档案 [http://casual-effects.com/data/index.xhtml](http://casual-effects.com/data/index.xhtml)
    下载并解压整个 Amazon Lumberyard Bistro 数据集。您可以通过运行 `deploy_deps.py` 脚本来自动完成此操作。
- en: Generating level-of-detail meshes using MeshOptimizer
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 MeshOptimizer 生成细节级别网格
- en: To get started with geometry manipulations, let’s implement a mesh geometry
    simplification demo using the MeshOptimizer library that, besides mesh optimizations,
    can generate simplified meshes for real-time discrete **level-of-detail** (**LOD**)
    algorithms we might want to use later. Simplification is an efficient way to improve
    rendering performance.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始进行几何操作，让我们实现一个使用 MeshOptimizer 库的网格几何简化演示，该库除了网格优化外，还可以生成简化网格，以便我们以后可能想要使用的实时离散
    **细节级别**（**LOD**）算法。简化是提高渲染性能的有效方法。
- en: For GPUs to render a mesh efficiently, all vertices in the vertex buffer should
    be unique and without duplicates. Solving this problem efficiently can be a complicated
    and computationally intensive task in any modern 3D content pipeline. MeshOptimizer
    is an open-source C++ library developed by Arseny Kapoulkine, which provides algorithms
    to help optimize meshes for modern GPU vertex and index processing pipelines.
    It can reindex an existing index buffer or generate an entirely new set of indices
    from an unindexed vertex buffer.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 GPU 高效地渲染网格，顶点缓冲区中的所有顶点都应该是唯一的，没有重复。在任何现代 3D 内容管线中，有效地解决这个问题可能是一个复杂且计算密集的任务。MeshOptimizer
    是由 Arseny Kapoulkine 开发的开源 C++ 库，它提供算法来帮助优化网格以适应现代 GPU 顶点和索引处理管线。它可以重新索引现有的索引缓冲区，或者从一个未索引的顶点缓冲区生成一组全新的索引。
- en: Let’s learn how to optimize and generate simplified meshes with MeshOptimizer.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何使用MeshOptimizer优化和生成简化网格。
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: It is recommended that you revisit *Chapter 3*, *Working with Vulkan Objects*.
    The complete source code for this recipe can be found in `Chapter05/01_MeshOptimizer`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您重新阅读*第3章*，*与Vulkan对象一起工作*。本菜谱的完整源代码可以在 `Chapter05/01_MeshOptimizer` 中找到。
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: '`MeshOptimizer` can generate all necessary LOD meshes for a specified set of
    indices and vertices. Once we have our loaded mesh with `Assimp`, we can pass
    it to `MeshOptimizer`. Here’s how to do it:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`MeshOptimizer` 可以为指定的索引和顶点集生成所有必要的LOD网格。一旦我们使用 `Assimp` 加载了网格，我们就可以将其传递给 `MeshOptimizer`。下面是如何做到这一点：'
- en: 'Let’s load a mesh from a `.gltf` file using `Assimp`. For this demo, we need
    only vertex positions and indices:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用 `Assimp` 从 `.gltf` 文件中加载一个网格。对于这个演示，我们只需要顶点位置和索引：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The LOD meshes are represented as a collection of indices that construct a
    new simplified mesh from the same vertices that are used for the original mesh.
    This way we have to store only one set of vertices and can render corresponding
    LODs just by switching index buffers data. As done previously, we store all indices
    as unsigned 32-bit integers for simplicity. Now we should generate a remap table
    for our existing vertex and index data:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LOD网格表示为索引集合，这些索引从用于原始网格的相同顶点构建一个新的简化网格。这样我们只需要存储一组顶点，并且可以通过切换索引缓冲区数据来渲染相应的LOD。像之前一样，我们为了简单起见，将所有索引存储为无符号32位整数。现在我们应该为现有的顶点和索引数据生成一个重映射表：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The MeshOptimizer documentation ([https://github.com/zeux/meshoptimizer](https://github.com/zeux/meshoptimizer))
    tells us the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: MeshOptimizer文档([https://github.com/zeux/meshoptimizer](https://github.com/zeux/meshoptimizer))告诉我们以下内容：
- en: '*“…the remap table is generated based on binary equivalence of the input vertices,
    so the resulting mesh will be rendered in the same way.”*'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“…重映射表是根据输入顶点的二进制等价性生成的，因此生成的网格将以相同的方式渲染。”*'
- en: 'The returned `vertexCount` value corresponds to the number of unique vertices
    that have remained after remapping. Let’s allocate space and generate new vertex
    and index buffers:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回的 `vertexCount` 值对应于重映射后保留的唯一顶点的数量。让我们分配空间并生成新的顶点和索引缓冲区：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now we can use other `MeshOptimizer` algorithms to optimize these buffers even
    further. The official documentation is pretty straightforward.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用其他 `MeshOptimizer` 算法进一步优化这些缓冲区。官方文档非常直接。
- en: 'When we want to render a mesh, the GPU has to transform each vertex via a vertex
    shader. GPUs can reuse transformed vertices by means of a small built-in cache,
    usually storing between 16 and 32 vertices inside it. In order to use this small
    cache effectively, we need to reorder the triangles to maximize the locality of
    vertex references. How to do this with `MeshOptimizer` in place is shown next.
    Pay attention to how only the indices data is being touched here:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们想要渲染一个网格时，GPU必须通过顶点着色器转换每个顶点。GPU可以通过内置的小缓存来重用转换后的顶点，通常在内部存储16到32个顶点。为了有效地使用这个小缓存，我们需要重新排序三角形以最大化顶点引用的局部性。如何在
    `MeshOptimizer` 中实现这一点将在下面展示。请注意，这里只接触到了索引数据：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Transformed vertices form triangles that are sent for rasterization to generate
    fragments. Usually, each fragment is run through a depth test first, and fragments
    that pass the depth test get the fragment shader executed to compute the final
    color. As fragment shaders get more and more expensive, it becomes increasingly
    important to reduce the number of fragment shader invocations. This can be achieved
    by reducing pixel overdraw in a mesh, and, in general, it requires the use of
    view-dependent algorithms. However, `MeshOptimizer` implements heuristics to reorder
    triangles and minimize overdraw from all directions. We can use it as follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转换后的顶点形成三角形，被发送进行光栅化以生成片段。通常，每个片段首先通过深度测试，通过深度测试的片段将执行片段着色器以计算最终颜色。由于片段着色器变得越来越昂贵，减少片段着色器调用的数量变得越来越重要。这可以通过减少网格中的像素过度绘制来实现，并且通常需要使用视图相关算法。然而，`MeshOptimizer`
    实现了启发式算法来重新排序三角形并最小化来自各个方向的过度绘制。我们可以如下使用它：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The last parameter, `1.05`, is the threshold that determines how much the algorithm
    can compromise the vertex cache hit ratio. We use the recommended default value
    from the documentation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个参数，`1.05`，是确定算法可以妥协顶点缓存命中率的阈值。我们使用文档中推荐的默认值。
- en: 'Once we have optimized the mesh to reduce pixel overdraw, the vertex buffer
    access pattern can still be optimized for memory efficiency. The GPU has to fetch
    specified vertex attributes from the vertex buffer and pass this data into the
    vertex shader. To speed up this fetch, a memory cache is used, which means optimizing
    the locality of vertex buffer access is very important. We can use MeshOptimizer
    to optimize our index and vertex buffers for vertex fetch efficiency, as follows:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们将网格优化以减少像素过度绘制，顶点缓冲区访问模式仍然可以优化以提高内存效率。GPU必须从顶点缓冲区获取指定的顶点属性并将这些数据传递到顶点着色器。为了加快此获取过程，使用了一个内存缓存，这意味着优化顶点缓冲区访问的局部性非常重要。我们可以使用MeshOptimizer来优化我们的索引和顶点缓冲区以实现顶点获取效率，如下所示：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This function will reorder vertices in the vertex buffer and regenerate indices
    to match the new contents of the vertex buffer.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将重新排序顶点缓冲区中的顶点并重新生成索引以匹配顶点缓冲区的新内容。
- en: 'The last thing we will do in this recipe is simplify the mesh. MeshOptimizer
    can generate a new index buffer that uses existing vertices from the vertex buffer
    with a reduced number of triangles. This new index buffer can be used to render
    LOD meshes. The following code snippet shows you how to do this using the default
    threshold and target error values:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将要做的最后一件事是简化网格。MeshOptimizer 可以生成一个新的索引缓冲区，它使用顶点缓冲区中的现有顶点，并减少三角形数量。这个新的索引缓冲区可以用来渲染LOD网格。以下代码片段展示了如何使用默认的阈值和目标误差值来完成这个操作：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now let’s take a look at how rendering of the LOD meshes works.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看LOD网格的渲染是如何工作的。
- en: How it works…
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In order to render the mesh and its lower-level LOD, we need to store a vertex
    buffer and two index buffers – one for the mesh and one for the LOD:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了渲染网格及其低级LOD，我们需要存储一个顶点缓冲区和两个索引缓冲区——一个用于网格，一个用于LOD：
- en: 'Here’s the vertex buffer for storing vertex positions:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是存储顶点位置的顶点缓冲区：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We use two index buffers to store both sets of indices:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用两个索引缓冲区来存储两组索引：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The rendering part is trivial, and the graphics pipeline setup is skipped here
    for the sake of brevity. We render the main mesh using the first index buffer:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染部分很简单，为了简洁起见，这里省略了图形管线设置。我们使用第一个索引缓冲区渲染主网格：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then we render the LOD mesh using the second index buffer:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们使用第二个索引缓冲区渲染LOD网格：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here’s a screenshot from the running demo application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是运行中的演示应用程序的屏幕截图。
- en: '![Figure 5.1: A mesh with a discrete LOD](img/file31.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1：具有离散LOD的网格](img/file31.png)'
- en: 'Figure 5.1: A mesh with a discrete LOD'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：具有离散LOD的网格
- en: Try changing the `threshold` parameter in the code to generate meshes with different
    LOD.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在代码中更改 `threshold` 参数以生成具有不同LOD的网格。
- en: There’s more...
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `MeshOptimizer` library contains many other useful algorithms, such as triangle
    strip generation, index and vertex buffer compression, and mesh animation data
    compression. All of these algorithms might be very useful for your geometry preprocessing
    stage depending on the kind of graphics software you are writing. Check out the
    official documentation and the releases page to get the latest features at [https://github.com/zeux/meshoptimizer](https://github.com/zeux/meshoptimizer).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`MeshOptimizer` 库包含许多其他有用的算法，例如三角形带生成、索引和顶点缓冲区压缩以及网格动画数据压缩。所有这些算法可能对你的几何预处理阶段非常有用，具体取决于你正在编写的图形软件类型。查看官方文档和发布页面，以获取最新的功能，请访问
    [https://github.com/zeux/meshoptimizer](https://github.com/zeux/meshoptimizer)。'
- en: In *Chapter 9*, *Advanced Rendering Techniques and Optimization*, we will learn
    how to render LODs in a GPU-friendly and performant way.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第9章*，*高级渲染技术和优化* 中，我们将学习如何以GPU友好和高效的方式渲染LOD。
- en: Implementing programmable vertex pulling
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现可编程顶点拉取
- en: The concept of **programmable vertex pulling** (**PVP**) was proposed in an
    article called *Introducing the Programmable Vertex Pulling Rendering Pipeline*
    by Daniel Rákos, published in the amazing book *OpenGL Insights* in 2012\. That
    article goes deep into the architecture of GPUs of that time and why it was beneficial
    to use this data storage approach. Initially, the idea of vertex pulling was to
    store vertex data inside one-dimensional buffer textures and, instead of setting
    up standard vertex input bindings. Then read the data using `texelFetch()` and
    GLSL `samplerBuffer` in the vertex shader. The built-in OpenGL GLSL `gl_VertexID`
    variable was used as an index to calculate texture coordinates for texel fetching.
    The reason for this trick was that because developers were hitting CPU limits
    with many draw calls, it was beneficial to combine multiple meshes inside a single
    buffer and render them in a single draw call without rebinding any vertex arrays
    or buffer objects to improve the batching of draw calls.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**可编程顶点提取**（**PVP**）的概念是在Daniel Rákos发表的一篇文章《介绍可编程顶点提取渲染管线》中提出的，这篇文章发表在2012年出版的令人惊叹的书籍《OpenGL
    Insights》中。该文章深入探讨了当时GPU的架构以及为什么使用这种数据存储方法是有益的。最初，顶点提取的想法是将顶点数据存储在一维缓冲区纹理中，而不是设置标准的顶点输入绑定。然后在顶点着色器中使用`texelFetch()`和GLSL
    `samplerBuffer`读取数据。内置的OpenGL GLSL `gl_VertexID`变量被用作索引来计算用于纹理提取的纹理坐标。这种技巧的原因是，由于开发者遇到了许多draw调用时的CPU限制，将多个网格合并到单个缓冲区中并在单个draw调用中渲染它们，而不需要重新绑定任何顶点数组或缓冲区对象，这有助于提高draw调用的批处理。'
- en: Nowadays, buffer textures are no longer required and the vertex data can be
    fetched directly from storage or uniform buffers using offsets calculated via
    the built-in Vulkan GLSL `gl_VertexIndex` variable.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，缓冲区纹理不再需要，顶点数据可以直接从存储或统一缓冲区中通过内置的Vulkan GLSL `gl_VertexIndex`变量计算出的偏移量来获取。
- en: This technique opens up possibilities for merge-instancing, where many small
    meshes can be merged into a bigger one to be handled as a part of the same batch.
    We will extensively use this technique in our examples starting from *Chapter
    7*, *Graphics Rendering Pipeline*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术为合并实例化提供了可能性，其中许多小网格可以合并成一个更大的网格，作为同一批次的处理部分。从*第7章*，*图形渲染管线*开始，我们将广泛使用这种技术。
- en: In this recipe, we will use storage buffers to implement a similar technique
    with Vulkan 1.3 and *LightweightVK*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用存储缓冲区来实现与Vulkan 1.3和*LightweightVK*类似的技巧。
- en: Getting ready
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: The complete source code for this recipe can be found in the source code bundle
    under the name `Chapter05/02_VertexPulling`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方完整的源代码可以在源代码包中找到，名称为`Chapter05/02_VertexPulling`。
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let’s render the rubber duck 3D model `data/rubber_duck/scene.gltf` from the
    previous recipe. However, this time, instead of using vertex attributes, we will
    be using the programmable vertex-pulling technique. The idea is to allocate two
    buffers, one buffer for indices and another storage buffer for the vertex data,
    and access them in the vertex shader to fetch vertex positions. This is how we
    can do it:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们渲染之前配方中的橡胶鸭3D模型`data/rubber_duck/scene.gltf`。然而，这次，我们不会使用顶点属性，而是将使用可编程顶点提取技术。想法是分配两个缓冲区，一个用于索引，另一个用于存储顶点数据的缓冲区，并在顶点着色器中访问它们以获取顶点位置。这就是我们如何做到这一点：
- en: 'First, we load the 3D model via `Assimp`, as in the previous recipe:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们通过`Assimp`加载3D模型，就像之前的配方中那样：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Convert per-vertex data into a format suitable for our GLSL shaders. We are
    going to use `vec3` for positions and `vec2` for texture coordinates:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每顶点数据转换为适合我们GLSL着色器的格式。我们将使用`vec3`表示位置和`vec2`表示纹理坐标：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For simplicity, we store indices as unsigned 32-bit integers. In real-world
    applications, consider using 16-bit indices for small meshes and be capable of
    switching between them:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了简单起见，我们将索引存储为无符号32位整数。在实际应用中，考虑使用16位索引来处理小网格，并能够在这两者之间切换：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once the index and vertex data are ready, we can upload them into the Vulkan
    buffers. We should create two buffers, one for the vertices and one for the indices.
    Not that here, despite calling it a vertex buffer, we set the usage flag to `lvk::BufferUsageBits_Storage`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦索引和顶点数据准备就绪，我们就可以将它们上传到Vulkan缓冲区。我们应该创建两个缓冲区，一个用于顶点，一个用于索引。注意，在这里，尽管称之为顶点缓冲区，但我们设置了使用标志为`lvk::BufferUsageBits_Storage`：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now we can create a render pipeline for our mesh. We will look into the shader
    code in a few moments:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以为我们的网格创建一个渲染管线。我们将在几分钟后查看着色器代码：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let’s load a texture for our mesh and create a proper depth state:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为我们的网格加载一个纹理并创建适当的深度状态：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Before we can proceed with the actual rendering, we should pass the texture
    ID and storage buffer address to our GLSL shader. We can do it using Vulkan push
    constants. Model-view-projection matrix calculations are reused from the previous
    recipe.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们进行实际渲染之前，我们应该将纹理ID和存储缓冲区地址传递给我们的GLSL着色器。我们可以使用Vulkan推送常量来完成此操作。模型视图投影矩阵的计算是从之前的配方中复用的。
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, the mesh rendering can done as follows.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，网格渲染可以按照以下方式进行。
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The rest of the C++ code can be found in `Chapter05/02_VertexPulling/src/main.cpp`.
    Now, we have to look into the GLSL vertex shader to understand how to read the
    vertex data from buffers. The vertex shader can be found in `Chapter05/02_VertexPulling/src/main.vert`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的C++代码可以在`Chapter05/02_VertexPulling/src/main.cpp`中找到。现在，我们必须查看GLSL顶点着色器，以了解如何从缓冲区中读取顶点数据。顶点着色器位于`Chapter05/02_VertexPulling/src/main.vert`：
- en: First, we have some declarations shared between all shaders. The reason for
    this sharing is that our fragment shader needs to access push constants to retrieve
    the texture ID. Note that the `Vertex` structure does not use `vec2` and `vec3`
    member fields to maintain tight padding and prevent any GPU alignment issues.
    This structure reflects how our C++ code writes vertex data into the buffer. The
    buffer holds an unbounded array `in_Vertices[]`. Each element corresponds to exactly
    one vertex.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们有一些在所有着色器之间共享的声明。这样做的原因是我们的片段着色器需要访问推送常量以检索纹理ID。请注意，`Vertex`结构不使用`vec2`和`vec3`成员字段来保持紧密填充并防止任何GPU对齐问题。这个结构反映了我们的C++代码如何将顶点数据写入缓冲区。该缓冲区包含一个无界数组`in_Vertices[]`。每个元素正好对应一个顶点。
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let’s introduce two accessor functions to make the shader code more readable.
    The assemble `vec3` and `vec2` values are from the raw float values in the storage
    buffer.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们引入两个访问器函数，使着色器代码更易于阅读。组装`vec3`和`vec2`值来自存储缓冲区中的原始浮点值。
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The rest of the shader is trivial. The previously mentioned functions are used
    to load the vertex positions and texture coordinates, which are passed further
    into the graphics pipeline.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 剩余的着色器部分很简单。之前提到的函数用于加载顶点位置和纹理坐标，这些坐标随后被传递到图形管线中。
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'That’s it for the PVP part. The fragment shader applies the texture and uses
    the barycentric coordinates trick for wireframe rendering as was described in
    the previous chapter. The resulting output from the program should look like the
    following screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: PVP部分的介绍就到这里。片段着色器应用纹理，并使用前一章中描述的加权坐标技巧进行线框渲染。程序输出的结果应该看起来像以下截图：
- en: '![Figure 5.2: Textured mesh rendering using PVP](img/file32.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2：使用PVP进行纹理网格渲染](img/file32.png)'
- en: 'Figure 5.2: Textured mesh rendering using PVP'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：使用PVP进行纹理网格渲染
- en: There’s more...
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: PVP is a complex topic and has different performance implications. There is
    an open-source project that does an in-depth analysis and run-time metrics of
    PVP performance based on different vertex data layouts and access methods, such
    as storing data as an array of structures or a structure of arrays, reading data
    as multiple floats or a single vector type, and so on. Check it out at [https://github.com/nlguillemot/ProgrammablePulling](https://github.com/nlguillemot/ProgrammablePulling).
    It should become one of your go-to tools when designing PVP pipelines in your
    applications.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: PVP是一个复杂的话题，并且有不同的性能影响。有一个开源项目对PVP性能进行了深入分析，并基于不同的顶点数据布局和访问方法，如将数据存储为结构数组或数组结构，以多个浮点数或单个向量类型读取数据等，进行了运行时度量。您可以在[https://github.com/nlguillemot/ProgrammablePulling](https://github.com/nlguillemot/ProgrammablePulling)查看它。当您在设计应用程序中的PVP管线时，它应该成为您的首选工具之一。
- en: Rendering instanced geometry
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染实例化几何体
- en: A common task in geometry rendering is drawing multiple meshes that share the
    same geometry but have different transformations and materials. This can lead
    to additional CPU overhead in generating all the necessary commands to instruct
    the GPU to draw each mesh individually. It occurs even though the Vulkan API already
    has significantly lower CPU overhead. One possible solution to this problem, provided
    by modern graphics APIs such as Vulkan, is instanced rendering. API draw commands
    can take a number of instances as a parameter and a vertex shader has access to
    the current instance number `gl_InstanceIndex`. Combined with the PVP approach
    demonstrated in the previous recipe, this technique can become incredibly flexible.
    Indeed, `gl_InstanceIndex` can be used to read all necessary material properties,
    transforms, and other data from buffers. Let’s take a look at a basic instanced
    geometry demo to learn how to do it in Vulkan.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 几何渲染中的一项常见任务是绘制多个具有相同几何形状但具有不同变换和材质的网格。这可能导致生成所有必要命令以指导GPU单独绘制每个网格的CPU开销增加。尽管Vulkan
    API已经具有显著较低的CPU开销，但这种情况仍然会发生。现代图形API（如Vulkan）提供的一个可能的解决方案是实例渲染。API绘制命令可以接受多个实例作为参数，顶点着色器可以访问当前的实例编号`gl_InstanceIndex`。结合前一个配方中演示的PVP方法，这种技术可以变得非常灵活。实际上，`gl_InstanceIndex`可以用来从缓冲区中读取所有必要的材质属性、变换和其他数据。让我们看看一个基本的实例几何演示，以了解如何在Vulkan中实现它。
- en: Getting ready
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure to read the previous recipe, *Implementing programmable vertex pulling*,
    to understand the notion of generating vertices data inside vertex shaders. The
    source code for this recipe can be found in `Chapter05/03_MillionCubes`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 确保阅读之前的配方，*实现可编程顶点提取*，以了解在顶点着色器内部生成顶点数据的概念。这个配方的源代码可以在`Chapter05/03_MillionCubes`中找到。
- en: How to do it…
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To demonstrate how instanced rendering can work, let’s render 1 million colored
    rotating cubes. Each cube should have its own distinct rotation angle around its
    diagonal and should be textured with an overlay of one of a few different colors.
    Let’s take a look at the C++ code in `03_MillionCubes/src/main.cpp`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示实例渲染如何工作，让我们渲染一百万个带有颜色的旋转立方体。每个立方体都应该围绕其对角线有一个独特的旋转角度，并且应该用几种不同颜色之一进行纹理覆盖。让我们看看`03_MillionCubes/src/main.cpp`中的C++代码：
- en: First, let’s generate a procedural texture for our cubes. An XOR pattern texture
    looks quite interesting. It is generated by XOR-ing the `x` and `y` coordinates
    of the current texel and then applying the result to all three BGR channels by
    bitshifts.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们为我们的立方体生成一个程序纹理。一个异或模式纹理看起来相当有趣。它是通过异或当前纹理单元的`x`和`y`坐标，然后将结果通过位移应用到所有三个BGR通道中生成的。
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Let’s create `vec3` positions and `float` initial rotation angles for 1 million
    cubes. We can organize this data into `vec4` containers and store them in an immutable
    storage buffer. The GLSL shader code will then perform calculations based on the
    elapsed time.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为100万个立方体创建`vec3`位置和`float`初始旋转角度。我们可以将这些数据组织到`vec4`容器中，并将它们存储在一个不可变存储缓冲区中。然后GLSL着色器代码将根据经过的时间进行计算。
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We skip the traditional framebuffer and pipeline creation code and jump straight
    into the main rendering loop. The camera motion is hardcoded so it moves back
    and forth through the swarm of the cubes.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们跳过了传统的帧缓冲区和管线创建代码，直接进入主渲染循环。摄像机运动是硬编码的，所以它会通过立方体的群移动来来回回。
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We pass all the necessary data to shaders using push constants. Our vertex shader
    is going to need the current time to do the calculations based on the initial
    cube positions and rotations.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用推送常数将所有必要的数据传递给着色器。我们的顶点着色器将需要当前时间来根据初始立方体位置和旋转进行计算。
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Rendering is started via `vkCmdDraw()`, which hides inside `cmdDraw()`. The
    first parameter is the number of vertices we need to generate a cube using triangle
    primitives. We will look at how it is handled in the vertex shader in a moment.
    The second parameter, `kNumCubes`, is the number of instances to be rendered.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染是通过`vkCmdDraw()`开始的，它隐藏在`cmdDraw()`中。第一个参数是我们需要生成一个立方体所使用的三角形原语的数量。我们稍后会看看它在顶点着色器中的处理方式。第二个参数`kNumCubes`是要渲染的实例数量。
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now let’s take a look at the GLSL code to understand how this instancing demo
    works under the hood.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看GLSL代码，以了解这个实例演示在底层是如何工作的。
- en: How it works…
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Our vertex shader starts by declaring the same `PerFrameData` structure as in
    our C++ code mentioned above. The shader outputs per-vertex color and texture
    coordinates. The storage buffer contains positions and initial angles for all
    the cubes.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的顶点着色器首先声明与上面提到的C++代码中相同的 `PerFrameData` 结构。着色器输出每个顶点的颜色和纹理坐标。存储缓冲区包含所有立方体的位置和初始角度。
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you may have noticed, the C++ code in the *How to do it…* section did not
    provide any index data to shaders. Instead, we a going to generate vertex data
    in the vertex shader. Let’s declare indices mapping right here. We need indices
    to construct `6` cube faces using triangles. Two triangles per face gives `6`
    points per face and `36` indices in total. That is the number passed to `vkCmdDraw()`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，*如何做…* 部分的C++代码没有向着色器提供任何索引数据。相反，我们将在顶点着色器中生成顶点数据。让我们在这里声明索引映射。我们需要索引来使用三角形构造
    `6` 个立方体面。每个面两个三角形给出每个面的 `6` 个点，总共 `36` 个索引。这是传递给 `vkCmdDraw()` 的索引数。
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here are the per-instance colors for our cubes.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是我们立方体的每个实例的颜色。
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As there are no translation and rotation matrices passed to the vertex shader,
    we have to generate everything ourselves right here. Here’s a GLSL function to
    apply a translation by a vector `v` to the current transformation `m`. This function
    is a counterpart to the C++ function `glm::translate()`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于没有传递给顶点着色器的平移和旋转矩阵，我们不得不在这里自己生成一切。这是一个GLSL函数，用于将向量 `v` 的平移应用于当前变换 `m`。这个函数是C++函数
    `glm::translate()` 的对应物。
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Rotations are handled in a similar way. This is an analogue of `glm::rotate()`
    ported to GLSL.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旋转以类似的方式处理。这是将 `glm::rotate()` 端口到GLSL的类似物。
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: With this extensive arsenal at our disposal, we can now write the `main()` function
    of our vertex shader. The built-in `gl_InstanceIndex` variable is used to index
    the storage buffer and retrieve positions and angles. Then, a model matrix for
    the current cube is computed using the `rotate()` and `translate()` helper functions.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了这个广泛的工具集，我们可以编写顶点着色器的 `main()` 函数。内置的 `gl_InstanceIndex` 变量用于索引存储缓冲区并检索位置和角度。然后，使用
    `rotate()` 和 `translate()` 辅助函数计算当前立方体的模型矩阵。
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The built-in `gl_VertexIndex` variable ranges from `0` to `35`, helping us extract
    the specific index for `8` of our vertices. Then we use this simple binary formula
    to generate `vec3` positions for each of those `8` vertices.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内置的 `gl_VertexIndex` 变量从 `0` 到 `35`，帮助我们提取出我们顶点的特定索引。然后我们使用这个简单的二进制公式为这 `8`
    个顶点中的每一个生成 `vec3` 位置。
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Remap the `0...1` vertex coordinates into the `-1…+1` coordinates and scale
    by the desired `edge` length:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `0...1` 的顶点坐标重新映射到 `-1…+1` 的坐标，并按所需的 `边长` 缩放：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The UV coordinates are selected on a per-face basis, and the colors are per
    instance:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: UV坐标是按面选择的，颜色是按实例分配的：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'That’s all the magic that happens in the vertex shader. The fragment shader
    is pretty trivial and short:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶点着色器中发生的所有魔法就这些。片段着色器相当简单且简短：
- en: '[PRE36]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The running demo should look as in the following screenshot. You are flying
    through a swarm of 1 million cubes:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 运行中的演示应该看起来如下截图所示。你正在飞越一百万个立方体的群体：
- en: '![Figure 5.3: One million cubes using instanced rendering](img/file33.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3：使用实例渲染的一百万个立方体](img/file33.png)'
- en: 'Figure 5.3: One million cubes using instanced rendering'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：使用实例渲染的一百万个立方体
- en: There’s more…
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: While this example is self-contained and very fast compared to non-instanced
    rendering, it can be made even faster if the indices are moved out of the vertex
    shader and stored in a dedicated index buffer to take advantage of the hardware
    vertex cache and model matrices are calculated per-instance and not per-vertex.
    We will cover this in the next recipe.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子是自包含的，并且与非实例渲染相比非常快，但如果将索引移出顶点着色器并存储在专用索引缓冲区中，以利用硬件顶点缓存，并且模型矩阵是按实例而不是按顶点计算的，它还可以更快。我们将在下一个菜谱中介绍这一点。
- en: Now let’s extend this instancing example a bit further and draw some meshes
    using real mesh data.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将这个实例化示例扩展得更进一步，并使用真实的网格数据绘制一些网格。
- en: Implementing instanced meshes with compute shaders
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用计算着色器实现实例网格
- en: In the last recipe, we learned the fundamentals of instanced rendering. Although
    that approach covers various aspects of rendering geometry instances, such as
    handling model matrices and materials, it’s not yet a practical implementation.
    Let’s expand on that example and demonstrate how to render instanced meshes loaded
    from a `.gltf` file.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个食谱中，我们学习了实例渲染的基础知识。尽管那种方法涵盖了渲染几何体实例的各个方面，例如处理模型矩阵和材质，但这还不是一种实用的实现。让我们扩展这个例子，并演示如何渲染从`.gltf`文件加载的实例网格。
- en: To add a bit more complexity to this example, we’ll enhance it by precalculating
    per-instance model matrices using a compute shader.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给这个例子增加一点复杂性，我们将通过使用计算着色器预先计算每个实例的模型矩阵来增强它。
- en: Getting ready
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you read the previous recipe, *Rendering instanced geometry*. The
    source code for this recipe can be found in `Chapter05/04_InstancedMeshes`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经阅读了之前的食谱，*渲染实例几何体*。这个食谱的源代码可以在`Chapter05/04_InstancedMeshes`中找到。
- en: How to do it…
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let’s skim the C++ code to understand the big picture
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速浏览一下C++代码，以了解整体情况。
- en: First, we generate random positions and initial rotation angles for our meshes.
    We use 32,000 meshes because our GPU cannot handle 1 million meshes with this
    naïve brute-force approach. Pushing it to 1 million meshes is possible, and we
    will show some tricks to approach that number in *Chapter 11*, *Advanced Rendering
    Techniques and Optimizations*.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们为我们的网格生成随机位置和初始旋转角度。我们使用32,000个网格，因为我们的GPU无法处理使用这种原始的暴力方法处理一百万个网格。将其推至一百万个网格是可能的，我们将在*第11章*，*高级渲染技术和优化*中展示一些接近这个数字的技巧。
- en: '[PRE37]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The center points and angles are loaded into a storage buffer in exactly the
    same way as in the previous recipe:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中心点和角度以与上一个食谱完全相同的方式加载到存储缓冲区中：
- en: '[PRE38]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: To store model matrices for our instances, we’ll require two buffers. We’ll
    alternate between them in a round-robin fashion during even and odd frames to
    prevent unnecessary synchronization.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了存储我们实例的模型矩阵，我们需要两个缓冲区。在偶数帧和奇数帧之间，我们将以轮询的方式交替使用它们，以防止不必要的同步。
- en: '[PRE39]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The rubber duck 3D model is loaded from `.gltf` the following way. This time,
    besides vertex positions and texture coordinates, we require normal vectors to
    do some improvized lighting. We are going to need it when we render so many meshes.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 橡皮鸭3D模型以下列方式从`.gltf`加载。这次，除了顶点位置和纹理坐标外，我们还需要法向量来进行一些即兴的照明。当我们渲染这么多网格时，我们将需要它。
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The mesh data is uploaded into index and vertex buffers:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网格数据被上传到索引和顶点缓冲区：
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Let’s load the texture and create compute and rendering pipelines. The compute
    shader will generate model matrices for our instances based on the elapsed time,
    following the approach used in the vertex shader in the previous recipe, *Rendering
    instanced meshes*. However, this time, we’ll do it on a per-instance basis instead
    of per vertex.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们加载纹理并创建计算和渲染管线。计算着色器将根据已过时间生成我们实例的模型矩阵，遵循在之前食谱*渲染实例网格*中使用的顶点着色器的方法。然而，这次，我们将基于每个实例而不是每个顶点来执行。
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The main loop goes like this. We use the `frameId` counter to facilitate the
    switching of buffers containing model matrices between even and odd frames.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主循环是这样的。我们使用`frameId`计数器来促进在偶数帧和奇数帧之间切换包含模型矩阵的缓冲区。
- en: '[PRE43]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'For convenience, push constants are shared between compute and rendering pipelines:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了方便起见，推送常数在计算和渲染管线之间共享：
- en: '[PRE44]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Dispatch the compute shader. Each local workgroup handles 32 meshes – a common
    portable baseline supported by many GPUs:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分发计算着色器。每个本地工作组处理32个网格——许多GPU支持的常见便携式基线：
- en: '[PRE45]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: After the compute shader has finished updating model matrices, we can start
    rendering. Note that we have a non-empty dependencies parameter here, which refers
    to the buffer with model matrices. This is necessary to make sure a proper Vulkan
    buffer memory barrier is issued by *LightweightVK* to prevent race conditions
    between the compute shader and the vertex shader.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算着色器完成更新模型矩阵后，我们可以开始渲染。请注意，这里有一个非空的依赖参数，它指的是包含模型矩阵的缓冲区。这是必要的，以确保*LightweightVK*发出适当的Vulkan缓冲区内存屏障，以防止计算着色器和顶点着色器之间的竞态条件。
- en: '[PRE46]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now let’s look at the barrier. The source and destination stages, respectively,
    are:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看屏障。源和目标阶段分别是：
- en: '[PRE47]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 并且：
- en: '[PRE48]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The underlying Vulkan barrier looks as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 基础的Vulkan屏障如下所示：
- en: '[PRE49]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The rest of the rendering code is pretty standard. The *LightweightVK* draw
    call command, `cmdDrawIndexed()`, takes the number of indices in our mesh and
    the number of instances `kNumMeshes`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染代码的其余部分相当标准。*LightweightVK* 绘制调用命令 `cmdDrawIndexed()` 接收我们网格中的索引数量和实例数量 `kNumMeshes`。
- en: '[PRE50]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, let’s delve into the GLSL implementation details to understand how it works
    internally.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解 GLSL 的实现细节，以了解其内部工作原理。
- en: How it works…
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The first part is the compute shader, which prepares data for rendering. Let’s
    take a look at `Chapter05/04_InstancedMeshes/src/main.comp`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是计算着色器，它为渲染准备数据。让我们看看 `Chapter05/04_InstancedMeshes/src/main.comp`：
- en: 'The compute shader processes 32 meshes in one local workgroup. Push constants
    are shared between the compute shader and the graphics pipeline. They are declared
    in an include file, `Chapter05/04_InstancedMeshes/src/common.sp`. We provide that
    file here for your convenience:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算着色器在一个局部工作组中处理 32 个网格。常量推送在计算着色器和图形管线之间共享。它们在包含文件 `Chapter05/04_InstancedMeshes/src/common.sp`
    中声明。我们在此提供该文件以供您方便使用：
- en: '[PRE51]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The matrices buffer reference declaration is not shared. Here, in the compute
    shader, it is declared as `writeonly`, while the vertex shader will declare it
    as `readonly`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 矩阵缓冲区引用声明不共享。在这里，在计算着色器中，它被声明为 `writeonly`，而顶点着色器将声明为 `readonly`。
- en: '[PRE52]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Helper functions `translate()` and `rotate()` mimic the `glm::translate()` and
    `glm::rotate()` C++ functions in GLSL. They are reused from the previous recipe,
    *Rendering instanced geometry*, in their entirety. As they are quite long, we
    will not duplicate them here.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 辅助函数 `translate()` 和 `rotate()` 模仿 GLSL 中的 `glm::translate()` 和 `glm::rotate()`
    C++ 函数。它们从先前的菜谱 *Rendering instanced geometry* 完整地重用。由于它们相当长，我们在此不会重复它们。
- en: '[PRE53]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `main()` function reads a `vec4` value containing the center point and initial
    angle, and calculates a model matrix. This is exactly the same computation we
    did in the vertex shader in the previous recipe. The model matrix is then stored
    in a storage buffer referenced by `bufMatricesId`.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main()` 函数读取包含中心点和初始角度的 `vec4` 值，并计算模型矩阵。这正是我们在先前的菜谱中顶点着色器中做的相同计算。然后，模型矩阵存储在由
    `bufMatricesId` 引用的存储缓冲区中。'
- en: '[PRE54]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As we moved most of the calculations into the compute shader, the shaders for
    the rendering pipeline became significantly shorter.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将大部分计算移动到了计算着色器中，渲染管线的着色器变得显著更短。
- en: 'The vertex shader uses the same shared declarations for push constants and
    buffer references:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶点着色器使用相同的共享声明用于常量推送和缓冲区引用：
- en: '[PRE55]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The vertex data contains normal vectors, as was declared in the C++ code earlier
    in this recipe:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶点数据包含法向量，正如在前面菜谱中用 C++ 代码声明的：
- en: '[PRE56]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The vertex data is retrieved from the “vertex” storage buffer, and the model
    matrix is obtained from the matrices buffer, which was updated by the compute
    shader:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶点数据从“vertex”存储缓冲区检索，模型矩阵从矩阵缓冲区获得，该缓冲区由计算着色器更新：
- en: '[PRE57]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now we can calculate the value of `gl_Position` and pass the normal vector
    and texture coordinates to our fragment shader:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以计算 `gl_Position` 的值，并将法向量和纹理坐标传递给我们的片段着色器：
- en: '[PRE58]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The fragment shader is quite straightforward. We perform some improvized diffuse
    lighting calculations to enhance the distinctiveness of the meshes:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 片段着色器相当直接。我们执行一些即兴的漫反射光照计算，以增强网格的区分度：
- en: '[PRE59]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The running demo application should render a swarm of rotating rubber ducks,
    as shown in the following screenshot, while the camera flies through them.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 运行的演示应用程序应该渲染一群旋转的橡皮鸭，如图下截图所示，同时摄像机穿越其中。
- en: '![Figure 5.4: A swarm of rotating rubber ducks using instanced rendering](img/file34.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4：使用实例渲染的旋转橡皮鸭群](img/file34.png)'
- en: 'Figure 5.4: A swarm of rotating rubber ducks using instanced rendering'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4：使用实例渲染的旋转橡皮鸭群
- en: There’s more…
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多…
- en: As you may have noticed, this demo utilizes only `32,768` instances compared
    to `1` million instances in the previous recipe. The reason for this difference
    is that the cube used in the previous example had only `36` indices, while the
    rubber duck model in this case has `33,216`, which is almost 1,000 times more.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所注意到的，这个演示只使用了 `32,768` 个实例，而先前的菜谱中使用了 `1` 百万个实例。这种差异的原因是，先前的示例中使用的立方体只有 `36`
    个索引，而在这个案例中的橡皮鸭模型有 `33,216`，几乎是前者的 1,000 倍。
- en: The naive brute force approach won’t suffice for this dataset. We need to employ
    additional tricks to render `1` million duckies, such as culling and GPU-level-of-detail
    management. We’ll delve into some of these topics in *Chapter 11*, *Advanced Rendering
    Techniques and Optimizations*.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个数据集，简单的暴力方法是不够的。我们需要采用额外的技巧来渲染 `1` 百万只鸭子，例如剔除和 GPU 级别细节管理。我们将在 *第 11 章*，*高级渲染技术和优化*
    中深入研究一些这些主题。
- en: Now, let’s switch gears and learn how to render some debug grid geometry before
    proceeding with examples of more complex mesh rendering.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转换一下思路，学习如何在继续更复杂的网格渲染示例之前渲染一些调试网格几何形状。
- en: Implementing an infinite grid GLSL shader
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现无限网格 GLSL 着色器
- en: In the previous recipes of this chapter, we learned how to approach geometry
    rendering. To debug our applications, it is useful to have a visible representation
    of the coordinate system so that a viewer can quickly infer the camera orientation
    and position just by looking at a rendered image. A natural way to represent a
    coordinate system in the image is to render an infinite grid where the grid plane
    is aligned with one of the coordinate planes. Let’s learn how to implement a decent-looking
    grid in GLSL.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面的食谱中，我们学习了如何处理几何渲染。为了调试我们的应用程序，有一个可见的坐标系表示是有用的，这样观众可以通过查看渲染图像快速推断摄像机的方向和位置。在图像中表示坐标系的一种自然方式是渲染一个无限网格，其中网格平面与坐标平面之一对齐。让我们学习如何在
    GLSL 中实现一个看起来不错的网格。
- en: Getting ready
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: The full C++ source code for this recipe can be found in `Chapter05/05_Grid`.
    The corresponding GLSL shaders will be reused in subsequent recipes, so they are
    located in the shared data folder in the `data/shaders/Grid.vert` and `data/shaders/Grid.frag`
    files.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的完整 C++ 源代码可以在 `Chapter05/05_Grid` 中找到。相应的 GLSL 着色器将在后续食谱中重用，因此它们位于共享数据文件夹中的
    `data/shaders/Grid.vert` 和 `data/shaders/Grid.frag` 文件中。
- en: How to do it...
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To parametrize our grid, we should introduce some constants. They can be found
    and tweaked in the `data/shaders/GridParameters.h` GLSL include file. Let’s take
    a look inside:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了参数化我们的网格，我们应该引入一些常数。它们可以在 `data/shaders/GridParameters.h` GLSL 包含文件中找到并调整。让我们看看里面：
- en: 'First of all, we need to define the size of our grid extents in the world coordinates.
    That is how far from the camera the grid is visible:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要定义我们的网格范围在世界坐标中的大小。这就是网格距离摄像机的可见距离：
- en: '[PRE60]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The size of one grid cell is specified in the same units as the grid size:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个网格单元的大小以与网格大小相同的单位指定：
- en: '[PRE61]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Let’s define the colors of the grid lines. We will use two different colors,
    one for regular thin lines and the other for thick lines, which are rendered in
    every tenth line. Since we render everything against a white background, we are
    good with black and 50% gray.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义网格线的颜色。我们将使用两种不同的颜色，一种用于常规细线，另一种用于每第十行渲染的粗线。由于我们是在白色背景上渲染一切，所以我们使用黑色和 50%
    灰色是合适的。
- en: '[PRE62]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Our grid implementation will change the number of rendered lines based on the
    grid LOD. We will switch LOD when the number of pixels between two adjacent grid
    cell lines drops below this value, as calculated in the fragment shader:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的网格实现将根据网格 LOD 改变渲染线条的数量。当两个相邻网格单元线条之间的像素数低于在片段着色器中计算的这个值时，我们将切换 LOD：
- en: '[PRE63]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Let’s take a look at a simple vertex shader we use to generate and transform
    grid vertices. It takes in the current model-view-projection matrix, the current
    camera position, and the grid origin. The origin is in world space and can be
    used to move the grid around.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看我们用来生成和变换网格顶点的简单顶点着色器。它接受当前模型视图投影矩阵、当前摄像机位置和网格原点。原点位于世界空间中，可以用来移动网格。
- en: '[PRE64]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The built-in `gl_VertexIndex` variable is used to access hardcoded quad indices
    and vertices `pos[]`. The `-1…+1` points are scaled by the desired grid size.
    The resulting vertex position is translated by the 2D camera in the horizontal
    plane and, then, by the 3D origin position:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内置的 `gl_VertexIndex` 变量用于访问硬编码的四边形索引和顶点 `pos[]`。`-1…+1` 点按所需的网格大小进行缩放。生成的顶点位置在水平平面上由
    2D 摄像机进行平移，然后由 3D 原点位置进行平移：
- en: '[PRE65]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The fragment shader is somewhat more complex. It will calculate a programmatic
    texture that looks like a grid. The grid lines are rendered based on how fast
    the `uv` coordinates change in the screen space to avoid the Moiré pattern, hence
    we are going to need screen space derivatives. The screen space derivative of
    a variable in your shader measures how much that variable changes from one pixel
    to the next. The GLSL function `dFdx()` represents the horizontal change, while
    `dFdy()` represents the vertical change. It measures how fast a GLSL variable
    changes as you move across the screen, approximating its partial derivatives in
    calculus terms. This approximation is due to relying on discrete samples at each
    fragment, rather than doing a mathematical evaluation of the change:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器稍微复杂一些。它将计算一个看起来像网格的程序化纹理。网格线是根据`uv`坐标在屏幕空间中变化的快慢来渲染的，以避免摩尔纹，因此我们需要屏幕空间导数。你的着色器中变量的屏幕空间导数衡量了该变量从一个像素到下一个像素的变化量。GLSL函数`dFdx()`代表水平变化，而`dFdy()`代表垂直变化。它衡量了当你移动到屏幕上时GLSL变量的变化速度，在微积分术语中近似其偏导数。这种近似是由于依赖于每个片段的离散样本，而不是进行数学上的变化评估：
- en: 'First, we introduce a bunch of GLSL helper functions to aid our calculations.
    They can be found in `data/shaders/GridCalculation.h`. The function names `satf()`
    and `satv()` stand for saturate-float and saturate-vector respectively:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们引入一系列GLSL辅助函数来帮助我们计算。它们可以在`data/shaders/GridCalculation.h`中找到。函数名`satf()`和`satv()`分别代表饱和浮点数和饱和向量：
- en: '[PRE66]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Let’s look into the `gridColor()` function, which is invoked from `main()`,
    and start by calculating the screen space length of the derivatives of the `uv`
    coordinates we previously generated in the vertex shader. We use built-in `dFdx()`
    and `dFdy()` functions to calculate the required derivatives:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们来看看`gridColor()`函数，它是在`main()`函数中被调用的，首先计算我们在顶点着色器中之前生成的`uv`坐标的导数的屏幕空间长度。我们使用内置的`dFdx()`和`dFdy()`函数来计算所需的导数：
- en: '[PRE67]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Knowing the derivatives, the current LOD of our grid can be calculated in the
    following way. The `gridMinPixelsBetweenCells` value controls how fast we want
    our LOD to increase. In this case, it is the minimum number of pixels between
    two adjacent cell lines of the grid:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 知道了导数，我们可以以下方式计算我们网格的当前LOD。`gridMinPixelsBetweenCells`值控制我们想要我们的LOD增加的速度。在这种情况下，它是网格相邻单元格线之间的最小像素数：
- en: '[PRE68]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Besides the LOD value, we are going to need a fading factor to render smooth
    transitions between the adjacent levels. It can be obtained by taking a fractional
    part of the floating point LOD level. The logarithm base `10` is used to ensure
    each LOD covers `pow(10, lodLevel)` more cells than the previous size.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 除了LOD值之外，我们还需要一个衰减因子来渲染相邻级别之间的平滑过渡。这可以通过取浮点数LOD级别的分数部分来获得。使用以10为底的对数来确保每个LOD比前一个大小覆盖更多的单元格。
- en: 'The LOD levels are blended with each other. To render them, we have to calculate
    the cell size for each LOD. Here, instead of calculating `pow()` three times,
    which is done purely for the sake of explanation, we can calculate it only for
    `lod0` and multiply each subsequent LOD cell size by `10.0`:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LOD级别之间相互混合。为了渲染它们，我们必须为每个LOD计算单元格大小。在这里，我们不是三次计算`pow()`，这纯粹是为了解释，我们可以只计算`lod0`，然后将每个后续LOD的单元格大小乘以`10.0`：
- en: '[PRE69]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'To be able to draw anti-aliased lines using alpha transparency, we need to
    increase the screen coverage of our lines. Let’s make sure each line covers up
    to `4` pixels. Shift grid coordinates to the centers of anti-aliased lines for
    subsequent alpha calculations:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够使用alpha透明度绘制抗锯齿线，我们需要增加我们线的屏幕覆盖率。让我们确保每条线覆盖多达`4`个像素。将网格坐标移动到抗锯齿线的中心，以便进行后续的alpha计算：
- en: '[PRE70]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now we should get coverage alpha value corresponding to each calculated LOD
    level. To do that, we calculate absolute distances to cell line centers for each
    LOD and pick the maximum coordinate:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们应该得到与每个计算LOD级别相对应的覆盖率alpha值。为此，我们计算每个LOD到单元格线中心的绝对距离，并选择最大坐标：
- en: '[PRE71]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Non-zero alpha values represent non-empty transition areas of the grid. Let’s
    blend between them using two colors to handle LOD transitions:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 非零的alpha值表示网格的非空过渡区域。让我们使用两种颜色在它们之间进行混合，以处理LOD过渡：
- en: '[PRE72]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Last but not least, make the grid disappear when it is far away from the camera.
    Use the `gridSize` value to calculate the opacity falloff:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，当网格远离摄像机时，让它消失。使用`gridSize`值来计算不透明度衰减：
- en: '[PRE73]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now we can blend between the LOD level alpha values and scale the result with
    the opacity falloff factor. The resulting pixel color value can be stored in the
    framebuffer:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以混合LOD级别的alpha值，并使用不透明度衰减因子缩放结果。生成的像素颜色值可以存储在帧缓冲区中：
- en: '[PRE74]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The abovementioned shaders in `data/shaders/GridCalculation.h` should be rendered
    using the following render pipeline state, which is created in `Chapter05/05_Grid/src/main.cpp`:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`data/shaders/GridCalculation.h`中提到的着色器应使用以下渲染管线状态进行渲染，该状态在`Chapter05/05_Grid/src/main.cpp`中创建：
- en: '[PRE75]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The C++ rendering code in the same file looks as follows:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同一文件中的C++渲染代码如下所示：
- en: '[PRE76]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Check out the complete `Chapter05/05_Grid` for a self-contained demo app. The
    camera can be controlled with the WASD keys and a mouse. The resulting image should
    look like in the following screenshot:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 查看完整的`Chapter05/05_Grid`以获取自包含的演示应用程序。可以使用WASD键和鼠标控制摄像机。生成的图像应类似于以下截图：
- en: '![Figure 5.5: GLSL grid](img/file35.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图5.5：GLSL网格](img/file35.png)'
- en: 'Figure 5.5: GLSL grid'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5：GLSL网格
- en: There’s more...
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Besides considering only the distance to the camera to calculate the antialiasing
    falloff factor, we can use the angle between the viewing vector and the grid line.
    This will make the overall look and feel of the grid more visually pleasing and
    can be an interesting improvement if you want to implement a grid not only as
    an internal debugging tool but also as a part of a customer-facing product, like
    an editor.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 除了仅考虑到摄像机的距离来计算抗锯齿衰减因子外，我们还可以使用视向量与网格线之间的角度。这将使网格的整体外观和感觉更加视觉上令人愉悦，如果您想将网格不仅作为内部调试工具，还作为面向客户的产品的部分，如编辑器，这将是一个有趣的改进。
- en: This implementation was inspired by the *Our Machinery* blog. Unfortunately,
    it is not available anymore. However, there are some other advanced materials
    available on the internet showing how to render a more complex grid suitable for
    customer-facing rendering. Make sure you read the blog post *The Best Darn Grid
    Shader (Yet)* by Ben Golus [https://bgolus.medium.com/the-best-darn-grid-shader-yet-727f9278b9d8](https://bgolus.medium.com/the-best-darn-grid-shader-yet-727f9278b9d8),
    which takes grid rendering a lot further.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现受到了*Our Machinery*博客的启发。不幸的是，它已经不再可用。然而，互联网上还有一些其他高级材料展示了如何渲染更复杂的网格，这些网格适合面向客户的渲染。请确保您阅读了Ben
    Golus的博客文章*The Best Darn Grid Shader (Yet)* [https://bgolus.medium.com/the-best-darn-grid-shader-yet-727f9278b9d8](https://bgolus.medium.com/the-best-darn-grid-shader-yet-727f9278b9d8)，该文章将网格渲染推进了很多。
- en: Before we move on to the next recipe, we want to mention that grid rendering
    is quite handy, and we’ve included it in most of our subsequent demo applications.
    You can use the `VulkanApp::drawGrid()` function to render this grid anywhere
    you want.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续下一个菜谱之前，我们想提一下，网格渲染非常方便，我们已经将其包含在我们大多数后续的演示应用程序中。您可以使用`VulkanApp::drawGrid()`函数在任何您想要的位置渲染此网格。
- en: Integrating tessellation into the graphics pipeline
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将细分集成到图形管线中
- en: Let’s switch gears and learn how to integrate hardware tessellation into the
    Vulkan graphics rendering pipeline.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转换一下话题，学习如何将硬件细分集成到Vulkan图形渲染管线中。
- en: Hardware tessellation is implemented as a set of two new shader stage types
    in the graphics pipeline. The first shader stage is called the **tessellation
    control shader**, and the second stage is called the **tessellation evaluation
    shader**. The tessellation control shader operates on a set of vertices, which
    are called control points and define a geometric surface called a patch. The shader
    can manipulate the control points and calculate the required tessellation level.
    The tessellation evaluation shader can access the barycentric coordinates of the
    tessellated triangles and can use them to interpolate any required per-vertex
    attributes such as texture coordinates and colors. Let’s go through the code to
    see how these new shader stages can be used to triangulate a mesh depending on
    the distance to the camera.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件细分在图形管线中实现为一组两个新的着色器阶段类型。第一个着色器阶段称为**细分控制着色器**，第二个阶段称为**细分评估着色器**。细分控制着色器在一系列顶点上操作，这些顶点称为控制点，并定义了一个称为补丁的几何表面。着色器可以操纵控制点并计算所需的细分级别。细分评估着色器可以访问细分三角形的重心坐标，并可以使用它们来插值任何所需的每个顶点属性，如纹理坐标和颜色。让我们通过代码来看看如何使用这些新的着色器阶段根据到摄像机的距离对网格进行三角化。
- en: Using tessellation shaders for hardware tessellation might not be as efficient
    on modern GPUs as using mesh shaders. Regrettably, as of the time this book was
    written, there is no standardized API for mesh shaders in core Vulkan. So, for
    now, let’s stick with the old tessellation approach.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用细分着色器进行硬件细分可能不如使用网格着色器高效。遗憾的是，截至本书编写时，核心Vulkan中还没有标准化的网格着色器API。因此，现在让我们继续使用旧的细分方法。
- en: Getting ready
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: The complete source code for this recipe is located in `Chapter05/06_Tessellation`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱的完整源代码位于`Chapter05/06_Tessellation`。
- en: How to do it...
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'What we want to do now is write shaders that will calculate per-vertex tessellation
    levels based on the distance to the camera. This way, we can render more geometrical
    details in the areas that are closer to the viewer. To do that, we should start
    with the `Chapter05/06_Tessellation/src/main.vert` vertex shader, which will compute
    the world positions of vertices and pass them down to the tessellation control
    shader:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要编写的是计算基于到相机距离的每个顶点的细分级别的着色器。这样，我们可以在靠近观察者的区域渲染更多的几何细节。为此，我们应该从`Chapter05/06_Tessellation/src/main.vert`顶点着色器开始，它将计算顶点的世界位置并将它们传递给细分控制着色器：
- en: 'Our per-frame data consist of the usual view and projection matrices, together
    with the current camera position in the world space, and the tessellation scaling
    factor, which is user-controllable and comes from an ImGui widget. This data does
    not fit into `128` bytes of push constants, so we put everything into a buffer.
    Geometry is accessed using the PVP technique and stored in the following format
    using `vec3` for vertex positions and `vec2` for texture coordinates:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们每帧的数据包括通常的视图和投影矩阵，以及当前相机在世界空间中的位置，以及细分缩放因子，这是用户可控制的，并来自ImGui小部件。这些数据不适合放入`128`字节的推送常量中，所以我们将其全部放入缓冲区。几何体使用PVP技术访问，并使用`vec3`存储顶点位置和`vec2`存储纹理坐标：
- en: '[PRE77]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Let’s write some helper functions to access vertex positions and texture coordinates
    using the traditional GLSL data types:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写一些辅助函数来使用传统的GLSL数据类型访问顶点位置和纹理坐标：
- en: '[PRE78]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The vertex shader outputs UV texture coordinates and per-vertex world positions.
    The actual calculation is done as follows:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶点着色器输出UV纹理坐标和每个顶点的世界位置。实际计算如下：
- en: '[PRE79]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now we can go further to the next shader stage and take a look at the tessellation
    control shader `Chapter05/06_Tessellation/src/main.tesc`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以进一步到下一个着色器阶段，看看细分控制着色器`Chapter05/06_Tessellation/src/main.tesc`：
- en: The shader operates on a group of `3` vertices that correspond to a single triangle
    in the input data. The `uv_in` and `worldPos_in` variables correspond to the ones
    in the vertex shader. Note how here we have arrays instead of single solitary
    values. The `PerFrameData` structure should be exactly the same for all shader
    stages in this example and comes from `common.sp`.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 着色器在一个由`3`个顶点组成的组上操作，这些顶点对应于输入数据中的单个三角形。`uv_in`和`worldPos_in`变量对应于顶点着色器中的那些。注意这里我们有数组而不是单个孤立的值。`PerFrameData`结构在此示例的所有着色器阶段中都应该完全相同，并来自`common.sp`。
- en: '[PRE80]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Let’s describe the input and output data structures that correspond to each
    individual vertex. Besides the required vertex position, we store `vec2` texture
    coordinates:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们描述与每个单独的顶点对应的输入和输出数据结构。除了所需的顶点位置外，我们存储`vec2`纹理坐标：
- en: '[PRE81]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The `getTessLevel()` function calculates the desired tessellation level based
    on the distance of two adjacent vertices from the camera. The hardcoded distance
    values that are used to switch the levels are scaled using the `tessellationScale`
    uniform coming from the UI:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getTessLevel()`函数根据两个相邻顶点到相机的距离计算所需的细分级别。用于切换级别的硬编码距离值使用来自UI的`tessellationScale`统一变量进行缩放：'
- en: '[PRE82]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The `main()` function is straightforward. It passes the positions and UV coordinates
    as-is and then calculates the distance from each vertex in the triangle to the
    camera:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main()`函数很简单。它直接传递位置和UV坐标，然后计算三角形中每个顶点到相机的距离：'
- en: '[PRE83]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Based on these distances, we can calculate the required inner and outer tessellation
    levels in the following way. The inner tessellation level defines how the inner
    part of a triangle is subdivided into smaller triangles. The outer level defines
    how the outer edges of the triangle are subdivided so that they can be correctly
    connected to adjacent triangles:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据这些距离，我们可以以下方式计算所需的内部和外部细分级别。内部细分级别定义了三角形内部如何细分成更小的三角形。外部级别定义了三角形的外边缘如何细分，以便它们可以正确地连接到相邻的三角形：
- en: '[PRE84]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Let’s take a look at the tessellation evaluation shader `Chapter05/06_Tessellation/src/main.tese`:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看细分评估着色器 `Chapter05/06_Tessellation/src/main.tese`：
- en: 'We should specify triangles as the input. The `equal_spacing` spacing mode
    tells Vulkan that the tessellation level `n` should be clamped to the range `0...64`
    and rounded to the nearest integer. After that, the corresponding edge should
    be divided into `n` equal segments. When the tessellation primitive generator
    produces triangles, the orientation of triangles can be specified by an input
    layout declaration using the identifiers `cw` and `ccw`. We use the counter-clockwise
    orientation:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该指定三角形作为输入。`equal_spacing` 间距模式告诉 Vulkan，细分级别 `n` 应该被限制在 `0...64` 范围内，并四舍五入到最接近的整数。之后，相应的边应该被分成
    `n` 个相等的段。当细分原语生成器生成三角形时，可以通过使用标识符 `cw` 和 `ccw` 的输入布局声明来指定三角形的方向。我们使用逆时针方向：
- en: '[PRE85]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'These two helper functions are useful for interpolating between the `vec2`
    and `vec4` attribute values at the corners of the original triangle using barycentric
    coordinates of the current vertex. The built-in `gl_TessCoord` variable contains
    the required barycentric coordinates, `0…1`:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两个辅助函数对于使用当前顶点的重心坐标在原始三角形的角之间插值 `vec2` 和 `vec4` 属性值很有用。内置的 `gl_TessCoord` 变量包含所需的权重坐标，`0…1`：
- en: '[PRE86]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The actual interpolation code in `main()` is straightforward and can be written
    in the following way:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main()` 中的实际插值代码很简单，可以写成以下方式：'
- en: '[PRE87]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The next stage of our hardware tessellation graphics pipeline is the geometry
    shader `Chapter05/06_Tessellation/src/main.geom`. We use it to generate barycentric
    coordinates for all the small tessellated triangles. It is used to render a nice
    antialiased wireframe overlay on top of our colored mesh, as we did earlier in
    this chapter in the *Generating LODs using MeshOptimizer* recipe:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们硬件细分图形管道的下一阶段是几何着色器 `Chapter05/06_Tessellation/src/main.geom`。我们使用它为所有的小细分三角形生成重心坐标。它用于在我们之前在本章的
    *使用 MeshOptimizer 生成 LODs* 菜单中，在着色网格上渲染一个漂亮的抗锯齿线框覆盖：
- en: 'The geometry shader consumes triangles generated by the hardware tessellator
    and outputs triangle strips, each consisting of a single triangle:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几何着色器消耗由硬件细分器生成的三角形，并输出由单个三角形组成的三角形带：
- en: '[PRE88]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Barycentric coordinates are assigned per vertex using these hardcoded constants:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下硬编码常量为每个顶点分配重心坐标：
- en: '[PRE89]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The final stage of this rendering pipeline is the fragment shader `Chapter05/06_Tessellation/src/main.frag`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 此渲染管道的最终阶段是片段着色器 `Chapter05/06_Tessellation/src/main.frag`：
- en: 'We take in the barycentric coordinates from the geometry shader and use them
    to calculate a wireframe overlay covering our mesh:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从几何着色器中获取重心坐标，并使用它们来计算覆盖我们网格的线框覆盖：
- en: '[PRE90]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'A helper function returns the blending factor based on the distance to the
    edge and the desired thickness of the wireframe contour. Essentially, when one
    of the `3` barycentric coordinate values is close to `0`, it indicates that the
    current fragment is near one of the triangle’s edges. The distance to zero controls
    the visible thickness of a rendered edge:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个辅助函数根据到边的距离和所需的线框轮廓厚度返回混合因子。本质上，当 `3` 个权重坐标值之一接近 `0` 时，它表示当前片段接近三角形的一条边。到零的距离控制渲染边的可见厚度：
- en: '[PRE91]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Let’s sample the texture using the provided UV values and call it a day:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用提供的 UV 值采样纹理，然后结束：
- en: '[PRE92]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The GLSL shader part of our Vulkan hardware tessellation pipeline is over,
    and it is time to look into the C++ code. The source code is located in the `Chapter05/06_Tessellation/src/main.cpp`
    file:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 Vulkan 硬件细分管道的 GLSL 着色器部分已经完成，现在是时候查看 C++ 代码了。源代码位于 `Chapter05/06_Tessellation/src/main.cpp`
    文件中：
- en: 'The shaders for the tessellated mesh rendering are loaded the following way:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 细分网格渲染的着色器以下方式加载：
- en: '[PRE93]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Now we create a corresponding rendering pipeline:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们创建相应的渲染管道：
- en: '[PRE94]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The `data/rubber_duck/scene.gltf` mesh loading code is identical to that from
    the previous recipes, so we’ll skip it here. What’s more important is how we render
    the mesh and ImGui widget to control the tessellation scale factor. Let’s take
    a look at the body of the rendering loop:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`data/rubber_duck/scene.gltf` 网格加载代码与之前菜谱中的相同，所以这里我们将跳过它。更重要的是我们如何渲染网格和 ImGui
    小部件来控制镶嵌缩放因子。让我们看看渲染循环的主体：'
- en: 'First, we calculate model-view-projection matrices for our mesh:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们计算我们的网格的模型视图投影矩阵：
- en: '[PRE95]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Per-frame data is uploaded into a buffer.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每帧数据被上传到缓冲区。
- en: '[PRE96]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Push constants are used to pass an address of the buffer into shaders. Then
    we can render the mesh using our tessellation pipeline.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用常量推送来传递缓冲区的地址到着色器。然后我们可以使用我们的镶嵌管道渲染网格。
- en: '[PRE97]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'We add a grid on top, as was described earlier in this chapter in the *Implementing
    an infinite grid GLSL shader* recipe. The origin is used to place the grid just
    under the duck model. Inside our frame rendering loop, we can access all the ImGui
    rendering functionality as usual. Here, we just render a single slider containing
    a floating-point value for the tessellation scale factor:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在上面添加了一个网格，正如本章前面在 *实现无限网格 GLSL 着色器* 菜谱中描述的那样。原点用于将网格放置在鸭模型下方。在我们的帧渲染循环中，我们可以像往常一样访问所有的
    ImGui 渲染功能。在这里，我们只渲染一个包含镶嵌缩放因子的浮点值的单个滑块：
- en: '[PRE98]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Here is a screenshot from the running demo application:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是运行中的演示应用程序的截图：
- en: '![Figure 5.6: Tessellated duck](img/file36.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6：镶嵌鸭](img/file36.png)'
- en: 'Figure 5.6: Tessellated duck'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6：镶嵌鸭
- en: Note how the different tessellation level varies based on the distance to the
    camera. Try playing with the control slider to emphasize the effect.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 注意不同的镶嵌级别如何根据与摄像机的距离而变化。尝试调整控制滑块以强调效果。
- en: There’s more...
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多...
- en: 'This recipe can be used as a cornerstone of hardware mesh tessellation techniques
    in your Vulkan applications. One natural step forward would be to apply a displacement
    map to the fine-grained tessellated vertices using the direction of normal vectors.
    Check out this page for inspiration: [https://www.geeks3d.com/20100804/test-opengl-4-tessellation-with-displacement-mapping](https://www.geeks3d.com/20100804/test-opengl-4-tessellation-with-displacement-mapping).
    For those who want to go serious on adaptive tessellation of subdivision surfaces,
    there is a chapter in the *GPU Gems 2* book covering this advanced topic in great
    detail. It is now available online at [https://developer.nvidia.com/gpugems/gpugems2/part-i-geometric-complexity/chapter-7-adaptive-tessellation-subdivision-surfaces](https://developer.nvidia.com/gpugems/gpugems2/part-i-geometric-complexity/chapter-7-adaptive-tessellation-subdivision-surfaces).'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱可以用作你在 Vulkan 应用程序中硬件网格镶嵌技术的基石。一个自然的下一步就是使用法线向量的方向将位移图应用到细粒度镶嵌的顶点上。查看这个页面以获取灵感：[https://www.geeks3d.com/20100804/test-opengl-4-tessellation-with-displacement-mapping](https://www.geeks3d.com/20100804/test-opengl-4-tessellation-with-displacement-mapping)。对于那些想要在细分表面自适应镶嵌上深入研究的人，*GPU
    Gems 2* 书籍中有一个章节详细介绍了这个高级主题。现在它可以在[https://developer.nvidia.com/gpugems/gpugems2/part-i-geometric-complexity/chapter-7-adaptive-tessellation-subdivision-surfaces](https://developer.nvidia.com/gpugems/gpugems2/part-i-geometric-complexity/chapter-7-adaptive-tessellation-subdivision-surfaces)在线获取。
- en: Organizing mesh data storage
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织网格数据存储
- en: In the previous chapters, we used fixed hardcoded vertex formats for our meshes,
    which changed between demos, and also implicitly included the material description.
    For example, a hardcoded texture was used to provide color information. A triangle
    mesh is defined by indices and vertices. Each vertex is defined as a set of attributes
    with distinct data formats corresponding to the `lvk::VertexInput` vertex input
    description. All auxiliary physical properties of an object, such as collision
    detection data, mass, and moments of inertia, can be represented by a mesh, while
    other information, such as surface material properties, can be stored outside
    of the mesh as external metadata. It’s worth noting that small 3D models, like
    the rubber duck we used before, can be loaded pretty quickly. However, larger
    and more intricate real-world 3D models, especially when using transmission formats
    like `.gltf`, may take several minutes to load. Using a run-time mesh format can
    address this issue by eliminating any parsing and replacing it with flat buffer
    loading, which matches internal rendering data structures. This involves employing
    fast functions like `fread()` and similar mechanisms.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章節中，我們為我們的網格使用了固定的硬編碼頂點格式，這些格式在演示之間會變化，並隱式地包含了材料描述。例如，使用硬編碼的紋理來提供顏色信息。一個三角形網格由索引和頂點定義。每個頂點被定義為一組屬性，它們具有與
    `lvk::VertexInput` 顶点输入描述相對應的獨特數據格式。一個物體的所有輔助物理屬性，如碰撞檢測數據、質量和慣量矩，都可以通過網格表示，而其他信息，如表面材料屬性，可以作為外部元數據存儲在網格之外。值得注意的是，像我們之前使用的橡皮鴨這樣的小型
    3D 模型可以非常快地加載。然而，更大、更複雜的現實世界 3D 模型，尤其是在使用 `.gltf` 等傳輸格式時，可能需要幾分鐘才能加載。通過消除任何解析並用平坦緩衝區加載替換它，運行時網格格式可以通過匹配內部渲染數據結構來解決這個問題。這涉及到使用像
    `fread()` 和類似的快速函數。
- en: Let’s define a unified mesh storage format covering all the use cases for the
    remaining part of this book.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 讓我們定義一個統一的網格存儲格式，以涵蓋本書後續部分的所有用例。
- en: Getting ready
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准備工作
- en: This recipe describes the basic data structures we will use to store mesh data
    throughout the rest of this book. The full corresponding source code is located
    in the header file `shared/Scene/VtxData.h`. Make sure you’ve read *Chapter 2*,
    *Getting Started with Vulkan* before going forward.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱描述了我们将用于在整个书中存储网格数据的基礎數據結構。完整的相應源代碼位於頭文件 `shared/Scene/VtxData.h` 中。在繼續進行之前，請確保您已經閱讀了
    *第 2 章*，*開始使用 Vulkan*。
- en: How to do it...
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作...
- en: A vector of homogeneous **vertex attributes** stored contiguously is called
    a **vertex stream**. Examples of such attributes are vertex positions, texture
    coordinates, and normal vectors, each of the three representing one attribute.
    Each stream must have a format. Vertex positions are `vec3`, texture coordinates
    can be `vec2`, normal vectors can use the packed format `Int_2_10_10_10_REV`,
    and so on.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 存儲在連續位置的均勻 **頂點屬性** 的向量被稱為 **頂點流**。這些屬性的例子包括頂點位置、紋理坐標和法向量，每個三個代表一個屬性。每個流必須有一個格式。頂點位置是
    `vec3`，紋理坐標可以是 `vec2`，法向量可以使用打包格式 `Int_2_10_10_10_REV`，等等。
- en: Let’s define a **LOD** as an index buffer of reduced size that uses existing
    vertices and hence can be used directly for rendering with the original vertex
    buffer. We learned how to create LODs earlier in this chapter in the *Generating
    LODs using MeshOptimizer* recipe.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我們將 **LOD** 定義為一個較小尺寸的索引緩衝區，它使用現有的頂點，因此可以直接使用原始頂點緩衝區進行渲染。我們在這一章的 *使用 MeshOptimizer
    生成 LOD* 製品中學習了如何創建 LOD。
- en: We define a **mesh** as a collection of all vertex data streams and a collection
    of all index buffers, one for each LOD. The number of elements in each vertex
    data stream is the same and is called the “vertex count”, which we will encounter
    in the instructions below. To make things a bit simpler, we always use 32-bit
    offsets and indices for our data.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我們將 **網格** 定義為所有頂點數據流和所有索引緩衝區的集合，每個 LOD 一個。每個頂點數據流中的元素數量相同，稱為“頂點數量”，我們將在下面的說明中遇到。為了讓事情簡單一點，我們總是使用
    32 位偏移量和索引來存儲我們的數據。
- en: All the vertex data streams and LOD index buffers are packed into a single blob.
    This allows us to load the data in a single `fread()` call or even use memory
    mapping to allow direct data access. This simple vertex data representation also
    enables direct upload of meshes into the GPU. What makes it particularly interesting
    is the ability to merge data for multiple meshes into a single file. Alternatively,
    this can be achieved by consolidating the data into two large buffers — one for
    indices and the other for vertex attributes. This will come in very handy later
    when we learn how to implement a LOD switching technique on GPU.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的顶点数据流和LOD索引缓冲区都被打包到一个单一的blob中。这允许我们通过单个`fread()`调用加载数据，甚至可以使用内存映射来允许直接数据访问。这种简单的顶点数据表示也使得直接将网格上传到GPU成为可能。特别有趣的是，它能够将多个网格的数据合并到一个文件中。或者，这也可以通过将数据合并到两个大缓冲区中实现——一个用于索引，另一个用于顶点属性。这将在我们学习如何在GPU上实现LOD切换技术时非常有用。
- en: 'In this recipe, we will deal only with geometrical data. The LOD creation process
    is covered in the recipe *Generating LODs using MeshOptimizer* and the material
    data export process is covered in the subsequent chapters. Let’s take a look at
    `shared/Scene/VtxData.h` and declare the main data structures for our mesh:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们只处理几何数据。LOD创建过程在配方*使用MeshOptimizer生成LOD*中介绍，而材质数据导出过程在随后的章节中介绍。让我们看一下`shared/Scene/VtxData.h`并声明我们网格的主要数据结构：
- en: First, we need to define an individual mesh description. We deliberately avoid
    using pointers, which hide memory allocations and prohibit simple saving and loading
    of the data. We store offsets to individual data streams and LOD index buffers,
    which are equivalent to pointers, but are more flexible and, most importantly,
    more GPU-friendly. All the offsets in the `Mesh` structure are given relative
    to the beginning of the data block. Let’s declare our main data structure for
    a mesh. It contains the number of LODs and vertex data streams. The LOD count,
    where the original mesh counts as one of the LODs, must be strictly less than
    `kMaxLODs`, because we do not store LOD index buffer sizes but calculate them
    from offsets. To calculate these sizes, we store one extra empty LOD level at
    the end. The number of vertex data streams is stored directly with no modifications.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要定义一个单独的网格描述。我们故意避免使用指针，因为指针隐藏内存分配并禁止简单保存和加载数据。我们存储指向各个数据流和LOD索引缓冲区的偏移量，这些偏移量相当于指针，但更灵活，最重要的是，更符合GPU的要求。`Mesh`结构中的所有偏移量都是相对于数据块开始的位置给出的。让我们声明我们网格的主要数据结构。它包含LOD的数量和顶点数据流。LOD计数，其中原始网格被视为一个LOD，必须严格小于`kMaxLODs`，因为我们不存储LOD索引缓冲区的大小，而是从偏移量计算它们。为了计算这些大小，我们在末尾存储一个额外的空LOD级别。顶点数据流的数量直接存储，没有修改。
- en: '[PRE99]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The `vertexCount` field contains the total number of vertices in this mesh.
    This number is described the content of the vertex buffer and can be greater than
    the number of vertices on any individual level of detail. We postpone the question
    of material data storage to the next chapters. To do this in an elegant manner,
    let’s introduce a level of indirection. The `materialID` field contains an abstract
    identifier that allows us to reference any material data stored elsewhere:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`vertexCount`字段包含此网格中的顶点总数。这个数字描述了顶点缓冲区的内容，并且可能大于任何单个细节级别上的顶点数。我们将材质数据存储的问题推迟到下一章。为了优雅地完成这项工作，让我们引入一个间接级别。`materialID`字段包含一个抽象标识符，允许我们引用存储在其他地方的材料数据：'
- en: '[PRE100]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Each mesh can potentially be displayed at different LODs. The file contains
    all indices for all levels of detail and offsets for the beginning of each LOD
    are stored in the `lodOffset` array. This array contains one extra item at the
    end, which serves as a marker to calculate the size of the last LOD:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个网格可能以不同的LOD显示。文件包含所有细节级别的索引和每个LOD开始的偏移量存储在`lodOffset`数组中。此数组在末尾包含一个额外的项，用作计算最后一个LOD大小的标记：
- en: '[PRE101]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Instead of storing the number of indices of each LOD, we define a little helper
    function to calculate that number:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 而不是存储每个LOD的索引数，我们定义了一个小辅助函数来计算这个数字：
- en: '[PRE102]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'As you might have noticed, the `Mesh` structure is just a sort of index into
    other buffers containing data, such as index and vertex buffers. Let’s take a
    look at that data container:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，`Mesh`结构只是对包含数据的其他缓冲区的索引，例如索引和顶点缓冲区。让我们看一下那个数据容器：
- en: The format of the vertex streams is described by the structure `lvk::VertexInput`.
    We already used it in *Chapter 2*, *Getting Started with Vulkan*. This form of
    vertex stream description allows very flexible storage.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶点流的格式由结构 `lvk::VertexInput` 描述。我们在 *第2章*，*Vulkan 入门* 中已经使用过它。这种顶点流描述形式允许非常灵活的存储。
- en: '[PRE103]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The actual index and vertex buffer data are stored in these containers. They
    can accommodate multiple meshes. We use only 32-bit indices in our book for the
    sake of simplicity.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际的索引和顶点缓冲区数据存储在这些容器中。它们可以容纳多个网格。为了简单起见，我们在这本书中使用32位索引。
- en: '[PRE104]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Another `std::vector` stores each individual mesh description:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个 `std::vector` 存储每个单独的网格描述：
- en: '[PRE105]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: For completeness, we’ll also store a bounding box for each mesh right here.
    Bounding boxes are extremely useful for culling, and having them precalculated
    can significantly speed up the loading process.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完整性，我们还将在这里为每个网格存储一个边界框。边界框对于剔除非常有用，并且预先计算它们可以显著加快加载过程。
- en: '[PRE106]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '**Note**'
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意**'
- en: ''
  id: totrans-352
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For this book, we are solely focusing on tightly-packed (non-interleaved) vertex
    attribute streams. However, it is not difficult to extend the proposed schema
    to support interleaved data storage by making use of the stride parameter in `lvk::VertexInput::VertexInputBinding`.
    One major drawback is that such data reorganization would require us to change
    all the vertex pulling code in shaders. If you are developing production code,
    measure which storage format works faster on your target hardware before committing
    to one particular approach.
  id: totrans-353
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于这本书，我们只关注紧密打包（非交错）的顶点属性流。然而，通过使用 `lvk::VertexInput::VertexInputBinding` 中的步进参数，将提出的模式扩展到支持交错数据存储并不困难。一个主要的缺点是这种数据重组将需要我们更改着色器中的所有顶点提取代码。如果您正在开发生产代码，在确定一种特定方法之前，请测量在目标硬件上哪种存储格式运行得更快。
- en: 'Before we can store these mesh data structures in a file, we need some sort
    of a file header:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够将这些网格数据结构存储到文件中之前，我们需要某种类型的文件标题：
- en: 'To ensure data integrity and to check the validity of the header, a magic hexadecimal
    value of `0x12345678` is stored in the first 4 bytes of the header:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保数据完整性和检查标题的有效性，我们在标题的前4个字节中存储了一个魔数十六进制值 `0x12345678`：
- en: '[PRE107]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The number of individual `Mesh` descriptors in this file is stored in the `meshCount`
    field:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该文件中 `Mesh` 描述符的数量存储在 `meshCount` 字段中：
- en: '[PRE108]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The last two member fields store the sizes of index and vertex data in bytes,
    respectively. These values come in handy when checking the integrity of a mesh
    file as well:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后两个成员字段分别存储索引和顶点数据的大小（以字节为单位）。这些值在检查网格文件完整性时非常有用：
- en: '[PRE109]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The file continues with the list of `Mesh` structures. After the header and
    a list of individual mesh descriptors, we store a large index and vertex data
    block, which can be loaded all at once.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 文件接着是 `Mesh` 结构的列表。在标题和单个网格描述符列表之后，我们存储一个大的索引和顶点数据块，可以一次性加载。
- en: How it works...
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let’s go through the pseudocode from `shared/Scene/VtxData.cpp` for loading
    such a file is just a few `fread()` calls that look as follows. Error checks are
    omitted from the book text but are present in the actual code:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过 `shared/Scene/VtxData.cpp` 中的伪代码来了解如何加载这样的文件，它只是几个看起来如下所示的 `fread()` 调用。本书文本中省略了错误检查，但在实际代码中是存在的：
- en: 'First, we read the file header with the mesh count. Error checks are skipped
    here in the book but are present in the bundled source code:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用网格数量读取文件标题。本书中省略了错误检查，但在捆绑的源代码中是存在的：
- en: '[PRE110]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Having read the header, we resize the mesh descriptors array and read in all
    `Mesh` descriptions:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取了标题后，我们调整网格描述符数组的大小，并读取所有 `Mesh` 描述：
- en: '[PRE111]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Then we read the main geometry data blocks for this mesh, which contain the
    actual index and vertex data:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们读取该网格的主几何数据块，其中包含实际的索引和顶点数据：
- en: '[PRE112]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Alternatively, index and vertex buffers can be combined into a single large
    byte buffer. We leave this as an exercise for our readers.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，索引和顶点缓冲区可以合并成一个单独的大字节数据缓冲区。我们将这个作为读者的练习。
- en: Later on, the `indexData` and `vertexData` containers can be directly uploaded
    to the GPU. We’ll revisit this idea in the subsequent recipes in this chapter.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，`indexData` 和 `vertexData` 容器可以直接上传到 GPU。我们将在本章后续的食谱中重新审视这个想法。
- en: Although you can see the result of this code in the demo app `Chapter05/07_MeshRenderer`
    for this chapter, there are some additional functionalities that need to be implemented.
    Let’s cover a few more topics before we can run and witness the demo.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您可以在本章的演示应用`Chapter05/07_MeshRenderer`中看到此代码的结果，但还有一些额外的功能需要实现。在我们运行并见证演示之前，让我们先探讨更多的话题。
- en: There’s more...
  id: totrans-373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This geometry data format is pretty simple and straightforward for the purpose
    of storing static mesh data. If the meshes may be changed, reloaded, or loaded
    asynchronously, we may store separate meshes in dedicated files.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这种几何数据格式对于存储静态网格数据来说非常简单和直接。如果网格可能会更改、重新加载或异步加载，我们可以在专用文件中存储单独的网格。
- en: Since it is impossible to predict all the use cases and since this book is all
    about the rendering and not some general gaming engine creation, it is up to the
    reader to make decisions on adding extra features such as mesh skinning or others.
    One simple example of such a decision is the addition of material data directly
    into the mesh file. Technically, all we need to do is add a `materialCount` field
    to `MeshFileHeader` and store a list of material descriptions right after the
    list of meshes. Even such a simple thing immediately raises more questions. Should
    we pack texture data in the same file? If yes, how complex should the texture
    format be? What material model should we use? And so on, and so forth. For now,
    we just leave mesh geometry data separated from material descriptions. We will
    come back to materials in subsequent chapters.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 由于无法预测所有用例，而且本书主要关于渲染而不是通用游戏引擎的创建，因此添加额外功能（如网格蒙皮或其他功能）的决定取决于读者。这样一个决定的简单例子是将材质数据直接添加到网格文件中。技术上，我们只需要在`MeshFileHeader`中添加一个`materialCount`字段，并在网格列表之后存储材质描述列表。即使这样简单的事情也会立即引发更多问题。我们应该在同一个文件中打包纹理数据吗？如果是这样，纹理格式应该有多复杂？我们应该使用哪种材质模型？等等。目前，我们将网格几何数据与材质描述分开。我们将在后续章节中回到材质。
- en: Implementing automatic geometry conversion
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现自动几何转换
- en: In the previous chapters, we learned how to use the `Assimp` library to load
    and render 3D models stored in different file formats. In real-world graphics
    applications, the process of loading a model can be tedious and multistage. Besides
    just loading, we might want to optimize a mesh in some specific way, such as optimizing
    geometry and computing multiple LOD meshes. This process might become slow for
    sizable meshes, so it makes perfect sense to preprocess meshes offline, before
    an application starts, and load them later in the app as described in the previous
    recipe, *Organizing mesh data storage*. Let’s learn how to implement a simple
    framework for automatic geometry preprocessing and conversion.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何使用`Assimp`库加载和渲染存储在不同文件格式中的3D模型。在实际的图形应用中，加载模型的过程可能既繁琐又多阶段。除了加载之外，我们可能还希望以某种特定方式优化网格，例如优化几何形状和计算多个LOD网格。对于较大的网格，这个过程可能会变得很慢，因此在应用程序开始之前离线预处理网格，并在应用程序中稍后加载它们，就像在之前的配方*组织网格数据存储*中描述的那样，是非常合理的。让我们学习如何实现一个简单的自动几何预处理和转换框架。
- en: In the previous edition of this book, we created a standalone tool for geometry
    conversion that needs to be executed before subsequent demo apps can load the
    converted data. It turned out to be a significant oversight on our part because
    many readers dove straight into running the demo apps and then reported issues
    when things didn’t work out of the box as they expected. Here, we have rectified
    that mistake. If an app requires converted data and cannot find it, it triggers
    all the necessary code to load the data from storage assets and convert it into
    our run-time format.
  id: totrans-378
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在本书的前一版中，我们创建了一个独立的几何转换工具，需要在后续的演示应用加载转换后的数据之前执行。结果证明，这是我们疏忽大意的一个重大错误，因为许多读者直接运行了演示应用，然后报告了当事情没有像他们预期的那样立即工作时的各种问题。在这里，我们已经纠正了这个错误。如果一个应用需要转换后的数据，但找不到它，它将触发所有必要的代码来从存储资源中加载数据并将其转换为我们的运行时格式。
- en: Getting ready
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: The source code for our geometry conversion framework is in `Chapter05/07_MeshRenderer`.
    Low-level loader functions are defined in `shared/Scene/VtxData.cpp`. The entire
    demo application is covered by multiple recipes from this chapter, including *Organizing
    mesh data storage*, *Implementing automatic geometry conversion*, and *Indirect
    rendering in Vulkan*.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几何转换框架的源代码位于`Chapter05/07_MeshRenderer`。低级加载函数定义在`shared/Scene/VtxData.cpp`中。整个演示应用程序由本章的多个配方覆盖，包括*组织网格数据存储*、*实现自动几何转换*和*Vulkan中的间接渲染*。
- en: How to do it...
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let us see how the `Assimp` library is used to export the mesh data and save
    it into the binary file using the data structures defined in the *Organizing mesh
    data storage* recipe:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`Assimp`库导出网格数据，并使用*组织网格数据存储*配方中定义的数据结构将其保存到二进制文件中：
- en: 'We start by exploring a function called `convertAIMesh()`, which converts the
    `Assimp` mesh representation into our run-time format and appends it to the referenced
    `MeshData` parameter. Global index and vertex offsets are updated as well. The
    function is quite lengthy, but we will explore it in full detail here. Error checks
    are omitted:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先探索一个名为`convertAIMesh()`的函数，该函数将`Assimp`网格表示转换为我们的运行时格式，并将其附加到引用的`MeshData`参数。同时更新全局索引和顶点偏移量。该函数相当长，但我们将在这里详细探讨。错误检查被省略：
- en: '[PRE113]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The actual mesh geometry data are stored in two following arrays. We cannot
    output converted meshes one by one, at least not in a single-pass tool, because
    we do not know the total size of data in advance, so we allocate in-memory storage
    for all the data and then write these data blobs into the output file. We also
    need a reference to the global vertex buffer, where we would append new vertices
    from this `aiMesh`. The `outLods` container is for per-LOD index buffers. Then
    we just go through all vertices of `aiMesh` and convert them:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际网格几何数据存储在以下两个数组中。我们无法逐个输出转换后的网格，至少在单遍工具中不能，因为我们事先不知道数据的总大小，所以我们为所有数据分配内存存储，然后将这些数据块写入输出文件。我们还需要一个全局顶点缓冲区的引用，我们将从这个`aiMesh`中添加新顶点。`outLods`容器是每个LOD的索引缓冲区。然后我们只需遍历`aiMesh`的所有顶点并将它们转换即可：
- en: '[PRE114]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: For this recipe, we assume there is a single LOD and that all the vertex data
    is stored as a continuous data stream. In other words, we have an interleaved
    storage of the data. We also ignore all the material information and deal exclusively
    with the index and vertex data for now.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个配方，我们假设只有一个LOD，并且所有顶点数据都存储为连续的数据流。换句话说，我们有一个数据交错存储。我们还忽略了所有材质信息，目前只处理索引和顶点数据。
- en: '[PRE115]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Once we have the stream data for the vertex, we can output it into the vertex
    buffer. The position `v` is stored as `vec3`. The texture coordinates `uv` are
    stored as half-float `vec2` to save some space. The normal vector is converted
    into `2_10_10_10_REV`, which has the size of `uint32_t` – not bad for `3` floats.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了顶点的流数据，我们就可以将其输出到顶点缓冲区。位置`v`以`vec3`存储。纹理坐标`uv`以半浮点`vec2`存储，以节省空间。法向量被转换为`2_10_10_10_REV`，大小为`uint32_t`——对于`3`个浮点数来说还不错。
- en: '`put()` is a templated function, which mem-copies the value from its second
    argument into a vector of `uint8_t`:'
  id: totrans-390
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`put()`是一个模板函数，它将第二个参数的值从其复制到`uint8_t`的向量中：'
- en: '[PRE116]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Describe the vertex streams for our demo: positions, texture coordinates, and
    normal vectors. The stride comes from the size of `vec3` positions, half-float
    `vec2` texture coordinates packed into `uint32_t`, and `2_10_10_10_REV` normals
    packed into `uint32_t`.'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述我们演示的顶点流：位置、纹理坐标和法向量。步长来自`vec3`位置的大小、打包到`uint32_t`的半浮点`vec2`纹理坐标，以及打包到`uint32_t`的`2_10_10_10_REV`法向量。
- en: '[PRE117]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Go through all faces and create an index buffer:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历所有面并创建索引缓冲区：
- en: '[PRE118]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: If no LOD calculation is required, we can just store `srcIndices` as LOD 0\.
    Otherwise, we call the processLods() function, which calculates LOD levels for
    this mesh, as described in the *Generating LODs using MeshOptimizer* recipe.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不需要LOD计算，我们只需将`srcIndices`存储为LOD 0即可。否则，我们调用`processLods()`函数，该函数根据*使用MeshOptimizer生成LOD*配方计算此网格的LOD级别。
- en: '[PRE119]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Before updating the `indexOffset` and `vertexOffset` parameters, let’s store
    their values in the resulting `Mesh` structure. Their values represent where all
    the previous index and vertex data ended before we started converting this `aiMesh`.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在更新`indexOffset`和`vertexOffset`参数之前，让我们将它们的值存储在生成的`Mesh`结构中。它们的值代表在我们开始转换此`aiMesh`之前，所有先前索引和顶点数据结束的位置。
- en: '[PRE120]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Stream out all the indices for all the LOD levels one after another:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 依次流出到所有LOD级别的所有索引：
- en: '[PRE121]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'After processing the input mesh, we increment offset counters for indices and
    the current starting vertex:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理输入网格后，我们增加索引和当前起始顶点的偏移计数器：
- en: '[PRE122]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Processing a 3D asset file by Assimp comprises loading the scene and converting
    each mesh into the internal format. Let’s take a look at the `loadMeshFile()`
    function to see how to do it:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Assimp处理3D资产文件包括加载场景并将每个网格转换为内部格式。让我们看看`loadMeshFile()`函数，看看如何操作：
- en: The list of flags for the `aiImportFile()` function includes options that allow
    further usage of imported data without any extra processing on our side. For example,
    all the transformation hierarchies are flattened, and the resulting transformation
    matrices are applied to mesh vertices.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`aiImportFile()`函数的标志列表包括允许在不进行任何额外处理的情况下进一步使用导入数据的选项。例如，所有变换层次结构都被简化，并且结果变换矩阵应用于网格顶点。'
- en: '[PRE123]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'After importing an Assimp scene, we resize the mesh descriptor container accordingly
    and call `convertAIMesh()` for each mesh in the scene. The `indexOffset` and `vertexOffset`
    offsets are accumulated incrementally:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导入Assimp场景后，我们相应地调整网格描述容器的大小，并对场景中的每个网格调用`convertAIMesh()`。`indexOffset`和`vertexOffset`偏移量是逐步累积的：
- en: '[PRE124]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'In the end, we precalculate axis-aligned bounding boxes for our mesh data:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们预先计算网格数据的轴对齐边界框：
- en: '[PRE125]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Although loading and preprocessing of data should be customizable to accommodate
    needs of each individual demo app, saving is pretty much standard because `MeshData`
    contains all the information we need. As such, the saving function `saveMeshData()`
    is defined in `shared/Scene/VtxData.cpp`.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管数据加载和预处理应根据每个演示应用的需求进行定制，但保存几乎是标准的，因为`MeshData`包含了我们所需的所有信息。因此，保存函数`saveMeshData()`定义在`shared/Scene/VtxData.cpp`。
- en: 'Saving converted meshes into our file format is the reverse process of reading
    meshes from the file described in the *Organizing mesh data storage* recipe:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 将转换后的网格保存到我们的文件格式是*组织网格数据存储*配方中描述的从文件读取网格的逆过程：
- en: 'First, we fill the file header structure using the mesh number and offsets:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用网格编号和偏移量填充文件头部结构：
- en: '[PRE126]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'We calculate byte sizes of index and vertex data buffers and store them in
    the header:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们计算索引和顶点数据缓冲区的字节数，并将它们存储在头部：
- en: '[PRE127]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Once all the sizes are known, we save the header and the list of mesh descriptions:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦所有尺寸都已知，我们就保存头部信息和网格描述列表：
- en: '[PRE128]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: After the header and other metadata, two blobs with index and vertex data are
    stored.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头部和其他元数据之后，存储了两个包含索引和顶点数据的块。
- en: '[PRE129]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Let’s put all this code to work in our demo app.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把所有这些代码应用到我们的演示应用中。
- en: How it works...
  id: totrans-422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The mesh conversion framework is a part of our demo app. Let’s take a look
    at that part in the `Chapter05/07_MeshRenderer/src/main.cpp` file:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 网格转换框架是我们演示应用的一部分。让我们看看`Chapter05/07_MeshRenderer/src/main.cpp`文件中的这部分内容：
- en: First, we check if there’s any valid cached mesh data available. The `isMeshDataValid()`
    function checks if the specified cached mesh file exists and does some routine
    sanity checks on the data sizes.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们检查是否有有效的缓存网格数据可用。`isMeshDataValid()` 函数检查指定的缓存网格文件是否存在，并对数据大小进行一些常规的合理性检查。
- en: '[PRE130]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Then, we use the `isMeshDataValid()` function to load the Lumberyard Bistro
    dataset:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`isMeshDataValid()`函数加载Lumberyard Bistro数据集：
- en: '[PRE131]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'If the data is already precached, we just load it using the `loadMeshData()`
    described earlier in this recipe:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果数据已经预缓存，我们只需使用前面在本配方中描述的`loadMeshData()`加载它：
- en: '[PRE132]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: The output mesh data is saved into the file `.cache/ch05_bistro.meshes`. Let’s
    go through the rest of this chapter to learn how to render this mesh with Vulkan.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的网格数据被保存到文件`.cache/ch05_bistro.meshes`中。让我们继续本章的其余部分，学习如何使用Vulkan渲染这个网格。
- en: Indirect rendering in Vulkan
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vulkan中的间接渲染
- en: Indirect rendering is the process of issuing drawing commands to the graphics
    API, where most of the parameters to those commands come from GPU buffers. It
    is a part of many modern GPU usage paradigms and exists in all contemporary rendering
    APIs in some form. For example, we can do indirect rendering with Vulkan using
    the `vkCmdDraw*Indirect*()` family of functions. Instead of dealing with low-level
    Vulkan here, let’s get more technical and learn how to combine indirect rendering
    in Vulkan with the mesh data format we introduced in the *Organizing mesh data
    storage* recipe.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 间接渲染是将绘图命令发送到图形API的过程，其中这些命令的大多数参数来自GPU缓冲区。它是许多现代GPU使用范例的一部分，并以某种形式存在于所有当代渲染API中。例如，我们可以使用Vulkan的`vkCmdDraw*Indirect*()`函数系列进行间接渲染。在这里不处理低级Vulkan，让我们更深入地了解如何将Vulkan中的间接渲染与我们在*组织网格数据存储*配方中介绍的网格数据格式相结合。
- en: Getting ready
  id: totrans-433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the earlier recipes, we covered building a mesh preprocessing pipeline and
    converting 3D meshes from transmission formats such as `.gltf2` into our run-time
    mesh data format. To wrap up this chapter, let’s demonstrate how to render this
    data. To delve into something new, let’s explore how to achieve this using the
    indirect rendering technique.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配方中，我们介绍了构建网格预处理管道和将3D网格从`.gltf2`等传输格式转换为我们的运行时网格数据格式。为了结束这一章，让我们展示如何渲染这些数据。为了探索新的内容，让我们探讨如何使用间接渲染技术实现这一点。
- en: Once we have defined the mesh data structures, we also need to render them.
    To do so, we allocate GPU buffers for vertex and index data using the previously
    described functions, upload all the data to the GPU, and finally, render all the
    meshes.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了网格数据结构，我们还需要渲染它们。为此，我们使用之前描述的函数为顶点和索引数据分配GPU缓冲区，将所有数据上传到GPU，最后渲染所有网格。
- en: The whole point of the previously defined `Mesh` data structure is the ability
    to render multiple meshes in a single Vulkan command. Since version 1.0 of the
    API, Vulkan supports the technique of indirect rendering. This means we do not
    need to issue the `vkCmdDraw()` command for each and every mesh. Instead, we create
    a GPU buffer and fill it with an array of `VkDrawIndirectCommand` structures,
    then fill these structures with appropriate offsets into our index and vertex
    data buffers, and finally emit a single `vkCmdDrawIndirect()` call. The `Mesh`
    structure described in the *Organizing mesh data storage* recipe contains the
    data required to fill in `VkDrawIndirectCommand`.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 之前定义的`Mesh`数据结构的全部意义在于能够在单个Vulkan命令中渲染多个网格。自API的1.0版本以来，Vulkan支持间接渲染技术。这意味着我们不需要为每个网格发出`vkCmdDraw()`命令。相反，我们创建一个GPU缓冲区，并用`VkDrawIndirectCommand`结构数组的填充，然后在这些结构中填充适当的偏移量到我们的索引和顶点数据缓冲区中，最后发出单个`vkCmdDrawIndirect()`调用。*组织网格数据存储*配方中描述的`Mesh`结构包含填充`VkDrawIndirectCommand`所需的数据。
- en: The full source code for this recipe is located in `Chapter05/07_MeshRenderer`.
    It is recommended to revisit the *Organizing mesh data storage* and *Implementing
    automatic geometry conversion* recipes before reading further.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方完整的源代码位于`Chapter05/07_MeshRenderer`。在继续阅读之前，建议重新查看*组织网格数据存储*和*实现自动几何转换*配方。
- en: How to do it...
  id: totrans-438
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let’s implement a simple helper class called `VKMesh` to render our mesh using
    *LightweightVK*:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个简单的辅助类`VKMesh`，使用*LightweightVK*来渲染我们的网格：
- en: 'We need three buffers, an index buffer, a vertex buffer, and an indirect buffer,
    as well as three shaders and a rendering pipeline:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要三个缓冲区，一个索引缓冲区、一个顶点缓冲区和间接缓冲区，以及三个着色器和渲染管线：
- en: '[PRE133]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The constructor accepts references to `MeshFileHeader` and `MeshData`, which
    we loaded in the previous recipe, *Implemented automatic geometry conversion*.
    The data buffers are used as-is and uploaded directly into the respective Vulkan
    buffers. The number of indices is inferred from the indices buffer size, assuming
    indices are stored as 32-bit unsigned integers. The depth format specification
    is required to create a corresponding rendering pipeline right here in this class:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数接受对`MeshFileHeader`和`MeshData`的引用，我们在之前的配方*实现了自动几何转换*中加载了它们。数据缓冲区按原样使用并直接上传到相应的Vulkan缓冲区。索引的数量从索引缓冲区大小推断出来，假设索引以32位无符号整数存储。需要深度格式规范来创建相应的渲染管道，就在这个类中：
- en: '[PRE134]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Create vertex and index buffers and upload the data into them:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建顶点和索引缓冲区并将数据上传到它们：
- en: '[PRE135]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Allocate the data storage for our indirect buffer:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的间接缓冲区分配数据存储：
- en: '[PRE136]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Store the number of draw commands at the very beginning of the indirect buffer.
    This approach is not used in this demo but can be useful for GPU-driven rendering
    when the GPU calculates the number of draw commands and stores it in a buffer.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在间接缓冲区的开头存储绘制命令的数量。这种方法在本演示中没有使用，但在GPU驱动的渲染中可能很有用，当GPU计算绘制命令的数量并将其存储在缓冲区中时。
- en: '[PRE137]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Fill in the content of our indirect commands buffer. Each command corresponds
    to a single `Mesh` structure. The indirect buffer should be allocated with the
    `BufferUsageBits_Indirect` usage flag.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填充我们的间接命令缓冲区的内容。每个命令对应一个单独的`Mesh`结构。间接缓冲区应该使用`BufferUsageBits_Indirect`使用标志分配。
- en: '[PRE138]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '`DrawIndexedIndirectCommand` is just our mirror-image of `VkDrawIndexedIndirectCommand`
    to prevent including Vulkan headers into our app. While this might be an exaggeration
    for a Vulkan book, this type of separation might be useful in real-world apps
    considering this data structure is compatible in Vulkan, Metal, and OpenGL.'
  id: totrans-452
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`DrawIndexedIndirectCommand`只是我们与`VkDrawIndexedIndirectCommand`的镜像，以防止将Vulkan头文件包含到我们的应用程序中。虽然这可能对Vulkan书籍来说有些夸张，但这种类型的分离在现实世界的应用程序中可能很有用，考虑到这种数据结构在Vulkan、Metal和OpenGL中都是兼容的。'
- en: ''
  id: totrans-453
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`struct DrawIndexedIndirectCommand { uint32_t count; uint32_t instanceCount;
    uint32_t firstIndex; uint32_t baseVertex; uint32_t baseInstance;};`'
  id: totrans-454
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`struct DrawIndexedIndirectCommand { uint32_t count; uint32_t instanceCount;
    uint32_t firstIndex; uint32_t baseVertex; uint32_t baseInstance;};`'
- en: '[PRE139]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The rendering pipeline is created using a set of vertex, geometry, and fragment
    shaders. The geometry shader is used for barycentric coordinates generation to
    render beautiful wireframes. The vertex stream descriptions from `meshData.streams`
    can be used directly to initialize the pipeline’s vertex input:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染管道使用一组顶点、几何和片段着色器创建。几何着色器用于生成重心坐标以渲染漂亮的线框。可以直接使用`meshData.streams`中的顶点流描述来初始化管道的顶点输入：
- en: '[PRE140]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The `draw()` method fills in a corresponding Vulkan command buffer to render
    the entire mesh. Note how `cmdDrawIndexedIndirect()` skips the first 32 bits of
    the indirect buffer where the number of commands is located. We will put that
    number to use in *Chapter 11*, *Advanced Rendering Techniques and Optimizations*:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`draw()`方法填充相应的Vulkan命令缓冲区以渲染整个网格。注意`cmdDrawIndexedIndirect()`跳过了间接缓冲区中命令数量的前32位。我们将在*第11章*，*高级渲染技术和优化*中使用这个数字：'
- en: '[PRE141]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'This class is used as follows after the Bistro mesh is loaded:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在加载Bistro网格后，此类被如下使用：
- en: '[PRE142]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'This completes the description of our initialization process. Now, let’s turn
    to the GLSL source code:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们初始化过程的描述。现在，让我们转向GLSL源代码：
- en: The vertex shader `Chapter05/07_MeshRenderer/src/main.vert` is quite simple.
    We do not use programmable vertex fetching here for the sake of simplicity. Only
    standard per-vertex attributes are used to simplify the example.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶点着色器`Chapter05/07_MeshRenderer/src/main.vert`相当简单。我们为了简单起见不使用可编程顶点提取。仅使用标准的顶点属性来简化示例。
- en: '[PRE143]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'The geometry shader, `Chapter05/07_MeshRenderer/src/main.geom`, provides the
    necessary barycentric coordinates, as described earlier in this chapter:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几何着色器`Chapter05/07_MeshRenderer/src/main.geom`提供了必要的重心坐标，如本章前面所述：
- en: '[PRE144]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'The fragment shader, `Chapter05/07_MeshRenderer/src/main.frag`, calculates
    some improvized lighting and applies a wireframe outline based on the barycentric
    coordinates generated by the geometry shader, as described in the *Integrating
    tessellation into the graphics pipeline* recipe:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 片段着色器`Chapter05/07_MeshRenderer/src/main.frag`计算一些改进的光照，并根据几何着色器生成的重心坐标应用线框轮廓，如*将细分集成到图形管道*配方中所述：
- en: '[PRE145]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'The final C++ rendering code snippet is straightforward because all the heavy
    lifting is already done inside the `VKMesh` helper class:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终的C++渲染代码片段很简单，因为所有繁重的工作已经在`VKMesh`辅助类内部完成了：
- en: '[PRE146]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'The running application will render the following image, if the image is loaded
    with the Lumberyard Bistro mesh:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用Lumberyard Bistro网格加载图像，运行中的应用程序将渲染以下图像：
- en: '![Figure 5.7: Amazon Lumberyard Bistro mesh geometry loaded and rendered](img/file37.png)'
  id: totrans-472
  prefs: []
  type: TYPE_IMG
  zh: '![图5.7：Amazon Lumberyard Bistro网格几何加载和渲染](img/file37.png)'
- en: 'Figure 5.7: Amazon Lumberyard Bistro mesh geometry loaded and rendered'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7：Amazon Lumberyard Bistro网格几何加载和渲染
- en: Generating textures in Vulkan using compute shaders
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用计算着色器在Vulkan中生成纹理
- en: We learned how to use basic compute shaders earlier in this chapter, in the
    *Implementing instanced meshes with compute shaders* recipe. It is time to go
    through a few examples of how to use them. Let’s start with some basic procedural
    texture generation. In this recipe, we implement a small program to display animated
    textures whose texel values are calculated in real time inside our custom compute
    shader. To add even more value to this recipe, we will port a GLSL shader from
    [https://www.shadertoy.com](https://www.shadertoy.com) to our Vulkan compute shader.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章早期学习了如何使用基本的计算着色器，在 *使用计算着色器实现实例网格* 菜谱中。现在是时候通过一些示例来了解如何使用它们了。让我们从一些基本的程序纹理生成开始。在这个菜谱中，我们实现了一个小程序来显示动画纹理，其
    texel 值是在我们的自定义计算着色器中实时计算的。为了给这个菜谱增加更多的价值，我们将从 [https://www.shadertoy.com](https://www.shadertoy.com)
    将一个 GLSL 着色器移植到我们的 Vulkan 计算着色器中。
- en: Getting ready
  id: totrans-476
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: The compute pipeline creation code and Vulkan application initialization are
    the same as in the *Implementing instanced meshes with compute shaders* recipe.
    Make sure you read it before proceeding further. To use and display the generated
    texture, we need a textured full-screen quad renderer. Its GLSL source code can
    be found in `data/shaders/Quad.vert` and `data/shaders/Quad.frag`. However, the
    geometry used is actually a triangle covering the entire screen. We will not focus
    on its internals here because at this point, it should be easy for you to render
    a full-screen quad on your own using the material from the previous chapters.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 计算管线创建代码和 Vulkan 应用程序初始化与 *使用计算着色器实现实例网格* 菜谱相同。在继续之前，请确保您已经阅读了它。为了使用和显示生成的纹理，我们需要一个纹理的全屏四边形渲染器。其
    GLSL 源代码可以在 `data/shaders/Quad.vert` 和 `data/shaders/Quad.frag` 中找到。然而，实际使用的几何形状是一个覆盖整个屏幕的三角形。我们在这里不会关注其内部结构，因为在这个阶段，您应该能够使用前几章中的材料自己渲染全屏四边形。
- en: 'The original shader, “Industrial Complex,” that we are going to use here to
    generate a Vulkan texture was created by Gary “Shane” Warne ([rhomboid.com](https://www.rhomboid.com))
    and can be downloaded from ShaderToy: [https://www.shadertoy.com/view/MtdSWS](https://www.shadertoy.com/view/MtdSWS).'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要在这里使用以生成 Vulkan 纹理的原始着色器，“工业综合体”，是由 Gary “Shane” Warne ([rhomboid.com](https://www.rhomboid.com))
    创建的，并且可以从 ShaderToy 下载：[https://www.shadertoy.com/view/MtdSWS](https://www.shadertoy.com/view/MtdSWS)。
- en: How to do it...
  id: totrans-479
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let’s start by discussing the process of writing a texture-generating GLSL
    compute shader. The simplest shader to generate an RGBA image without using any
    input data outputs an image by using the `gl_GlobalInvocationID` built-in variable
    to calculate which pixel to output. This maps directly to how ShaderToy shaders
    operate, thus we can transform them into a compute shader just by adding some
    input and output parameters and layout modifiers that are specific to compute
    shaders and Vulkan. Let’s take a look at a minimalistic compute shader that creates
    a red-green gradient texture:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论编写纹理生成 GLSL 计算着色器的过程。最简单的着色器是生成一个 RGBA 图像，它不使用任何输入数据，通过使用内置变量 `gl_GlobalInvocationID`
    来计算输出哪个像素。这直接映射到 ShaderToy 着色器的工作方式，因此我们只需添加一些针对计算着色器和 Vulkan 特定的输入和输出参数以及布局修饰符，就可以将它们转换为计算着色器。让我们看看一个创建红色-绿色渐变纹理的最小化计算着色器：
- en: 'As in all other compute shaders, one mandatory line at the beginning tells
    the driver how to distribute the workload on the GPU. In our case, we are processing
    tiles of 16x16 pixels – the local workgroup size, 16x16, is supported on many
    GPUs, and we will use it for compatibility purposes:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与所有其他计算着色器一样，在开头有一行强制性的代码告诉驱动程序如何在 GPU 上分配工作负载。在我们的情况下，我们正在处理 16x16 像素的瓦片 -
    16x16 的本地工作组大小在许多 GPU 上得到支持，我们将用它来确保兼容性：
- en: '[PRE147]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'The only buffer binding that we need to specify is the output image. This is
    the first time we have used the image type `image2D` in this book. Here, it means
    that the array `kTextures2DOut` contains an array of 2D images whose elements
    are nothing but pixels of a texture. The `writeonly` layout qualifier instructs
    the compiler to assume we will not read from this image in the shader. The binding
    is updated from the C++ code in the *Using Vulkan descriptor indexing* recipe
    in *Chapter 2, Getting Started with Vulkan*:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要指定的唯一缓冲区绑定是输出图像。这是我们在这本书中第一次使用图像类型 `image2D`。在这里，这意味着数组 `kTextures2DOut`
    包含一个 2D 图像数组，其元素只是纹理的像素。`writeonly` 布局限定符指示编译器假设我们不会在着色器中从这个图像中读取。绑定是从 *第 2 章，Vulkan
    入门* 中的 *使用 Vulkan 描述符索引* 菜谱的 C++ 代码中更新的：
- en: '[PRE148]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'The GLSL compute shading language provides a set of helper functions to retrieve
    various image attributes. We use the built-in `imageSize()` function to determine
    the size of an image in pixels, and the image ID is loaded from push constants:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GLSL计算着色语言提供了一套辅助函数来检索各种图像属性。我们使用内置的`imageSize()`函数来确定图像的像素大小，并将图像ID从推送常量中加载：
- en: '[PRE149]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'The built-in `gl_GlobalInvocationID` variable tells us which global element
    of our compute grid we are processing. To convert its value into 2D image coordinates,
    we divide it by the image dimensions. As we are dealing with 2D textures, only
    `x` and `y` components matter. The calling code from the C++ side executes the
    `vkCmdDispatch()` function and passes the output image size as the X and Y numbers
    of local workgroups:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内置的`gl_GlobalInvocationID`变量告诉我们正在处理我们的计算网格的哪个全局元素。要将它的值转换为2D图像坐标，我们需要将其除以图像的尺寸。由于我们处理的是2D纹理，只有`x`和`y`分量是重要的。从C++侧调用的代码执行`vkCmdDispatch()`函数，并将输出图像大小作为本地工作组的X和Y数字传递：
- en: '[PRE150]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'The actual real work we do in this shader is to call the `imageStore()` GLSL
    function:'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个着色器中我们实际要做的工作是调用`imageStore()` GLSL函数：
- en: '[PRE151]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Now, this example is rather limited, and all you get is a red-and-green gradient
    image. Let’s change it a little bit to use the actual shader code from ShaderToy.
    The compute shader that renders a Vulkan version of the “Industrial Complex” shader
    from ShaderToy, available via the following URL [https://shadertoy.com/view/MtdSWS](https://shadertoy.com/view/MtdSWS),
    can be found in the `Chapter05/08_ComputeTexture/src/main.comp` file.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个例子相当有限，你只能得到一个红绿渐变图像。让我们稍作修改，使用ShaderToy的实际着色器代码。渲染ShaderToy中“Industrial
    Complex”着色器的Vulkan版本的计算着色器，可通过以下URL获取[https://shadertoy.com/view/MtdSWS](https://shadertoy.com/view/MtdSWS)，可以在`Chapter05/08_ComputeTexture/src/main.comp`文件中找到。
- en: 'First, let’s copy the entire original ShaderToy GLSL code into our new compute
    shader. There is a function called `mainImage()` in there, which is declared as
    follows:'
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们将整个原始ShaderToy GLSL代码复制到我们的新计算着色器中。其中有一个名为`mainImage()`的函数，其声明如下：
- en: '[PRE152]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'We should replace it with a function that returns a `vec4` color instead of
    storing it in the output parameter:'
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该用一个返回`vec4`颜色的函数来替换它，而不是将其存储在输出参数中：
- en: '[PRE153]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Don’t forget to add an appropriate `return` statement at the end.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在最后添加一个适当的`return`语句。
- en: 'Now, let’s change the `main()` function of our compute shader to invoke `mainImage()`
    properly and do 5x5 accumulative antialiasing. It is a pretty neat trick:'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将我们的计算着色器的`main()`函数更改为正确调用`mainImage()`并执行5x5累积抗锯齿。这是一个相当巧妙的技巧：
- en: '[PRE154]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: There is still one issue that needs to be resolved before we can run this code.
    The ShaderToy code uses two custom input variables, `iTime` for the elapsed time
    and `iResolution`, which contains the size of the resulting image. To prevent
    any search and replace in the original GLSL code, we mimic these variables, one
    as a push constant and the other with a hardcoded value for simplicity.
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们可以运行此代码之前，还有一个问题需要解决。ShaderToy代码使用了两个自定义输入变量，`iTime`用于已过时间，`iResolution`包含结果的图像大小。为了防止在原始GLSL代码中进行任何搜索和替换，我们模拟了这些变量，一个作为推送常量，另一个使用硬编码值以简化处理。
- en: '[PRE155]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '**Note**'
  id: totrans-501
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意**'
- en: ''
  id: totrans-502
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The GLSL `imageSize()` function can be used to obtain the `iResolution` value
    based on the actual size of our texture. We leave it as an exercise to the reader.
  id: totrans-503
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: GLSL的`imageSize()`函数可以根据我们纹理的实际大小获取`iResolution`值。我们将其留给读者作为练习。
- en: 'The C++ code is rather short and consists of creating a texture and invoking
    the previously mentioned compute shader, inserting a Vulkan pipeline barrier,
    and rendering a textured full-screen quad:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: C++代码相当简短，包括创建一个纹理，调用之前提到的计算着色器，插入一个Vulkan管道屏障，并渲染一个纹理的全屏四边形：
- en: 'A texture is created using the `TextureUsageBits_Storage` usage flag to make
    it accessible to compute shaders:'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`TextureUsageBits_Storage`使用标志创建一个纹理，使其对计算着色器可访问：
- en: '[PRE156]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Compute and rendering pipelines are created the following way:'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算和渲染管道的创建方式如下：
- en: '[PRE157]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'When doing rendering, we provide the texture ID to both shaders and the current
    time to the compute shader using push constants:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进行渲染时，我们通过推送常量将纹理ID提供给两个着色器，并将当前时间提供给计算着色器：
- en: '[PRE158]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: A pipeline barrier that ensures that the compute shader finishes before texture
    sampling happens is created by LightweightVK when we specify a required texture
    dependency. Take a look at `lvk::CommandBuffer::transitionToShaderReadOnly()`
    for the low-level image barrier code. As our fullscreen shader uses a triangle
    covering the entire screen, draw 3 vertices of that triangle.
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们指定所需的纹理依赖项时，LightweightVK会创建一个管道屏障，确保计算着色器在纹理采样之前完成。查看`lvk::CommandBuffer::transitionToShaderReadOnly()`以获取低级图像屏障代码。由于我们的全屏着色器使用覆盖整个屏幕的三角形，所以绘制该三角形的3个顶点。
- en: '[PRE159]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'The running application should render the following image, which is similar
    to the output of [https://www.shadertoy.com/view/MtdSWS](https://www.shadertoy.com/view/MtdSWS):'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 运行的应用程序应渲染以下图像，该图像类似于[https://www.shadertoy.com/view/MtdSWS](https://www.shadertoy.com/view/MtdSWS)的输出：
- en: '![Figure 5.8: Using compute shaders to generate textures](img/file38.jpg)'
  id: totrans-514
  prefs: []
  type: TYPE_IMG
  zh: '![图5.8：使用计算着色器生成纹理](img/file38.jpg)'
- en: 'Figure 5.8: Using compute shaders to generate textures'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8：使用计算着色器生成纹理
- en: In the next recipe, we will continue learning the Vulkan compute pipeline and
    implement a mesh generation compute shader.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个配方中，我们将继续学习Vulkan计算管线并实现一个网格生成计算着色器。
- en: Implementing computed meshes
  id: totrans-517
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现计算网格
- en: In the *Generating textures in Vulkan using compute shaders* recipe, we learned
    how to write pixel data into textures from compute shaders. We are going to need
    that data in the next chapter to implement a BRDF precomputation tool for our
    physically-based rendering pipeline. But before that, let’s learn a few simple
    and interesting ways to use compute shaders in Vulkan and combine this feature
    with mesh geometry generation on the GPU.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 在“使用计算着色器在Vulkan中生成纹理”的配方中，我们学习了如何从计算着色器中将像素数据写入纹理。在下一章中，我们需要这些数据来实现一个用于基于物理渲染管道的BRDF预计算工具。但在那之前，让我们学习一些简单而有趣的方法来在Vulkan中使用计算着色器，并将这一特性与GPU上的网格几何生成相结合。
- en: We are going to run a compute shader to create the triangulated geometry of
    a 3D torus knot shape with different `P` and `Q` parameters.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将运行一个计算着色器来创建具有不同`P`和`Q`参数的3D环面结形状的三角化几何。
- en: '**Note**'
  id: totrans-520
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意**'
- en: ''
  id: totrans-521
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'A torus knot is a special kind of knot that lies on the surface of an unknotted
    torus in 3D space. Each torus knot is specified by a pair of coprime integers,
    p and q. To find out more, check out the Wikipedia page: [https://en.wikipedia.org/wiki/Torus_knot](https://en.wikipedia.org/wiki/Torus_knot).'
  id: totrans-522
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 环面结是一种特殊的结，它位于三维空间中未打结的环面表面上。每个环面结由一对互质的整数p和q指定。要了解更多信息，请查看维基百科页面：[https://en.wikipedia.org/wiki/Torus_knot](https://en.wikipedia.org/wiki/Torus_knot)。
- en: A compute shader generates vertex data, including positions, texture coordinates,
    and normal vectors. This data is stored in a buffer and later utilized as a vertex
    buffer to render a mesh in a graphics pipeline. To make the results more visually
    pleasing, we will implement real-time morphing between two different torus knots
    that is controllable from an ImGui widget. Let’s get started.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 计算着色器生成顶点数据，包括位置、纹理坐标和法向量。这些数据存储在缓冲区中，稍后作为顶点缓冲区用于图形管线中的网格渲染。为了使结果更具视觉吸引力，我们将实现两个不同环面结之间的实时变形，该变形可以通过ImGui小部件进行控制。让我们开始吧。
- en: Getting ready
  id: totrans-524
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: The source code for this example is located in `Chapter05/09_ComputeMesh`.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的源代码位于`Chapter05/09_ComputeMesh`。
- en: How to do it...
  id: totrans-526
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'The application consists of multiple parts: the C++ part (which drives the
    UI and Vulkan commands), the mesh generation compute shader, the texture generations
    compute shader, and a rendering pipeline with simple vertex and fragment shaders.
    The C++ part in `Chapter05/09_ComputeMesh/src/main.cpp` is quite short, so let’s
    tackle it first:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序由多个部分组成：C++部分（驱动UI和Vulkan命令）、网格生成计算着色器、纹理生成计算着色器以及一个具有简单顶点和片段着色器的渲染管线。`Chapter05/09_ComputeMesh/src/main.cpp`中的C++部分相当简短，所以让我们先处理它：
- en: 'We store a queue of P-Q pairs, which defines the order of morphing. The queue
    always has at least two elements, which define the current and the next torus
    knot. We also store a floating point value, `g_MorphCoef`, which is the morphing
    factor `0...1` between the two adjacent P-Q pairs in the queue. The mesh is regenerated
    in every frame, and the morphing coefficient is increased until it reaches `1.0`.
    At this point, we will either stop morphing or, if there are more than two elements
    in the queue, remove the top element from it, reset `g_MorphCoef` to `zero`, and
    repeat. The `g_AnimationSpeed` value defines how fast one torus knot mesh morphs
    into another. The `g_UseColoredMesh` Boolean flag is used to switch between colored
    and textured shading of the mesh:'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们存储一个 P-Q 对的队列，它定义了形态的顺序。队列始终至少有两个元素，它们定义了当前和下一个环面结。我们还存储一个浮点值 `g_MorphCoef`，它是队列中相邻两个
    P-Q 对之间的形态因子 `0...1`。网格在每一帧中都会重新生成，形态系数会增加，直到达到 `1.0`。在此点，我们将停止形态或，如果队列中有超过两个元素，从队列中移除顶部元素，将
    `g_MorphCoef` 重置为 `zero` 并重复。`g_AnimationSpeed` 值定义了一个环面结网格如何快速地形态为另一个。`g_UseColoredMesh`
    布尔标志用于在网格的彩色和纹理着色之间切换：
- en: '[PRE160]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Two global constants define the tessellation level of a torus knot. Feel free
    to play around with them:'
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个全局常量定义了环面结的细分级别。您可以随意调整它们：
- en: '[PRE161]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Regardless of the `P` and `Q` parameter values, we have a single order in which
    we should traverse vertices to produce torus knot triangles. The `generateIndices()`
    function prepares index buffer data for this purpose. Here, `6` is the number
    of indices generated for each rectangular grid element consisting of `2` triangles:'
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论 `P` 和 `Q` 参数值如何，我们都有一个顺序，应该遍历顶点以生成环面结三角形。`generateIndices()` 函数为此目的准备索引缓冲区数据。在这里，`6`
    是每个由 `2` 个三角形组成的矩形网格元素生成的索引数：
- en: '[PRE162]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Additionally, our C++ code operates an ImGui UI for selecting a configuration
    of a torus knot and managing various parameters. This offers insights into the
    code’s flow, so let’s examine it more closely:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的 C++ 代码运行一个 ImGui UI，用于选择环面结的配置和管理各种参数。这有助于了解代码的流程，因此让我们更仔细地检查它：
- en: Each torus knot is specified by a pair of coprime integers, `P` and `Q`. Here,
    we have preselected a few pairs that produce visually interesting results.
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个环面结由一对互质的整数 `P` 和 `Q` 定义。在这里，我们预先选择了一些产生视觉上有趣结果的配对。
- en: '[PRE163]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: We can control the morphing animation speed. That is how fast one mesh morphs
    into another. We can also switch between colored and textured shading of the mesh.
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以控制形态动画的速度。这就是一个网格如何快速地形态为另一个。我们还可以在网格的彩色和纹理着色之间切换。
- en: '[PRE164]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: When we click a button with a different set of `P`-`Q` parameters, we don’t
    regenerate the mesh right away. Instead, we let any ongoing animations complete
    by adding a new pair to a queue. In the main loop, after the current morphing
    animation concludes, we remove the front element from the queue and initiate the
    animation again.
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们点击一个具有不同 `P`-`Q` 参数集的按钮时，我们不会立即重新生成网格。相反，我们通过向队列添加一个新对来让任何正在进行的动画完成。在主循环中，当前形态动画结束后，我们从队列中移除前面的元素并再次启动动画。
- en: '[PRE165]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'The content of the morph queue is printed here for you. The current `P`-`Q`
    pair is marked with `“<---”`:'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里打印了形态队列的内容。当前的 `P`-`Q` 对用 `“<---”` 标记：
- en: '[PRE166]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'If we apply an animated texture for shading the mesh, let’s also showcase it
    using `ImGui::Image()`:'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们为网格着色应用动画纹理，让我们也使用 `ImGui::Image()` 展示它：
- en: '[PRE167]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Now, let’s examine the C++ code that’s responsible for creating buffers and
    populating them with initial data:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查负责创建缓冲区并将初始数据填充到其中的 C++ 代码：
- en: The indices are immutable and are generated using the previously mentioned `generateIndices()`
    function. The vertex buffer size is calculated based on `12` `float` elements
    per vertex. That is `vec4` positions, `vec4` texture coordinates, and `vec4` normal
    vectors. This padding is used to simplify the compute shader that writes to the
    vertex buffer.
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 索引是不可变的，并使用之前提到的 `generateIndices()` 函数生成。顶点缓冲区大小基于每个顶点的 `12` 个 `float` 元素计算。这是
    `vec4` 位置、`vec4` 纹理坐标和 `vec4` 法向量。这种填充用于简化写入顶点缓冲区的计算着色器。
- en: '[PRE168]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Let’s create a texture that will be generated by a compute shader. This is similar
    to the previous recipe, *Generating textures in Vulkan using compute shaders*.
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个将由计算着色器生成的纹理。这与之前的配方类似，*使用计算着色器在 Vulkan 中生成纹理*。
- en: '[PRE169]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'The vertex buffer should be created with the `BufferUsageBits_Storage` flag
    to allow vertex shader usage:'
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶点缓冲区应该使用 `BufferUsageBits_Storage` 标志创建，以允许顶点着色器使用：
- en: '[PRE170]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'We create two compute pipelines: one for mesh generation and another for texture
    generation.'
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了两个计算管线：一个用于网格生成，另一个用于纹理生成。
- en: '[PRE171]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Shader modules are loaded as usual. The geometry shader generates barycentric
    coordinates for wireframe outlines. Wireframe outline rendering will be enabled
    if you set `kNumU` and `kNumV` to `64` or lower values.
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 着色器模块按常规加载。几何着色器为线框轮廓生成重心坐标。如果你将 `kNumU` 和 `kNumV` 设置为 `64` 或更低的值，将启用线框轮廓渲染。
- en: '[PRE172]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'For vertex input, we employ `vec4` to simplify padding concerns—or, to be more
    precise, to eliminate them entirely:'
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于顶点输入，我们使用 `vec4` 来简化填充问题——或者，更准确地说，是为了完全消除它们：
- en: '[PRE173]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'The same shader code is specialized for textures and colored shading using
    specialization constants:'
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相同的着色器代码针对纹理和彩色着色使用专用常数进行专门化：
- en: '[PRE174]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'The final segment of the C++ code is the rendering loop. Let’s explore how
    to populate a command buffer:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 代码的最后一部分是渲染循环。让我们探索如何填充命令缓冲区：
- en: 'First, we need to access the current `P`-`Q` pair from the morph queue:'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要从形变队列中访问当前的 `P`-`Q` 对：
- en: '[PRE175]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: The number of parameters for the shaders is larger than usual, precisely `128`
    bytes. Push constants are shared across all shaders, compute, and graphics, for
    convenience purposes and to simplify the code.
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 着色器的参数数量比通常情况下要多，精确到 `128` 字节。为了方便起见并简化代码，推送常数在所有着色器、计算和图形之间共享。
- en: '[PRE176]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'When we dispatch the mesh generation compute shader, we need to specify proper
    memory barriers to make sure the previous frame has finished rendering:'
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们调度网格生成计算着色器时，我们需要指定适当的内存屏障以确保前一帧已经完成渲染：
- en: '[PRE177]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: Do the same for the texture generation shader. We must ensure the texture regeneration
    is properly synchronized with rendering by issuing a Vulkan image layout transition
    with appropriate pipeline stages and masks. This is done by `LightweightVK` inside
    `lvk::CommandBuffer::cmdDispatchThreadGroups()` using a few empirical rules.
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于纹理生成着色器也做同样的处理。我们必须确保通过发出适当的管道阶段和掩码的 Vulkan 图像布局转换，纹理的重新生成与渲染正确同步。这是通过 `LightweightVK`
    在 `lvk::CommandBuffer::cmdDispatchThreadGroups()` 中使用一些经验规则完成的。
- en: '[PRE178]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: When we start rendering, it’s essential to specify both dependencies—the texture
    and the vertex buffer. The choice of the rendering pipeline depends on whether
    we aim to render a colored or textured mesh.
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们开始渲染时，指定两个依赖项——纹理和顶点缓冲区是至关重要的。渲染管道的选择取决于我们是否旨在渲染彩色或纹理网格。
- en: '[PRE179]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: The `renderGUI()` function renders the ImGui UI, as described earlier in this
    recipe. In this case, we pass our generated texture to it for presentation.
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`renderGUI()` 函数渲染 ImGui UI，如本食谱中之前所述。在这种情况下，我们将其生成的纹理传递给它进行展示。'
- en: '[PRE180]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: That covers the C++ part. Now, let’s delve into the GLSL shaders to understand
    how the whole demo works.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 这就涵盖了 C++ 部分。现在，让我们深入了解 GLSL 着色器，以了解整个演示是如何工作的。
- en: How it works…
  id: totrans-574
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let’s start with the compute shader, `Chapter05/09_ComputeMesh/src/main_mesh.comp`,
    which is responsible for generating vertex data:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从计算着色器开始，`Chapter05/09_ComputeMesh/src/main_mesh.comp`，它负责生成顶点数据：
- en: 'The push constants are declared in `Chapter05/09_ComputeMesh/src/common.sp`.
    They are shared between all shaders, and we paste them here for convenience:'
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推送常数在 `Chapter05/09_ComputeMesh/src/common.sp` 中声明。它们在所有着色器之间共享，我们在这里粘贴它们以方便使用：
- en: '[PRE181]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: This is the structure containing per-vertex data that we aim to generate and
    write into a buffer referenced by `VertexBuffer`, which is stored in `pc.bufferId`
    a few lines above the buffer.
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是包含我们旨在生成并写入由 `VertexBuffer` 引用的缓冲区中的顶点数据的结构，该缓冲区存储在 `pc.bufferId` 几行之上。
- en: '[PRE182]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'The heart of our mesh generation algorithm is the `torusKnot()` function, which
    uses the following parametrization to triangulate a torus knot [https://en.wikipedia.org/wiki/Torus_knot](https://en.wikipedia.org/wiki/Torus_knot):'
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们网格生成算法的核心是 `torusKnot()` 函数，它使用以下参数化来对环面结进行三角剖分 [https://en.wikipedia.org/wiki/Torus_knot](https://en.wikipedia.org/wiki/Torus_knot)：
- en: '[PRE183]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'The `torusKnot()` function is rather long and is implemented directly from
    the previously mentioned parametrization. Feel free to play with the `baseRadius`,
    `segmentRadius`, and `tubeRadius` values:'
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`torusKnot()` 函数相当长，并且直接从之前提到的参数化实现。您可以随意调整 `baseRadius`、`segmentRadius` 和
    `tubeRadius` 的值：'
- en: '[PRE184]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'We are running this compute shader in each frame, so, instead of generating
    a static set of vertices, we can actually pre-transform them to make the mesh
    look like it is rotating. Here is a couple of helper functions to compute the
    appropriate rotation matrices:'
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在每一帧中运行这个计算着色器，因此，而不是生成静态的顶点集，我们实际上可以预先变换它们，使网格看起来像是在旋转。这里有一些辅助函数来计算适当的旋转矩阵：
- en: '[PRE185]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'Using the previously mentioned helpers, the `main()` function of our compute
    shader is now straightforward, and the only interesting thing worth mentioning
    here is the real-time morphing that blends two torus knots with different `P`
    and `Q` parameters. This is pretty easy because the total number of vertices always
    remains the same:'
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前面提到的辅助函数，我们的计算着色器的`main()`函数现在很简单，唯一值得注意的有趣之处是实时变形，它将具有不同`P`和`Q`参数的两个环面结混合在一起。这很简单，因为顶点的总数始终保持不变：
- en: '[PRE186]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Two sets of UV coordinates for parametrization need to be computed:'
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要计算两组UV坐标以进行参数化：
- en: '[PRE187]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'Compute the model matrix for our mesh by combining two rotation matrices:'
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过组合两个旋转矩阵来计算我们的网格的模型矩阵：
- en: '[PRE188]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Compute two vertex positions for two different torus knots defined by the two
    sets of `P`-`Q` parameters: `P1`-`Q1` and `P2`-`Q2`.'
  id: totrans-592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算由两组`P`-`Q`参数定义的两个不同环面结的两个顶点位置：`P1`-`Q1`和`P2`-`Q2`。
- en: '[PRE189]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'Perform a linear blend between them using the `pc.morph` coefficient. We only
    need to blend the position and the normal vector. While normal vectors can be
    interpolated more gracefully, we leave that as another exercise for our readers:'
  id: totrans-594
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pc.morph`系数在这两者之间执行线性混合。我们只需要混合位置和法线向量。虽然法线向量可以更优雅地插值，但我们将其留作读者另一项练习：
- en: '[PRE190]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'Fill in the resulting `VertexData` structure and store it in the output vertex
    buffer:'
  id: totrans-596
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填充结果`VertexData`结构并将其存储在输出顶点缓冲区中：
- en: '[PRE191]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'The vertex shader looks as follows. Just note that the vertex attributes have
    proper types here:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器如下所示。请注意，这里的顶点属性有适当的类型：
- en: '[PRE192]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'The geometry shader is trivial because the only thing it does is generate barycentric
    coordinates as described in *Integrating tessellation into the graphics pipeline*.
    So, let’s jump straight to the fragment shader, `Chapter05/09_ComputeMesh/src/main.frag`:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 几何着色器很简单，因为它所做的唯一事情是生成如*将细分整合到图形管线中*中所述的重心坐标。所以，让我们直接跳到片段着色器，`Chapter05/09_ComputeMesh/src/main.frag`：
- en: 'The specialization constant is used to switch between the colored and textured
    versions of the shader:'
  id: totrans-601
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 专用常量用于在着色器的彩色和纹理版本之间切换：
- en: '[PRE193]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'Edge factor calculation for wireframe outlines as described in the *Integrating
    tessellation into the graphics pipeline* recipe:'
  id: totrans-603
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如*将细分整合到图形管线中*配方中所述的线框轮廓的边缘因子计算：
- en: '[PRE194]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'A function to calculate an RGB color for our mesh based on a floating point
    “hue” value:'
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个函数，根据浮点“色调”值计算我们的网格的RGB颜色：
- en: '[PRE195]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: For high values of `numU` and `numV`, the tessellation level is so dense that
    no distinct wireframe edges are visible—everything collapses into a black Moiré
    mess. We disable wireframe overlays for values greater than `64`.
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`numU`和`numV`的高值，细分级别非常密集，以至于没有明显的线框边缘可见——一切都会塌缩成一个黑色的摩尔纹混乱。我们禁用大于`64`的值上的线框叠加：
- en: '[PRE196]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: Last but not least, there’s a compute shader responsible for generating an animated
    texture. You can find it in `Chapter05/09_ComputeMesh/src/main_texture.comp`,
    and the idea is identical to the approach described in the previous recipe, *Generating
    textures in Vulkan using compute shaders*. We do not copy and paste that shader
    here.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，有一个计算着色器负责生成动画纹理。您可以在`Chapter05/09_ComputeMesh/src/main_texture.comp`中找到它，其思路与之前配方中描述的方法相同，*使用计算着色器在Vulkan中生成纹理*。我们在此处不复制和粘贴该着色器。
- en: 'The demo application will produce a variety of torus knots similar to the one
    in the following screenshot. Each time you select a new pair of `P`-`Q` parameters
    from the UI, the morphing animation will kick in and transform one knot into another.
    Checking the *Use colored mesh* box will apply colors to the mesh instead of a
    computed texture:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 演示应用程序将生成与以下截图类似的各种环面结。每次您从UI中选择新的`P`-`Q`参数对时，形态动画就会启动，将一个结转换成另一个。勾选*使用彩色网格*框将应用颜色到网格而不是计算的纹理：
- en: '![Figure 5.9: Computed mesh with real-time animation](img/file39.png)'
  id: totrans-611
  prefs: []
  type: TYPE_IMG
  zh: '![图5.9：带有实时动画的计算网格](img/file39.png)'
- en: 'Figure 5.9: Computed mesh with real-time animation'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9：带有实时动画的计算网格
- en: There’s more…
  id: totrans-613
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Refer to the Wikipedia page [https://en.wikipedia.org/wiki/Torus_knot](https://en.wikipedia.org/wiki/Torus_knot)
    for additional explanation of the math details. Try setting the values of `kNumU`
    and `kNumV` to `32` while checking “Use colored mesh”.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考维基百科页面[https://en.wikipedia.org/wiki/Torus_knot](https://en.wikipedia.org/wiki/Torus_knot)以获取关于数学细节的额外解释。尝试将`kNumU`和`kNumV`的值设置为`32`，同时勾选“使用彩色网格”。
- en: 'This is the initial recipe that involves an explicit synchronization process
    between two independent compute shaders and a rendering pass. The *LightweightVK*
    implementation aims to make this synchronization as seamless as possible through
    explicit dependency specification. In more complex real-world 3D applications,
    more fine-grained synchronization mechanisms would be desirable. Refer to the
    guide on Vulkan synchronization from Khronos for valuable insights on how to handle
    it effectively: [https://github.com/KhronosGroup/Vulkan-Docs/wiki/Synchronization-Examples](https://github.com/KhronosGroup/Vulkan-Docs/wiki/Synchronization-Examples).'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个涉及两个独立计算着色器之间显式同步过程以及渲染过程的初始配方。*LightweightVK*实现旨在通过显式依赖指定使这种同步尽可能无缝。在更复杂的现实世界3D应用中，更精细的同步机制将是所希望的。请参考Khronos的Vulkan同步指南，以获取关于如何有效处理它的宝贵见解：[https://github.com/KhronosGroup/Vulkan-Docs/wiki/Synchronization-Examples](https://github.com/KhronosGroup/Vulkan-Docs/wiki/Synchronization-Examples)。
