- en: '*Chapter 11*: Installing and Packaging'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：安装和打包'
- en: 'Our project has been built, tested, and documented. Now, it''s finally time
    to release it to our users. This chapter is mainly about the two last steps we''ll
    need to take to do that: installation and packaging. These are advanced techniques
    that build on top of everything we''ve learned so far: managing targets and their
    dependencies, transient usage requirements, generator expressions, and much more.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目已经构建、测试并文档化。现在，终于到了将其发布给用户的时候。本章主要介绍我们将要采取的最后两个步骤：安装和打包。这些都是建立在迄今为止我们所学习的一切之上的高级技术：管理目标和它们的依赖关系、瞬态使用需求、生成器表达式等等。
- en: Installation allows our project to be discoverable and accessible system-wide.
    In this chapter, we will cover how to export targets so that another project can
    use them without installation, as well as how to install our projects so that
    they can easily be used by any program on the system. In particular, we'll learn
    how to configure our project so that it can automatically put different artifact
    types in the correct directory. To handle more advanced scenarios, we'll introduce
    low-level commands for installing files and directories, as well as for executing
    custom scripts and CMake commands.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 安装使我们的项目能够在系统范围内被发现和访问。在本章中，我们将介绍如何导出目标，以便另一个项目可以在不安装的情况下使用它们，以及如何安装我们的项目，以便它们可以很容易地被系统上的任何程序使用。特别是，我们将学习如何配置我们的项目，使其可以自动将不同类型的工件放入正确的目录中。为了处理更高级的场景，我们将介绍用于安装文件和目录的低级命令，以及用于执行自定义脚本和CMake命令的命令。
- en: Next, we'll learn how to set up reusable CMake packages so that they can be
    discovered by calling `find_package()` from other projects. Specifically, we'll
    explain how to make sure that targets and their definitions are not fixed to a
    specific location on the filesystem. We'll also discuss how to write basic and
    advanced config files, along with the *version files* associated with packages.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何设置可重用的CMake包，以便它们可以被其他项目通过调用`find_package()`发现。具体来说，我们将解释如何确保目标和它们的定义不会固定在文件系统的特定位置。我们还将讨论如何编写基本和高级的配置文件，以及与包关联的*版本文件*。
- en: 'Then, to make things modular, we''ll briefly introduce the concept of components,
    both in terms of CMake packages and the `install()` command. All this preparation
    will pave the way for the final aspect we''ll be covering in this chapter: using
    CPack to generate archives, installers, bundles, and packages that are recognized
    by all kinds of package managers in different operating systems. These can be
    used to carry pre-built artifacts, executables, and libraries. It''s the easiest
    way for end users to start using our software.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了使事情模块化，我们将简要介绍组件的概念，包括CMake包和`install()`命令。所有这些准备将为本章我们将要涵盖的最后方面铺平道路：使用CPack生成各种包管理器在不同操作系统中认识的归档文件、安装程序、捆绑包和包。这些可以用来携带预构建的工件、可执行文件和库。这是最终用户开始使用我们的软件的最简单方法。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Exporting without installation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需安装导出
- en: Installing projects on the system
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在系统上安装项目
- en: Creating reusable packages
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可重用的包
- en: Defining components
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义组件
- en: Packaging with CPack
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CPack打包
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter11](https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter11).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码文件：[https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter11](https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter11)。
- en: 'To build examples provided in this book always use recommended commands:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建本书中提供的示例，请始终使用推荐命令：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Be sure to replace placeholders `<build tree>` and `<source tree>` with appropriate
    paths. As a reminder: **build tree** is the path to target/output directory, **source
    tree** is the path at which your source code is located.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保将占位符`<build tree>`和`<source tree>`替换为合适的路径。作为提醒：**构建树**是目标/输出目录的路径，**源树**是您的源代码所在的路径。
- en: Exporting without installation
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无需安装导出
- en: How can we make the targets of project `A` available to the consuming project
    `B`? Usually, we'd reach for the `find_package()` command, but that would mean
    that we'd need to create a package and install it on the system. That approach
    is useful, but it takes some work. Sometimes, we just need a really quick way
    to build a project and make its targets available for other projects.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使项目`A`的目标对消费项目`B`可用？通常，我们会使用`find_package()`命令，但这意味着我们需要创建一个包并在系统上安装它。这种方法很有用，但需要一些工作。有时，我们只是需要一种快速的方法来构建一个项目，并使其目标对其他项目可用。
- en: 'We could save some time by including the main listfile of `A`: it contains
    all the target definitions already. Unfortunately, it also potentially contains
    a lot of other things: global configuration, requirements, CMake commands with
    side effects, additional dependencies, and perhaps targets that we don''t want
    in `B` (such as unit tests). So, let''s not do that. It''s better to achieve this
    by providing `B`, can include with the `include()` command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过包含`A`的主列表文件来节省一些时间：它已经包含了所有的目标定义。不幸的是，它也可能包含很多其他内容：全局配置、需求、具有副作用的CMake命令、附加依赖项，以及我们可能不想在`B`中出现的目标（如单元测试）。所以，我们不要这样做。更好的方法是提供`B`，并通过`include()`命令包含：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Doing this will provide definitions (commands such as `add_library()` and `add_executable()`)
    for all the targets of `A` with the correct properties set.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此操作将为`A`的所有目标提供正确的属性集定义（如`add_library()`和`add_executable()`等命令）。
- en: 'Of course, we''re not going to write such a file manually – that wouldn''t
    be a very DRY approach. CMake can generate these files for us with the `export()`
    command, which has the following signature:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不会手动写这样的文件——这不会是一个非常DRY的方法。CMake可以用`export()`命令为我们生成这些文件，该命令具有以下签名：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We must supply all the targets that we''d like to export after the `TARGET`
    keyword and provide the destination filename after `FILE`. The other arguments
    are optional:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须提供所有我们想要导出的目标，在`TARGET`关键字之后，并提供目标文件名在`FILE`之后。其他参数是可选的：
- en: '`NAMESPACE` is recommended as a hint, stating that the target has been imported
    from other projects.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NAMESPACE`建议作为一个提示，说明目标已经从其他项目中导入。'
- en: '`APPEND` tells CMake that it shouldn''t erase the contents of the file before
    writing.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APPEND`告诉CMake在写入文件之前不要擦除文件的内容。'
- en: '`EXPORT_LINK_INTERFACE_LIBRARIES` will export target link dependencies (including
    imported and config-specific variants).'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPORT_LINK_INTERFACE_LIBRARIES`将导出目标链接依赖（包括导入和配置特定的变体）。'
- en: 'Let''s see this in action with our example Calc library, which provides two
    simple methods:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用我们示例中的Calc库来看看这个功能，它提供了两个简单的方法：
- en: chapter-11/01-export/src/include/calc/calc.h
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-11/01-export/src/include/calc/calc.h
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We declare its target like so:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样声明它的目标：
- en: chapter-11/01-export/src/CMakeLists.txt
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-11/01-export/src/CMakeLists.txt
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, we ask CMake to generate the export file with the `export(TARGETS)` command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们要求CMake使用`export(TARGETS)`命令生成导出文件：
- en: chapter-11/01-export/CMakeLists.txt (fragment)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-11/01-export/CMakeLists.txt（片段）
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, we can see that the `EXPORT_DIR` variable has been set
    to the `cmake` subdirectory of the build tree (as per the convention for `.cmake`
    files). Then, we export the target declaration file, `CalcTargets.cmake`, with
    a single target `calc` that's visible as `Calc::calc` for projects that will include
    this file.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到`EXPORT_DIR`变量已被设置为构建树中的`cmake`子目录（按照`.cmake`文件的约定）。然后，我们导出目标声明文件`CalcTargets.cmake`，其中有一个名为`calc`的单一目标，对于将包含此文件的工程项目，它将作为`Calc::calc`可见。
- en: Note that this export file is not a package yet. And, more importantly, all
    the paths in this file are absolute and hardcoded to the build tree. In other
    words, they're non-relocatable (we'll discuss this in the *Understanding the issues
    with relocatable targets* section).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个导出文件还不是包。更重要的是，这个文件中的所有路径都是绝对的，且硬编码到构建树中。换句话说，它们是不可移动的（我们将在*理解可移动目标的问题*部分讨论这个问题）。
- en: 'The `export()` command also has a shorter version:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`export()`命令还有一个更短的版本：'
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'However, it requires a `<export>` name rather than a list of exported targets.
    Such `<export>` instances are named lists of targets that are defined by `install(TARGETS)`
    (we''ll cover this command in the *Installing logical targets* section). Here''s
    a tiny example demonstrating how this shorthand is used in practice:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它需要一个`<export>`名称，而不是一个导出的目标列表。这样的`<export>`实例是由`install(TARGETS)`定义的目标的命名列表（我们将在*安装逻辑目标*部分介绍这个命令）。以下是一个演示如何在实际中使用这种简写法的微型示例：
- en: chapter-11/01-export/CMakeLists.txt (continued)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-11/01-export/CMakeLists.txt（续）
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code works exactly like the previous one, but now, a single target
    list between the `export()` and `install()` commands is being shared.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码与之前的代码完全一样，但现在，`export()` 和 `install()` 命令之间的单个目标列表被共享。
- en: 'Both ways of generating export files will produce the same results. They will
    contain some boilerplate code and a few lines defining the target. With `/tmp/b`
    set to the build tree path, they''ll look like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 生成导出文件的两个方法会产生相同的结果。它们将包含一些模板代码和几行定义目标的内容。将 `/tmp/b` 设置为构建树路径时，它们看起来像这样：
- en: /tmp/b/cmake/CalcTargets.cmake (fragment)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: /tmp/b/cmake/CalcTargets.cmake（片段）
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Normally, we wouldn't edit this file or even open it, but I wanted to highlight
    the hardcoded paths in this generated file. In its current form, the package is
    not relocatable. If we want to change that, we'll need to jump through some hoops
    first. We'll explore why that's important in the next section.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们不会编辑这个文件，甚至不会打开它，但我想要强调这个生成文件中的硬编码路径。以其当前形式，这个包是不可移动的。如果我们想要改变这一点，我们首先需要做一些跳跃。我们将在下一节探讨为什么这很重要。
- en: Installing projects on the system
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在系统上安装项目
- en: 'In [*Chapter 1*](B17205_01_Final_JC_ePub.xhtml#_idTextAnchor014), *First Steps
    with CMake*, we indicated that CMake offers a command-line mode that installs
    built projects on the system:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第*章 1*](B17205_01_Final_JC_ePub.xhtml#_idTextAnchor014) *CMake初学者*中，我们提到CMake提供了一个命令行模式，可以在系统上安装构建好的项目：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`<dir>` is the path to the generated build tree (required). Our `<options>`
    are as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`<dir>` 是生成构建树的目标路径（必需）。我们的 `<options>` 如下：'
- en: '`--config <cfg>`: This picks the build configuration for a multi-configuration
    generator.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--config <cfg>`：这对于多配置生成器，选择构建配置。'
- en: '`--component <comp>`: This limits the installation to the given component.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--component <comp>`：这限制了安装到给定组件。'
- en: '`--default-directory-permissions <permissions>`: This sets the default permissions
    for the installed directories (in `<u=rwx,g=rx,o=rx>` format).'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--default-directory-permissions <permissions>`：这设置了安装目录的默认权限（在 `<u=rwx,g=rx,o=rx>`
    格式中）。'
- en: '`--prefix <prefix>`: This specifies the non-default installation path (stored
    in the `CMAKE_INSTALL_PREFIX` variable). It defaults to `/usr/local` for Unix-like
    systems and `c:/Program Files/${PROJECT_NAME}` for Windows.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--prefix <prefix>`：这指定了非默认的安装路径（存储在 `CMAKE_INSTALL_PREFIX` 变量中）。对于类Unix系统，默认为
    `/usr/local`，对于Windows，默认为 `c:/Program Files/${PROJECT_NAME}`。'
- en: '`-v, --verbose`: This makes the output verbose (this can also be achieved by
    setting the `VERBOSE` environment variable).'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v, --verbose`：这会使输出详细（这也可以通过设置 `VERBOSE` 环境变量来实现）。'
- en: 'Installations can consist of many steps, but at their core, they copy the generated
    artifacts and the necessary dependencies to a directory somewhere on the system.
    Using CMake for installation not only introduces a convenient standard to all
    CMake projects but also does the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 安装可以由许多步骤组成，但它们的本质是将生成的工件和必要的依赖项复制到系统上的某个目录中。使用CMake进行安装不仅为所有CMake项目引入了一个方便的标准，而且还做了以下事情：
- en: Provides a platform-specific installation path for artifacts, depending on their
    types (by following *GNU Coding Standards*)
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为根据它们的类型提供特定于平台的安装路径（遵循*GNU编码标准*）
- en: Enhances the installation process by generating target export files, which allow
    project targets to be directly reused by other projects
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过生成目标导出文件，增强安装过程，允许项目目标直接被其他项目重用
- en: Creates discoverable packages through config files, which wrap the target export
    files and package-specific CMake macros and functions defined by the author
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过配置文件创建可发现的包，这些文件封装了目标导出文件以及作者定义的特定于包的CMake宏和函数
- en: These features are quite powerful as they save a lot of time and simplify the
    usage of projects that are prepared this way. The first step in performing a basic
    installation is copying the built artifacts to their destination directory.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能非常强大，因为它们节省了很多时间，并简化了以这种方式准备的项目使用。执行基本安装的第一步是将构建好的工件复制到目标目录。
- en: 'This brings us to the `install()` command and its various modes:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们来到了 `install()` 命令及其各种模式：
- en: '`install(TARGETS)`: This installs output artifacts such as libraries and executables.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`install(TARGETS)`：这会安装输出工件，如库和可执行文件。'
- en: '`install(FILES|PROGRAMS)`: This installs individual files and sets their permissions.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`install(FILES|PROGRAMS)`：这会安装单个文件并设置它们的权限。'
- en: '`install(DIRECTORY)`: This installs whole directories.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`install(DIRECTORY)`: 这会安装整个目录。'
- en: '`install(SCRIPT|CODE)`: This runs a CMake script or a snippet during installation.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`install(SCRIPT|CODE)`：在安装期间运行CMake脚本或代码段。'
- en: '`install(EXPORT)`: This generates and installs a target export file.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`install(EXPORT)`：这生成并安装一个目标导出文件。'
- en: Adding these commands to your listfile will generate a `cmake_install.cmake`
    file in your build tree. While it's possible to invoke this script manually with
    `cmake -P`, it isn't recommended. This file is meant to be used by CMake internally
    when `cmake --install` is executed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些命令添加到您的列表文件中将生成一个`cmake_install.cmake`文件在您的构建树中。虽然可以手动调用此脚本使用`cmake -P`，但不建议这样做。这个文件是用来在执行`cmake
    --install`时由CMake内部使用的。
- en: Note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Upcoming CMake versions will also support installing runtime artifacts and dependency
    sets, so be sure to check the latest documentation to learn more.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 即将推出的CMake版本还将支持安装运行时工件和依赖集合，因此请务必查阅最新文档以了解更多信息。
- en: 'Every `install()` mode has an extensive set of options. A few of them are shared
    and work the same way:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`install()`模式都有一组广泛的选项。其中一些是共享的，并且工作方式相同：
- en: '`DESTINATION`: This specifies the installation path. Relative paths will be
    prepended with `CMAKE_INSTALL_PREFIX`, while absolute paths are used verbatim
    (and not supported by `cpack`).'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DESTINATION`：这指定了安装路径。相对路径将前缀`CMAKE_INSTALL_PREFIX`，而绝对路径则直接使用（并且`cpack`不支持）。'
- en: '`PERMISSIONS`: This sets file permissions on platforms that support them. The
    available values are `OWNER_READ`, `OWNER_WRITE`, `OWNER_EXECUTE`, `GROUP_READ`,
    `GROUP_WRITE`, `GROUP_EXECUTE`, `WORLD_READ`, `WORLD_WRITE`, `WORLD_EXECUTE`,
    `SETUID`, and `SETGID`. The default permissions for directories that are created
    during installation time can be set by specifying the `CMAKE_INSTALL_DEFAULT_DIRECTORY_PERMISSIONS`
    variable.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PERMISSIONS`：这设置了支持它们的平台上的文件权限。可用的值有`OWNER_READ`、`OWNER_WRITE`、`OWNER_EXECUTE`、`GROUP_READ`、`GROUP_WRITE`、`GROUP_EXECUTE`、`WORLD_READ`、`WORLD_WRITE`、`WORLD_EXECUTE`、`SETUID`
    和 `SETGID`。在安装期间创建的目录的默认权限可以通过指定`CMAKE_INSTALL_DEFAULT_DIRECTORY_PERMISSIONS`变量来设置。'
- en: '`CONFIGURATIONS`: This specifies a list of configurations (`Debug`, `Release`).
    Any of the options in this command that follow this keyword will only be applied
    if the current build config is in this list.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIGURATIONS`：这指定了一个配置列表（`Debug`、`Release`）。此命令中跟随此关键字的所有选项仅当当前构建配置在此列表中时才会被应用。'
- en: '`OPTIONAL`: This disables raising errors when the installed files don''t exist.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OPTIONAL`：这禁用了在安装的文件不存在时引发错误。'
- en: 'Two shared options are also used in component-specific installations: `COMPONENT`
    and `EXCLUDE_FROM_ALL`. We''ll discuss these in detail in the *Defining components*
    section.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件特定安装中还使用了两个共享选项：`COMPONENT`和`EXCLUDE_FROM_ALL`。我们将在*定义组件*部分详细讨论这些内容。
- en: 'Let''s take a look at the first installation mode: `install(TARGETS)`.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看第一个安装模式：`install(TARGETS)`。
- en: Installing logical targets
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装逻辑目标
- en: 'Targets defined by `add_library()` and `add_executable()` can easily be installed
    with the `install(TARGETS)` command. This means copying the artifacts that have
    been produced by the buildsystem to the appropriate destination directories and
    setting suitable file permissions for them. The general signature for this mode
    is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由`add_library()`和`add_executable()`定义的目标可以很容易地使用`install(TARGETS)`命令安装。这意味着将构建系统产生的工件复制到适当的目标目录并将它们的文件权限设置为合适。此模式的通用签名如下：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After the initial mode specifier – that is, `TARGETS` – we must provide a list
    of targets we'd like to install. Here, we may optionally assign them to a `EXPORT`
    option, which can be used in `export(EXPORT)` and `install(EXPORT)` to produce
    a target export file. Then, we must configure the installation of output artifacts
    (grouped by type). Optionally, we can provide a list of directories that will
    be added to the target export file for each target in its `INTERFACE_INCLUDE_DIRECTORIES`
    property.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始模式指定符 – 即`TARGETS` – 之后，我们必须提供一个我们想要安装的目标列表。在这里，我们可以选择性地将它们分配给`EXPORT`选项，该选项可用于`export(EXPORT)`和`install(EXPORT)`以生成目标导出文件。然后，我们必须配置输出工件（按类型分组）的安装。可选地，我们可以提供一系列目录，这些目录将添加到每个目标在其`INTERFACE_INCLUDE_DIRECTORIES`属性中的目标导出文件中。
- en: '`[<output-artifact-configuration>...]` provides a list of configuration blocks.
    The full syntax of a single block is as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`[<output-artifact-configuration>...]` 提供了一个配置块列表。单个块的完整语法如下：'
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Every output artifact block has to start with `<TYPE>` (this is the only required
    element). CMake recognizes several of them:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 每个输出工件块都必须以`<TYPE>`开头（这是唯一必需的元素）。CMake识别它们中的几个：
- en: '`ARCHIVE`: Static libraries (`.a`) and DLL import libraries for Windows-based
    systems (`.lib`).'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ARCHIVE`：静态库（`.a`）和基于Windows系统的DLL导入库（`.lib`）。'
- en: '`LIBRARY`: Shared libraries (`.so`), but not DLLs.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LIBRARY`：共享库（`.so`），但不包括DLL。'
- en: '`RUNTIME`: Executables and DLLs.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUNTIME`：可执行文件和DLL。'
- en: '`OBJECTS`: *Object files* from `OBJECT` libraries.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OBJECTS`：来自`OBJECT`库的*对象文件*。'
- en: '`FRAMEWORK`: Static and shared libraries that have the `FRAMEWORK` property
    set (this excludes them from `ARCHIVE` and `LIBRARY`). This is macOS-specific.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FRAMEWORK`：设置了`FRAMEWORK`属性的静态和共享库（这使它们不属于`ARCHIVE`和`LIBRARY`）。这是macOS特定的。'
- en: '`BUNDLE`: Executables marked with `MACOSX_BUNDLE` (also not part of `RUNTIME`).'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BUNDLE`：标记有`MACOSX_BUNDLE`的可执行文件（也不是`RUNTIME`的一部分）。'
- en: '`PUBLIC_HEADER`, `PRIVATE_HEADER`, `RESOURCE`: Files specified in the target
    properties with the same name (on Apple platforms, they should be set on the `FRAMEWORK`
    or `BUNDLE` targets).'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUBLIC_HEADER`、`PRIVATE_HEADER`、`RESOURCE`：在目标属性中指定相同名称的文件（在苹果平台上，它们应该设置在`FRAMEWORK`或`BUNDLE`目标上）。'
- en: 'The CMake documentation claims that if you only configure one artifact type
    (for example, `LIBRARY`), only this type will be installed. For CMake version
    3.20.0, this is not true: all the artifacts will be installed as if they were
    configured with the default options. This can be solved by specifying `<TYPE>
    EXCLUDE_FROM_ALL` for all unwanted artifact types.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: CMake文档声称，如果你只配置了一种工件类型（例如，`LIBRARY`），只有这种类型将被安装。对于CMake 3.20.0版本，这并不正确：所有工件都将以默认选项配置的方式安装。这可以通过为所有不需要的工件类型指定`<TYPE>
    EXCLUDE_FROM_ALL`来解决。
- en: Note
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A single `install(TARGETS)` command can have multiple artifact configuration
    blocks. However, be aware that you may only specify one of each type per call.
    That is, if you'd like to configure different destinations of `ARCHIVE` artifacts
    for the `Debug` and `Release` configurations, then you must make two separate
    `install(TARGETS ... ARCHIVE)` calls.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 单个`install(TARGETS)`命令可以有多个工件配置块。但是，请注意，每次调用您可能只能指定每种类型的一个。也就是说，如果您想要为`Debug`和`Release`配置指定不同位置的`ARCHIVE`工件，那么您必须分别进行两次`install(TARGETS
    ... ARCHIVE)`调用。
- en: 'You may also omit the type name and specify options for all the artifacts:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以省略类型名称，为所有工件指定选项：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Installation would be then performed for every file that's produced by these
    targets, regardless of their type.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程将会对所有这些目标生成的文件进行，不论它们的类型是什么。
- en: Also, you don't always need to provide an installation directory with `DESTINATION`.
    Let's see why.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你并不总是需要为`DESTINATION`提供安装目录。让我们看看原因。
- en: Working out the correct destination for different platforms
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为不同平台确定正确的目的地
- en: 'The formula for a destination path is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 目标路径的公式如下所示：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If `DESTINATION` isn''t provided, CMake will use a built-in default for every
    type:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未提供`DESTINATION`，CMake将使用每个类型的内置默认值：
- en: '![](img/Table_11.1_B17205.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_11.1_B17205.jpg)'
- en: While default paths are sometimes useful, they aren't correct for every situation.
    For example, by default, CMake will "guess" that `DESTINATION` for libraries should
    be `lib`. The full path for libraries will be computed to `/usr/local/lib` for
    all Unix-like systems, and something like `C:\Program Files (x86)\<project-name>\lib`
    on Windows. This won't be a very good choice for Debian with multi-arch support,
    which requires a path to a specific architecture (for example, `i386-linux-gnu`)
    when `INSTALL_PREFIX` is `/usr`. Figuring out the correct path for every platform
    is a common problem for Unix-like systems. To get it right, we need to follow
    *GNU Coding Standards* (a link to this can be found in the *Further reading* section).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然默认路径有时很有用，但它们并不适用于每种情况。例如，默认情况下，CMake会“猜测”库的`DESTINATION`应该是`lib`。所有类Unix系统上的库的完整路径将被计算为`/usr/local/lib`，而在Windows上则是类似于`C:\Program
    Files (x86)\<项目名称>\lib`。这对于支持多架构的Debian来说不会是一个很好的选择，当`INSTALL_PREFIX`为`/usr`时，它需要一个特定架构（例如`i386-linux-gnu`）的路径。为每个平台确定正确的路径是类Unix系统的一个常见问题。为了做到正确，我们需要遵循*GNU编码标准*（在*进一步阅读*部分可以找到这个链接）。
- en: Before going with a "guess," CMake will check if a `CMAKE_INSTALL_<DIR>DIR`
    variable for this artifact type was set and use the path from there. What we need
    is an algorithm that will detect the platform and fill the install directory variables
    with the appropriate paths. CMake simplifies this by providing the `GNUInstallDirs`
    utility module, which handles most platforms by setting the install directory
    variables accordingly. Just `include()` it before calling any `install()` commands
    and you'll be set.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在采用“猜测”之前，CMake将检查是否为这种工件类型设置了`CMAKE_INSTALL_<DIR>DIR`变量，并使用从此处开始的路径。我们需要的是一个算法，能够检测平台并填充安装目录变量以提供适当的路径。CMake通过提供`GNUInstallDirs`实用模块简化了此操作，该模块处理大多数平台并相应地设置安装目录变量。在调用任何`install()`命令之前只需`include()`它，然后你就可以正常使用了。
- en: Users that need custom configuration can provide install directory variables
    through the command line with `-DCMAKE_INSTALL_BINDIR=/path/in/the/system`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 需要自定义配置的用户可以通过命令行使用`-DCMAKE_INSTALL_BINDIR=/path/in/the/system`提供安装目录变量。
- en: However, installing the public headers of libraries can be a little tricky.
    Let's see why.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，安装库的公共头文件可能会有些棘手。让我们来看看原因。
- en: Dealing with public headers
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理公共头文件
- en: 'The `install(TARGETS)` documentation recommends that we specify public headers
    (as a semicolon-separated list) in the `PUBLIC_HEADER` property of the library
    target:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`install(TARGETS)`文档建议我们在库目标的`PUBLIC_HEADER`属性中（用分号分隔）指定公共头文件：'
- en: chapter-11/02-install- targets/src/CMakeLists.txt
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-11/02-install-targets/src/CMakeLists.txt
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we''re using the default "guess" for Unix, files will end up in `/usr/local/include`.
    This isn''t necessarily the best practice. Ideally, we''d like to put these public
    headers in a directory that would indicate their origin and introduce namespacing;
    for example, `/usr/local/include/calc`. This will allow us to use them in all
    the projects on this system, like so:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用Unix的默认“猜测”方式，文件最终会出现在`/usr/local/include`。这并不一定是最佳实践。理想情况下，我们希望能够将这些公共头文件放在一个能表明它们来源并引入命名空间的目录中；例如，`/usr/local/include/calc`。这将允许我们在这个系统上的所有项目中使用它们，如下所示：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Most preprocessors recognize directives with angle brackets as a request to
    scan standard system directories. This is where the `GNUInstallDirs` module, which
    we mentioned earlier, comes in. It defines the installation variables for the
    `install()` command, though we can also use them explicitly. In this case, we
    want to prepend the public header''s destination, `calc`, with `CMAKE_INSTALL_INCLUDEDIR`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数预处理器将尖括号中的指令识别为扫描标准系统目录的请求。这就是我们之前提到的`GNUInstallDirs`模块的作用。它为`install()`命令定义了安装变量，尽管我们也可以显式使用它们。在这种情况下，我们想要在公共头文件的目的地`calc`前加上`CMAKE_INSTALL_INCLUDEDIR`：
- en: chapter-11/02-install-targets/CMakeLists.txt
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-11/02-install-targets/CMakeLists.txt
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After including the listfile from `src`, which defined our `calc` target, we
    must configure the installation of the static library and its public headers.
    We have included the `GNUInstallDirs` module and explicitly specified `DESTINATION`
    for `PUBLIC_HEADERS`. Running `cmake` in install mode will work exactly as expected:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在从`src`包含列表文件，定义了我们的`calc`目标之后，我们必须配置静态库及其公共头文件的安装。我们已经包含了`GNUInstallDirs`模块，并明确指定了`DESTINATION`为`PUBLIC_HEADERS`。以安装模式运行`cmake`将按预期工作：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This works well for this basic case, but there''s a slight drawback: files
    specified in this way don''t retain their directory structure. They will all be
    installed in the same destination, even if they''re nested in different base directories.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方式对于这个基本案例来说很好，但有一个轻微的缺点：以这种方式指定的文件不保留它们的目录结构。它们都将被安装在同一个目的地，即使它们嵌套在不同的基本目录中。
- en: 'There are plans for newer versions (CMake 3.23.0) to manage headers better
    with the `FILE_SET` keyword:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 计划在新版本中（CMake 3.23.0）使用`FILE_SET`关键字更好地管理头文件：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: See the *Further reading* section for a link to the discussion on official forums.
    Until that option is released, we can use this mechanism with the `PRIVATE_HEADER`
    and `RESOURCE` artifact types. But how can we specify a more complex installation
    directory structure?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有关官方论坛上的讨论，请参阅*进一步阅读*部分中的链接。在发布该选项之前，我们可以使用此机制与`PRIVATE_HEADER`和`RESOURCE`工件类型。但我们如何指定更复杂的安装目录结构呢？
- en: Low-level installation
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 低级安装
- en: 'Modern CMake is moving away from the concept of manipulating files directly.
    Ideally, we''d always add them to a logical target and use that as a higher level
    of abstraction to represent all the underlying assets: source files, headers,
    resources, configuration, and so on. The main advantage is the dryness of the
    code: usually, we won''t need to change more than one line to add a file to the
    target.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 CMake 正在逐步放弃直接操作文件的概念。理想情况下，我们总是将它们添加到一个逻辑目标中，并使用这个更高层次的抽象来表示所有底层资产：源文件、头文件、资源、配置等等。主要优点是代码的简洁性：通常，我们添加一个文件到目标时不需要更改多于一行代码。
- en: 'Unfortunately, adding every installed file to a target isn''t always possible
    or convenient. For such cases, three choices are available: `install(FILES)`,
    `install(PROGRAMS)`, and `install(DIRECTORY)`.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，将每个已安装的文件添加到目标上并不总是可能的或方便的。对于这种情况，有三种选择可用：`install(FILES)`、`install(PROGRAMS)`
    和 `install(DIRECTORY)`。
- en: Installing file sets with install(FILES|PROGRAMS)
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 install(FILES|PROGRAMS) 安装文件集
- en: The `FILES` and `PROGRAMS` modes are very similar. They can be used to install
    public header files, documentation, shell scripts, configuration, and all kinds
    of assets, including images, audio files, and datasets to be used at runtime.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`FILES` 和 `PROGRAMS` 模式非常相似。它们可以用来安装公共头文件、文档、shell 脚本、配置文件，以及所有种类的资产，包括图像、音频文件和将在运行时使用的数据集。'
- en: 'Here''s the command signature:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是命令签名：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The main difference between `FILES` and `PROGRAMS` is the default file permission
    set on newly copied files. `install(PROGRAMS)` will also set `EXECUTE` for all
    users, while `install(FILES)` will not (both will set `OWNER_WRITE`, `OWNER_READ`,
    `GROUP_READ`, and `WORLD_READ`). You can change this behavior by providing the
    optional `PERMISSIONS` keyword, then picking the leading keyword as an indicator
    of what''s installed: `FILES` or `PROGRAMS`. We''ve already discussed how `PERMISSIONS`,
    `CONFIGURATIONS`, and `OPTIONAL` work. `COMPONENT` and `EXCLUDE_FROM_ALL` will
    be discussed later in the *Defining components* section.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`FILES` 和 `PROGRAMS` 之间的主要区别是新复制文件的默认文件权限设置。`install(PROGRAMS)` 也会为所有用户设置 `EXECUTE`
    权限，而 `install(FILES)` 不会（两者都会设置 `OWNER_WRITE`、`OWNER_READ`、`GROUP_READ` 和 `WORLD_READ`）。你可以通过提供可选的
    `PERMISSIONS` 关键字来改变这种行为，然后选择领先的关键字作为安装内容的指示器：`FILES` 或 `PROGRAMS`。我们已经讨论了 `PERMISSIONS`、`CONFIGURATIONS`
    和 `OPTIONAL` 如何工作。`COMPONENT` 和 `EXCLUDE_FROM_ALL` 在 *定义组件* 部分中稍后讨论。'
- en: Right after the initial keyword, we need to list all the files we want to install.
    CMake supports relative and absolute paths, as well as generator expressions.
    Just keep in mind that if your file path starts with a generator expression, it
    must be absolute.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始关键字之后，我们需要列出所有想要安装的文件。CMake支持相对路径、绝对路径以及生成器表达式。只需记住，如果你的文件路径以生成器表达式开始，那么它必须是绝对的。
- en: 'The next required keyword is `TYPE` or `DESTINATION`. We can explicitly provide
    the `DESTINATION` path or ask CMake to look it up for a specific `TYPE` file.
    Unlike in `install(TARGETS)`, `TYPE` doesn''t claim to selectively install any
    subset of the provided files to be installed. Nevertheless, computing the installation
    path follows the same pattern (the `+` symbol denotes a platform-specific path
    separator):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个必需的关键字是 `TYPE` 或 `DESTINATION`。我们可以显式提供 `DESTINATION` 路径，或者要求 CMake 为特定 `TYPE`
    文件查找它。与 `install(TARGETS)` 不同，`TYPE` 并不声称选择性地将要安装的文件子集安装到指定位置。然而，计算安装路径遵循相同的模式（`+`
    符号表示平台特定的路径分隔符）：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And similarly, every `TYPE` will have built-in guesses:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，每个 `TYPE` 都会有内置猜测：
- en: '![](img/Table_11.2_B17205.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_11.2_B17205.jpg)'
- en: 'The behavior here follows the same principle that was described in the *Working
    out the correct destination for different platforms* section: if no installation
    directory variable for this `TYPE` file is set, CMake will fall back to the default
    "guess" path. Again, we can use the `GNUInstallDirs` module for portability.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的行为遵循在 *为不同平台计算正确的目的地* 部分描述的相同原则：如果此 `TYPE` 文件没有设置安装目录变量，CMake 将退回到默认的“猜测”路径。再次，我们可以使用
    `GNUInstallDirs` 模块以提高可移植性。
- en: 'Some of the built-in guesses in the table are prefixed with installation directory
    variables:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 表中一些内置猜测的前缀是安装目录变量：
- en: '`$LOCALSTATE` is `CMAKE_INSTALL_LOCALSTATEDIR` or defaults to `var`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$LOCALSTATE` 是 `CMAKE_INSTALL_LOCALSTATEDIR` 或默认为 `var`'
- en: '`$DATAROOT` is `CMAKE_INSTALL_DATAROOTDIR` or defaults to `share`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$DATAROOT` 是 `CMAKE_INSTALL_DATAROOTDIR` 或默认为 `share`'
- en: 'As with `install(TARGETS)`, if the `GNUInstallDirs` module is included, it
    will provide platform-specific installation directory variables. Let''s look at
    an example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与`install(TARGETS)`类似，如果包含了`GNUInstallDirs`模块，它将提供特定于平台的安装目录变量。让我们来看一个例子：
- en: chapter-11/03-install-files/CMakeLists.txt
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-11/03-install-files/CMakeLists.txt
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this case, CMake will install the two header-only libraries – that is, `calc.h`
    and `nested/calc_extended.h` – in the project-specific subdirectory in the system-wide
    *include directory*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，CMake将在系统级*include目录*的项目特定子目录中安装两个头文件库——即`calc.h`和`nested/calc_extended.h`。
- en: Note
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We know from the `GNUInstallDirs` source that `CMAKE_INSTALL_INCLUDEDIR` contains
    the same path for all supported platforms. However, it's still recommended to
    use it for readability and consistency with more dynamic variables. For example,
    `CMAKE_INSTALL_LIBDIR` will vary by architecture and distribution – `lib`, `lib64`,
    or `lib/<multiarch-tuple>`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从`GNUInstallDirs`源文件中我们知道`CMAKE_INSTALL_INCLUDEDIR`对所有支持的平台都包含相同的路径。然而，为了可读性和与更动态的变量保持一致，仍然建议使用它。例如，`CMAKE_INSTALL_LIBDIR`将根据架构和发行版而变化——`lib`、`lib64`或`lib/<multiarch-tuple>`。
- en: CMake 3.20 also adds a somewhat useful `RENAME` keyword to the `install(FILES|PROGRAMS)`
    command, which has to be followed by a new filename (this only works if the `files...`
    list contains a single file).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 3.20还向`install(FILES|PROGRAMS)`命令添加了相当有用的`RENAME`关键字，后跟新文件名（仅当`files...`列表包含单个文件时才有效）。
- en: 'The example in this section shows how easy it can be to install files in the
    appropriate directory. There''s one problem, though – take a look at the installation
    output:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的示例展示了安装文件到适当目录是多么简单。不过有一个问题——看看安装输出：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Both files were installed in the same directory, regardless of nesting. Sometimes,
    that's not what we want. In the next section, we'll learn how to deal with this.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 两个文件都被安装在同一个目录中，无论嵌套与否。有时，这可能不是我们想要的。在下一节中，我们将学习如何处理这种情况。
- en: Working with whole directories
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理整个目录
- en: 'If you don''t want to add individual files to your installation command, you
    can choose the broader approach and work with entire directories instead. The
    `install(DIRECTORY)` mode was created for this purpose. It will copy the listed
    directories verbatim to the chosen destination. Let''s see what it looks like:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想将单个文件添加到安装命令中，你可以选择更广泛的方法，而是处理整个目录。`install(DIRECTORY)`模式就是为了这个目的而创建的。它将列表中的目录原样复制到所选的目标位置。让我们看看它看起来像什么：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you can see, many options are repeated from `install(FILES|PROGRAMS)`. They
    work the same way. There''s one detail worth noting: if the paths that are provided
    after the `DIRECTORY` keyword do not end with `/`, the last directory of the path
    will be appended to the destination, like so:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，许多选项是从`install(FILES|PROGRAMS)`重复的。它们的工作方式是一样的。有一个值得注意的细节：如果在与`DIRECTORY`关键字提供的路径不以`/`结尾，路径的最后目录将被添加到目的地，如下所示：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This will create a directory called `/x/a` and copy the contents of `a` to
    it. Now, look at the following code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`/x/a`的目录并将`a`的内容复制到其中。现在，看看以下代码：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This will copy the contents of `a` directly to `/x`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这将直接将`a`的内容复制到`/x`。
- en: '`install(DIRECTORY)` also introduces other mechanisms that are not available
    for files:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`install(DIRECTORY)`还引入了其他对文件不可用的机制：'
- en: Output silencing
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静默输出
- en: Extended permission control
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展权限控制
- en: File/directories filtering
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件/目录过滤
- en: Let's start with the output silencing option, `MESSAGE_NEVER`. It disables output
    diagnostics during installation. It is very useful when we have many files in
    the directories we're installing and it would be too noisy to print them all.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从静默输出选项`MESSAGE_NEVER`开始。它禁用了安装过程中的输出诊断。当我们有很多要安装的目录中的文件，打印它们所有人会太吵时，这个功能非常有用。
- en: 'Next up are permissions. This `install()` mode supports three options for setting
    permissions:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是权限。这个`install()`模式支持设置权限的三个选项：
- en: '`USE_SOURCE_PERMISSIONS` works exactly as expected – it sets the permissions
    on installed files that follow the original files. This only works when `FILE_PERMISSIONS`
    is not set.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USE_SOURCE_PERMISSIONS`按预期工作——它设置了遵循原始文件权限的安装文件权限。只有当`FILE_PERMISSIONS`未设置时，这才会起作用。'
- en: '`FILE_PERMISSIONS` is pretty self-explanatory as well. It allows us to specify
    the permissions we want to set on installed files and directories. The default
    permissions are `OWNER_WRITE`, `OWNER_READ`, `GROUP_READ`, and `WORLD_READ`.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FILE_PERMISSIONS`也非常容易解释。它允许我们指定想要设置在安装的文件和目录上的权限。默认的权限有`OWNER_WRITE`、`OWNER_READ`、`GROUP_READ`和`WORLD_READ`。'
- en: '`DIRECTORY_PERMISSIONS` works similarly to the previous option, but it will
    set additional `EXECUTE` permissions for all users (this is because `EXECUTE`
    on directories is understood by Unix-like systems as permission to list their
    contents).'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DIRECTORY_PERMISSIONS`与前面选项的工作方式类似，但它将为所有用户设置额外的`EXECUTE`权限（这是因为Unix-like系统将目录上的`EXECUTE`理解为列出其内容的权限）。'
- en: 'Note that CMake will ignore permissions options on platforms that don''t support
    them. More permission control can be achieved by adding the `PERMISSIONS` keyword
    after every filtering expression: any files or directories that are matched by
    it will receive permissions that are specified after this keyword instead.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，CMake将在不支持它们的平台上忽略权限选项。通过在每一个过滤表达式之后添加`PERMISSIONS`关键字，可以实现更多的权限控制：任何被它匹配的文件或目录都将接收到在此关键字之后指定的权限。
- en: 'Let''s talk about filters or "globbing" expressions. You can set multiple filters
    that control which files/directories get installed from source directories. They
    have the following syntax:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来谈谈过滤器或“通配符”表达式。你可以设置多个过滤器，控制从源目录安装哪些文件/目录。它们有以下语法：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'There are two matching methods to pick from:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种匹配方法可以选择：
- en: With `PATTERN`, which is the simpler option, we're allowed to provide a pattern
    with `?` placeholders (matches any character) and wildcards, `*` (matches any
    string). Only paths that end with `<pattern>` will be matched.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`PATTERN`，这是更简单的选项，我们可以提供一个带有`?`占位符（匹配任何字符）和通配符，`*`（匹配任何字符串）的模式。只有以`<pattern>`结尾的路径才会被匹配。
- en: On the other hand, the `REGEX` option is more advanced – it supports regular
    expressions. It also allows us to match any part of the path (we can still use
    the `^` and `$` anchors to denote the beginning and end of the path).
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，`REGEX`选项更高级——它支持正则表达式。它还允许我们匹配路径的任何部分（我们仍然可以使用`^`和`$`锚点来表示路径的开始和结束）。
- en: Optionally, we can set the `FILES_MATCHING` keyword before the first filter,
    which will specify that any filters will be applied to files and not directories.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，我们可以在第一个过滤器之前设置`FILES_MATCHING`关键字，这将指定任何过滤器都将应用于文件，而不是目录。
- en: 'Remember two caveats:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 记住两个注意事项：
- en: '`FILES_MATCHING` requires an inclusive filter in that you may exclude some
    files, but unless you also add an expression to include some of them, no files
    will be copied. However, all directories will be created, regardless of filtering.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FILES_MATCHING`需要一个包含性过滤器，也就是说，你可以排除一些文件，但除非你也添加一个表达式来包含其中的一些，否则没有文件会被复制。然而，无论过滤与否，所有目录都会被创建。'
- en: All subdirectories are filtered in by default; you may only filter out.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有子目录默认都是被过滤进去的；你只能进行排除。
- en: For each filtering method, we may choose to `EXCLUDE` matched paths (this only
    works when `FILES_MATCHING` isn't used).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种过滤方法，我们可以选择`EXCLUDE`匹配的路径（这只有在没有使用`FILES_MATCHING`时才有效）。
- en: 'We can set specific permissions for all matched paths by adding the `PERMISSIONS`
    keyword and a list of desired permissions after any filter. Let''s try this out.
    In this example, we''ll install three directories in three different ways. We''ll
    have some static data files that will be used at runtime:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在任何一个过滤器之后添加`PERMISSIONS`关键字和一个所需权限的列表，为所有匹配的路径设置特定的权限。让我们试试看。在这个例子中，我们将以三种不同的方式安装三个目录。我们将有一些在运行时使用的静态数据文件：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We also need some public headers that live in the `src` directory among other,
    unrelated files:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一些位于`src`目录中的公共头文件，以及其他不相关的文件：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, we will need two configuration files at two levels of nesting. To
    make things more interesting, we are going to make the contents of `/etc/calc/`
    accessible only to the file owner:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要两个嵌套级别的配置文件。为了使事情更有趣，我们将使得`/etc/calc/`的内容只能被文件所有者访问：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To install the directory with static data files, we''ll start our project with
    the most basic form of the `install(DIRECTORY)` command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装具有静态数据文件的目录，我们将使用`install(DIRECTORY)`命令的最基本形式开始我们的项目：
- en: chapter-11/04-install-directories/CMakeLists.txt (fragment)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-11/04-install-directories/CMakeLists.txt（片段）
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This command will simply take all the contents of our `data` directory and put
    it in `${CMAKE_INSTALL_PREFIX}` and `share/calc`. Note that our source path ends
    with a `/` symbol to indicate we don't want to copy the `data` directory itself,
    only its contents.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将简单地取我们`data`目录下的所有内容并将其放入`${CMAKE_INSTALL_PREFIX}`和`share/calc`。请注意，我们的源路径以一个`/`符号结束，以表示我们不想复制`data`目录本身，只想它的内容。
- en: 'The second case is the opposite: we don''t add the trailing `/` because the
    directory should be included. This is because we''re relying on a system-specific
    path for the `INCLUDE` file type, which is provided by `GNUInstallDirs` (note
    how the `INCLUDE` and `EXCLUDE` keywords represent unrelated concepts):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个案例正好相反：我们不添加尾随的`/`，因为目录应该被包含。这是因为我们依赖于`GNUInstallDirs`提供的特定于系统的`INCLUDE`文件类型路径（注意`INCLUDE`和`EXCLUDE`关键词代表无关的概念）：
- en: chapter-11/04-install-directories/CMakeLists.txt (fragment)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第11章/04-install-directories/CMakeLists.txt（片段）
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Additionally, we have excluded two paths from this operation: the entire `ignored`
    directory and all files ending with `calc_extended.h` (remember how `PATTERN`
    works).'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们已经将这两个路径从这个操作中排除：整个`ignored`目录和所有以`calc_extended.h`结尾的文件（记得`PATTERN`是如何工作的）。
- en: 'The third case installs some default configuration files and sets their permissions:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个案例安装了一些默认的配置文件并设置了它们的权限：
- en: chapter-11/04-install-directories/CMakeLists.txt (fragment)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 第11章/04-install-directories/CMakeLists.txt（片段）
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Again, we aren''t interested in appending `etc` from the source path to the
    path for the `SYSCONF` type (this has already been provided by including `GNUInstallDirs`)
    because we would end up putting the files in `/etc/etc`. Additionally, we must
    specify two permission rules:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，我们不关心从源路径中添加`etc`到`SYSCONF`类型的路径（这已经由包含`GNUInstallDirs`提供），因为我们会把文件放在`/etc/etc`中。此外，我们必须指定两个权限规则：
- en: Subdirectories should only be editable and listable by the owner.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子目录只能由所有者编辑和列出。
- en: Files ending with `nested.conf` should only be editable by the owner.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以`nested.conf`结尾的文件只能由所有者编辑。
- en: Installing directories handles a lot of different use cases, but for really
    advanced installation scenarios (such as post-install configuration), we may need
    to involve external tools. How would we do that?
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 安装目录处理了很多不同的用例，但对于真正高级的安装场景（如安装后配置），我们可能需要使用外部工具。我们应该如何做到这一点？
- en: Invoking scripts during installation
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在安装过程中调用脚本
- en: 'If you have ever installed a shared library on a Unix-like system, you may
    remember that before you can use it, you''ll likely need to tell the dynamic linker
    to scan trusted directories and build its cache by calling `ldconfig` (see the
    *Further reading* section for references). If you''d like to make your installation
    fully automatic, CMake offers the `install(SCRIPT|CODE)` command to support such
    cases. Here''s the full command''s signature:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经在类Unix系统上安装过一个共享库，你可能记得在可以使用它之前，你可能需要告诉动态链接器扫描可信目录并调用`ldconfig`（在*进一步阅读*部分可以看到参考文献）来构建其缓存。如果你想要使你的安装完全自动化，CMake提供了`install(SCRIPT|CODE)`命令来支持这类情况。以下是完整命令的签名：
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You should pick `SCRIPT` or `CODE` mode and provide the appropriate arguments
    – either a path to the CMake script to run or a CMake snippet to execute during
    the installation. To see how this works, we''ll modify the `02-install-targets`
    example to build a shared library:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该选择`SCRIPT`或`CODE`模式并提供适当的参数——要么是一个运行CMake脚本的路径，要么是在安装过程中执行的CMake代码片段。为了了解这是如何工作的，我们将修改`02-install-targets`示例以构建一个共享库：
- en: chapter-11/05-install-code/src/CMakeLists.txt
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 第11章/05-install-code/src/CMakeLists.txt
- en: '[PRE34]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We need to change the artifact type from `ARCHIVE` to `LIBRARY` in the installation
    script to copy the files. Then, we can just add the logic to run `ldconfig` after:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在安装脚本中将 artifact 类型从 `ARCHIVE` 更改为 `LIBRARY` 以复制文件。然后，我们可以在之后添加运行 `ldconfig`
    的逻辑：
- en: chapter-11/05-install-code/CMakeLists.txt (fragment)
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 第11章/05-install-code/CMakeLists.txt（片段）
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `if()` condition checks if the command matches the operating system (it
    wouldn't be correct to execute `ldconfig` on Windows or macOS). Of course, the
    provided code must have valid CMake syntax to work (however, it won't be checked
    during the initial build; any failures will surface during installation).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`if()`条件检查命令是否与操作系统匹配（在Windows或macOS上执行`ldconfig`是不正确的）。当然，提供的代码必须具有有效的CMake语法才能工作（不过，在初始构建期间不会进行检查；任何失败都会在安装时显现）。'
- en: 'After running an installation command, we can confirm that it worked by printing
    the cached libraries:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 运行安装命令后，我们可以通过打印缓存中的库来确认它是否工作：
- en: '[PRE36]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Both modes support generator expressions, should you need them. As such, this
    command is as versatile as CMake itself and can be used for all sorts of things:
    printing messages for users, verifying that the installation was successful, extensive
    configuration, file signing – you name it.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种模式都支持生成表达式，如果你需要的话。因此，这个命令和CMake本身一样多功能，可以用于所有 sorts of things：为用户打印消息，验证安装是否成功，进行详尽的配置，文件签名——你能想到的都有。
- en: Now that we know all the different ways we can install a set of files on the
    system, let's learn how to turn them into a natively available package for other
    CMake projects.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了将一组文件安装到系统上的所有不同方法，那么接下来让我们学习如何将它们转换为其他CMake项目可以原生使用的包。
- en: Creating reusable packages
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可重用包
- en: 'We have used `find_package()` extensively in previous chapters. We saw how
    convenient it is and how it simplifies the whole process. To make our project
    accessible through this command, we need to complete a few steps so that CMake
    can treat our project as a coherent package:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们大量使用了`find_package()`。我们看到了它有多方便，以及它是如何简化整个过程的。为了使我们的项目通过这个命令可用，我们需要完成几步，以便CMake可以将我们的项目视为一个连贯的包：
- en: Make our targets relocatable.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使我们的目标可移动。
- en: Install the target export file to a standard location.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将目标导出文件安装到标准位置。
- en: Create a config-files and *version file* for the package.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为包创建配置文件和*版本文件*。
- en: 'Let''s start from the beginning: why do targets need to be relocatable and
    how can we do this?'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从开头说起：为什么目标需要可移动，我们又该如何实现？
- en: Understanding the issues with relocatable targets
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解可移动目标的问题
- en: 'Installation solves many problems but unfortunately, it also introduces some
    complexity: not only is `CMAKE_INSTALL_PREFIX` platform-specific but it can also
    be set by the user at the installation stage with the `--prefix` option. However,
    target export files are generated before the installation, during the build stage,
    at which point we don''t know where the installed artifacts will go. Take a look
    at the following code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 安装解决了许多问题，但不幸的是，它也引入了一些复杂性：不仅`CMAKE_INSTALL_PREFIX`是平台特定的，而且它还可以在安装阶段由用户使用`--prefix`选项进行设置。然而，目标导出文件是在安装之前生成的，在构建阶段，此时我们不知道安装的工件将去哪里。请看下面的代码：
- en: chapter-11/01-export/src/CMakeLists.txt
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-11/01-export/src/CMakeLists.txt
- en: '[PRE37]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this example, we specifically add the *include directory* to the *include
    directories* of `calc`. Since this is a relative path, CMake's exported target
    generation will implicitly prepend this path with the contents of the `CMAKE_CURRENT_SOURCE_DIR`
    variable, which points to the directory where this listfile is located.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们特别将*包含目录*添加到`calc`的*包含目录*中。由于这是一个相对路径，CMake生成的目标将隐式地将这个路径与`CMAKE_CURRENT_SOURCE_DIR`变量的内容相结合，该变量指向这个列表文件所在的目录。
- en: However, that's not going to cut it. The installed project shouldn't need files
    from the source or build tree anymore. Everything (including library headers)
    is copied to a shared location, such as `/usr/lib/calc/` on Linux. We cannot use
    the target that's been defined in this snippet in another project since the target's
    *include directory* path still points to its source tree.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这还不够。已安装的项目不应再需要源代码或构建树中的文件。一切（包括库头文件）都被复制到一个共享位置，如Linux上的`/usr/lib/calc/`。由于这个片段中定义的目标的*包含目录*路径仍然指向其源树，所以我们不能在另一个项目中使用这个目标。
- en: 'CMake solves this with two generator expressions that will filter out the expression,
    depending on the context:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: CMake用两个生成表达式解决了这个问题，这些表达式将根据上下文过滤出表达式：
- en: '`$<BUILD_INTERFACE>`: This includes the content for regular builds but excludes
    it for installation.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<BUILD_INTERFACE>`：这包括了常规构建的内容，但在安装时将其排除。'
- en: '`$<INSTALL_INTERFACE>`: This includes the content for installation but excludes
    it for regular builds.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<INSTALL_INTERFACE>`：这包括了安装的内容，但排除了常规构建。'
- en: 'The following code shows how you can use them in practice:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码展示了你如何实际上使用它们：
- en: chapter-11/06-install-export/src/CMakeLists.txt
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-11/06-install-export/src/CMakeLists.txt
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'For regular builds, the value of the `calc` target property, `INTERFACE_INCLUDE_DIRECTORIES`,
    will be expanded, like so:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于常规构建，`calc`目标属性的`INTERFACE_INCLUDE_DIRECTORIES`值将像这样扩展：
- en: '[PRE39]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Empty double quotes mean that the value provided in `INSTALL_INTERFACE` was
    excluded and evaluated as an empty string. On the other hand, when we install,
    the value will get expanded like so:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 空的双引号意味着在`INSTALL_INTERFACE`中提供的值被排除，并被评估为空字符串。另一方面，当我们安装时，该值将像这样扩展：
- en: '[PRE40]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This time, the value that was provided in the `BUILD_INTERFACE` generator expression
    was evaluated as an empty string, and we're left with the value from the other
    generator expression.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，在`BUILD_INTERFACE`生成表达式中提供的值被评估为空字符串，我们留下了另一个生成表达式的值。
- en: 'One more word about `CMAKE_INSTALL_PREFIX`: this variable shouldn''t be used
    as a component in paths specified in targets. It would be evaluated during the
    build stage, making the path absolute and not necessarily the same as the one
    that was provided in the installation stage (as users may use the `--prefix` option).
    Instead, use the `$<INSTALL_PREFIX>` generator expression:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`CMAKE_INSTALL_PREFIX`再说一句：这个变量不应该用作目标中指定路径的组件。它将在构建阶段进行评估，使路径成为绝对路径，并且不一定与在安装阶段提供的路径相同（因为用户可能使用`--prefix`选项）。相反，请使用`$<INSTALL_PREFIX>`生成表达式：
- en: '[PRE41]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Or, even better, you can use relative paths (they will get prepended with the
    correct installation prefix):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，更好的做法是使用相对路径（它们会前缀正确的安装前缀）：
- en: '[PRE42]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Please take a look at the official documentation for more examples and information
    (a link to this can be found in the *Further reading* section).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅官方文档以获取更多示例和信息（可以在*进阶阅读*部分找到此链接）。
- en: Now that our targets are "installation-compatible," we can safely generate and
    install their target export files.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的目标已经是“安装兼容”的，我们可以安全地生成并安装它们的导出文件。
- en: Installing target export files
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装目标导出文件
- en: 'We discussed target export files a little bit in the *Exporting without installation*
    section. Target export files that are intended for installation are quite similar,
    as is the signature of the command for creating them:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*无需安装导出*部分稍微讨论了目标导出文件。打算用于安装的目标导出文件非常相似，创建它们的命令签名也是如此：
- en: '[PRE43]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: It's a combination of "plain" `export(EXPORT)` and other `install()` commands
    (its options work the same way). Just remember that it will create and install
    a target export file for a named export that must be defined with the `install(TARGETS)`
    command. The major difference to be aware of here is that the generated export
    file will contain the target paths that were evaluated in the `INSTALL_INTERFACE`
    generator expression and not `BUILD_INTERFACE` like `export(EXPORT)` did.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这是“普通”的`export(EXPORT)`和其他`install()`命令的组合（它的选项工作方式相同）。只需记住，它会创建并安装一个名为导出，必须使用`install(TARGETS)`命令定义。这里需要注意的是，生成的导出文件将包含在`INSTALL_INTERFACE`生成表达式中评估的目标路径，而不是`BUILD_INTERFACE`，就像`export(EXPORT)`一样。
- en: 'In this example, we''ll generate and install the target export file for the
    target from `chapter-11/06-install-export/src/CMakeLists.txt`. To do so, we must
    call `install(EXPORT)` in our top listfile:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将为`chapter-11/06-install-export/src/CMakeLists.txt`中的目标生成并安装目标导出文件。为此，我们必须在顶层列表文件中调用`install(EXPORT)`：
- en: chapter-11/06-install-export/CMakeLists.txt
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-11/06-install-export/CMakeLists.txt
- en: '[PRE44]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Again, note how we're referencing the `CalcTargets` export name in `install(EXPORT)`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意我们如何在`install(EXPORT)`中引用`CalcTargets`导出名称。
- en: 'Running `cmake --install` in the build tree will result in the export file
    being generated in the specified destination:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建树中运行`cmake --install`将导致导出文件在指定目的地生成：
- en: '[PRE45]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If, for some reason, the override default name for the target export file (`<export
    name>.cmake`) doesn't work for you, you can add the `FILE new-name.cmake` argument
    to change it (the filename must end with `.cmake`).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出于某种原因，目标导出文件的默认重写名称（`<export name>.cmake`）对您不起作用，您可以添加`FILE new-name.cmake`参数来更改它（文件名必须以`.cmake`结尾）。
- en: Don't get confused by this – the target export file isn't a config file, so
    you can't use `find_package()` to consume installed targets just yet. However,
    it's possible to `include()` export files directly if needed. So, how do we define
    the package that can be consumed by other projects? Let's find out!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被这个困惑 - 目标导出文件不是一个配置文件，所以您现在还不能使用`find_package()`来消耗已安装的目标。然而，如果需要，您可以直接包含导出文件。那么，我们如何定义可以被其他项目消耗的包呢？让我们找出答案！
- en: Writing basic config-files
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写基本配置文件
- en: A complete package definition consists of the target export files, the package's
    *config file*, and the package's *version file*, but technically, all that's needed
    for `find_package()` to work is a config-file. It's considered a package definition
    and it's responsible for providing any package functions and macros, checking
    requirements, finding dependencies, and including target export files.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的包定义包括目标导出文件、包的*config文件*以及包的*版本文件*，但技术上来说，为了使`find_package()`工作只需要一个config-file。它被视为一个包定义，负责提供任何包函数和宏，检查要求，查找依赖项，并包含目标导出文件。
- en: 'As we mentioned earlier, users can install your package anywhere on their system
    by using the following command:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，用户可以使用以下命令将您的包安装到他们系统上的任何位置：
- en: '[PRE46]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This prefix determines where the installed files will be copied. To support
    this, you must at least ensure the following:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这个前缀决定了安装文件将被复制到的位置。为了支持这一点，您至少必须确保以下几点：
- en: The paths on the target properties can be relocated (as described in the *Understanding
    the issues with relocatable targets* section).
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标属性中的路径可以移动（如*理解可移动目标的问题*部分所述）。
- en: The paths that are used in your config-file are relative to it.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您config-file中使用的路径相对于它本身是相对的。
- en: 'To use such packages that have been installed in non-default locations, the
    consuming projects need to provide `<installation path>` through the `CMAKE_PREFIX_PATH`
    variable during the configuration stage. We can do this with the following command:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用已安装在非默认位置的这类包，消费项目在配置阶段需要通过`CMAKE_PREFIX_PATH`变量提供`<安装路径>`。我们可以用以下命令来实现：
- en: '[PRE47]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `find_package()` command will scan the list of paths that are outlined
    in the documentation (link in the *Further reading* section) in a platform-specific
    way. One of the patterns that''s checked on Windows and Unix-like systems is as
    follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_package()`命令将按照文档中概述的路径（*进一步阅读*部分的链接）以平台特定的方式扫描。在Windows和类Unix系统中检查的一个模式如下：'
- en: '[PRE48]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This tells us that installing the config-file in a path such as `lib/calc/cmake`
    should work just fine. Also, it's important to highlight that config-files must
    be named `<PackageName>-config.cmake` or `<PackageName>Config.cmake` to be found.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，将config-file安装在如`lib/calc/cmake`的路径上应该完全没有问题。另外，重要的是要强调config-files必须命名为`<包名>-config.cmake`或`<包名>Config.cmake`才能被找到。
- en: 'Let''s add the installation of the config-file to the `06-install-export` example:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将config-file的安装添加到`06-install-export`示例中：
- en: chapter-11/07-config-file/CMakeLists.txt (fragment)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-11/07-config-file/CMakeLists.txt（片段）
- en: '[PRE49]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This command will install `CalcConfig.cmake` from the same source directory
    (`CMAKE_INSTALL_LIBDIR` will be evaluated to the correct `lib` path for the platform).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将从同一源目录（`CMAKE_INSTALL_LIBDIR`将被评估为平台正确的`lib`路径）安装`CalcConfig.cmake`。
- en: 'The most basic config-file we can provide consists of a single line that includes
    the target export file:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够提供的最基本的config-file由一条包含目标导出文件的直线组成：
- en: chapter-11/07-config-file/CalcConfig.cmake
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-11/07-config-file/CalcConfig.cmake
- en: '[PRE50]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `CMAKE_CURRENT_LIST_DIR` variable refers to the directory that the config-file
    lives in. Because `CalcConfig.cmake` and `CalcTargets.cmake` are installed in
    the same directory in our example (as set by `install(EXPORT)`), the target export
    file will be included correctly.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMAKE_CURRENT_LIST_DIR`变量指的是config-file所在的目录。因为在我们示例中`CalcConfig.cmake`和`CalcTargets.cmake`安装在同一个目录中（如`install(EXPORT)`所设置），目标导出文件将被正确包含。'
- en: 'To make sure that our package is usable, we''ll create a simple project consisting
    of just one listfile:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的包可以被使用，我们将创建一个简单的项目，仅包含一个listfile：
- en: chapter-11/08-find-package/CMakeLists.txt
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-11/08-find-package/CMakeLists.txt
- en: '[PRE51]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To test this in practice, we can build and install the `07-config-file` example
    to one directory, and then build `08-find-package` while referencing it with the
    `DCMAKE_PREFIX_PATH` argument, like so:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在实际中测试这个，我们可以将`07-config-file`示例构建并安装到一个目录中，然后在使用`DCMAKE_PREFIX_PATH`参数引用它的情况下构建`08-find-package`，如下所示：
- en: '[PRE52]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This will produce the following output (all the `<_tree-of_>` placeholders
    will be replaced with real paths):'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出（所有`<_tree-of_>`占位符都将被真实路径替换）：
- en: '[PRE53]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `CalcTargets.cmake` file was found and included correctly, and the path
    to the *include directory* was set to follow the chosen prefix. This solves packaging
    for a very basic case. Now, let's learn how to handle more advanced scenarios.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 找到了`CalcTargets.cmake`文件，并正确地包含了它，`*include目录*`的路径设置为遵循所选的前缀。这对于一个非常基础的打包情况解决了打包问题。现在，让我们学习如何处理更高级的场景。
- en: Creating advanced config-files
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建高级配置文件
- en: 'If you have more things to manage than a single target export file, it might
    be useful to include a few macros in your config-file. The `CMakePackageConfigHelpers`
    utility module gives us access to the `configure_package_config_file()` command.
    To use it, we need to supply a template file that will be interpolated with CMake
    variables to generate a config-file with two embedded macro definitions:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你管理的不仅仅是单个目标导出文件，那么在配置文件中包含几个宏可能是有用的。`CMakePackageConfigHelpers`工具模块让我们可以使用`configure_package_config_file()`命令。使用它时，我们需要提供一个模板文件，这个文件会被CMake变量插值，以生成一个带有两个内嵌宏定义的配置文件：
- en: '`set_and_check(<variable> <path>)`: This works like `set()`, but it checks
    that `<path>` actually exists and fails with `FATAL_ERROR` otherwise. It is recommended
    to use this in your config-files to detect incorrect paths early.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_and_check(<variable> <path>)`: 这个命令类似于`set()`，但它会检查`<path>`是否存在，如果不存在则会导致`FATAL_ERROR`。建议在配置文件中使用它，以便尽早发现错误的路径。'
- en: '`check_required_components(<PackageName>)`: This is added to the end of the
    config-file and will verify whether all the components in our package, which are
    required by the user in `find_package(<package> REQUIRED <component>)`, have been
    found. This is done by checking that the `<package>_<component>_FOUND` variables
    are true.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`check_required_components(<PackageName>)`: 这句话添加到配置文件的最后，将验证我们包中由用户在`find_package(<package>
    REQUIRED <component>)`中 required 的所有组件是否已经被找到。这是通过检查`<package>_<component>_FOUND`变量是否为真来完成的。'
- en: 'Paths for more convoluted directory trees can be prepared for the installation
    stage while you''re generating the config-file. Take a look at the following signature:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在生成配置文件的同时为更复杂的目录树准备安装阶段的路径。看看以下的签名：
- en: '[PRE54]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The file that's been provided as `<template>` will be interpolated with variables
    and stored in the `<output>` path. Here, the path that's required after `INSTALL_DESTINATION`
    will be used to transform the paths stored in the variables listed in `PATH_VARS`
    so that they are relative to the install destination. We can also indicate that
    `INSTALL_DESTINATION` is relative to `INSTALL_PREFIX` by providing it as its base
    path.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`<template>`提供的文件将被变量插值并存储在`<output>`路径中。在这里，`INSTALL_DESTINATION`之后所需的路径将用于转换存储在`PATH_VARS`中的变量，使其相对于安装目的地。我们还可以通过提供`INSTALL_DESTINATION`的基路径来指示`INSTALL_DESTINATION`是相对于`INSTALL_PREFIX`的。
- en: '`NO_SET_AND_CHECK_MACRO` and `NO_CHECK_REQUIRED_COMPONENTS_MACRO` tell CMake
    not to add these macro definitions to the generated config-file. Let''s see this
    generation in practice. Again, we''ll extend the `06-install-export` example:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`NO_SET_AND_CHECK_MACRO`和`NO_CHECK_REQUIRED_COMPONENTS_MACRO`告诉CMake不要在生成的配置文件中添加这些宏定义。让我们在实践中看看这个生成过程。再次，我们将扩展`06-install-export`示例：'
- en: chapter-11/09-advanced-config/CMakeLists.txt (fragment)
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-11/09-advanced-config/CMakeLists.txt (片段)
- en: '[PRE55]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let''s take a look at what we must do in the preceding code:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看在前面的代码中我们必须做什么：
- en: '`include()` the utility module with helpers.'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在帮助器中`include()`这个工具模块。
- en: '`set()` a variable that will be used to make a relocatable path.'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个变量，用于生成可移动路径。
- en: Generate the `CalcConfig.cmake` config-file for the build tree using the `CalcConfig.cmake.in`
    template located in the source tree. Finally, provide `LIB_INSTALL_DIR` as a variable
    name to be computed as relative to `INSTALL_DESTINATION` or `${CMAKE_INSTALL_LIBDIR}/calc/cmake`.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用位于源树中的`CalcConfig.cmake.in`模板生成构建树中的`CalcConfig.cmake`配置文件。最后，提供一个名为`LIB_INSTALL_DIR`的变量，它将被计算为相对于`INSTALL_DESTINATION`或`${CMAKE_INSTALL_LIBDIR}/calc/cmake`的相对路径。
- en: Pass the config-file that was generated for the build tree to `install(FILE)`.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将构建树生成的配置文件传递给`install(FILE)`。
- en: Note that `DESTINATION` in `install(FILE)` and `INSTALL_DESTINATION` in `install(FILES)`
    are the same so that the relative paths can be computed correctly.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`install(FILE)`中的`DESTINATION`和`install(FILES)`中的`INSTALL_DESTINATION`是相同的，这样就可以正确计算相对路径。
- en: 'Finally, we''ll need a config file template (their names are usually suffixed
    with `.in`):'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个配置文件模板（它们的名称通常以`.in`结尾）：
- en: chapter-11/09-advanced-config/CalcConfig.cmake.in
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-11/09-advanced-config/CalcConfig.cmake.in
- en: '[PRE56]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: It should start with a `@PACKAGE_INIT@` placeholder. The generator will fill
    it with the definitions of the `set_and_check` and `check_required_components`
    commands so that they can consume the project. You may recognize these `@PLACEHOLDERS@`
    from our plain `configure_file()` – they work the same as they do in C++ files.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该以`@PACKAGE_INIT@`占位符开始。生成器将它填充为`set_and_check`和`check_required_components`命令的定义，以便它们可以消耗项目。您可能会认出这些`@PLACEHOLDERS@`来自我们的普通`configure_file()`——它们的工作方式与C++文件中的相同。
- en: Next, we'll set`(CALC_LIB_DIR)` to the path that's passed in the `@PACKAGE_LIB_INSTALL_DIR@`
    placeholder. It will contain the path of `$LIB_INSTALL_DIR` that's provided in
    the listfile, but it will be calculated relative to the installation path. Then,
    we'll use it to include the target export files.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将`(CALC_LIB_DIR)`设置为通过`@PACKAGE_LIB_INSTALL_DIR@`占位符传递的路径。它将包含列表文件中提供的`$LIB_INSTALL_DIR`的路径，但它将相对于安装路径进行计算。然后，我们使用它来包含目标导出文件。
- en: Finally, `check_required_components()` verifies if all the components that are
    required by the package consumer have been found. Adding this command is recommended,
    even if the package doesn't have any components, to verify that the user has not
    accidentally added unsupported requirements.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`check_required_components()`验证是否找到了包消费者所需的所有组件。即使包没有任何组件，建议添加此命令，以验证用户是否无意中添加了不受支持的要求。
- en: 'The `CalcConfig.cmake` config-file, when generated this way, looks like this:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式生成的`CalcConfig.cmake`配置文件，看起来像这样：
- en: '[PRE57]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The following diagram, which shows how the various package files are related
    to each other, puts this into perspective:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了各种包文件之间的关系，从而提供了这种关系的视角：
- en: '![Figure 11.1 – The file structure for advanced packages'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.1 – 高级包的文件结构'
- en: '](img/Figure_11.1_B17205.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.1_B17205.jpg)'
- en: Figure 11.1 – The file structure for advanced packages
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 高级包的文件结构
- en: All the required sub-dependencies of a package must also be found in the package
    config file. This can be done by calling the `find_dependency()` macro from the
    `CMakeFindDependencyMacro` helper. We learned how to use it in [*Chapter 7*](B17205_07_Final_JC_ePub.xhtml#_idTextAnchor162),
    *Managing Dependencies with CMake*.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 包的所有必需的子依赖项也必须在包配置文件中找到。这可以通过调用`CMakeFindDependencyMacro`助手中的`find_dependency()`宏来实现。我们在[第7章](B17205_07_Final_JC_ePub.xhtml#_idTextAnchor162)中学习了如何使用它，*使用CMake管理依赖项*。
- en: If you decide to expose any macros or functions to the consuming project, it
    is recommended that you put their definitions in a separate file that you can
    `include()` from the package's config-file.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定向消耗项目暴露任何宏或函数，建议您将它们的定义放在一个单独的文件中，然后您可以从包的配置文件中`include()`它。
- en: Interestingly, `CMakePackageConfigHelpers` also provides a helper command to
    generate package's version files. Let's take a look.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，`CMakePackageConfigHelpers`也提供了一个辅助命令来生成包的版本文件。我们来了解一下。
- en: Generating package version files
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成包版本文件
- en: 'As your package grows, it will slowly gain new features, old ones will be marked
    as deprecated, and eventually be removed. It''s important to keep track of these
    modifications in a changelog that''s available to developers that use your package.
    When a specific feature is needed, a developer can find the lowest version that
    supports it and use it as an argument to `find_package()`, like so:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '随着您的包的增长，它将逐渐增加新功能，旧的将被标记为弃用，最终被移除。对于使用您的包的开发人员来说，保持这些修改的变更日志是很重要的。当需要特定功能时，开发者可以找到支持它的最低版本并将其用作`find_package()`的参数，如下所示:'
- en: '[PRE58]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: CMake will then search the config-file for `Calc` and check if a *version file*
    named `<config-file>-version.cmake` or `<config-file>Version.cmake` is present
    in the same directory, that is, `CalcConfigVersion.cmake`. Next, this file will
    be read for its version information and the compatibility it provides with other
    versions. For example, you may not have version `1.2.3` installed as required,
    but you may have `1.3.5`, which is marked as "compatible" with any older versions.
    CMake will gladly accept such a package as it knows that the package vendor provides
    backward compatibility.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，CMake会在配置文件中搜索`Calc`，并检查是否有一个名为`<config-file>-version.cmake`或`<config-file>Version.cmake`的*版本文件*存在于同一目录中，即`CalcConfigVersion.cmake`。接下来，这个文件将被读取以获取其版本信息以及与其他版本的兼容性。例如，你可能没有安装所需的版本`1.2.3`，但你可能有`1.3.5`，它被标记为与任何旧版本“兼容”。CMake会欣然接受这样的包，因为它知道包供应商提供了向后兼容性。
- en: 'You can use the `CMakePackageConfigHelpers` utility module to generate package''s
    *version files* by calling `write_basic_package_version_file()`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`CMakePackageConfigHelpers`工具模块通过调用`write_basic_package_version_file()`生成包的*版本文件*：
- en: '[PRE59]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: First, we need to provide the `<filename>` property of the artifact we want
    to create; it must follow the rules we outlined earlier. Other than that, keep
    in mind that we should store all the generated files in the build tree.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要提供要创建的工件的`<filename>`属性；它必须遵循我们之前概述的规则。除此之外，请记住我们应该将所有生成的文件存储在构建树中。
- en: Optionally, we can pass an explicit `VERSION` (the usual format, `major.minor.patch`,
    is supported here). If we don't do this, the version that's provided in the `project()`
    command will be used instead (expect an error if your project doesn't specify
    one).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，我们可以传递一个显式的`VERSION`（这里支持常用的格式，`major.minor.patch`）。如果我们不这样做，将使用`project()`命令中提供的版本（如果您的项目没有指定，请期待一个错误）。
- en: 'The `COMPATIBILITY` keyword is self-explanatory:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`COMPATIBILITY`关键词不言自明：'
- en: '`ExactVersion` must match all three components of the version and won''t support
    ranged versions: `find_package(<package> 1.2.8...1.3.4)`.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExactVersion`必须与版本的所有三个组件相匹配，并且不支持范围版本：`find_package(<package> 1.2.8...1.3.4)`。'
- en: '`SameMinorVersion` matches if the first two components are the same (ignores
    `patch`).'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SameMinorVersion`如果前两个组件相同（忽略`patch`）则匹配。'
- en: '`SameMajorVersion` matches if the first component is the same (ignores `minor`
    and `patch`).'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SameMajorVersion`如果第一个组件相同（忽略`minor`和`patch`）则匹配。'
- en: '`AnyNewerVersion` seems to have a reversed name: it will match any older version.
    In other words, `<package>` on version `1.4.2` will be a good match for `find_package(<package>
    1.2.8)`.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnyNewerVersion`似乎有一个反向的名字：它会匹配任何旧版本。换句话说，版本`1.4.2`的`<package>`将与`find_package(<package>
    1.2.8)`相匹配。'
- en: Normally, all packages must be built for the same architecture as the consuming
    project to match (an exact check is performed). However, for packages that don't
    compile anything (header-only libraries, macro packages, and so on), you can specify
    the `ARCH_INDEPENDENT` keyword to skip this check.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，所有包必须为与消费项目相同的架构构建（执行精确检查）。然而，对于不编译任何内容的包（仅头文件库、宏包等），您可以使用`ARCH_INDEPENDENT`关键词跳过此检查。
- en: 'Now, it''s time for a practical example. The following code shows how to provide
    the *version file* for the project that we started in the `06-install-export`
    example:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候来一个实际例子了。以下代码展示了如何为我们在`06-install-export`示例中开始的项目提供*版本文件*：
- en: chapter-11/10-version-file/CMakeLists.txt (fragment)
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-11/10-version-file/CMakeLists.txt（片段）
- en: '[PRE60]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: For convenience, we configure the version of the package at the top of the file,
    in the `project()` command. This requires us to switch from the short `project(<name>
    <languages>)` syntax to an explicit, full syntax by adding the `LANGUAGE` keyword.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，我们在文件的顶部，在`project()`命令中配置包的版本。这需要我们从简短的`project(<name> <languages>)`语法切换到通过添加`LANGUAGE`关键词来使用显式、完整语法的语法。
- en: After including the helper utility module, we call the generation command and
    write the file to a build tree with a name conforming to the pattern that's required
    by `find_package()`. Here, we deliberately skip the `VERSION` keyword to have
    the version read from the `PROJECT_VERSION` variable. We're also marking our package
    as fully backward compatible with `COMPATIBILITY AnyNewerVersion`. After that,
    we install the package *version file* to the same destination as `CalcConfig.cmake`.
    And that's it – our package is fully configured.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含助手工具模块后，我们调用生成命令并将文件写入符合`find_package()`所需模式的构建树中。在这里，我们故意省略了`VERSION`关键词，以便从`PROJECT_VERSION`变量中读取版本。我们还标记我们的包为与`COMPATIBILITY
    AnyNewerVersion`完全向后兼容。之后，我们将包*版本文件*安装到与`CalcConfig.cmake`相同的目的地。就这样——我们的包已经完全配置好了。
- en: In the next section, we'll learn what components are and how to use them with
    packages.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习什么是组件以及如何将它们与包一起使用。
- en: Defining components
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义组件
- en: 'We''ll start talking about package components by clearing up some possible
    confusion around the term `find_package()`:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将先讨论包组件，通过澄清一些关于`find_package()`术语可能的混淆：
- en: '[PRE61]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The components that are mentioned here shouldn't be conflated with the `COMPONENT`
    keyword that's used in the `install()` command. They are different concepts that
    must be understood separately, despite sharing the same name. We'll look at this
    in more detail in the following subsections.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提到的组件不应与在`install()`命令中使用的`COMPONENT`关键字混淆。它们是两个不同的概念，尽管它们共享相同的名字，但必须分别理解。我们将在下面的子节中更详细地讨论这一点。
- en: How to use components in find_package()
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何在`find_package()`中使用组件
- en: When we call `find_package()` with a list of `COMPONENTS` or `OPTIONAL_COMPONENTS`,
    we tell CMake that we're only interested in packages that provide them. However,
    it's important to realize that it's up to the package to verify this requirement,
    and if the package vendor doesn't add the necessary checks to the config-file
    mentioned in the *Creating advanced config-file* section, then nothing happens.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`find_package()`并带有`COMPONENTS`或`OPTIONAL_COMPONENTS`列表时，我们告诉CMake我们只对提供这些组件的包感兴趣。然而，重要的是要意识到，是否有必要检查这一要求取决于包本身，如果包的供应商没有在*创建高级config文件*小节中提到的config文件中添加必要的检查，那么什么也不会发生。
- en: Requested components are passed to the config-file in the `<package>_FIND_COMPONENTS`
    variable (both optional and not). Additionally, for every non-optional component,
    a `<package>_FIND_REQUIRED_<component>` will be set. As package authors, we could
    write a macro to scan this list and check if we have provided all the required
    components. But we don't need to – this is exactly what `check_required_components()`
    does. To use it, the config-file should set the `<Package>_<Component>_FOUND`
    variable when the necessary component is found. The macro at the end of the file
    will check if all the required variables were set.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 请求的组件将通过`<package>_FIND_COMPONENTS`变量传递给config文件（可选和非可选都有）。此外，对于每个非可选组件，将设置一个`<package>_FIND_REQUIRED_<component>`。作为包的作者，我们可以编写一个宏来扫描这个列表并检查我们是否提供了所有必需的组件。但我们不需要这样做——这正是`check_required_components()`所做的。要使用它，config文件应在找到必要的组件时设置`<Package>_<Component>_FOUND`变量。文件末尾的宏将检查是否设置了所有必需的变量。
- en: How to use components in the install() command
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何在`install()`命令中使用组件
- en: 'Some produced artifacts may not need to be installed for all scenarios. For
    example, a project may install static libraries and public headers for developing
    purposes, but by default, it can just install a shared library for the runtime.
    To make this duality of behavior possible, we can group artifacts under a common
    name by using the `COMPONENT` keyword, which is available in all the `install()`
    commands. Users that are interested in limiting installation to a specific component
    can request this explicitly by running the following command (the component names
    are case-sensitive):'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 一些生成的工件可能不需要在所有场景中都进行安装。例如，一个项目可能为了开发目的安装静态库和公共头文件，但默认情况下，它只需安装共享库以供运行时使用。为了实现这种行为的双重性，我们可以使用在所有`install()`命令中可用的`COMPONENT`关键字来将工件分组，用户如果对限制安装到特定组件感兴趣，可以通过运行以下命令（组件名称区分大小写）来显式请求：
- en: '[PRE62]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Marking an artifact with the `COMPONENT` keyword doesn't mean that it won't
    be installed by default. To prevent this from happening, we must add the `EXCLUDE_FROM_ALL`
    keyword.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 用`COMPONENT`关键字标记一个工件并不意味着它不会被默认安装。为了防止这种情况发生，我们必须添加`EXCLUDE_FROM_ALL`关键字。
- en: 'Let''s explore these components using a code example:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个代码示例来探索这些组件：
- en: chapter-11/11-components/CMakeLists.txt (fragment)
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-11/11-components/CMakeLists.txt（片段）
- en: '[PRE63]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'These install commands define the following components:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这些安装命令定义了以下组件：
- en: '`lib`: This contains the static library and target export files. It''s installed
    by default.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lib`：这包含静态库和目标导出文件。它默认安装。'
- en: '`headers`: This contains public header files. It is installed by default.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`headers`：包含公共头文件。它默认安装。'
- en: '`extra`: This executes a piece of code by printing a message. It''s not installed
    by default.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extra`：通过打印一条消息执行一段代码。它不会被默认安装。'
- en: 'Let''s reiterate this:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重申这一点：
- en: '`cmake --install` without the `--component` argument will install both the
    `lib` and `headers` components.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不带`--component`参数的`cmake --install`将安装`lib`和`headers`组件。
- en: '`cmake --install --component headers` will only install public headers.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmake --install --component headers`将只安装公共头文件。'
- en: '`cmake --install --component extra` will print a message that''s inaccessible
    otherwise (because of the `EXCLUDE_FROM_ALL` keyword).'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmake --install --component extra`将打印一条在其他情况下无法访问的消息（因为`EXCLUDE_FROM_ALL`关键字）。'
- en: If no `COMPONENT` keyword is specified for the installed artifact, it will get
    a default value of `Unspecified` from the `CMAKE_INSTALL_DEFAULT_COMPONENT_NAME`
    variable.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安装的工件没有指定`COMPONENT`关键字，它将从`CMAKE_INSTALL_DEFAULT_COMPONENT_NAME`变量中获得默认值`Unspecified`。
- en: Note
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Since there's no easy way to list all the components that are available from
    the `cmake` command line, users of your package will benefit from exhaustive documentation
    listing your package's components. Perhaps the `INSTALL` file would be a good
    place to mention it.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有简单的方法从`cmake`命令行列出所有可用的组件，您的包的用户将受益于详尽的文档，列出您的包的组件。也许在`INSTALL`文件中提到这一点是个好主意。
- en: If `cmake` is called with the `--component` argument for a component that doesn't
    exist, then the command will succeed without any warnings or errors. It just won't
    install anything.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用`cmake`时为不存在的一个组件提供了`--component`参数，那么该命令将成功执行，不带任何警告或错误。它只是不会安装任何东西。
- en: Partitioning our installation into components enables users to cherry-pick what
    they want to install. We have mostly discussed grouping installed files into components,
    but there are also are procedural steps such as `install(SCRIPT|CODE)` or creating
    symlinks for shared libraries.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的安装划分为组件使得用户能够挑选他们想要安装的内容。我们 mostly 讨论了将安装文件划分为组件，但还有些程序步骤，比如`install(SCRIPT|CODE)`或为共享库创建符号链接。
- en: Managing symbolic links for versioned shared libraries
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理版本化共享库的符号链接
- en: The target platform for your installation may use symbolic links to help linkers
    discover the currently installed version of a shared library. After creating a
    `lib<name>.so` symlink to the `lib<name>.so.1` file, it's possible to link this
    library by passing the `-l<name>` argument to the linker. The creation of such
    symlinks is handled by CMake's `install(TARGETS <target> LIBRARY)` block when
    needed.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 您的安装目标平台可能使用符号链接来帮助链接器发现当前安装的共享库版本。在创建一个指向`lib<name>.so.1`文件的`lib<name>.so`符号链接之后，可以通过向链接器传递`-l<name>`参数来链接这个库。当需要时，此类符号链接由CMake的`install(TARGETS
    <target> LIBRARY)`块处理。
- en: 'However, we may decide to move that step into another `install()` command by
    adding `NAMELINK_SKIP` to this block:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可能决定将这个步骤移到另一个`install()`命令中，通过在这个块中添加`NAMELINK_SKIP`来实现：
- en: '[PRE64]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'To assign symlinking to another component (instead of disabling it altogether),
    we can repeat the `install()` command for the same target and specify a different
    component, followed by the `NAMELINK_ONLY` keyword:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 要将符号链接分配给另一个组件（而不是完全禁用它），我们可以为同一目标重复`install()`命令，指定不同的组件，然后是`NAMELINK_ONLY`关键字：
- en: '[PRE65]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The same can be achieved with the `NAMELINK_COMPONENT` keyword:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，可以使用`NAMELINK_COMPONENT`关键字实现：
- en: '[PRE66]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Now that we have configured automatic installation, we can provide pre-built
    artifacts for our users using the CPack tool, which is included with CMake.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如今我们已经配置了自动安装，我们可以使用随CMake提供的CPack工具为我们的用户提供预先构建的工件。
- en: Packaging with CPack
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CPack进行打包
- en: Building projects from a source has its benefits, but it can take a long time
    and introduce a lot of complexity. This isn't the best experience for end users
    who just want to use the package, especially if they aren't developers themselves.
    A much more convenient form of software distribution is to use binary packages
    that contain compiled artifacts and other static files that are needed by the
    runtime. CMake supports generating multiple kinds of such packages through a command-line
    tool called `cpack`.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 从源代码构建项目有其优点，但它可能需要很长时间并引入很多复杂性。这并不是终端用户所期望的最佳体验，尤其是如果他们自己不是开发者的话。对于终端用户来说，一种更加便捷的软件分发方式是使用包含编译工件和其他运行时所需静态文件的二进制包。CMake通过名为`cpack`的命令行工具支持生成多种此类包。
- en: 'The following table lists the available package generators:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了可用的包生成器：
- en: '![](img/Table_11.3_B17205.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_11.3_B17205.jpg)'
- en: Most of these generators have extensive configurations. It is beyond the scope
    of this book to delve into all their details, so be sure to check out the full
    documentation, which can be found in the *Further reading* section. Instead, we'll
    focus on the general use case.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这些生成器中的大多数都有广泛的配置。深入了解所有它们的细节超出了本书的范围，所以一定要查看完整的文档，您可以在“进一步阅读”部分找到。相反，我们将关注一般使用案例。
- en: Note
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Package generators shouldn't be confused with buildsystem generators (Unix Makefiles,
    Visual Studio, and so on).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 包生成器不应该与构建系统生成器（Unix Makefiles，Visual Studio等）混淆。
- en: To use CPack, we'll need to correctly configure the installation of our project
    with the necessary `install()` commands and build our project. The resulting `cmake_install.cmake`
    that's generated in our build tree will be used by `cpack` to prepare binary packages
    based on the configuration file (`CPackConfig.cmake`). While it's possible to
    create this file manually, it's easier to use `include(CPack)` to include the
    utility module in our project's listfile. It will generate the configuration in
    the project's build tree and supply all the default values where needed.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用CPack，我们需要正确配置项目的安装，并使用必要的`install()`命令构建项目。在我们构建树中生成的`cmake_install.cmake`将用于`cpack`根据配置文件（`CPackConfig.cmake`）准备二进制包。虽然可以手动创建此文件，但使用`include(CPack)`更容易地在项目的列表文件中包含实用模块。它将在项目的构建树中生成配置，并在需要的地方提供所有默认值。
- en: 'Let''s see how we can extend the example `11-components` so that it can work
    with CPack:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何扩展示例`11-components`，使其可以与CPack一起工作：
- en: chapter-11/12-cpack/CMakeLists.txt (fragment)
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-11/12-cpack/CMakeLists.txt (片段)
- en: '[PRE67]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The code is pretty self-explanatory, so we won''t dwell on it too much (please
    refer to the module documentation, which can be found in the *Further reading*
    section). One thing worth noting here is the fact that the `CPack` module will
    infer a few values from the `project()` command:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 代码相当直观，所以我们不会过多地解释（请参考模块文档，可以在*进一步阅读*部分找到）。这里值得注意的一点是，`CPack`模块将从`project()`命令中推断出一些值：
- en: '`CPACK_PACKAGE_NAME`'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CPACK_PACKAGE_NAME`'
- en: '`CPACK_PACKAGE_VERSION`'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CPACK_PACKAGE_VERSION`'
- en: '`CPACK_PACKAGE_FILE_NAME`'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CPACK_PACKAGE_FILE_NAME`'
- en: 'The last value will be used to produce the output package. Its structure is
    as follows:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个值将用于生成输出包。其结构如下：
- en: '[PRE68]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Here, `CPACK_SYSTEM_NAME` is the name of the target OS; for example, `Linux`
    or `win32`. For example, by executing a ZIP generator on Debian, CPack will generate
    a file named `CPackPackage-1.2.3-Linux.zip`.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`CPACK_SYSTEM_NAME`是目标操作系统的名称；例如，`Linux`或`win32`。例如，通过在Debian上执行ZIP生成器，CPack将生成一个名为`CPackPackage-1.2.3-Linux.zip`的文件。
- en: 'After building our project, we can generate actual packages by running the
    `cpack` binary in the build tree:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建项目之后，我们可以在构建树中运行`cpack`二进制文件来生成实际的包：
- en: '[PRE69]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Technically speaking, CPack is capable of reading all its options from the
    configuration file that''s been placed in the current working directory, but you
    may choose to override these settings from the command line:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，CPack能够读取放置在当前工作目录中的所有配置文件选项，但你也可以选择从命令行覆盖这些设置：
- en: '`-G <generators>`: This is a semicolon-separated list of package generators
    to use. The default value can be specified in the `CPackConfig.cmake` in the `CPACK_GENERATOR`
    variable.'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-G <generators>`:这是一个由分号分隔的包生成器列表。默认值可以在`CPackConfig.cmake`中的`CPACK_GENERATOR`变量中指定。'
- en: '`-C <configs>`: This is a semicolon-separated list of build configurations
    (debug, release) to generate packages for (required for multi-configuration buildsystem
    generators).'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-C <configs>`:这是一个由分号分隔的构建配置（调试、发布）列表，用于生成包（对于多配置构建系统生成器，这是必需的）。'
- en: '`-D <var>=<value>`: This overrides a `<var>` variable that''s set in the `CPackConfig.cmake`
    file with `<value>`.'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-D <var>=<value>`: 这个选项会覆盖`CPackConfig.cmake`文件中设置的`<var>`变量，以`<value>`为准。'
- en: '`--config <config-file>`: This is the config-file you should use instead of
    the default `CPackConfig.cmake`.'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--config <config-file>`: 这是你应该使用的配置文件，而不是默认的`CPackConfig.cmake`。'
- en: '`--verbose, -V`: Provides verbose output.'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--verbose, -V`: 提供详细输出。'
- en: '`-P <packageName>`: Overrides the package name.'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-P <packageName>`: 覆盖包名称。'
- en: '`-R <packageVersion>`: Overrides the package version.'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-R <packageVersion>`: 覆盖包版本。'
- en: '`--vendor <vendorName>`: Overrides the package vendor.'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--vendor <vendorName>`: 覆盖包供应商。'
- en: '`-B <packageDirectory>`: Specifies the output directory for `cpack` (by default,
    this will be the current working directory).'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-B <packageDirectory>`: 为`cpack`指定输出目录（默认情况下，这将是目前的工作目录）。'
- en: 'Let''s try generating packages for our `12-cpack` output. We''re going to use
    ZIP, 7Z, and the Debian package generator:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试为我们的`12-cpack`输出生成包。我们将使用ZIP、7Z和Debian包生成器：
- en: '[PRE70]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The following packages should be generated:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 以下应该生成以下包：
- en: '`CPackPackage-1.2.3-Linux.7z`'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CPackPackage-1.2.3-Linux.7z`'
- en: '`CPackPackage-1.2.3-Linux.deb`'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CPackPackage-1.2.3-Linux.deb`'
- en: '`CPackPackage-1.2.3-Linux.zip`'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CPackPackage-1.2.3-Linux.zip`'
- en: In this format, binary packages are ready to be published on the website of
    our project, in a GitHub release, or sent to a package repository for end users
    to enjoy.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种格式中，二进制包准备好发布在我们项目的网站上，在GitHub发行版中，或发送到包仓库，供最终用户享用。
- en: Summary
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Writing installation scripts in a cross-platform way is an incredibly complex
    task without a tool such as CMake. While it still requires a little bit of work
    to set up, it's a much more streamlined process that ties closely to all the other
    concepts and techniques we've used so far in this book.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有像CMake这样的工具的情况下，以跨平台方式编写安装脚本是一项极其复杂的任务。虽然设置还需要一点工作，但它是一个更加流畅的过程，紧密地与本书到目前为止使用的所有其他概念和技术相关联。
- en: First, we learned how to export CMake targets from projects so that they can
    be consumed in other projects without installing them. Then, we learned how to
    install projects that had already been configured for this purpose.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们学习了如何从项目中导出CMake目标，以便它们可以在不安装它们的情况下被其他项目消费。然后，我们学习了如何安装已经为此目的配置好的项目。
- en: 'After that, we started exploring the basics of installation by starting with
    the most important subject: installing CMake targets. We now know how CMake handles
    different destinations for various artifact types and how to deal with public
    headers that are somewhat special. To manage these installation steps at lower
    levels, we discussed other modes of the `install()` command, including installing
    files, programs, and directories and invoking scripts during the installation.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在那之后，我们开始探索安装的基础知识，从最重要的主题开始：安装CMake目标。我们现在知道CMake如何处理各种工件类型的不同目的地以及如何处理 somewhat
    special 的公共头文件。为了在较低级别管理这些安装步骤，我们讨论了`install()`命令的其他模式，包括安装文件、程序和目录以及在安装过程中调用脚本。
- en: After explaining how to codify the installation steps, we learned about CMake's
    reusable packages. Specifically, we learned how to make targets in our projects
    relocatable so that the packages can be installed wherever the user wants. Then,
    we focused on forming a fully-defined package that can be consumed by other projects
    with `find_package()`, which required preparing target export files, config-files,
    and *version files*.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释了如何编码安装步骤之后，我们学习了CMake的可重用包。具体来说，我们学习了如何使项目中的目标可移动，以便包可以在用户希望安装的任何地方进行安装。然后，我们专注于形成一个完全定义的包，它可以通过`find_package()`被其他项目消费，这需要准备目标导出文件、配置文件以及*版本文件*。
- en: Recognizing that different users may need different parts of our package, we
    discovered how to group artifacts and actions in installation components, as well
    as how they differ from the components of CMake packages.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 认识到不同用户可能需要我们包的不同部分，我们发现了如何将工件和动作分组在安装组件中，以及它们与CMake包组件的区别。
- en: Finally, we touched on CPack and learned how to prepare basic binary packages
    that can be used to distribute our software in a pre-compiled form.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们提到了CPack，并学习了如何准备基本的二进制包，以使用预编译的形式分发我们的软件。
- en: There's still a long way to go to fully grasp all the details and complexities
    of installation and packaging, but this chapter has given us a solid foundation
    to handle the most common scenarios and explore them further with confidence.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全掌握安装和打包的所有细节和复杂性还有很长的路要走，但本章为我们提供了坚实的基础，以处理最常见的情况并自信地进一步探索它们。
- en: In the next chapter, we will put everything we've learned so far into practice
    by creating a coherent, professional project.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把我们到目前为止所学的所有内容付诸实践，通过创建一个连贯、专业的项目。
- en: Further reading
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章涵盖的主题，请查看以下资源：
- en: '*GNU Coding Standards for Destinations*:[https://www.gnu.org/prep/standards/html_node/Directory-Variables.html](https://www.gnu.org/prep/standards/html_node/Directory-Variables.html)'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于*GNU目标目的地编码标准*：[https://www.gnu.org/prep/standards/html_node/Directory-Variables.html](https://www.gnu.org/prep/standards/html_node/Directory-Variables.html)
- en: '*Discussion on new public header management with the* `FILE_SET` *keyword*:
    [https://gitlab.kitware.com/cmake/cmake/-/issues/22468#note_991860](https://gitlab.kitware.com/cmake/cmake/-/issues/22468#note_991860)'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于使用`FILE_SET`关键字的新公共头文件管理进行的*讨论*：[https://gitlab.kitware.com/cmake/cmake/-/issues/22468#note_991860](https://gitlab.kitware.com/cmake/cmake/-/issues/22468#note_991860)
- en: '*How to install a shared library*:[https://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html](https://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html)'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安装共享库： [https://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html](https://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html)
- en: '*Creating relocatable packages*: [https://cmake.org/cmake/help/latest/guide/importing-exporting/index.html#creating-relocatable-packages](https://cmake.org/cmake/help/latest/guide/importing-exporting/index.html#creating-relocatable-packages)'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可移动包： [https://cmake.org/cmake/help/latest/guide/importing-exporting/index.html#creating-relocatable-packages](https://cmake.org/cmake/help/latest/guide/importing-exporting/index.html#creating-relocatable-packages)
- en: '*List of paths scanned by* `find_package()` *to find the config file*: [https://cmake.org/cmake/help/latest/command/find_package.html#config-mode-search-procedure](https://cmake.org/cmake/help/latest/command/find_package.html#config-mode-search-procedure)'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_package()` 扫描的路径列表以找到配置文件： [https://cmake.org/cmake/help/latest/command/find_package.html#config-mode-search-procedure](https://cmake.org/cmake/help/latest/command/find_package.html#config-mode-search-procedure)'
- en: '*Full documentation of* `CMakePackageConfigHelpers`: [https://cmake.org/cmake/help/latest/module/CMakePackageConfigHelpers.html](https://cmake.org/cmake/help/latest/module/CMakePackageConfigHelpers.html)'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMakePackageConfigHelpers`的完整文档： [https://cmake.org/cmake/help/latest/module/CMakePackageConfigHelpers.html](https://cmake.org/cmake/help/latest/module/CMakePackageConfigHelpers.html)'
- en: '*CPack package generators*:[https://cmake.org/cmake/help/latest/manual/cpack-generators.7.html](https://cmake.org/cmake/help/latest/manual/cpack-generators.7.html)'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPack包生成器： [https://cmake.org/cmake/help/latest/manual/cpack-generators.7.html](https://cmake.org/cmake/help/latest/manual/cpack-generators.7.html)
- en: '*On preferred package generators for different platforms*:[https://stackoverflow.com/a/46013099](https://stackoverflow.com/a/46013099)'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同平台首选的包生成器： [https://stackoverflow.com/a/46013099](https://stackoverflow.com/a/46013099)
- en: '*CPack utility module documentation*:[https://cmake.org/cmake/help/latest/module/CPack.html](https://cmake.org/cmake/help/latest/module/CPack.html)'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPack工具模块文档： [https://cmake.org/cmake/help/latest/module/CPack.html](https://cmake.org/cmake/help/latest/module/CPack.html)
