["```cpp\nvoid Dispatcher::addRequest(AbstractRequest* request) {\n    workersMutex.lock();\n    if (!workers.empty()) {\n          Worker* worker = workers.front();\n          worker->setRequest(request);\n          condition_variable* cv;\n          mutex* mtx;\n          worker->getCondition(cv);\n          worker->getMutex(mtx);\n          unique_lock<mutex> lock(*mtx);\n          cv->notify_one();\n          workers.pop();\n          workersMutex.unlock();\n    }\n    else {\n          workersMutex.unlock();\n          requestsMutex.lock();\n          requests.push(request);\n          requestsMutex.unlock();\n    }\n } \n```", "```cpp\nbool Dispatcher::addWorker(Worker* worker) {\n    bool wait = true;\n    requestsMutex.lock();\n    if (!requests.empty()) {\n          AbstractRequest* request = requests.front();\n          worker->setRequest(request);\n          requests.pop();\n          wait = false;\n          requestsMutex.unlock();\n    }\n    else {\n          requestsMutex.unlock();\n          workersMutex.lock();\n          workers.push(worker);\n          workersMutex.unlock();\n    }\n          return wait;\n } \n```", "```cpp\n    ==6984== Possible data race during write of size 1 at 0x5CD9260 by thread #1\n ==6984== Locks held: none\n ==6984==    at 0x40362C: Worker::stop() (worker.h:37)\n ==6984==    by 0x403184: Dispatcher::stop() (dispatcher.cpp:50)\n ==6984==    by 0x409163: main (main.cpp:70)\n ==6984== \n ==6984== This conflicts with a previous read of size 1 by thread #2\n ==6984== Locks held: none\n ==6984==    at 0x401E0E: Worker::run() (worker.cpp:51)\n ==6984==    by 0x408FA4: void std::_Mem_fn_base<void (Worker::*)(), true>::operator()<, void>(Worker*) const (in /media/sf_Projects/Cerflet/dispatcher/dispatcher_demo)\n ==6984==    by 0x408F38: void std::_Bind_simple<std::_Mem_fn<void (Worker::*)()> (Worker*)>::_M_invoke<0ul>(std::_Index_tuple<0ul>) (functional:1531)\n ==6984==    by 0x408E3F: std::_Bind_simple<std::_Mem_fn<void (Worker::*)()> (Worker*)>::operator()() (functional:1520)\n ==6984==    by 0x408D47: std::thread::_Impl<std::_Bind_simple<std::_Mem_fn<void (Worker::*)()> (Worker*)> >::_M_run() (thread:115)\n ==6984==    by 0x4EF8C7F: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21)\n ==6984==    by 0x4C34DB6: ??? (in /usr/lib/valgrind/vgpreload_helgrind-amd64-linux.so)\n ==6984==    by 0x53DF6B9: start_thread (pthread_create.c:333)\n ==6984==  Address 0x5cd9260 is 96 bytes inside a block of size 104 alloc'd\n ==6984==    at 0x4C2F50F: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_helgrind-amd64-linux.so)\n ==6984==    by 0x40308F: Dispatcher::init(int) (dispatcher.cpp:38)\n ==6984==    by 0x4090A0: main (main.cpp:51)\n ==6984==  Block was alloc'd by thread #1\n\n```", "```cpp\nbool Dispatcher::stop() {\n    for (int i = 0; i < allWorkers.size(); ++i) {\n          allWorkers[i]->stop();\n    }\n          cout << \"Stopped workers.n\";\n          for (int j = 0; j < threads.size(); ++j) {\n          threads[j]->join();\n                      cout << \"Joined threads.n\";\n    }\n } \n```", "```cpp\n   void stop() { running = false; } \n```", "```cpp\nvoid Worker::run() {\n    while (running) {\n          if (ready) {\n                ready = false;\n                request->process();\n                request->finish();\n          }\n                      if (Dispatcher::addWorker(this)) {\n                while (!ready && running) {\n                      unique_lock<mutex> ulock(mtx);\n                      if (cv.wait_for(ulock, chrono::seconds(1)) == cv_status::timeout) {\n                      }\n                }\n          }\n    }\n } \n```", "```cpp\nbool TAS(bool lock) { \n   if (lock) { \n         return true; \n   } \n   else { \n         lock = true; \n         return false; \n   } \n} \n```", "```cpp\nbool CAS(int* p, int old, int new) { \n   if (*p != old) { \n               return false; \n         } \n\n   *p = new; \n         return true; \n} \n```", "```cpp\nvolatile bool lock = false; \n\n void critical() { \n     while (TAS(&lock) == false); \n     // Critical section \n     lock = 0; \n } \n```", "```cpp\nclass Foo { \n   static std::map<int, std::string> strings; \n   static std::string oneString; \n\npublic: \n   static void init(int a, std::string b, std::string c) { \n         strings.insert(std::pair<int, std::string>(a, b)); \n         oneString = c; \n   } \n}; \n\nstd::map<int, std::string> Foo::strings; \nstd::string Foo::oneString; \n```", "```cpp\nclass Bar { \n   static std::string name; \n   static std::string initName(); \n\npublic: \n   void init(); \n}; \n\n// Static initializations. \nstd::string Bar::name = Bar::initName(); \n\nstd::string Bar::initName() { \n   Foo::init(1, \"A\", \"B\"); \n   return \"Bar\"; \n} \n```", "```cpp\nclass Foo { \n   static std::map<int, std::string>& strings(); \n   static std::string oneString; \n\npublic: \n   static void init(int a, std::string b, std::string c) { \n         static std::map<int, std::string> stringsStatic = Foo::strings(); \n         stringsStatic.insert(std::pair<int, std::string>(a, b)); \n         oneString = c; \n   } \n}; \n\nstd::string Foo::oneString; \n\nstd::map<int, std::string>& Foo::strings() { \n   static std::map<int, std::string>* stringsStatic = new std::map<int, std::string>(); \n   return *stringsStatic; \n} \n```"]