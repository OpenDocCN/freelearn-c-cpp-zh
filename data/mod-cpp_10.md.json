["```cpp\n        struct foo \n        { \n          foo() = default; \n        };\n```", "```cpp\n        struct foo \n        { \n          foo(foo const &) = delete; \n        }; \n\n        void func(int) = delete;\n```", "```cpp\n        class foo_not_copyable \n        { \n        public: \n          foo_not_copyable() = default; \n\n          foo_not_copyable(foo_not_copyable const &) = delete; \n          foo_not_copyable& operator=(foo_not_copyable const&) = delete; \n        };\n```", "```cpp\n        class data_wrapper \n        { \n          Data* data; \n        public: \n          data_wrapper(Data* d = nullptr) : data(d) {} \n          ~data_wrapper() { delete data; } \n\n          data_wrapper(data_wrapper const&) = delete; \n          data_wrapper& operator=(data_wrapper const &) = delete; \n\n          data_wrapper(data_wrapper&& o) :data(std::move(o.data))  \n          {  \n            o.data = nullptr;  \n          } \n\n          data_wrapper& operator=(data_wrapper&& o) \n          { \n            if (this != &o) \n            { \n              delete data; \n              data = std::move(o.data); \n              o.data = nullptr; \n            } \n\n            return *this; \n          } \n        };\n```", "```cpp\n        template <typename T> \n        void run(T val) = delete; \n\n        void run(long val) {} // can only be called with long integers\n```", "```cpp\n    class foo \n    { \n    public: \n      foo() = default; \n\n      inline foo& operator=(foo const &); \n    }; \n\n    inline foo& foo::operator=(foo const &) = default;\n```", "```cpp\n    run(42);  // error, matches a deleted overload \n    run(42L); // OK, long integer arguments are allowed\n```", "```cpp\n    void forward_declared_function(); \n    // ... \n    void forward_declared_function() = delete; // error\n```", "```cpp\n        auto numbers =  \n          std::vector<int>{ 0, 2, -3, 5, -1, 6, 8, -4, 9 }; \n        auto positives = std::count_if( \n          std::begin(numbers), std::end(numbers),  \n          [](int const n) {return n > 0; });\n```", "```cpp\n        auto ispositive = [](int const n) {return n > 0; }; \n        auto positives = std::count_if( \n          std::begin(numbers), std::end(numbers), ispositive);\n```", "```cpp\n        auto positives = std::count_if( \n          std::begin(numbers), std::end(numbers),  \n          [](auto const n) {return n > 0; });\n```", "```cpp\n    struct __lambda_name__ \n    { \n      bool operator()(int const n) const { return n > 0; } \n    };\n```", "```cpp\n    auto numbers = std::vector<int>{ 0, 2, -3, 5, -1, 6, 8, -4, 9 }; \n    auto start{ 5 }; \n    auto end{ 10 }; \n    auto inrange = std::count_if( \n             std::begin(numbers), std::end(numbers),  \n             [start, end](int const n) {\n                return start <= n && n <= end;});\n```", "```cpp\n    class __lambda_name_2__ \n    { \n      int start_; \n      int end_; \n    public: \n      explicit __lambda_name_2__(int const start, int const end) : \n        start_(start), end_(end) \n      {} \n\n      __lambda_name_2__(const __lambda_name_2__&) = default; \n      __lambda_name_2__(__lambda_name_2__&&) = default; \n      __lambda_name_2__& operator=(const __lambda_name_2__&)  \n         = delete; \n      ~__lambda_name_2__() = default; \n\n      bool operator() (int const n) const \n      { \n        return start_ <= n && n <= end_; \n      } \n    };\n```", "```cpp\n    [capture-list](params) mutable constexpr exception attr -> ret\n    { body }\n```", "```cpp\n        auto numbers =\n          std::vector<int>{0, 2, -3, 5, -1, 6, 8, -4, 9};  \n        auto texts =  \n          std::vector<std::string>{\"hello\"s, \" \"s, \"world\"s, \"!\"s}; \n\n        auto lsum = [](auto const s, auto const n) {return s + n;}; \n\n        auto sum = std::accumulate( \n          std::begin(numbers), std::end(numbers), 0, lsum); \n          // sum = 22 \n\n        auto text = std::accumulate( \n          std::begin(texts), std::end(texts), \"\"s, lsum); \n          // sum = \"hello world!\"s\n```", "```cpp\n    struct __lambda_name__ \n    { \n      template<typename T1, typename T2> \n      auto operator()(T1 const s, T2 const n) const { return s + n; } \n\n       __lambda_name__(const __lambda_name__&) = default; \n       __lambda_name__(__lambda_name__&&) = default; \n       __lambda_name__& operator=(const __lambda_name__&) = delete; \n       ~__lambda_name__() = default; \n    };\n```", "```cpp\n    constexpr int fib(int const n) \n    { \n      return n <= 2 ? 1 : fib(n - 1) + fib(n - 2); \n    }\n```", "```cpp\n        void sample() \n        { \n          std::function<int(int const)> lfib =  \n            [&lfib](int const n) \n            { \n              return n <= 2 ? 1 : lfib(n - 1) + lfib(n - 2); \n            }; \n\n          auto f10 = lfib(10); \n        }\n```", "```cpp\n        std::function<int(int const)> fib_create() \n        { \n          std::function<int(int const)> f = [](int const n)  \n          { \n            std::function<int(int const)> lfib = [&lfib](int n) \n            { \n              return n <= 2 ? 1 : lfib(n - 1) + lfib(n - 2); \n            }; \n            return lfib(n); \n          }; \n          return f; \n        } \n\n        void sample() \n        { \n          auto lfib = fib_create(); \n          auto f10 = lfib(10); \n        }\n```", "```cpp\n    // this implementation of fib_create is faulty\n    std::function<int(int const)> fib_create() \n    { \n      std::function<int(int const)> lfib = [&lfib](int const n) \n      { \n        return n <= 2 ? 1 : lfib(n - 1) + lfib(n - 2); \n      }; \n\n      return lfib; \n    } \n\n    void sample() \n    { \n      auto lfib = fib_create();\n      auto f10 = lfib(10);       // crash \n    }\n```", "```cpp\n    template <typename T>                 // [1] overload with fixed \n    T add(T value)                        //     number of arguments \n    { \n      return value; \n    } \n\n    template <typename T, typename... Ts> // [2] typename... Ts \n    T add(T head, Ts... rest)             // [3] Ts... rest \n    { \n      return head + add(rest...);         // [4] rest...  \n    }\n```", "```cpp\n    auto s1 = add(1, 2, 3, 4, 5);  \n    // s1 = 15 \n    auto s2 = add(\"hello\"s, \" \"s, \"world\"s, \"!\"s);  \n    // s2 = \"hello world!\"\n```", "```cpp\n    int add(int head, int arg1, int arg2, int arg3, int arg4)  \n    {return head + add(arg1, arg2, arg3, arg4);} \n    int add(int head, int arg1, int arg2, int arg3)  \n    {return head + add(arg1, arg2, arg3);} \n    int add(int head, int arg1, int arg2)  \n    {return head + add(arg1, arg2);} \n    int add(int head, int arg1)  \n    {return head + add(arg1);} \n    int add(int value)  \n    {return value;}\n```", "```cpp\n    T add(T, Ts ...) [with T = int; Ts = {int, int, int, int}] \n    T add(T, Ts ...) [with T = int; Ts = {int, int, int}] \n    T add(T, Ts ...) [with T = int; Ts = {int, int}] \n    T add(T, Ts ...) [with T = int; Ts = {int}] \n    T add(T) [with T = int]\n```", "```cpp\n    auto s3 = add(\"hello\"s, ' ', \"world\"s, '!');  \n    // s3 = \"hello world!\"\n```", "```cpp\nIn instantiation of 'T add(T, Ts ...) [with T = char; Ts = {string, char}]': \n16:29:   required from 'T add(T, Ts ...) [with T = string; Ts = {char, string, char}]' \n22:46:   required from here \n16:29: error: cannot convert 'string' to 'char' in return \n In function 'T add(T, Ts ...) [with T = char; Ts = {string, char}]': \n17:1: warning: control reaches end of non-void function [-Wreturn-type]\n```", "```cpp\n    string add(string head, char arg1, string arg2, char arg3)  \n    {return head + add(arg1, arg2, arg3);} \n    char add(char head, string arg1, char arg2)  \n    {return head + add(arg1, arg2);} \n    string add(string head, char arg1)  \n    {return head + add(arg1);} \n    char add(char value)  \n    {return value;}\n```", "```cpp\n    template <typename T, typename... Ts> \n    auto add(T head, Ts... rest) \n    { \n      return head + add(rest...); \n    }\n```", "```cpp\n    template<typename... T> \n    auto make_even_tuple(T... a) \n    { \n      static_assert(sizeof...(a) % 2 == 0,  \n                    \"expected an even number of arguments\"); \n      std::tuple<T...> t { a... }; \n\n      return t; \n    } \n\n    auto t1 = make_even_tuple(1, 2, 3, 4); // OK \n\n    // error: expected an even number of arguments \n    auto t2 = make_even_tuple(1, 2, 3);\n```", "```cpp\n    template <typename T> \n    T add(T value) \n    { \n      return value; \n    } \n\n    template <typename T, typename... Ts> \n    T add(T head, Ts... rest) \n    { \n      return head + add(rest...); \n    }\n```", "```cpp\n        template <typename... Ts> \n        auto add(Ts... args) \n        { \n          return (... + args); \n        }\n```", "```cpp\n        template <typename... Ts> \n        auto add_to_one(Ts... args) \n        { \n          return (1 + ... + args); \n        }\n```", "```cpp\n        template <typename... Ts> \n        auto add(Ts... args) \n        { \n          return (args + ...); \n        }\n```", "```cpp\n        template <typename... Ts> \n        auto add_to_one(Ts... args) \n        { \n          return (args + ... + 1); \n        }\n```", "```cpp\n    auto sum = add(1, 2, 3, 4, 5);         // sum = 15 \n    auto sum1 = add_to_one(1, 2, 3, 4, 5); // sum = 16\n```", "```cpp\n    int add(int arg1, int arg2, int arg3, int arg4, int arg5) \n    { \n      return ((((arg1 + arg2) + arg3) + arg4) + arg5); \n    }\n```", "```cpp\n    template <typename T> \n    struct wrapper \n    { \n      T const & value; \n    }; \n\n    template <typename T> \n    constexpr auto operator<(wrapper<T> const & lhs,  \n                             wrapper<T> const & rhs)  \n    { \n      return wrapper<T> { \n        lhs.value < rhs.value ? lhs.value : rhs.value}; \n    } \n\n    template <typename... Ts> \n    constexpr auto min(Ts&&... args)  \n    { \n      return (wrapper<Ts>{args} < ...).value; \n    }\n```", "```cpp\n    auto m = min(1, 2, 3, 4, 5); // m = 1\n```", "```cpp\n        template <typename F, typename R> \n        R mapf(F&& f, R r) \n        { \n          std::transform( \n            std::begin(r), std::end(r), std::begin(r),  \n            std::forward<F>(f)); \n          return r; \n        }\n```", "```cpp\n        template<typename F, typename T, typename U> \n        std::map<T, U> mapf(F&& f, std::map<T, U> const & m) \n        { \n          std::map<T, U> r; \n          for (auto const kvp : m) \n            r.insert(f(kvp)); \n          return r; \n        } \n\n        template<typename F, typename T> \n        std::queue<T> mapf(F&& f, std::queue<T> q) \n        { \n          std::queue<T> r; \n          while (!q.empty()) \n          { \n            r.push(f(q.front())); \n            q.pop(); \n          } \n          return r; \n        }\n```", "```cpp\n        template <typename F, typename R, typename T> \n        constexpr T foldl(F&& f, R&& r, T i) \n        { \n          return std::accumulate( \n            std::begin(r), std::end(r),  \n            std::move(i),  \n            std::forward<F>(f)); \n        } \n\n        template <typename F, typename R, typename T> \n        constexpr T foldr(F&& f, R&& r, T i) \n        { \n          return std::accumulate( \n            std::rbegin(r), std::rend(r),  \n            std::move(i),  \n            std::forward<F>(f)); \n        }\n```", "```cpp\n        template <typename F, typename T> \n        constexpr T foldl(F&& f, std::queue<T> q, T i) \n        { \n          while (!q.empty()) \n          { \n            i = f(i, q.front()); \n            q.pop(); \n          } \n          return i; \n        }\n```", "```cpp\n        auto vnums =  \n          std::vector<int>{0, 2, -3, 5, -1, 6, 8, -4, 9};  \n        auto r = funclib::mapf([](int const i) { \n          return std::abs(i); }, vnums);  \n        // r = {0, 2, 3, 5, 1, 6, 8, 4, 9}\n```", "```cpp\n        auto lnums = std::list<int>{1, 2, 3, 4, 5}; \n        auto l = funclib::mapf([](int const i) { \n          return i*i; }, lnums); \n        // l = {1, 4, 9, 16, 25}\n```", "```cpp\n        template<class T = double> \n        struct fround \n        {   \n          typename std::enable_if< \n            std::is_floating_point<T>::value, T>::type \n          operator()(const T& value) const \n          { \n            return std::round(value); \n          } \n        }; \n\n        auto amounts =  \n          std::array<double, 5> {10.42, 2.50, 100.0, 23.75, 12.99}; \n        auto a = funclib::mapf(fround<>(), amounts); \n        // a = {10.0, 3.0, 100.0, 24.0, 13.0}\n```", "```cpp\n        auto words = std::map<std::string, int>{  \n          {\"one\", 1}, {\"two\", 2}, {\"three\", 3}  \n        }; \n        auto m = funclib::mapf( \n          [](std::pair<std::string, int> const kvp) { \n            return std::make_pair( \n              funclib::mapf(toupper, kvp.first),  \n              kvp.second); \n          }, \n          words); \n        // m = {{\"ONE\", 1}, {\"TWO\", 2}, {\"THREE\", 3}}\n```", "```cpp\n        auto priorities = std::queue<int>(); \n        priorities.push(10); \n        priorities.push(20); \n        priorities.push(30); \n        priorities.push(40); \n        priorities.push(50); \n        auto p = funclib::mapf( \n          [](int const i) { return i > 30 ? 2 : 1; },  \n          priorities); \n        // p = {1, 1, 1, 2, 2}\n```", "```cpp\n        auto vnums =  \n           std::vector<int>{0, 2, -3, 5, -1, 6, 8, -4, 9};  \n\n        auto s1 = funclib::foldl( \n           [](const int s, const int n) {return s + n; },  \n           vnums, 0);                // s1 = 22 \n\n        auto s2 = funclib::foldl( \n           std::plus<>(), vnums, 0); // s2 = 22 \n\n        auto s3 = funclib::foldr( \n           [](const int s, const int n) {return s + n; },  \n           vnums, 0);                // s3 = 22 \n\n        auto s4 = funclib::foldr( \n           std::plus<>(), vnums, 0); // s4 = 22\n```", "```cpp\n        auto texts =  \n           std::vector<std::string>{\"hello\"s, \" \"s, \"world\"s, \"!\"s}; \n\n        auto txt1 = funclib::foldl( \n           [](std::string const & s, std::string const & n) { \n           return s + n;},  \n           texts, \"\"s);    // txt1 = \"hello world!\" \n\n        auto txt2 = funclib::foldr( \n           [](std::string const & s, std::string const & n) { \n           return s + n; },  \n           texts, \"\"s);    // txt2 = \"!world hello\"\n```", "```cpp\n        char chars[] = {'c','i','v','i','c'}; \n\n        auto str1 = funclib::foldl(std::plus<>(), chars, \"\"s);  \n        // str1 = \"civic\" \n\n        auto str2 = funclib::foldr(std::plus<>(), chars, \"\"s);  \n        // str2 = \"civic\"\n```", "```cpp\n        auto words = std::map<std::string, int>{  \n           {\"one\", 1}, {\"two\", 2}, {\"three\", 3} }; \n\n        auto count = funclib::foldl( \n           [](int const s, std::pair<std::string, int> const kvp) { \n              return s + kvp.second; }, \n           words, 0); // count = 6\n```", "```cpp\n    auto vnums = std::vector<int>{ 0, 2, -3, 5, -1, 6, 8, -4, 9 }; \n\n    auto s = funclib::foldl( \n      std::plus<>(), \n      funclib::mapf( \n        [](int const i) {return i*i; },  \n        funclib::mapf( \n          [](int const i) {return std::abs(i); }, \n          vnums)), \n      0); // s = 236\n```", "```cpp\n    template <typename F, typename T1, typename T2> \n    auto foldl(F&&f, T1 arg1, T2 arg2) \n    { \n      return f(arg1, arg2); \n    } \n\n    template <typename F, typename T, typename... Ts> \n    auto foldl(F&& f, T head, Ts... rest) \n    { \n      return f(head, foldl(std::forward<F>(f), rest...)); \n    }\n```", "```cpp\n    auto s1 = foldl(std::plus<>(), 1, 2, 3, 4, 5);  \n    // s1 = 15 \n    auto s2 = foldl(std::plus<>(), \"hello\"s, ' ', \"world\"s, '!');  \n    // s2 = \"hello world!\" \n    auto s3 = foldl(std::plus<>(), 1); // error, too few arguments\n```", "```cpp\n        template <typename F, typename G> \n        auto compose(F&& f, G&& g) \n        {  \n          return [=](auto x) { return f(g(x)); }; \n        } \n\n        auto v = compose( \n          [](int const n) {return std::to_string(n); }, \n          [](int const n) {return n * n; })(-3); // v = \"9\"\n```", "```cpp\n        template <typename F, typename... R> \n        auto compose(F&& f, R&&... r) \n        { \n          return [=](auto x) { return f(compose(r...)(x)); }; \n        } \n\n        auto n = compose( \n          [](int const n) {return std::to_string(n); }, \n          [](int const n) {return n * n; }, \n          [](int const n) {return n + n; }, \n          [](int const n) {return std::abs(n); })(-3); // n = \"36\"\n```", "```cpp\n    auto s = compose( \n      [](std::vector<int> const & v) { \n        return foldl(std::plus<>(), v, 0); }, \n      [](std::vector<int> const & v) { \n        return mapf([](int const i) {return i + i; }, v); }, \n      [](std::vector<int> const & v) { \n        return mapf([](int const i) {return std::abs(i); }, v); })(vnums);\n```", "```cpp\n    template <typename F, typename G> \n    auto operator*(F&& f, G&& g) \n    { \n      return compose(std::forward<F>(f), std::forward<G>(g)); \n    } \n\n    template <typename F, typename... R> \n    auto operator*(F&& f, R&&... r) \n```", "```cpp\n    { \n      return operator*(std::forward<F>(f), r...); \n    }\n```", "```cpp\n    auto n = \n      ([](int const n) {return std::to_string(n); } * \n       [](int const n) {return n * n; } * \n       [](int const n) {return n + n; } * \n       [](int const n) {return std::abs(n); })(-3); // n = \"36\" \n\n    auto c =  \n      [](std::vector<int> const & v) { \n        return foldl(std::plus<>(), v, 0); } * \n      [](std::vector<int> const & v) { \n        return mapf([](int const i) {return i + i; }, v); } * \n      [](std::vector<int> const & v) { \n        return mapf([](int const i) {return std::abs(i); }, v); }; \n\n    auto s = c(vnums); // s = 76\n```", "```cpp\n    int add(int const a, int const b) \n    { \n      return a + b; \n    } \n\n    struct foo \n    { \n      int x = 0; \n\n      void increment_by(int const n) { x += n; } \n    };\n```", "```cpp\n        auto a1 = std::invoke(add, 1, 2);   // a1 = 3\n```", "```cpp\n        auto a2 = std::invoke(&add, 1, 2);  // a2 = 3 \n        int(*fadd)(int const, int const) = &add; \n        auto a3 = std::invoke(fadd, 1, 2);  // a3 = 3\n```", "```cpp\n        foo f; \n        std::invoke(&foo::increment_by, f, 10);\n```", "```cpp\n        foo f; \n        auto x1 = std::invoke(&foo::x, f);  // x1 = 0\n```", "```cpp\n        foo f; \n        auto x3 = std::invoke(std::plus<>(),  \n          std::invoke(&foo::x, f), 3); // x3 = 3\n```", "```cpp\n        auto l = [](auto a, auto b) {return a + b; }; \n        auto a = std::invoke(l, 1, 2); // a = 3\n```", "```cpp\n    namespace details \n    { \n      template <class F, class T, std::size_t... I> \n      auto apply(F&& f, T&& t, std::index_sequence<I...>) \n      { \n        return std::invoke( \n          std::forward<F>(f), \n          std::get<I>(std::forward<T>(t))...); \n      } \n    } \n\n    template <class F, class T> \n    auto apply(F&& f, T&& t) \n    { \n      return details::apply( \n        std::forward<F>(f), \n        std::forward<T>(t), \n        std::make_index_sequence< \n          std::tuple_size<std::decay_t<T>>::value> {}); \n    }\n```", "```cpp\n    // direct call \n    auto a1 = add(1, 2);    // a1 = 3 \n\n    // call through function pointer \n    int(*fadd)(int const, int const) = &add; \n    auto a2 = fadd(1, 2);   // a2 = 3 \n\n    auto fadd2 = &add; \n    auto a3 = fadd2(1, 2);  // a3 = 3\n```", "```cpp\n    foo f; \n    f.increment_by(3); \n    auto x1 = f.x;    // x1 = 3 \n\n    void(foo::*finc)(int const) = &foo::increment_by; \n    (f.*finc)(3); \n    auto x2 = f.x;    // x2 = 6 \n\n    auto finc2 = &foo::increment_by; \n    (f.*finc2)(3); \n    auto x3 = f.x;    // x3 = 9\n```"]