- en: Chapter 5. Effective Data Structures beyond STL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。超越STL的有效数据结构
- en: The C++ Standard Library provides a rich set of **generic containers** that
    can be employed for a wide variety of common programming tasks. These include
    sequence containers like `std::vector`, `std::deque`, `std::list`, `std::forward_list`,
    and ordered and unordered associative containers like `std::map`, `std::set`,
    `std::unordered_map`, `std::unordered_set`, and so on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库提供了一套丰富的**通用容器**，可用于各种常见的编程任务。这些包括序列容器，如`std::vector`、`std::deque`、`std::list`、`std::forward_list`，以及有序和无序的关联容器，如`std::map`、`std::set`、`std::unordered_map`、`std::unordered_set`等等。
- en: Containers are traversed, and their individual elements accessed, using **iterators**.
    C++ defines a hierarchy of iterator categories based on the kind of access they
    provide to the elements of the container (read, write, forward traversal, bidirectional
    traversal, and random access). The type of iterator available for traversing a
    container is dependent on the internal structure of a container.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 容器被遍历，并且它们的单个元素使用**迭代器**进行访问。C++根据它们对容器元素提供的访问类型（读取、写入、前向遍历、双向遍历和随机访问）定义了迭代器类别的层次结构。用于遍历容器的迭代器类型取决于容器的内部结构。
- en: Available alongside the containers is a library of **generic algorithms** that
    read and manipulate generic containers, using one or more iterators. These libraries
    heavily rely on **generic programming**, in which program interfaces are abstracted
    from and are parameterized in terms of data types.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 除了容器之外，还有一个**通用算法**库，用于读取和操作通用容器，使用一个或多个迭代器。这些库大量依赖**通用编程**，其中程序接口被抽象化，并且以数据类型的形式进行参数化。
- en: This collection of generic containers, algorithms, and a bunch of accompanying
    utilities originated in the **Standard Template Library** or **STL**, developed
    at HP Labs by Alexander Stepanov and Meng Lee, and were accepted as part of the
    C++ Standard Library in 1994\. The name STL has stuck on for those parts of the
    Standard Library that originated in this work, and we will loosely use it to mean
    such parts of the library. STL containers and algorithms have been heavily used
    in C++ software ever since, but have had several limitations. Before C++11, you
    could only store copyable objects in containers. Certain classes of containers
    like hash-based associative containers, were absent in the Standard Library while
    others, like priority queues, were under-represented.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这个通用容器、算法集合以及一堆相关的实用工具最初起源于**标准模板库**或**STL**，由亚历山大·斯蒂潘诺夫和孟李在惠普实验室开发，并于1994年被接受为C++标准库的一部分。STL这个名字一直沿用至今，用来指代源自这项工作的标准库的部分内容，我们会宽泛地使用它来指代这样的库的部分内容。STL容器和算法自那时以来一直在C++软件中被广泛使用，但存在一些限制。在C++11之前，你只能在容器中存储可复制的对象。标准库中缺少了一些容器类，比如基于哈希的关联容器，而其他一些容器，比如优先队列，受到了限制。
- en: As of C++14, there are no containers yet in the Standard Library suitable for
    storing pointers to dynamically-allocated objects, though with the availability
    of `std::unique_ptr`, this is easier to deal with since C++11\. You cannot efficiently
    search the contents of an associative container, like `std::map` by value rather
    than key, nor can you easily write iterators for your custom container classes
    that work well with STL algorithms. There is no easy library to read property
    sets or key-value pairs from various standard formats (XML, JSON, etc.) into in-memory
    data structures. There are many more such routine uses that require significant
    effort if you are limited to the Standard Library.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 截至C++14，标准库中还没有适合存储动态分配对象指针的容器，尽管有了`std::unique_ptr`的可用性，自C++11以来处理起来更容易。您无法有效地搜索关联容器的内容，比如通过值而不是键来搜索`std::map`，也无法轻松地为自定义容器类编写与STL算法良好配合的迭代器。没有一个简单的库可以从各种标准格式（XML、JSON等）中读取属性集或键值对到内存数据结构中。还有许多其他常见的用途，如果只使用标准库，就需要付出很大的努力。
- en: 'In this chapter and the next, we will look at the leading Boost libraries that
    fill many of these gaps. The chapter is divided into the following sections:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和下一章中，我们将看一下填补这些空白的主要Boost库。本章分为以下几个部分：
- en: The Boost Container library
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost容器库
- en: Fast lookups using Boost Unordered containers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Boost无序容器进行快速查找
- en: Containers for dynamically-allocated objects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于动态分配对象的容器
- en: Expressive initialization and assignment using Boost.Assign
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Boost.Assign进行表达式初始化和赋值
- en: Iteration patterns with Boost.Iterator
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Boost.Iterator进行迭代模式
- en: This chapter should provide you a solid foundation for using the wide variety
    of data structure libraries in Boost.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章应该为您提供了一个扎实的基础，以便使用Boost中各种各样的数据结构库。
- en: Boost Container library
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Boost容器库
- en: The Boost Container library implements majority of the STL container templates
    in addition to providing a few nifty nonstandard containers. So, what is the point
    of reimplementing STL containers? To understand this, let us look at what kind
    of objects can be stored in STL containers and what kind cannot be.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Boost容器库实现了大部分STL容器模板，还提供了一些非标准容器。那么，重新实现STL容器有什么意义呢？为了理解这一点，让我们看看STL容器可以存储哪些对象，以及哪些对象不能存储。
- en: 'To store objects of type `T` in a `std::vector`, for example, the type `T`
    must be a complete type (that is, must be completely defined, not just declared)
    at the point where the object of type `std::vector<T>` is defined. Moreover, in
    pre-C++11, objects of type `T` must be copyable and assignable. These requirements
    generally hold for other STL containers besides `std::vector`. In general, till
    before C++11, STL was a copy-intensive framework: you copied objects into STL
    containers to store them, the containers copied them around while being resized
    or restructured, and the containers destroyed those copies when they went out
    of scope. Copying being an expensive operation in terms of time and memory is
    also more error prone and thus the exception safety of several operations on STL
    containers was weak.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`std::vector`中存储类型为`T`的对象，例如，类型`T`必须在定义类型为`std::vector<T>`的对象的地方是一个完整类型（即必须完全定义，而不仅仅是声明）。此外，在C++11之前，类型为`T`的对象必须是可复制和可赋值的。这些要求通常适用于除了`std::vector`之外的其他STL容器。一般来说，在C++11之前，STL是一个复制密集型的框架：你将对象复制到STL容器中存储，容器在调整大小或重组时复制它们，容器在作用域结束时销毁这些副本。复制是一种在时间和内存方面昂贵的操作，也更容易出错，因此STL容器上的几个操作的异常安全性较弱。
- en: C++11 introduced move semantics that made it possible to **move-construct**
    new objects by moving or usurping the state of an existing object, typically by
    only exchanging integers and pointers and completely avoiding any non-trivial
    and error-prone copy operations. Likewise, the state or contents of an object
    could be moved into another existing object in an operation called **move-assignment**.
    Move semantics are applied by default when constructing or assigning from a temporary
    object while it can be explicitly enforced when copying from an l-value object
    (see [Appendix](apa.html "Appendix A. C++11 Language Features Emulation"), *C++11
    Language Features Emulation*). These capabilities allow operations on Standard
    Library containers in C++11 to be significantly optimized and independent of **copy
    semantics**. The objects stored in C++11 STL containers need not be **copyable**
    if they are **move constructible**. C++11 also allows objects to be constructed
    in-place in the container's layout instead of requiring them to be constructed
    first and then copied.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: C++11引入了移动语义，使得可以通过移动或篡夺现有对象的状态来**移动构造**新对象，通常只交换整数和指针，完全避免任何非平凡和容易出错的复制操作。同样，对象的状态或内容可以在称为**移动赋值**的操作中移动到另一个现有对象中。在从临时对象构造或赋值时，默认应用移动语义，而在从左值对象复制时可以显式强制执行移动语义（参见[附录](apa.html
    "附录 A. C++11语言特性模拟")，*C++11语言特性模拟*）。这些能力使得C++11中标准库容器的操作可以得到显著优化，并且独立于**复制语义**。存储在C++11
    STL容器中的对象如果是**可移动构造**的，则无需是**可复制**的。C++11还允许在容器的布局中就地构造对象，而不需要先构造然后复制。
- en: The Boost Container library provides move-aware implementations of Standard
    Library containers that work not only with C++11 compilers, but also with Boost
    move emulation for C++03 compilers (see [Appendix](apa.html "Appendix A. C++11
    Language Features Emulation"), *C++11 Language Features Emulation emulation*).
    In addition, they also support in-place construction of objects. This is a significant
    functionality if you are on a C++03 compiler. In addition, the containers in Boost
    Container library can hold objects of incomplete types, making it possible to
    define interesting recursive structures that are simply not possible with the
    standard containers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Container库提供了对移动感知的标准库容器的实现，不仅适用于C++11编译器，还适用于C++03编译器的Boost移动模拟（参见[附录](apa.html
    "附录 A. C++11语言特性模拟")，*C++11语言特性模拟*）。此外，它们还支持对象的就地构造。如果你在C++03编译器上，这是一个重要的功能。此外，Boost
    Container库中的容器可以容纳不完整类型的对象，这使得可以定义有趣的递归结构，这是使用标准容器简单不可能的。
- en: In addition to the standard containers, the Boost Container library also implements
    several useful nonstandard containers that are useful for various specific uses.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准容器之外，Boost Container库还实现了几个有用的非标准容器，适用于各种特定用途。
- en: Move-awareness and in-place construction
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动感知和原地构造
- en: 'Consider the following class for encapsulating `char` strings, which is movable
    but not copyable. We use the Boost move emulation macros to define its move semantics.
    In a C++11 environment, this code translates to C++11 move syntax, while on C++03,
    it emulates the move semantics:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下用于封装`char`字符串的类，它是可移动但不可复制的。我们使用Boost移动模拟宏来定义其移动语义。在C++11环境中，这段代码转换为C++11移动语法，而在C++03中，它模拟了移动语义：
- en: '**Listing 5.1: Movable but not copyable String**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单5.1：可移动但不可复制的字符串**'
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'On a pre-C++11 compiler, trying to store instances of `String` in a standard
    container will result in compiler errors because `String` is not copyable. Here
    is some code that moves String instances into a `boost::container::vector`, which
    is the Boost counterpart of `std::vector`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11之前的编译器上，尝试将`String`的实例存储在标准容器中将导致编译错误，因为`String`是不可复制的。以下是一些将String实例移入`boost::container::vector`的代码，它是`std::vector`的Boost对应物：
- en: '**Listing 5.2: Pushing String objects onto Boost vectors**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单5.2：将String对象推送到Boost向量**'
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, we create a Boost `vector` (line 6) and append a temporary
    String `"Hello"` to it (line 9). This automatically invokes move semantics, as
    the expression `String("Hello")` is an **rvalue**. We construct a `String` variable
    called `world` (line 7), but if we tried to append it to `strVec`, it would fail
    because it would try to copy `world`, but it is not copyable (line 11).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们创建了一个Boost `vector`（第6行），并将临时String `"Hello"`附加到它（第9行）。这自动调用了移动语义，因为表达式`String("Hello")`是一个**rvalue**。我们构造了一个名为`world`的`String`变量（第7行），但如果我们尝试将它附加到`strVec`，将会失败，因为它会尝试复制`world`，但它是不可复制的（第11行）。
- en: In order to put `world` into `strVec`, we need to explicitly move it, using
    `boost::move` (line 13). Once `world` is moved into `strVec`, its contents are
    moved out into a `String` object stored in `strVec`, and hence, its contents become
    null (line 15).Finally, we construct a `String` object in-place by calling the
    `emplace_back` member of the vector and passing it the constructor arguments of
    String (line 17). The code in listings 5.1 and 5.2 will compile and work correctly
    on pre-C++11 compilers as well as C++11\. Moreover, on C++11, the Boost macros
    for move emulation simply translate to the C++ rvalue reference syntax. Note that
    we use the `BOOST_FOREACH` macro instead of a C++11 range-based for-loop to iterate
    through the vector (see [Appendix](apa.html "Appendix A. C++11 Language Features
    Emulation"), *C++11 Language Features Emulation*).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将`world`放入`strVec`，我们需要明确地移动它，使用`boost::move`（第13行）。一旦`world`移动到`strVec`中，它的内容就会移动到存储在`strVec`中的`String`对象中，因此其内容变为空（第15行）。最后，通过调用向量的`emplace_back`成员并传递String的构造函数参数来就地构造一个`String`对象（第17行）。清单5.1和5.2中的代码将在C++11编译器以及C++11上正确编译和工作。此外，在C++11上，Boost移动模拟的宏简单地转换为C++右值引用语法。请注意，我们使用`BOOST_FOREACH`宏而不是C++11基于范围的for循环来遍历向量（参见[附录](apa.html
    "附录 A. C++11语言特性模拟")，*C++11语言特性模拟*）。
- en: 'The code prints the following lines:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 代码打印以下行：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that in the range-based for-loop, the loop variable `str` is introduced
    using `auto&`. If we did not use the trailing ampersand after `auto`, the compiler
    would try to generate code to copy each element of `strVec` into `str`, which
    would fail because `String` is not copyable. Using the trailing ampersand ensures
    that `str` is a reference to successive elements.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在基于范围的for循环中，循环变量`str`是使用`auto&`引入的。如果我们没有在`auto`后使用尾随的`&`，编译器将尝试生成代码将`strVec`的每个元素复制到`str`中，这将失败，因为`String`是不可复制的。使用尾随的`&`确保`str`是对连续元素的引用。
- en: In addition to `vector`, the Boost Container library implements other standard
    containers, like `deque`, `list`, `set`, `multiset`, `map` and `multimap`, and
    also `basic_string`. These are move-aware containers that are very similar to
    their C++11 counterparts and can be used in pre-C++11 environments using move
    emulation (via Boost.Move).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`vector`，Boost容器库还实现了其他标准容器，如`deque`，`list`，`set`，`multiset`，`map`和`multimap`，以及`basic_string`。这些是移动感知容器，非常类似于它们的C++11对应物，并且可以在使用移动模拟（通过Boost.Move）的C++11之前的环境中使用。
- en: Nonstandard containers
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非标准容器
- en: In addition to the standard containers, the Boost Container library provides
    several useful nonstandard containers. This section is a quick overview of these
    containers and their applicability.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准容器外，Boost容器库还提供了几个有用的非标准容器。本节是对这些容器及其适用性的快速概述。
- en: Flat associative containers
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 平面关联容器
- en: 'There are two flavors of the standard associative containers: **ordered** and
    **unordered**. Ordered containers like `std:set`, `std::multiset`, `std::map`,
    and `std::multimap` are typically implemented using a balanced search tree (an
    optimized Red-Black Tree implementation is **de facto**). Thus, they store their
    elements in sorted order. The unordered containers `std::unordered_set`, `std::unordered_multiset`,
    `std::unordered_map`, and `std::unordered_multimap`, are based on hash tables.
    They originated in the Boost Container library before becoming part of the C++TR1
    release and C++11 Standard Library. These containers store objects in an array
    of buckets called a **hash table**, based on hash value computed for the object.
    There is no inherent ordering in how the objects are stored in the hash tables,
    hence the name unordered containers.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 标准关联容器有两种类型：**有序**和**无序**。有序容器如`std:set`，`std::multiset`，`std::map`和`std::multimap`通常使用平衡搜索树实现（优化的红黑树实现是**事实上的**）。因此，它们按排序顺序存储它们的元素。无序容器`std::unordered_set`，`std::unordered_multiset`，`std::unordered_map`和`std::unordered_multimap`基于哈希表。它们起源于Boost容器库，然后成为C++TR1发布和C++11标准库的一部分。这些容器将对象存储在称为**哈希表**的桶数组中，基于为对象计算的哈希值。在哈希表中存储对象的顺序没有固有的顺序，因此称为无序容器。
- en: 'Associative containers support fast lookup. Ordered containers use balanced
    search trees which support logarithmic time searches, and unordered containers
    use hash tables which support amortized constant-time searches. These are not
    the only data structures that support fast lookups. Binary search on a sorted
    sequence that allows random positional access to its elements also performs in
    logarithmic time. The four flat associative containers: `flat_set`, `flat_multiset`,
    `flat_map`, and `flat_multimap` use a sorted vector to store data and use binary
    search on the vector to perform lookups. They are drop-in replacements for their
    ordered and unordered counterparts from the Standard Library but have different
    performance characteristics for insertions and lookups:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 关联容器支持快速查找。有序容器使用平衡搜索树，支持对数时间搜索，无序容器使用哈希表，支持摊销常数时间搜索。这些不是唯一支持快速查找的数据结构。对排序序列进行二分搜索，允许对其元素进行随机位置访问，也可以在对数时间内执行。四个平面关联容器：`flat_set`，`flat_multiset`，`flat_map`和`flat_multimap`使用排序向量存储数据，并在向量上使用二分搜索执行查找。它们是标准库中有序和无序对应物的替代品，但对于插入和查找具有不同的性能特征：
- en: '**Listing 5.3: Using flat maps**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单5.3：使用平面映射**'
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This first example lists a set of countries, whose capitals were moved in the
    last few decades. If you thought Lagos is still Nigeria's capital, you're in for
    a surprise. Geography apart, there isn't a whole lot surprising going on in the
    preceding code. We create a `typedef` for `boost::container::flat_map<std::string,
    std::string>`, and instantiate a map `newCapitals` of this type, inserting string
    pairs of countries and their new capitals. If we replace `boost::container::flat_map`
    with `std::map`, the code will work without any changes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个例子列出了一些国家，它们的首都在过去几十年里发生了变化。如果你认为拉各斯仍然是尼日利亚的首都，那你会感到惊讶。地理因素除外，在前面的代码中并没有太多令人惊讶的事情。我们为`boost::container::flat_map<std::string,
    std::string>`创建了一个`typedef`，并实例化了一个这种类型的地图`newCapitals`，插入了国家和它们的新首都的字符串对。如果我们用`std::map`替换`boost::container::flat_map`，那么代码将可以在不进行任何更改的情况下工作。
- en: The flat associative containers can store objects that are either copyable or
    movable. Objects are stored in a contiguous layout without using pointers for
    indirection. Thus, in order to store a given number of objects of a certain type,
    the flat containers will less memory than the tree-based and hash-based containers
    too. Insertions maintain sorted order and are thus costlier than in the other
    associative containers; in particular, for value types that are copyable but not
    movable. Also, unlike with the standard associative containers, all the iterators
    are invalidated by insertion of any new element or deletion of existing elements.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '扁平关联容器可以存储可复制或可移动的对象。对象以连续布局存储，而不使用指针进行间接引用。因此，为了存储某种类型的给定数量的对象，扁平容器将比基于树和哈希的容器占用更少的内存。插入会保持排序顺序，因此比其他关联容器更昂贵；特别是对于可复制但不可移动的值类型。此外，与标准关联容器不同，插入任何新元素或删除现有元素都会使所有迭代器失效。 '
- en: 'Iterations and lookups tend to be faster, and cache performance better than
    that of the standard containers due to the contiguous layout and faster performance
    of binary search. Insertions into flat containers can cause reallocations and
    elements to get moved or copied if the initial capacity of flat containers is
    exceeded. This can be prevented by reserving sufficient space using the `reserve`
    member function before performing insertions. The following example illustrates
    this aspect:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代和查找往往比标准容器更快，缓存性能也更好，这是由于连续布局和二分查找的更快性能。插入到扁平容器中可能会导致重新分配，并且如果扁平容器的初始容量超过，则元素会被移动或复制。这可以通过在执行插入之前使用`reserve`成员函数来预留足够的空间来防止。下面的例子说明了这一方面：
- en: '**Listing 5.4: Using flat sets**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单5.4：使用扁平集**'
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This example shows one way to figure out how the internal layout of the flat
    associative containers changes with successive insertions. We define a `flat_set`
    container called `someStrings` (line 18) and insert names of eight string instruments.
    The `printContainer` template is called on the container after each insertion
    to print out the successive address in the internal vector, where each string
    is present. We reserve capacity for eight elements before the insertion (line
    19), and insert eight elements thereafter. As there is sufficient capacity at
    the outset, none of the insertions should trigger reallocations and you should
    see a fairly stable set of addresses with only the order of strings changing to
    maintain sorted order. If we commented out the call to reserve (line 19) and ran
    the code, we might see reallocations and changing addresses.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了一种方法，来找出扁平关联容器的内部布局在连续插入后如何改变。我们定义了一个名为`someStrings`的`flat_set`容器（第18行），并插入了八个字符串乐器的名称。在每次插入后，模板`printContainer`被调用以打印出内部向量中的连续地址，每个字符串都在其中。我们在插入之前（第19行）为八个元素保留了容量，并在此后插入了八个元素。由于一开始就有足够的容量，没有一个插入应该触发重新分配，你应该看到一组相当稳定的地址，只有字符串的顺序改变以保持排序顺序。如果我们注释掉保留的调用（第19行）并运行代码，我们可能会看到重新分配和地址的变化。
- en: slist
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: slist
- en: The `boost::container::slist` container is a singly-linked list abstraction
    similar to a container template of the same name that was available in the SGI
    STL implementation but never made it to the standard. The `std::list` container
    is a doubly linked list. C++ finally got its own singly linked list with `std::forward_list`
    introduced in C++11\. The `slist` is move-aware.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::container::slist`容器是一个类似于SGI STL实现中可用但从未成为标准的同名容器模板的单链表抽象。`std::list`容器是一个双链表。C++最终在C++11中引入了`std::forward_list`，得到了自己的单链表。`slist`是可移动的。'
- en: 'Singly-linked lists have a lesser memory overhead than doubly linked lists,
    although the time complexity of certain operations goes from constant to linear.
    If you need a sequence container that should support relatively frequent insertions
    and you do not need backward traversals, singly linked lists are a good choice:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 单链表的内存开销比双链表小，尽管某些操作的时间复杂度从常数变为线性。如果你需要一个支持相对频繁插入且不需要向后遍历的序列容器，单链表是一个不错的选择：
- en: '**Listing 5.5: Using slist**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单5.5：使用slist**'
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this simple example, we use an `slist` to store successive geologic eras.
    Unlike the standard sequence container `std::list`, `slist` does not have a `push_back`
    method to append an element to the end of the list. This is because computing
    the end of the list for each append would make it a linear operation instead of
    a constant one. Instead, we use the `push_front` member to add each new element
    at the head of the list. The final order of the strings in the list is the reverse
    of the order of insertion (and in the chronological order of the periods, oldest
    first).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，我们使用`slist`来存储连续的地质时代。与标准序列容器`std::list`不同，`slist`没有`push_back`方法来将元素追加到列表的末尾。这是因为为每个追加计算列表的末尾会使其成为一个线性操作，而不是一个常数操作。相反，我们使用`push_front`成员将每个新元素添加到列表的头部。列表中字符串的最终顺序是插入顺序的相反顺序（以及按照时期的年代顺序，最早的在前）。
- en: Certain operations on singly-linked lists have higher time-complexity than their
    equivalents on doubly linked lists. The `insert` method which inserts an element
    before another is constant time in `std::list` but is linear time in `slist`.
    This is because the element preceding the position of insertion can be located
    using the link to the previous element in a doubly linked list like `std::list`
    but would require traversal from the beginning of the list in `slist`. For the
    same reason, the `erase` member function for erasing an element at a given position
    and the `emplace` member function for the in-place construction of an element
    *before* another also have linear complexity compared to their `std::list` counterparts.
    For this reason, `slist` provides member functions `insert_after`, `erase_after`,
    and `emplace_after` that provide similar functionality with slightly altered semantics
    of inserting, erasing, and emplacing objects in constant time after a given position.
    In order to allow these functions to add an element to the beginning of an `slist`,
    you can use the `before_begin` member function to get an iterator to a `head`
    pointer—a non-dereferenceable iterator which when incremented, points to the first
    element in the `slist`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 单链表上的某些操作的时间复杂度比双链表上的等效操作要高。`insert`方法在`std::list`中是常数时间，但在`slist`中是线性时间。这是因为在双链表中，如`std::list`，可以使用前一个元素的链接来定位插入位置之前的元素，但在`slist`中需要从列表开头进行遍历。出于同样的原因，用于擦除给定位置的元素的`erase`成员函数和用于就地构造元素*在*另一个元素之前的`emplace`成员函数与它们的`std::list`对应物相比也具有线性复杂度。因此，`slist`提供了成员函数`insert_after`、`erase_after`和`emplace_after`，它们提供了类似的功能，稍微改变了在给定位置之后插入、擦除和就地构造对象的语义，以在常数时间内添加元素到`slist`的开头，您可以使用`before_begin`成员函数获取指向`head`指针的迭代器，这是一个不可解引用的迭代器，当递增时，指向`slist`中的第一个元素。
- en: 'We can now rewrite listing 5.5 to insert the geologic periods into the `slist`
    in chronological order:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以重写清单5.5，按年代顺序将地质时期插入`slist`中：
- en: '**Listing 5.6: Adding elements to the end of slist**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单5.6：将元素添加到slist的末尾**'
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Splicing
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 拼接
- en: 'Besides `insert` and `emplace`, you can also add elements at any given position
    in an `slist` using an operation called `splice`. Splicing is a useful operation
    on linked lists in which one or more successive elements from one given list are
    moved to a particular position in another linked list or to a different position
    in the same list. The `std::list` container provides a `splice` member function
    that allows you to do this in constant time. In an `slist`, the time complexity
    of the `splice` member function is linear in the number of elements spliced, due
    to the need for linear traversal to locate the element before the position of
    insertion. The `splice_after` member function, like `insert_after` and `emplace_after`,
    moves elements into a list after a specified position:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`insert`和`emplace`之外，您还可以使用称为`splice`的操作在`slist`中的任何给定位置添加元素。拼接是链表上的一个有用操作，其中来自给定列表的一个或多个连续元素被移动到另一个链表的特定位置或同一列表中的不同位置。`std::list`容器提供了一个`splice`成员函数，允许您在常数时间内执行此操作。在`slist`中，`splice`成员函数的时间复杂度与被拼接的元素数量成线性关系，因为需要线性遍历来定位插入位置之前的元素。`splice_after`成员函数，像`insert_after`和`emplace_after`一样，在指定位置之后将元素移动到列表中：
- en: '**Listing 5.7: Splicing slists**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单5.7：拼接slists**'
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this code example, we have an array of eight dinosaur names, starting with
    the first eight letters of the English alphabet (lines 13-16). It is a sorted
    list, which is rotated by four positions, so it starts with `Elasmosaurus` and
    has `Appatosaurus` somewhere in the middle. We make an `slist` out of these, using
    `insert_after` (line 20), and then locate the pivot at which the lexically smallest
    string lies (lines 29-30). At the end of the loop, `iter` points to the lexically
    smallest string in the `dinos` list and `last` points to the element immediately
    before `iter`. Here is the prototype of the `splice_after` overload we want to
    use to move the tail of the list to the beginning:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，我们有一个包含八个恐龙名称的数组，以英文字母表的前八个字母开头（第13-16行）。它是一个排序列表，被旋转了四个位置，所以以`Elasmosaurus`开头，并且在中间某处有`Appatosaurus`。我们使用`insert_after`（第20行）将其转换为`slist`，然后定位词典顺序最小的字符串所在的枢轴（第29-30行）。在循环结束时，`iter`指向`dinos`列表中词典顺序最小的字符串，`last`指向`iter`的前一个元素。这是我们想要使用的`splice_after`重载的原型，用于将列表的尾部移动到开头：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The sequence of elements that are to be moved from the source container to the
    target starts at the element following `start_after` and ends at `end`, both ends
    inclusive, that is, the half-open interval (`start_after`, `end`). These elements
    are inserted into the target `slist` after the position is identified by `add_after`.
    We can use the iterator `last` for the third argument. For the fourth argument,
    we compute the position of the last element in the list (lines 36-40). The iterator
    `itend` now points to the last element in the list. Using the chosen `splice_after`
    overload, we move all elements, following `last` and till the end of the list,
    to the beginning of the list (lines 43-44).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要从源容器移动到目标的元素序列从`start_after`后面的元素开始，到`end`结束，两端都包括在内，即半开区间（`start_after`，`end`）。这些元素被插入到目标`slist`中，位置由`add_after`确定。我们可以使用第三个参数的迭代器`last`。对于第四个参数，我们计算列表中最后一个元素的位置（第36-40行）。迭代器`itend`现在指向列表中的最后一个元素。使用所选的`splice_after`重载，我们将所有元素从`last`开始，直到列表的末尾，移动到列表的开头（第43-44行）。
- en: The `std::forward_list` container does not provide a `size` member function
    to return the number of elements in a list. This helps ensure that its `splice_after`
    implementation is constant time. Otherwise, during each `splice_after` operation,
    the number of elements transferred to the list would need to be counted, and the
    total count of elements need to be incremented by that much. Solely to support
    this, `splice_after` would have to be linear in the number of elements transferred
    instead of constant time. The `slist` container provides a `size` member and several
    overloads of `splice_after`. The overload of `splice_after` that we used is linear
    in the number of elements transferred, as it computes this number using a linear
    traversal. However, if we computed this number in our code without extra loops
    and passed it to the `splice_after` function, then it could avoid iterating again
    and use the passed number. There are two overloads of `splice_after` that take
    the count of the elements from the user and avoid the linear computation, thus
    providing constant-time splice.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::forward_list`容器没有提供`size`成员函数来返回列表中元素的数量。这有助于确保其`splice_after`实现是常数时间。否则，在每次`splice_after`操作期间，需要计算转移到列表中的元素数量，并且需要将元素的总数增加相应的数量。仅仅为了支持这一点，`splice_after`将不得不是线性的，而不是常数时间。`slist`容器提供了一个`size`成员和几个`splice_after`的重载。我们使用的`splice_after`的重载是线性的，因为它使用线性遍历来计算这个数字。然而，如果我们在我们的代码中计算这个数字而不需要额外的循环，并将其传递给`splice_after`函数，那么它可以避免再次迭代并使用传递的数字。有两个`splice_after`的重载，它们接受用户提供的元素数量，并避免线性计算，从而提供常数时间的splice。'
- en: 'Here is a slightly altered snippet to do this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个略微修改的片段来实现这一点：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We compute `count` while determining the iterator range to move, and pass that
    to `splice_after`. We must make sure that our computation of `count` is correct,
    or the behavior will be undefined. This overload is useful because we had a way
    to determine the count without increasing the complexity of our calling code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在确定要移动的迭代器范围时计算`count`，并将其传递给`splice_after`。我们必须确保我们对`count`的计算是正确的，否则行为将是未定义的。这个重载很有用，因为我们有一种方法来确定计数，而不增加我们调用代码的复杂性。
- en: 'For `std::forward_list`, the `splice_after` signature differs slightly in semantics
    from that of `boost::container::slist`. Here is the prototype of one overload
    of the `splice_after` member of `std::forward_list`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`std::forward_list`，`splice_after`的签名在语义上与`boost::container::slist`略有不同。以下是`std::forward_list`的`splice_after`成员的一个重载的原型：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The iterators `before_first` and `after_last` identify an open interval, and
    the actual elements transferred would be the sequence starting at the element
    following `before_first` and ending at the element before `after_last`, that is,
    the open interval (`before_first`, `after_last`). Using this function, we would
    not need to write the loop to determine the last element in this case because
    we could simply use `dinos.end()` as the marker for one-past-the-end position.
    If `dinos` were an instance of `std::forward_list`, we would have edited listing
    5.7, thus saving six lines of code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器`before_first`和`after_last`标识了一个开放区间，实际转移的元素将是从`before_first`后面的元素开始，到`after_last`前面的元素结束，即开放区间(`before_first`,
    `after_last`)。使用这个函数，我们在这种情况下不需要编写循环来确定最后一个元素，因为我们可以简单地使用`dinos.end()`作为结束位置的标记。如果`dinos`是`std::forward_list`的一个实例，我们将编辑列表5.7，从而节省六行代码：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: All `splice_after` overloads in `std::forward_list` that transfer a range of
    elements are linear in the number of elements transferred. While we saw a constant-time
    overload in `boost::container::slist`, we had to write linear complexity logic
    to pass the correct count of elements to it. So, in many cases, code using `std::forward_list`
    might be more maintainable and no less efficient if you can make do without the
    constant-time `size` member function.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::forward_list`中所有传输元素范围的`splice_after`重载都是线性的。虽然我们在`boost::container::slist`中看到了一个常数时间的重载，但我们必须编写线性复杂度的逻辑来传递正确的元素数量。因此，在许多情况下，如果您可以在不使用常数时间的`size`成员函数的情况下做到，使用`std::forward_list`的代码可能更易于维护，而且效率不会降低。'
- en: stable_vector
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: stable_vector
- en: 'The `std::vector` container stores objects in contiguous memory. The `vector`
    reallocates internal storage and copies or moves objects to new storage as needed,
    so as to accommodate additional new objects. It allows fast random access to the
    stored objects using an index. Inserting elements at arbitrary positions in the
    vector is expensive compared to appending elements at the end, because insertion
    requires elements after the point of insertion to be moved in order to make room
    for the new element. There is one more implication of this behavior. Consider
    the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector`容器在连续的内存中存储对象。`vector`根据需要重新分配内部存储并复制或移动对象到新的存储空间，以便容纳额外的新对象。它允许使用索引快速随机访问存储的对象。在向向量的任意位置插入元素比在末尾追加元素要昂贵，因为插入需要移动插入点后的元素，以便为新元素腾出空间。这种行为还有一个含义。考虑以下代码：'
- en: '**Listing 5.8: Iterator invalidation in std::vector**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表5.8：std::vector中的迭代器失效**'
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding code, we create a `vector` of integers `v` and initialize
    it with four integers (line 5). The brace-enclosed list of comma-separated values
    used to initialize the vector is a very handy C++11 construct called **initializer
    list**. In pre-C++11, you had to manually append values or, as we will see later
    in this chapter, use the `Boost.Assign` library. We then compute the iterator
    to the last element of the object as an offset from the first iterator (line 7).
    We assert that the last element is 5 (line 8). Next, we insert an element before
    the last element (line 9). Past this point, the iterator `last` will be invalidated
    and any access of the iterator `last` will be undefined behavior. In fact, in
    the two random access containers, vectors and deques, iterator invalidations happen
    all too often. Any write operation on the vector can invalidate iterators. For
    example, if you erase an element at a particular iterator position, all existing
    iterators to later positions are invalidated. Even appending an element to the
    end of the vector could trigger a resize of the vector''s internal storage, requiring
    elements to be moved. Such an event will invalidate all existing iterators. The
    Standard Library `vector` is an **unstable container**. The `boost::container::stable_vector`
    is a sequence container that provides random access coupled with stable iterators,
    which are not invalidated unless the element they point to is erased. Have a look
    at the following image from the Boost documentation pages on stable_vector ([http://www.boost.org/doc/libs/1_58_0/doc/html/container/non_standard_containers.html#container.non_standard_containers.stable_vector](http://www.boost.org/doc/libs/1_58_0/doc/html/container/non_standard_containers.html#container.non_standard_containers.stable_vector)):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个整数`vector`，名为`v`，并用四个整数进行初始化（第5行）。用于初始化向量的大括号括起来的逗号分隔值列表是一个非常方便的C++11构造，称为**初始化列表**。在C++11之前，您必须手动附加值，或者如我们将在本章后面看到的那样，使用`Boost.Assign`库。然后我们计算对象的最后一个元素的迭代器，作为从第一个迭代器的偏移量（第7行）。我们断言最后一个元素是5（第8行）。接下来，我们在最后一个元素之前插入一个元素（第9行）。在此之后，迭代器`last`将被使无效，并且任何访问迭代器`last`的操作都将是未定义行为。实际上，在两个随机访问容器，即向量和双端队列中，迭代器的使无效经常发生。向向量执行任何写操作都可能使迭代器无效。例如，如果您在特定迭代器位置擦除一个元素，则所有现有的迭代器到后续位置的迭代器都将被使无效。甚至在向量的末尾添加一个元素也可能触发向量内部存储的调整大小，需要移动元素。这样的事件将使所有现有的迭代器无效。标准库`vector`是一个**不稳定的容器**。`boost::container::stable_vector`是一个序列容器，提供了稳定的迭代器的随机访问，除非它们所指向的元素被擦除。请查看Boost文档页面上关于stable_vector的以下图片（[http://www.boost.org/doc/libs/1_58_0/doc/html/container/non_standard_containers.html#container.non_standard_containers.stable_vector](http://www.boost.org/doc/libs/1_58_0/doc/html/container/non_standard_containers.html#container.non_standard_containers.stable_vector)）：
- en: '![stable_vector](img/1217OT_05_01.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![stable_vector](img/1217OT_05_01.jpg)'
- en: 'As illustrated here, `stable_vector` does not store the objects in a contiguous
    memory layout. Instead, each object is stored in a separate node, and a contiguous
    array stores pointers to these nodes in the order of insertion. Each node contains
    the actual object and also a pointer to its position in the array. The iterators
    point to these nodes rather than to positions in the array. Thus, nodes with existing
    objects do not change after insertion of new objects or deletion of some existing
    objects and their iterators also remain valid. Their back pointers are updated
    however when they change positions due to insertions/removals. The contiguous
    array of node pointers still allows random access to elements. Because of the
    extra pointers and indirections, `stable_vector` tends to be slower than `std::vector`,
    but that is the trade-off for stable iterators. Here is some code to boot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这里所说明的，`stable_vector`不会以连续的内存布局存储对象。相反，每个对象都存储在一个单独的节点中，并且一个连续的数组以插入顺序存储指向这些节点的指针。每个节点包含实际的对象，还包含指向数组中其位置的指针。迭代器指向这些节点，而不是数组中的位置。因此，具有现有对象的节点在插入新对象或删除一些现有对象后不会改变，并且它们的迭代器也保持有效。但是，当它们由于插入/删除而改变位置时，它们的后向指针会被更新。节点指针的连续数组仍然允许对元素进行随机访问。由于额外的指针和间接引用，`stable_vector`倾向于比`std::vector`慢，但这是稳定迭代器的权衡。以下是一些示例代码：
- en: '**Listing 5.9: Stable vector example**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单5.9：稳定向量示例**'
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using `stable_vector` is no different from using `vector`, and it is move-aware
    too. In the preceding example, we want to store the names of different types of
    clouds in a `stable_vector` of `std::string`. There are eight cloud names present
    in an array called `cloud_names` (lines 7-9). We create a `stable_vector` called
    `clouds` to store these names, and reserve a capacity for only four elements (lines
    12-13). What we want to show is that once we add elements beyond the capacity
    of the `stable_vector`, requiring an expansion of the underlying array and movement
    of the existing data, iterators computed before the change in capacity still remain
    valid. It is entirely possible for `reserve` to allocate more capacity than that
    requested, and if this is more than the total number of cloud names we have, our
    example is moot.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`stable_vector`与使用`vector`没有区别，而且它也是移动感知的。在前面的示例中，我们想要将不同类型的云的名称存储在`std::string`的`stable_vector`中。有一个名为`cloud_names`的数组中存在八个云的名称（第7-9行）。我们创建了一个名为`clouds`的`stable_vector`来存储这些名称，并为仅四个元素保留了容量（第12-13行）。我们想要展示的是，一旦我们添加超出`stable_vector`容量的元素，需要扩展基础数组并移动现有数据，那么在更改容量之前计算的迭代器仍然保持有效。`reserve`完全有可能分配比请求的更多的容量，如果这比我们拥有的云名称的总数还要多，那么我们的示例就没有意义。
- en: We first store names of clouds (lines 18-21) without overshooting the capacity,
    and compute the iterator to the first element (line 23). We then append remaining
    cloud names, if any (lines 25-27). If there were any remaining cloud names, then
    they would have caused a resize when the first of them got stored.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先存储云的名称（第18-21行），而不会超出容量，并计算第一个元素的迭代器（第23行）。然后，我们追加剩余的云名称（如果有的话）（第25-27行）。如果有剩余的云名称，那么当它们中的第一个被存储时，会导致调整大小。
- en: We compute the iterator to the sixth element (line 29), erase the fifth element
    (line 32), and insert two more cloud names before the fourth element (lines 34-35).
    After all this, the iterator `first` still points to the first element (line 37).
    At the time we computed the iterator `sixth`, it pointed to the sixth element
    and its value was `"cirrocumulus"`, the sixth string in the `cloud_names` array.
    Now with one deletion and two insertions before it, it should be the seventh element
    (line 38), but its value should remain unchanged (line 39)—as stable as iterators
    get!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算第六个元素的迭代器（第29行），删除第五个元素（第32行），并在第四个元素之前插入两个云名称（第34-35行）。在所有这些之后，迭代器`first`仍然指向第一个元素（第37行）。在我们计算迭代器`sixth`的时候，它指向第六个元素，其值为`"cirrocumulus"`，即`cloud_names`数组中的第六个字符串。现在经过一次删除和两次插入，它应该是第七个元素（第38行），但其值应该保持不变（第39行）——就像迭代器一样稳定！
- en: Tip
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Since Boost 1.54, the `capacity` member function of `stable_vector` returns
    an incorrect value for the capacity after a call to `reserve`. By calling the
    `resize` member function with an argument as large as what was passed to `reserve`
    (line 13) before calling `capacity`, we can circumvent the bug and ensure that
    a subsequent call to `capacity` returns the correct value. Once the bug is fixed
    in a later release, the call to `resize` following the call to `reserve` should
    not be needed.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 自Boost 1.54以来，`stable_vector`的`capacity`成员函数在调用`reserve`后返回了一个不正确的容量值。通过在调用`capacity`之前使用与`reserve`传递的参数一样大的参数调用`resize`成员函数（第13行），我们可以规避这个bug，并确保随后调用`capacity`返回正确的值。一旦bug在以后的版本中修复，调用`reserve`后的`resize`应该是不需要的。
- en: static_vector
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: static_vector
- en: The `boost::container::static­_vector` template is a vector-like container with
    an upper limit on the size defined at compile time. It allocates a fixed size,
    uninitialized storage in its layout, rather than dynamically in a separate buffer.
    It does not try to value-initialize all the elements upon instantiation, unlike
    `vector` or `stable_vector`, both of which try to value-initialize elements when
    an initial size is specified as a constructor argument. The absence of heap allocation
    and value-initialization makes `static_vector` instantiation almost zero overhead.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::container::static_vector`模板是一个类似于向量的容器，其大小上限在编译时定义。它在布局中分配了一个固定大小的未初始化存储空间，而不是在单独的缓冲区中动态分配。与`vector`或`stable_vector`不同，它不会在实例化时尝试对所有元素进行值初始化，后两者在构造函数参数中指定初始大小时会尝试对元素进行值初始化。由于没有堆分配和值初始化，`static_vector`实例化几乎没有开销。'
- en: 'A `static_vector` is used just as a regular vector with one important caveat.
    Trying to insert one element too many into a `static_vector` would result in a
    runtime error, so you should always make sure that there is enough room in the
    `static_vector` before trying to insert an additional element:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`static_vector`就像普通的vector一样，但有一个重要的注意事项。尝试在`static_vector`中插入一个太多的元素会导致运行时错误，因此在尝试插入额外元素之前，您应该始终确保`static_vector`中有足够的空间：'
- en: '**Listing 5.10: Using a static_vector**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单5.10：使用static_vector**'
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We construct a `static_vector` of `ChattyInit` objects, `ChattyInit` being
    a simple class whose constructor prints its own name. The fixed size of the `static_vector`
    is specified as a numeric template argument (line 15). Running the preceding code
    prints the following on my GNU Linux box with a g++ 4.9 compiler:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构造了一个`ChattyInit`对象的`static_vector`，`ChattyInit`是一个简单的类，其构造函数打印自己的名称。`static_vector`的固定大小被指定为一个数字模板参数（第15行）。运行上述代码在我的GNU
    Linux系统上使用g++ 4.9编译器打印如下内容：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can see that no objects are created as part of `static_vector` initialization,
    and individual objects are instantiated as they are appended. We make sure that
    the total number of elements inserted does not exceed the capacity of the container
    (line 18). Because the elements of `static_vector` are not value-initialized by
    default, the `size` member function returns zero when no elements are explicitly
    added. Compare this with `std::vector`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在`static_vector`初始化的过程中没有创建任何对象，只有在追加时才实例化单个对象。我们确保插入的元素总数不超过容器的容量（第18行）。由于`static_vector`的元素默认情况下不进行值初始化，因此当没有显式添加元素时，`size`成员函数返回零。与`std::vector`相比：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If we actually tried appending one element too many (line 22), the program would
    crash. `boost::container::static_vector` is a useful container if you are looking
    for a fast, size-bounded `vector` replacement.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们实际上尝试添加一个太多的元素（第22行），程序将崩溃。`boost::container::static_vector`是一个有用的容器，如果您正在寻找一个快速的、大小受限的`vector`替代品。
- en: Fast lookups using Boost Unordered containers
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Boost无序容器进行快速查找
- en: 'The four standard associative containers in C++03: `std::set`, `std::map`,
    `std::multiset`, and `std::multimap` are ordered containers and store their keys
    in some sorted order using balanced binary search trees. They require an ordering
    relationship to be defined for their keys and provide logarithmic complexity insertions
    and lookups. Given the ordering relationship and two keys, A and B, we can determine
    whether A precedes B or B precedes A in the relationship. If neither precedes
    the other, the keys A and B are said to be equivalent; this does not mean A and
    B are equal. In fact, the ordered containers are agnostic to equality and there
    need not be a notion of equality defined at all. This is the reason, such a relation
    is called a **strict weak ordering**.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: C++03中的四个标准关联容器：`std::set`、`std::map`、`std::multiset`和`std::multimap`都是有序容器，它们使用平衡二叉搜索树以某种排序顺序存储它们的键。它们要求为它们的键定义一个排序关系，并提供对数复杂度的插入和查找。给定排序关系和两个键A和B，我们可以确定A是在B之前还是B在A之前。如果两者都不在对方之前，键A和B被称为等价；这并不意味着A和B相等。事实上，有序容器对相等是不关心的，甚至根本不需要定义相等的概念。这就是为什么这样的关系被称为**严格弱序**。
- en: 'Consider the following example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We define a type `Person` that represents a human individual, using the fields
    `name`, `age`, `profession`, and `nationality` (lines 3-9), and then define an
    ordering relation using the `operator<` that does not take the `profession` field
    into account (lines 11-15). This allows `Person` objects to be ordered, but not
    compared for equality. Two `Person` objects `p1` and `p2` would be deemed equivalent
    if `!(p1 < p2)` and `!(p2 < p1)` both hold. This would be true of any two `Person`
    objects with the same `name`, `age`, and `nationality`, irrespective of their
    `profession`. The ordered container `std::set` does not allow multiple keys that
    are equivalent to each other while `std::multiset` does. Likewise, `std::map`
    does not allow multiple key-value pairs, whose keys are equivalent, while `std::multimap`
    does. Thus, adding a key-value pair to a `std::map` that already contains an equivalent
    key overwrites the older value.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个类型`Person`，代表一个人，使用字段`name`，`age`，`profession`和`nationality`（第3-9行），然后使用`operator<`定义了一个不考虑`profession`字段的排序关系（第11-15行）。这允许对`Person`对象进行排序，但不能进行相等比较。如果`!(p1
    < p2)`和`!(p2 < p1)`都成立，那么两个`Person`对象`p1`和`p2`将被视为等价。这对于任何具有相同`name`，`age`和`nationality`的`Person`对象都是成立的，而不考虑它们的`profession`。有序容器`std::set`不允许具有相等键的多个键，而`std::multiset`允许。同样，`std::map`不允许具有等价键的多个键值对，而`std::multimap`允许。因此，向`std::map`添加一个已经包含等价键的键值对会覆盖旧值。
- en: The ordered containers are implemented using a kind of balanced binary search
    tree known as Red-Black Trees, with several optimizations. They offer one key
    capability besides the ability to lookup and insert keys in logarithmic time—an
    ordered traversal of the keys in the container. However, if you do not need ordered
    traversal, then there are more efficient alternatives available—hash tables being
    the most obvious one. Appropriate implementations of hash tables support constant-time
    lookups on average, and amortized constant-time inserts that outperform the ordered
    containers with better cache performance, while having a somewhat higher space
    overhead.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有序容器使用一种称为红黑树的平衡二叉搜索树进行实现，具有多种优化。除了能够在对数时间内查找和插入键之外，它们还提供了一个关键的功能——对容器中的键进行有序遍历。然而，如果您不需要有序遍历，那么有更高效的替代方案可用——哈希表是最明显的选择。哈希表的适当实现支持平均常数时间查找和摊销常数时间插入，这比有序容器具有更好的缓存性能，并具有略高的空间开销。
- en: 'The Boost Unordered library introduced four hash table-based counterparts of
    the ordered containers: `boost::unordered_set`, `boost::unordered_map`, `boost::unordered_multiset`,
    and `boost::unordered_multimap`, which became part of the C++ TR1 release in 2007
    and were included in the Standard Library in C++11\. Of course, you can use Boost
    Unordered even with a C++03 compiler.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Unordered库引入了四个基于哈希表的有序容器的对应物：`boost::unordered_set`，`boost::unordered_map`，`boost::unordered_multiset`和`boost::unordered_multimap`，它们在2007年成为C++
    TR1版本的一部分，并在C++11标准库中包含。当然，您可以在C++03编译器中使用Boost Unordered。
- en: 'Unordered containers require the notion of equality to be defined for the objects
    they store, but not the notion of ordering. Thus, for unordered containers, equivalence
    is defined in terms of equality rather than ordering. In addition, unordered containers
    need a way to compute a hash value of each key to determine the position in the
    table, where the key is stored. In the following code examples, we will see how
    to use unordered containers and compute hash values for objects, reusing the `Person`
    type we introduced earlier:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 无序容器需要为其存储的对象定义相等的概念，但不需要排序的概念。因此，对于无序容器，等价性是根据相等性而不是排序来定义的。此外，无序容器需要一种方法来计算每个键的哈希值，以确定键存储在表中的位置。在接下来的代码示例中，我们将看到如何使用无序容器和计算对象的哈希值，重用我们之前介绍的`Person`类型。
- en: '**Listing 5.11: Using unordered_sets**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单5.11：使用unordered_sets**'
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding example shows how an `unordered_set` is used to store objects
    of the user-defined type `Person` that we defined in the earlier listing. We define
    an `unordered_set` of `Person` objects (line 31), create two `Person` objects
    `p` and `p1`, and insert them into the `unordered_set` called `Persons` (lines
    34, 37). We define a third `Person` object `p2`, which is a copy of `p`, and try
    to insert this element but fail (line 43). The container being a set (`unordered_set`)
    contains unique elements. Since `p2` is a copy of `p` and is equal to it, its
    insertion fails.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例展示了如何使用`unordered_set`来存储我们在前面清单中定义的用户定义类型`Person`的对象。我们定义了一个`Person`对象的`unordered_set`（第31行），创建了两个`Person`对象`p`和`p1`，并将它们插入名为`Persons`的`unordered_set`（第34、37行）。我们定义了第三个`Person`对象`p2`，它是`p`的副本，并尝试插入此元素，但失败了（第43行）。容器作为一个集合（`unordered_set`）包含唯一元素。由于`p2`是`p`的副本并且等于它，它的插入失败了。
- en: 'There are a couple of ways for the `unordered_set` to compute the hash value
    of each object it stores. We demonstrate one such way: open the `boost` namespace
    (line 14) to define a specialization for the function template `boost::hash` for
    the type `Person` in question (line 21-24). To compute the hash of a `Person`
    object, we consider only two of its fields: `name` and `nationality`. We use the
    utility functions `boost::hash_value` and `boost::hash_combine` (to generate the
    hash values for individual fields and combine them). Since we only consider the
    name and nationality of a person while determining the hash value for that `Person`
    object, the objects `p` and `p1`, both of which represent individuals with the
    same name and nationality, end up having the same hash value. However, they are
    not equal, as their other fields are different, and therefore, both objects are
    successfully added to the set. On the other hand, the object `p2` is a copy of
    `p`, and when we try inserting `p2` into the `persons` set, the insertion fails
    because sets do not contain duplicates and `p2` is a duplicate of `p`. The `boost::unordered_multiset`
    and `boost::unordered_multimap` containers are hash-based containers that can
    store duplicate objects.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`unordered_set`有几种计算其存储的每个对象的哈希值的方法。我们演示其中一种方法：打开`boost`命名空间（第14行），为所讨论的`Person`类型定义`boost::hash`函数模板的特化（第21-24行）。为了计算`Person`对象的哈希值，我们只考虑它的两个字段：`name`和`nationality`。我们使用实用函数`boost::hash_value`和`boost::hash_combine`（生成各个字段的哈希值并将它们组合）。由于我们在确定`Person`对象的哈希值时只考虑一个人的姓名和国籍，因此代表具有相同姓名和国籍的个人的对象`p`和`p1`最终具有相同的哈希值。但是，它们并不相等，因为它们的其他字段不同，因此两个对象都成功添加到集合中。另一方面，对象`p2`是`p`的副本，当我们尝试将`p2`插入`persons`集合时，插入失败，因为集合不包含重复项，而`p2`是`p`的重复项。`boost::unordered_multiset`和`boost::unordered_multimap`容器是可以存储重复对象的基于哈希的容器。'
- en: Computing good hash values is important in ensuring that objects are well distributed
    in the hash table. While the `boost::hash_value` and `boost::hash_combine` utility
    function templates help compute hash values for more complex objects, their indiscriminate
    application can result in inefficient hashing algorithms. For user-defined types,
    it may be better in many cases to roll out a mathematically validated hashing
    algorithm that exploits the semantics of the user-defined type. If you use primitives
    or standard types like `std::string` as keys in your `unordered_set` or `unordered_map`,
    then you need not roll out your own hash function, as `boost::hash` does an adequate
    job.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 计算好的哈希值对于确保对象在哈希表中分布良好非常重要。虽然`boost::hash_value`和`boost::hash_combine`实用函数模板有助于计算更复杂对象的哈希值，但它们的滥用可能导致低效的哈希算法。对于用户定义的类型，在许多情况下，最好使用经过数学验证的哈希算法，以利用用户定义类型的语义。如果您在`unordered_set`或`unordered_map`中使用原语或标准类型如`std::string`作为键，则无需自己编写哈希函数，因为`boost::hash`已经做得很好。
- en: Looking up values is typically done using the `find` and `count` member functions
    of the unordered associative containers. While `find` returns an iterator to the
    actual object stored in the container, corresponding to the key passed, `count`
    returns just the count of occurrences of the key. The `equal_range` member function
    of `unordered_multiset` and `unordered_multimap` return the range of matching
    objects. For `unordered_set` and `unordered_map`, the count member function can
    never return a value greater than 1.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 查找值通常使用无序关联容器的`find`和`count`成员函数进行。`find`返回指向容器中存储的实际对象的迭代器，对应于传递的键，而`count`只返回键的出现次数。`unordered_multiset`和`unordered_multimap`的`equal_range`成员函数返回匹配对象的范围。对于`unordered_set`和`unordered_map`，count成员函数永远不会返回大于1的值。
- en: Containers for dynamically-allocated objects
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态分配对象的容器
- en: Object-oriented programming relies heavily on using polymorphic base class references
    to manipulate objects of an entire class hierarchy. More often than not, these
    objects are dynamically allocated. When dealing with a whole collection of such
    objects, STL containers come a cropper; they store concrete objects of a single
    type and require copy or move semantics. It is impossible to define a single container
    that can store objects of different classes across a hierarchy. While you may
    store polymorphic base class pointers in containers, pointers are treated as POD-types
    and with little support for deep-copy semantics. The life cycle of dynamically-allocated
    objects is none of STL's business. But it is unwieldy to define a container of
    pointers whose lifetimes have to be managed separately without any help from the
    container.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程在很大程度上依赖于使用多态基类引用来操作整个类层次结构的对象。往往，这些对象是动态分配的。当处理这样一整套对象时，STL容器就显得力不从心；它们只能存储单一类型的具体对象，并需要复制或移动语义。不可能定义一个可以存储跨类层次结构的不同类对象的单一容器。虽然可以在容器中存储多态基类指针，但指针被视为POD类型，并且对于深复制语义几乎没有支持。动态分配对象的生命周期与STL无关。但是，定义一个需要单独管理指针生命周期的容器是笨拙的，而且没有任何来自容器的帮助。
- en: The Boost Pointer Container library addresses these gaps by storing pointers
    to dynamically-allocated objects and deallocating them at the end of the container's
    life. The pointer containers provide an interface through which you can operate
    on the underlying objects without the need for pointer indirection. As they store
    pointers to objects, these containers naturally support polymorphic containers
    without any extra machinery.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Boost指针容器库通过存储指向动态分配对象的指针并在容器生命周期结束时释放它们来解决这些问题。指针容器提供了一个接口，通过它可以操作底层对象，而无需进行指针间接。由于它们存储对象的指针，这些容器自然支持多态容器，无需任何额外的机制。
- en: 'The following table shows pointer containers and their Standard Library counterparts:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了指针容器及其标准库对应物：
- en: '| Pointer container from Boost | Standard Library container |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| Boost的指针容器 | 标准库容器 |'
- en: '| --- | --- |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| boost::ptr_array | std::array |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| boost::ptr_array | std::array |'
- en: '| boost::ptr_vector | std::vector |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| boost::ptr_vector | std::vector |'
- en: '| boost::ptr_deque | std::deque |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| boost::ptr_deque | std::deque |'
- en: '| boost::ptr_list | std::list |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| boost::ptr_list | std::list |'
- en: '| boost::ptr_set / boost::ptr_multiset | std::set / std::multiset |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| boost::ptr_set / boost::ptr_multiset | std::set / std::multiset |'
- en: '| boost::ptr_unordered_set / boost::ptr_unordered_multiset | std::unordered_set
    / std::unordered_multiset |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| boost::ptr_unordered_set / boost::ptr_unordered_multiset | std::unordered_set
    / std::unordered_multiset |'
- en: '| boost::ptr_map / boost::ptr_multimap | std::map / std::multimap |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| boost::ptr_map / boost::ptr_multimap | std::map / std::multimap |'
- en: '| boost::ptr_unordered_map / boost::ptr_unordered_multimap | std::unordered_map
    / std::unordered_multimap |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| boost::ptr_unordered_map / boost::ptr_unordered_multimap | std::unordered_map
    / std::unordered_multimap |'
- en: 'Boost defines the pointer container equivalents for all the standard containers.
    These containers can be used to store polymorphic pointers, and the underlying
    objects pointed to by the stored pointers need not be copyable or movable. Here
    is a basic example to get started with:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Boost为所有标准容器定义了指针容器的等价物。这些容器可用于存储多态指针，存储指针指向的底层对象不需要可复制或可移动。以下是一个基本示例以便开始：
- en: '**Listing 5.12: Using Boost pointer containers**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单5.12：使用Boost指针容器**'
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding example, `AbstractJob` is an abstract base class (line 5) which
    defines two private pure virtual functions `doStep1` and `doStep2` (lines 16,
    17), and a non-virtual public function `doJob` which calls these two functions
    (line 10). `JobA` and `JobB` are two concrete implementations of `AbstractJob`,
    which implement the virtual functions `doStep1` and `doStep2`. The `override`
    keyword trailing the function signature (lines 22, 26, 33, and 37) is a C++11
    feature that clarifies that a particular function overrides a virtual function
    in the base class. In the main function, we create a `ptr_vector` of `AbstractJobs`.
    Note that the template argument is not the pointer type (line 44). We then append
    two concrete instances of `JobA` and `JobB` to the vector (lines 46 and 47). We
    access the first and last elements in the vector using the `front` (line 49) and
    `back` (line 50) member functions, both of which return references to the underlying
    objects rather than their pointers. Finally, we read off the stored objects in
    a range-based for-loop (line 52). The loop variable `job` is declared as a reference
    (`auto&`), not a pointer. Member functions of the pointer containers as well as
    iterators return references not to the stored pointers but to the underlying objects
    they point to, providing for syntactic ease.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`AbstractJob`是一个抽象基类（第5行），它定义了两个私有纯虚函数`doStep1`和`doStep2`（第16、17行），以及一个非虚公共函数`doJob`，该函数调用这两个函数（第10行）。`JobA`和`JobB`是`AbstractJob`的两个具体实现，它们实现了虚函数`doStep1`和`doStep2`。函数签名后面的`override`关键字（第22、26、33和37行）是C++11的一个特性，它澄清了特定函数覆盖了基类中的虚函数。在主函数中，我们创建了一个`ptr_vector`的`AbstractJobs`。注意模板参数不是指针类型（第44行）。然后我们将两个`JobA`和`JobB`的具体实例附加到向量中（第46和47行）。我们使用`front`（第49行）和`back`（第50行）成员函数访问向量中的第一个和最后一个元素，它们都返回对底层对象的引用，而不是它们的指针。最后，我们在一个基于范围的for循环中读取存储的对象（第52行）。循环变量`job`声明为引用（`auto&`），而不是指针。指针容器的成员函数和迭代器返回的是对存储指针的引用，而不是它们指向的底层对象，提供了语法上的便利。
- en: 'While range-based for-loops and `BOOST_FOREACH` make it easy to iterate through
    collections, you can also use the iterator interface directly if you need to:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然基于范围的for循环和`BOOST_FOREACH`使得遍历集合变得容易，但如果需要，也可以直接使用迭代器接口：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once again, notice that the iterator returns a reference to the underlying
    object, not to the pointer (line 53), even though the container stores pointers.
    The variable `job` is a reference because `AbstractJob` is abstract and cannot
    be instantiated. But what if the base class was not abstract? Consider the following
    example of a non-abstract polymorphic base class:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，迭代器返回的是对底层对象的引用，而不是指针（第53行），即使容器存储的是指针。变量`job`是一个引用，因为`AbstractJob`是抽象的，不能被实例化。但是如果基类不是抽象的呢？考虑一个非抽象多态基类的以下示例：
- en: '**Listing 5.13: Pitfalls of copyable concrete base classes**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单5.13：可复制的具体基类的陷阱**'
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding code compiles cleanly but may not do what you expect it to do.
    In the body of the for-loop, we assign each object of a derived class to a base
    class instance (line 29). The copy constructor of `ConcreteBase` takes effect,
    and what we get is a sliced object and incorrect behavior.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码编译干净，但可能不会产生您期望的结果。在for循环的主体中，我们将派生类的每个对象分配给一个基类实例（第29行）。`ConcreteBase`的复制构造函数生效，我们得到的是一个切片对象和不正确的行为。
- en: 'Thus, it is a good idea to prevent copying at the outset by deriving the base
    class itself from `boost::noncopyable`, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最好通过将基类本身从`boost::noncopyable`派生出来来防止在一开始就进行复制，如下所示：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This would prevent slicing due to an inadvertent copy by causing such code to
    be flagged as compilation error. Note that this would make all classes in the
    hierarchy noncopyable. We will look at ways of adding copy semantics to such a
    hierarchy in the next section. But before that, a look at using associative pointer
    containers.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这将防止由于无意的复制而导致切片，从而使这样的代码被标记为编译错误。请注意，这将使层次结构中的所有类都不可复制。我们将在下一节中探讨如何向这样的层次结构添加复制语义。但在此之前，让我们看一下使用关联指针容器的方法。
- en: 'We can store dynamically-allocated objects, including polymorphic objects in
    `boost::ptr_set` or `boost::ptr_multiset`. Since these are ordered containers,
    we must define a strict weak ordering relation for the value-type stored in the
    container. This is typically done by defining the `bool operator<` for the type.
    If you store polymorphic pointers to objects of a class hierarchy, you must define
    an ordering relationship for all objects of the hierarchy, not just among objects
    of a particular concrete type:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`boost::ptr_set`或`boost::ptr_multiset`中存储动态分配的对象，包括多态对象。由于这些是有序容器，我们必须为容器中存储的值类型定义一个严格的弱排序关系。通常通过为该类型定义`bool
    operator<`来完成。如果您存储类层次结构的多态指针对象，您必须为层次结构中的所有对象定义一个排序关系，而不仅仅是特定具体类型的对象之间：
- en: '**Listing 5.14: Using associative pointer containers – ptr_set**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 清单5.14：使用关联指针容器 - ptr_set
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This shows the use of `std::ptr_set` to store polymorphic pointers to dynamically-allocated
    objects. The `Animal` abstract base declares a pure virtual function `name`. Two
    two derived classes, `SnowLeopard` and `Puma`, (representing two real mammal species)
    override them. We define a `ptr_set` of `Animal` pointers called `animals` (line
    53). We create two pumas named `Kaju` and `Juki` and a snow leopard named `Rongi`,
    inserting them into the set `animals` (lines 54-56). When we iterate through the
    list, we get references to the dynamically-allocated objects, not pointers (lines
    58, 59). The `operator<` (line 46) compares any two animals and orders them lexically
    by name. Without this operator, we would not be able to define the `ptr_set`.
    Here is the output of the preceding code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '这显示了使用“std :: ptr_set”存储动态分配对象的多态指针。 “Animal”抽象基类声明了一个纯虚函数“name”。两个派生类，“SnowLeopard”和“Puma”，（代表两种真实的哺乳动物物种）对它们进行了覆盖。我们定义了一个名为“animals”的“Animal”指针的“ptr_set”（第53行）。我们创建了两只名为“Kaju”和“Juki”的美洲狮和一只名为“Rongi”的雪豹，并将它们插入到集合“animals”中（第54-56行）。当我们遍历列表时，我们得到的是动态分配对象的引用，而不是指针（第58,
    59行）。 “operator <”（第46行）比较任何两个动物，并按名称按字典顺序排序。如果没有此运算符，我们将无法定义“ptr_set”。以下是前述代码的输出：'
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The three animals are listed in the first three lines, and then the destructor
    of each object is invoked and prints its identity as the `ptr_set` container instance
    goes out of scope.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 前三行列出了三种动物，然后调用每个对象的析构函数并打印其身份，因为“ptr_set”容器实例超出范围。
- en: 'Another common use of associative pointer containers is to store polymorphic
    objects in a map or a multimap:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 关联指针容器的另一个常见用途是在映射或多重映射中存储多态对象：
- en: '**Listing 5.15: Using associative pointer containers**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 清单5.15：使用关联指针容器
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We create a multimap called `animals` (line 6) that keeps the species name
    as a key of type `std::string`, and stores one or more polymorphic pointers to
    animals of that species for each key (lines 10-12). We use the same `Animal` hierarchy
    we used in listing 5.14\. We loop through all the entries in the multimap, printing
    the name of the species followed by the given name of the specific animal. Here
    is the output:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '我们创建了一个名为“animals”的多重映射（第6行），它将物种名称作为键的类型为“std :: string”，并为每个键存储一个或多个该物种的动物的多态指针（第10-12行）。我们使用了与清单5.14中使用的相同的“Animal”层次结构。我们循环遍历多重映射中的所有条目，打印物种的名称，然后是特定动物的给定名称。以下是输出：'
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Each `Animal` entry is of type `std::pair<std::string, Animal*>`, and thus the
    key and value are accessed using the members `first` and `second`. Note that `entry.second`
    returns the stored pointer, not a reference to the underlying object (line 16).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '每个“Animal”条目都是类型为“std :: pair <std :: string，Animal *>”的，因此可以使用成员“first”和“second”访问键和值。请注意，“entry.second”返回存储的指针，而不是底层对象的引用（第16行）。'
- en: Ownership semantics of pointer containers
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指针容器的所有权语义
- en: We have already seen that pointer containers "own" the dynamically-allocated
    objects we store in them, in the sense that the container takes care of deallocating
    them at the end of its own life. The objects themselves need to support neither
    copy nor move semantics, so it is natural to wonder what it would mean to copy
    a pointer container. Actually, the pointer containers are copyable and support
    simple copy semantics—upon copy-construction or copy assignment of a pointer-container,
    it dynamically allocates a copy of each object in the source container and stores
    the pointer to that object. This works fine for any non-polymorphic type that
    is either a POD-type or has a copy constructor. For polymorphic types, this behavior
    leads to slicing or failure to compile when the base classes are abstract or noncopyable.
    In order to create deep copies of containers with polymorphic objects, the objects
    must support the clone interface.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到指针容器“拥有”我们存储在其中的动态分配对象，即容器负责在其生命周期结束时对它们进行解除分配。对象本身既不需要支持复制语义也不需要支持移动语义，因此很自然地想知道复制指针容器意味着什么。实际上，指针容器是可复制的，并支持简单的复制语义
    - 在复制构造或复制分配指针容器时，它会动态分配源容器中每个对象的副本并存储指向该对象的指针。这对于任何既不是POD类型也没有复制构造函数的非多态类型都可以正常工作。对于多态类型，此行为会导致切片或在基类为抽象或不可复制时无法编译。为了创建具有多态对象的容器的深层副本，对象必须支持克隆接口。
- en: 'To support creating copies of objects of a polymorphic type `T`, in a namespace
    `X`, you must define a free function in the namespace `X` with the following signature:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持在命名空间“X”中创建多态类型“T”的对象的副本，必须在命名空间“X”中定义具有以下签名的自由函数：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The function `new_clone` is found via **Argument Dependent Lookup** (**ADL**)
    and is expected to return a copy of the object `obj` passed to it, whose runtime
    type should be the same as that of `obj`. We can extend the animal example; we
    can do this by defining a `clone` virtual function that is overridden in each
    subclass of `Animal` to return a copy of the object. The `new_clone` free function
    then simply has to call the clone function on the passed object and return the
    cloned pointer:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过**参数相关查找**（**ADL**）找到函数“new_clone”，并且预期返回传递给它的对象“obj”的副本，其运行时类型应与“obj”的相同。我们可以扩展动物示例；我们可以通过在每个“Animal”的子类中定义一个被覆盖的“clone”虚函数来实现这一点，以返回对象的副本。然后，“new_clone”自由函数只需调用传递对象上的克隆函数并返回克隆的指针：
- en: '**Listing 5.16: Making objects and pointer containers cloneable**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 清单5.16：使对象和指针容器可克隆
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For full generality, we put the `Animal` and its derived classes into a namespace
    called `nature` (line 6), and add a pure virtual function called `clone` in `Animal`
    (line 13). We override the clone method in each of the two derived classes (line
    33, 42), and implement the `new_clone` free function in terms of the `clone` method.
    We declare two `ptr_vector` containers of `nature::Animal` pointers: `animals`
    and `animals2` (line 51), initialize `animals` with three furry mammals (lines
    53-55), and finally, assign the clone of `animals` to `animals2` (line 57). What
    if instead of the call to `clone`, we write the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全通用，我们将`Animal`及其派生类放入名为`nature`的命名空间（第6行），并在`Animal`中添加一个名为`clone`的纯虚函数（第13行）。我们在两个派生类中重写了`clone`方法（第33、42行），并根据`clone`方法实现了`new_clone`自由函数。我们声明了两个`nature::Animal`指针的`ptr_vector`容器：`animals`和`animals2`（第51行），用三个毛茸茸的哺乳动物初始化了`animals`（第53-55行），最后，将`animals`的克隆分配给`animals2`（第57行）。如果我们不调用`clone`，而是写如下代码会怎样：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this case, the line would fail to compile because `Animal` is abstract and
    noncopyable, and the preceding line would try to slice each stored object in `animals`
    and copy it to `animals2`. If `Animal` was copyable and nonabstract, such a line
    would have compiled, but `animals2` would contain some hapless, sliced `Animals`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，该行将无法编译，因为`Animal`是抽象且不可复制的，前一行将尝试对`animals`中的每个存储对象进行切片并将其复制到`animals2`中。如果`Animal`是可复制且非抽象的，这样的行将编译通过，但`animals2`将包含一些不幸的切片`Animals`。
- en: 'The pointer containers support moving ownership of objects from one container
    to another, even when the containers are of different types. You can move a single
    element, a range of elements, or the entire contents of one container to another,
    in operations reminiscent of `slice` in Standard Library `std::list`. The following
    example illustrates some of these techniques:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 指针容器支持将对象的所有权从一个容器移动到另一个容器，即使这些容器的类型不同。您可以移动单个元素、一系列元素或一个容器的整个内容到另一个容器，这些操作类似于标准库`std::list`中的`slice`。以下示例说明了其中一些技术：
- en: '**Listing 5.17: Moving pointers between containers**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单5.17：在容器之间移动指针**'
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding example illustrates all the different techniques of moving elements
    from one container to another. Two `Puma`s (`Kaju` and `Juki`) and two `SnowLeopard`s
    (`Rongi` and `Turo`) are on mountain A, so the vector `mountA` stores the animals
    on mountain A. The four animals decide to move to mountain B; the vector `mountB`
    is empty to start with. Then, the four `Animals` move to mountain B, so we move
    the contents of `mountA` to `mountB`, using the release method of `mountA` (line
    25). Following this, there are no more `Animals` in `mountA` (line 26) while `mountB`
    contains all four (line 27). Now the animals want to cross over to mountain C,
    and it is a different kind of mountain that is difficult to climb. The animals
    on mountain C are tracked in a `ptr_list` called `mountC` (rather than a `ptr_vector`).
    To start with, `Rongi`, the snow leopard (the second element in `mountB`) shows
    the way and is the first to climb mountain C. So we move the second element of
    `mountB` to the beginning of `mountC`, using the `transfer` member function of
    `mountC` (line 30). Next, Turo, the other snow leopard ventures to cross over
    to C. We move the last element of `mountB` to the end of `mountC` by first popping
    it off the end of `mountB` (line 35), then calling `release` on the `popped` object,
    and appending the returned pointer to `mountC` (line 36). At this point, there
    are two more `Animals` on `mountB` (line 39). The remaining elements (two pumas)
    are moved from `mountB` to the end of `mountC` by a call to the `transfer` member
    function of `mountC` (lines 42, 43), thus completing the exodus of the animals
    (line 45).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例说明了从一个容器移动元素到另一个容器的所有不同技术。两只`Puma`（`Kaju`和`Juki`）和两只`SnowLeopard`（`Rongi`和`Turo`）在A山上，因此向量`mountA`存储了A山上的动物。这四只动物决定搬到B山；向量`mountB`一开始是空的。然后，这四只`Animals`搬到了B山，因此我们使用`mountA`的`release`方法将`mountA`的内容移动到`mountB`（第25行）。在此之后，`mountA`中没有更多的`Animals`（第26行），而`mountB`包含了全部四只（第27行）。现在动物们想要过到C山，这是一种不同类型的山，很难攀登。C山上的动物在名为`mountC`的`ptr_list`中被跟踪（而不是`ptr_vector`）。一开始，雪豹`Rongi`（`mountB`中的第二个元素）带头攀登并成为第一个到达C山的动物。因此，我们使用`mountC`的`transfer`成员函数将`mountB`的第二个元素移动到`mountC`的开头（第30行）。接下来，另一只雪豹`Turo`冒险过到C山。我们首先从`mountB`的末尾弹出`mountB`的最后一个元素（第35行），然后在`popped`对象上调用`release`，并将返回的指针附加到`mountC`（第36行）。此时，`mountB`上还有两只`Animals`（第39行）。剩下的元素（两只美洲狮）通过调用`mountC`的`transfer`成员函数（第42、43行）从`mountB`移动到`mountC`的末尾，从而完成了动物的迁徙（第45行）。
- en: The first argument to `transfer` is the iterator identifying the position in
    the destination container, where the moved elements are inserted. In the three-parameter
    overload (line 30), the second argument identifies the iterator to the element
    in the source container, which needs to be moved, and the third argument is a
    reference to the source container. In the four-parameter overload, the second
    and third arguments identify the range of elements from the source container that
    need to be moved, and the fourth argument is the reference to the source container.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`transfer`的第一个参数是标识目标容器中插入移动元素位置的迭代器。在三参数重载（第30行），第二个参数标识源容器中需要移动的元素的迭代器，第三个参数是源容器的引用。在四参数重载中，第二和第三个参数标识需要移动的源容器元素范围，第四个参数是源容器的引用。'
- en: 'If you are on pre-C++11, you cannot use the `auto` keyword to do away with
    type names you do not care about (line 35). In that case, you will need to store
    the result of `pop_back()` (or other methods that remove and return an element
    from the container) in a variable of type `container::auto_type`. For example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是C++11之前的版本，您无法使用`auto`关键字来摆脱您不关心的类型名称（第35行）。在这种情况下，您需要将`pop_back()`的结果（或其他从容器中移除并返回元素的方法）存储在类型为`container::auto_type`的变量中。例如：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Null pointers in pointer containers
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指针容器中的空指针
- en: 'Given the fact that pointer containers store pointers and give out references
    to the underlying objects, what happens if you store a null pointer? By default,
    pointer containers do not allow null pointers and trying to store a null pointer
    would duly cause an exception to be thrown at runtime. You can override this behavior
    and tell the compiler to allow storing nulls. To do this, you have to modify your
    container definition slightly, to use:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到指针容器存储指针并提供对基础对象的引用，如果存储空指针会发生什么？默认情况下，指针容器不允许空指针，并且尝试存储空指针将在运行时引发异常。您可以覆盖此行为并告诉编译器允许存储空指针。要做到这一点，您必须稍微修改容器定义，使用：
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Instead of:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是：
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The advantages are limited, and you have to additionally make sure you do not
    dereference a potential null pointer. Your code becomes complex, and it becomes
    difficult to use range-based for-loops. Here is an example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 优点有限，并且您还必须确保不解引用潜在的空指针。您的代码变得复杂，使用基于范围的for循环变得困难。这里是一个例子：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It is best to avoid storing null pointers, and instead, use the Null Object
    Pattern that the library author recommends. You can see the Boost online documentation
    for more details on the Null Object Pattern ([http://www.boost.org/doc/libs/1_57_0/libs/ptr_container/doc/guidelines.html#avoid-null-pointers-in-containers-if-possible](http://www.boost.org/doc/libs/1_57_0/libs/ptr_container/doc/guidelines.html#avoid-null-pointers-in-containers-if-possible)).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最好避免存储空指针，而是使用库作者建议的Null Object Pattern。您可以查看Boost在线文档，了解有关Null Object Pattern的更多详细信息（[http://www.boost.org/doc/libs/1_57_0/libs/ptr_container/doc/guidelines.html#avoid-null-pointers-in-containers-if-possible](http://www.boost.org/doc/libs/1_57_0/libs/ptr_container/doc/guidelines.html#avoid-null-pointers-in-containers-if-possible)）。
- en: In summary, the Boost Pointer Containers are a full-featured set of containers
    for pointers to dynamically-allocated objects and are well suited for handling
    polymorphic objects. In C++11, one alternative way of achieving similar semantics
    is via containers of `std::unique_ptr<T>`. With sufficient optimization, the overhead
    of the `unique_ptr` wrapper is likely to be minimal, and the performance comparable
    to that of Boost's pointer container. While using containers of `boost::shared_ptr<T>`
    (`T` being the type of the dynamically-allocated objects) serves the use cases
    described here, they have higher memory and runtime overhead and are not optimal
    unless shared ownership semantics are needed.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，Boost指针容器是一组完整的用于指向动态分配对象的指针的容器，并且非常适合处理多态对象。在C++11中，实现类似语义的另一种方法是使用`std::unique_ptr<T>`的容器。通过充分优化，`unique_ptr`包装器的开销可能很小，并且性能与Boost的指针容器相当。虽然使用`boost::shared_ptr<T>`（`T`为动态分配对象的类型）的容器适用于这里描述的用例，但它们具有更高的内存和运行时开销，除非需要共享所有权语义，否则不是最佳选择。
- en: Expressive initialization and assignment using Boost.Assign
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Boost.Assign进行表达式初始化和赋值
- en: Initializing an object or assigning some literal value to it using a single
    statement is a succinct way of generating the contents of the object. It is easy
    to do this for simple variables like numeric variables or strings, because there
    are readily available literals. On the other hand, there are no simple syntactic
    means of initializing containers with arbitrary sets of values. This is because
    expressing more complex objects with nontrivial internal data structures as literals
    is difficult. Using some ingenious patterns and overloaded operators, the Boost.Assign
    library makes it possible to initialize and assign values to a whole host of STL
    and Boost containers, using a very expressive syntax.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单个语句初始化对象或将一些文字值分配给它是生成对象内容的简洁方式。对于简单变量（如数字变量或字符串），这很容易做到，因为有现成的文字。另一方面，没有简单的语法方式来使用任意一组值初始化容器。这是因为使用文字表达更复杂的具有非平凡内部数据结构的对象是困难的。使用一些巧妙的模式和重载的运算符，Boost.Assign库使得可以使用非常表达式的语法初始化和分配值给大量STL和Boost容器。
- en: With the availability of the new **initializer list** and **uniform initialization**
    syntax in C++11, these tasks can be accomplished without Boost.Assign. Still Boost.Assign
    is the only means of getting the job done on pre-C++11, and also provides some
    nifty additional capabilities not easily available via initializer lists and uniform
    initialization.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 有了C++11中新的**初始化列表**和**统一初始化**语法，这些任务可以在没有Boost.Assign的情况下完成。但是Boost.Assign是在C++11之前完成工作的唯一方法，并且还提供了一些通过初始化列表和统一初始化不容易获得的额外功能。
- en: Assigning lists of values to containers
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将值列表分配给容器
- en: 'Boost.Assign is one of those nifty little libraries in Boost, which you get
    into the habit of using at the smallest opportunity. Here is an example:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Boost.Assign是Boost中那些巧妙的小库之一，您会在最小的机会中习惯使用它。这里是一个例子：
- en: '**Listing 5.18: Assigning a list of values to a vector**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单5.18：将值列表分配给向量**'
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Assigning a list of values to a vector was never as much fun as with Boost.Assign.
    By overloading the comma operator (`operator,`) and `operator+=`, the Boost Assign
    library provides an easy way to append a list of values to a vector. In order
    to use the operators, we include `boost/assign.hpp` (line 3). The `using namespace`
    directive makes the operators defined in Boost Assign available in the global
    scope (line 6). Without this, we would not be able to freely use the operators
    and the expressiveness would be gone. We append three "good morning" greetings
    in English, French, and Italian to the vector `greetings` (line 11), and then
    three more in Hebrew, German, and French (line 12). The net effect is a vector
    with six strings (line 14). We could have replaced the vector with a deque and
    this would have still worked. If you wanted an alternate mode of insertion like
    inserting at the head of a list or deque or inserting into a map, Boost Assign
    can still work for you. Here is one more example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 向向量分配值列表从未像使用Boost.Assign那样有趣。通过重载逗号操作符（`operator,`）和`operator+=`，Boost Assign库提供了一种简单的方法来向向量追加值列表。为了使用这些操作符，我们包含`boost/assign.hpp`（第3行）。`using
    namespace`指令使得在全局范围内可以使用Boost Assign中定义的操作符（第6行）。如果没有这个，我们将无法自由地使用这些操作符，表达能力也会消失。我们向向量`greetings`追加了三个英语、法语和意大利语的“早上好”问候语（第11行），然后又追加了三个希伯来语、德语和法语的问候语（第12行）。最终效果是一个包含六个字符串的向量（第14行）。我们也可以用deque替换向量，这样也能正常工作。如果你想要另一种插入模式，比如在列表或deque的头部插入，或者插入到地图中，Boost
    Assign也可以满足你。这里还有一个例子：
- en: '**Listing 5.19: Assigning elements to other containers**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单5.19：向其他容器分配元素**'
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we see examples of assigning values to three different kinds of containers.
    We first push six "good night" greets in different languages into the head of
    a `std::deque` (lines 13-14). We do this using the `push_front` adaptor from Boost
    Assign which invokes the method of the same name `push_front` on the deque `greets`.
    It should be clear that after this operation, the last string in the list (`"Bonne
    nuit"`) sits at the front of the queue.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了给三种不同类型的容器赋值的例子。我们首先将六个不同语言的“晚安”问候语推入`std::deque`的头部（第13-14行）。我们使用Boost
    Assign中的`push_front`适配器来执行同名方法`push_front`，将这些值推入`greets`的deque中。在这个操作之后，列表中的最后一个字符串（“Bonne
    nuit”）将位于队列的前面。
- en: 'If you have had a thing for rock ''n'' roll and are as old as I am, you would
    perhaps identify the characters in the next example: an `std::map` of characters
    from rock ''n'' roll songs and albums, and what they did (according to those songs).
    Using the `insert` adaptor, which calls the method of the same name, on the map
    `rockCharacters`, we insert five pairs of strings—each mapping a character to
    an act (lines 17-22). The `insert` adaptor and other adaptors like it return an
    object with an overloaded `operator()` which can be chained. By chaining calls
    to this operator, the list of values is created.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对摇滚乐有兴趣，并且和我一样老，你可能会在下一个例子中识别出角色：一个`std::map`，其中包含摇滚乐歌曲和专辑中的角色，以及他们在歌曲中的行为。使用`insert`适配器，在`rockCharacters`地图上调用同名方法，我们插入了五对字符串，每对将一个角色映射到一个行为（第17-22行）。`insert`适配器和类似它的其他适配器返回一个重载了`operator()`的对象，可以进行链式调用。通过对这个操作符的调用进行链式调用，值列表被创建。
- en: The last container we use is a `std::list`, and for fun, we keep a list of famous
    trios from fiction. The `boost::tuple` template can be used to define tuples of
    an arbitrary number of elements of different types. Here, we use a `boost::tuple`
    of three strings to represent a trio, and keep a list of such trios in the variable
    `trios` (line 24). The `push_back` adaptor from Boost Assign is used to append
    the trios to the end of the list. The operator `+=` used in listing 5.17 with
    `std::vector` calls `push_back` on the underlying container. However, in this
    case, the `push_back` adaptor needs to be used to allow tuples of values to be
    pushed into the list.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的最后一个容器是`std::list`，为了好玩，我们保留了一个虚构中著名的三人组的列表。`boost::tuple`模板可以用来定义任意数量的不同类型元素的元组。在这里，我们使用了三个字符串的`boost::tuple`来表示一个三人组，并将这样的三人组列表保存在变量`trios`中（第24行）。使用Boost
    Assign中的`push_back`适配器将这些三人组追加到列表的末尾。在清单5.17中与`std::vector`一起使用的`+=`操作符调用了基础容器的`push_back`。然而，在这种情况下，需要使用`push_back`适配器来允许将值元组推入列表。
- en: 'Next, we print the content of the data structures. To access each element of
    each tuple in the list `trios`, we use the `boost::get` template that accesses
    the elements in tuples by a 0-based index (lines 44-45). Running this code prints
    the following output:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们打印数据结构的内容。为了访问列表`trios`中每个元组的每个元素，我们使用`boost::get`模板，通过基于0的索引访问元组中的元素（第44-45行）。运行这段代码会打印以下输出：
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Initializing containers with lists of values
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用值列表初始化容器
- en: 'In the previous examples, we saw various ways of appending or inserting values
    into a container, but Boost.Assign also lets you initialize containers with values
    at the time of construction. The syntax is slightly different from what is used
    for assignments:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们看到了向容器追加或插入值的各种方法，但Boost.Assign还允许您在构造时使用值初始化容器。语法与用于赋值的语法略有不同：
- en: '**Listing 5.20: Aggregate initialization with Boost Assign**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单5.20：使用Boost Assign进行聚合初始化**'
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding example constructs a vector of the first ten Catalan Numbers.
    The nth Catalan number (`n` being a nonnegative integer) equals the number of
    permutations of a string containing `n` left parentheses and `n` right parentheses
    in which all parentheses are correctly matched. We use the `list_of` adaptor from
    the `boost::assign` namespace to construct the list of first ten Catalan numbers
    with which the vector `catalan` is initialized (lines 10-11). We use an `ostream_iterator`
    to print this list (lines 13-14).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子构建了前十个卡特兰数的向量。第n个卡特兰数（n为非负整数）等于包含n个左括号和n个右括号的字符串的排列数，其中所有括号都正确匹配。我们使用`boost::assign`命名空间中的`list_of`适配器来构造前十个卡特兰数的列表，并用它来初始化向量`catalan`（第10-11行）。我们使用`ostream_iterator`来打印这个列表（第13-14行）。
- en: 'Next, we create a `std::map` containing the first eight Bernoulli numbers:
    the keys are the ordinal positions and the values are the numbers themselves.
    Bernoulli numbers are a sequence of rational numbers (expressible as a ratio of
    two integers) that arise in number theory and combinatorics. For initializing
    such a map, we use the `map_list_of` adaptor passing keys and values as shown
    (lines 17-25). For representing a rational number, we use the `boost::rational`
    template defined in the header `boost/rational.hpp`.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一个包含前八个伯努利数的`std::map`：键是序数位置，值是数本身。伯努利数是一系列有理数（可以表示为两个整数的比值），在数论和组合数学中出现。为了初始化这样一个映射，我们使用`map_list_of`适配器传递键和值，如示例所示（第17-25行）。为了表示有理数，我们使用在头文件`boost/rational.hpp`中定义的`boost::rational`模板。
- en: 'This code prints the following output:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码打印了以下输出：
- en: '[PRE39]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Interestingly, you can also create anonymous sequences using Boost Assign.
    These sequences can be constructed either as a sequence of non-constant l-value
    references or as a sequence of const l-value references that can admit literals.
    They are more efficient to construct than `list_of` and can be used in its place
    for initializing sequence containers like vectors. These sequences comply with
    the Boost Range concept and can be used anywhere a range can be used. Here is
    an example:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，你也可以使用Boost Assign创建匿名序列。这些序列可以构造为非常量l-value引用的序列，也可以构造为可以接受字面值的const l-value引用的序列。它们比`list_of`更有效地构造，并且可以用于初始化向量等序列容器。这些序列符合Boost
    Range概念，并且可以在任何可以使用范围的地方使用。以下是一个例子：
- en: '**Listing 5.21: Creating anonymous sequences**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单5.21：创建匿名序列**'
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We create an anonymous sequence of size ten using the `cref_list_of` adaptor,
    but actually put only eight values in it (line 22). If we had variables to put
    in the sequence instead of character literals, we could have used the `ref_list_of`
    adaptor, and this would have created a mutable sequence. We use `boost::size`,
    `boost::begin` and `boost::end` functions for operating on ranges to determine
    the length of the sequence (line 9) and its first and last elements (lines 12-13).
    Next, we use an anonymous list of string pairs to initialize a `std::map` (lines
    26-29). Note that `value_type` nested typedef in a map represents the type of
    each key-value pair in the map.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`cref_list_of`适配器创建了一个大小为十的匿名序列，但实际上只放了八个值进去（第22行）。如果我们有变量要放进序列而不是字符字面值，我们可以使用`ref_list_of`适配器，这将创建一个可变序列。我们使用`boost::size`、`boost::begin`和`boost::end`函数来操作范围，确定序列的长度（第9行）以及它的第一个和最后一个元素（第12-13行）。接下来，我们使用一个字符串对的匿名列表来初始化一个`std::map`（第26-29行）。请注意，`map`中的`value_type`嵌套typedef表示地图中每个键值对的类型。
- en: 'C++11 introduces the very handy aggregate initialization syntax using which
    arbitrary containers can be initialized. It is syntactically simpler to perform
    initialization using the aggregate initializer syntax than Boost Assign and is
    likely more efficient. In pre-C++11 environments, Boost Assign''s initialization
    syntax remains the only choice. Here are a few examples of C++11 aggregate initialization:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: C++11引入了非常方便的聚合初始化语法，使用这种语法可以初始化任意容器。使用聚合初始化程序语法进行初始化在语法上比Boost Assign更简单，并且可能更有效。在C++11之前的环境中，Boost
    Assign的初始化语法仍然是唯一的选择。以下是一些C++11聚合初始化的例子：
- en: '[PRE41]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This snippet shows the way to use a comma-separated list of values enclosed
    in curly braces to initialize collections. The `scholars` vector is initialized
    with names of four Muslim scholars from the Middle Ages, and then the `scholarsFrom`
    map is initialized with the names of those scholars as keys and their places of
    origin as the values. Note how each key-value pair is enclosed in braces in a
    comma-separated list of such pairs. Also, note that we freely use l-values (like
    `scholars[0]`) as well as literals in the initializer.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段展示了使用花括号括起来的逗号分隔的值列表来初始化集合的方法。`scholars`向量用中世纪四位穆斯林学者的名字初始化，然后`scholarsFrom`映射用这些学者的名字作为键，他们的出生地作为值进行初始化。请注意，每个键值对都被括在花括号中，以逗号分隔的这样的对列表中。另外，请注意我们在初始化器中自由使用l-values（比如`scholars[0]`）以及字面值。
- en: Initializing pointer containers and assigning values
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化指针容器并分配值
- en: The Boost Assign library provides special support for assigning values to pointer
    containers and initializing pointer containers in an exception-safe way.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Assign库提供了特殊支持，以一种异常安全的方式为指针容器分配值和初始化指针容器。
- en: 'The following short example summarizes the usage:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下简短的例子总结了用法：
- en: '**Listing 5.22: Boost Assign with pointer containers**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单5.22：使用指针容器的Boost Assign**'
- en: '[PRE42]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In this example, we define a type `WorkShift` that represents a shift at a
    workplace and encapsulates information about work hours for a particular shift.
    Its constructor takes two arguments, the start and end time of the shift, and
    defaults them to 9.30 and 17.30 (line 12). We create a `ptr_vector` of `WorkShift`
    objects and initialize them, using the `ptr_list_of` adaptor. Instead of passing
    constructed objects, we pass constructor arguments for two objects: a shift between
    6.00 and 14.00 and another shift with a default start and end time (line 28).'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了一个类型`WorkShift`，表示工作场所的一个班次，并封装了关于特定班次工作时间的信息。它的构造函数接受两个参数，班次的开始和结束时间，并将它们默认为9.30和17.30（第12行）。我们创建了一个`ptr_vector`的`WorkShift`对象，并使用`ptr_list_of`适配器对它们进行初始化。我们不是传递构造好的对象，而是传递两个对象的构造函数参数：一个班次在6.00到14.00之间，另一个班次有默认的开始和结束时间（第28行）。
- en: 'The template argument to `ptr_list_of` denotes which type to instantiate. We
    add two more shifts to the `ptr_vector` called `shifts`, using the `ptr_push_back`
    adaptor. Next, we make a `ptr_map` called `shiftMap` with string keys, identifying
    the type of shifts and pointers to shift objects for values (line 31). We then
    use the `ptr_map_insert` adaptor to insert the elements into the map. We create
    each entry by invoking `operator()`, passing the string key as the first argument
    and the constructor arguments for the `WorkShift` object as the remaining arguments
    (lines 32-33). We print the contents of the `ptr_map` (line 35-38), using the
    overloaded streaming operator for `WorkShift` (line 19). The following is the
    output of this program:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`ptr_list_of`的模板参数表示要实例化的类型。我们使用`ptr_push_back`适配器向`ptr_vector`添加了两个更多的shifts。接下来，我们创建了一个名为`shiftMap`的`ptr_map`，其中包含字符串键，用于标识shifts的类型和指向值的shift对象（第31行）。然后，我们使用`ptr_map_insert`适配器将元素插入到地图中。我们通过调用`operator()`创建每个条目，将字符串键作为第一个参数传递，将`WorkShift`对象的构造函数参数作为剩余参数（第32-33行）。我们打印`ptr_map`的内容（第35-38行），使用`WorkShift`的重载流操作符（第19行）。以下是此程序的输出：'
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'It is important to understand why a separate class of adaptors is used for
    initializing pointer containers. The following, for example, is a perfectly a
    valid code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解为什么为初始化指针容器使用了一个单独的适配器类。例如，以下是一个完全有效的代码：
- en: '[PRE44]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'However, in this example, the user of the library (that is us) manually allocates
    two new `WorkShift` objects. The order in which these get allocated is not guaranteed
    by the compiler. Only the order in which they are appended to `shifts` is guaranteed
    (via calls to the overloaded `operator()` in the adaptor returned by `boost::assign::push_back`).
    So, for the preceding sample, the compiler could generate code roughly equivalent
    to the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在此示例中，库的用户（也就是我们）手动分配了两个新的`WorkShift`对象。这些分配的顺序不能由编译器保证。只有通过对`boost::assign::push_back`返回的适配器调用来保证它们附加到`shifts`的顺序。因此，对于前面的示例，编译器可能生成大致等效于以下内容的代码：
- en: '[PRE45]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If the constructor of `WorkShift` threw while `w2` was constructed (line 3),
    then `w1` would be leaked. In order to ensure exception-safety, we should use
    `ptr_push_back`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在构造`w2`时`WorkShift`的构造函数抛出异常（第3行），那么`w1`将会泄漏。为了确保异常安全，我们应该使用`ptr_push_back`：
- en: '[PRE46]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Instead, the overloaded `operator()` in the `boost::assign::ptr_push_back` adaptor
    takes the constructor arguments for each `WorkShift` object that needs to be in
    the `shifts` container and constructs each `WorkShift` object, forwarding those
    arguments to the `WorkShift` constructor. The call returns only after the constructed
    object is in the container. This ensures that at the time of construction of a
    `WorkShift` object, all previously constructed `WorkShift` objects are already
    part of the container. So if the constructor throws, the container along with
    the previously-constructed objects are released.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在`boost::assign::ptr_push_back`适配器中重载的`operator()`接受需要在`shifts`容器中的每个`WorkShift`对象的构造函数参数，并构造每个`WorkShift`对象，将这些参数转发到`WorkShift`构造函数。调用仅在构造对象后才返回到容器中。这确保在构造`WorkShift`对象时，所有先前构造的`WorkShift`对象已经是容器的一部分。因此，如果构造函数抛出异常，容器以及先前构造的对象都将被释放。
- en: Iteration patterns using Boost.Iterator
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Boost.Iterator进行迭代模式
- en: Iteration is a fundamental task in most programming problems, whether it is
    iterating through the elements of a container, a series of natural numbers, or
    the files in a directory. By abstracting how a collection of values is iterated
    through, we can write generic code to process such a collection without depending
    on methods of iteration specific to each collection.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代是大多数编程问题中的基本任务，无论是遍历容器的元素，一系列自然数，还是目录中的文件。通过抽象化对值集合的迭代方式，我们可以编写通用代码来处理这样的集合，而不依赖于每个集合特定迭代方法。
- en: The Standard Library containers expose iterators for this purpose, and the generic
    algorithms in the Standard Library can operate on any conforming container through
    its iterators, without depending on the specific type of the container or its
    internal structure.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库容器为此目的公开了迭代器，并且标准库中的通用算法可以通过其迭代器操作任何符合条件的容器，而不依赖于容器的特定类型或其内部结构。
- en: The Boost.Iterator library provides a framework for writing iterators for custom
    classes that conform to the standards and are compatible with algorithms in the
    Standard Library. It also helps generalize iteration concepts to more abstract
    object collections, not limited to containers.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Boost.Iterator库提供了一个框架，用于为符合标准并与标准库中的算法兼容的自定义类编写迭代器。它还有助于将迭代概念推广到更抽象的对象集合，而不仅限于容器。
- en: Smart iteration using Boost.Iterator
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Boost.Iterator进行智能迭代
- en: The Boost Iterator library provides a number of iterator adaptors that make
    iterating over containers and sequences of values more expressive and efficient.
    An iterator adaptor wraps an iterator to produce another iterator. The adapted
    iterator may or may not iterate over the entire range of elements addressed by
    the underlying iterator. Also, they can be designed to return a different value,
    potentially of a different type than the underlying iterator. In this section,
    we look at a few examples of such iterator adaptors from Boost.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Iterator库提供了许多迭代器适配器，使得在容器和值序列上进行迭代更加表达和高效。迭代器适配器包装一个迭代器以产生另一个迭代器。适配的迭代器可能会或可能不会遍历底层迭代器所寻址的元素的整个范围。此外，它们可以被设计为返回不同的值，可能是不同类型的值，而不是底层迭代器。在本节中，我们将看一些来自Boost的此类迭代器适配器的示例。
- en: Filter Iterator
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤迭代器
- en: The filter iterators iterate over a subsequence of an underlying sequence of
    elements. They wrap an underlying iterator sequence and take a unary Boolean predicate,
    which is used to determine which elements to include from the underlying range,
    and which ones to skip. The predicate takes an element of the underlying sequence
    as a single argument and returns true or false. The ones for which true is returned
    are included in the iteration, the rest are filtered out; hence the name.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤迭代器遍历基础元素序列的子序列。它们包装一个基础迭代器序列，并采用一元布尔谓词，用于确定从基础范围中包括哪些元素，跳过哪些元素。谓词将基础序列的一个元素作为单个参数，并返回true或false。返回true的元素包括在迭代中，其余被过滤掉；因此得名。
- en: 'You can create filter iterators by using the `boost::make_filter_iterator`
    function template. You pass it a unary function object (functor, lambda, or function
    pointer) that returns `bool`. You also pass it not one, but two iterators: the
    one it wraps and another one marking the end of sequence. In the following example,
    we have a list of `Person` objects, and we need to write code to make a payout
    of 100 dollars to the bank account of each person who is seventy years of age
    or older:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`boost::make_filter_iterator`函数模板创建过滤迭代器。您传递一个返回`bool`的一元函数对象（函数对象、lambda或函数指针）。您还传递不是一个，而是两个迭代器：它包装的一个和标记序列结束的另一个。在下面的例子中，我们有一个`Person`对象的列表，我们需要编写代码，向每个七十岁或以上的人的银行帐户支付100美元：
- en: '**Listing 5.23: Using filter iterators**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单5.23：使用过滤迭代器**'
- en: '[PRE47]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this example, the function `payout` takes an account number and an amount
    and initiates a payment to the account (line 17). The function `creditSum` takes
    a pair of iterators defining a sequence of `Person` objects and an amount, and
    initiates a payment of that amount to each `Person` in the sequence, calling `payout`
    for each (line 23-24). We have a vector of `Person` objects (line 39), which we
    initialize with the details of five people, using the uniform initialization syntax
    from C++11\. We cannot directly call `creditSum` on the entire range of elements
    in the vector because we only want to credit it to people who are seventy or older.
    To do this, we first define the predicate function `seventyOrOlder` (line 32)
    that helps us select the candidate entries, and then define the filter iterators
    `first` and `last` (lines 45-49). Finally, we call `creditSum` with the pair of
    filter iterators and the sum to credit (line 51).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，函数`payout`接受一个帐号和一个金额，并向该帐号发起付款（第17行）。函数`creditSum`接受定义`Person`对象序列和金额的一对迭代器，并向序列中的每个`Person`发起该金额的付款，为每个调用`payout`（第23-24行）。我们有一个`Person`对象的向量（第39行），我们使用C++11的统一初始化语法初始化了五个人的详细信息。我们不能直接在向量中的所有元素范围上调用`creditSum`，因为我们只想将其信用额度授予七十岁或以上的人。为此，我们首先定义了谓词函数`seventyOrOlder`（第32行），它帮助我们选择候选条目，然后定义了过滤迭代器`first`和`last`（第45-49行）。最后，我们使用一对过滤迭代器和要信用的总额调用`creditSum`（第51行）。
- en: Transform Iterator
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换迭代器
- en: Transform iterators allow you to traverse a sequence, and when dereferenced,
    return the result of applying a unary function to the underlying element of the
    sequence. You can construct transform iterators using `boost::make_tranform_iterator`,
    passing it the unary function object and the underlying iterator.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 转换迭代器允许您遍历序列，并在取消引用时返回将一元函数应用于序列的基础元素的结果。您可以使用`boost::make_tranform_iterator`构造转换迭代器，将一元函数对象和基础迭代器传递给它。
- en: 'Consider `std::map` objects containing subject names as keys and subjects scores
    as values. We use transform iterators to compute the sum of the scores in all
    the subjects, as shown in the following example:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑包含科目名称作为键和科目分数作为值的`std::map`对象。我们使用转换迭代器来计算所有科目分数的总和，如下例所示：
- en: '**Listing 5.24: Using transform iterators**'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单5.24：使用转换迭代器**'
- en: '[PRE48]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The map `subjectScores` contains the scores in individual subjects stored against
    each subject name. We use the C++11 uniform initialization syntax to initialize
    the map (lines 25-26). We want to iterate through the values in this map and compute
    their sum. Iterating through `subjectScores` will give us key-value pairs of subject
    names and scores. To extract the score from a pair, we define a functor `GetScore`
    (lines 14-15). We then define a pair of transform iterators `first` and `last`,
    each constructed using an instance of the `GetScore` functor and the underlying
    iterator, and pointing to the beginning and end of the `subjectScores` map (lines
    28-31). By calling `std::accumulate` from `first` to `last`, we sum over the scores
    in the map (line 33) and print the result.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 映射`subjectScores`包含存储在每个科目名称下的各科成绩。我们使用C++11统一初始化语法来初始化映射（第25-26行）。我们想要遍历这个映射中的值并计算它们的总和。遍历`subjectScores`将给我们提供科目名称和成绩的键值对。为了从一对中提取分数，我们定义了一个函数对象`GetScore`（第14-15行）。然后我们定义了一对转换迭代器`first`和`last`，每个都使用`GetScore`函数对象和基础迭代器构造，并指向`subjectScores`映射的开始和结束（第28-31行）。通过从`first`到`last`调用`std::accumulate`，我们对映射中的分数求和（第33行）并打印结果。
- en: Notice that `GetScore` derives from `std::unary_function<ArgType, RetType>`,
    where `ArgType` is the type of the functor's single argument and `RetType` is
    return type of the functor. This is not required for C++11, and you do not need
    to derive `GetScore` from any specific class in C++11.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`GetScore`派生自`std::unary_function<ArgType, RetType>`，其中`ArgType`是函数对象的单个参数的类型，`RetType`是函数对象的返回类型。这对于C++11不是必需的，您不需要在C++11中从任何特定类派生`GetScore`。
- en: Like `boost::transform_iterator`, the `std::transform` algorithm allows applying
    a transform to each element in a sequence, but you must also store the results
    in a sequence. The transform iterator allows you to create a lazy sequence whose
    elements are evaluated, as they are accessed without the binding need to store
    them anywhere.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 像`boost::transform_iterator`一样，`std::transform`算法允许对序列中的每个元素应用转换，但您还必须将结果存储在序列中。转换迭代器允许您创建一个延迟序列，其元素在访问时被评估，而无需将它们存储在任何地方。
- en: Function Output Iterator
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数输出迭代器
- en: The function output iterators apply a unary function to each element that is
    assigned to them. You can create a function output iterator using the `boost::make_function_output_iterator`
    function template, passing it a unary function object. You can then use `std::copy`
    or a similar algorithm to assign elements from a sequence to the function output
    iterator. The function output iterator simply calls the function on each element
    assigned to it. You can encapsulate any logic in the function object you provide,
    print them enclosed in quotes, add them to another container, keep a count of
    elements processed, and so on.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 函数输出迭代器对分配给它们的每个元素应用一元函数。您可以使用`boost::make_function_output_iterator`函数模板创建函数输出迭代器，将一元函数对象传递给它。然后，您可以使用`std::copy`或类似的算法将序列中的元素分配给函数输出迭代器。函数输出迭代器只是在分配给它的每个元素上调用函数。您可以在提供的函数对象中封装任何逻辑，将它们打印在引号中，将它们添加到另一个容器中，保持已处理元素的计数等。
- en: 'In the following example, we have a list of directory names, and using the
    `boost::function_output_iterator`, we concatenate them together separated by spaces,
    making sure to quote any strings with embedded spaces:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们有一个目录名称列表，并使用`boost::function_output_iterator`，将它们用空格分隔起来连接在一起，确保引用任何包含嵌入空格的字符串：
- en: '**Listing 5.25: Using function output iterators**'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单5.25：使用函数输出迭代器**'
- en: '[PRE49]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We define a functor `StringCat` that stores a non-const reference to a `std::string`
    passed to its constructor (line 12) in a member called `result_`. It defines a
    unary `operator()`, which takes a single string parameter and appends it to `result_`.
    If the passed string has embedded spaces or tabs, it is quoted and appended with
    a leading space (line 14). Otherwise it is appended with a leading space without
    quoting (line 16).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个函数对象`StringCat`，它在构造函数中存储对`std::string`的非常量引用（第12行）在一个名为`result_`的成员中。它定义了一个一元`operator()`，它接受一个字符串参数并将其附加到`result_`。如果传递的字符串中包含嵌入的空格或制表符，则用引号引起来并在前面加上一个空格（第14行）。否则，在前面加上一个空格而不引用（第16行）。
- en: 'We have a list of directory names called `dirs` (line 25-27), and we want to
    append them following this scheme to a string called `dirString` (line 28). To
    do this, we create an instance of `StringCat`, passing it a reference to `dirString`
    (line 31), and pass this to `boost:: make_function_output_iterator`, which returns
    an output iterator (line 30). We use `std::copy` to copy the elements from `dirs`
    into the output iterator returned, which has the effect of concatenating the strings
    by making repeated calls to the `StringCat` functor. When `std::copy` returns,
    `dirString` has the following content:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为`dirs`的目录名称列表（第25-27行），我们想按照这个方案将它们附加到一个名为`dirString`的字符串上（第28行）。为此，我们创建了一个`StringCat`的实例，将其传递给`dirString`的引用（第31行），并将其传递给`boost::make_function_output_iterator`，它返回一个输出迭代器（第30行）。我们使用`std::copy`将元素从`dirs`复制到返回的输出迭代器中，这样做的效果是通过多次调用`StringCat`函数对象来连接字符串。当`std::copy`返回时，`dirString`的内容如下：
- en: '[PRE50]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You can see that `personal docs`, which is the name of a single directory, is
    appropriately quoted.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到`personal docs`，这是一个单个目录的名称，被适当地引用了。
- en: There are other iterator adaptors besides the ones listed above that we did
    not cover here, including `boost::indirect_iterator`, `boost::function_input_iterator`,
    `boost::zip_iterator`, `boost::counting_iterator`, and `boost::permutation_iterator`.
    Use the documentation on the Boost website to familiarize yourself with the patterns
    of their uses, and explore how you can use them in your own code.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上面列出的迭代器适配器之外，还有其他我们在这里没有涵盖的迭代器适配器，包括`boost::indirect_iterator`、`boost::function_input_iterator`、`boost::zip_iterator`、`boost::counting_iterator`和`boost::permutation_iterator`。使用Boost网站上的文档来熟悉它们的使用模式，并探索如何在自己的代码中使用它们。
- en: Iterator adaptors provide a set of common idioms from functional programming
    languages and libraries like Python's **itertools**. Iterator adaptors are particularly
    useful when you have APIs that take a pair of iterators but have no option to
    filter or adapt the elements via functors or predicates. Much of what iterator
    adaptors enable can also be achieved by using the more modern Boost Range Adaptors,
    perhaps with less verbose syntax. However, if your APIs expect iterators instead
    of ranges, then these iterator adaptors will be handy.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器适配器提供了来自函数式编程语言和库（如Python的**itertools**）的一组常见习语。当您的API接受一对迭代器但没有通过函数对象或谓词过滤或适应元素的选项时，迭代器适配器特别有用。迭代器适配器使能的许多功能也可以通过使用更现代的Boost
    Range Adaptors来实现，可能语法更简洁。但是，如果您的API期望迭代器而不是范围，那么这些迭代器适配器将非常方便。
- en: Creating conforming iterators for custom classes
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为自定义类创建符合规范的迭代器
- en: In addition to providing iterator adaptor templates, the Boost.Iterator library
    provides a framework for creating conforming iterators. In this section, we will
    use the Boost.Iterator library to create conforming iterators for a threaded binary
    search tree. A binary search tree is an abstract data type that stores elements
    in a tree structure. Loosely speaking, each node in the tree has zero, one, or
    two children. All elements in the left sub-tree of a node are smaller than the
    node, and all elements in the right sub-tree of a node are larger than the node.
    Nodes with zero children are called leaves. A threaded binary search tree is optimized
    for traversing its elements in a sorted order, the so-called **inorder traversal**.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供迭代器适配器模板外，Boost.Iterator库还提供了创建符合规范的迭代器的框架。在本节中，我们将使用Boost.Iterator库为线程化二叉搜索树创建符合规范的迭代器。二叉搜索树是一种将元素存储在树结构中的抽象数据类型。粗略地说，树中的每个节点都有零个、一个或两个子节点。节点的左子树中的所有元素都小于节点，节点的右子树中的所有元素都大于节点。没有子节点的节点称为叶子节点。线程化二叉搜索树被优化为以排序顺序遍历其元素，即所谓的**中序遍历**。
- en: We implement a naïve version of a threaded binary search tree, in which we will
    maintain pointers to the predecessor and successor of a node in each node. We
    will then provide a bidirectional iterator interface that will allow forward and
    reverse traversal of the tree in the order of its elements.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个简单版本的线程化二叉搜索树，在其中我们将在每个节点中维护指向前驱和后继节点的指针。然后我们将提供一个双向迭代器接口，允许以元素顺序进行树的正向和反向遍历。
- en: '**Listing 5.26: A naïve threaded binary search tree**'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单5.26：一个简单的线程化二叉搜索树**'
- en: '[PRE51]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can use the `BinarySearchTree` template in the following code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下代码中使用`BinarySearchTree`模板：
- en: '[PRE52]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This example helps us illustrate the techniques for creating custom iterators
    for a not too trivial data structure, using the Boost Iterator framework. The
    threaded tree implementation is made deliberately simple to aid understanding.
    `TreeNode<T>` represents each node in a tree containing values of a parameterized
    type `T`. `BinarySearchTree<T>` represents a binary search tree that supports
    inorder traversal. It stores three pointers of type `TreeNode<T>`: the root of
    the tree, the pointer `first` to the smallest element, and a sentinal pointer
    `last`, representing the end of the traversal (lines 68-70). Finally, `BSTIterator<T>`
    represents the type of a bidirectional iterator to `BinarySearchTree<T>`, one
    that allows inorder traversal through the elements of the tree in both directions.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子帮助我们说明了使用Boost迭代器框架为一个不太复杂的数据结构创建自定义迭代器的技术。线程化树的实现被故意简化以帮助理解。`TreeNode<T>`代表树中的每个节点，包含参数化类型`T`的值。`BinarySearchTree<T>`代表支持中序遍历的二叉搜索树。它存储三个`TreeNode<T>`类型的指针：树的根节点，指向最小元素的指针`first`，以及表示遍历结束的哨兵指针`last`（第68-70行）。最后，`BSTIterator<T>`代表`BinarySearchTree<T>`的双向迭代器类型，允许以两个方向遍历树的元素。
- en: '`TreeNode<T>` stores two pointers to its `left` and `right` children and two
    more to its nodes that precede (`prev`) and follow (`next`) it in order of the
    values they store (lines 12-13). A new node is always inserted as a leaf node,
    and the `prev` and `next` pointers of the new node and the ones that precede and
    follow it in a traversal order are readjusted appropriately. New elements are
    inserted into the tree using the `insert` public method, and the actual logic
    for insertion is in the private overload of the `insert` method (lines 72-102).The
    `begin` and `end` methods of `BinarySearchTree` return iterators to the first
    element in the tree and another node, marking the end of traversal.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`TreeNode<T>`存储指向其`left`和`right`子节点的两个指针，以及指向其在值顺序中的前驱（`prev`）和后继（`next`）节点的两个指针（第12-13行）。新节点总是作为叶节点插入，新节点和在遍历顺序中其前后的节点的`prev`和`next`指针将被适当地调整。新元素是使用`insert`公共方法插入到树中的，插入的实际逻辑在`insert`方法的私有重载中（第72-102行）。`BinarySearchTree`的`begin`和`end`方法返回树中的第一个元素的迭代器和另一个标记遍历结束的节点。'
- en: 'The `BSTIterator` template, which is the iterator implementation that we are
    most interested in, derives from a specialization of `boost::iterator_facade`
    (lines 29-30). The specialization takes three arguments: `BSTIterator<T>` itself,
    the type parameter `T`, and a tag `boost::bidirectional_traversal_tag` to identify
    the type of traversal the iterator supports (bidirectional in this case). The
    base template taking the derived class as an argument is a well-known C++ idiom
    called **Curiously Recurring Template Parameter** and is used to achieve the effect
    of virtual method calls without the runtime cost of it. We now define a set of
    members to finish the implementation.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`BSTIterator`模板是我们最感兴趣的迭代器实现，它派生自`boost::iterator_facade`的一个特化（第29-30行）。特化需要三个参数：`BSTIterator<T>`本身，类型参数`T`，以及一个标签`boost::bidirectional_traversal_tag`，用于标识迭代器支持的遍历类型（在本例中是双向）。以派生类作为参数的基本模板是一个众所周知的C++习语，称为**奇异递归模板参数**，用于实现虚方法调用的效果，但没有运行时成本。我们现在定义一组成员来完成实现。'
- en: 'The `BSTIterator` template keeps a `TreeNode<T>` pointer to a node in the tree
    (line 40). This is initialized using a default constructor and the one that takes
    a node pointer (lines 33-35). Also, importantly, we must make `BSTIterator` copyable
    (lines 36-37). We define a set of private member functions, which are accessed
    by the Boost Iterator framework. The framework code accesses these functions via
    a class called `boost::iterator_core_access`, which is therefore defined as a
    `friend` class (line 42). The functions `increment` (line 44) and `decrement`
    (line 45) are called when we increment or decrement the iterator using `operator++`
    or `operator--`. They change the internal node pointer to point to the next or
    previous node in the traversal order (inorder). The function `dereference` is
    called when we dereference the iterator using `operator*`. It returns a reference
    to the data element stored in each node (line 51). The `equal` method is used
    to check whether two iterators are equal to each other. This is invoked when,
    for example, you check if an iterator has reached the end of the sequence of values
    in a container with code like:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`BSTIterator`模板保持对树中节点的`TreeNode<T>`指针（第40行）。这是使用默认构造函数和带有节点指针的构造函数进行初始化的（第33-35行）。同样重要的是，我们必须使`BSTIterator`可复制（第36-37行）。我们定义了一组私有成员函数，这些函数由Boost迭代器框架访问。框架代码通过一个名为`boost::iterator_core_access`的类访问这些函数，因此将其定义为`friend`类（第42行）。`increment`函数（第44行）和`decrement`函数（第45行）在我们使用`operator++`或`operator--`增加或减少迭代器时被调用。它们将内部节点指针更改为指向遍历顺序（中序）中的下一个或上一个节点。当我们使用`operator*`对迭代器进行解引用时，将调用`dereference`函数。它返回对存储在每个节点中的数据元素的引用（第51行）。`equal`方法用于检查两个迭代器是否相等。例如，当您检查迭代器是否已经到达容器中值序列的末尾时，会调用它。'
- en: '[PRE53]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This is all we need to do to define a fully functional iterator. There is one
    additional bit of work that has to be done inside the container. We define the
    `begin` and `end` methods that return the start and end of the sequence of values
    in the container (lines 77-78). These pointers, `first` (line 89) and `last` (line
    90), are maintained as additional members and suitably updated by the `BinarySearchTree`
    template. The pointer `first` is updated each time a new smallest element is inserted
    into the container. The pointer `last`, which represents a sentinel beyond which
    the forward traversal can never proceed, is created initially and never updated
    (line 69). Each time a new largest element is added to the tree, its `next` pointer
    points to `last`. The const versions of `begin` and `end` member functions (lines
    80-85) are provided to ensure that calling them on a constant container give immutable
    iterators. Following essentially the same pattern, you can roll out your own iterators
    for your containers that are compliant with the Standard Library's iterator concepts.
    A number of Standard Library algorithms may be used on your custom container via
    such an iterator interface. The concise implementation of the iterator (lines
    27-51) is made possible by the abstractions provided by the Boost Iterator framework.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要做的全部工作来定义一个完全功能的迭代器。容器内部还需要做一些额外的工作。我们定义`begin`和`end`方法，返回容器中值序列的开始和结束（第77-78行）。这些指针，`first`（第89行）和`last`（第90行），作为额外的成员，并由`BinarySearchTree`模板适当更新。指针`first`在每次插入新的最小元素时更新。指针`last`代表一个标记，超过这个标记前进遍历将永远无法进行，最初创建并且永远不会更新（第69行）。每次将新的最大元素添加到树中时，它的`next`指针指向`last`。提供`begin`和`end`成员函数的const版本（第80-85行）是为了确保在常量容器上调用它们会得到不可变的迭代器。基本上采用相同的模式，您可以为符合标准库迭代器概念的容器推出自己的迭代器。许多标准库算法可以通过这样的迭代器接口用于自定义容器。迭代器的简洁实现（第27-51行）得益于Boost迭代器框架提供的抽象。
- en: Self-test questions
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自测问题
- en: 'For multiple choice questions, choose all the options that apply:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多项选择题，选择所有适用的选项：
- en: Which of the following are true for flat associative containers compared to
    ordered/unordered associative containers?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与有序/无序关联容器相比，对于平面关联容器以下哪些是正确的？
- en: a. Require less memory
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: a. 需要更少的内存
- en: b. Insertion is faster
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: b. 插入更快
- en: c. Traversal is slower
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: c. 遍历较慢
- en: d. Lookups are faster
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: d. 查找更快
- en: 'The `std::forward_list` does not provide a `size()` member function because:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::forward_list`不提供`size()`成员函数，因为：'
- en: a. Linear time size members cannot be supported for singly-linked lists
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: a. 线性时间大小成员不能支持单链表
- en: b. Both splice and size members cannot be constant time
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: b. 既splice又size成员不能是常数时间
- en: c. It would be thread-unsafe
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: c. 它将是线程不安全的
- en: d. All of the above
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: d. 以上所有
- en: 'Where is the internal memory of a `static_vector` allocated:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`static_vector`的内部内存分配在哪里：'
- en: a. Stack
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: a. 栈
- en: b. Depends on where the static vector is created
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: b. 取决于静态向量的创建位置
- en: c. Free store
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: c. 自由存储区
- en: d. Depends on the allocator used
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: d. 取决于使用的分配器
- en: In order to store objects of type X in an unordered container, which of the
    following must be defined/available for objects of type X?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将X类型的对象存储在无序容器中，必须为X类型的对象定义/可用以下哪些？
- en: a. Ordering relation
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: a. 排序关系
- en: b. Hash function
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: b. 哈希函数
- en: c. Equality comparison
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: c. 相等比较
- en: d. Copy constructor
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: d. 复制构造函数
- en: Which data structure allows random access to its elements and supports iterators
    that are not invalidated upon insertion and erase of other elements?
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种数据结构允许对其元素进行随机访问，并支持在插入和删除其他元素时不会使迭代器失效？
- en: a. `static_vector`
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: a. `static_vector`
- en: b. `unordered_map`
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: b. `unordered_map`
- en: c. `stable_vector`
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: c. `stable_vector`
- en: d. `circular_buffer`
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: d. `circular_buffer`
- en: Summary
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter laid out a wide array of Boost libraries that provide different
    kinds of containers or make it easier to work with them. We looked at several
    useful nonstandard containers that extend the Standard Library containers, looked
    at containers designed to store dynamically-allocated object pointers, saw some
    expressive ways of assigning elements to containers, learned about hash-based
    unordered containers, and learned different patterns of iterating over collections
    and enabling iteration for custom collections.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一系列Boost库，这些库提供了不同类型的容器，或者使得使用它们更容易。我们看了一些有用的非标准容器，扩展了标准库容器，看了一些设计用于存储动态分配对象指针的容器，看到了一些将元素分配给容器的表达方式，了解了基于哈希的无序容器，学习了不同的迭代集合的模式，并为自定义集合启用了迭代。
- en: In the next chapter, we will continue our study of container libraries from
    Boost and focus on specialized containers that support efficient lookup of objects
    based on multiple criteria.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续研究Boost的容器库，并专注于支持根据多个条件高效查找对象的专用容器。
- en: References
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'Avoid null-pointers in containers (if possible): [http://www.boost.org/doc/libs/1_57_0/libs/ptr_container/doc/guidelines.html#avoid-null-pointers-in-containers-if-possible](http://www.boost.org/doc/libs/1_57_0/libs/ptr_container/doc/guidelines.html#avoid-null-pointers-in-containers-if-possible)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下避免容器中的空指针：[http://www.boost.org/doc/libs/1_57_0/libs/ptr_container/doc/guidelines.html#avoid-null-pointers-in-containers-if-possible](http://www.boost.org/doc/libs/1_57_0/libs/ptr_container/doc/guidelines.html#avoid-null-pointers-in-containers-if-possible)
