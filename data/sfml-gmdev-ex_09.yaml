- en: Chapter 9. A Breath of Fresh Air – Entity Component System Continued
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章. 一股清新的空气 – 实体组件系统继续
- en: In the previous chapter, we discussed the benefits of using aggregation versus
    simple inheritance. While not necessarily intuitive at first glance, entities
    composed of multiple components and operated on by systems inarguably enable higher
    flexibility and re-usability of code, not to mention a more convenient environment
    for future growth. Well, "The future is now!" as the popular expression states.
    A house is useless without a good foundation, just as much as a good foundation
    is useless without a house built on top of it. Since we already have a solid foundation,
    laying bricks until a proper structure emerges is what's next.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了使用聚合而非简单继承的优点。虽然一开始可能不太直观，但由多个组件组成并由系统操作的实体无疑提高了代码的灵活性和可重用性，更不用说为未来的增长提供了一个更方便的环境。正如流行表达所说，“未来已经到来！”一座房子没有好的基础是无用的，就像一个好的基础如果没有在上面建造房子也是无用的。既然我们已经有了坚实的基础，那么接下来就是砌砖直到出现一个合适的结构。
- en: 'In this chapter, we will be:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Implementing basic movement
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现基本移动
- en: Developing a system for updating sprite sheets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个更新精灵图的系统
- en: Revisiting and implementing entity states
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新审视并实现实体状态
- en: Studying the collision within the entity component system paradigm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实体组件系统范式下研究碰撞
- en: Adding entity movement
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加实体移动
- en: 'Within the entity component system paradigm, movement of a particular body
    is quantified by all the forces imposed on it. The collection of these forces
    can be represented by a movable component:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在实体组件系统范式下，特定身体的移动是通过作用在其上的所有力来量化的。这些力的集合可以表示为一个可移动组件：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This component takes away physics elements from the second project of this book,
    namely the velocity, speed and acceleration attributes. In order to simplify the
    code, the velocity cap is represented by a single float this time, as it is unlikely
    we will ever need to limit the velocity differently based on its axis.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件从本书的第二项目中移除了物理元素，即速度、速度和加速度属性。为了简化代码，这次将速度限制表示为一个单一的浮点数，因为我们不太可能需要根据其轴来不同地限制速度。
- en: 'Let''s take a look at the rest of the movable component class:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看可移动组件类的其余部分：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The constructor here initializes the data members to some default values, which
    are later replaced by ones from de-serialization:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的构造函数将数据成员初始化为一些默认值，这些值随后将由反序列化中的值替换：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For purposes of easily manipulating velocity within a certain range, we provide
    the `AddVelocity` method:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便地在一定范围内操纵速度，我们提供了`AddVelocity`方法：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After adding the provided argument velocity, the end result is checked for being
    higher than the maximum allowed value on each axis. If it is, the velocity is
    capped at the maximum allowed value with the appropriate sign.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加提供的速度参数后，检查最终结果是否高于每个轴上允许的最大值。如果是，则将速度限制在允许的最大值，并保留适当的符号。
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Applying friction to the current velocity is also regulated. In order to avoid
    friction forcing the velocity to change its sign, it's checked to not be equal
    to zero, as well as if the difference between absolute values of current velocity
    and provided friction isn't going to be negative. If it is, the velocity is set
    to zero. Otherwise, the friction value is added to current velocity with an appropriate
    sign.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 将摩擦应用于当前速度也是受控的。为了避免摩擦使速度改变符号，它被检查是否不等于零，以及当前速度的绝对值与提供的摩擦之间的差异不会是负数。如果是，则将速度设置为零。否则，将摩擦值以适当的符号添加到当前速度。
- en: 'In order for an entity to move, it has to be accelerated. Let''s supply a method
    for that:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使实体能够移动，它必须被加速。让我们提供一个方法：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For the sake of convenience, we provide the same method, overloaded to take
    in two types of arguments: a float vector and two separate float values. All it
    does is simply add the argument values to current acceleration.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们提供了相同的方法，重载以接受两种类型的参数：一个浮点向量和两个单独的浮点值。它所做的只是简单地将参数值添加到当前加速度。
- en: 'Lastly, entities can also be moved based on a provided direction, instead of
    calling the `Accelerate` method manually:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，实体也可以根据提供的方向移动，而不是手动调用`Accelerate`方法：
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Based on the direction provided as an argument, the entity's speed is added
    to the acceleration vector.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 根据提供的方向参数，实体的速度被添加到加速度向量中。
- en: The movement system
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动系统
- en: 'With the movement component designed, let''s take a stab at implementing the
    actual system that will move our entities around:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计好移动组件后，让我们尝试实现实际移动我们实体的系统：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'First, an `Axis` enumeration is created, in order to simply the code in one
    of the private helper methods of this class. We then forward-declare a `Map` class,
    in order to be able to use it in the header. With that, comes a `Map` data member,
    as well as a public method for providing the movement system with an instance
    of `Map`. A few private helper methods are also needed in order to make the code
    more readable. Let''s begin by setting up our constructor:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个`Axis`枚举，以便简化此类私有辅助方法中的代码。然后，我们提前声明一个`Map`类，以便能够在头文件中使用它。这样，就有一个`Map`数据成员，以及一个公共方法，用于向移动系统提供一个`Map`实例。还需要一些私有辅助方法来使代码更易于阅读。让我们从设置构造函数开始：
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The requirements for this system consist of two components: position and movable.
    In addition to that, this system also subscribes to the `Is_Moving` message type,
    in order to respond to it.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 该系统的要求包括两个组件：位置和可移动。除此之外，该系统还订阅了`Is_Moving`消息类型，以便对其做出响应。
- en: 'Next, let''s update our entity information:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更新我们的实体信息：
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As the requirements of this system suggest, it will be operating on the position
    component, as well as the movable component. For every entity that belongs to
    this system, we want to update its physics and adjust its position in accordance
    to its velocity and the time that has passed in between frames, producing movement
    based on forces.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如该系统的要求所示，它将在位置组件和可移动组件上运行。对于属于此系统的每个实体，我们希望更新其物理属性并根据其速度和帧间经过的时间调整其位置，从而产生基于力的移动。
- en: 'Let''s take a look at the movement step method:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看移动步骤方法：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The friction value of the tile an entity is standing on is obtained first. It
    gets applied to the entity's movable component right after its velocity is updated
    based on the acceleration value.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先获取实体站立的地砖的摩擦值。在根据加速度值更新速度后，立即将其应用于实体的可移动组件。
- en: 'Next, we must make sure that diagonal movement is handled correctly. Consider
    the following illustration:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须确保对角移动被正确处理。考虑以下插图：
- en: '![The movement system](img/B04284_09_01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![移动系统](img/B04284_09_01.jpg)'
- en: According to the Pythagorean theorem, the squared hypotenuse of a right triangle,
    which represents diagonal movement, is equal to the sum of its squared sides.
    In other words, its hypotenuse is shorter than the sum of both of its sides. Characters
    that move down-right, for example, would appear to move faster than they do in
    a single direction, unless we cap their velocity based on the magnitude of the
    velocity vector, also known as the hypotenuse of the triangle in our illustration.
    Once the magnitude is calculated, it is checked for exceeding the maximum possible
    velocity of an entity. If it does, it gets normalized and multiplied by the value
    of maximum velocity, in order to impose slower diagonal movement.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 根据勾股定理，表示对角移动的直角三角形的斜边平方等于其两边的平方和。换句话说，斜边比两边的和要短。例如，向右下移动的角色看起来会比单方向移动得更快，除非我们根据速度向量的幅度（也称为我们插图中的三角形的斜边）限制它们的速度。一旦计算出幅度，就会检查它是否超过了实体可能的最大速度。如果超过了，它会被归一化并乘以最大速度的值，以强制对角移动变慢。
- en: 'Obtaining the tile friction can be done like so:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 获取地砖摩擦力的方法如下：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A tile pointer is set up before a `while` loop is initiated. It will keep trying
    to fetch a tile at a provided location while decreasing the elevation each time.
    This means that tile friction is effectively yielded from the top-most tile that
    a player is over. If a tile hasn't been found, the default friction value is returned
    instead.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动`while`循环之前设置一个地砖指针。它将不断尝试在提供的位置获取地砖，同时每次减少海拔。这意味着地砖摩擦力实际上是从玩家所在的最顶层地砖中获得的。如果没有找到地砖，则返回默认摩擦值。
- en: 'As you might be able to guess by now, the movement system needs to respond
    to quite a few events, due to its importance:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如你现在可能猜到的，由于其重要性，移动系统需要响应相当多的事件：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: First, it handles two colliding events, to which it responds by calling the
    private `StopEntity` method in order to halt an entity on a specified axis. Next,
    we have four movement events. In cases of `Moving_Left` and `Moving_Right`, the
    private `SetDirection` method is invoked in order to update the direction of an
    entity. Moving up and down, however, is a little bit different. We want the entity's
    direction to only change if it has no velocity on the *x* axis. Otherwise, it
    ends up moving rather cheesily.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它处理两个碰撞事件，通过调用私有的`StopEntity`方法来在指定轴上停止实体。接下来，我们有四个移动事件。在`Moving_Left`和`Moving_Right`的情况下，调用私有的`SetDirection`方法来更新实体的方向。然而，上下移动则略有不同。我们希望实体的方向只有在它没有*x*轴上的速度时才改变。否则，它最终会以一种相当滑稽的方式移动。
- en: 'Next up, message handling:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是消息处理：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, we''re only concerned with a single message type: `Is_Moving`. It''s
    a message, designed to trigger another one being sent when the entity becomes
    idle. First, the system is checked for having the entity in question. Its movable
    component is then acquired, the velocity of which is checked for being at absolute
    zero. Given that that''s the case, an event is created to signify the entity becoming
    idle.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只关心一种消息类型：`Is_Moving`。这是一个消息，当实体变得空闲时，会触发发送另一个消息。首先，检查系统是否包含相关的实体。然后获取其实体的可移动组件，检查其速度是否为零。既然是这样，就创建一个事件来表示实体变得空闲。
- en: 'All we have left now are the private helper methods. It''s all of the redundant
    logic, the existence of which within methods saves us from code duplication. The
    first one we''ll examine is responsible for halting an entity:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只剩下私有辅助方法。这些都是冗余逻辑，其存在避免了代码重复。我们将首先检查负责停止实体的第一个方法：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After obtaining its movable component, the entity then has its velocity set
    to zero on an axis, provided as the argument to this method.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在获得其可移动组件后，实体在其轴上将其速度设置为零，该轴作为此方法的参数提供。
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `SetDirection` method updates the direction of a movable component. A message
    is then dispatched to notify all the other systems of this change.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetDirection`方法更新可移动组件的方向。然后发送一条消息来通知所有其他系统这一变化。'
- en: 'Finally, we''re down to a single setter method for the `Map` class:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只剩下一个`Map`类的设置器方法：
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In order for entities to have dynamic friction, the movement system has to
    have access to the `Map` class, so it gets set up in the game state:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使实体具有动态摩擦，移动系统必须能够访问`Map`类，因此它在游戏状态中设置：
- en: '[PRE17]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This last code snippet concludes the implementation of the movement system.
    Our entities are now able to move, based on the forces inflicted on them. Having
    support for movement, however, does not actually generate movement. This is where
    the entity state system comes in.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后这段代码片段完成了移动系统的实现。我们的实体现在可以根据施加在它们身上的力进行移动。然而，有了移动支持实际上并不产生移动。这就是实体状态系统发挥作用的地方。
- en: Implementing states
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现状态
- en: 'Movement, much like many other actions and events that are relevant to entities
    are contingent upon their current state being satisfactory. A dying player should
    not be able to move around. Relevant animations should be played, based on its
    current state. Enforcing those laws requires the entity to have a state component:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 移动，就像许多与实体相关的其他动作和事件一样，取决于它们当前状态是否令人满意。一个垂死的玩家不应该能够四处移动。应根据其实际状态播放相关的动画。强制执行这些规则需要实体具有状态组件：
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can tell already, this is a very simple chunk of code. It defines its
    own enumeration of possible entity states. The component class itself simply provides
    a setter and a getter, as well as the required method for de-serialization. The
    rest is, as always, left up to the system to hash out.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，这是一段非常简单的代码。它定义了自己的实体可能状态枚举。组件类本身仅提供设置器和获取器，以及所需的反序列化方法。其余的，像往常一样，留给系统自行处理。
- en: The state system
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 状态系统
- en: 'Since most of the system headers from here on out are going to look pretty
    much the same, they will be omitted. With that said, let''s begin by implementing
    the constructor and destructor of our state system:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于从现在开始的大多数系统头文件看起来几乎相同，因此将省略它们。话虽如此，让我们首先实现我们的状态系统的构造函数和析构函数：
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'All this system requires is the state component. It also subscribes to two
    message types: `Move` and `Switch_State`. While the latter is self-explanatory,
    the `Move` message is what gets sent by the methods in the game state in order
    to move the player. Because movement is entirely dependent on the entity state,
    this is the only system that handles this type of message and determines whether
    the state is appropriate for motion.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统所需的所有东西只是一个状态组件。它还订阅了两种消息类型：`Move` 和 `Switch_State`。后者是显而易见的，而 `Move` 消息是由游戏状态中的方法发送的，以移动玩家。因为移动完全依赖于实体状态，所以这是唯一处理这种类型消息并确定状态是否适合运动的系统。
- en: 'Next, let''s take a look at the `Update` method:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `Update` 方法：
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'All that happens here is a simple check of the entity''s current state. If
    it''s in motion, a message `Is_Moving` is dispatched. If you recall, this type
    of message is handled by the movement system, which fires an event when the entity
    becomes idle. That event is handled by our state system:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的一切只是一个简单的检查实体当前的状态。如果它在运动中，就会分发一个 `Is_Moving` 消息。如果你还记得，这种类型的消息是由运动系统处理的，当实体变为空闲时，它会触发一个事件。这个事件由我们的状态系统处理：
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: All it does is invoke a private method `ChangeState`, which alters the current
    state of an entity to `Idle`. The third argument here is simply a flag for whether
    the state change should be forced or not.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 它所做的只是调用一个私有方法 `ChangeState`，该方法将实体的当前状态更改为 `Idle`。这里的第三个参数只是一个标志，用于指示状态更改是否应该被强制执行。
- en: 'The last public method we''ll be dealing with here is `Notify`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里将要处理的最后一个公共方法是 `Notify`：
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `Move` message is handled by obtaining the state of an entity it targets.
    If the entity isn't dying, a `Moving_X` event is constructed based on which direction
    the message holds. Once the event is dispatched, the entity's state is changed
    to `Walking`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Move` 消息通过获取目标实体的状态来处理。如果实体没有死亡，就会根据消息包含的方向构建一个 `Moving_X` 事件。一旦事件被分发，实体的状态就会更改为
    `Walking`。'
- en: 'The `Switch_State` message simply alters the current state of an entity without
    forcing it, by invoking this private method:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Switch_State` 消息只是通过调用这个私有方法来更改实体的当前状态，而不进行强制更改：'
- en: '[PRE23]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: After the state is obtained, the `l_force` flag is checked. If it's set to `false`,
    the state is only altered if the entity isn't currently `DYING`. We don't want
    anything to snap entities out of death randomly. The state is changed regardless
    of that, if the `l_force` flag is set to `true`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在获得状态后，检查 `l_force` 标志。如果它设置为 `false`，只有当实体当前不是 `DYING` 时，状态才会被更改。我们不希望任何东西随机地将实体从死亡中拉出来。如果
    `l_force` 标志设置为 `true`，则无论是否更改状态。
- en: Now we have control over what can happen to an entity, based on its current
    state. With that in place, the entities are now ready to be controlled.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以根据实体的当前状态控制可能发生的事情。有了这个，实体现在就可以被控制了。
- en: The entity controller
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体控制器
- en: 'The idea behind having a separate system be responsible for moving an entity
    around is not only that we get to decide which entities are capable of being moved,
    but also further separation of logic, and hooks for future A.I. implementations.
    Let''s take a look at the controller component:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让一个独立的系统负责移动实体的想法不仅在于我们可以决定哪些实体可以被移动，而且还进一步分离了逻辑，并为未来的 A.I. 实现提供了钩子。让我们看看控制器组件：
- en: '[PRE24]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Yes, it's just an empty component, that is simply used as a way to tell the
    control system that the entity it belongs to can be controlled. There might be
    some additional information it needs to store in the future, but for now, it's
    simply a "flag."
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，它只是一个空组件，它只是用作告诉控制系统它所属的实体可以被控制的一种方式。它可能需要存储一些额外的信息，但到目前为止，它只是一个“标志”。
- en: 'The actual control system is extremely simple to implement. Let''s begin with
    the constructor:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的控制系统非常简单易实现。让我们从构造函数开始：
- en: '[PRE25]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It imposes requirements for position, movable and controller components, in
    order to be able to move the entity, which is the only purpose of this system.
    The actual movement is handled by processing entity events like so:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 它对位置、可移动和控制器组件提出了要求，以便能够移动实体，这正是这个系统的唯一目的。实际的移动由处理实体事件来处理，如下所示：
- en: '[PRE26]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'All four events invoke the same private method, which simply calls the `Move`
    method of a movable component and passes in the appropriate direction:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 所有四个事件都会调用同一个私有方法，该方法只是调用可移动组件的 `Move` 方法，并传入适当的方向：
- en: '[PRE27]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After this humble addition to our code-base, we can finally move the player
    around with the keyboard:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在向我们的代码库添加了这个谦虚的补充之后，我们终于可以用键盘移动玩家了：
- en: '![The entity controller](img/B04284_09_02.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![实体控制器](img/B04284_09_02.jpg)'
- en: The only problem now is entities looking like they're sliding on ice, due to
    complete lack of animations. To resolve this issue, the animation system must
    be introduced.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在唯一的问题是实体看起来像是在冰上滑行，这是由于完全缺乏动画。为了解决这个问题，必须引入动画系统。
- en: Animating the entities
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画实体
- en: If you recall from previous chapters, the `SpriteSheet` class we built already
    has great support for animations. There is no reason to annex that at this point,
    especially since we're only dealing with sprite-sheet based graphics. This saves
    us a lot of time and allows sprite-sheet animations to be handled by a single
    system, with no additional component overhead.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您回忆起前面的章节，我们构建的 `SpriteSheet` 类已经对动画有很好的支持。在这个阶段没有必要添加这个功能，尤其是我们只处理基于精灵图的图形。这为我们节省了大量时间，并允许精灵图动画由一个单独的系统处理，无需额外的组件开销。
- en: 'Let''s start implementing the sprite sheet animation system, as always, by
    getting the constructor out of the way:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现精灵图动画系统，就像往常一样，先处理构造函数：
- en: '[PRE28]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Since entity animations are, so far, entirely state-based, this system requires
    a state component, in addition to the sprite sheet component. It also subscribes
    to the `State_Changed` message type in order to respond to state changes by playing
    the appropriate animation. Updating all of the entities is the area where this
    system has most of its logic, so let''s take a look at the `Update` method:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于实体动画到目前为止完全是基于状态的，因此这个系统需要一个状态组件，除了精灵图组件之外。它还订阅了 `State_Changed` 消息类型，以便通过播放适当的动画来响应状态变化。更新所有实体是这个系统逻辑最多的区域，所以让我们看看
    `Update` 方法：
- en: '[PRE29]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: First, both the sprite sheet and state components are obtained. The sprite sheet
    is then updated and the current name of the animation is retrieved. If an attack
    animation is no longer playing, a message of `Switch_State` type is sent out in
    order to put the entity back to an `Idle` state. Otherwise, the animation is checked
    for currently being within the "action" frame range, which is specified in the
    sprite sheet file. If it is, an `Attack_Action` message is sent out to the current
    entity, which can later be used by different systems to implement combat. On the
    other hand, if the death animation has concluded, a `Dead` message is dispatched.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，获取精灵图和状态组件。然后更新精灵图并检索当前动画的名称。如果攻击动画不再播放，则发送一个 `Switch_State` 类型的消息，以便将实体放回
    `Idle` 状态。否则，检查动画是否当前处于精灵图文件中指定的 "action" 帧范围内。如果是，向当前实体发送一个 `Attack_Action` 消息，稍后不同的系统可以使用它来实现战斗。另一方面，如果死亡动画已经结束，则发送一个
    `Dead` 消息。
- en: 'Next, let''s work on handling messages:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们处理消息：
- en: '[PRE30]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'All possible messages this system would be interested in deal with specific
    entities, so that check is made first. For now, we''ll only be dealing with a
    single message type: `State_Changed`. Every time a state is changed, we''ll be
    altering the animation of the entity. The only possible exception here is the
    `Hurt` state, which will be dealt with later.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统可能感兴趣的任何消息都与特定实体有关，所以首先进行这个检查。目前，我们只处理一种消息类型：`State_Changed`。每次状态改变时，我们都会改变实体的动画。唯一的可能例外是
    `Hurt` 状态，稍后我们会处理它。
- en: 'The last bit of code we need is the private `ChangeAnimation` method:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的最后一段代码是私有的 `ChangeAnimation` 方法：
- en: '[PRE31]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: After obtaining the entity's sprite sheet component, it simply invokes its `SetAnimation`
    method to change the current animation that's playing. This code is redundant
    enough to warrant a separate method.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 获取实体的精灵图组件后，它简单地调用其 `SetAnimation` 方法来更改正在播放的当前动画。这段代码足够冗余，值得有一个单独的方法。
- en: 'Upon successful compilation, we can see that our entities are now animated:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 编译成功后，我们可以看到我们的实体现在已经开始动画了：
- en: '![Animating the entities](img/B04284_09_03.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![动画实体](img/B04284_09_03.jpg)'
- en: Handling collisions
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理碰撞
- en: 'Making entities bump into each other, as well as into all the lush environments
    we''ll be building is a mechanic, without which most games out there would not
    be able to function. In order for that to be possible, these animated images zooming
    around the screen must have a component, which represents their solidity. Bounding
    boxes worked really well for us in the past, so let''s stick to them and begin
    constructing the collidable body component:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让实体相互碰撞，以及进入我们将要构建的所有茂密环境，是一种机制，没有这种机制，大多数游戏将无法运行。为了实现这一点，这些在屏幕上四处移动的动画图像必须有一个表示其固体的组件。边界框在过去为我们工作得很好，所以让我们坚持使用它们，并开始构建可碰撞体组件：
- en: '[PRE32]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Every collidable entity must have a bounding box that represents the solid portion
    of it. That's exactly where the `m_AABB` rectangle comes in. In addition to that,
    the bounding box itself can be offset by a number of pixels, based on what kind
    of entity it is, as well as have a different origin. Lastly, we want to keep track
    of whether an entity is currently colliding on any given axis, which warrants
    the use of `m_collidingOnX` and `m_collidingOnY` flags.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 每个可碰撞实体都必须有一个表示其实体固体部分的边界框。这正是`m_AABB`矩形发挥作用的地方。除此之外，边界框本身可以根据实体的类型偏移一定数量的像素，并且可以有不同的起点。最后，我们想要跟踪实体是否在给定的轴上发生碰撞，这需要使用`m_collidingOnX`和`m_collidingOnY`标志。
- en: 'The constructor of this component might look a little something like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件的构造函数可能看起来有点像这样：
- en: '[PRE33]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After initializing the default values to some of its data members, this component,
    like many others, needs to have a way to be de-serialized:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在将默认值初始化到其一些数据成员之后，这个组件，就像许多其他组件一样，需要有一种反序列化的方式：
- en: '[PRE34]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here are a few unique setter and getter methods that we''ll be using:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些独特的设置器和获取器方法，我们将使用它们：
- en: '[PRE35]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, we arrive at the key method of this component, `SetPosition`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了这个组件的关键方法，`SetPosition`：
- en: '[PRE36]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In order to support different types of origins, the position of the bounding
    box rectangle must be set differently. Consider the following illustration:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持不同类型的起点，边界框矩形的定位必须不同。考虑以下插图：
- en: '![Handling collisions](img/B04284_09_04.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![处理碰撞](img/B04284_09_04.jpg)'
- en: The origin of the actual bounding box rectangle is always going to be the top-left
    corner. To position it correctly, we use its width and height to compensate for
    differences between several possible origin types.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的边界框矩形的起点始终是左上角。为了正确定位它，我们使用其宽度和高度来补偿几种可能的起点类型之间的差异。
- en: The collision system
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞系统
- en: 'The actual collision magic doesn''t start happening until we have a system
    responsible for accounting for every collidable body in the game. Let''s begin
    by taking a look at the data types that are going to be used in this system:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的碰撞魔法只有在有了负责计算游戏中每个可碰撞体系统的系统之后才会开始。让我们首先看看在这个系统中将要使用的数据类型：
- en: '[PRE37]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: For proper collision detection and response, we're also going to need a data
    structure that is capable of holding collision information, which can later be
    sorted and processed. For that, we're going to be using a vector of `CollisionElement`
    data types. It's a structure, consisting of a float, representing area of collision,
    a pointer to a `TileInfo` instance, which carries all of the information about
    a tile, and a simple float rectangle, which holds the bounding box information
    of a map tile.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行适当的碰撞检测和响应，我们还需要一个能够存储碰撞信息的数据结构，这些信息可以稍后进行排序和处理。为此，我们将使用`CollisionElement`数据类型的向量。它是一个结构，由一个表示碰撞面积的浮点数、一个指向`TileInfo`实例的指针（该实例携带有关瓦片的所有信息）和一个简单的浮点矩形组成，该矩形包含地图瓦片的边界框信息。
- en: In order to detect collisions between entities and tiles, the collision system
    needs to have access to a `Map` instance. Knowing all of that, let's get started
    on implementing the class!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测实体和瓦片之间的碰撞，碰撞系统需要能够访问一个`Map`实例。了解所有这些后，让我们开始实现这个类！
- en: Implementing the collision system
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现碰撞系统
- en: 'As always, we''re going to be setting up the component requirements right inside
    the constructor of this class:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们将在类的构造函数中设置组件要求：
- en: '[PRE38]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As you can see, this system imposes requirements of position and collidable
    components on entities. Its `m_gameMap` data member is also initialized to `nullptr`,
    until it gets set up via the use of this method:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，该系统对实体施加了位置和可碰撞组件的要求。其`m_gameMap`数据成员也被初始化为`nullptr`，直到通过使用此方法进行设置：
- en: '[PRE39]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next up is the oh-so-common update method that makes everything behave as it
    should:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是那个非常常见的更新方法，它使一切行为如预期：
- en: '[PRE40]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'For clarity, the update method uses two other helper methods: `CheckOutOfBounds`
    and `MapCollisions`. While iterating over all collidable entities, this system
    obtains their position and collidable component. The latter is updated, using
    the entity''s latest position. It also has its Boolean collision flags reset.
    After all entities have been updated, the private `EntityCollisions` method is
    invoked to process entity-on-entity intersection tests. Note the very beginning
    of this method. It immediately returns in case the map instance hasn''t been properly
    set up.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，更新方法使用了另外两个辅助方法：`CheckOutOfBounds` 和 `MapCollisions`。在遍历所有可碰撞实体时，该系统获取其实体位置和可碰撞组件。后者使用实体的最新位置进行更新。同时，它的布尔碰撞标志也被重置。在所有实体都被更新后，私有的
    `EntityCollisions` 方法被调用以处理实体与实体之间的交点测试。注意这个方法的开始部分。如果地图实例没有正确设置，它将立即返回。
- en: 'First, the entity is checked for being outside the boundaries of our map:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，检查实体是否位于我们地图的边界之外：
- en: '[PRE41]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If the entity has somehow ended up outside the map, its position gets reset.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实体意外地位于地图之外，其位置将被重置。
- en: 'At this point, we begin running the tile-on-entity collision test:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们开始运行实体与地砖的碰撞测试：
- en: '[PRE42]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'A collision information vector named `c` is set up. It will contain all the
    important information about what the entity is colliding with, the size of the
    collision area and properties of the tile it''s colliding with. The entity''s
    bounding box is then obtained from the collidable component. A range of coordinates
    to be checked is calculated, based on that bounding box, as shown here:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 设置了一个名为 `c` 的碰撞信息向量。它将包含实体碰撞的所有重要信息，碰撞区域的尺寸以及它所碰撞的地砖的属性。然后从可碰撞组件中获取实体的边界框。根据该边界框计算出一个要检查的坐标范围，如下所示：
- en: '![Implementing the collision system](img/B04284_09_05.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![实现碰撞系统](img/B04284_09_05.jpg)'
- en: 'Those coordinates are immediately put to use, as we begin iterating over the
    calculated range of tiles, checking for collisions:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这些坐标立即被使用，因为我们开始遍历计算出的地砖范围，检查碰撞：
- en: '[PRE43]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Once a solid tile is encountered, its bounding box, tile information and area
    of intersection details are gathered and inserted into the vector `c`. It's important
    to stop the layer loop if a solid tile is detected, otherwise collision detection
    may not function properly.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦遇到一个固体地砖，就收集其边界框、地砖信息和交点区域细节，并将它们插入到向量 `c` 中。如果检测到固体地砖，则必须停止层循环，否则碰撞检测可能无法正常工作。
- en: 'After all the solids the entity collides with in the calculated range have
    been found, they all must be sorted:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在找到计算范围内实体碰撞的所有固体之后，它们都必须进行排序：
- en: '[PRE44]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'After sorting, we can finally begin resolving collisions:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 排序后，我们最终可以开始解决碰撞：
- en: '[PRE45]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Since resolution of one collision could potentially resolve another as well,
    the bounding box of an entity must be checked for intersections here as well,
    before we commit to resolving it. The actual resolution is pretty much the same
    as it was in [Chapter 7](ch07.html "Chapter 7. Rediscovering Fire – Common Game
    Design Elements"), *Rediscovering Fire – Common Game Design Elements*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于解决一个碰撞可能会解决另一个碰撞，因此在承诺解决碰撞之前，必须检查实体的边界框是否存在交点。实际的解决方法与[第7章](ch07.html "第7章。重新发现火焰
    – 常见游戏设计元素")中描述的几乎相同，即*重新发现火焰 – 常见游戏设计元素*。
- en: Once the resolution details are calculated, the position component is moved
    based on it. The collidable component has to be updated here as well, because
    it would end up getting resolved multiple times and moved incorrectly otherwise.
    The last bit we need to worry about is adding a collision event to the entity's
    event queue and calling the `CollideOnX` or `CollideOnY` method in the collidable
    component to update its flags.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦计算了解决细节，位置组件就会根据它移动。可碰撞组件也必须在这里更新，否则它可能会被多次解决并错误地移动。最后需要关注的是向实体的事件队列中添加碰撞事件，并在可碰撞组件中调用
    `CollideOnX` 或 `CollideOnY` 方法来更新其标志。
- en: 'Now for entity-on-entity collisions:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是实体与实体之间的碰撞：
- en: '[PRE46]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This method checks all entities against all other entities for collisions between
    their bounding boxes, by using the `intersects` method, kindly provided by SFML's
    rectangle class. For now, we don't have to worry about responding to these types
    of collisions, however, we will be using this functionality in future chapters.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法通过使用SFML矩形类提供的`intersects`方法，将所有实体与其余所有实体的边界框进行碰撞检查。目前，我们不必担心对这些类型的碰撞做出响应，然而，我们将在未来的章节中使用这个功能。
- en: 'Lastly, just like its movement counterpart, the collision system requires a
    pointer to the `Map` class, so let''s give it one in the game state''s `OnCreate`
    method:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，就像其移动对应物一样，碰撞系统需要一个指向`Map`类的指针，所以让我们在游戏状态的`OnCreate`方法中给它一个：
- en: '[PRE47]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This final code snippet gives the collision system all of the power it needs,
    in order to keep the entities from walking through solid tiles, as so:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段为碰撞系统提供了所有所需的权力，以防止实体穿过固体瓷砖，如下所示：
- en: '![Implementing the collision system](img/B04284_09_06.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![实现碰撞系统](img/B04284_09_06.jpg)'
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Upon completing this chapter, we've successfully moved away from inheritance-based
    entity design and reinforced our code-base with a much more modular approach,
    thus avoiding many pitfalls that composition leaves behind. A chain is only as
    strong as its weakest link, and now we can rest assured that the entity segment
    will hold.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章内容后，我们成功摆脱了基于继承的实体设计，并通过一种更加模块化的方法强化了我们的代码库，从而避免了组合留下的许多陷阱。链条的强度仅取决于其最薄弱的环节，而现在我们可以放心，实体部分将稳固。
- en: In the next two chapters, we will be discussing how to make the game more interactive
    and user friendly by adding a GUI system, as well as adding a few different types
    of elements, managing their events and providing room for them to be graphically
    customizable. See you there!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两章中，我们将讨论如何通过添加GUI系统以及添加一些不同类型的元素，管理它们的事件，并为它们提供图形自定义的空间，来使游戏更加互动和用户友好。那里见！
