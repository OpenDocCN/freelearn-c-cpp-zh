- en: Sprite Animations in WebAssembly with SDL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在WebAssembly中使用SDL进行精灵动画
- en: At the time of writing, **S****imple DirectMedia Layer** (**SDL**) is the only
    2D rendering library integrated into Emscripten for use in WebAssembly. But, even
    as more rendering libraries become available, SDL is a highly supported rendering
    library that has been ported to a large number of platforms and will remain both
    relevant and useful for WebAssembly and C++ development into the foreseeable future.
    Using SDL to render to WebGL saves us a tremendous amount of time, because we
    do not have to write the code to interface between our WebAssembly C++ code and
    WebGL ourselves. The large community also offers support and documentation. You
    can find more SDL resources online at [libsdl.org](http://libsdl.org).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Simple DirectMedia Layer（SDL）是唯一集成到Emscripten中供WebAssembly使用的2D渲染库。但是，即使更多的渲染库变得可用，SDL也是一个得到广泛支持的渲染库，已经被移植到了大量平台，并且在可预见的未来仍将保持相关和有用，用于WebAssembly和C++开发。使用SDL渲染到WebGL可以节省大量时间，因为我们不必自己编写WebAssembly
    C++代码和WebGL之间的接口代码。庞大的社区还提供支持和文档。您可以在[libsdl.org](http://libsdl.org)上找到更多SDL资源。
- en: 'You will need to include several images in your build to make this project
    work. Make sure you include the `/Chapter04/sprites/` and `/Chapter04/font/` folders
    from the project''s GitHub. If you haven''t yet downloaded the GitHub project,
    you can get it online from: [https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在构建中包含几个图像才能使此项目工作。确保包括项目的GitHub中的`/Chapter04/sprites/`和`/Chapter04/font/`文件夹。如果您还没有下载GitHub项目，可以从以下网址在线获取：[https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly)。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Using SDL in WebAssembly
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在WebAssembly中使用SDL
- en: Rendering a sprite to the canvas
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将精灵渲染到画布上
- en: Animating a sprite
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画精灵
- en: Moving the sprite
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动精灵
- en: Using SDL in WebAssembly
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在WebAssembly中使用SDL
- en: 'At this point, I could roll my own system for interaction between the WebAssembly
    module and the JavaScript WebGL library. That would involve using a function table
    to call the JavaScript WebGL functions from within C++. Luckily for us, the Emscripten
    team has done most of this work. They have created a port of a popular 2D C++
    graphics library that does this for us. SDL is a 2D graphics **Application Programming**
    **Interface** (**API**) built on top of OpenGL in most implementations. There
    is an Emscripten port that is used to help us render our 2D graphics on top of
    WebGL. If you would like to know what other libraries have been integrated into
    Emscripten, use the following `emcc` command:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我可以为WebAssembly模块和JavaScript WebGL库之间的交互自己开发系统。这将涉及使用函数表从C++中调用JavaScript
    WebGL函数。幸运的是，Emscripten团队已经完成了大部分工作。他们已经为我们创建了一个流行的2D C++图形库的端口，可以实现这一点。SDL是一个建立在大多数实现中的OpenGL之上的2D图形API。有一个Emscripten端口，用于帮助我们在WebGL上渲染我们的2D图形。如果您想知道Emscripten集成了哪些其他库，请使用以下`emcc`命令：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you run this command, you will notice that several different SDL libraries
    are displayed. These include SDL2, SDL2_image, SDL2_gfx, SDL2_ttf, and SDL2_net.
    SDL was created with a modular design to allow the user to include only the parts
    of SDL that they need, allowing the core SDL library to remain small. This is
    very helpful if your goal is to create a web game where download size is limited.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行此命令，您会注意到显示了几个不同的SDL库。这些包括SDL2、SDL2_image、SDL2_gfx、SDL2_ttf和SDL2_net。SDL是以模块化设计创建的，允许用户只包含他们需要的SDL部分，从而使核心SDL库保持较小。如果您的目标是创建一个下载大小受限的网络游戏，这将非常有帮助。
- en: The first thing we will do is get familiar with SDL by creating a simple "Hello
    World" application that writes some text to the HTML5 canvas element. To do this,
    we will need to include two of the Emscripten libraries listed when we ran the
    `emcc --show-ports` command. We will need to add the core SDL library to our Emscripten
    compiled with the `USE_SDL=2,` flag, and we will need to add the SDL TrueType
    font library by adding the `USE_SDL_TTF=2` flag.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过创建一个简单的“Hello World”应用程序来熟悉SDL，该应用程序将一些文本写入HTML5画布元素。为此，我们需要包含我们运行`emcc
    --show-ports`命令时列出的Emscripten库中的两个。我们需要通过在Emscripten编译时添加`USE_SDL=2`标志来添加核心SDL库，还需要通过添加`USE_SDL_TTF=2`标志来添加SDL
    TrueType字体库。
- en: 'The `.c` source code that will display a message such as `"HELLO SDL!"` inside
    an HTML canvas is relatively simple:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 将在HTML画布中显示消息“HELLO SDL!”的`.c`源代码相对简单：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let me walk you through exactly what is going on here. The first four lines
    of code are the SDL header files, as well as the Emscripten header file:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我来详细介绍一下这里发生了什么。代码的前四行是SDL头文件，以及Emscripten头文件：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Following this, there are three preprocessor defines. If we wanted to change
    the message or font size quickly, we would modify these first two lines. The third
    define is a little less clear. We have something called `FONT_FILE`, which is
    a string that appears to be a filesystem location. That is a little bit weird,
    because WebAssembly does not have access to the local filesystem. To give the
    WebAssembly module access to the TrueType font file in the fonts directory, we
    will use the `--preload-file` flag when we compile the `WASM` file. This will
    generate a `.data` file from the contents of the font directory. The web browser
    loads this data file into the virtual filesystem, which is accessed by the WebAssembly
    module. That means that the C code that we are writing will have access to this
    file as if it were accessing it inside a local filesystem:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，有三个预处理器定义。如果我们想快速更改消息或字体大小，我们将修改这前两行。第三个定义不太清楚。我们有一个叫做`FONT_FILE`的东西，它是一个看起来像是文件系统位置的字符串。这有点奇怪，因为WebAssembly无法访问本地文件系统。为了让WebAssembly模块访问fonts目录中的TrueType字体文件，我们将在编译`WASM`文件时使用`--preload-file`标志。这将从字体目录的内容生成一个`.data`文件。Web浏览器将此数据文件加载到虚拟文件系统中，WebAssembly模块可以访问该文件。这意味着我们编写的C代码将可以像访问本地文件系统一样访问此文件：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Initializing SDL
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化SDL
- en: 'Like in other targets for C/C++, the code begins execution from within the
    `main` function. We are going to start our `main` function by declaring some variables:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与C/C++的其他目标一样，代码从`main`函数开始执行。我们将通过声明一些变量来启动我们的`main`函数：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first two variables are the `SDL_Window` and `SDL_Renderer` objects. The
    `window` object would define the application window that we would be rendering
    into if we were writing code for a Windows, Mac, or Linux system. When we build
    for WebAssembly, there is a canvas in our HTML, but SDL still requires a `window`
    object pointer for initialization and cleanup. All calls to SDL use the `renderer`
    object to render images to the canvas.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个变量是`SDL_Window`和`SDL_Renderer`对象。`window`对象将定义应用程序窗口，如果我们为Windows、Mac或Linux系统编写代码，我们将渲染到该窗口中。当我们构建WebAssembly时，我们的HTML中有一个画布，但SDL仍然需要一个`window`对象指针来进行初始化和清理。所有对SDL的调用都使用`renderer`对象将图像渲染到画布上。
- en: The `SDL_Rect dest` variable is a rectangle that represents the destination
    where we will be rendering onto the canvas. We will render to the center of the
    320x200 canvas, so we will start with an `x` and `y` value of `160` and `100`.
    We do not yet know the width and height of the text we will render, so, at this
    point, we are going to set `w` and `h` to `0`. We will reset this value later,
    so, in theory, we could set it to anything.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`SDL_Rect dest`变量是一个表示我们将要渲染到画布上的目标的矩形。我们将渲染到320x200画布的中心，所以我们将从`x`和`y`值`160`和`100`开始。我们还不知道我们将要渲染的文本的宽度和高度，所以在这一点上，我们将`w`和`h`设置为`0`。我们稍后会重置这个值，所以理论上，我们可以将它设置为任何值。'
- en: The `TTF_Font *font` variable is a pointer to the `SDL_TTF` library's `font`
    object. Later, we will use that object to load up a font from the virtual filesystem
    and render that font to the `SDL_Texture *texture` pointer variable. The `SDL_Texture`
    variables are used by SDL to render sprites to the canvas.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`TTF_Font *font`变量是指向`SDL_TTF`库的`font`对象的指针。稍后，我们将使用该对象从虚拟文件系统加载字体，并将该字体渲染到`SDL_Texture
    *texture`指针变量。`SDL_Texture`变量由SDL用于将精灵渲染到画布上。'
- en: 'These next few lines are used to do some initialization work in SDL:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行用于在SDL中进行一些初始化工作：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `SDL_Init` function is called with a single flag initializing only the
    video subsystem. As a side note, I am not aware of any use case for SDL that does
    not require the video subsystem to be initialized. Many developers use SDL as
    an OpenGL/WebGL graphics rendering system; so, unless you have designed a game
    that is audio only, you should always pass in the `SDL_INIT_VIDEO` flag. If you
    would like to initialize additional SDL subsystems, you would pass in the flags
    for those subsystems using a Boolean or `|` operator, as shown in the following
    code snippet:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`SDL_Init`函数使用单个标志调用，仅初始化视频子系统。顺便说一句，我不知道SDL的任何用例不需要视频子系统初始化。许多开发人员将SDL用作OpenGL/WebGL图形渲染系统；因此，除非您设计了一个仅音频的游戏，否则应始终传入`SDL_INIT_VIDEO`标志。如果您想初始化其他SDL子系统，您将使用布尔或`|`运算符传入这些子系统的标志，如下面的代码片段所示：'
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If we use the preceding line, SDL would have also initialized the audio and
    haptic subsystems, but we do not need them right now, so we will not be making
    that change.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用上一行，SDL也会初始化音频和触觉子系统，但我们现在不需要它们，所以我们不会进行更改。
- en: The `TTF_Init();` function initializes our TrueType fonts, and `SDL_CreateWindowAndRenderer`
    returns a `window` and `renderer` object to us. We are passing `320` for the width
    of the canvas and `200` for the height. The third variable is the `window` flags.
    We pass `0` in for that parameter to indicate that we do not need any `window`
    flags. Because we are working with the SDL Emscripten port, we do not have control
    of the window, so these flags do not apply.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`TTF_Init();`函数初始化我们的TrueType字体，`SDL_CreateWindowAndRenderer`向我们返回`window`和`renderer`对象。我们传入`320`作为画布的宽度，`200`作为高度。第三个变量是`window`标志。我们传入`0`作为该参数，表示我们不需要任何`window`标志。因为我们正在使用SDL
    Emscripten端口，我们无法控制窗口，所以这些标志不适用。'
- en: Clearing the SDL renderer
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清除SDL渲染器
- en: 'After the initialization is complete, we will need to clear out the renderer.
    We can clear our renderer with any color we choose. To do this, we will make a
    call to the `SDL_RenderDrawColor` function:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化完成后，我们需要清除渲染器。我们可以用任何颜色清除我们的渲染器。为了做到这一点，我们将调用`SDL_RenderDrawColor`函数：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'That sets the drawing color for the renderer to black with full opacity. `0,
    0, 0` are the RGB color values, and `255` is the alpha opacity. These numbers
    all range from 0 to 255, where 255 is the full color on the color spectrum. We
    set this up so that when we call the `SDL_RenderClear` function in the next line,
    it will clear the renderer with the color black. If we wanted the color to clear
    red instead of black, we would have to modify the call in the following way:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为渲染器设置绘图颜色为完全不透明的黑色。`0, 0, 0`是RGB颜色值，`255`是alpha不透明度。这些数字的范围都是从0到255，其中255是颜色光谱上的全色。我们设置这样，这样当我们在下一行调用`SDL_RenderClear`函数时，它将用黑色清除渲染器。如果我们想要清除红色而不是黑色，我们需要修改以下调用方式：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That is not what we want, so we will not make that change. I just wanted to
    point out that we could clear the renderer with any color we like.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是我们想要的，所以我们不会做出这种改变。我只是想指出我们可以用任何颜色清除渲染器。
- en: Using the WebAssembly virtual filesystem
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用WebAssembly虚拟文件系统
- en: 'The next few lines will open up the TrueType font file in the virtual filesystem,
    and render it to `SDL_Texture`, which can be used to render to the canvas:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行将在虚拟文件系统中打开TrueType字体文件，并将其渲染到`SDL_Texture`，这可以用来渲染到画布：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the first line of the preceding code, we open the TrueType font by passing
    in the location of the file in the WebAssembly virtual filesystem, defined at
    the top of the program. We also need to specify the font's point size, which was
    defined as 16 at the top of the program as well. The next thing we do is create
    an `SDL_Color` variable that we will use for the font. This is a RGBA color, and
    we have all values set to 255 so that it is a fully opaque white color. After
    we have done this, we will need to render the text to a surface using the `TTF_RenderText_Blended`
    function. We pass the TrueType font we opened a few lines earlier, the `MESSAGE`,
    which was defined as `"HELLO SDL!"`, near the top of the program, and the font
    color, defined as white. Then, we will create a texture from our surface and free
    the surface memory we have just allocated. You should always free the memory from
    your surface pointers immediately after using them to create a texture, as once
    you have your textures the surfaces are no longer needed.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面代码的第一行中，我们通过在程序顶部定义的WebAssembly虚拟文件系统中传递文件的位置来打开TrueType字体。我们还需要指定字体的点大小，这也在程序顶部定义为16。接下来，我们创建一个`SDL_Color`变量，我们将用它来设置字体的颜色。这是一个RGBA颜色，我们将所有值设置为255，这样它就是完全不透明的白色。做完这些之后，我们需要使用`TTF_RenderText_Blended`函数将文本渲染到一个表面上。我们传递了几行前打开的TrueType字体，`MESSAGE`，在程序顶部定义为`"HELLO
    SDL!"`，以及定义为白色的字体颜色。然后，我们将从我们的表面创建一个纹理，并释放我们刚刚分配的表面内存。在使用表面指针创建纹理后，您应该立即释放表面指针的内存，因为一旦您有了纹理，表面就不再需要了。
- en: Rendering a texture to the HTML5 canvas
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将纹理渲染到HTML5画布
- en: After we load a font from the virtual filesystem and then render that font to
    the texture, we need to take that texture and copy it to a location in our renderer
    object. After we have done that, we will need to take that renderer and present
    its contents to the HTML5 canvas element.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从虚拟文件系统加载字体，然后将该字体渲染到纹理后，我们需要将该纹理复制到渲染器对象的位置。在完成这些操作后，我们需要将渲染器的内容呈现到HTML5画布元素。
- en: 'The following is the source code that renders the texture to the canvas:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将纹理渲染到画布的源代码：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The call to the `SDL_QueryTexture` function is used to retrieve the width and
    height of the texture. We need to use these values in the destination rectangle
    so that we render our texture to the canvas without changing its dimensions. After
    that call, the program knows the width and height of the texture, so it can use
    those values to modify the *x* and *y* variables of the destination rectangle
    so that it can center our text on the canvas. Because the *x* and *y* values of
    the `dest` (destination) rectangle specify the top-left corner of that rectangle,
    we need to subtract half the width and half the height of the rectangle to make
    sure that it is centered. The `SDL_RenderCopy` function then renders this texture
    to our rendering buffer and `SDL_RenderPresent` moves that entire buffer to the
    HTML5 canvas.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`SDL_QueryTexture`函数用于检索纹理的宽度和高度。我们需要使用这些值在目标矩形中，以便我们将纹理渲染到画布而不改变其尺寸。在那个调用之后，程序知道了纹理的宽度和高度，所以它可以使用这些值来修改目标矩形的*x*和*y*变量，以便它可以将我们的文本居中在画布上。因为`dest`（目标）矩形的*x*和*y*值指定了该矩形的左上角，我们需要减去矩形宽度的一半和矩形高度的一半，以确保它居中。然后`SDL_RenderCopy`函数将这个纹理渲染到我们的渲染缓冲区，`SDL_RenderPresent`将整个缓冲区移动到HTML5画布上。
- en: 'At this point, all that is left to do in the code is `return`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，代码中剩下的就是`return`：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Returning with a value of `EXIT_SUCCESS` tells our JavaScript glue code that
    everything went well when running this module.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以`EXIT_SUCCESS`的值返回告诉我们的JavaScript粘合代码，当运行这个模块时一切都进行得很好。
- en: Cleaning up SDL
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理SDL。
- en: 'Something that you may notice is missing from this code, that would be in a
    Windows or Linux version of an SDL application, is code that does some SDL clean
    up at the end of the program. If we exited an application in Windows, for instance,
    and did not do our cleanup work, we would be exiting without clearing out some
    of the memory allocated by SDL. If this were not a WebAssembly module, the following
    lines would be included at the end of the function:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到这段代码中缺少的内容，这在Windows或Linux版本的SDL应用程序中会有，那就是在程序结束时进行一些SDL清理的代码。例如，如果我们在Windows中退出应用程序，而没有进行清理工作，我们将退出而不清除SDL分配的一些内存。如果这不是一个WebAssembly模块，以下行将包含在函数的末尾：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Because we have not spent the time to make a game loop, we would want to delay
    the cleanup and exiting of the program by five seconds using a call to `SDL_Delay(5000)`,
    `5000` being the number of milliseconds to wait before doing the cleanup. We want
    to reiterate that, because we are compiling to WebAssembly, we do not want to
    clean up our SDL. Doing so has different effects on different browsers.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们还没有花时间制作游戏循环，我们希望通过调用`SDL_Delay(5000)`来延迟清理和退出程序五秒，`5000`是等待进行清理之前的毫秒数。我们要重申，因为我们正在编译为WebAssembly，我们不希望清理我们的SDL。这对不同的浏览器有不同的影响。
- en: When testing this code in Firefox, using the delay is unnecessary, because the
    web browser tab will stay open even after the WebAssembly module stops executing.
    However, the Chrome browser tab will display an error page as soon as SDL destroys
    the `window` object.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在Firefox中测试此代码时，使用延迟是不必要的，因为Web浏览器标签会在WebAssembly模块停止执行后保持打开。然而，Chrome浏览器标签在SDL销毁`window`对象后会显示错误页面。
- en: The `SDL_DestroyWindow` function would destroy the `window` object if this were
    a Windows environment. The `SDL_Quit` function terminates the SDL engine, and,
    finally, `return EXIT_SUCCESS;` exits successfully from the `main` function.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`SDL_DestroyWindow`函数会在Windows环境下销毁`window`对象。`SDL_Quit`函数终止SDL引擎，最后，`return
    EXIT_SUCCESS;`从`main`函数成功退出。'
- en: Compiling hello_sdl.html
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译hello_sdl.html
- en: 'Finally, we will compile and test our WebAssembly module using the Emscripten
    `emcc` compiler:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用Emscripten的`emcc`编译器编译和测试我们的WebAssembly模块：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It is important to remember that you must run WebAssembly apps using a web server,
    or with `emrun`. If you would like to run your WebAssembly app using `emrun`,
    you must compile it with the `--emrun` flag. The web browser requires a web server
    to stream the WebAssembly module. If you attempt to open an HTML page that uses
    WebAssembly in a browser directly from your hard drive, that WebAssembly module
    will not load.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，您必须使用Web服务器或`emrun`来运行WebAssembly应用程序。如果您想使用`emrun`来运行WebAssembly应用程序，您必须使用`--emrun`标志进行编译。Web浏览器需要Web服务器来流式传输WebAssembly模块。如果您尝试直接从硬盘驱动器在浏览器中打开使用WebAssembly的HTML页面，那么WebAssembly模块将无法加载。
- en: There are a few new flags we are using in this call to `emcc`, and we have temporarily
    left out the `--shell-file new_shell.html` flag that is used to generate a customized
    version of the template. If you would like to continue using `emrun` to test the
    app, you must include the `--emrun` flag, to run with the `emrun` command. If
    you are using a WebServer, such as Node.js, to serve the app, you may omit the
    `--emrun` flag from this point forward. If you like using `emrun`, continue to
    compile with that flag.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次对`emcc`的调用中，我们使用了一些新的标志，并临时省略了`--shell-file new_shell.html`标志，该标志用于生成模板的定制版本。如果您想继续使用`emrun`来测试应用程序，您必须包括`--emrun`标志，以使用`emrun`命令运行。如果您使用Node.js等Web服务器来提供应用程序，则可以从现在开始省略`--emrun`标志。如果您喜欢使用`emrun`，请继续使用该标志进行编译。
- en: 'We have added the `--preload-file` font flag to allow us to create a virtual
    filesystem contained in the `hello_sdl.data` file. This file holds our TrueType
    font. The application uses the core SDL library and the additional SDL TrueType
    font module, so we have included the following flag, `-s USE_SDL=2 -s USE_SDL_TTF=2`,
    to allow calls to `SDL` and `SDL_ttf`. If everything went well in your compile,
    this is what the new `hello_sdl.html` file will look like when you bring it up
    in a browser:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了`--preload-file`字体标志，以便我们可以创建包含在`hello_sdl.data`文件中的虚拟文件系统。这个文件保存了我们的TrueType字体。应用程序使用了核心SDL库和额外的SDL
    TrueType字体模块，因此我们包含了以下标志`-s USE_SDL=2 -s USE_SDL_TTF=2`，以允许调用`SDL`和`SDL_ttf`。如果您的编译顺利进行，当您在浏览器中打开新的`hello_sdl.html`文件时，它将会是这个样子：
- en: '![](img/261996ad-2fb3-49af-9505-dead70bfb861.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/261996ad-2fb3-49af-9505-dead70bfb861.png)'
- en: 'Figure 4.1: Hello SDL! app screenshot'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：Hello SDL!应用程序截图
- en: In the next section, we will learn how to use SDL to render a sprite to the
    HTML5 canvas.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用SDL将精灵渲染到HTML5画布上。
- en: Render a sprite to the canvas
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将精灵渲染到画布上
- en: Now that we have learned how to render text to our HTML canvas element using
    SDL and Emscripten, we can take the next step and learn how to render sprites.
    The code used to render a sprite to the canvas is quite similar to the code that
    we used to render a TrueType font. We will still be using the virtual filesystem
    to generate a data file that contains the sprites we are using, but we will need
    a new SDL library to do this. We no longer need `SDL2_ttf` to load a TrueType
    font and render it to a texture. Instead, we need `SDL2_image`. We will show you
    how to change our call to `emcc` to include this new library a little later.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何使用SDL和Emscripten将文本渲染到HTML画布元素，我们可以迈出下一步，学习如何渲染精灵。用于将精灵渲染到画布的代码与我们用于渲染TrueType字体的代码非常相似。我们仍然使用虚拟文件系统来生成包含我们使用的精灵的数据文件，但是我们需要一个新的SDL库来实现这一点。我们不再需要`SDL2_ttf`来加载TrueType字体并将其渲染到纹理。相反，我们需要`SDL2_image`。稍后我们将向您展示如何更改我们对`emcc`的调用以包含这个新库。
- en: 'First, let''s take a look at the new version of the SDL code that renders an
    image to our HTML canvas element instead of the text we rendered in the previous
    section:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看一下新版本的SDL代码，它将图像渲染到我们的HTML画布元素上，而不是我们在上一节中渲染的文本：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This code is similar to the code we wrote in the last section, *HTML5 and WebAssembly*,
    for the *HELLO SDL!* application. Instead of using the `SDL2_ttf` module, we are
    using the `SDL2_image` module. Because of this, we will need to include the `SDL2/SDL_image.h`
    header file. We will also need to load a sprite file from the `sprites` directory,
    which we will add to the WebAssembly virtual filesystem:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码类似于我们在上一节*HTML5和WebAssembly*中编写的代码，用于*HELLO SDL!*应用程序。我们使用的是`SDL2_image`模块，而不是`SDL2_ttf`模块。因此，我们需要包含`SDL2/SDL_image.h`头文件。我们还需要从`sprites`目录加载一个精灵文件，并将其添加到WebAssembly虚拟文件系统中：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Below the call to `IMG_Load`, we add an error check that will let us know what
    went wrong if the file fails to load. Aside from that, the code is mostly the
    same. If we are successful, the canvas will display our 16x16 pixel image of the
    Starship Franchise:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`IMG_Load`之后，我们添加了一个错误检查，以便在文件加载失败时让我们知道出了什么问题。除此之外，代码大部分都是相同的。如果成功，画布将显示我们的16x16像素的Starship
    Franchise图像：
- en: '![](img/e3515281-4ae7-471c-ba8c-b98e64540058.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3515281-4ae7-471c-ba8c-b98e64540058.png)'
- en: 'Figure 4.2: Franchise1.png'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：Franchise1.png
- en: In the next section, we will learn how to use SDL to animate a sprite on our
    canvas.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用SDL在画布上制作动画精灵。
- en: Animating a sprite
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画精灵
- en: 'In this section, we will learn how to make a quick and dirty little animation
    in our SDL application. That will not be the way we do animations in our final
    game, but it will give you an idea of how we could create animations from within
    SDL by swapping out textures over time. I am going to present the code to animate
    a sprite broken into two parts. The first part includes our preprocessor macros,
    global variables, and the `show_animation` function:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在SDL应用程序中制作一个快速而简单的动画。这不是我们在最终游戏中做动画的方式，但它会让您了解我们如何通过在SDL内部交换纹理来随时间创建动画。我将呈现分解为两部分的代码来动画精灵。第一部分包括我们的预处理宏、全局变量和`show_animation`函数：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After we define our `show_animation` function, we will need to define our module''s
    `main` function:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了`show_animation`函数之后，我们需要定义模块的`main`函数：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There is a lot to unpack here. There are much more efficient ways to do this
    animation, but what we are doing here takes what we have already done and adds
    to it. In earlier versions of the code, we rendered a single frame to the canvas,
    then exited the WebAssembly module. That works well enough if your goal is to
    render something static to the canvas and never change it. If you are writing
    a game, however, you need to be able to animate your sprites and move them around
    the canvas. Here, we run into a problem that we do not have if we are compiling
    our C++ code for any target other than WebAssembly. Games typically run in a loop
    and are directly responsible for rendering to the screen. WebAssembly runs inside
    of the JavaScript engine in your web browser. The WebAssembly module itself cannot
    update our canvas. Emscripten uses the JavaScript glue code to update the HTML
    canvas indirectly from the SDL API. However, if the WebAssembly runs in a loop,
    and uses that loop to animate our sprite through SDL, the WebAssembly module never
    lets go of the thread it is in, and the JavaScript never has an opportunity to
    update the canvas. Because of this, we can not put the game loop inside the `main`
    function. Instead, we must create a different function, and use Emscripten to
    set up the JavaScript glue code to call that function every time the browser renders
    a frame. The function we will use to do that is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多内容需要解释。有更高效的方法来做这个动画，但我们在这里所做的是基于我们已经完成的工作并进行扩展。在代码的早期版本中，我们将单个帧呈现到画布上，然后退出WebAssembly模块。如果您的目标是将静态内容呈现到画布并永远不更改它，那么这样做就足够了。但是，如果您正在编写游戏，则需要能够对精灵进行动画处理并在画布上移动它们。在这里，我们遇到了一个问题，如果我们将C++代码编译为WebAssembly以外的任何目标，我们就不会遇到这个问题。游戏通常在循环中运行，并直接负责向屏幕渲染。WebAssembly在Web浏览器的JavaScript引擎内运行。WebAssembly模块本身无法更新我们的画布。Emscripten使用JavaScript粘合代码间接从SDL
    API更新HTML画布。但是，如果WebAssembly在循环中运行，并使用该循环通过SDL来对我们的精灵进行动画处理，那么WebAssembly模块永远不会释放它所在的线程，并且JavaScript永远没有机会更新画布。因此，我们不能将游戏循环放在`main`函数中。相反，我们必须创建一个不同的函数，并使用Emscripten来设置JavaScript粘合代码，以便在每次浏览器渲染帧时调用该函数。我们将使用的函数如下：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first parameter we will pass to `emscripten_set_main_loop` is `show_animation`.
    This is the name of a function we defined near the top of the code. I will talk
    about the specifics of the `show_animation` function a little later. For now,
    it is enough to know that this is the function called every time the browser renders
    a new frame on the canvas.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将传递给`emscripten_set_main_loop`的第一个参数是`show_animation`。这是我们在代码顶部附近定义的一个函数的名称。稍后我会谈论`show_animation`函数的具体内容。现在，知道这是每次浏览器在画布上渲染新帧时调用的函数就足够了。
- en: The second parameter of `emscripten_set_main_loop` is **frames per second**
    (**FPS**). If you want to set the FPS of your game to a fixed rate, you can do
    so by passing the target frame rate into the function here. If you pass in `0`,
    this tells `emscripten_set_main_loop` to run with the highest frame rate it can.
    As a general rule, you want your game to run with the highest frame rate possible,
    so passing in `0` is usually the best thing to do. If you pass in a value higher
    than what the computer is capable of rendering, it will merely render as fast
    as it is able anyway, so this value only puts a cap on your FPS.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`emscripten_set_main_loop`的第二个参数是**每秒帧数**（**FPS**）。如果要将游戏的FPS设置为固定速率，可以通过在此处将目标帧速率传递给函数来实现。如果传入`0`，这告诉`emscripten_set_main_loop`以尽可能高的帧速率运行。通常情况下，您希望游戏以尽可能高的帧速率运行，因此传入`0`通常是最好的做法。如果传入的值高于计算机能够渲染的速度，它将以其能够的速度渲染，因此此值仅对FPS设置了上限。'
- en: The third parameter we pass in is `simulate_infinite_loop`. Passing in `0` is
    equivalent to passing a `false` value. If the value of this parameter is `true`,
    it forces the module to re-enter through the `main` function for every frame.
    I am not sure what the use case for this is. I would recommend keeping it at `0`
    and separating your game loop into another function as we have done here.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递的第三个参数是`simulate_infinite_loop`。传入`0`等同于传递`false`值。如果此参数的值为`true`，它会强制模块在每帧通过`main`函数重新进入。我不确定这个用例是什么。我建议将其保持为`0`，并将游戏循环分离到另一个函数中，就像我们在这里做的那样。
- en: 'Before calling `emscripten_set_main_loop`, we will set up an array of SDL texture
    surface pointers:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`emscripten_set_main_loop`之前，我们将设置一个SDL纹理表面指针的数组：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This loop loads `FranchiseExplosion1.png` through `FranchiseExplosion7.png`
    into an array of SDL textures and stores them into a different array, called `anim`.
    That is the array we will loop through later in the `show_animation` function.
    There are more efficient ways to do this using sprite sheets, and by modifying
    the destination rectangle. We will discuss those techniques for rendering animated
    sprites in later chapters.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环将`FranchiseExplosion1.png`到`FranchiseExplosion7.png`加载到一个SDL纹理数组中，并将它们存储到一个名为`anim`的不同数组中。这是我们稍后将在`show_animation`函数中循环的数组。有更有效的方法可以使用精灵表，并通过修改目标矩形来实现这一点。我们将在后面的章节中讨论渲染动画精灵的这些技术。
- en: 'Near the top of the code, we defined the `show_animation` function, called
    every rendered frame:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的顶部附近，我们定义了`show_animation`函数，每渲染一帧就调用一次：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This function is designed to wait a certain number of milliseconds, then update
    the texture we are rendering. I have created a seven frame animation that blows
    up the Starship Franchise in a little pixelated explosion. The reason we need
    a short wait in this loop is that our refresh rate is probably 60+ FPS, and if
    we render a new frame of our animation every time `show_animation` is called,
    the entire animation would run in about 1/10 of a second. Classic arcade games
    frequently flipped through their animation sequences at a much slower rate than
    the games frame rate. Many classic **Nintendo Entertainment System** (**NES**)
    games used two-stage animations where the animation would alternate sprites every
    few hundred milliseconds, even though the NES ran with a frame rate of 60 FPS.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的设计是等待一定的毫秒数，然后更新我们正在渲染的纹理。我创建了一个七帧动画，让星际特许经营号在一个小像素化的爆炸中爆炸。在这个循环中我们需要短暂等待的原因是，我们的刷新率可能是60+
    FPS，如果我们每次调用`show_animation`时都渲染一个新的动画帧，整个动画将在大约1/10秒内运行完毕。经典的街机游戏经常以比游戏帧率慢得多的速度翻转它们的动画序列。许多经典的**任天堂娱乐系统**（**NES**）游戏使用两阶段动画，其中动画会在几百毫秒内交替精灵，尽管NES的帧率是60
    FPS。
- en: The core of this function is similar to the single texture render we created
    earlier. The primary difference is that we wait a fixed number of milliseconds
    before changing the frame of our animation by incrementing the `current_frame`
    variable. That takes us through all seven stages of our animation in a little
    less than a second.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的核心与我们之前创建的单纹理渲染类似。主要的区别是在改变动画帧之前我们等待固定的毫秒数，通过递增`current_frame`变量来遍历我们动画的所有七个阶段，这需要不到一秒的时间。
- en: Moving the sprite
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动精灵
- en: 'Now that we have learned how to animate our sprite in a frame-by-frame animation,
    we will learn how to move a sprite around on our canvas. I want to keep our spaceship
    animated, but I would prefer it not run in an `explosion` loop. In our `sprites`
    folder, I have included a simple four-stage animation that causes our ship''s
    engines to flicker. The source code is quite lengthy, so I will introduce it in
    three parts: a preprocessor and global variable section, the `show_animation`
    function, and the `main` function.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何以逐帧动画的方式为我们的精灵添加动画，我们将学习如何在画布上移动精灵。我希望保持我们的飞船动画，但我希望它不要在`爆炸`循环中运行。在我们的`sprites`文件夹中，我包含了一个简单的四阶段动画，可以使我们飞船的引擎闪烁。源代码非常长，所以我将分三部分介绍它：预处理和全局变量部分，`show_animation`函数和`main`函数。
- en: 'Here is the code that defines the preprocessor directives and the global variables
    at the beginning of our `cpp` file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`cpp`文件开头定义的预处理指令和全局变量的代码：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Following the preprocessor directives and global variables, our `cpp` file
    contains a `show_animation` function that defines our game loop. Here is the code
    for our `show_animation` function:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在预处理指令和全局变量之后，我们的`cpp`文件包含了一个定义游戏循环的`show_animation`函数。以下是我们`show_animation`函数的代码：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The final part of our `cpp` file defines the `main` function. That is the initialization
    code in our WebAssembly module:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`cpp`文件的最后部分定义了`main`函数。这是我们的WebAssembly模块中的初始化代码：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This code is similar to our `sprite_animation` code. There are only a few modifications,
    and most of them are within the `show_animation` function:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码类似于我们的`sprite_animation`代码。只有一些修改，大部分在`show_animation`函数中：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We advance our frame whenever the value in `ms`, which tracks the milliseconds
    since the last frame change, exceeds `ms_per_frame`, which we set to a value of
    `100`. Because the spaceship is moving, we still need to update our canvas every
    frame with the new spaceship position. We do this by modifying the `dest.y` value,
    which tells SDL where to render our spaceship on the y-axis. We subtract one from
    the `dest.y` variable every frame to move the spaceship up. We also perform a
    check to see whether this value has become smaller than `-16`. Because the sprite
    is 16-pixels high, this will happen when the sprite has moved entirely off the
    screen at the top. If this is the case, we need to move the sprite back down to
    the bottom of the game screen by setting the `y` value back to `200`. In an actual
    game, to tie our movement directly to the frame rate like this would be a bad
    idea, but for this demonstration, it will be fine.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当`ms`中的值超过`ms_per_frame`时，我们就会推进我们的帧，`ms`跟踪自上一帧更改以来的毫秒数，我们将`ms_per_frame`设置为`100`。因为飞船在移动，我们仍然需要在每一帧更新我们的画布以显示新的飞船位置。我们通过修改`dest.y`的值来实现这一点，这告诉SDL在y轴上渲染我们的飞船。我们每一帧都从`dest.y`变量中减去1，以将飞船向上移动。我们还进行了一个检查，看看这个值是否变小到小于`-16`。因为精灵高度为16像素，当精灵完全移出屏幕顶部时，这种情况就会发生。如果是这种情况，我们需要通过将`y`值设置回`200`来将精灵移回游戏屏幕的底部。在实际游戏中，像这样直接将我们的移动与帧速率绑定在一起是一个坏主意，但是对于这个演示来说，这样做是可以的。
- en: Compiling sprite.html
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译sprite.html
- en: 'We can now compile our sprite WebAssembly app by using the `emcc` command.
    You will need the `sprites` folder from the `Chapter02` folder on GitHub. After
    you have downloaded the `sprites` folder and placed it in your project''s folder,
    you can compile the app with the following command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`emcc`命令来编译我们的精灵WebAssembly应用程序。您需要从GitHub的`Chapter02`文件夹中获取`sprites`文件夹。在您下载了`sprites`文件夹并将其放在项目文件夹中之后，您可以使用以下命令编译应用程序：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It is important to remember that the app must be run from a web server, or using
    `emrun`. If you do not run the app from a web server, or use `emrun`, you will
    receive a variety of errors when the JavaScript glue code attempts to download
    the WASM and data files. You should also know that IIS requires additional configuration
    in order to set the proper MIME types for the `.wasm` and `.data` file extensions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，应用程序必须从Web服务器上运行，或者使用`emrun`。如果您不从Web服务器上运行应用程序，或者使用`emrun`，当JavaScript粘合代码尝试下载WASM和数据文件时，您将收到各种错误。您还应该知道，为了设置`.wasm`和`.data`文件扩展名的正确MIME类型，IIS需要额外的配置。
- en: We are still using the `--preload-file` flag, however, this time we are passing
    in the `sprites` folder instead of the `fonts` folder. We will continue to use
    the `-s USE_SDL=2` flag and will be adding the `-s USE_SDL_IMAGE=2` flag, which
    will allow us to use images with SDL that are an alternative to the `.bmp` file
    format.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然使用`--preload-file`标志，但是这次我们传递的是`sprites`文件夹，而不是`fonts`文件夹。我们将继续使用`-s USE_SDL=2`标志，并将添加`-s
    USE_SDL_IMAGE=2`标志，这将允许我们在SDL中使用图像，这是`.bmp`文件格式的替代品。
- en: 'To tell `SDL_IMAGE` which file format to use, we pass in the `png` format using
    the following `-s SDL2_IMAGE_FORMATS=["png"]` flag:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了告诉`SDL_IMAGE`要使用哪种文件格式，我们使用以下`-s SDL2_IMAGE_FORMATS=["png"]`标志传递`png`格式：
- en: '![](img/3bd87aeb-0bf2-46f2-95ba-58180ce3f054.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3bd87aeb-0bf2-46f2-95ba-58180ce3f054.png)'
- en: 'Figure 4.3: Screenshot of sprite_move.html'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：sprite_move.html的屏幕截图
- en: Summary
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, I have introduced you to SDL and its library of modules that
    are available for use within WebAssembly. We have learned about the WebAssembly
    virtual filesystem, and how Emscripten creates the `.data` files for access within
    the WebAssembly virtual filesystem. I have taught you how to use SDL to render
    images and fonts to the HTML canvas. Finally, we have learned how to use SDL to
    create a simple animation in our game.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我向您介绍了SDL及其可在WebAssembly中使用的模块库。我们了解了WebAssembly虚拟文件系统，以及Emscripten如何创建`.data`文件以便在WebAssembly虚拟文件系统中访问。我教会了您如何使用SDL将图像和字体渲染到HTML画布上。最后，我们学会了如何使用SDL在游戏中创建简单的动画。
- en: In the next chapter, we will learn how to use keyboard input to move game objects
    on the canvas.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用键盘输入来移动画布上的游戏对象。
