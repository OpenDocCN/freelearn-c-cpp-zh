["```cpp\n<div class=\"container\">\n<div class=\"empty_box\">&nbsp;</div><br/>\n<span class=\"label\">min start scale:</span>\n<input type=\"number\" id=\"min_starting_scale\" max=\"9.9\" min=\"0.1\" step=\"0.1\" value=\"1.0\" class=\"em_input\"><br/>\n<span class=\"label\">max start scale:</span>\n<input type=\"number\" id=\"max_starting_scale\" max=\"10.0\" min=\"0.2\" step=\"0.1\" value=\"2.0\" class=\"em_input\"><br/>\n<span class=\"label\">min end scale:</span>\n<input type=\"number\" id=\"min_end_scale\" max=\"9.9\" min=\"0.1\" step=\"0.1\" value=\"1.0\" class=\"em_input\">\n<br/>\n<span class=\"label\">max end scale:</span>\n<input type=\"number\" id=\"max_end_scale\" max=\"10.0\" min=\"0.2\" step=\"0.1\" value=\"2.0\" class=\"em_input\">\n<br/>\n<span class=\"label\">start color:</span>\n<input type=\"color\" id=\"start_color\" value=\"#ffffff\" class=\"color_input\"><br/>\n<span class=\"label\">end color:</span>\n<input type=\"color\" id=\"end_color\" value=\"#ffffff\" class=\"color_input\"><br/>\n<span class=\"label\">burst time pct:</span>\n<input type=\"number\" id=\"burst_time\" max=\"1.0\" min=\"0.0\" step=\"0.05\" value=\"0.0\" class=\"em_input\">\n<br/>\n<span class=\"label\">burst particles:</span>\n<input type=\"number\" id=\"burst_particles\" max=\"100\" min=\"0\" step=\"1\" value=\"0\" class=\"em_input\">\n<br/>\n<label class=\"ccontainer\"><span class=\"label\">loop:</span>\n    <input type=\"checkbox\" id=\"loop\" checked=\"checked\">\n    <span class=\"checkmark\"></span>\n</label>\n<br/>\n<label class=\"ccontainer\"><span class=\"label\">align rotation:</span>\n    <input type=\"checkbox\" id=\"align_rotation\" checked=\"checked\">\n    <span class=\"checkmark\"></span>\n</label>\n<br/>\n<span class=\"label\">emit time ms:</span>\n<input type=\"number\" id=\"emit_time\" max=\"10000\" min=\"100\" step=\"100\" value=\"1000\" class=\"em_input\">\n<br/>\n<span class=\"label\">animation frames:</span>\n<input type=\"number\" id=\"animation_frames\" max=\"64\" min=\"1\" step=\"1\" value=\"1\" class=\"em_input\">\n<br/>\n<div class=\"input_box\">\n<button id=\"update_btn\" class=\"em_button\" onclick=\"UpdateClick()\">Update Emitter</button>\n</div>\n</div>\n```", "```cpp\n<span class=\"label\">min start scale:</span>\n<input type=\"number\" id=\"min_starting_scale\" max=\"9.9\" min=\"0.1\" step=\"0.1\" value=\"1.0\" class=\"em_input\"><br/>\n<span class=\"label\">max start scale:</span>\n<input type=\"number\" id=\"max_starting_scale\" max=\"10.0\" min=\"0.2\" step=\"0.1\" value=\"2.0\" class=\"em_input\"><br/>\n<span class=\"label\">min end scale:</span>\n<input type=\"number\" id=\"min_end_scale\" max=\"9.9\" min=\"0.1\" step=\"0.1\" value=\"1.0\" class=\"em_input\">\n<br/>\n<span class=\"label\">max end scale:</span>\n<input type=\"number\" id=\"max_end_scale\" max=\"10.0\" min=\"0.2\" step=\"0.1\" value=\"2.0\" class=\"em_input\">\n<br/>\n```", "```cpp\n<span class=\"label\">start color:</span>\n<input type=\"color\" id=\"start_color\" value=\"#ffffff\" class=\"color_input\"><br/>\n<span class=\"label\">end color:</span>\n<input type=\"color\" id=\"end_color\" value=\"#ffffff\" class=\"color_input\"><br/>\n```", "```cpp\n<span class=\"label\">burst time pct:</span>\n<input type=\"number\" id=\"burst_time\" max=\"1.0\" min=\"0.0\" step=\"0.05\" value=\"0.0\" class=\"em_input\">\n<br/>\n<span class=\"label\">burst particles:</span>\n<input type=\"number\" id=\"burst_particles\" max=\"100\" min=\"0\" step=\"1\" value=\"0\" class=\"em_input\">\n<br/>\n```", "```cpp\n<label class=\"ccontainer\"><span class=\"label\">loop:</span>\n<input type=\"checkbox\" id=\"loop\" checked=\"checked\">\n<span class=\"checkmark\"></span>\n</label>\n<br/>\n```", "```cpp\n<label class=\"ccontainer\"><span class=\"label\">align rotation:</span>\n <input type=\"checkbox\" id=\"align_rotation\" checked=\"checked\">\n <span class=\"checkmark\"></span>\n </label>\n <br/>\n```", "```cpp\n<span class=\"label\">emit time ms:</span>\n<input type=\"number\" id=\"emit_time\" max=\"10000\" min=\"100\" step=\"100\" value=\"1000\" class=\"em_input\"><br/>\n```", "```cpp\n<span class=\"label\">animation frames:</span>\n<input type=\"number\" id=\"animation_frames\" max=\"64\" min=\"1\" step=\"1\" value=\"1\" class=\"em_input\"><br/>\n```", "```cpp\nfunction UpdateClick() {\n    if( ready == false || image_added == false ) {\n        return;\n    }\n    var max_particles = Number(document.getElementById\n                        (\"max_particles\").value);\n    var min_angle = Number(document.getElementById\n                    (\"min_angle\").value) / 180 * Math.PI;\n    var max_angle = Number(document.getElementById\n                    (\"max_angle\").value) / 180 * Math.PI\n    var particle_lifetime = Number(document.getElementById\n                            (\"lifetime\").value);\n    var acceleration = Number(document.getElementById\n                       (\"acceleration\").value);\n    var alpha_fade = Boolean(document.getElementById\n                     (\"alpha_fade\").checked);\n    var emission_rate = Number(document.getElementById\n                        (\"emission_rate\").value);\n    var x_pos = Number(document.getElementById\n                (\"x_pos\").value);\n    var y_pos = Number(document.getElementById\n                (\"y_pos\").value);\n    var radius = Number(document.getElementById\n                 (\"radius\").value);\n    var min_starting_velocity = Number(document.getElementById\n                                (\"min_starting_vel\").value);\n    var max_starting_velocity = Number(document.getElementById\n                                (\"max_starting_vel\").value);\n\n    /* NEW INPUT PARAMETERS */\n    var min_start_scale = Number(document.getElementById\n                          (\"min_starting_scale\").value);\n    var max_start_scale = Number(document.getElementById\n                          (\"max_starting_scale\").value);\n    var min_end_scale = Number(document.getElementById\n                        (\"min_end_scale\").value);\n    var max_end_scale = Number(document.getElementById\n                        (\"max_end_scale\").value);\n    var start_color_str = document.getElementById\n                          (\"start_color\").value.substr(1, 7);\n    var start_color = parseInt(start_color_str, 16);\n    var end_color_str = document.getElementById\n                        (\"end_color\").value.substr(1, 7);\n    var end_color = parseInt(end_color_str, 16);\n    var burst_time = Number(document.getElementById\n                     (\"burst_time\").value);\n    var burst_particles = Number(document.getElementById\n                          (\"burst_particles\").value);\n    var loop = Boolean(document.getElementById\n               (\"loop\").checked);\n    var align_rotation = Boolean(document.getElementById\n                         (\"align_rotation\").checked);\n    var emit_time = Number(document.getElementById\n                    (\"emit_time\").value);\n    var animation_frames = Number(document.getElementById\n                           (\"animation_frames\").value);\n\n    Module.ccall('update_emitter', 'undefined', [\"number\", \"number\", \n    \"number\", \"number\", \"number\", \"bool\", \"number\", \"number\",\n    \"number\", \"number\", \"number\", \"number\",\n    /* new parameters */\n    \"number\", \"number\", \"number\", \"number\", \"number\", \"number\", \n    \"number\", \"number\", \"bool\", \"bool\", \"number\"],\n    [max_particles, min_angle, max_angle, particle_lifetime, \n    acceleration, alpha_fade, min_starting_velocity, \n    max_starting_velocity, emission_rate, x_pos, y_pos, radius,\n    /* new parameters */\n    min_start_scale, max_start_scale, min_end_scale, max_end_scale,\n    start_color, end_color, burst_time, burst_particles,    \n    loop, align_rotation, emit_time, animation_frames]);\n    }\n```", "```cpp\nvar min_start_scale = Number(document.getElementById\n                      (\"min_starting_scale\").value);\nvar max_start_scale = Number(document.getElementById\n                      (\"max_starting_scale\").value);\nvar min_end_scale = Number(document.getElementById\n                    (\"min_end_scale\").value);\nvar max_end_scale = Number(document.getElementById\n                    (\"max_end_scale\").value);\n```", "```cpp\nvar start_color_str = document.getElementById\n                      (\"start_color\").value.substr(1, 7);\n```", "```cpp\nvar start_color = parseInt(start_color_str, 16);\n```", "```cpp\nvar end_color_str = document.getElementById\n                    (\"end_color\").value.substr(1, 7);\nvar end_color = parseInt(end_color_str, 16);\n```", "```cpp\nvar burst_time = Number(document.getElementById\n                 (\"burst_time\").value);\nvar burst_particles = Number(document.getElementById\n                      (\"burst_particles\").value);\nvar loop = Boolean(document.getElementById\n           (\"loop\").checked);\nvar align_rotation = Boolean(document.getElementById\n                     (\"align_rotation\").checked);\nvar emit_time = Number(document.getElementById\n                (\"emit_time\").value);\nvar animation_frames = Number(document.getElementById\n                       (\"animation_frames\").value);\n```", "```cpp\nModule.ccall('update_emitter', 'undefined', [\"number\", \"number\",                                       \"number\", \"number\", \"number\", \"bool\",\n                                  \"number\", \"number\", \"number\",                                           \"number\", \"number\",\"number\",\n                                            /* new parameters */\n                                             \"number\", \"number\",\n                                             \"number\", \"number\",\n                                             \"number\", \"number\",\n                                             \"number\", \"number\",\n                                             \"bool\", \"bool\", \"number\"],\n                                            [max_particles, min_angle, \n                                             max_angle,\n                                             particle_lifetime,         \n                                             acceleration, alpha_fade,\n                                             min_starting_velocity, \n                                             max_starting_velocity,\n                                             emission_rate, x_pos, \n                                             y_pos, radius,\n                                            /* new parameters */\n                                             min_start_scale,   \n                                             max_start_scale,\n                                             min_end_scale, \n                                             max_end_scale,\n                                             start_color, end_color,\n                                             burst_time, \n                                             burst_particles,\n                                             loop, align_rotation, \n                                             emit_time,\n                                             animation_frames\n                                         ]);\n```", "```cpp\nfunction handleFiles(files) {\n    var file_count = 0;\n    for (var i = 0; i < files.length; i++) {\n        if (files[i].type.match(/image.png/)) {\n            var file = files[i]; \n            var file_name = file.name;\n            var fr = new FileReader();\n            fr.onload = function (file) {\n                var data = new Uint8Array(fr.result);\n                Module.FS_createDataFile('/', file_name, data, true, true, \n                true);\n                var max_particles = Number(document.getElementById\n                                    (\"max_particles\").value);\n                var min_angle = Number(document.getElementById\n                                (\"min_angle\").value) / 180 * Math.PI;\n                var max_angle = Number(document.getElementById\n                                (\"max_angle\").value) / 180 * Math.PI\n                var particle_lifetime = Number(document.getElementById\n                                        (\"lifetime\").value);\n                var acceleration = Number(document.getElementById\n                                   (\"acceleration\").value);\n                var alpha_fade = Boolean(document.getElementById\n                                 (\"alpha_fade\").checked);\n                var emission_rate = Number(document.getElementById\n                                    (\"emission_rate\").value);\n                var x_pos = Number(document.getElementById\n                                  (\"x_pos\").value);\n                var y_pos = Number(document.getElementById\n                                  (\"y_pos\").value);\n                var radius = Number(document.getElementById\n                                   (\"radius\").value);\n                var min_starting_velocity = Number(document.getElementById\n                                            (\"min_starting_vel\").value);\n                var max_starting_velocity = Number(document.getElementById\n                                            (\"max_starting_vel\").value);\n\n                /* NEW INPUT PARAMETERS */\n                var min_start_scale = Number(document.getElementById\n                                      (\"min_starting_scale\").value);\n                var max_start_scale = Number(document.getElementById\n                                      (\"max_starting_scale\").value);\n                var min_end_scale = Number(document.getElementById\n                                    (\"min_end_scale\").value);\n                var max_end_scale = Number(document.getElementById\n                                    (\"max_end_scale\").value);\n                var start_color_str = document.getElementById\n                                     (\"start_color\").value.substr(1, 7);\n                var start_color = parseInt(start_color_str, 16);\n                var end_color_str = document.getElementById\n                                    (\"end_color\").value.substr(1, 7);\n                var end_color = parseInt(end_color_str, 16);\n                var burst_time = Number(document.getElementById\n                                 (\"burst_time\").value);\n                var burst_particles = Number(document.getElementById\n                                      (\"burst_particles\").value);\n                var loop = Boolean(document.getElementById\n                           (\"loop\").checked);\n                var align_rotation = Boolean(document.getElementById \n                                     (\"align_rotation\").checked);\n                var emit_time = Number(document.getElementById\n                                (\"emit_time\").value);\n                var animation_frames = Number(document.getElementById\n                                       (\"animation_frames\").value);\n\n                Module.ccall('add_emitter', 'undefined', \n                [\"string\",\"number\", \"number\", \"number\", \n                \"number\",\"number\",\"bool\",\"number\",\"number\",\n                \"number\", \"number\", \"number\",\"number\", \n                /* new parameters */ \n                \"number\", \"number\", \"number\",\n                \"number\", \"number\", \"number\", \"number\", \n                \"number\",\"bool\", \"bool\", \"number\"],\n                    file_name,max_particles,min_angle,max_angle,\n                    particle_lifetime,acceleration,alpha_fade,\n                    min_starting_velocity,max_starting_velocity,\n                    emission_rate, x_pos,y_pos,radius,\n                    /* new parameters */ \n                    min_start_scale,max_start_scale,min_end_scale, \n                    max_end_scale,start_color,end_color,\n                    burst_time,burst_particles,loop,\n                    align_rotation,emit_time,animation_frames ]);\n                image_added = true;\n            };\n            fr.readAsArrayBuffer(files[i]); }}}\n```", "```cpp\nclass Particle {\n    public:\n        bool m_active;\n        bool m_alpha_fade;\n        bool m_color_mod;\n        bool m_align_rotation;\n        float m_rotation;\n\n        Uint8 m_start_red;\n        Uint8 m_start_green;\n        Uint8 m_start_blue;\n\n        Uint8 m_end_red;\n        Uint8 m_end_green;\n        Uint8 m_end_blue;\n\n        Uint8 m_current_red;\n        Uint8 m_current_green;\n        Uint8 m_current_blue;\n\n        SDL_Texture *m_sprite_texture;\n        int m_ttl;\n\n        Uint32 m_life_time;\n        Uint32 m_animation_frames;\n        Uint32 m_current_frame;\n        Uint32 m_next_frame_ms;\n\n        float m_acceleration;\n        float m_alpha;\n        float m_width;\n        float m_height;\n        float m_start_scale;\n        float m_end_scale;\n        float m_current_scale;\n\n        Point m_position;\n        Point m_velocity;\n\n        SDL_Rect m_dest = {.x = 0, .y = 0, .w = 0, .h = 0 };\n        SDL_Rect m_src = {.x = 0, .y = 0, .w = 0, .h = 0 };\n\n        Particle( SDL_Texture *sprite, Uint32 life_time, float \n        acceleration,\n                    bool alpha_fade, int width, int height, bool \n                    align_rotation,\n                    Uint32 start_color,\n                    Uint32 end_color,\n                    Uint32 animation_frames );\n        void Update( Uint32 life_time, float acceleration,\n                     bool alpha_fade, bool align_rotation,\n                     Uint32 start_color, Uint32 end_color,\n                     Uint32 animation_frames );\n\n        void Spawn( float x, float y, float velocity_x, float \n                velocity_y,\n                    float start_scale, float end_scale, float rotation );\n\n        void Move();\n        void Render();\n};\n```", "```cpp\nbool m_align_rotation;\nfloat m_rotation;\n```", "```cpp\nUint8 m_start_red;\nUint8 m_start_green;\nUint8 m_start_blue;\n\nUint8 m_end_red;\nUint8 m_end_green;\nUint8 m_end_blue;\n\nUint8 m_current_red;\nUint8 m_current_green;\nUint8 m_current_blue;\n```", "```cpp\nUint32 m_animation_frames;\nUint32 m_current_frame;\nUint32 m_next_frame_ms;\n```", "```cpp\nfloat m_width;\nfloat m_height;\n\nfloat m_start_scale;\nfloat m_end_scale;\nfloat m_current_scale;\n```", "```cpp\nSDL_Rect m_src = {.x = 0, .y = 0, .w = 0, .h = 0 };\n```", "```cpp\nParticle( SDL_Texture *sprite, Uint32 life_time, float acceleration,\n             bool alpha_fade, int width, int height, bool align_rotation,\n             Uint32 start_color,\n             Uint32 end_color,\n             Uint32 animation_frames );\n```", "```cpp\nvoid Update( Uint32 life_time, float acceleration,\n             bool alpha_fade, bool align_rotation,\n             Uint32 start_color, Uint32 end_color,\n             Uint32 m_animation_frames );\n```", "```cpp\nvoid Spawn( float x, float y, float velocity_x, float velocity_y,\n             float start_scale, float end_scale, float rotation );\n```", "```cpp\nParticle::Particle( SDL_Texture *sprite_texture, Uint32 life_time, \n                   float acceleration, bool alpha_fade, int width, \n                   int height, bool align_rotation,\n                   Uint32 start_color, Uint32 end_color, \n                   Uint32 animation_frames ) {\n\n    if( start_color != 0xffffff || end_color != 0xffffff ) {\n        m_color_mod = true;\n        m_start_red = (Uint8)(start_color >> 16);\n        m_start_green = (Uint8)(start_color >> 8);\n        m_start_blue = (Uint8)(start_color);\n\n        m_end_red = (Uint8)(end_color >> 16);\n        m_end_green = (Uint8)(end_color >> 8);\n        m_end_blue = (Uint8)(end_color);\n\n        m_current_red = m_start_red;\n        m_current_green = m_start_green;\n        m_current_blue = m_start_blue;\n    }\n    else {\n        m_color_mod = false;\n\n        m_start_red = (Uint8)255;\n        m_start_green = (Uint8)255;\n        m_start_blue = (Uint8)255;\n\n        m_end_red = (Uint8)255;\n        m_end_green = (Uint8)255;\n        m_end_blue = (Uint8)255;\n\n        m_current_red = m_start_red;\n        m_current_green = m_start_green;\n        m_current_blue = m_start_blue;\n    }\n    m_align_rotation = align_rotation;\n    m_animation_frames = animation_frames;\n    m_sprite_texture = sprite_texture;\n    m_life_time = life_time;\n    m_acceleration = acceleration;\n    m_alpha_fade = alpha_fade;\n    m_width = (float)width;\n    m_height = (float)height;\n\n    m_src.w = m_dest.w = (int)((float)width / (float)m_animation_frames);\n    m_src.h = m_dest.h = height;\n\n    m_next_frame_ms = m_life_time / m_animation_frames;\n    m_current_frame = 0;\n    m_active = false;\n}\n```", "```cpp\nm_start_red = (Uint8)(start_color >> 16);\nm_start_green = (Uint8)(start_color >> 8);\nm_start_blue = (Uint8)(start_color);\n```", "```cpp\nm_end_red = (Uint8)(end_color >> 16);\nm_end_green = (Uint8)(end_color >> 8);\nm_end_blue = (Uint8)(end_color);\n```", "```cpp\nelse {\n    m_color_mod = false;\n    m_start_red = (Uint8)255;\n    m_start_green = (Uint8)255;\n    m_start_blue = (Uint8)255;\n\n    m_end_red = (Uint8)255;\n    m_end_green = (Uint8)255;\n    m_end_blue = (Uint8)255;\n\n    m_current_red = m_start_red;\n    m_current_green = m_start_green;\n    m_current_blue = m_start_blue;\n}\n```", "```cpp\nm_align_rotation = align_rotation;\nm_animation_frames = animation_frames;\nm_sprite_texture = sprite_texture;\nm_life_time = life_time;\nm_acceleration = acceleration;\nm_alpha_fade = alpha_fade;\n\nm_width = (float)width;\nm_height = (float)height;\n```", "```cpp\nm_src.w = m_dest.w = (int)((float)width / (float)m_animation_frames);\nm_src.h = m_dest.h = height;\n```", "```cpp\nm_current_frame = 0;\nm_active = false;\n```", "```cpp\nvoid Particle::Update( Uint32 life_time, float acceleration, \n                       bool alpha_fade, bool align_rotation,\n                       Uint32 start_color, Uint32 end_color, \n                       Uint32 animation_frames ) {\n    if( start_color != 0xffffff || end_color != 0xffffff ) {\n        m_color_mod = true;\n\n        m_start_red = (Uint8)(start_color >> 16);\n        m_start_green = (Uint8)(start_color >> 8);\n        m_start_blue = (Uint8)(start_color);\n\n        m_end_red = (Uint8)(end_color >> 16);\n        m_end_green = (Uint8)(end_color >> 8);\n        m_end_blue = (Uint8)(end_color);\n\n        m_current_red = m_start_red;\n        m_current_green = m_start_green;\n        m_current_blue = m_start_blue;\n    }\n     else {\n        m_color_mod = false;\n\n        m_start_red = (Uint8)255;\n        m_start_green = (Uint8)255;\n        m_start_blue = (Uint8)255;\n\n        m_end_red = (Uint8)255;\n        m_end_green = (Uint8)255;\n        m_end_blue = (Uint8)255;\n\n        m_current_red = m_start_red;\n        m_current_green = m_start_green;\n        m_current_blue = m_start_blue;\n    }\n\n    m_align_rotation = align_rotation;\n    m_life_time = life_time;\n    m_acceleration = acceleration;\n    m_alpha_fade = alpha_fade;\n    m_active = false;\n\n    m_current_frame = 0;\n    m_animation_frames = animation_frames;\n    m_next_frame_ms = m_life_time / m_animation_frames;;\n\n    m_src.w = m_dest.w = (int)((float)m_width / (float)m_animation_frames);\n    m_src.h = m_dest.h = m_height;\n}\n```", "```cpp\nvoid Particle::Spawn( float x, float y,\n                      float velocity_x, float velocity_y,\n                      float start_scale, float end_scale,\n                      float rotation ) {\n     m_position.x = x;\n     m_dest.x = (int)m_position.x;\n     m_position.y = y;\n     m_dest.y = (int)m_position.y;\n\n    m_velocity.x = velocity_x;\n    m_velocity.y = velocity_y;\n\n    m_alpha = 255.0;\n    m_active = true;\n    m_ttl = m_life_time;\n    m_rotation = rotation;\n\n    m_current_red = m_start_red;\n    m_current_green = m_start_green;\n    m_current_blue = m_start_blue;\n\n    m_current_scale = m_start_scale = start_scale;\n    m_end_scale = end_scale;\n\n    m_current_frame = 0;\n    m_next_frame_ms = m_life_time / m_animation_frames;\n}\n```", "```cpp\nvoid Particle::Move() {\n    float time_pct = 1.0 - (float)m_ttl / (float)m_life_time;\n    m_current_frame = (int)(time_pct * (float)m_animation_frames);\n    float acc_adjusted = 1.0f;\n\n    if( m_acceleration < 1.0f ) {\n        acc_adjusted = 1.0f - m_acceleration;\n        acc_adjusted *= delta_time;\n        acc_adjusted = 1.0f - acc_adjusted;\n    }\n    else if( m_acceleration > 1.0f ) {\n        acc_adjusted = m_acceleration - 1.0f;\n        acc_adjusted *= delta_time;\n        acc_adjusted += 1.0f;\n    }\n    m_velocity.x *= acc_adjusted;\n    m_velocity.y *= acc_adjusted;\n\n    m_position.x += m_velocity.x * delta_time;\n    m_position.y += m_velocity.y * delta_time;\n\n    m_dest.x = (int)m_position.x;\n    m_dest.y = (int)m_position.y;\n\n    if( m_alpha_fade == true ) {\n         m_alpha = 255.0 * (1.0 - time_pct);\n         if( m_alpha < 0 ) {\n            m_alpha = 0;\n        }\n    }\n    else {\n        m_alpha = 255.0;\n    }\n    if( m_color_mod == true ) {\n        m_current_red = m_start_red + (Uint8)(( m_end_red - m_start_red\n        ) * \n        time_pct);\n        m_current_green = m_start_green + (Uint8)(( m_end_green -\n        m_start_green ) * \n        time_pct);\n        m_current_blue = m_start_blue + (Uint8)(( m_end_blue -\n        m_start_blue ) * \n        time_pct);\n    }\n\n    m_current_scale = m_start_scale + (m_end_scale - m_start_scale) * \n    time_pct;\n    m_dest.w = (int)(m_src.w * m_current_scale);\n    m_dest.h = (int)(m_src.h * m_current_scale);    \n    m_ttl -= diff_time;\n\n    if( m_ttl <= 0 ) {\n        m_active = false;\n    }\n    else {\n        m_src.x = (int)(m_src.w * m_current_frame);\n    }\n}\n```", "```cpp\nfloat time_pct = 1.0 - (float)m_ttl / (float)m_life_time;\n```", "```cpp\nm_current_frame = (int)(time_pct * (float)m_animation_frames);\n```", "```cpp\nfloat acc_adjusted = 1.0f;\n\nif( m_acceleration < 1.0f ) {\n    acc_adjusted = 1.0f - m_acceleration;\n    acc_adjusted *= delta_time;\n    acc_adjusted = 1.0f - acc_adjusted;\n}\nelse if( m_acceleration > 1.0f ) {\n    acc_adjusted = m_acceleration - 1.0f;\n    acc_adjusted *= delta_time;\n    acc_adjusted += 1.0f;\n}\n\nm_velocity.x *= acc_adjusted;\nm_velocity.y *= acc_adjusted;\n```", "```cpp\nm_position.x += m_velocity.x * delta_time;\nm_position.y += m_velocity.y * delta_time;\n\nm_dest.x = (int)m_position.x;\nm_dest.y = (int)m_position.y;\n```", "```cpp\nif( m_alpha_fade == true ) {\n    m_alpha = 255.0 * (1.0 - time_pct);\n    if( m_alpha < 0 ) {\n        m_alpha = 0;\n    }\n}\nelse {\n    m_alpha = 255.0;\n}\n```", "```cpp\nif( m_color_mod == true ) {\n    m_current_red = m_start_red + (Uint8)(( m_end_red - m_start_red ) *         \n    time_pct);\n    m_current_green = m_start_green + (Uint8)(( m_end_green -\n    m_start_green ) * time_pct);\n    m_current_blue = m_start_blue + (Uint8)(( m_end_blue - m_start_blue         \n    ) * time_pct);\n}\n```", "```cpp\nm_current_scale = m_start_scale + (m_end_scale - m_start_scale) * time_pct;\nm_dest.w = (int)(m_src.w * m_current_scale);\nm_dest.h = (int)(m_src.h * m_current_scale);\n```", "```cpp\nm_ttl -= diff_time;\nif( m_ttl <= 0 ) {\n    m_active = false;\n}\nelse {\n    m_src.x = (int)(m_src.w * m_current_frame);\n}\n```", "```cpp\nvoid Particle::Render() {\n\n    SDL_SetTextureAlphaMod(m_sprite_texture,\n                            (Uint8)m_alpha );\n\n    if( m_color_mod == true ) {\n        SDL_SetTextureColorMod(m_sprite_texture,\n        m_current_red,\n        m_current_green,\n        m_current_blue );\n    }\n\n    if( m_align_rotation == true ) {\n        SDL_RenderCopyEx( renderer, m_sprite_texture, &m_src, &m_dest, \n                            m_rotation, NULL, SDL_FLIP_NONE );\n    }\n    else {\n        SDL_RenderCopy( renderer, m_sprite_texture, &m_src, &m_dest );\n    }\n}\n```", "```cpp\nEmitter::Emitter(char* sprite_file, int max_particles, float min_angle, \n         float max_angle, Uint32 particle_lifetime, \n         float acceleration, bool alpha_fade,\n         float min_starting_velocity, float max_starting_velocity,\n         Uint32 emission_rate, int x_pos, int y_pos, float radius,\n         float min_start_scale, float max_start_scale,\n         float min_end_scale, float max_end_scale,\n         Uint32 start_color, Uint32 end_color,\n         float burst_time_pct, Uint32 burst_particles,\n         bool loop, bool align_rotation, Uint32 emit_time_ms, \n         Uint32 animation_frames ) {\n    m_start_color = start_color;\n    m_end_color = end_color;\n    m_active = true;\n    if( min_starting_velocity > max_starting_velocity ) {\n        m_min_starting_velocity = max_starting_velocity;\n        m_max_starting_velocity = min_starting_velocity;\n    }\n    else {\n        m_min_starting_velocity = min_starting_velocity;\n        m_max_starting_velocity = max_starting_velocity;\n    }\n    SDL_Surface *temp_surface = IMG_Load( sprite_file );\n    if( !temp_surface ) {\n        printf(\"failed to load image: %s\\n\", IMG_GetError() );\n        return;\n    }\n    m_sprite_texture = SDL_CreateTextureFromSurface( renderer, temp_surface \n    );\n    SDL_FreeSurface( temp_surface );\n    SDL_QueryTexture( m_sprite_texture,\n                        NULL, NULL,\n                        &m_sprite_width, &m_sprite_height );\n    m_max_particles = max_particles;\n    for( int i = 0; i < m_max_particles; i++ ) {\n        m_particle_pool.push_back(\n            new Particle( m_sprite_texture, particle_lifetime, \n\n                          acceleration, alpha_fade, m_sprite_width, \n                          m_sprite_height, align_rotation,\n                          m_start_color, m_end_color, \n                          animation_frames )\n            );\n    }\n    m_max_angle = max_angle;\n    m_min_angle = min_angle;\n    m_radius = radius;\n    m_position.x = (float)x_pos;\n    m_position.y = (float)y_pos;\n    m_emission_rate = emission_rate;\n    m_emission_time_ms = 1000 / m_emission_rate;\n    m_next_emission = 0;\n    /* new values */\n    m_min_start_scale = min_start_scale;\n    m_max_start_scale = max_start_scale;\n    m_min_end_scale = min_end_scale;\n    m_max_end_scale = max_end_scale;\n\n    m_loop = loop;\n    m_align_rotation = align_rotation;\n    m_emit_loop_ms = emit_time_ms;\n    m_ttl = m_emit_loop_ms;\n    m_animation_frames = animation_frames;\n    m_burst_time_pct = burst_time_pct;\n    m_burst_particles = burst_particles;\n    m_has_burst = false;\n}\n```", "```cpp\nif( min_starting_velocity > max_starting_velocity ) {\n    m_min_starting_velocity = max_starting_velocity;\n    m_max_starting_velocity = min_starting_velocity;\n}\nelse {\n    m_min_starting_velocity = min_starting_velocity;\n    m_max_starting_velocity = max_starting_velocity;\n}\n```", "```cpp\nSDL_Surface *temp_surface = IMG_Load( sprite_file );\n\nif( !temp_surface ) {\n    printf(\"failed to load image: %s\\n\", IMG_GetError() );\n    return;\n}\n```", "```cpp\nm_sprite_texture = SDL_CreateTextureFromSurface( renderer, temp_surface );\nSDL_FreeSurface( temp_surface );\nSDL_QueryTexture( m_sprite_texture,\n                  NULL, NULL,\n                  &m_sprite_width, &m_sprite_height );\n```", "```cpp\nm_max_particles = max_particles;\nfor( int i = 0; i < m_max_particles; i++ ) {\n    m_particle_pool.push_back(\n        new Particle( m_sprite_texture, particle_lifetime, acceleration,\n                        alpha_fade, m_sprite_width, m_sprite_height, \n                        align_rotation,\n                        m_start_color, m_end_color, animation_frames )\n    );\n}\n```", "```cpp\nm_max_angle = max_angle;\nm_min_angle = min_angle;\nm_radius = radius;\nm_position.x = (float)x_pos;\nm_position.y = (float)y_pos;\nm_emission_rate = emission_rate;\nm_emission_time_ms = 1000 / m_emission_rate;\nm_next_emission = 0;\n\n/* new values */\nm_min_start_scale = min_start_scale;\nm_max_start_scale = max_start_scale;\nm_min_end_scale = min_end_scale;\nm_max_end_scale = max_end_scale;\n\nm_loop = loop;\nm_align_rotation = align_rotation;\nm_emit_loop_ms = emit_time_ms;\nm_ttl = m_emit_loop_ms;\nm_animation_frames = animation_frames;\nm_burst_time_pct = burst_time_pct;\nm_burst_particles = burst_particles;\nm_has_burst = false;\n```", "```cpp\nif( min_starting_velocity > max_starting_velocity ) {\n    m_min_starting_velocity = max_starting_velocity;\n    m_max_starting_velocity = min_starting_velocity;\n}\nelse {\n    m_min_starting_velocity = min_starting_velocity;\n    m_max_starting_velocity = max_starting_velocity;\n}\nm_active = true;\nm_has_burst = false;\nm_max_particles = max_particles;\nm_min_angle = min_angle;\nm_max_angle = max_angle;\nm_emission_rate = emission_rate;\nm_emission_time_ms = 1000 / m_emission_rate;\nm_position.x = (float)x_pos;\nm_position.y = (float)y_pos;\nm_radius = radius;\n/* new values */\nm_min_start_scale = min_start_scale;\nm_max_start_scale = max_start_scale;\nm_min_end_scale = min_end_scale;\nm_max_end_scale = max_end_scale;\nm_start_color = start_color;\nm_end_color = end_color;\nm_burst_time_pct = burst_time_pct;\nm_burst_particles = burst_particles;\nm_loop = loop;\nm_align_rotation = align_rotation;\nm_emit_loop_ms = emit_time_ms;\nm_ttl = m_emit_loop_ms;\nm_animation_frames = animation_frames;\n```", "```cpp\nif( m_particle_pool.size() > m_max_particles ) {\n    m_particle_pool.resize( m_max_particles );\n}\nelse if( m_max_particles > m_particle_pool.size() ) {\n    while( m_max_particles > m_particle_pool.size() ) {\n        m_particle_pool.push_back(\n            new Particle( m_sprite_texture, particle_lifetime, \n                            acceleration, alpha_fade, m_sprite_width, \n                            m_sprite_height, m_align_rotation,\n                            m_start_color, m_end_color, \n                            m_animation_frames )\n        );\n    }\n}\n```", "```cpp\nParticle* particle;\nstd::vector<Particle*>::iterator it;\nfor( it = m_particle_pool.begin(); it != m_particle_pool.end(); it++ ) {\n    particle = *it;\n    particle->Update( particle_lifetime, acceleration, alpha_fade, \n    m_align_rotation, m_start_color, m_end_color, m_animation_frames );\n}\n```", "```cpp\nvoid Emitter::Move() {\n    Particle* particle;\n    std::vector<Particle*>::iterator it;\n    if( m_active == true ) {\n        m_next_emission -= diff_time;\n        m_ttl -= diff_time;\n        if( m_ttl <= 0 ) {\n            if( m_loop ) {\n                m_ttl = m_emit_loop_ms;\n                m_has_burst = false;\n            }\n            else {\n                m_active = false;\n            }\n        }\n        if( m_burst_particles > 0 && m_has_burst == false ) {\n            if( (float)m_ttl / (float)m_emit_loop_ms <= 1.0 - \n            m_burst_time_pct ) {\n                m_has_burst = true;\n                m_next_emission -= m_burst_particles * m_emission_time_ms;\n            }\n        }\n        while( m_next_emission <= 0 ) {\n            m_next_emission += m_emission_time_ms;\n            particle = GetFreeParticle();\n            if( particle != NULL ) {\n                Point spawn_point;\n                spawn_point.x = get_random_float( 0.0, m_radius );\n                Point velocity_point;\n                velocity_point.x = get_random_float( \n                m_min_starting_velocity, m_max_starting_velocity );\n                float angle = get_random_float( m_min_angle, m_max_angle );\n                float start_scale = get_random_float( m_min_start_scale, \n                m_max_start_scale );\n                float end_scale = get_random_float( m_min_end_scale, \n                m_max_end_scale );\n                spawn_point.x += m_position.x;\n                spawn_point.y += m_position.y;\n                particle->Spawn(spawn_point.x, spawn_point.y, \n                velocity_point.x, velocity_point.y,\n                                start_scale, end_scale,\n                                (int)(angle / 3.14159 * 180.0 + 360.0) \n                                % 360 );\n            }\n            else {\n                m_next_emission = m_emission_time_ms;\n            }\n        }\n    }\n    for( it = m_particle_pool.begin(); it != m_particle_pool.end(); it++ ) {\n        particle = *it;\n        if( particle->m_active ) {\n            particle->Move();\n            particle->Render();\n        }\n    }\n}\n```", "```cpp\nif( m_active == true ) {\n    m_next_emission -= diff_time;\n    m_ttl -= diff_time;\n    if( m_ttl <= 0 ) {\n        if( m_loop ) {\n            m_ttl = m_emit_loop_ms;\n            m_has_burst = false;\n        }\n        else {\n            m_active = false;\n        }\n    }\n```", "```cpp\nif( m_burst_particles > 0 && m_has_burst == false ) {\n    if( (float)m_ttl / (float)m_emit_loop_ms <= 1.0 - m_burst_time_pct ) {\n        m_has_burst = true;\n        m_next_emission -= m_burst_particles * m_emission_time_ms;\n    }\n}\n```", "```cpp\nwhile( m_next_emission <= 0 ) {\n    m_next_emission += m_emission_time_ms;\n    particle = GetFreeParticle();\n    if( particle != NULL ) {\n```", "```cpp\nPoint spawn_point;\nspawn_point.x = get_random_float( 0.0, m_radius );\nPoint velocity_point;\nvelocity_point.x = get_random_float( m_min_starting_velocity, m_max_starting_velocity );\nfloat angle = get_random_float( m_min_angle, m_max_angle );\nfloat start_scale = get_random_float( m_min_start_scale, m_max_start_scale );\nfloat end_scale = get_random_float( m_min_end_scale, m_max_end_scale );\n```", "```cpp\nvelocity_point.Rotate(angle);\nspawn_point.Rotate( angle );\n```", "```cpp\nspawn_point.x += m_position.x;\nspawn_point.y += m_position.y;\n```", "```cpp\nparticle->Spawn(spawn_point.x, spawn_point.y, velocity_point.x, \n                velocity_point.y,\n                start_scale, end_scale,\n                (int)(angle / 3.14159 * 180.0 + 360.0) % 360 );\n```", "```cpp\nfor( it = m_particle_pool.begin(); it != m_particle_pool.end(); it++ ) {\n    particle = *it;\n    if( particle->m_active ) {\n        particle->Move();\n        particle->Render();\n    }\n}\n```", "```cpp\nfloat get_random_float( float min, float max ) {\n    int int_min = (int)(min * 1000);\n    int int_max = (int)(max * 1000);\n    if( int_min > int_max ) {\n        int temp = int_max;\n        int_max = int_min;\n        int_min = temp;\n    }\n    int int_diff = int_max - int_min;\n    int int_rand = (int_diff == 0) ? 0 : rand() % int_diff;\n    int_rand += int_min;\n    return (float)int_rand / 1000.0;\n}\n```", "```cpp\nint int_min = (int)(min * 1000);\nint int_max = (int)(max * 1000);\n```", "```cpp\nif( int_min > int_max ) {\n    int temp = int_max;\n    int_max = int_min;\n    int_min = temp;\n}\n```", "```cpp\nint int_diff = int_max - int_min;\n```", "```cpp\nint int_rand = (int_diff == 0) ? 0 : rand() % int_diff;\n```", "```cpp\nint_rand += int_min;\n```", "```cpp\nreturn (float)int_rand / 1000.0;\n```", "```cpp\nextern \"C\"\n    EMSCRIPTEN_KEEPALIVE\n    void add_emitter(char* file_name, int max_particles, float min_angle, \n         float max_angle,\n         Uint32 particle_lifetime, float acceleration, bool alpha_fade,\n         float min_starting_velocity, float max_starting_velocity,\n         Uint32 emission_rate, float x_pos, float y_pos, float radius,\n         /* new parameters */\n         float min_start_scale, float max_start_scale,\n         float min_end_scale, float max_end_scale,\n         Uint32 start_color, Uint32 end_color,\n         float burst_time_pct, Uint32 burst_particles,\n         bool loop, bool align_rotation, Uint32 emit_time_ms,\n         Uint32 animation_frames ) {\n        if( emitter != NULL ) {\n            delete emitter;\n        }\n\n        emitter = new Emitter(file_name, max_particles, min_angle, \n                  max_angle,\n                  particle_lifetime, acceleration, alpha_fade,\n                  min_starting_velocity, max_starting_velocity,\n                  emission_rate, x_pos, y_pos, radius,\n                  /* new parameters */\n                  min_start_scale, max_start_scale,\n                  min_end_scale, max_end_scale,\n                  start_color, end_color,\n                  burst_time_pct, burst_particles,\n                  loop, align_rotation, emit_time_ms,\n                  animation_frames\n                  );\n    }\n```", "```cpp\nextern \"C\"\n    EMSCRIPTEN_KEEPALIVE\n    void update_emitter(int max_particles, float min_angle, \n         float max_angle,\n         Uint32 particle_lifetime, float acceleration, bool alpha_fade,\n         float min_starting_velocity, float max_starting_velocity,\n         Uint32 emission_rate, float x_pos, float y_pos, float radius,\n         /* new parameters */\n         float min_start_scale, float max_start_scale,\n         float min_end_scale, float max_end_scale,\n         Uint32 start_color, Uint32 end_color,\n         float burst_time_pct, Uint32 burst_particles,\n         bool loop, bool align_rotation, Uint32 emit_time_ms,\n         Uint32 animation_frames ) {\n         if( emitter == NULL ) {\n                        return;\n                    }\n                    emitter->Update(max_particles, min_angle, max_angle,\n                          particle_lifetime, acceleration, alpha_fade,\n                          min_starting_velocity, max_starting_velocity,\n                          emission_rate, x_pos, y_pos, radius,\n                          /* new parameters */\n                          min_start_scale, max_start_scale,\n                          min_end_scale, max_end_scale,\n                          start_color, end_color,\n                          burst_time_pct, burst_particles,\n                          loop, align_rotation, emit_time_ms,\n                          animation_frames\n                    );\n                }\n```", "```cpp\nem++ emitter.cpp particle.cpp point.cpp advanced_particle.cpp -o particle.html -std=c++17 --shell-file advanced_particle_shell.html -s NO_EXIT_RUNTIME=1 -s USE_WEBGL2=1 -s USE_SDL=2 -s USE_SDL_IMAGE=2 -s SDL2_IMAGE_FORMATS=[\"png\"] -s NO_EXIT_RUNTIME=1 -s EXPORTED_FUNCTIONS=\"['_add_emitter', '_update_emitter', '_main']\" -s EXTRA_EXPORTED_RUNTIME_METHODS=\"['cwrap', 'ccall']\" -s FORCE_FILESYSTEM=1\n```", "```cpp\nextern float get_random_float( float min, float max );\n```", "```cpp\nclass Particle {\n    public:\n        bool m_active;\n        bool m_alpha_fade;\n        bool m_color_mod;\n        bool m_align_rotation;\n\n        Uint8 m_start_red;\n        Uint8 m_start_green;\n        Uint8 m_start_blue;\n\n        Uint8 m_end_red;\n        Uint8 m_end_green;\n        Uint8 m_end_blue;\n\n        Uint8 m_current_red;\n        Uint8 m_current_green;\n        Uint8 m_current_blue;\n\n        SDL_Texture *m_sprite_texture;\n        int m_ttl;\n\n        Uint32 m_life_time;\n        Uint32 m_animation_frames;\n        Uint32 m_current_frame;\n\n        Uint32 m_next_frame_ms;\n        float m_rotation;\n        float m_acceleration;\n        float m_alpha;\n\n        float m_width;\n        float m_height;\n\n        float m_start_scale;\n        float m_end_scale;\n        float m_current_scale;\n\n        Point m_position;\n        Point m_velocity;\n        SDL_Rect m_dest = {.x = 0, .y = 0, .w = 0, .h = 0 };\n        SDL_Rect m_src = {.x = 0, .y = 0, .w = 0, .h = 0 };\n\n        Particle( SDL_Texture *sprite, Uint32 life_time, float \n                    acceleration,\n                    bool alpha_fade, int width, int height, bool \n                    align_rotation,\n                    Uint32 start_color,\n                    Uint32 end_color,\n                    Uint32 animation_frames );\n\n        void Update( Uint32 life_time, float acceleration,\n                    bool alpha_fade, bool align_rotation,\n                    Uint32 start_color, Uint32 end_color,\n                    Uint32 m_animation_frames );\n\n        void Spawn( float x, float y, float velocity_x, float velocity_y,\n                    float start_scale, float end_scale, float rotation );\n        void Move();\n        void Render();\n};\n```", "```cpp\nclass Emitter {\n    public:\n        bool m_loop;\n        bool m_align_rotation;\n        bool m_active;\n        bool m_has_burst;\n\n        SDL_Texture *m_sprite_texture;\n        std::vector<Particle*> m_particle_pool;\n        int m_sprite_width;\n        int m_sprite_height;\n        int m_ttl;\n\n        // added ----------------------------\n        int m_x_adjustment = 0;\n        int m_y_adjustment = 0;\n        // ----------------------------------\n\n        Uint32 m_max_particles;\n        Uint32 m_emission_rate;\n        Uint32 m_emission_time_ms;\n\n        Uint32 m_start_color;\n        Uint32 m_end_color;\n\n        Uint32 m_burst_particles;\n        Uint32 m_emit_loop_ms;\n        Uint32 m_animation_frames;\n\n        int m_next_emission;\n\n        float* m_parent_rotation;\n\n        float m_max_angle;\n        float m_min_angle;\n        float m_radius;\n        float m_min_starting_velocity;\n        float m_max_starting_velocity;\n\n        float m_min_start_scale;\n        float m_max_start_scale;\n        float m_min_end_scale;\n        float m_max_end_scale;\n        float m_min_start_rotation;\n        float m_max_start_rotation;\n        float m_burst_time_pct;\n\n        // added ----------------------------\n        float* m_parent_rotation_ptr;\n        float* m_parent_x_ptr;\n        float* m_parent_y_ptr;\n        // -----------------------------------\n\n        Point m_position;\n\n        Emitter(char* sprite_file, int max_particles, float min_angle, \n              float max_angle,\n              Uint32 particle_lifetime, float acceleration, \n              bool alpha_fade,\n              float min_starting_velocity, float max_starting_velocity,\n              Uint32 emission_rate, int x_pos, int y_pos, float radius,\n              float min_start_scale, float max_start_scale,\n              float min_end_scale, float max_end_scale,\n              Uint32 start_color, Uint32 end_color,\n              float burst_time_pct, Uint32 burst_particles,\n              bool loop, bool align_rotation,\n              Uint32 emit_time_ms, Uint32 animation_frames );\n\n        void Update(int max_particles, float min_angle, float max_angle,\n             Uint32 particle_lifetime, float acceleration, bool alpha_fade,\n             float min_starting_velocity, float max_starting_velocity,\n             Uint32 emission_rate, int x_pos, int y_pos, float radius,\n             float min_start_scale, float max_start_scale,\n             float min_end_scale, float max_end_scale,\n             Uint32 start_color, Uint32 end_color,\n             float burst_time_pct, Uint32 burst_particles,\n             bool loop, bool align_rotation, Uint32 emit_time_ms,\n             Uint32 animation_frames );\n\n        void Move();\n        Particle* GetFreeParticle();\n\n        void Run(); // added\n };\n```", "```cpp\nint m_x_adjustment = 0;\nint m_y_adjustment = 0;\n```", "```cpp\nfloat* m_parent_rotation_ptr;\nfloat* m_parent_x_ptr;\nfloat* m_parent_y_ptr;\n```", "```cpp\nvoid Run();\n```", "```cpp\nEmitter::Emitter(char* sprite_file, int max_particles, float min_angle, \n                float max_angle,\n                Uint32 particle_lifetime, float acceleration, bool \n                alpha_fade,\n                float min_starting_velocity, float max_starting_velocity,\n                Uint32 emission_rate, int x_pos, int y_pos, float radius,\n                float min_start_scale, float max_start_scale,\n                float min_end_scale, float max_end_scale,\n                Uint32 start_color, Uint32 end_color,\n                float burst_time_pct, Uint32 burst_particles,\n                bool loop, bool align_rotation, Uint32 emit_time_ms, Uint32 \n                animation_frames ) {\n    // added -----------------------------\n    m_parent_rotation_ptr = NULL;\n    m_parent_x_ptr = NULL;\n    m_parent_y_ptr = NULL;\n    // -----------------------------------\n    m_start_color = start_color;\n    m_end_color = end_color;\n    m_active = true;\n\n    if( min_starting_velocity > max_starting_velocity ) {\n        m_min_starting_velocity = max_starting_velocity;\n        m_max_starting_velocity = min_starting_velocity;\n    }\n    else {\n        m_min_starting_velocity = min_starting_velocity;\n        m_max_starting_velocity = max_starting_velocity;\n    }\n    SDL_Surface *temp_surface = IMG_Load( sprite_file );\n\n    if( !temp_surface ) {\n        printf(\"failed to load image: %s\\n\", IMG_GetError() );\n        printf(\"failed sprite file: %s\\n\", sprite_file );\n        return;\n    }\n    m_sprite_texture = SDL_CreateTextureFromSurface( renderer, temp_surface \n    );\n    SDL_FreeSurface( temp_surface );\n    SDL_QueryTexture( m_sprite_texture,\n                        NULL, NULL,\n                        &m_sprite_width, &m_sprite_height );\n                        m_max_particles = max_particles;\n\n    for( int i = 0; i < m_max_particles; i++ ) {\n        m_particle_pool.push_back(\n            new Particle( m_sprite_texture, particle_lifetime, \n            acceleration,\n                            alpha_fade, m_sprite_width, m_sprite_height, \n                            align_rotation,\n                            m_start_color, m_end_color, animation_frames )\n            );\n    }\n\n    // modified -----------------------------\n    m_min_angle = (min_angle+90) / 180 * 3.14159;\n    m_max_angle = (max_angle+90) / 180 * 3.14159;\n    // --------------------------------------\n\n    m_radius = radius;\n    m_position.x = (float)x_pos;\n    m_position.y = (float)y_pos;\n    m_emission_rate = emission_rate;\n    m_emission_time_ms = 1000 / m_emission_rate;\n    m_next_emission = 0;\n    m_min_start_scale = min_start_scale;\n    m_max_start_scale = max_start_scale;\n    m_min_end_scale = min_end_scale;\n    m_max_end_scale = max_end_scale;\n\n    m_loop = loop;\n    m_align_rotation = align_rotation;\n    m_emit_loop_ms = emit_time_ms;\n    m_ttl = m_emit_loop_ms;\n\n    m_animation_frames = animation_frames;\n    m_burst_time_pct = burst_time_pct;\n    m_burst_particles = burst_particles;\n    m_has_burst = false;\n}\n```", "```cpp\nm_parent_rotation_ptr = NULL;\nm_parent_x_ptr = NULL;\nm_parent_y_ptr = NULL;\n```", "```cpp\nm_min_angle = (min_angle+90) / 180 * 3.14159;\nm_max_angle = (max_angle+90) / 180 * 3.14159;\n```", "```cpp\nm_min_angle = (min_angle+90) / 180 * 3.14159;\nm_max_angle = (max_angle+90) / 180 * 3.14159;\n```", "```cpp\nvoid Emitter::Run() {\n    m_active = true;\n    m_ttl = m_emit_loop_ms;\n    m_has_burst = false;\n}\n```", "```cpp\nvoid Emitter::Move() {\n Particle* particle;\n std::vector<Particle*>::iterator it;\n    if( m_active == true ) {\n        m_next_emission -= diff_time;\n        m_ttl -= diff_time;\n        if( m_ttl <= 0 ) {\n            if( m_loop ) {\n                m_ttl = m_emit_loop_ms;\n                m_has_burst = false;\n            }\n            else { m_active = false; }\n        }\n        if( m_burst_particles > 0 && m_has_burst == false ) {\n            if( (float)m_ttl / (float)m_emit_loop_ms <= 1.0 - \n                m_burst_time_pct ) {\n                m_has_burst = true;\n                m_next_emission -= m_burst_particles * m_emission_time_ms;\n            }\n        }\n        while( m_next_emission <= 0 ) {\n            m_next_emission += m_emission_time_ms;\n            particle = GetFreeParticle();\n            if( particle != NULL ) {\n                Point spawn_point, velocity_point, rotated_position;\n                spawn_point.x = get_random_float( 0.0, m_radius );\n                velocity_point.x = \n                get_random_float(m_min_starting_velocity, \n                m_max_starting_velocity);\n                float angle = get_random_float( m_min_angle,m_max_angle );\n                float start_scale = get_random_float(m_min_start_scale, \n                m_max_start_scale);\n                float end_scale = get_random_float( m_min_end_scale,\n                m_max_end_scale );\n                if( m_parent_rotation_ptr != NULL ) {\n                    angle += *m_parent_rotation_ptr;\n                    rotated_position = m_position;\n                    rotated_position.Rotate( *m_parent_rotation_ptr );\n                }\n                velocity_point.Rotate(angle);\n                spawn_point.Rotate( angle );\n\n                if( m_parent_rotation_ptr == NULL ) {\n                    spawn_point.x += m_position.x;\n                    spawn_point.y += m_position.y;\n                    if( m_parent_x_ptr != NULL ) { spawn_point.x += \n                    *m_parent_x_ptr; }\n                    if( m_parent_y_ptr != NULL ) { spawn_point.y += \n                    *m_parent_y_ptr; }\n                }\n                else {\n                    spawn_point.x += rotated_position.x;\n                    spawn_point.y += rotated_position.y;\n                    if( m_parent_x_ptr != NULL ) { spawn_point.x += \n                    *m_parent_x_ptr; }\n                    if( m_parent_y_ptr != NULL ) { spawn_point.y += \n                    *m_parent_y_ptr; }\n                }\n                spawn_point.x += m_x_adjustment;\n                spawn_point.y += m_y_adjustment;\n                particle->Spawn(spawn_point.x, \n                spawn_point.y,velocity_point.x, velocity_point.y,\n                    start_scale, end_scale, (int)(angle / 3.14159 * 180.0 + \n                    360.0) % 360 );\n            }\n            else {\n                m_next_emission = m_emission_time_ms;\n            }\n        }\n    }\n    for( it = m_particle_pool.begin(); it != m_particle_pool.end(); it++ ) \n    {\n        particle = *it;\n        if( particle->m_active ) {\n            particle->Move();\n            particle->Render();\n        }\n    }\n}\n```", "```cpp\nPoint rotated_position;\n\nif( m_parent_rotation_ptr != NULL ) {\n    angle += *m_parent_rotation_ptr;\n    rotated_position = m_position;\n    rotated_position.Rotate( *m_parent_rotation_ptr );\n}\n```", "```cpp\nif( m_parent_rotation_ptr == NULL ) {\n    spawn_point.x += m_position.x;\n    spawn_point.y += m_position.y;\n}\n```", "```cpp\nelse {\n    spawn_point.x += rotated_position.x;\n    spawn_point.y += rotated_position.y;\n}\n```", "```cpp\nif( m_parent_x_ptr != NULL ) {\n    spawn_point.x += *m_parent_x_ptr;\n}\nif( m_parent_y_ptr != NULL ) {\n    spawn_point.y += *m_parent_y_ptr;\n}\n```", "```cpp\nspawn_point.x += m_x_adjustment;\nspawn_point.y += m_y_adjustment;\n```", "```cpp\nShip::Ship() : Collider(8.0) {\n    m_Rotation = PI;\n    m_DX = 0.0;\n    m_DY = 1.0;\n    m_VX = 0.0;\n    m_VY = 0.0;\n    m_LastLaunchTime = current_time;\n    m_Accelerating = false;\n    m_Exhaust = new Emitter((char*)\"/sprites/ProjectileExpOrange.png\", 200,\n                            -10, 10,\n                            400, 1.0, true,\n                            0.1, 0.1,\n                            30, 0, 12, 0.5,\n                            0.5, 1.0,\n                            0.5, 1.0,\n                            0xffffff, 0xffffff,\n                            0.7, 10,\n                            true, true,\n                            1000, 6 );\n\n    m_Exhaust->m_parent_rotation_ptr = &m_Rotation;\n    m_Exhaust->m_parent_x_ptr = &m_X;\n    m_Exhaust->m_parent_y_ptr = &m_Y;\n    m_Exhaust->m_x_adjustment = 10;\n    m_Exhaust->m_y_adjustment = 10;\n    m_Exhaust->m_active = false;\n    m_Explode = new Emitter((char*)\"/sprites/Explode.png\", 100,\n                             0, 360,\n                             1000, 0.3, false,\n                             20.0, 40.0,\n                             10, 0, 0, 5,\n                             1.0, 2.0,\n                             1.0, 2.0,\n                             0xffffff, 0xffffff,\n                             0.0, 10,\n                             false, false,\n                             800, 8 );\n    m_Explode->m_parent_rotation_ptr = &m_Rotation;\n    m_Explode->m_parent_x_ptr = &m_X;\n    m_Explode->m_parent_y_ptr = &m_Y;\n    m_Explode->m_active = false;\n}\n```", "```cpp\nm_Exhaust = new Emitter((char*)\"/sprites/ProjectileExpOrange.png\", 200,\n                        -10, 10,\n                        400, 1.0, true,\n                        0.1, 0.1,\n                        30, 0, 12, 0.5,\n                        0.5, 1.0,\n                        0.5, 1.0,\n                        0xffffff, 0xffffff,\n                        0.7, 10,\n                        true, true,\n                        1000, 6 );\n\n m_Exhaust->m_parent_rotation_ptr = &m_Rotation;\n m_Exhaust->m_parent_x_ptr = &m_X;\n m_Exhaust->m_parent_y_ptr = &m_Y;\n m_Exhaust->m_x_adjustment = 10;\n m_Exhaust->m_y_adjustment = 10;\n m_Exhaust->m_active = false;\n```", "```cpp\nEmitter(char* sprite_file, int max_particles, float min_angle, float max_angle,\n        Uint32 particle_lifetime, float acceleration, bool alpha_fade,\n        float min_starting_velocity, float max_starting_velocity,\n        Uint32 emission_rate, int x_pos, int y_pos, float radius,\n        float min_start_scale, float max_start_scale,\n        float min_end_scale, float max_end_scale,\n        Uint32 start_color, Uint32 end_color,\n        float burst_time_pct, Uint32 burst_particles,\n        bool loop, bool align_rotation, Uint32 emit_time_ms, Uint32 \n        animation_frames );\n```", "```cpp\n --preload-file sprites\n```", "```cpp\nm_Explode = new Emitter((char*)\"/sprites/Explode.png\", 100,\n                         0, 360,\n                         1000, 0.3, false,\n                         20.0, 40.0,\n                         10, 0, 0, 5,\n                         1.0, 2.0,\n                         1.0, 2.0,\n                         0xffffff, 0xffffff,\n                         0.0, 10,\n                         false, false,\n                         800, 8 );\n\nm_Explode->m_parent_rotation_ptr = &m_Rotation;\nm_Explode->m_parent_x_ptr = &m_X;\nm_Explode->m_parent_y_ptr = &m_Y;\nm_Explode->m_active = false;\n```", "```cpp\nvoid Ship::Accelerate() {\n    m_Accelerating = true; // added line\n    m_VX += m_DX * delta_time;\n    m_VY += m_DY * delta_time;\n}\n```", "```cpp\nvoid Ship::Render() {\n    if( m_Alive == false ) {\n        return;\n    }\n    m_Exhaust->Move();\n    m_Explode->Move();\n    dest.x = (int)m_X;\n    dest.y = (int)m_Y;\n    dest.w = c_Width;\n    dest.h = c_Height;\n    src.x = 32 * m_CurrentFrame;\n    float degrees = (m_Rotation / PI) * 180.0;\n    int return_code = SDL_RenderCopyEx( renderer, m_SpriteTexture,\n                                         &src, &dest,\n                                         degrees, NULL, SDL_FLIP_NONE );\n    if( return_code != 0 ) {\n        printf(\"failed to render image: %s\\n\", IMG_GetError() );\n    }\n\n    if( m_Accelerating == false ) {\n        m_Exhaust->m_active = false;\n    }\n    else {\n        m_Exhaust->m_active = true;\n    }\n    m_Accelerating = false;\n}\n```", "```cpp\nm_Exhaust->Move();\nm_Explode->Move();\n```", "```cpp\nif( m_Accelerating == false ) {\n    m_Exhaust->m_active = false;\n}\nelse {\n    m_Exhaust->m_active = true;\n}\nm_Accelerating = false;\n```", "```cpp\nvoid ProjectilePool::MoveProjectiles() {\n    Projectile* projectile;\n    std::vector<Projectile*>::iterator it;\n    for( it = m_ProjectileList.begin(); it != m_ProjectileList.end(); it++ ) {\n        projectile = *it;\n        if( projectile->m_Active ) {\n            projectile->Move();\n            if( projectile->m_CurrentFrame == 0 &&\n                player->m_CurrentFrame == 0 &&\n                ( projectile->HitTest( player ) ||\n                    player->CompoundHitTest( projectile ) ) ) {\n                player->m_CurrentFrame = 1;\n                player->m_NextFrameTime = ms_per_frame;\n                player->m_Explode->Run(); // added\n                projectile->m_CurrentFrame = 1;\n                projectile->m_NextFrameTime = ms_per_frame;\n            }\n            if( projectile->m_CurrentFrame == 0 &&\n                enemy->m_CurrentFrame == 0 &&\n                ( projectile->HitTest( enemy ) ||\n                    enemy->CompoundHitTest( projectile ) ) ) {\n                enemy->m_CurrentFrame = 1;\n                enemy->m_NextFrameTime = ms_per_frame;\n                enemy->m_Explode->Run(); // added\n                projectile->m_CurrentFrame = 1;\n                projectile->m_NextFrameTime = ms_per_frame;\n            }\n        }\n    }\n}\n```", "```cpp\nfloat get_random_float( float min, float max ) {\n    int int_min = (int)(min * 1000);\n    int int_max = (int)(max * 1000);\n    if( int_min > int_max ) {\n        int temp = int_max;\n        int_max = int_min;\n        int_min = temp;\n    }\n    int int_diff = int_max - int_min;\n    int int_rand = (int_diff == 0) ? 0 : rand() % int_diff;\n    int_rand += int_min;\n    return (float)int_rand / 1000.0;\n}\n```", "```cpp\nem++ collider.cpp emitter.cpp enemy_ship.cpp particle.cpp player_ship.cpp point.cpp projectile_pool.cpp projectile.cpp ship.cpp main.cpp -o particle_system.html --preload-file sprites -std=c++17 -s USE_WEBGL2=1 -s USE_SDL=2 -s USE_SDL_IMAGE=2 -s SDL2_IMAGE_FORMATS=[\"png\"] -s USE_SDL_IMAGE=2 -s SDL2_IMAGE_FORMATS=[\"png\"]\n```"]