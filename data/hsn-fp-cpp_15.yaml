- en: Refactoring to and through Pure Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构到纯函数并通过纯函数
- en: Programmers often hit code they are afraid to change. By extracting pure functions,
    using currying and composition, and taking advantage of the compiler, you can
    refactor existing code in a safer manner. We'll see an example of refactoring
    through pure functions, and then we'll look at a few design patterns, how they
    are implemented in functional programming, and how to use them in your refactoring.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员经常遇到他们害怕改变的代码。通过提取纯函数，使用柯里化和组合，并利用编译器，你可以以更安全的方式重构现有代码。我们将看一个通过纯函数重构的例子，然后我们将看一些设计模式，以及它们在函数式编程中的实现，以及如何在重构中使用它们。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: How to think about legacy code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何思考遗留代码
- en: How to use the compiler and pure functions to identify and separate dependencies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用编译器和纯函数来识别和分离依赖关系
- en: How to extract lambdas from any piece of code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从任何代码中提取lambda
- en: How to remove duplication between lambdas using currying and composition, and
    group them into classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用柯里化和组合消除lambda之间的重复，并将它们分组到类中
- en: How to implement a few design patterns (strategy, command, and dependency injection)
    using functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用函数实现一些设计模式（策略、命令和依赖注入）
- en: How to use design patterns based on functions to refactor toward them
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用基于函数的设计模式来重构
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need a compiler that supports C++ 17\. I used GCC 7.4.0c.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要一个支持C++ 17的编译器。我使用的是GCC 7.4.0c。
- en: The code is on GitHub at [https:/​/​github.​com/​PacktPublishing/​Hands-​On-​Functional-Programming-​with-​Cpp](https://github.%E2%80%8Bcom/PacktPublishing/Hands-On-Functional-Programming-with-Cpp)
    in the `Chapter12` folder. It includes and uses `doctest`, which is a single-header,
    open source, unit testing library. You can find it on its GitHub repository at
    [https:/​/github.​com/​onqtam/​doctest](https://github.%E2%80%8Bcom/onqtam/doctest).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在GitHub上的`Chapter12`文件夹中。它包括并使用`doctest`，这是一个单头文件的开源单元测试库。你可以在它的GitHub仓库上找到它[https:/​/github.​com/​onqtam/​doctest](https://github.%E2%80%8Bcom/onqtam/doctest)。
- en: Refactoring to and through pure functions
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构到纯函数并通过纯函数
- en: '**Refactoring** is an important and continuous part of software development.
    The main reason is the continuous change in requirements, driven by the changes
    in the world around the applications that we build. Our clients keep learning
    about the ecosystem in which products work, and need us to adapt these products
    to the new reality they discover. As a result, our code, even when perfectly structured,
    is almost always behind our current understanding of the problems that we''re
    solving.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**重构**是软件开发的一个重要而持续的部分。主要原因是需求的持续变化，由我们构建的应用程序周围世界的变化所驱动。我们的客户不断了解产品所在的生态系统，并需要我们将这些产品适应他们发现的新现实。因此，我们的代码，即使结构完美，几乎总是落后于我们当前对所解决问题的理解。'
- en: Structuring our code perfectly is no easy feat either. Programmers are people,
    so we make mistakes, lose focus, and sometimes fail to find the best solutions.
    The only way to deal with this complex situation is by using merciless refactoring;
    that is, after we make things work, we improve the code structure until the code
    is as good as it can be under the constraints we have.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 完美地构建我们的代码也不容易。程序员是人，所以我们会犯错，失去焦点，有时找不到最佳解决方案。处理这种复杂情况的唯一方法是使用无情的重构；也就是说，在让事情运转后，我们改进代码结构，直到在我们拥有的约束下代码达到最佳状态。
- en: That's easy to say and do, as long as we refactor very early and we write the
    tests. But what if we inherit a code base that has no tests? What do we do then?
    We'll visit this problem, along with a promising idea that uses pure functions
    to refactor the legacy code later.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们很早就重构并编写测试，那就很容易说和做。但是如果我们继承了一个没有测试的代码库呢？那我们该怎么办？我们将讨论这个问题，以及后面将使用纯函数来重构遗留代码的一个有前途的想法。
- en: First, let's define our terms. What is refactoring?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义我们的术语。什么是重构？
- en: What is refactoring?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是重构？
- en: 'Refactoring is one of the terms that''s universally used in the industry, but
    is not well understood. Unfortunately, the term is often used to justify big redesigns.
    Consider the following common story about a given project:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 重构是行业中普遍使用的术语之一，但并不被很好理解。不幸的是，这个术语经常被用来证明大的重设计。考虑以下关于给定项目的常见故事：
- en: When the project starts, features are added at a fast pace.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目开始时，功能以快速的速度添加。
- en: Soon enough (months, one year, or even weeks), the speed decreases, but the
    demand is the same.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很快（几个月、一年，甚至几周），速度下降了，但需求是一样的。
- en: Years later, it's so difficult to add new features that the clients are annoyed
    and pressure the team.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多年后，添加新功能变得如此困难，以至于客户感到恼火并向团队施加压力。
- en: Finally, a decision is made to rewrite or change the whole structure of the
    code in the hope it will speed things up.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终，决定重写或改变代码的整体结构，希望能加快速度。
- en: Six months later, the rewrite or redesign (usually) fails and the management
    faces an impossible situation—should we try to redesign, restart the project,
    or do something else?
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 六个月后，重写或重设计（通常）失败，管理层面临着一个不可能的情况——我们应该尝试重设计、重新启动项目，还是做其他事情？
- en: The **big redesign** phase of this cycle is often erroneously called refactoring,
    but that's not what refactoring is.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环的**大重设计**阶段通常错误地被称为重构，但这并不是重构的含义。
- en: 'Instead, to understand the true meaning of refactoring, let''s start by thinking
    about what changes we can make to a code base. We can usually classify these changes
    into categories as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，要理解重构的真正含义，让我们从思考对代码库可以做出的改变开始。我们通常可以将这些改变分类如下：
- en: Implementing a new requirement
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施新要求
- en: Fixing a bug
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复一个错误
- en: Reorganizing the code in various ways—refactoring, re-engineering, re-designing,
    and/or re-architecting
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以各种方式重新组织代码——重构、重工程、重设计和/或重架构
- en: 'We can roughly classify these changes into two big categories as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些更改大致分类为两大类，如下：
- en: Changes that impact on the behavior of the code
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 影响代码行为的更改
- en: Changes that don't impact on the behavior of the code
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不影响代码行为的更改
- en: When we talk about behavior, we talk about inputs and outputs, such as "when
    I introduce these values in a **user interface** (**UI**) form and click this
    button, then I see this output and these things are saved". We don't usually include cross-functional
    concerns such as performance, scalability, or security in the behaviors.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论行为时，我们谈论输入和输出，比如“当我在**用户界面**（UI）表单中输入这些值并单击此按钮时，然后我看到这个输出并保存这些东西”。我们通常不包括性能、可伸缩性或安全性等跨功能关注点在行为中。
- en: With these terms clear, we can define refactoring—it is simply making changes
    to the code structure that don't affect the external behavior of the program.
    Big redesigns or rewrites rarely fit into this definition, because usually, teams
    doing big redesigns don't prove that the result has the same behaviors as the
    original (including the known bugs, since someone may depend on them).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些明确的术语，我们可以定义重构——简单地对不影响程序外部行为的代码结构进行更改。大型重设计或重写很少符合这个定义，因为通常进行大型重设计的团队并不证明结果与原始代码具有相同的行为（包括已知的错误，因为有人可能依赖它们）。
- en: Any change to the program that modifies its behavior is not refactoring. This
    includes fixing bugs or adding a feature. However, we can split these changes
    into two phases—first, refactor to *make space* for the change, and then make
    the change in behavior.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对程序进行任何修改其行为的更改都不是重构。这包括修复错误或添加功能。然而，我们可以将这些更改分为两个阶段——首先重构以*为更改腾出空间*，然后进行行为更改。
- en: 'This definition raises a few questions, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义引发了一些问题，如下：
- en: 'How can we prove we haven''t changed the behavior? There''s only one way we
    know to do this: automated regression tests. If we have a suite of automated tests
    that we trust and that are fast enough, we can easily make a change without changing
    any tests and see if they pass.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何证明我们没有改变行为？我们知道的唯一方法是：自动回归测试。如果我们有一套我们信任且足够快速的自动化测试，我们可以轻松地进行更改而不改变任何测试，并查看它们是否通过。
- en: 'How small is the refactoring? The larger a change is, the more difficult it
    is to prove that nothing is affected, since programmers are humans and make mistakes.
    We prefer to have very small steps in refactoring. Here are a few examples of
    small behavior-preserving code changes: rename, add a parameter to a function,
    change the order of parameters for a function, and extract a group of statements
    into a function, among others. Each small change can be easily made and the tests
    run to prove that no behavioral change happened. Whenever we need to make a bigger
    refactoring, we just make a series of these small changes.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构有多小？更改越大，证明没有受到影响就越困难，因为程序员是人类，会犯错误。我们更喜欢在重构中采取非常小的步骤。以下是一些保持行为的小代码更改的示例：重命名、向函数添加参数、更改函数的参数顺序以及将一组语句提取到函数中等。每个小更改都可以轻松进行，并运行测试以证明没有发生行为更改。每当我们需要进行更大的重构时，我们只需进行一系列这些小更改。
- en: How can we prove that we haven't changed the behavior of code when we have no
    tests? This is when we need to talk about legacy code and the legacy code dilemma.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们没有测试时，我们如何证明我们没有改变代码的行为？这就是我们需要谈论遗留代码和遗留代码困境的时候。
- en: The legacy code dilemma
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遗留代码困境
- en: Programming is probably the only domain in which the word *legacy* has a negative
    connotation. In any other context, legacy means something that someone leaves
    behind and something that someone is usually proud of. In programming, legacy
    code refers to exclusive code that we inherit and is a pain to maintain.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 编程可能是唯一一个“遗留”一词具有负面含义的领域。在任何其他情况下，“遗留”都意味着某人留下的东西，通常是某人引以为傲的东西。在编程中，遗留代码指的是我们继承的独占代码，维护起来很痛苦。
- en: 'Too often, programmers think that legacy code is inevitable and there''s nothing
    that can be done about it. We can, however, do a lot of things. The first is to
    clarify what we mean by legacy code. Michael Feathers, in his book on legacy code,
    defines it as code that doesn''t have tests. However, I like to use a more general
    definition: *code that you''re afraid to change*. Code that you are afraid to
    change will slow you down, reduce your options, and make any new development an
    ordeal. But this is, by no means, inevitable: we can change it and we''ll see
    how.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员经常认为遗留代码是不可避免的，对此无能为力。然而，我们可以做很多事情。首先是澄清我们所说的遗留代码是什么意思。迈克尔·菲瑟斯在他的遗留代码书中将其定义为没有测试的代码。然而，我更倾向于使用更一般的定义：*你害怕改变的代码*。你害怕改变的代码会减慢你的速度，减少你的选择，并使任何新的开发成为一场磨难。但这绝不是不可避免的：我们可以改变它，我们将看到如何做到这一点。
- en: The second thing we can do is understand the dilemma of legacy code. To be less
    afraid of change, we need to refactor it, but in order to refactor the code, we
    need to write tests. To write tests, we need to adjust the code to make it testable;
    this looks like a circle—in order to change the code, we need to change the code!
    How do we do that if we're afraid to change the code in the first place?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的第二件事是了解遗留代码的困境。为了不那么害怕改变，我们需要对其进行重构，但为了重构代码，我们需要编写测试。要编写测试，我们需要调整代码使其可测试；这看起来像一个循环——为了改变代码，我们需要改变代码！如果我们一开始就害怕改变代码，我们该怎么办？
- en: Fortunately, this dilemma has a resolution. If we could just make safe changes
    to the code—changes that leave us very little opportunity for error and allows
    us to test the code—then we could slowly, but surely, improve the code. These
    changes are, indeed, refactoring, but they're even smaller and safer than the
    refactoring steps. Their main goal is to break the dependency between the design
    elements in your code, enabling us to write tests so we can continue refactoring
    afterward.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这个困境有一个解决办法。如果我们能够对代码进行安全的更改——这些更改几乎没有错误的机会，并且允许我们测试代码——那么我们就可以慢慢但肯定地改进代码。这些更改确实是重构，但它们甚至比重构步骤更小、更安全。它们的主要目标是打破代码中设计元素之间的依赖关系，使我们能够编写测试，以便在之后继续重构。
- en: Since our focus is on using pure functions and functional constructs to refactor
    code, we won't look at the full list of techniques. I can give one simple example
    called **extract and override**. Let's say you need to write tests for a very
    large function. It would be ideal if we could just write tests for a small part
    of the function instead. The way we could do this is by extracting the code that
    we want to test into another function. However, the new function depends on old
    code, so we'll have a hard time figuring out all the dependencies. To solve this
    issue, we can create a derived class that overrides all the dependencies of our
    function with dummy functions. In unit testing, this is called a *partial mock*.
    This allows us to cover, with tests, all the code from our extracted function,
    while assuming that all the other parts of the class work as expected. Once we
    cover it with tests, we can then move to refactoring; we often end up extracting
    a new class that is fully mocked or stubbed by the end of this exercise.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的重点是使用纯函数和函数构造来重构代码，我们不会查看完整的技术列表。我可以给出一个简单的例子，称为**提取和覆盖**。假设您需要为一个非常大的函数编写测试。如果我们只能为函数的一小部分编写测试，那将是理想的。我们可以通过将要测试的代码提取到另一个函数中来实现这一点。然而，新函数依赖于旧代码，因此我们将很难弄清所有的依赖关系。为了解决这个问题，我们可以创建一个派生类，用虚拟函数覆盖我们函数的所有依赖关系。在单元测试中，这称为*部分模拟*。这使我们能够用测试覆盖我们提取函数的所有代码，同时假设类的所有其他部分都按预期工作。一旦我们用测试覆盖了它，我们就可以开始重构；在这个练习结束时，我们经常会提取一个完全由模拟或存根的新类。
- en: These techniques were written before we had such widespread support for functional
    programming in our languages. We can now take advantage of pure functions to safely
    refactor the code we write. But, to do that, we need to understand how dependencies
    affect our ability to test and change code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术是在我们的语言中广泛支持函数式编程之前编写的。现在我们可以利用纯函数来安全地重构我们编写的代码。但是，为了做到这一点，我们需要了解依赖关系如何影响我们测试和更改代码的能力。
- en: Dependencies and change
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖和变更
- en: Our users and customers want more and more features, for as long as the project
    is successful. Yet, we often fail to deliver, because code tends to become more
    rigid over time. Adding new features gets slower and slower as time passes, and,
    when adding a feature, new bugs pop up.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户和客户希望项目成功的时间越长，就能获得越多的功能。然而，我们经常无法交付，因为随着时间的推移，代码往往变得越来越僵化。随着时间的推移，添加新功能变得越来越慢，而且在添加功能时会出现新的错误。
- en: This leads to the one-billion question—what makes code difficult to change?
    How can we write code that maintains the speed of change, or even increases it?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了一个十分重要的问题——是什么使代码难以更改？我们如何编写能够保持变更速度甚至增加变更速度的代码？
- en: This is a complex problem, with many facets and with various solutions. One
    of them is fundamentally agreed in the industry—dependencies tend to slow down
    development. Code structures with fewer dependencies are generally easier to change,
    thus making it easier to add features.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个复杂的问题，有许多方面和各种解决方案。其中一个在行业中基本上是一致的——依赖关系往往会减慢开发速度。具有较少依赖关系的代码结构通常更容易更改，从而更容易添加功能。
- en: We can look at dependencies on many levels. At a higher level, we can talk about
    executables that depend on other executables; for example, a web service that
    directly calls another web service. Reducing dependencies at this level can be
    done by using event-based systems instead of direct calls. At a lower level, we
    can talk about dependencies on libraries or OS routines; for example, a web service
    that depends on the existence of a specific folder or specific library version.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从许多层面来看依赖关系。在更高的层面上，我们可以谈论依赖于其他可执行文件的可执行文件；例如，直接调用另一个网络服务的网络服务。通过使用基于事件的系统而不是直接调用，可以减少这个层面上的依赖关系。在更低的层面上，我们可以谈论对库或操作系统例程的依赖；例如，一个网络服务依赖于特定文件夹或特定库版本的存在。
- en: While all the other levels are interesting, for our goals we will focus on the
    class/function level, and specifically on how classes and functions depend on
    one another. Since it's impossible to avoid dependencies in any non-trivial code
    bases, we will focus instead on the strength of dependencies.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然其他所有层面都很有趣，但对于我们的目标，我们将专注于类/函数级别，特别是类和函数如何相互依赖。由于在任何非平凡的代码库中都不可能避免依赖关系，因此我们将专注于依赖关系的强度。
- en: 'We''ll use as an example a small piece of code I wrote that computes salaries
    based on a list of employees and parameters such as role, seniority, continuity
    in the organization, and bonus level. It reads the list of employees from a CSV
    file, computes salaries based on a few rules, and prints the computed salary list.
    The first version of the code is naively written, using just the `main` function
    and putting everything together in the same file, as shown in the following code
    example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以我编写的一小段代码作为示例，该代码根据员工列表和角色、资历、组织连续性和奖金水平等参数计算工资。它从CSV文件中读取员工列表，根据一些规则计算工资，并打印计算出的工资列表。代码的第一个版本是天真地编写的，只使用`main`函数，并将所有内容放在同一个文件中，如下面的代码示例所示。
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The input file was generated with random values using a specialized tool and
    looks like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 输入文件是使用专门的工具生成的随机值，看起来像这样：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When we run the program, `salary` is computed for each employee and the output
    looks like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行程序时，为每个员工计算了`salary`，输出如下所示：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: So, does this code have dependencies? Yes, and they are hidden in plain sight.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这段代码有依赖关系吗？有，并且它们就在眼前。
- en: 'One way to find dependencies is to look for constructor calls or global variables.
    In our case, we have one constructor call to `ifstream`, and one use of the `cout`, as
    shown in the following example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 查找依赖关系的一种方法是查找构造函数调用或全局变量。在我们的例子中，我们有一个对`ifstream`的构造函数调用，以及一个对`cout`的使用，如下例所示：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Another way to identify dependencies is to create an imagination exercise. Imagine
    what requirements could produce changes in the code. There are a few. If we decide
    to switch to an employee database, we'll need to change the way we read data.
    If we want to output to a file, we'll need to change the lines of code that print
    the salaries. If the rules for computing salaries change, we will need to change
    the lines that compute `salary`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 识别依赖的另一种方法是进行一种想象练习。想象一下什么要求可能会导致代码的变化。有几种情况。如果我们决定切换到员工数据库，我们将需要改变读取数据的方式。如果我们想要输出到文件，我们将需要改变打印工资的代码行。如果计算工资的规则发生变化，我们将需要更改计算`salary`的代码行。
- en: 'Both methods lead to the same conclusion; we have dependencies on the file
    system and on the standard output. Let''s focus on the standard output and ask
    one question; how can we change the code so that we can output the salaries both
    to standard output and to a file? The answer is quite easy, due to the polymorphic
    nature of the **Standard Template Library** (**STL**) streams, just extract a
    function that receives an output stream and writes the data. Let''s see what such
    a function would look like; for simplicity, we''ve also introduced a structure
    called `Employee` that contains all the fields we need, as shown in the following
    example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都得出了相同的结论；我们对文件系统和标准输出有依赖。让我们专注于标准输出，并提出一个问题；我们如何改变代码，以便将工资输出到标准输出和文件中？答案非常简单，由于**标准模板库**（**STL**）流的多态性，只需提取一个接收输出流并写入数据的函数。让我们看看这样一个函数会是什么样子；为了简单起见，我们还引入了一个名为`Employee`的结构，其中包含我们需要的所有字段，如下例所示：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This function doesn''t depend on the standard output anymore. In terms of dependencies,
    we can say that *we broke the dependency* between the employee printing and the
    standard output. How did we do that? Well, we passed the `cout` stream as an argument
    of the function from the caller:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数不再依赖于标准输出。在依赖方面，我们可以说*我们打破了依赖关系*，即员工打印和标准输出之间的依赖关系。我们是如何做到的呢？嗯，我们将`cout`流作为函数的参数从调用者传递进来：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This seemingly minor change makes the function polymorphic. The caller of `printEmployee` now controls
    the output of the function without changing anything inside the function.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个看似微小的改变使函数成为多态的。`printEmployee`的调用者现在控制函数的输出，而不需要改变函数内部的任何东西。
- en: Moreover, we can now write tests for the `printEmployee` function that never
    touch the filesystem. This is important, since file system access is slow and
    errors can appear when testing the happy path due to things such as a lack of
    disk space or corrupted sections. How can we write such tests? Well, we just need
    to call the function using an in-memory stream, and then compare the output written
    into the in-memory stream with what we expect.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们现在可以为`printEmployee`函数编写测试，而不必触及文件系统。这很重要，因为文件系统访问速度慢，而且由于诸如磁盘空间不足或损坏部分等原因，在测试正常路径时可能会出现错误。我们如何编写这样的测试呢？嗯，我们只需要使用内存流调用该函数，然后将写入内存流的输出与我们期望的输出进行比较。
- en: Therefore, breaking this dependency leads to a huge improvement in the changeability
    and testability of our code. This mechanism is so useful and widespread that it
    gained a name—**dependency injection** (**DI**). In our case, the caller of the
    `printEmployee` function (the `main` function, the `test` function, or another
    future caller) injects the dependency to the output stream into our function,
    thus controlling its behavior.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，打破这种依赖关系会极大地改善我们代码的可更改性和可测试性。这种机制非常有用且广泛，因此它得到了一个名字——**依赖注入**（**DI**）。在我们的情况下，`printEmployee`函数的调用者（`main`函数、`test`函数或另一个未来的调用者）将依赖注入到我们的函数中，从而控制其行为。
- en: It's important to clarify one thing about DI—it is a design pattern, not a library.
    Many modern libraries and MVC frameworks enable DI, but you don't need anything
    external to inject dependencies. You just need to pass the dependency into a constructor,
    property, or function argument and you're all set.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 关于DI有一点很重要——它是一种设计模式，而不是一个库。许多现代库和MVC框架都支持DI，但您不需要任何外部内容来注入依赖关系。您只需要将依赖项传递给构造函数、属性或函数参数，然后就可以了。
- en: We learned how to identify dependencies and how we can use DI to break them.
    It's time to look at how we can refactor this code by taking advantage of pure
    functions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学会了如何识别依赖关系以及如何使用DI来打破它们。现在是时候看看我们如何利用纯函数来重构这段代码了。
- en: Pure functions and the structure of programs
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯函数和程序的结构
- en: 'A few years ago, I learned a fundamental law about computer programs that has
    led me to study how to use pure functions in refactoring:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，我学到了关于计算机程序的一个基本定律，这导致我研究如何在重构中使用纯函数：
- en: '*Any computer program can be built from two types of classes/functions—some
    that do I/O and some that are pure.*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何计算机程序都可以由两种类型的类/函数构建——一些进行I/O，一些是纯函数。*'
- en: Searching for similar ideas afterward, I found Gary Bernhardt's concise naming
    for such structures: *functional core, imperative shell* ([https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell](https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell)).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在之后寻找类似想法时，我发现Gary Bernhardt对这些结构的简洁命名：*functional core, imperative shell*（[https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell](https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell)）。
- en: 'Regardless of what you call it, the consequences of this idea on refactoring
    are fundamental. If any program can be written as two separate types of classes/functions,
    some immutable and some I/O, then we can take advantage of this property to refactor
    legacy code. The high-level process would look like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你如何称呼它，这个想法对重构的影响都是根本的。如果任何程序都可以被写成两种不同类型的类/函数，一些是不可变的，一些是I/O，那么我们可以利用这个属性来重构遗留代码。高层次的过程看起来会像这样：
- en: Extract pure functions (and we'll see that these steps identify dependencies).
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取纯函数（我们将看到这些步骤识别依赖关系）。
- en: Test and refactor them.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试和重构它们。
- en: Regroup them into classes according to the high-cohesion principle.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据高内聚原则将它们重新分组为类。
- en: I would like to add an axiom to this law. I believe we can apply this at any
    level of the code, be it a function, class, group of lines of code, group of classes,
    or whole module, except for those lines of code that are pure I/O. In other words,
    this law is fractal; it applies at any level of code except the most basic ones.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我想在这个定律中添加一个公理。我相信我们可以在代码的任何级别应用这个定律，无论是函数、类、代码行组、类组还是整个模块，除了那些纯I/O的代码行。换句话说，这个定律是分形的；它适用于代码的任何级别，除了最基本的代码行。
- en: The importance of this axiom is huge. What it tells us is that we can apply
    the same method we previously described on any level of the code, except the most
    basic. In other words, it doesn't matter where we start applying the method because
    it will work anywhere.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个公理的重要性是巨大的。它告诉我们的是，我们可以在代码的任何级别应用之前描述的相同方法，除了最基本的。换句话说，我们从哪里开始应用这个方法并不重要，因为它在任何地方都会起作用。
- en: In the following sections, we will explore each step of the method. First, let's
    extract some pure functions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将探讨该方法的每个步骤。首先，让我们提取一些纯函数。
- en: Use the compiler and pure functions to identify dependencies
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用编译器和纯函数来识别依赖关系。
- en: It can feel risky to try to change code that we don't understand and that doesn't
    have tests. Any mistake can lead to ugly bugs, and any change can lead to a mistake.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试更改我们不理解且没有测试的代码可能会感到冒险。任何错误都可能导致丑陋的错误，任何更改都可能导致错误。
- en: Fortunately, the compiler and pure functions can help reveal the dependencies.
    Remember what pure functions are—functions that return the same outputs for the
    same inputs. This means, by definition, that all dependencies of pure functions
    are visible, passed either as parameters, global variables, or through variable
    capture.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，编译器和纯函数可以帮助揭示依赖关系。记住纯函数是什么——对于相同的输入返回相同输出的函数。这意味着，根据定义，纯函数的所有依赖关系都是可见的，通过参数、全局变量或变量捕获传递。
- en: 'This leads us to a simple way to identify dependencies in code: pick a few
    lines of code, extract them into a function, make it pure, and let the compiler
    tell you what the dependencies are. In addition, the dependencies will have to
    be injected, thus leading us to a testable function.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这引导我们以一种简单的方式来识别代码中的依赖关系：选择几行代码，将它们提取到一个函数中，使其成为纯函数，然后让编译器告诉你依赖关系是什么。此外，这些依赖关系将需要被注入，从而使我们得到一个可测试的函数。
- en: 'Let''s look at a few examples. A simple start is the following few lines of
    code that compute the base salary based on a given employee''s position in the
    company:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看几个例子。一个简单的开始是下面几行代码，根据公司员工的职位计算基本工资：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s extract this as a pure function. The name doesn''t matter for now, so
    we''ll temporarily call it `doesSomething` and I''ll just copy and paste the lines
    of code into the new function, without removing them from the old function, as
    shown in the following example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其提取为一个纯函数。现在名称并不重要，所以我们暂时称之为`doesSomething`，然后我将代码行复制粘贴到新函数中，而不是从旧函数中删除它们，如下例所示：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'My compiler immediately complains that the position is not defined, so it did
    my work for me in figuring out the dependency. Let''s add it as an argument as
    shown in the following example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我的编译器立即抱怨说位置未定义，所以它帮我找出了依赖关系。让我们将其添加为一个参数，如下面的示例所示：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This function is missing something; pure functions always return values, but
    this does not. Let''s add the `return` statement as shown in the following code
    example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数缺少一些东西；纯函数总是返回值，但这个函数没有。让我们添加`return`语句，如下面的代码示例所示：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The function is now simple enough to test in isolation. But first, we need
    to extract it into a separate `.h` file and give it a proper name. `baseSalaryForPosition`
    sounds good; let''s see its tests in the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个函数足够简单，可以独立测试了。但首先，我们需要将其提取到一个单独的`.h`文件中，并给它一个合适的名称。`baseSalaryForPosition`听起来不错；让我们在下面的代码中看看它的测试：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The tests are fairly simple to write. They also duplicate many things from
    the function, the position strings and salary values included. There are better
    ways to organize the code, but that is expected from legacy code. For now, we
    are happy that we covered part of the initial code with tests. We can also show
    these tests to a domain expert and check that they are correct, but let''s continue
    with our refactoring. We need to start calling the new function from `main()`, as
    shown in the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 编写这些测试相当简单。它们也重复了许多来自函数的东西，包括位置字符串和薪水值。有更好的方法来组织代码，但这是预期的遗留代码。现在，我们很高兴我们用测试覆盖了初始代码的一部分。我们还可以向领域专家展示这些测试，并检查它们是否正确，但让我们继续进行重构。我们需要从`main()`开始调用新函数，如下所示：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'While this was an easy case, it shows the basic process, as listed in the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个简单的案例，但它展示了基本的过程，如下所示：
- en: Pick a few lines of code.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择几行代码。
- en: Extract them into a function.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将它们提取到一个函数中。
- en: Make the function pure.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使函数成为纯函数。
- en: Inject all dependencies.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入所有依赖。
- en: Write tests for the new pure function.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为新的纯函数编写测试。
- en: Validate the behaviors.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证行为。
- en: Repeat until the whole code is covered in tests.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复，直到整个代码都被测试覆盖。
- en: If you follow this process, the risk of introducing bugs becomes extremely small.
    From my experience, what you need to be most careful about is making the function
    pure. Remember—if it's in a class, make it static with `const` parameters, but
    if it's outside of a class, pass all parameters as `const` and make it a lambda.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遵循这个过程，引入错误的风险将变得极小。根据我的经验，您需要最小心的是使函数成为纯函数。记住——如果它在一个类中，将其设为带有`const`参数的静态函数，但如果它在类外部，将所有参数作为`const`传递，并将其设为lambda。
- en: 'If we repeat this process a few more times, we end up with more pure functions.
    First,  `factorForSeniority` computes the factor based on the seniority level,
    as shown in the following example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重复这个过程几次，我们最终会得到更多的纯函数。首先，`factorForSeniority`根据资历级别计算因子，如下例所示：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, `factorForContinuity` computes the factor based on—you guessed it—continuity:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`factorForContinuity`根据——你猜对了——连续性计算因子：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, the `bonusLevel` function reads the bonus level:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`bonusLevel`函数读取奖金级别：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Each of these functions can be easily tested with example-based, data-driven,
    or property-based tests. With all these functions extracted, our main method looks
    like the following example (a few lines were omitted for brevity):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数中的每一个都可以很容易地通过基于示例的、数据驱动的或基于属性的测试进行测试。提取了所有这些函数后，我们的主要方法看起来像以下示例（为简洁起见，省略了几行）：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is a bit cleaner and better covered with tests. Lambdas can be used for
    much more though; let's see how we can do this.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这样会更清晰，而且测试覆盖更好。然而，lambda还可以用于更多的操作；让我们看看我们如何做到这一点。
- en: From legacy code to lambdas
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从遗留代码到lambda
- en: 'Besides purity, lambdas offer us many operations we can use: functional composition,
    partial application, currying, and higher-level functions. We can take advantage
    of these operations while refactoring legacy code.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 除了纯度，lambda还为我们提供了许多可以使用的操作：函数组合、部分应用、柯里化和高级函数。在重构遗留代码时，我们可以利用这些操作。
- en: 'The easiest way to show this is by extracting the whole `salary` computation
    from the `main` method. These are the lines of code that compute the `salary`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 展示这一点最简单的方法是从`main`方法中提取整个`salary`计算。以下是计算`salary`的代码行：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can extract this pure function in two ways—one is by passing in every value
    needed as a parameter, the result of which is shown in the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以两种方式提取这个纯函数——一种是将需要的每个值作为参数传递，结果如下所示：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The second option is much more interesting. Instead of passing the variables,
    how about we pass the functions and bind them to the needed variables beforehand?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项更有趣。与其传递变量，不如我们传递函数并事先将它们绑定到所需的变量？
- en: 'That''s an intriguing idea. The result is a function that receives multiple
    functions as a parameter, each of them without any arguments:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有趣的想法。结果是一个接收多个函数作为参数的函数，每个函数都没有任何参数：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `main` method needs to bind the functions first and then inject them into
    our method, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`方法需要首先绑定这些函数，然后将它们注入到我们的方法中，如下所示：'
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Why is this approach interesting? Well, let's look at it from a software design
    perspective. We created small pure functions that each have a clear responsibility.
    Then, we bound them to specific values. Afterward, we passed them as arguments
    to another lambda that uses them to compute the result we need.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这种方法很有趣？好吧，让我们从软件设计的角度来看看。我们创建了小的纯函数，每个函数都有明确的责任。然后，我们将它们绑定到特定的值。之后，我们将它们作为参数传递给另一个lambda，该lambda使用它们来计算我们需要的结果。
- en: What would that mean in an **object-oriented programming** (**OOP**) style?
    Well, functions would be part of a class. Binding a function to a value is equivalent
    to calling the constructor of the class. Passing the object to another function
    is called DI.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在**面向对象编程**（**OOP**）风格中，这意味着什么？好吧，函数将成为类的一部分。将函数绑定到值相当于调用类的构造函数。将对象传递给另一个函数称为DI。
- en: Wait a minute! What we are actually doing is separating responsibilities and
    injecting dependencies, only by using pure functions instead of objects! Because
    we use pure functions, the dependencies are made evident by the compiler. Therefore,
    we have a method to refactor code that has a very small probability of error,
    because we use the compiler a lot. This is a very useful process for refactoring.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下！实际上我们正在分离责任并注入依赖项，只是使用纯函数而不是对象！因为我们使用纯函数，依赖关系由编译器明确表示。因此，我们有一种重构代码的方法，几乎没有错误的可能性，因为我们经常使用编译器。这是一个非常有用的重构过程。
- en: I have to admit that the result is not as nice as I'd like. Let's refactor our
    lambda.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我不得不承认，结果并不如我所希望的那样好。让我们重构我们的lambda。
- en: Refactoring lambdas
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构lambda
- en: 'I''m not happy with what the `computeSalary` lambda we''ve extracted looks
    like. It''s quite complex due to receiving many parameters and multiple responsibilities.
    Let''s take a closer look at it, and see how we can improve it:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我对我们提取出来的`computeSalary` lambda的样子并不满意。由于接收了许多参数和多个责任，它相当复杂。让我们仔细看看它，看看我们如何可以改进它：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'All the signs seem to point to the fact that the function has multiple responsibilities.
    What if we extract more functions from it? Let''s start with the `specialBonusFactor`
    computation:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 所有迹象似乎表明这个函数有多个责任。如果我们从中提取更多的函数会怎样呢？让我们从`specialBonusFactor`计算开始：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can now inject `specialBonusFactor`. However, notice that `specialBonusFactor`
    is the only lambda that needs `bonusLevel`. This means that we can replace the
    `bonusLevel` lambda with the `specialBonusFactor` lambda partially applied to
    `bonusLevel`, as shown in the following example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以注入`specialBonusFactor`。但是，请注意，`specialBonusFactor`是唯一需要`bonusLevel`的lambda。这意味着我们可以将`bonusLevel`
    lambda部分应用于`specialBonusFactor` lambda，如下例所示：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Our `computeSalary` lambda is now smaller. We can make it even smaller still, by
    inlining the temporary variables:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`computeSalary` lambda现在更小了。我们甚至可以通过内联临时变量使它更小：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'That''s pretty good! However, I''d like to get it closer to a mathematical
    formula. First, let''s rewrite the line computing `salary` (highlighted in bold
    in the code):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这很不错！然而，我想让它更接近一个数学公式。首先，让我们重写计算`salary`的那一行（在代码中用粗体标出）：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, let''s replace the variable with the functions. We are then left with
    the following code example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们用函数替换变量。然后我们得到以下代码示例：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Therefore, we have a lambda that receives multiple lambdas and uses them to
    compute a value. We could still make improvements to the other functions, but
    we have reached an interesting point.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个lambda函数，它接收多个lambda函数并使用它们来计算一个值。我们仍然可以对其他函数进行改进，但我们已经达到了一个有趣的点。
- en: So where do we go from here? We've injected dependencies, the code is more modular,
    easier to change, and easier to test. We can inject lambdas from tests that return
    the values we want, which is actually a stub in unit testing. While we haven't
    improved the whole code, we have separated dependencies and responsibilities by
    extracting pure functions and using functional operations. We can leave the code
    like this if we want to. Or, we can take another step and regroup the functions
    into classes.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们接下来该怎么办呢？我们已经注入了依赖关系，代码更加模块化，更容易更改，也更容易测试。我们可以从测试中注入lambda函数，返回我们想要的值，这实际上是单元测试中的一个stub。虽然我们没有改进整个代码，但我们通过提取纯函数和使用函数操作来分离依赖关系和责任。如果我们愿意，我们可以把代码留在这样。或者，我们可以迈出另一步，将函数重新分组成类。
- en: From lambdas to classes
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从lambda到类
- en: We've already made the point a few times in this book, that a class is nothing
    more than a set of cohesive partially applied pure functions. With our technique
    until now, we've created a bunch of partially applied pure functions. Turning
    them into classes is a simple task now.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们已经多次指出，一个类只不过是一组具有内聚性的部分应用纯函数。到目前为止，我们使用的技术已经创建了一堆部分应用的纯函数。现在将它们转换成类是一项简单的任务。
- en: 'Let''s see a simple example of the `baseSalaryForPosition` function:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个`baseSalaryForPosition`函数的简单例子：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We use it in `main()` as in the following example:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`main()`中使用它，就像下面的例子一样：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To turn it into a class, we just need to create a constructor that will receive
    the `position` parameter and then change it to be a class method. Let''s see it
    in the following example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要将其转换成类，我们只需要创建一个接收`position`参数的构造函数，然后将其改为类方法。让我们在下面的示例中看一下：
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Instead of passing the partially applied function into the `computeSalary`
    lambda, we can simply initialize it and pass the object, as shown in the following
    code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地将部分应用函数传递给`computeSalary` lambda，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'For this to work, we also need to change our `computeSalary` lambda as shown
    here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其工作，我们还需要像这里所示的改变我们的`computeSalary` lambda：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, to allow the injection of different implementations, we actually need to
    extract an interface from the `BaseSalaryForPosition` class and inject it as an
    interface, instead of a class. This is especially useful for injecting doubles
    from tests, such as stubs or mocks.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了允许注入不同的实现，我们实际上需要从`BaseSalaryForPosition`类中提取一个接口，并将其作为接口注入，而不是作为一个类。这对于从测试中注入double值非常有用，比如stub或mock。
- en: From now on, nothing stops you regrouping the functions into classes as you
    see fit. I will leave this as an exercise for the reader because I believe we
    have shown how to use pure functions to refactor code, even when we want to obtain
    the object-oriented code at the end.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，你可以根据自己的需要将函数重新分组成类。我会把这留给读者作为一个练习，因为我相信我们已经展示了如何使用纯函数来重构代码，即使我们最终想要得到面向对象的代码。
- en: Recapping the refactoring method
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重温重构方法
- en: What have we learned so far? Well, we went through a structured process of refactoring
    that can be used at any level in the code, reduces the probability of errors,
    and enables changeability and testing. The process is based on two fundamental
    ideas—any program can be written as a combination of immutable functions and I/O
    functions, or as a functional core within an imperative shell. In addition, we
    have shown that this property is fractal—we can apply it to any level of code,
    from a few lines up to a whole module.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们学到了什么？嗯，我们经历了一个结构化的重构过程，可以在代码的任何级别使用，减少错误的概率，并实现可更改性和测试性。这个过程基于两个基本思想——任何程序都可以被写成不可变函数和I/O函数的组合，或者作为一个函数核心在一个命令式外壳中。此外，我们已经表明这个属性是分形的——我们可以将它应用到任何代码级别，从几行到整个模块。
- en: Since immutable functions can be the core of our programs, we can extract them
    little by little. We write the new function name, copy and paste the body, and
    use the compiler to pass any dependencies as arguments. When the code is compiled,
    and if we're carefully and slowly changing it, we are fairly sure that the code
    still works properly. This extraction reveals the dependencies of our function,
    thus allowing us to make design decisions.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不可变函数可以成为我们程序的核心，我们可以逐渐提取它们。我们写下新的函数名称，复制并粘贴函数体，并使用编译器将任何依赖项作为参数传递。当代码编译完成时，如果我们小心而缓慢地进行更改，我们可以相当确信代码仍然正常工作。这种提取揭示了我们函数的依赖关系，从而使我们能够做出设计决策。
- en: Going forward, we will extract more functions that receive other partially applied
    pure functions as parameters. This leads to a clear distinction between dependencies
    and actual breaking dependencies.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将提取更多的函数，这些函数接收其他部分应用的纯函数作为参数。这导致了依赖关系和实际的破坏性依赖关系之间的明显区别。
- en: Finally, since the partially applied functions are equivalent to classes, we
    can easily encapsulate one or more of them, based on cohesion. This process works
    whether we start from classes or functions, and it's no matter if we want to end
    with functions or classes as well. However, it allows us to use functional constructs
    to break dependencies and to separate responsibilities in our code.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于部分应用函数等同于类，我们可以根据内聚性轻松地封装一个或多个函数。这个过程无论我们是从类还是函数开始，都可以工作，而且无论我们最终想要以函数或类结束都没有关系。然而，它允许我们使用函数构造来打破依赖关系，并在我们的代码中分离责任。
- en: Since we are improving the design, it's time to see how design patterns apply
    in functional programming and how to refactor toward them. We'll visit a few of
    the Gang of Four patterns, as well as DI, which we've already used in our code.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在改进设计，现在是时候看看设计模式如何应用于函数式编程以及如何向它们重构。我们将访问一些四人帮模式，以及我们已经在我们的代码中使用过的DI。
- en: Design patterns
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式
- en: Many of the good things in software development come from people who notice
    how programmers work and extract certain lessons from it; in other words, looking
    at the practical approaches and extracting common and useful lessons rather than
    speculating a solution.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发中的许多好东西都来自于那些注意到程序员工作方式并从中提取某些教训的人；换句话说，看待实际方法并提取共同和有用的教训，而不是推测解决方案。
- en: The so-called Gang of Four (Erich Gamma, Richard Helm, Ralph Johnson, and John
    Vlissides) took this exact approach when they documented, in a precise language,
    a list of design patterns. After noticing how more programmers were solving the
    same problems in similar ways, they decided to write these patterns down and introduced
    the world of programming to the idea of reusable solutions to specific problems
    within a clear context.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 所谓的四人帮（Erich Gamma，Richard Helm，Ralph Johnson和John Vlissides）在记录设计模式时采取了这种确切的方法，用精确的语言列出了一系列设计模式。在注意到更多程序员以类似的方式解决相同问题后，他们决定将这些模式写下来，并向编程世界介绍了在明确上下文中对特定问题的可重用解决方案的想法。
- en: Since the design paradigm of the day was OOP, the *Design Patterns* book they
    published shows these solutions using object-oriented approaches. As an aside,
    it's quite interesting to notice that they documented at least two types of solutions
    wherever possible—one based on careful inheritance and the other on object composition.
    I've spent many hours studying the design patterns book, and I can tell you that
    it's a very interesting lesson in software design.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于当时的设计范式是面向对象编程，他们出版的*设计模式*书籍展示了使用面向对象方法的这些解决方案。顺便说一句，有趣的是注意到他们在可能的情况下至少记录了两种类型的解决方案——一种基于继承，另一种基于对象组合。我花了很多时间研究设计模式书籍，我可以告诉你，这是一个非常有趣的软件设计课程。
- en: We'll be exploring a few design patterns and how to implement them using functions
    in the next section.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中探讨一些设计模式以及如何使用函数来实现它们。
- en: The strategy pattern, functional style
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略模式，功能风格
- en: The strategy pattern can be described briefly as a way to structure your code,
    which allows the selection of an algorithm at runtime. The OOP implementation
    uses DI, and you're probably familiar with both the object-oriented and functional
    design from STL.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式可以简要描述为一种结构化代码的方式，它允许在运行时选择算法。面向对象编程的实现使用DI，你可能已经熟悉STL中的面向对象和功能性设计。
- en: 'Let''s take a look at the STL `sort` function. Its most complex form requires
    a functor object as shown in the following example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看STL `sort`函数。其最复杂的形式需要一个函数对象，如下例所示：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `sort` function uses the `comparator` object to compare elements from the
    vector and sort it in place. It's a strategy pattern because we can exchange `comparator`
    with anything that has the same interface; in fact, it just requires the `operator()`
    function to be implemented. We could imagine, for example, a UI in which a human
    user selects the comparison function and sorts a list of values using it; we would
    only need to create the right instance of `comparator` at runtime and send it
    to the `sort` function.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort`函数使用`comparator`对象来比较向量中的元素并对其进行排序。这是一种策略模式，因为我们可以用具有相同接口的任何东西来交换`comparator`；实际上，它只需要实现`operator()`函数。例如，我们可以想象一个用户在UI中选择比较函数并使用它对值列表进行排序；我们只需要在运行时创建正确的`comparator`实例并将其发送给`sort`函数。'
- en: 'You can already see the seeds of the functional solution. In fact, the `sort`
    function allows a much simpler version, as shown in the following example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经可以看到功能性解决方案的种子。事实上，`sort`函数允许一个更简单的版本，如下例所示：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This time, we drop the ceremony and jump straight into implementing what we
    need—a comparison function that we plug into `sort`. No more classes, no more
    operators—a strategy is just a function.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们放弃了仪式感，直接开始实现我们需要的东西——一个可以插入`sort`的比较函数。不再有类，不再有运算符——策略只是一个函数。
- en: Let's see how this works in a more complex context. We will use the problem
    from the Wikipedia page on the *Strategy pattern*, [https://en.wikipedia.org/wiki/Strategy_pattern](https://en.wikipedia.org/wiki/Strategy_pattern),
    and write it using a functional approach.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这在更复杂的情境中是如何工作的。我们将使用维基百科关于*策略模式*的页面上的问题，并使用功能性方法来编写它。
- en: 'Here''s the problem: we need to write a billing system for a pub that can apply
    a discount for the happy hour. The problem lends itself to the usage of the strategy
    pattern since we have two strategies for computing the final price of the bill—one
    that returns the full price, while the second returns a happy hour discount on
    the full bill (we''ll use 50% in our case). Once again, the solution is to simply
    use two functions for the two strategies—the `normalBilling` function that just
    returns the full price it receives and the `happyHourBilling` function that returns
    half the value it receives. Let''s see this in action in the following code (resulting
    from my **test-driven development** (**TDD**) approach):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有个问题：我们需要为一家酒吧编写一个计费系统，可以在欢乐时光时应用折扣。这个问题适合使用策略模式，因为我们有两种计算账单最终价格的策略——一种返回全价，而另一种返回全账单的欢乐时光折扣（在我们的例子中使用50%）。再次，解决方案就是简单地使用两个函数来实现这两种策略——`normalBilling`函数只返回它接收到的全价，而`happyHourBilling`函数返回它接收到的值的一半。让我们在下面的代码中看看这个解决方案（来自我的测试驱动开发（TDD）方法）：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: I think this shows that the simplest implementation for a strategy is a function.
    I personally enjoy the simplicity this model brings to the strategy pattern; it's
    liberating to write minimal useful code that makes things work.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这表明，策略的最简单实现是一个函数。我个人喜欢这种模型为策略模式带来的简单性；编写最小的有用代码使事情正常运行是一种解放。
- en: The command pattern, functional style
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令模式，函数式风格
- en: The command pattern is one that I've used extensively in my work. It fits perfectly
    with MVC web frameworks, allowing the separation of the controller into multiple
    pieces of functionality, and at the same time allows separation from the storage
    format. Its intent is to separate a request from the action—that's what makes
    it so versatile, since any call can be seen as a request.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式是我在工作中广泛使用的一种模式。它与MVC网络框架完美契合，允许将控制器分离为多个功能片段，并同时允许与存储格式分离。它的意图是将请求与动作分离开来——这就是它如此多才多艺的原因，因为任何调用都可以被视为一个请求。
- en: A simple example of usage for the command pattern is in games that support multiple
    controllers and changing the keyboard shortcuts. These games can't afford to link
    the *W* key press event directly to the code that moves your character up; instead,
    you bind the *W* key to a `MoveUpCommand`, thus neatly decoupling the two. We
    can easily change the controller event associated with the command or the code
    for moving up, without interference between the two.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式的一个简单用法示例是在支持多个控制器和更改键盘快捷键的游戏中。这些游戏不能直接将*W*键按下事件与移动角色向上的代码关联起来；相反，您将*W*键绑定到`MoveUpCommand`，从而将两者清晰地解耦。我们可以轻松地更改与命令关联的控制器事件或向上移动的代码，而不会干扰两者之间的关系。
- en: 'When we look at how commands are implemented in object-oriented code, the functional
    solution becomes equally obvious. A `MoveUpCommand` class would look like the
    following example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看命令在面向对象代码中是如何实现的时，函数式解决方案变得同样明显。`MoveUpCommand`类将如下例所示：
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'I said it was obvious! What we''re actually trying to accomplish is easily
    done with a named function, as shown in the following example:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我说过这是显而易见的！我们实际上要做的是很容易用一个命名函数来完成，如下例所示：
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The simplest command pattern is a function. Who would have thought it?
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的命令模式就是一个函数。谁会想到呢？
- en: Dependency injection with functions
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数依赖注入
- en: We can't talk about widely spread design patterns without touching on DI. While
    not defined in the Gang of Four book, the pattern has become so common in modern
    code that many programmers know it as being part of a framework or library rather
    than as the design pattern.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 谈论广泛传播的设计模式时，不能不提及DI。虽然没有在《四人组》的书中定义，但这种模式在现代代码中变得如此普遍，以至于许多程序员认为它是框架或库的一部分，而不是设计模式。
- en: 'The intent of the DI pattern is to separate the creation of dependencies for
    a class or function from their behavior. To understand the problem it solves,
    let''s look at this code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: DI模式的意图是将类或函数的依赖项的创建与其行为分离。为了理解它解决的问题，让我们看看这段代码：
- en: '[PRE36]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This is pretty fair code to write if all you need to do is add together two
    numbers read from a file. Unfortunately, in the real world, our clients will most
    likely require more sources for reading the numbers, such as, a console, as shown
    in the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只需要从文件中读取两个数字并将它们相加，那么这是相当合理的代码。不幸的是，在现实世界中，我们的客户很可能需要更多的读取数字的来源，比如，如下所示，控制台：
- en: '[PRE37]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Before moving on, please note that the test for this function will pass only
    if you introduce from the console 2 numbers whose sum is `30`. Because they require
    input at every run, the test case is commented in our code sample; please feel
    free to enable it and play around with it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请注意，此函数的测试只有在您从控制台输入两个和为`30`的数字时才会通过。因为它们需要在每次运行时输入，所以测试用例在我们的代码示例中被注释了；请随意启用它并进行测试。
- en: 'The two functions look very similar. To solve such similarities, DI can help
    as shown in the following example:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数看起来非常相似。为了解决这种相似之处，DI可以帮助，如下例所示：
- en: '[PRE38]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now we can implement readers that use files:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实现使用文件的读取器：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can also implement readers who use the console:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以实现使用控制台的读取器：
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As usual, we can test that they work correctly in various combinations, as
    shown in the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们可以测试它们在各种组合中是否正确工作，如下所示：
- en: '[PRE41]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We are injecting the code that reads the numbers through a lambda. Please note
    in the test code that using this method allows us to mix and match the dependencies
    as we see fit—the last check reads the first number from a file, while the second
    is read from the console.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过lambda注入了读取数字的代码。请注意测试代码中使用此方法允许我们随心所欲地混合和匹配依赖项——最后一个检查从文件中读取第一个数字，而第二个数字从控制台中读取。
- en: Of course, the way we usually implement DI in object-oriented languages uses
    interfaces and classes. However, as we can see, the simplest way to implement
    DI is with a function.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们通常在面向对象语言中实现DI的方式是使用接口和类。然而，正如我们所看到的，实现DI的最简单方式是使用函数。
- en: Purely functional design patterns
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯函数式设计模式
- en: So far, we've seen how some of the classic object-oriented design patterns can
    be turned into a functional variant. But can we imagine design patterns that stem
    from functional programming?
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了一些经典面向对象设计模式如何转变为函数变体。但我们能想象出源自函数式编程的设计模式吗？
- en: Well, we've actually already used some of them. `map`/`reduce` (or `transform`/`accumulate`
    in STL) is one example. Most of the higher-order functions (such as `filter`,
    `all_of`, and `any_of`,  among others) are also examples of patterns. However,
    we can go even further and explore a common, but opaque, design pattern that comes
    from functional programming.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我们实际上已经使用了其中一些。`map`/`reduce`（或STL中的`transform`/`accumulate`）就是一个例子。大多数高阶函数（如`filter`、`all_of`和`any_of`等）也是模式的例子。然而，我们甚至可以进一步探索一种常见但不透明的设计模式，它源自函数式编程。
- en: The best way to understand it is by starting from specific problems. First,
    we'll see how we can maintain state in an immutable context. Then, we'll learn
    about the design pattern. Finally, we'll see it in action in another context.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 理解它的最佳方法是从具体的问题开始。首先，我们将看看如何在不可变的上下文中保持状态。然后，我们将了解设计模式。最后，我们将在另一个上下文中看到它的应用。
- en: Maintaining state
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持状态
- en: How can we maintain state in functional programming? This may seem like a strange
    question, given that one of the ideas behind functional programming is immutability,
    which, in turn, seems to prevent state change.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中如何保持状态？鉴于函数式编程背后的一个想法是不可变性，这似乎是一个奇怪的问题，因为不可变性似乎阻止了状态的改变。
- en: However, this limitation is an illusion. To understand it, let's think for a
    moment about how time passes. If I put on a hat, I change my state from hat off
    to hat on. If I could look back in time second by second from the moment I reached
    for the hat until I had it on, I would be able to see how my movement advanced
    each second toward this goal. But I can't change anything from any past second.
    The past is immutable, whether we like it or not (after all, maybe I look silly
    with the hat, but I can't revert it). So nature makes time work in such a way
    that the past is immutable, yet we can change state.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种限制是一种幻觉。为了理解这一点，让我们想一想时间是如何流逝的。如果我戴上帽子，我就会从没戴帽子变成戴帽子。如果我能够一秒一秒地回顾过去，从我伸手拿帽子的那一刻到戴上它，我就能看到我的每一次动作是如何每秒向着这个目标前进的。但我无法改变任何过去的一秒。无论我们喜欢与否，过去是不可改变的（毕竟，也许我戴帽子看起来很傻，但我无法恢复它）。因此，自然使时间以这样的方式运行，过去是不可改变的，但我们可以改变状态。
- en: 'How can we model this conceptually? Well, think about it this way—first, we
    have an initial state, Alex with hat off, and a definition of a movement with
    the intent to reach the hat and put it on. In programming terms, we model the
    movement with a function. The function receives the position of the hand and the
    function itself, and returns the new position of the hand plus the function. Therefore,
    by copying nature, we end up with the sequence of states in the following example:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在概念上对这进行建模？好吧，这样想一想——首先，我们有一个初始状态，亚历克斯没戴帽子，以及一个意图到达帽子并戴上的运动定义。在编程术语中，我们用一个函数来模拟运动。该函数接收手的位置和函数本身，并返回手的新位置加上函数。因此，通过模仿自然，我们得到了以下示例中的状态序列：
- en: '[PRE42]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: By applying `MovementFunction` repeatedly, we end up with a sequence of states. *Each
    of the states is immutable, yet we can store the state*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 通过反复应用`MovementFunction`，我们最终得到一系列状态。*每个状态都是不可变的，但我们可以存储状态*。
- en: Now let's see a simple example in C++. The simplest example we can use is an
    autoincrement index. The index needs to remember the last value used and use an
    `increment` function to return the next value from the index. Normally, we would
    be in trouble when trying to implement this using immutable code, but can we do
    it with the method described previously?
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一个在C++中的简单例子。我们可以使用的最简单的例子是一个自增索引。索引需要记住上次使用的值，并使用`increment`函数从索引返回下一个值。通常情况下，我们在尝试使用不可变代码实现这一点时会遇到麻烦，但我们可以用之前描述的方法做到吗？
- en: 'Let''s find out. First, we need to initialize the auto-increment index with
    the first value—let''s say it''s `1`. As usual, I''d like to check that the value
    is initialized to what I expect, as shown in the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找出来。首先，我们需要用第一个值初始化自增索引——假设它是`1`。像往常一样，我想检查值是否初始化为我期望的值，如下所示：
- en: '[PRE43]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note that, since the `autoIncrementIndex` does not change, we can make it `const`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于`autoIncrementIndex`不会改变，我们可以将其设为`const`。
- en: 'How do we implement `initAutoIncrement`? As we said, we need to initialize
    a structure that holds both the current value (`1` in this case) and the increment
    function. I will start with a pair like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何实现`initAutoIncrement`？正如我们所说，我们需要初始化一个结构，其中包含当前值（在这种情况下为`1`）和增量函数。我将从这样的一对开始：
- en: '[PRE44]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As for the previous `value` function, it just returns the value from the pair;
    it is the first element from the pair, as shown in the following snippet:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 至于之前的`value`函数，它只是返回一对中的值；它是一对中的第一个元素，如下面的代码片段所示：
- en: '[PRE45]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s compute now the next element from our autoincrement index. We initialize
    it, then compute the next value, and check that the next value is `2`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们计算一下我们的自增索引的下一个元素。我们初始化它，然后计算下一个值，并检查下一个值是否为`2`：
- en: '[PRE46]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Once again, please note that both `autoIncrementIndex` variables are `const` because
    they never mutate. We have the value function already, but what does the `computeNextAutoIncrement`
    function look like? Well, it has to take the current value and the function from
    the pair, apply the function to the current value, and return a pair between the
    new value and the function:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 请再次注意，由于它们永远不会变化，所以两个`autoIncrementIndex`变量都是`const`。我们已经有了值函数，但`computeNextAutoIncrement`函数是什么样子的呢？好吧，它必须接受当前值和一对中的函数，将函数应用于当前值，并返回新值和函数之间的一对：
- en: '[PRE47]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We''re using a utility function, `lambda`, that returns the lambda from the
    pair:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用一个实用函数`lambda`，它返回一对中的lambda：
- en: '[PRE48]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Does this really work? Let''s test the next value:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这真的有效吗？让我们测试下一个值：
- en: '[PRE49]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: All the tests pass, showing that we have just stored the state in an immutable
    way!
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的测试都通过了，表明我们刚刚以不可变的方式存储了状态！
- en: Since this solution seems very simple, the next question is—can we generalize
    it? Let's try.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个解决方案看起来非常简单，下一个问题是——我们能否将其概括化？让我们试试看。
- en: 'First, let''s replace `pair` with `struct`. The struct needs to have a value
    and function that will compute the next value as data members. This will remove
    the need for our `value()` and `lambda()` functions:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们用`struct`替换`pair`。结构需要有一个值和一个计算下一个值的函数作为数据成员。这将消除我们的`value()`和`lambda()`函数的需要：
- en: '[PRE50]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `int` type repeats itself, but why should it? A state can be more complex
    than just `int`, so let''s turn our `struct` into a template:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`int`类型会重复出现，但为什么呢？状态可能比`int`更复杂，所以让我们把`struct`变成一个模板：'
- en: '[PRE51]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'With this, we can initialize an autoincrement index and check the initial value:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以初始化一个自增索引并检查初始值：
- en: '[PRE52]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Lastly, we need a function that computes the next `State`. The function needs
    to return a `State<ValueType>`, so it''s best to encapsulate it into the `State`
    struct. Also, it can use the current value, so there is no need to pass a value
    into it:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个计算下一个`State`的函数。该函数需要返回一个`State<ValueType>`，所以最好将其封装到`State`结构中。此外，它可以使用当前值，因此无需将值传递给它：
- en: '[PRE53]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'With this implementation, we can now check the next two values of our autoincrement
    index:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个实现，我们现在可以检查我们的自动增量索引的下两个值：
- en: '[PRE54]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The tests pass, so the code works! Now let's play with it some more.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通过了，所以代码有效！现在让我们再玩一会儿。
- en: Let's imagine we are implementing a simple Tic-Tac-Toe game. We'd like to use
    the same pattern to compute the next state of the board after a move.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在实现一个简单的井字棋游戏。我们希望在移动后使用相同的模式来计算棋盘的下一个状态。
- en: 'First, we need a structure that can hold a TicTacToe board. For simplicity,
    I will use `vector<vector<Token>>`, where `Token` is an `enum` that can hold the `Blank`,
    `X`, or `O` values:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个可以容纳TicTacToe棋盘的结构。为简单起见，我将使用`vector<vector<Token>>`，其中`Token`是一个可以容纳`Blank`、`X`或`O`值的`enum`：
- en: '[PRE55]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, we need a `Move` structure. The `Move` structure needs to contain the
    board coordinates of the move and the token used to make the move:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要一个`Move`结构。`Move`结构需要包含移动的棋盘坐标和用于进行移动的标记：
- en: '[PRE56]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We also need a function that can take a `TicTacToeBoard`, apply a move, and
    return the new board. For simplicity, I will implement it with local mutation,
    as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个函数，它可以接受一个`TicTacToeBoard`，应用一个移动，并返回新的棋盘。为简单起见，我将使用本地变异来实现它，如下所示：
- en: '[PRE57]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We also need an empty board to initialize our `State`. Let''s just fill it
    with `Token::Blank` by hand:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个空白的棋盘来初始化我们的`State`。让我们手工填充`Token::Blank`：
- en: '[PRE58]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We''d like to make the first move. However, our `makeMove` function doesn''t
    have the signature allowed by the `State` structure; it takes an additional parameter, `Move`.
    For a first test, we can just bind the `Move` parameter to a hardcoded value.
    Let''s say that `X` moves to the upper left corner, coordinates *(0,0)*:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要进行第一步移动。但是，我们的`makeMove`函数不符合`State`结构允许的签名；它需要一个额外的参数，`Move`。首先，我们可以将`Move`参数绑定到一个硬编码的值。假设`X`移动到左上角，坐标为*(0,0)*：
- en: '[PRE59]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'As you can see, our `State` structure works fine in this case. However, it
    has a limitation: it will only allow one move. The problem is that the function
    that computes the next stage cannot change. But what if we passed it as a parameter
    to the `nextState()` function instead? We end up with a new structure; let''s
    call it `StateEvolved`. It holds a value and a `nextState()` function that takes
    the function that computes the next state, applies it, and returns the next `StateEvolved`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的`State`结构在这种情况下运行良好。但是，它有一个限制：它只允许一次移动。问题在于计算下一个阶段的函数不能更改。但是，如果我们将其作为参数传递给`nextState()`函数呢？我们最终得到了一个新的结构；让我们称之为`StateEvolved`。它保存一个值和一个`nextState()`函数，该函数接受计算下一个状态的函数，应用它，并返回下一个`StateEvolved`：
- en: '[PRE60]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We can now make a move by passing into `nextState` the `makeMove` function
    with the `Move` parameter bound to the actual move:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过将`makeMove`函数与绑定到实际移动的`Move`参数一起传递给`nextState`来进行移动：
- en: '[PRE61]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We can now make a second move. Let''s say `O` moves in the center to coordinates
    *(1, 1)*. Let''s check the before-and-after state:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以进行第二步移动。假设`O`移动到坐标*(1,1)*的中心。让我们检查前后状态：
- en: '[PRE62]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As you can see, using this pattern we can store any state in an immutable way.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，使用这种模式，我们可以以不可变的方式存储任何状态。
- en: The reveal
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 揭示
- en: The design pattern we discussed previously seems very useful for functional
    programming, but you may have realized that I've avoided naming it.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论的设计模式对函数式编程似乎非常有用，但你可能已经意识到我一直在避免命名它。
- en: In fact, the pattern we have discussed so far is one example of a monad, specifically
    a `State` monad. I've avoided telling you its name until now because monads are
    a particularly opaque topic in software development. For this book, I have watched
    hours of videos on monads; I have also read blog posts and articles, and for some
    reason none of them was understandable. Since a monad is a mathematical object
    from category theory, some of the resources I mentioned take the mathematical
    approach and explain them using definitions and operators. Other resources try
    to explain by example, but they are written in programming languages with native
    support for the monad pattern. None of them fit our goals for this book—a practical
    approach to complex concepts.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，到目前为止我们讨论的模式是单子的一个例子，具体来说是`State`单子。我一直避免告诉你它的名字，因为单子在软件开发中是一个特别晦涩的话题。对于这本书，我观看了数小时的单子视频；我还阅读了博客文章和文章，但出于某种原因，它们都无法理解。由于单子是范畴论中的一个数学对象，我提到的一些资源采用数学方法，并使用定义和运算符来解释它们。其他资源尝试通过示例来解释，但它们是用具有对单子模式的本地支持的编程语言编写的。它们都不符合我们这本书的目标——对复杂概念的实际方法。
- en: To understand monads better, we need to look at more examples. The easiest one
    is probably the `Maybe` monad.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要更好地理解单子，我们需要看更多的例子。最简单的例子可能是`Maybe`单子。
- en: Maybe
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 也许
- en: 'Consider trying to compute an expression such as the following in C++:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑尝试在C++中计算以下表达式：
- en: '[PRE63]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'What is likely to happen? Usually, an exception will be thrown since we are
    attempting to divide by `0`. But, there are situations in which we''d like to
    see a value such as `None` or `NaN`, or some kind of message. We''ve seen that
    we can use `optional<int>` to store data that may be an integer or a value; we
    could, therefore, implement a divide function that returns an `optional<int>`, as
    shown in the following:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会发生什么？通常会抛出异常，因为我们试图除以`0`。但是，有些情况下，我们希望看到一个值，比如`None`或`NaN`，或者某种消息。我们已经看到，我们可以使用`optional<int>`来存储可能是整数或值的数据；因此，我们可以实现一个返回`optional<int>`的除法函数，如下所示：
- en: '[PRE64]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'However, when we try to use the `divideEvenWith0` in an expression, we realize
    that we also need to change all the other operators. For example, we could implement
    a `plusOptional` function that returns `nullopt` when either parameter is `nullopt`, or
    the value if not, as shown in the following example:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们尝试在表达式中使用`divideEvenWith0`时，我们意识到我们还需要改变所有其他操作符。例如，我们可以实现一个`plusOptional`函数，当任一参数为`nullopt`时返回`nullopt`，否则返回值，如下例所示：
- en: '[PRE65]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'While it works, this requires writing more functions and a lot of duplication.
    But hey, could we write a function that takes a `function<int(int, int)>` and
    turns it into a `function<optional<int>(optional<int>, optional<int>)>`? Sure,
    let''s write the function as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它有效，但这需要编写更多的函数和大量的重复。但是，嘿，我们能写一个函数，它接受一个`function<int(int, int)>`并将其转换为`function<optional<int>(optional<int>,
    optional<int>)`吗？当然，让我们编写以下函数：
- en: '[PRE66]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This works fine, as shown in the following passing tests:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好地运行了，如下所示通过了测试：
- en: '[PRE67]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'However, this doesn''t solve one problem—we still need to return `nullopt`
    when dividing by `0`. So, the following test will fail as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并没有解决一个问题——当除以`0`时，我们仍然需要返回`nullopt`。因此，以下测试将失败如下：
- en: '[PRE68]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We can solve this problem by using our own `divideEvenBy0` method instead of
    the standard divide:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用我们自己的`divideEvenBy0`方法来解决这个问题，而不是使用标准的除法：
- en: '[PRE69]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This time, the test passes, as shown here:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，测试通过了，如下所示：
- en: '[PRE70]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Moreover, the display after running the tests looks like this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，运行测试后的显示如下：
- en: '[PRE71]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: I have to say, there's something weirdly satisfying about escaping the tyranny
    of dividing by `0` and getting a result instead. Maybe that's just me.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我不得不说，摆脱除以`0`的暴政并得到一个结果有一种奇怪的满足感。也许这只是我。
- en: 'Anyway, this leads us to the definition of the `Maybe` monad. It stores a value
    and a function called `apply`. The `apply` function takes an operation (`plus<int>()`,
    `minus<int>()`, `divideEvenWith0`, or `multiplies<int>()`), and a second value
    to which we apply the operation, and returns the result:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，这引导我们来定义`Maybe`单子。它存储一个值和一个名为`apply`的函数。`apply`函数接受一个操作（`plus<int>()`，`minus<int>()`，`divideEvenWith0`，或`multiplies<int>()`），以及一个要应用操作的第二个值，并返回结果：
- en: '[PRE72]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We can use the `Maybe` monad to make computations as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Maybe`单子来进行计算如下：
- en: '[PRE73]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Once again, we can compute expressions, even with `nullopt`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以计算表达式，即使有`nullopt`。
- en: So what is a monad?
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么单子是什么？
- en: A **monad** is a functional design pattern that models computations. It comes
    from mathematics; more precisely, from the domain called **category theory**.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**单子**是一种模拟计算的函数式设计模式。它来自数学；更确切地说，来自称为**范畴论**的领域。'
- en: What is computation? A basic computation is a function; however, we are interested
    in adding more behaviors to the functions. We've seen two examples of maintaining
    state and allowing operations with an optional type, but monads are quite widespread
    in software design.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是计算？基本计算是一个函数；但是，我们有兴趣为函数添加更多的行为。我们已经看到了维护状态和允许可选类型操作的两个例子，但是单子在软件设计中是相当普遍的。
- en: 'A monad basically has a value and a higher-order function. To understand what
    they do, let''s compare the `State` monad shown in the following code:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 单子基本上有一个值和一个高阶函数。为了理解它们的作用，让我们来比较以下代码中显示的`State`单子：
- en: '[PRE74]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'With the `Maybe` monad shown here:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此处显示的`Maybe`单子：
- en: '[PRE75]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: They both hold a value. The value is encapsulated in the monad structure. They
    both hold a function that makes computation on that value. The `apply`/`nextState`
    (called `bind` in the literature) functions receive a function themselves that
    encapsulates the computation; however, the monad does something in addition to
    the computation.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都包含一个值。该值封装在单子结构中。它们都包含一个对该值进行计算的函数。`apply`/`nextState`（在文献中称为`bind`）函数本身接收一个封装计算的函数；但是，单子除了计算之外还做了一些其他事情。
- en: There's more to the monads than just these simple examples. However, they show
    how to encapsulate certain computations and how to remove certain types of duplication.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 单子还有更多的内容，不仅仅是这些简单的例子。但是，它们展示了如何封装某些计算以及如何消除某些类型的重复。
- en: It's worth noting that the `optional<>` type from C++ is actually inspired from
    the `Maybe` monad, as well as the promises, so you're probably already using monads
    in your code that are waiting to be discovered.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，C++中的`optional<>`类型实际上是受到了`Maybe`单子的启发，以及承诺，因此您可能已经在代码中使用了等待被发现的单子。
- en: Summary
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We've learned a lot of things in this chapter, all around improving design.
    We learned that refactoring means restructuring the code without changing the
    external behavior of a program. We saw that to ensure the preservation of behavior,
    we need to make very small steps and tests. We learned that legacy code is code
    that we're afraid to change, and in order to write tests for it, we need to change
    the code first, which leads to a dilemma. We've also learned that, fortunately,
    we can make some small changes in the code that are guaranteed to preserve behavior,
    but that break dependencies and thus allow us to plug into the code with tests.
    We saw then that we can use pure functions to identify and break the dependencies,
    leading to lambdas that we can regroup into classes based on cohesiveness.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学到了很多关于改进设计的知识。我们了解到重构意味着重构代码而不改变程序的外部行为。我们看到为了确保行为的保留，我们需要采取非常小的步骤和测试。我们了解到遗留代码是我们害怕改变的代码，为了为其编写测试，我们需要首先更改代码，这导致了一个困境。我们还学到，幸运的是，我们可以对代码进行一些小的更改，这些更改保证了行为的保留，但打破了依赖关系，从而允许我们通过测试插入代码。然后我们看到，我们可以使用纯函数来识别和打破依赖关系，从而导致我们可以根据内聚性将它们重新组合成类。
- en: Finally, we learned that we can use design patterns with functional programming,
    and we saw a few examples. Even if you don't use anything else from functional
    programming, using functions such as strategy, command, or injected dependencies
    will make your code easier to change with minimal fuss. We touched on a strikingly
    abstract design pattern, the monad, and we saw how to use the `Maybe` monad and
    the `State` monad. Both can help a lot in our quest to write less code with richer
    functionality.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们了解到我们可以在函数式编程中使用设计模式，并且看到了一些例子。即使您不使用函数式编程的其他内容，使用策略、命令或注入依赖等函数将使您的代码更容易进行最小干扰的更改。我们提到了一个非常抽象的设计模式，单子，以及我们如何使用`Maybe`单子和`State`单子。这两者都可以在我们的写作中帮助我们更少的代码实现更丰富的功能。
- en: We've discussed quite a lot about software design. But does functional programming
    apply to architecture? That's what we'll visit in the next chapter—event sourcing.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了很多关于软件设计的内容。但是函数式编程是否适用于架构？这就是我们将在下一章中讨论的内容——事件溯源。
