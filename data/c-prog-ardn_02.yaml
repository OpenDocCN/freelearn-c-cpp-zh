- en: Chapter 2. First Contact with C
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章。与C的第一次接触
- en: In my life as a programmer, I encountered a lot of compiler-based as well as
    scripting languages. One of the lowest common denominators has always been the
    C language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的程序员生涯中，我遇到了很多基于编译器和脚本语言的情况。其中最低的共同点一直是C语言。
- en: In our case, this is **embedded system programming**, which is another name
    for **hardware programming**; this first statement is also true.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，这是 **嵌入式系统编程**，这是 **硬件编程** 的另一个名称；这个说法也是正确的。
- en: Let's check what C programming really is and let's enter into a new world, that
    is, the realm of Arduino programming. We'll also use a very necessary feature
    called **serial monitoring**. This will help us a lot in our C learning, and you'll
    understand that this feature is also used in real-life projects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看C编程究竟是什么，让我们进入一个新的世界，那就是Arduino编程的领域。我们还将使用一个非常必要的功能，称为 **串行监控**。这将在我们的C学习中帮我们很多，你也会理解这个功能在现实生活中的项目中也被使用。
- en: An introduction to programming
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程简介
- en: The first question is, **what is a program?**
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题，**什么是程序**？
- en: A **program** is text that you write using a programming language that contains
    behaviors that you need a processor to acquire. It basically creates a way of
    handling inputs and producing outputs according to these behaviors.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序** 是你使用编程语言编写的文本，其中包含你需要处理器获取的行为。它基本上创建了一种处理输入和根据这些行为产生输出的方式。'
- en: 'According to Wikipedia ([http://en.wikipedia.org/wiki/Computer_programming](http://en.wikipedia.org/wiki/Computer_programming)):'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科 ([http://en.wikipedia.org/wiki/Computer_programming](http://en.wikipedia.org/wiki/Computer_programming))：
- en: Programming is the process of designing, writing, testing, debugging and maintaining
    the source code of computer programs.
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编程是设计、编写、测试、调试和维护计算机程序源代码的过程。
- en: Of course, this definition is very simple and it also applies to microcontrollers,
    as we already know that the latter are basically a type of computers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个定义非常简单，它也适用于微控制器，因为我们已经知道后者基本上是一种计算机。
- en: '*Designing a program* is the fact you have to think about first, before you
    begin coding it. It generally involves writing, drawing, and making schematics
    of all the actions you want your processor to make for you. Sometimes, it also
    implies to write what we call **pseudocode**. I hope you remember that this is
    what we created in the previous chapter when we wanted to define precisely all
    the steps of our desired LED behavior.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*设计一个程序* 是你在开始编码之前必须首先思考的事实。这通常涉及到编写、绘制以及制作你希望处理器为你执行的所有动作的示意图。有时，这也意味着编写我们所说的
    **伪代码**。我希望你能记住，这是我们上章在想要精确定义我们期望的LED行为的所有步骤时创建的内容。'
- en: I don't agree with a lot of people calling it *pseudocode* because it is actually
    more of a *real code*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我不同意很多人称它为 *伪代码*，因为它实际上更像是 *真实代码*。
- en: What we call *pseudocode* is something that helps a lot because it is human-readable,
    made of clear sentences, and is used to think and illustrate better our purpose,
    which is the key to success.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所说的 *伪代码* 是非常有帮助的东西，因为它易于阅读，由清晰的句子组成，并且用于更好地思考和说明我们的目的，这是成功的关键。
- en: 'An example of my firmware *pseudocode*''s definition could be as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我固件 *伪代码* 的定义示例可能如下：
- en: Measure the current thermic sensor value.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测量热敏传感器的当前值。
- en: Check if the temperature is greater than 30° C and make a sound if it is.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查温度是否大于30°C，如果是，则发出声音。
- en: If not, light the blue LED.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不是，点亮蓝色LED。
- en: And make those previous steps permanent in a loop.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并且将这些之前的步骤永久地放在一个循环中。
- en: '*Writing a program* is typically what converts the pseudocode into real and
    well-formed code. It involves having knowledge of programming languages because
    it is the step when you really write the program. This is what we''ll learn in
    a moment.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*编写一个程序* 通常是将伪代码转换为真实且格式良好的代码的过程。这涉及到对编程语言的了解，因为这是你真正编写程序的时候。这就是我们接下来要学习的。'
- en: '*Testing* is the obvious step when you run the program after you made some
    modifications to the code. It is an exciting moment when you also are a bit afraid
    of bugs, those annoying things that make running your program absolutely different
    from what you expected at first.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*测试* 是在你对代码进行了一些修改后运行程序时的明显步骤。当你也是程序员时，这是一个既令人兴奋又有点害怕的时刻，因为你害怕虫子，那些让你的程序运行结果与最初预期完全不同的事情。'
- en: '*Debugging* is a very important step when you are trying to find out why that
    program doesn''t work well as expected. You are tracking typo errors, logic discrepancies,
    and global program architecture problems. You''ll need to monitor things and often
    modify your program a bit in order to precisely trace how it works.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*调试* 是当你试图找出为什么程序没有按预期工作得很好时的一个非常重要的步骤。你正在追踪打字错误、逻辑差异和全局程序架构问题。你需要监控事物，并且经常需要稍微修改你的程序，以便精确地追踪它是如何工作的。'
- en: '*Maintaining the source code* is the part of the program''s life that helps
    to avoid obsolescence.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*维护源代码* 是程序生命周期中帮助避免过时的部分。'
- en: The program is working and you improve it progressively; you make it up-to-date
    considering hardware evolutions, and sometimes, you debug it because the user
    has this still undiscovered bug. This step increases the life duration of your
    program.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 程序正在运行，并且你逐步改进它；你根据硬件的进化更新它，有时，你需要调试它，因为用户仍然发现了这个未知的错误。这一步骤增加了你程序的使用寿命。
- en: Different programming paradigms
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不同的编程范式
- en: A **paradigm** is a manner of describing something. It can either be a representation
    or a theoretical model of something.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**范式**是描述某物的方式。它可以是某物的表示或理论模型。'
- en: Applied to programming, a programming paradigm is *a fundamental style of computer
    programming*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 将编程应用于，编程范式是*计算机编程的基本风格*。
- en: 'The following are four main programming paradigms:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是有四种主要的编程范式：
- en: Object-oriented
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象
- en: Imperative
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令式
- en: Functional
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式
- en: Logic programming
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑编程
- en: Some languages follow not one but multiple paradigms.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言遵循的不是一种而是多种范式。
- en: 'It is not the purpose of this book to have a debate around those, but I would
    add one, which can be a combination of these and which also describes a particular
    concept: **visual programming**. We''ll discover one of the most powerful frameworks
    in [Chapter 6](ch06.html "Chapter 6. Sensing the World – Feeling with Analog Inputs"),
    *Sensing the World — Feeling with Analog Inputs*, namely the **Max 6** framework
    (formerly named **Max/MSP**).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的目的不是围绕这些进行辩论，但我可以增加一个，它可以是这些的组合，同时也描述了一个特定的概念：**可视化编程**。我们将在[第6章](ch06.html
    "第6章. 感知世界 – 使用模拟输入感受")中了解到最强大的框架之一，即*感知世界 – 使用模拟输入感受*，也就是**Max 6**框架（之前称为**Max/MSP**）。
- en: Programming style
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程风格
- en: 'There is no scientific or universal way to define what is the absolute best
    style of programming. However, I can quote six items that can help to understand
    what we''ll try to do together all along this book in order to make good programs.
    We''ll aim for the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 没有科学或普遍的方法来定义什么是绝对最佳的编程风格。然而，我可以引用六个项目，这些项目可以帮助我们理解在这本书中我们将尝试一起做什么，以编写出优秀的程序。我们的目标是以下内容：
- en: '**Reliability**: This enables a code to handle its own generated errors while
    running'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠性**：这使代码能够在运行时处理其生成的错误'
- en: '**Solidity**: This provides a frame to anticipate problems on the user side
    (wrong inputs)'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**稳定性**：这提供了一个框架来预测用户端的问题（错误的输入）'
- en: '**Ergonomics**: This helps to intuitively be able to use it with ease'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**人体工程学**：这有助于直观地轻松使用它'
- en: '**Portability**: This is the designing of a program for a wide range of platforms'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可移植性**：这是为广泛的平台设计程序'
- en: '**Maintainability**: This is the ease of modifying it even if you didn''t code
    it yourself'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：这是即使你没有亲自编写代码也能轻松修改它的程度'
- en: '**Efficiency**: This indicates that a program runs very smoothly without consuming
    a lot of resources'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**：这表明程序运行得非常顺畅，而不消耗大量资源'
- en: Of course, we'll come back to them in the examples of this book, and I'm sure
    you'll improve your style progressively.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们将在本书的例子中回到它们，我相信你将逐步改进你的风格。
- en: C and C++?
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C和C++？
- en: '**Dennis Ritchie** [http://en.wikipedia.org/wiki/Dennis_Ritchie](http://en.wikipedia.org/wiki/Dennis_Ritchie))
    at Bell Labs developed the C programming language from 1969 to 1973\. It is often
    defined as a general-purpose programming language and is indeed one of the most
    used languages of all times. It had been used initially to design the Unix operating
    system ([http://en.wikipedia.org/wiki/Unix](http://en.wikipedia.org/wiki/Unix))
    that had numerous requirements, especially high performance.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**丹尼斯·里奇** [http://en.wikipedia.org/wiki/Dennis_Ritchie](http://en.wikipedia.org/wiki/Dennis_Ritchie))
    在贝尔实验室从1969年到1973年开发了C编程语言。它通常被定义为一门通用编程语言，并且确实是所有时代中最常用的语言之一。它最初被用来设计具有众多要求的Unix操作系统([http://en.wikipedia.org/wiki/Unix](http://en.wikipedia.org/wiki/Unix))，特别是高性能。'
- en: It has influenced a lot of very well known and used languages such as C++, Objective-C,
    Java, JavaScript, Perl, PHP, and many others.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 它影响了很多非常知名且广泛使用的语言，如C++、Objective-C、Java、JavaScript、Perl、PHP等。
- en: C is to both **imperative** and **structured**. It is very appropriate for both
    8-bit and 64-bit processors, for systems having not only several bytes of memory
    but also terabytes too, and also for huge projects involving huge teams, to the
    smallest of projects with a single developer.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: C语言既适用于**命令式**也适用于**结构化**。它非常适合8位和64位处理器，对于既有几字节内存也有太字节内存的系统，以及涉及庞大团队的大型项目，以及只有单个开发者的最小项目。
- en: Yes, we are going to learn a language that will open your mind to global and
    universal programming concepts!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们将学习一种语言，它将打开你的思路，让你接触到全球和通用的编程概念！
- en: C is used everywhere
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C语言无处不在
- en: 'Indeed, the C language provides a lot of advantages. They are as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，C语言提供了很多优点。它们如下：
- en: '*It is small and easy to learn.*'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*它体积小，易于学习*。'
- en: '*It is processor-independent* because *compilers* exist for almost all processors
    in the world. This independence provides something very useful to programmers:
    they can focus on algorithms and the application levels of their job instead of
    thinking about the hardware level at each row of code.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*它是处理器无关的*，因为几乎世界上所有的处理器都有相应的*编译器*。这种无关性为程序员提供了非常有用的东西：他们可以专注于算法和工作的应用层面，而不是在每一行代码中都要考虑硬件层面。'
- en: '*It is a very "low-level" high-level language*.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*它是一种非常“底层”的高级语言*。'
- en: 'This is its main strength. Dennis M. Ritchie, in his book *The C Programming
    Language* written with Brian W. Kernighan commented on C as:'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是它的主要优势。Dennis M. Ritchie在他的与Brian W. Kernighan合著的《C程序设计语言》一书中对C语言评论道：
- en: C is a relatively "low level" language. This characterization is not pejorative;
    it simply means that C deals with the same sort of objects that most computers
    do. These may be combined and moved about with the arithmetic and logical operators
    implemented by real machines.
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: C是一种相对“底层”的语言。这种描述并不是贬义的；它仅仅意味着C处理的是大多数计算机都处理的对象。这些对象可以用真实机器实现的算术和逻辑运算符组合和移动。
- en: Today, this is the only language that allows interacting with the underlying
    hardware engine so easily and this is the reason why the Arduino toolchain is
    based on C.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，这是唯一一种可以如此容易地与底层硬件引擎交互的语言，这也是为什么Arduino工具链基于C语言的原因。
- en: Arduino is programmed with C and C++
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Arduino是用C和C++编写的
- en: C++ can be considered as a superset of C. It means C++ brings new concepts and
    elements to C. Basically, C++ can be defined as C with object-oriented implementation
    ([http://en.wikipedia.org/wiki/Object-oriented_programming](http://en.wikipedia.org/wiki/Object-oriented_programming)),
    which is a higher-level feature. This is a very nice feature that brings and provides
    new ways of design.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: C++可以被认为是C的超集。这意味着C++为C带来了新的概念和元素。基本上，C++可以定义为具有面向对象实现的C（[http://en.wikipedia.org/wiki/Object-oriented_programming](http://en.wikipedia.org/wiki/Object-oriented_programming)），这是一个高级特性。这是一个非常好的特性，它带来了新的设计方式。
- en: We'll enter together into this concept a bit later in this book but basically,
    in object-oriented programs, you define structures called **classes** that are
    a kind of a model, and you create objects called **instances** of those classes,
    which have their own life at runtime and which respect and inherit the structure
    of the class from which they came.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书稍后更深入地探讨这个概念，但基本上，在面向对象的程序中，你定义称为**类**的结构，它们是一种模型，然后你创建这些类的**实例**，这些实例在运行时拥有自己的生命周期，并且尊重和继承它们所属类的结构。
- en: '**Object-oriented programming** (**OOP**) provides four properties that are
    very useful and interesting:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象编程**（**OOP**）提供了四个非常有用且有趣的特点：'
- en: Inheritance (classes can inherit attributes and behaviors from their parent
    classes)
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承（类可以从其父类继承属性和行为）
- en: Data encapsulation (each instance retains its data and functions)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据封装（每个实例保留其数据和函数）
- en: Object identity (each instance is an individual)
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象标识（每个实例都是独立的）
- en: Polymorphism (each behavior can depend on the context)
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态（每个行为都可以依赖于上下文）
- en: In OOP, we define classes first and then we use specific functions called **constructors**
    to create instances of those classes. Imagine that a class is a map of a type
    of house, and the instances are all the houses built according to the map.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在OOP中，我们首先定义类，然后使用称为**构造函数**的特定函数来创建这些类的实例。想象一下，一个类是一类房子的地图，而实例则是根据这个地图建造的所有房子。
- en: Almost all Arduino libraries are made using C++ in order to be easily reusable,
    which is one of the most important qualities in programming.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的Arduino库都是使用C++编写的，以便易于重用，这是编程中最重要的品质之一。
- en: The Arduino native library and other libraries
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Arduino原生库和其他库
- en: A **programming library** is a collection of resources that are available for
    use by programs.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**编程库**是一组可供程序使用的资源。'
- en: 'They can include different types of things, such as the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以包括不同类型的东西，如下所示：
- en: Configuration data
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置数据
- en: Help and documentation resources
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助和文档资源
- en: Subroutines and reusable part of code
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子程序和可重用代码部分
- en: Classes
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Type definitions
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型定义
- en: I like to say that libraries provide a **behavior encapsulation**; you don't
    have to know how the behavior is made for using it but you just use it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢说图书馆提供了一种**行为封装**；您不需要知道如何实现该行为，只需使用它即可。
- en: Libraries can be very specific, or can have a global purpose.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图书馆可以是非常具体的，也可以具有全局目的。
- en: 'For instance, if you intend to design firmware that connects the Arduino to
    the Internet in order to grab some information from a mail server, and react by
    making an LED matrix blink in one way or another according to the content of the
    mail server''s response, you have the following two solutions:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您打算设计固件，将Arduino连接到互联网以从邮件服务器获取一些信息，并根据邮件服务器响应的内容以某种方式使LED矩阵闪烁，您有以下两种解决方案：
- en: Code the whole firmware from scratch
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头开始编写整个固件
- en: Use libraries
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用库
- en: Even if we like to code things, we are happier if we can focus on the global
    purpose of our designs, aren't we?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们都喜欢编写代码，但如果我们能专注于我们设计的全局目的，我们会更快乐，不是吗？
- en: In that case, we'll try to find libraries already designed specifically for
    the behaviors we need. For instance, there is probably a library specifically
    designed for LED matrix control, and another one with a server-connection purpose.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将尝试找到已经为所需行为专门设计的库。例如，可能有一个专门用于LED矩阵控制的库，还有一个具有服务器连接目的的库。
- en: Discovering the Arduino native library
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发现Arduino原生库
- en: The native library is designed for a very elementary and global purpose. It
    means it may not be enough, but it also means you'll use it every time in all
    your firmware design.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 原生库是为了一个非常基础和全局的目的而设计的。这意味着它可能不够用，但也意味着您将在所有固件设计中每次都使用它。
- en: You can find it at [http://arduino.cc/en/Reference/HomePage](http://arduino.cc/en/Reference/HomePage).
    This page will be familiar to you by now!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://arduino.cc/en/Reference/HomePage](http://arduino.cc/en/Reference/HomePage)找到它。现在您对这个页面应该很熟悉了！
- en: 'It is divided in the following three parts:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 它分为以下三个部分：
- en: '**Structure** (from global conditional control structures to more specific
    ones)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构**（从全局条件控制结构到更具体的结构）'
- en: '**Variables** (related to types and conversions between types)'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量**（与类型和类型之间的转换相关）'
- en: '**Functions** (from I/O functions to math calculation ones and more)'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数**（从I/O函数到数学计算函数等）'
- en: 'The following steps can be used to find help directly in IDE:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤可用于在IDE中直接查找帮助：
- en: Open your IDE.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的IDE。
- en: Go to **File** | **Examples**; you'll see the following screenshot:![Discovering
    the Arduino native library](img/7584_02_001.jpg)
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**文件** | **示例**；您将看到以下屏幕截图：![发现Arduino原生库](img/7584_02_001.jpg)
- en: In the first part of the menu (in the preceding screenshot), you have lots of
    examples related to the native library only.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在菜单的第一部分（在先前的屏幕截图中），您有与原生库相关的许多示例。
- en: Select the **02.Digital** button.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**02.Digital**按钮。
- en: A new window is displayed. Right-click on a colored keyword in the code as shown
    in the next screenshot:![Discovering the Arduino native library](img/7584_02_002.jpg)
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将显示一个新窗口。右键单击代码中的彩色关键字，如图所示：![发现Arduino原生库](img/7584_02_002.jpg)
- en: Finding information in reference for all reserved keywords directly in the Arduino
    IDE
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Arduino IDE中直接查找所有保留关键字的参考信息
- en: You can see at the bottom of this contextual menu **Find in Reference***.* This
    is a really useful tool that you are going to understand right now; click on it!
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在此上下文菜单的底部看到**在参考中查找***。这是一个您现在就会理解的非常有用的工具；点击它！
- en: Your IDE directly called your default browser with an HTML page corresponding
    to the help page of the keyword on which you clicked. You can stay focused inside
    your IDE and go to help.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您的IDE直接调用了您的默认浏览器，并显示了一个与您点击的关键字帮助页面相对应的HTML页面。您可以在IDE内部保持专注并获取帮助。
- en: '![Discovering the Arduino native library](img/7584_02_003.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![发现Arduino本地库](img/7584_02_003.jpg)'
- en: The useful local help files that are available
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的有用本地帮助文件
- en: Other libraries included and not directly provided
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包含但未直接提供的其他库
- en: The Arduino library has progressively included both necessary and useful other
    libraries. We have seen in the earlier chapter that the used libraries are now
    integrated into the *core* of the Arduino distribution, which is a bit abusive,
    but summarizes well the fact that they are available when you install only the
    Arduino IDE package.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino库逐步包括了必要的和有用的其他库。我们在前面的章节中看到，现在使用的库已经集成到Arduino分发的 *核心* 中，这有点滥用，但很好地总结了它们在您仅安装Arduino
    IDE包时即可使用的事实。
- en: Some very useful included libraries
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一些非常有用的包含库
- en: '**EEPROM** provides functions and classes to read/write in hardware storage
    components. It is very useful to store something beyond the power state of the
    Arduino, that is, even when the power is off.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EEPROM**提供在硬件存储组件中读取/写的函数和类。这对于存储超出Arduino电源状态的内容非常有用，也就是说，即使在断电时。'
- en: '**Ethernet** helps to make layer 2 and layer 3 communications over an Ethernet
    network.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ethernet**帮助在以太网网络上进行第2层和第3层通信。'
- en: '**Firmata** is used for serial communication.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Firmata**用于串行通信。'
- en: '**SD** provides an easy way to read/write SD Cards; it is a more user-friendly
    alternative to the EEPROM solution.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SD**提供了一种读取/写入SD卡的简单方法；它是对EEPROM解决方案更用户友好的替代方案。'
- en: '**Servo** helps to control servo motors.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**伺服**帮助控制伺服电机。'
- en: There are a couple more libraries in the core distribution. Sometimes, new ones
    are included.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 核心分发中还有一些其他库。有时，还会包含新的库。
- en: Some external libraries
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一些外部库
- en: I suggest that you check other libraries quoted and referenced on the same page
    at the link [http://arduino.cc/en/Reference/Libraries](http://arduino.cc/en/Reference/Libraries).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您检查链接 [http://arduino.cc/en/Reference/Libraries](http://arduino.cc/en/Reference/Libraries)
    上同一页引用的库。
- en: 'I especially used a lot of the following libraries:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我特别使用了以下很多库：
- en: '**TLC5940**: Used to control a 16-channel, 12-bit LED controller smoothly'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TLC5940**：用于平滑地控制16通道、12位LED控制器'
- en: '**MsTimer2**: Used to trigger an action that has to be very fast and even each
    1 ms (this library is also a nice hack of one of the hardware timers included
    in the chipset)'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MsTimer2**：用于触发一个必须非常快且甚至每1毫秒就要执行一次的动作（这个库也是芯片组中包含的硬件定时器的一个很好的黑客技巧）'
- en: '**Tone***:* Used to generate audible square waves'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Tone***：用于生成可听见的方波'
- en: You can use *Google* to find more libraries. You will find a lot of them, but
    not all are equally documented and maintained. We'll see in the last chapter of
    this book how to create our own library, and of course how to document it nicely
    for both other users and ourselves.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 *Google* 搜索更多库。您会发现很多库，但并非所有都同等文档化和维护。我们将在本书的最后一章中看到如何创建我们自己的库，当然也包括如何为其他用户和
    ourselves 优雅地文档化。
- en: Checking all basic development steps
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查所有基本开发步骤
- en: We are not here together to understand the entire details of code compilation.
    But I want to give you a global explanation that will help you to understand better
    how it works under the hood. It will also help you to understand how to debug
    your source code and why something wouldn't work in any random case.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里聚在一起不是为了理解代码编译的整个细节。但我想要提供一个全局的解释，这将帮助您更好地理解它的工作原理。这也有助于您理解如何调试源代码以及为什么在某些随机情况下某些东西不会工作。
- en: Let's begin by a flowchart showing the entire process.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一张流程图开始，展示整个流程。
- en: '![Checking all basic development steps](img/7584_02_004.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![检查所有基本开发步骤](img/7584_02_004.jpg)'
- en: From the source code to the binary executable code
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 从源代码到二进制可执行代码
- en: 'The following steps are executed to take the code from the source to the executable
    production stage:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤用于将代码从源代码转换为可执行的生产阶段：
- en: The **C and C++ source code** is just the type of code you already wrote for
    the `Blink250ms` project in [Chapter 1](ch01.html "Chapter 1. Let's Plug Things"),
    *Let's Plug Things*.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**C和C++源代码**正是您在[第1章](ch01.html "第1章。让我们连接事物") *让我们连接事物* 中为 `Blink250ms` 项目编写的代码类型。'
- en: '**Headers** are usually included at the beginning of your code, and they refer
    to other files with the extension `.h` in which there are some definitions and
    class declarations. This kind of design, in which you have separate files for
    the source code (the program you are currently writing) and the headers (already
    made elements), provides a nice way to re-use your already written code.'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**头文件**通常包含在代码的开头，并引用其他具有`.h`扩展名的文件，其中包含一些定义和类声明。这种设计，其中你有源代码（你目前正在编写的程序）和头文件（已制作元素）的单独文件，为你已经编写的代码的复用提供了一个很好的方式。'
- en: The **Preprocessor** is a routine that basically substitutes text elements in
    your code, considering the *headers* and *other constants'* definitions.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**预处理器**是一种基本替换代码中文本元素的例程，考虑到*头文件*和其他*常量*的定义。'
- en: The **Parser** prepares a file that will be translated, and that file will be
    assembled to produce multiple *object* files.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**解析器**准备一个将被翻译的文件，该文件将被汇编以生成多个**目标**文件。'
- en: An **object** file contains machine code that is not directly executable by
    any hardware processor.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**目标文件**包含机器代码，这些代码不能直接由任何硬件处理器执行。'
- en: The last important step is the **linkage** made by the **linker** program. The
    linker takes all objects produced by the previous compilation steps and combines
    them into a single executable file called **program**.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个重要步骤是由**链接器**程序执行的**链接**。链接器将之前编译步骤产生的所有目标文件组合成一个单一的名为**程序**的可执行文件。
- en: From the source code to the object file, all processes are summarized under
    the name `compilation`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从源代码到目标文件，所有过程都概括为`编译`。
- en: Usually, libraries provide object files, ready to be linked by the linker. Sometimes,
    especially in the open source world, libraries come with source code too. This
    makes any changes in the library easier. In that case, the library itself would
    have to be compiled to produce the required object files that would be used in
    your global code compilation.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，库提供目标文件，供链接器链接。有时，特别是在开源世界中，库还附带源代码。这使得对库的任何更改都更容易。在这种情况下，库本身必须编译以生成在全局代码编译中使用的所需目标文件。
- en: Hence, we'll define *compilation* as the whole process from the source code
    to the program.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们将**编译**定义为从源代码到程序的整体过程。
- en: 'I should even use and introduce another term: **cross-compilation**. Indeed,
    we are compiling the source code on our computer, but the final targeted processor
    of our resulting program (firmware) is the Arduino''s processor.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我甚至应该使用并介绍另一个术语：**交叉编译**。实际上，我们是在我们的计算机上编译源代码，但最终目标处理器是我们生成的程序（固件）的Arduino处理器。
- en: Generally, we define cross-compilation as the process of compiling source code
    using a processor in order to make a program for another processor.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们将交叉编译定义为使用一个处理器编译源代码以制作针对另一个处理器的程序的过程。
- en: Now, let's move further and learn how we are going to test our initial pieces
    of C code precisely using the IDE console.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进一步学习如何精确地使用IDE控制台测试我们的初始C代码片段。
- en: Using the serial monitor
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用串行监视器
- en: The Arduino board itself can communicate easily using basic protocols for serial
    communication.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino板本身可以使用基本的串行通信协议轻松通信。
- en: Basically, **serial communication** is the process of sending data elements
    over a channel, often named a **bus**. Usually, data elements are bytes, but it
    all depends on the implementation of the serial communication.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，**串行通信**是发送数据元素到通道的过程，通常称为**总线**。通常，数据元素是字节，但这完全取决于串行通信的实现。
- en: In serial communication, data is sent *sequentially*, one after the previous
    one. This is the opposite of **parallel communication**, where data are sent over
    more than one channel, all at the same time.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在串行通信中，数据是**顺序地**发送的，一个接一个。这与**并行通信**相反，在并行通信中，数据通过多个通道同时发送。
- en: Baud rate
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 波特率
- en: 'Because the two entities that want to communicate using serial communications
    have to be okay about the answer to the question "Hey, what is a word?", we have
    to use the same speed of transmission on both sides. Indeed, if I send `001010101010`,
    is it a whole word or are there many words? We have to define, for instance, that
    a word is four-digits long. Then, we can understand that the previous example
    contains three words: `0010`, `1010`, and `1010`. This involves a clock.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因为想要使用串行通信进行通信的两个实体必须对“嘿，一个单词是什么？”这个问题有相同的答案，所以我们必须在双方使用相同的传输速度。实际上，如果我发送`001010101010`，这是一个完整的单词，还是有多个单词？我们必须定义，例如，一个单词是四位数长。然后，我们可以理解前面的例子包含三个单词：`0010`、`1010`和`1010`。这涉及到一个时钟。
- en: That clock definition is made by initializing serial communication at a particular
    *speed* in **baud**, also called **baud rate**.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 那个时钟定义是通过在特定的**波特率**下初始化串行通信来实现的，也称为**波特率**。
- en: 1 baud means 1 symbol transmitted per second. A symbol can be more than one
    bit.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 1波特表示每秒传输1个符号。一个符号可以超过一个比特。
- en: This is why we don't have to create confusion between bps, bit per second, and
    baud!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们不必在bps（每秒比特数）、波特率之间产生混淆！
- en: Serial communication with Arduino
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Arduino进行串行通信
- en: Each Arduino board has at least one serial port. It can be used by using digital
    pins 0 and 1, or directly using the USB connection when you want to use serial
    communication with your computer.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 每块Arduino板至少有一个串行端口。你可以通过使用数字引脚0和1，或者直接使用USB连接来使用它，当你想要通过串行通信与电脑通信时。
- en: You can check [http://arduino.cc/en/Reference/serial](http://arduino.cc/en/Reference/serial).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以检查[http://arduino.cc/en/Reference/serial](http://arduino.cc/en/Reference/serial)。
- en: On the Arduino board, you can read RX and TX on both digital pins 0 and 1 respectively.
    **TX** means transmit and **RX means** receive; indeed, the most basic serial
    communication requires two wires.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在Arduino板上，你可以分别在数字引脚0和1上读取RX和TX。**TX**代表发送，**RX**代表接收；实际上，最基本的串行通信只需要两根线。
- en: There are many other kinds of serial communication buses we'll describe a bit
    later in [Chapter 10](ch10.html "Chapter 10. Some Advanced Techniques"), *Some
    Advanced Techniques*, in the *Using I2C and SPI for LCD, LED, and other funny
    games* section.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第10章[第10章。一些高级技巧](ch10.html "第10章。一些高级技巧")的*使用I2C和SPI进行LCD、LED和其他有趣游戏*部分稍后描述许多其他类型的串行通信总线。
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you use serial communication on your Arduino board, you cannot use the digital
    pins 0 and 1.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要在Arduino板上使用串行通信，你不能使用数字引脚0和1。
- en: '![Serial communication with Arduino](img/7584_02_005.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![使用Arduino进行串行通信](img/7584_02_005.jpg)'
- en: Check TX and RX on digital pins 1 and 0
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 检查数字引脚1和0上的TX和RX
- en: Arduino IDE provides a nice serial monitor that displays all symbols sent by
    the board to the computer via the USB interface. It provides a lot of baud rates
    from 300 baud to 115,200 baud. We are going to check how to use it in the following
    sections.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino IDE提供了一个很好的串行监控器，它通过USB接口显示板通过USB接口发送给电脑的所有符号。它提供了从300波特到115,200波特的多种波特率。我们将在接下来的章节中检查如何使用它。
- en: Serial monitoring
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 串行监控
- en: Serial monitoring is the way of creating very basic and easy communication with
    our board! It means we can program it to speak to us, via the serial monitor.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 串行监控是创建与我们的板非常基本和简单通信的方式！这意味着我们可以通过串行监控来编程它，让它对我们说话。
- en: If you have to debug something and the board's behavior differs from what you
    are expecting from it, and you want to "verify whether the problem stems from
    the firmware or not, you can create some routines that will write messages to
    you. These messages are called **traces**. Traces can be totally necessary for
    debugging source code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须调试某些东西，并且板的行为与你的预期不同，你想“验证问题是否源于固件”，你可以创建一些将消息写入你的例程。这些消息被称为**跟踪**。跟踪对于调试源代码可能是完全必要的。
- en: Traces will be described in detail in the next chapter.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪将在下一章中详细介绍。
- en: Making the Arduino talk to us
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让Arduino与我们对话
- en: Imagine that you have followed carefully the `Blink250ms` project, everything
    is wired correctly, you double-checked that, and the code seems okay too, but
    it doesn't work.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你已经仔细地跟随了`Blink250ms`项目，一切连接都正确无误，你也再次检查过，代码看起来也没有问题，但它就是不起作用。
- en: Our LED isn't blinking at all. How to be sure that the `loop()` structure of
    your code is correctly running? We'll modify the code a bit in order to trace
    its steps.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的LED根本就没有闪烁。如何确保你的代码中的`loop()`结构正确运行呢？我们将稍微修改一下代码，以便追踪其步骤。
- en: Adding serial communication to Blink250ms
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将串行通信添加到Blink250ms
- en: 'Here, in the following code, we''ll add serial communication for the LED to
    blink every 250 ms:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们将为 LED 添加串行通信，使其每 250 毫秒闪烁一次：
- en: Open your previous code.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您之前的代码。
- en: Use **Save As** to create another project under the name `TalkingAndBlink250ms`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **另存为** 创建一个名为 `TalkingAndBlink250ms` 的另一个项目。
- en: Note
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is good practice to start from an already existing code, to save it under
    another name, and to modify it according to your needs.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从一个已经存在的代码开始，将其保存为另一个名称，并根据您的需求进行修改，这是一个好的实践。
- en: 'Modify the current code by adding all rows beginning with `Serial`as follows:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下以 `Serial` 开头的所有行来修改当前代码：
- en: '[PRE0]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please notice that I highlight the comment code a bit each time in order to
    make things more readable. In the following steps, for instance, I won''t write
    the following comment:'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，我每次都会稍微突出显示注释代码，以便使内容更易于阅读。例如，在以下步骤中，我不会写出以下注释：
- en: // ---------- loop routine
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // ---------- 循环例程
- en: You can also find the whole code in the zip file in the folder `Chapter02/TalkingAndBlink250ms/`.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您也可以在文件夹 `Chapter02/TalkingAndBlink250ms/` 中的 zip 文件中找到整个代码。
- en: Click on the Serial Monitor button in the Arduino IDE:![Adding serial communication
    to Blink250ms](img/7584_02_006.jpg)
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 Arduino IDE 中的串行监视器按钮：![向 Blink250ms 添加串行通信](img/7584_02_006.jpg)
- en: Click on the little glass symbol in the top-right corner to activate the Serial
    Monitor
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 点击右上角的玻璃图标以激活串行监视器
- en: Choose the same baud rate you wrote in the code, which is in the menu at the
    bottom-right of the Serial Monitoring window, and observe what is happening.![Adding
    serial communication to Blink250ms](img/7584_02_007.jpg)
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择与代码中相同的波特率，该波特率位于串行监视窗口的右下角菜单中，并观察正在发生的事情。![向 Blink250ms 添加串行通信](img/7584_02_007.jpg)
- en: Your Arduino board seems to be speaking to you!
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的 Arduino 板似乎正在与您对话！
- en: You will notice some messages appearing in the Serial Monitor window, synchronized
    with the blinking LED states.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您将注意到一些消息出现在串行监视器窗口中，与 LED 闪烁状态同步。
- en: Now, we can be sure that our code is fine because each message is sent and because
    all rows are processed sequentially; it means the `digitalWrite()` functions are
    also called correctly (nothing is blocked). This information can be a clue, for
    instance, to check our circuit once more to try to find the error there instead
    of in the code.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以确信我们的代码是正确的，因为每个消息都已发送，并且所有行都是顺序处理的；这意味着 `digitalWrite()` 函数也被正确调用（没有阻塞）。这些信息可以作为一个线索，例如，再次检查我们的电路，以尝试在那里而不是在代码中找到错误。
- en: Of course this is a trivial example, but I'm sure you understand the target
    and the power of tracing your code!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当然这是一个简单的例子，但我相信您理解了目标和追踪代码的力量！
- en: Serial functions in more detail
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更详细地了解串行函数
- en: Let's check what we added in the code.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查我们在代码中添加了什么。
- en: Serial.begin()
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Serial.begin()
- en: Everything begins with the `Serial.begin()` function. This function in the `setup()`
    routine is executed only once, that is, when the Arduino is starting.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都从 `Serial.begin()` 函数开始。这个函数在 `setup()` 例程中只执行一次，即当 Arduino 启动时。
- en: In the code, I set up the board to initiate a serial communication at 9,600
    baud.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我设置了板子以 9,600 波特率启动串行通信。
- en: Serial.print() and Serial.println()
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Serial.print() 和 Serial.println()
- en: '`Serial.print()` and `Serial.println()` behave almost identically: they write
    something to the serial output, but the `ln` version also adds a carriage return
    and a newline.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`Serial.print()` 和 `Serial.println()` 几乎相同：它们将某些内容写入串行输出，但 `ln` 版本还会添加回车和换行符。'
- en: The syntax of this function is `Serial.print(val)` or `Serial.print(val,format)`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的语法是 `Serial.print(val)` 或 `Serial.print(val,format)`。
- en: You can pass one or two arguments.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以传递一个或两个参数。
- en: Basically, if `Serial.print(5)` prints the number `5` as an ASCII-encoded decimal
    symbol, `Serial.print(5,OCT)` prints the number `5` as an ASCII-encoded octal
    one.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，如果 `Serial.print(5)` 将数字 `5` 打印为 ASCII 编码的十进制符号，那么 `Serial.print(5,OCT)`
    将数字 `5` 打印为 ASCII 编码的八进制符号。
- en: Digging a bit…
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入挖掘…
- en: 'If you checked the code carefully (and I''m sure you did), you noticed we put
    two groups of three rows: one group just after the digitalWrite(ledPin,HIGH) function
    that lights on the LED, and the other group after the row that lights it off.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细检查了代码（我相信您确实检查了），您会注意到我们放置了两组三行：一组在 `digitalWrite(ledPin,HIGH)` 函数之后，该函数点亮了
    LED，另一组在关闭 LED 的行之后。
- en: Got it?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 明白了？
- en: We have asked the Arduino board to send a message according to the last order
    passed to the digital pin numbered 8, where the LED is still connected. And the
    board sends a message when we asked the pin to deliver current (when the LED is
    on), and another message when the pin doesn't deliver current (when the LED is
    off).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要求Arduino板根据传递给数字引脚8（LED仍然连接的引脚）的最后一个命令发送消息。当请求引脚传递电流（LED开启时），板会发送消息；当引脚不传递电流（LED关闭时），板会发送另一条消息。
- en: You just wrote your first trace routine.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚编写了你的第一个跟踪例程。
- en: Talking to the board from the computer
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从计算机与板通信
- en: 'You probably noticed a text field and a **Send** button in the Serial Monitor
    window:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到了串行监视器窗口中的文本字段和**发送**按钮：
- en: '![Talking to the board from the computer](img/7584_02_008.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![从计算机与板通信](img/7584_02_008.jpg)'
- en: We can send symbol to our Arduino board using Serial Communication
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过串行通信将符号发送到我们的Arduino板
- en: This means we can also use that tool to send data to the board from our computer.
    The firmware's board, however, has to implement some other functions in order
    to be able to understand what we'd like to send.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们也可以使用这个工具从我们的计算机向板发送数据。然而，固件板必须实现一些其他功能，以便能够理解我们想要发送的内容。
- en: Later in this book we'll see how to use the Serial Monitor window, the genius
    Processing framework, and the Max 6 framework to send messages easily to the Arduino
    board.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面部分，我们将看到如何使用串行监视器窗口、天才的Processing框架和Max 6框架轻松地向Arduino板发送消息。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about programming using C language. We also learned
    how to use the serial monitoring feature of our Arduino IDE in order to know a
    bit more about what is happening in real time in our Arduino processor using traces.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了使用C语言进行编程。我们还学习了如何使用Arduino IDE的串行监视功能，以便更了解我们的Arduino处理器在实时中使用跟踪时发生的情况。
- en: I spoke about serial communication because it is very useful and is also used
    in many real-life projects in which you need a computer and an Arduino board to
    communicate among themselves. It can also be used between two Arduino boards or
    between Arduino boards and other circuits.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到了串行通信，因为它非常有用，并且在许多需要计算机和Arduino板之间进行通信的实际情况项目中也被使用。它也可以用于两个Arduino板之间，或者Arduino板与其他电路之间。
- en: In the next chapter, we'll enter C code by using the serial monitoring window
    in order to make things a bit less abstract.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过使用串行监视器窗口输入C代码，以便使事情更加具体化。
