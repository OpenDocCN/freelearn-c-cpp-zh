["```cpp\n(0 OR 1)\u00a0\u00a0\u2014> TRUE\n(1 AND 0)\u00a0\u2014> FALSE\n(1 NOT 1) \u2014> FALSE\n(1 NOT 0) AND (0 NOT 1) \u2014> TRUE\n```", "```cpp\n(a1 OR a2) \u2014> TRUE \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(0 \u2228 0) = FALSE\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(0 \u2228 1) = TRUE\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(1 \u2228 0) = TRUE\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(1 \u2228 1) = TRUE\n(a1 AND a2) \u2014> TRUE\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(0 \u2227 0) = FALSE\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(0 \u2227 1) = FALSE\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(1 \u2227 0) = FALSE\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(1 \u2227 1) = TRUE\n(a1 NOT a1) \u2014> FALSE \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(0 \u00ac 0) = FALSE\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(1 \u00ac 1) = FALSE\n(a1 NOT a2) AND (a1 AND a2) \u2014> FALSE \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(0 \u00ac 0) \u2227 (0 \u2227 0) = FALSE\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(0 \u00ac 1) \u2227 (0 \u2227 1) = FALSE\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(1 \u00ac 0) \u2227 (1 \u2227 0) = FALSE\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(1 \u00ac 1) \u2227 (1 \u2227 1) = FALSE\n```", "```cpp\n\u00a0\u00a0\u00a0\u00a0For each piece, a, belonging to the current player:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Consider every possible move, m_a, that a can make:\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0For each piece, b, belonging to the opponent:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Consider each possible move m_b that b can make\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0in response to m_a.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for each piece, a, belonging to the \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0current player\u2026\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(etc.)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Count number of ways player_1 can win after this move\nNext best move is the one where the probability that player_1 wins is maximized.\n```", "```cpp\nSet\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0{\u00a02\u00a06\u00a04\u00a015\u00a03\u00a09\u00a0}\nTarget\u00a0\u2014>\u00a024\nSubset\u00a0\u2014>\u00a0{\u00a02\u00a06\u00a04\u00a0}\nSum\u00a0=\u00a02\u00a0+\u00a06\u00a0+\u00a04\u00a0=\u00a012\u00a0\nFALSE\nSubset\u00a0\u2014>\u00a0{\u00a02\u00a06\u00a015\u00a03\u00a0}\nSum\u00a0=\u00a02\u00a0+\u00a06\u00a0+\u00a015\u00a0+\u00a03\u00a0=\u00a024\nTRUE\nSubset\u00a0\u2014>\u00a0{\u00a015\u00a09\u00a0}\nSum\u00a0=\u00a015\u00a0+\u00a09\u00a0=\u00a024\nTRUE\nSubset\u00a0\u2014>\u00a0{\u00a06\u00a04\u00a03\u00a09\u00a0}\nSum\u00a0=\u00a06\u00a0+\u00a04\u00a0+\u00a03\u00a0+\u00a09\u00a0=\u00a022\nFALSE\n```", "```cpp\nCapacity\u00a0\u2014>\u00a010\u00a0\nNumber\u00a0of\u00a0items\u00a0\u2014>\u00a05\nWeights\u00a0\u2014>\u00a0{\u00a02,\u00a03,\u00a01,\u00a04,\u00a06\u00a0}\u00a0\nValues\u00a0\u2014>\u00a0\u00a0{\u00a04,\u00a02,\u00a07,\u00a03,\u00a09\u00a0}\n```", "```cpp\nfor sum (1 <= sum <= max_sum) found at index i of the set: \n\u00a0\u00a0\u00a0if sum < set[i-1]: \n\u00a0\u00a0\u00a0\u00a0DP(i, sum) = DP(i-1, sum)\n\u00a0\u00a0\u00a0if sum >= set[i-1]:\n\u00a0\u00a0\u00a0\u00a0DP(i, sum) = DP(i-1, sum) OR DP(i-1, sum - set[i-1])\n```", "```cpp\nfor total_weight (1 <= total_weight <= max_capacity) found at index i of the set:\n\u00a0\u00a0if total_weight < weight[i]:\n\u00a0\u00a0\u00a0\u00a0\u00a0maximum_value(i, total_weight) = maximum_value(i-1, total_weight)\n\u00a0\u00a0if total_weight >= weight[i]:\n\u00a0\u00a0\u00a0\u00a0\u00a0maximum_value(i, total_weight) = maximum of:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01) maximum_value(i-1, total_weight)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02) maximum_value(i-1, total_weight \u2013 weight[i]) + value[i]\n```", "```cpp\n    #include <iostream>\n    #include <vector>\n    #include <algorithm>\n    using namespace std;\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0int items, capacity;\n    \u00a0\u00a0\u00a0\u00a0cin >> items >> capacity;\n    \u00a0\u00a0\u00a0\u00a0vector<int> values(items), weight(items);\n    \u00a0\u00a0\u00a0\u00a0for(auto &v : values) cin >> v;\n    \u00a0\u00a0\u00a0\u00a0for(auto &w : weight) cin >> w;\n    \u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    }\n    ```", "```cpp\n    int Knapsack_01(int items, int capacity, vector<int> value, vector<int> weight)\n    {\n    \u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    }\n    ```", "```cpp\n    vector<vector<int>> DP(items + 1, vector<int>(capacity + 1, 0));\n    ```", "```cpp\n    for(int i = 1; i <= items; i++)\n    {\n    \u00a0\u00a0\u00a0\u00a0int currentWeight = weight[i-1];\n    \u00a0\u00a0\u00a0\u00a0int currentValue = values[i-1];\n    \u00a0\u00a0\u00a0\u00a0for(int totalWeight = 1; totalWeight <= capacity; totalWeight++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    if(totalWeight < currentWeight)\n    {\n    \u00a0\u00a0\u00a0\u00a0DP[i][totalWeight] = DP[i-1][totalWeight];\n    }\n    else \n    {\n    \u00a0\u00a0\u00a0\u00a0DP[i][totalWeight] = max(DP[i-1][totalWeight], DP[i-1][totalWeight - currentWeight] + currentValue);\n    }\n    ```", "```cpp\n    return DP[items][capacity];\n    ```", "```cpp\n    int result = Knapsack_01(items, capacity, values, weight);\n    cout << \"The highest-valued subset of items that can fit in the knapsack is: \" << result << endl;\n    return 0;\n    ```", "```cpp\n    8 66\n    20 4 89 12 5 50 8 13\n    5 23 9 72 16 14 32 4\n    ```", "```cpp\n    The highest-valued subset of items that can fit in the knapsack is: 180\n    ```", "```cpp\nCapacity = 25\nValues \u2014> { 5, 13, 4, 3, 8  }\nWeight \u2014> { 9, 12, 3, 7, 19 }\n{ 0 } \u2014> Weight = 9, Value = 5\n{ 1 } \u2014> Weight = 12, Value = 13\n{ 2 } \u2014> Weight = 3, Value = 4\n{ 3 } \u2014> Weight = 7, Value = 3\n{ 4 } \u2014> Weight = 32, Value = 8\n{ 0, 0 } \u2014> Weight = 18, Value = 10\n{ 0, 1 } \u2014> Weight = 21, Value = 18\n{ 0, 2 } \u2014> Weight = 12, Value = 9\n{ 0, 3 } \u2014> Weight = 16, Value = 8\n{ 0, 4 } \u2014> Weight = 28, Value = 13\n{ 1, 1 } \u2014> Weight = 24, Value = 26\n{ 1, 2 } \u2014> Weight = 15, Value = 17\n{ 1, 3 } \u2014> Weight = 19, Value = 16\n{ 1, 4 } \u2014> Weight = 31, Value = 21\n{ 2, 2 } \u2014> Weight = 6, Value = 8\n{ 2, 3 } \u2014> Weight = 10, Value = 7\n{ 2, 4 } \u2014> Weight = 22, Value = 12\n{ 3, 3 } \u2014> Weight = 14, Value = 6\n{ 3, 4 } \u2014> Weight = 26, Value = 11\n{ 4, 4 } \u2014> Weight = 38, Value = 16\n{ 0, 0, 0 } \u2014> Weight = 27, Value = 15\n{ 0, 0, 1 } \u2014> Weight = 30, Value = 26\n{ 0, 0, 2 } \u2014> Weight = 21, Value = 14\n{ 0, 0, 3 } \u2014> Weight = 25, Value = 13\n{ 0, 0, 4 } \u2014> Weight = 37, Value = 18\n{ 0, 1, 1 } \u2014> Weight = 33, Value = 31\n\u2026\u2026\n```", "```cpp\nfor total_weight (1 <= total_weight <= max_capacity) found at index i of the set:\n\u00a0\u00a0\u00a0\u00a0if total_weight < set[i-1]:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0maximum_value(i, total_weight) = maximum_value(i-1, total_weight)\n\n\u00a0\u00a0\u00a0\u00a0if total_weight >= set[i-1]:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0maximum_value(i, total_weight) = maximum of:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01) maximum_value(i-1, total_weight)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02) maximum_value(i-1, total_weight - current_weight) + current_value\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03) maximum_value(i, total_weight - current_weight) + current_value\n```", "```cpp\nauto max = [](int a, int b, int c) { return std::max(a, std::max(b, c)); };\nfor(int i = 1; i <= items; i++)\n{\n\u00a0\u00a0\u00a0\u00a0int current_weight = weight[i\u20141];\n\u00a0\u00a0\u00a0\u00a0int value = values[i-1];\n\u00a0\u00a0\u00a0\u00a0for(int total_weight = 0; total_weight <= capacity; w++)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(total_weight < current_weight)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DP[i][total_weight] = DP[i-1][total_weight];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DP[i][total_weight] = max\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DP[i-1][total_weight], \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DP[i-1][total_weight \u2013 current_weight] + value, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DP[i][total_weight \u2013 current_weight] + value\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n}\n```", "```cpp\nFor m <= n:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Base case:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m = 1, m = n \u2014> triangle(n, m) = 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Recurrence: \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0triangle(n, m) = triangle(n-1, m-1) + triangle(n-1, m)\n```", "```cpp\nvector<vector<int>> DP(N + 1, vector<int>(N + 1, 0));\nDP[1][1] = 1;\nfor(int row = 2; row <= N; row++)\n{\n\u00a0\u00a0\u00a0\u00a0for(int col = 1; col <= row; col++)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DP[row][col] = DP[row-1][col-1] + DP[row-1][col];\n\u00a0\u00a0\u00a0\u00a0}\n}\n```", "```cpp\nvector<vector<int>> DP(N + 1);\nDP[1] = { 0, 1 };\nfor(int row = 2; row <= N; row++)\n{\n\u00a0\u00a0\u00a0\u00a0DP[row].resize(row + 1);\n\u00a0\u00a0\u00a0\u00a0for(int col = 1; col <= row; col++)\n\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int a = DP[row-1][col-1];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int b = DP[row-1][min(col, DP[row-1].size()-1)];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DP[row][col] = a + b;\n\u00a0\u00a0\u00a0\u00a0}\n}\n```", "```cpp\nDP(7, 7) \u2261 DP(7, 1)\nDP(7, 6) \u2261 DP(7, 2)\nDP(7, 5) \u2261 DP(7, 3)\n```", "```cpp\nDP(N, M) \u2261 DP(N, N - M + 1)\n```", "```cpp\nvector<vector<int>> DP(N + 1);\nDP[0] = { 0, 1 };\nfor(int row = 1; row <= N; row++)\n{\n\u00a0\u00a0\u00a0\u00a0int width = (row / 2) + (row % 2);\n\u00a0\u00a0\u00a0\u00a0DP[row].resize(width + 2);\n\u00a0\u00a0\u00a0\u00a0for(int col = 1; col <= width; col++)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DP[row][col] = DP[row-1][col-1] + DP[row-1][col];\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0if(row % 2 == 0) \n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DP[row][width+1] = DP[row][width];\n\u00a0\u00a0\u00a0\u00a0}\n}\n\u2026\u2026\nfor(int i = 0; i < queries; i++)\n{\n\u00a0\u00a0\u00a0\u00a0int N, M;\n\u00a0\u00a0\u00a0\u00a0cin >> N >> M;\n\u00a0\u00a0\u00a0\u00a0if(M * 2 > N)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0M = N - M + 1;\n\u00a0\u00a0\u00a0\u00a0} \n\u00a0\u00a0\u00a0\u00a0cout << DP[N][M] << endl;\n}\n```", "```cpp\nmap<pair<int, int>, int> results;\nvector<pair<int, int>> queries;\nint q;\ncin >> q;\nint maxRow = 0;\nfor(int i = 0; i < q; i++)\n{\n\u00a0\u00a0\u00a0\u00a0int N, M;\n\u00a0\u00a0\u00a0\u00a0cin >> N >> M;\n\u00a0\u00a0\u00a0\u00a0queries.push_back({N, M});\n\n\u00a0\u00a0\u00a0\u00a0if(M * 2 > N) M = N - M + 1;\n\u00a0\u00a0\u00a0\u00a0results[{N, M}] = -1; \n\u00a0\u00a0\u00a0\u00a0maxRow = max(maxRow, N);\n}\nvector<int> prev = { 0, 1 };\nfor(int row = 1; row <= maxRow; row++)\n{\n\u00a0\u00a0\u00a0\u00a0int width = (row / 2) + (row % 2);\n\u00a0\u00a0\u00a0\u00a0vector<int> curr(width + 2);\n\u00a0\u00a0\u00a0\u00a0for(int col = 1; col <= width; col++)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0curr[col] = prev[col-1] + prev[col];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(results.find({row, col}) != results.end())\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queries[{row, col}] = curr[col];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0if(row % 2 == 0)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0curr[width + 1] = curr[width];\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0prev = move(curr);\n}\nfor(auto query : queries)\n{\n\u00a0\u00a0\u00a0\u00a0int N = query.first, M = query.second;\n\u00a0\u00a0\u00a0\u00a0if(M * 2 > N) M = N - M + 1;\n\n\u00a0\u00a0\u00a0\u00a0cout << results[{N, M}] << endl;\n}\n```", "```cpp\nCapacity \u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a012\nValues\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0{ 5, 1, 6, 3, 4 }\nWeight \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0{ 3, 2, 4, 5, 2 }\n```", "```cpp\nCapacity\u00a0\u2014> 12\nValues\u00a0\u00a0\u00a0\u2014> { 5, 1, 6, 3, 4 }\nWeight\u00a0\u00a0\u00a0\u2014> { 3, 2, 4, 5, 2 }\n```", "```cpp\n    #include <iostream>\n    #include <vector>\n    #include <algorithm>\n    using namespace std;\n    \u2026\u2026\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0int items, capacity;\n    \u00a0\u00a0\u00a0\u00a0cin >> items >> capacity;\n    \u00a0\u00a0\u00a0\u00a0vector<int> values(items), weight(items);\n    \u00a0\u00a0\u00a0\u00a0for(auto &v : values) cin >> v;\n    \u00a0\u00a0\u00a0\u00a0for(auto &w : weight) cin >> w;\n    \u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    }\n    ```", "```cpp\n    int UnboundedKnapsack(int items, int capacity, vector<int> values, vector<int> weight)\n    {\n    \u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    }\n    ```", "```cpp\n    vector<int> DP(capacity + 1, 0);\n    ```", "```cpp\n    for(int w = 0; w <= capacity; w++)\n    {\n    \u00a0\u00a0\u00a0\u00a0for(int i = 0; i < items; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    \u00a0\u00a0\u00a0\u00a0}\n    } \n    ```", "```cpp\n    for(int w = 0; w <= capacity; w++)\n    {\n    \u00a0\u00a0\u00a0\u00a0for(int i = 0; i < items; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(weight[i] <= w)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DP[w] = max(DP[w], DP[w - weight[i]] + values[i]);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    return DP[capacity];\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    \u00a0\u00a0\u00a0\u00a0int result = UnboundedKnapsack(items, capacity, values, weight);\n    \u00a0\u00a0\u00a0\u00a0cout << \"Maximum value of items that can be contained in the knapsack: \" << result << endl;\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    30 335\n    91 81 86 64 24 61 13 57 60 25 94 54 39 62 5 34 95 12 53 33 53 3 42 75 56 1 84 38 46 62 \n    40 13 4 17 16 35 5 33 35 16 25 29 6 28 12 37 26 27 32 27 7 24 5 28 39 15 38 37 15 40 \n    ```", "```cpp\n    Maximum value of items that can be contained in the knapsack: 7138\n    ```", "```cpp\n{ A B }\u00a0\u00a0\u00a0\u00a0Cost: 30\u00a0\u00a0\u00a0\u00a0\u00a0| Quantity: 15\u00a0\u00a0\u00a0\u00a0| Value: 70\n{ A D }\u00a0\u00a0\u00a0\u00a0Cost: 70\u00a0\u00a0\u00a0\u00a0\u00a0| Quantity: 13\u00a0\u00a0\u00a0\u00a0| Value: 110\n{ A E }\u00a0\u00a0\u00a0\u00a0Cost: 60\u00a0\u00a0\u00a0\u00a0\u00a0| Quantity: 14\u00a0\u00a0\u00a0\u00a0| Value: 130\n{ B C }\u00a0\u00a0\u00a0\u00a0Cost: 25\u00a0\u00a0\u00a0\u00a0\u00a0| Quantity: 17\u00a0\u00a0\u00a0\u00a0| Value: 40\n{ C D }\u00a0\u00a0\u00a0\u00a0Cost: 65\u00a0\u00a0\u00a0\u00a0\u00a0| Quantity: 15\u00a0\u00a0\u00a0\u00a0| Value: 80\n{ C E }\u00a0\u00a0\u00a0\u00a0Cost: 55\u00a0\u00a0\u00a0\u00a0\u00a0| Quantity: 16\u00a0\u00a0\u00a0\u00a0| Value: 100\n{ D E }\u00a0\u00a0\u00a0\u00a0Cost: 90\u00a0\u00a0\u00a0\u00a0\u00a0| Quantity: 7\u00a0\u00a0\u00a0\u00a0\u00a0| Value: 140\n{ A B D }\u00a0\u00a0Cost: 80 \u00a0\u00a0\u00a0\u00a0| Quantity: 18\u00a0\u00a0\u00a0\u00a0| Value: 130\n{ A B E }\u00a0\u00a0Cost: 70\u00a0\u00a0\u00a0\u00a0\u00a0| Quantity: 19\u00a0\u00a0\u00a0\u00a0| Value: 150\n{ B C D }\u00a0\u00a0Cost: 75\u00a0\u00a0\u00a0\u00a0\u00a0| Quantity: 20\u00a0\u00a0\u00a0\u00a0| Value: 100\n{ B D E }\u00a0\u00a0Cost: 100\u00a0\u00a0\u00a0\u00a0| Quantity: 12\u00a0\u00a0\u00a0\u00a0| Value: 160\n```", "```cpp\nSource \u2014> A\nDestination \u2014> E\nThe shortest path from A to E is equal to:\n\u00a0\u00a0\u00a0\u00a0\u2026the edge weight from A to B (4), plus\u2026\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026the shortest path from B to E, which is:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026the edge weight from B to C (3), plus:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026the edge weight from C to E (2).\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026or the edge weight from B to E (9).\n\u00a0\u00a0\u00a0\u00a0\u2026or the edge weight from A to D (3), plus:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026the shortest path from D to E, which is:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026the edge weight from D to B (8), plus:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026the shortest path from B to E (9), which is:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026the edge weight from B to C (3), plus:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026the edge weight from C to E (2).\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026or the edge weight from B to E (9).\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026the edge weight from D to C (3), plus:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026the edge weight from C to E (2).\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026or the edge weight from D to E (7).\n```", "```cpp\nShortestPath(node, depth)\nnode \u2014> the node being considered\ndepth \u2014> the current iteration in the traversal\n```", "```cpp\nif depth = 0:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ShortestPath(node, depth) \u2014> UNKNOWN\n```", "```cpp\nif node = target: \n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ShortestPath(node, depth) \u2014> 0\n```", "```cpp\nfor i = 1 to V - 1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for each edge in graph:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edge \u2014> u, v, weight \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if distance(u) is not UNKNOWN and distance(u) + weight < distance(v):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0distance(v) = distance(u) + weight\n```", "```cpp\nfor each edge adjacent to node:\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edge \u2014> neighbor, weight\n\u00a0\u00a0\u00a0\u00a0if ShortestPath(neighbor, depth - 1) + weight < ShortestPath(node, depth):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ShortestPath(node, depth) = ShortestPath(neighbor, depth - 1) + weight\n```", "```cpp\nDepth = 7:\n\u00a0\u00a0\u00a0\u00a0SP(0, 7): 0\n\u00a0\u00a0\u00a0\u00a0SP(1, 7): 6\n\u00a0\u00a0\u00a0\u00a0SP(2, 7): UNKNOWN\n\u00a0\u00a0\u00a0\u00a0SP(3, 7): 12\n\u00a0\u00a0\u00a0\u00a0SP(4, 7): UNKNOWN\n\u00a0\u00a0\u00a0\u00a0SP(5, 7): UNKNOWN\n\u00a0\u00a0\u00a0\u00a0SP(6, 7): 13\n\u00a0\u00a0\u00a0\u00a0SP(7, 7): UNKNOWN\nDepth = 6:\n\u00a0\u00a0\u00a0\u00a0SP(0, 6): 0\n\u00a0\u00a0\u00a0\u00a0SP(1, 6): 6\n\u00a0\u00a0\u00a0\u00a0SP(2, 6): 14\n\u00a0\u00a0\u00a0\u00a0SP(3, 6): 12\n\u00a0\u00a0\u00a0\u00a0SP(4, 6): UNKNOWN\n\u00a0\u00a0\u00a0\u00a0SP(5, 6): UNKNOWN\n\u00a0\u00a0\u00a0\u00a0SP(6, 6): 12\n\u00a0\u00a0\u00a0\u00a0SP(7, 6): 15\nDepth = 5:\n\u00a0\u00a0\u00a0\u00a0SP(0, 5): 0\n\u00a0\u00a0\u00a0\u00a0SP(1, 5): 6\n\u00a0\u00a0\u00a0\u00a0SP(2, 5): 14\n```", "```cpp\n    #include <iostream>\n    #include <vector>\n    #include <utility>\n    #include <map>\n    using namespace std;\n    const int UNKNOWN = 1e9;\n    ```", "```cpp\n    int V, E;\n    vector<vector<int>> adj;\n    vector<vector<int>> weight;\n    map<pair<int, int>, int> memo;\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int V, E;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cin >> V >> E;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0weight.resize(V, vector<int>(V, UNKNOWN));\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0adj.resize(V);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(int i = 0; i < E; i++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int u, v, w;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cin >> u >> v >> w;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0adj[u].push_back(v);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0weight[u][v] = w;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026\n    }\n    ```", "```cpp\n    vector<int> SingleSourceShortestPaths(int source)\n    {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    }\n    ```", "```cpp\n    // Clear table\n    vector<vector<int>> adj_t(V);\n    vector<vector<int>> weight_t(V, vector<int>(V, UNKNOWN));\n    for(int i = 0; i < V; i++)\n    {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Create transpose of graph\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(auto j : adj[i])\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0adj_t[j].push_back(i);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0weight_t[j][i] = weight[i][j];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Base case \u2014 shortest distance from source to itself is zero at any depth\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0memo[{source, i}] = 0;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(i != source) \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// If any node other than the source has been reached \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// after V - 1 iterations, no path exists.\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0memo[{i, 0}] = UNKNOWN;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0int ShortestPath_Memoization(int depth, int node, vector<vector<int>> &adj, vector<vector<int>> &weight)\n    {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    \u00a0\u00a0\u00a0\u00a0}\n    ```", "```cpp\n    // Check if key exists in map\n    if(memo.find({node, depth}) != memo.end())\n    {\n    \u00a0\u00a0\u00a0\u00a0return memo[{node, depth}];\n    }\n    memo[{node, depth}] = UNKNOWN;\n    // Iterate through adjacent edges\n    for(auto next : adj[node])\n    {\n    \u00a0\u00a0\u00a0\u00a0int w = weight[node][next];\n    \u00a0\u00a0\u00a0\u00a0int dist = ShortestPath_Memoization(depth - 1, next, adj, weight) + w;\n    \u00a0\u00a0\u00a0\u00a0memo[{node, depth}] = min(memo[{node, depth}], dist);\n    }\n    return memo[{node, depth}];\n    ```", "```cpp\n    vector<int> distance;\n\n    for(int i = 0; i < V; i++)\n    {\n    \u00a0\u00a0\u00a0\u00a0distance[i] = ShortestPath_Memoization(V - 1, i, adj_t, weight_t);\n    }\n    return distance;\n    ```", "```cpp\n    vector<vector<int>> paths(V);\n    for(int i = 0; i < V; i++)\n    {\n    \u00a0\u00a0\u00a0\u00a0paths[i] = SingleSourceShortestPaths(i);\n    }\n    ```", "```cpp\n    cout << \"The shortest distances between each pair of vertices are:\" << endl;\n    for(int i = 0; i < V; i++)\n    {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(int j = 0; j < V; j++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"\\t\" << j << \": \";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(paths[i][j] == UNKNOWN) ? cout << \"- \";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: cout << paths[i][j] << \" \";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << endl;\n    }\n    ```", "```cpp\n    8 20\n    0 1 387\n    0 3 38\n    0 5 471\n    1 0 183\n    1 4 796\n    2 5 715\n    3 0 902\n    3 1 712\n    3 2 154\n    3 6 425\n    4 3 834\n    4 6 214\n    5 0 537\n    5 3 926\n    5 4 125\n    5 6 297\n    6 1 863\n    6 7 248\n    7 0 73\n    7 3 874\n    ```", "```cpp\n    The shortest distances between each pair of vertices are:\n    0: 0 387 192 38 596 471 463 711 \n    1: 183 0 375 221 779 654 646 894 \n    2: 1252 1639 0 1290 840 715 1012 1260 \n    3: 746 712 154 0 994 869 425 673 \n    4: 535 922 727 573 0 1006 214 462 \n    5: 537 924 729 575 125 0 297 545 \n    6: 321 708 513 359 917 792 0 248 \n    7: 73 460 265 111 669 544 536 0\u00a0\u00a0\n    ```", "```cpp\n    #include <iostream>\n    #include <vector>\n    using namespace std;\n    const int UNKNOWN = 1e9;\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int V, E;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cin >> V >> E;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vector<vector<int>> weight(V, vector<int>(V, UNKNOWN));\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(int i = 0; i < E; i++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int u, v, w;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cin >> u >> v >> w;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0weight[u][v] = w;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    vector<vector<int>> FloydWarshall(int V, vector<vector<int>> weight)\n    {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    }\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0vector<vector<int>> distance(V, vector<int>(V, UNKNOWN));\n    for(int i = 0; i < V; i++)\n    {\n    \u00a0\u00a0\u00a0\u00a0for(int j = 0; j < V; j++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0distance[i][j] = weight[i][j];\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0distance[i][i] = 0;\n    }\n    ```", "```cpp\n    for(int mid = 0; mid < V; mid++)\n    {\n    \u00a0\u00a0\u00a0\u00a0for(int start = 0; start < V; start++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(int end = 0; end < V; end++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(distance[start][mid] + distance[mid][end] < distance[start][end])\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0distance[start][end] = distance[start][mid] + distance[mid][end];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    for(int i = 0; i < V; i++)\n    {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// If distance from a node to itself is negative, there must be a negative cycle\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(distance[i][i] < 0)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return {};\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    } \n    return distance;\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    \u00a0\u00a0\u00a0\u00a0vector<vector<int>> distance = FloydWarshall(V, weight);\n    \u00a0\u00a0\u00a0\u00a0// Graphs with negative cycles will return an empty vector\n    \u00a0\u00a0\u00a0\u00a0if(distance.empty())\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"NEGATIVE CYCLE FOUND\" << endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0for(int i = 0; i < V; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << i << endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(int j = 0; j < V; j++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"\\t\" << j << \": \";\n\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(distance[i][j] == UNKNOWN) \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0? cout << \"_\" << endl \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: cout << distance[i][j] << endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    Input:\n    7 9\n    0 1 3\n    1 2 5\n    1 3 10\n    1 5 -4\n    2 4 2\n    3 2 -7\n    4 1 -3\n    5 6 -8\n    6 0 12\n    Output:\n    0:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00: 0\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01: 3\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02: 6\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03: 13\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04: 8\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a05: -1\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a06: -9\n    1:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00: 0\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01: 0\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02: 3\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03: 10\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04: 5\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a05: -4\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a06: -12\n    2:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00: -1\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01: -1\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02: 0\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03: 9\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04: 2\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a05: -5\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a06: -13\n    3:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00: -8\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01: -8\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02: -7\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03: 0\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04: -5\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a05: -12\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a06: -20\n    4:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00: -3\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01: -3\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02: 0\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03: 7\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04: 0\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a05: -7\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a06: -15\n    5:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00: 4\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01: 7\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02: 10\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03: 17\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04: 12\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a05: 0\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a06: -8\n    6:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00: 12\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01: 15\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02: 18\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03: 25\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04: 20\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a05: 11\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a06: 0\n    ```", "```cpp\n    Input:\n    6 8\n    0 1 3\n    1 3 -8\n    2 1 3\n    2 4 2\n    2 5 5\n    3 2 3\n    4 5 -1\n    5 1 8\n    Output:\n    NEGATIVE CYCLE FOUND\n    ```"]