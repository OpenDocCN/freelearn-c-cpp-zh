- en: Using Templates for Generic Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模板进行通用编程
- en: In this chapter, we will learn advanced template programming techniques. These
    techniques include the ability to change the implementation of a template class
    based on the type that is provided, how to work different types of arguments including
    how to properly forward them, how to optimize your code both at runtime and compile
    time, and how to use some new features added to C++17\. This is important because
    it provides a better understanding of how template programming works as well as
    how to ensure your templates are performing the way you expect.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习高级模板编程技术。这些技术包括根据提供的类型来改变模板类的实现方式，如何处理不同类型的参数以及如何正确地转发它们，如何在运行时和编译时优化代码，以及如何使用C++17中添加的一些新特性。这很重要，因为它可以更好地理解模板编程的工作原理，以及如何确保模板的性能符合预期。
- en: Too often, we write template code assuming it is executing one way when, in
    fact, it is executing in another, either generating unreliable code, code with
    unexpected performance penalties, or both. This chapter will explain how to avoid
    these issues and provide the foundation for writing proper generic programs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 经常情况下，我们编写模板代码时假设它以某种方式执行，而实际上它以另一种方式执行，可能会生成不可靠的代码、意外的性能损失，或者两者兼而有之。本章将解释如何避免这些问题，并为编写正确的通用程序奠定基础。
- en: 'The recipes in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例如下：
- en: Implementing SFINAE
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现SFINAE
- en: Learning perfect forwarding
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习完美转发
- en: Using `if constexpr`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`if constexpr`
- en: Using tuples to work with parameter packs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用元组处理参数包
- en: Using traits to vary the behavior of template implementations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特性来改变模板实现的行为
- en: Learning how to implement `template<auto>`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何实现`template<auto>`
- en: Working with explicit template declarations
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用显式模板声明
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To compile and run the examples in this chapter, you must have administrative
    access to a computer running Ubuntu 18.04 with a functional internet connection.
    Prior to running these examples, install the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和运行本章中的示例，您必须具有管理权限的计算机，运行Ubuntu 18.04，并具有正常的互联网连接。在运行这些示例之前，安装以下内容：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If this is installed on any operating system other than Ubuntu 18.04, then GCC
    7.4 or higher and CMake 3.6 or higher will be required.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这安装在Ubuntu 18.04以外的任何操作系统上，则需要GCC 7.4或更高版本和CMake 3.6或更高版本。
- en: Implementing SFINAE
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现SFINAE
- en: In this recipe, we will learn how to use **Substitution Failure Is Not An Error** (**SFINAE**).
    This recipe is important because, often, we create templates without ensuring
    the types passed to a template are what we expect. This can lead to unexpected
    behavior, suboptimal performance, and even buggy, unreliable code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何使用**Substitution Failure Is Not An Error**（**SFINAE**）。这个示例很重要，因为我们经常创建模板时没有确保传递给模板的类型是我们期望的。这可能导致意外行为、性能不佳，甚至是错误的、不可靠的代码。
- en: SFINAE allows us to be explicit about what types we are expecting in our template.
    It also provides us with a means to change the behavior of our templates based
    on the types we are provided. The problem with SFINAE for some is that this concept
    is difficult to understand. Our goal in this recipe is to demystify SFINAE and
    show how you can use this in your own code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: SFINAE允许我们明确指定我们在模板中期望的类型。它还为我们提供了一种根据我们提供的类型来改变模板行为的方法。对于一些人来说，SFINAE的问题在于这个概念很难理解。我们在本示例中的目标是揭开SFINAE的神秘面纱，并展示您如何在自己的代码中使用它。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有编译和执行本示例中示例的必要工具。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'You need to perform the following steps to try this recipe:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这个示例，您需要执行以下步骤：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端中运行以下命令以下载源代码：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To compile the source code, run the following:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译源代码后，您可以通过运行以下命令来执行本示例中的每个示例：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本示例中所教授的课程的关系。
- en: How it works...
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, you will learn how to incorporate SFINAE in your own code. To
    start, we must first understand what SFINAE is and how the standard library uses
    it to implement `type` traits. Without knowing how `type` traits are implemented,
    it can be difficult to understand how to use them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，您将学习如何在自己的代码中使用SFINAE。首先，我们必须先了解SFINAE是什么，以及标准库如何使用它来实现`type`特性。如果不了解`type`特性是如何实现的，就很难理解如何使用它们。
- en: 'To start, the most important thing to understand with SFINAE is what its name
    says, which is that a *substitution failure is not an error*. What this means
    is that when a template type is being substituted, if a failure occurs, the compiler
    will *not* generate an error as a result. For example, we can write the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，理解SFINAE最重要的事情是理解它的名字，即*substitution failure is not an error*。这意味着当模板类型被替换时，如果发生失败，编译器将*不会*生成错误。例如，我们可以编写以下内容：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output for each of these are depicted here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每个示例的输出如下所示：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, we have created two versions of the `foo()` function. This
    first version takes a `T` type that has a `type` alias that we use to create the
    function's parameter. The second version just takes the `T` type itself. We then
    use both versions of the `foo()` function, one with an integer and the other with
    a struct that defines the `type` alias.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了`foo()`函数的两个版本。第一个版本接受具有我们用来创建函数参数的`type`别名的`T`类型。第二个版本只接受`T`类型本身。然后我们使用`foo()`函数的两个版本，一个使用整数，另一个使用定义了`type`别名的结构。
- en: 'The takeaway from the preceding example is that when we call the `foo<int>()`
    version of the `foo()` function, the compiler doesn''t generate an error when
    it attempts to match the `int` type with the version of the `foo()` function that
    takes a type with the `type` alias. This is what SFINAE is. All it says is that
    when the compiler attempts to take a given type and match it to a template, if
    a failure occurs, the compiler will not generate an error. The only time an error
    would occur is if the compiler cannot find a suitable substitution. For example,
    what happens if we comment out the second version of `foo()`? Let''s see:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中可以得出的结论是，当我们调用`foo<int>()`版本的`foo()`函数时，编译器在尝试将`int`类型与具有`type`别名的`foo()`函数的版本进行匹配时不会生成错误。这就是SFINAE。它只是说，当编译器尝试获取给定类型并将其与模板匹配时，如果发生失败，编译器不会生成错误。唯一会发生错误的情况是，如果编译器找不到合适的替换。例如，如果我们注释掉`foo()`的第二个版本会发生什么？让我们看看：
- en: '![](img/84d28ad2-c0bd-49a0-879d-ad42f5add912.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/84d28ad2-c0bd-49a0-879d-ad42f5add912.png)'
- en: As you can see from the preceding error output, the compiler is even saying
    that the error is a substitution error. The template that we provide is not a
    valid candidate based on the type that was provided.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的错误输出中可以看出，编译器甚至说错误是一个替换错误。我们提供的模板不是基于提供的类型的有效候选。
- en: The other important takeaway from this example is that the compiler was able
    to pick between the two different versions of our `foo()` function based on the
    type that was provided. We can use this to our advantage. Specifically, this gives
    us the power to do different things based on the type that is provided. All we
    need is a means to write our `foo()` function so that we can enable/disable different
    versions of our templates based on the types that we are provided.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中得出的另一个重要结论是，编译器能够根据提供的类型在两个不同版本的`foo()`函数之间进行选择。我们可以利用这一点。具体来说，这给了我们根据提供的类型做不同事情的能力。我们所需要的只是一种方法来编写我们的`foo()`函数，以便我们可以根据我们提供的类型启用/禁用模板的不同版本。
- en: 'This is where `std::enable_if` comes into play. `std::enable_if` takes the
    idea of SFINAE to the next step, allowing us to define a type if its parameter
    is true. Otherwise, it will generate a substitution error, purposely forcing the
    compiler to pick a different version of the template. `std::enable_if` is defined
    as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`std::enable_if`发挥作用的地方。`std::enable_if`将SFINAE的思想推向了下一步，允许我们在其参数为true时定义一个类型。否则，它将生成一个替换错误，故意迫使编译器选择模板的不同版本。`std::enable_if`的定义如下：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This first defines a struct that takes `bool B` and a `T` type that defaults
    to `void`. It then defines a specialization of this `struct` type when `bool`
    is true. Specifically, when the `bool` value is `true`, the type that is provided
    is returned, which, as we stated before, defaults to `void`. To see how this is
    used, let''s look at an example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先定义了一个结构，它接受`bool B`和一个默认为`void`的`T`类型。然后定义了这个`struct`类型的一个特化，当`bool`为true时。具体来说，当`bool`值为`true`时，返回提供的类型，这个类型默认为`void`。为了看到这是如何使用的，让我们看一个例子：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/395bc1d6-02a2-4609-be80-8855f53d6acc.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/395bc1d6-02a2-4609-be80-8855f53d6acc.png)'
- en: In this example, we create a function called `is_int()` that always returns
    `false`. We then create a template specialization of this function for `int` that
    returns `true`. Next, we create a function that takes any type, but we add `std::enable_if_t`
    (the added `_t` part is a shorthand that was added to C++17 for `::type`) to the
    template definition that uses our `is_int()` function. If the `T` type that is
    provided is `int`, our `is_int()` function will return `true`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为`is_int()`的函数，它总是返回`false`。然后我们为`int`创建了这个函数的模板特化，返回`true`。接下来，我们创建了一个接受任何类型的函数，但我们在使用我们的`is_int()`函数的模板定义中添加了`std::enable_if_t`（添加的`_t`部分是C++17中为`::type`添加的简写）。如果提供的`T`类型是`int`，我们的`is_int()`函数将返回`true`。
- en: '`std::enable_if` does nothing by default. If it is `true`, however, it returns
    a `type` alias, which, in the preceding example, is the `int` type that we are
    passing as the second parameter of `std::enable_if`. What this is saying is that
    if `std::enable_if` is `true`, it will return an `int` type. We then set this
    `int` type to `0`, which is a valid thing to do. This doesn''t generate a failure;
    our template function becomes a valid substitution and, therefore, is used. In
    summary, if `T` is an `int` type, `std::enable_if` turns into an `int` type itself
    that we then set to `0`, which compiles without an issue. If our `T` type is not `int`,
    `std::enable_if` turns into nothing. Attempting to set nothing to `0` results
    in a compilation error, but since this is SFINAE, the compiler error becomes nothing
    more than a substitution error.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::enable_if`默认情况下什么也不做。但如果它为`true`，它会返回一个`type`别名，在前面的例子中，就是我们作为`std::enable_if`第二个参数传递的`int`类型。这意味着如果`std::enable_if`为`true`，它将返回一个`int`类型。然后我们将这个`int`类型设置为`0`，这是一个有效的操作。这不会产生失败；我们的模板函数成为一个有效的替换，因此被使用。总之，如果`T`是`int`类型，`std::enable_if`会变成一个`int`类型本身，然后我们将其设置为`0`，这样就可以编译而不会出现问题。如果我们的`T`类型不是`int`，`std::enable_if`会变成什么也没有。试图将什么也没有设置为`0`会导致编译错误，但由于这是SFINAE，编译器错误不会变成更多的替换错误。'
- en: 'Let''s look at the error case. If we set `42` to `42.0`, which is a `double`,
    not `int`, we get the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看错误的情况。如果我们将`42`设置为`42.0`，这是一个`double`，而不是`int`，我们会得到以下结果：
- en: '![](img/3eadc479-fa00-4c25-9a68-b82cb13ee914.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3eadc479-fa00-4c25-9a68-b82cb13ee914.png)'
- en: As you can see from the preceding error, the compiler is saying that there is
    no type named `type` in `enable_if`. If you look at the definition of `std::enable_if`,
    this is expected because `std::enable_if` doesn't do anything if it is false.
    It only creates a type named `type` if it is true.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从上面的错误中看到的，编译器说在`enable_if`中没有名为`type`的类型。如果您查看`std::enable_if`的定义，这是预期的，因为如果为false，`std::enable_if`不会执行任何操作。它只有在为true时才创建一个名为`type`的类型。
- en: 'To better understand how this works, let''s look at another example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这是如何工作的，让我们看另一个例子：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/cb55d047-89b4-4e40-815a-273456762831.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb55d047-89b4-4e40-815a-273456762831.png)'
- en: In the preceding example, we use `std::is_integral_v`, which does the same thing
    as our `is_int()` function, with the difference being that it is provided by the
    standard library and can handle CV types. In fact, the standard library has a
    massive list of different versions of these functions including different types,
    inheritance properties, CV properties, and so on. If you need to check for a `type`
    property of any kind, chances are that the standard library has an `std:is_xxx`
    function that you can use.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们使用了`std::is_integral_v`，它与我们的`is_int()`函数做了相同的事情，不同之处在于它是由标准库提供的，并且可以处理CV类型。事实上，标准库有一个巨大的不同版本的这些函数列表，包括不同的类型、继承属性、CV属性等等。如果您需要检查任何类型的`type`属性，很有可能标准库有一个`std:is_xxx`函数可以使用。
- en: The preceding example is nearly identical to our previous one with the difference
    being that we do not return `int` in our `std::enable_if` method. Instead, we
    use `* = nullptr`. This works because `std::enable_if` returns `void` by default.
    The `*` character turns this void into a void pointer, which we then set to `nullptr`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子几乎与我们之前的例子相同，不同之处在于我们在`std::enable_if`方法中不返回`int`。相反，我们使用`* = nullptr`。这是因为`std::enable_if`默认返回`void`。`*`字符将这个void转换为一个void指针，然后我们将其设置为`nullptr`。
- en: 'In the next example, we show another twist on this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个例子中，我们展示了另一个变化：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output is as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/5ca6a189-e687-45a2-a8cd-422d3e2f274e.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ca6a189-e687-45a2-a8cd-422d3e2f274e.png)'
- en: 'In this example, `void` for our function is created by `std::enable_if`. If
    `T` is not an integer, `void` is not returned and we see this error (instead of
    the code compiling and allowing us to execute it in the first place):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的函数的`void`是由`std::enable_if`创建的。如果`T`不是整数，就不会返回`void`，我们会看到这个错误（而不是首先编译和允许我们执行它）：
- en: '![](img/d7ec86d0-edec-409d-8dd5-76b3abfa3978.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7ec86d0-edec-409d-8dd5-76b3abfa3978.png)'
- en: 'In summary, `std::enable_if` will create a type named `type`, which is based
    on the type that you provide it. By default, this is `void` but you can pass in
    any type that you want. Not only can this functionality be used to enforce a type
    for our templates, but it can also be used to define different functions based
    on the type that we are provided, as shown in this example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，`std::enable_if`将创建一个名为`type`的类型，该类型基于您提供的类型。默认情况下，这是`void`，但您可以传入任何您想要的类型。这种功能不仅可以用于强制执行模板的类型，还可以根据我们提供的类型定义不同的函数，就像在这个示例中所示的那样：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output for the preceding code is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 上面代码的输出如下：
- en: '![](img/1c12f216-9fc9-4b34-9868-9ccf45ae4fb7.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1c12f216-9fc9-4b34-9868-9ccf45ae4fb7.png)'
- en: Like our first example in this recipe, we have created two different versions
    of the same function. SFINAE allows the compiler to pick the most suitable version
    based on the type that was provided.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 就像本教程中的第一个例子一样，我们创建了相同函数的两个不同版本。SFINAE允许编译器根据提供的类型选择最合适的版本。
- en: Learning perfect forwarding
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习完美转发
- en: In this recipe, we will learn how to use perfect forwarding. This recipe is
    important because, often, when writing templates, we pass template parameters
    to other functions. If we do not use perfect forwarding, we can inadvertently
    convert r-value references into l-value references, resulting in a potential copy
    taking place instead of a move, which, in some cases, could be suboptimal. Perfect
    forwarding also provides the compiler with hints that could be leveraged to improve
    function inlining and unwrapping.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将学习如何使用完美转发。这个教程很重要，因为在编写模板时，通常我们将模板参数传递给其他函数。如果我们不使用完美转发，我们可能会无意中将r值引用转换为l值引用，导致潜在的复制发生，而不是移动，在某些情况下，这可能是不太理想的。完美转发还为编译器提供了一些提示，可以用来改进函数内联和展开。
- en: Getting ready
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有编译和执行本教程中示例所需的适当工具。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'You need to perform the following steps to try this recipe:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要执行以下步骤来尝试这个教程：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个新的终端，运行以下命令来下载源代码：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To compile the source code, run the following:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦源代码编译完成，您可以通过运行以下命令来执行本教程中的每个示例：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本教程中所教授的课程的关系。
- en: How it works...
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In this recipe, we will learn how to use perfect forwarding to ensure that,
    when we pass parameters in our templates (that is, forward our parameters), we
    do so in a way that doesn''t erase r-valueness. To better understand the issue,
    let''s look at the following example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何使用完美转发来确保当我们在模板中传递参数时（也就是转发我们的参数），我们以不会抹去r-value特性的方式进行。为了更好地理解这个问题，让我们看下面的例子：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output is as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/eb4f4cb0-e924-4b6e-af1a-617c8e3183b0.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb4f4cb0-e924-4b6e-af1a-617c8e3183b0.png)'
- en: 'In the preceding example, we have two different versions of a `foo()` function:
    one that takes an l-value reference and one that takes an r-value reference. We
    then call `foo()` from a template function. This template function takes a forwarding
    reference (also called a universal reference), which is an r-value reference paired
    with either `auto` or a template function. Finally, from our main function, we
    call our template to see which `foo()` function is called. The first time we call
    our template, we pass in an l-value. Since we are given an l-value, the universal
    reference becomes an l-value, and the l-value version of our `foo()` function
    is called. The problem is, the second time we call our template function, we give
    it an r-value, but it calls the l-value version of our `foo()` function, even
    though it was given an r-value.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们有`foo()`函数的两个不同版本：一个接受l-value引用，一个接受r-value引用。然后我们从模板函数中调用`foo()`。这个模板函数接受一个转发引用（也称为通用引用），它是一个r-value引用，配合`auto`或模板函数。最后，从我们的主函数中，我们调用我们的模板来看哪个`foo()`函数被调用。第一次调用我们的模板时，我们传入一个l-value。由于我们得到了一个l-value，通用引用变成了l-value，并且调用了我们的`foo()`函数的l-value版本。问题是，第二次调用我们的模板函数时，我们给它一个r-value，但它调用了我们的`foo()`函数的l-value版本，即使它得到了一个r-value。
- en: The common mistake here is that even though the template function takes a universal
    reference and we have a version of the `foo()` function that also takes an r-value,
    we assume this `foo()` function would be called. Scott Meyers does a great job
    explaining this in many of his lectures on universal references. The problem is
    that the moment you use a universal reference, it becomes an l-value. The very
    act of passing the `names` parameter, which means it must be an l-value. It forces
    the compiler to convert to an l-value because it sees you using it, even though
    all you are doing is passing the parameter. It should be noted that our example
    doesn't compile with optimizations as the compiler is free to optimize the l-value
    out if it can safely determine that the variable is not used.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的常见错误是，即使模板函数接受一个通用引用，我们也有一个接受r-value的`foo()`函数的版本，我们假设会调用这个`foo()`函数。Scott
    Meyers在他关于通用引用的许多讲座中很好地解释了这一点。问题在于，一旦使用通用引用，它就变成了l-value。传递`names`参数的行为，意味着它必须是l-value。它迫使编译器将其转换为l-value，因为它看到你在使用它，即使你只是在传递参数。值得注意的是，我们的示例在优化时无法编译，因为编译器可以安全地确定变量没有被使用，从而可以优化掉l-value。
- en: 'To prevent this issue, we need to tell the compiler that we wish to forward
    the parameter. Normally, we would use `std::move()` for this. The problem is,
    if we were originally given an l-value, we cannot use `std::move()` as that would
    convert an l-value into an r-value. This is why the standard library has `std::forward()`,
    which is implemented using the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这个问题，我们需要告诉编译器我们希望转发参数。通常，我们会使用`std::move()`来实现。问题是，如果我们最初得到的是l-value，我们不能使用`std::move()`，因为那样会将l-value转换为r-value。这就是标准库有`std::forward()`的原因，它是使用以下方式实现的：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'All `std::forward()` does is cast the parameter back to its original reference
    type. This tells the compiler explicitly to treat the parameter as an r-value
    if it was originally an r-value, as in the following example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::forward()`的作用如下：将参数强制转换回其原始引用类型。这告诉编译器明确地将参数视为r-value，如果它最初是r-value，就像以下示例中一样：'
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/c64d9b68-b5d8-4ce2-ba02-17195ee8906d.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c64d9b68-b5d8-4ce2-ba02-17195ee8906d.png)'
- en: The preceding example is identical to the first example with the only difference
    being that we pass the parameter in our template function using `std::forward()`.
    This time, when we call our template function with an r-value, it calls the r-value
    version of our `foo()` function. This is called **perfect forwarding**. It ensures
    that we maintain CV properties and l-/r-value properties when passing parameters.
    It should be noted that perfect forwarding only works when using template functions
    or `auto`. What this means is that perfect forwarding is usually only useful when
    writing wrappers. A good example of a standard library wrapper is `std::make_unique()`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例与第一个示例相同，唯一的区别是我们在模板函数中使用`std::forward()`传递参数。这一次，当我们用r-value调用我们的模板函数时，它调用我们的`foo()`函数的r-value版本。这被称为**完美转发**。它确保我们在传递参数时保持CV属性和l-/r-value属性。值得注意的是，完美转发只在使用模板函数或`auto`时有效。这意味着完美转发通常只在编写包装器时有用。标准库包装器的一个很好的例子是`std::make_unique()`。
- en: 'One issue with a wrapper such as `std::make_unique()` is that you might not
    know how many parameters need to be passed. That is, you might end up needing
    variadic template arguments in your wrapper. Perfect forwarding supports this
    by doing the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::make_unique()`这样的包装器的一个问题是，你可能不知道需要传递多少个参数。也就是说，你可能最终需要在你的包装器中使用可变模板参数。完美转发通过以下方式支持这一点：'
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output is as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/6a2956d6-ac8c-4113-b411-eb131555a556.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a2956d6-ac8c-4113-b411-eb131555a556.png)'
- en: The preceding example works because the variadic template arguments being passed
    to our `foo()` function are replaced by a comma-separated list of perfect forwards.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例之所以有效，是因为传递给我们的`foo()`函数的可变模板参数被替换为逗号分隔的完美转发列表。
- en: Using if constexpr
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用if constexpr
- en: In this recipe, we will learn how to use a new feature in C++17 called `constexpr
    if`. This recipe is important because it will teach you how to create `if` statements
    that are evaluated at runtime. Specifically, what this means is that the branch
    logic is picked at compile time and not at runtime. This allows you to change
    the behavior of a function at compile time without sacrificing performance, something
    that, in the past, could only be done with macros, which is not useful in template
    programming, as we will show.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将学习如何使用C++17中的一个新特性`constexpr if`。这个教程很重要，因为它将教会你如何创建在运行时评估的`if`语句。具体来说，这意味着分支逻辑是在编译时选择的，而不是在运行时。这允许您在编译时更改函数的行为，而不会牺牲性能，这是过去只能通过宏来实现的，而在模板编程中并不实用，正如我们将展示的那样。
- en: Getting ready
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有编译和执行本教程中示例所需的适当工具。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'You need to perform the following steps to try this recipe:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要执行以下步骤来尝试这个教程：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端运行以下命令来下载源代码：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To compile the source code, run the following:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译完成后，您可以通过运行以下命令来执行本教程中的每个示例：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用，以及它与本教程所教授的课程的关系。
- en: How it works...
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Sometimes, we wish to change the behavior of our programs but the code that
    we are creating is always constant, meaning the compiler is capable of determining
    the value of the branch itself, as shown in this example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望改变程序的行为，但我们创建的代码始终是常量，这意味着编译器能够确定分支本身的值，就像这个示例中所示的那样：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is a common `if` statement used in a lot of code, including the standard
    library. If debugging is enabled, this code evaluates to `true`. We use this by
    adding debug statements to our code, which can be turned off. The compiler is
    smart enough to see that `NDEBUG` is `true` or `false` and will either add the
    code or remove the code completely. In other words, the compiler can make a simple
    optimization and reduce the size of the code as well as remove an unneeded branch
    as it knows the value of this `if` statement will never change at runtime. The
    problem is, this trick relies on the fact that the compiler is smart. The removal
    of the logic is implicitly trusted, which often leads to assumptions about what
    the compiler is doing. C++17 added a `constexpr if` statement that allows us to
    be explicit instead. It allows us to tell the compiler: that the statement I am
    providing should be evaluated at compile time, not at runtime. What makes this
    truly powerful is that we get compile-time errors when this assumption is not
    true, meaning the optimizations we were implicitly trusting the compiler to perform,
    we can now verify at compile time, and if the assumptions are false, we are told
    so that we can fix the issue, as shown in this example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常见的`if`语句，在很多代码中都有，包括标准库。如果启用了调试，这段代码将评估为`true`。我们可以通过向代码添加调试语句来使用它，这些语句可以被关闭。编译器足够聪明，能够看到`NDEBUG`是`true`还是`false`，并且会添加代码或完全删除代码。换句话说，编译器可以进行简单的优化，减小代码的大小，并且在运行时永远不会改变这个`if`语句的值。问题是，这个技巧依赖于编译器的智能。逻辑的移除是隐式信任的，这经常导致对编译器正在做什么的假设。C++17添加了一个`constexpr
    if`语句，允许我们明确地进行。它允许我们告诉编译器：我提供的语句应该在编译时而不是在运行时进行评估。这真正强大的地方在于，当这个假设不成立时，我们会在编译时获得编译时错误，这意味着我们以前隐式信任编译器执行的优化，现在可以在编译时进行验证，如果假设是错误的，我们会得到通知，以便我们可以解决问题，就像这个示例中所示的那样：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/cf8bb6b4-07e7-4b3e-a97e-3a558cfc3533.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf8bb6b4-07e7-4b3e-a97e-3a558cfc3533.png)'
- en: 'In the preceding example, we create `constexpr` and evaluate it at compile
    time instead of runtime. If we change `constexpr` to an actual variable, `constexpr
    if` will result in the following error:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了`constexpr`并在编译时而不是在运行时进行了评估。如果我们将`constexpr`更改为实际变量，`constexpr
    if`将导致以下错误：
- en: '![](img/9474112b-7528-4649-b754-1e6702247c6c.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9474112b-7528-4649-b754-1e6702247c6c.png)'
- en: 'We can then use this in our template functions to change the behavior of our
    template functions based on the type that we are given, as shown in this example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在我们的模板函数中使用它来根据我们给定的类型改变我们的模板函数的行为，就像这个示例中所示的那样：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding example, we use the `std::is_floating_point_v` type trait to
    determine whether the type that we were provided is a floating point or not. If
    the type is not a floating point, this will return `constexpr false`, which the
    compiler can optimize out. Since we are using `constexpr if`, we can ensure that
    our `if` statement is actually `constexpr` and not a runtime conditional.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用`std::is_floating_point_v`类型特征来确定我们提供的类型是否是浮点类型。如果类型不是浮点类型，这将返回`constexpr
    false`，编译器可以优化掉。由于我们使用了`constexpr if`，我们可以确保我们的`if`语句实际上是`constexpr`而不是运行时条件。
- en: Using tuples to work with parameter packs
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用元组处理参数包
- en: In this recipe, we will learn how to work with variadic parameter lists using `std::tuple`.
    This is important because a variadic parameter list is meant to be used in wrapper
    functions where the wrapper doesn't know anything about the arguments being passed
    to it but instead will forward these arguments to something that does. There are,
    however, use cases where you will care about the arguments being passed, and you
    must have a way of working with these arguments. This recipe will demonstrate
    how to do that including how to deal with any number of arguments.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何使用`std::tuple`处理可变参数列表。这很重要，因为可变参数列表是用于包装函数的，包装器不知道传递给它的参数，而是将这些参数转发给了解这些参数的东西。然而，也有一些用例，你会关心传递的参数，并且必须有一种方法来处理这些参数。本教程将演示如何做到这一点，包括如何处理任意数量的参数。
- en: Getting ready
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有正确的工具来编译和执行本教程中的示例。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'You need to perform the following steps to try this recipe:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要执行以下步骤来尝试本教程：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端中运行以下命令以下载源代码：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To compile the source code, run the following:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译完成后，可以通过运行以下命令执行本教程中的每个示例：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本教程中所教授的内容的关系。
- en: How it works...
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'Variadic templates provide the programmer with the ability to define a template
    function without needing to define all of the arguments. These are used heavily
    in wrapper functions as they prevent the wrapper from having to have any knowledge
    of the function''s arguments, as shown in this example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 可变模板使程序员能够定义模板函数，而无需定义所有参数。这些在包装函数中被广泛使用，因为它们防止包装器必须了解函数的参数，如下例所示：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As shown in the preceding example, we have created a `foo` function that can
    take any number of arguments. In this example, we use the universal reference
    notation, `Args &&...args`, which ensures the CV qualifiers and l-/r-valueness
    is preserved, meaning we can then use `std::forward()` to pass the variable arguments
    list to any other function with as little loss in performance as possible. Functions
    such as `std::make_unique()` make heavy use of variadic parameters.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，我们创建了一个可以接受任意数量参数的`foo`函数。在这个例子中，我们使用了通用引用符号`Args &&...args`，它确保了CV限定符和l-/r-值性得到保留，这意味着我们可以使用`std::forward()`将可变参数列表传递给任何其他函数，尽可能少地降低性能损失。诸如`std::make_unique()`之类的函数大量使用可变参数。
- en: 'Sometimes, however, you might want to access one of the arguments in the list
    that is provided. To do this, we can use `std::tuple`. This is a data structure
    that takes a variable number of arguments and provides an `std::get()` function
    to get any data from `std::tuple`, as shown in this example:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时您可能希望访问提供的参数列表中的一个参数。为此，我们可以使用`std::tuple`。这是一个接受可变数量参数并提供`std::get()`函数从`std::tuple`获取任何数据的数据结构，如下例所示：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output is as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/e3147713-d2d1-4d27-b867-d95407e67851.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3147713-d2d1-4d27-b867-d95407e67851.png)'
- en: 'In the preceding example, we create `std::tuple` and then we output the contents
    of `std::tuple` to `stdout` using the `std:get()` function. If you attempt to
    access data that is out of range, the compiler will know at compile time, and
    give you an error that looks something like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了`std::tuple`，然后使用`std::get()`函数将`std::tuple`的内容输出到`stdout`。如果尝试访问超出范围的数据，编译器将在编译时知道，并给出类似于以下的错误：
- en: '![](img/f0d35dc0-05d0-44ae-9202-1dbc5da6503c.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0d35dc0-05d0-44ae-9202-1dbc5da6503c.png)'
- en: 'Using `std::tuple`, we can access the data from a variadic parameter list as
    follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`std::tuple`，我们可以按以下方式访问可变参数列表中的数据：
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output is as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/fac54cfd-01a0-4fc8-a4e1-80bb81c1fd5f.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fac54cfd-01a0-4fc8-a4e1-80bb81c1fd5f.png)'
- en: In the preceding example, we create a function with a variadic parameter list.
    We then pass this list using `std::forward()` to preserve the l-/r-valueness to `std::tuple`.
    Finally, we use `std::tuple` to access the arguments. If we didn't use `std::forward()`,
    we would end up with l-value versions of the data passed to `std::tuple`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个带有可变参数列表的函数。然后，我们使用`std::forward()`传递此列表以保留l-/r-值性到`std::tuple`。最后，我们使用`std::tuple`来访问这些参数。如果我们不使用`std::forward()`，我们将得到传递给`std::tuple`的数据的l-value版本。
- en: 'The obvious problem with the preceding examples is that we have hardcoded the
    `0` and `1` indexes into `std::tuple`. Variadic parameters are not a runtime,
    dynamic array of parameters. Instead, they are a way of saying *I don''t care
    about the parameters I have been given*, which is why they are normally used by
    wrappers. A wrapper is wrapping something that does care about the parameters.
    In the case of `std::make_unique()`, the function is creating `std::unique_ptr`.
    To do this, `std::make_unique()` will allocate `std::unique_ptr` for you, using
    the variadic parameter list to initialize the newly allocated type and then provide
    the pointer to this type to `std::unique_ptr` for you, as shown in this example:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 上面例子的明显问题是，我们在`std::tuple`中硬编码了`0`和`1`索引。可变参数不是运行时的、动态的参数数组。相反，它们是一种说“我不关心我收到的参数”的方式，这就是为什么它们通常被包装器使用的原因。包装器是包装一些关心参数的东西。在`std::make_unique()`的情况下，该函数正在创建`std::unique_ptr`。为此，`std::make_unique()`将为您分配`std::unique_ptr`，使用可变参数列表来初始化新分配的类型，然后将指针提供给`std::unique_ptr`，就像这个例子中所示的那样：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The wrapper doesn't care about the arguments being passed. The constructor for
    `T` does. If you attempt to access the variadic arguments, you are saying *I do
    care about the arguments*, in which case, if you care, you must have some idea
    of the layout of the parameters being passed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 包装器不关心传递的参数。`T`的构造函数关心。如果你尝试访问可变参数，你就是在说“我关心这些参数”，在这种情况下，如果你关心，你必须对传递的参数的布局有一些想法。
- en: 'There are some tricks that allow you to work with an unknown number of arguments,
    however. The biggest problem with attempting to do this is the library facilities
    for working with variadic parameters are best used during runtime, which doesn''t
    help in most cases, as shown in this example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些技巧可以让你处理未知数量的参数，然而。尝试这样做的最大问题是处理可变参数的库设施最好在运行时使用，这在大多数情况下并不起作用，就像这个例子中所示的那样：
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output is as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/3e437b68-faa5-4a2b-a2e5-1353d8935542.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e437b68-faa5-4a2b-a2e5-1353d8935542.png)'
- en: In the preceding example, we attempt to get the total size of the number of
    arguments in the variadic parameter list. We can do this either using the variadic
    version of the `sizeof()` function or we can use the `std::tuple_size` trait.
    The problem is this doesn't help us during compile time as we cannot loop through
    the parameters using this size information (as there is no `for` loop for compile-time
    logic).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们试图获取可变参数列表中参数的总大小。我们可以使用`sizeof()`函数的可变版本，也可以使用`std::tuple_size`特性来实现这一点。问题是，这并不能在编译时帮助我们，因为我们无法使用这个大小信息来循环遍历参数（因为编译时逻辑没有`for`循环）。
- en: 'To overcome this, one trick that we can use is something called compile-time
    recursion. This trick uses templates to create a recursive template function that
    will loop through all of the arguments in a variadic parameter list. Check out
    this example:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这一点，我们可以使用一种称为编译时递归的技巧。这个技巧使用模板来创建一个递归模板函数，它将循环遍历可变参数列表中的所有参数。看看这个例子：
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We start with a template function that performs all of the magic. This first
    template parameter is `I`, which is an integer that starts as `0`. The next is
    a variadic template parameter and the last is a function type. Our template function
    takes `std::tuple`, which we wish to iterate over (in this case, we show a constant
    version, but we could overload this to provide a non-constant version as well),
    and a function that we wish to call for each element in `std::tuple`. In other
    words, this function will loop over each element in `std::tuple` and call the
    provided function with each element iterated over, just like `for_each()`, which we
    are used to using at runtime in other languages or C++ libraries.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个执行所有魔术的模板函数开始。第一个模板参数是`I`，它是一个从`0`开始的整数。接下来是一个可变模板参数，最后是一个函数类型。我们的模板函数接受我们希望迭代的`std::tuple`（在这种情况下，我们展示了一个常量版本，但我们也可以重载它以提供一个非常量版本），以及我们希望对`std::tuple`中的每个元素调用的函数。换句话说，这个函数将循环遍历`std::tuple`中的每个元素，并对每个迭代的元素调用提供的函数，就像我们在其他语言或C++库中运行时使用的`for_each()`一样。
- en: 'Inside this function, we check to see whether we have reached the total size
    of the tuple. If we have not, we get the element in the tuple for the current
    value of `I`, pass it to the provided function, and then call our `for_each()`
    function again with `I++`. To use this `for_each()` function, we can do the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数内部，我们检查是否已经达到了元组的总大小。如果没有，我们获取元组中当前值为`I`的元素，将其传递给提供的函数，然后再次调用我们的`for_each()`函数，传入`I++`。要使用这个`for_each()`函数，我们可以这样做：
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here, we have been given a variadic parameter list and we wish to iterate over
    this list and output each argument to `stdout`. To do this, we create `std::tuple`
    as we have previously, but this time, we pass `std::tuple` to our `for_each()`
    function:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们得到了一个可变参数列表，我们希望迭代这个列表并将每个参数输出到`stdout`。为此，我们创建了`std::tuple`，就像以前一样，但这次，我们将`std::tuple`传递给我们的`for_each()`函数：
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output is as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/d6d45daa-3d12-43cd-b947-93a9aa3990f1.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6d45daa-3d12-43cd-b947-93a9aa3990f1.png)'
- en: Just like we did in the previous examples, we call our `foo` function with some
    text that we wish to output to `stdout`, hence demonstrating how to work with
    variadic function parameters using `std:tuple`, even if we don't know the total
    number of arguments we will be given.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在之前的例子中所做的那样，我们调用我们的`foo`函数，并传入一些文本，我们希望将其输出到`stdout`，从而演示如何使用`std:tuple`处理可变函数参数，即使我们不知道将收到的参数的总数。
- en: Using type traits to overload functions and objects
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型特征来重载函数和对象
- en: One issue that C++ had to deal with when C++11 was created was how to handle
    resizing `std::vector`, which is capable of taking any type, including types that
    can throw from `std::move()`. When resizing, new memory is created and the elements
    from the old vector are moved to the new vector. This works great because, if
    `std::move()` cannot throw, the resize can safely be performed as once the resizing
    function starts to move elements from one array to the other, no errors can occur.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: C++11创建时，C++需要处理的一个问题是如何处理`std::vector`的调整大小，它能够接受任何类型，包括从`std::move()`抛出异常的类型。调整大小时，会创建新的内存，并将旧向量的元素移动到新向量。这很好地工作，因为如果`std::move()`不能抛出异常，那么一旦调整大小函数开始将元素从一个数组移动到另一个数组，就不会发生错误。
- en: If `std::move()` can throw, however, it is possible that part of the way through
    the loop, an error could occur. The `resize()` function, however, would have no
    way to put the old memory back to normal as attempting to move to the old memory
    could also throw an exception. In this case, `resize()` performs a copy instead
    of a move. A copy ensures that the old memory has a valid copy of each object;
    so, if an exception is thrown, the original array is left intact and the exception
    can be thrown as needed.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果`std::move()`可能会抛出异常，那么在循环进行到一半时可能会发生错误。然而，`resize()`函数无法将旧内存恢复正常，因为尝试移动到旧内存也可能会引发异常。在这种情况下，`resize()`执行复制而不是移动。复制确保旧内存有每个对象的有效副本；因此，如果抛出异常，原始数组保持不变，并且可以根据需要抛出异常。
- en: In this recipe, we will explore how this is done by changing the behavior of
    a template class using traits.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将探讨如何通过更改模板类的行为来实现这一点。
- en: Getting ready
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有编译和执行本示例的适当工具。完成后，打开一个新的终端。我们将使用此终端来下载、编译和运行示例。
- en: How to do it...
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'You need to perform the following steps to try this recipe:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试此示例，需要执行以下步骤：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端运行以下命令以下载源代码：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To compile the source code, run the following:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译源代码后，可以通过运行以下命令来执行本示例中的每个示例：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐步介绍每个示例，并解释每个示例程序的作用以及它与本示例中所教授的课程的关系。
- en: How it works...
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'C++ added a function called `std::move_if_noexcept()`. This function will cast
    as an r-value if the move constructor/assignment operator cannot throw, and will
    cast as an l-value otherwise. For example, take a look at the following code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: C++添加了一个名为`std::move_if_noexcept()`的函数。如果移动构造函数/赋值运算符不能抛出异常，此函数将转换为右值，否则将转换为左值。例如，看一下以下代码：
- en: '[PRE43]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To try this, we will perform the following steps:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这样做，我们将执行以下步骤：
- en: 'First, we will create a class that has a move/copy constructor that cannot
    throw:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个类，该类具有一个不能抛出异常的移动/复制构造函数：
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, we will provide a class that has a move/copy constructor that can throw.
    Finally, let''s use `std::move_if_noexcept()` to see whether a move or a copy
    occurs when attempting to move an instance of each of these preceding classes:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将提供一个具有可能抛出异常的移动/复制构造函数的类。最后，让我们使用`std::move_if_noexcept()`来查看在尝试移动这些先前类的实例时是发生移动还是复制：
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output for the preceding code is as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/0308a282-75f7-42fd-82e6-4debaf2bd0d2.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0308a282-75f7-42fd-82e6-4debaf2bd0d2.png)'
- en: As shown in the preceding example, in one case, the move constructor is called
    and in the other case, the copy constructor is called based on whether or not
    the type can throw an exception when performing a move.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，在一种情况下，调用移动构造函数，在另一种情况下，调用复制构造函数，这取决于类型在执行移动时是否会抛出异常。
- en: 'Now, let''s create a simple mock vector with a resize function to demonstrate
    how we can change the behavior of our `template` class using traits:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个简单的模拟向量，并添加一个调整大小函数，以演示如何使用特性更改我们的`template`类的行为：
- en: '[PRE46]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Our mock vector has an internal buffer and a size. When the vector is created,
    we allocate the internal buffer using the given size. We then provide a `resize()`
    function that can be used to resize the internal buffer given a new size. The
    first thing we do is create our new internal buffer, and then we loop through
    each element and the element from one buffer to the other. If `T` cannot throw,
    no exception will fire during the execution of the loop, in which case, the new
    buffer will be valid. If `T` can throw, a copy will occur instead. If an exception
    fires, the old buffer has not yet been replaced with the new one. Instead, the
    new buffer is deleted along with all of the elements that were copied.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模拟向量有一个内部缓冲区和一个大小。当创建向量时，我们使用给定的大小分配内部缓冲区。然后我们提供一个`resize()`函数，可以用来调整内部缓冲区的大小。我们首先创建新的内部缓冲区，然后循环遍历每个元素，并将一个缓冲区的元素复制到另一个缓冲区。如果`T`不能抛出异常，在循环执行过程中不会触发任何异常，此时新缓冲区将是有效的。如果`T`可以抛出异常，将会发生复制。如果发生异常，旧缓冲区尚未被新缓冲区替换。相反，新缓冲区将被删除，以及所有被复制的元素。
- en: 'To use this, let''s create a class that can throw in the move constructor/assignment
    operator:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个，让我们创建一个在移动构造函数/赋值运算符中可能抛出异常的类：
- en: '[PRE47]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s also add a class that cannot throw from the move constructor/assignment
    operator:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们还添加一个在移动构造函数/赋值运算符中不能抛出异常的类：
- en: '[PRE48]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, we will create a vector using both of these classes and attempt to
    resize it:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用这两个类创建一个向量，并尝试调整其大小：
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output for the preceding code is as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码的输出如下：
- en: '![](img/e9bee1c2-cc4a-4a6b-8b40-d2f08e9c28b8.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9bee1c2-cc4a-4a6b-8b40-d2f08e9c28b8.png)'
- en: As shown in the preceding example, when we attempt to resize the class, a move
    is performed when a move cannot throw, and a copy is performed otherwise. In other
    words, the behavior of the class changes depending on the traits of the `T` type.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，当我们尝试调整类的大小时，如果移动不能抛出异常，则执行移动操作，否则执行复制操作。换句话说，类的行为取决于`T`类型的特征。
- en: Learning how to implement template<auto>
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习如何实现template<auto>
- en: C++ has had the ability to create templates for a long time, which allows the
    programmer to create generic implementations of classes and functions, given a
    type. You can also, however, provide non-type parameters.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: C++很长时间以来就具有创建模板的能力，这使程序员可以根据类型创建类和函数的通用实现。但是，您也可以提供非类型参数。
- en: In C++17, you can now use `auto` to provide for generic, non-type template arguments.
    In this recipe, we will explore how to use this feature. This is important because
    it allows you to create more generic templates in your code.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17中，您现在可以使用`auto`来提供通用的非类型模板参数。在本示例中，我们将探讨如何使用此功能。这很重要，因为它允许您在代码中创建更通用的模板。
- en: Getting ready
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE50]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有适当的工具来编译和执行本示例中的示例。完成后，打开一个新的终端。我们将使用此终端来下载、编译和运行示例。
- en: How to do it...
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'You need to perform the following steps to try this recipe:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要执行以下步骤来尝试此示例：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端运行以下命令以下载源代码：
- en: '[PRE51]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To compile the source code, run the following:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE52]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译完成后，可以通过运行以下命令来执行本文中的每个示例：
- en: '[PRE53]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍每个示例，并解释每个示例程序的作用以及它与本示例中所教授的课程的关系。
- en: How it works...
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Before C++17, you could provide non-type template arguments in a template,
    but you had to state the variable type in the definition, as shown in this example:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17之前，您可以在模板中提供非类型模板参数，但是您必须在定义中声明变量类型，就像本示例中所示的那样：
- en: '[PRE54]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The output is as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/e5ae3433-362c-4d0d-a865-298472d67d5c.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5ae3433-362c-4d0d-a865-298472d67d5c.png)'
- en: 'In the preceding example, we create a template argument variable of the `int` type and
    output the value of this variable to `stdout`. In C++17, we can now do the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个`int`类型的模板参数变量，并将此变量的值输出到`stdout`。在C++17中，我们现在可以这样做：
- en: '[PRE55]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The output is as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '![](img/dee00755-5e4b-4fe9-8067-fe5306327929.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dee00755-5e4b-4fe9-8067-fe5306327929.png)'
- en: 'As shown in the preceding, instead of having to state `int`, we can now state
    `auto`. This allows us to create a single function that can take more than one
    non-type template parameter. We can also use type traits to establish which non-type
    parameters are allowed, as shown in this example:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，我们现在可以使用`auto`而不是`int`。这使我们能够创建一个可以接受多个非类型模板参数的函数。我们还可以使用类型特征来确定允许使用哪些非类型参数，就像本示例中所示的那样：
- en: '[PRE56]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The output is as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/08ad857b-3e01-41e9-885d-ceea78bc65f1.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08ad857b-3e01-41e9-885d-ceea78bc65f1.png)'
- en: In the preceding example, our template non-type parameter can only be an integer
    type.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们的模板非类型参数只能是整数类型。
- en: Working with explicit template declarations
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用显式模板声明
- en: In this recipe, we will explore how to speed up the compilation of your template
    classes by creating an explicit template declaration. This is important because
    templates require the compiler to create instances of your classes as needed.
    In certain cases, explicit template declaration might provide the programmer with
    a means to speed up compilation by caching the template types that are most likely
    to be used, preventing the need to include the entire definition of a template.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将探讨如何通过创建显式模板声明来加快模板类的编译速度。这很重要，因为模板需要编译器根据需要创建类的实例。在某些情况下，显式模板声明可能为程序员提供一种加快编译速度的方法，通过缓存最有可能使用的模板类型，从而避免包含整个模板定义的需要。
- en: Getting ready
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE57]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有适当的工具来编译和执行本示例中的示例。完成后，打开一个新的终端。我们将使用此终端来下载、编译和运行示例。
- en: How to do it...
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'You need to perform the following steps to try this recipe:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要执行以下步骤来尝试此示例：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端运行以下命令以下载源代码：
- en: '[PRE58]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To compile the source code, run the following:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE59]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译完成后，可以通过运行以下命令来执行本文中的每个示例：
- en: '[PRE60]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些例子，并解释每个例子程序的作用以及它与本教程中所教授的课程的关系。
- en: How it works...
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Each time the compiler sees the use of a template class with a given type,
    it creates a version of that type implicitly. This, however, can happen multiple
    times, reducing the speed of the compiler. If, however, the types that are expected
    to be used are known upfront, this issue can be solved using explicit template
    specialization. Take a look at this example:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 每当编译器看到使用给定类型的模板类时，它会隐式地创建该类型的一个版本。然而，这可能会发生多次，降低编译器的速度。然而，如果预先知道要使用的类型，这个问题可以通过显式模板特化来解决。看看这个例子：
- en: '[PRE61]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Earlier, we created a simple structure that outputs to `stdout` during construction.
    Normally, this class would be created by the compiler once the first specialization
    of the class is seen. We can, however, perform the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们创建了一个简单的结构，在构造过程中输出到`stdout`。通常，一旦看到类的第一个特化，编译器就会创建这个类。然而，我们可以执行以下操作：
- en: '[PRE62]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This is similar to a class prototype, and it explicitly creates the specializations
    that we expect to use. These must be stated before they are used in code (which
    means they are usually stated after the definition of the template); however,
    once they are stated, they can be used as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于一个类原型，它明确地创建了我们期望使用的特化。这些必须在它们在代码中使用之前声明（这意味着它们通常在模板的定义之后声明）；然而，一旦声明了，它们可以如下使用：
- en: '[PRE63]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The output for the code is as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出如下：
- en: '![](img/cdc10992-381a-45a6-80a6-aff500c8753f.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cdc10992-381a-45a6-80a6-aff500c8753f.png)'
- en: 'As shown in the preceding example, we can create instances of our template
    as normal, but, in this case, we can speed up the compiler in scenarios where
    this class is used a lot. This is because, in the source code, we do not need
    to include the implementation of the template. To demonstrate this, let''s look
    at another, more complicated example. In a header file (called `recipe07.h`),
    we will create our template using the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们可以像平常一样创建模板的实例，但是在这种情况下，我们可以加快编译器在大量使用这个类的情况下的速度。这是因为在源代码中，我们不需要包含模板的实现。为了证明这一点，让我们看另一个更复杂的例子。在一个头文件（名为`recipe07.h`）中，我们将使用以下内容创建我们的模板：
- en: '[PRE64]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'As you can see, we have a `template` class with no implementation for the provided
    functions. We will then provide the implementation of this template using the
    following in its own source file:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们有一个没有提供函数实现的`template`类。然后，我们将提供这个模板的实现，使用以下内容在它自己的源文件中：
- en: '[PRE65]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'As you can see in the preceding example, we added an explicit template declaration.
    This ensures that we generate the implementations for the class that we expect.
    The compiler will create the instances for the class that we expect explicitly,
    just like any other source that we would normally write. The difference is, we
    can explicitly define this class for whatever types we want. Finally, we will
    call this code as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的例子中所看到的，我们添加了显式的模板声明。这确保我们生成了我们期望的类的实现。编译器将为我们期望的类显式地创建实例，就像我们通常编写的任何其他源代码一样。不同之处在于，我们可以明确地为任何类型定义这个类。最后，我们将调用这段代码如下：
- en: '[PRE66]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output is as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/b30b50ca-8f48-4791-80c2-83b5886b15f3.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b30b50ca-8f48-4791-80c2-83b5886b15f3.png)'
- en: As you can see, we can call our class the same way we would if the class were
    defined with explicit types instead of a template class using a normal header
    file that is small and doesn't have the full implementation, allowing the compiler
    to speed up.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们可以以与使用显式类型定义的类相同的方式调用我们的类，而不是使用一个小型的头文件，它没有完整的实现，从而使编译器加快速度。
