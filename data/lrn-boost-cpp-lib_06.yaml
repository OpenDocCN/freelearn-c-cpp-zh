- en: Chapter 6. Bimap and Multi-index Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。Bimap和多索引容器
- en: The Standard Library has ordered and unordered associative containers for storing
    objects and looking them up efficiently using some **key**. The key could be a
    text type, numeric type, or first-class objects. For ordered containers such as
    `std::set` and `std::map`, the keys must have a well-defined ordering relation
    that allows any set of keys to be sorted. For unordered containers, it must be
    possible to compute an integer hash value for each key, and additionally, determine
    whether any two keys are equivalent for some definition of equivalence. The key
    represents an index or criterion for lookup, and all the Standard Library associative
    containers support lookup using only a single criterion. In other words, you cannot
    efficiently look up objects using multiple, independent criteria.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库有有序和无序的关联容器，用于存储对象并使用某个**键**高效地查找它们。键可以是文本类型、数字类型或一级对象。对于有序容器，如`std::set`和`std::map`，键必须具有明确定义的排序关系，允许对任何一组键进行排序。对于无序容器，必须能够为每个键计算一个整数哈希值，并且另外确定任何两个键是否相等，以某种等价定义。键表示查找的索引或标准，并且所有标准库关联容器都支持仅使用单个标准进行查找。换句话说，您不能使用多个独立标准高效地查找对象。
- en: 'Let us suppose you have a type called `PersonEntry` to describe a person. The
    `PersonEntry` type has attributes like name, age, phone number, and so on. You
    would end up storing several objects of type `PersonEntry` in containers and at
    different times, you may need to look up `PersonEntry` objects using different
    attributes like name, age, phone number, and so on. While the Standard Library
    containers do an admirable job for a lot of common tasks involving collections,
    they cut a sorry figure when you want a data structure that stores data and searches
    them efficiently based on multiple criteria. Boost provides a small number of
    generic containers geared for this need, two of which we study in this chapter.
    The chapter is divided into the following sections:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个称为`PersonEntry`的类型来描述一个人。`PersonEntry`类型具有名称、年龄、电话号码等属性。您将在容器中存储多个`PersonEntry`类型的对象，并且在不同的时间，您可能需要使用不同的属性（如名称、年龄、电话号码等）查找`PersonEntry`对象。虽然标准库容器在涉及集合的许多常见任务时表现出色，但当您需要一个基于多个标准高效存储数据并搜索数据的数据结构时，它们表现得很糟糕。Boost提供了一小部分通用容器，专门用于这种需求，其中我们在本章中研究了其中的两个。本章分为以下几个部分：
- en: Containers for multi-criteria lookups
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多标准查找的容器
- en: Boost Multi-index containers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost Multi-index容器
- en: Boost Bimap
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost Bimap
- en: Containers for multi-criteria lookups
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多标准查找的容器
- en: 'Consider a collection of objects of type `PersonEntry`, as defined in the following
    code:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个`PersonEntry`类型的对象集合，如下面的代码所定义：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'An object of this type represents an entry in a telephone directory perhaps.
    How would you design a data structure that allows you to look up a person by name?
    We can use a `std::set` of `PersonEntry` objects for it, with an appropriate ordering
    relation defined for `PersonEntry`. Since we want to search by name, we should
    define the ordering relationship by name:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的对象可能代表电话簿中的一个条目。您将如何设计一个数据结构，使您能够按名称查找一个人？我们可以使用`std::set`存储`PersonEntry`对象，为`PersonEntry`定义适当的排序关系。由于我们想按名称搜索，因此应该按名称定义排序关系：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now `std::set` stores only unique elements and any two `PersonEntry` objects
    with the same name would be considered duplicates. Since namesakes are common
    in real life, we should choose a container that allows duplicates, that is, `std::multiset`.
    We can then insert elements and look them up by name using the following code:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`std::set`仅存储唯一元素，任何两个具有相同名称的`PersonEntry`对象都将被视为重复。由于现实生活中常见同名，我们应该选择一个允许重复的容器，即`std::multiset`。然后我们可以使用以下代码插入元素并按名称查找它们：
- en: '**Listing 6.1: Lookups using multimaps**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单6.1：使用多重映射进行查找**'
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We create two `PersonEntry` objects of two people with the same name (lines
    13-15) and insert them into a `multiset` (lines 16-17). The objects are initialized
    using C++11's nifty uniform initializer syntax. We then look up the name `"Arindam
    Mukherjee"`. The correct way to do this in a `multiset` is to determine the range
    of matching elements. The `lower_bound` member function returns the iterator to
    the first matching element (lines 18-19). The `upper_bound` member function returns
    the iterator to the first element to follow the last matching element (lines 20-21).
    If there are no matching elements, both return the iterator to the first element
    that would follow a matching element if there was one. We then iterate over the
    range defined by [low, high) and print all matching elements. If you noticed,
    we constructed temporary `PersonEntry` objects to perform the lookups. Now, it
    is perfectly reasonable to want to do a reverse lookup, given a phone number,
    and find out who it belongs to. How can we do this with the preceding arrangement?
    We could always perform a linear search through the container, or we could use
    a separate container of references to the `PersonEntry` objects in a dictionary
    that stores objects ordered by phone number; neither method is particularly elegant
    or efficient. This is where the Boost Multi-index library steps in.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个具有相同名称的人的`PersonEntry`对象（第13-15行），并将它们插入`multiset`（第16-17行）。使用了C++11的新颖统一初始化语法来初始化对象。然后我们查找名称为`"Arindam
    Mukherjee"`的对象。在`multiset`中正确的方法是确定匹配元素的范围。`lower_bound`成员函数返回指向第一个匹配元素的迭代器（第18-19行）。`upper_bound`成员函数返回指向紧随最后一个匹配元素的第一个元素的迭代器（第20-21行）。如果没有匹配的元素，两者都返回指向第一个元素的迭代器，如果有匹配的元素，则返回指向匹配元素后面的第一个元素的迭代器。然后我们遍历[low,
    high)定义的范围，并打印所有匹配的元素。如果您注意到，我们构造了临时的`PersonEntry`对象来执行查找。现在，如果想要进行反向查找，即根据电话号码查找并找出它属于谁，这是完全合理的。在前面的安排中，我们该如何做呢？我们可以始终通过容器执行线性搜索，或者我们可以使用一个按电话号码排序的对象的字典中的`PersonEntry`对象的引用的单独容器；这两种方法都不是特别优雅或高效。这就是Boost
    Multi-index库的用武之地。
- en: Boost Multi-index containers
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Boost Multi-index容器
- en: 'The Boost Multi-index library actually provides a single generic container
    called `multi_index_container` to store your objects and options to specify one
    or more indexes, using which you may look up the objects. Each index will use
    a different criterion on potentially different fields of the object. The indexes
    are defined and specified as template parameters to the container and this does
    make the container declaration a little daunting. But, this ultimately makes the
    container implementation tighter with a lot of compile-time optimizations. Indeed,
    the hardest part of using these containers is really getting their declaration
    right; so let us deconstruct a declaration of such a container of `PersonEntry`
    objects:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Multi-index库实际上提供了一个称为`multi_index_container`的单个通用容器，用于存储对象和指定一个或多个索引的选项，通过这些索引可以查找对象。每个索引将在对象的潜在不同字段上使用不同的标准。索引被定义并指定为容器的模板参数，这确实使容器的声明有些令人生畏。但是，这最终使容器的实现更加紧凑，具有大量的编译时优化。事实上，使用这些容器最困难的部分实际上是确保它们的声明正确；因此让我们解构一下`PersonEntry`对象的这种容器的声明：
- en: '**Listing 6.2: Defining multi-index containers**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表6.2：定义多索引容器**'
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding snippet, we create a typedef for a `multi_index_container`
    of the `PersonEntry` objects (lines 9-10). We use a single index called `person_index`
    that we defined earlier (line 8). The `person_index` is the type of index that
    will be used for looking up objects in the container. It is defined as `ordered_non_unique<identity<PersonEntry>>`.
    This means that the index keeps the `PersonEntry` objects ordered by their defined
    ordering relationship and allows for duplicates (non-unique). This index provides
    the same semantics as `std::multiset<PersonEntry>`. Now, if we want to look up
    `PersonEntry` objects by telephone number, we would need to define additional
    indexes:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们创建了`PersonEntry`对象的`multi_index_container`的typedef（第9-10行）。我们使用了之前定义的名为`person_index`的单个索引（第8行）。`person_index`是用于在容器中查找对象的索引类型。它被定义为`ordered_non_unique<identity<PersonEntry>>`。这意味着索引通过它们定义的排序关系保持`PersonEntry`对象的顺序，并允许重复（非唯一）。这个索引提供了与`std::multiset<PersonEntry>`相同的语义。现在，如果我们想要按电话号码查找`PersonEntry`对象，我们需要定义额外的索引：
- en: '**Listing 6.3: Defining multi-index containers**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表6.3：定义多索引容器**'
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here we define two index types: an index type `by_name` for looking up objects
    by the name field and a second index type `phone_index` for looking up by phone
    numbers (lines 9-12). We use the `member` template to indicate that we want an
    index based on a data member of `PersonEntry` called `name` or `phoneNumber` of
    type `std::string`.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了两种索引类型：一个名为`by_name`的索引类型，用于按名称字段查找对象，以及一个名为`phone_index`的第二索引类型，用于按电话号码查找（第9-12行）。我们使用`member`模板来指示我们希望基于`PersonEntry`的数据成员`name`或`phoneNumber`（类型为`std::string`）创建索引。
- en: 'We pass a specialization of the `indexed_by` template to the `multi_index_container`
    template as an argument. All the indexes that we want to enable are listed as
    arguments of this specialization (lines 15-16). Let us now see these types in
    action. We assume that all the header files from the listing 6.3 are included
    and all the types defined in listing 6.3 are available in the following listing:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`indexed_by`模板的一个特化作为参数传递给`multi_index_container`模板。我们想要启用的所有索引都作为这个特化的参数列出（第15-16行）。现在让我们看看这些类型是如何工作的。我们假设列表6.3中的所有头文件都已包含，并且列表6.3中定义的所有类型都在以下列表中可用：
- en: '**Listing 6.4: Using Boost Multi-index containers**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表6.4：使用Boost Multi-index容器**'
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, we create a multi-index container of `PersonEntry` objects
    indexed by `name` and `phoneNumber` fields, as defined in listing 6.3\. We insert
    three `PersonEntry` objects (lines 8-10). We then perform a lookup by name on
    the container (lines 12-13). The container's behavior defaults to that of the
    first index, which is `by_name` (listing 6.3, lines 9-10). Thus, the call to the
    `find` method uses the first index (`by_name`) for the lookup. To look up by phone
    numbers, we need to get a reference to the second index. To do this, we use the
    `get` member template of `multi_index_container`, passing it `1`, which is the
    zero-based position of the `by_phone` index (line 15). We can then call methods
    on the returned index reference just like on `std::set` (lines 16-18). We can
    even iterate through the index using a range-based for-loop construct (line 21)
    or using actual iterators.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个`PersonEntry`对象的多索引容器，按照列表6.3中定义的`name`和`phoneNumber`字段进行索引。我们插入了三个`PersonEntry`对象（第8-10行）。然后我们在容器中按名称进行查找（第12-13行）。容器的行为默认为第一个索引`by_name`（列表6.3，第9-10行）。因此，调用`find`方法使用第一个索引（`by_name`）进行查找。要按电话号码查找，我们需要获取对第二个索引的引用。为此，我们使用`multi_index_container`的`get`成员模板，传递`1`，这是`by_phone`索引的从零开始的位置（第15行）。然后我们可以像在`std::set`上一样在返回的索引引用上调用方法（第16-18行）。我们甚至可以使用基于范围的for循环结构（第21行）或使用实际迭代器来遍历索引。
- en: In the preceding example both indexes are ordered, which requires that whichever
    element they are based on (`name` or `phoneNumber` fields) should define an ordering
    relationship. In this case, both fields are of type `std::string`, so the ordering
    relationship is well-defined. But if it is not available, we need to roll our
    own definition of ordering as an overloaded `operator<`. Alternatively, we can
    define a functor to perform the ordering comparisons between two elements of the
    type in question and pass its type as a trailing argument to the `member` template.
    The online documentation for Boost Multi-index has more details.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，两个索引都是有序的，这要求它们基于的元素（`name`或`phoneNumber`字段）应该定义一个排序关系。在这种情况下，这两个字段都是`std::string`类型，因此排序关系是明确定义的。但是如果没有可用的排序关系，我们需要自己定义一个重载的`operator<`来进行排序。或者，我们可以定义一个函数对象来执行类型的两个元素之间的排序比较，并将其类型作为`member`模板的尾随参数传递。Boost
    Multi-index的在线文档有更多详细信息。
- en: 'If specifying numeric positions for index types seems less than ideal, you
    can use tags instead. This changes the declaration of the `by_phone` index a wee
    bit but makes for more readable code where it matters. Here is how to do it for
    the `phone_index`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为索引类型指定数字位置似乎不太理想，可以改用标签。这会稍微改变`by_phone`索引的声明，但可以使代码更易读。以下是如何为`phone_index`做到这一点：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding snippet, we define an empty struct called `phone_tag` just
    to act as a tag for a particular index (line 1). We then define the index type
    `by_phone`, as specialization of the `ordered_unique` template. The first parameter
    of the `ordered_unique` template specifies the tag to use for retrieving this
    index (`phone_tag`). The second template parameter to `ordered_unique` is `member<PersonEntry,
    std::string, &PersonEntry::phoneNumber>`; it specifies that the `phoneNumber`
    member of each `PersonEntry` object is to be used as the key for this index, and
    that it is of type `std::string` (lines 2-3). Finally, we access the index by
    calling the `get` member template of `phonedir`, but pass it the tag `phone_tag`
    rather than a numeric index (line 5).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的片段中，我们定义了一个名为`phone_tag`的空结构，只是作为特定索引的标签（第1行）。然后我们定义了索引类型`by_phone`，作为`ordered_unique`模板的特化。`ordered_unique`模板的第一个参数指定用于检索此索引的标签（`phone_tag`）。`ordered_unique`的第二个模板参数是`member<PersonEntry,
    std::string, &PersonEntry::phoneNumber>`；它指定每个`PersonEntry`对象的`phoneNumber`成员将用作此索引的键，并且它的类型是`std::string`（第2-3行）。最后，我们通过调用`phonedir`的`get`成员模板来访问索引，但是传递的是标签`phone_tag`而不是数字索引（第5行）。
- en: Index types
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引类型
- en: The `ordered_unique` and `ordered_non_unique` indexes correspond to the semantics
    of `std::set` and `std::multiset` respectively. Using these indexes, you not only
    get logarithmic lookup and insertions, but can also perform an ordered traversal
    of the container's elements. If you do not care about ordered traversal, you can
    also use `hashed_unique` and `hashed_non_unique` indexes, which provide excellent
    insertion and lookup performance (constant expected time). Naturally, the hashed
    indexes do not require any ordering relationship to be defined on the elements
    but require a way to generate their hash values. This can be enabled using the
    techniques shown for unordered containers in listing 5.11.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`ordered_unique`和`ordered_non_unique`索引分别对应于`std::set`和`std::multiset`的语义。使用这些索引，不仅可以获得对数级别的查找和插入，还可以执行容器元素的有序遍历。如果您不关心有序遍历，还可以使用`hashed_unique`和`hashed_non_unique`索引，它们提供了出色的插入和查找性能（常数预期时间）。当然，散列索引不需要在元素上定义任何排序关系，但需要一种方法来生成它们的哈希值。这可以使用列表5.11中显示的无序容器的技术来实现。'
- en: 'Sometimes, it is important to get objects in the order of insertion and also
    perform lookups based on different criteria. To get objects in the order in which
    they were inserted, we need to use the `sequenced` index. Sequenced indexes do
    not take any arguments other than an optional tag. We can add the `sequenced<>`
    index to the `directory_t` type we defined in listing 6.3, as shown in the following
    code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，按插入顺序获取对象并根据不同标准执行查找是很重要的。要按插入顺序获取对象，我们需要使用`sequenced`索引。`sequenced`索引除了可选标签外不接受任何参数。我们可以将`sequenced<>`索引添加到我们在6.3清单中定义的`directory_t`类型中，如下所示：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We could have passed a tag as a template argument to `sequenced` if we wanted
    to. If we also want a random access iterator to this sequence in insertion order,
    we may use the `random_access<>` index instead:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要，我们可以将标签作为模板参数传递给`sequenced`。如果我们还想要按插入顺序获得此序列的随机访问迭代器，可以改用`random_access<>`索引：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now let us suppose that you look up a `PersonEntry` by name using the `by_name`
    index and want to find out the position of the element in insertion order. Iterators
    are associated with an index and the iterator we have is associated with the `by_phone`
    index. Now you want an iterator to the same element on the `random_access` index
    as well. You can then compute the difference between that iterator and the beginning
    iterator of the `random_access` index to compute the ordinal position of the element.
    The general way to do this is to use the `project` member template of the `multi_index_container`,
    as shown in the following example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设您使用`by_name`索引按名称查找`PersonEntry`，并希望找出元素在插入顺序中的位置。迭代器与索引相关联，我们的迭代器与`by_phone`索引相关联。现在您还希望获得与`random_access`索引相同的元素的迭代器。然后，您可以计算该迭代器与`random_access`索引的起始迭代器之间的差异，以计算元素的序数位置。这样做的一般方法是使用`multi_index_container`的`project`成员模板，如下例所示：
- en: '**Listing 6.5: Using iterator projections**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单6.5：使用迭代器投影**'
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We look up an element by name using the find member, which returns an iterator
    `it` to the element (line 21). We then get a reference to the random access index
    at index 2, using the `get` member template (line 22). Using the `project` member
    template of `phonedir`, we get the iterator corresponding to `it` in the `random_access`
    index (line 24). The returned iterator `rit` being a random access iterator, we
    compute the zero-based position of the element as the difference between `rit`
    and the begin iterator on `random_index`. If we had used a `sequenced<>` index
    in place of `random_access<>` (line 5), we would not be able to compute the position
    by computing the difference of the two iterators (line 26). Instead, we would
    need to use the `std::distance` Standard Library function to compute the offset
    between the beginning of the sequenced container and the looked up iterator. This
    would be of linear time complexity rather than constant.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`find`成员按名称查找元素，返回一个指向元素的迭代器`it`（第21行）。然后，我们使用`get`成员模板在索引2处获取与随机访问索引相关联的引用（第22行）。使用`phonedir`的`project`成员模板，我们在`random_access`索引中获取与`it`对应的迭代器（第24行）。返回的迭代器`rit`是一个随机访问迭代器，我们可以计算元素的从零开始的位置，即`rit`与`random_index`的起始迭代器之间的差异。如果我们在这里使用`sequenced<>`索引而不是`random_access<>`索引（第5行），我们将无法通过计算两个迭代器的差异来计算位置（第26行）。相反，我们需要使用`std::distance`标准库函数来计算有序容器的开始和查找迭代器之间的偏移量。这将具有线性时间复杂度而不是常数时间。
- en: Range lookups using lambda
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用lambda进行范围查找
- en: 'Sometimes we want to find elements whose attributes fall in a certain range
    of values. Instead of using the `lower_bound` and `upper_bound` members of the
    `multi_index_container` and its indexes, we can perform range lookups using a
    more expressive syntax that uses Boost Lambda. Lambda expressions are discussed
    later in this book (see [Chapter 7](ch07.html "Chapter 7. Higher Order and Compile-time
    Programming"), *Higher Order and Compile-time Programming*), but you really do
    not need to understand any of it to follow the example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望找到属性值在某个范围内的元素。我们可以使用更具表现力的语法，使用Boost Lambda进行范围查找，而不是使用`multi_index_container`及其索引的`lower_bound`和`upper_bound`成员。Lambda表达式将在本书的后面进行讨论（参见[第7章](ch07.html
    "第7章。高阶和编译时编程")，“高阶和编译时编程”），但实际上您不需要理解其中的任何内容就可以遵循本示例。
- en: '**Listing 6.6: Expressive range lookup**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表6.6：表达范围查找**'
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Using the `multi_index_container` type called `directory_t` defined in listing
    6.3, which uses the indexes `by_name` and `by_phone`, we define a multi-index
    container of `PersonEntry` objects called `phonedir` (line 8) and insert four
    entries into it (lines 10-17). We then look for all entries with names lexically
    greater or equal to `"Ar"` and lexically less than `"D"`. To do this, we first
    get the appropriate index, the `by_name` index, which is the zeroth index or default
    index. We then call the `range` member function on this index, passing it the
    two criteria for determining the ends of the range using a lambda placeholder
    `_1` (`boost::lambda::_1`). Semantically, `std::string("Ar") <= _1` says we are
    looking for strings, which are lexically not smaller than `"Ar"`, and `std::string("D")
    > _1` says we are looking for strings that are lexically smaller than `"D"`. These
    two criteria together determine which elements fall in the range and which ones
    fall outside. Turns out, my two namesakes are in the range while their more famous
    friends are out. This program prints:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表6.3中定义的`directory_t`类型的`multi_index_container`，该容器使用`by_name`和`by_phone`索引，我们定义了一个名为`phonedir`的`PersonEntry`对象的多索引容器（第8行），并将四个条目插入其中（第10-17行）。然后，我们查找所有名称词法大于或等于`"Ar"`且词法小于`"D"`的条目。为此，我们首先获取适当的索引，即`by_name`索引，它是第零个索引或默认索引。然后我们在该索引上调用`range`成员函数，通过lambda占位符`_1`（`boost::lambda::_1`）传递两个确定范围结束的条件。语义上，`std::string("Ar")
    <= _1`表示我们正在寻找词法上不小于`"Ar"`的字符串，`std::string("D") > _1`表示我们正在寻找词法上小于`"D"`的字符串。这两个条件一起确定了哪些元素属于范围内，哪些元素属于范围外。结果是，我的两个同名人在范围内，而他们更有名的朋友不在范围内。该程序打印：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Insertions and updates
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入和更新
- en: You can add new elements into the `multi_index_container` and erase them using
    the container interface or any of its indexes. How you add and erase elements
    via the index interfaces depends on the type of the index. How you add and erase
    them via the container's public interface is defined by the type of the first
    index of the container.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以向`multi_index_container`中添加新元素，并使用容器接口或任何其索引来擦除它们。通过索引接口添加和擦除元素的方式取决于索引的类型。通过容器的公共接口添加和擦除元素的方式由容器的第一个索引的类型定义。
- en: We already used the `insert` member function in previous examples to add a single
    element to `multi_index_containers`. We used the overload of `insert` that takes
    a single object and adds it to the container at the appropriate location. We may
    also use this method on an individual index of type `ordered_unique`, `ordered_non_unique`,
    `hashed_unique`, or `hashed_non_unique`. But on the `random_access` or `sequenced`
    indexes, and on containers that use such an index as their first index, a single
    argument overload of `insert` is not available. You may use `push_back` or `push_front`
    to add elements to the ends. You may also use an overload of `insert` that takes
    the iterator to the position to insert at as an additional argument. Likewise
    for `erase`, with `sequenced<>` and `random_access<>` indexes, you can only use
    overloads that specify the element to erase with an iterator; while with ordered
    and hashed indexes, you can actually use an overload that takes a value to look
    up and erases all matching elements.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们已经使用`insert`成员函数向`multi_index_containers`中添加单个元素。我们使用了接受单个对象并将其添加到容器中适当位置的`insert`重载。我们还可以在类型为`ordered_unique`、`ordered_non_unique`、`hashed_unique`或`hashed_non_unique`的单个索引上使用此方法。但是在`random_access`或`sequenced`索引上，以及在使用此类索引作为其第一个索引的容器上，`insert`的单个参数重载不可用。您可以使用`push_back`或`push_front`将元素添加到末尾。您还可以使用接受要插入位置的迭代器作为额外参数的`insert`重载。同样对于`erase`，对于`sequenced<>`和`random_access<>`索引，您只能使用指定要擦除的元素的迭代器的重载；而对于有序和散列索引，您实际上可以使用接受要查找并擦除所有匹配元素的值的重载。
- en: 'You can also update values in a multi-index container using either the `replace`
    or the `modify` method. The following snippet illustrates these concepts:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`replace`或`modify`方法在多索引容器中更新值。以下代码片段说明了这些概念：
- en: '**Listing 6.7: Inserts, erases and updates on multi-index containers**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表6.7：在多索引容器上插入、擦除和更新**'
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this example, we create a multi-index container of `PersonEntry` objects
    with three indexes: the default `random_access` index, an ordered non-unique index
    on the `name` field, and an ordered unique index on the `phoneNumber` field. We
    first use the public interface of the container to add a `PersonEntry` record
    using the `push_back` method (lines 19-20). We then access a reference to the
    phone index (line 21) and name index (line 24). We add a second record using the
    single argument `insert` overload on the phone index (line 22), and a third record
    using the same overload on the name index (lines 25-26). Next, we use the `push_front`
    method on the container to add a fourth record (lines 27-28), which puts this
    record at the front or beginning of the `random_access` index.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个`PersonEntry`对象的多索引容器，有三个索引：默认的`random_access`索引，`name`字段上的有序非唯一索引，以及`phoneNumber`字段上的有序唯一索引。我们首先使用容器的公共接口使用`push_back`方法添加了一个`PersonEntry`记录（第19-20行）。然后我们访问了电话索引（第21行）和名称索引（第24行）的引用。我们使用电话索引上的单参数`insert`重载添加了第二条记录（第22行），并使用名称索引上的相同重载添加了第三条记录（第25-26行）。接下来，我们使用容器的`push_front`方法添加了第四条记录（第27-28行），这将这条记录放在`random_access`索引的前面或开头。
- en: 'We then call the single argument `erase` overload on the name index passing
    it the string to match against the `name` field (line 30). This erases the two
    matching records (inserted on lines 22-23 and 25-26). We then erase the record
    at the beginning of the container (line 31), which deletes the `"Ace Ventura"`
    record. The sole remaining record (line 32) is printed to the console (line 33)
    and this should print:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用了单参数`erase`重载，传递了与`name`字段匹配的字符串给名称索引（第30行）。这将擦除两条匹配的记录（第22-23行和25-26行插入）。然后我们擦除了容器开头的记录（第31行），删除了`"Ace
    Ventura"`的记录。剩下的唯一记录（第32行）被打印到控制台（第33行），应该打印出：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next we use `push_back` to add another record for a person called `Tarzan` (line
    35-36). Interestingly, Mr. Tarzan has the same phone number as Dr. Dolittle. But
    because there is a unique index on the `phoneNumber` field, this insertion does
    not succeed and the container still retains the record of Dr. Dolittle (lines
    37, 38). We fix this by adding a new record for Tarzan with a unique phone number
    (lines 40-41), which succeeds (line 42).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`push_back`为名为`Tarzan`的人添加另一条记录（第35-36行）。有趣的是，Tarzan先生的电话号码与Dolittle博士相同。但是因为`phoneNumber`字段上有唯一索引，这次插入不会成功，容器仍然保留了Dolittle博士的记录（第37,
    38行）。我们通过为Tarzan添加一个具有唯一电话号码的新记录来解决这个问题（第40-41行），这次成功了（第42行）。
- en: Next, we access the record for Tarzan, which would be the second record in insertion
    order, and create a copy of that object (line 44). We then change the `phoneNumber`
    field of the `tarzan` object to the same number as Dr. Dolittle's. We try to replace
    the object for Tarzan in the container with this modified object using the `replace`
    member function, but because the replacement violates the uniqueness constraint
    on the phone number, the `replace` method fails to update the record returning
    a Boolean false. We can also use the more efficient `modify` method instead of
    `replace`. We will not cover `modify` in this book; the online documentation is
    a good place to look for reference.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们访问了Tarzan的记录，这将是插入顺序中的第二条记录，并创建了该对象的副本（第44行）。然后我们将`tarzan`对象的`phoneNumber`字段更改为与Dolittle博士相同的号码。我们尝试使用`replace`成员函数用修改后的对象替换容器中的Tarzan对象，但由于替换违反了电话号码的唯一性约束，`replace`方法无法更新记录，返回一个布尔值false。我们也可以使用更高效的`modify`方法来代替`replace`。我们不会在本书中涵盖`modify`；在线文档是寻找参考的好地方。
- en: Each insertion updates all indexes and like the associative containers and `std::list`
    from the Standard Library, they do not invalidate any existing iterators, not
    even those generated from other indexes. Erase operations invalidate only iterators
    to the erased elements.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 每次插入都会更新所有索引，就像标准库中的关联容器和`std::list`一样，它们不会使任何现有的迭代器失效，甚至不会使其他索引生成的迭代器失效。擦除操作只会使被擦除的元素的迭代器失效。
- en: Boost Bimap
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Boost Bimap
- en: Storing objects and looking them up using a key is a very common programming
    chore, and every language has some measure of support for it through native constructs
    or libraries in the form of dictionaries or lookup tables. In C++, the `std::map`
    and `std::multimap` containers (and their unordered variants) provide the lookup
    table abstraction. Traditionally, such libraries support lookups in one direction.
    Given a key you can look up a value and this is adequate for many cases. But sometimes,
    we also need a way to look up a key given a value, and the standard library associative
    containers are of little help in such cases; what we need there is the Boost Bimap
    library.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 存储对象并使用键查找它们是一项非常常见的编程任务，每种语言都通过本机构造或库（如字典或查找表）提供了一定程度的支持。在C++中，`std::map`和`std::multimap`容器（以及它们的无序变体）提供了查找表抽象。传统上，这些库只支持单向查找。给定一个键，你可以查找一个值，这对许多情况来说是足够的。但有时，我们也需要一种通过值查找键的方法，标准库的关联容器在这种情况下帮助不大；我们需要的是Boost
    Bimap库。
- en: 'The Boost Bimap library provides bimaps or bidirectional map data structures
    that allow lookups using keys as well as values. Let us start with an example
    to get a feel of how it works. We will use a Boost bimap to store names of countries
    and territories, with their capitals:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Bimap库提供了双向映射数据结构，允许使用键和值进行查找。让我们从一个例子开始，以了解它是如何工作的。我们将使用Boost bimap来存储国家和地区的名称以及它们的首都：
- en: '**Listing 6.8: Using a bimap**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单6.8：使用bimap**'
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The type `bimap<string, string>` that will hold names of the countries and map
    them to the capitals is named `string_bimap_t` (line 8). We define a bimap of
    this type called `countryCapitals` (line 12), and add the names of five countries
    and their capitals using the `insert` adaptor from Boost Assign (lines 14-18).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 类型`bimap<string, string>`将保存国家的名称并将其映射到首都，命名为`string_bimap_t`（第8行）。我们定义了一个这种类型的bimap，称为`countryCapitals`（第12行），并使用Boost
    Assign的`insert`适配器（第14-18行）添加了五个国家及其首都的名称。
- en: 'A bimap defines a relation or mapping between values in two containers: a *left
    container* consisting of country names and a *right container* consisting of names
    of capital cities. We can get a *left view* of the bimap that maps the keys (country
    names) to values (capitals) and a *right view* that maps the values (capitals)
    to the keys (country names). These represent two alternative views of the bimap.
    We can access these two alternate views using the members `left` and `right` of
    the bimap (lines 20, 28). These two views have a very similar public interface
    as `std::map` or, to borrow a succinct description from the online documentation,
    they are *signature-compatible* with `std::map`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Bimap定义了两个容器中值之间的关系或映射：一个*左容器*包含国家名称，一个*右容器*包含首都名称。我们可以得到bimap的*左视图*，将键（国家名称）映射到值（首都），以及*右视图*，将值（首都）映射到键（国家名称）。这代表了bimap的两种替代视图。我们可以使用bimap的成员`left`和`right`（第20、28行）来访问这两个替代视图。这两个视图具有与`std::map`非常相似的公共接口，或者借用在线文档中的简洁描述，它们与`std::map`*具有相同的签名*。
- en: So far, there is a one-to-one mapping between the set of countries and the set
    of capitals. We now try to insert an entry for Chile's second capital, Valparaiso
    (lines 37-38). It fails (lines 39-40) because, just like `std::map` and unlike
    `std::multimap`, the keys must be unique.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，国家集合和首都集合之间存在一对一的映射。现在我们尝试为智利的第二个首都Valparaiso插入一个条目（第37-38行）。它失败了（第39-40行），因为与`std::map`一样，但与`std::multimap`不同，键必须是唯一的。
- en: Now consider what happens if we try to insert a new entry into the bimap (lines
    42-43) for a new country `Norfolk Island` (a territory under Australia), whose
    capital `Kingston` shares its name with that of another country on the map (`Jamaica`).
    Unlike what would have happened in a `std::map`, the insertion fails and there
    is no change in the number of entries in the bimap (lines 44-45). In this case,
    the values too must be unique, which is not a constraint for `std::map`. But what
    if we actually want to represent a one-to-many or many-to-many kind of a relation
    using Boost Bimap? We will see the options we have in the next section.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一下，如果我们尝试向bimap（第42-43行）插入一个新的条目，用于一个新的国家`Norfolk Island`（澳大利亚的一个领土），其首都`Kingston`与地图上的另一个国家（`牙买加`）的名字相同会发生什么。与`std::map`中将会发生的情况不同，插入失败，bimap中的条目数量没有变化（第44-45行）。在这种情况下，值也必须是唯一的，这对于`std::map`来说不是一个约束。但是，如果我们真的想要使用Boost
    Bimap来表示一对多或多对多的关系，我们将在下一节中看到我们有哪些选项。
- en: Collection types
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合类型
- en: 'The default behavior of Boost Bimap is one-to-one mapping, that is, unique
    keys and unique values. But, we can support one-to-many and many-to-many mappings
    by varying a couple of template parameters. To illustrate such use with an example,
    we use a map of given names to nicknames (listing 6.9). A given name can sometimes
    be associated with multiple nicknames and a nickname too can occasionally apply
    to multiple given names. So we would like to model a many-to-many relationship.
    To define a bimap that allows many-to-many relations, we have to choose a collection
    type for the left and right containers different from the default (which has set
    semantics). Since both names and nicknames can be non-unique, both the left and
    right containers should have the semantics of multisets instead. Boost Bimap provides
    collection type specifiers (refer to the following table), which can be used as
    template arguments to the `boost::bimap` template. Depending on the collection
    type, the semantics of the left or right view of the bimap also change. Here is
    a short table summarizing the available collection types, their semantics, and
    the corresponding views (based on the online documentation at [www.boost.org](http://www.boost.org)):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Bimap的默认行为是一对一映射，即唯一键和唯一值。但是，我们可以通过改变一些模板参数来支持一对多和多对多映射。为了用一个例子说明这样的用法，我们使用一个给定名称到昵称的映射（清单6.9）。一个给定名称有时可能与多个昵称相关联，一个昵称也偶尔可以适用于多个给定名称。因此，我们希望建模一个多对多关系。为了定义一个允许多对多关系的bimap，我们必须选择左右容器的集合类型与默认值（具有集合语义）不同。由于名称和昵称都可以是非唯一的，因此左右容器都应该具有多重集的语义。Boost
    Bimap提供了集合类型说明符（参考下表），可以用作`boost::bimap`模板的模板参数。根据集合类型，bimap的左视图或右视图的语义也会发生变化。以下是一个简短的表格，总结了可用的集合类型、它们的语义以及相应的视图（基于[www.boost.org](http://www.boost.org)上的在线文档）：
- en: '| Collection type | Semantics | View type |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 集合类型 | 语义 | 视图类型 |'
- en: '| --- | --- | --- |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `set_of` | Ordered, unique. | map |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `set_of` | 有序，唯一。 | map |'
- en: '| `multiset_of` | Ordered, non-unique. | multimap |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `multiset_of` | 有序，非唯一。 | multimap |'
- en: '| `unordered_set_of` | Hashed, unique. | unordered_map |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `unordered_set_of` | 哈希，唯一。 | unordered_map |'
- en: '| `unordered_multiset_of` | Hashed, non-unique. | unordered_multimap |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `unordered_multiset_of` | 哈希，非唯一。 | unordered_multimap |'
- en: '| `unconstrained_set_of` | Unconstrained. | No view available |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `unconstrained_set_of` | 无约束。 | 没有可用的视图 |'
- en: '| `list_of` | Non-ordered, non-unique. | Linked list of key-value pairs |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `list_of` | 无序，非唯一。 | 键值对的链表 |'
- en: '| `vector_of` | Non-ordered, non-unique, random access sequence. | Vector of
    key-value pairs |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `vector_of` | 无序，非唯一，随机访问序列。 | 键值对的向量 |'
- en: 'Note that the collection types are defined in the `boost::bimaps` namespace
    and each collection type comes in its own header, which must be included separately.
    The following example shows you how to use collection types in conjunction with
    the `boost::bimap` template to define many-to-many relations:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，集合类型是在`boost::bimaps`命名空间中定义的，每种集合类型都有自己的头文件，必须单独包含。以下示例向您展示了如何使用集合类型与`boost::bimap`模板结合使用来定义多对多关系：
- en: '**Listing 6.9: Bimaps for many-to-many relations**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单6.9：多对多关系的Bimaps**'
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The specific bimap container type we need to use is `bimap<multiset_of<string>`,
    `multiset_of<string>>` (lines 10-11). Using `bimap<string, string>` would have
    given us a one-to-one mapping. If we wanted a one-to-many relation, we could have
    used `bimap<set_of<string>`, `multiset_of<string>>`, or simply `bimap<string,
    multiset_of<string>>` since `set_of` is the default collection type used when
    we do not specify one. Note that in the code, we use `boostbi` as an alias for
    the `boost::bimaps` namespace (line 8).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用的特定双射图容器类型是`bimap<multiset_of<string>`, `multiset_of<string>>`（第10-11行）。使用`bimap<string,
    string>`将给我们一个一对一的映射。如果我们想要一对多的关系，我们可以使用`bimap<set_of<string>`, `multiset_of<string>>`，或者简单地使用`bimap<string,
    multiset_of<string>>`，因为当我们不指定时，`set_of`是默认的集合类型。请注意，在代码中，我们使用`boostbi`作为`boost::bimaps`命名空间的别名（第8行）。
- en: We define the `namesShortNames` bimap to hold the name and nickname entries
    (line 15).We add some entries, including a duplicate name `Robert` and a duplicate
    nickname `Ted` (lines 17-22). Using the `insert` member function of bimap, add
    one more duplicate name `William` (lines 25-26) and one more duplicate nickname
    `Chris` (lines 29-30); both insertions succeed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义`namesShortNames`双射图来保存名称和昵称条目（第15行）。我们添加了一些条目，包括重复的名称`Robert`和重复的昵称`Ted`（第17-22行）。使用双射图的`insert`成员函数，添加了一个重复的名称`William`（第25-26行）和一个重复的昵称`Chris`（第29-30行）；两个插入操作都成功了。
- en: We access the left view with names as keys and the right view with nicknames
    as keys, using the `left` and `right` members of bimap (lines 33, 45). Both the
    left and right views are signature compatible with `std::multimap`, and we perform
    lookups on them just as we would on `std::multimaps`. Thus, given a name, to find
    the first matching entry for it, we use the `lower_bound` member function (line
    35). To find the first entry lexically greater than the name, we use the `upper_bound`
    member function (line 37).We can iterate over the range of matching entries using
    the iterators returned by these two functions (line 39). In general, `lower_bound`
    returns the first element with name lexically equal or greater than the passed
    key; so if there are no matching elements, `lower_bound` and `upper_bound` return
    the same iterator. We can also use the `equal_range` function, which returns both
    the lower bound and upper bound iterators as an iterator pair (line 47).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`bimap`的`left`和`right`成员来访问左视图和右视图，左视图以名称作为键，右视图以昵称作为键（第33行，45行）。左视图和右视图都与`std::multimap`兼容，并且我们可以像在`std::multimaps`上一样在它们上执行查找。因此，给定一个名称，要找到与其匹配的第一个条目，我们使用`lower_bound`成员函数（第35行）。要找到字典顺序大于名称的第一个条目，我们使用`upper_bound`成员函数（第37行）。我们可以使用这两个函数返回的迭代器迭代匹配条目的范围（第39行）。通常，`lower_bound`返回与传递的键词字典顺序相等或大于的第一个元素；因此，如果没有匹配的元素，`lower_bound`和`upper_bound`返回相同的迭代器。我们还可以使用`equal_range`函数，它将下界和上界迭代器作为迭代器对返回（第47行）。
- en: If we did not care about ordered traversal of the maps, we could have used `unordered_set_of`
    or `unordered_multiset_of` collection types. Like with all unordered containers,
    the notion of equality of elements and a mechanism to compute the hash values
    of the elements must be available.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不关心地图的有序遍历，我们可以使用`unordered_set_of`或`unordered_multiset_of`集合类型。与所有无序容器一样，元素的相等性概念和计算元素的哈希值的机制必须可用。
- en: A container such as `std::map<T, U>`, has the same semantics as `bimap<T, unconstrained_set_of<U>>`.
    The `unconstrained_set_of` collection type does not provide a way to iterate through
    elements in it or look them up, and does not require the elements to be unique.
    While `bimap<T, multiset_of<U>>` allows non-unique values, it also supports looking
    up by values, something that `std::map` does not.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 像`std::map<T, U>`这样的容器具有与`bimap<T, unconstrained_set_of<U>>`相同的语义。`unconstrained_set_of`集合类型不提供迭代或查找元素的方法，并且不要求元素是唯一的。而`bimap<T,
    multiset_of<U>>`允许非唯一值，它还支持按值查找，这是`std::map`不支持的。
- en: The `list_of` and `vector_of` collection types, like the `unconstrained_set_of`
    collection type, do not enforce either uniqueness or any structure that allows
    look up. However, they can be iterated through element by element, unlike `unconstrained_set_of`
    and thus, you can use a Standard Library algorithm like `std::find` to perform
    linear searches. `vector_of` provides random access. One can sort the entities
    it contains using its `sort` member function following which one could perform
    binary searches using `std::binary_search`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`list_of`和`vector_of`集合类型，像`unconstrained_set_of`集合类型一样，既不强制唯一性，也不强制任何允许查找的结构。但是，它们可以逐个元素地进行迭代，与`unconstrained_set_of`不同，因此，您可以使用标准库算法如`std::find`执行线性搜索。`vector_of`提供了随机访问。可以使用其`sort`成员函数对其包含的实体进行排序，随后可以使用`std::binary_search`执行二分搜索。'
- en: More ways to use bimaps
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多使用双射图的方法
- en: There are several ways to make the use of bimaps more expressive. In this section,
    we explore a few of these.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以使双射图的使用更加表达。在本节中，我们将探讨其中的一些。
- en: Tagged access
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标记访问
- en: 'Instead of using `left` and `right` to access each of the two opposing views
    in the container, you may like to use a more descriptive name to access them.
    You can do this using tags or empty structures that are used as markers. This
    is very similar to how indexes in Boost''s multi-index containers are accessed
    by a tag instead of a numeric position. The following code snippet illustrates
    this technique:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与其使用`left`和`right`来访问容器中的两个对立视图，您可能更喜欢使用更具描述性的名称来访问它们。您可以使用标记或空结构作为标记来实现这一点。这与Boost的多索引容器中通过标记而不是数值位置访问索引的方式非常相似。以下代码片段说明了这种技术：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We define an empty struct for a tag for each view we want to access by name
    (lines 1-2). We then define the bimap container type, tagging the individual collections
    with our tags using the `tagged` template (lines 6, 8). We finally use the `by`
    member template to access the individual views. While the syntax for using tags
    is not the most straightforward, the expressiveness of accessing views using `by<tag>`
    can certainly make your code clearer and less error-prone.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为要按名称访问的每个视图定义了一个空结构体标签（第1-2行）。然后，我们定义了bimap容器类型，使用`tagged`模板为我们的标签标记单独的集合（第6、8行）。最后，我们使用`by`成员模板来访问单独的视图。虽然使用标签的语法并不是最直接的，但使用`by<tag>`访问视图的表现力肯定可以使您的代码更清晰、更不容易出错。
- en: 'Searches on views can be written more succinctly using the `range` member function
    and Boost Lambda placeholders, just like we did with Boost Multi-index. Here is
    an example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`range`成员函数和Boost Lambda占位符，可以更简洁地编写对视图的搜索，就像我们在Boost Multi-index中所做的那样。以下是一个例子：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The call to the `range` member function of the `right` view returns a Boost.Range
    object called `range`, which is really a pair of iterators (lines 7-8). We extract
    the two individual iterators (line 10) and then run through the returned range,
    printing the nicknames and the full names (lines 10-11).With range-aware algorithms,
    we can simply pass the range object without bothering to extract iterators from
    them. If you want to constrain only one end of the range, you can use `boost::bimaps::unbounded`
    for the other end.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`right`视图的`range`成员函数返回一个名为`range`的Boost.Range对象，实际上是一对迭代器（第7-8行）。我们提取两个单独的迭代器（第10行），然后遍历返回的范围，打印昵称和全名（第10-11行）。使用范围感知算法，我们可以简单地传递范围对象，而不必从中提取迭代器。如果您只想约束范围的一端，可以使用`boost::bimaps::unbounded`来表示另一端。
- en: Projections
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 投影
- en: 'From an iterator on one view, you can get to an iterator on another view using
    the `project` member template or the `project_left`/`project_right` member functions.
    Let us suppose that given a name, you want to find out all other names that share
    the same nickname. Here is one way to do this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个视图的迭代器，可以使用`project`成员模板或`project_left`/`project_right`成员函数获取到另一个视图的迭代器。假设给定一个名称，您想找出所有其他共享相同昵称的名称。以下是一种方法：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We first obtain an iterator to a matching name by using the `find` member function
    on the `names` view (line 1).We then project this iterator to the nicknames view
    using the `project` member template. If we do not use tagged keys and values,
    we should use `project_left` and `project_right` member functions instead, depending
    on which view we want to project to. This returns an iterator to the same element
    on the nicknames view (line 2). Next, using the `range` member function, we find
    all entries whose nickname equals `i2->first` (lines 4-5). We then print the pairs
    of nicknames by looping through the iterator range returned by `range` (lines
    7-9).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`names`视图上的`find`成员函数获取到匹配名称的迭代器（第1行）。然后，我们使用`project`成员模板将此迭代器投影到昵称视图。如果我们不使用标记的键和值，我们应该使用`project_left`和`project_right`成员函数，具体取决于我们要投影到哪个视图。这将返回昵称视图上相同元素的迭代器（第2行）。接下来，使用`range`成员函数，我们找到所有昵称等于`i2->first`的条目（第4-5行）。然后，通过循环遍历`range`返回的迭代器范围，打印昵称对（第7-9行）。
- en: There are several other useful features of Boost Bimap, including a view of
    the container as a collection of relations between pairs of elements and the ability
    to modify keys and values in a bimap, in-place. The online Bimap documentation
    on [www.boost.org](http://www.boost.org) is comprehensive and you should refer
    to it for more details on these features.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Bimap还有其他几个有用的功能，包括将容器视为元素对之间关系的集合的视图，以及在bimap中就地修改键和值的能力。[www.boost.org](http://www.boost.org)上的在线Bimap文档非常全面，您应该参考它以获取有关这些功能的更多详细信息。
- en: Self-test questions
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'For multiple choice questions, choose all options that apply:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多项选择题，选择所有适用的选项：
- en: 'The `ordered_non_unique` index on Boost `multi_index_container` has the semantics
    of:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一章中，我们将转而关注函数组合和元编程技术，这些技术使我们能够编写功能强大、表达力强的应用程序，并具有出色的运行时性能。
- en: a. `std::set`
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: a. `std::set`
- en: b. `std::multiset`
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: b. `std::multiset`
- en: c. `std::unordered_set`
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: c. `std::unordered_set`
- en: d. `std::unordered_multiset`
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: d. `std::unordered_multiset`
- en: Deleting an element in a `multi_index_container` will only invalidate the iterator
    to the deleted element, irrespective of the index.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`multi_index_container`中删除一个元素只会使对已删除元素的迭代器失效，而不受索引的影响。
- en: a. True
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: a. True
- en: b. False
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: b. False
- en: c. Depends on the type of index
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: c. 取决于索引的类型
- en: Which of the following bimap types has semantics equivalent to a `multimap<T,
    U>`?
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪种bimap类型具有与`multimap<T, U>`等价的语义？
- en: a. `bimap<T, multiset_of<U>>`
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 自测问题
- en: b. `bimap<multiset_of<T>, U>`
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对`multi_index_container`上的`ordered_non_unique`索引具有以下语义：
- en: c. `bimap<multiset_of<T>, unconstrained_set_of<U>>`
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: c. `bimap<multiset_of<T>, unconstrained_set_of<U>>`
- en: d. `bimap<multiset_of<T>, multiset_if<U>>`
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: d. `bimap<multiset_of<T>, multiset_if<U>>`
- en: Summary
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we focused on containers specialized for looking up objects
    based on multiple criteria. Specifically, we looked at Boost Bimap which is a
    bidirectional map object, whose keys and values can both be looked up efficiently.
    We also looked at Boost Multi-index containers, which are generic associative
    containers with multiple associated indexes, each assisting the efficient look
    up of an object on one criterion.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于专门用于基于多个条件查找对象的容器。具体来说，我们看了Boost Bimap，这是一个双向映射对象，其键和值都可以高效地查找。我们还看了Boost
    Multi-index容器，这是一种通用的关联容器，具有多个关联索引，每个索引都有助于根据一个条件高效查找对象。
- en: In the next chapter, we change gears to look at functional composition and metaprogramming
    techniques that enable us to write powerful and expressive applications with excellent
    runtime performance.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: a. `bimap<T, multiset_of<U>>`
- en: References
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: b. `bimap<multiset_of<T>, U>`
- en: 'Multi-index modify method: [http://www.boost.org/doc/libs/release/libs/multi_index/doc/reference/ord_indices.html#modif](http://www.boost.org/doc/libs/release/libs/multi_index/doc/reference/ord_indices.html#modif)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 多索引修改方法：[http://www.boost.org/doc/libs/release/libs/multi_index/doc/reference/ord_indices.html#modif](http://www.boost.org/doc/libs/release/libs/multi_index/doc/reference/ord_indices.html#modif)
