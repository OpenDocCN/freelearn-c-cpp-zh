- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: There’s a Single C++, and It Is Object-Oriented
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只有一个 C++，它是面向对象的
- en: '*Only if you ignore all* *the others*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*只有当你忽略所有* *其他所有内容*'
- en: C++ was born as C with objects, which makes many developers still consider it
    an OOP language. We will see in this chapter that C++ allows multiple paradigms,
    and you could safely describe it as multiple programming languages in one. We
    will look at a few paradigms supported in C++, including structured programming,
    OOP, functional programming, and metaprogramming, in combination with the choice
    of strong versus quasi-optional types.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 是在 C 的基础上加入了对象特性而诞生的，这使得许多开发者仍然认为它是一种面向对象编程（OOP）语言。在本章中，我们将看到 C++ 允许多种编程范式，并且可以安全地将其描述为一种包含多种编程语言的单一语言。我们将探讨
    C++ 支持的几种范式，包括结构化编程、面向对象编程、函数式编程和元编程，以及强类型与准可选类型的选择。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: The multiple facets of C++
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++ 的多重面相
- en: Functional programming in C++
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++ 中的函数式编程
- en: Metaprogramming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元编程
- en: Strong types to the limit
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 极端强类型
- en: What about ignoring types?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那么，忽略类型呢？
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter is available from the GitHub repository [https://github.com/PacktPublishing/Debunking-CPP-Myths](https://github.com/PacktPublishing/Debunking-CPP-Myths)
    , in the **ch3** folder. It uses Makefile, g++, and the doctest library ( [https://github.com/doctest/doctest](https://github.com/doctest/doctest)
    ) for unit testing. The code is compiled for C++20.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以从 GitHub 仓库 [https://github.com/PacktPublishing/Debunking-CPP-Myths](https://github.com/PacktPublishing/Debunking-CPP-Myths)
    中的 **ch3** 文件夹获取。它使用 Makefile、g++ 和 doctest 库（[https://github.com/doctest/doctest](https://github.com/doctest/doctest)）进行单元测试。代码是为
    C++20 编译的。
- en: The multiple facets of C++
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ 的多重面相
- en: 'If you, like me, frequently move between different organizations, teams, and
    technical conferences, you will quickly notice two things: C++ programmers have
    distinct interests compared to other developers, and the C++ community is more
    aptly described as small, specialized pockets of C++ developers. That’s different
    from other communities; if you discuss Java, you’ll likely end up talking about
    Spring Framework and REST APIs or the Android toolkit. C# is mostly fairly standardized
    around the Microsoft libraries, and JavaScript is mostly about React. But get
    100 C++ programmers in a room from different organizations and you’ll soon notice
    the differences. Embedded C++ is all about keeping all the resources in check
    because adding an extra 1 MB of memory to a device sold in millions of units quickly
    pumps up the cost. Game developers are on the other side of the spectrum, looking
    at how to squeeze extra frame rate out of next-generation GPUs and CPUs. The high-frequency
    trading people know all about avoiding CPU cache misses and how to brush off a
    picosecond of the automated transaction algorithm because the smallest time fraction
    can mean millions of euros. Engineering software developers are more relaxed,
    but still worried about the validity of the changes in a complex rendering model.
    And then you find the programmers dealing with automated systems for rails, cars,
    or factories, whose main concern is resilience and robustness.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像我一样，经常在不同的组织、团队和技术会议上穿梭，你很快就会注意到两件事：与其他开发者相比，C++ 程序员有独特的兴趣，C++ 社区更准确地描述为小型的、专业的
    C++ 开发者群体。这与其他社区不同；如果你讨论 Java，你可能会最终谈到 Spring 框架和 REST API 或 Android 工具包。C# 主要围绕
    Microsoft 库进行标准化，而 JavaScript 主要与 React 相关。但是，如果你把来自不同组织的 100 名 C++ 程序员召集到一起，你很快就会注意到差异。嵌入式
    C++ 专注于控制所有资源，因为为销售数百万台的设备额外增加 1 MB 的内存会迅速推高成本。游戏开发者处于光谱的另一端，他们关注如何从下一代 GPU 和
    CPU 中挤出额外的帧率。高频交易人士对避免 CPU 缓存未命中以及如何从自动化交易算法中消除皮秒级的延迟了如指掌，因为最小的时分数值可能意味着数百万欧元。工程软件开发者更为轻松，但仍担心复杂渲染模型中变更的有效性。然后你还会发现处理铁路、汽车或工厂自动化系统的程序员，他们的主要关注点是弹性和健壮性。
- en: 'This picture, while far from complete, is enough to show us the immense variability
    of C++ programmers, unlike their peers using any other language. We could almost
    say that from a certain point of view, C++ is the last remaining de facto general-purpose
    language, since the other mainstream ones are used in practice mostly for specific
    types of programs: Java for enterprise backend services and Android development,
    C# for web and Windows applications and services, JavaScript for rich web frontends
    and serverless backends, and Python for scripts, data science, and DevOps. But
    C++ is in embedded software, factory systems, trading, simulations, engineering
    tools, operating systems, and so on.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图片虽然远非完整，但足以展示C++程序员巨大的多样性，与使用其他任何语言的同行相比。我们几乎可以说，从某个角度来看，C++是最后剩下的实际通用语言，因为其他主流语言在实践中主要用于特定类型的程序：Java用于企业后端服务和Android开发，C#用于Web和Windows应用程序和服务，JavaScript用于丰富的Web前端和无服务器后端，Python用于脚本、数据科学和DevOps。但C++用于嵌入式软件、工厂系统、交易、模拟、工程工具、操作系统等等。
- en: The old saying “form follows function” is about design applying to everything
    built by people, including programming languages, and applies equally well to
    C++. The large variability in projects and types of programmers fed into the language,
    along with Stroustrup’s desire to make it as capable as possible. C++ is not a
    single language; every programmer uses a subset of C++ that is often different
    from their colleagues working in the same organization.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 旧话“形式追随功能”是关于设计适用于人们建造的每一件事物，包括编程语言，对C++同样适用。项目类型和程序员的大幅变化，以及斯特劳斯特鲁普希望使其尽可能强大的愿望，都融入了C++语言。C++不是一种单一的语言；每个程序员使用的C++子集通常与他们所在组织中的同事不同。
- en: Yes, C++ started as C with objects, at a time when OOP was on the rise. But,
    at the same time, C++ is backward compatible with C, which means you can still
    write structured programming in C++. Then, templates were needed. Then, lambdas
    were useful. While C++ has always been a collection of different languages, today
    it’s even more so. To prove this point, let’s look at a few paradigms you can
    use in C++, starting with functional programming.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，C++最初是以具有对象的C语言为基础发展起来的，那时面向对象编程（OOP）正处于兴起阶段。但是，与此同时，C++与C语言向后兼容，这意味着你仍然可以在C++中编写结构化编程。然后，模板变得必要。接着，lambda表达式变得有用。虽然C++始终是一系列不同语言的集合，但如今这种趋势更加明显。为了证明这一点，让我们看看你可以在C++中使用的一些范式，从函数式编程开始。
- en: Functional programming in C++
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++中的函数式编程
- en: I remember being in university, fascinated about programming, and already quite
    adept at writing BASIC, Pascal, Logo, and simple C++. I think it was in my second
    year when I took a course on functional programming. The teacher was very passionate
    and eager to show us the wonders of this paradigm, explaining a lot of concepts
    that I couldn’t quite grasp. The course turned into a complete miss for me, since
    the only thing I learned was how to write imperative code in Lisp and how to translate
    the idioms I knew into something that would work in this weird language that wears
    its parentheses on the outside of expressions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我记得在大学时，对编程非常着迷，并且已经相当擅长编写BASIC、Pascal、Logo和简单的C++。我认为是在我二年级的时候，我选修了一门关于函数式编程的课程。老师非常热情，渴望向我们展示这种范式的奇妙之处，解释了许多我无法完全理解的概念。这门课程对我来说完全是一次失败，因为我唯一学到的是如何在Lisp中编写命令式代码，以及如何将我已知的习惯用法翻译成在这个奇怪的语言中可以工作，其括号位于表达式外部的东西。
- en: I tried to go back to functional programming after starting my career as a software
    engineer. There were plenty of resources online, only the way they explained the
    paradigm didn’t help. “It’s basically category theory,” they said. Everything
    is a function, even numbers (check out Church encoding). You can easily understand
    monads since they are a monoid in the category of endofunctors. This style of
    explanation uses a more complicated concept to explain a practical one and doesn’t
    facilitate understanding.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我在作为软件工程师开始职业生涯后，试图回归函数式编程。网上有很多资源，但它们解释范式的方式并没有帮助。“这基本上是范畴论，”他们说。一切皆函数，甚至数字（查看Church编码）。由于它们是端内函子的范畴中的幺半群，你可以轻松理解单子。这种解释风格使用更复杂的概念来解释实际的概念，并不利于理解。
- en: This is why it took me years to understand what functional programming is and
    how it helps with software development. I became a fan, but not a fanatic, of
    this paradigm. Like any engineer, I like to solve problems, and in my case, most
    often I solve them with code. Having code that is simpler is always great, although
    often simpler does not mean more familiar.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么我花了好几年时间才理解函数式编程是什么以及它如何帮助软件开发。我成为了这个范式的粉丝，但不是狂热者。像任何工程师一样，我喜欢解决问题，在我的情况下，我通常用代码来解决。拥有更简单的代码总是很好的，尽管通常更简单并不意味着更熟悉。
- en: 'If I were to explain functional programming today, I would focus on three important
    things: *immutability* , *pure functions* , and *operations with functions* .
    Perhaps unexpectedly, C++ is a good fit for all these traits. Immutability is
    where C++ shines compared to the other mainstream programming languages (although
    less than Rust, but we’ll talk about that in the final chapter).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我今天要解释函数式编程，我会关注三个重要的事情：*不可变性*、*纯函数*和*函数操作*。也许出乎意料的是，C++非常适合所有这些特性。与其它主流编程语言相比（尽管不如Rust，但我们在最后一章会谈到这一点），C++在不可变性方面表现出色。
- en: 'However, there’s one catch: functional programming is a different paradigm,
    with its own trade-offs. I’ve noticed that C++ programmers find it difficult to
    think about lambdas since they see lambdas not as a fundamental concept but as
    something built on top of the existing language. That’s fair enough since lambdas
    are objects and not first-class design elements in C++. However, thinking in a
    functional paradigm requires the programmers to temporarily forget this knowledge
    and embrace the functional design elements. You can go back to this knowledge
    when you have implemented something that works and are looking for improvements.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个问题：函数式编程是一个不同的范式，有其自身的权衡。我发现C++程序员发现思考lambda表达式很困难，因为他们将lambda表达式视为不是基本概念，而是建立在现有语言之上的东西。这是公平的，因为lambda表达式是对象，而不是C++中的第一级设计元素。然而，以函数式范式思考要求程序员暂时忘记这些知识，并接受函数式设计元素。当你实现了一些有效的东西并寻求改进时，你可以回到这些知识。
- en: Let’s explain the three characteristics in more detail and then discuss the
    impact of using functional programming on our software architecture.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地解释这三个特性，然后讨论使用函数式编程对我们软件架构的影响。
- en: Immutability
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变性
- en: Immutability fundamentally means that each variable is initialized with a value,
    but a new value cannot be assigned to the variable. In C++, this can be done with
    **const** or **constexpr** , depending on whether we want the value to be immutable
    at runtime or at compile time.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性从根本上意味着每个变量都初始化为一个值，但无法将新值赋给变量。在C++中，这可以通过**const**或**constexpr**来实现，具体取决于我们希望值在运行时还是编译时不可变。
- en: 'While immutability is easy to understand for simple types, collections and
    objects introduce challenges. An immutable collection is one that returns a new
    collection upon every change. So, for example, the following code shows a mutable
    collection:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不可变性对于简单类型来说容易理解，但集合和对象引入了挑战。一个不可变集合是在每次更改时返回一个新的集合。例如，以下代码展示了一个可变集合：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Contrast this example with a hypothetic immutable collection, shown in the
    next code sample, that returns a new collection upon adding to it:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个例子与下一个代码示例中的假设不可变集合进行对比，该集合在添加元素时返回一个新的集合：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This trait guarantees that you’re using the correct version of the data structure
    that you need. But the memory optimization bells might ring in your C++ brain.
    There seems to be a lot of memory allocation happening for immutable collections!
    Isn’t that a waste?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性保证了你使用的是所需数据结构的正确版本。但C++大脑中的内存优化警钟可能会响起。似乎为不可变集合分配了大量的内存！这不是一种浪费吗？
- en: It is indeed possible to be temporarily using more memory than you’d expect
    upon performing a change in an immutable collection. However, functional languages
    have found smart ways to avoid this, and C++ is perfectly capable of using the
    same mechanisms. It depends on the implementation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在不可变集合中执行更改时，确实可能会暂时使用比预期更多的内存。然而，函数式语言已经找到了避免这种情况的智能方法，C++也完全有能力使用相同的机制。这取决于实现方式。
- en: The way to optimize memory for immutable collections is to use *smart pointers*
    . Remember that values are immutable once assigned to a variable. Therefore, when
    the collection is first initialized, memory is allocated for each element of the
    collection and each memory area is assigned to a specific value. When a new element
    is added, the pointers to each element are copied and a new memory area is allocated
    for the new value. If an element is removed from the collection, all the pointers
    to existing elements are copied except the one pointing to the removed element.
    Once a memory area is no longer referenced by any pointer, it gets deleted.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 优化不可变集合内存的方法是使用*智能指针*。记住，一旦值被分配给变量，它就是不可变的。因此，当集合首次初始化时，为集合的每个元素分配内存，并将每个内存区域分配给特定的值。当添加新元素时，每个元素的指针被复制，并为新值分配新的内存区域。如果从集合中删除元素，除了指向被删除元素的指针外，所有指向现有元素的指针都被复制。一旦内存区域不再被任何指针引用，它就会被删除。
- en: While immutable collections are not implemented as such in STL, libraries such
    as immer ( [https://github.com/arximboldi/immer](https://github.com/arximboldi/immer)
    ) allow you to use this pattern without worrying too much about the internal details.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然STL中没有实现不可变集合，但像immer（[https://github.com/arximboldi/immer](https://github.com/arximboldi/immer)）这样的库允许你使用这种模式，而不必过多担心内部细节。
- en: OK, but what about immutable objects? Isn’t the whole purpose of OOP to mix
    behavior with data?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，但不可变对象怎么办？面向对象的全部目的不是将行为与数据混合吗？
- en: To this, I have three things to say.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这一点，我有三件事情要说。
- en: First, good question!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，好问题！
- en: 'Second, OOP was misunderstood to be about encapsulation, inheritance, and polymorphism
    when in fact it’s about message passing. C++ was unfortunately the trendsetter
    for what I like to call “class-oriented programming”: a style of programming focused
    on classes and their relationships instead of objects and their relationships.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，面向对象编程被误解为关于封装、继承和多态，而实际上它是关于消息传递。不幸的是，C++是我喜欢称之为“面向类编程”的趋势的引领者：一种关注类及其关系而不是对象及其关系的编程风格。
- en: 'And third, functional programming has in fact no qualms with objects. Implementing
    immutable objects is very simple: either we implement an immutable data structure
    using **const** , or every method that changes data returns instead a new object
    with the modified data.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，函数式编程实际上并不排斥对象。实现不可变对象非常简单：要么我们使用**const**实现不可变的数据结构，要么每个改变数据的函数返回一个包含修改后数据的新的对象。
- en: It’s worth mentioning at this point that you don’t have to use immutability
    to its fullest in your programs to benefit from functional programming. I write
    enough code that maximizes constness but still uses the standard STL collections
    and objects that change their internal data. However, you need to be aware that
    the level of immutability described previously allows you to introduce parallelism
    much more easily into your programs. If values cannot change, you have no problems
    with critical sections. Each thread works with its own value, and changing the
    value will change it only for the specific thread. Indeed, this is one of the
    side benefits of immutability. I say side benefits because immutability combined
    with pure functions and good naming gives you programs that are easier to understand
    once you get used to the building blocks. So, let’s look at pure functions next.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里值得提一下的是，你不需要在程序中完全使用不可变性来从函数式编程中受益。我写的代码足够多，最大化了常量性，但仍然使用了标准STL集合和会改变其内部数据的对象。然而，你需要意识到，之前描述的不可变性的水平使得你更容易将并行性引入到你的程序中。如果值不能改变，你将不会有临界区的问题。每个线程都使用自己的值，改变值只会对特定的线程产生影响。实际上，这是不可变性的一个附带好处。我说附带好处，因为不可变性结合纯函数和良好的命名，一旦你习惯了构建块，程序就更容易理解。所以，让我们看看纯函数。
- en: Pure functions
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯函数
- en: A pure function is a function that returns the same output for the same input
    and doesn’t change any value in the context. By definition, a pure function cannot
    do **Input/Output** ( **I/O** ) operations. However, any non-trivial program can
    be written as a combination of pure functions and I/O functions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数是一个对于相同的输入返回相同输出且不会改变任何上下文值的函数。根据定义，纯函数不能进行**输入/输出**（**I/O**）操作。然而，任何非平凡的程序都可以写成纯函数和I/O函数的组合。
- en: Pure functions are the simplest types of functions you can think of. They are
    easy to understand, very predictable, and cacheable because they lack side effects.
    This leads to easy testing with data-driven unit tests and potential optimizations
    such as caching the result of the function upon first call with specific inputs
    and reusing it later.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数是你能想到的最简单的函数类型。它们易于理解，非常可预测，并且由于缺乏副作用，可以缓存。这导致数据驱动的单元测试变得容易，以及可能的优化，例如在第一次调用时缓存特定输入的函数结果，并在以后重用。
- en: Pure functions are at the core of functional programming. In C++, they are very
    easy to implement using the support for immutability.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数是函数式编程的核心。在C++中，它们可以通过对不可变性的支持轻松实现。
- en: The original way of writing functions in pure functional languages is lambdas.
    Lambdas have made their way into the standard since C++11. However, C++ lambdas
    can be mutable because they can change the variables they capture in their context.
    So, writing pure functions in C++, even with lambdas, requires you to ensure the
    constness of all variables involved.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯函数式语言中编写函数的原始方式是lambda表达式。自C++11以来，lambda表达式已经成为了标准的一部分。然而，C++中的lambda表达式可以是可变的，因为它们可以改变它们在上下文中捕获的变量。因此，在C++中编写纯函数，即使使用lambda表达式，也需要你确保所有涉及的变量的const属性。
- en: In a functional paradigm, everything is either a function or a data structure,
    and in pure functional languages, the two are interchangeable. So, how do we create
    complex behaviors from simple functions? We compose functions using various operations,
    of course.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式范式下，一切要么是函数要么是数据结构，而在纯函数式语言中，这两者是可以互换的。那么，我们如何从简单的函数中创建复杂的行为呢？当然是通过使用各种操作来组合函数。
- en: Operations on functions
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数上的操作
- en: Since functions are the main design element of functional programming, it’s
    par to the course to think about how functions can change through operations.
    The most common functional operations are partial application and composition.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数是函数式编程的主要设计元素，思考函数如何通过操作进行变化是理所当然的。最常见的函数式操作是偏应用和组合。
- en: 'Partial application refers to creating a new function by binding the value
    of one parameter of a function to a specific value. For example, if we have a
    function, **add(const int first, const int second)** , we can obtain the **increment(const
    int)** function by binding the **second** parameter to the value **1** . Let’s
    take a moment to consider the consequence: every function, no matter how many
    arguments it receives, can be reduced through subsequent partial applications
    to functions that take no parameters. This gives us a universal language for expressing
    anything in code.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 偏应用指的是通过将函数的一个参数的值绑定到特定值来创建一个新的函数。例如，如果我们有一个函数**add(const int first, const int
    second)**，我们可以通过将**second**参数绑定到值**1**来获得**increment(const int)**函数。让我们花点时间考虑一下后果：无论函数接收多少参数，都可以通过后续的偏应用减少到不接受任何参数的函数。这为我们提供了一个通用的语言，可以用来在代码中表达任何事物。
- en: 'To implement a partial application in C++, we can use the **std::bind** function
    from the **<functional>** header. Let’s see how we can obtain the **increment**
    function from the **add** function by binding the second parameter of **add**
    to the value **1** :'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要在C++中实现偏应用，我们可以使用来自**<functional>**头文件的**std::bind**函数。让我们看看如何通过绑定**add**函数的第二个参数到值**1**来从**add**函数获得**increment**函数：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a neat solution from a functional programming perspective. However,
    the return value is complicated and approximates a function instead of being a
    function. This is one of the mental hurdles for C++ programmers when trying functional
    programming. I’ve been away from the language long enough to allow myself to think
    in higher-level concepts instead of always analyzing the implementation. So, when
    I use **std::bind** to do the partial application, I treat the result as a function
    and hope the implementors have done their job of optimizing and providing the
    necessary behaviors.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从函数式编程的角度来看的一个整洁的解决方案。然而，返回值很复杂，近似于一个函数而不是一个函数。这是C++程序员在尝试函数式编程时遇到的心理障碍之一。我已经远离这个语言足够长的时间，可以让自己用高级概念来思考，而不是总是分析实现。所以，当我使用**std::bind**进行偏应用时，我会把结果当作一个函数，并希望实现者已经完成了优化并提供必要的功能。
- en: The other fundamental operation with functions is functional composition. You’ve
    probably encountered this construct in mathematics. Functional composition refers
    to creating a function, *f* , from two functions, *g* and *h* , such that *f(x)
    = g(h(x))* for any value *x* . This is commonly denoted in math as *f =* *g* *∘*
    *h* .
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的另一个基本操作是函数式组合。你可能已经在数学中遇到过这个结构。函数式组合指的是从两个函数，*g* 和 *h*，创建一个函数 *f*，使得对于任何值
    *x*，*f(x) = g(h(x))*。在数学中，这通常表示为 *f = g∘h*。
- en: Unfortunately, there’s no function or operation in the C++ standard that implements
    functional composition, but it’s easy to implement this operation with templates.
    Once again, the result of this operation in C++ is complicated, but I encourage
    you to think about it as a function rather than the actual data structure.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，C++ 标准中没有函数或操作来实现函数式组合，但使用模板很容易实现这个操作。再次强调，C++ 中这个操作的结果可能很复杂，但我鼓励你将其视为一个函数，而不是实际的数据结构。
- en: 'Let’s see a possible implementation for functional composition in C++. The
    **compose** function takes two type parameters, **F** and **G** , that each denote
    the type of functions **f** and **g** to compose. The **compose** function returns
    a lambda that takes one parameter, **value** , and returns **f(g(value)** :'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 C++ 中函数式组合的一个可能实现。`compose` 函数接受两个类型参数，**F** 和 **G**，分别表示要组合的函数 **f**
    和 **g** 的类型。`compose` 函数返回一个 lambda 表达式，它接受一个参数 **value**，并返回 **f(g(value)**：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding example is borrowed from Alex’s other book on the topic with Packt
    Publishing, *Hands-On Functional Programming* *in C++* .
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 上述例子是从 Alex 的另一本关于该主题的 Packt 出版物书籍中借用的，书名为 *Hands-On Functional Programming*
    *in C++* 。
- en: 'Let’s see how we could use this function with a simple example. Let’s implement
    a price calculator that takes as parameters the price, a discount, a service fee,
    and tax and returns the final price. Let’s look first at an imperative implementation,
    using a single function that computes everything inline. The **computePriceImperative**
    function takes the price, subtracts the discount, adds the service fee, and then
    adds the tax percentage on top:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子来看看如何使用这个函数。让我们实现一个价格计算器，它接受价格、折扣、服务费和税费作为参数，并返回最终价格。我们先来看一个命令式实现，使用一个函数来直接计算所有内容。`computePriceImperative`
    函数接受价格，减去折扣，加上服务费，然后再加上税费百分比：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is a simple implementation, and good enough to give a result. Challenges
    usually appear for this type of code when we need to add more types of discounts,
    modify taxes depending on items, or change the order of discounts. Of course,
    we can apply an imperative or object-oriented style when the time comes, and extract
    multiple functions, one for each operation, that we then combine however we need.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的实现，足以给出结果。当需要添加更多类型的折扣、根据项目修改税费或更改折扣的顺序时，这类代码通常会出现挑战。当然，当需要时，我们可以应用命令式或面向对象风格，并提取多个函数，每个操作一个函数，然后按需组合它们。
- en: 'But let’s look at the functional style now. The first thing we can do is to
    use lambdas for every operation, and another lambda for the final computation.
    We implement a few lambdas: one that subtracts the discount from the price, a
    second that applies the service fee, a third that applies the tax, and a final
    one that computes the price by chaining calls to all the previously defined lambdas.
    We end up with the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在让我们看看函数式风格。我们可以做的第一件事是使用 lambda 表达式来表示每个操作，并为最终计算使用另一个 lambda 表达式。我们实现了一些
    lambda 表达式：一个用于从价格中减去折扣，第二个用于应用服务费，第三个用于应用税费，最后一个通过链式调用之前定义的所有 lambda 表达式来计算价格。最终我们得到了以下代码：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Is this code better? Well, it depends. One factor is familiarity with this
    paradigm, but don’t let that stop you; as I said before, familiarity is often
    confused with simplicity, but the two are not the same. Another factor is to see
    the lambdas as functions and not as data structures. Once you pass these two challenges,
    we notice a few things: the lambdas are very small, they are easy to understand,
    and they are pure functions, which are objectively the simplest types of functions
    out there. We can chain the calls in multiple ways, for example, applying the
    discount at the price with tax, so we have more options with this implementation.
    Still, there’s nothing we couldn’t do with imperative programming until now.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码更好吗？好吧，这取决于。一个因素是对这种范式的熟悉程度，但不要让这阻止你；正如我之前说的，熟悉性常常被误认为是简单性，但这两者并不相同。另一个因素是将lambda表达式视为函数而不是数据结构。一旦你克服这两个挑战，我们会注意到一些事情：lambda表达式非常小，易于理解，并且是纯函数，这在客观上是最简单的函数类型。我们可以以多种方式链式调用，例如，在含税价格上应用折扣，因此我们有了更多的选择。尽管如此，我们仍然可以用命令式编程做到现在为止我们能做的任何事情。
- en: 'Let’s then take the next step and make this fully functional. We will use the
    lambdas we created, but instead of returning a value, our implementation will
    use partial application and functional composition to return a function that gives
    us the answer we are looking for. Since the preceding lambdas have two parameters,
    we need to bind one of the arguments to the corresponding input before applying
    the functional composition. So, for the **discountPrice** lambda, we bind the
    discount argument to the value passed to the **computePriceFunctional** function
    and we obtain a lambda that takes a single parameter, the initial price, and returns
    the price with a discount. For the **addServiceFee** lambda, we bind the **serviceFee**
    argument to the value passed to the **computePriceFunctional** function and obtain
    a function that takes a single parameter, the price before service, and returns
    the price with the service fee. For the **applyTax** lambda, we bind the **taxPercentage**
    argument to the value passed to the **computePriceFunctional** function and we
    obtain a function that takes a single parameter, the price without tax, and returns
    the price with tax. Once we obtain these functions that take a single parameter,
    we compose them using the **compose** function shown previously, and we obtain
    a function that takes a single argument price and, when called, computes the correct
    final price. Here is the result:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们再进一步，使其完全功能化。我们将使用我们创建的lambda表达式，但不是返回一个值，我们的实现将使用部分应用和函数组合来返回一个函数，该函数能给出我们想要的答案。由于前面的lambda表达式有两个参数，在应用函数组合之前，我们需要将其中一个参数绑定到相应的输入。因此，对于**discountPrice**
    lambda表达式，我们将折扣参数绑定到传递给**computePriceFunctional**函数的值，并得到一个只接受一个参数（初始价格）的lambda表达式，返回带有折扣的价格。对于**addServiceFee**
    lambda表达式，我们将**serviceFee**参数绑定到传递给**computePriceFunctional**函数的值，并得到一个只接受一个参数（服务前的价格）的函数，返回带有服务费的价格。对于**applyTax**
    lambda表达式，我们将**taxPercentage**参数绑定到传递给**computePriceFunctional**函数的值，并得到一个只接受一个参数（不含税的价格）的函数，返回带有税的价格。一旦我们得到这些只接受一个参数的函数，我们就可以使用之前展示的**compose**函数将它们组合起来，从而得到一个只接受一个参数（价格）的函数，当调用时，计算正确的最终价格。以下是结果：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This style of programming is at first glance very different from what OOP or
    structured programming does. But if you think for a little bit, you will realize
    that an object is just a set of cohesive, partially applied functions. If you
    extract the functions from objects, you need to pass in the data members used
    in the object, a style familiar to those who have ever programmed in C. Including
    a method in an object is therefore equivalent to binding a few of the arguments
    to the object data members that are initialized by the constructor. Therefore,
    OOP and functional programming are not really enemies, just different and equivalent
    ways of expressing the same behavior, with different trade-offs.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编程风格乍一看与面向对象编程（OOP）或结构化编程截然不同。但如果你稍微思考一下，你会意识到一个对象仅仅是一组紧密相连、部分应用的函数集合。如果你从对象中提取函数，你需要传递对象中使用的成员数据，这对于那些曾经用C语言编程的人来说是一种熟悉的风格。因此，将方法包含在对象中相当于将一些参数绑定到由构造函数初始化的对象数据成员上。因此，面向对象编程和函数式编程并不是真正的敌人，只是表达相同行为的不同且等效的方式，各有不同的权衡。
- en: 'As a prelude to the *Metaprogramming* section coming later, let’s look at making
    all these functions available at compile time. We need to do a little bit of magic
    with templates and pass in the value parameters as template arguments, and we
    need to add a lot of **constexpr** , but the following code works equally well:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 作为后续“元编程”部分的序言，让我们先看看如何在编译时使所有这些函数可用。我们需要用模板做一点魔法，并将值参数作为模板参数传递，还需要添加很多**constexpr**，但以下代码同样有效：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With this, we have seen the fundamental blocks of functional programming in
    C++. Let’s now look at where and why they are useful.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经看到了C++中函数式编程的基本块。现在让我们看看它们在哪里以及为什么有用。
- en: Architectural patterns in functional style
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数式风格的架构模式
- en: Let’s first look at how we would implement an application going all the way
    to the functional style. We can’t discuss all the possible design patterns of
    such an application, but we can show a few examples.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看如何实现一个完全采用函数式风格的程序。我们无法讨论这种应用程序的所有可能的设计模式，但我们可以展示一些示例。
- en: We notice first that functional programming places a few constraints upon our
    design. We favor immutability and pure functions. We use data structures, but
    they are immutable, meaning that every change to the data structure gives us a
    new version. Finally, the I/O part needs to be separate and as thin as possible
    since it needs mutations.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先注意到，函数式编程对我们的设计提出了一些约束。我们倾向于不可变性和纯函数。我们使用数据结构，但它们是不可变的，这意味着对数据结构的任何更改都会给我们一个新的版本。最后，I/O部分需要尽可能分离和瘦，因为它需要进行更改。
- en: A simple design pattern using these constraints is the pipe pattern. Let’s imagine
    we receive a file in XML format, and we call web services with data from it. We
    have an input layer that reads the XML file, an output layer that writes to web
    services, and a layer in the center that uses a functional style. We can now consider
    the input and output data and implement consequent transformations on the input
    that lead to the desired output. Each of these transformations is a pure function
    working on immutable data structures.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些约束的一个简单设计模式是管道模式。让我们想象我们收到一个XML格式的文件，并使用其中的数据调用Web服务。我们有一个输入层读取XML文件，一个输出层写入Web服务，以及一个中间层使用函数式风格。我们现在可以考虑输入和输出数据，并在输入上实施后续转换，以产生所需的输出。这些转换中的每一个都是对不可变数据结构工作的纯函数。
- en: Such a process is highly parallelizable because of the lack of mutation. In
    fact, C++17 introduced the **<execution>** header, which allows running the common
    STL algorithms in parallel. Similar patterns are used in data transformation architectures
    such as **Extract, Transform, Load** ( **ETL** ) and in the MapReduce architecture
    made popular by Hadoop.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缺乏更改，这种过程高度可并行化。事实上，C++17引入了**<execution>**头文件，它允许并行运行常见的STL算法。类似的模式在数据转换架构（如**提取、转换、加载**（**ETL**））和由Hadoop普及的MapReduce架构中使用。
- en: The pattern can be extended beyond data transformation, to the more loosely
    defined **functional core, imperative shell** architecture, aptly named by Gary
    Bernhardt. If you want more specific details, look into the hexagonal architecture
    with a functional core.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式可以扩展到数据转换之外，到更宽松定义的**功能核心，命令式外壳**架构，由Gary Bernhardt恰当地命名。如果您想了解更多具体细节，可以查看具有功能核心的六边形架构。
- en: This shows not only that we can design programs using a functional paradigm
    in C++ but also that there are situations when this architecture fits. It also
    shows that we can take some parts of this style of programming and use it on pieces
    of our implementation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅表明我们可以使用函数式范式在C++中设计程序，而且还表明在某些情况下这种架构是合适的。它还表明我们可以采用这种编程风格的一些部分，并将其应用于我们的实现中。
- en: Metaprogramming
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元编程
- en: 'One thing seems to unite programmers, no matter how different they are otherwise:
    the enjoyment of jokes on recursion. There’s something in the programmer’s mind
    that appreciates a certain type of symmetry. When it comes to programming languages
    and programming paradigms, you’d be hard-pressed to find a more symmetrical type
    of language than one that can understand itself.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎有一件事将程序员团结在一起，无论他们如何不同：对递归笑话的喜爱。程序员心中有一种欣赏某种类型对称性的东西。当涉及到编程语言和编程范式时，你很难找到一个比能够理解自己的语言更对称的类型。
- en: The corresponding programming paradigm is called metaprogramming, and programming
    languages that take this idea to the limit are known as homoiconic, meaning that
    a program can manipulate another program’s representation or its own as data.
    Programming languages that have this property include Lisp and its derived dialects,
    the latest being Clojure.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的编程范式被称为元编程，而将这一理念推向极限的编程语言被称为同构语言，这意味着一个程序可以操作另一个程序或其自身的表示或数据。具有这种特性的编程语言包括Lisp及其衍生方言，最新的是Clojure。
- en: Metaprogramming is very powerful, but also very difficult to master, and can
    introduce a lot of issues in large projects. Some features connected to metaprogramming
    are available in modern languages, such as instrumentation, reflection, or dynamic
    execution of instructions. But other than using annotations, very little of all
    this is used in practice.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 元编程非常强大，但也非常难以掌握，并且可能会在大型项目中引入许多问题。与元编程相关的一些功能在现代语言中可用，例如工具、反射或指令的动态执行。但除了使用注解之外，实践中很少使用所有这些功能。
- en: C++ is different, however. One feature of metaprogramming is the ability to
    move computations from runtime to compile time, and C++ has fully embraced it
    with template metaprogramming. In more recent versions of the language, the implementation
    of compile-time computations has been simplified with the introduction of generalized
    constant expressions with **constexpr** and **consteval** .
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，C++却有所不同。元编程的一个特性是将计算从运行时移动到编译时，C++通过模板元编程完全接受了这一点。在语言更近的版本中，通过引入**constexpr**和**consteval**的泛化常量表达式，编译时计算的实现已经得到了简化。
- en: 'A typical example of this technique is the factorial implementation. A recursive
    factorial implementation computed at runtime looks like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的典型例子是阶乘实现。在运行时计算的递归阶乘实现看起来是这样的：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The same implementation can be done using template metaprogramming. It is perhaps
    a lesser-known characteristic of C++ templates that they can take a value as a
    parameter, not just a type. Moreover, both a generic template, for example, one
    that takes any integer value as a parameter, and a specialization, which takes
    only a specific value, can be provided. In our case, we can implement a factorial
    template that takes an integer and a specialization for the value **0** , resulting
    in the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的实现可以使用模板元编程来完成。C++模板的一个可能不太为人所知的特性是它们可以接受一个值作为参数，而不仅仅是类型。此外，既可以是泛型模板，例如，接受任何整数值作为参数的模板，也可以是特化，它只接受特定的值，都可以提供。在我们的例子中，我们可以实现一个接受整数和针对值**0**的特化的阶乘模板，从而得到以下代码：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This implementation achieves the same goal as the previous one, with the exception
    that a call to **Factorial<25>** , for example, will be computed at compile time
    rather than runtime. Starting with C++11 and generalized constant expressions,
    we can avoid templates altogether and instead use **constexpr** and **consteval**
    to tell the compiler which values are to be computed at compile time. Here’s a
    simplified implementation of the same code with a constant expression:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现与之前的一个实现达到相同的目标，唯一的区别是对于**Factorial<25>**这样的调用，将在编译时而不是运行时进行计算。从C++11开始，随着泛化常量表达式的引入，我们可以完全避免使用模板，而是使用**constexpr**和**consteval**来告诉编译器哪些值需要在编译时计算。以下是对同一代码的简化实现，使用了常量表达式：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These metaprogramming techniques available to C++ programmers allow more flexibility
    in decisions related to what happens at compile time versus runtime. They offer
    a trade-off of CPU cycles versus the executable size. If you have a lot of memory
    available but the computations need to happen extremely fast, caching results
    in the executable can be the way to go, and **constexpr** and **consteval** become
    your friends.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 可供C++程序员使用的这些元编程技术使得与编译时和运行时发生的事情相关的决策更加灵活。它们在CPU周期与可执行文件大小之间提供了一个权衡。如果你有大量的内存可用，但计算需要非常快，那么在可执行文件中缓存结果可能是可行的，而**constexpr**和**consteval**将成为你的朋友。
- en: But the possibilities don’t stop here. We can create in C++ programs that are
    demonstrably valid from compilation. We just need to take strong types to their
    limit.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 但可能性并不止于此。我们可以在C++程序中创建从编译时就可以验证的有效程序。我们只需要将强类型推向极限。
- en: Strong types to the limit
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强类型推向极限
- en: One of the biggest challenges in software development is avoiding bugs. This
    is such a pervasive problem that we have taken to naming it something that suggests
    something bad has happened to our code. In fact, however, we should be calling
    bugs *mistakes* , because that is what they are.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发中最大的挑战之一是避免错误。这是一个普遍存在的问题，以至于我们习惯于用暗示代码出了问题的名称来称呼它。然而，实际上，我们应该称之为“错误”，因为这就是它们的本质。
- en: 'Since we have compilers, why can’t we place enough restrictions on the code
    so that they tell us when there’s a bug? We might be able to do just that, only
    not for free. We discussed template metaprogramming in the previous section, but
    we have left out one important characteristic: template metaprogramming is Turing
    complete. This means that for any program that we can write in the normal way,
    we can also write it using template metaprogramming.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们有编译器，为什么不能对代码施加足够的限制，以便它们在出现错误时告诉我们？我们可能能够做到这一点，但不是免费的。我们在上一节讨论了模板元编程，但我们遗漏了一个重要的特性：模板元编程是图灵完备的。这意味着对于我们可以用常规方式编写的任何程序，我们也可以使用模板元编程来编写。
- en: 'This idea is very powerful, and it has been discussed in various contexts over
    time. If you want to try a programming language built entirely around this notion,
    try Idris ( [https://www.idris-lang.org/](https://www.idris-lang.org/) ). Many
    programmers might be familiar with the support available in Haskell for validation
    at compilation time. But my first encounter with this idea was Andrei Alexandrescu’s
    seminal book *Modern C++ Design: Generic Programming and Design Patterns Applied*
    , published in 2001.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法非常强大，并且随着时间的推移在各个环境中都有所讨论。如果你想尝试一个完全围绕这个概念构建的编程语言，可以尝试Idris（[https://www.idris-lang.org/](https://www.idris-lang.org/)）。许多程序员可能熟悉Haskell在编译时验证方面的支持。但我的第一次接触这个想法是在2001年安德烈·亚历山德鲁斯库的奠基性著作《现代C++设计：泛型编程和设计模式应用》中。
- en: Let’s consider a simple problem. One of the common sources for bugs and code
    smell is the so-called **primitive obsession** , that is, the obsession to use
    primitive types to represent complex data. A typical example of primitive obsession
    is to represent length, money, temperature, or weight as a number, by completely
    ignoring their units of measure. Rather than doing this, a specific type for money
    would use a value that allows for a specific precision depending on the context,
    such as seven decimals for accounting and banks, and the currency. This is often
    useful in software development even when the program deals with a single currency
    because one thing you can bet on when it comes to features is that eventually,
    one thing will become more – there will be a time when your client will ask you
    to add a second currency.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简单的问题。常见的错误和代码恶臭的来源之一是所谓的**原始类型迷恋**，即使用原始类型来表示复杂数据的迷恋。原始类型迷恋的一个典型例子是将长度、金钱、温度或重量表示为数字，完全忽略它们的计量单位。与其这样做，不如为金钱使用一个值，它允许根据上下文具有特定的精度，例如会计和银行以及货币的七位小数。即使在程序只处理单一货币的情况下，这在软件开发中通常也很有用，因为你可以肯定的是，在功能方面，最终总会有一些变化——会有一个时间点，你的客户会要求你添加第二种货币。
- en: A typical challenge relating to primitive obsession is with constraining primitive
    types. For example, consider a type that can store the hour of the day. Not only
    is this value an unsigned int, but it can only be from 0 to 23, assuming a 24-hour
    format for simplicity. It would be great to be able to tell the compiler that
    no value outside of the 0-23 range is ever accepted as an hour and to give a relevant
    error when passing, for example, a value of 27.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与原始类型迷恋相关的一个典型挑战是限制原始类型。例如，考虑一个可以存储一天中小时数的类型。这个值不仅是一个无符号整数，而且只能是从0到23，假设为了简单起见采用24小时制。如果能告诉编译器，0-23范围之外的任何值都不应被视为小时数，并在传递例如27这样的值时给出相关错误，那就太好了。
- en: 'In this case, an enum can be a solution, since the number of values is small.
    But we’ll ignore this option and consider first how we would implement this at
    runtime. We can imagine a class called **Hour** that throws an exception if the
    value passed in the constructor is not between 0 and 23:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，枚举可以是一个解决方案，因为值的数量很少。但我们将忽略这个选项，首先考虑如何在运行时实现它。我们可以想象一个名为**Hour**的类，如果传递给构造函数的值不在0到23之间，它会抛出一个异常：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'What if we want to move the check at compile time? Well, time to use the power
    of **constexpr** to tell the compiler what values are defined at compile time,
    and **static_assert** to verify the range:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在编译时进行检查呢？好吧，是时候使用**constexpr**的力量来告诉编译器哪些值在编译时定义，以及使用**static_assert**来验证范围了：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With the preceding implementation, the following code works perfectly:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的实现中，以下代码运行完美：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'But if we try to pass a value outside the range, we get a compilation error:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们尝试传递一个超出范围的值，我们会得到一个编译错误：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This error tells us that we can’t have an hour with the value 30, which is precisely
    what we needed!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误告诉我们，我们不能有一个值为30的小时，这正是我们所需要的！
- en: This is just one technique in the toolbox of C++ programmers who want to create
    programs that are provably valid at compile time. As we mentioned, template metaprogramming
    is Turing complete, which means we can theoretically implement any program at
    compile time that we can implement at runtime. As always, there are trade-offs.
    Notice how the **Hour** value must be **constexpr** , which means the value will
    be stored in the executable. This is by design, since the only way to constrain
    the types to the maximum is to compile them into the unit.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是C++程序员工具箱中的一种技术，他们希望创建在编译时可以证明有效的程序。正如我们提到的，模板元编程是图灵完备的，这意味着我们可以在理论上在编译时实现任何我们可以在运行时实现的程序。但总是有权衡。注意，**小时**值必须是**constexpr**，这意味着值将被存储在可执行文件中。这是设计上的考虑，因为将类型约束到最大值唯一的方法是将它们编译到单元中。
- en: In practice, I noticed that this technique can easily lead to code that is extremely
    difficult to understand and modify. Making changes to this code requires a strong
    discipline, since modifying existing code can still introduce bugs that we otherwise
    have weeded out through our strong types. The fundamental technique is always
    to add, never to modify, unless to fix issues. We have kept this code clean until
    now, but types can get very abstract very quickly, which makes reconstructing
    the reasoning that led to them very difficult after, say, six months. On the upside,
    this technique works best when creating libraries focused on a very specific domain.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，我发现这种技术很容易导致难以理解和修改的代码。修改这种代码需要很强的纪律性，因为修改现有代码仍然可能引入我们通过强类型否则已经排除的bug。基本技术始终是添加，而不是修改，除非是为了修复问题。我们一直保持代码的整洁，但类型可以很快变得非常抽象，这使得在六个月之后重建导致它们的推理变得非常困难。从积极的一面来看，这种技术在创建专注于非常特定领域的库时效果最好。
- en: While I find this technique intriguing, I tend to prefer more freedom when I
    program. I use my own disciplines – test-driven development, merciless refactoring,
    extreme attention to names, and simple design – when I code. I’d rather have a
    way to write the code that I want and let the compiler figure out the details,
    which is why the last paradigm I’m going to discuss ignores types as much as possible.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我发现这种技术很有趣，但我倾向于在编程时更喜欢自由。我在编码时使用自己的纪律——测试驱动开发、无情重构、极端关注命名和简单设计。我更希望有一种编写代码的方式，让编译器处理细节，这就是为什么我将要讨论的最后一种范式尽可能地忽略类型。
- en: What about ignoring types?
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么忽略类型呢？
- en: A few years ago, I led a team that built a few web applications in a language
    called Groovy with a framework named Grails. Groovy is an optionally typed and
    dynamic language, meaning that it assigns types at runtime, but you can provide
    type hints for the compiler. It can also be compiled statically, and since it’s
    built on JVM, the code ends up in a Java unit.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，我领导了一个团队，使用名为Groovy的语言和名为Grails的框架构建了一些Web应用程序。Groovy是一种可选类型和动态语言，这意味着它在运行时分配类型，但你可以为编译器提供类型提示。它也可以静态编译，并且由于它是建立在JVM上的，代码最终会变成Java单元。
- en: I had noticed in previous web projects that types were useful at the edges of
    the system, for checking request parameters, interacting with databases, and other
    I/O operations. But types in the core of a web application tended to make things
    more difficult. We often had to change code or write extra code to accommodate
    new ways of using the already-implemented behaviors, since users of web apps often
    notice a scenario that is useful and want it to work in other contexts or for
    other types of data. So, I decided from the very beginning that we would use types
    for request validation, to ensure security and correctness, and for the interaction
    with external systems, to ensure simplicity. But we did not use types in the core.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我在之前的Web项目中注意到，类型在系统的边缘很有用，用于检查请求参数、与数据库交互以及其他I/O操作。但在Web应用的核心中，类型往往会使事情变得更复杂。我们经常不得不更改代码或编写额外的代码来适应已经实现的行为的新用法，因为Web应用的用户通常会注意到一个有用的场景，并希望它在其他上下文或其他类型的数据中也能工作。因此，我从一开始就决定，我们将使用类型进行请求验证，以确保安全和正确性，以及与外部系统的交互，以确保简单性。但我们没有在核心中使用类型。
- en: 'The plan was always to use a sound strategy for automated testing so that all
    the code was proven valid through tests. I expected that the lack of types would
    make us write more tests, but I was in for a big surprise: the number of tests
    was relatively the same as before, but we had less code. Also, the code we wrote,
    because there were no types involved, pushed us to name things very carefully
    since names were the only hints we had as programmers as to what a function or
    a variable was doing.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 计划一直是使用一种合理的自动化测试策略，以便通过测试证明所有代码的有效性。我预计没有类型会使我们编写更多的测试，但我遇到了一个巨大的惊喜：测试的数量与之前相对相同，但我们有更少的代码。此外，我们编写的代码，因为不涉及类型，迫使我们非常小心地命名事物，因为名称是我们作为程序员了解函数或变量正在做什么的唯一线索。
- en: 'This is, to this day, my favorite style of programming. I want to write the
    code as I want, and as expressive as I can, and let the compiler work out the
    types. You can think about this approach as extreme polymorphism: if you pass
    a variable of a type that has the required methods, the code should work irrespective
    of the type you pass in. It is not a style I would recommend for everyone, because
    it’s not obvious if it works solely in combination with a specific design experience,
    but it is a style that you can experiment with. However, the first hurdle is to
    let go of controlling what the compiler does, a feat more difficult to achieve
    for C++ programmers who are very detailed-oriented.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这至今仍是我最喜欢的编程风格。我想按自己的意愿编写代码，尽可能表达清晰，然后让编译器处理类型。你可以将这种方法视为极端的多态：如果你传递一个具有所需方法的类型的变量，代码应该能够根据你传递的类型正常工作。这不是一个我会推荐给每个人的风格，因为它是否有效并不明显，仅与特定的设计经验相结合，但它是一种你可以尝试的风格。然而，第一个挑战是放弃控制编译器做什么，这对非常注重细节的C++程序员来说是一个更难达成的成就。
- en: How would this work in C++? Well, fortunately for me, the **auto** keyword was
    introduced in C++ since C++11, and its features were improved little by little
    in consequent standards. On the downside, C++ is not as permissive as Groovy on
    dynamic typing, so occasionally I need templates.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这在C++中是如何工作的呢？幸运的是，自从C++11以来，C++引入了**auto**关键字，并在后续的标准中逐渐改进了其功能。然而，不利的是，C++在动态类型方面不如Groovy那么宽容，所以我偶尔需要使用模板。
- en: 'First, let me amaze you with the most polymorphic function you can write:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我用你可以编写的最多态的函数来让你惊叹一下：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This function works no matter what we pass into it. Isn’t that neat? Imagine
    that you have a bunch of functions like this that you can use in the core of your
    system, without needing to change them. That sounds like an ideal programming
    environment to me. Alas, life is more complicated than this, and programs need
    more than identity functions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数无论我们传递给它什么都能正常工作。这不是很酷吗？想象一下，你有一堆这样的函数可以用在系统的核心部分，而且不需要修改它们。这听起来就像是我心目中的理想编程环境。然而，现实生活比这要复杂得多，程序需要的不仅仅是恒等函数。
- en: 'Let’s look at a slightly more complicated example. We’ll start by checking
    whether a string is a palindrome, that is, whether it reads the same both forward
    and reversed. A simple implementation in C++ is to take the string, reverse it
    by using **std::reverse_copy** , and then compare the initial string with its
    reverse:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个稍微复杂一点的例子。我们将首先检查一个字符串是否是回文，也就是说，它正向和反向读起来都一样。在C++中一个简单的实现是取一个字符串，使用**std::reverse_copy**来反转它，然后比较原始字符串与其反转：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'What if we were to make this code less interested in types? First, we would
    change the parameter type to **auto** . Then, we need a way to reverse it without
    constraining ourselves to a string input. Fortunately, the **ranges** library
    has a **reverse_view** that we can use. Finally, we need to compare the initial
    value with the reversed one, again without restraining the type too much. C++
    provides us with **std::equal** . So, we end up with the following code, which
    we can use not only for strings but also for a **vector<string>** that represents
    a phrase, or with tokens defined in an enum. Let’s see the extreme polymorphism
    in action:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使这段代码对类型的兴趣减少呢？首先，我们会将参数类型改为 **auto**。然后，我们需要一种方法来反转它，而不会限制我们只能使用字符串输入。幸运的是，**ranges**
    库有一个 **reverse_view** 我们可以使用。最后，我们需要比较初始值和反转后的值，再次不太多地限制类型。C++ 为我们提供了 **std::equal**。因此，我们最终得到以下代码，我们可以用它不仅用于字符串，还可以用于表示短语的一个
    **vector<string**>，或者用于在枚举中定义的标记。让我们看看极端多态的实际应用：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Perhaps I have now shown you why I find this style of programming very appealing.
    If we ignore the types, or make our functions extremely polymorphic, we can write
    code that applies to future situations without needing to change. The trade-off
    is that the code has its constraints in the deducted types and that the names
    of the parameters and functions matter a lot. For example, if I pass in an integer
    value to **isPalindrome** , I will get a complicated error instead of the simple
    one telling me that the parameter is of the incorrect type. This is the beginning
    of the g++ compiler output on my computer when trying to pass in an integer:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我现在已经向你展示了为什么我觉得这种编程风格非常吸引人。如果我们忽略类型，或者使我们的函数具有极端的多态性，我们可以编写适用于未来情况的代码，而无需进行更改。权衡是代码在其推导出的类型中有限制，并且参数和函数的名称非常重要。例如，如果我向
    **isPalindrome** 传递一个整数值，我将得到一个复杂的错误，而不是一个简单的错误，告诉我参数类型不正确。这是在我尝试传递整数时，我的计算机上
    g++ 编译器输出的开始：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It’s now up to you: do you prefer strong types or extreme polymorphic behavior?
    Both have their trade-offs and their own application domains.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在取决于你：你更喜欢强类型还是极端多态的行为？两者都有其权衡和各自的应用领域。
- en: Summary
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We have seen in this chapter that we can use multiple paradigms to program
    in C++. We looked briefly at a few: functional programming, metaprogramming, types
    that ensure compile-time validation, and extreme polymorphism. Each of these approaches,
    as well as the standard object-oriented and structured programming, are useful
    for various contexts when building libraries or specific programs. Each of them
    has something to offer to the curious programmer who wants to learn as much as
    possible about their craft. Each of them has its trade-offs and its own implementations
    in the world of software development.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到我们可以使用多种范式来用 C++ 编程。我们简要地看了一些：函数式编程、元编程、确保编译时验证的类型以及极端多态。所有这些方法，以及标准的面向对象和结构化编程，在构建库或特定程序的各种情况下都是有用的。它们各自都有提供给那些想要尽可能多地了解自己技艺的程序员的东西。它们各自都有其权衡和软件开发世界中的实现。
- en: We have shown that C++ programmers perhaps only use a subset of the language,
    and it doesn’t have to be an object-oriented one. Instead, it’s best to experiment
    with all of them, making the most of the fact that C++ is powerful enough to offer
    so many options, and to pick and choose depending on the task at hand.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经表明，C++ 程序员可能只使用了语言的一个子集，而且不一定是面向对象的。相反，最好是尝试所有这些，充分利用 C++ 足够强大，可以提供如此多的选项的事实，并根据手头的任务进行选择和选择。
- en: In the next chapter, we will see that the **main()** function might not actually
    be the entry point of our applications.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到 **main()** 函数可能实际上并不是我们应用程序的入口点。
