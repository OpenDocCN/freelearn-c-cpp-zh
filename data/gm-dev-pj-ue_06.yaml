- en: 6\. Collision Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 碰撞对象
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we will continue working on the collision-based game we introduced
    in the previous chapter by adding further mechanics and objects to our game. Initially,
    we will follow on from the previous chapter by introducing object collision. You
    will learn how to use collision boxes, collision triggers, overlap events, hit
    events, and physics simulation. You will also learn how to use timers, the Projectile
    Movement Component, and Physical Materials.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续在上一章介绍的基于碰撞的游戏中添加更多的机制和对象。最初，我们将继续介绍对象碰撞。您将学习如何使用碰撞框、碰撞触发器、重叠事件、击中事件和物理模拟。您还将学习如何使用定时器、投射物移动组件和物理材料。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we came across some of the basic concepts of collision,
    namely Line Traces and Sweep Traces. We learned how to execute different types
    of Line Traces, how to create our own custom Trace Channels, and how to change
    how an object responds to a specific channel. Many of the things you learned in
    the previous chapter will be used in this chapter, where we'll learn about object
    collision.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了一些碰撞的基本概念，即线追踪和扫描追踪。我们学习了如何执行不同类型的线追踪，如何创建自定义的追踪通道，以及如何更改对象对特定通道的响应方式。在本章中，我们将使用上一章学到的许多内容，学习关于对象碰撞。
- en: Throughout this chapter, we will continue to build upon our top-down `Dodgeball`
    game by adding game mechanics that revolve around object collision. We will create
    the **Dodgeball actor**, which will act as a dodgeball that bounces off of the
    floor and walls; a **Wall actor**, which will block all objects; a **Ghost Wall
    actor**, which will only block the player, not the enemies' lines of sight or
    the dodgeball; and a **Victory Box actor**, which will end the game when the player
    enters the Victory Box, representing the end of the level.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续通过添加围绕对象碰撞的游戏机制来构建我们的顶部“躲避球”游戏。我们将创建**躲避球角色**，它将作为一个从地板和墙壁上弹开的躲避球；一个**墙壁角色**，它将阻挡所有对象；一个**幽灵墙角色**，它只会阻挡玩家，而不会阻挡敌人的视线或躲避球；以及一个**胜利箱角色**，当玩家进入胜利箱时游戏结束，代表关卡的结束。
- en: Before we start creating our `Dodgeball` class, we will go over the basic concepts
    of object collision in the next section.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建我们的“躲避球”类之前，我们将在下一节中介绍对象碰撞的基本概念。
- en: Object Collision in UE4
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UE4中的对象碰撞
- en: Every game development tool must have a physics engine that simulates collision
    between multiple objects, as explained in the previous chapter. Collision is the
    backbone of most games released nowadays, whether 2D or 3D. In many games, it's
    the main way in which the player acts upon the environment, be it running, jumping,
    or shooting, and the environment acts accordingly by making the player land, get
    hit, and so on. It is no understatement to say that, without simulated collision,
    it wouldn't be possible to make many games at all.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 每个游戏开发工具都必须有一个模拟多个对象之间碰撞的物理引擎，如前一章所述。碰撞是当今大多数游戏的基础，无论是2D还是3D。在许多游戏中，这是玩家对环境进行操作的主要方式，无论是奔跑、跳跃还是射击，环境都会相应地使玩家着陆、受到打击等。毫不夸张地说，如果没有模拟碰撞，许多游戏根本无法制作。
- en: So, let's understand how object collision works in UE4 and the ways in which
    we can use it, starting with collision components.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们了解UE4中对象碰撞的工作原理以及我们可以使用的方式，从碰撞组件开始。
- en: Collision Components
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞组件
- en: 'In UE4, there are two types of components that can affect and be affected by
    collision; they are as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在UE4中，有两种类型的组件可以影响并受到碰撞的影响；它们如下：
- en: Meshes
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格
- en: Shape objects
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形状对象
- en: '**Meshes** can be as simple as a cube, or as complex as a high-resolution character
    with tens of thousands of vertices. A mesh''s collision can be specified with
    a custom file imported alongside the mesh into UE4 (which is outside the scope
    of this book), or it can be calculated automatically by UE4 and customized by
    you.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**网格**可以简单到一个立方体，也可以复杂到有数万个顶点的高分辨率角色。网格的碰撞可以通过与网格一起导入UE4的自定义文件指定（这超出了本书的范围），也可以由UE4自动计算并由您自定义。'
- en: 'It is generally a good practice to keep the collision mesh as simple (few triangles)
    as possible so that the physics engine can efficiently calculate collision at
    runtime. The types of meshes that can have collision are as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通常最好将碰撞网格保持尽可能简单（少三角形），以便物理引擎可以在运行时高效地计算碰撞。可以具有碰撞的网格类型如下：
- en: Static Meshes
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态网格
- en: Skeletal Meshes
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 骨骼网格
- en: Procedural Meshes
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序化网格
- en: And so on
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以及其他
- en: '**Shape objects**, which are simple meshes represented in wireframe mode that
    are used to behave as collision objects by causing and receiving collision events.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**形状对象**是简单的网格，在线框模式下表示，通过引起和接收碰撞事件来充当碰撞对象。'
- en: Note
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Wireframe mode is a commonly used visualization mode in game development, usually
    for debugging purposes, which allows you to see meshes without any faces or textures
    – they can only be seen through their edges, which are connected by their vertices.
    You will see what wireframe mode is when we add a Shape component to an actor.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 线框模式是游戏开发中常用的可视化模式，通常用于调试目的，允许您看到没有任何面或纹理的网格 - 它们只能通过它们的边缘连接的顶点来看到。当我们向角色添加形状组件时，您将看到线框模式是什么。
- en: 'Please note that Shape objects are essentially invisible meshes and that their
    three types are as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，形状对象本质上是不可见的网格，它们的三种类型如下：
- en: Box Collision (Box Component in C++)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 盒形碰撞（C++中的盒形组件）
- en: Sphere Collision (Sphere Component in C++)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 球形碰撞（C++中的球形组件）
- en: Capsule Collider (Capsule Component in C++)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 胶囊碰撞器（C++中的胶囊组件）
- en: Note
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There's a class that all the components that provide geometry and collision
    inherit from, which is the `Primitive` Component. This component is the basis
    for all components that contain any sort of geometry, which is the case for mesh
    components and shape components.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个类，所有提供几何和碰撞的组件都继承自它，那就是`Primitive`组件。这个组件是包含任何类型几何的所有组件的基础，这适用于网格组件和形状组件。
- en: So, how can these components collide, and what happens when they do so? We shall
    have a look at this in the next section, collision events.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这些组件如何发生碰撞，以及它们碰撞时会发生什么？我们将在下一节中看看这个，即碰撞事件。
- en: Collision Events
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞事件
- en: 'Let''s say that there are two objects colliding into one another. Two things
    can happen:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有两个对象相互碰撞。可能发生两种情况：
- en: They overlap each other, as if the other object weren't there, in which case
    the `Overlap` event is called.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们会互相重叠，好像另一个对象不存在，这种情况下会调用`Overlap`事件。
- en: They collide and prevent each other from continuing their course, in which case
    the `Block` event is called.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们会发生碰撞并阻止对方继续前进，这种情况下会调用`Block`事件。
- en: In the previous chapter, we learned how to change an object's response to a
    specific `Trace` channel. During this process, we learned that an object's response
    can be either `Block`, `Overlap`, or `Ignore`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们学习了如何将对象对特定的`Trace`通道的响应进行更改。在这个过程中，我们了解到对象的响应可以是`Block`、`Overlap`或`Ignore`。
- en: Now, let's see what happens in each of these responses during a collision.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看在碰撞中每种响应发生了什么。
- en: '`Block`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`Block`：'
- en: Both objects will have their `OnHit` events called. This event is called whenever
    two objects block each other's path at the moment they collide. If one of the
    objects is simulating physics, that object must have its `SimulationGeneratesHitEvents`
    property set to `true`.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个对象都会调用它们的`OnHit`事件。这个事件在两个对象在碰撞时阻止对方路径时被调用。如果其中一个对象正在模拟物理，那么该对象必须将其`SimulationGeneratesHitEvents`属性设置为`true`。
- en: Both objects will physically stop each other from continuing with their course.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个对象将互相阻止对方继续前进。
- en: 'Have a look at the following figure, which shows an example of when two objects
    are thrown and bounce off each other:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的图，它展示了两个对象被扔出并互相弹开的例子：
- en: '![Figure 6.1: Object A and Object B blocking each other'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1：对象A和对象B互相阻止对方'
- en: '](img/B16183_06_01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_06_01.jpg)'
- en: 'Figure 6.1: Object A and Object B blocking each other'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：对象A和对象B互相阻止对方
- en: '**Overlap**: Two objects will overlap each other if they don''t block each
    other and neither of them is ignoring the other:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**Overlap**：如果两个对象不会互相阻止对方，并且它们中没有一个忽略另一个，那么它们会互相重叠：'
- en: If both objects have the `GenerateOverlapEvents` property set to `true`, they
    will have their `OnBeginOverlap` and `OnEndOverlap` events called. These overlap
    events are called when an object starts and stops overlapping another object,
    respectively. If at least one of them doesn't have this property set to `true`,
    neither of them will call these events.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个对象的`GenerateOverlapEvents`属性都设置为`true`，它们将调用它们的`OnBeginOverlap`和`OnEndOverlap`事件。这些重叠事件分别在一个对象开始和停止与另一个对象重叠时调用。如果它们中至少有一个没有将此属性设置为`true`，则它们都不会调用这些事件。
- en: The objects act as if the other object doesn't exist and will overlap each other.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象会表现得好像另一个对象不存在，并且会互相重叠。
- en: As an example, suppose the player's character walks into a trigger box that
    marks the end of the level, which only reacts to the player's character.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设玩家角色走进一个只对玩家角色做出反应的关卡结束触发器。
- en: 'Have a look at the following figure, which shows an example of two objects
    overlapping each other:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的图，它展示了两个对象互相重叠的例子：
- en: '![Figure 6.2: Object A and Object B overlapping each other'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2：对象A和对象B互相重叠'
- en: '](img/B16183_06_02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_06_02.jpg)'
- en: 'Figure 6.2: Object A and Object B overlapping each other'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：对象A和对象B互相重叠
- en: '**Ignore**: Two objects will ignore each other if at least one of them is ignoring
    the other:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ignore**：如果两个对象中至少有一个忽略另一个，它们会互相忽略：'
- en: There will be no events called on either object.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何一个对象都不会调用事件。
- en: Similar to the `Overlap` response, the objects will act as if the other object
    doesn't exist and will overlap each other.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与`Overlap`响应类似，对象会表现得好像另一个对象不存在，并且会互相重叠。
- en: An example of two objects ignoring each other would be when an object other
    than the player's character goes into a trigger box that marks the end of the
    level, which only reacts to the player's character.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 两个对象互相忽略的一个例子是，当除了玩家角色以外的对象进入一个只对玩家角色做出反应的关卡结束触发器时。
- en: Note
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can look at the previous figure, where two objects overlap each other, to
    understand **Ignore**.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看一下之前的图，两个对象互相重叠，以理解**Ignore**。
- en: 'Here is a table to help you understand the necessary responses that two objects
    must have in order to trigger the previously described situations:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个表格，帮助你理解两个对象必须具有的必要响应，以触发先前描述的情况：
- en: '![Figure 6.3: Resulting responses on objects based on Block, Overlap, and Ignore'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3：基于Block、Overlap和Ignore的对象的响应结果'
- en: '](img/B16183_06_03.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_06_03.jpg)'
- en: 'Figure 6.3: Resulting responses on objects based on Block, Overlap, and Ignore'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：基于Block、Overlap和Ignore的对象的响应结果
- en: 'Following this table, consider that you have two objects – Object A and Object
    B:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个表格，考虑你有两个对象 - 对象A和对象B：
- en: If Object A has set its response to Object B to `Block` and Object B has set
    its response to Object A to `Block`, they will `Block` each other.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对象A将其响应设置为对象B的`Block`，而对象B将其响应设置为对象A的`Block`，它们将会互相阻止对方。
- en: If Object A has set its response to Object B to `Block` and Object B has set
    its response to Object A to `Overlap`, they will `Overlap` each other.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对象A将其响应设置为对象B的`Block`，而对象B将其响应设置为对象A的`Overlap`，它们将会互相重叠。
- en: If Object A has set its response to Object B to `Ignore` and Object B has set
    its response to Object A to `Overlap`, they will `Ignore` each other.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果物体A将其对物体B的响应设置为“忽略”，而物体B将其对物体A的响应设置为“重叠”，它们将互相“忽略”。
- en: Note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find a full reference to UE4''s collision interactions here: [https://docs.unrealengine.com/en-US/Engine/Physics/Collision/Overview](https://docs.unrealengine.com/en-US/Engine/Physics/Collision/Overview).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里找到UE4碰撞交互的完整参考：[https://docs.unrealengine.com/en-US/Engine/Physics/Collision/Overview](https://docs.unrealengine.com/en-US/Engine/Physics/Collision/Overview)。
- en: 'A collision between objects has two aspects to it:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 物体之间的碰撞有两个方面：
- en: '**Physics**: All collisions related to physics simulation, such as a ball being
    affected by gravity and bouncing off the floors and walls.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 物理学：所有与物理模拟相关的碰撞，比如球受重力影响并从地板和墙壁上弹开。
- en: 'The physically simulated response of the collision within the game, which can
    be either:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的碰撞的物理模拟响应，可以是：
- en: Both objects continuing their trajectories as if the other object wasn't there
    (no physical collision).
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个物体继续它们的轨迹，就好像另一个物体不存在一样（没有物理碰撞）。
- en: Both objects colliding and changing their trajectories, usually with at least
    one of them continuing its movement, that is, blocking each other's paths.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个物体相撞并改变它们的轨迹，通常至少有一个物体继续其运动，即阻挡彼此的路径。
- en: '**Query**: Query can be divided into two aspects of collision, as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**查询**：查询可以分为碰撞的两个方面，如下所示：'
- en: 'The events related to the collision of the objects that are called by the game
    and that you can use to create additional logic. These events are the same ones
    we mentioned previously:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与游戏中的物体碰撞相关的事件，您可以使用这些事件创建额外的逻辑。这些事件与我们之前提到的是相同的：
- en: The `OnHit` event
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “命中”事件
- en: The `OnBeginOverlap` event
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “开始重叠”事件
- en: The `OnEndOverlap` event
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “结束重叠”事件
- en: 'The physical response of the collision within the game, which can be either:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏中的碰撞的物理响应，可以是：
- en: Both objects continuing their movement as if the other object wasn't there (no
    physical collision)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个物体继续它们的运动，就好像另一个物体不存在一样（没有物理碰撞）。
- en: Both objects colliding and blocking each other's path
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个物体相撞并阻挡彼此的路径
- en: The physical response from the Physics aspect might sound similar to the physical
    response from the Query aspect; however, although those are both physical responses,
    they will cause objects to behave differently.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 物理方面的物理响应可能听起来与查询方面的物理响应相似；然而，尽管它们都是物理响应，但它们会导致对象的行为不同。
- en: The physical response from the Physics aspect (physics simulation) only applies
    when an object is simulating physics (for example, being affected by gravity,
    bouncing off the walls and ground, and so on). Such an object, when hitting a
    wall, for instance, will bounce back and continue moving in another direction.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 物理方面的物理响应（物理模拟）仅适用于物体在模拟物理时（例如受重力影响、从墙壁和地面弹开等）。当这样的物体撞到墙壁时，会弹回并继续朝另一个方向移动。
- en: On the other hand, the physical response from the Query aspect applies to all
    objects that don't simulate physics. An object can move without simulating physics
    when being controlled by code (for example, by using the `SetActorLocation` function
    or by using the Character Movement Component). In this case, depending on which
    method you use to move the object and its properties, when an object hits a wall,
    it will simply stop moving instead of bouncing back. This is because you're simply
    telling the object to move in a certain direction and something is blocking its
    path, so the physics engine doesn't allow that object to continue moving.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，查询方面的物理响应适用于所有不模拟物理的物体。当一个物体不模拟物理时，可以通过代码控制移动（例如使用`SetActorLocation`函数或使用角色移动组件）。在这种情况下，根据您用于移动物体的方法和其属性，当物体撞到墙壁时，它将简单地停止移动而不是弹回。这是因为您只是告诉物体朝某个方向移动，而有东西挡住了它的路径，所以物理引擎不允许该物体继续移动。
- en: In the next section, we will be looking at Collision Channels.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看碰撞通道。
- en: Collision Channels
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞通道
- en: In the previous chapter, we took a look at the existing Trace Channels (*Visibility*
    and *Camera*) and learned how to make our own custom channel. Now that you know
    about Trace Channels, it's time to talk about Object Channels, also known as Object Types.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看了现有的跟踪通道（*可见性*和*相机*）并学习了如何创建自定义通道。现在您已经了解了跟踪通道，是时候谈谈对象通道，也称为对象类型了。
- en: While Trace Channels are only used for Line Traces, Object Channels are used
    for object collision. You can specify a "purpose" for each `Object` Channel, much
    like with Trace Channels, such as Pawn, Static Object, Physics Object, Projectile,
    and so on. You can then specify how you want each Object Type to respond to all
    the other Object Types by blocking, overlapping, or ignoring objects of that type.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然跟踪通道仅用于线跟踪，但对象通道用于对象碰撞。您可以为每个“对象”通道指定一个“目的”，就像跟踪通道一样，比如角色、静态对象、物理对象、抛射物等等。然后，您可以指定您希望每种对象类型如何响应所有其他对象类型，即通过阻挡、重叠或忽略该类型的对象。
- en: Collision Properties
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞属性
- en: Now that we've taken a look at how collision works, let's go back to the collision
    settings of the cube we selected in the previous chapter, where we changed its
    response to the Visibility Channel.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了碰撞的工作原理，让我们回到上一章中选择的立方体的碰撞设置，我们在那里将其响应更改为可见性通道。
- en: 'The cube can be seen in the following screenshot:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中可以看到立方体：
- en: '![Figure 6.4: Cube blocking the SightSource of the enemy'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4：立方体阻挡敌人的视觉源'
- en: '](img/B16183_06_04.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_06_04.jpg)'
- en: 'Figure 6.4: Cube blocking the SightSource of the enemy'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：立方体阻挡敌人的视觉源
- en: 'With the level open in the editor, select the cube and go to the `Collision`
    section of its Details Panel:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器中打开关卡，选择立方体并转到其详细面板的“碰撞”部分：
- en: '![Figure 6.5: The changes in the level editor'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.5：关卡编辑器中的更改'
- en: '](img/B16183_06_05.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_06_05.jpg)'
- en: 'Figure 6.5: The changes in the level editor'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：级别编辑器中的变化
- en: 'Here, we can see some options that are important to us:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到一些对我们很重要的选项：
- en: '`SimulationGeneratesHitEvents`, which allows the `OnHit` events to be called
    when an object is simulating physics (we''ll talk about this later in this chapter).'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SimulationGeneratesHitEvents`，当物体模拟物理时允许调用`OnHit`事件（我们将在本章后面讨论这个）。'
- en: '`GenerateOverlapEvents`, which allows the `OnBeginOverlap` and `OnEndOverlap`
    events to be called.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GenerateOverlapEvents`，允许调用`OnBeginOverlap`和`OnEndOverlap`事件。'
- en: '`CanCharacterStepUpOn`, which allows a character to easily step up onto this object.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CanCharacterStepUpOn`，允许角色轻松站在这个物体上。'
- en: '`CollisionPresets`, which allows us to specify how this object responds to
    each Collision Channel.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CollisionPresets`，允许我们指定此对象如何响应每个碰撞通道。'
- en: 'Let''s change the `CollisionPresets` value from `Default` to `Custom` and take
    a look at the new options that show up:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`CollisionPresets`的值从`默认`更改为`自定义`，并查看出现的新选项：
- en: '![Figure 6.6: Changes in Collision Presets'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.6：碰撞预设的变化'
- en: '](img/B16183_06_06.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_06_06.jpg)'
- en: 'Figure 6.6: Changes in Collision Presets'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6：碰撞预设的变化
- en: 'The first of these options is the `CollisionEnabled` property. It allows you
    to specify which aspects of collision you want this object to be considered for:
    Query, Physics, Both, or None. Again, Physics Collision is related to physics
    simulation (whether this object will be considered by other objects that simulate
    physics), while Query Collision is related to collision events and whether objects
    will block each other''s movement:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项中的第一个是`CollisionEnabled`属性。它允许您指定要考虑此对象的碰撞的哪些方面：查询、物理、两者或无。再次，物理碰撞与物理模拟相关（此物体是否会被模拟物理的其他物体考虑），而查询碰撞与碰撞事件相关，以及物体是否会阻挡彼此的移动：
- en: '![Figure 6.7: Collision Enabled for Query and Physics'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.7：查询和物理的碰撞启用'
- en: '](img/B16183_06_07.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_06_07.jpg)'
- en: 'Figure 6.7: Collision Enabled for Query and Physics'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7：查询和物理的碰撞启用
- en: 'The second option is the `ObjectType` property. This is very similar to the
    Trace Channel concept but is specifically for object collision and, most importantly,
    dictates what type of collision object this is. The Object Type values that come
    with UE4 are as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项是`ObjectType`属性。这与跟踪通道概念非常相似，但专门用于对象碰撞，并且最重要的是决定了这是什么类型的碰撞对象。UE4提供的对象类型值如下：
- en: '`WorldStatic`: An object that doesn''t move (structures, buildings, and so
    on)'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WorldStatic`：不移动的物体（结构、建筑等）'
- en: '`WorldDynamic`: An object that may move (objects whose movement is triggered
    by code, objects the player can pick up and move, and so on)'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WorldDynamic`：可能移动的物体（由代码触发移动的物体，玩家可以拾取和移动的物体等）'
- en: '`Pawn`: Used for Pawns that can be controlled and moved around the level'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pawn`：用于可以在级别中控制和移动的Pawns'
- en: '`PhysicsBody`: Used for objects that simulate physics'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PhysicsBody`：用于模拟物理的物体'
- en: '`Vehicle`: Used for Vehicle objects'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vehicle`：用于车辆物体'
- en: '`Destructible`: Used for destructible meshes'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`可破坏`：用于可破坏的网格'
- en: As mentioned previously, you can create your own custom object types (which
    will be mentioned later in this chapter) as well, similar to how you can create
    your own Trace Channels (*which was covered in the previous chapter*).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，您还可以创建自己的自定义对象类型（稍后在本章中提到），类似于您可以创建自己的跟踪通道（*在上一章中介绍过*）。
- en: The last option we have is related to `Collision Responses`. Given that this
    `Cube` object has the default collision options, all the responses are set to
    `Block`, which means that this object will block all the Line Traces and all objects
    that block `WorldStatic` objects, given that that is this object's type.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们拥有的最后一个选项与`碰撞响应`有关。鉴于这个`Cube`对象具有默认的碰撞选项，所有响应都设置为`阻挡`，这意味着该对象将阻挡所有线跟踪和所有阻挡`WorldStatic`对象的对象，鉴于这是该对象的类型。
- en: Because there are so many different combinations of collision properties, UE4
    allows you to group collision property values in the form of Collision Presets.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于碰撞属性有很多不同的组合，UE4允许您以碰撞预设的形式对碰撞属性值进行分组。
- en: 'Let''s go back to the `CollisionPresets` property, which is currently set to
    `Custom`, and *click it* so that we can see all the possible options. Some of
    the existing `Collision Presets` are as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`CollisionPresets`属性，它当前设置为`自定义`，并*点击*以查看所有可能的选项。一些现有的`碰撞预设`如下：
- en: '**No Collision**: Used for objects that aren''t affected by collision whatsoever:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**无碰撞**：用于根本不受碰撞影响的物体：'
- en: '`Collision Enabled`: `NoCollision`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`碰撞启用`：`无碰撞`'
- en: '`Object Type`: `WorldStatic`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`物体类型`：`WorldStatic`'
- en: 'Responses: Irrelevant'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应：无关
- en: 'Example: Objects that are purely visual and distant, such as an object that
    the player will never reach'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例：纯粹是视觉和遥远的物体，如玩家永远不会接触的物体
- en: '**Block All**: Used for objects that are static and block all other objects:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**全部阻挡**：用于静态物体并阻挡所有其他物体：'
- en: '`Collision Enabled`: `Query` and `Physics`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`碰撞启用`：`查询`和`物理`'
- en: '`Object Type`: `WorldStatic`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`物体类型`：`WorldStatic`'
- en: 'Responses: `Block` all channels'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应：`阻挡`所有通道
- en: 'Example: Objects that are close to the player character and block their movement,
    such as the floor and walls, which will always be stationary'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例：靠近玩家角色并阻挡其移动的物体，如地板和墙壁，将始终保持静止
- en: '**Overlap All**: Used for objects that are static and overlap all other objects:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**重叠所有**：用于静态物体并与所有其他物体重叠：'
- en: '`Collision Enabled`: `Query` only'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`碰撞启用`：仅`查询`'
- en: '`Object Type`: `WorldStatic`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`物体类型`：`WorldStatic`'
- en: 'Responses: `Overlap` all channels'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应：`重叠`所有通道
- en: 'Example: Trigger boxes placed in the level, which will always be stationary'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例：放置在级别中的触发框，将始终保持静止
- en: '`Block All` preset, but for dynamic objects that may change their transform
    during gameplay (`Object Type`: `WorldDynamic`)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`全部阻挡`预设，但用于可能在游戏过程中改变其变换的动态物体（`物体类型`：`WorldDynamic`）'
- en: '`Overlap All` preset, but for dynamic objects that may change their transform
    during gameplay (`Object Type`: `WorldDynamic`)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`Overlap All`预设，但对于可能在游戏过程中改变其变换的动态对象（`对象类型`：`WorldDynamic`）'
- en: '**Pawn**: Used for pawns and characters:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**Pawn**：用于pawns和characters：'
- en: '`Collision Enabled`: `Query` and `Physics`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`碰撞使能`：`Query`和`Physics`'
- en: '`Object Type`: `Pawn`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`对象类型`：`Pawn`'
- en: 'Responses: `Block` all channels, `Ignore` Visibility Channel'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应：`Block`所有通道，`Ignore`可见性通道
- en: 'Example: Player character and non-playable characters'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例：玩家角色和非玩家角色
- en: '**Physics Actor**: Used for objects that simulate physics:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 物理演员：用于模拟物理的对象：
- en: '`Collision Enabled`: `Query` and `Physics`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`碰撞使能`：`Query`和`Physics`'
- en: '`Object Type`: `PhysicsBody`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`对象类型`：`PhysicsBody`'
- en: 'Responses: `Block` all channels'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应：`Block`所有通道
- en: 'Example: Objects that are affected by physics, such as a ball that bounces
    off the floor and walls'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例：受物理影响的对象，比如从地板和墙壁上弹开的球
- en: Just like the other collision properties, you can also create your own Collision
    Presets.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他碰撞属性一样，你也可以创建自己的碰撞预设。
- en: Note
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find a full reference to UE4''s collision responses here: [https://docs.unrealengine.com/en-US/Engine/Physics/Collision/Reference](https://docs.unrealengine.com/en-US/Engine/Physics/Collision/Reference).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到UE4碰撞响应的完整参考：[https://docs.unrealengine.com/en-US/Engine/Physics/Collision/Reference](https://docs.unrealengine.com/en-US/Engine/Physics/Collision/Reference)。
- en: Now that we know about the basic concepts of collision, let's go ahead and start
    creating the `Dodgeball` class. The next exercise will guide you toward doing
    just that.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了碰撞的基本概念，让我们继续开始创建`Dodgeball`类。下一个练习将指导你完成这个任务。
- en: 'Exercise 6.01: Creating the Dodgeball Class'
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.01：创建Dodgeball类
- en: In this exercise, we'll be creating our `Dodgeball` class, which will be thrown
    by our enemies and bounce off the floor and walls, just like an actual dodgeball.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建我们的`Dodgeball`类，这个类将被敌人投掷，并且会像真正的躲避球一样从地板和墙壁上弹开。
- en: Before we actually start creating the `Dodgeball` C++ class and its logic, we
    should set up all the necessary collision settings for it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们真正开始创建`Dodgeball` C++类和它的逻辑之前，我们应该为它设置所有必要的碰撞设置。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成这个练习：
- en: Open our `Project Settings` and go to the `Collision` subsection within the
    `Engine` section. Currently, there are no Object Channels, so you need to create
    a new one.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们的`Project Settings`并转到`Engine`部分中的`Collision`子部分。当前没有对象通道，所以你需要创建一个新的。
- en: Press the `New Object Channel` button, name it `Dodgeball`, and set its `Default
    Response` to `Block`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`New Object Channel`按钮，命名为`Dodgeball`，并将其`默认响应`设置为`Block`。
- en: After you've done this, expand the `Preset` section. Here, you'll find all the
    default presets available in UE4\. If you select one of them and press the `Edit`
    option, you can change that `Preset` collision's settings.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，展开`Preset`部分。在这里，你会找到UE4中所有默认的预设。如果你选择其中一个并按下`Edit`选项，你可以更改该`Preset`碰撞的设置。
- en: 'Create your own `Preset` by pressing the `New` option. We want our `Dodgeball`
    `Preset` settings to be as follows:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按下`New`选项创建自己的`Preset`。我们希望我们的`Dodgeball` `Preset`设置如下：
- en: '`Name`: `Dodgeball`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`名称`：`Dodgeball`'
- en: '`CollisionEnabled`: `Collision Enabled (Query and Physics)` (we want this to
    be considered for physics simulation as well as collision events)'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CollisionEnabled`：`Collision Enabled (Query and Physics)`（我们希望这也被考虑为物理模拟以及碰撞事件）'
- en: '`Object Type`: `Dodgeball`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`对象类型`：`Dodgeball`'
- en: '`Collision Responses`: Select *Block* for most of the options, but *Ignore*
    the Camera and `EnemySight` (we don''t want the dodgeball to block the camera
    or the enemy''s line of sight)'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`碰撞响应`：对大多数选项选择*Block*，但对于相机和`EnemySight`选择*Ignore*（我们不希望躲避球阻挡相机或敌人的视线）'
- en: Once you've selected the correct options, press `Accept`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你选择了正确的选项，点击`Accept`。
- en: Now that the `Dodgeball` class's collision settings have been set up, let's
    create the `Dodgeball` C++ class.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Dodgeball`类的碰撞设置已经设置好了，让我们创建`Dodgeball` C++类。
- en: Inside the `Content Browser`, *right-click* and select `New C++ Class`.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content Browser`中，*右键单击*并选择`New C++ Class`。
- en: Choose `Actor` as the parent class.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Actor`作为父类。
- en: Choose `DodgeballProjectile` as the name of the class (our project is already
    named `Dodgeball`, so we can't name this new class that too).
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`DodgeballProjectile`作为类的名称（我们的项目已经命名为`Dodgeball`，所以我们不能再将这个新类命名为`Dodgeball`）。
- en: 'Open the `DodgeballProjectile` class files in Visual Studio. The first thing
    we''ll want to do is add the collision component of the Dodgeball, so we''ll add
    a `SphereComponent` to our class header (*actor component properties are usually private*):'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中打开`DodgeballProjectile`类文件。我们首先要做的是添加躲避球的碰撞组件，所以我们将在我们的类头文件中添加一个`SphereComponent`（*actor组件属性通常是私有的*）：
- en: '[PRE0]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, include the `SphereComponent` class at the top of our source file:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在我们的源文件顶部包含`SphereComponent`类：
- en: '[PRE1]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that all header file includes must be before the .generated.h include.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，所有头文件包含都必须在`.generated.h`之前。
- en: Now, head to the `DodgeballProjectile` class's constructor, within its source
    file, and perform the following steps.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，前往`DodgeballProjectile`类的构造函数，在其源文件中执行以下步骤。
- en: 'Create the `SphereComponent` object:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`SphereComponent`对象：
- en: '[PRE2]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Set its `radius` to `35` units:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其`半径`设置为`35`个单位：
- en: '[PRE3]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Set its `Collision Preset` to the `Dodgeball` preset we created:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其`碰撞预设`设置为我们创建的`Dodgeball`预设：
- en: '[PRE4]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We want the `Dodgeball` to simulate physics, so notify the component of this,
    as shown in the following code snippet:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望`Dodgeball`模拟物理，因此通知组件进行如下所示的设置：
- en: '[PRE5]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We want the `Dodgeball` to call the `OnHit` event while simulating physics,
    so call the `SetNotifyRigidBodyCollision` function in order to set that to `true`
    (this is the same as the `SimulationGeneratesHitEvents` property that we saw in
    the `Collision` section of an object''s properties):'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望`Dodgeball`在模拟物理时调用`OnHit`事件，因此调用`SetNotifyRigidBodyCollision`函数以将其设置为`true`（这与我们在对象属性的`Collision`部分看到的`SimulationGeneratesHitEvents`属性相同）：
- en: '[PRE6]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We will also want to listen to the `OnHit` event of `SphereComponent`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望监听“SphereComponent”的“OnHit”事件。
- en: 'Create a declaration for the function that will be called when the `OnHit`
    event is triggered, in the `DodgeballProjectile` class''s header file. This function
    should be called `OnHit`. It should be `public`, return nothing (`void`), have
    the `UFUNCTION` macro, and receive some parameters, in this order:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“DodgeballProjectile”类的头文件中为将在“OnHit”事件触发时调用的函数创建声明。此函数应该被命名为“OnHit”。它应该是“public”，不返回任何内容（`void`），具有`UFUNCTION`宏，并按照以下顺序接收一些参数：
- en: '`UPrimitiveComponent* HitComp`: The component that was hit and belongs to this
    actor. A Primitive Component is an actor component that has a `Transform` property
    and some sort of geometry (for example, a `Mesh` or `Shape` Component).'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “UPrimitiveComponent* HitComp”：被击中并属于此演员的组件。原始组件是具有“Transform”属性和某种几何形状（例如`Mesh`或`Shape`组件）的演员组件。
- en: '`AActor* OtherActor`: The other actor involved in the collision.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “AActor* OtherActor”：碰撞中涉及的另一个演员。
- en: '`UPrimitiveComponent* OtherComp`: The component that was hit and belongs to
    the other actor.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “UPrimitiveComponent* OtherComp”：被击中并属于其他演员的组件。
- en: '`FVector NormalImpulse`: The direction in which the object will be moving after
    it has been hit, and with how much force (by checking the size of the vector).
    This parameter will only be non-zero for objects that are simulating physics.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “FVector NormalImpulse”：对象被击中后将移动的方向，以及以多大的力（通过检查向量的大小）。此参数仅对模拟物理的对象是非零的。
- en: '`FHitResult& Hit`: The data of the `Hit` resulting from the collision between
    this object and the other object. As we saw in the previous chapter, it contains
    properties such as the location of the `Hit`, its normal, which component and
    actor it hit, and so on. Most of the relevant information is already available
    to us through the other parameters, but if you need more detailed information,
    you can access this parameter:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “FHitResult& Hit”：碰撞结果的数据，包括此对象与其他对象之间的碰撞。正如我们在上一章中看到的，它包含诸如“Hit”位置、法线、击中的组件和演员等属性。大部分相关信息已经通过其他参数可用，但如果需要更详细的信息，可以访问此参数：
- en: '[PRE7]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Add the `OnHit` function's implementation to the class's source file and within
    that function, at least for now, destroy the dodgeball when it hits the player.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 将“OnHit”函数的实现添加到类的源文件中，并在该函数中，至少暂时，当它击中玩家时销毁躲避球。
- en: 'Cast the `OtherActor` parameter to our `DodgeballCharacter` class and check
    if the value is not a `nullptr`. If it''s not, which means that the other actor
    we hit is a `DodgeballCharacter`, we''ll destroy this `DodgeballProjectile` actor:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“OtherActor”参数转换为我们的“DodgeballCharacter”类，并检查该值是否不是“nullptr”。如果不是，则表示我们击中的其他演员是“DodgeballCharacter”，我们将销毁此“DodgeballProjectile”演员：
- en: '[PRE8]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Given that we''re referencing the `DodgebalCharacter` class, we''ll need to
    include it at the top of this class''s source file:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们正在引用“DodgebalCharacter”类，我们需要在此类的源文件顶部包含它：
- en: '[PRE9]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the next chapter, we'll change this function so that we have the dodgeball
    damage the player before destroying itself. We'll do this when we talk about Actor
    Components.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更改此函数，使得躲避球在销毁自身之前对玩家造成伤害。我们将在讨论Actor组件时进行此操作。
- en: 'Head back to the `DodgeballProjectile` class''s constructor and add the following
    line at the end in order to listen to the `OnHit` event of `SphereComponent`:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回“DodgeballProjectile”类的构造函数，并在末尾添加以下行，以便监听“SphereComponent”的“OnHit”事件：
- en: '[PRE10]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will bind the `OnHit` function we created to this `SphereComponent` `OnHit`
    event (because this is an actor component, this event is called `OnComponentHit`),
    which means our function will be called alongside that event.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这将绑定我们创建的“OnHit”函数到这个“SphereComponent”的“OnHit”事件（因为这是一个演员组件，此事件称为“OnComponentHit”），这意味着我们的函数将与该事件一起被调用。
- en: 'Lastly, make `SphereComponent` this actor''s `RootComponent`, as shown in the
    following code snippet:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将“SphereComponent”设置为该演员的“RootComponent”，如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In order for a moving actor to behave correctly on collision, whether it's simulating
    physics or not, it is usually necessary for the main collision component of the
    actor to be its `RootComponent`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使移动的演员在碰撞时正确行为，无论是否模拟物理，通常需要将演员的主要碰撞组件设置为其“RootComponent”。
- en: For example, the `RootComponent` of the `Character` class is a Capsule Collider
    component, because that actor will be moving around and that component is the
    main way the character collides with the environment.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，“Character”类的“RootComponent”是Capsule Collider组件，因为该演员将在周围移动，该组件是角色与环境碰撞的主要方式。
- en: Now that we've added the `DodgeballProjectile` C++ class's logic, let's go ahead
    and create our Blueprint class.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了“DodgeballProjectile”C++类的逻辑，让我们继续创建我们的蓝图类。
- en: Compile your changes and open the editor.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译更改并打开编辑器。
- en: Go to the `Content` > `ThirdPersonCPP` > `Blueprints` directory in the Content
    Browser, right-click, and create a new Blueprint class.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到内容浏览器中的“Content” > “ThirdPersonCPP” > “Blueprints”目录，右键单击，创建一个新的蓝图类。
- en: Expand the `All Classes` section and search for the `DodgeballProjectile` class,
    then set it as the parent class.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开“所有类”部分，搜索“DodgeballProjectile”类，然后将其设置为父类。
- en: Name the new Blueprint class `BP_DodgeballProjectile`.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的蓝图类命名为“BP_DodgeballProjectile”。
- en: Open this new Blueprint class.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开这个新的蓝图类。
- en: 'Notice the wireframe representation of the `SphereCollision` component in the
    actor''s Viewport window (this is hidden by default during the game, but you can
    change that property in this component''s `Rendering` section by changing its
    `HiddenInGame` property):![Figure 6.8: Visual wireframe representation of the
    SphereCollision component'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意演员视口窗口中“SphereCollision”组件的线框表示（默认情况下在游戏过程中隐藏，但可以通过更改此组件的“Rendering”部分中的“HiddenInGame”属性来更改该属性）：![图6.8：SphereCollision组件的视觉线框表示
- en: '](img/B16183_06_08.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_06_08.jpg)'
- en: 'Figure 6.8: Visual wireframe representation of the SphereCollision component'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8：SphereCollision组件的视觉线框表示
- en: 'Now, add a new `Sphere` mesh as a child of the existing `Sphere Collision` component:![Figure
    6.9: Adding a Sphere mesh'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个新的`球体`网格作为现有的`球体碰撞`组件的子级：![图6.9：添加一个球体网格
- en: '](img/B16183_06_09.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_06_09.jpg)'
- en: 'Figure 6.9: Adding a Sphere mesh'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9：添加一个球体网格
- en: 'Change its scale to `0.65`, as shown in the following screenshot:![Figure 6.10:
    Updating the scale'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其比例更改为`0.65`，如下图所示：![图6.10：更新比例
- en: '](img/B16183_06_10.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_06_10.jpg)'
- en: 'Figure 6.10: Updating the scale'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10：更新比例
- en: 'Set its `Collision Presets` to `NoCollision`:![Figure 6.11: Updating Collision
    Presets to NoCollision'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其`碰撞预设`设置为`无碰撞`：![图6.11：更新碰撞预设为无碰撞
- en: '](img/B16183_06_11.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_06_11.jpg)'
- en: 'Figure 6.11: Updating Collision Presets to NoCollision'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11：更新碰撞预设为无碰撞
- en: 'Finally, open our level and place an instance of the `BP_DodgeballProjectile`
    class near the player (this one was placed at a height of 600 units):![Figure
    6.12: Dodgeball bouncing on the ground'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打开我们的关卡，并在玩家附近放置一个`BP_DodgeballProjectile`类的实例（这个实例放置在600单位的高度）：![图6.12：躲避球在地面上弹跳
- en: '](img/B16183_06_12.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_06_12.jpg)'
- en: 'Figure 6.12: Dodgeball bouncing on the ground'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12：躲避球在地面上弹跳
- en: After you've done this, play the level. You'll notice that the Dodgeball will
    be affected by gravity and bounce off the ground a couple of times before coming
    to a standstill.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，玩这个关卡。你会注意到躲避球会受到重力的影响，在触地几次后停止下来。
- en: By completing this exercise, you've created an object that behaves like a physics object.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你已经创建了一个行为像物理对象的对象。
- en: You now know how to create your own collision object types, use the `OnHit`
    event, and change an object's collision properties.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何创建自己的碰撞对象类型，使用`OnHit`事件，并更改对象的碰撞属性。
- en: Note
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'In the previous chapter, we briefly mentioned `LineTraceSingleByObjectType`.
    Now that we know how object collision works, we can briefly mention its use: when
    executing a Line Trace that checks for a Trace Channel, you should use the `LineTraceSingleByChannel`
    function; when executing a Line Trace that checks for an `Object` Channel (Object
    Type), you should use the `LineTraceSingleByObjectType` function. It should be
    made clear that this function, unlike the `LineTraceSingleByChannel` function,
    will not check for objects that block a specific Object Type, but those that are
    of a specific Object Type. Both those functions have the exact same parameters
    and both the Trace Channels and Object Channels are available through the `ECollisionChannel`
    enum.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要提到了`LineTraceSingleByObjectType`。现在我们知道对象碰撞是如何工作的，我们可以简要提到它的用法：当执行检查追踪通道的线追踪时，应该使用`LineTraceSingleByChannel`函数；当执行检查`对象`通道（对象类型）的线追踪时，应该使用`LineTraceSingleByObjectType`函数。应该明确指出，与`LineTraceSingleByChannel`函数不同，这个函数不会检查阻挡特定对象类型的对象，而是检查特定对象类型的对象。这两个函数具有完全相同的参数，追踪通道和对象通道都可以通过`ECollisionChannel`枚举来使用。
- en: But what if you wanted the ball to bounce off the floor more times? What if
    you wanted to make it bouncier? Well, that's where Physical Materials come in.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你想让球在地板上弹跳更多次呢？如果你想让它更有弹性呢？那么物理材料就派上用场了。
- en: Physical Materials
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物理材料
- en: 'In UE4, the way you can customize how an object behaves while simulating physics
    is through Physical Materials. In order to get into this new type of asset, let''s
    create our own:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在UE4中，你可以通过物理材料来自定义对象在模拟物理时的行为方式。为了进入这种新类型的资产，让我们创建我们自己的：
- en: Create a new folder inside the `Content` folder called `Physics`.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`内容`文件夹内创建一个名为`物理`的新文件夹。
- en: '*Right-click* on the `Content Browser` while inside that folder and, under
    the `Create Advanced Asset` section, go to the `Physics` subsection and select
    `Physical Material`.'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*在*该文件夹内的`内容浏览器`上右键单击，并在`创建高级资产`部分下，转到`物理`子部分并选择`物理材料`。'
- en: Name this new Physical Material `PM_Dodgeball`.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个新的物理材料命名为`PM_Dodgeball`。
- en: 'Open the asset and take a look at the available options.![Figure 6.13: Asset
    options'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开资产并查看可用选项。![图6.13：资产选项
- en: '](img/B16183_06_13.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_06_13.jpg)'
- en: 'Figure 6.13: Asset options'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13：资产选项
- en: 'The main options we should note are as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意的主要选项如下：
- en: '`Friction`: This property goes from `0` to `1` and specifies how much friction
    will affect this object (`0` means this object will slide as if it was on ice,
    while `1` means this object will stick like a piece of gum).'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`摩擦`：此属性从`0`到`1`，指定摩擦对这个对象的影响程度（`0`表示此对象会像在冰上一样滑动，而`1`表示此对象会像一块口香糖一样粘住）。'
- en: '`Restitution` (also known as *Bounciness*): This property goes from `0` to
    `1` and specifies how much velocity will be kept after colliding with another
    object (`0` means this object will never bounce off of the ground, while `1` means
    this object will bounce for a long time).'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`弹性`（也称为*弹性*）：此属性从`0`到`1`，指定与另一个对象碰撞后保留多少速度（`0`表示此对象永远不会从地面上弹跳，而`1`表示此对象将长时间弹跳）。'
- en: '`Density`: This property specifies how dense this object is (that is, how heavy
    it is relative to its mesh). Two objects can be of the same size, but if one is
    twice as dense as the other, that means it will be twice as heavy.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`密度`：此属性指定这个对象有多密集（即相对于其网格有多重）。两个对象可以是相同大小的，但如果一个比另一个密度高两倍，那就意味着它会重两倍。'
- en: To have our `DodgeballProjectile` object behave closer to an actual Dodgeball,
    it'll have to suffer quite a bit of friction (the default value is `0.7`, which
    is high enough) and be quite bouncy. Let's increase the `Restitution` property
    of this Physical Material to `0.95`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的`DodgeballProjectile`对象更接近实际的躲避球，它将不得不承受相当大的摩擦（默认值为`0.7`，足够高），并且非常有弹性。让我们将这个物理材料的`弹性`属性增加到`0.95`。
- en: 'After you''ve done this, open the `BP_DodgeballProjectile` Blueprint class
    and change the Sphere Collision component''s Physical Material, inside its `Collision`
    section, to the one we just created, `PM_Dodgeball`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，打开`BP_DodgeballProjectile`蓝图类，并在其`碰撞`部分内更改球体碰撞组件的物理材料为我们刚刚创建的`PM_Dodgeball`：
- en: '![Figure 6.14: Updating the BP_DodgeballProjectile Blueprint class'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.14：更新BP_DodgeballProjectile蓝图类'
- en: '](img/B16183_06_14.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_06_14.jpg)'
- en: 'Figure 6.14: Updating the BP_DodgeballProjectile Blueprint class'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14：更新BP_DodgeballProjectile蓝图类
- en: Note
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure the instance of the Dodgeball actor you added to your level also has
    this physical material.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您在级别中添加的躲避球角色实例也具有这种物理材料。
- en: If you play the level that we created in *Exercise 6.01*, *Creating the Dodgeball
    Class* again, you'll notice that our `BP_DodgeballProjectile` will now bounce
    off the ground several times before coming to a standstill, behaving much more
    like an actual dodgeball.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您再次玩我们在*练习6.01*中创建的级别，*创建躲避球类*，您会注意到我们的“BP_DodgeballProjectile”现在会在停止之前在地面上反弹几次，行为更像一个真正的躲避球。
- en: With all that done, we're just missing one thing to make our `Dodgeball` actor
    behave like an actual dodgeball. Right now, there is no way for us to be able
    to throw it. So, let's address that by creating a Projectile Movement Component,
    which is what we'll be doing in the next exercise.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 做完所有这些之后，我们只缺少一个东西，让我们的“Dodgeball”角色行为像一个真正的躲避球。现在，我们没有办法投掷它。所以，让我们通过创建一个投射物移动组件来解决这个问题，这就是我们下一个练习要做的事情。
- en: 'In the previous chapters, when we replicated the Third Person template project,
    we learned that the `Character` class that comes with UE4 has a `CharacterMovementComponent`.
    This actor component is what allows an actor to move around in the level in various
    ways, and has many properties that allow you to customize that to your preference.
    However, there is another movement component that is also frequently used: `ProjectileMovementComponent`.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，当我们复制第三人称模板项目时，我们了解到UE4自带的“Character”类具有“CharacterMovementComponent”。这个角色组件是允许角色以各种方式在级别中移动的，它有许多属性，允许您根据自己的喜好进行自定义。然而，还有另一个经常使用的移动组件：“ProjectileMovementComponent”。
- en: The `ProjectileMovementComponent` actor component is used to attribute the behavior
    of a projectile to an actor. It allows you to set an initial speed, gravity force,
    and even some physics simulation parameters such as `Bounciness` and `Friction`.
    However, given that our `Dodgeball Projectile` is already simulating physics,
    the only property that we'll be using is `InitialSpeed`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: “ProjectileMovementComponent”角色组件用于将投射物的行为赋予角色。它允许您设置初始速度、重力力量，甚至一些物理模拟参数，如“弹性”和“摩擦力”。然而，鉴于我们的“Dodgeball
    Projectile”已经在模拟物理，我们将使用的唯一属性是“InitialSpeed”。
- en: 'Exercise 6.02: Adding a Projectile Movement Component to DodgeballProjectile'
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.02：向DodgeballProjectile添加一个投射物移动组件
- en: In this exercise, we will be adding a `ProjectileMovementComponent` to our `DodgeballProjectile`
    so that it has an initial horizontal speed. We're doing this so that it can be
    thrown by our enemies and doesn't just fall vertically.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将向我们的“DodgeballProjectile”添加一个“ProjectileMovementComponent”，以便它具有初始的水平速度。我们这样做是为了让我们的敌人可以投掷它，而不仅仅是垂直下落。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成这个练习：
- en: 'Add a `ProjectileMovementComponent` property to the `DodgeballProjectile` class''s
    header file:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“DodgeballProjectile”类的头文件中添加一个“ProjectileMovementComponent”属性：
- en: '[PRE12]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Include the `ProjectileMovementComponent` class at the top of the class''s
    source file:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的源文件顶部包含“ProjectileMovementComponent”类：
- en: '[PRE13]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'At the end of the class''s constructor, create the `ProjectileMovementComponent`
    object:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的构造函数末尾，创建“ProjectileMovementComponent”对象：
- en: '[PRE14]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, set its `InitialSpeed` to `1500` units:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将其“InitialSpeed”设置为“1500”单位：
- en: '[PRE15]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After you''ve done this, compile your project and open the editor. To demonstrate
    the Dodgeball''s initial speed, lower its position on the *Z* axis and place it
    behind the player (*this one was placed at a height of 200 units*):'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，编译您的项目并打开编辑器。为了演示躲避球的初始速度，将其在*Z*轴上降低，并将其放在玩家后面（*这个放置在高度为200单位的位置*）：
- en: '![Figure 6.15: Dodgeball moving along the X axis'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.15：躲避球沿X轴移动'
- en: '](img/B16183_06_15.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_06_15.jpg)'
- en: 'Figure 6.15: Dodgeball moving along the X axis'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15：躲避球沿X轴移动
- en: 'When you play the level, you''ll notice that the Dodgeball starts moving towards
    its *X* axis (*red arrow*):'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当您玩这个级别时，您会注意到躲避球开始朝着它的*X*轴移动（*红色箭头*）：
- en: And with that, we can conclude our exercise. Our `DodgeballProjectile` now behaves
    like an actual dodgeball. It falls, it bounces, and gets thrown.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以结束我们的练习了。我们的“DodgeballProjectile”现在的行为就像一个真正的躲避球。它下落，弹跳，被投掷。
- en: The next step in our project is going to be adding logic to our `EnemyCharacter`
    so that it throws these dodgeballs at the player, but before we address that,
    we must address the concept of timers.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目的下一步是为我们的“EnemyCharacter”添加逻辑，使其向玩家投掷这些躲避球，但在解决这个问题之前，我们必须先解决计时器的概念。
- en: Timers
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计时器
- en: Given the nature of video games and the fact that they're strongly event-based,
    every game development tool must have a way for you to cause a delay, or a wait
    time, before something happens. For instance, when you're playing an online death
    match game, where your character can die and then respawn, usually, the respawn
    event doesn't happen the instant your character dies but a few seconds later.
    There is a multitude of scenarios where you want something to happen, but only
    after a certain amount of time. This will be the case for our `EnemyCharacter`,
    which will be throwing dodge balls every few seconds. This delay, or wait time,
    can be achieved through timers.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于视频游戏的性质以及它们是强烈基于事件的，每个游戏开发工具都必须有一种方法让您在发生某事之前引起延迟或等待时间。例如，当您玩在线死亡竞赛游戏时，您的角色可以死亡然后重生，通常情况下，重生事件不会在您的角色死亡后立即发生，而是几秒钟后。有很多情况下，您希望某事发生，但只能在一定时间后发生。这将是我们的“EnemyCharacter”的情况，它将每隔几秒钟投掷一次躲避球。这种延迟或等待时间可以通过计时器实现。
- en: A **timer** allows you to call a function after a certain amount of time. You
    can choose to loop that function call with an interval and also set a delay before
    the loop starts. If you want the Timer to stop, you can also do that.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**定时器**允许您在一定时间后调用一个函数。您可以选择以一定的时间间隔循环调用该函数，并在循环开始之前设置延迟。如果要停止定时器，也可以这样做。'
- en: We will be using timers so that our enemy throws a dodge ball every `X` amount
    of time, indefinitely, as long as it can see the player character, and then stop
    that timer when the enemy can no longer see its target.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用定时器，这样我们的敌人就可以每隔`X`时间投掷一个躲避球，只要它能看到玩家角色，并且当敌人不能再看到其目标时停止定时器。
- en: Before we start adding logic to our `EnemyCharacter` class that will make it
    throw dodge balls at the player, we should take a look at another topic, which
    is how to spawn actors.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始为`EnemyCharacter`类添加逻辑，使其向玩家投掷躲避球之前，我们应该看一下另一个主题，即如何生成演员。
- en: Spawning Actors
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成演员
- en: In *Chapter 1*, *Unreal Engine Introduction*, you learned how to place an actor
    that you created in the level through the editor, but what if you wanted to place
    that actor in the level as the game is being played? That's what we're going to
    be taking a look at now.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1章*，*虚幻引擎介绍*中，您学会了如何通过编辑器在级别中放置您创建的演员，但是如果您想在游戏进行时将该演员放置在级别中呢？这就是我们现在要看的。
- en: 'UE4, much like most other game development tools, allows you to place an actor
    in the game while the game itself is running. This process is called `SpawnActor`
    function, available from the `World` object (which we can access using the `GetWorld`
    function, as mentioned previously). However, the `SpawnActor` function has a few
    parameters that need to be passed, as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: UE4，就像大多数其他游戏开发工具一样，允许您在游戏运行时放置一个演员。这个过程称为`SpawnActor`函数，可从`World`对象（我们可以使用之前提到的`GetWorld`函数访问）中获得。但是，`SpawnActor`函数有一些需要传递的参数，如下所示：
- en: A `UClass*` property, which lets the function know the class of the object that
    will be spawned. This property can be a C++ class, available through the `NameOfC++Class::StaticClass()`
    function, or a Blueprint class, available through the `TSubclassOf` property.
    It is generally a good practice not to spawn actors from a C++ class directly,
    but to create a Blueprint class and spawn an instance of that instead.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`UClass*`属性，让函数知道将要生成的对象的类。这个属性可以是一个C++类，通过`NameOfC++Class::StaticClass()`函数可用，也可以是一个蓝图类，通过`TSubclassOf`属性可用。通常最好不要直接从C++类生成演员，而是创建一个蓝图类并生成该类的实例。
- en: The `TSubclassOf` property is a way for you to reference a Blueprint class in
    C++. It's used for referencing a class in C++ code, which might be a Blueprint
    class. You declare a `TSubclassOf` property with a template parameter, which is
    the C++ class that class must inherit from. We will be taking a look at how to
    use this property in practice in the next exercise.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TSubclassOf`属性是您在C++中引用蓝图类的一种方式。它用于在C++代码中引用一个类，该类可能是蓝图类。您使用模板参数声明`TSubclassOf`属性，该参数是该类必须继承的C++类。我们将在下一个练习中看一下如何在实践中使用这个属性。'
- en: Either an `FTransform` property or the `FVector` and `FRotator` properties,
    which will indicate the location, rotation, and scale of the object we want to spawn.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论是`FTransform`属性还是`FVector`和`FRotator`属性，都将指示我们想要生成的对象的位置、旋转和比例。
- en: An optional `FActorSpawnParameters` property, which allows you to specify more
    properties specific to the spawning process, such as who caused the actor to spawn
    (that is, the `Instigator`), how to handle the object spawning if the location
    that it spawns at is being occupied by other objects, which may cause an overlap
    or a block event, and so on.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`FActorSpawnParameters`属性，允许您指定与生成过程相关的更多属性，例如谁导致演员生成（即`Instigator`），如何处理对象生成，如果生成位置被其他对象占用，可能会导致重叠或阻塞事件等。
- en: 'The `SpawnActor` function will return an instance to the actor that was spawned
    from this function. Given that it is also a template function, you can call it
    in such a way that you receive a reference to the type of actor you spawned directly
    using a template parameter:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpawnActor`函数将返回从此函数生成的演员的实例。鉴于它也是一个模板函数，您可以以这样的方式调用它，以便使用模板参数直接接收到您生成的演员类型的引用：'
- en: '[PRE16]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this case, the `SpawnActor` function is being called, where we're spawning
    an instance of the `NameOfC++Class` class. Here, we provide a reference to the
    class with the `ClassReference` property and the location and rotation of the
    actor to be spawned using the `SpawnLocation` and `SpawnRotation` properties,
    respectively.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，正在调用`SpawnActor`函数，我们正在生成`NameOfC++Class`类的一个实例。在这里，我们使用`ClassReference`属性提供对类的引用，并使用`SpawnLocation`和`SpawnRotation`属性分别提供要生成的演员的位置和旋转。
- en: You will learn how to apply these properties in *Exercise 6.03*, *Adding Projectile-Throwing
    Logic to the EnemyCharacter*.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在*练习6.03*，*向EnemyCharacter添加投掷项目逻辑*中学习如何应用这些属性。
- en: 'Before we continue to the exercise, though, I''d like to briefly mention a
    variation of the `SpawnActor` function that may also come in handy: the `SpawnActorDeferred`
    function. While the `SpawnActor` function will create an instance of the object
    you specify and then place it in the world, this new `SpawnActorDeferred` function
    will create an instance of the object you want, and only place it in the world
    when you call the actor''s `FinishSpawning` function.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续练习之前，我想简要提一下`SpawnActor`函数的一个变体，这也可能会派上用场：`SpawnActorDeferred`函数。`SpawnActor`函数将创建您指定的对象的实例，然后将其放置在世界中，而这个新的`SpawnActorDeferred`函数将创建您想要的对象的实例，并且只有在调用演员的`FinishSpawning`函数时才将其放置在世界中。
- en: For instance, let's say we want to change the `InitialSpeed` of our Dodgeball
    at the moment we spawn it. If we used the `SpawnActor` function, there's a chance
    that the Dodgeball will start moving before we set its `InitialSpeed` property.
    However, by using the `SpawnActorDeferred` function, we can create an instance
    of the dodge ball, then set its `InitialSpeed` to whatever we want, and only then
    place it in the world by calling the newly created dodgeball's `FinishSpawning`
    function, whose instance is returned to us by the `SpawnActorDeferred` function.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想在生成Dodgeball时更改其`InitialSpeed`。如果我们使用`SpawnActor`函数，Dodgeball有可能在我们设置其`InitialSpeed`属性之前开始移动。然而，通过使用`SpawnActorDeferred`函数，我们可以创建一个dodge
    ball的实例，然后将其`InitialSpeed`设置为我们想要的任何值，然后通过调用新创建的dodgeball的`FinishSpawning`函数将其放置在世界中，该函数的实例由`SpawnActorDeferred`函数返回给我们。
- en: Now that we know how to spawn an actor in the world, and also about the concept
    of timers, we can add the logic that's responsible for throwing dodge balls to
    our `EnemyCharacter` class, which is what we'll be doing in the next exercise.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何在世界中生成一个actor，也知道定时器的概念，我们可以在下一个练习中向我们的`EnemyCharacter`类添加负责投掷dodge球的逻辑。
- en: 'Exercise 6.03: Adding Projectile-Throwing Logic to the EnemyCharacter'
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.03：向EnemyCharacter添加投掷投射物的逻辑
- en: In this exercise, we will be adding the logic that's responsible for throwing
    the Dodgeball actor that we just created to our `EnemyCharacter` class.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将向我们刚刚创建的`EnemyCharacter`类添加负责投掷Dodgeball actor的逻辑。
- en: Open the class's files in Visual Studio in order to get started. We will begin
    by modifying our `LookAtActor` function so that we can save the value that tells
    us whether we can see the player and use it to manage our timer.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中打开类的文件以开始。我们将首先修改我们的`LookAtActor`函数，以便我们可以保存告诉我们是否能看到玩家的值，并用它来管理我们的定时器。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个练习：
- en: 'In the `EnemyCharacter` class''s header file, change the `LookAtActor` function''s
    return type from `void` to `bool`:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`EnemyCharacter`类的头文件中，将`LookAtActor`函数的返回类型从`void`更改为`bool`：
- en: '[PRE17]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Do the same in the function''s implementation, inside the class''s source file,
    while also returning `true` at the end of the `if` statement where we call the
    `CanSeeActor` function. Also, return `false` in the first `if` statement where
    we check if `TargetActor` is a `nullptr` and also at the end of the function:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数的实现中做同样的事情，在类的源文件中，同时在我们调用`CanSeeActor`函数的`if`语句结束时返回`true`。还在我们检查`TargetActor`是否为`nullptr`的第一个`if`语句中返回`false`，并在函数的结尾返回`false`：
- en: '[PRE18]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, add two `bool` properties, `bCanSeePlayer` and `bPreviousCanSeePlayer`,
    set to `protected` in your class''s header file, which will represent whether
    the player can be seen in this frame from the enemy character''s perspective and
    whether the player could be seen in the last frame, respectively:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在你的类头文件中添加两个`bool`属性，`bCanSeePlayer`和`bPreviousCanSeePlayer`，设置为`protected`，它们将表示敌人角色在这一帧中是否能看到玩家，以及上一帧中玩家是否能被看到：
- en: '[PRE19]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, go to your class''s `Tick` function implementation and set the value
    of `bCanSeePlayer` to the return value of the `LookAtActor` function. This will
    replace the previous call to the `LookAtActor` function:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，转到你的类的`Tick`函数实现，并将`bCanSeePlayer`的值设置为`LookAtActor`函数的返回值。这将替换对`LookAtActor`函数的先前调用：
- en: '[PRE20]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After that, set the value of `bPreviousCanSeePlayer` to the value of `bCanSeePlayer`:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将`bPreviousCanSeePlayer`的值设置为`bCanSeePlayer`的值：
- en: '[PRE21]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In-between the previous two lines, add an `if` statement that checks whether
    the values of `bCanSeePlayer` and `bPreviousCanSeePlayer` are different. This
    will mean that either we couldn''t see the player last frame and now we can, or
    that we could see the player last frame and now we can''t:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前两行之间添加一个`if`语句，检查`bCanSeePlayer`和`bPreviousCanSeePlayer`的值是否不同。这意味着我们上一帧看不到玩家，现在可以看到，或者我们上一帧看到玩家，现在看不到：
- en: '[PRE22]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Inside this `if` statement, we want to start a timer if we can see the player
    and stop that timer if we can no longer see the player:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个`if`语句中，如果我们能看到玩家，我们希望启动一个定时器，如果我们不能再看到玩家，就停止定时器：
- en: '[PRE23]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In order to start a timer, we''ll need to add the following properties to our
    class''s header file, which can all be `protected`:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了启动一个定时器，我们需要在类的头文件中添加以下属性，它们都可以是`protected`：
- en: 'An `FTimerHandle` property, which is responsible for identifying which timer
    we want to start. It basically works as the identifier of a specific timer:'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`FTimerHandle`属性，负责标识我们要启动的定时器。它基本上作为特定定时器的标识符：
- en: '[PRE24]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'A `float` property, which represents the amount of time to wait between throwing
    dodgeballs (the interval) so that we can loop the timer. We give this a default
    value of `2` seconds:'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`float`属性，表示投掷dodgeball之间等待的时间（间隔），以便我们可以循环定时器。我们给它一个默认值`2`秒：
- en: '[PRE25]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Another `float` property, which represents the initial delay before the timer
    starts looping. Let''s give it a default value of `0.5` seconds:'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个`float`属性，表示定时器开始循环之前的初始延迟。让我们给它一个默认值`0.5`秒：
- en: '[PRE26]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'A function to be called every time the timer ends, which we will create and
    call `ThrowDodgeball`. This function doesn''t return anything and doesn''t receive
    any parameters:'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个在定时器结束时调用的函数，我们将创建并命名为`ThrowDodgeball`。这个函数不返回任何值，也不接收任何参数：
- en: '[PRE27]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Before we can call the appropriate function to start the timer, we will need
    to add an `#include` to the object responsible for that, `FTimerManager`, in our
    source file.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的源文件中，为了调用适当的函数启动定时器，我们需要添加一个`#include`到负责这个的对象`FTimerManager`。
- en: 'Each `World` has one Timer Manager, which can start and stop timers and access
    relevant functions related to them, such as whether they''re still active, how
    long they''re running for, and so on:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`World`都有一个定时器管理器，它可以启动和停止定时器，并访问与它们相关的相关函数，比如它们是否仍然活动，它们运行了多长时间等等：
- en: '[PRE28]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, access the current World''s Timer Manager by using the `GetWorldTimerManager`
    function:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`GetWorldTimerManager`函数访问当前世界的定时器管理器：
- en: '[PRE29]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, call the `SetTimer` function of the Timer Manager, if we can see the
    player character, in order to start the timer responsible for throwing dodge balls.
    The `SetTimer` function receives the following parameters:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，如果我们能看到玩家角色，就调用定时器管理器的`SetTimer`函数，以启动负责投掷躲避球的计时器。`SetTimer`函数接收以下参数：
- en: 'The `FTimerHandle` representing the desired timer: `ThrowTimerHandle`.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代表所需计时器的`FTimerHandle`：`ThrowTimerHandle`。
- en: 'The object that the function to be called belongs to: `this`.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要调用的函数所属的对象：`this`。
- en: The function to be called, which must be specified by prefixing its name with
    `&ClassName::`, resulting in `&AEnemyCharacter::ThrowDodgeball`.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要调用的函数，必须通过在其名称前加上`&ClassName::`来指定，得到`&AEnemyCharacter::ThrowDodgeball`。
- en: 'The timer''s rate, or interval: `ThrowingInterval`.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计时器的速率或间隔：`ThrowingInterval`。
- en: 'Whether this timer will loop: `true`.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个计时器是否会循环：`true`。
- en: 'The delay before this timer starts looping: `ThrowingDelay`.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个计时器开始循环之前的延迟：`ThrowingDelay`。
- en: 'The following code snippet comprises these parameters:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段包括这些参数：
- en: '[PRE30]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If we can no longer see the player and we want to stop the timer, we can do
    so using the `ClearTimer` function. This function only needs to receive an `FTimerHandle`
    property as a parameter:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们看不到玩家并且想要停止计时器，可以使用`ClearTimer`函数来实现。这个函数只需要接收一个`FTimerHandle`属性作为参数：
- en: '[PRE31]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The only thing left is to implement the `ThrowDodgeball` function. This function
    will be responsible for spawning a new `DodgeballProjectile` actor. In order to
    do this, we'll need a reference to the class we want to spawn, which must inherit
    from `DodgeballProjectile`, so the next thing we need to do is create the appropriate
    property using the `TSubclassOf` object.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在唯一剩下的就是实现`ThrowDodgeball`函数。这个函数将负责生成一个新的`DodgeballProjectile`角色。为了做到这一点，我们需要一个引用要生成的类，它必须继承自`DodgeballProjectile`，所以下一步我们需要使用`TSubclassOf`对象创建适当的属性。
- en: 'Create the `TSubclassOf` property in the `EnemyCharacter` header file, which
    can be `public`:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`EnemyCharacter`头文件中创建`TSubclassOf`属性，可以是`public`：
- en: '[PRE32]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Because we''ll be using the `DodgeballProjectile` class, we also need to include
    it in the `EnemyCharacter` source file:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们将使用`DodgeballProjectile`类，所以我们还需要在`EnemyCharacter`源文件中包含它：
- en: '[PRE33]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, within the `ThrowDodgeball` function''s implementation in the source
    file, start by checking if this property is a `nullptr`. If it is, we `return`
    immediately:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在源文件中`ThrowDodgeball`函数的实现中，首先检查这个属性是否为`nullptr`。如果是，我们立即`return`：
- en: '[PRE34]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, we will be spawning a new actor from that class. Its location will be
    `40` units in front of the enemy and its rotation will be the same as the enemy.
    In order to spawn the Dodgeball in front of the enemy character, we''ll need to
    access the enemy''s `ForwardVector` property, which is a unitary `FVector` (*meaning
    that its length is 1*) that indicates the direction an actor is facing, and multiply
    it by the distance at which we want to spawn our dodgeball, which is `40` units:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将从该类中生成一个新的角色。它的位置将在敌人前方`40`个单位，旋转角度与敌人相同。为了在敌人前方生成躲避球，我们需要访问敌人的`ForwardVector`属性，这是一个单位`FVector`（*意味着它的长度为1*），表示角色面对的方向，并将其乘以我们想要生成躲避球的距离，即`40`个单位：
- en: '[PRE35]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This concludes the modifications we need to make to the `EnemyCharacter` class.
    Before we finish setting up the Blueprint of this logic, let's make a quick modification
    to our `DodgeballProjectile` class.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们需要对`EnemyCharacter`类进行的修改。在完成设置此逻辑的蓝图之前，让我们快速修改一下我们的`DodgeballProjectile`类。
- en: Open the `DodgeballProjectile` class's source file in Visual Studio.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中打开`DodgeballProjectile`类的源文件。
- en: 'Within its `BeginPlay` event, set its `LifeSpan` to `5` seconds. This property,
    which belongs to all actors, dictates how much longer they will remain in the
    game before being destroyed. By setting our dodgeball''s `LifeSpan` to `5` seconds
    on its `BeginPlay` event, we are telling UE4 to destroy that object 5 seconds
    after it''s spawned (*or, if it''s already been placed in the level, 5 seconds
    after the game starts*). We will do this so that the floor isn''t filled with
    dodge balls after a certain amount of time, which would make the game unintentionally
    difficult for the player:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其`BeginPlay`事件中，将其`LifeSpan`设置为`5`秒。这个属性属于所有角色，规定了它们在游戏中还会存在多久才会被销毁。通过在`BeginPlay`事件中将我们的躲避球的`LifeSpan`设置为`5`秒，我们告诉UE4在它生成后5秒后销毁该对象（*或者，如果它已经放置在关卡中，在游戏开始后5秒*）。我们这样做是为了避免在一定时间后地板上充满了躲避球，这会让游戏对玩家来说变得意外困难：
- en: '[PRE36]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now that we''ve finished our C++ logic related to the `EnemyCharacter` class''s
    Dodgeball throwing logic, let''s compile our changes, open the editor, and then
    open our `BP_EnemyCharacter` Blueprint. There, head to the `Class Defaults` panel
    and change the `DodgeballClass` property''s value to `BP_DodgeballProjectile`:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了与`EnemyCharacter`类的躲避球投掷逻辑相关的C++逻辑，让我们编译我们的更改，打开编辑器，然后打开我们的`BP_EnemyCharacter`蓝图。在那里，转到`Class
    Defaults`面板，并将`DodgeballClass`属性的值更改为`BP_DodgeballProjectile`：
- en: '![Figure 6.16: Updating the Dodgeball Class'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.16：更新躲避球类'
- en: '](img/B16183_06_16.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_06_16.jpg)'
- en: 'Figure 6.16: Updating the Dodgeball Class'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16：更新躲避球类
- en: After you've done this, you can remove the existing instance of the `BP_DodgeballProjectile`
    class we had placed in our level, if it's still there.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，如果还在的话，可以移除我们在关卡中放置的`BP_DodgeballProjectile`类的现有实例。
- en: 'Now, we can play our level. You''ll notice that the enemy will almost immediately
    start throwing dodge balls at the player and will continue to do so as long as
    the player character is in view:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以玩我们的关卡。你会注意到敌人几乎立即开始向玩家投掷躲避球，并且只要玩家角色在视线中，它就会继续这样做：
- en: '![Figure 6.17: Enemy character throwing dodgeballs if the player is in sight'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.17：敌人角色在玩家视线中投掷躲避球'
- en: '](img/B16183_06_17.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_06_17.jpg)'
- en: 'Figure 6.17: Enemy character throwing dodgeballs if the player is in sight'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17：敌人角色在玩家视线中投掷躲避球
- en: With that, we have concluded our dodge ball-throwing logic for the `EnemyCharacter`.
    You now know how to use timers, an essential tool for any game programmer.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们已经完成了`EnemyCharacter`的躲避球投掷逻辑。您现在知道如何使用定时器，这是任何游戏程序员的必备工具。
- en: Walls
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 墙
- en: 'The next step in our project is going to be creating the `Wall` classes. We
    will have two types of walls:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目的下一步将是创建`Wall`类。我们将有两种类型的墙：
- en: A normal wall, which will block the enemy's line of sight, the player character,
    and the dodge ball.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个普通的墙，它将阻挡敌人的视线，玩家角色和躲避球。
- en: A ghost wall, which will only block the player character, and ignore the enemy's
    line of sight and the dodge ball. You might find this type of collision setup
    in specific types of puzzle games.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个幽灵墙，它只会阻挡玩家角色，而不会阻挡敌人的视线和躲避球。您可能会在特定类型的益智游戏中找到这种类型的碰撞设置。
- en: We'll create both these Wall classes in the next exercise.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一个练习中创建这两个Wall类。
- en: 'Exercise 6.04: Creating Wall Classes'
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.04：创建Wall类
- en: In this exercise, we will be creating the `Wall` classes that represent both
    a normal `Wall` and a `GhostWall`, which will only block the player character's
    movement, but not the enemies' lines of sight or the dodge balls they throw.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建代表普通`Wall`和`GhostWall`的`Wall`类，后者只会阻挡玩家角色的移动，而不会阻挡敌人的视线或他们投掷的躲避球。
- en: Let's start with the normal `Wall` class. This C++ class will basically be empty
    because the only thing that it'll need is a mesh in order to reflect the projectiles
    and block the enemies' lines of sight, which will be added through its Blueprint
    class.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从普通的`Wall`类开始。这个C++类基本上是空的，因为它唯一需要的是一个网格，以便反射抛射物并阻挡敌人的视线，这将通过其蓝图类添加。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此练习：
- en: Open the editor.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开编辑器。
- en: In the top-left corner of the Content Browser, press the green `Add New` button.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内容浏览器的左上角，按绿色的`添加新`按钮。
- en: Select the first option at the top; `Add Feature or Content Pack`.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部选择第一个选项；`添加功能或内容包`。
- en: A new window will show up. Select the `Content Packs` tab, then select the `Starter
    Content` pack and then press the `Add To Project` button. This will add some basic
    assets to the project, which we'll use in this chapter and some of the following
    chapters.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将会出现一个新窗口。选择`内容包`选项卡，然后选择`Starter Content`包，然后按`添加到项目`按钮。这将向项目中添加一些基本资产，我们将在本章和一些后续章节中使用。
- en: Create a new C++ class, called `Wall`, with the `Actor` class as its parent.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Wall`的新的C++类，其父类为`Actor`类。
- en: 'Next, open the class''s files in Visual Studio and add a `SceneComponent` as
    our Wall''s `RootComponent`:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在Visual Studio中打开类的文件，并将`SceneComponent`添加为我们的Wall的`RootComponent`：
- en: 'The `Header` file will be as follows:'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Header`文件将如下所示：'
- en: '[PRE37]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `Source` file will be as follows:'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Source`文件将如下所示：'
- en: '[PRE38]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Compile your code and open the editor.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译您的代码并打开编辑器。
- en: Next, go to the `Content` > `ThirdPersonCPP` >:`Blueprints` directory inside
    the Content Browser, create a new Blueprint class that inherits from the `Wall`
    class, name it `BP_Wall`, and open that asset.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到内容浏览器中的`Content` > `ThirdPersonCPP` >:`Blueprints`目录，创建一个新的蓝图类，该类继承自`Wall`类，命名为`BP_Wall`，然后打开该资产。
- en: Add a Static Mesh Component and set its `StaticMesh` property to `Wall_400x300`.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个静态网格组件，并将其`StaticMesh`属性设置为`Wall_400x300`。
- en: Set its `Material` property to `M_Metal_Steel`.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其`Material`属性设置为`M_Metal_Steel`。
- en: 'Set the Static Mesh Component''s location on the *X* axis to `–200` units (*so
    that the mesh is centered relative to our actor''s origin*):![Figure 6.18: Updating
    the Static Mesh Component''s location'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将静态网格组件的位置设置在*X*轴上为`-200`单位（*以便网格相对于我们的角色原点居中*）：![图6.18：更新静态网格组件的位置
- en: '](img/B16183_06_18.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_06_18.jpg)'
- en: 'Figure 6.18: Updating the Static Mesh Component''s location'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.18：更新静态网格组件的位置
- en: 'This is what your Blueprint class''s Viewport should look like:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您的蓝图类的视口应该看起来的样子：
- en: '![Figure 6.19: Blueprint class''s Viewport Wall'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.19：蓝图类的视口墙'
- en: '](img/B16183_06_19.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_06_19.jpg)'
- en: 'Figure 6.19: Blueprint class''s Viewport Wall'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.19：蓝图类的视口墙
- en: Note
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is generally good practice to add a `SceneComponent` as an object's `RootComponent`,
    when a collision component isn't necessary, in order to allow for more flexibility
    with its child components.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 通常最好将`SceneComponent`添加为对象的`RootComponent`，当不需要碰撞组件时，以便允许更多的灵活性与其子组件。
- en: An actor's `RootComponent` cannot have its location or rotation modified, which
    is why, in our case, if we had created a Static Mesh Component in the Wall C++
    class and set that as its Root Component, instead of using a Scene Component,
    we'd have a hard time offsetting it.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 演员的`RootComponent`不能修改其位置或旋转，这就是为什么在我们的情况下，如果我们在Wall C++类中创建了一个静态网格组件，并将其设置为其Root
    Component，而不是使用场景组件，我们将很难对其进行偏移。
- en: Now that we've set up the regular `Wall` class, let's create our `GhostWall`
    class. Because these classes don't have any logic set up, we're just going to
    create the `GhostWall` class as a child of the `BP_Wall` Blueprint class and not
    our C++ class.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了常规的`Wall`类，让我们创建我们的`GhostWall`类。因为这些类没有设置任何逻辑，我们只是将`GhostWall`类创建为`BP_Wall`蓝图类的子类，而不是我们的C++类。
- en: '*Right-click* the `BP_Wall` asset and select `Create Child Blueprint Class`.'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击*`BP_Wall`资产，然后选择`创建子蓝图类`。'
- en: Name the new Blueprint `BP_GhostWall`.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的蓝图命名为`BP_GhostWall`。
- en: Open it.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开它。
- en: 'Change the Static Mesh Component''s Collision properties:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改静态网格组件的碰撞属性：
- en: Set its `CollisionPreset` to `Custom`.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其`CollisionPreset`设置为`Custom`。
- en: Change its response to both the `EnemySight` and `Dodgeball` channels to `Overlap`.
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其响应更改为`EnemySight`和`Dodgeball`通道都为`Overlap`。
- en: Change the Static Mesh Component's `Material` property to `M_Metal_Copper`.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将静态网格组件的`Material`属性更改为`M_Metal_Copper`。
- en: 'Your `BP_GhostWall`''s Viewport should now look like this:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 您的`BP_GhostWall`的视口现在应该是这样的：
- en: '![Figure 6.20: Creating the Ghost Wall'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.20：创建Ghost Wall'
- en: '](img/B16183_06_20.jpg)'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_06_20.jpg)'
- en: 'Figure 6.20: Creating the Ghost Wall'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.20：创建Ghost Wall
- en: 'Now that you''ve created both these Wall actors, place each in the level to
    test them. Set their transforms to the following transform values:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了这两个Wall角色，将它们放在关卡中进行测试。将它们的变换设置为以下变换值：
- en: 'Wall: `Location`: `(-710, 120, 130)`'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wall：`位置`：`(-710, 120, 130)`
- en: 'Ghost Wall: `Location`: `(-910, -100, 130)`; `Rotation`: `(0, 0, 90)`:![Figure
    6.21: Updating the Ghost Wall''s locations and rotation'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ghost Wall：`位置`：`(-910, -100, 130)`；`旋转`：`(0, 0, 90)`：![图6.21：更新Ghost Wall的位置和旋转
- en: '](img/B16183_06_21.jpg)'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_06_21.jpg)'
- en: 'Figure 6.21: Updating the Ghost Wall''s locations and rotation'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.21：更新Ghost Wall的位置和旋转
- en: 'The final outcome should look like this:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果应该是这样的：
- en: '![Figure 6.22: Final outcome with the Ghost Wall and the Wall'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.22：带有Ghost Wall和Wall的最终结果'
- en: '](img/B16183_06_22.jpg)'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_06_22.jpg)'
- en: 'Figure 6.22: Final outcome with the Ghost Wall and the Wall'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.22：带有Ghost Wall和Wall的最终结果
- en: You'll notice that when you hide your character behind the normal `Wall` (the
    one on the right), the enemy won't throw dodgeballs at the player; however, when
    you try to hide your character behind the `GhostWall` (the one on the left), even
    though the enemy can't go through it, the enemy will throw dodgeballs at the character
    and they will pass through the Wall as if it wasn't there!
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 当你把你的角色藏在普通的`Wall`（右边的那个）后面时，敌人不会向玩家扔躲避球；然而，当你试图把你的角色藏在`GhostWall`（左边的那个）后面时，即使敌人无法穿过它，敌人也会向角色扔躲避球，它们会穿过墙壁，就好像它不存在一样！
- en: And that concludes our exercise. We have made our `Wall` actors, which will
    either behave normally or ignore the enemies' lines of sight and dodgeballs!
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们的练习。我们已经制作了我们的`Wall`角色，它们将正常运作或者忽略敌人的视线和躲避球！
- en: Victory Box
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 胜利宝盒
- en: The next step in our project is going to be creating the `VictoryBox` actor.
    This actor will be responsible for ending the game when the player character enters
    it, given that the player has beaten the level. In order to do this, we'll be
    using the `Overlap` event. The following exercise will help us understand Victory
    Box.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目的下一步将是创建`VictoryBox`角色。这个角色将负责在玩家角色进入时结束游戏，前提是玩家已经通过了关卡。为了做到这一点，我们将使用`Overlap`事件。接下来的练习将帮助我们理解Victory
    Box。
- en: 'Exercise 6.05: Creating the VictoryBox class'
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.05：创建VictoryBox类
- en: In this exercise, we will be creating the `VictoryBox` class, which, when entered
    by the player character, will end the game.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建`VictoryBox`类，当玩家角色进入时，游戏将结束。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成这个练习：
- en: Create a new C++ class that inherits from the actor and call it `VictoryBox`.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个继承自角色的新的C++类，并将其命名为`VictoryBox`。
- en: Open that class's files in Visual Studio.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中打开该类的文件。
- en: 'Create a new `SceneComponent` property, which will be used as a `RootComponent`,
    just like we did with our `Wall` C++ class:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`SceneComponent`属性，它将被用作`RootComponent`，就像我们的`Wall`C++类一样：
- en: '`Header` file:'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Header`文件：'
- en: '[PRE39]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`Source` file:'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`源`文件：'
- en: '[PRE40]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Declare a `BoxComponent` in the header file that will check for overlap events
    with the player character, which should also be `private`:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头文件中声明一个`BoxComponent`，它将检查与玩家角色的重叠事件，也应该是`private`：
- en: '[PRE41]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Include the `BoxComponent` file in the class''s source file:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的源文件中包含`BoxComponent`文件：
- en: '[PRE42]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'After creating the `RootScene` Component, create the `BoxComponent`, which
    should also be `private`:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`RootScene`组件后，创建`BoxComponent`，它也应该是`private`：
- en: '[PRE43]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Attach it to the `RootComponent` using the `SetupAttachment` function:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`SetupAttachment`函数将其附加到`RootComponent`：
- en: '[PRE44]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Set its `BoxExtent` property to `60` units on all axes. This will cause the
    `BoxComponent` to be double that size `(120 x 120 x 120)`:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其`BoxExtent`属性设置为所有轴上的`60`单位。这将使`BoxComponent`的大小加倍为`(120 x 120 x 120)`：
- en: '[PRE45]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Offset its relative position on the *Z* axis by `120` units using the `SetRelativeLocation`
    function:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`SetRelativeLocation`函数将其相对位置在*Z*轴上偏移`120`单位：
- en: '[PRE46]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, you will require a function that will listen to the `BoxComponent`''s
    `OnBeginOverlap` event. This event will be called whenever an object enters the
    `BoxComponent`. This function must be preceded by the `UFUNCTION` macro, be `public`,
    return nothing, and have the following parameters:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你需要一个函数来监听`BoxComponent`的`OnBeginOverlap`事件。每当一个对象进入`BoxComponent`时，这个事件将被调用。这个函数必须在`UFUNCTION`宏之前，是`public`的，不返回任何内容，并具有以下参数：
- en: '[PRE47]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The parameters are as follows:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 参数如下：
- en: '`UPrimitiveComponent* OverlappedComp`: The component that was overlapped and
    belongs to this actor.'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UPrimitiveComponent* OverlappedComp`：被重叠并属于该角色的组件。'
- en: '`AActor* OtherActor`: The other actor involved in the overlap.'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AActor* OtherActor`：参与重叠的其他角色。'
- en: '`UPrimitiveComponent* OtherComp`: The component that was overlapped and belongs
    to the other actor.'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UPrimitiveComponent* OtherComp`：被重叠并属于其他角色的组件。'
- en: '`int32 OtherBodyIndex`: The index of the item in the primitive that was hit
    (usually useful for Instanced Static Mesh components).'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int32 OtherBodyIndex`：被击中的原始中的项目索引（通常对于实例化静态网格组件很有用）。'
- en: '`bool bFromSweep`: Whether the overlap originated from a Sweep Trace.'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool bFromSweep`：重叠是否起源于扫描跟踪。'
- en: '`FHitResult& SweepResult`: The data of the Sweep Trace resulting from the collision
    between this object and the other object.'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FHitResult& SweepResult`：由该对象与其他对象之间的碰撞产生的扫描跟踪的数据。'
- en: Note
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Although we won''t be using the `OnEndOverlap` event in this project, you will
    most likely need to use it sooner or later, so here''s the required function signature
    for that event, which looks very similar to the one we just learned about:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这个项目中不会使用`OnEndOverlap`事件，但你很可能以后会需要使用它，所以这是该事件的必需函数签名，它看起来与我们刚刚学到的那个函数非常相似：
- en: '`UFUNCTION()`'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '`UFUNCTION()`'
- en: '`void OnEndOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor,
    UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);`'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '`void OnEndOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor,
    UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);`'
- en: 'Next, we need to bind this function to the `BoxComponent`''s `OnComponentBeginOverlap`
    event:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将这个函数绑定到`BoxComponent`的`OnComponentBeginOverlap`事件上：
- en: '[PRE48]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Within our `OnBeginOverlap` function implementation, we''re going to check
    whether the actor we overlapped is a `DodgeballCharacter`. Because we''ll be referencing
    this class, we also need to include it:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的“OnBeginOverlap”函数实现中，我们将检查我们重叠的角色是否是“DodgeballCharacter”。因为我们将引用这个类，所以我们也需要包括它：
- en: '[PRE49]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If the actor we overlapped is a `DodgeballCharacter`, we want to quit the game.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重叠的角色是“DodgeballCharacter”，我们想要退出游戏。
- en: 'We will use `KismetSystemLibrary` for this purpose. The `KismetSystemLibrary`
    class contains useful functions for general use in your project:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用“KismetSystemLibrary”来实现这个目的。“KismetSystemLibrary”类包含了在项目中通用使用的有用函数：
- en: '[PRE50]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In order to quit the game, we will call `KismetSystemLibrary`''s `QuitGame`
    function. This function receives the following:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了退出游戏，我们将调用“KismetSystemLibrary”的“QuitGame”函数。这个函数接收以下内容：
- en: '[PRE51]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The important parameters from the preceding code snippet are explained as follows:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码片段中的重要参数解释如下：
- en: A `World` object, which we can access with the `GetWorld` function.
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个“World”对象，我们可以用“GetWorld”函数访问。
- en: A `PlayerController` object, which we will set to `nullptr`. We're doing this
    because this function will automatically find one this way.
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个“PlayerController”对象，我们将设置为“nullptr”。我们这样做是因为这个函数会自动这样找到一个。
- en: An `EQuitPreference` object, which means the way in which we want to end the
    game, by either quitting or just putting it as a background process. We will want
    to actually quit the game, and not just put it as a background process.
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个“EQuitPreference”对象，表示我们想要结束游戏的方式，是退出还是只将其作为后台进程。我们希望实际退出游戏，而不只是将其作为后台进程。
- en: A `bool`, which indicates whether we want to ignore the platform's restrictions
    when it comes to quitting the game, which we will set to `true`.
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个“bool”，表示我们是否想要忽略平台的限制来退出游戏，我们将设置为“true”。
- en: Next, we're going to create our Blueprint class.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建我们的蓝图类。
- en: 'Compile your changes, open the editor, go to the `Content` → `ThirdPersonCPP`
    → `Blueprint` directory inside the `Content Browser`, create a new Blueprint class
    that inherits from `VictoryBox`, and name it `BP_VictoryBox`. Open that asset
    and make the following modifications:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的更改，打开编辑器，转到“内容”→“ThirdPersonCPP”→“蓝图”目录，在“内容浏览器”中创建一个继承自“VictoryBox”的新蓝图类，并命名为“BP_VictoryBox”。打开该资产并进行以下修改：
- en: Add a new Static Mesh Component.
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个新的静态网格组件。
- en: Set its `StaticMesh` property to `Floor_400x400`.
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其“StaticMesh”属性设置为“Floor_400x400”。
- en: Set its `Material` property to `M_Metal_Gold`.
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其“材质”属性设置为“M_Metal_Gold”。
- en: Set its scale to `0.75` units on all three axes.
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其比例设置为所有三个轴上的“0.75”单位。
- en: Set its location to `(-150, -150, 20)`, on the *X*, *Y*, and *Z* axes, respectively.
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其位置设置为“（-150，-150，20）”，分别在*X*、*Y*和*Z*轴上。
- en: 'After you''ve made those changes, your Blueprint''s Viewport tab should look
    something like this:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在你做出这些改变之后，你的蓝图的视口选项卡应该看起来像这样：
- en: '![Figure 6.23: Victory box placed in the Blueprint''s Viewport tab'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.23：胜利盒放置在蓝图的视口选项卡中'
- en: '](img/B16183_06_23.jpg)'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_06_23.jpg)'
- en: 'Figure 6.23: Victory box placed in the Blueprint''s Viewport tab'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.23：胜利盒放置在蓝图的视口选项卡中
- en: 'Place that Blueprint in your level to test its functionality:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 将蓝图放在你的关卡中以测试其功能：
- en: '![Figure 6.24: Victory Box blueprint in the level for testing'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.24：用于测试的胜利盒蓝图在关卡中'
- en: '](img/B16183_06_24.jpg)'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_06_24.jpg)'
- en: 'Figure 6.24: Victory Box blueprint in the level for testing'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.24：用于测试的胜利盒蓝图在关卡中
- en: If you play the level and step onto the golden plate (and overlap the collision
    box), you'll notice that the game abruptly ends, as intended.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你玩这个关卡并踏上金色的板子（并重叠碰撞箱），你会注意到游戏突然结束，这是预期的。
- en: And with that, we conclude our `VictoryBox` class! You now know how to use the
    overlap events in your own projects. There's a multitude of game mechanics that
    you can create using these events, so congratulations on completing this exercise.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们结束了“VictoryBox”类！你现在知道如何在你自己的项目中使用重叠事件。使用这些事件，你可以创建多种游戏机制，恭喜你完成了这个练习。
- en: We are now very close to reaching the end of this chapter, where we'll be completing
    a new activity, but first, we'll need to make some modifications to our `DodgeballProjectile`
    class, namely adding a getter function to its `ProjectileMovementComponent`, which
    we'll be doing in the next exercise.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在非常接近完成本章的结尾，我们将完成一个新的活动，但首先，我们需要对我们的“DodgeballProjectile”类进行一些修改，即在下一个练习中添加一个getter函数到它的“ProjectileMovementComponent”。
- en: A getter function is a function that only returns a specific property and does
    nothing else. These functions are usually marked as inline, which means that,
    when the code compiles, a call to that function will simply be replaced with its
    content. They are also usually marked as `const`, given that they don't modify
    any of the class's properties.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 一个getter函数是一个只返回特定属性并且不做其他事情的函数。这些函数通常被标记为内联，这意味着当代码编译时，对该函数的调用将简单地被替换为它的内容。它们通常也被标记为“const”，因为它们不修改类的任何属性。
- en: 'Exercise 6.06: Adding the ProjectileMovementComponent Getter Function in DodgeballProjectile'
  id: totrans-488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.06：在DodgeballProjectile中添加ProjectileMovementComponent Getter函数
- en: In this exercise, we will be adding a getter function to the `DodgeballProjectile`
    class's `ProjectileMovement` property so that other classes can access it and
    modify its properties. We will be doing the same in this chapter's activity.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将向“DodgeballProjectile”类的“ProjectileMovement”属性添加一个getter函数，以便其他类可以访问它并修改它的属性。我们将在本章的活动中做同样的事情。
- en: 'In order to do this, you''ll need to follow these steps:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，你需要按照以下步骤进行：
- en: Open the `DodgeballProjectile` class's header file in Visual Studio.
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中打开“DodgeballProjectile”类的头文件。
- en: 'Add a new `public` function called `GetProjectileMovementComponent`. This function
    will be an inline function, which in UE4''s version of C++ is replaced with the
    `FORCEINLINE` macro. The function should also return a `UProjectileMovementComponent*`
    and be a `const` function:'
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`GetProjectileMovementComponent`的新`public`函数。这个函数将是一个内联函数，在UE4的C++版本中用`FORCEINLINE`宏替换。该函数还应返回一个`UProjectileMovementComponent*`并且是一个`const`函数：
- en: '[PRE52]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When using the `FORCEINLINE` macro for a specific function, you can't add the
    declaration of that function to the header file and its implementation to the
    source file. Both must be done simultaneously in the header file, as shown previously.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定函数使用`FORCEINLINE`宏时，不能将该函数的声明添加到头文件中，然后将其实现添加到源文件中。两者必须同时在头文件中完成，如前所示。
- en: With that, we conclude this quick exercise. Here, we have added a simple `getter`
    function to our `DodgeballProjectile` class, which we will be using in this chapter's
    activity, where we'll replace the `SpawnActor` function within the `EnemyCharacter`
    class with the `SpawnActorDeferred` function. This will allow us to safely edit
    our `DodgeballProjectile` class's properties before we spawn an instance of it.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们完成了这个快速练习。在这里，我们为`DodgeballProjectile`类添加了一个简单的`getter`函数，我们将在本章的活动中使用它，在这里，我们将在`EnemyCharacter`类中用`SpawnActorDeferred`函数替换`SpawnActor`函数。这将允许我们在生成实例之前安全地编辑`DodgeballProjectile`类的属性。
- en: 'Activity 6.01: Replacing the SpawnActor Function with SpawnActorDeferred in
    EnemyCharacter'
  id: totrans-497
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动6.01：在EnemyCharacter中用SpawnActorDeferred替换SpawnActor函数
- en: In this activity, you will be changing the EnemyCharacter's `ThrowDodgeball`
    function in order to use the `SpawnActorDeferred` function instead of the `SpawnActor`
    function so that we can change the `DodgeballProjectile`'s `InitialSpeed` before
    spawning it.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，您将更改EnemyCharacter的`ThrowDodgeball`函数，以便使用`SpawnActorDeferred`函数而不是`SpawnActor`函数，以便在生成之前更改`DodgeballProjectile`的`InitialSpeed`。
- en: 'The following steps will help you complete this activity:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此活动：
- en: Open the `EnemyCharacter` class's source file in Visual Studio.
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中打开`EnemyCharacter`类的源文件。
- en: Go to the `ThrowDodgeball` function's implementation.
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`ThrowDodgeball`函数的实现。
- en: Because the `SpawnActorDeferred` function can't just receive a spawn location
    and rotation properties, and must instead receive an `FTransform` property, we'll
    need to create one of those before we call that function. Let's call it `SpawnTransform`
    and send the spawn rotation and location, in that order, as inputs for its constructor,
    which will be this enemy's rotation and the `SpawnLocation` property, respectively.
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为`SpawnActorDeferred`函数不能只接收生成位置和旋转属性，而必须接收一个`FTransform`属性，所以我们需要在调用该函数之前创建一个。让我们称之为`SpawnTransform`，并按顺序发送生成旋转和位置作为其构造函数的输入，这将是这个敌人的旋转和`SpawnLocation`属性，分别。
- en: Then, update the `SpawnActor` function call into the `SpawnActorDeferred` function
    call. Instead of sending the spawn location and spawn rotation as its second and
    third parameters, replace those with the `SpawnTransform` properties we just created,
    as the second parameter.
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将`SpawnActor`函数调用更新为`SpawnActorDeferred`函数调用。将生成位置和生成旋转作为其第二个和第三个参数发送，将这些替换为我们刚刚创建的`SpawnTransform`属性作为第二个参数。
- en: Make sure you save the return value of this function call inside a `ADodgeballProjectile*`
    property called `Projectile`.
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保将此函数调用的返回值保存在名为`Projectile`的`ADodgeballProjectile*`属性中。
- en: After you've done this, you will have successfully created a new `DodgeballProjectile`
    object. However, we still need to change its `InitialSpeed` property and actually
    spawn it
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，您将成功创建一个新的`DodgeballProjectile`对象。但是，我们仍然需要更改其`InitialSpeed`属性并实际生成它。
- en: After you've called the `SpawnActorDeferred` function, call the `Projectile`
    property's `GetProjectileMovementComponent` function, which returns its Projectile
    Movement Component, and change its `InitialSpeed` property to `2200` units.
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`SpawnActorDeferred`函数后，调用`Projectile`属性的`GetProjectileMovementComponent`函数，该函数返回其Projectile
    Movement Component，并将其`InitialSpeed`属性更改为`2200`单位。
- en: Because we'll be accessing properties belonging to the Projectile Movement Component
    inside the `EnemyCharacter` class, we'll need to include that component, just
    like we did in *Exercise 6.02*, *Adding a Projectile Movement Component to DodgeballProjectile*.
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们将在`EnemyCharacter`类中访问属于Projectile Movement Component的属性，所以我们需要像在*Exercise
    6.02*，*Adding a Projectile Movement Component to DodgeballProjectile*中那样包含该组件。
- en: After you've changed the value of the `InitialSpeed` property, the only thing
    left to do is call the `Projectile` property's `FinishSpawning` function, which
    will receive the `SpawnTransform` property we created as a parameter.
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在更改`InitialSpeed`属性的值后，唯一剩下的事情就是调用`Projectile`属性的`FinishSpawning`函数，该函数将接收我们创建的`SpawnTransform`属性作为参数。
- en: After you've done this, compile your changes and open the editor.
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，编译更改并打开编辑器。
- en: 'Expected output:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出：
- en: '![Figure 6.25: Dodgeball thrown at the player'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.25：向玩家投掷躲避球'
- en: '](img/B16183_06_25.jpg)'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_06_25.jpg)'
- en: 'Figure 6.25: Dodgeball thrown at the player'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.25：向玩家投掷躲避球
- en: Note
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在以下网址找到：[https://packt.live/338jEBx](https://packt.live/338jEBx)。
- en: By completing this activity, you've consolidated the use of the `SpawnActorDeferred`
    function and know how to use it in your future projects.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成此活动，您已巩固了`SpawnActorDeferred`函数的使用，并知道如何在将来的项目中使用它。
- en: Summary
  id: totrans-517
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you've learned how to affect an object with physics simulations,
    create your own Object Types and Collision Presets, use the `OnHit`, `OnBeginOverlap`,
    and `OnEndOverlap` events, update an object's Physical Material, and use timers.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学会了如何使用物理模拟影响对象，创建自己的对象类型和碰撞预设，使用`OnHit`，`OnBeginOverlap`和`OnEndOverlap`事件，更新对象的物理材料以及使用定时器。
- en: Now that you've learned these fundamental concepts of collision topics, you'll
    be able to come up with new and creative ways to use them when creating your own
    projects.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了碰撞主题的这些基本概念，你将能够想出新的创造性方式来运用它们，从而创建你自己的项目。
- en: In the next chapter, we'll be taking a look at Actor Components, Interfaces,
    and Blueprint Function Libraries, which are very useful for keeping your project's
    complexity manageable and highly modular, thereby allowing you to easily take
    parts of one project and add them to another.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一下角色组件、接口和蓝图函数库，这些对于保持项目的复杂性可控和高度模块化非常有用，因此可以轻松地将一个项目的部分添加到另一个项目中。
