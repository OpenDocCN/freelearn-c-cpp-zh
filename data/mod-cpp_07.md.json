["```cpp\n    #ifdef TEST \n       cout << \"TEST defined\" << endl;     \n    #else \n       cout << \"TEST not defined\" << endl; \n    #endif\n```", "```cpp\n    #if TEST < 0 \n       cout << \"negative\" << endl; \n    #elif TEST > 0 \n       cout << \"positive\" << endl; \n    #else \n       cout << \"zero or undefined\" << endl; \n    #endif\n```", "```cpp\n    cl /EHsc prog.cpp /DTEST=1\n```", "```cpp\n    vector<int> data = get_data(); \n    #if TRACE_LEVEL > 0 \n    cout << \"number of data items returned: \" << data.size() << endl; \n    #endif\n```", "```cpp\n    #pragma warning(push,3)\n```", "```cpp\n    #pragma warning(pop)\n```", "```cpp\n    #pragma warning(disable: 4189)\n```", "```cpp\n    #pragma warning(2: 4333) \n    unsigned shift8(unsigned char c)  \n    { \n        return c >> 8;  \n    } \n    #pragma warning(default: 4333)\n```", "```cpp\n    // TODO: potential data loss, review use of shift8 function \n    unsigned shift8(unsigned char c)  \n    { \n        return c >> 8;  \n    }\n```", "```cpp\n    #pragma message(\"review use of shift8 function\") \n    unsigned shift8(unsigned char c)  \n    { \n        return c >> 8;  \n    }\n```", "```cpp\n Microsoft (R) C/C++ Optimizing Compiler Version 19.00.24215.1 for x86\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\ntest.cpp\nreview the use of shift8 function\ntest.cpp(8): warning C4333: '>>': right shift by too large amount, data loss\n```", "```cpp\n    #ifndef __cplusplus \n    #error C++ compiler required. \n    #endif\n```", "```cpp\n    #ifndef __cplusplus \n    static_assert(false, \"Compile with /TP\"); \n    #endif \n    #include <iostream> // needs the C++ compiler\n```", "```cpp\n    #include <type_traits> \n\n    template <class T> \n    void func(T& value) \n    { \n        static_assert(std::is_class<T>::value, \"T must be a class\"); \n        // other code \n    }\n```", "```cpp\n    func(string(\"hello\")); \n    func(\"hello\");\n```", "```cpp\nMicrosoft (R) C/C++ Optimizing Compiler Version 19.00.24215.1 for x86\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\ntest.cpp\ntest.cpp(25): error C2338: T must be a class\ntest.cpp(39): note: see reference to function template instantiation \n\n'void func<const char*>(T)' being compiled\nwith\n[\n T=const char *\n]\n```", "```cpp\n    #ifdef _DEBUG \n       cout << \"debug build\" << endl; \n    #else \n       cout << \"release built\" << endl; \n    #endif\n```", "```cpp\n    #ifdef _DEBUG \n    #define TRACE cout << __func__ << \" (\" << __LINE__ << \")\" << endl; \n    #else \n    #define TRACE \n    #endif\n```", "```cpp\n    DEVELOPER=\"$(USERNAME)\"\n```", "```cpp\n    cout << \"Compiled by \" << DEVELOPER << endl;\n```", "```cpp\n    /DDEVELOPER=\"$(USERNAME)\"\n```", "```cpp\n    path_to_source_file(line) message\n```", "```cpp\n    #define AT_FILE(msg) __FILE__ \" \" msg \n\n    #pragma message(AT_FILE(\"this is a message\"))\n```", "```cpp\n    c:\\Beginning_C++Chapter_10test.cpp this is a message\n```", "```cpp\n    #define STRING2(x) #x \n    #define STRING(x) STRING2(x) \n    #define AT_FILE(msg) __FILE__ \"(\" STRING(__LINE__) \") \" msg\n```", "```cpp\n    ofstream file; \n    if (!file.open(argv[1], ios::out)) \n    { \n        clog << \"cannot open \" << argv[1] << endl; \n        return 1; \n    }\n```", "```cpp\n    clog << \"clog\" << endl; \n    cerr << \"cerrn\"; \n    cout << \"cout\" << endl;\n```", "```cpp\nC:\\Beginning_C++\\Chapter_10>app\nclog\ncerr\ncout\n```", "```cpp\nC:\\Beginning_C++\\Chapter_10>app 2>log.txt\ncout\n\nC:\\Beginning_C++\\Chapter_10>type log.txt\nclog\ncerr\n```", "```cpp\n    extern void run_code(); \n\n    int main() \n    { \n        ofstream log_file; \n        if (log_file.open(\"log.txt\")) clog.rdbuf(log_file.rdbuf()); \n\n        run_code(); \n\n        clog.flush(); \n        log_file.close(); \n        clog.rdbuf(nullptr); \n        return 0; \n    }\n```", "```cpp\n    include <crtdbg.h> \n\n    extern void run_code(); \n\n    int main() \n    { \n        _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_DEBUG); \n        _RPTF0(_CRT_WARN, \"Application startedn\"); \n\n        run_code(); \n\n        _RPTF0(_CRT_WARN, \"Application endedn\"); \n        return 0; \n    }\n```", "```cpp\n    #define WIN32_LEAN_AND_MEAN \n    #include <Windows.h> \n    #include <crtdbg.h>\n```", "```cpp\n    HANDLE file =  \n       CreateFileA(\"log.txt\", GENERIC_WRITE, 0, 0, CREATE_ALWAYS, 0, 0); \n    _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE); \n    _CrtSetReportFile(_CRT_WARN, file); \n    _RPTF0(_CRT_WARN, \"Application startedn\"); \n\n    run_code(); \n\n    _RPTF0(_CRT_WARN, \"Application endedn\"); \n    CloseHandle(file);\n```", "```cpp\n    extern void run_code(); \n\n    int main() \n    { \n        #ifdef _DEBUG \n            OutputDebugStringA(\"Application startedn\"); \n        #endif \n\n        run_code(); \n\n        #ifdef _DEBUG \n           OutputDebugStringA(\"Application endedn\"); \n        #endif \n        return 0; \n    }\n```", "```cpp\n    const int MAGIC=9; \n\n    char get_data(char *p, size_t size) \n    { \n        assert((p != nullptr)); \n        assert((size >= MAGIC)); \n        return p[MAGIC]; \n    }\n```", "```cpp\n    #ifndef _DEBUG \n    #define NDEBUG \n    #endif\n```", "```cpp\n    _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE); \n    _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDOUT); \n\n    int i = 99; \n    _ASSERTE((i > 100));\n```", "```cpp\n    test.cpp(23) : Assertion failed: (i > 100)\n```", "```cpp\n    int i = 99; \n    if (i <= 100) _CrtDbgBreak();\n```", "```cpp\n    HANDLE file = CreateFileA( \n        \"does_not_exist\", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0); \n    if (INVALID_HANDLE_VALUE == file) \n    { \n        DWORD err = GetLastError(); \n        char *str; \n        DWORD ret = FormatMessageA( \n            FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_ALLOCATE_BUFFER, \n            0, err, LANG_USER_DEFAULT, reinterpret_cast<LPSTR>(&str),  \n            0, 0); \n        cout << \"Error: \"<< str << endl; \n        LocalFree(str); \n    } \n    else \n    { \n        CloseHandle(file); \n    }\n```", "```cpp\n    Error: The system cannot find the file specified.\n```", "```cpp\n    LanguageNames = (British = 0x0409:MSG00409) \n    LanguageNames = (French  = 0x040c:MSG0040C) \n\n    MessageId       = 1 \n    SymbolicName    = IDS_GREETING \n    Language        = English \n    Hello \n    . \n    Language        = British \n    Good day \n    . \n    Language        = French \n    Salut \n    .\n```", "```cpp\n    LANGUAGE 0xc,0x1 \n    1 11 \"MSG0040C.bin\" \n    LANGUAGE 0x9,0x1 \n    1 11 \"MSG00001.bin\" \n    LANGUAGE 0x9,0x1 \n    1 11 \"MSG00409.bin\"\n```", "```cpp\n    double reciprocal(double d) \n    { \n        if (d == 0)  \n        { \n            // throw 0; \n            // throw \"divide by zero\"; \n            // throw new exception(\"divide by zero\"); \n            throw exception(\"divide by zero\"); \n        } \n        return 1.0 / d; \n    }\n```", "```cpp\n    try  \n    { \n        string s(\"this is an object\"); \n        vector<int> v = { 1, 0, -1}; \n        reciprocal(v[0]); \n        reciprocal(v[1]); \n        reciprocal(v[2]); \n    } \n    catch(exception& e) \n    { \n        cout << e.what() << endl; \n    }\n```", "```cpp\n    class test \n    { \n        string str; \n    public: \n        test() : str(\"\") {} \n        test(const string& s) : str(s) {} \n        ~test() \n        { \n            cout << boolalpha << str << \" uncaught exception = \" \n             << uncaught_exception() << endl; \n        } \n    };\n```", "```cpp\n    void f(bool b) \n    { \n        test t(\"auto f\"); \n        cout << (b ? \"f throwing exception\" : \"f running fine\")  \n            << endl; \n        if (b) throw exception(\"f failed\"); \n    } \n\n    int main() \n    { \n        test t1(\"auto main\"); \n        try \n        { \n            test t2(\"in try in main\"); \n            f(false); \n            f(true); \n            cout << \"this will never be printed\"; \n        } \n        catch (exception& e) \n        { \n            cout << e.what() << endl; \n        } \n        return 0; \n    }\n```", "```cpp\n f running fine\n auto f uncaught exception = false\n f throwing exception\n auto f uncaught exception = true\n in try in main uncaught exception = true\n f failed\n auto main uncaught exception = false\n```", "```cpp\n    try  \n    { \n        call_code(); \n    } \n    catch(invalid_argument& iva) \n    { \n        cout << \"invalid argument: \" << e.what() << endl; \n    } \n    catch(exception& exc) \n    { \n        cout << typeid(exc).name() << \": \" << e.what() << endl; \n    } \n    catch(...) \n    { \n        cout << \"some other C++ exception\" << endl; \n    }\n```", "```cpp\n    exception_ptr eptr = nullptr; \n\n    void first_thread() \n    { \n        try  \n        { \n            call_code(); \n        } \n        catch (...)  \n        { \n            eptr = current_exception();  \n        } \n        // some signalling mechanism ... \n    } \n\n    void second_thread() \n    { \n        // other code \n\n        // ... some signalling mechanism \n        if (eptr != nullptr)  \n        { \n            try \n            { \n                rethrow_exception(eptr); \n            } \n            catch(my_exception& e) \n            { \n                // process this exception \n            } \n            eptr = nullptr; \n        } \n        // other code \n    }\n```", "```cpp\n    void test(double d) \n    { \n        try \n        { \n            cout << setw(10) << d << setw(10) << reciprocal(d) << endl; \n        } \n\n        catch (exception& e) \n        { \n            cout << \"error: \" << e.what() << endl; \n        } \n    }\n```", "```cpp\n    void test(double d) \n    try \n    { \n        cout << setw(10) << d << setw(10) << reciprocal(d) << endl; \n    } \n    catch (exception& e) \n    { \n        cout << \"error: \" << e.what() << endl; \n    }\n```", "```cpp\n    class inverse \n    { \n        double recip; \n    public: \n        inverse() = delete; \n        inverse(double d) recip(reciprocal(d)) {} \n        double get_recip() const { return recip; } \n    };\n```", "```cpp\n    inverse::inverse(double d)  \n    {  \n        try { recip = reciprocal(d); } \n        catch(exception& e) { cout << \"invalid value \" << d << endl; } \n    }\n```", "```cpp\n    inverse::inverse(double d)  \n    try \n        : recip (reciprocal(d)) {}  \n    catch(exception& e) { cout << \"invalid value \" << d << endl; }\n```", "```cpp\n    HANDLE file = CreateFileA( \n       \"does_not_exist\", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0); \n    if (INVALID_HANDLE_VALUE == file) \n    { \n        throw system_error(GetLastError(), system_category()); \n    } \n    else \n    { \n        CloseHandle(file); \n    }\n```", "```cpp\n    void open(const char *filename) \n    { \n        try  \n        { \n            ifstream file(filename); \n            file.exceptions(ios_base::failbit); \n            // code if the file exists \n        } \n        catch (exception& e)  \n        { \n            throw_with_nested( \n                system_error(ENOENT, system_category(), filename)); \n        } \n    }\n```", "```cpp\n    try \n    { \n        open(\"does_not_exist\"); \n    } \n    catch (exception& e) \n    { \n        cout << e.what() << endl; \n    }\n```", "```cpp\n does_not_exist: The system cannot find the file specified.\n```", "```cpp\n    void print_exception(exception& outer) \n    { \n        cout << outer.what() << endl; \n        try { rethrow_if_nested(outer); } \n        catch (exception& inner) { print_exception(inner); } \n    }\n```", "```cpp\n    does_not_exist: The system cannot find the file specified. \n    ios_base::failbit set: iostream stream error\n```", "```cpp\n    char* pPageBuffer; \n    unsigned long curPages = 0; \n    const unsigned long PAGESIZE = 4096; \n    const unsigned long PAGECOUNT = 10; \n\n    int main() \n    { \n        void* pReserved = VirtualAlloc( \n        nullptr, PAGECOUNT * PAGESIZE, MEM_RESERVE, PAGE_NOACCESS); \n        if (nullptr == pReserved)  \n        { \n            cout << \"allocation failed\" << endl; \n            return 1; \n        } \n\n        char *pBuffer = static_cast<char*>(pReserved); \n        pPageBuffer = pBuffer; \n\n        for (int i = 0; i < PAGECOUNT * PAGESIZE; ++i) \n        { \n            __try { pBuffer[i] = 'X'; } __except (exception_filter(GetExceptionCode())) { cout << \"Exiting process.n\"; ExitProcess(GetLastError()); } \n        } \n        VirtualFree(pReserved, 0, MEM_RELEASE); \n        return 0; \n    }\n```", "```cpp\n    int exception_filter(unsigned int code) \n    { \n        if (code != EXCEPTION_ACCESS_VIOLATION) \n        { \n            cout << \"Exception code = \" << code << endl; \n            return EXCEPTION_EXECUTE_HANDLER; \n        } \n\n        if (curPage >= PAGECOUNT) \n        { \n            cout << \"Exception: out of pages.n\"; \n            return EXCEPTION_EXECUTE_HANDLER; \n        } \n\n        if (VirtualAlloc(static_cast<void*>(pPageBuffer), PAGESIZE, \n         MEM_COMMIT, PAGE_READWRITE) == nullptr) \n        { \n            cout << \"VirtualAlloc failed.n\"; \n            return EXCEPTION_EXECUTE_HANDLER; \n        } \n\n        curPage++; \n        pPageBuffer += PAGESIZE; \n        return EXCEPTION_CONTINUE_EXECUTION; \n    }\n```", "```cpp\n    try  \n    { \n        RaiseException(1, 0, 0, nullptr); \n    } \n    // legal code, but don't do it \n    catch(...) \n    { \n        cout << \"SEH or C++ exception caught\" << endl; \n    }\n```", "```cpp\n    void func(unsigned int, EXCEPTION_POINTERS*);\n```", "```cpp\n    void seh_to_cpp(unsigned int code, EXCEPTION_POINTERS*) \n    { \n        if (code == 1) throw exception(\"my error\"); \n    }\n```", "```cpp\n    _set_se_translator(seh_to_cpp); \n    try  \n    { \n        RaiseException(1, 0, 0, nullptr); \n    } \n    catch(exception& e) \n    { \n        cout << e.what() << endl; \n    }\n```", "```cpp\n    double reciprocal(double d) \n    { \n        return 1.0 / d; \n    } \n\n    void seh_to_cpp(unsigned int code, EXCEPTION_POINTERS*) \n    { \n        if (STATUS_FLOAT_DIVIDE_BY_ZERO == code || \n            STATUS_INTEGER_DIVIDE_BY_ZERO == code) \n        { \n            throw invalid_argument(\"divide by zero\"); \n        } \n    }\n```", "```cpp\n    _set_se_translator(seh_to_cpp); \n    try  \n    { \n        reciprocal(0.0); \n    } \n    catch(invalid_argument& e) \n    { \n        cout << e.what() << endl; \n    }\n```"]