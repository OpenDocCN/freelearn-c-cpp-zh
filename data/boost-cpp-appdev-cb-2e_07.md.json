["```cpp\n#include <string> \nstd::string str1 = \"Thanks for reading me!\"; \nstd::string str2 = \"Thanks for reading ME!\"; \n```", "```cpp\n#include <boost/algorithm/string/predicate.hpp> \n\nconst bool solution_1 = (\n     boost::iequals(str1, str2)\n);\n```", "```cpp\n#include <boost/algorithm/string/compare.hpp> \n#include <algorithm> \n\nconst bool solution_2 = (\n    str1.size() == str2.size() && std::equal(\n        str1.begin(),\n        str1.end(),\n        str2.begin(),\n        boost::is_iequal()\n    )\n);\n```", "```cpp\n#include <boost/algorithm/string/case_conv.hpp> \n\nvoid solution_3() {\n    std::string str1_low = boost::to_lower_copy(str1);\n    std::string str2_low = boost::to_lower_copy(str2);\n    assert(str1_low == str2_low);\n}\n```", "```cpp\n#include <boost/algorithm/string/case_conv.hpp> \n\nvoid solution_4() {\n    std::string str1_up = boost::to_upper_copy(str1);\n    std::string str2_up = boost::to_upper_copy(str2);\n    assert(str1_up == str2_up);\n}\n```", "```cpp\n#include <boost/algorithm/string/case_conv.hpp> \n\nvoid solution_5() {\n    boost::to_lower(str1);\n    boost::to_lower(str2);\n    assert(str1 == str2);\n}\n```", "```cpp\n  // On some platforms std::locale::classic() works \n  // faster than std::locale().\n  boost::iequals(str1, str2, std::locale::classic()); \n```", "```cpp\n#include <boost/regex.hpp> \n#include <iostream> \n```", "```cpp\nint main() { \n    std::cout  \n        << \"Available regex syntaxes:\\n\" \n        << \"\\t[0] Perl\\n\" \n        << \"\\t[1] Perl case insensitive\\n\" \n        << \"\\t[2] POSIX extended\\n\" \n        << \"\\t[3] POSIX extended case insensitive\\n\" \n        << \"\\t[4] POSIX basic\\n\" \n        << \"\\t[5] POSIX basic case insensitive\\n\\n\" \n        << \"Choose regex syntax: \"; \n```", "```cpp\n    boost::regex::flag_type flag;\n    switch (std::cin.get()) \n    {\n    case '0': flag = boost::regex::perl;\n        break;\n\n    case '1': flag = boost::regex::perl|boost::regex::icase;\n        break;\n\n    case '2': flag = boost::regex::extended;\n        break;\n\n    case '3': flag = boost::regex::extended|boost::regex::icase;\n        break;\n\n    case '4': flag = boost::regex::basic;\n        break;\n\n    case '5': flag = boost::regex::basic|boost::regex::icase;\n        break;\n    default:\n        std::cout << \"Incorrect number of regex syntax. Exiting...\\n\";\n        return 1;\n    }\n\n    // Disabling exceptions.\n    flag |= boost::regex::no_except;\n```", "```cpp\n    // Restoring std::cin.\n    std::cin.ignore();\n    std::cin.clear();\n\n    std::string regex, str;\n    do {\n        std::cout << \"Input regex: \";\n        if (!std::getline(std::cin, regex) || regex.empty()) {\n            return 0;\n        }\n\n        // Without `boost::regex::no_except`flag this\n        // constructor may throw.\n        const boost::regex e(regex, flag);\n        if (e.status()) {\n            std::cout << \"Incorrect regex pattern!\\n\";\n            continue;\n        }\n```", "```cpp\n        std::cout << \"String to match: \";\n        while (std::getline(std::cin, str) && !str.empty()) {\n```", "```cpp\n            const bool matched = boost::regex_match(str, e);\n            std::cout << (matched ? \"MATCH\\n\" : \"DOES NOT MATCH\\n\");\n            std::cout << \"String to match: \";\n        } // end of `while (std::getline(std::cin, str))`\n```", "```cpp\n        // Restoring std::cin.\n        std::cin.ignore();\n        std::cin.clear();\n    } while (1);\n} // int main() \n```", "```cpp\n Available regex syntaxes:\n```", "```cpp\n [0] Perl\n [1] Perl case insensitive\n [2] POSIX extended\n [3] POSIX extended case insensitive\n [4] POSIX basic\n [5] POSIX basic case insensitive\n```", "```cpp\nChoose regex syntax: 0\n Input regex: (\\d{3}[#-]){2}\n String to match: 123-123#\n MATCH\n String to match: 312-321-\n MATCH\n String to match: 21-123-\n DOES NOT MATCH\n String to match: ^Z\n Input regex: \\l{3,5}\n String to match: qwe\n MATCH\n String to match: qwert\n MATCH\n String to match: qwerty\n DOES NOT MATCH\n String to match: QWE\n DOES NOT MATCH\n String to match: ^Z\n\n Input regex: ^Z\n Press any key to continue . . .\n```", "```cpp\n        if (e.status()) {\n            std::cout << \"Incorrect regex pattern!\\n\";\n            continue;\n        }\n```", "```cpp\nInput regex: (incorrect regex(\nIncorrect regex pattern!\n```", "```cpp\n Available regex syntaxes:\n```", "```cpp\n [0] Perl\n [1] Perl case insensitive\n [2] POSIX extended\n [3] POSIX extended case insensitive\n [4] POSIX basic\n [5] POSIX basic case insensitive\n```", "```cpp\n\n Choose regex syntax: 0\n Input regex: (\\d)(\\d)\n String to match: 00\n MATCH: 0, 0,\n Replace pattern: \\1#\\2\n RESULT: 0#0\n String to match: 42\n MATCH: 4, 2,\n Replace pattern: ###\\1-\\1-\\2-\\1-\\1###\n RESULT: ###4-4-2-4-4###\n```", "```cpp\n    std::string regex, str, replace_string;\n```", "```cpp\n        std::cout << \"String to match: \";\n        while (std::getline(std::cin, str) && !str.empty()) {\n            boost::smatch results;\n            const bool matched = regex_search(str, results, e);\n            if (matched)  {\n                std::cout << \"MATCH: \";\n                std::copy(\n                    results.begin() + 1, \n                    results.end(), \n                    std::ostream_iterator<std::string>(std::cout, \", \")\n                );\n```", "```cpp\n                std::cout << \"\\nReplace pattern: \";\n                if (\n                        std::getline(std::cin, replace_string)\n                        && !replace_string.empty())\n                {\n                    std::cout << \"RESULT: \" << \n                        boost::regex_replace(str, e, replace_string)\n                    ; \n                } else {\n                    // Restoring std::cin.\n                    std::cin.ignore();\n                    std::cin.clear();\n                }\n            } else { // `if (matched) `\n                std::cout << \"DOES NOT MATCH\";\n            }\n```", "```cpp\n    std::copy( \n        results.begin() + 1,  \n        results.end(),  \n        std::ostream_iterator<std::string>( std::cout, \", \") \n    ); \n```", "```cpp\nstd::cout << \"RESULT: \" << boost::regex_replace(str, e, replace_string); \n```", "```cpp\nstd::cout << \"RESULT: \" << results.format(replace_string); \n```", "```cpp\nInput regex: (\\d)(\\d)\n String to match: 12\n MATCH: 1, 2,\n Replace pattern: $1-$2---$&---$$\n RESULT: 1-2---12---$\n```", "```cpp\nclass i_hold_some_internals \n{\n    int i;\n    std::string s;\n    char c;\n    // ...\n}; \n```", "```cpp\n#include <boost/format.hpp>\n```", "```cpp\n    // `fmt` parameter may contain the following:\n    // $1$ for outputting integer 'i'.\n    // $2$ for outputting string 's'.\n    // $3$ for outputting character 'c'.\n    std::string to_string(const std::string& fmt) const {\n```", "```cpp\n        boost::format f(fmt);\n        unsigned char flags = boost::io::all_error_bits;\n        flags ^= boost::io::too_many_args_bit;\n        f.exceptions(flags);\n        return (f % i % s % c).str();\n    }\n```", "```cpp\nint main() {\n    i_hold_some_internals class_instance;\n\n    std::cout << class_instance.to_string(\n        \"Hello, dear %2%! \"\n        \"Did you read the book for %1% %% %3%\\n\"\n    );\n\n    std::cout << class_instance.to_string(\n        \"%1% == %1% && %1%%% != %1%\\n\\n\"\n    );\n}\n```", "```cpp\n Hello, dear Reader! Did you read the book for 100 % !\n 100 == 100 && 100% != 100\n```", "```cpp\n    boost::format f(format_specifier);\n    unsigned char flags = boost::io::all_error_bits;\n    flags ^= boost::io::too_many_args_bit;\n```", "```cpp\n    // Outputs 'Reader'.\n    std::cout << class_instance.to_string(\"%2%\\n\\n\");\n```", "```cpp\n    try {\n        class_instance.to_string(\"%1% %2% %3% %4% %5%\\n\");\n        assert(false);\n    } catch (const std::exception& e) {\n        // boost::io::too_few_args exception is catched.\n        std::cout << e.what() << '\\n';\n    }\n```", "```cpp\n boost::too_few_args: format-string referred to more arguments than\n    were passed\n```", "```cpp\n#include <string> \nconst std::string str = \"Hello, hello, dear Reader.\"; \n```", "```cpp\n#include <boost/algorithm/string/erase.hpp>\n\nvoid erasing_examples() {\n    namespace ba = boost::algorithm;\n    using std::cout;\n\n    cout << \"\\n erase_all_copy :\" << ba::erase_all_copy(str, \",\");\n    cout << \"\\n erase_first_copy:\" << ba::erase_first_copy(str, \",\");\n    cout << \"\\n erase_last_copy :\" << ba::erase_last_copy(str, \",\");\n    cout << \"\\n ierase_all_copy :\" << ba::ierase_all_copy(str, \"hello\");\n    cout << \"\\n ierase_nth_copy :\" << ba::ierase_nth_copy(str, \",\", 1);\n}\n```", "```cpp\n erase_all_copy   :Hello hello dear Reader.\n erase_first_copy :Hello hello, dear Reader.\n erase_last_copy  :Hello, hello dear Reader.\n ierase_all_copy   :, , dear Reader.\n ierase_nth_copy  :Hello, hello dear Reader.\n```", "```cpp\n#include <boost/algorithm/string/replace.hpp>\n\nvoid replacing_examples() {\n    namespace ba = boost::algorithm;\n    using std::cout;\n\n    cout << \"\\n replace_all_copy :\" \n        << ba::replace_all_copy(str, \",\", \"!\");\n\n    cout << \"\\n replace_first_copy :\"\n        << ba::replace_first_copy(str, \",\", \"!\");\n\n    cout << \"\\n replace_head_copy :\"\n        << ba::replace_head_copy(str, 6, \"Whaaaaaaa!\");\n}\n```", "```cpp\n replace_all_copy :Hello! hello! dear Reader.\n replace_first_copy :Hello! hello, dear Reader.\n replace_head_copy :Whaaaaaaa! hello, dear Reader.\n```", "```cpp\n#include <boost/algorithm/string/erase.hpp>\n\nvoid erasing_examples_locale() {\n    namespace ba = boost::algorithm;\n\n    const std::locale loc = std::locale::classic();\n\n    const std::string r1\n        = ba::ierase_all_copy(str, \"hello\", loc);\n\n    const std::string r2\n        = ba::ierase_nth_copy(str, \",\", 1, loc);\n\n    // ...\n}\n```", "```cpp\n#include <iostream>\n#include <boost/algorithm/string/split.hpp>\n#include <boost/algorithm/string/classification.hpp>\n#include <algorithm>\n```", "```cpp\nint main() {\n    const char str[] =\n        \"This is a long long character array.\"\n        \"Please split this character array to sentences!\"\n        \"Do you know, that sentences are separated using period, \"\n        \"exclamation mark and question mark? :-)\"\n    ;\n```", "```cpp\n    typedef boost::split_iterator<const char*> split_iter_t;\n```", "```cpp\n    split_iter_t sentences = boost::make_split_iterator(str,\n        boost::algorithm::token_finder(boost::is_any_of(\"?!.\"))\n    );\n```", "```cpp\n    for (unsigned int i = 1; !sentences.eof(); ++sentences, ++i) {\n        boost::iterator_range<const char*> range = *sentences;\n        std::cout << \"Sentence #\" << i << \" : \\t\" << range << '\\n';\n```", "```cpp\n        std::cout << range.size() << \" characters.\\n\";\n```", "```cpp\n        std::cout \n            << \"Sentence has \" \n            << std::count(range.begin(), range.end(), ' ') \n            << \" whitespaces.\\n\\n\";\n    } // end of for(...) loop\n} // end of main()\n```", "```cpp\n Sentence #1 : This is a long long character array\n 35 characters.\n Sentence has 6 whitespaces.\n\n Sentence #2 : Please split this character array to sentences\n 46 characters.\n Sentence has 6 whitespaces.\n\n Sentence #3 : Do you know, that sentences are separated using dot,\n exclamation mark and question mark\n 90 characters.\n Sentence has 13 whitespaces.\n\n Sentence #4 : :-)\n 4 characters.\n Sentence has 1 whitespaces.\n```", "```cpp\n#include <string>\n#include <algorithm>\n\nstd::string between_str(const std::string& input, char starts, char ends) {\n    std::string::const_iterator pos_beg \n        = std::find(input.begin(), input.end(), starts);\n    if (pos_beg == input.end()) {\n        return std::string();\n    }\n    ++ pos_beg;\n\n    std::string::const_iterator pos_end \n        = std::find(pos_beg, input.end(), ends);\n\n    return std::string(pos_beg, pos_end);\n}\n```", "```cpp\nbetween_str(\"Getting expression (between brackets)\", '(', ')'); \n```", "```cpp\n#include <boost/utility/string_view.hpp>\n```", "```cpp\nboost::string_view between(\n    boost::string_view input,\n    char starts,\n    char ends)\n```", "```cpp\n{\n    boost::string_view::const_iterator pos_beg \n        = std::find(input.cbegin(), input.cend(), starts);\n    if (pos_beg == input.cend()) {\n        return boost::string_view();\n    }\n    ++ pos_beg;\n\n    boost::string_view::const_iterator pos_end \n        = std::find(pos_beg, input.cend(), ends);\n    // ...\n```", "```cpp\n    if (pos_end == input.cend()) {\n        return boost::string_view(pos_beg, input.end() - pos_beg);\n    }\n\n    return boost::string_view(pos_beg, pos_end - pos_beg);\n}\n```", "```cpp\n   between(std::string(\"(expression)\"), '(', ')')\n```", "```cpp\n    boost::string_view r0(\"^_^\");\n\n    std::string O_O(\"O__O\");\n    boost::string_view r1 = O_O;\n\n    std::vector<char> chars_vec(10, '#');\n    boost::string_view r2(&chars_vec.front(), chars_vec.size());\n```", "```cpp\n#include <boost/algorithm/string/case_conv.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include <boost/lexical_cast.hpp>\n#include <iterator>\n#include <iostream>\n\nvoid string_view_algorithms_examples() {\n    boost::string_view r(\"O_O\");\n    // Finding single symbol.\n    std::find(r.cbegin(), r.cend(), '_');\n\n    // Will print 'o_o'.\n    boost::to_lower_copy(std::ostream_iterator<char>(std::cout), r);\n    std::cout << '\\n';\n\n    // Will print 'O_O'.\n    std::cout << r << '\\n';\n\n    // Will print '^_^'.\n    boost::replace_all_copy(\n        std::ostream_iterator<char>(std::cout), r, \"O\", \"^\"\n    );\n    std::cout << '\\n';\n\n    r = \"100\";\n    assert(boost::lexical_cast<int>(r) == 100);\n}\n```", "```cpp\nvoid foo(const std::string& s);\nvoid foo(const char* s);\nvoid foo(const char* s, std::size_t s_size);\n```", "```cpp\nvoid foo(boost::string_view s);\n```", "```cpp\ntypedef basic_string_view<char, std::char_traits<char> > string_view; \n```", "```cpp\ntypedef basic_string_view<wchar_t,  std::char_traits<wchar_t> > wstring_view; \n\ntypedef basic_string_view<char16_t, std::char_traits<char16_t> > u16string_view; \n\ntypedef basic_string_view<char32_t, std::char_traits<char32_t> > u32string_view; \n```"]