- en: Advanced Visual Effects in Qt Quick
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt Quick 中的高级视觉效果
- en: Sprite animations and smooth transitions are not always enough to make the game
    visually appealing. In this chapter, we will explore many ways to add some eye
    candy to your games. Qt Quick provides a decent amount of built-in visual effects
    that will come in handy. However, from time to time, you will want to do something
    that is not possible to do with standard components—something unique and specific
    to your game. In these cases, you don't need to limit your imagination. We will
    teach you to dive deep into the C++ API of Qt Quick to implement truly unique
    graphics effects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵动画和流畅的过渡并不总是足以使游戏在视觉上吸引人。在本章中，我们将探讨许多方法来为您的游戏添加一些视觉亮点。Qt Quick 提供了相当数量的内置视觉效果，这些效果将非常有用。然而，有时您可能想要做一些标准组件无法完成的事情——一些独特且特定于您游戏的事情。在这些情况下，您不需要限制您的想象力。我们将教您深入
    Qt Quick 的 C++ API 以实现真正独特的图形效果。
- en: 'The main topics covered in this chapter are these:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主要主题包括：
- en: Auto-scaling user interfaces
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动缩放用户界面
- en: Applying graphical effects to the existing items
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将图形效果应用于现有项目
- en: Particle systems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒子系统
- en: OpenGL painting in Qt Quick
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt Quick 中的 OpenGL 绘图
- en: Using `QPainter` in Qt Quick
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Qt Quick 中使用 `QPainter`
- en: Making the game more attractive
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使游戏更具吸引力
- en: A game should not just be based upon an interesting idea, and it should not
    only work fluently on a range of devices and give entertainment to those people
    playing it. It should also look nice and behave nicely. Whether people are choosing
    from a number of similar implementations of the same game or want to spend money
    on another similarly priced and entertaining game, there is a good chance that
    they'll choose the game that looks the best—having a lot of animations, graphics,
    and flashy content. We already learned a number of techniques to make a game more
    pleasing to the eye, such as using animations or implementing parallax effect.
    Here, we will show you a number of other techniques that can make your Qt Quick
    applications more attractive.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一款游戏不应仅仅基于一个有趣的想法，它不仅应该在各种设备上流畅运行并给玩家带来娱乐，还应该看起来很漂亮，表现得很优雅。无论是人们从同一游戏的多个类似实现中选择，还是想要花钱购买价格相似且有趣的另一款游戏，有很大可能性他们会选择看起来最好的游戏——拥有大量的动画、图形和闪亮的元素。我们已经学习了许多使游戏更吸引眼球的技巧，例如使用动画或实现视差效果。在这里，我们将向您展示一些其他技巧，可以使您的
    Qt Quick 应用程序更具吸引力。
- en: Auto-scaling user interfaces
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动缩放用户界面
- en: The first extension you may implement is making your game auto-adjust to the
    device resolution it is running on. There are basically two ways to accomplish
    this. The first is to center the user interface in the window (or screen) and
    if it doesn't fit, enable scrolling. The other approach is to scale the interface
    to always fit the window (or screen). Which one to choose depends on a number
    of factors, the most important of which is whether your UI is good enough when
    upscaled. If the interface consists of text and non-image primitives (basically
    rectangles), or if it includes images but only vector ones or those with very
    high resolution, then it is probably fine to try and scale the user interface.
    Otherwise, if you use a lot of low-resolution bitmap images, you will have to
    choose one particular size for the UI (optionally allowing it to downscale, since
    the quality degradation should be less significant in this direction if you enable
    anti-aliasing).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能首先实现的扩展是使您的游戏自动调整其运行的设备分辨率。基本上有两种方法可以实现这一点。第一种是在窗口（或屏幕）中居中用户界面，如果它不合适，则启用滚动。另一种方法是缩放界面以始终适合窗口（或屏幕）。选择哪一种取决于许多因素，其中最重要的是当界面放大时，UI
    是否足够好。如果界面由文本和非图像原语（基本上是矩形）组成，或者如果它包含图像但只有矢量图像或分辨率非常高的图像，那么尝试缩放用户界面可能是可以的。否则，如果您使用了大量的低分辨率位图图像，您将不得不为
    UI 选择一个特定的尺寸（可选地允许它降级，因为如果启用抗锯齿，这种方向上的质量下降应该不那么明显）。
- en: 'Whether you choose to scale or to center and scroll, the basic approach is
    the same—you put your UI item in another item so that you have fine control over
    the UI geometry, regardless of what happens to the top-level window. Taking the
    centered approach is quite easy—just anchor the UI to the center of the parent.
    To enable scrolling, wrap the UI in the `Flickable` item and constrain its size
    if the size of the window is not big enough to fit the whole user interface:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择缩放还是居中滚动，基本方法都是一样的——你将UI项放入另一个项中，这样你就可以对UI几何形状进行精细控制，无论顶级窗口发生什么变化。采用居中方法非常简单——只需将UI锚定到父项的中心。要启用滚动，将UI包裹在`Flickable`项中，并约束其大小，如果窗口的大小不足以容纳整个用户界面：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can put the following simple code into the `UI.qml` file to see how `Flickable`
    positions the UI item:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将以下简单的代码放入`UI.qml`文件中，以查看`Flickable`如何定位UI项：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You should probably decorate the top-level item with a nice background if the
    UI item does not occupy the full area of its parent.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果UI项没有占据其父项的全部区域，你可能需要给顶级项装饰一个漂亮的背景。
- en: 'Scaling seems more complicated, but it is really easy with Qt Quick. Again,
    you have two choices—either stretch or scale. Stretching is as easy as executing
    the `anchors.fill: parent` command, which effectively forces the UI to recalculate
    the geometry of all its items, but it possibly allows us to use the space more
    efficiently. It is, in general, very time-consuming for the developer to provide
    expressions for calculating the geometry of each and every element in the user
    interface as the size of the view changes. This is usually not worth the effort.
    A simpler approach is to just scale the UI item to fit the window, which will
    implicitly scale the contained items. In such an event, their size can be calculated
    relative to the base size of the main view of the user interface. For this to
    work, you need to calculate the scale that is to be applied to the user interface
    to make it fill the whole space available. The item has a scale of 1 when its
    effective width equals its implicit width and its effective height equals its
    implicit height. If the window is larger, we want to scale up the item until it
    reaches the size of the window.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '缩放看起来可能更复杂，但使用Qt Quick实际上非常简单。再次强调，你有两个选择——拉伸或缩放。拉伸就像执行`anchors.fill: parent`命令一样简单，这实际上迫使UI重新计算所有其项的几何形状，但可能允许我们更有效地使用空间。通常，对于开发者来说，在视图大小变化时为每个界面元素提供表达式来计算几何形状是非常耗时的。这通常不值得努力。一个更简单的方法是将UI项缩放到适合窗口的大小，这将隐式地缩放包含的项。在这种情况下，它们的大小可以相对于用户界面主视图的基本大小来计算。为了使这起作用，你需要计算应用于用户界面的缩放比例，使其填充整个可用空间。当项的有效宽度等于其隐式宽度，其有效高度等于其隐式高度时，项的缩放比例为1。如果窗口更大，我们希望缩放项，直到它达到窗口的大小。'
- en: 'Therefore, the window''s width divided by the item''s implicit width will be
    the item''s scale in the horizontal direction. This is shown in the following
    diagram:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，窗口宽度除以项的隐式宽度将是项在水平方向上的缩放比例。这在上面的图中有所展示：
- en: '![](img/84379d94-af36-48dd-b35d-be256d7cde63.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/84379d94-af36-48dd-b35d-be256d7cde63.png)'
- en: 'The same can be applied to the vertical direction, but if the UI has a different
    aspect ratio than the window, its horizontal and vertical scale factors will be
    different. For the UI to look nice, we have to take the lower of the two values—to
    only scale up as much as the direction with less space allows, leaving a gap in
    the other direction:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的方法也适用于垂直方向，但如果UI的宽高比与窗口不同，其水平和垂直缩放因子也会不同。为了让UI看起来更美观，我们必须取两个值中较小的一个——只允许在空间较小的方向上进行缩放，在另一个方向上留下空白：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Again, it may be a good idea to put some background on the window item to fill
    in the gaps.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，给窗口项添加一些背景信息以填补空白可能是个不错的主意。
- en: 'What if you want to save some margin between the user interface and the window?
    You can, of course, take that into consideration when calculating the scale (`(window.width
    - 2 * margin) / width`, and so on) but there is an easier way—simply put an additional
    item inside the window, leaving an appropriate margin, and put the user interface
    item in that additional item and scale it up to the additional item''s size:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在用户界面和窗口之间保留一些边距呢？当然，你可以在计算缩放时考虑这一点（例如`(window.width - 2 * margin) / width`等），但有一个更简单的方法——只需在窗口内放置一个额外的项，留下适当的边距，并将用户界面项放入该额外项中，并将其缩放到额外项的大小：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When you scale elements a lot, you should consider enabling anti-aliasing for
    items that can lose quality when rendered in a size different than their native
    size (for example, images). This is done very easily in Qt Quick, as each `Item` instance
    has a property called `antialiasing` which, when enabled, will cause the rendering
    backend to try to reduce distortions caused by the aliasing effect. Remember that
    this comes at the cost of increased rendering complexity, so try to find a balance
    between quality and efficiency, especially on low-end hardware. You may provide
    an option to the user to globally enable or disable anti-aliasing for all game
    objects or to gradually adjust quality settings for different object types.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当你大量缩放元素时，你应该考虑为那些在渲染为不同于其原始大小的大小时会失去质量的项启用抗锯齿（例如，图像）。在Qt Quick中，这非常容易实现，因为每个`Item`实例都有一个名为`antialiasing`的属性，当启用时，将导致渲染后端尝试减少由锯齿效应引起的失真。记住，这会以增加渲染复杂性的代价，因此尝试在质量和效率之间找到平衡，尤其是在低端硬件上。你可以为用户提供一个选项，全局启用或禁用所有游戏对象的抗锯齿，或者为不同类型的对象逐渐调整质量设置。
- en: Graphical effects
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形效果
- en: The basic two predefined items in Qt Quick are rectangle and image. You can
    use them in a variety of creative ways and make them more pleasant-looking by
    applying GLSL shaders. However, implementing a shader program from scratch is
    cumbersome and requires in-depth knowledge of the shader language. Luckily, a
    number of common effects are already implemented and ready to use in the form
    of the `QtGraphicalEffects` module.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick中的基本两个预定义项目是矩形和图像。你可以用各种创造性的方式使用它们，并通过应用GLSL着色器使它们看起来更愉快。然而，从头开始实现着色器程序是繁琐的，并且需要深入了解着色器语言。幸运的是，许多常见效果已经以`QtGraphicalEffects`模块的形式实现并准备好使用。
- en: 'To add a subtle black shadow to our canvas-based heartbeat element defined
    in the `HeartBeat.qml` file, use a code similar to the following that makes use
    of the `DropShadow` effect:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要为在`HeartBeat.qml`文件中定义的基于画布的心跳元素添加微妙的黑色阴影，请使用类似于以下代码的代码，该代码利用了`DropShadow`效果：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To apply a shadow effect, you need an existing item as the source of the effect.
    In our case, we are using an instance of the `HeartBeat` class centered in a top-level
    item. Then, the shadow effect is defined and its geometry follows that of its
    source using the `anchors.fill` element. Just as the `DropShadow` class renders
    the original item as well as the shadow, the original item can be hidden by setting
    its `visible` property to `false`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用阴影效果，你需要一个现有项目作为效果来源。在我们的例子中，我们使用了一个位于顶级项目中心的`HeartBeat`类实例。然后，定义阴影效果，并使用`anchors.fill`元素使其几何形状遵循其来源。正如`DropShadow`类渲染原始项目及其阴影一样，可以通过将`visible`属性设置为`false`来隐藏原始项目：
- en: '![](img/86c9667d-7fc3-4b2a-8a28-d4cde532d888.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/86c9667d-7fc3-4b2a-8a28-d4cde532d888.png)'
- en: Most of the `DropShadow` class's properties are self-explanatory, but two properties—`radius` and `samples`—require
    some additional explanation. The shadow is drawn as a blurred monochromatic copy
    of the original item offset by a given position. The two mentioned properties
    control the amount of blur and its quality—the more samples used for blurring,
    the better the effect, but also the more demanding the computation that needs
    to be performed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`DropShadow`类的大部分属性都是不言自明的，但有两个属性——`radius`和`samples`——需要一些额外的解释。阴影被绘制为原始项目的模糊单色副本，并偏移给定位置。这两个提到的属性控制模糊的量和质量——用于模糊的样本越多，效果越好，但需要执行的计算也越复杂。'
- en: 'Speaking of blur, the plain blurring effect is also available in the graphics
    effects module through the `GaussianBlur` element type. To apply a blur instead
    of a shadow to the last example, simply replace the occurrence of the `DropShadow` class
    with the following code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 说到模糊，纯模糊效果也通过`GaussianBlur`元素类型在图形效果模块中提供。要将模糊效果而不是阴影应用于上一个示例，只需将`DropShadow`类的出现替换为以下代码：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This change will produce the following result:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改将产生以下结果：
- en: '![](img/5747ab9d-eb99-4c4d-b9ce-2fb65a04b2de.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5747ab9d-eb99-4c4d-b9ce-2fb65a04b2de.png)'
- en: Here, you can see two earlier mentioned properties as well as a vaguely named `transparentBorder` one.
    Enabling this property fixes some artifacts on the edges of the blur and in general,
    you'll want to keep it that way.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到前面提到的两个属性以及一个模糊命名的`transparentBorder`属性。启用此属性可以修复模糊边缘的一些伪影，并且通常你希望保持这种方式。
- en: Have a go hero – The blur parallax scrolled game view
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一下英雄效果 - 模糊视差滚动游戏视图
- en: The `blur` property is a very nice effect that can be used in many situations.
    For example, you can try to implement a feature within our elephant game whereby
    when the user pauses the game (for example, by pressing the *P* key on the keyboard),
    the view gets blurred. Make the effect smooth by applying an animation to the
    effect's `radius` property.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`blur` 属性是一个非常棒的效果，可以在许多情况下使用。例如，您可以在我们的象形游戏中尝试实现一个功能，当用户暂停游戏时（例如，通过按键盘上的 *P*
    键），视图会变得模糊。通过应用动画到效果的 `radius` 属性，使效果平滑。'
- en: 'Another interesting effect is `Glow`. It renders a colored and blurred copy
    of the source element. An example use case for games is highlighting some parts
    of the user interface—you can direct the user''s attention to the element (for
    example, button or badge) by making the element flash periodically:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的效果是 `Glow`。它渲染源元素的彩色和模糊副本。在游戏中的一个示例用法是突出显示用户界面的某些部分——您可以通过使元素周期性地闪烁来引导用户的注意力到该元素（例如，按钮或徽章）：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The complete module contains 20 different effects. We cannot describe each
    effect in detail here. Nevertheless, you can learn about it yourself. If you clone
    the module''s source git repository (found under [https://code.qt.io/cgit/qt/qtgraphicaleffects.git/](https://code.qt.io/cgit/qt/qtgraphicaleffects.git/)),
    in the `tests/manual/testbed` subdirectory of the cloned repository, you will
    find a nice application for testing the existing effects. To run the tool, open
    the `testBed.qml` file with `qmlscene`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 完整模块包含 20 种不同的效果。我们无法在这里详细描述每种效果。不过，您可以自己了解它们。如果您克隆模块的源 git 仓库（位于 [https://code.qt.io/cgit/qt/qtgraphicaleffects.git/](https://code.qt.io/cgit/qt/qtgraphicaleffects.git/)），在克隆仓库的
    `tests/manual/testbed` 子目录中，您将找到一个用于测试现有效果的不错应用程序。要运行此工具，请使用 `qmlscene` 打开 `testBed.qml`
    文件：
- en: '![](img/664cba82-99f9-4434-a149-c126267ea868.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/664cba82-99f9-4434-a149-c126267ea868.png)'
- en: You can also access a complete list of effects and their short descriptions
    by searching for QtGraphicalEffects in the documentation index.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过在文档索引中搜索 `QtGraphicalEffects` 来访问效果和它们的简短描述的完整列表。
- en: Particle systems
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子系统
- en: A commonly used visual effect in games is generating a large number of small,
    usually short-lived, often fast-moving, fuzzy objects such as stars, sparks, fumes,
    dust, snow, splinters, falling leaves, or the like. Placing these as regular items
    within a scene would greatly degrade performance. Instead, a special engine is
    used, which keeps a registry of such objects and tracks (simulates) their logical
    attributes without having physical entities in the scene. Such objects, called
    **particles**, are rendered upon request in the scene using very efficient algorithms.
    This allows us to use a large number of particles without having a negative impact
    on the rest of the scene.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中常用的一种视觉效果是生成大量小、通常寿命短、通常快速移动、模糊的对象，如星星、火花、烟雾、灰尘、雪、碎片、落叶等。将这些作为场景中的常规项目放置会大大降低性能。相反，使用一个特殊的引擎，该引擎维护此类对象的注册表并跟踪（模拟）它们的逻辑属性，而不在场景中具有物理实体。这些称为
    **粒子** 的对象，在请求时使用非常高效的算法在场景中进行渲染。这允许我们使用大量粒子，而不会对场景的其他部分产生负面影响。
- en: Qt Quick provides a particle system in the `QtQuick.Particles` import. The `ParticleSystem` element
    provides the core for the simulation, which uses the `Emitter` elements to spawn
    particles. They are then rendered according to definitions in a `ParticlePainter` element.
    Simulated entities can be manipulated using the `Affector` objects, which can
    modify the trajectory or life span of particles.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick 在 `QtQuick.Particles` 导入中提供了一个粒子系统。`ParticleSystem` 元素提供了模拟的核心，它使用
    `Emitter` 元素来生成粒子。然后根据 `ParticlePainter` 元素中的定义进行渲染。可以使用 `Affector` 对象来操作模拟实体，这些对象可以修改粒子的轨迹或生命周期。
- en: 'Let''s start with a simple example. The following code snippet declares the
    simplest possible particle system:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的例子开始。以下代码片段声明了最简单的粒子系统：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The result can be observed in the following image:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可以在以下图像中观察到：
- en: '![](img/12a485eb-2095-49a4-b081-4b863c3a28e4.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/12a485eb-2095-49a4-b081-4b863c3a28e4.png)'
- en: Let's analyze the code. After importing `QtQuick.Particles 2.0`, a `ParticleSystem` 
    item is instantiated that defines the domain of the particle system. We define
    two objects within that system. The first object is the `Emitter` and defines
    an area where particles will be spawned. The area is set to encompass the whole
    domain. The second object is an object of the `ImageParticle` type, which is a `ParticlePainter` subclass.
    It determines that particles should be rendered as instances of a given image.
    By default, the `Emitter` object spawns 10 particles per second, each of which
    lives for one second and then dies and is removed from the scene. In the code
    presented, the `Emitter` and `ImageParticle` objects are direct children of the `ParticleSystem` class;
    however, this doesn't have to be the case. The particle system can be explicitly
    specified by setting the `system` property.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下代码。在导入`QtQuick.Particles 2.0`之后，会实例化一个`ParticleSystem`项目，它定义了粒子系统的域。我们在该系统中定义了两个对象。第一个对象是`Emitter`，它定义了粒子生成的区域。该区域被设置为包含整个域。第二个对象是`ImageParticle`类型的对象，它是`ParticlePainter`子类。它确定粒子应以给定图像的实例进行渲染。默认情况下，`Emitter`对象每秒生成10个粒子，每个粒子存活一秒后死亡并被从场景中移除。在所展示的代码中，`Emitter`和`ImageParticle`对象是`ParticleSystem`类的直接子类；然而，这并不一定必须如此。可以通过设置`system`属性来显式指定粒子系统。
- en: Tuning the emitter
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整发射器
- en: 'You can control the amount of particles being emitted by setting the `emitRate` property
    of the emitter. Another property, called the `lifeSpan`, determines how many milliseconds
    it takes before a particle dies. To introduce some random behavior, you can use
    the `lifeSpanVariation` property to set a maximum amount of time (in milliseconds)
    the life span can be altered by the system (in both directions):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过设置发射器的`emitRate`属性来控制正在发射的粒子数量。另一个属性，称为`lifeSpan`，决定了粒子死亡前需要多少毫秒。为了引入一些随机行为，您可以使用`lifeSpanVariation`属性来设置系统可以改变生命周期（在两个方向上）的最大时间（以毫秒为单位）：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A possible result of this change is shown in the following picture:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变化的可能结果如下所示：
- en: '![](img/c3b83796-4b1f-4c37-9b0b-974eb2622d2d.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c3b83796-4b1f-4c37-9b0b-974eb2622d2d.png)'
- en: Increasing the emission rate and life span of particles can lead to a situation
    in which a very large number of particles have to be managed (and possibly rendered).
    This can degrade performance; thus, an upper limit of particles that can concurrently
    be alive can be set through the `maximumEmitted` property.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 增加粒子的发射率和生命周期可能会导致需要管理（以及可能渲染）的粒子数量非常大。这可能会降低性能；因此，可以通过`maximumEmitted`属性设置可以同时存活的粒子的上限。
- en: 'Tweaking the life span of particles makes the system more diverse. To strengthen
    the effect, you can also manipulate the size of each particle through the `size` and 
     `sizeVariation` properties:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 调整粒子的生命周期可以使系统更加多样化。为了增强效果，您还可以通过`size`和`sizeVariation`属性来调整每个粒子的尺寸：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will give you particles of different sizes:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为您提供不同大小的粒子：
- en: '![](img/d5afd80a-1d48-452c-843f-8c5d7a734b14.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d5afd80a-1d48-452c-843f-8c5d7a734b14.png)'
- en: 'The range of functionality presented thus far should be enough to create many
    nice-looking and useful particle systems. However, particles are emitted from
    the whole area of the emitter, which is a regular `QQuickItem` and thus is rectangular.
    This doesn''t have to be the case, though. The `Emitter` element contains a `shape` property,
    which is a way to declare the area that is to be giving birth to particles. The `QtQuick.Particles` module
    defines three types of custom shape that can be used—`EllipseShape`, `LineShape`,
    and `MaskShape`. The first two are very simple, defining either an empty or filled
    ellipse inscribed in the item or a line crossing one of the two diagonals of the
    item. The `MaskShape` element is more interesting, as it makes it possible to
    use an image as a shape for the `Emitter` element:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止所展示的功能范围应该足够创建许多看起来很好看且实用的粒子系统。然而，粒子是从发射器的整个区域发射出来的，这是一个常规的`QQuickItem`，因此是矩形的。但这并不一定必须如此。`Emitter`元素包含一个`shape`属性，这是一种声明粒子生成区域的途径。`QtQuick.Particles`模块定义了三种可用的自定义形状类型——`EllipseShape`、`LineShape`和`MaskShape`。前两种非常简单，定义了在项目内绘制的空或填充的椭圆或穿过项目对角线的线。`MaskShape`元素更有趣，因为它使得可以使用图像作为`Emitter`元素的形状：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Particles can now only spawn within the specified area:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子现在只能在指定的区域内生成：
- en: '![](img/dfd9d5e8-772c-4de8-b31f-28d6b273d999.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dfd9d5e8-772c-4de8-b31f-28d6b273d999.png)'
- en: Rendering particles
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染粒子
- en: So far, we have used a bare `ImageParticle` element to render particles. It
    is only one of the three `ParticlePainters` available, with the others being `ItemParticle` and 
     `CustomParticle`. However, before we move on to other renderers, let's focus
    on tweaking the `ImageParticle` element to obtain some interesting effects.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用裸`ImageParticle`元素来渲染粒子。它只是三种`ParticlePainters`中的一种，其他两种是`ItemParticle`和`CustomParticle`。然而，在我们继续到其他渲染器之前，让我们专注于调整`ImageParticle`元素以获得一些有趣的效果。
- en: The `ImageParticle` element renders each logical particle as an image. The image
    can be manipulated separately for each particle by changing its color and rotation,
    deforming its shape, or using it as a sprite animation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageParticle` 元素将每个逻辑粒子渲染为一个图像。可以通过改变每个粒子的颜色和旋转、变形其形状或将其用作精灵动画来分别操作每个图像。'
- en: To influence the color of particles, you can use any of the large number of
    dedicated properties—`alpha`, `color`, `alphaVariation`, `colorVariation`, `redVariation`, `greenVariation`,
    and `blueVariation`. The first two properties define the base value for the respective
    attributes, and the remaining properties set the maximum deviation of a respective
    parameter from the base value. In the case of opacity, there is only one type
    of variation you can use, but when defining the color, you can either set different
    values for each of the red, green, and blue channels, or you can use the global `colorVariation` 
      property, which is similar to setting the same value for all three channels.
    Allowed values are any between the range of 0 (no deviation allowed) and 1.0 (100%
    in either direction).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要影响粒子的颜色，你可以使用大量专用属性中的任何一个——`alpha`、`color`、`alphaVariation`、`colorVariation`、`redVariation`、`greenVariation`
    和 `blueVariation`。前两个属性定义了相应属性的基值，其余属性设置相应参数从基值的最大偏差。在透明度的情况下，你只能使用一种类型的偏差，但在定义颜色时，你可以为红色、绿色和蓝色通道设置不同的值，或者你可以使用全局的`colorVariation`属性，这类似于为所有三个通道设置相同的值。允许的值是0（不允许偏差）和1.0（任一方向的100%）之间的任何值。
- en: Note that when a color is applied to an image, the respective components of
    the colors (red, green, blue, and alpha) are multiplied. Black color (0, 0, 0,
    1) has all components set to 0 except for alpha, so applying a solid color to
    a black image will not have any effect. On the contrary, if your image contains
    white pixels (1, 1, 1, 1), they will be displayed in exactly the specified color.
    Transparent pixels will stay transparent because their alpha component will remain
    set to 0.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当将颜色应用于图像时，相应颜色的成分（红色、绿色、蓝色和alpha）会被相乘。黑色（0, 0, 0, 1）的所有成分都设置为0，除了alpha，因此将纯色应用于黑色图像将不会产生任何效果。相反，如果你的图像包含白色像素（1,
    1, 1, 1），它们将以指定的颜色精确显示。透明像素将保持透明，因为它们的alpha成分将保持设置为0。
- en: 'In our example, we can create particles with different colors using the following
    code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们可以使用以下代码创建不同颜色的粒子：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The result should look like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该看起来像这样：
- en: '![](img/b0b68155-65d2-4181-9ca6-7845053e7890.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b0b68155-65d2-4181-9ca6-7845053e7890.png)'
- en: The properties mentioned are stationary—the particle obeys the constant value
    during its whole life. The `ImageParticle` element also exposes two properties,
    letting you control the color of particles relative to their age. First of all,
    there is a property called  `entryEffect` that defines what happens with the particle
    at its birth and death. The default value is `Fade`, which makes particles fade
    in from 0 opacity at the start of their life and fades them back to 0 just before
    they die. You have already experienced this effect in all the earlier particle
    animations we demonstrated. Other values for the property are  `None` and `Scale`.
    The first one is obvious—there is no entry effect associated with particles. The
    second one scales particles from 0 at their birth and scales them back to 0 at
    the end of their life.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 提到的属性是静态的——粒子在其整个生命周期中遵循恒定值。`ImageParticle` 元素还公开了两个属性，允许你根据粒子的年龄控制其颜色。首先，有一个名为`entryEffect`的属性，它定义了粒子在其出生和死亡时会发生什么。默认值是`Fade`，这使得粒子在其生命开始时从0不透明度淡入，并在死亡前将其淡回0。你已经在所有之前演示的粒子动画中体验过这种效果。该属性的其它值是`None`和`Scale`。第一个值很明显——与粒子无关的进入效果。第二个值将粒子从出生时的0缩放到生命结束时的0。
- en: The other time-related property is `colorTable`. You can feed it with a URL
    of an image to be used as a one-dimensional texture determining the color of each
    particle over its life. At the beginning, the particle gets color-defined by the
    left edge of the image and then progresses right in a linear fashion. It is most
    common to set an image here containing a color gradient to achieve smooth transitions
    between colors.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个与时间相关的属性是`colorTable`。您可以提供用作确定粒子在其生命周期中颜色的单维纹理的图像的URL。一开始，粒子由图像的左侧定义颜色，然后以线性方式向右移动。最常见的是在这里设置包含颜色渐变的图像，以实现颜色之间的平滑过渡。
- en: The second parameter that can be altered is the rotation of a particle. Here,
    we can also either use properties that define constant values for rotation (`rotation` and 
    `rotationVariation`) specified in degrees or modify the rotation of particles
    in time with `rotationVelocity` and `rotationVelocityVariation`. The velocity
    defines the pace or rotation in degrees per second.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 可以改变的第二个参数是粒子的旋转。在这里，我们也可以使用定义旋转的常量值（以度为单位）的属性（`rotation`和`rotationVariation`）或使用`rotationVelocity`和`rotationVelocityVariation`在时间上修改粒子的旋转。速度定义了每秒旋转的度数或速度。
- en: Particles can also be deformed. The `xVector` and `yVector` properties allow
    binding vectors, which define distortions in horizontal and vertical axes. We
    will describe how to set the vectors in the next section. Last but not least,
    using the `sprites` property, you can define a list of sprites that will be used
    to render particles. This works in a fashion similar to the `SpriteSequence` type described
    in the previous chapter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子还可以变形。`xVector`和`yVector`属性允许绑定向量，这些向量定义了水平和垂直轴上的扭曲。我们将在下一节中描述如何设置这些向量。最后但同样重要的是，使用`sprites`属性，您可以定义用于渲染粒子的精灵列表。这与前一章中描述的`SpriteSequence`类型的工作方式类似。
- en: Making particles move
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使粒子移动
- en: Apart from fading and rotating, the particle systems we have seen so far were
    very static. While this is useful for making star fields, it is not at all useful
    for explosions, sparks, or even falling snow. This is because particles are mostly
    about movement. Here, we will show you two aspects of making your particles fly.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 除了淡入淡出和旋转之外，我们迄今为止所看到的粒子系统都非常静态。虽然这对于制作星系很有用，但对于爆炸、火花甚至下雪来说却毫无用处。这是因为粒子主要关于运动。在这里，我们将向您展示使粒子飞行的两个方面。
- en: The first aspect is modeling how the particles are born. By that, we mean the
    physical conditions of the object creating the particles. During an explosion,
    matter is pushed away from the epicenter with a very large force that causes air
    and small objects to rush outward at an extremely high speed. Fumes from a rocket
    engine are ejected with high velocities in the direction opposite to that of the
    propelled craft. A moving comet draws along a braid of dust and gases put into
    motion by the inertia.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方面是模拟粒子的生成方式。这意味着创建粒子的物体的物理条件。在爆炸过程中，物质以非常大的力量从震中推开，导致空气和小物体以极高的速度向外冲。火箭发动机的烟雾以与推进器相反的方向以高速喷射。移动的彗星会拖着一缕尘埃和气体，这些尘埃和气体是由惯性引起的。
- en: All these conditions can be modeled by setting the velocity or acceleration
    of the particles. These two metrics are described by vectors determining the direction
    and amount (magnitude or length) of the given quantity. In Qt Quick, such vectors
    are represented by an element type called `Direction`, where the tail of the vector
    is attached to the object and the position of the head is calculated by the `Direction` instance.
    Since we have no means of setting attributes on particles because we have no objects
    representing them, those two attributes—`velocity` and `acceleration`—are applied
    to emitters spawning the particles. As you can have many emitters in a single
    particle system, you can set different velocities and accelerations for particles
    of different origins.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些条件都可以通过设置粒子的速度或加速度来模拟。这两个指标由向量描述，这些向量确定了给定量的方向和数量（大小或长度）。在 Qt Quick 中，这些向量由一个称为“方向”的元素类型表示，其中向量的尾部附着在对象上，而头部位置由“方向”实例计算得出。由于我们没有设置粒子属性的方法，因为我们没有代表它们的对象，所以这两个属性——`速度`和`加速度`——应用于产生粒子的发射器。由于您可以在单个粒子系统中拥有许多发射器，因此可以为不同来源的粒子设置不同的速度和加速度。
- en: There are four types of direction elements representing different sources of
    information about the direction. First, there is `CumulativeDirection`, which
    acts as a container for other direction types and works like a sum of directions
    contained within.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种类型的方向元素，代表关于方向的不同信息来源。首先，有`CumulativeDirection`，它作为其他方向类型的容器，并像包含在其内的方向的总和一样工作。
- en: 'Then, there is `PointDirection`, where you can specify the *x* and *y* coordinates
    of a point where the head of the vector should be attached. To avoid the unrealistic
    effect of all particles heading in the same direction, you can specify `xVariation`
    and `yVariation` to introduce allowed deviation from a given point:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，有`PointDirection`，在这里你可以指定向量头部应该连接的点的*x*和*y*坐标。为了避免所有粒子都朝同一方向移动的不现实效果，你可以指定`xVariation`和`yVariation`来引入从给定点允许的偏差：
- en: '![](img/bc1602b8-72ed-444c-8ae8-0838c464a5ac.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bc1602b8-72ed-444c-8ae8-0838c464a5ac.png)'
- en: 'The third type is the most popular direction type—`AngleDirection`, which directly
    specifies the angle (in degrees clockwise from straight right) and magnitude (in
    pixels per second) of the vector. The angle can vary from the base by `angleVariation`, and
    similarly, `magnitudeVariation` can be used to introduce variation to the length
    of the vector:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种是最受欢迎的方向类型——`AngleDirection`，它直接指定了向量的角度（从正右方向顺时针计算）和大小（以每秒像素计）。角度可以从基准值变化`angleVariation`，同样，`magnitudeVariation`可以用来引入向量大小的变化：
- en: '![](img/132e4975-9919-4f09-9c4f-2d57ce0859dc.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/132e4975-9919-4f09-9c4f-2d57ce0859dc.png)'
- en: 'The last type is similar to the previous one. The `TargetDirection` vector
    can be used to point the vector toward the center of a given Qt Quick item (set
    with the `targetItem`  property). The length of the vector is calculated by giving
    the `magnitude` and  `magnitudeVariation`, and both can be interpreted as pixels
    per second or multiples of distance between the source and target points (depending
    on the value of the `proportionalMagnitude` property):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种类型与前面的一种类似。`TargetDirection`向量可以用来将向量指向给定Qt Quick项（通过`targetItem`属性设置）的中心。向量的长度通过给出`magnitude`和`magnitudeVariation`来计算，两者都可以解释为每秒像素数或源点和目标点之间距离的倍数（取决于`proportionalMagnitude`属性的值）：
- en: '![](img/166fabdf-9fc8-47fb-afd2-fb8d7a616f3c.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/166fabdf-9fc8-47fb-afd2-fb8d7a616f3c.png)'
- en: 'Let''s get back to setting particle velocity. We can use the `AngleDirection` vector
    to specify that particles should be moving left, spreading at a maximum of 45
    degrees:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到设置粒子速度。我们可以使用`AngleDirection`向量来指定粒子应该向左移动，最大扩散角度为45度：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This code will produce the effect shown on the following picture:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将产生以下图片中所示的效果：
- en: '![](img/fbcd2b9f-b9bc-4333-a3ce-6b578537a00d.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fbcd2b9f-b9bc-4333-a3ce-6b578537a00d.png)'
- en: 'Setting acceleration works the same way. You can even set both the initial
    velocity and the acceleration each particle should have. It is very easy to shoot
    the particles in the left direction and start pulling them down:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 设置加速度的工作方式相同。你甚至可以设置每个粒子应该具有的初始速度和加速度。很容易将粒子射向左侧并开始向下拉：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This code will produce particles moving along a single curve:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将产生沿单一路径移动的粒子：
- en: '![](img/82cb84a0-7627-468f-aba5-b968d18e38a3.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/82cb84a0-7627-468f-aba5-b968d18e38a3.png)'
- en: 'The `Emitter` element has one more nice property that is useful in the context
    of moving particles. Setting the `velocityFromMovement` parameter to a value different
    from `0`  makes any movement of the `Emitter` element apply to the velocity of
    the particles. The direction of the additional vector matches the direction of
    the emitter''s movement, and the magnitude is set to the speed of the emitter
    multiplied by the value set to `velocityFromMovement`. It is a great way to generate
    fumes ejected from a rocket engine:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`Emitter`元素还有一个在移动粒子上下文中很有用的属性。将`velocityFromMovement`参数设置为不同于`0`的值，会使`Emitter`元素的任何移动都应用于粒子的速度。附加向量的方向与发射器的移动方向一致，其大小设置为发射器速度乘以`velocityFromMovement`设置的值。这是一种生成火箭发动机喷射烟雾的绝佳方式：'
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is how the result could look like:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是结果可能看起来像什么：
- en: '![](img/70d657de-7e31-4a14-9904-c502f5db4f75.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/70d657de-7e31-4a14-9904-c502f5db4f75.png)'
- en: 'The second way of addressing the behavior of particles is to influence their
    attributes after they are born—in any particular moment of their life. This can
    be done using affectors. These are items inheriting affector, which can modify
    some attributes of particles currently traveling though the area of the affector.
    One of the simplest affectors is `Age`. It can advance particles to a point in
    their lifetime where they only have `lifeLeft` milliseconds of their life left:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 处理粒子行为的第二种方式是在粒子出生后影响它们的属性——在任何特定的生命时刻。这可以通过影响者来实现。这些是继承自影响者的项目，可以修改正在通过影响者区域的粒子的某些属性。最简单的影响者之一是`Age`。它可以推进粒子到它们生命周期的某个点，在那里它们只剩下`lifeLeft`毫秒的生命：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Setting `once` to `true` makes each affector influence a given particle only
    once. Otherwise, each particle can have its attributes modified many times.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将`once`设置为`true`使得每个影响者只对给定的粒子产生一次影响。否则，每个粒子可以多次修改其属性。
- en: Another affector type is `Gravity`, which can accelerate particles in a given
    angle. `Friction` can slow particles down, and `Attractor` will affect the particle's
    position, velocity, or acceleration so that it starts traveling toward a given
    point. `Wander` is great for simulating snowflakes or butterflies flying in pseudo-random
    directions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种影响类型是`Gravity`，它可以在给定的角度加速粒子。`Friction`可以减慢粒子的速度，而`Attractor`将影响粒子的位置、速度或加速度，使其开始向给定点移动。`Wander`非常适合模拟雪花或蝴蝶以伪随机方向飞行的效果。
- en: There are also other affector types available, but we will not go into their
    details here. We would like to warn you, however, against using affectors too
    often—they can severely degrade performance.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他类型的影响者可用，但在这里我们不会深入其细节。然而，我们想提醒您，不要过度使用影响者——它们可能会严重降低性能。
- en: Time for action – Vanishing coins spawning particles
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 生成消失的硬币粒子
- en: It is now time to practice our freshly acquired skills. The task is to add a
    particle effect to the game we created in the previous chapter. When the player
    collects a coin, it will explode into a sprinkle of colorful stars.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候练习我们新获得的知识了。任务是向我们在上一章中创建的游戏添加粒子效果。当玩家收集到硬币时，它将爆炸成一片五彩缤纷的星星。
- en: 'Start by declaring a particle system as filling the game scene, along with
    the particle painter definition:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，声明一个粒子系统作为游戏场景的填充，以及粒子绘制器的定义：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, modify the definition of `Coin` to include an emitter:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，修改`Coin`的定义以包括发射器：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, the `hit()` function has to be updated:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，必须更新`hit()`函数：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run the game and see what happens when Benjamin collects coins:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏并看看当本杰明收集硬币时会发生什么：
- en: '![](img/c281ab1c-c633-40a5-aa0f-bf4690a32b01.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c281ab1c-c633-40a5-aa0f-bf4690a32b01.png)'
- en: What just happened?
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: In this exercise, we defined a simple particle system that fills the whole scene.
    We defined a simple image painter for the particles where we allow particles to
    take on all the colors and start in all possible rotations. We used a star pixmap
    as our particle template.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们定义了一个简单的粒子系统，它填充了整个场景。我们为粒子定义了一个简单的图像绘制器，允许粒子呈现所有颜色并在所有可能的旋转中开始。我们使用星形位图作为我们的粒子模板。
- en: Then, an `Emitter` object is attached to every coin. Its `emitRate` is set to `0`,
    which means it does not emit any particles on its own. We set a varying life span
    on particles and let them fly in all directions by setting their initial velocity
    with an angle variation of 180 degrees in both directions (giving a total of 360
    degrees). By setting an acceleration, we give the particles a tendency to travel
    toward the top edge of the scene.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一个`Emitter`对象被附加到每个硬币上。它的`emitRate`被设置为`0`，这意味着它不会自行发射任何粒子。我们为粒子设置了不同的生命周期，并通过设置它们的初始速度，在两个方向上以180度的角度变化（总共360度）使它们向所有方向飞行。通过设置加速度，我们使粒子倾向于向场景的顶部边缘移动。
- en: In the hit function, we call a `burst()` function on the emitter, which makes
    it give instant birth to a given number of particles.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在`hit`函数中，我们调用发射器的`burst()`函数，这使得它立即产生一定数量的粒子。
- en: Custom OpenGL-based Qt Quick items
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于OpenGL的Qt Quick自定义项目
- en: In [Chapter 12](4fdfe294-c35c-476d-9656-0aefd533e491.xhtml), *Customization
    in Qt Quick*, we learned to create new QML element types that can be used to provide
    dynamic data engines or some other type of non-visual objects. Now we will see
    how to provide new types of visual items to Qt Quick.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](4fdfe294-c35c-476d-9656-0aefd533e491.xhtml)，“Qt Quick中的自定义”，我们学习了如何创建新的QML元素类型，这些类型可以被用来提供动态数据引擎或其他类型的非视觉对象。现在我们将看到如何为Qt
    Quick提供新的视觉项目类型。
- en: The first question you should ask yourself is whether you really need a new
    type of item. Maybe you can achieve the same goal with the already existing elements?
    Very often, you can use vector or bitmap images to add custom shapes to your applications,
    or you can use Canvas to quickly draw the graphics you need directly in QML.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该首先问自己一个问题：你是否真的需要一种新的项目类型。也许你可以用现有的元素达到同样的目标？非常常见的是，你可以使用矢量图或位图图像来为你的应用程序添加自定义形状，或者你可以使用Canvas在QML中直接快速绘制所需的图形。
- en: If you decide that you do require custom items, you will be doing that by implementing
    subclasses of the `QQuickItem` C++ class, which is the base class for all items
    in Qt Quick. After creating the new type, you will always have to register it
    with QML using  `qmlRegisterType`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定你需要自定义项目，你将通过实现`QQuickItem` C++类的子类来完成，这是Qt Quick中所有项目的基类。创建新类型后，你将始终需要使用`qmlRegisterType`将其注册到QML中。
- en: The scene graph
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景图
- en: To provide very fast rendering of its scene, Qt Quick uses a mechanism called **scene
    graph**. The graph consists of a number of nodes of well-known types, each describing
    a primitive shape to be drawn. The framework makes use of knowledge of each of
    the primitives allowed and their parameters to find the most performance-wise
    optimal order in which items can be rendered. Rendering itself is done using OpenGL,
    and all the shapes are defined in terms of OpenGL calls.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供非常快速的场景渲染，Qt Quick使用一种称为**场景图**的机制。该图由许多已知类型的节点组成，每个节点描述要绘制的原始形状。框架利用对允许的每个原始形状及其参数的知识，找到渲染项目时性能最优的顺序。渲染本身使用OpenGL完成，所有形状都使用OpenGL调用来定义。
- en: Providing new items for Qt Quick boils down to delivering a set of nodes that
    define the shape using terminology the graph understands. This is done by subclassing 
    `QQuickItem` and implementing the pure virtual `updatePaintNode()` method, which
    is supposed to return a node that will tell the scene graph how to render the
    item. The node will most likely be describing a geometry (shape) with a material
    (color, texture) applied.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为Qt Quick提供新项目归结为提供一组节点，这些节点使用图表理解的术语来定义形状。这是通过子类化`QQuickItem`并实现纯虚`updatePaintNode()`方法来完成的，该方法应该返回一个节点，告诉场景图如何渲染项目。该节点很可能会描述一个应用了材质（颜色、纹理）的几何形状（形状）。
- en: Time for action – Creating a regular polygon item
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 创建正多边形项
- en: 'Let''s learn about the scene-graph by delivering an item class for rendering
    convex regular polygons. We will draw the polygon using the OpenGL drawing mode
    called "triangle fan". It draws a set of triangles that all have a common vertex.
    Subsequent triangles are defined by the shared vertex, the vertex from the previous
    triangle, and the next vertex specified. Take a look at the diagram to see how
    to draw a hexagon as a triangle fan using eight vertices as control points:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过提供一个用于渲染凸多边形的项类来了解场景图。我们将使用称为“三角形扇”的OpenGL绘图模式来绘制多边形。它绘制一组具有公共顶点的三角形。后续的三角形由共享顶点、前一个三角形的顶点和指定的下一个顶点定义。看看图解，了解如何使用八个顶点作为控制点将六边形作为三角形扇绘制：
- en: '![](img/d1cd68c1-1eb0-43c8-98c4-cc8083a64281.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d1cd68c1-1eb0-43c8-98c4-cc8083a64281.png)'
- en: The same method applies for any regular polygon. The first vertex defined is
    always the shared vertex occupying the center of the shape. The remaining points
    are positioned on the circumference of a bounding circle of the shape at equal
    angular distances. The angle is easily calculated by dividing the full angle by
    the number of sides. For a hexagon, this yields 60 degrees.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的方法适用于任何正多边形。定义的第一个顶点始终是占据形状中心的共享顶点。其余的点位于形状边界圆的圆周上，角度相等。角度可以通过将完整角度除以边的数量来轻松计算。对于六边形，这会产生60度。
- en: 'Let''s get down to business and the `QQuickItem` subclass. We will give it
    a very simple interface:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始处理业务和`QQuickItem`子类。我们将给它一个非常简单的接口：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Our polygon is defined by the number of vertices and the fill color. We also
    get everything we inherited from `QQuickItem`, including the width and height
    of the item. Besides adding the obvious getters and setters for the properties,
    we override the virtual  `updatePaintNode()` method, which is responsible for
    building the scene-graph.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的多边形由顶点数和填充颜色定义。我们还继承了`QQuickItem`的所有内容，包括项目的宽度和高度。除了添加明显的属性获取器和设置器外，我们还重写了虚拟`updatePaintNode()`方法，该方法负责构建场景图。
- en: 'Before we deal with updating graph nodes, let''s deal with the easy parts first.
    Implement the constructor as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们处理更新图节点之前，让我们先处理简单的部分。构造函数的实现如下：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We make our polygon a hexagon by default. We also set a flag, `ItemHasContents`,
    which tells the scene-graph that the item is not fully transparent and should
    ask us how the item should be painted by calling `updatePaintNode()`. Existence
    of this flag allows Qt to avoid preparing the whole infrastructure if the item
    would not be painting anything anyway.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们默认将多边形设置为六边形。我们还设置了一个标志`ItemHasContents`，它告诉场景图该项目不是完全透明的，并且应该通过调用`updatePaintNode()`来询问我们如何绘制项目。这个标志的存在允许Qt在项目根本不会绘制任何内容的情况下避免准备整个基础设施。
- en: 'The setters are also quite easy to grasp:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 设置器也很容易理解：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A polygon has to have at least three sides; thus, we enforce this as a minimum,
    sanitizing the input value with `qMax`. After we change any of the properties
    that could influence the look of the item, we call `update()` to let Qt Quick
    know that the item needs to be rerendered. Let''s tackle `updatePaintNode()` now.
    We''ll disassemble it into smaller pieces so that it is easier for you to understand
    how the function works:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一个多边形至少需要有三条边；因此，我们通过`qMax`对输入值进行清理，强制执行这个最小值。在我们更改任何可能影响项目外观的属性后，我们调用`update()`让Qt
    Quick知道项目需要重新渲染。现在让我们处理`updatePaintNode()`。我们将将其分解成更小的部分，这样你更容易理解函数的工作方式：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When the function is called, it may receive a node it returned during a previous
    call. Be aware that the graph is free to delete all the nodes when it feels like
    it, so you should never rely on the node being there even if you returned a valid
    node during the previous run of the function. Let''s move on to the next part
    of the function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数被调用时，它可能会接收到在之前调用中返回的节点。请注意，图在觉得合适的时候可以自由地删除所有节点，因此你绝对不应该依赖于节点存在，即使你在函数的前一次运行中返回了一个有效的节点。让我们继续函数的下一部分：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The node we will return is a geometry node that contains information about
    the geometry and the material of the shape being drawn. We will be filling those
    variables as we go through the method. Next, we check whether `oldNode` was provided:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将返回的节点是一个包含绘制形状的几何和材质信息的几何节点。我们将随着方法的执行填充这些变量。接下来，我们检查是否提供了`oldNode`：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As we already mentioned, the function is called with the previously returned
    node as the argument, but we should be prepared for the node not being there and
    we should create it. Thus, if that is the case, we create a new `QSGGeometryNode` and
    a new `QSGGeometry`  for it. The geometry constructor takes a so-called attribute
    set as its parameter, which defines a layout for data in the geometry.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，函数是用之前返回的节点作为参数调用的，但我们应该准备好节点可能不存在的情况，并且我们应该创建它。因此，如果是这种情况，我们将创建一个新的`QSGGeometryNode`和一个新的`QSGGeometry`。几何构造函数接受一个所谓的属性集作为其参数，该属性集定义了几何中数据的布局。
- en: 'Most common layouts have been predefined:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数常见的布局已经被预定义：
- en: '| **Attribute set** | **Usage** | **First attribute** | **Second attribute**
    |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| **属性集** | **用途** | **第一个属性** | **第二个属性** |'
- en: '| `Point2D` | Solid colored shape | `float x, y` | - |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `Point2D` | 单色形状 | `float x, y` | - |'
- en: '| `ColoredPoint2D` | Per-vertex color | `float x, y` | `uchar red, green, blue,
    alpha` |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `ColoredPoint2D` | 每个顶点的颜色 | `float x, y` | `uchar red, green, blue, alpha`
    |'
- en: '| `TexturedPoint2D` | Per-vertex texture coordinate | `float x, y` | `float
    tx, float ty` |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `TexturedPoint2D` | 每个顶点的纹理坐标 | `float x, y` | `float tx, float ty` |'
- en: We will be defining the geometry in terms of 2D points without any additional
    information attached to each point; therefore, we pass `QSGGeometry::defaultAttributes_Point2D()` 
    to construct the layout we need. As you can see in the preceding table for that
    layout, each attribute consists of two floating point values denoting the *x* and *y* coordinates
    of a point.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用2D点来定义几何形状，每个点不附加任何额外信息；因此，我们传递`QSGGeometry::defaultAttributes_Point2D()`来构建我们需要的布局。正如你在前表中看到的，该布局的每个属性都由两个浮点值组成，表示点的*x*和*y*坐标。
- en: 'The second argument of the `QSGGeometry` constructor informs us about the number
    of vertices we will be using. The constructor will allocate as much memory as
    is needed to store the required number of vertices using the given attribute layout.
    After the geometry container is ready, we pass its ownership to the geometry node
    so that when the geometry node is destroyed, the memory for the geometry is freed
    as well. At this moment, we also mark that we will be rendering in the `GL_TRIANGLE_FAN` mode. The
    process is repeated for the material:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`QSGGeometry`构造函数的第二个参数告诉我们我们将使用多少个顶点。构造函数将根据给定的属性布局分配足够的内存来存储所需数量的顶点。在几何容器准备好后，我们将它的所有权传递给几何节点，以便当几何节点被销毁时，几何形状的内存也会被释放。在此时刻，我们还标记我们将以`GL_TRIANGLE_FAN`模式进行渲染。这个过程会为材料重复进行。'
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We use `QSGFlatColorMaterial` as the whole shape will have one color that is
    set from `m_color`. Qt provides a number of predefined material types. For example,
    if we wanted to give each vertex a separate color, we would have used  `QSGVertexColorMaterial` along
    with the `ColoredPoint2D` attribute layout.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`QSGFlatColorMaterial`作为整个形状将有一个从`m_color`设置的单一颜色。Qt提供了一系列预定义的材料类型。例如，如果我们想给每个顶点分配不同的颜色，我们会使用`QSGVertexColorMaterial`以及`ColoredPoint2D`属性布局。
- en: 'The next piece of code deals with a situation in which `oldNode` did contain
    a valid pointer to a node that was already initialized:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 下一段代码处理的是`oldNode`确实包含了一个指向已经初始化的节点的有效指针的情况：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In this case, we only need to ensure that the geometry can hold as many vertices
    as we need in case the number of sides changed since the last time the function
    was executed. Next, we check the material:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只需要确保几何形状能够容纳我们需要的尽可能多的顶点，以防自上次函数执行以来边的数量发生了变化。接下来，我们检查材料：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If the color differs, we reset it and tell the geometry node that the material
    needs to be updated by marking the `DirtyMaterial` flag.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果颜色不同，我们将其重置，并告诉几何节点材料需要更新，通过标记`DirtyMaterial`标志。
- en: 'Finally, we can set vertex data:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以设置顶点数据：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: First, we ask the geometry object to prepare a mapping for us from the allocated
    memory to a `QSGGeometry::Point2D` structure, which can be used to conveniently
    set data for each vertex. Then, actual calculations are performed using the equation
    for calculating points on a circle. The radius of the circle is taken as the smaller
    part of the width and height of the item so that the shape is centered in the
    item. As you can see in the diagram at the beginning of the exercise, the last
    point in the array has the same coordinates as the second point in the array to
    close the fan into a regular polygon.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们要求几何对象为我们准备一个从分配的内存到`QSGGeometry::Point2D`结构的映射，这可以方便地为每个顶点设置数据。然后，使用计算圆上点的方程进行实际计算。圆的半径取为项目宽度和高度的较小部分，以便形状在项目中居中。正如你在练习开始时的图中可以看到的，数组中的最后一个点与数组中的第二个点具有相同的坐标，以便将扇形封闭成规则多边形。
- en: 'At the very end, we mark the geometry as changed and return the node to the
    caller:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们标记几何形状已更改，并将节点返回给调用者：
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: What just happened?
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: Rendering in Qt Quick can happen in a thread different that is than the main
    thread. Before calling the `updatePaintNode()` function, Qt performs synchronization
    between the GUI thread and the rendering thread to allow us safely access our
    item's data and other objects living in the main thread. The function executing
    the main thread is blocked while this function executes, so it is crucial that
    it executes as quickly as possible and doesn't do any unnecessary calculations
    as this directly influences performance. This is also the only place in your code
    where at the same time you can safely call functions from your item (such as reading
    properties) and interact with the scene-graph (creating and updating the nodes).
    Try not emitting any signals nor creating any objects from within this method
    as they will have affinity to the rendering thread rather than the GUI thread.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt Quick中的渲染可以在与主线程不同的线程中发生。在调用`updatePaintNode()`函数之前，Qt会在GUI线程和渲染线程之间执行同步，以便我们安全地访问项目数据和其他存在于主线程中的对象。在执行此函数时，执行主线程的函数将被阻塞，因此它必须尽可能快地执行，并且不要进行任何不必要的计算，因为这会直接影响性能。这也是你可以在代码中同时安全调用项目中的函数（如读取属性）并与场景图（创建和更新节点）交互的唯一地方。尽量在此方法中不要发出任何信号或创建任何对象，因为它们将具有渲染线程的亲和力，而不是GUI线程。
- en: 'Having said that, you can now register your class with QML using `qmlRegisterType` and
    test it with the following QML document:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，你现在可以使用 `qmlRegisterType` 将你的类注册到 QML 中，并使用以下 QML 文档进行测试：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This should give you a nice blue pentagon. If the shape looks aliased, you
    can enforce anti-aliasing by setting the surface format for the application:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会给你一个漂亮的蓝色五边形。如果形状看起来有锯齿，你可以通过设置应用程序的表面格式来强制抗锯齿：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If the application produces a black screen after enabling anti-aliasing, try
    to lower the number of samples or disable it.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在启用抗锯齿后应用程序产生黑色屏幕，尝试减少样本数量或禁用它。
- en: Have a go hero – Creating a supporting border for RegularPolygon
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一下英雄 – 创建 RegularPolygon 的支持边框
- en: 'What is returned by `updatePaintNode()` may not just be a single `QSGGeometryNode` 
    but also a larger tree of `QSGNode` items. Each node can have any number of child
    nodes. By returning a node that has two geometry nodes as children, you can draw
    two separate shapes in the item:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`updatePaintNode()` 返回的不仅可能是一个单一的 `QSGGeometryNode`，也可能是一个更大的 `QSGNode` 项的树。每个节点可以有任意数量的子节点。通过返回一个有两个几何节点作为子节点的节点，你可以在项中绘制两个独立的形状：'
- en: '![](img/1d3adbdc-88a0-4a2d-9ebb-a2daa20dafe5.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1d3adbdc-88a0-4a2d-9ebb-a2daa20dafe5.png)'
- en: As a challenge, extend `RegularPolygon` to draw not only the internal filled
    part of the polygon but also an edge that can be of a different color. You can
    draw the edge using the `GL_QUAD_STRIP` drawing mode. Coordinates of the points
    are easy to calculate—the points closer to the middle of the shape are the same
    points that form the shape itself. The remaining points also lie on a circumference
    of a circle that is slightly larger (by the width of the border). Therefore, you
    can use the same equations to calculate them.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 作为挑战，扩展 `RegularPolygon` 以绘制多边形的内部填充部分以及可以不同颜色的边。你可以使用 `GL_QUAD_STRIP` 绘图模式来绘制边。点的坐标很容易计算——靠近形状中间的点就是构成形状本身的点。其余的点也位于一个略微更大的圆的圆周上（边框的宽度）。因此，你可以使用相同的方程来计算它们。
- en: 'The `GL_QUAD_STRIP` mode renders quadrilaterals with every two vertices specified
    after the first four, composing a connected quadrilateral. The following diagram
    should give you a clear idea of what we are after:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`GL_QUAD_STRIP` 模式通过指定在第一个四个顶点之后的每两个顶点来渲染四边形，组成一个连接的四边形。以下图表应该能清楚地说明我们想要达到的效果：'
- en: '![](img/c5b793c6-e376-4ef5-9a02-fba871dc80d5.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c5b793c6-e376-4ef5-9a02-fba871dc80d5.png)'
- en: Using QPainter interface in Qt Quick
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Qt Quick 中使用 QPainter 接口
- en: Implementing items in OpenGL is quite difficult—you need to come up with an
    algorithm of using OpenGL primitives to draw the shape you want, and then you
    also need to be skilled enough with OpenGL to build a proper scene graph node
    tree for your item. However, there is another way—you can create items by painting
    them with `QPainter`. This comes at a cost of performance as behind the scenes,
    the painter draws on an indirect surface (a frame buffer object or an image) that
    is then converted to OpenGL texture and rendered on a quad by the scene-graph.
    Even considering that performance hit, it is often much simpler to draw the item
    using a rich and convenient drawing API than to spend hours doing the equivalent
    in OpenGL or using Canvas.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenGL 中实现项相当困难——你需要想出一个使用 OpenGL 原语绘制你想要的形状的算法，然后你还需要足够熟练地使用 OpenGL 来为你的项构建一个合适的场景图节点树。然而，还有另一种方法——你可以通过
    `QPainter` 绘制项。这会带来性能上的损失，因为幕后画家在一个间接的表面（帧缓冲对象或图像）上绘制，然后由场景图通过一个四边形将其转换为 OpenGL
    纹理并渲染。即使考虑到性能损失，使用丰富且方便的绘图 API 绘制项通常比在 OpenGL 或 Canvas 中花费数小时做同样的事情要简单得多。
- en: To use that approach, we will not be subclassing `QQuickItem` directly but `QQuickPaintedItem`,
    which gives us the infrastructure needed to use the painter for drawing items.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这种方法，我们不会直接子类化 `QQuickItem`，而是 `QQuickPaintedItem`，这为我们提供了使用画家绘制项所需的基础设施。
- en: Basically, all we have to do, then, is implement the pure virtual `paint()` method
    that renders the item using the received painter. Let's see this put into practice
    and combine it with the skills we gained earlier.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们接下来要做的就是实现纯虚的 `paint()` 方法，使用接收到的画家渲染项。让我们看看这是如何付诸实践，并将其与我们之前获得的技术结合起来。
- en: Time for action – Creating an item for drawing outlined text
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践 – 创建用于绘制轮廓文本的项
- en: 'The goal of the current exercise is to be able to make the following QML code
    work:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当前练习的目标是能够使以下 QML 代码工作：
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, it produces the following result:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它会产生以下结果：
- en: '![](img/a4b0cb80-bd85-42f5-b69b-c1df9ea24fa1.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a4b0cb80-bd85-42f5-b69b-c1df9ea24fa1.png)'
- en: 'Start with an empty Qt Quick application project. Create a new C++ class and
    call it `OutlineTextItemBorder`. Place the following code into the class definition:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个空的Qt Quick应用程序项目开始。创建一个新的C++类，并将其命名为`OutlineTextItemBorder`。将以下代码放入类定义中：
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is a simple `QObject`-based class holding a number of properties. You
    can see that  `Q_PROPERTY` macros don''t have the `READ` and `WRITE` keywords
    we''ve been using thus far. This is because we are taking a shortcut right now,
    and we let **moc** produce code that will operate on the property by directly
    accessing the given class member. Normally, we would recommend against such an
    approach as without getters; the only way to access the properties is through
    the generic `property()` and `setProperty()` calls. However, in this case, we
    will not be exposing this class to the public in C++ so we won''t need the setters,
    and we implement the getters ourselves, anyway. The nice thing about the `MEMBER` 
    keyword is that if we also provide the `NOTIFY` signal, the generated code will
    emit that signal when the value of the property changes, which will make property
    bindings in QML work as expected. We also need to implement the method that returns
    the actual pen based on values of the properties:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基于`QObject`的简单类，包含多个属性。你可以看到，`Q_PROPERTY`宏没有我们迄今为止使用的`READ`和`WRITE`关键字。这是因为我们现在正在走捷径，我们让`moc`生成直接访问给定类成员以操作属性的代码。通常，我们不建议采取这种方法，因为没有getter；访问属性的唯一方式是通过通用的`property()`和`setProperty()`调用。然而，在这种情况下，我们不会将这个类公开在C++中，所以我们不需要setter，我们仍然会自己实现getter。`MEMBER`关键字的好处是，如果我们还提供了`NOTIFY`信号，生成的代码将在属性值变化时发出该信号，这将使QML中的属性绑定按预期工作。我们还需要实现一个根据属性值返回实际画笔的方法：
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The class will provide a grouped property for our main item class. Create a
    class called `OutlineTextItem` and derive it from `QQuickPaintedItem`, as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 该类将为我们的主要项目类提供一个分组属性。创建一个名为`OutlineTextItem`的类，并从`QQuickPaintedItem`派生，如下所示：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The interface defines properties for the text to be drawn, in addition to its
    color, font, and the grouped property for the outline data. Again, we use `MEMBER` to
    avoid having to manually implement getters and setters. Unfortunately, this makes
    our constructor code more complicated, as we still need a way to run some code
    when any of the properties are modified. Implement the constructor using the following
    code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接口定义了要绘制的文本属性，以及它的颜色、字体和轮廓数据的分组属性。同样，我们使用`MEMBER`来避免手动实现getter和setter。不幸的是，这使得我们的构造函数代码更加复杂，因为我们仍然需要一种方法在任何属性被修改时运行一些代码。使用以下代码实现构造函数：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We basically connect all the property change signals from both the object and
    its grouped property object to the same slot that will update the data for the
    item if any of its components are modified. We also call the same slot directly
    to prepare the initial state of the item. The slot can be implemented like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上将对象及其分组属性对象的所有属性更改信号连接到同一个槽，该槽将在任何组件被修改时更新项目的数据。我们还将直接调用同一个槽来准备项目的初始状态。该槽可以像这样实现：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'At the beginning, the function resets a painter path object that serves as
    a backend for drawing outlined text and initializes it with the text drawn using
    the font set. Then, the slot calculates the bounding rect for the path using the `borderShape()` function that
    we will shortly see. We use `controlPointRect()` to calculate the bounding rectangle
    as it is much faster than `boundingRect()` and returns an area greater than or
    equal to the one  `boundingRect()`, which is OK for us. Finally, it sets the calculated
    size as the size hint for the item and asks the item to repaint itself with the `update()` call.
    Implement the `borderShape()` function using the following code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，该函数重置一个画家路径对象，该对象作为绘制轮廓文本的后端，并使用设置的字体初始化它。然后，槽函数使用我们很快就会看到的`borderShape()`函数计算路径的边界矩形。我们使用`controlPointRect()`来计算边界矩形，因为它比`boundingRect()`快得多，并且返回一个大于或等于`boundingRect()`的面积，这对我们来说是可以接受的。最后，它将计算出的尺寸设置为项目的尺寸提示，并使用`update()`调用请求项目重新绘制。使用以下代码实现`borderShape()`函数：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `borderShape()` function returns a new painter path that includes both the
    original path and its outline created with the `QPainterPathStroker` object. This
    is so that the width of the stroke is correctly taken into account when calculating
    the bounding rectangle.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`borderShape()`函数返回一个新的绘图路径，该路径包括原始路径及其使用`QPainterPathStroker`对象创建的轮廓。这样做是为了在计算边界矩形时正确考虑笔触的宽度。'
- en: 'What remains is to implement the `paint()` routine itself:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是实现`paint()`例程本身：
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The code is really simple—we bail out early if there is nothing to draw. Otherwise,
    we set up the painter using the pen and color obtained from the item's properties.
    We enable anti-aliasing and calibrate the painter coordinates with that of the
    bounding rectangle of the item. Finally, we draw the path on the painter.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 代码非常简单——如果没有东西要绘制，我们就会提前退出。否则，我们使用从项的属性中获得的笔和颜色设置绘图器。我们启用抗锯齿并使用项的边界矩形校准绘图器坐标。最后，我们在绘图器上绘制路径。
- en: What just happened?
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'During this exercise, we made use of the powerful API of Qt''s raster graphics
    engine to complement an existing set of Qt Quick items with a simple functionality.
    This is otherwise very hard to achieve using predefined Qt Quick elements and
    even harder to implement using OpenGL. We agreed to take a small performance hit
    in exchange for having to write just about a hundred lines of code to have a fully
    working solution. Remember to register the class with QML if you want to use it
    in your code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次练习中，我们利用Qt的矢量图形引擎的强大API，通过简单的功能来补充现有的Qt Quick项集。否则，使用预定义的Qt Quick元素来实现这一点非常困难，而使用OpenGL实现则更加困难。我们同意为了只写大约一百行代码就能得到一个完全工作的解决方案，我们愿意承受一点性能损失。如果你想在代码中使用它，请记住将类注册到QML中：
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Pop quiz
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速问答
- en: Q1\. Which QML type can be used to enable scrolling of a large item inside a
    smaller viewport?
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 哪种QML类型可以用来在较小的视口中启用大项的滚动？
- en: '`Rectangle`'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Rectangle`'
- en: '`Flickable`'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Flickable`'
- en: '`Window`'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Window`'
- en: Q2\. What is the purpose of the `Affector` QML type?
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. `Affector` QML类型的目的何在？
- en: '`Affector` allows you to change properties of QML items during an animation'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Affector`允许你在动画过程中更改QML项的属性'
- en: '`Affector` influences properties of particles spawned by a particle system'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Affector`影响由粒子系统产生的粒子的属性'
- en: '`Affector` allows you to control initial properties of particles spawned by
    a particle system'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Affector`允许你控制由粒子系统产生的粒子的初始属性'
- en: Q3\. What happens when you use `QPainter` to draw on a Qt Quick item?
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. 当你使用`QPainter`在Qt Quick项上绘图时会发生什么？
- en: Every call to the `QPainter` API is translated to an equivalent OpenGL call
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次调用`QPainter` API都会转换为等效的OpenGL调用
- en: '`QPainter` paints on an invisible buffer that is then loaded as an OpenGL texture'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QPainter`在不可见的缓冲区上绘图，然后将其作为OpenGL纹理加载'
- en: The item painted by `QPainter` is displayed without hardware acceleration
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由`QPainter`绘制的项在没有硬件加速的情况下显示
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You are now familiar with Qt Quick's capabilities that allow you to add astonishing
    graphical effects to your games. You can configure particle systems and implement
    OpenGL painting in the Qt Quick's scene graph. You are also able to utilize the
    skills acquired in the first parts of the book to implement painted Qt Quick items.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经熟悉了Qt Quick的功能，这些功能允许你在游戏中添加令人惊叹的图形效果。你可以配置粒子系统并在Qt Quick的场景图中实现OpenGL绘图。你也能够利用本书第一部分学到的技能来实现绘制的Qt
    Quick项。
- en: Of course, Qt Quick is much richer than all this, but we had to stop somewhere.
    The set of skills we have hopefully passed on to you should be enough to develop
    many great games. However, many of the elements have more properties than we have
    described here. Whenever you want to extend your skills, you can check the reference
    manual to see whether the element type has more interesting attributes. Qt Quick
    is still in active development, so it's a good idea to go through the changelogs
    of the recent Qt versions to see the new features that could not be covered in
    this book.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Qt Quick的功能比这还要丰富，但我们不得不在某处停下来。我们希望传授给你的技能应该足够开发出许多优秀的游戏。然而，许多元素具有比我们这里描述的更多的属性。无论何时你想扩展你的技能，你都可以查看参考手册，看看元素类型是否有更多有趣的属性。Qt
    Quick仍在积极开发中，因此查看最近Qt版本的变更日志，看看这本书中未能涵盖的新功能是个好主意。
- en: In the next chapter, we'll turn our attention to the Qt 3D module, which is
    a relatively recent addition to the Qt framework. Qt 3D provides a rich QML API
    that will allow us to use many of the skills we learned while working with Qt
    Quick. However, instead of user interface and 2D graphics, you will now create
    games that display hardware accelerated 3D graphics. When you learn to use Qt
    3D, you will be able to take your games to a completely new level!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将关注Qt 3D模块，这是Qt框架中相对较新的一个模块。Qt 3D提供了一个丰富的QML API，这将使我们能够使用我们在与Qt Quick一起工作时学到的许多技能。然而，与用户界面和2D图形不同，你现在将创建显示硬件加速3D图形的游戏。当你学会使用Qt
    3D时，你将能够将你的游戏提升到一个全新的水平！
