- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Mastering Abstract Classes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握抽象类
- en: This chapter will continue expanding our knowledge of object-oriented programming
    in C++. We will begin by exploring a powerful OO concept, **abstract classes**,
    and then progress to understanding how this idea is implemented in C++ through
    *direct language support*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将继续扩展我们对C++面向对象编程知识的理解。我们将从探索一个强大的面向对象概念——**抽象类**开始，然后进一步了解这个想法是如何通过**直接语言支持**在C++中实现的。
- en: We will implement abstract classes using pure virtual functions to ultimately
    support refinements in a hierarchy of related classes. We will understand how
    abstract classes augment and pair with our understanding of polymorphism. We will
    also recognize how the OO concept of abstract classes presented in this chapter
    will support powerful and adaptable designs, allowing us to create easily extensible
    C++ code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用纯虚函数实现抽象类，以最终支持相关类层次结构中的改进。我们将了解抽象类如何增强和与我们的多态理解相匹配。我们还将认识到本章中提出的抽象类面向对象概念将支持强大且灵活的设计，使我们能够轻松创建可扩展的C++代码。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Understanding the OO concept of an abstract class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解抽象类的面向对象概念
- en: Implementing abstract classes with pure virtual functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用纯虚函数实现抽象类
- en: Creating interfaces using abstract classes and pure virtual functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用抽象类和纯虚函数创建接口
- en: Generalizing derived class objects using abstract classes, and upcasting and
    downcasting
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用抽象类泛化派生类对象，以及向上和向下转换
- en: By the end of this chapter, you will understand the OO concept of an abstract
    class, and how to implement this idea in C++ through pure virtual functions. You
    will learn how abstract classes containing only pure virtual functions can define
    an OOP concept of an interface. You will understand how abstract classes and interfaces
    contribute to powerful OO designs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将理解抽象类的面向对象概念，以及如何通过纯虚函数在C++中实现这一想法。您将了解仅包含纯虚函数的抽象类如何定义一个面向对象的概念——接口。您将理解抽象类和接口如何有助于强大的面向对象设计。
- en: You will see how we can very easily generalize groups of related, specialized
    objects using sets of abstract types. We will further explore up and downcasting
    within the hierarchy to understand what is allowed and when such typecasting is
    reasonable to employ.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到我们如何非常容易地使用抽象类型集合泛化相关、专业的对象组。我们将进一步探索在层次结构中的向上和向下转换，以了解允许什么以及何时进行此类类型转换是合理的。
- en: By understanding the direct language support of abstract classes in C++ using
    pure virtual functions, as well as why creating interfaces is useful, you will
    have more tools available to create an extensible hierarchy of related classes.
    Let us expand our understanding of C++ as an OOP language by understanding how
    these concepts are implemented in C++.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解C++中抽象类的直接语言支持以及为什么创建接口是有用的，您将拥有更多工具来创建一个可扩展的相关类层次结构。让我们通过理解这些概念在C++中的实现来扩展我们对C++作为面向对象语言的理解。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter08](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter08).
    Each full program example can be found in the GitHub under the appropriate chapter
    heading (subdirectory) in a file that corresponds to the chapter number, followed
    by a dash, followed by the example number in the chapter at hand. For example,
    the first full program in this chapter can be found in the subdirectory `Chapter08`
    in a file named `Chp8-Ex1.cpp` under the aforementioned GitHub directory.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 完整程序示例的在线代码可以在以下GitHub URL中找到：[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter08](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter08)。每个完整程序示例都可以在GitHub的相应章节标题（子目录）下找到，该文件对应章节编号，后面跟着一个连字符，然后是当前章节中的示例编号。例如，本章的第一个完整程序可以在上述GitHub目录下的`Chapter08`子目录中的名为`Chp8-Ex1.cpp`的文件中找到。
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3SZv0jy](https://bit.ly/3SZv0jy).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可以在以下链接中查看：[https://bit.ly/3SZv0jy](https://bit.ly/3SZv0jy)。
- en: Understanding the OO concept of an abstract class
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解抽象类的面向对象概念
- en: In this section, we will introduce an essential object-oriented concept, that
    of an abstract class. This concept will add to your growing knowledge base of
    key OO ideas including encapsulation, information hiding, generalization, specialization,
    and polymorphism. You know how to encapsulate a class. You also know how to build
    inheritance hierarchies using single inheritance, and various reasons to build
    hierarchies, such as supporting *Is-A* relationships or for the lesser-used reason
    of supporting implementation inheritance. Furthermore, you know how to employ
    runtime binding of methods to operations using the concept of polymorphism, implemented
    by virtual functions. Let’s extend our growing OO terminology by exploring **abstract
    classes**.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一个基本面向对象的概念，即抽象类。这个概念将丰富你对关键OO（面向对象）思想的了解，包括封装、信息隐藏、泛化、特化和多态。你知道如何封装一个类。你也知道如何使用单继承构建继承层次结构，以及构建层次结构的各种原因，例如支持*是*关系或支持实现继承的较少使用原因。此外，你知道如何通过多态的概念使用运行时绑定方法到操作，这是通过虚函数实现的。让我们通过探索**抽象类**来扩展我们不断增长的OO术语。
- en: An **abstract class** is a base class that is intended to collect commonalities
    that may exist in derived classes for the purpose of asserting a common interface
    (that is, a set of operations) on the derived class. An abstract class does not
    represent a class that is intended for instantiation. Only objects of the derived
    class types may be instantiated.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象类**是一个基类，旨在收集派生类中可能存在的共同点，目的是在派生类上断言一个公共接口（即一组操作）。抽象类不代表一个旨在实例化的类。只有派生类类型的对象可以被实例化。'
- en: Let’s start by looking at the C++ language feature that allows us to implement
    abstract classes, that is, pure virtual functions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从C++语言特性开始，它允许我们实现抽象类，即纯虚函数。
- en: Implementing abstract classes with pure virtual functions
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用纯虚函数实现抽象类
- en: An abstract class is specified by introducing at least one abstract method (that
    is, a pure virtual function prototype) in the class definition. The OO concept
    of an **abstract method** is the specification of an operation with only its protocol
    for usage (that is, with only the *name* and *signature* of the member function),
    but with no definition for the function. An abstract method will be polymorphic,
    in that, having no definition, it is expected to be redefined by derived classes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类是通过在类定义中引入至少一个抽象方法（即纯虚函数原型）来指定的。抽象方法的概念是仅指定操作的协议（即仅成员函数的*名称*和*签名*），但没有函数定义。抽象方法将是多态的，因为没有定义，它预期将被派生类重新定义。
- en: 'A `=0` after the arguments to the function. Additionally, it is important to
    understand the following nuances regarding pure virtual functions:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数后跟一个 `=0`。此外，理解有关纯虚函数的以下细微差别也很重要：
- en: Usually, definitions for pure virtual functions are not provided. This equates
    to the operation (prototype only) being specified at the base class level and
    all methods (member function definitions) being supplied at the derived class
    level.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常不提供纯虚函数的定义。这相当于在基类级别指定操作（仅原型），并在派生类级别提供所有方法（成员函数定义）。
- en: Derived classes that do not provide methods for all pure virtual functions introduced
    by their base classes are also considered abstract and are therefore not instantiable.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 派生类没有为其基类引入的所有纯虚函数提供方法，也被认为是抽象的，因此不能实例化。
- en: The `=0` in the prototype is merely an indication to the linker that a definition
    for this function need not be linked in (or resolved) when creating an executable
    program.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型中的 `=0` 仅是向链接器指示，在创建可执行程序时，不需要（或解决）此函数的定义。
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: An abstract class is designated by including one or more pure virtual function
    prototypes in the class definition. The optional definitions for these methods
    are not typically provided.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类是通过在类定义中包含一个或多个纯虚函数原型来指定的。通常不提供这些方法的可选定义。
- en: The reason that pure virtual functions will most often not have a definition
    is because they are meant to provide a protocol of usage for polymorphic operations
    to be implemented in descendent classes. A pure virtual function designates a
    class to be abstract; an abstract class cannot be instantiated. Therefore, a definition
    provided in a pure virtual function will never be selected as the appropriate
    method for a polymorphic operation because instances of the abstract type will
    never exist. That being said, a pure virtual function can still provide a definition
    that could be explicitly called using the scope resolution operator (`::`) and
    base class name. Perhaps, this default behavior might be meaningful as a helper
    function used by derived class implementations.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 纯虚函数通常不会有定义的原因是它们旨在为在派生类中实现的多态操作提供一个使用协议。纯虚函数指定一个类为抽象类；抽象类不能被实例化。因此，在纯虚函数中提供的定义永远不会被选为多态操作的正确方法，因为抽象类型的实例永远不会存在。话虽如此，纯虚函数仍然可以提供一个定义，该定义可以使用作用域解析运算符（`::`）和基类名称显式调用。也许，这种默认行为可能对作为派生类实现中辅助函数的有意义。
- en: 'Let’s begin with a brief overview of the syntax required to specify an abstract
    class. Remember, a potential keyword of *abstract* is not used to specify an abstract
    class. Rather, by merely introducing one or more pure virtual functions, we have
    indicated the class to be an abstract class:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简要概述一下指定抽象类所需的语法开始。记住，使用*abstract*关键字本身并不用于指定抽象类。相反，仅仅通过引入一个或多个纯虚函数，我们就已经指明了该类是一个抽象类：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice that in the abstract class definition, we have introduced four virtual
    functions, three of which are pure virtual functions. The virtual destructor has
    no memory to release but is indicated as `virtual` so that it will be polymorphic,
    and so that the correct destruction sequence can be applied to derived class instances
    stored as pointers to base class types.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在抽象类定义中，我们引入了四个虚函数，其中三个是纯虚函数。虚析构函数没有内存需要释放，但被标记为`virtual`，以便它是多态的，并且可以应用于存储为基类类型指针的派生类实例的正确销毁顺序。
- en: The three pure virtual functions, `Print()`, `IsA()`, and `Speak()`, are indicated
    with `=0` in their prototype. There are no definitions for these operations (though
    there optionally can be). A pure virtual function can have a default implementation,
    but not as an inline function. It will be the derived class’ responsibility to
    provide methods for these operations using the interface (that is, signature)
    specified by this base class definition. Here, the pure virtual functions provide
    the *interface* for the polymorphic operations that will be defined in derived
    class definitions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 三个纯虚函数，`Print()`、`IsA()`和`Speak()`，在它们的原型中用`=0`表示。这些操作没有定义（尽管可以有选择地定义）。纯虚函数可以有默认实现，但不能作为内联函数。提供这些操作的方法的责任将落在派生类身上，使用由基类定义指定的接口（即签名）。在这里，纯虚函数为在派生类定义中定义的多态操作提供了*接口*。
- en: Important note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Abstract classes will certainly have derived classes (since we cannot instantiate
    an abstract class itself). In order to allow the virtual destructor mechanism
    to work appropriately in the eventual hierarchy, be sure to include a *virtual
    destructor* in the abstract class definition. This will ensure that all derived
    class destructors are *virtual*, and can be overridden to provide the correct
    entry point in an object’s destruction sequence.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类肯定会有派生类（因为我们不能实例化抽象类本身）。为了确保虚拟析构机制在最终层次结构中适当工作，请确保在抽象类定义中包含一个*虚拟析构函数*。这将确保所有派生类析构函数都是虚拟的，并且可以被重写以在对象的销毁顺序中提供正确的入口点。
- en: Now, let’s take a deeper look at what it means to have an interface, from an
    OO perspective.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从面向对象的角度更深入地探讨拥有接口的含义。
- en: Creating interfaces
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建接口
- en: An **interface class** is an OO concept of a class that is a further refinement
    of an abstract class. Whereas an abstract class can contain generalized attributes
    and default behaviors (by including data members and default definitions for pure
    virtual functions or by providing non-virtual member functions), an interface
    class will only contain abstract methods. An abstract class in C++ containing
    only abstract methods (that is, pure virtual functions with no optional definitions)
    can be thought of as an **interface class**.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口类**是一个类的面向对象概念，它是抽象类的一个进一步细化。而抽象类可以包含泛化属性和默认行为（通过包含数据成员和纯虚函数的默认定义，或者通过提供非虚成员函数），接口类将只包含抽象方法。在C++中，只包含抽象方法（即没有可选定义的纯虚函数）的抽象类可以被视为**接口类**。'
- en: 'When considering interface classes as implemented in C++, it is useful to remember
    the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑C++中实现的接口类时，记住以下内容是有用的：
- en: Abstract classes are not instantiable; they provide (via inheritance) the interfaces
    (that is, operations) that a derived class must offer.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类是不可实例化的；它们通过继承提供（即，接口，即操作）派生类必须提供的接口。
- en: Although a pure virtual function may contain an optional implementation (that
    is, method body) in the abstract class, this implementation should not be provided
    if the class wishes to be considered an interface class in pure OO terms.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然纯虚函数在抽象类中可能包含一个可选的实现（即，方法体），但如果类希望被视为在纯面向对象术语中的接口类，则不应提供此实现。
- en: Although an abstract class may have data members, it should not if the class
    wishes to be considered an interface class.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管抽象类可能包含数据成员，但如果类希望被视为接口类，则不应包含。
- en: An abstract method, in OO terms, is an operation without a method; it is the
    interface only and is implemented in C++ as a pure virtual function.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在面向对象术语中，抽象方法是一个没有方法的操作；它仅是接口，并在C++中作为纯虚函数实现。
- en: As a reminder, be sure to include a virtual destructor prototype in the interface
    class definition; this will ensure that derived class destructors will be virtual.
    The destructor definition should be empty.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为提醒，请确保在接口类定义中包含虚拟析构函数原型；这将确保派生类的析构函数将是虚拟的。析构函数定义应该是空的。
- en: Let’s consider various motivations for having interface classes within our OOP
    arsenal of implementation techniques. Some OOP languages follow very strict OO
    concepts and only allow for the implementation of very pure OO designs. Other
    OOP languages, such as C++, offer more flexibility, by allowing more radical OOP
    ideas to be implemented by the language directly.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑在面向对象编程（OOP）实现技术中拥有接口类的各种动机。一些面向对象编程（OOP）语言遵循非常严格的面向对象概念，并且只允许实现非常纯粹的面向对象设计。其他面向对象编程（OOP）语言，如C++，提供了更多的灵活性，允许通过语言直接实现更激进的面向对象思想。
- en: For example, in pure object-oriented terms, inheritance should be reserved for
    *Is-A* relationships. We’ve seen implementation inheritance, which C++ supports
    through private and protected base classes. We’ve seen some acceptable uses of
    implementation inheritance, that is, to implement a new class in terms of another
    (with the ability to hide the underlying implementation with the use of protected
    and public base classes).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在纯面向对象术语中，继承应该保留用于“是...的”关系。我们已经看到了实现继承，这是C++通过私有和受保护基类支持的。我们已经看到了一些可接受的实现继承的使用，即，通过另一个（使用受保护和公共基类使用的能力来隐藏底层实现）来实现一个新的类。
- en: Another example of a fringe OOP feature is that of multiple inheritance. We’ll
    see in [*Chapter 9*](B19087_09.xhtml#_idTextAnchor426), *Exploring Multiple Inheritance*,
    that C++ allows a class to be derived from more than one base class. In some cases,
    we are truly saying that the derived class has an Is-A relationship with potentially
    many base classes, but not always.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个边缘面向对象编程（OOP）特性的例子是多继承。我们将在[*第9章*](B19087_09.xhtml#_idTextAnchor426)，“探索多继承”中看到，C++允许一个类从多个基类派生。在某些情况下，我们确实是在说派生类与可能许多基类之间存在“是...的”关系，但并非总是如此。
- en: Some OOP languages do not allow multiple inheritance and those that do not rely
    more on interface classes to mix in the functionality of (otherwise) multiple
    base classes. In these situations, the OOP language can allow a derived class
    to implement the functionality as specified in multiple interface classes without
    actually using multiple inheritance. Ideally, interfaces are used to *mix-in*
    functionality from multiple classes. These classes, not surprisingly, are sometimes
    referred to as **mix-in** classes. In these situations, we are not saying that
    the Is-A relationship necessarily applies between derived and base classes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一些面向对象的语言不允许多重继承，而那些不允许多重继承的语言则更多地依赖于接口类来混合（否则）多个基类的功能。在这些情况下，面向对象的语言可以允许派生类根据多个接口类中指定的功能实现，而不实际使用多重继承。理想情况下，接口用于从多个类中*混合*功能。这些类，不出所料，有时被称为**混合**类。在这些情况下，我们并不是说派生类和基类之间必然存在Is-A关系。
- en: In C++, when we introduce an abstract class with only pure virtual functions,
    we can think of creating an interface class. When a new class mixes in functionality
    from multiple interfaces, we can think of this in OO terms as using each interface
    class as a means to mix-in the desired interfaces for behaviors. Note that the
    derived classes must override each of the pure virtual functions with their own
    implementation; we’re mixing in only the required API.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，当我们引入一个只包含纯虚函数的抽象类时，我们可以将其视为创建一个接口类。当一个新类从多个接口中混合功能时，我们可以从面向对象的角度将其视为使用每个接口类作为混合所需接口以实现行为的一种手段。请注意，派生类必须用自己的实现覆盖每个纯虚函数；我们只是在混合所需的API。
- en: C++’s implementation of the OO concept of an interface is merely that of an
    abstract class containing only pure virtual functions. Here, we’re using public
    inheritance from an abstract class paired with polymorphism to simulate the OO
    concept of an interface class. Note that other languages (such as Java) implement
    this idea directly in the language (but then those languages do not support multiple
    inheritance). In C++, we can do almost anything, yet it remains important to understand
    how to implement OO ideals (even those not offered with direct language support)
    in reasonable and meaningful ways.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: C++实现面向对象的接口概念仅仅是包含纯虚函数的抽象类。在这里，我们使用从抽象类的公共继承以及多态来模拟面向对象的接口类概念。请注意，其他语言（如Java）直接在语言中实现这个想法（但那些语言不支持多重继承）。在C++中，我们可以做几乎所有的事情，但了解如何以合理和有意义的方式实现面向对象的理念（即使这些理念没有直接的语言支持）仍然很重要。
- en: 'Let’s see an example to illustrate an abstract class used to implement an interface
    class:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来展示如何使用抽象类来实现接口类：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the aforementioned class definitions, we first notice a simple interface
    class, `Charitable`, implemented using a restricted abstract class. We include
    no data members and a pure virtual function `virtual void Give(float) = 0;` to
    define the interface class. We also include a virtual destructor.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述类定义中，我们首先注意到一个简单的接口类`Charitable`，它使用受限的抽象类实现。我们不包含数据成员，而是一个纯虚函数`virtual void
    Give(float) = 0;`来定义接口类。我们还包含一个虚析构函数。
- en: Next, `Person` is derived from `Charitable` using public inheritance to implement
    the `Charitable` interface. We simply override `virtual void Give(float);` to
    provide a default definition for *giving*. We then derive `Student` from `Person`;
    note that a *Student Is-A Person that mixes-in (or implements) the Charitable
    interface*. In our `Student` class, we choose to redefine `virtual void Give(float);`
    to provide a more suitable `Give()` definition for `Student` instances. Perhaps
    students have limited finances and opt to donate an amount of their time that
    is equivalent to a predetermined monetary amount.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`Person`通过公共继承从`Charitable`派生出来，以实现`Charitable`接口。我们简单地覆盖`virtual void Give(float);`以提供默认的*捐赠*定义。然后我们从`Person`派生出`Student`；请注意，*学生是Person的一个混合（或实现）Charitable接口的类*。在我们的`Student`类中，我们选择重新定义`virtual
    void Give(float);`以提供更适合`Student`实例的`Give()`定义。也许学生财务有限，选择捐赠相当于预定金额的时间。
- en: Here, we have used an abstract class in C++ to model the OO concept of an interface
    class.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用C++中的抽象类来模拟面向对象的接口类概念。
- en: Let’s continue with our discussion relating to abstract classes overall by examining
    how derived class objects may be collected by abstract class types.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论与抽象类相关的内容，通过考察派生类对象如何被抽象类类型收集来展开。
- en: Generalizing derived class objects as abstract types
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将派生类对象泛化为抽象类型
- en: We’ve seen in [*Chapter 7*](B19087_07.xhtml#_idTextAnchor366), *Utilizing Dynamic
    Binding through Polymorphism*, that it is reasonable at times to group related
    derived class instances in a collection that is stored using base class pointers.
    Doing so allows uniform processing of related derived class types using polymorphic
    operations as specified by the base class. We also know that when a polymorphic
    base class operation is invoked, the correct derived class method will be invoked
    at runtime by virtue of the virtual functions and internal v-table that implement
    polymorphism in C++.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第7章*](B19087_07.xhtml#_idTextAnchor366)，“通过多态利用动态绑定”，看到有时将相关的派生类实例分组到一个使用基类指针存储的集合中是合理的。这样做允许使用基类指定的多态操作对相关的派生类类型进行统一处理。我们还知道，当调用多态基类操作时，由于C++中实现多态的虚函数和内部v-table，将在运行时调用正确的派生类方法。
- en: You may contemplate, however, whether it is possible to collect a group of related
    derived class types by a base class type that is an abstract class. Remember,
    an abstract class is not instantiable, so how might we store a derived class object
    as an object that cannot be instantiated? The solution is to use *pointers* (or
    even a reference). Whereas we cannot collect derived class instances in a set
    of abstract base class instances (those types cannot be instantiated), we can
    collect derived class instances in a set of pointers of the abstract class type.
    We may also have a reference of the abstract class type refer to a derived class
    instance. We’ve been doing this type of grouping (with base class pointers) since
    we learned about polymorphism.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以思考一下，是否有可能通过一个抽象基类类型来收集一组相关的派生类类型。记住，抽象类是不可实例化的，那么我们如何将派生类对象存储为一个不能实例化的对象呢？解决方案是使用*指针*（甚至是一个引用）。由于我们不能在抽象基类实例的集合中收集派生类实例（这些类型不能实例化），我们可以在抽象类类型的指针集合中收集派生类实例。我们还可以让抽象类类型的引用指向派生类实例。自从我们学习了多态性以来，我们就一直在做这种类型的分组（使用基类指针）。
- en: Generalized groups of specialized objects employ implicit upcasting. Undoing
    such an upcast must be done using an explicit downcast, and the programmer will
    need to be correct as to the derived type that has been previously generalized.
    An incorrect downcast to the wrong type will cause a runtime error.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 专门对象的泛化组使用隐式向上转型。撤销这种向上转型必须使用显式向下转型来完成，程序员需要确保之前泛化的派生类型是正确的。错误的向下转型到错误类型将导致运行时错误。
- en: When is it necessary to collect derived class objects by base class types, including
    abstract base class types? The answer is when it makes sense in your application
    to process related derived class types in a more generic way, that is, when the
    operations specified in the base class type account for all of the operations
    you’d like to utilize. Undeniably, you may find just as many situations where
    keeping derived class instances in their own type (to utilize specialized operations
    introduced at the derived class level) is reasonable. Now you understand what
    is possible.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在什么情况下有必要通过基类类型（包括抽象基类类型）收集派生类对象？答案是当在你的应用程序中按更通用的方式处理相关的派生类类型是有意义的时候，也就是说，当基类类型中指定的操作涵盖了您希望利用的所有操作时。不可否认，你可能会发现同样多的情况，其中保持派生类实例在其自己的类型中（以利用在派生类级别引入的专用操作）是合理的。现在你理解了可能发生的情况。
- en: Let’s continue by examining a comprehensive example showing abstract classes
    in action.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续通过检查一个展示抽象类在行动中的综合示例来继续。
- en: Putting all the pieces together
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有部件组合在一起
- en: So far in this chapter, we have understood the subtleties of abstract classes,
    including pure virtual functions, and how to create interface classes using abstract
    classes and pure virtual functions. It is always important to see our code in
    action, with all its various components and their various nuances.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经理解了抽象类的微妙之处，包括纯虚函数，以及如何使用抽象类和纯虚函数创建接口类。始终重要的是要看到我们的代码在行动中的表现，以及其所有各种组件及其各种细微差别。
- en: 'Let’s take a look at a more complex, full program example to fully illustrate
    abstract classes, implemented using pure virtual functions in C++. In this example,
    we will not further designate an abstract class as an interface class, but we
    will take the opportunity to collect related derived class types using a set of
    pointers of their abstract base class type. This example will be broken into many
    segments; the full program can be found in the following GitHub location:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个更复杂、完整的程序示例，以完全说明使用纯虚函数实现的抽象类。在这个例子中，我们不会进一步将抽象类指定为接口类，但我们将有机会使用它们抽象基类类型的一组指针收集相关的派生类类型。这个例子将被分成多个部分；完整的程序可以在以下GitHub位置找到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter08/Chp8-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter08/Chp8-Ex1.cpp)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter08/Chp8-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter08/Chp8-Ex1.cpp)'
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the aforementioned class definition, we notice that `LifeForm` is an abstract
    class. It is an abstract class because it contains at least one pure virtual function
    definition. In fact, it contains three pure virtual function definitions, namely
    `Print()`, `IsA()`, and `Speak()`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述类定义中，我们注意到`LifeForm`是一个抽象类。它是一个抽象类，因为它至少包含一个纯虚函数的定义。实际上，它包含三个纯虚函数的定义，即`Print()`、`IsA()`和`Speak()`。
- en: 'Now, let’s extend `Lifeform` with a concrete derived class, `Cat`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过一个具体的派生类`Cat`来扩展`Lifeform`：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the previous segment of code, we see the class definition for `Cat`. Notice
    that `Cat` has redefined `LifeForm`’s pure virtual functions `Print()`, `IsA()`,
    and `Speak()` by providing definitions for each of these methods in the `Cat`
    class. With the existing methods in place for these functions, any derived class
    of `Cat` may optionally choose to redefine these methods with more suitable versions
    (but they are no longer obligated to do so).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码段中，我们看到了`Cat`类的定义。注意，`Cat`通过在`Cat`类中为这些方法提供定义，重新定义了`LifeForm`的纯虚函数`Print()`、`IsA()`和`Speak()`。由于这些函数已经有了现有的方法，任何`Cat`的派生类都可以选择性地重新定义这些方法以使用更合适的版本（但它们不再有义务这样做）。
- en: Note that if `Cat` had failed to redefine even one of the pure virtual functions
    of `LifeForm`, then `Cat` would also be considered an abstract class and therefore
    not instantiable.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果`Cat`未能重新定义`LifeForm`的任何一个纯虚函数，那么`Cat`也将被视为一个抽象类，因此不能实例化。
- en: As a reminder, even though virtual functions `IsA()` and `Speak()` are written
    inline to abbreviate the code, virtual functions will almost never be inlined
    by the compiler, as their correct method must be determined at runtime (except
    for a few cases involving compiler devirtualization, involving final methods,
    or when an instance’s dynamic type is known).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，尽管`IsA()`和`Speak()`虚函数被内联编写以缩短代码，但编译器几乎永远不会内联虚函数，因为它们的正确方法必须在运行时确定（除了涉及编译器去虚化、final方法或实例的动态类型已知的一些情况）。
- en: Notice that in the `Cat` constructors, the member initialization list is used
    to select the `LifeForm` constructor that takes an integer argument (that is,
    `:LifeForm(CAT_LIFE)`). A value of `15` (`CAT_LIFE`) is passed up to the `LifeForm`
    constructor to initialize `lifeExpectancy`, defined in `LifeForm`, to the value
    of `15`. The member initialization list is additionally used to initialize data
    members defined in the `Cat` class for the cases when in-class initialization
    is not used (that is, the value is determined by a parameter to the method).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`Cat`构造函数中，成员初始化列表被用来选择接受一个整型参数的`LifeForm`构造函数（即`:LifeForm(CAT_LIFE)`）。值`15`（`CAT_LIFE`）被传递给`LifeForm`构造函数，以将`LifeForm`中定义的`lifeExpectancy`初始化为`15`。此外，成员初始化列表还用于初始化`Cat`类中定义的数据成员，在类内初始化未使用的情况下（即，值由方法的参数确定）。
- en: 'Now, let’s move forward to the class definition for `Person`, along with its
    inline functions:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续前进到`Person`类的定义，以及它的内联函数：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that `Person` now extends `LifeForm` using public inheritance. In previous
    chapters, `Person` was a base class at the top of the inheritance hierarchy. `Person`
    redefines the pure virtual functions from `LifeForm`, namely, `Print()`, `IsA()`,
    and `Speak()`. As such, `Person` is now a concrete class and can be instantiated.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意现在`Person`使用公有继承扩展了`LifeForm`。在之前的章节中，`Person`是继承层次结构顶部的基类。`Person`重新定义了来自`LifeForm`的纯虚函数，即`Print()`、`IsA()`和`Speak()`。因此，`Person`现在是一个具体类，可以被实例化。
- en: 'Now, let’s review the member function definitions for `Person`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾`Person`的成员函数定义：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the `Person` member functions, notice that we have implementations for `Print()`,
    `IsA()`, and `Speak()`. Additionally, notice that in two of the `Person` constructors,
    we select `:LifeForm(PERSON_LIFE)` in their member initialization lists to call
    the `LifeForm(int)` constructor. This call will set the private inherited data
    member `LifeExpectancy` to `80` (`PERSON_LIFE`) in the `LifeForm` subobject of
    a given `Person` instance.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Person`成员函数中，请注意我们为`Print()`、`IsA()`和`Speak()`提供了实现。此外，请注意在两个`Person`构造函数中，我们在它们的成员初始化列表中选择了`:LifeForm(PERSON_LIFE)`来调用`LifeForm(int)`构造函数。这个调用将设置私有继承数据成员`LifeExpectancy`为`80`（`PERSON_LIFE`）在给定`Person`实例的`LifeForm`子对象中。
- en: 'Next, let’s review the `Student` class definition, along with its inline function
    definitions:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们回顾`Student`类的定义，以及它的内联函数定义：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The aforementioned class definition for `Student` looks much as we’ve seen in
    the past. `Student` extends `Person` using public inheritance because a `Student`
    *Is-A* `Person`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 上述`Student`类的定义看起来与我们过去看到的非常相似。`Student`使用公有继承扩展了`Person`，因为`Student`是`Person`的一个子类。
- en: 'Moving forward, we’ll recall the non-inline `Student` class member functions:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将回顾非内联的`Student`类成员函数：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the previously listed section of code, we see the non-inline member function
    definitions for `Student`. The complete class definition is, at this point, largely
    familiar to us.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前列出的代码部分中，我们看到`Student`的非内联成员函数定义。到这一点，完整的类定义对我们来说在很大程度上是熟悉的。
- en: 'Accordingly, let’s examine the `main()` function:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们检查`main()`函数：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, in `main()`, we declare an array of pointers to `LifeForn`. Recall, `LifeForm`
    is an abstract class. We could not create an array of `LifeForm` objects, because
    that would require us to be able to instantiate a `LifeForm`; we can’t – `LifeForm`
    is an abstract class.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在`main()`函数中，我们声明了一个指向`LifeForm`的指针数组。回想一下，`LifeForm`是一个抽象类。我们不能创建一个`LifeForm`对象的数组，因为这需要我们能够实例化一个`LifeForm`；我们不能——`LifeForm`是一个抽象类。
- en: However, we can create a set of pointers to an abstract type and this allows
    us to collect related types, `Person`, `Student`, and `Cat` instances in this
    set. Of course, the only operations we may apply to instances stored in this generalized
    fashion are those found in the abstract base class, `LifeForm`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以创建一个抽象类型的指针集合，这允许我们收集相关类型，例如在这个集合中收集`Person`、`Student`和`Cat`实例。当然，我们可能应用于以这种泛型方式存储的实例的操作仅限于在抽象基类`LifeForm`中找到的操作。
- en: Next, we allocate a variety of `Person`, `Student`, and `Cat` instances, storing
    each instance via an element in the generalized set of pointers of type `LifeForm`.
    When any of these derived class instances is stored in this fashion, an implicit
    upcast to the abstract base class type is performed (but the instance is not altered
    in any fashion – we’re just pointing to the most base class subobject comprising
    the entire memory layout).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们分配了各种`Person`、`Student`和`Cat`实例，通过类型为`LifeForm`的泛型指针集合的元素存储每个实例。当任何这些派生类实例以这种方式存储时，将执行隐式向上转换到抽象基类类型（但实例本身不会被任何方式改变——我们只是在指向构成整个内存布局的最基础类子对象）。
- en: Now, we proceed through a loop to apply operations as found in the abstract
    class `LifeForm` to all instances in this generalized collection, such as `Speak()`,
    `Print()`, and `IsA()`. These operations happen to be polymorphic, allowing each
    instance’s most appropriate implementation to be utilized via dynamic binding.
    We additionally invoke `GetLifeExpectancy()` on each of these instances, which
    is a non-virtual function found at the `LifeForm` level. This function merely
    returns the life expectancy of the `LifeForm` in question.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们通过循环应用在抽象类`LifeForm`中找到的操作，将这些操作应用于这个泛型集合中的所有实例，例如`Speak()`、`Print()`和`IsA()`。这些操作恰好是多态的，允许通过动态绑定利用每个实例最合适的实现。我们还对每个这些实例调用了`GetLifeExpectancy()`，这是一个在`LifeForm`级别找到的非虚函数。这个函数仅仅返回所讨论的`LifeForm`的生命预期。
- en: Lastly, we loop through deleting the dynamically allocated instances of `Person`,
    `Student`, and `Cat` again using the generalized `LifeForm` pointers. We know
    that `delete()` will patch in a call to the destructor, and because the destructor
    is virtual, the appropriate starting level of the destructor and proper destruction
    sequence will commence. Additionally, by setting `item = nullptr;`, we are ensuring
    that the deleted pointer will not be used mistakenly as a bonafide address (we
    are overwriting each relinquished address with a `nullptr`).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们再次通过使用通用的`LifeForm`指针来遍历删除`Person`、`Student`和`Cat`的动态分配实例。我们知道`delete()`会调用析构函数，并且由于析构函数是虚函数，因此将开始适当的析构函数起始级别和正确的销毁顺序。此外，通过设置`item
    = nullptr;`，我们确保被删除的指针不会错误地用作有效地址（我们正在用`nullptr`覆盖每个释放的地址）。
- en: The utility of the abstract class `LifeForm` in this example is that its use
    allows us to generalize common aspects and behaviors of all `LifeForm` objects
    together in one base class (such as `lifeExpectancy` and `GetLifeExpectancy()`).
    The common behaviors also extend to a set of pure virtual functions with the desired
    interfaces that all `LifeForm` objects should have, namely `Print()`, `IsA()`,
    and `Speak()`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，抽象类`LifeForm`的效用在于，它的使用允许我们将所有`LifeForm`对象的共同方面和行为集中在一个基类中（例如`lifeExpectancy`和`GetLifeExpectancy()`）。这些共同行为还扩展到一组具有所需接口的纯虚函数，即所有`LifeForm`对象都应该有的`Print()`、`IsA()`和`Speak()`。
- en: Important reminder
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: An abstract class is one that collects common traits of derived classes, yet
    does not itself represent a tangible entity or object that should be instantiated.
    In order to specify a class as abstract, it must contain at least one pure virtual
    function.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类是收集派生类共同特性的类，但它本身并不代表一个有形的实体或对象，不应该被实例化。为了指定一个类为抽象类，它必须至少包含一个纯虚函数。
- en: Looking at the output for the aforementioned program, we can see that objects
    of various related derived class types are instantiated and processed uniformly.
    Here, we’ve collected these objects by their abstract base class type and have
    overridden the pure virtual functions in the base class with meaningful definitions
    in various derived classes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 观察上述程序的输出，我们可以看到各种相关派生类类型的对象被实例化和统一处理。在这里，我们通过它们的抽象基类类型收集了这些对象，并在各种派生类中对基类中的纯虚函数进行了有意义的定义。
- en: 'Here is the output for the full program example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是完整程序示例的输出：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We have now thoroughly examined the OO idea of an abstract class and how it
    is implemented in C++ using pure virtual functions, as well as how these ideas
    can extend to creating OO interfaces. Let’s briefly recap the language features
    and OO concepts we’ve covered in this chapter before moving onward to our next
    chapter.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经彻底研究了抽象类的OO概念及其在C++中使用纯虚函数的实现，以及这些想法如何扩展到创建OO接口。在继续下一章之前，让我们简要回顾一下本章中我们涵盖的语言特性和OO概念。
- en: Summary
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have continued our progression with object-oriented programming,
    foremost, by understanding how pure virtual functions in C++ provide direct language
    support for the OO concept of an abstract class. We have explored how abstract
    classes without data members that do not contain non-virtual functions can support
    the OO ideal of an interface class. We’ve talked about how other OOP languages
    utilize interface classes, and how C++ may choose to support this paradigm as
    well by using such restricted abstract classes. We’ve upcast related derived class
    types to be stored as pointers of the abstract base class type, as a typical,
    and overall very useful, programming technique.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们继续通过面向对象编程来推进我们的学习，首先，通过理解C++中的纯虚函数如何直接提供对抽象类OO概念的语言支持。我们探讨了没有数据成员且不包含非虚函数的抽象类如何支持OO理想中的接口类。我们讨论了其他OOP语言如何利用接口类，以及C++可能如何通过使用这种受限的抽象类来支持这种范式。我们将相关的派生类类型向上转换为存储为抽象基类类型的指针，这是一种典型且非常有用的编程技术。
- en: We have seen how abstract classes complement polymorphism not only by providing
    a class to specify common attributes and behaviors that derived classes share,
    but most notably to provide the interfaces of polymorphic behaviors for the related
    classes since abstract classes themselves are not instantiable.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，抽象类如何通过提供指定派生类共享的公共属性和行为，不仅补充了多态性，而且最值得注意的是，为相关类提供了多态行为的接口，因为抽象类本身是不可实例化的。
- en: By adding abstract classes and potentially the OO concept of interface classes
    to our programming repertoire in C++, we are able to implement designs that promote
    easily extensible code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将抽象类和可能的对象导向概念中的接口类添加到我们的C++编程资源中，我们能够实现促进代码易于扩展的设计。
- en: We are now ready to continue to [*Chapter 9*](B19087_09.xhtml#_idTextAnchor426),
    *Exploring Multiple Inheritance*, to enhance our OOP skills by next learning how
    and when to appropriately utilize the concept of multiple inheritance, while understanding
    trade-offs and potential design alternatives. Let’s move forward!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备继续学习[第9章](B19087_09.xhtml#_idTextAnchor426)《探索多重继承》，通过学习如何和何时恰当地利用多重继承的概念来增强我们的面向对象编程技能，同时理解权衡和潜在的设计替代方案。让我们继续前进！
- en: Questions
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Create a hierarchy of shapes using the following guidelines:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下指南创建形状的层次结构：
- en: 'Create an abstract base class called `Shape`, which defines an operation to
    compute the area of a shape. Do not include a method for the `Area()` operation.
    Hint: use a pure virtual function.'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Shape`的抽象基类，该类定义了一个计算形状面积的操作。不要包含`Area()`操作的任何方法。提示：使用纯虚函数。
- en: Derive classes `Rectangle`, `Circle`, and `Triangle` from `Shape` using public
    inheritance. Optionally, derive class `Square` from `Rectangle`. Redefine the
    operation `Area()` that `Shape` has introduced, in each derived class. Be sure
    to provide the method to support the operation in each derived class so that you
    can later instantiate each type of `Shape`.
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Shape`类使用公有继承派生出`Rectangle`、`Circle`和`Triangle`类。可选地，从`Rectangle`类派生出`Square`类。在每个派生类中重新定义`Shape`类引入的`Area()`操作。确保为每个派生类提供支持该操作的方法，以便你以后可以实例化每种类型的`Shape`。
- en: Add data members and other member functions as necessary to complete the newly
    introduced class definitions. Remember, only common attributes and operations
    should be specified in `Shape` – all others belong in their respective derived
    classes. Don’t forget to implement the copy constructor and access functions within
    each class definition.
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要添加数据成员和其他成员函数以完成新引入的类定义。记住，只有公共属性和操作应该在`Shape`中指定——所有其他属性都属于它们各自的派生类。不要忘记在每个类定义中实现复制构造函数和访问函数。
- en: Create an array of pointers of the abstract class type, `Shape`. Assign elements
    in this array point to instances of type `Rectangle`, `Square`, `Circle`, and
    `Triangle`. Since you are now treating derived class objects as generalized `Shape`
    objects, loop through the array of pointers and invoke the `Area()` function for
    each. Be sure to `delete()` any dynamically allocated memory you have allocated.
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个抽象类`Shape`类型的指针数组。将数组中的元素分配给`Rectangle`、`Square`、`Circle`和`Triangle`类型的实例。由于你现在将派生类对象作为通用的`Shape`对象处理，因此遍历指针数组并对每个实例调用`Area()`函数。确保删除你分配的任何动态分配的内存。
- en: Is your abstract `Shape` class also an interface class in conceptual OO terms?
    Why, or why not?
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的抽象`Shape`类在概念面向对象术语中也是一个接口类吗？为什么，或者为什么不？
