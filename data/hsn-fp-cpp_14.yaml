- en: Property-Based Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于属性的测试
- en: We've seen that pure functions have one important property—they return the same
    output for the same inputs. We've also seen that this property allows us to easily
    write example-based unit tests for pure functions. Moreover, we can write data-driven
    tests, allowing one test function to be reused with multiple inputs and outputs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到纯函数有一个重要的属性——它们对于相同的输入返回相同的输出。我们也看到这个属性使我们能够轻松地为纯函数编写基于示例的单元测试。此外，我们可以编写数据驱动的测试，允许一个测试函数被多个输入和输出重复使用。
- en: It turns out that we can do even better. Instead of, or in addition to, writing
    many lines of data-driven tests, we can take advantage of mathematical properties
    of pure functions. This technique is possible due to data generators that are
    enabled by functional programming. These tests are confusingly named **property-based
    tests**; you'll have to remember that the name comes from mathematical properties
    of pure functions, and not from properties implemented in classes or objects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，我们甚至可以做得更好。除了编写许多行的数据驱动测试之外，我们还可以利用纯函数的数学属性。这种技术是由函数式编程启用的数据生成器所实现的。这些测试被误导地称为**基于属性的测试**；您必须记住，这个名称来自纯函数的数学属性，而不是来自类或对象中实现的属性。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the idea of property-based tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解基于属性的测试的概念
- en: How to write generators and take advantage of them
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写生成器并利用它们
- en: How to get to property-based tests from example-based tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从基于示例的测试转向基于属性的测试
- en: How to write good properties
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写良好的属性
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need a compiler that supports C++ 17\. I used GCC 7.4.0.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要一个支持C++ 17的编译器。我使用的是GCC 7.4.0。
- en: The code can be found on GitHub at [https:/​/​github.​com/​PacktPublishing/​Hands-​On-​Functional-Programming-​with-​Cpp](https://github.%E2%80%8Bcom/PacktPublishing/Hands-On-Functional-Programming-with-Cpp)
    in the `Chapter11` folder. It includes and uses `doctest`, which is a single header
    open source unit testing library. You can find it on its GitHub repository at [https:/​/github.com/​onqtam/​doctest](https://github.%E2%80%8Bcom/onqtam/doctest).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可以在GitHub上找到，网址为[https:/​/​github.​com/​PacktPublishing/​Hands-​On-​Functional-Programming-​with-​Cpp](https://github.%E2%80%8Bcom/PacktPublishing/Hands-On-Functional-Programming-with-Cpp)，位于`Chapter11`文件夹中。它包括并使用了`doctest`，这是一个单头开源单元测试库。您可以在其GitHub存储库上找到它，网址为[https:/​/github.com/​onqtam/​doctest](https://github.%E2%80%8Bcom/onqtam/doctest)。
- en: Property-based testing
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于属性的测试
- en: 'Unit tests are an extremely useful software development technique. A good suite
    of unit tests can do the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是一种非常有用的软件开发技术。一套良好的单元测试可以做到以下几点：
- en: Speed up deployments by automating the boring parts of regression testing.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过自动化回归测试的繁琐部分来加快部署速度。
- en: Enable professional testers to find the hidden issues rather than running the
    same test plan again and again.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使专业测试人员能够发现隐藏的问题，而不是一遍又一遍地运行相同的测试计划。
- en: Remove bugs very early in the development process, thereby reducing the cost
    of finding and fixing them.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发过程的早期消除错误，从而减少查找和修复错误的成本。
- en: Improve the software design by providing feedback as a first client of the code
    structure (if tests are complicated, most likely your design is complicated),
    as long as the developers know how to see and interpret the feedback.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过提供反馈来改进软件设计，作为代码结构的第一个客户端（如果测试复杂，很可能您的设计也很复杂），只要开发人员知道如何看到和解释反馈。
- en: Increase the trust in the code, hence allowing for more changes, and thereby
    facilitating refactoring that speeds up development or removes risks from the
    code.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加对代码的信任，从而允许更多的更改，从而促进加速开发或消除代码中的风险。
- en: I love writing unit tests. I love figuring out the interesting test cases, and
    I love using tests to drive my code—as you've seen in [Chapter 9](f3b31186-dfef-496e-bc6e-82a55eeb0cba.xhtml),
    *Test-Driven Development for Functional Programming*. At the same time, I'm always
    looking for better ways to write the tests, since it would be great if we could
    speed up the process.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢编写单元测试。我喜欢找出有趣的测试用例，我喜欢使用测试驱动我的代码——正如您在[第9章](f3b31186-dfef-496e-bc6e-82a55eeb0cba.xhtml)中所看到的，*函数式编程的测试驱动开发*。与此同时，我一直在寻找更好的编写测试的方法，因为如果我们能加快这个过程，那将是很棒的。
- en: We've seen in [Chapter 9](f3b31186-dfef-496e-bc6e-82a55eeb0cba.xhtml), *Test-Driven
    Development for Functional Programming*, that pure functions allow us to more
    easily identify test cases, because, by definition, their outputs are constrained.
    It turns out that we can go further than that if we venture into the realm of
    mathematical properties associated with these pure functions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第9章](f3b31186-dfef-496e-bc6e-82a55eeb0cba.xhtml)中看到，纯函数使我们更容易识别测试用例，因为根据定义，它们的输出是受限制的。事实证明，如果我们涉足与这些纯函数相关的数学属性领域，我们可以走得更远。
- en: If you've been writing unit tests for a while, you probably had the feeling
    that some of the tests are a bit redundant. If only we could write tests like
    this—for inputs in a certain interval of values, the expected outputs must have
    a certain property. It turns out that, with the help of data generators and a
    bit of abstract thinking, we can make this work.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经写了一段时间的单元测试，您可能会觉得其中一些测试有点多余。如果我们能够编写这样的测试——对于一定范围内的输入，预期输出必须具有某种属性，那将是很好的。事实证明，借助数据生成器和一点抽象思维，我们可以做到这一点。
- en: Let's compare approaches.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较一下方法。
- en: Example-based tests versus property-based tests
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于示例的测试与基于属性的测试
- en: 'Let''s take an example of the `power` function:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以`power`函数为例：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'How would you test it using example-based tests? We need to figure out a few
    interesting values for first and second and combine them. We''ll limit ourselves
    to positive integers for the goal of this exercise. In general, interesting values
    for integers are—`0`, `1`, many, and maximum. This leads to the following possible
    cases:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如何使用基于示例的测试来测试它？我们需要找出一些有趣的值作为第一个和第二个，并将它们组合。对于这个练习的目标，我们将限制自己只使用正整数。一般来说，整数的有趣值是`0`，`1`，很多，和最大值。这导致了以下可能的情况：
- en: '*0⁰ -> undefined* (* the `pow` implementation in C++ returns `1` unless specific
    errors are enabled)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*0⁰ -> 未定义*（在C++的pow实现中，除非启用了特定错误，否则返回`1`）'
- en: '*0^(any integer from 0 to max) -> 0*'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*0^(0到max之间的任何整数) -> 0*'
- en: '*1^(any integer) -> 1*'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*1^(任何整数) -> 1*'
- en: '*(any integer except 0)⁰ -> 1*'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*(除了0之外的任何整数)⁰ -> 1*'
- en: '*2² -> 4*'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*2² -> 4*'
- en: '*2^(max integer that doesn''t overflow) -> value to be computed*'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*2^(不会溢出的最大整数) -> 要计算的值*'
- en: '*10⁵ -> 100000*'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*10⁵ -> 100000*'
- en: '*10^(max integer that doesn''t overflow) -> value to be computed*'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*10^(不会溢出的最大整数) -> 要计算的值*'
- en: 'This list is by no means complete, but it shows an interesting analysis of
    the problem. So, let''s write these tests:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个清单当然并不完整，但它展示了对问题的有趣分析。因此，让我们写下这些测试：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is obviously not the full list of tests we would need to check to establish
    that the power function works, but it's a good start. While looking at this list,
    I'm wondering, what do you think—would you write more or fewer tests? I would
    definitely want to write more, but I lost the drive in the process. Sure, one
    of the issues is that I wrote these tests after the code; I'm much more motivated
    to write them along with the code as in **Test-Driven Development** (**TDD**).
    But maybe there's a better way?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然不是我们需要检查以确保幂函数有效的所有测试的完整清单，但这是一个很好的开始。看着这个清单，我在想，你认为——你会写更多还是更少的测试？我肯定想写更多，但在这个过程中我失去了动力。当然，其中一个问题是我是在编写代码之后才写这些测试；我更有动力的是在编写代码的同时编写测试，就像**测试驱动开发**（**TDD**）一样。但也许有更好的方法？
- en: 'Let''s think differently for a moment. Are there properties we can test that
    hold for some or all of the expected outputs? Let''s write a list:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们换个角度思考一下。有没有一些我们可以测试的属性，适用于一些或所有的预期输出？让我们写一个清单：
- en: '*0⁰ -> undefined (1 by default in pow function in C++)*'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*0⁰ -> 未定义（在C++的pow函数中默认为1）*'
- en: '*0^([1 .. maxInt]) -> 0*'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*0^([1 .. maxInt]) -> 0*'
- en: '*value: [1 .. maxInt]⁰ -> 1*'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*值：[1 .. maxInt]⁰ -> 1*'
- en: '*value: [0 .. maxInt]¹ -> value*'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*值：[0 .. maxInt]¹ -> 值*'
- en: 'These are some obvious properties. They cover, however, only a small subset
    of the values. We still need to cover the general case of *x**^y*, where both
    *x* and *y* are neither `0` nor `1`. Can we find any property here? Well, think
    about the mathematical definition of integer power—it''s a repeated multiplication.
    We can therefore infer, for any *x* and *y* value greater than `1`, the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些明显的属性。然而，它们只涵盖了一小部分值。我们仍然需要涵盖*x**^y*的一般情况，其中*x*和*y*都不是`0`或`1`。我们能找到任何属性吗？好吧，想想整数幂的数学定义——它是重复的乘法。因此，我们可以推断，对于大于`1`的任何*x*和*y*值，以下成立：
- en: '![](img/785b00f6-7df4-4d02-94ee-1e520377ed0c.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/785b00f6-7df4-4d02-94ee-1e520377ed0c.png)'
- en: We do have a boundary issue here, since the computation might overflow. So,
    the values of *x* and *y* need to be picked so that *x^y* is smaller than `maxInt`.
    One way to deal with this issue is to pick *x* first and pick *y* between *y=2*
    and `maxy=floor(log[x]maxInt)`. To make it as close to boundaries as possible,
    we should always pick `maxy` as a value. To check for the overflow case, we just
    need to test that *x* to the power of `maxy + 1` overflows.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里有一个边界问题，因为计算可能会溢出。因此，需要选择*x*和*y*的值，使*x^y*小于`maxInt`。解决这个问题的一种方法是首先选择*x*，然后选择*y*在*y=2*和`maxy=floor(log[x]maxInt)`之间。为了尽可能接近边界，我们应该始终选择`maxy`作为一个值。要检查溢出情况，我们只需要测试*x*的`maxy
    + 1`次方是否溢出。
- en: The preceding approach implies, of course, that we trust the result of the logarithm
    function from the standard library. If your *tester paranoia* is larger than mine,
    I suggest using a verified logarithm table for all bases from `2` to `maxInt`
    and the value `maxInt`. I will, however, use the STL logarithm function.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法当然意味着我们信任标准库中对数函数的结果。如果你的“测试者偏执狂”比我更大，我建议使用经过验证的对数表，包括从`2`到`maxInt`和值`maxInt`的所有基数。然而，我会使用STL对数函数。
- en: We now have a list of the mathematical properties of the power function. But
    we'd like to implement them as previously seen, with intervals. Can we even do
    that? Enter data generators.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了幂函数的数学属性清单。但我们想要像之前看到的那样，使用区间来实现它们。我们能做到吗？这就是数据生成器的作用。
- en: Generators
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器
- en: 'Generators are a staple feature of functional programming languages. They are
    usually implemented through a combination of lambdas and lazy evaluation, allowing
    code like the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器是函数式编程语言的一个重要特性。它们通常通过lambda和惰性求值的组合来实现，允许编写以下代码：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The generator function usually generates an infinite number of values, but because
    it is lazy evaluated, the `100` values materialize only when `pick` is called.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数通常会生成无限数量的值，但由于它是惰性求值的，只有在调用`pick`时，这`100`个值才会实现。
- en: C++ doesn't yet have standard support for lazy evaluation and data generators,
    so we'll have to implement our own generator. It's worth noting that C++ 20 has
    adopted the inclusion of the awesome ranges library in the standard, which enables
    both these features. For the goals of this chapter, we'll stick to the standard
    available today, but you'll find the basic usage of ranges library in the final
    chapters of this book.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: C++目前还没有标准支持惰性求值和数据生成器，因此我们必须实现自己的生成器。值得注意的是，C++ 20已经采纳了在标准中包含了令人敬畏的ranges库，该库可以实现这两个功能。对于本章的目标，我们将坚持使用今天可用的标准，但你将在本书的最后几章中找到ranges库的基本用法。
- en: 'First, how can we generate data? STL offers us a nice way to generate uniformly
    distributed random integers by using the `uniform_int_distribution` class. Let''s
    first look at the code; I''ve added comments to explain what happens:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们如何生成数据？STL为我们提供了一种生成均匀分布的随机整数的好方法，使用`uniform_int_distribution`类。让我们先看看代码；我已经添加了注释来解释发生了什么：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This function will generate uniformly distributed numbers from `min` to `max`.
    I prefer to always include the edges of the intervals, since these are always
    interesting values for tests.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将从`min`到`max`生成均匀分布的数字。我倾向于始终包括区间的边缘，因为这些对于测试来说总是有趣的值。
- en: 'We''re also using a function called `range` that you haven''t seen yet. Its
    goal is to fill a vector with the values from `minValue` to `maxValue` to allow
    simpler transformations. Here it is:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了一个名为`range`的函数，您还没有看到。它的目标是用`minValue`到`maxValue`的值填充一个向量，以便进行简单的转换。在这里：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It's worth noting that ranges are usually lazy-evaluated in functional programming
    languages, which highly reduces their memory footprint. For the goals of our example
    though, this works fine.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在函数式编程语言中，范围通常是惰性求值的，这大大减少了它们的内存占用。不过，对于我们的示例目标来说，这也很好用。
- en: 'The previous `generator` function allows us to create input data for our tests,
    uniformly distributed between one and the maximum integer value. It just takes
    a simple bind:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的`generator`函数允许我们为我们的测试创建输入数据，这些数据在1和最大整数值之间均匀分布。它只需要一个简单的绑定：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's use this for our property-based tests.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其用于我们的属性测试。
- en: Putting the properties to the test
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将属性放到测试中
- en: 'Let''s see again the list of properties that we''d like to check:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看我们想要检查的属性列表：
- en: '*0⁰ -> undefined (1 by default in pow function in C++)*'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*0⁰ -> 未定义（在C++的pow函数中默认为1）*'
- en: '*0^([1 .. maxInt]) -> 0*'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*0^([1 .. maxInt]) -> 0*'
- en: '*value: [1 .. maxInt]⁰ -> 1*'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*值：[1 .. maxInt]⁰ -> 1*'
- en: '*value: [0 .. maxInt]¹ -> value*'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*值：[0 .. maxInt]¹ -> 值*'
- en: '*x^y = x^(y-1) * x*'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x^y = x^(y-1) * x*'
- en: We will now implement each of the properties in turn. For every property, we
    will use either a normal example-based test, or the data generators inspired by
    the `generate_ints_greater_than_1` function. Let's start with the simplest property—*0⁰*
    should be undefined—or actually `1` in its standard implementation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将依次实现每个属性。对于每个属性，我们将使用基于示例的测试或受`generate_ints_greater_than_1`函数启发的数据生成器。让我们从最简单的属性开始——*0⁰*应该是未定义的——或者实际上是其标准实现中的`1`。
- en: Property: 00 -> undefined
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性：00 -> 未定义
- en: 'The first one is quite simple to implement using a normal example-based test.
    We''ll extract it in a function for the sake of consistency:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题使用基于示例的测试非常容易实现。出于一致性考虑，我们将其提取到一个函数中：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In our test, we will write a description of the property, as well, in order
    to obtain an informative output:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试中，我们还将编写属性的描述，以便获得信息丰富的输出：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When run, this results in the following output, passing the test:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行时，会产生以下输出，通过测试：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This was easy enough! We now have a basic structure for property-based test.
    The next test will require a data generator, but we already have it. Let's see
    how it will work for the `0` property to any power, except `0` equals `0`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易！我们现在有了一个基本的属性测试结构。下一个测试将需要一个数据生成器，但我们已经有了。让我们看看它如何适用于`0`属性到任何幂，除了`0`等于`0`。
- en: 'Property: 0[1 .. maxInt] -> 0'
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性：0[1 .. maxInt] -> 0
- en: 'We need our number generator from `1` to `maxInt`, which we''ve already implemented.
    We then need a property function that checks that, for any exponent from `1` to
    `maxInt`, `0` raised to the exponent equals `0`. The code is quite easy to write:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要我们的数字生成器从`1`到`maxInt`，这已经实现了。然后我们需要一个属性函数，检查对于从`1`到`maxInt`的任何指数，`0`的指数等于`0`。代码编写起来相当容易：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we need to check this property. Since we have a list of generated values,
    we can use the `all_of` function to check all of them against the property. To
    make things more informative, I decided to display the list of values we''re using:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要检查这个属性。由于我们有一个生成的值列表，我们可以使用`all_of`函数来检查所有这些值是否符合属性。为了使事情更加信息丰富，我决定显示我们正在使用的值列表：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, we can write our test. We once again display the property name before
    the test:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以编写我们的测试。我们将再次在测试之前显示属性名称：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Running the test gives the following output:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试会产生以下输出：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, a bunch of random values are used for the test, and the final
    two values are `1` and `maxInt`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，一堆随机值被用于测试，最后两个值是`1`和`maxInt`。
- en: It's time to pause and reflect for a minute. These tests are unusual. One of
    the key ideas in unit testing is to have repeatable tests, but here, we have a
    bunch of random values. Do these count? And what do we do when one value leads
    to a failure?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候停下来思考一分钟了。这些测试是不寻常的。单元测试的一个关键思想是进行可重复的测试，但在这里，我们有一堆随机值。这些算不算？当一个值导致失败时我们该怎么办？
- en: These are great questions! First, using property-based tests doesn't exclude
    example-based tests. In fact, we are mixing the two right now—*0⁰* is an example
    rather than a property. So, don't hesitate to check for any specific values when
    it makes sense.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是很好的问题！首先，使用基于属性的测试并不排除基于示例的测试。实际上，我们现在正在混合使用这两种——*0⁰*是一个示例，而不是一个属性。因此，在有意义时，不要犹豫检查任何特定值。
- en: Second, libraries that support property-based testing allow the collection of
    specific failure values and retesting for those automatically. It's simple enough—whenever
    there's a failure, save the values somewhere, and include them in the generation
    the following occasions when the tests are run. Not only does this allow you to
    test more thoroughly, but you also discover the behaviors of the code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，支持属性测试的库允许收集特定失败值并自动重新测试这些值。很简单——每当有失败时，将值保存在某个地方，并在下次运行测试时包含它们。这不仅可以让您进行更彻底的测试，还可以发现代码的行为。
- en: We have, therefore, to look at example-based testing and property-based testing
    as complementary techniques. The first helps you to drive the code using **Test-Driven
    Development** (**TDD**) and check the interesting cases. The second allows you
    to find the cases you haven't considered and retest for the same mistakes. Both
    are useful, just in different ways.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须将基于示例的测试和基于属性的测试视为互补的技术。第一个帮助您使用**测试驱动开发**（**TDD**）来驱动代码，并检查有趣的案例。第二个允许您找到您尚未考虑的案例，并重新测试相同的错误。两者都有用，只是方式不同。
- en: Let's go back to writing our properties, then. The next one is about any number
    to the power `0` equals `1`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到编写我们的属性。接下来的一个属性是任何数的零次幂等于`1`。
- en: 'Property: value: [1 .. maxInt]0 -> 1'
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '属性：value: [1 .. maxInt]0 -> 1'
- en: 'We have everything in place, and we just need to write it:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备就绪，我们只需要写下来：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The test then becomes the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 测试变成了以下内容：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And running the test leads to the following output (a few lines are omitted
    for brevity):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试会得到以下输出（为简洁起见，省略了几行）：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can see from the preceding samples that the numbers are indeed random, while
    always including `1` and `maxInt`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的示例中可以看出，这些数字确实是随机的，同时始终包括`1`和`maxInt`。
- en: We're getting the hang of this! The next property is that any value to the power
    of `1` is the value.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经掌握了这个！下一个属性是任何值的1次幂就是这个值。
- en: 'Property: value: [0 .. maxInt]1 -> value'
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '属性：value: [0 .. maxInt]1 -> value'
- en: 'We need another generator method, starting from `0`. We just need to use the
    bind magic again to obtain the required result:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要另一个生成方法，从`0`开始。我们只需要再次使用bind魔术来获得所需的结果：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This property is easy enough to write:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性写起来很容易：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The test is obvious:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 测试很明显：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Running the test leads once again to a pass.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试，结果再次通过。
- en: 'Let''s take a moment to reflect once again:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次反思一下：
- en: How many values do we check? The answer is `301`.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们要检查多少个值？答案是`301`。
- en: How many lines of test code are there? The test code is just 23 lines of code,
    while the *library* functions that we reuse for our tests are roughly 40 lines
    of code.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试代码有多少行？测试代码只有23行代码，而我们用于测试的*库*函数大约有40行代码。
- en: Isn't this amazing? Doesn't this make a worthy investment in your testing?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是很神奇吗？这不是对你的测试值得投资吗？
- en: We know how to do this. It's time for the most complex property from our exercise—any
    number raised to power *y* equals the number raised to the power *y-1* multiplied
    by the number.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道如何做到这一点。是时候来看我们的练习中最复杂的属性了——任何数的y次幂等于y-1次幂乘以这个数。
- en: Property: xy = xy-1 * x
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性：xy = xy-1 * x
- en: 'This will require us to generate two sets of values, *x* and *y*, so that *x^y
    < maxInt*. It took me some fiddling with the data generators, but I figured out
    that any *x* that''s larger than ![](img/26c14df0-ec8d-4ebe-96a3-b44950f3df7c.png)
    can only be tested for *y=1*. I will therefore use two generators; the first one
    will generate numbers between `2` and ![](img/11ab32f9-a191-4287-803b-b8c1f5457f18.png),
    while the second generates numbers greater than ![](img/5406f9ba-b514-4cb4-9a41-d1d3813e3745.png)
    and smaller than `maxInt`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这将要求我们生成两组值，*x*和*y*，以便*x^y < maxInt*。我花了一些时间与数据生成器一起摸索，但我发现任何大于![](img/26c14df0-ec8d-4ebe-96a3-b44950f3df7c.png)的*x*只能测试*y=1*。因此，我将使用两个生成器；第一个将生成`2`和![](img/11ab32f9-a191-4287-803b-b8c1f5457f18.png)之间的数字，而第二个将生成大于![](img/5406f9ba-b514-4cb4-9a41-d1d3813e3745.png)且小于`maxInt`的数字：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The first part of the property becomes the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的第一部分变成了以下内容：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In order to implement the property, we also need to generate exponents for
    the `x` base, so that we can write the property as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现属性，我们还需要生成`x`基数的指数，这样我们就可以将属性写成如下形式：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you can see from the name of the generator function, we need to generate
    numbers between `1` and *log[x]maxInt*. Any number above this value will overflow
    when computing x^y. Since we don''t have a general logarithm function in STL,
    we need to implement one. To compute *log[x]maxInt*, we just need to use a mathematical
    equality:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从生成函数的名称中可以看出，我们需要生成在`1`和*log[x]maxInt*之间的数字。超过这个值的任何数字在计算x^y时都会溢出。由于STL中没有通用对数函数，我们需要实现一个。为了计算*log[x]maxInt*，我们只需要使用一个数学等式：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And our generator function becomes the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的生成函数变成了以下内容：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With this in place, we can run our tests. Here''s a brief portion of the output:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以运行我们的测试。以下是输出的简要部分：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The final part of the test is to add the interval from ![](img/11ab32f9-a191-4287-803b-b8c1f5457f18.png)
    + 1 to `maxInt`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的最后一部分是添加从![](img/11ab32f9-a191-4287-803b-b8c1f5457f18.png) + 1到`maxInt`的区间：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This also leads to an update in the generation function to support a few edge
    cases; refer to the comments for explanations in the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这也导致了生成函数的更新，以支持一些边缘情况；请参考以下代码中的注释以获取解释：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: And with this, we've implemented our final property!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了我们的最终属性！
- en: Conclusion
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: 'We''re now checking all of the following things with just a few lines of code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需用几行代码来检查所有以下内容：
- en: '*0⁰ -> undefined (1 by default in pow function in C++)*'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*0⁰ -> undefined (1 by default in pow function in C++)*'
- en: '*0^([1 .. maxInt]) -> 0*'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*0^([1 .. maxInt]) -> 0*'
- en: '*value: [1 .. maxInt]⁰ -> 1*'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*value: [1 .. maxInt]⁰ -> 1*'
- en: '*value: [0 .. maxInt]¹ -> value*'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*value: [0 .. maxInt]¹ -> value*'
- en: '*x^y = x^(y-1) * x*'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x^y = x^(y-1) * x*'
- en: How does this compare with the more commonly used approach of having example-based
    tests? We test more with less code. We can find hidden issues in code. But the
    properties are more difficult to identify than examples. We've also established
    that property-based tests work very well together with example-based tests.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这与更常用的基于示例的测试方法相比如何？我们用更少的代码进行更多的测试。我们可以发现代码中隐藏的问题。但是属性比示例更难识别。我们还确定了基于属性的测试与基于示例的测试非常有效地配合使用。
- en: So, let's tackle now the problem of finding the properties. This requires a
    bit of analysis, and we'll explore a practical way in which you can evolve the
    properties from examples through data-driven tests.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们现在解决找到属性的问题。这需要一些分析，我们将探讨一种实际的方式，通过数据驱动测试从示例中演变出属性。
- en: From examples to data-driven tests to properties
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从示例到数据驱动测试到属性
- en: When I first heard about property-based tests, I had two issues. First, I thought
    they were meant to replace example tests—and we know now that they are not; just
    use the two techniques side by side. Second, I had no idea how to come up with
    good properties.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当我第一次听说基于属性的测试时，我有两个问题。首先，我以为它们是用来替代示例测试的——现在我们知道它们并不是；只需将这两种技术并行使用。其次，我不知道如何提出好的属性。
- en: 'I had, however, a good idea on how to come with good examples and how to remove
    duplication between tests. We''ve seen a sample on how to come up with good examples
    for the power function; let''s recap them:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我对如何提出好的示例和如何消除测试之间的重复有了一个好主意。我们已经看到了如何为幂函数提出好的示例；让我们回顾一下：
- en: '*0⁰ -> undefined (* the pow implementation in C++ returns 1 unless specific
    errors are enabled)*'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*0⁰ -> 未定义（C++中的pow实现返回1，除非启用了特定错误）*'
- en: '*0^(any integer from 0 to max) -> 0*'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0^(0到最大的任何整数) -> 0
- en: '*1^(any integer) -> 1*'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*1^(任何整数) -> 1*'
- en: '*(any integer except 0)⁰ -> 1*'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （除0外的任何整数）⁰ -> 1
- en: '*2² -> 4*'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*2² -> 4*'
- en: '*2^(max int that doesn''t overflow) -> value to be computed*'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*2^(不会溢出的最大整数) -> 要计算的值*'
- en: '*10⁵ -> 100000*'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*10⁵ -> 100000*'
- en: '*10^(max int that doesn''t overflow) -> value to be computed*'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*10^(不会溢出的最大整数) -> 要计算的值*'
- en: 'We''ve also seen that it''s easy enough to write the example-based tests for
    these situations:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了为这些情况编写基于示例的测试非常容易：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'These examples exhibit code similarity. The `0`, `1`, `2`, and `3` bases repeat
    a number of times. We''ve seen in [Chapter 9](f3b31186-dfef-496e-bc6e-82a55eeb0cba.xhtml),
    *Test-Driven Development for Functional Programming*, that we can remove this
    similarity with data-driven tests by specifying multiple input values:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例展示了代码的相似之处。`0`、`1`、`2`和`3`的基数重复了多次。我们在[第9章](f3b31186-dfef-496e-bc6e-82a55eeb0cba.xhtml)中已经看到，*函数式编程的测试驱动开发*，我们可以通过指定多个输入值来使用数据驱动测试来消除这种相似性：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After I worked to remove these similarities for some time, I started to see
    the properties. It''s quite obvious, in this case, that we can add a test that
    checks the same mathematical property by using random inputs rather than specific
    examples. Indeed, we wrote it in the previous section, and it looks like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我努力一段时间后消除这些相似性之后，我开始看到这些属性。在这种情况下，很明显，我们可以添加一个检查相同数学属性的测试，而不是使用特定示例。事实上，我们在上一节中写了它，它看起来像这样：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: So my advice is—if you reflect for a few minutes on the problem and find the
    mathematical properties to check, perfect! (Write the property-based tests and
    add as many example-based tests to feel confident that you have covered the situations.)
    If you can't see them, no worries; keep adding example-based tests, remove duplication
    between tests by using data-driven tests, and eventually you will reveal the properties.
    Then, add property-based tests and decide what to do with the existing example-based
    tests.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我的建议是——如果你花几分钟思考问题并找到要检查的数学属性，那太好了！（编写基于属性的测试，并添加尽可能多的基于示例的测试，以确保你已经涵盖了各种情况。）如果你看不到它们，别担心；继续添加基于示例的测试，通过使用数据驱动测试消除测试之间的重复，并最终你会发现这些属性。然后，添加基于属性的测试，并决定如何处理现有的基于示例的测试。
- en: Good properties, bad properties
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 好的属性，坏的属性
- en: Since properties are an abstraction level higher than the examples, it's easy
    to implement them in a confusing or unclear manner. You already need to pay a
    lot of attention to example-based tests; you now need to up your efforts in relation
    to the property-based tests.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于属性比示例更抽象，因此很容易以混乱或不清晰的方式实现它们。你已经需要对基于示例的测试付出很多注意力；现在你需要加倍努力来处理基于属性的测试。
- en: 'First of all, good properties are like good unit tests. We want, therefore
    to have properties that are as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，好的属性就像好的单元测试。因此，我们希望有以下属性：
- en: Small
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小
- en: Named appropriately and clearly
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适当命名和清晰
- en: Giving a very clear message when they fail
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在失败时提供非常清晰的消息
- en: Fast
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速
- en: Repeatable
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可重复
- en: There's one caveat with property-based tests though—since we're using random
    values, shouldn't we expect random failures? Well, when a property-based test
    fails, we learn something new about our code, so it's a reason for celebration.
    We should expect, however, to have fewer failures as time passes by and we remove
    our bugs. If your property-based tests fail every day, something is definitely
    wrong—maybe the property is too large, or the implementation has many holes in
    it. If your property-based tests fail from time to time, and they show a possible
    bug in the code—that's great.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，基于属性的测试有一个警告——由于我们使用随机值，我们是否应该期望随机失败？当基于属性的测试失败时，我们会对我们的代码有所了解，因此这是值得庆祝的。然而，我们应该期望随着时间的推移和错误的消除，失败次数会减少。如果你的基于属性的测试每天都失败，那肯定有问题——也许属性太大，或者实现中存在许多漏洞。如果你的基于属性的测试偶尔失败，并且显示代码中可能存在的错误——那太好了。
- en: One of the difficult things with property-based tests is to keep the generators
    and the property checks free of bugs. This is code too, and any code can have
    bugs. In example-based tests, we deal with this problem by simplifying the unit
    tests to a level where it's virtually impossible to make mistakes. Be aware that
    properties are more complex, and so may require more attention. The old principle
    *keep it simple, stupid* is even more valuable when it comes to property-based
    tests. So, favor smaller properties over larger ones, make your analysis, and
    review your code with colleagues—both the names and the implementation.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 基于属性的测试的一个困难之处在于保持生成器和属性检查没有错误。这也是代码，任何代码都可能有错误。在基于示例的测试中，我们通过简化单元测试的方式来解决这个问题，使错误几乎不可能发生。请注意，属性更加复杂，因此可能需要更多的注意。旧的原则“保持简单，愚蠢”在基于属性的测试中更加有价值。因此，更偏爱小属性而不是大属性，进行分析，并与同事一起审查代码，包括名称和实现。
- en: A few words regarding implementation
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于实现的一些建议
- en: In this chapter, we've used a custom set of functions for implementing data
    generators in order to keep the code standard C++ 17\. However, these functions
    are optimized for learning the technique, and are not production ready. You could
    already see that they are not optimized for memory footprint or performance. We
    could already make them better with a smart use of iterators, but there's a better
    way.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了一组自定义函数来实现数据生成器，以保持代码标准为C++ 17。然而，这些函数是为了学习技术而优化的，并不适用于生产环境。您可能已经注意到，它们并不针对内存占用或性能进行优化。我们可以通过巧妙地使用迭代器来改进它们，但还有更好的方法。
- en: If you can use the range library or compile your tests using C++ 20, it's quite
    easy to implement infinite data generators (due to lazy evaluation). I also advise
    you to research for property-based tests libraries, or for generator libraries,
    since some of the generators have already been written by other people and it's
    much faster to use them in your code once you understand the concept.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您可以使用范围库或使用C++ 20编译您的测试，那么实现无限数据生成器就会变得非常容易（由于惰性评估）。我还建议您搜索基于属性的测试库或生成器库，因为一些生成器已经被其他人编写，一旦您理解了概念，就可以更快地在您的代码中使用它们。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Property-based tests are a welcome addition to the example-based tests we've
    known and used for many years. They show us how we can combine data generation
    with a bit of analysis to both remove duplication from tests and find cases we
    hadn't considered.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 基于属性的测试是我们多年来所知道和使用的基于示例的测试的一个受欢迎的补充。它向我们展示了如何将数据生成与一些分析相结合，以消除测试中的重复项并找到我们未考虑的情况。
- en: Property-based tests are enabled by data generators that are very easy to implement
    using pure functions. Things will become even easier with lazy evaluation coming
    in C++ 20 or with the ranges library.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 基于属性的测试是通过非常容易使用纯函数实现的数据生成器来实现的。随着C++ 20中的惰性评估或范围库的到来，事情将变得更加容易。
- en: But the core technique in property-based testing is to identify the properties.
    We've seen two ways to do that—the first by analyzing the examples, and the second
    by writing the example-based tests, removing duplication to turn them into data-driven
    tests, and then replacing the rows of data with properties.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 但基于属性的测试的核心技术是识别属性。我们已经看到了两种方法来做到这一点——第一种是通过分析示例，第二种是通过编写基于示例的测试，消除重复项，将其转换为数据驱动测试，然后用属性替换数据行。
- en: Finally, remember that property-based tests are code, and they need to be very
    clean, easy to change, and easy to understand. Favor small properties whenever
    possible, and make them very understandable by naming them clearly.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请记住，基于属性的测试是代码，它们需要非常干净，易于更改和理解。尽可能偏爱小属性，并通过清晰命名使它们易于理解。
- en: In the next chapter, we will look at how we can use pure functions to support
    our refactoring effort and at how design patterns can be implemented as functions.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看如何使用纯函数来支持我们的重构工作，以及如何将设计模式实现为函数。
