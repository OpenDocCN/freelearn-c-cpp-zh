- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Leveraging Threading and Concurrency
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用线程和并发
- en: Most computers contain multiple processors or at least multiple cores, and leveraging
    this computational power is key to many categories of applications. Unfortunately,
    many developers still have a mindset of sequential code execution, even though
    operations that do not depend on each other could be executed concurrently. This
    chapter presents standard library support for threads, asynchronous tasks, and
    related components, as well as some practical examples at the end.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数计算机都包含多个处理器或至少多个核心，利用这种计算能力对于许多应用类别至关重要。不幸的是，许多开发者仍然持有顺序代码执行的心态，即使不依赖彼此的操作也可以并发执行。本章介绍了标准库对线程、异步任务和相关组件的支持，以及一些最后的实际示例。
- en: Most modern processors (except those dedicated to types of applications that
    do not require great computing power, such as Internet of Things applications)
    have two, four, or more cores that enable you to concurrently execute multiple
    threads of execution. Applications must be explicitly written to leverage the
    multiple processing units that exist; you can write such applications by executing
    functions on multiple threads at the same time. Since C++11, the standard library
    provides support for working with threads, synchronization of shared data, thread
    communication, and asynchronous tasks. In this chapter, we’ll explore the most
    important topics related to threads and tasks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代处理器（除了那些针对不需要强大计算能力的应用类型，如物联网应用）都有两个、四个或更多核心，这使您能够并发执行多个执行线程。应用程序必须明确编写以利用现有的多个处理单元；您可以通过同时在多个线程上执行函数来编写此类应用程序。自
    C++11 以来，标准库提供了与线程、共享数据同步、线程通信和异步任务一起工作的支持。在本章中，我们将探讨与线程和任务相关的重要主题。
- en: 'This chapter includes the following recipes:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下食谱：
- en: Working with threads
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与线程一起工作
- en: Synchronizing access to shared data with mutexes and locks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用互斥锁和锁同步对共享数据的访问
- en: Finding alternatives for recursive mutexes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找递归互斥锁的替代方案
- en: Handling exceptions from thread functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理线程函数的异常
- en: Sending notifications between threads
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线程之间发送通知
- en: Using promises and futures to return values from threads
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用承诺和未来从线程返回值
- en: Executing functions asynchronously
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步执行函数
- en: Using atomic types
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原子类型
- en: Implementing parallel `map` and `fold` with threads
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用线程实现并行 `map` 和 `fold`
- en: Implementing parallel `map` and `fold` with tasks
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用任务实现并行 `map` 和 `fold`
- en: Implementing parallel `map` and `fold` with standard parallel algorithms
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准并行算法实现并行 `map` 和 `fold`
- en: Using joinable threads and cancellation mechanisms
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可连接线程和取消机制
- en: Synchronizing threads with latches, barriers, and semaphores
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用闩锁、屏障和信号量同步线程
- en: Synchronizing writing to output streams from multiple threads
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从多个线程同步写入输出流
- en: In the first part of this chapter, we will look at the various threading objects
    and mechanisms that have built-in support in the library, such as threads, locking
    objects, condition variables, exception handling, and others.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一部分，我们将探讨库中内置支持的多种线程对象和机制，例如线程、锁定对象、条件变量、异常处理等。
- en: Working with threads
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与线程一起工作
- en: A thread is a sequence of instructions that can be managed independently by
    a scheduler, such as the operating system. Threads could be software or hardware.
    Software threads are threads of execution that are managed by the operating system.
    They can run on single processing units, usually by time slicing. This is a mechanism
    where each thread gets a time slot of execution (in the range of milliseconds)
    on the processing unit before the operating system schedules another software
    thread to run on the same processing unit. Hardware threads are threads of execution
    at the physical level. They are, basically, a CPU or a CPU core. They can run
    simultaneously, that is, in parallel, on systems with multiprocessors or multicores.
    Many software threads can run concurrently on a hardware thread, usually by using
    time slicing. The C++ library provides support for working with software threads.
    In this recipe, you will learn how to create and perform operations with threads.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是由调度程序（如操作系统）独立管理的指令序列。线程可以是软件或硬件。软件线程是由操作系统管理的执行线程。它们通常通过时间切片在单个处理单元上运行。这是一种机制，其中每个线程在操作系统调度另一个软件线程在相同处理单元上运行之前，在处理单元上获得一个执行时间槽（在毫秒范围内）。硬件线程是在物理层面的执行线程。它们基本上是一个CPU或CPU核心。它们可以在具有多处理器或多核的系统上同时运行，即并行运行。许多软件线程可以同时在硬件线程上运行，通常通过使用时间切片。C++库提供了与软件线程一起工作的支持。在本食谱中，你将学习如何创建和操作线程。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: A thread of execution is represented by the `thread` class, available in the
    `std` namespace in the `<thread>` header. Additional thread utilities are available
    in the same header but in the `std::this_thread` namespace.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 执行线程由`thread`类表示，该类在`<thread>`头文件中的`std`命名空间中可用。相同的头文件中还有其他线程实用工具，但位于`std::this_thread`命名空间中。
- en: 'In the following examples, the `print_time()` function is used. This function
    prints the local time to the console. Its implementation is as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，使用了`print_time()`函数。此函数将本地时间打印到控制台。其实现如下：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the next section, we will see how to perform common operations with threads.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何使用线程执行常见操作。
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Use the following solutions to manage threads:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下解决方案来管理线程：
- en: 'To create a `std::thread` object without starting the execution of a new thread,
    use its default constructor:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个不启动新线程执行的`std::thread`对象，请使用其默认构造函数：
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Start the execution of a function on another thread by constructing a `std::thread`
    object and passing the function as an argument:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过构造一个`std::thread`对象并将函数作为参数传递，在另一个线程上启动函数的执行：
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Start the execution of a function with arguments on another thread by constructing
    a `std::thread` object, and then passing the function as an argument to the constructor,
    followed by its arguments:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过构造一个`std::thread`对象，并将函数作为构造函数的参数传递，然后传递其参数，在另一个线程上启动具有参数的函数的执行：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To wait for a thread to finish its execution, use the `join()` method on the
    `thread` object:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要等待线程完成其执行，请使用`thread`对象的`join()`方法：
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To allow a thread to continue its execution independently of the current `thread`
    object, use the `detach()` method. This means the thread will continue its execution
    until it finishes without being managed by the `std::thread` object, which will
    no longer own any thread:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要允许线程独立于当前`thread`对象继续执行，请使用`detach()`方法。这意味着线程将继续执行，直到完成，而不会被`std::thread`对象管理，该对象将不再拥有任何线程：
- en: '[PRE5]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To pass arguments by reference to a function thread, wrap them in either `std::ref`
    or `std::cref` (if the reference is constant):'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将引用传递给函数线程，请将它们包装在`std::ref`或`std::cref`（如果引用是常量）中：
- en: '[PRE6]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To stop the execution of a thread for a specified duration, use the `std::this_thread::sleep_for()`
    function:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使线程的执行停止指定的时间长度，请使用`std::this_thread::sleep_for()`函数：
- en: '[PRE7]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To stop the execution of a thread until a specified moment in time, use the
    `std::this_thread::sleep_until()` function:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使线程的执行停止到指定的时间点，请使用`std::this_thread::sleep_until()`函数：
- en: '[PRE8]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To suspend the execution of the current thread and provide an opportunity for
    another thread to perform the execution, use `std::this_thread::yield()`:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要挂起当前线程的执行并提供其他线程执行的机会，请使用`std::this_thread::yield()`：
- en: '[PRE9]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `std::thread` class, which represents a single thread of execution, has
    several constructors:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 表示单个执行线程的`std::thread`类有几个构造函数：
- en: A default constructor that only creates the thread object but does not start
    the execution of a new thread.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个默认构造函数，它只创建线程对象，但不启动新线程的执行。
- en: A move constructor that creates a new thread object to represent a thread of
    execution previously represented by the object it was constructed from. After
    the construction of the new object, the other object is no longer associated with
    the execution thread.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个移动构造函数，它创建一个新的线程对象来表示之前由构造函数所创建的对象所表示的线程执行。在新对象构造完成后，另一个对象就不再与执行线程相关联。
- en: 'A constructor with a variable number of arguments: the first being a function
    that represents the top-level thread function and the others being arguments to
    be passed to the thread function. Arguments need to be passed to the thread function
    by value. If the thread function takes parameters by reference or by constant
    reference, they must be wrapped in either a `std::ref` or `std::cref` object.
    These are helper function templates that generate objects of the type `std::reference_wrapper`,
    which wraps a reference in a copyable and assignable object.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有可变数量参数的构造函数：第一个是一个表示顶级线程函数的函数，其余的是要传递给线程函数的参数。参数需要通过值传递给线程函数。如果线程函数通过引用或常量引用接收参数，它们必须被包装在`std::ref`或`std::cref`对象中。这些是辅助函数模板，它们生成`std::reference_wrapper`类型的对象，该对象将引用包装在可复制和可赋值的对象中。
- en: The thread function, in this case, cannot return a value. It is not illegal
    for the function to actually have a return type other than `void`, but it ignores
    any value that is directly returned by the function. If it has to return a value,
    it can do so using a shared variable or a function argument. In the *Using promises
    and futures to return values from threads* recipe, later in this chapter, we will
    see how a thread function returns a value to another thread using a *promise*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，线程函数无法返回值。函数实际上具有除`void`之外的返回类型并不违法，但它会忽略函数直接返回的任何值。如果它必须返回一个值，可以使用共享变量或函数参数来实现。在本书后面的*使用承诺和未来从线程返回值*配方中，我们将看到线程函数如何使用*承诺*将值返回给另一个线程。
- en: If the function terminates with an exception, the exception cannot be caught
    with a `try...catch` statement in the context where a thread was started and the
    program terminates abnormally with a call to `std::terminate()`. All exceptions
    must be caught within the executing thread, but they can be transported across
    threads via a `std::exception_ptr` object. We’ll discuss this topic in a later
    recipe, called *Handling exceptions from thread functions*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数因异常而终止，则无法在启动线程的上下文中使用`try...catch`语句捕获异常。所有异常都必须在执行线程中被捕获，但它们可以通过`std::exception_ptr`对象在线程之间传输。我们将在稍后的配方中讨论这个主题，称为*处理线程函数中的异常*。
- en: After a thread has started its execution, it is both joinable and detachable.
    Joining a thread implies blocking the execution of the current thread until the
    joined thread ends its execution. Detaching a thread means decoupling the thread
    object from the thread of execution it represents, allowing both the current thread
    and the detached thread to be executed at the same time. Detached threads are
    sometimes called background threads or daemon threads. When a program terminates
    (by returning from the main function), the detached threads that are still running
    are not waited for. That means the stack of those threads is not unwound. Because
    of this, the destructor of the objects on the stack is not called, which may lead
    to resource leaks or corrupted resources (files, shared memory, etc.).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在线程开始执行后，它既是可连接的也是可分离的。连接线程意味着阻塞当前线程的执行，直到连接的线程结束其执行。分离线程意味着将线程对象与其所代表的线程执行解耦，允许当前线程和分离的线程同时执行。分离的线程有时被称为后台线程或守护线程。当程序终止（通过从主函数返回）时，仍在运行的分离线程不会被等待。这意味着那些线程的堆栈不会被回滚。因此，堆栈上对象的析构函数不会被调用，这可能导致资源泄漏或资源损坏（文件、共享内存等）。
- en: Joining a thread is done with `join()` and detaching a thread is done with `detach()`.
    Once you call either of these two methods, the thread is said to be non-joinable
    and the thread object can be safely destroyed. When a thread is detached, the
    shared data it may need to access must be available throughout its execution.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`join()`方法来连接线程，使用`detach()`方法来分离线程。一旦调用这两个方法之一，该线程就被认为是不可连接的，线程对象可以安全地被销毁。当线程被分离时，它可能需要访问的共享数据必须在其整个执行过程中可用。
- en: When you detach a thread, you cannot join it anymore. An attempt to do so will
    result in a runtime error. You can prevent this by checking whether the thread
    can be joined or not by using the `joinable()` member function.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当你断开线程时，你不能再将其连接。尝试这样做将导致运行时错误。你可以通过使用`joinable()`成员函数来检查线程是否可以被连接来防止这种情况。
- en: If a thread object goes out of scope and is destroyed but neither `join()` or
    `detach()` has been called, then `std::terminate()` is invoked.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果线程对象超出作用域并被销毁，但既没有调用`join()`也没有调用`detach()`，则将调用`std::terminate()`。
- en: Each thread has an identifier that can be retrieved. For the current thread,
    call the `std::this_thread::get_id()` function. For another thread of execution
    represented by a `thread` object, call its `get_id()` method.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线程都有一个可以检索的标识符。对于当前线程，调用`std::this_thread::get_id()`函数。对于由`thread`对象表示的另一个执行线程，调用其`get_id()`方法。
- en: 'There are several additional utility functions available in the `std::this_thread`
    namespace:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在`std::this_thread`命名空间中提供了几个额外的实用函数：
- en: The `yield()` method hints at the scheduler to activate another thread. This
    is useful when implementing a busy-waiting routine, as in the last example from
    the previous section. However, the actual behavior is implementation-specific.
    A call to this function, in fact, may have no effect on the execution of threads.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yield()`方法向调度器暗示激活另一个线程。这在实现忙等待例程时很有用，如上一节中的最后一个示例。然而，实际行为是特定于实现的。实际上，对这个函数的调用可能对线程的执行没有影响。'
- en: The `sleep_for()` method blocks the execution of the current thread for at least
    the specified period of time (the actual time the thread is put to sleep may be
    longer than the requested period due to scheduling).
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sleep_for()`方法阻塞当前线程的执行，至少达到指定的持续时间（由于调度，线程被置于睡眠状态的实际时间可能比请求的持续时间更长）。'
- en: The `sleep_until()` method blocks the execution of the current thread until
    at least the specified time point (the actual duration of the sleep may be longer
    than requested due to scheduling).
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sleep_until()`方法阻塞当前线程的执行，直到至少达到指定的时刻（由于调度，实际睡眠时间可能比请求的时间更长）。'
- en: The `std::thread` class requires the `join()` method to be called explicitly
    to wait for the thread to finish. This can lead to programming errors (as detailed
    above). The C++20 standard provides a new thread class, called `std::jthread`,
    that solves this inconvenience. This will be the topic of the *Using joinable
    threads and cancellation mechanisms* recipe, later in this chapter.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::thread`类需要显式调用`join()`方法来等待线程完成。这可能导致编程错误（如上所述）。C++20标准提供了一个新的线程类，称为`std::jthread`，它解决了这个不便之处。这将是本章后面“使用可连接线程和取消机制”食谱的主题。'
- en: See also
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Synchronizing access to shared data with mutexes and locks*, to see what mechanisms
    are available for synchronizing thread access to shared data and how they work'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用互斥锁和锁同步对共享数据的访问*，了解可用于同步线程对共享数据访问的机制以及它们是如何工作的'
- en: '*Finding alternatives for recursive mutexes*, to learn why recursive mutexes
    should be avoided, and also how to transform a thread-safe type using a recursive
    mutex into a thread-safe type using a non-recursive mutex'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*寻找递归互斥锁的替代方案*，了解为什么应该避免递归互斥锁，以及如何将使用递归互斥锁的线程安全类型转换为使用非递归互斥锁的线程安全类型'
- en: '*Handling exceptions from thread functions*, to understand how to handle exceptions
    thrown in a worker thread from the main thread or the thread where it was joined'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理线程函数中的异常*，了解如何在主线程或连接线程中处理从工作线程抛出的异常'
- en: '*Sending notifications between threads*, to see how to use condition variables
    to send notifications between producer and consumer threads'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在线程之间发送通知*，了解如何使用条件变量在生产者和消费者线程之间发送通知'
- en: '*Using promises and futures to return values from threads*, to learn how to
    use a `std::promise` object to return a value or an exception from a thread'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用承诺和未来从线程返回值*，了解如何使用`std::promise`对象从线程返回一个值或异常'
- en: Synchronizing access to shared data with mutexes and locks
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用互斥锁和锁同步对共享数据的访问
- en: Threads allow you to execute multiple functions at the same time, but it is
    often necessary that these functions access shared resources. Access to shared
    resources must be synchronized so that only one thread can read or write from
    or to the shared resource at a time. In this recipe, we will see what mechanisms
    the C++ standard defines for synchronizing thread access to shared data and how
    they work.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 线程允许你同时执行多个函数，但通常这些函数需要访问共享资源。对共享资源的访问必须进行同步，以确保一次只有一个线程可以读取或写入共享资源。在本例中，我们将看到C++标准定义了哪些机制来同步对共享数据的线程访问，以及它们是如何工作的。
- en: Getting ready
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `mutex` and `lock` classes discussed in this recipe are available in the
    `std` namespace in the `<mutex>` header, and, respectively, `<shared_mutex>` for
    C++14 shared mutexes and locks.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中讨论的`mutex`和`lock`类在`<mutex>`头文件中的`std`命名空间中可用，而`<shared_mutex>`用于C++14的共享互斥锁和锁。
- en: How to do it...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Use the following pattern for synchronizing access with a single shared resource:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下模式来同步对单个共享资源的访问：
- en: 'Define a `mutex` in the appropriate context (class or global scope):'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在适当的作用域（类或全局作用域）中定义一个`mutex`：
- en: '[PRE10]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Acquire a `lock` on this `mutex` before accessing the shared resource in each
    thread:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个线程访问共享资源之前，先获取这个`mutex`的`lock`：
- en: '[PRE11]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Use the following pattern for synchronizing access to multiple shared resources
    at the same time to avoid deadlocks:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下模式来同步对多个共享资源的访问，以避免死锁：
- en: 'Define a mutex for each shared resource in the appropriate context (global
    or class scope):'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在适当的作用域（全局或类作用域）中为每个共享资源定义一个互斥锁（mutex）：
- en: '[PRE12]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Lock the mutexes at the same time using a deadlock avoidance algorithm with
    `std::lock()`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用死锁避免算法通过`std::lock()`同时锁定互斥锁：
- en: '[PRE13]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After locking them, adopt the ownership of each mutex into a `std::lock_guard`
    class to ensure they are safely released at the end of the function (or scope):'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在锁定它们之后，将每个互斥锁的所有权采用到`std::lock_guard`类中，以确保在函数（或作用域）结束时安全释放：
- en: '[PRE14]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A **mutex** (**mutual exclusion**) is a synchronization primitive that allows
    us to protect simultaneous access to shared resources from multiple threads. The
    C++ standard library provides several implementations:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**互斥锁**（**互斥**）是一种同步原语，它允许我们从多个线程中保护对共享资源的同步访问。C++标准库提供了几种实现：'
- en: '`std::mutex` is the most commonly used mutex type; it is illustrated in the
    preceding code snippet. It provides methods to acquire and release the mutex.
    `lock()` tries to acquire the mutex and blocks it if it is not available, `try_lock()`
    tries to acquire the mutex and returns it without blocking if the mutex is not
    available, and `unlock()` releases the mutex.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::mutex`是最常用的互斥锁类型；它在上面的代码片段中进行了说明。它提供了获取和释放互斥锁的方法。`lock()`尝试获取互斥锁，如果不可用则阻塞，`try_lock()`尝试获取互斥锁，如果不可用则不阻塞并返回，`unlock()`释放互斥锁。'
- en: '`std::timed_mutex` is similar to `std::mutex` but provides two more methods
    to acquire the mutex using a timeout: `try_lock_for()` tries to acquire the mutex
    and returns it if the mutex is not made available during the specified duration,
    and `try_lock_until()` tries to acquire the mutex and returns it if the mutex
    is not made available until a specified time point.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::timed_mutex`与`std::mutex`类似，但提供了两种使用超时获取互斥锁的方法：`try_lock_for()`尝试获取互斥锁，如果在指定的时间内互斥锁不可用，则返回它，`try_lock_until()`尝试获取互斥锁，如果在指定的时间点之前互斥锁不可用，则返回它。'
- en: '`std::recursive_mutex` is similar to `std::mutex`, but the mutex can be acquired
    multiple times from the same thread without being blocked.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::recursive_mutex`与`std::mutex`类似，但互斥锁可以从同一线程多次获取而不会被阻塞。'
- en: '`std::recursive_timed_mutex` is a combination of a recursive mutex and a timed
    mutex.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::recursive_timed_mutex`是递归互斥锁和定时互斥锁的组合。'
- en: '`std::shared_timed_mutex`, since C++14, is to be used in scenarios when multiple
    readers can access the same resource at the same time without causing data races,
    while only one writer is allowed to do so. It implements locking with two levels
    of access – *shared* (several threads can share the ownership of the same mutex)
    and *exclusive* (only one thread can own the mutex) – and provides timeout facilities.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::shared_timed_mutex`自C++14起使用，适用于在多个读者可以同时访问同一资源而不引起数据竞争的场景，同时只允许一个写者这样做。它实现了两种访问级别的锁定
    – *共享*（多个线程可以共享同一互斥锁的所有权）和*独占*（只有一个线程可以拥有互斥锁） – 并提供了超时功能。'
- en: '`std::shared_mutex`, since C++17, is similar to the `shared_timed_mutex` but
    without the timeout facilities.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::shared_mutex`自C++17起与`shared_timed_mutex`类似，但没有超时功能。'
- en: The first thread that locks an available mutex takes ownership of it and continues
    with the execution. All consecutive attempts to lock the mutex from any thread
    fail, including the thread that already owns the mutex, and the `lock()` method
    blocks the thread until the mutex is released with a call to `unlock()`. If a
    thread needs to be able to lock a mutex multiple times without blocking it and
    therefore enter a deadlock, a `recursive_mutex` class template should be used.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个锁定可用互斥量的线程将拥有它并继续执行。所有从任何线程尝试锁定互斥量的后续尝试都会失败，包括已经拥有互斥量的线程，并且`lock()`方法会阻塞线程，直到通过调用`unlock()`释放互斥量。如果一个线程需要能够多次锁定互斥量而不被阻塞，从而避免死锁，则应使用`recursive_mutex`类模板。
- en: 'The typical use of a mutex to protect access to a shared resource comprises
    locking the mutex, using the shared resource, and then unlocking the mutex:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用互斥量保护对共享资源的访问的典型用法包括锁定互斥量，使用共享资源，然后解锁互斥量：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This method of using the mutex is, however, prone to error. This is because
    each call to `lock()` must be paired with a call to `unlock()` on all execution
    paths; that is, both normal return paths and exception return paths. In order
    to safely acquire and release a mutex, regardless of the way the execution of
    a function goes, the C++ standard defines several locking classes:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种使用互斥量的方法容易出错。这是因为每个对`lock()`的调用都必须与所有执行路径上的`unlock()`调用配对；也就是说，无论是正常返回路径还是异常返回路径。为了安全地获取和释放互斥量，无论函数的执行方式如何，C++标准定义了几个锁定类：
- en: '`std::lock_guard` is the locking mechanism seen earlier; it represents a mutex
    wrapper implemented in an RAII manner. It attempts to acquire the mutex at the
    time of its construction and release it upon destruction. This is available in
    C++11\. The following is a typical implementation of `lock_guard`:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::lock_guard`是之前看到的锁定机制；它代表了一种以RAII方式实现的互斥量包装器。它试图在构造时获取互斥量，并在销毁时释放它。这在C++11中可用。以下是对`lock_guard`的典型实现：'
- en: '[PRE16]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`std::unique_lock` is a mutex ownership wrapper that provides support for deferred
    locking, time locking, recursive locking, transfer of ownership, and using it
    with condition variables. This is available in C++11.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unique_lock`是一个互斥量所有权包装器，它提供了对延迟锁定、时间锁定、递归锁定、所有权转移以及与条件变量一起使用支持。这在C++11中可用。'
- en: '`std::shared_lock` is a mutex-shared ownership wrapper that provides support
    for deferred locking, time locking, and transfer of ownership. This is available
    in C++14.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::shared_lock`是一个互斥量共享所有权包装器，它提供了对延迟锁定、时间锁定和所有权转移的支持。这在C++14中可用。'
- en: '`std::scoped_lock` is a wrapper for multiple mutexes implemented in an RAII
    manner. Upon construction, it attempts to acquire ownership of the mutexes in
    a deadlock avoidance manner as if it is using `std::lock()`, and upon destruction,
    it releases the mutexes in reverse order of the way they were acquired. This is
    available in C++17.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::scoped_lock`是多个互斥量的包装器，以RAII方式实现。在构造时，它试图以避免死锁的方式获取互斥量的所有权，就像它正在使用`std::lock()`一样，并在销毁时以获取它们的相反顺序释放互斥量。这在C++17中可用。'
- en: '**RAII**, which stands for **Resource Acquisition Is Initialization**, is a
    programming technique used in some programming languages, including C++, that
    simplifies resource management, ensures program correctness, and reduces code
    size. This technique binds the life cycle of a resource to an object. The allocation,
    also referred to as the acquisition, of a resource is done during the creation
    of the object (in the constructor) and the release of the resource (deallocation)
    is done when the object is destroyed (in the destructor). This ensures resources
    do not leak, provided that the bound objects are not themselves leaked. For more
    information about RAII, see [https://en.cppreference.com/w/cpp/language/raii](https://en.cppreference.com/w/cpp/language/raii).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**RAII**，即**资源获取即初始化**，是一种在包括C++在内的某些编程语言中使用的编程技术，它简化了资源管理，确保程序正确性，并减少代码大小。这种技术将资源的生命周期绑定到对象上。资源的分配（也称为获取），是在对象的创建过程中（在构造函数中）完成的，而资源的释放（解除分配）是在对象被销毁时（在析构函数中）完成的。这确保了资源不会泄漏，前提是绑定到对象本身不会泄漏。有关RAII的更多信息，请参阅[https://en.cppreference.com/w/cpp/language/raii](https://en.cppreference.com/w/cpp/language/raii)。'
- en: 'In the first example in the *How to do it...* section, we used `std::mutex`
    and `std::lock_guard` to protect access to the `std::cout` stream object, which
    is shared between all the threads in a program. The following example shows how
    the `thread_func()` function can be executed concurrently on several threads:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *如何做...* 部分的第一个例子中，我们使用了 `std::mutex` 和 `std::lock_guard` 来保护对 `std::cout`
    流对象的访问，该对象在程序的所有线程之间共享。以下示例展示了 `thread_func()` 函数如何在多个线程上并发执行：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A possible output for this program is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序的可能的输出如下：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When a thread needs to take ownership of multiple mutexes that are meant to
    protect multiple shared resources, acquiring them one by one may lead to deadlocks.
    Let’s consider the following example (where `container` is the class shown in
    the *How to do it...* section):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个线程需要获取多个互斥锁以保护多个共享资源时，逐个获取它们可能会导致死锁。让我们考虑以下示例（其中 `container` 是在 *如何做...*
    部分中显示的类）：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this example, the `container` class holds data that may be accessed simultaneously
    from different threads; therefore, it needs to be protected by acquiring a mutex.
    The `move_between()` function is a thread-safe function that removes an element
    from a container and adds it to a second container. To do so, it acquires the
    mutexes of the two containers sequentially, then erases the element from the first
    container and adds it to the end of the second container.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`container` 类持有可能被不同线程同时访问的数据；因此，它需要通过获取互斥锁来保护。`move_between()` 函数是一个线程安全函数，它从一个容器中删除一个元素并将其添加到第二个容器中。为此，它按顺序获取两个容器的互斥锁，然后从第一个容器中删除元素并将其添加到第二个容器的末尾。
- en: 'This function is, however, prone to deadlocks because a race condition might
    be triggered while acquiring the locks. Suppose we have a scenario where two different
    threads execute this function, but with different arguments:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，此函数容易发生死锁，因为在获取锁的过程中可能会触发竞争条件。假设我们有一个场景，其中两个不同的线程执行此函数，但具有不同的参数：
- en: The first thread starts executing with the arguments `c1` and `c2` in this order.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个线程以 `c1` 和 `c2` 的顺序开始执行。
- en: The first thread is suspended after it acquires the lock for the `c1` container.
    The second thread starts executing with the arguments `c2` and `c1` in this order.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个线程在获取 `c1` 容器的锁后暂停。第二个线程以 `c2` 和 `c1` 的顺序开始执行。
- en: The second thread is suspended after it acquires the lock for the `c2` container.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个线程在获取 `c2` 容器的锁后暂停。
- en: The first thread continues the execution and tries to acquire the mutex for
    `c2`, but the mutex is unavailable. Therefore, a deadlock occurs (this can be
    simulated by putting the thread to sleep for a short while after it acquires the
    first mutex).
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个线程继续执行并尝试获取 `c2` 的互斥锁，但互斥锁不可用。因此，发生死锁（这可以通过在获取第一个互斥锁后让线程短暂休眠来模拟）。
- en: 'To avoid possible deadlocks such as these, mutexes should be acquired in a
    deadlock avoidance manner, and the standard library provides a utility function
    called `std::lock()` that does that. The `move_between()` function needs to change
    by replacing the two locks with the following code (as shown in the *How to do
    it...* section):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免可能出现的此类死锁，互斥锁应按死锁避免方式获取，标准库提供了一个名为 `std::lock()` 的实用函数来执行此操作。`move_between()`
    函数需要通过以下代码替换两个锁（如 *如何做...* 部分所示）来更改：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The ownership of the mutexes must still be transferred to a lock guard object
    so they are properly released after the execution of the function ends (or, depending
    on the case, when a particular scope ends).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥锁的所有权必须仍然转移到锁保护对象，以便在函数执行结束后（或根据情况，当特定作用域结束时）正确释放。
- en: 'In C++17, a new mutex wrapper is available, `std::scoped_lock`, that can be
    used to simplify code, such as the one in the preceding example. This type of
    lock can acquire the ownership of multiple mutexes in a deadlock-free manner.
    These mutexes are released when the scoped lock is destroyed. The preceding code
    is equivalent to the following single line of code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++17 中，一个新的互斥锁包装器 `std::scoped_lock` 可用，可用于简化代码，例如前一个示例中的代码。这种类型的锁可以以无死锁的方式获取多个互斥锁的所有权。当作用域锁被销毁时，这些互斥锁被释放。前面的代码等同于以下单行代码：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `scoped_lock` class provides a simplified mechanism for owning one or more
    mutexes for the duration of a scoped block and also helps with writing simple
    and more robust code.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`scoped_lock` 类提供了一种简化的机制，用于在作用域块期间拥有一个或多个互斥锁，并有助于编写简单且更健壮的代码。'
- en: See also
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Working with threads*, to learn about the `std::thread` class and the basic
    operations for working with threads in C++'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与线程一起工作*，了解C++中`std::thread`类以及线程的基本操作'
- en: '*Using joinable threads and cancellation mechanisms*, to learn about the C++20
    `std::jthread` class, which manages a thread of execution and automatically joins
    during its destruction, as well as the improved mechanisms for stopping the execution
    of threads'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用可连接线程和取消机制*，了解C++20的`std::jthread`类，该类管理一个执行线程，并在其销毁时自动连接，以及改进的停止线程执行机制'
- en: '*Finding alternatives for recursive mutexes*, to learn why recursive mutexes
    should be avoided and how to transform a thread-safe type using a recursive mutex
    into a thread-safe type using a non-recursive mutex'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*寻找递归互斥锁的替代方案*，了解为什么应该避免使用递归互斥锁，以及如何将使用递归互斥锁的线程安全类型转换为使用非递归互斥锁的线程安全类型'
- en: Finding alternatives for recursive mutexes
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找递归互斥锁的替代方案
- en: The standard library provides several mutex types for protecting access to shared
    resources. `std::recursive_mutex` and `std::recursive_timed_mutex` are two implementations
    that allow you to use multiple locking in the same thread. A typical use for a
    recursive mutex is to protect access to a shared resource from a recursive function.
    A `std::recursive_mutex` class may be locked multiple times from a thread, either
    with a call to `lock()` or `try_lock()`. When a thread locks an available recursive
    mutex, it acquires its ownership; as a result of this, consecutive attempts to
    lock the mutex from the same thread do not block the execution of the thread,
    creating a deadlock. The recursive mutex is, however, released only when an equal
    number of calls to `unlock()` are made. Recursive mutexes may also have a greater
    overhead than non-recursive mutexes. For these reasons, when possible, they should
    be avoided. This recipe presents a use case for transforming a thread-safe type
    using a recursive mutex into a thread-safe type using a non-recursive mutex.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了几种互斥锁类型，用于保护对共享资源的访问。`std::recursive_mutex`和`std::recursive_timed_mutex`是两种实现，允许您在同一个线程中使用多次锁定。递归互斥锁的一个典型用途是保护递归函数对共享资源的访问。`std::recursive_mutex`类可以从线程中多次锁定，无论是通过调用`lock()`还是`try_lock()`。当一个线程锁定一个可用的递归互斥锁时，它获得所有权；因此，来自同一线程的连续锁定尝试不会阻塞线程的执行，从而创建死锁。然而，递归互斥锁仅在执行了相同数量的`unlock()`调用后才会释放。递归互斥锁可能比非递归互斥锁具有更大的开销。因此，在可能的情况下，应避免使用它们。本菜谱展示了将使用递归互斥锁的线程安全类型转换为使用非递归互斥锁的线程安全类型的使用案例。
- en: Getting ready
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to be familiar with the various mutexes and locks available in the
    standard library. I recommend that you read the previous recipe, *Synchronizing
    access to shared data with mutex and locks*, to get an overview of them.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要熟悉标准库中可用的各种互斥锁和锁。我建议您阅读之前的菜谱，*使用互斥锁和锁同步对共享数据的访问*，以了解它们的大致情况。
- en: 'For this recipe, we will consider the following class:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将考虑以下类：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The purpose of this recipe is to transform the `foo_rec` class so we can avoid
    using `std::recursive_mutex`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的目的是将`foo_rec`类进行转换，以便我们可以避免使用`std::recursive_mutex`。
- en: How to do it...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To transform the preceding implementation into a thread-safe type using a non-recursive
    mutex, do this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要将前面的实现转换为使用非递归互斥锁的线程安全类型，请执行以下操作：
- en: 'Replace `std::recursive_mutex` with `std::mutex`:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`std::recursive_mutex`替换为`std::mutex`：
- en: '[PRE23]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Define private non-thread-safe versions of the public methods or helper functions
    to be used in thread-safe public methods:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义私有非线程安全的版本，用于在线程安全的公共方法或辅助函数中使用：
- en: '[PRE24]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Rewrite the public methods to use the newly defined non-thread-safe private
    methods:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将公共方法重写为使用新定义的非线程安全私有方法：
- en: '[PRE25]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `foo_rec` class we just discussed uses a recursive mutex to protect access
    to shared data; in this case, it is an integer member variable that is accessed
    from two thread-safe public functions:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才讨论的`foo_rec`类使用递归互斥锁来保护对共享数据的访问；在这种情况下，它是一个整数成员变量，从两个线程安全的公共函数中访问：
- en: '`update()` sets a new value in the private variable.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update()`在私有变量中设置新值。'
- en: '`update_and_return()` sets a new value in the private variable and returns
    the previous value to the called function. This function calls `update()` to set
    the new value.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update_and_return()`在私有变量中设置新值，并将旧值返回给调用函数。此函数调用`update()`来设置新值。'
- en: The implementation of `foo_rec` was probably intended to avoid duplication of
    code, yet this particular approach is rather a design error that can be improved,
    as shown in the *How to do it...* section. Rather than reusing public thread-safe
    functions, we can provide private non-thread-safe functions that could then be
    called from the public interface.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`foo_rec`的实现可能旨在避免代码重复，但这种方法实际上是一个可以改进的设计错误，如*如何做…*部分所示。我们不是重用公共线程安全函数，而是可以提供私有非线程安全函数，然后可以从公共接口调用这些函数。'
- en: 'The same solution can be applied to other similar problems: define a non-thread-safe
    version of the code and then provide perhaps lightweight, thread-safe wrappers.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的解决方案可以应用于其他类似问题：定义一个非线程安全的代码版本，然后提供可能轻量级的线程安全包装器。
- en: See also
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Working with threads*, to learn about the `std::thread` class and the basic
    operations for working with threads in C++'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与线程一起工作*，了解`std::thread`类以及C++中与线程一起工作的基本操作'
- en: '*Synchronizing access to shared data with mutexes and locks*, to see what mechanisms
    are available for synchronizing thread access to shared data and how they work'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用互斥锁和锁同步对共享数据的访问*，以了解同步线程对共享数据访问的可用机制及其工作原理'
- en: Handling exceptions from thread functions
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理线程函数中的异常
- en: In the first recipe, we introduced the thread support library and saw how to
    do some basic operations with threads. In that recipe, we briefly discussed exception
    handling in thread functions and mentioned that exceptions cannot be caught with
    a `try…catch` statement in the context where the thread was started. On the other
    hand, exceptions can be transported between threads within a `std::exception_ptr`
    wrapper. In this recipe, we will see how to handle exceptions from thread functions.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个配方中，我们介绍了线程支持库，并展示了如何使用线程进行一些基本操作。在那个配方中，我们简要讨论了线程函数中的异常处理，并提到在启动线程的上下文中无法使用`try…catch`语句捕获异常。另一方面，异常可以在`std::exception_ptr`包装器内线程之间传输。在这个配方中，我们将了解如何处理线程函数中的异常。
- en: Getting ready
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You are now familiar with the thread operations we discussed in the previous
    recipe, *Working with threads*. The `exception_ptr` class is available in the
    `std` namespace, which is in the `<exception>` header; `mutex` (which we discussed
    in more detail previously) is also available in the same namespace but in the
    `<mutex>` header.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经熟悉了在先前的配方*与线程一起工作*中讨论的线程操作。`exception_ptr`类在`std`命名空间中可用，该命名空间在`<exception>`头文件中；`mutex`（我们之前更详细地讨论过）也在同一个命名空间中，但在`<mutex>`头文件中。
- en: How to do it...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'To properly handle exceptions thrown in a worker thread from the main thread
    or the thread where it was joined, do the following (assuming multiple exceptions
    can be thrown from multiple threads):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确处理在工作线程中从主线程或其连接的线程抛出的异常，请执行以下操作（假设可以从多个线程抛出多个异常）：
- en: 'Use a global container to hold instances of `std::exception_ptr`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用全局容器来保存`std::exception_ptr`的实例：
- en: '[PRE26]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Use a global `mutex` to synchronize access to the shared container:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用全局`mutex`来同步对共享容器的访问：
- en: '[PRE27]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Use a `try...catch` block for the code that is being executed in the top-level
    thread function. Use `std::current_exception()` to capture the current exception
    and wrap a copy or its reference into a `std::exception_ptr` pointer, which is
    added to the shared container for exceptions:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`try…catch`块来处理在顶级线程函数中执行的代码。使用`std::current_exception()`捕获当前异常，并将其副本或引用包装到一个`std::exception_ptr`指针中，然后将该指针添加到共享异常容器中：
- en: '[PRE28]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Clear the container from the main thread before you start the threads:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启动线程之前，从主线程中清除容器：
- en: '[PRE29]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the main thread, after the execution of all the threads has finished, inspect
    the caught exceptions and handle each of them appropriately:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主线程中，所有线程执行完成后，检查捕获的异常并适当地处理每个异常：
- en: '[PRE30]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: For the example in the preceding section, we assumed that multiple threads could
    throw exceptions and therefore need a container to hold them all. If there is
    a single exception from a single thread at a time, then you do not need a shared
    container and a mutex to synchronize access to it. You can use a single global
    object of the type `std::exception_ptr` to hold the exception that’s transported
    between threads.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前一个示例中的示例，我们假设多个线程可以抛出异常，因此需要一个容器来保存它们。如果一次只有一个线程抛出异常，那么你不需要共享容器和互斥锁来同步对其的访问。你可以使用一个全局的`std::exception_ptr`类型的单个对象来保存线程之间传输的异常。
- en: '`std::current_exception()` is a function that is typically used in a `catch`
    clause to capture the current exception and create an instance of `std::exception_ptr`.
    This is done to hold a copy or reference (depending on the implementation) to
    the original exception, which remains valid as long as there is a `std::exception_ptr`
    pointer available that refers to it. If this function is called when no exception
    is being handled, then it creates an empty `std::exception_ptr`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::current_exception()`是一个函数，通常用于`catch`子句中，用于捕获当前异常并创建一个`std::exception_ptr`实例。这样做是为了保留原始异常的副本或引用（取决于实现），只要有一个`std::exception_ptr`指针引用它，该异常就保持有效。如果在这个函数被调用时没有正在处理的异常，那么它创建一个空的`std::exception_ptr`。'
- en: The `std::exception_ptr` pointer is a wrapper for an exception captured with
    `std::current_exception()`. If default constructed, it does not hold any exception;
    it is, in this case, a null pointer. Two objects of this type are equal if they
    are both empty or point to the same exception object. The `std::exception_ptr`
    objects can be passed to other threads, where they can be rethrown and caught
    in a `try...catch` block.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::exception_ptr`指针是使用`std::current_exception()`捕获的异常的包装器。如果默认构造，它不包含任何异常；在这种情况下，它是一个空指针。如果两个对象都是空的或指向相同的异常对象，则这两个类型的对象相等。《std::exception_ptr`对象可以被传递到其他线程，在那里它们可以在`try...catch`块中被重新抛出和捕获。'
- en: '`std::rethrow_exception()` is a function that takes `std::exception_ptr` as
    an argument and throws the exception object referred to by its argument.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::rethrow_exception()`是一个函数，它接受`std::exception_ptr`作为参数，并抛出由其参数引用的异常对象。'
- en: '`std::current_exception()`, `std::rethrow_exception()`, and `std::exception_ptr`
    are all available in C++11.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::current_exception()`、`std::rethrow_exception()`和`std::exception_ptr`都是C++11中可用的。'
- en: In the example from the previous section, each thread function uses a `try...catch`
    statement for the entire code it executes so that no exception may leave the function
    uncaught. When an exception is handled, a lock on the global `mutex` object is
    acquired and the `std::exception_ptr` object holding the current exception is
    added to the shared container. With this approach, the thread function stops at
    the first exception; however, in other circumstances, you may need to execute
    multiple operations, even if the previous one throws an exception. In this case,
    you will have multiple `try...catch` statements and perhaps transport only some
    of the exceptions outside the thread.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节的示例中，每个线程函数使用整个代码执行的`try...catch`语句，以确保没有异常可能未捕获地离开函数。当处理异常时，会获取全局`mutex`对象的锁，并将包含当前异常的`std::exception_ptr`对象添加到共享容器中。使用这种方法，线程函数会在第一个异常处停止；然而，在其他情况下，你可能需要执行多个操作，即使前一个操作抛出了异常。在这种情况下，你将有多重`try...catch`语句，并且可能只将一些异常传输到线程外。
- en: In the main thread, after all the threads have finished executing, the container
    is iterated, and each non-empty exception is rethrown and caught with a `try...catch`
    block and handled appropriately.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在主线程中，所有线程执行完毕后，容器被迭代，每个非空异常都会被重新抛出，并通过一个`try...catch`块捕获并适当处理。
- en: See also
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Working with threads*, to learn about the `std::thread` class and the basic
    operations for working with threads in C++'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与线程一起工作*，了解`std::thread`类以及C++中处理线程的基本操作'
- en: '*Synchronizing access to shared data with mutexes and locks*, to see what mechanisms
    are available for synchronizing thread access to shared data and how they work'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用互斥锁和锁同步对共享数据的访问*，以了解可用于同步线程对共享数据访问的机制以及它们是如何工作的'
- en: Sending notifications between threads
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在线程之间发送通知
- en: Mutexes are synchronization primitives that can be used to protect access to
    shared data. However, the standard library provides a synchronization primitive,
    called a *condition variable*, that enables a thread to signal to others that
    a certain condition has occurred. The thread or threads that are waiting on the
    condition variable are blocked until the condition variable is signaled or until
    a timeout or a spurious wakeup occurs. In this recipe, we will see how to use
    condition variables to send notifications between thread-producing data and thread-consuming
    data.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥锁是同步原语，可以用来保护对共享数据的访问。然而，标准库提供了一个名为*条件变量*的同步原语，它允许一个线程向其他线程发出信号，表明某个条件已经发生。等待条件变量的线程或线程将被阻塞，直到条件变量被信号或直到超时或虚假唤醒发生。在这个菜谱中，我们将看到如何使用条件变量在产生数据的线程和消费数据的线程之间发送通知。
- en: Getting ready
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: For this recipe, you need to be familiar with threads, mutexes, and locks. Condition
    variables are available in the `std` namespace in the `<condition_variable>` header.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，你需要熟悉线程、互斥锁和锁。条件变量在 `<condition_variable>` 头文件中的 `std` 命名空间中可用。
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Use the following pattern for synchronizing threads with notifications on condition
    variables:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下模式来同步线程，并在条件变量上实现通知：
- en: 'Define a condition variable (in the appropriate context):'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个条件变量（在适当的作用域内）：
- en: '[PRE31]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Define a mutex for threads to lock on. A second mutex should be used for synchronizing
    access to the standard console from different threads:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个线程用于锁定互斥锁的互斥锁。第二个互斥锁应用于同步不同线程对标准控制台访问：
- en: '[PRE32]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Define the shared data used between the threads:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义线程之间使用的共享数据：
- en: '[PRE33]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the producing thread, lock the mutex before you modify the data:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生产线程中，在修改数据之前锁定互斥锁：
- en: '[PRE34]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the producing thread, signal the condition variable with a call to `notify_one()`
    or `notify_all()` (do this after the mutex used to protect the shared data is
    unlocked):'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生产线程中，通过调用 `notify_one()` 或 `notify_all()` 来信号条件变量（在用于保护共享数据的互斥锁解锁之后进行）：
- en: '[PRE35]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the consuming thread, acquire a unique lock on the data mutex and use it
    to wait on the condition variable. Beware that spurious wakeups may occur, which
    is a subject we’ll discuss in detail in the *How it works…* section:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在消费线程中，获取数据互斥锁上的唯一锁并使用它来等待条件变量。请注意，可能会发生虚假唤醒，这是我们将在 *How it works…* 部分详细讨论的主题：
- en: '[PRE36]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the consuming thread, use the shared data after the condition is notified:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在消费线程中，在条件被通知后使用共享数据：
- en: '[PRE37]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The preceding example represents two threads that share common data (in this
    case, an integer variable). One thread produces data after a lengthy computation
    (simulated with a sleep), while the other consumes it only after it is produced.
    To do so, they use a synchronization mechanism that uses a mutex and a condition
    variable that blocks the consuming thread until a notification arises from the
    producer thread, indicating that data has been made available. The key in this
    communication channel is the condition variable that the consuming thread waits
    on until the producing thread notifies it. Both threads start at about the same
    time. The producer thread begins a long computation that is supposed to produce
    data for the consuming thread. At the same time, the consuming thread cannot actually
    proceed until the data is made available; it must remain blocked until it is notified
    that the data has been produced. Once notified, it can continue its execution.
    The entire mechanism works as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例表示两个共享公共数据（在这种情况下，是一个整型变量）的线程。一个线程在经过长时间的计算（用睡眠来模拟）后产生数据，而另一个线程只在数据被产生后消费它。为了做到这一点，它们使用了一个同步机制，该机制使用互斥锁和一个条件变量来阻塞消费线程，直到生产线程发出通知，表明数据已可用。在这个通信通道中的关键是消费线程等待的条件变量，直到生产线程通知它。两个线程几乎同时开始。生产线程开始一个长时间的计算，这个计算应该为消费线程产生数据。同时，消费线程实际上不能继续执行，直到数据可用；它必须保持阻塞，直到它被通知数据已产生。一旦通知，它就可以继续执行。整个机制的工作方式如下：
- en: There must be at least one thread waiting on the condition variable to be notified.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少必须有一个线程在等待条件变量被通知。
- en: There must be at least one thread that is signaling the condition variable.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少必须有一个线程在信号条件变量。
- en: The waiting threads must first acquire a lock on a mutex (`std::unique_lock<std::mutex>`)
    and pass it to the `wait()`, `wait_for()`, or `wait_until()` method of the condition
    variable. All the waiting methods atomically release the mutex and block the thread
    until the condition variable is signaled. At this point, the thread is unblocked
    and the mutex is atomically acquired again (that means the operations involved
    are treated as a whole and the thread cannot be interrupted while performing them).
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待的线程必须首先在互斥锁上获取一个锁（`std::unique_lock<std::mutex>`）并将其传递给条件变量的 `wait()`、`wait_for()`
    或 `wait_until()` 方法。所有等待方法原子性地释放互斥锁并阻塞线程，直到条件变量被信号。此时，线程被解除阻塞，互斥锁再次原子性地获取（这意味着涉及的操作被视为一个整体，并且在执行这些操作时线程不能被中断）。
- en: The thread that signals the condition variable can do so with either `notify_one()`,
    where one blocked thread is unblocked, or `notify_all()`, where all the blocked
    threads waiting for the condition variable are unblocked.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号条件变量的线程可以使用 `notify_one()` 来这样做，其中只有一个阻塞的线程被解除阻塞，或者使用 `notify_all()`，其中所有等待条件变量的阻塞线程都被解除阻塞。
- en: Condition variables cannot be made completely predictable on multiprocessor
    systems. Therefore, *spurious wakeups* may occur, and a thread is unlocked even
    if nobody signals the condition variable. So, it is necessary to check whether
    the condition is true after the thread has been unblocked. However, spurious wakeups
    may occur multiple times and, therefore, it is necessary to check the condition
    variable in a loop. You can learn more about spurious wakeups at [https://en.wikipedia.org/wiki/Spurious_wakeup](https://en.wikipedia.org/wiki/Spurious_wakeup).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在多处理器系统中，条件变量无法完全预测。因此，可能会发生虚假唤醒，即使没有人信号条件变量，线程也会被解锁。因此，在线程被解除阻塞后，有必要检查条件是否为真。然而，虚假唤醒可能会多次发生，因此有必要在循环中检查条件变量。您可以在[https://en.wikipedia.org/wiki/Spurious_wakeup](https://en.wikipedia.org/wiki/Spurious_wakeup)上了解更多关于虚假唤醒的信息。
- en: 'The C++ standard provides two implementations of condition variables:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准提供了两个条件变量的实现：
- en: '`std::condition_variable`, used in this recipe, defines a condition variable
    associated with `std::unique_lock`.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此配方中使用的`std::condition_variable`定义了一个与`std::unique_lock`关联的条件变量。
- en: '`std::condition_variable_any` represents a more general implementation that
    works with any lock that meets the requirements of a basic lock (implements the
    `lock()` and `unlock()` methods). A possible use of this implementation is providing
    interruptible waits, as explained by Anthony Williams in *C++ Concurrency In Action*
    (2012):'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::condition_variable_any`代表一个更通用的实现，它可以与满足基本锁要求的任何锁一起工作（实现了`lock()`和`unlock()`方法）。此实现的可能用途是提供可中断的等待，如安东尼·威廉姆斯在《C++并发实战》（2012年）中所述：'
- en: A custom lock operation would both lock the associated mutex as expected and
    also perform the necessary job of notifying this condition variable when the interrupting
    signal is received.
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 自定义锁操作将按预期锁定相关互斥锁，并在接收到中断信号时执行必要的任务，即通知此条件变量。
- en: 'All the waiting methods of the condition variable have two overloads:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 条件变量的所有等待方法都有两个重载：
- en: The first overload takes `std::unique_lock<std::mutex>` (based on the type;
    that is, duration or time point) and causes the thread to remain blocked until
    the condition variable is signaled. This overload atomically releases the mutex
    and blocks the current thread, and then adds it to the list of threads waiting
    on the condition variable. The thread is unblocked when the condition is notified
    with either `notify_one()` or `notify_all()`, a spurious wakeup occurs, or a timeout
    occurs (depending on the function overload). When this happens, the mutex is atomically
    acquired again.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个重载接受`std::unique_lock<std::mutex>`（基于类型；即持续时间或时间点），并导致线程在条件变量被信号之前保持阻塞。此重载原子地释放互斥锁并阻塞当前线程，然后将其添加到等待条件变量的线程列表中。当条件通过`notify_one()`或`notify_all()`被通知，发生虚假唤醒或超时（取决于函数重载）时，线程被解除阻塞。当这种情况发生时，互斥锁再次被原子地获取。
- en: 'The second overload takes a predicate in addition to the arguments of the other
    overloads. This predicate can be used to avoid spurious wakeups while waiting
    for a condition to become `true`. This overload is equivalent to the following:'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个重载除了其他重载的参数外还接受一个谓词。这个谓词可以在等待条件变为`true`时避免虚假唤醒。此重载等同于以下内容：
- en: '[PRE38]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'On the other hand, the consumer thread’s implementation is listed here:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，消费者线程的实现如下所示：
- en: '[PRE41]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The consumer thread does the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者线程执行以下操作：
- en: Loops until it is signaled that the process of producing data is finished.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环直到接收到生产数据过程结束的信号。
- en: Acquires a unique lock on the `mutex` object associated with the condition variable.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在与条件变量关联的`mutex`对象上获取一个唯一的锁。
- en: Uses the `wait_for()` overload, which takes a predicate, checking that the buffer
    is not empty when a wakeup occurs (to avoid spurious wakeups). This method uses
    a timeout of 1 second and returns after the timeout has occurred, even if the
    condition is signaled.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`wait_for()`重载，该重载接受一个谓词，检查唤醒时缓冲区是否为空（以避免虚假唤醒）。此方法使用1秒的超时，并在超时发生后返回，即使条件已被信号。
- en: Consumes all of the data from the queue after it is signaled through the condition
    variable.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在通过条件变量发出信号后，消耗队列中的所有数据。
- en: 'To test this, we can start several producing threads and one consuming thread.
    Producer threads generate random data and, therefore, share the pseudo-random
    generator engines and distributions. All of this is shown in the following code
    sample:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，我们可以启动几个生产线程和一个消费线程。生产线程生成随机数据，因此共享伪随机数生成器和分布。所有这些都在下面的代码示例中展示：
- en: '[PRE42]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'A possible output of this program is as follows (the actual output would be
    different for each execution):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的可能的输出如下（实际输出会因每次执行而不同）：
- en: '[PRE43]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The standard also features a helper function called `notify_all_at_thread_exit()`,
    which provides a way for a thread to notify other threads through a `condition_variable`
    object that it’s completely finished execution, including destroying all `thread_local`
    objects. This function has two parameters: a `condition_variable` and a `std::unique_lock<std::mutex>`
    associated with the condition variable (that it takes ownership of). The typical
    use case for this function is running a detached thread that calls this function
    just before finishing.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 该标准还提供了一个名为`notify_all_at_thread_exit()`的辅助函数，它提供了一种方式，允许一个线程通过一个`condition_variable`对象通知其他线程它已经完全完成执行，包括销毁所有`thread_local`对象。此函数有两个参数：一个与条件变量关联的`condition_variable`和一个`std::unique_lock<std::mutex>`（它接受所有权）。此函数的典型用例是运行一个分离的线程，在完成前调用此函数。
- en: See also
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Working with threads*, to learn about the `std::thread` class and the basic
    operations for working with threads in C++'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与线程一起工作*，了解`std::thread`类以及C++中与线程一起工作的基本操作'
- en: '*Synchronizing access to shared data with mutexes and locks*, to see what mechanisms
    are available for synchronizing thread access to shared data and how they work'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用互斥锁和锁同步对共享数据的访问*，了解可用于同步线程对共享数据访问的机制以及它们是如何工作的'
- en: Using promises and futures to return values from threads
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用承诺和未来从线程返回值
- en: In the first recipe of this chapter, we discussed how to work with threads.
    You also learned that thread functions cannot return values and that threads should
    use other means, such as shared data, to do so; however, for this, synchronization
    is required. An alternative to communicating a return value or an exception with
    either the main or another thread is using `std::promise`. This recipe will explain
    how this mechanism works.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一个菜谱中，我们讨论了如何与线程一起工作。你还了解到，线程函数不能返回值，并且线程应该使用其他方法，例如共享数据，来做到这一点；然而，为此需要同步。与主线程或另一个线程通信返回值或异常的另一种选择是使用`std::promise`。本菜谱将解释这个机制是如何工作的。
- en: Getting ready
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `promise` and `future` classes used in this recipe are available in the
    `std` namespace in the `<future>` header.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱中使用的`promise`和`future`类在`<future>`头文件中的`std`命名空间中可用。
- en: How to do it...
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To communicate a value from one thread to another through promises and futures,
    do this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过承诺和未来从一个线程向另一个线程通信一个值，这样做：
- en: 'Make a promise available to the thread function through a parameter; for example:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过参数将承诺提供给线程函数；例如：
- en: '[PRE44]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Call `set_value()` on the promise to set the result to represent a value or
    `set_exception()` to set the result to indicate an exception:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在承诺上调用`set_value()`来设置结果表示一个值或调用`set_exception()`来设置结果表示一个异常：
- en: '[PRE45]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Make the future associated with the promise available to the other thread function
    through a parameter; for example:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过参数将承诺关联的未来提供给其他线程函数；例如：
- en: '[PRE46]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Call `get()` on the `future` object to get the result set to the promise:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`future`对象上调用`get()`来获取设置到承诺中的结果：
- en: '[PRE47]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the calling thread, use `get_future()` on the promise to get the `future`
    associated with the promise:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用线程中，使用承诺的`get_future()`方法来获取与承诺关联的`future`：
- en: '[PRE48]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works...
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The promise-future pair is basically a communication channel that enables a
    thread to communicate a value or exception with another thread through a shared
    state. `promise` is an asynchronous provider of the result and has an associated
    `future` that represents an asynchronous return object. To establish this channel,
    you must first create a promise. This, in turn, creates a shared state that can
    be later read through the future associated with the promise.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺-未来对基本上是一个通信通道，它允许一个线程通过共享状态与另一个线程通信一个值或异常。`promise`是一个异步的结果提供者，它有一个关联的`future`，代表异步返回对象。为了建立这个通道，你必须首先创建一个承诺。这反过来又创建了一个可以稍后通过承诺关联的未来读取的共享状态。
- en: 'To set a result to a promise, you can use any of the following methods:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要将结果设置到承诺中，你可以使用以下任何一种方法：
- en: The `set_value()` or `set_value_at_thread_exit()` method is used to set a return
    value; the latter function stores the value in the shared state but only makes
    it available through the associated future if the thread exits.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`set_value()`或`set_value_at_thread_exit()`方法来设置返回值；后一个函数将值存储在共享状态中，但只有在线程退出时才通过关联的future使其可用。
- en: The `set_exception()` or `set_exception_at_thread_exit()` method is used to
    set an exception as a return value. The exception is wrapped in a `std::exception_ptr`
    object. The latter function stores the exception in the shared state but only
    makes it available when the thread exits.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`set_exception()`或`set_exception_at_thread_exit()`方法来设置一个异常作为返回值。异常被封装在一个`std::exception_ptr`对象中。后一个函数将异常存储在共享状态中，但只有在线程退出时才使其可用。
- en: 'To retrieve the `future` object associated with `promise`, use the `get_future()`
    method. To get the value from the `future` value, use the `get()` method. This
    blocks the calling thread until the value from the shared state is made available.
    The future class has several methods for blocking the thread until the result
    from the shared state is made available:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索与`promise`关联的`future`对象，请使用`get_future()`方法。要从`future`值中获取值，请使用`get()`方法。这将阻塞调用线程，直到共享状态中的值可用。Future类有几种方法可以阻塞线程，直到共享状态的结果可用：
- en: '`wait()` only returns when the result is available.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wait()`仅在结果可用时返回。'
- en: '`wait_for()` returns either when the result is available or when the specified
    timeout expires.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wait_for()`在结果可用或指定的超时时间到期时返回。'
- en: '`wait_until()` returns either when the result is available or when the specified
    time point is reached.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wait_until()`在结果可用或指定的时刻到达时返回。'
- en: 'If an exception is set to the `promise` value, calling the `get()` method on
    the `future` object will throw this exception. The example from the previous section
    has been rewritten as follows to throw an exception instead of setting a result:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将异常设置到`promise`值，则在`future`对象上调用`get()`方法将抛出此异常。上一节中的示例已被重写如下，以抛出异常而不是设置结果：
- en: '[PRE49]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: You can see here that, in the `consume_value()` function, the call to `get()`
    is put in a `try...catch` block. If an exception is caught – and in this particular
    implementation, it is – its message is printed to the console.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到，在`consume_value()`函数中，对`get()`的调用被放在一个`try...catch`块中。如果捕获到异常——在这个特定的实现中，确实是这样——其消息将被打印到控制台。
- en: There’s more...
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Establishing a promise-future channel in this manner is a rather explicit operation
    that can be avoided by using the `std::async()` function; this is a higher-level
    utility that runs a function asynchronously, creates an internal promise and a
    shared state, and returns a future associated with the shared state. We will see
    how `std::async()` works in the next recipe, *Executing functions asynchronously*.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式建立promise-future通道是一个相当明确的操作，可以通过使用`std::async()`函数来避免；这是一个高级实用工具，它异步运行一个函数，创建一个内部promise和一个共享状态，并返回与共享状态关联的future。我们将在下一个配方中看到`std::async()`是如何工作的，*异步执行函数*。
- en: See also
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Working with threads*, to learn about the `std::thread` class and the basic
    operations for working with threads in C++'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用线程*，了解`std::thread`类以及如何在C++中操作线程的基本操作'
- en: '*Handling exceptions from thread functions*, to understand how to handle exceptions
    thrown in a worker thread from the main thread or the thread where it was joined'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理线程函数中的异常*，了解如何从主线程或连接的线程中处理工作线程抛出的异常'
- en: Executing functions asynchronously
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步执行函数
- en: Threads enable us to run multiple functions at the same time; this helps us
    take advantage of the hardware facilities in multiprocessor or multicore systems.
    However, threads require explicit, lower-level operations. An alternative to threads
    is tasks, which are units of work that run in a particular thread. The C++ standard
    does not provide a complete task library, but it enables developers to execute
    functions asynchronously on different threads and communicate results back through
    a promise-future channel, as seen in the previous recipe. In this recipe, we will
    see how to do this using `std::async()` and `std::future`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 线程使我们能够同时运行多个函数；这有助于我们利用多处理器或多核系统中的硬件设施。然而，线程需要显式、低级别的操作。线程的替代方案是任务，它们是在特定线程中运行的作业单元。C++标准没有提供完整的任务库，但它允许开发者在不同线程上异步执行函数，并通过promise-future通道返回结果，如前一个配方中所示。在这个配方中，我们将看到如何使用`std::async()`和`std::future`来完成这项工作。
- en: Getting ready
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For the examples in this recipe, we will use the following functions:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱的示例中，我们将使用以下函数：
- en: '[PRE50]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this recipe, we will use futures; therefore, you are advised to read the
    previous recipe to get a quick overview of how they work. Both `async()` and `future`
    are available in the `std` namespace in the `<future>` header.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用 futures；因此，建议您阅读之前的食谱以快速了解它们的工作原理。`async()` 和 `future` 都在 `<future>`
    头文件中的 `std` 命名空间中可用。
- en: How to do it...
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To execute a function asynchronously on another thread when the current thread
    is continuing with the execution without expecting a result, do the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当当前线程继续执行而不期望结果时，在另一个线程上异步执行函数，直到当前线程需要异步函数的结果，请执行以下操作：
- en: 'Use `std::async()` to start a new thread to execute the specified function.
    This will create an asynchronous provider and return a `future` associated with
    it. Use the `std::launch::async` policy for the first argument to the `std::async()`
    function in order to make sure the function will run asynchronously:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `std::async()` 启动一个新线程来执行指定的函数。这将创建一个异步提供者，并返回与其关联的 `future` 对象。为了确保函数将异步运行，请使用
    `std::launch::async` 策略作为 `std::async()` 函数的第一个参数：
- en: '[PRE51]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Continue with the execution of the current thread:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续执行当前线程：
- en: '[PRE52]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Call the `wait()` method on the `future` object returned by `std::async()`
    when you need to make sure the asynchronous operation is completed:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你需要确保异步操作完成时，请在 `std::async()` 返回的 `future` 对象上调用 `wait()` 方法：
- en: '[PRE53]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To execute a function asynchronously on a worker thread while the current thread
    continues its execution, until the result from the asynchronous function is needed
    in the current thread, do the following:'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当当前线程继续执行，直到当前线程需要异步函数的结果时，在工作者线程上异步执行函数，请执行以下操作：
- en: 'Use `std::async()` to start a new thread to execute the specified function,
    create an asynchronous provider, and return a `future` associated with it. Use
    the `std::launch::async` policy of the first argument to the function to make
    sure the function does run asynchronously:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `std::async()` 启动一个新线程来执行指定的函数，创建一个异步提供者，并返回与其关联的 `future` 对象。为了确保函数确实异步运行，请使用函数的第一个参数的
    `std::launch::async` 策略：
- en: '[PRE54]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Continue the execution of the current thread:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续执行当前线程：
- en: '[PRE55]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Call the `get()` method on the `future` object returned by `std::async()` when
    you need the result from the function to be executed asynchronously:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你需要异步执行函数的结果时，请在 `std::async()` 返回的 `future` 对象上调用 `get()` 方法：
- en: '[PRE56]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: How it works...
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`std::async()` is a variadic function template that has two overloads: one
    that specifies a launch policy as the first argument and another that does not.
    The other arguments to `std::async()` are the function to execute and its arguments,
    if any. The launch policy is defined by a scoped enumeration called `std::launch`,
    available in the `<future>` header:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::async()` 是一个变长参数模板函数，有两个重载：一个指定了作为第一个参数的启动策略，另一个则没有。`std::async()` 的其他参数是要执行的函数及其参数（如果有）。启动策略由一个名为
    `std::launch` 的范围枚举定义，该枚举在 `<future>` 头文件中可用：'
- en: '[PRE57]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The two available launch policies specify the following:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的两个启动策略指定如下：
- en: With `async`, a new thread is launched to execute the task asynchronously.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `async`，将启动一个新线程来异步执行任务。
- en: With `deferred`, the task is executed on the calling thread the first time its
    result is requested.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `deferred`，任务将在第一次请求其结果时在调用线程上执行。
- en: When both flags are specified (`std::launch::async | std::launch::deferred`),
    it is an implementation decision regarding whether to run the task asynchronously
    on a new thread or synchronously on the current thread. This is the behavior of
    the other `std::async()` overload that does not specify a launch policy. This
    behavior is not deterministic.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当同时指定两个标志（`std::launch::async | std::launch::deferred`）时，是否在新的线程上异步运行任务或在当前线程上同步运行是实现决策。这是不指定启动策略的其他
    `std::async()` 重载的行为。这种行为是不确定的。
- en: Do not use the non-deterministic overload of `std::async()` to run tasks asynchronously.
    For this purpose, always use the overload that requires a launch policy, and always
    use only `std::launch::async`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用非确定性的 `std::async()` 重载来异步运行任务。为此，始终使用需要启动策略的重载，并且始终只使用 `std::launch::async`。
- en: Both overloads of `std::async()` return a `future` object that refers to the
    shared state created internally by `std::async()` for the promise-future channel
    it establishes. When you need the result of the asynchronous operation, call the
    `get()` method on the future. This blocks the current thread until either the
    result value or an exception is made available. If the future does not transport
    any value or if you are not actually interested in that value, but you want to
    make sure the asynchronous operation will be completed at some point, use the
    `wait()` method; it blocks the current thread until the shared state is made available
    through the future.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::async()` 的两种重载都返回一个 `future` 对象，该对象引用 `std::async()` 内部创建的共享状态，用于它建立的承诺-未来通道。当你需要异步操作的结果时，请在
    `future` 上调用 `get()` 方法。这将阻塞当前线程，直到结果值或异常可用。如果 `future` 不携带任何值或你实际上不感兴趣该值，但想确保异步操作将在某个时刻完成，请使用
    `wait()` 方法；它将阻塞当前线程，直到通过 `future` 可用共享状态。'
- en: 'The future class has two more waiting methods: `wait_for()` specifies a duration
    after which the call ends and returns even if the shared state is not yet available
    through the future, while `wait_until()` specifies a time point after which the
    call returns, even if the shared state is not yet available. These methods could
    be used to create a polling routine and display a status message to the user,
    as shown in the following example:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`future` 类还有两个等待方法：`wait_for()` 指定一个持续时间，在此之后调用结束并返回，即使共享状态尚未通过 `future` 可用，而
    `wait_until()` 指定一个时间点，在此之后调用返回，即使共享状态尚未可用。这些方法可以用来创建轮询例程并向用户显示状态消息，如下例所示：'
- en: '[PRE58]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The result of running this program is as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序的结果如下：
- en: '[PRE59]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: See also
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: '*Using promises and futures to return values from threads*, to learn how to
    use a `std::promise` object to return a value or an exception from a thread'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用承诺和未来从线程返回值*，了解如何使用 `std::promise` 对象从线程返回一个值或异常'
- en: Using atomic types
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原子类型
- en: The thread support library offers functionalities for managing threads and synchronizing
    access to shared data with mutexes and locks, and, as of C++20, with latches,
    barriers, and semaphores. The standard library provides support for the complementary,
    lower-level atomic operations on data, which are indivisible operations that can
    be executed concurrently from different threads on shared data, without the risk
    of producing race conditions and without the use of locks. The support it provides
    includes atomic types, atomic operations, and memory synchronization ordering.
    In this recipe, we will see how to use some of these types and functions.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 线程支持库提供了管理线程和同步对共享数据访问（使用互斥锁和锁，以及从 C++20 开始使用闩锁、屏障和信号量）的功能。标准库提供了对数据互补、低级原子操作的支持，这些操作是不可分割的操作，可以在不同线程上并发执行，而不会产生竞态条件，也不需要使用锁。它提供支持包括原子类型、原子操作和内存同步排序。在本菜谱中，我们将看到如何使用这些类型和函数。
- en: Getting ready
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: All the atomic types and operations are defined in the `std` namespace in the
    `<atomic>` header.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 所有原子类型和操作都在 `<atomic>` 头文件中定义的 `std` 命名空间中。
- en: How to do it...
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following are a series of typical operations that use atomic types:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一系列使用原子类型的典型操作：
- en: 'Use the `std::atomic` class template to create atomic objects that support
    atomic operations, such as loading, storing, or performing arithmetic or bitwise
    operations:'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::atomic` 类模板创建支持原子操作（如加载、存储或执行算术或位运算）的原子对象：
- en: '[PRE60]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In C++20, use the `std::atomic_ref` class template to apply atomic operations
    to a referenced object, which can be a reference or pointer to an integral type,
    a floating-point type, or a user-defined type:'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C++20 中，使用 `std::atomic_ref` 类模板将原子操作应用于引用的对象，该对象可以是整数类型、浮点类型或用户定义类型的引用或指针：
- en: '[PRE61]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Use the `std::atomic_flag` class for an atomic Boolean type:'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::atomic_flag` 类来表示原子布尔类型：
- en: '[PRE62]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Use the atomic type’s members – `load()`, `store()`, and `exchange()` – or non-member
    functions – `atomic_load()`/`atomic_load_explicit()`, `atomic_store()`/`atomic_store_explicit()`,
    and `atomic_exchange()`/`atomic_exchange_explicit()` – to atomically read, set,
    or exchange the value of an atomic object.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原子类型的成员 – `load()`、`store()` 和 `exchange()` – 或非成员函数 – `atomic_load()`/`atomic_load_explicit()`、`atomic_store()`/`atomic_store_explicit()`、和
    `atomic_exchange()`/`atomic_exchange_explicit()` – 以原子方式读取、设置或交换原子对象的值。
- en: 'Use its member functions `fetch_add()` and `fetch_sub()` or non-member functions
    `atomic_fetch_add()`/`atomic_fetch_add_explicit()` and `atomic_fetch_sub()`/`atomic_fetch_sub_explicit()`
    to atomically add or subtract a value to/from an atomic object and return its
    value before the operation:'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用其成员函数 `fetch_add()` 和 `fetch_sub()` 或非成员函数 `atomic_fetch_add()`/`atomic_fetch_add_explicit()`
    和 `atomic_fetch_sub()`/`atomic_fetch_sub_explicit()` 来原子性地向原子对象添加或减去一个值，并返回操作前的值：
- en: '[PRE63]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Use its member functions `fetch_and()`, `fetch_or()`, and `fetch_xor()` or non-member
    functions `atomic_fetch_and()`/`atomic_fetch_and_explicit()`, `atomic_fetch_or()`/
    `atomic_fetch_or_explicit()`, and `atomic_fetch_xor()`/`atomic_fetch_xor_explicit()`
    to perform AND, OR, and XOR atomic operations, respectively, with the specified
    argument and return the value of the atomic object before the operation.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用其成员函数 `fetch_and()`、`fetch_or()` 和 `fetch_xor()` 或非成员函数 `atomic_fetch_and()`/`atomic_fetch_and_explicit()`、`atomic_fetch_or()`/
    `atomic_fetch_or_explicit()`、和 `atomic_fetch_xor()`/`atomic_fetch_xor_explicit()`
    来执行分别对应 AND、OR 和 XOR 原子操作，并返回操作前原子对象的价值。
- en: Use the `std::atomic_flag` member functions `test_and_set()` and `clear()` or
    non-member functions `atomic_flag_test_and_set()`/`atomic_flag_test_and_set_explicit()`
    and `atomic_flag_clear()`/`atomic_flag_clear_explicit()` to set or reset an atomic
    flag. In addition, in C++20, you can use the member function `test()` and the
    non-member function `atomic_flag_test()`/`atomic_flag_test_explicit()` to atomically
    return the value of the flag.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::atomic_flag` 的成员函数 `test_and_set()` 和 `clear()` 或非成员函数 `atomic_flag_test_and_set()`/`atomic_flag_test_and_set_explicit()`
    和 `atomic_flag_clear()`/`atomic_flag_clear_explicit()` 来设置或重置一个原子标志。此外，在 C++20
    中，你可以使用成员函数 `test()` 和非成员函数 `atomic_flag_test()`/`atomic_flag_test_explicit()`
    来原子性地返回标志的值。
- en: In C++20, perform thread synchronization with member functions `wait()`, `notify_one()`,
    and `notify_all()`, available to `std::atomic`, `std::atomic_ref`, and `std::atomic_flag`,
    as well as the non-member functions `atomic_wait()`/`atomic_wait_explicit()`,
    `atomic_notify_one()`, and `atomic_notify_all()`. These functions provide a more
    efficient mechanism for waiting for the value of an atomic object to change than
    polling.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C++20 中，使用成员函数 `wait()`、`notify_one()` 和 `notify_all()` 以及非成员函数 `atomic_wait()`/`atomic_wait_explicit()`、`atomic_notify_one()`
    和 `atomic_notify_all()` 来执行线程同步，这些函数对 `std::atomic`、`std::atomic_ref` 和 `std::atomic_flag`
    都可用。这些函数提供了一个比轮询更有效的等待原子对象值改变的机制。
- en: How it works...
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`std::atomic` is a class template that defines (including its specializations)
    an atomic type. The behavior of an object of an atomic type is well defined when
    one thread writes to the object and the other reads data, without using locks
    to protect access. The operations on atomic variables are treated as single, uninterruptable
    actions. If two threads want to write on the same atomic variable, the first to
    take hold of it will write, while the other will wait for the atomic write to
    complete before it writes. This is a deterministic behavior and does not require
    additional locking.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::atomic` 是一个类模板，定义了（包括其特化）一个原子类型。当一个线程写入对象而另一个线程读取数据时，原子类型对象的行为是明确定义的，无需使用锁来保护访问。原子变量的操作被视为单一、不可中断的操作。如果两个线程都想写入同一个原子变量，则第一个获得它的线程将写入，而另一个将等待原子写入完成后再写入。这是一个确定性行为，不需要额外的锁定。'
- en: 'The `std::atomic` class provides several specializations:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::atomic` 类提供了几个特化：'
- en: Full specialization for `bool`, with a typedef called `atomic_bool`.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 `bool` 的完全特化，有一个名为 `atomic_bool` 的类型别名。
- en: Full specialization for all integral types, with type aliases (typedefs) called
    `atomic_bool` (for `std::atomic<bool>`), `atomic_int` (for `std::atomic<int>`),
    `atomic_long` (for `std::atomic<long>`), `atomic_char` (for `std::atomic<char>`),
    `atomic_size_t` (for `std::atomic<std::size_t>`), and many others.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有整型类型都实现了完全特化，包括类型别名（typedefs），例如 `atomic_bool`（对应 `std::atomic<bool>`）、`atomic_int`（对应
    `std::atomic<int>`）、`atomic_long`（对应 `std::atomic<long>`）、`atomic_char`（对应 `std::atomic<char>`）、`atomic_size_t`（对应
    `std::atomic<std::size_t>`）以及许多其他类型。
- en: Partial specialization for pointer types.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针类型的部分特化。
- en: In C++20, full specializations for the floating-point types `float`, `double`,
    and `long double`.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C++20 中，对浮点类型 `float`、`double` 和 `long double` 实现了完全特化。
- en: In C++20, partial specializations such as `std::atomic<std::shared_ptr<U>>`
    for `std::shared_ptr` and `std::atomic<std::weak_ptr<U>>` for `std::weak_ptr`.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C++20 中，对 `std::shared_ptr<U>` 的 `std::atomic<std::shared_ptr<U>>` 和对 `std::weak_ptr<U>`
    的 `std::atomic<std::weak_ptr<U>>` 实现了部分特化。
- en: 'The `atomic` class template has various member functions that perform atomic
    operations, such as the following:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`atomic` 类模板具有各种成员函数，执行原子操作，例如以下：'
- en: '`load()` to atomically load and return the value of the object.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load()` 用于原子地加载并返回对象的值。'
- en: '`store()` to atomically store a non-atomic value in the object; this function
    does not return anything.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`store()` 用于原子地将非原子值存储在对象中；此函数不返回任何内容。'
- en: '`exchange()` to atomically store a non-atomic value in the object and return
    the previous value.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exchange()` 用于原子地将非原子值存储在对象中并返回之前的值。'
- en: '`operator=`, which has the same effect as `store(arg)`.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator=`，其效果与 `store(arg)` 相同。'
- en: '`fetch_add()` to atomically add a non-atomic argument to the atomic value and
    return the value stored previously.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch_add()` 用于原子地将非原子参数添加到原子值中，并返回之前存储的值。'
- en: '`fetch_sub()` to atomically subtract a non-atomic argument from the atomic
    value and return the value stored previously.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch_sub()` 用于原子地从原子值中减去非原子参数并返回之前存储的值。'
- en: '`fetch_and()`, `fetch_or()`, and `fetch_xor()` to atomically perform a bitwise
    AND, OR, or XOR operation between the argument and the atomic value; store the
    new value in the atomic object; and return the previous value.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch_and()`, `fetch_or()`, 和 `fetch_xor()` 用于原子地在参数和原子值之间执行位与、或或异或操作；将新值存储在原子对象中；并返回之前的值。'
- en: Prefixing and postfixing `operator++` and `operator--` to atomically increment
    and decrement the value of the atomic object with 1\. These operations are equivalent
    to using `fetch_add()` or `fetch_sub()`.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `operator++` 和 `operator--` 前缀和后缀中添加，以原子地增加和减少原子对象的值 1。这些操作相当于使用 `fetch_add()`
    或 `fetch_sub()`。
- en: '`operator +=`, `-=`, `&=`, `|=`, and `ˆ=` to add, subtract, or perform bitwise
    AND, OR, or XOR operations between the argument and the atomic value and store
    the new value in the atomic object. These operations are equivalent to using `fetch_add()`,
    `fetch_sub()`, `fetch_and()`, `fetch_or()`, and `fetch_xor()`.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator +=`, `-=`, `&=`, `|=`, 和 `ˆ=` 用于在参数和原子值之间添加、减去或执行位与、或或异或操作，并将新值存储在原子对象中。这些操作相当于使用
    `fetch_add()`、`fetch_sub()`、`fetch_and()`、`fetch_or()` 和 `fetch_xor()`。'
- en: 'Consider you have an atomic variable, such as `std::atomic<int> a`; the following
    is not an atomic operation:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个原子变量，例如 `std::atomic<int> a`；以下不是原子操作：
- en: '[PRE64]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This involves a series of operations, some of which are atomic:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这涉及一系列操作，其中一些是原子的：
- en: Atomically load the value of the atomic object
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原子地加载原子对象的值
- en: Add 42 to the value that was loaded (which is not an atomic operation)
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 42 添加到加载的值（这不是原子操作）
- en: Atomically store the result in the atomic object `a`
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原子地将结果存储在原子对象 `a` 中
- en: 'On the other hand, the following operation, which uses the member operator
    `+=`, is atomic:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，以下使用成员运算符 `+=` 的操作是原子的：
- en: '[PRE65]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This operation has the same effect as either of the following:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作与以下任一操作具有相同的效果：
- en: '[PRE66]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Though `std::atomic` has a full specialization for the `bool` type, called
    `std::atomic<bool>`, the standard defines yet another atomic type called `std::atomic_flag`,
    which is guaranteed to be lock-free. This atomic type, however, is very different
    than `std::atomic<bool>`, and it has only the following member functions:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `std::atomic` 为 `bool` 类型提供了完全特化，称为 `std::atomic<bool>`，但标准还定义了另一种原子类型，称为
    `std::atomic_flag`，它保证是无锁的。然而，此原子类型与 `std::atomic<bool>` 非常不同，并且它只有以下成员函数：
- en: '`test_and_set()` atomically sets the value to `true` and returns the previous
    value.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_and_set()` 原子地将值设置为 `true` 并返回之前的值。'
- en: '`clear()` atomically sets the value to `false`.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear()` 原子地将值设置为 `false`。'
- en: In C++20, there’s `test()`, which atomically returns the value of the flag.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C++20 中，有 `test()`，它原子地返回标志的值。
- en: 'Prior to C++20, the only way to initialize a `std::atomic_flag` to a definite
    value was by using the `ATOMIC_FLAG_INIT` macro. This initializes the atomic flag
    to the clear (`false`) value:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++20 之前，初始化 `std::atomic_flag` 为确定值的唯一方法是使用 `ATOMIC_FLAG_INIT` 宏。此宏将原子标志初始化为清除（`false`）值：
- en: '[PRE67]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In C++20, this macro has been deprecated because the default constructor of
    `std::atomic_flag` initializes it to the clear state.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++20 中，此宏已被弃用，因为 `std::atomic_flag` 的默认构造函数将其初始化为清除状态。
- en: All member functions mentioned earlier, for both `std::atomic` and `std::atomic_flag`,
    have non-member equivalents that are prefixed with `atomic_` or `atomic_flag_`,
    depending on the type they refer to. For instance, the equivalent of `std::atomic::fetch_add()`
    is `std::atomic_fetch_add()`, and the first argument of these non-member functions
    is always a pointer to a `std::atomic` object. Internally, the non-member function
    calls the equivalent member function on the provided `std::atomic` argument. Similarly,
    the equivalent of `std::atomic_flag::test_and_set()` is `std::atomic_flag_test_and_set()`,
    and its first parameter is a pointer to a `std::atomic_flag` object.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的所有成员函数，无论是 `std::atomic` 还是 `std::atomic_flag`，都有非成员等效函数，这些函数以 `atomic_`
    或 `atomic_flag_` 为前缀，具体取决于它们引用的类型。例如，`std::atomic::fetch_add()` 的等效函数是 `std::atomic_fetch_add()`，这些非成员函数的第一个参数始终是指向
    `std::atomic` 对象的指针。内部，非成员函数在提供的 `std::atomic` 参数上调用等效的成员函数。同样，`std::atomic_flag::test_and_set()`
    的等效函数是 `std::atomic_flag_test_and_set()`，其第一个参数是指向 `std::atomic_flag` 对象的指针。
- en: All these member functions of `std::atomic` and `std::atomic_flag` have two
    sets of overloads; one of them has an extra argument representing a memory order.
    Similarly, all non-member functions – such as `std::atomic_load()`, `std::atomic_fetch_add()`,
    and `std::atomic_flag_test_and_set()` – have a companion with the suffix `_explicit`
    – `std::atomic_load_explicit()`, `std::atomic_fetch_add_explicit()`, and `std::atomic_flag_test_and_set_explicit()`;
    these functions have an extra argument that represents the memory order.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些 `std::atomic` 和 `std::atomic_flag` 的成员函数都有两套重载；其中一套有一个额外的参数表示内存顺序。同样，所有非成员函数——例如
    `std::atomic_load()`、`std::atomic_fetch_add()` 和 `std::atomic_flag_test_and_set()`——都有一个带有后缀
    `_explicit` 的伴随函数——`std::atomic_load_explicit()`、`std::atomic_fetch_add_explicit()`
    和 `std::atomic_flag_test_and_set_explicit()`；这些函数有一个额外的参数表示内存顺序。
- en: The memory order specifies how non-atomic memory accesses are to be ordered
    around atomic operations. By default, the memory order of all atomic types and
    operations is *sequential consistency*.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 内存顺序指定了非原子内存访问如何围绕原子操作进行排序。默认情况下，所有原子类型和操作的内存顺序是 *顺序一致性*。
- en: Additional ordering types are defined in the `std::memory_order` enumeration
    and can be passed as an argument to the member functions of `std::atomic` and
    `std::atomic_flag`, or the non-member functions with the suffix `_explicit()`.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `std::memory_order` 枚举中定义了额外的排序类型，可以将它们作为 `std::atomic` 和 `std::atomic_flag`
    的成员函数或带有后缀 `_explicit()` 的非成员函数的参数传递。
- en: '*Sequential consistency* is a consistency model that requires that, in a multiprocessor
    system, all instructions are executed in some order and all writes become instantly
    visible throughout the system. This model was first proposed by Leslie Lamport
    in the 70s, and is described as follows:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '*顺序一致性* 是一种一致性模型，它要求在多处理器系统中，所有指令都必须按某种顺序执行，并且所有写操作都必须立即在整个系统中可见。这个模型最初由Leslie
    Lamport在70年代提出，描述如下：'
- en: '*“the results of any execution is the same as if the operations of all the
    processors were executed in some sequential order, and the operations of each
    individual processor appear in this sequence in the order specified by its program.”*'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '*“任何执行的任何结果都等同于如果所有处理器的操作都按某种顺序执行，并且每个处理器的操作都按其程序指定的顺序出现在这个序列中。”*'
- en: 'Various types of memory ordering functions are described in the following table,
    taken from the C++ reference website ([http://en.cppreference.com/w/cpp/atomic/memory_order](http://en.cppreference.com/w/cpp/atomic/memory_order)).
    The details of how each of these works is beyond the scope of this book and can
    be looked up in the standard C++ reference (see the previous link):'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格描述了各种类型的内存排序函数，这些内容摘自C++参考网站（[http://en.cppreference.com/w/cpp/atomic/memory_order](http://en.cppreference.com/w/cpp/atomic/memory_order)）。每个这些函数如何工作的细节超出了本书的范围，可以在标准的C++参考中查找（参见前面的链接）：
- en: '| **Model** | **Explanation** |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| **模型** | **说明** |'
- en: '| `memory_order_relaxed` | This is a relaxed operation. There are no synchronization
    or ordering constraints; only atomicity is required from this operation. |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| `memory_order_relaxed` | 这是一个非同步操作。没有同步或排序约束；仅要求此操作具有原子性。|'
- en: '| `memory_order_consume` | A load operation with this memory order performs
    a consume operation on the affected memory location; no reads or writes in the
    current thread that are dependent on the value currently loaded can be reordered
    before this load operation. Writes to data-dependent variables in other threads
    that release the same atomic variable are visible in the current thread. On most
    platforms, this affects compiler optimizations only. |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| `memory_order_consume` | 使用此内存顺序的加载操作在受影响的内存位置执行消耗操作；当前线程中依赖于当前加载值的任何读取或写入操作都不能在此加载操作之前重排。在其他线程中对释放相同原子变量的数据依赖变量进行的写入在当前线程中是可见的。在大多数平台上，这仅影响编译器优化。|'
- en: '| `memory_order_acquire` | A load operation with this memory order performs
    the acquire operation on the affected memory location; no reads or writes in the
    current thread can be reordered before this load. All writes in other threads
    that release the same atomic variable are visible in the current thread. |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| `memory_order_acquire` | 使用此内存顺序的加载操作在受影响的内存位置执行获取操作；当前线程中的任何读取或写入操作都不能在此加载之前重排。在其他线程中释放相同原子变量的所有写入在当前线程中都是可见的。|'
- en: '| `memory_order_release` | A store operation with this memory order performs
    the release operation; no reads or writes in the current thread can be reordered
    after this store. All writes in the current thread are visible in other threads
    that acquire the same atomic variable, and writes that carry a dependency to the
    atomic variable become visible in other threads that consume the same atomic variable.
    |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| `memory_order_release` | 使用此内存顺序的存储操作执行释放操作；当前线程中的任何读取或写入操作都不能在此存储之后重排。当前线程中的所有写入在其他线程中获取相同原子变量的线程中都是可见的，并且对原子变量的依赖写入在其他线程中消耗相同原子变量的线程中变为可见。|'
- en: '| `memory_order_acq_rel` | A read-modify-write operation with this memory order
    is both an acquire operation and a release operation. No memory reads or writes
    in the current thread can be reordered before or after this store. All writes
    in other threads that release the same atomic variable are visible before the
    modification, and the modification is visible in other threads that acquire the
    same atomic variable. |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| `memory_order_acq_rel` | 使用此内存顺序的读取-修改-写入操作既是获取操作也是释放操作。当前线程中的任何内存读取或写入都不能在此存储之前或之后重排。在其他线程中释放相同原子变量的所有写入在修改之前都是可见的，并且修改在其他线程中获取相同原子变量的线程中可见。|'
- en: '| `memory_order_seq_cst` | Any operation with this memory order is both an
    acquire operation and a release operation; a single total order exists in which
    all threads observe all modifications in the same order. |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| `memory_order_seq_cst` | 任何具有此内存顺序的操作既是获取操作也是释放操作；存在一个单一的全序，其中所有线程以相同的顺序观察到所有修改。|'
- en: 'Table 8.1: std::memory_order members that describe how memory access is ordered
    for an atomic operation'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.1：描述原子操作内存访问顺序的 std::memory_order 成员
- en: 'The first example in the *How to do it...* section shows several threads repeatedly
    modifying a shared resource – a counter – by incrementing it concurrently. This
    example can be refined further by implementing a class to represent an atomic
    counter with methods such as `increment()` and `decrement()`, which modify the
    value of the counter, and `get()`, which retrieves its current value:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *如何做...* 部分的第一个示例展示了几个线程反复通过并发增加来修改一个共享资源——一个计数器。这个示例可以通过实现一个具有如 `increment()`
    和 `decrement()` 方法来表示原子计数器的类进一步优化，这些方法用于修改计数器的值，以及 `get()` 方法，用于检索其当前值：
- en: '[PRE68]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'With this class template, the first example can be rewritten in the following
    form with the same result:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个类模板，第一个示例可以按照以下形式重写，结果相同：
- en: '[PRE69]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: If you need to perform atomic operations on references, you cannot use `std::atomic`.
    However, in C++20, you can use the new `std::atomic_ref` type. This is a class
    template that applies atomic operations to the object it references. This object
    must outlive the `std::atomic_ref` object and, as long as any `std::atomic_ref`
    instance referencing this object exists, the object must be accessed only through
    the `std::atomic_ref` instances.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要在引用上执行原子操作，不能使用 `std::atomic`。然而，在 C++20 中，可以使用新的 `std::atomic_ref` 类型。这是一个类模板，它将原子操作应用于它引用的对象。此对象必须比
    `std::atomic_ref` 对象存在时间更长，并且只要存在任何引用此对象的 `std::atomic_ref` 实例，此对象就只能通过 `std::atomic_ref`
    实例访问。
- en: 'The `std::atomic_ref` type has the following specializations:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::atomic_ref` 类型有以下特化：'
- en: The primary template can be instantiated with any trivially copyable type `T`,
    including `bool`.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要模板可以用任何可以简单复制的类型`T`实例化，包括`bool`。
- en: Partial specialization for all pointer types.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有指针类型的部分特化。
- en: Specializations for integral types (character types, signed and unsigned integer
    types, and any additional integral types needed by the typedefs in the `<cstdint>`
    header).
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数类型（字符类型、有符号和无符号整数类型，以及`<cstdint>`头文件中typedef所需的所有其他整数类型）的特化。
- en: Specializations for the floating-point types `float`, `double`, and `long double`.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点类型`float`、`double`和`long double`的特化。
- en: 'When using `std::atomic_ref`, you must keep in mind that:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`std::atomic_ref`时，你必须记住：
- en: It is not thread-safe to access any sub-object of the object referenced by a
    `std::atomic_ref`.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`std::atomic_ref`引用的对象的任何子对象访问都不是线程安全的。
- en: It is possible to modify the referenced value through a const `std::atomic_ref`
    object.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过一个const `std::atomic_ref`对象来修改引用的值。
- en: 'Also, in C++20, there are new member and non-member functions that provide
    an efficient thread-synchronization mechanism:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在C++20中，有一些新的成员函数和非成员函数提供了高效的线程同步机制：
- en: The member function `wait()` and non-member functions `atomic_wait()`/`atomic_wait_explicit()`
    and `atomic_flag_wait()`/`atomic_flag_wait_explicit()` perform atomic wait operations,
    blocking a thread until notified and the atomic value changes. Its behavior is
    similar to repeatedly comparing the provided argument with the value returned
    by `load()` and, if equal, blocks until notified by `notify_one()` or `notify_all()`,
    or the thread is unblocked spuriously. If the compared values are not equal, then
    the function returns without blocking.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员函数`wait()`以及非成员函数`atomic_wait()`/`atomic_wait_explicit()`和`atomic_flag_wait()`/`atomic_flag_wait_explicit()`执行原子等待操作，阻塞线程直到被通知并且原子值发生变化。其行为类似于反复比较提供的参数与`load()`返回的值，如果相等，则阻塞直到由`notify_one()`或`notify_all()`通知，或者线程被意外解除阻塞。如果比较的值不相等，则函数返回而不阻塞。
- en: The member function `notify_one()` and non-member functions `atomic_notify_one()`
    and `atomic_flag_notify_one()` notify, atomically, at least one thread blocked
    in an atomic waiting operation. If there is no such thread blocked, the function
    does nothing.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员函数`notify_one()`以及非成员函数`atomic_notify_one()`和`atomic_flag_notify_one()`原子性地通知，至少有一个线程在原子等待操作中被阻塞。如果没有这样的线程被阻塞，该函数不执行任何操作。
- en: The member function `notify_all()` and the non-member functions `atomic_notify_all()`
    and `atomic_flag_notify_all()` unblock all the threads blocked in an atomic waiting
    operation or do nothing if no such thread exists.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员函数`notify_all()`以及非成员函数`atomic_notify_all()`和`atomic_flag_notify_all()`解除所有在原子等待操作中被阻塞的线程的阻塞，或者如果没有这样的线程，则不执行任何操作。
- en: Finally, it should be mentioned that all the atomic objects from the standard
    atomic operations library – `std::atomic`, `std::atomic_ref`, and `std::atomic_flag`
    – are free of data races.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，应该提到的是，所有来自标准原子操作库的原子对象——`std::atomic`、`std::atomic_ref`和`std::atomic_flag`——都是无数据竞争的。
- en: See also
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Working with threads*, to learn about the `std::thread` class and the basic
    operations for working with threads in C++'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与线程协同工作*，了解`std::thread`类以及如何在C++中处理线程的基本操作'
- en: '*Synchronizing access to shared data with mutexes and locks*, to see what mechanisms
    are available for synchronizing thread access to shared data and how they work'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用互斥锁和锁同步对共享数据的访问*，以了解同步线程对共享数据访问的可用机制及其工作原理'
- en: '*Executing functions asynchronously*, to learn how to use the `std::future`
    class and the `std::async()` function to execute functions asynchronously on different
    threads and communicate the result back'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*异步执行函数*，了解如何使用`std::future`类和`std::async()`函数在不同的线程上异步执行函数并将结果返回'
- en: Implementing parallel map and fold with threads
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线程实现并行映射和折叠
- en: 'In *Chapter 3*, *Exploring Functions*, we discussed two higher-order functions:
    `map`, which applies a function to the elements of a range by either transforming
    the range or producing a new range, and `fold` (also referred to as `reduce`),
    which combines the elements of a range into a single value. The various implementations
    we did were sequential. However, in the context of concurrency, threads, and asynchronous
    tasks, we can leverage the hardware and run parallel versions of these functions
    to speed up their execution for large ranges, or when the transformation and aggregation
    are time-consuming. In this recipe, we will see a possible solution for implementing
    `map` and `fold` using threads.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第3章*，*探索函数*中，我们讨论了两个高阶函数：`map`，它通过转换范围或产生一个新的范围来将函数应用于范围中的元素，以及`fold`（也称为`reduce`），它将范围中的元素组合成一个单一值。我们所做的各种实现都是顺序的。然而，在并发、线程和异步任务的环境中，我们可以利用硬件来运行这些函数的并行版本，以加快大范围或转换和聚合耗时时的执行速度。在本配方中，我们将看到实现`map`和`fold`使用线程的可能解决方案。
- en: Getting ready
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to be familiar with the concepts of the `map` and `fold` functions.
    It is recommended that you read the *Implementing higher-order functions map and
    fold* recipe from *Chapter 3*, *Exploring Functions*. In this recipe, we will
    use the various thread functionalities presented in the *Working with threads*
    recipe.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要熟悉`map`和`fold`函数的概念。建议您阅读*第3章*，*探索函数*中的*实现高阶函数map和fold*配方。在本配方中，我们将使用*与线程一起工作*配方中展示的各种线程功能。
- en: To measure the execution time of these functions and compare it with sequential
    alternatives, we will use the `perf_timer` class template, which we introduced
    in the *Measuring function execution time with a standard clock* recipe in *Chapter
    6*, *General-Purpose Utilities*.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测量这些函数的执行时间并将其与顺序替代方案进行比较，我们将使用我们在*第6章*，*通用工具*中的*使用标准时钟测量函数执行时间*配方中引入的`perf_timer`类模板。
- en: A parallel version of an algorithm can potentially speed up execution time,
    but this is not necessarily true in all circumstances. Context switching for threads
    and synchronized access to shared data can introduce a significant overhead. For
    some implementations and particular datasets, this overhead could make a parallel
    version actually take a longer time to execute than a sequential version.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的并行版本可能会加快执行时间，但这并不一定在所有情况下都成立。线程的上下文切换和对共享数据的同步访问可能会引入显著的开销。对于某些实现和特定数据集，这种开销可能会使并行版本的实际执行时间比顺序版本更长。
- en: 'To determine the number of threads required to split the work, we will use
    the following function:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定需要拆分工作所需的线程数，我们将使用以下函数：
- en: '[PRE70]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We’ll explore the first possible implementation for a parallel version of the
    `map` and `fold` functions in the next section.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨`map`和`fold`函数并行版本的第一种可能实现。
- en: How to do it...
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To implement a parallel version of the `map` function, do the following:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现`map`函数的并行版本，请执行以下操作：
- en: 'Define a function template that takes the `begin` and `end` iterators of a
    range and a function to apply to all the elements:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数模板，它接受范围的`begin`和`end`迭代器以及应用于所有元素的功能：
- en: '[PRE71]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Check the size of the range. If the number of elements is smaller than a predefined
    threshold (for this implementation, the threshold is 10,000), execute the mapping
    in a sequential manner:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查范围的大小。如果元素数量小于预定义的阈值（对于此实现，阈值为10,000），则以顺序方式执行映射：
- en: '[PRE72]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'For larger ranges, split the work on multiple threads and let each thread map
    be a part of the range. These parts should not overlap to avoid the need to synchronize
    access to the shared data:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于较大的范围，可以将工作分配到多个线程，并让每个线程映射范围的一部分。这些部分不应重叠，以避免同步访问共享数据的需求：
- en: '[PRE73]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Start the threads, and on each thread, run a sequential version of the mapping:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动线程，并在每个线程上运行映射的顺序版本：
- en: '[PRE74]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Wait until all the threads have finished their execution:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待所有线程完成执行：
- en: '[PRE75]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The preceding steps, when put together, result in the following implementation:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的步骤组合起来，得到以下实现：
- en: '[PRE76]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'To implement a parallel version of the left `fold` function, do the following:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现左`fold`函数的并行版本，请执行以下操作：
- en: 'Define a function template that takes a `begin` and an `end` iterator for a
    range, an initial value, and a binary function to apply to the elements of the
    range:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数模板，它接受一个范围的`begin`和`end`迭代器、一个初始值以及应用于范围元素的二进制函数：
- en: '[PRE77]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Check the size of the range. If the number of elements is smaller than a predefined
    threshold (for this implementation, it is 10,000), execute the folding in a sequential
    manner:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查范围的大小。如果元素数量小于预定义的阈值（对于此实现，为10,000），则以顺序方式执行折叠：
- en: '[PRE78]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'For larger ranges, split the work into multiple threads and let each thread
    fold a part of the range. These parts should not overlap in order to avoid thread
    synchronization of shared data. The result can be returned through a reference
    passed to the thread function in order to avoid data synchronization:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于较大的范围，将工作拆分为多个线程，并让每个线程处理范围的一部分。这些部分不应重叠，以避免共享数据的线程同步。结果可以通过传递给线程函数的引用返回，以避免数据同步：
- en: '[PRE79]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Start the threads, and on each thread, execute a sequential version of the
    folding:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动线程，并在每个线程上执行顺序版本的折叠：
- en: '[PRE80]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Wait until all the threads have finished execution and fold the partial results
    into the final result:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待所有线程执行完毕并将部分结果合并到最终结果中：
- en: '[PRE81]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The steps we just put together result in the following implementation:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才组合的步骤导致以下实现：
- en: '[PRE82]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: How it works...
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'These parallel implementations of `map` and `fold` are similar in several aspects:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`和`fold`的这些并行实现有几个方面是相似的：'
- en: They both fall back to a sequential version if the number of elements in the
    range is smaller than 10,000.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果范围中的元素数量小于10,000，它们都会回退到顺序版本。
- en: They both start the same number of threads. These threads are determined using
    the static function `std::thread::hardware_concurrency()`, which returns the number
    of concurrent threads supported by the implementation. However, this value is
    more of a hint than an accurate value and should be used with that in mind.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们都启动相同数量的线程。这些线程是通过使用静态函数`std::thread::hardware_concurrency()`确定的，该函数返回实现支持的并发线程数。然而，这个值更多的是一个提示，而不是一个准确值，应该考虑到这一点。
- en: No shared data is used to avoid synchronization of access. Even though all the
    threads work on the elements from the same range, they all process parts of the
    range that do not overlap.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有使用共享数据以避免访问同步。尽管所有线程都在处理同一范围的元素，但它们都处理不重叠的范围部分。
- en: Both of these functions are implemented as function templates that take a begin
    and an end iterator to define the range to be processed. In order to split the
    range into multiple parts to be processed independently by different threads,
    use additional iterators in the middle of the range. For this, we use `std::advance()`
    to increment an iterator with a particular number of positions. This works well
    for vectors or arrays but is very inefficient for containers such as lists. Therefore,
    this implementation is suited only for ranges that have random access iterators.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这两个函数都实现为函数模板，它们接受一个开始迭代器和结束迭代器来定义要处理的范围。为了将范围拆分为多个部分，由不同的线程独立处理，请在范围中间使用额外的迭代器。为此，我们使用`std::advance()`来增加迭代器的特定位置数。这对于向量或数组来说效果很好，但对于列表等容器来说效率非常低。因此，此实现仅适用于具有随机访问迭代器的范围。
- en: The sequential versions of `map` and `fold` can be simply implemented in C++
    with `std::transform()` and `std::accumulate()`. In fact, to verify the correctness
    of the parallel algorithms and check whether they provide any execution speedup,
    we can compare them with the execution of these general-purpose algorithms.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`和`fold`的顺序版本可以用`std::transform()`和`std::accumulate()`简单地实现。实际上，为了验证并行算法的正确性并检查它们是否提供了任何执行速度提升，我们可以将它们与这些通用算法的执行进行比较。'
- en: 'To put this to the test, we will use `map` and `fold` on a vector with sizes
    varying from 10,000 to 50 million elements. The range is first mapped (that is,
    transformed) by doubling the value of each element, and then the result is folded
    into a single value by adding together all the elements of the range. For simplicity,
    each element in the range is equal to its 1-based index (the first element is
    1, the second element is 2, and so on). The following sample runs both the sequential
    and parallel versions of `map` and `fold` on vectors of different sizes and prints
    the execution time in a tabular format:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行测试，我们将使用`map`和`fold`在一个大小从10,000到5,000万元素的向量上。首先将范围映射（即转换），即每个元素的值翻倍，然后将结果折叠成一个单一值，通过将范围的所有元素相加。为了简单起见，范围中的每个元素都等于其基于1的索引（第一个元素是1，第二个元素是2，依此类推）。以下示例在大小不同的向量上运行了`map`和`fold`的顺序和并行版本，并以表格格式打印了执行时间：
- en: As an exercise, you can vary the number of elements, as well as the number of
    threads, and see how the parallel version performs compared to the sequential
    version.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，你可以改变元素的数量以及线程的数量，并观察并行版本与顺序版本的性能对比。
- en: '[PRE83]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'A possible output of this program is shown in the following chart (executed
    on a machine running Windows 64-bit with an Intel Core i7 processor and 4 physical
    and 8 logical cores). The parallel version, especially the `fold` implementation,
    performs better than the sequential version. But this is true only when the length
    of the vector exceeds a certain size. In the following table, we can see that
    for up to 1 million elements, the sequential version is still faster. The parallel
    version executes faster when there are 2 million or more elements in the vector.
    Notice that the actual times vary slightly from one run to another, even on the
    same machine, and they can be very different on different machines:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的可能的输出如下图表所示（在运行Windows 64位操作系统、Intel Core i7处理器和4个物理核心、8个逻辑核心的机器上执行）。特别是`fold`实现，并行版本的性能优于顺序版本。但这仅在向量的长度超过一定大小时才成立。在下面的表中，我们可以看到，对于最多一百万个元素，顺序版本仍然更快。当向量中有两百万个或更多元素时，并行版本执行得更快。请注意，实际时间可能会因运行而异，即使在同一台机器上，它们也可能在不同机器上非常不同：
- en: '[PRE84]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'To better visualize these results, we can represent the speedup of the parallel
    version in the form of a bar chart. In the following chart, the blue bars represent
    the speedup of a parallel `map` implementation, while the orange bars show the
    speedup of the parallel `fold` implementation. A positive value indicates that
    the parallel version is faster; a negative version indicates that the sequential
    version is faster:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地可视化这些结果，我们可以将并行版本的加速以柱状图的形式表示。在下面的图表中，蓝色柱状图表示并行`map`实现的加速，而橙色柱状图显示并行`fold`实现的加速。正值表示并行版本更快；负值表示顺序版本更快：
- en: '![](img/B21549_08_01.png)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21549_08_01.png)'
- en: 'Figure 8.1: The speedup of the parallel implementation for map (in blue) and
    fold (in orange) for various processed elements'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：对于各种处理元素，map（蓝色）和fold（橙色）并行实现的加速
- en: This chart makes it easier to see that only when the number of elements exceeds
    a certain threshold (which is about 2 million in my benchmarks) is the parallel
    implementation faster than the sequential version.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表使得更容易看出，只有当元素数量超过某个特定阈值（在我的基准测试中约为两百万）时，并行实现才比顺序版本更快。
- en: See also
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Chapter 3*, *Implementing higher-order functions map and fold*, to learn about
    higher-order functions in functional programming and see how to implement the
    widely used `map` and `fold` (or reduce) functions'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第3章*，*实现高阶函数map和fold*，了解函数式编程中的高阶函数，并了解如何实现广泛使用的`map`和`fold`（或reduce）函数'
- en: '*Implementing parallel map and fold with tasks*, to see how to implement the
    `map` and `fold` functions from functional programming using asynchronous functions'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用任务实现并行map和fold*，了解如何使用异步函数实现函数式编程中的`map`和`fold`函数'
- en: '*Implementing parallel map and fold with standard parallel algorithms*, to
    see how to implement the `map` and `fold` functions from functional programming
    using parallel algorithms from C++17'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用标准并行算法实现并行map和fold*，了解如何使用C++17中的并行算法实现函数式编程中的`map`和`fold`函数'
- en: '*Working with threads*, to learn about the `std::thread` class and the basic
    operations for working with threads in C++'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用线程*，了解`std::thread`类以及C++中处理线程的基本操作'
- en: Implementing parallel map and fold with tasks
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用任务实现并行map和fold
- en: Tasks are a higher-level alternative to threads for performing concurrent computations.
    `std::async()` enables us to execute functions asynchronously, without the need
    to handle lower-level threading details. In this recipe, we will take the same
    task of implementing a parallel version of the `map` and `fold` functions, as
    in the previous recipe, but we will use tasks and see how it compares with the
    thread version.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 任务是执行并发计算的高级替代方案。`std::async()`使我们能够异步执行函数，无需处理低级线程细节。在本食谱中，我们将执行与之前食谱中相同的任务，即实现`map`和`fold`函数的并行版本，但我们将使用任务，并观察它与线程版本的比较。
- en: Getting ready
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The solution presented in this recipe is similar in many aspects to the one
    that uses threads in the previous recipe, *Implementing parallel map and fold
    with threads*. Make sure you read that one before continuing with the current
    recipe.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱中提出的解决方案在许多方面与之前菜谱中使用的线程的解决方案相似，即 *使用线程实现并行 map 和 fold*。在继续当前菜谱之前，请确保阅读那个菜谱。
- en: How to do it...
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To implement a parallel version of the `map` function, do the following:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现 `map` 函数的并行版本，请按照以下步骤操作：
- en: 'Define a function template that takes a begin and end iterator for a range
    and a function to apply to all the elements:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数模板，它接受一个范围的起始和结束迭代器以及应用于所有元素的功能：
- en: '[PRE85]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Check the size of the range. For a number of elements smaller than the predefined
    threshold (for this implementation, the threshold is 10,000), execute the mapping
    in a sequential manner:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查范围的大小。对于元素数量小于预定义阈值（对于此实现，阈值为10,000）的情况，以顺序方式执行映射：
- en: '[PRE86]'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'For larger ranges, split the work into multiple tasks and let each task map
    a part of the range. These parts should not overlap to avoid synchronizing thread
    access to shared data:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于较大的范围，将工作分成多个任务，并让每个任务映射范围的一部分。这些部分不应重叠，以避免同步对共享数据的线程访问：
- en: '[PRE87]'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Start the asynchronous functions and run a sequential version of the mapping
    on each of them:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动异步函数，并对每个函数执行顺序版本的映射：
- en: '[PRE88]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Wait until all the asynchronous functions have finished their execution:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待所有异步函数执行完成：
- en: '[PRE89]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'These steps, when put together, result in the following implementation:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些步骤组合起来，可以得到以下实现：
- en: '[PRE90]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'To implement a parallel version of the left `fold` function, do the following:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现左 `fold` 函数的并行版本，请按照以下步骤操作：
- en: 'Define a function template that takes a begin and end iterator for a range,
    an initial value, and a binary function to apply to the elements of the range:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数模板，它接受一个范围的起始和结束迭代器、一个初始值以及一个应用于范围元素的二元函数：
- en: '[PRE91]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Check the size of the range. For a number of elements smaller than the predefined
    threshold (for this implementation, the threshold is 10,000), execute the folding
    in a sequential manner:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查范围的大小。对于元素数量小于预定义阈值（对于此实现，阈值为10,000）的情况，以顺序方式执行折叠：
- en: '[PRE92]'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'For larger ranges, split the work into multiple tasks and let each task fold
    a part of the range. These parts should not overlap to avoid synchronizing thread
    access to the shared data. The result can be returned through a reference passed
    to the asynchronous function to avoid synchronization:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于较大的范围，将工作分成多个任务，并让每个任务折叠范围的一部分。这些部分不应重叠，以避免同步对共享数据的线程访问。结果可以通过传递给异步函数的引用返回，以避免同步：
- en: '[PRE93]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Start the asynchronous functions and execute a sequential version of folding
    on each one of them:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动异步函数，并对每个函数执行顺序版本的折叠：
- en: '[PRE94]'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Wait until all the asynchronous functions have finished execution and fold
    the partial results into the final result:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待所有异步函数执行完成，并将部分结果折叠成最终结果：
- en: '[PRE95]'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'These steps, when put together, result in the following implementation:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些步骤组合起来，可以得到以下实现：
- en: '[PRE96]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: How it works...
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The implementation just proposed is only slightly different than what we did
    in the previous recipe. Threads were replaced with asynchronous functions, starting
    with `std::async()`, and results were made available through the returned `std::future`.
    The number of asynchronous functions that are launched concurrently is equal to
    the number of threads the implementation can support. This is returned by the
    static method `std::thread::hardware_concurrency()`, but this value is only a
    hint and should not be considered very reliable.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 提出的实现仅略不同于之前的菜谱。线程被替换为异步函数，从 `std::async()` 开始，并通过返回的 `std::future` 提供结果。并发启动的异步函数数量等于实现可以支持的线程数量。这个值由静态方法
    `std::thread::hardware_concurrency()` 返回，但这个值只是一个提示，不应被视为非常可靠。
- en: 'There are mainly two reasons for taking this approach:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法的两个主要原因：
- en: Seeing how a function implemented for parallel execution with threads can be
    modified to use asynchronous functions and, therefore, avoid lower-level details
    of threading.
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看一个为线程并行执行而实现的函数如何修改以使用异步函数，从而避免线程的底层细节。
- en: Running a number of asynchronous functions equal to the number of supported
    threads can potentially run one function per thread; this could provide the fastest
    execution time for the parallel function because there is a minimum overhead of
    context switching and waiting time.
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行与支持的线程数量相等的异步函数可能每个线程运行一个函数；这可能会为并行函数提供最快的执行时间，因为上下文切换和等待时间的开销最小。
- en: 'We can test the performance of the new `map` and `fold` implementations using
    the same method as in the previous recipe:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用与之前配方相同的方法测试新的`map`和`fold`实现的性能：
- en: '[PRE97]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'A possible output of the preceding program, which can vary slightly from one
    execution to another and greatly from one machine to another, is as follows:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个程序的可能输出，可能因执行而略有不同，因机器而大不相同，如下所示：
- en: '[PRE98]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Similar to the illustration of the solution with threads, the speedup of the
    parallel `map` and `fold` implementations can be seen in the following chart.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 与线程解决方案的说明类似，以下图表显示了并行`map`和`fold`实现的加速。
- en: 'Negative values indicate that the sequential version was faster:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 负值表示顺序版本更快：
- en: '![](img/B21549_08_02.png)'
  id: totrans-488
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21549_08_02.png)'
- en: 'Figure 8.2: The speedup of the parallel implementation of map (in blue) and
    fold (in orange) using asynchronous functions, compared to the sequential implementation'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：使用异步函数的并行实现（在蓝色中）和折叠（在橙色中）相对于顺序实现的加速
- en: 'If we compare this with the results from the parallel version using threads,
    we will find that these are faster execution times and that the speedup is significant,
    especially for the `fold` function. The following chart shows the speedup of the
    task’s implementation over the thread’s implementation. In this chart, a value
    smaller than 1 means that the thread’s implementation was faster:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将此与使用线程的并行版本的结果进行比较，我们会发现这些执行时间更快，并且速度提升显著，尤其是在`fold`函数上。以下图表显示了任务实现相对于线程实现的加速：
- en: '![](img/B21549_08_03.png)'
  id: totrans-491
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21549_08_03.png)'
- en: 'Figure 8.3: The speedup of the parallel implementation using asynchronous functions
    over the parallel implementation using threads for map (in blue) and fold (in
    orange)'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：使用异步函数的并行实现相对于使用线程的并行实现（在蓝色中）和折叠（在橙色中）的速度提升
- en: There’s more...
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The implementation shown earlier is only one of the possible approaches we
    can take for parallelizing the `map` and `fold` functions. A possible alternative
    uses the following strategy:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 之前显示的实现只是我们可以采取的并行化`map`和`fold`函数的可能方法之一。一个可能的替代方案使用以下策略：
- en: Divide the range to process into two equal parts.
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将要处理的范围分成两个相等的部分。
- en: Recursively call the parallel function asynchronously to process the first part
    of the range.
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归异步调用并行函数以处理范围的第一个部分。
- en: Recursively call the parallel function synchronously to process the second part
    of the range.
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归同步调用并行函数以处理范围的第二部分。
- en: After the synchronous recursive call is finished, wait for the asynchronous
    recursive call to end too before finishing the execution.
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在完成同步递归调用后，等待异步递归调用结束再完成执行。
- en: This divide-and-conquer algorithm can potentially create a lot of tasks. Depending
    on the size of the range, the number of asynchronous calls can greatly exceed
    the number of threads, and in this case, there will be lots of waiting time that
    will affect the overall execution time.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分而治之算法可能会创建很多任务。根据范围的大小，异步调用的数量可能会远远超过线程的数量，在这种情况下，会有很多等待时间，这会影响整体执行时间。
- en: 'The `map` and `fold` functions can be implemented using a divide-and-conquer
    algorithm, as follows:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`和`fold`函数可以使用以下分而治之算法实现：'
- en: '[PRE99]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The execution times for this implementation are listed here, next to the ones
    for the previous implementations:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现的执行时间列于此处，与之前实现的执行时间并列：
- en: '[PRE100]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: When we compare these execution times, we can see that this version (indicated
    by `p2` in the preceding output) is similar to the sequential version for both
    `map` and `fold` and much worse than the first parallel version shown earlier
    (indicated by `p1`).
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们比较这些执行时间时，我们可以看到这个版本（在前面的输出中由`p2`表示）对于`map`和`fold`都与顺序版本相似，并且比之前显示的第一个并行版本（由`p1`表示）要差得多。
- en: See also
  id: totrans-505
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Implementing parallel map and fold with threads*, to see how to implement
    the `map` and `fold` functions from functional programming using raw threads'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用线程实现并行map和fold*，查看如何使用原始线程实现函数式编程中的`map`和`fold`函数'
- en: '*Implementing parallel map and fold with standard parallel algorithms*, to
    see how to implement the `map` and `fold` functions from functional programming
    using parallel algorithms from C++17'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用标准并行算法实现并行map和fold*，了解如何使用C++17的并行算法实现函数式编程中的`map`和`fold`函数'
- en: '*Executing functions asynchronously*, to learn how to use the `std::future`
    class and the `std::async()` function to execute functions asynchronously on different
    threads and communicate the result back'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*异步执行函数*，了解如何使用`std::future`类和`std::async()`函数在不同的线程上异步执行函数并将结果返回'
- en: Implementing parallel map and fold with standard parallel algorithms
  id: totrans-509
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标准并行算法实现并行map和fold
- en: In the previous two recipes, we implemented parallel versions of the `map` and
    `fold` functions (which are called `std::transform()` and `std::accumulate()`
    in the standard library) using threads and tasks. However, these implementations
    required manual handling of parallelization details, such as splitting data into
    chunks to be processed in parallel and creating threads or tasks, synchronizing
    their execution, and merging the results.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个食谱中，我们使用线程和任务实现了`map`和`fold`函数的并行版本（在标准库中分别称为`std::transform()`和`std::accumulate()`）。然而，这些实现需要手动处理并行化细节，例如将数据分割成并行处理的数据块，创建线程或任务，同步它们的执行，以及合并结果。
- en: In C++17, many of the standard generic algorithms have been parallelized. In
    fact, the same algorithm can execute sequentially or in parallel, depending on
    a provided execution policy. In this recipe, we will learn how to implement `map`
    and `fold` in parallel with standard algorithms.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17中，许多标准泛型算法已被并行化。实际上，同一个算法可以按顺序或并行执行，这取决于提供的执行策略。在本食谱中，我们将学习如何使用标准算法并行实现`map`和`fold`。
- en: Getting ready
  id: totrans-512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before you continue with this recipe, it is recommended that you read the previous
    two to make sure you understand the differences between various parallel implementations.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续此食谱之前，建议你阅读前两个，以确保你理解了各种并行实现之间的差异。
- en: How to do it...
  id: totrans-514
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To use the standard algorithms with parallel execution, you should do the following:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用具有并行执行的标准化算法，你应该做以下事情：
- en: Find a good candidate for an algorithm to parallelize. Not every algorithm runs
    faster in parallel. Make sure you correctly identify the parts of the program
    that can be improved with parallelization. Use profilers for this purpose and,
    in general, look at operations that have *O(n)* or worse complexity.
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找一个适合并行化的算法。并非每个算法在并行时都会运行得更快。确保你正确地识别了程序中可以通过并行化改进的部分。为此使用分析器，并且通常查看具有*O(n)*或更差复杂性的操作。
- en: Include the header `<execution>` for the execution policies.
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含头文件`<execution>`以使用执行策略。
- en: Provide the parallel execution policy (`std::execution::par`) as the first argument
    to the overloaded algorithm.
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将并行执行策略（`std::execution::par`）作为重载算法的第一个参数。
- en: 'A parallel implementation of the map function using the parallel overload of
    `std::transform()` is as follows:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`std::transform()`的并行重载实现的map函数的并行实现如下：
- en: '[PRE101]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'A parallel implementation of the fold function using the parallel overload
    of `std::reduce()` is as follows:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`std::reduce()`的并行重载实现的fold函数的并行实现如下：
- en: '[PRE102]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: How it works...
  id: totrans-523
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In C++17, 69 of the standard generic algorithms have been overloaded to support
    parallel execution. These overloads take an execution policy as the first parameter.
    The available execution policies, from header `<execution>`, are as follows:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17中，69个标准泛型算法被重载以支持并行执行。这些重载将执行策略作为第一个参数。从头文件`<execution>`中可用的执行策略如下：
- en: '| **Policy** | **Since** | **Description** | **Global object** |'
  id: totrans-525
  prefs: []
  type: TYPE_TB
  zh: '| **策略** | **自** | **描述** | **全局对象** |'
- en: '| `std::execution::sequenced_policy` | C++17 | Indicates that the algorithm
    may not execute in parallel. | `std::execution::seq` |'
  id: totrans-526
  prefs: []
  type: TYPE_TB
  zh: '| `std::execution::sequenced_policy` | C++17 | 表示算法可能不会并行执行。 | `std::execution::seq`
    |'
- en: '| `std::execution::parallel_policy` | C++17 | Indicates that the algorithm’s
    execution may be parallelized. | `std::execution::par` |'
  id: totrans-527
  prefs: []
  type: TYPE_TB
  zh: '| `std::execution::parallel_policy` | C++17 | 表示算法的执行可能被并行化。 | `std::execution::par`
    |'
- en: '| `std::execution::parallel_unsequenced_policy` | C++17 | Indicates that the
    algorithm’s execution may be parallelized and vectorized. | `std::execution::par_unseq`
    |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
  zh: '| `std::execution::parallel_unsequenced_policy` | C++17 | 表示算法的执行可能被并行化和向量化。|
    `std::execution::par_unseq` |'
- en: '| `std::execution::unsequenced_policy` | C++20 | Indicates that the algorithm’s
    execution may be vectorized. | `std::execution::unseq` |'
  id: totrans-529
  prefs: []
  type: TYPE_TB
  zh: '| `std::execution::unsequenced_policy` | C++20 | 表示算法的执行可能被向量化。| `std::execution::unseq`
    |'
- en: 'Table 8.2: Execution policies from the <execution> header'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.2：来自 `<execution>` 头文件的执行策略
- en: Vectorization is the process of transforming an algorithm so that instead of
    working on a single value at a time it would work on a set of values (vector)
    at the same time. Modern processors provide this at a hardware level through **SIMD**
    (**Single Instruction, Multiple Data**) units.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 向量化是将算法转换为一次处理一组值（向量）而不是一次处理单个值的过程。现代处理器通过**SIMD**（**单指令，多数据**）单元在硬件级别提供这种功能。
- en: 'Apart from the existing algorithms that have been overloaded, seven new algorithms
    have been added:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 除了现有的已重载的算法外，还增加了七个新算法：
- en: '| **Algorithm** | **Description** |'
  id: totrans-533
  prefs: []
  type: TYPE_TB
  zh: '| **算法** | **描述** |'
- en: '| `std::for_each_n` | Applies a given function to the first *N* elements of
    the specified range, according to the specified execution policy. |'
  id: totrans-534
  prefs: []
  type: TYPE_TB
  zh: '| `std::for_each_n` | 根据指定的执行策略，将给定的函数应用于指定范围的前*N*个元素。|'
- en: '| `std::exclusive_scan` | Computes the partial sum of a range of elements (using
    either `std::plus<>` or a binary operation) but excludes the *i*th element from
    the *i*th sum. If the binary operation is associative, the result is the same
    as when using `std::partial_sum()`. |'
  id: totrans-535
  prefs: []
  type: TYPE_TB
  zh: '| `std::exclusive_scan` | 计算元素范围的局部和（使用`std::plus<>`或二元操作），但排除第*i*个元素的第*i*个和。如果二元操作是结合的，则结果与使用`std::partial_sum()`相同。|'
- en: '| `std::inclusive_scan` | Computes the partial sum of a range of elements (using
    either `std::plus<>` or a binary operation) but includes the *i*th element in
    the *i*th sum. |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
  zh: '| `std::inclusive_scan` | 计算元素范围的局部和（使用`std::plus<>`或二元操作），但包括第*i*个元素在第*i*个和中。|'
- en: '| `std::transform_exclusive_scan` | Applies a unary function to each element
    of a range and then calculates an exclusive scan on the resulting range. |'
  id: totrans-537
  prefs: []
  type: TYPE_TB
  zh: '| `std::transform_exclusive_scan` | 将一元函数应用于范围的每个元素，然后计算结果范围的排除扫描。|'
- en: '| `std::transform_inclusive_scan` | Applies a unary function to each element
    of a range and then calculates an inclusive scan on the resulting range. |'
  id: totrans-538
  prefs: []
  type: TYPE_TB
  zh: '| `std::transform_inclusive_scan` | 将一元函数应用于范围中的每个元素，然后计算结果范围的包含扫描。|'
- en: '| `std::reduce` | An out-of-order version of `std::accumulate()`. |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
  zh: '| `std::reduce` | `std::accumulate()`的无序版本。|'
- en: '| `std::transform_reduce` | Applies a function to the elements of a range then
    accumulates the elements of the resulting range out of order (that is, reduces).
    |'
  id: totrans-540
  prefs: []
  type: TYPE_TB
  zh: '| `std::transform_reduce` | 将函数应用于范围的元素，然后无序地累积结果范围的元素（即减少）。|'
- en: 'Table 8.2: New algorithms in C++17 from the <algorithm> and <numeric> headers'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.2：来自 `<algorithm>` 和 `<numeric>` 头文件的新算法
- en: In the preceding examples, we used `std::transform()` and `std::reduce()` with
    an execution policy – in our case, `std::execution::par`. The algorithm `std::reduce()`
    is similar to `std::accumulate()` but it processes the elements out of order.
    `std::accumulate()` does not have an overload for specifying an execution policy,
    so it can only execute sequentially.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用`std::transform()`和`std::reduce()`与执行策略一起使用——在我们的情况下，`std::execution::par`。算法`std::reduce()`类似于`std::accumulate()`，但它以无序的方式处理元素。`std::accumulate()`没有指定执行策略的重载，因此它只能顺序执行。
- en: It is important to note that, just because an algorithm supports parallelization,
    it doesn’t mean that it will run faster than the sequential version. Execution
    depends on the actual hardware, datasets, and algorithm particularities. In fact,
    some of these algorithms may never, or hardly ever, execute faster when parallelized
    than sequentially. For this reason, for instance, the Microsoft implementation
    of several algorithms that permute, copy, or move elements does not perform parallelization
    but falls back to sequential execution in all cases. These algorithms are `copy()`,
    `copy_n()`, `fill()`, `fill_n()`, `move()`, `reverse()`, `reverse_copy()`, `rotate()`,
    `rotate_copy()`, and `swap_ranges()`. Moreover, the standard does not guarantee
    a particular execution; specifying a policy is actually a request for an execution
    strategy but with no guarantees implied.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，尽管一个算法支持并行化，但这并不意味着它的运行速度会比顺序版本更快。执行速度取决于实际硬件、数据集和算法的特定特性。实际上，这些算法在并行化时可能永远不会，或者几乎不会比顺序执行更快。因此，例如，微软对一些排列、复制或移动元素的算法的实现并没有执行并行化，而是在所有情况下都回退到顺序执行。这些算法包括
    `copy()`、`copy_n()`、`fill()`、`fill_n()`、`move()`、`reverse()`、`reverse_copy()`、`rotate()`、`rotate_copy()`
    和 `swap_ranges()`。此外，标准并不保证特定的执行；指定策略实际上是一个执行策略的请求，但没有隐含的保证。
- en: On the other hand, the standard library allows parallel algorithms to allocate
    memory. When this cannot be done, an algorithm throws `std::bad_alloc`. However,
    again, the Microsoft implementation differs and instead of throwing an exception,
    it falls back to the sequential version of the algorithm.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，标准库允许并行算法分配内存。当无法这样做时，算法会抛出 `std::bad_alloc`。然而，微软的实现有所不同，它不是抛出异常，而是回退到算法的顺序版本。
- en: Another important aspect that must be known is that the standard algorithms
    work with different kinds of iterators. Some require forward iterators, some input
    iterators. However, all the overloads that allow specifying an execution policy
    restrict the use of the algorithm with forward iterators.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个必须了解的重要方面是，标准算法与不同类型的迭代器一起工作。一些需要前向迭代器，一些需要输入迭代器。然而，所有允许指定执行策略的重载都限制了算法与前向迭代器的使用。
- en: 'Take a look at the following table:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的表格：
- en: '![](img/B21549_08_04.png)'
  id: totrans-547
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21549_08_04.png)'
- en: 'Figure 8.4: A comparison of execution times for sequential and parallel implementations
    of the map and reduce functions'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：顺序和并行实现 `map` 和 `reduce` 函数的执行时间比较
- en: Here, you can see a comparison of execution times for sequential and parallel
    implementations of the `map` and `reduce` functions. Highlighted are the versions
    of the functions implemented in this recipe. These times may vary slightly from
    execution to execution. These values were obtained by running a 64-bit released
    version compiled with Visual C++ 2019 16.4.x on a machine with an Intel Xeon CPU
    with four cores. Although the parallel versions perform better than the sequential
    version for these datasets, which one is actually better varies with the size
    of the dataset. This is why profiling is key when you optimize by parallelizing
    work.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 `map` 和 `reduce` 函数顺序和并行实现的执行时间比较。突出显示的是本食谱中实现的函数版本。这些时间可能会因执行而略有不同。这些值是通过在具有四核英特尔至强CPU的机器上使用Visual
    C++ 2019 16.4.x编译的64位发布版本获得的。尽管对于这些数据集，并行版本的性能优于顺序版本，但实际上哪个版本更好取决于数据集的大小。这就是为什么在通过并行化工作来优化时，分析至关重要。
- en: There’s more...
  id: totrans-550
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this example, we have seen separate implementations for `map` and `fold`
    (which is also called reduce). However, in C++17, there is a standard algorithm
    called `std::transform_reduce()`, which composes the two operations into a single
    function call. This algorithm has overloads for sequential execution, as well
    as policy-based execution for parallelism and vectorization. We can, therefore,
    utilize this algorithm instead of the handwritten implementation we did in these
    previous three recipes.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们看到了 `map` 和 `fold`（也称为reduce）的单独实现。然而，在C++17中，有一个名为 `std::transform_reduce()`
    的标准算法，它将这两个操作组合成一个单独的函数调用。这个算法有顺序执行的过载，以及基于策略的并行化和向量化执行。因此，我们可以利用这个算法来代替我们在前三个食谱中手动实现的实现。
- en: 'The following are the sequential and parallel versions of the algorithm used
    to compute the sum of the doubles of all the elements of a range:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用以计算范围中所有元素双倍之和的算法的顺序和并行版本：
- en: '[PRE103]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'If we compare the execution time of these two calls, seen in the following
    table in the last two columns, with the total time for separately calling `map`
    and `reduce`, as seen in the other implementations, you can see that `std::transform_reduce()`,
    especially the parallel version, executes better in most cases:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将以下表格中最后两列显示的这两个调用的执行时间与单独调用 `map` 和 `reduce` 的总时间进行比较，正如其他实现中所示，您会发现 `std::transform_reduce()`，尤其是并行版本，在大多数情况下执行得更好：
- en: '![](img/B21549_08_05.png)'
  id: totrans-555
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21549_08_05.png)'
- en: 'Figure 8.5: A comparison of execution times for the transform/reduce pattern
    with a highlight of the times for the std::transform_reduce() standard algorithm
    from C++17'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：transform/reduce 模式的执行时间比较，突出显示 C++17 中 std::transform_reduce() 标准算法的时间
- en: See also
  id: totrans-557
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Chapter 3*, *Implementing higher-order functions map and fold*, to learn about
    higher-order functions in functional programming and see how to implement the
    widely used `map` and `fold` (or reduce) functions'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第3章*，*实现高阶函数 map 和 fold*，了解函数式编程中的高阶函数，并了解如何实现广泛使用的 `map` 和 `fold`（或 reduce）函数'
- en: '*Implementing parallel map and fold with threads*, to see how to implement
    the `map` and `fold` functions from functional programming using raw threads'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用线程实现并行 map 和 fold*，了解如何使用原始线程实现函数式编程中的 `map` 和 `fold` 函数'
- en: '*Implementing parallel map and fold with tasks*, to see how to implement the
    `map` and `fold` functions from functional programming using asynchronous functions'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用任务实现并行 map 和 fold*，了解如何使用异步函数实现函数式编程中的 `map` 和 `fold` 函数'
- en: Using joinable threads and cancellation mechanisms
  id: totrans-561
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可连接线程和取消机制
- en: 'The C++11 class `std::thread` represents a single thread of execution and allows
    multiple functions to execute concurrently. However, it has a major inconvenience:
    you must explicitly invoke the `join()` method to wait for the thread to finish
    execution. This can lead to problems because if a `std::thread` object is destroyed
    while it is still joinable, then `std::terminate()` is called. C++20 provides
    an improved thread class called `std::jthread` (from *joinable thread*) that automatically
    calls `join()` if the thread is still joinable when the object is destroyed. Moreover,
    this type supports cancellation through `std::stop_source`/`std::stop_token` and
    its destructor also requests the thread to stop before joining. In this recipe,
    you will learn how to use these new C++20 types.'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 类 `std::thread` 代表一个执行线程，并允许多个函数并发执行。然而，它有一个主要的不便之处：您必须显式调用 `join()` 方法等待线程完成执行。这可能导致问题，因为如果
    `std::thread` 对象在仍然可连接时被销毁，则会调用 `std::terminate()`。C++20 提供了一个改进的线程类，称为 `std::jthread`（来自
    *joinable thread*），如果对象销毁时线程仍然可连接，则会自动调用 `join()`。此外，此类型支持通过 `std::stop_source`/`std::stop_token`
    进行取消，其析构函数也会在连接之前请求线程停止。在本菜谱中，您将学习如何使用这些新的 C++20 类型。
- en: Getting ready
  id: totrans-563
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before you continue with this, you should read the first recipe of this chapter,
    *Working with threads*, to make sure you are familiar with `std::thread`. To use
    `std::jthread`, you need to include the same `<thread>` header. For `std::stop_source`
    and `std::stop_token`, you need to include the header `<stop_token>`.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，您应该阅读本章的第一个菜谱，*与线程一起工作*，以确保您熟悉 `std::thread`。要使用 `std::jthread`，您需要包含相同的
    `<thread>` 头文件。对于 `std::stop_source` 和 `std::stop_token`，您需要包含头文件 `<stop_token>`。
- en: How to do it...
  id: totrans-565
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'The typical scenarios for using joinable threads and a cooperative cancellation
    mechanism are as follows:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可连接线程和协作取消机制的经典场景如下：
- en: 'If you want to automatically join a thread object when it goes out of scope,
    use `std::jthread` instead of `std::thread`. You can still use all the methods
    that `std::thread` has, such as explicitly joining with `join()`:'
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想在对象超出作用域时自动连接线程对象，请使用 `std::jthread` 而不是 `std::thread`。您仍然可以使用 `std::thread`
    所有的方法，例如使用 `join()` 显式连接：
- en: '[PRE104]'
  id: totrans-568
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'If you need to be able to cancel the execution of a thread, you should do the
    following:'
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您需要能够取消线程的执行，您应该做以下事情：
- en: Make sure the first parameter of the thread function is a `std::stop_token`
    object.
  id: totrans-570
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保线程函数的第一个参数是 `std::stop_token` 对象。
- en: In the thread function, periodically check if stopping was requested using the
    `stop_requested()` method of the `std::stop_token` object and stop when signaled.
  id: totrans-571
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线程函数中，定期使用 `std::stop_token` 对象的 `stop_requested()` 方法检查是否请求停止，并在收到信号时停止。
- en: Use `std::jthread` for executing the function on a separate thread.
  id: totrans-572
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::jthread` 在单独的线程上执行函数。
- en: 'From the calling thread, use the `request_stop()` method of the `std::jthread`
    object to request the thread function to stop and return:'
  id: totrans-573
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从调用线程中，使用 `std::jthread` 对象的 `request_stop()` 方法请求线程函数停止并返回：
- en: '[PRE105]'
  id: totrans-574
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'If you need to cancel the work of multiple threads, then you can do the following:'
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要取消多个线程的工作，你可以这样做：
- en: All thread functions must take a `std::stop_token` object as the first argument.
  id: totrans-576
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有线程函数都必须将 `std::stop_token` 对象作为第一个参数。
- en: All thread functions should periodically check if a stop was requested by calling
    the `stop_requested()` method of `std::stop_token` and, if a stop was requested,
    abort the execution.
  id: totrans-577
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有线程函数都应该定期检查是否请求了停止，通过调用 `std::stop_token` 的 `stop_requested()` 方法，如果请求了停止，则终止执行。
- en: Use `std::jthread` to execute functions on different threads.
  id: totrans-578
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::jthread` 在不同的线程上执行函数。
- en: In the calling thread, create a `std::stop_source` object.
  id: totrans-579
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用线程中，创建一个 `std::stop_source` 对象。
- en: Get a `std::stop_token` object by calling the `get_token()` method of the `std::stop_source`
    object and pass it as the first argument for the thread function when creating
    `std::jthread` objects.
  id: totrans-580
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用 `std::stop_source` 对象的 `get_token()` 方法获取 `std::stop_token` 对象，并在创建 `std::jthread`
    对象时将其作为第一个参数传递给线程函数。
- en: When you want to stop the execution of the thread functions, call the `request_stop()`
    method of the `std::stop_source` object.
  id: totrans-581
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想要停止线程函数的执行时，调用 `std::stop_source` 对象的 `request_stop()` 方法。
- en: '[PRE106]'
  id: totrans-582
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'If you need to execute a piece of code when a stop source is requesting cancellation,
    you can use a `std::stop_callback` created with the `std::stop_token` object,
    which signals the stop request and a callback function that is invoked when the
    stop is requested (through the `std::stop_source` object associated with `std::stop_token`):'
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要在停止源请求取消时执行一段代码，你可以使用由 `std::stop_token` 对象创建的 `std::stop_callback`，它发出停止请求，并在请求停止时（通过与
    `std::stop_token` 关联的 `std::stop_source` 对象）调用回调函数：
- en: '[PRE107]'
  id: totrans-584
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: How it works...
  id: totrans-585
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`std::jthread` is very similar to `std::thread`. It is, in fact, an attempt
    to fix what was missing for threads in C++11\. Its public interface is very similar
    to `std::thread`. All the methods `std::thread` has are also present in `std::thread`.
    However, it differs in the following key aspects:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::jthread` 与 `std::thread` 非常相似。实际上，它是试图修复 C++11 中线程所缺失的功能。它的公共接口与 `std::thread`
    非常相似。`std::thread` 所有的方法在 `std::jthread` 中也都存在。然而，它在以下关键方面有所不同：'
- en: Internally, it maintains, at least logically, a shared stop state, which allows
    for the request of the thread function to stop execution.
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内部，它至少在逻辑上维护一个共享的停止状态，这使得可以请求线程函数停止执行。
- en: 'It has several methods for handling cooperative cancellation: `get_stop_source()`,
    which returns a `std::stop_source` object associated with the shared stop state
    of the thread, `get_stop_token()`, which returns a `std::stop_token` associated
    with the shared stop state of the thread, and `request_stop()`, which requests
    the cancellation of the execution of the thread function via the shared stop state.'
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有几种处理协作取消的方法：`get_stop_source()`，它返回与线程共享停止状态关联的 `std::stop_source` 对象，`get_stop_token()`，它返回与线程共享停止状态关联的
    `std::stop_token`，以及 `request_stop()`，它通过共享停止状态请求取消线程函数的执行。
- en: The behavior of its destructor, which, when the thread is joinable, calls `request_stop()`
    and then `join()` to first signal the request to stop execution and then wait
    until the thread has finished its execution.
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其析构函数的行为，当线程可连接时，会调用 `request_stop()` 然后调用 `join()`，首先发出停止执行请求，然后等待线程完成执行。
- en: You can create `std::jthread` objects just as you would create `std::thread`
    objects. However, the callable function that you pass to a `std::jthread` can
    have a first argument of the type `std::stop_token`. This is necessary when you
    want to be able to cooperatively cancel the thread’s execution.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像创建 `std::thread` 对象一样创建 `std::jthread` 对象。然而，传递给 `std::jthread` 的可调用函数可以有一个类型为
    `std::stop_token` 的第一个参数。当你想要能够协作取消线程的执行时，这是必要的。
- en: 'Typical scenarios include graphical user interfaces where user interaction
    may cancel work in progress, but many other situations can be envisioned. The
    invocation of such a function thread happens as follows:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 典型场景包括图形用户界面，其中用户交互可能会取消正在进行的操作，但可以设想许多其他情况。这样的函数线程调用如下：
- en: If the first argument for the thread function, supplied when constructing `std::jthread`,
    is a `std::stop_token`, it is forwarded to the callable function.
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果为`std::jthread`构造时提供的线程函数的第一个参数是`std::stop_token`，则将其转发到可调用函数。
- en: If the first argument, when there are arguments, for the callable function is
    not a `std::stop_token` object, then the `std::stop_token` object associated with
    the `std::jthread` object’s internal shared stop state is passed to the function.
    This token is obtained with a call to `get_stop_token()`.
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在存在参数的情况下，可调用函数的第一个参数不是`std::stop_token`对象，则将`std::jthread`对象内部共享的停止状态关联的`std::stop_token`对象传递给函数。此令牌通过调用`get_stop_token()`获得。
- en: The function thread must periodically check the status of the `std::stop_token`
    object. The `stop_requested()` method checks if a stop was requested. The request
    to stop comes from a `std::stop_source` object.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 线程函数必须定期检查`std::stop_token`对象的状态。`stop_requested()`方法检查是否请求了停止。停止请求来自`std::stop_source`对象。
- en: If multiple stop tokens are associated with the same stop source, a stop request
    is visible to all the stop tokens. If a stop is requested, it cannot be withdrawn,
    and successive stop requests have no meaning. To request a stop, you should call
    the `request_stop()` method. You can check if a `std::stop_source` is associated
    with a stop state and can be requested to stop by calling the `stop_possible()`
    method.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个停止令牌与同一个停止源相关联，则停止请求对所有停止令牌都是可见的。如果请求停止，则无法撤销，并且后续的停止请求没有意义。要请求停止，应调用`request_stop()`方法。你可以通过调用`stop_possible()`方法来检查`std::stop_source`是否与停止状态相关联，并且可以请求停止。
- en: 'If you need to invoke a callback function when a stop source is requested to
    stop, then you can use the `std::stop_callback` class. This associates a `std::stop_token`
    object with a callback function. When the stop source of the stop token is requested
    to stop the callback is invoked. Callback functions are invoked as follows:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在请求停止源停止时调用回调函数，则可以使用`std::stop_callback`类。这会将`std::stop_token`对象与回调函数关联起来。当停止令牌的停止源被请求停止时，将调用回调。回调函数的调用方式如下：
- en: In the same thread that invoked `request_stop()`.
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用`request_stop()`的同一线程中。
- en: In the thread constructing the `std::stop_callback` object, if the stop has
    already been requested before the stop callback object has been constructed.
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建`std::stop_callback`对象之前，如果已经请求停止。
- en: You can create any number of `std::stop_callback` objects for the same stop
    token. However, the order the callbacks are invoked in is unspecified. The only
    guarantee is that they will be executed synchronously, provided that the stop
    has been requested after the `std::stop_callback` objects have been created.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为同一个停止令牌创建任意数量的`std::stop_callback`对象。然而，回调函数被调用的顺序是不确定的。唯一的保证是，如果停止是在`std::stop_callback`对象创建之后请求的，它们将同步执行。
- en: It is also important to note that, if any callback function returns via an exception,
    then `std::terminate()` will be invoked.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，如果任何回调函数通过异常返回，则将调用`std::terminate()`。
- en: See also
  id: totrans-601
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Working with threads*, to learn about the `std::thread` class and the basic
    operations for working with threads in C++'
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与线程协同工作*，了解`std::thread`类以及如何在C++中处理线程的基本操作'
- en: '*Sending notifications between threads*, to see how to use condition variables
    to send notifications between producer and consumer threads'
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*线程间发送通知*，了解如何使用条件变量在生产者和消费者线程之间发送通知'
- en: Synchronizing threads with latches, barriers, and semaphores
  id: totrans-604
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用latches、barriers和semaphores同步线程
- en: 'The thread support library from C++11 includes mutexes and condition variables
    that enable thread-synchronization to shared resources. A mutex allows only one
    thread of multiple processes to execute, while other threads that want to access
    a shared resource are put to sleep. Mutexes can be expensive to use in some scenarios.
    For this reason, the C++20 standard features several new, simpler synchronization
    mechanisms: latches, barriers, and semaphores. Although these do not provide new
    use cases, they are simpler to use and can be more performant because they may
    internally rely on lock-free mechanisms.'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: C++11的线程支持库包括互斥锁和条件变量，这些变量使得线程同步到共享资源成为可能。互斥锁允许多个进程中的一个线程执行，而其他想要访问共享资源的线程将被挂起。在某些情况下，互斥锁的使用可能会很昂贵。因此，C++20标准引入了几个新的、更简单的同步机制：latches、barriers和semaphores。尽管它们不提供新的用例，但它们的使用更简单，并且可能由于内部依赖于无锁机制而具有更高的性能。
- en: Getting ready
  id: totrans-606
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The new C++20 synchronization mechanisms are defined in new headers. You have
    to include `<latch>` for `std::latch`, `<barrier>`, or `std::barrier`, and `<semaphore>`
    for `std::counting_semaphore` and `std::binary_semaphore`.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 C++20 同步机制定义在新头文件中。你必须包含 `<latch>` 以使用 `std::latch`、`<barrier>` 或 `std::barrier`，以及
    `<semaphore>` 以使用 `std::counting_semaphore` 和 `std::binary_semaphore`。
- en: 'The code snippets in this recipe will use the following two functions:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中的代码片段将使用以下两个函数：
- en: '[PRE108]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: How to do it...
  id: totrans-610
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Use the C++20 synchronization mechanisms as follows:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下方式使用 C++20 同步机制：
- en: 'Use `std::latch` when you need threads to wait until a counter, decreased by
    other threads, reaches zero. The latch must be initialized with a non-zero count
    and multiple threads can decrease it, while others wait for the count to reach
    zero. When that happens, all waiting threads are awakened and the latch can no
    longer be used. If the latch count does not decrease to zero (not enough threads
    decrease it) the waiting threads will be blocked forever. In the following example,
    four threads are creating data (stored in a vector of integers) and the main thread
    waits for the completion of them all by utilizing a `std::latch`, decremented
    by each thread after completing its work:'
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要线程等待直到一个由其他线程减少的计数器达到零时，请使用 `std::latch`。闩锁必须使用非零计数初始化，并且多个线程可以减少它，而其他线程等待计数达到零。当这种情况发生时，所有等待的线程都会被唤醒，并且闩锁不能再使用。如果闩锁计数没有减少到零（没有足够的线程减少它），等待的线程将永远阻塞。在下面的示例中，四个线程正在创建数据（存储在整数向量中），主线程通过使用
    `std::latch`（每个线程在其工作完成后减少）来等待它们的完成：
- en: '[PRE109]'
  id: totrans-613
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Use `std::barrier` when you need to perform loop synchronization between parallel
    tasks. You construct a barrier with a count and, optionally, a completion function.
    Threads arrive at the barrier, decrease the internal counter, and block. When
    the counter reaches zero, the completion function is invoked, all blocked threads
    are awakened, and a new cycle begins. In the following example, four threads are
    creating data that they store in a vector of integers. When all the threads have
    completed a cycle, the data is processed in the main thread, by a completion function.
    Each thread blocks after completing a cycle until they are awakened through the
    use of a `std::barrier` object, which also stores the completion function. This
    process is repeated 10 times:'
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要执行并行任务之间的循环同步时，请使用 `std::barrier`。你使用一个计数和一个可选的完成函数来构造一个屏障。线程到达屏障，减少内部计数，并阻塞。当计数达到零时，调用完成函数，所有阻塞的线程被唤醒，并开始新的周期。在下面的示例中，四个线程正在创建数据，并将它们存储在一个整数向量中。当所有线程完成一个周期后，主线程通过一个完成函数处理数据。每个线程在完成一个周期后都会阻塞，直到通过使用
    `std::barrier` 对象被唤醒，该对象也存储了完成函数。这个过程重复10次：
- en: '[PRE110]'
  id: totrans-615
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Use `std::counting_semaphore<N>` or `std::binary_semaphore` when you want to
    restrict a number of *N* threads (a single thread, in the case of `binary_semaphore`)
    to access a shared resource, or when you want to pass notifications between different
    threads. In the following example, four threads are creating data that is added
    to the end of a vector of integers. To avoid race conditions, a `binary_semaphore`
    object is used to restrict the access to the vector to a single thread:'
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想限制 *N* 个线程（在 `binary_semaphore` 的情况下是一个线程）访问共享资源，或者你想在不同线程之间传递通知时，请使用 `std::counting_semaphore<N>`
    或 `std::binary_semaphore`。在下面的示例中，四个线程正在创建数据，并将数据添加到整数向量的末尾。为了避免竞争条件，使用了一个 `binary_semaphore`
    对象来限制对向量的访问只能由单个线程进行：
- en: '[PRE111]'
  id: totrans-617
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: How it works...
  id: totrans-618
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `std::latch` class implements a counter that can be used to synchronize
    threads. It is a race-free class that works as follows:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::latch` 类实现了一个可以用来同步线程的计数器。它是一个无竞争的类，工作方式如下：'
- en: The counter is initialized when the latch is created and can only be decreased.
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计数器在创建闩锁时初始化，并且只能减少。
- en: A thread may decrease the value of the latch and can do so multiple times.
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个线程可以减少闩锁的值，并且可以多次这样做。
- en: A thread may block by waiting until the latch counter reaches zero.
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个线程可以通过等待直到闩锁计数器达到零来阻塞。
- en: When the counter reaches zero, the latch becomes permanently signaled and all
    the threads that are blocked on the latch are awakened.
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当计数器达到零时，闩锁永久地被信号，并且所有在闩锁上阻塞的线程都会被唤醒。
- en: 'The `std::latch` class has the following methods:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::latch` 类有以下方法：'
- en: '| **Methods** | **Descriptions** |'
  id: totrans-625
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `count_down()` | Decrements the internal counter by *N* (which is `1` by
    default) without blocking the caller. This operation is performed atomically.
    *N* must be a positive value no greater than the value of the internal counter;
    otherwise, the behavior is undefined. |'
  id: totrans-626
  prefs: []
  type: TYPE_TB
  zh: '| `count_down()` | 通过原子操作减少内部计数器 *N*（默认为 `1`）而不阻塞调用者。此操作是原子性的。*N* 必须是一个正数，且不超过内部计数器的值；否则，行为是未定义的。
    |'
- en: '| `try_wait()` | Indicates whether the internal counter reaches zero, in which
    case it returns `true`. There is a very low probability that, although the counter
    has reached zero, the function may still return `false`. |'
  id: totrans-627
  prefs: []
  type: TYPE_TB
  zh: '| `try_wait()` | 表示内部计数器是否达到零，如果是，则返回 `true`。尽管计数器已经达到零，但函数可能仍然返回 `false` 的概率非常低。
    |'
- en: '| `wait()` | Blocks the calling thread until the internal counter reaches zero.
    If the internal counter is already zero, the function returns immediately without
    blocking. |'
  id: totrans-628
  prefs: []
  type: TYPE_TB
  zh: '| `wait()` | 阻塞调用线程，直到内部计数器达到零。如果内部计数器已经为零，函数将立即返回而不阻塞。 |'
- en: '| `arrive_and_wait()` | This function is equivalent to calling `count_down()`,
    followed by `wait()`. It decrements the internal counter with *N* (which is `1`
    by default) and then blocks the calling thread until the internal counter reaches
    zero. |'
  id: totrans-629
  prefs: []
  type: TYPE_TB
  zh: '| `arrive_and_wait()` | 此函数相当于调用 `count_down()`，然后调用 `wait()`。它将内部计数器减少 *N*（默认为
    `1`）并阻塞调用线程，直到内部计数器达到零。 |'
- en: 'Table 8.3: std::memory_order members that describe how memory access is ordered
    for an atomic operation'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.3：描述原子操作内存访问顺序的 `std::memory_order` 成员
- en: In the first example in the previous section, we have a `std::latch`, called
    `work_done`, initialized with the number of threads (or jobs) that perform work.
    Each thread produces data that is then written in a shared resource, a vector
    of integers. Although this is shared, there is no race condition because each
    thread writes to a different place; therefore, there is no need for a synchronization
    mechanism. After completing its work, each thread decrements the counter of the
    latch. The main thread waits until the counter of the latch reaches zero, after
    which it processes the data from the threads.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节的第一例中，我们有一个名为 `work_done` 的 `std::latch`，它初始化为执行工作的线程（或作业）数量。每个线程生成数据，然后将其写入共享资源，即整数向量。尽管这是共享的，但由于每个线程写入不同的位置，因此不存在竞态条件；因此，不需要同步机制。完成工作后，每个线程都会减少
    `latch` 的计数器。主线程会等待直到 `latch` 的计数器达到零，之后它会处理来自线程的数据。
- en: Because the internal counter of `std::latch` cannot be incremented or reset,
    this synchronization mechanism can be used only once. A similar but reusable synchronization
    mechanism is `std::barrier`. A barrier allows threads to block until an operation
    is completed and is useful for managing repeated tasks performed by multiple threads.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `std::latch` 的内部计数器不能增加或重置，因此这种同步机制只能使用一次。一个类似但可重复使用的同步机制是 `std::barrier`。屏障允许线程阻塞，直到操作完成，这对于管理多个线程执行的重叠任务很有用。
- en: 'A barrier works as follows:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 屏障的工作方式如下：
- en: A barrier contains a counter that is initialized during its creation and can
    be decreased by threads arriving at the barrier. When the counter reaches zero,
    it is reset to its initial value and the barrier can be reused.
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个屏障包含一个计数器，它在创建时初始化，并且可以被到达屏障的线程减少。当计数器达到零时，它将重置为其初始值，屏障可以再次使用。
- en: A barrier also contains a completion function that is called when the counter
    reaches zero. If a default completion function is used, it is invoked as part
    of the call to `arrive_and_wait()` or `arrive_and_drop()`. Otherwise, the completion
    function is invoked on one of the threads that participate in the completion phase.
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏障还包含一个完成函数，当计数器达到零时被调用。如果使用默认的完成函数，它将在调用 `arrive_and_wait()` 或 `arrive_and_drop()`
    时作为调用的一部分被调用。否则，完成函数将在参与完成阶段的某个线程上被调用。
- en: The process through which a barrier goes from start to reset is called the **completion
    phase**. This starts with a so-called **synchronization point** and ends with
    the **completion step**.
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个屏障从开始到重置的过程称为 **完成阶段**。这从所谓的 **同步点** 开始，以 **完成步骤** 结束。
- en: The first *N* threads that arrive at the synchronization point after the construction
    of the barrier are said to be the **set of participating threads**. Only these
    threads are allowed to arrive at the barrier during each of the following cycles.
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在屏障构建后到达同步点的第一个 *N* 个线程被称为 **参与线程集**。只有这些线程在每个后续周期中被允许到达屏障。
- en: A thread that arrives at the synchronization point may decide to participate
    in the completion phase by calling `arrive_and_wait()`. However, a thread may
    remove itself from the participation set by calling `arrive_and_drop()`. In this
    case, another thread must take its place in the participation set.
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到达同步点的线程可以通过调用 `arrive_and_wait()` 来决定参与完成阶段。然而，线程也可以通过调用 `arrive_and_drop()`
    来从参与集中移除自己。在这种情况下，另一个线程必须取代它在参与集中的位置。
- en: 'When all the threads in the participation set have arrived at the synchronization
    point, the completion phase is executed. There are three steps that occur: first,
    the completion function is invoked. Second, all the threads that are blocked are
    awakened. Third, and last, the barrier count is reset and a new cycle begins.'
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当参与集中的所有线程都到达同步点时，执行完成阶段。这个过程有三个步骤：首先，调用完成函数。其次，唤醒所有阻塞的线程。最后，重置屏障计数并开始新周期。
- en: 'The `std::barrier` class has the following methods:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::barrier` 类有以下方法：'
- en: '| **Methods** | **Descriptions** |'
  id: totrans-641
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `arrive()` | Arrives at the barrier’s synchronization point and decrements
    the expected count by a value n. The behavior is undefined if the value of n is
    greater than the expected count, or equal to or less than zero. The function executes
    atomically. |'
  id: totrans-642
  prefs: []
  type: TYPE_TB
  zh: '| `arrive()` | 到达屏障的同步点并按值 n 减少预期的计数。如果 n 的值大于预期的计数，或者等于或小于零，则行为未定义。该函数以原子方式执行。
    |'
- en: '| `wait()` | Blocks at the synchronization point until the completion step
    is executed. |'
  id: totrans-643
  prefs: []
  type: TYPE_TB
  zh: '| `wait()` | 在同步点阻塞，直到执行完成步骤。 |'
- en: '| `arrive_and_wait()` | Arrives at the barrier’s synchronization point and
    blocks. The calling thread must be in the participating set; otherwise, the behavior
    is undefined. This function only returns after the completion phase ends. |'
  id: totrans-644
  prefs: []
  type: TYPE_TB
  zh: '| `arrive_and_wait()` | 到达屏障的同步点并阻塞。调用此函数的线程必须属于参与集；否则，行为未定义。此函数仅在完成阶段结束后才返回。
    |'
- en: '| `arrive_and_drop()` | Arrives at the barrier’s synchronization point and
    removes the thread from the participation set. It is an implementation detail
    whether the function blocks or not until the end of the completion phase. The
    calling thread must be in the participation set; otherwise, the behavior is undefined.
    |'
  id: totrans-645
  prefs: []
  type: TYPE_TB
  zh: '| `arrive_and_drop()` | 到达屏障的同步点并从参与集中移除线程。函数是否阻塞直到完成阶段结束是一个实现细节。调用此函数的线程必须属于参与集；否则，行为未定义。
    |'
- en: 'Table 8.4: The member functions of the std::barrier class'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.4：std::barrier 类的成员函数
- en: '[PRE112]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The last synchronization mechanism available in the thread support library in
    C++20 is represented by semaphores. A semaphore contains an internal counter that
    can be both decreased and increased by multiple threads. When the counter reaches
    zero, further attempts to decrease it will block the thread, until another thread
    increases the counter.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: C++20中线程支持库中可用的最后一种同步机制由信号量表示。信号量包含一个内部计数器，可以被多个线程同时增加和减少。当计数器达到零时，进一步尝试减少它将阻塞线程，直到另一个线程增加计数器。
- en: 'There are two semaphore classes: `std::counting_semaphore<N>` and `std::binary_semaphore`.
    The latter is actually just an alias for `std::counting_semaphore<1>`.'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个信号量类：`std::counting_semaphore<N>` 和 `std::binary_semaphore`。后者实际上是 `std::counting_semaphore<1>`
    的别名。
- en: 'A `counting_semaphore` allows *N* threads to access a shared resource, unlike
    a mutex, which only allows one. `binary_semaphore`, is, in this matter, similar
    to the mutex, because only one thread can access the shared resource. On the other
    hand, a mutex is bound to a thread: the thread that locked the mutex must unlock
    it. However, this is not the case for semaphores. A semaphore can be released
    by threads that did not acquire it, and a thread that acquired a semaphore does
    not have to also release it.'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '`counting_semaphore` 允许 *N* 个线程访问共享资源，与只允许一个线程的互斥锁不同。`binary_semaphore` 在这个方面与互斥锁相似，因为只有一个线程可以访问共享资源。另一方面，互斥锁绑定到线程：锁定互斥锁的线程必须解锁它。然而，对于信号量来说并非如此。信号量可以被未获取它的线程释放，并且获取了信号量的线程也不必释放它。'
- en: 'The `std::counting_semaphore` class has the following methods:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::counting_semaphore` 类有以下方法：'
- en: '| **Methods** | **Descriptions** |'
  id: totrans-652
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `acquire()` | Decrements the internal counter by 1 if it is greater than
    0\. Otherwise, it blocks until the counter becomes greater than 0. |'
  id: totrans-653
  prefs: []
  type: TYPE_TB
  zh: '| `acquire()` | 如果内部计数器大于0，则将其减1。否则，它将阻塞，直到计数器大于0。 |'
- en: '| `try_acquire()` | Tries to decrement the counter by 1 if it is greater than
    0\. It returns `true` if it succeeds, or `false` otherwise. This method does not
    block. |'
  id: totrans-654
  prefs: []
  type: TYPE_TB
  zh: '| `try_acquire()` | 如果计数器大于0，则尝试将其减少1。如果成功，返回`true`，否则返回`false`。此方法不会阻塞。 |'
- en: '| `try_acquire_for()` | Tries to decrease the counter by 1 if it is greater
    than 0\. Otherwise, it blocks either until the counter becomes greater than 0
    or a specified timeout occurs. The function returns `true` if it succeeds in decreasing
    the counter. |'
  id: totrans-655
  prefs: []
  type: TYPE_TB
  zh: '| `try_acquire_for()` | 如果计数器大于0，则尝试将其减少1。否则，它将阻塞，直到计数器大于0或发生指定的超时。如果成功减少计数器，函数返回`true`。
    |'
- en: '| `try_acquire_until()` | Tries to decrease the counter by 1 if it is greater
    than 0\. Otherwise, it blocks either until the counter becomes greater than 0
    or a specified time point has been passed. The function returns `true` if it succeeds
    in decreasing the counter. |'
  id: totrans-656
  prefs: []
  type: TYPE_TB
  zh: '| `try_acquire_until()` | 如果计数器大于0，则尝试将其减少1。否则，它将阻塞，直到计数器大于0或经过指定的时间点。如果成功减少计数器，函数返回`true`。
    |'
- en: '| `release()` | Increments the internal counter by the specified value (which
    is 1 by default). Any thread that was blocked waiting for the counter to become
    greater than 0 is awakened. |'
  id: totrans-657
  prefs: []
  type: TYPE_TB
  zh: '| `release()` | 通过指定的值（默认为1）增加内部计数器。任何被阻塞等待计数器大于0的线程将被唤醒。 |'
- en: 'Table 8.5: The member functions of the std::counting_semaphore class'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.5：std::counting_semaphore类的成员函数
- en: All the increment and decrement operations performed on the counter by the methods
    listed here are executed atomically.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出的方法对计数器进行的所有增加和减少操作都是原子执行的。
- en: The last example in the *How to do it...* section shows how a `binary_semaphore`
    can be used. A number of threads (four, in this example) produce work in a loop
    and write to a shared resource. Unlike the previous examples, they simply add
    to the end of a vector of integers. Therefore, the access to this vector must
    be synchronized between the threads, and this is where the binary semaphore is
    used. In each loop, the thread function creates a new value (which may take some
    time). This value is then appended to the end of the vector. However, the thread
    must call the `acquire()` method of the semaphore to make sure it is the only
    thread that can continue execution and access the shared resource. After the write
    operation completes, the thread calls the `release()` method of the semaphore
    in order to increment the internal counter and allow another thread to access
    the shared resource.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: '*如何做...*部分的最后一个示例展示了如何使用`binary_semaphore`。多个线程（在这个例子中是四个）在循环中产生工作并写入共享资源。与前面的示例不同，它们只是简单地将数据添加到整数向量的末尾。因此，必须在线程之间同步对向量的访问，这就是使用二进制信号量的地方。在每次循环中，线程函数创建一个新的值（这可能需要一些时间）。然后，这个值被追加到向量的末尾。然而，线程必须调用信号量的`acquire()`方法以确保它是唯一可以继续执行并访问共享资源的线程。在写操作完成后，线程调用信号量的`release()`方法以增加内部计数器并允许另一个线程访问共享资源。'
- en: 'Semaphores can be used for multiple purposes: to block access to shared resources
    (similar to mutexes), to signal or pass notifications between threads (similar
    to condition variables), or to implement barriers, often with better performance
    than similar mechanisms.'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量可用于多种用途：阻止对共享资源的访问（类似于互斥锁）、在线程之间发出或传递通知（类似于条件变量），或实现屏障，通常比类似的机制具有更好的性能。
- en: See also
  id: totrans-662
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Working with threads*, to learn about the `std::thread` class and the basic
    operations for working with threads in C++'
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与线程一起工作*，了解`std::thread`类以及C++中处理线程的基本操作'
- en: '*Synchronizing access to shared data with mutexes and locks*, to see what mechanisms
    are available for synchronizing thread access to shared data and how they work'
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用互斥锁和锁同步对共享数据的访问*，以了解可用于同步线程对共享数据访问的机制以及它们的工作原理'
- en: '*Sending notifications between threads*, to see how to use condition variables
    to send notifications between producer and consumer threads'
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在线程之间发送通知*，了解如何使用条件变量在生产者和消费者线程之间发送通知'
- en: Synchronizing writing to output streams from multiple threads
  id: totrans-666
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步来自多个线程的输出流写入
- en: '`std::cout` is a global object of the `std::ostream` type. It is used to write
    text to the standard output console. Although writing to it is guaranteed to be
    thread-safe, this applies to just one invocation of the `operator<<`. Multiple
    such sequenced calls to `operator<<` can be interrupted and resumed later, making
    it necessary to employ synchronization mechanisms to avoid corrupted results.
    This applies to all scenarios where multiple threads operate on the same output
    stream. To simplify this scenario, C++20 introduced `std::basic_osyncstream` to
    provide a mechanism to synchronize threads writing to the same output stream.
    In this recipe, you will learn how to use this new utility.'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::cout` 是 `std::ostream` 类的全局对象。它用于将文本写入标准输出控制台。尽管写入它是保证线程安全的，但这仅适用于 `operator<<`
    的单个调用。多个此类顺序调用可能会被中断并在稍后恢复，这使得必须使用同步机制来避免损坏的结果。这适用于所有多个线程操作同一输出流的场景。为了简化这种情况，C++20
    引入了 `std::basic_osyncstream` 以提供同步写入同一输出流的线程的机制。在本食谱中，你将学习如何使用这个新工具。'
- en: How to do it…
  id: totrans-668
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To synchronize access to an output stream for writing from multiple threads,
    do the following:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 要同步多个线程对输出流的写入访问，请执行以下操作：
- en: Include the `<syncstream>` header.
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含 `<syncstream>` 头文件。
- en: Define a variable of the `std::osyncstream` type to wrap the shared output stream,
    such as `std::cout`.
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个 `std::osyncstream` 类型的变量来包装共享输出流，例如 `std::cout`。
- en: Use the wrapper variable exclusively to write to the output stream.
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅使用包装变量写入输出流。
- en: 'The following snippet shows an example for this pattern:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段展示了这种模式的示例：
- en: '[PRE113]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: How it works…
  id: totrans-675
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'By default, the standard C++ stream objects `std::cin`/`std::wcin`, `std::cout`/`std::wcout`,
    `std::cerr`/`std::wcerr`, and `std::clog`/`std::wclog` are synchronized with their
    respective C streams, `stdin`, `stdout`, and `stderr` (unless a call to `std::ios_base::sync_with_stdio()`
    disables this synchronization). What this means is that any operation applied
    to a C++ stream object is immediately applied to the corresponding C stream. Moreover,
    accessing these streams is guaranteed to be thread-safe. This means that calls
    to `operator <<` or `>>` are atomic; another thread cannot access the stream until
    the call completes. However, multiple calls can be interrupted, as shown in the
    following example:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，标准 C++ 流对象 `std::cin`/`std::wcin`、`std::cout`/`std::wcout`、`std::cerr`/`std::wcerr`
    和 `std::clog`/`std::wclog` 与其各自的 C 流 `stdin`、`stdout` 和 `stderr` 同步（除非调用 `std::ios_base::sync_with_stdio()`
    禁用了这种同步）。这意味着对 C++ 流对象进行的任何操作都会立即应用于相应的 C 流。此外，访问这些流是保证线程安全的。这意味着对 `operator <<`
    或 `>>` 的调用是原子的；另一个线程无法访问流，直到调用完成。然而，多个调用可能会被中断，如下面的示例所示：
- en: '[PRE114]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The output differs on different executions, but it looks like the following:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 输出在不同的执行中会有所不同，但看起来如下所示：
- en: '[PRE115]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: There are three different invocations to `operator <<` in the thread function.
    Although each executes atomically, the thread can be suspended in between calls
    for another thread to get a chance to execute. This is why we see the output having
    the shape shown earlier.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 在线程函数中，对 `operator <<` 有三种不同的调用方式。尽管每个调用都是原子性的，但线程在调用之间可能会被挂起，以便其他线程有机会执行。这就是为什么我们看到的输出具有之前显示的形状。
- en: 'This can be solved in several ways. One can use a synchronization mechanism,
    such as a mutex. However, in this particular case, a simpler solution is to use
    a local `std::stringstream` object to build the text to be displayed on the console
    and make a single invocation to `operator<<`, as shown next:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过几种方式解决。可以使用同步机制，例如互斥锁。然而，在这种情况下，一个更简单的解决方案是使用一个局部的 `std::stringstream`
    对象来构建要在控制台上显示的文本，并对 `operator<<` 进行单次调用，如下所示：
- en: '[PRE116]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'With these changes, the output has the form that was expected:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改后，输出具有预期的形式：
- en: '[PRE117]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: In C++20, you can use a `std::osyncstream`/`std::wosyncstream` object to wrap
    an output stream to synchronize access, as shown in the *How to do it…* section.
    The `osyncstream` class guarantees there are no data races if all the write operations
    from different threads occur through instances of this class. The `std::basic_osyncstream`
    class wraps an instance of `std::basic_syncbuf`, which, in turn, wraps an output
    buffer but also contains a separate internal buffer. This class accumulates output
    in an internal buffer and transmits it to the wrapped buffer when the object is
    destructed or when an explicit call to the `emit()` member function occurs.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++20中，你可以使用`std::osyncstream`/`std::wosyncstream`对象来包装一个输出流以同步访问，如*如何实现…*部分所示。`osyncstream`类保证如果所有来自不同线程的写操作都通过这个类的实例进行，则不会有数据竞争。`std::basic_osyncstream`类包装了一个`std::basic_syncbuf`的实例，它反过来包装了一个输出缓冲区，但也包含一个单独的内部缓冲区。这个类在内部缓冲区中累积输出，并在对象被销毁或显式调用`emit()`成员函数时将其传输到包装的缓冲区。
- en: 'The sync stream wrappers can be used to synchronize access to any output stream,
    not just `std::ostream`/`std::wostream` (the type of `std::cout`/`std::wcout`).
    For instance, it can be used to synchronize access to a string stream, as shown
    in the following snippet:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 同步流包装器可以用来同步访问任何输出流，而不仅仅是`std::ostream`/`std::wostream`（`std::cout`/`std::wcout`的类型）。例如，它可以用来同步访问字符串流，如下面的代码片段所示：
- en: '[PRE118]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'In this example, we define a `std::ostringstream` object called `str`. In the
    inner block, this is wrapped by a `std::osyncstream` object and then we write
    the text `"sync stream demo"` through this wrapper to the string stream. On the
    line marked with **[1]**, we print the content of the string stream to the console.
    However, the content of the stream’s buffer is empty because the sync stream has
    not been destroyed, nor has a call to `emit()` occurred. When the sync stream
    goes out of scope, the content of its inner buffer is transferred to the wrapped
    stream. Therefore, on the line marked with **[2]**, the `str` string stream contains
    the text `"sync stream demo"`. This results in the following output for the program:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们定义了一个名为`str`的`std::ostringstream`对象。在内部块中，这个对象被`std::osyncstream`对象包装，然后我们通过这个包装器将文本`"sync
    stream demo"`写入字符串流。在**[1]**行标记的行上，我们打印字符串流的内容到控制台。然而，流的缓冲区内容为空，因为同步流尚未被销毁，也没有发生对`emit()`的调用。当同步流超出作用域时，其内部缓冲区的内容传输到包装流。因此，在**[2]**行标记的行上，`str`字符串流包含文本`"sync
    stream demo"`。这导致程序输出如下：
- en: '[PRE119]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'We can elaborate on this example to show how the `emit()` member function affects
    the behavior of the streams. Let’s consider the following snippet:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步阐述这个示例，以展示`emit()`成员函数如何影响流的操作。让我们考虑以下代码片段：
- en: '[PRE120]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The first part of this second example is the same. On line **[1]**, the content
    of the string buffer is empty. However, after the call to `emit()`, the sync stream
    transfers the content of its inner buffer to the wrapped output stream. Therefore,
    on line **[2]**, the string buffer contains the text `"sync stream demo"`. New
    text, `"demo part 2"`, is written to the string stream through the sync stream,
    but this is not transferred to the string stream before the line marked with **[3]**
    executes; therefore, at this point the content of the string stream is unchanged.
    Upon going out of scope at the end of the inner block, the new content of the
    sync stream’s inner buffer is again transferred to the wrapped string stream,
    which will now contain the text `"sync stream demodemo part 2"`. As a result,
    the output of this second example is the following:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第二个示例的第一部分是相同的。在**[1]**行，字符串缓冲区的内容为空。然而，在调用`emit()`之后，同步流将内部缓冲区的内容传输到包装的输出流。因此，在**[2]**行，字符串缓冲区包含文本`"sync
    stream demo"`。新的文本`"demo part 2"`通过同步流写入字符串流，但在**[3]**行标记执行之前，这些文本并未传输到字符串流；因此，此时字符串流的内容没有改变。当内部块结束时超出作用域，同步流内部缓冲区的新内容再次传输到包装的字符串流，此时字符串流将包含文本`"sync
    stream demodemo part 2"`。因此，这个第二个示例的输出如下：
- en: '[PRE121]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The `std::basic_syncstream` class has a member function called `get_wrapped()`,
    which returns a pointer to the wrapped stream buffer. This can be used to construct
    a new instance of the `std::basic_syncstream` class so that you can sequence content
    to the same output stream through different instances of `std::basic_osyncstream`.
    The next snippet demonstrates how this works:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::basic_syncstream` 类有一个名为 `get_wrapped()` 的成员函数，它返回指向包装流缓冲区的指针。这可以用来构造
    `std::basic_syncstream` 类的新实例，以便你可以通过 `std::basic_osyncstream` 的不同实例将内容序列到相同的输出流。下面的代码片段演示了它是如何工作的：'
- en: '[PRE122]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Again, the first part of the example is unchanged. However, here we have a
    second inner block where a second instance of `std::osyncstream` is constructed
    with a pointer to the stream buffer returned by the call to `syncstr`''s `get_wrapped()`
    member function. At the line marked with **[2]**, none of the two instances of
    `std::osyncstream` has been destroyed; therefore, the content of the `str` string
    stream is still empty. The first sync stream to be destroyed is `syncstr2`, at
    the end of the second inner block. Therefore, on the line marked with **[3]**,
    the content of the string stream will be `"demo part 3"`. Then, the first sync
    stream object, `syncstr`, goes out of scope at the end of the first inner block,
    adding the text `"sync stream demo"` to the string stream. The output of running
    this program is the following:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，示例的第一部分没有改变。然而，这里我们有一个第二个内部块，其中使用 `syncstr` 的 `get_wrapped()` 成员函数返回的流缓冲区指针构造了第二个
    `std::osyncstream` 实例。在标记为 **[2]** 的行，两个 `std::osyncstream` 实例都尚未被销毁；因此，`str`
    字符串流的内容仍然是空的。第一个要销毁的同步流是 `syncstr2`，在第二个内部块的末尾。因此，在标记为 **[3]** 的行，字符串流的内容将是 `"demo
    part 3"`。然后，第一个同步流对象 `syncstr` 在第一个内部块的末尾超出作用域，将文本 `"sync stream demo"` 添加到字符串流中。运行此程序的输出如下：
- en: '[PRE123]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Although in all these examples we defined named variables, you can write to
    an output stream using a temporary sync stream too, as shown below:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在所有这些示例中我们都定义了命名变量，但你也可以使用临时同步流向输出流写入，如下所示：
- en: '[PRE124]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: See also
  id: totrans-700
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Working with threads*, to learn about the `std::thread` class and the basic
    operations for working with threads in C++'
  id: totrans-701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与线程一起工作*，了解 `std::thread` 类以及 C++ 中处理线程的基本操作'
- en: '*Using joinable threads and cancellation mechanisms*, to learn about the C++20
    `std::jthread` class, which manages a thread of execution and automatically joins
    during its destruction, as well as the improved mechanisms for stopping the execution
    of threads'
  id: totrans-702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用可连接的线程和取消机制*，了解 C++20 的 `std::jthread` 类，该类管理执行线程并在其销毁时自动连接，以及改进的停止线程执行机制'
- en: Learn more on Discord
  id: totrans-703
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://discord.gg/7xRaTCeEhx](Chapter_08.xhtml)'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.gg/7xRaTCeEhx](Chapter_08.xhtml)'
- en: '![](img/QR_Code2659294082093549796.png)'
  id: totrans-706
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code2659294082093549796.png)'
