- en: Learning Modern Core Language Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习现代核心语言特性
- en: 'The recipes included in this chapter are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下配方：
- en: Using auto whenever possible
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能使用auto
- en: Creating type aliases and alias templates
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建类型别名和别名模板
- en: Understanding uniform initialization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解统一初始化
- en: Understanding the various forms of non-static member initialization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解各种形式的非静态成员初始化
- en: Controlling and querying object alignment
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制和查询对象对齐
- en: Using scoped enumerations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用作用域枚举
- en: Using override and final for virtual methods
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用override和final来定义虚方法
- en: Using range-based for loops to iterate on a range
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于范围的for循环迭代范围
- en: Enabling range-based for loops for custom types
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为自定义类型启用基于范围的for循环
- en: Using explicit constructors and conversion operators to avoid implicit conversion
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用显式构造函数和转换运算符来避免隐式转换
- en: Using unnamed namespaces instead of static globals
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用未命名命名空间代替静态全局变量
- en: Using inline namespaces for symbol versioning
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内联命名空间进行符号版本控制
- en: Using structured bindings to handle multi-return values
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用结构化绑定处理多返回值
- en: Using auto whenever possible
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尽可能使用auto
- en: Automatic type deduction is one of the most important and widely used features
    in modern C++. The new C++ standards have made it possible to use `auto` as a
    placeholder for types in various contexts and let the compiler deduce the actual
    type. In C++11, `auto` can be used for declaring local variables and for the return
    type of a function with a trailing return type. In C++14, `auto` can be used for
    the return type of a function without specifying a trailing type and for parameter
    declarations in lambda expressions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 自动类型推断是现代C++中最重要和广泛使用的特性之一。新的C++标准使得在各种情况下使用`auto`作为类型的占位符并让编译器推断实际类型成为可能。在C++11中，`auto`可用于声明局部变量和带有尾随返回类型的函数的返回类型。在C++14中，`auto`可用于不指定尾随类型的函数的返回类型以及lambda表达式中的参数声明。
- en: Future standard versions are likely to expand the use of `auto` to even more
    cases. The use of `auto` in these contexts has several important benefits. Developers
    should be aware of them, and prefer `auto` whenever possible. An actual term was
    coined for this by Andrei Alexandrescu and promoted by Herb Sutter--*almost always
    auto* (*AAA*).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 未来的标准版本可能会扩展`auto`的使用范围。在这些情况下使用`auto`有几个重要的好处。开发人员应该意识到这一点，并尽可能使用`auto`。Andrei
    Alexandrescu提出了一个实际的术语，并由Herb Sutter推广--*almost always auto* (*AAA*)。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Consider using `auto` as a placeholder for the actual type in the following
    situations:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在以下情况下使用`auto`作为实际类型的占位符：
- en: 'To declare local variables with the form `auto name = expression` when you
    do not want to commit to a specific type:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用形式为`auto name = expression`的局部变量，当你不想承诺特定类型时：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To declare local variables with the `auto name = type-id { expression }` form
    when you need to commit to a specific type:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`auto name = type-id { expression }`形式声明局部变量时，当你需要承诺特定类型时：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To declare named lambda functions, with the form `auto name = lambda-expression`,
    unless the lambda needs to be passed or return to a function:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明命名的lambda函数，形式为`auto name = lambda-expression`，除非lambda需要传递或返回给函数：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To declare lambda parameters and return values:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明lambda参数和返回值：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To declare function return type when you don''t want to commit to a specific
    type:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不想承诺特定类型时声明函数返回类型：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The `auto` specifier is basically a placeholder for an actual type. When using
    `auto`, the compiler deduces the actual type from the following instances:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`auto`修饰符基本上是实际类型的占位符。使用`auto`时，编译器从以下实例中推断出实际类型：'
- en: From the type of the expression used to initialize a variable, when `auto` is
    used to declare variables.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从用于初始化变量的表达式的类型，当使用`auto`声明变量时。
- en: From the trailing return type or the type of the return expression of a function,
    when `auto` is used as a placeholder for the return type of a function.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从函数的尾随返回类型或返回表达式的类型，当`auto`用作函数的返回类型的占位符时。
- en: In some cases, it is necessary to commit to a specific type. For instance, in
    the preceding example, the compiler deduces the type of `s` to be `char const
    *`. If the intention was to have a `std::string`, then the type must be specified
    explicitly. Similarly, the type of `v` was deduced as `std::initializer_list<int>`.
    However, the intention could be to have a `std::vector<int>`. In such cases, the
    type must be specified explicitly on the right side of the assignment.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，有必要承诺特定类型。例如，在前面的例子中，编译器推断`s`的类型为`char const *`。如果意图是要有一个`std::string`，那么类型必须明确指定。类似地，`v`的类型被推断为`std::initializer_list<int>`。然而，意图可能是要有一个`std::vector<int>`。在这种情况下，类型必须在赋值的右侧明确指定。
- en: 'There are some important benefits of using the auto specifier instead of actual
    types; the following is a list of, perhaps, the most important ones:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用auto修饰符而不是实际类型有一些重要的好处；以下是可能最重要的一些：
- en: It is not possible to leave a variable uninitialized. This is a common mistake
    that developers do when declaring variables specifying the actual type, but it
    is not possible with `auto` that requires an initialization of the variable in
    order to deduce the type.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可能让变量未初始化。这是一个常见的错误，开发人员在声明变量时指定实际类型时会犯这个错误，但是对于需要初始化变量以推断类型的`auto`来说是不可能的。
- en: 'Using `auto` ensures that you always use the correct type and that implicit
    conversion will not occur. Consider the following example where we retrieve the
    size of a vector to a local variable. In the first case, the type of the variable
    is `int`, though the `size()` method returns `size_t`. That means an implicit
    conversion from `size_t` to `int` will occur. However, using `auto` for the type
    will deduce the correct type, that is, `size_t`:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`auto`可以确保你始终使用正确的类型，不会发生隐式转换。考虑以下示例，我们将向局部变量检索向量的大小。在第一种情况下，变量的类型是`int`，尽管`size()`方法返回`size_t`。这意味着将发生从`size_t`到`int`的隐式转换。然而，使用`auto`类型将推断出正确的类型，即`size_t`：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using `auto` promotes good object-oriented practices, such as preferring interfaces
    over implementations. The lesser the number of types specified the more generic
    the code is and more open to future changes, which is a fundamental principle
    of object-oriented programming.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`auto`有助于促进良好的面向对象的实践，比如更喜欢接口而不是实现。指定的类型越少，代码就越通用，更容易进行未来的更改，这是面向对象编程的基本原则。
- en: It means less typing and less concern for actual types that we don't care about
    anyways. It is very often that even though we explicitly specify the type, we
    don't actually care about it. A very common case is with iterators, but one can
    think of many more. When you want to iterate over a range, you don't care about
    the actual type of the iterator. You are only interested in the iterator itself;
    so, using `auto` saves time used for typing possibly long names and helps you
    focus on actual code and not type names. In the following example, in the first
    `for` loop, we explicitly use the type of the iterator. It is a lot of text to
    type, the long statements can actually make the code less readable, and you also
    need to know the type name that you actually don't care about. The second loop
    with the `auto` specifier looks simpler and saves you from typing and caring about
    actual types.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这意味着更少的输入和更少关心我们根本不关心的实际类型。经常情况下，即使我们明确指定了类型，我们实际上并不关心它。迭代器就是一个非常常见的例子，但还有很多其他情况。当你想要遍历一个范围时，你并不关心迭代器的实际类型。你只对迭代器本身感兴趣；因此，使用`auto`可以节省输入可能很长的名称所用的时间，并帮助你专注于实际的代码而不是类型名称。在下面的例子中，在第一个`for`循环中，我们明确使用了迭代器的类型。这是很多文本需要输入，长语句实际上可能使代码不太可读，而且你还需要知道你实际上并不关心的类型名称。而使用`auto`关键字的第二个循环看起来更简单，可以节省你的输入和关心实际类型的时间。
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Declaring variables with `auto` provides a consistent coding style with the
    type always in the right-hand side. If you allocate objects dynamically, you need
    to write the type both on the left and right side of the assignment, for example,
    `int* p = new int(42)`. With `auto`, the type is specified only once on the right
    side.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`auto`声明变量提供了一致的编码风格，类型总是在右侧。如果动态分配对象，你需要在赋值的左右两侧都写上类型，例如`int* p = new int(42)`。而使用`auto`，类型只在右侧指定一次。
- en: 'However, there are some gotchas when using `auto`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用`auto`时有一些需要注意的地方：
- en: 'The `auto` specifier is only a placeholder for the type, not for the `const`/`volatile`
    and references specifiers. If you need a `const`/`volatile` and/or reference type,
    then you need to specify them explicitly. In the following example, `foo.get()`
    returns a reference to `int`; when variable `x` is initialized from the return
    value, the type deduced by the compiler is `int`, and not `int&`. Therefore, any
    change to `x` will not propagate to `foo.x_`. In order to do so, one should use
    `auto&`:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auto`关键字只是类型的占位符，而不是`const`/`volatile`和引用限定符的占位符。如果需要`const`/`volatile`和/或引用类型，那么需要显式指定它们。在下面的例子中，`foo.get()`返回一个`int`的引用；当变量`x`从返回值初始化时，编译器推断的类型是`int`，而不是`int&`。因此，对`x`的任何更改都不会传播到`foo.x_`。为了做到这一点，应该使用`auto&`：'
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It is not possible to use `auto` for types that are not moveable:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可能对不可移动的类型使用`auto`：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It is not possible to use auto for multi-word types, such as `long long`, `long
    double`, or `struct foo`. However, in the first case, the possible workarounds
    are to use literals or type aliases; as for the second, using `struct`/`class`
    in that form is only supported in C++ for C compatibility and should be avoided
    anyways:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可能使用`auto`来表示多个单词的类型，比如`long long`、`long double`或`struct foo`。然而，在第一种情况下，可能的解决方法是使用字面量或类型别名；至于第二种情况，使用`struct`/`class`的形式只在C++中支持C兼容性，并且应该尽量避免：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you use the `auto` specifier but still need to know the type, you can do
    so in any IDE by putting the cursor over a variable, for instance. If you leave
    the IDE, however, that is not possible anymore, and the only way to know the actual
    type is to deduce it yourself from the initialization expression, which could
    probably mean searching through the code for function return types.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用`auto`关键字但仍然需要知道类型，你可以在任何IDE中将光标放在变量上来查看类型。然而，如果你离开IDE，那就不可能了，唯一的方法是从初始化表达式中自己推断出类型，这可能意味着需要在代码中搜索函数返回类型。
- en: 'The `auto` can be used to specify the return type from a function. In C++11,
    this requires a trailing return type in the function declaration. In C++14, this
    has been relaxed, and the type of the return value is deduced by the compiler
    from the `return` expression. If there are multiple return values they should
    have the same type:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`auto`可以用来指定函数的返回类型。在C++11中，这需要在函数声明中使用尾返回类型。在C++14中，这已经放宽，返回值的类型由编译器从`return`表达式中推断出来。如果有多个返回值，它们应该有相同的类型：'
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As mentioned earlier, `auto` does not retain `const`/`volatile` and reference
    qualifiers. This leads to problems with `auto` as a placeholder for the return
    type from a function. To explain this, let us consider the preceding example with
    `foo.get()`. This time we have a wrapper function called `proxy_get()` that takes
    a reference to a `foo`, calls `get()`, and returns the value returned by `get()`,
    which is an `int&`. However, the compiler will deduce the return type of `proxy_get()`
    as being `int`, not `int&`. Trying to assign that value to an `int&` fails with
    an error:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`auto`不保留`const`/`volatile`和引用限定符。这导致了`auto`作为函数返回类型的占位符出现问题。为了解释这一点，让我们考虑前面提到的`foo.get()`的例子。这次我们有一个名为`proxy_get()`的包装函数，它接受一个`foo`的引用，调用`get()`，并返回`get()`返回的值，即`int&`。然而，编译器会推断`proxy_get()`的返回类型为`int`，而不是`int&`。尝试将该值分配给`int&`会导致错误：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To fix this, we need to actually return `auto&`. However, this is a problem
    with templates and perfect forwarding the return type without knowing whether
    that is a value or a reference. The solution to this problem in C++14 is `decltype(auto)`
    that will correctly deduce the type:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，我们需要实际返回`auto&`。然而，这是一个关于模板和完美转发返回类型的问题，而不知道这是一个值还是一个引用。在C++14中解决这个问题的方法是`decltype(auto)`，它将正确推断类型：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The last important case where `auto` can be used is with lambdas. As of C++14,
    both lambda return type and lambda parameter types can be `auto`. Such a lambda
    is called a *generic lambda* because the closure type defined by the lambda has
    a templated call operator. The following shows a generic lambda that takes two
    `auto` parameters and returns the result of applying `operator+` on the actual
    types:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`auto`可以用于lambda的另一个重要情况是。从C++14开始，lambda的返回类型和参数类型都可以是`auto`。这样的lambda被称为*通用lambda*，因为lambda定义的闭包类型具有模板化的调用运算符。以下是一个接受两个`auto`参数并返回应用于实际类型的`operator+`结果的通用lambda的示例：'
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This lambda can be used to add anything for which the `operator+` is defined.
    In the following example, we use the lambda to add two integers and to concatenate
    to `std::string` objects (using the C++14 user-defined literal `operator ""s`):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个lambda可以用来添加任何定义了`operator+`的内容。在下面的例子中，我们使用lambda来添加两个整数并连接两个`std::string`对象（使用C++14用户定义的字面量`operator
    ""s`）：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: See also
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Creating type aliases and alias templates*'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建类型别名和别名模板*'
- en: '*Understanding uniform initialization*'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*理解统一初始化*'
- en: Creating type aliases and alias templates
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建类型别名和别名模板
- en: In C++, it is possible to create synonyms that can be used instead of a type
    name. This is achieved by creating a `typedef` declaration. This is useful in
    several cases, such as creating shorter or more meaningful names for a type or
    names for function pointers. However, `typedef` declarations cannot be used with
    templates to create `template type aliases`. An `std::vector<T>`, for instance,
    is not a type (`std::vector<int>` is a type), but a sort of family of all types
    that can be created when the type placeholder `T` is replaced with an actual type.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，可以创建可以代替类型名称的同义词。这是通过创建`typedef`声明实现的。这在几种情况下很有用，比如为类型创建更短或更有意义的名称，或者为函数指针创建名称。然而，`typedef`声明不能与模板一起用于创建`模板类型别名`。例如，`std::vector<T>`不是一个类型（`std::vector<int>`是一个类型），而是一种当类型占位符`T`被实际类型替换时可以创建的所有类型的一种家族。
- en: In C++11, a type alias is a name for another already declared type, and an alias
    template is a name for another already declared template. Both of these types
    of aliases are introduced with a new `using` syntax.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11中，类型别名是另一个已声明类型的名称，而别名模板是另一个已声明模板的名称。这两种类型的别名都是用新的`using`语法引入的。
- en: How to do it...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Create type aliases with the form `using identifier = type-id` as in the following
    examples:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下形式创建类型别名`using identifier = type-id`，如下例所示：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create alias templates with the form `template<template-params-list> identifier
    = type-id` as in the following examples:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下形式创建别名模板`template<template-params-list> identifier = type-id`，如下例所示：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For consistency and readability, you should do the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了一致性和可读性，您应该做到以下几点：
- en: Not mix `typedef` and `using` declarations for creating aliases.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要混合使用`typedef`和`using`声明来创建别名。
- en: Use the `using` syntax to create names of function pointer types.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`using`语法创建函数指针类型的名称。
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A `typedef` declaration introduces a synonym (or an alias in other words) for
    a type. It does not introduce another type (like a `class`, `struct`, `union`,
    or `enum` declaration). Type names introduced with a `typedef` declaration follow
    the same hiding rules as identifier names. They can also be redeclared, but only
    to refer to the same type (therefore, you can have valid multiple `typedef` declarations
    that introduce the same type name synonym in a translation unit as long as it
    is a synonym for the same type). The following are typical examples of `typedef`
    declarations:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`typedef`声明引入了一个类型的同义词（或者换句话说是别名）。它不引入另一个类型（比如`class`、`struct`、`union`或`enum`声明）。使用`typedef`声明引入的类型名称遵循与标识符名称相同的隐藏规则。它们也可以被重新声明，但只能引用相同的类型（因此，只要它是同一个类型的同义词，就可以在一个翻译单元中有多个有效的`typedef`声明）。以下是`typedef`声明的典型示例：'
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A type alias declaration is equivalent to a `typedef` declaration. It can appear
    in a block scope, class scope, or namespace scope. According to C++11 paragraph
    7.1.3.2:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 类型别名声明等同于`typedef`声明。它可以出现在块作用域、类作用域或命名空间作用域。根据C++11段落7.1.3.2：
- en: A typedef-name can also be introduced by an alias-declaration. The identifier
    following the using keyword becomes a typedef-name and the optional attribute-specifier-seq
    following the identifier appertains to that typedef-name. It has the same semantics
    as if it were introduced by the typedef specifier. In particular, it does not
    define a new type and it shall not appear in the type-id.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: typedef名称也可以通过别名声明引入。在使用关键字后面的标识符成为typedef名称，后面的可选属性说明符序列与该typedef名称相关。它具有与通过typedef说明符引入的语义相同。特别是，它不定义新类型，也不应出现在类型标识符中。
- en: An alias-declaration is, however, more readable and more clear about the actual
    type that is aliased when it comes to creating aliases for array types and function
    pointer types. In the examples from the *How to do it...* section, it is easily
    understandable that `array_t` is a name for the type array of 10 integers, and
    `fn` is a name for a function type that takes two parameters of type `byte` and
    `double` and returns `void`. That is also consistent with the syntax for declaring
    `std::function` objects (for example, `std::function<void(byte, double)> f`).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，别名声明在创建数组类型和函数指针类型的别名时更易读且更清晰。在*如何做到...*部分的示例中，很容易理解`array_t`是10个整数的数组类型的名称，`fn`是一个接受两个`byte`和`double`类型参数并返回`void`的函数类型的名称。这也与声明`std::function`对象的语法一致（例如，`std::function<void(byte,
    double)> f`）。
- en: The driving purpose of the new syntax is to define alias templates. These are
    templates which, when specialized, are equivalent to the result of substituting
    the template arguments of the alias template for the template parameters in the
    `type-id`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 新语法的驱动目的是定义别名模板。这些模板在特化时，等同于将别名模板的模板参数替换为`type-id`中的模板参数的结果。
- en: 'It is important to take note of the following things:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意以下事项：
- en: Alias templates cannot be partially or explicitly specialized.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 别名模板不能部分或显式地进行特化。
- en: Alias templates are never deduced by template argument deduction when deducing
    a template parameter.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当推断模板参数时，别名模板永远不会通过模板参数推断进行推断。
- en: The type produced when specializing an alias template is not allowed to directly
    or indirectly make use of its own type.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当特化别名模板时产生的类型不允许直接或间接地使用其自身类型。
- en: Understanding uniform initialization
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解统一初始化
- en: Brace-initialization is a uniform method for initializing data in C++11\. For
    this reason, it is also called *uniform initialization*. It is arguably one of
    the most important features from C++11 that developers should understand and use.
    It removes previous distinctions between initializing fundamental types, aggregate
    and non-aggregate types, and arrays and standard containers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 花括号初始化是C++11中初始化数据的统一方法。因此，它也被称为*统一初始化*。这可以说是C++11中开发人员应该理解和使用的最重要的功能之一。它消除了以前在初始化基本类型、聚合和非聚合类型以及数组和标准容器之间的区别。
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For continuing with this recipe, you need to be familiar with direct initialization
    that initializes an object from an explicit set of constructor arguments and copy
    initialization that initializes an object from another object. The following is
    a simple example of both types of initialization, but for further details, you
    should see additional resources:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要继续使用这个示例，你需要熟悉直接初始化（从显式的构造函数参数集初始化对象）和复制初始化（从另一个对象初始化对象）。以下是这两种初始化类型的简单示例，但是要了解更多细节，你应该查看其他资源：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How to do it...
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: To uniformly initialize objects regardless of their type, use the brace-initialization
    form `{}` that can be used for both direct initialization and copy initialization.
    When used with brace initialization, these are called direct list and copy list
    initialization.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了统一初始化对象，无论其类型如何，都可以使用花括号初始化形式`{}`，它可以用于直接初始化和复制初始化。在使用花括号初始化时，这些被称为直接列表初始化和复制列表初始化。
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Examples of uniform initialization are as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 统一初始化的示例如下：
- en: 'Standard containers:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准容器：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Dynamically allocated arrays:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态分配的数组：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Arrays:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Built-in types:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置类型：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'User-defined types:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户定义的类型：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'User-defined POD types:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户定义的POD类型：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '工作原理... '
- en: 'Before C++11 objects required different types of initialization based on their
    type:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11之前，对象根据其类型需要不同类型的初始化：
- en: 'Fundamental types could be initialized using assignment:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本类型可以使用赋值进行初始化：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Class objects could also be initialized using assignment from a single value
    if they had a conversion constructor (prior to C++11, a constructor with a single
    parameter was called a *conversion constructor*):'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类对象具有转换构造函数（在C++11之前，具有单个参数的构造函数被称为*转换构造函数*），也可以使用赋值进行初始化：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Non-aggregate classes could be initialized with parentheses (the functional
    form) when arguments were provided and only without any parentheses when default
    initialization was performed (call to the default constructor). In the next example,
    `foo` is the structure defined in the *How to do it...* section:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非聚合类可以在提供参数时使用括号（函数形式）进行初始化，只有在执行默认初始化（调用默认构造函数）时才可以不使用任何括号。在下一个示例中，`foo`是在*如何做...*部分中定义的结构：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Aggregate and POD types could be initialized with brace-initialization. In
    the next example, `bar` is the structure defined in the *How to do it...* section:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合和POD类型可以使用花括号初始化进行初始化。在下一个示例中，`bar`是在*如何做...*部分中定义的结构：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Apart from the different methods of initializing the data, there are also some
    limitations. For instance, the only way to initialize a standard container was
    to first declare an object and then insert elements into it; vector was an exception
    because it is possible to assign values from an array that can be prior initialized
    using aggregate initialization. On the other hand, however, dynamically allocated
    aggregates could not be initialized directly.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 除了初始化数据的不同方法外，还有一些限制。例如，初始化标准容器的唯一方法是首先声明一个对象，然后将元素插入其中；vector是一个例外，因为可以从可以使用聚合初始化进行先期初始化的数组中分配值。另一方面，动态分配的聚合体不能直接初始化。
- en: All the examples in the *How to do it...* section use direct initialization,
    but copy initialization is also possible with brace-initialization. The two forms,
    direct and copy initialization, may be equivalent in most cases, but copy initialization
    is less permissive because it does not consider explicit constructors in its implicit
    conversion sequence that must produce an object directly from the initializer,
    whereas direct initialization expects an implicit conversion from the initializer
    to an argument of the constructor. Dynamically allocated arrays can only be initialized
    using direct initialization.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*如何做...*部分中的所有示例都使用了直接初始化，但是使用花括号初始化也可以进行复制初始化。这两种形式，直接初始化和复制初始化，在大多数情况下可能是等效的，但是复制初始化不够宽松，因为它在其隐式转换序列中不考虑显式构造函数，必须直接从初始化程序产生对象，而直接初始化期望从初始化程序到构造函数的参数的隐式转换。动态分配的数组只能使用直接初始化进行初始化。'
- en: Of the classes shown in the preceding examples, `foo` is the one class that
    has both a default constructor and a constructor with parameters. To use the default
    constructor to perform default initialization, we need to use empty braces, that
    is, `{}`. To use the constructor with parameters, we need to provide the values
    for all the arguments in braces `{}`. Unlike non-aggregate types where default
    initialization means invoking the default constructor, for aggregate types, default
    initialization means initializing with zeros.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中显示的类中，`foo`是唯一既有默认构造函数又有带参数的构造函数的类。要使用默认构造函数执行默认初始化，我们需要使用空括号，即`{}`。要使用带参数的构造函数，我们需要在括号`{}`中提供所有参数的值。与非聚合类型不同，其中默认初始化意味着调用默认构造函数，对于聚合类型，默认初始化意味着用零初始化。
- en: Initialization of standard containers, such as the vector and the map also shown
    above, is possible because all standard containers have an additional constructor
    in C++11 that takes an argument of type `std::initializer_list<T>`. This is basically
    a lightweight proxy over an array of elements of type `T const`. These constructors
    then initialize the internal data from the values in the initializer list.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11中，初始化标准容器（如上面显示的向量和映射）是可能的，因为所有标准容器都有一个额外的构造函数，该构造函数接受类型为`std::initializer_list<T>`的参数。这基本上是类型为`T
    const`的元素数组的轻量级代理。然后，这些构造函数从初始化列表中的值初始化内部数据。
- en: 'The way the initialization using `std::initializer_list` works is the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`std::initializer_list`进行初始化的方式如下：
- en: The compiler resolves the types of elements in the initialization list (all
    elements must have the same type).
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器解析初始化列表中元素的类型（所有元素必须具有相同类型）。
- en: The compiler creates an array with the elements in the initializer list.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器创建一个具有初始化列表中元素的数组。
- en: The compiler creates an `std::initializer_list<T>` object to wrap the previously
    created array.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器创建一个`std::initializer_list<T>`对象来包装先前创建的数组。
- en: The `std::initializer_list<T>` object is passed as an argument to the constructor.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::initializer_list<T>`对象作为参数传递给构造函数。'
- en: 'An initializer list always takes precedence over other constructors where brace-initialization
    is used. If such a constructor exists for a class, it will be called when brace-initialization
    is performed:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化列表始终优先于其他构造函数，其中使用大括号初始化。如果类存在这样的构造函数，那么在执行大括号初始化时将调用它：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The precedence rule applies to any function, not just constructors. In the
    following example, two overloads of the same function exist. Calling the function
    with an initializer list resolves to a call to the overload with an `std::initializer_list`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 优先规则适用于任何函数，而不仅仅是构造函数。在下面的示例中，存在相同函数的两个重载。使用初始化列表调用函数将解析为调用具有`std::initializer_list`的重载：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This, however, has the potential of leading to bugs. Let''s take, for example,
    the vector type. Among the constructors of the vector, there is one that has a
    single argument representing the initial number of elements to be allocated and
    another one that has an `std::initializer_list` as an argument. If the intention
    is to create a vector with a preallocated size, using the brace-initialization
    will not work, as the constructor with the `std::initializer_list` will be the
    best overload to be called:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这可能导致错误。例如，考虑向量类型。在向量的构造函数中，有一个构造函数有一个表示要分配的初始元素数量的单个参数，另一个构造函数有一个`std::initializer_list`作为参数。如果意图是创建一个预分配大小的向量，使用大括号初始化将不起作用，因为具有`std::initializer_list`的构造函数将是要调用的最佳重载：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The preceding code does not create a vector with five elements, but a vector
    with one element with a value 5\. To be able to actually create a vector with
    five elements, initialization with the parentheses form must be used:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码不会创建一个具有五个元素的向量，而是创建一个具有一个值为5的元素的向量。要实际创建一个具有五个元素的向量，必须使用括号形式的初始化：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Another thing to note is that brace-initialization does not allow narrowing
    conversion. According to the C++ standard (refer to paragraph 8.5.4 of the standard),
    a narrowing conversion is an implicit conversion:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的是，大括号初始化不允许缩小转换。根据C++标准（参见标准的第8.5.4段），缩小转换是一种隐式转换：
- en: '- From a floating-point type to an integer type'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '- 从浮点类型到整数类型'
- en: '- From long double to double or float, or from double to float, except where
    the source is a constant expression and the actual value after conversion is within
    the range of values that can be represented (even if it cannot be represented
    exactly)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '- 从长双精度到双精度或浮点数，或从双精度到浮点数，除非源是常量表达式，并且转换后的实际值在可以表示的值范围内（即使不能精确表示）'
- en: '- From an integer type or unscoped enumeration type to a floating-point type,
    except where the source is a constant expression and the actual value after conversion
    will fit into the target type and will produce the original value when converted
    to its original type'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '- 从整数类型或未作用域的枚举类型到浮点类型，除非源是常量表达式，并且转换后的实际值适合目标类型，并且在转换回原始类型时会产生原始值'
- en: '- From an integer type or unscoped enumeration type to an integer type that
    cannot represent all the values of the original type, except where the source
    is a constant expression and the actual value after conversion will fit into the
    target type and will produce the original value when converted to its original
    type.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '- 从整数类型或未作用域的枚举类型到不能表示原始类型所有值的整数类型，除非源是常量表达式，并且转换后的实际值适合目标类型，并且在转换回原始类型时会产生原始值。'
- en: 'The following declarations trigger compiler errors because they require a narrowing
    conversion:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下声明触发编译器错误，因为它们需要缩小转换：
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To fix the error, an explicit conversion must be done:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要修复错误，必须进行显式转换：
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: A brace-initialization list is not an expression and does not have a type. Therefore,
    `decltype` cannot be used on a brace-init list, and template type deduction cannot
    deduce the type that matches a brace-init list.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 花括号初始化列表不是一个表达式，也没有类型。因此，`decltype`不能用于花括号初始化列表，模板类型推断也不能推断与花括号初始化列表匹配的类型。
- en: There's more
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: The following sample shows several examples of direct-list-initialization and
    copy-list-initialization. In C++11, the deduced type of all these expressions
    is `std::initializer_list<int>`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了直接列表初始化和复制列表初始化的几个例子。在C++11中，所有这些表达式的推断类型都是`std::initializer_list<int>`。
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'C++17 has changed the rules for list initialization, differentiating between
    the direct- and copy-list-initialization. The new rules for type deduction are
    as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: C++17已经改变了列表初始化的规则，区分了直接列表初始化和复制列表初始化。类型推断的新规则如下：
- en: for copy list initialization auto deduction will deduce a `std::initializer_list<T>`
    if all elements in the list have the same type, or be ill-formed.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于复制列表初始化，如果列表中的所有元素具有相同类型，auto推断将推断出一个`std::initializer_list<T>`，否则会形成错误。
- en: for direct list initialization auto deduction will deduce a `T` if the list
    has a single element, or be ill-formed if there is more than one element.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于直接列表初始化，如果列表只有一个元素，auto推断会推断出一个`T`，如果有多个元素，则会形成错误。
- en: 'Base on the new rules, the previous examples would change as follows: `a` and
    `c` are deduced as `std::initializer_list<int>`; `b` is deduced as an `int`; `d`,
    which uses direct initialization and has more than one value in the brace-init-list,
    triggers a compiler error.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 根据新规则，前面的示例将会发生变化：`a`和`c`被推断为`std::initializer_list<int>`；`b`被推断为`int`；`d`使用直接初始化，在花括号初始化列表中有多个值，会触发编译错误。
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: See also
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Using auto whenever possible*'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*尽可能使用auto*'
- en: '*Understanding the various forms of non-static member initialization*'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解非静态成员初始化的各种形式
- en: Understanding the various forms of non-static member initialization
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解非静态成员初始化的各种形式
- en: Constructors are a place where non-static class member initialization is done.
    Many developers prefer assignments in the constructor body. Aside from the several
    exceptional cases when that is actually necessary, initialization of non-static
    members should be done in the constructor's initializer list or, as of C++11,
    using default member initialization when they are declared in the class. Prior
    to C++11, constants and non-constant non-static data members of a class had to
    be initialized in the constructor. Initialization on declaration in a class was
    only possible for static constants. As we will see further, this limitation was removed
    in C++11 that allows initialization of non-statics in the class declaration. This
    initialization is called *default member initialization* and is explained in the
    next sections.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是进行非静态类成员初始化的地方。许多开发人员更喜欢在构造函数体中进行赋值。除了几种特殊情况需要在构造函数体中进行赋值之外，非静态成员的初始化应该在构造函数的初始化列表中进行，或者在C++11中，当它们在类中声明时使用默认成员初始化。在C++11之前，类的常量和非常量非静态数据成员必须在构造函数中初始化。在类中声明时初始化只对静态常量可能。正如我们将在后面看到的，C++11消除了这种限制，允许在类声明中初始化非静态成员。这种初始化称为*默认成员初始化*，并在接下来的章节中进行解释。
- en: This recipe will explore the ways the non-static member initialization should
    be done.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 本文将探讨非静态成员初始化应该如何进行的方式。
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To initialize non-static members of a class you should:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化类的非静态成员，应该：
- en: Use default member initialization for providing default values for members of
    classes with multiple constructors that would use a common initializer for those
    members (see `[3]` and `[4]` in the following code).
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于具有多个构造函数的类的成员提供默认值，应使用默认成员初始化来为这些成员提供公共初始化器（见以下代码中的`[3]`和`[4]`）。
- en: Use default member initialization for constants, both static and non-static
    (see `[1]` and `[2]` in the following code).
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于常量，无论是静态的还是非静态的，应使用默认成员初始化（见以下代码中的`[1]`和`[2]`）。
- en: Use the constructor initializer list to initialize members that don't have default
    values, but depend on constructor parameters (see `[5]` and `[6]` in the following
    code).
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用构造函数初始化列表来初始化没有默认值但依赖于构造函数参数的成员（见以下代码中的`[5]`和`[6]`）。
- en: Use assignment in constructors when the other options are not possible (examples
    include initializing data members with pointer `this`, checking constructor parameter
    values, and throwing exceptions prior to initializing members with those values
    or self-references of two non-static data members).
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当其他选项不可行时，在构造函数中使用赋值（例如使用指针`this`初始化数据成员，检查构造函数参数值，并在使用这些值或两个非静态数据成员的自引用初始化成员之前抛出异常）。
- en: 'The following example shows these forms of initialization:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了这些初始化形式：
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works...
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Non-static data members are supposed to be initialized in the constructor''s
    initializer list as shown in the following example:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 应该在构造函数的初始化列表中初始化非静态数据成员，如下例所示：
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Many developers, however, do not use the initializer list, but prefer assignments
    in the constructor's body, or even mix assignments and the initializer list. That
    could be for several reasons--for larger classes with many members, the constructor
    assignments may look easier to read than long initializer lists, perhaps split
    on many lines, or it could be because they are familiar with other programming
    languages that don't have an initializer list or because, unfortunately, for various
    reasons they don't even know about it.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，许多开发人员并不使用初始化列表，而更喜欢在构造函数体中进行赋值，甚至混合使用赋值和初始化列表。这可能是由于几个原因--对于具有许多成员的较大类，构造函数赋值可能看起来比长长的初始化列表更容易阅读，也许分成许多行，或者可能是因为他们熟悉其他没有初始化列表的编程语言，或者不幸的是，由于各种原因，他们甚至不知道它的存在。
- en: It is important to note that the order in which non-static data members are
    initialized is the order in which they were declared in the class definition,
    and not the order of their initialization in a constructor initializer list. On
    the other hand, the order in which non-static data members are destroyed is the
    reversed order of construction.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，非静态数据成员初始化的顺序是它们在类定义中声明的顺序，而不是它们在构造函数初始化列表中初始化的顺序。另一方面，非静态数据成员销毁的顺序是构造的相反顺序。
- en: 'Using assignments in the constructor is not efficient, as this can create temporary
    objects that are later discarded. If not initialized in the initializer list,
    non-static members are initialized via their default constructor and then, when
    assigned a value in the constructor''s body, the assignment operator is invoked.
    This can lead to inefficient work if the default constructor allocates a resource
    (such as memory or a file) and that has to be deallocated and reallocated in the
    assignment operator:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中使用赋值是不高效的，因为这可能会创建稍后被丢弃的临时对象。如果在初始化列表中未初始化非静态成员，则这些成员将通过它们的默认构造函数进行初始化，然后在构造函数体中赋值时调用赋值运算符。如果默认构造函数分配资源（如内存或文件），并且必须在赋值运算符中进行释放和重新分配，则可能会导致效率低下：
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The preceding code produces the following output showing how data member `f`
    is first default initialized and then assigned a new value:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码产生以下输出，显示数据成员`f`首先进行默认初始化，然后赋予一个新值：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Changing the initialization from the assignment in the constructor body to
    the initializer list replaces the calls to the default constructor plus assignment
    operator with a call to the copy constructor:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 将初始化从构造函数体中的赋值更改为初始化列表将用复制构造函数替换默认构造函数加赋值运算符的调用：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Adding the preceding line of code produces the following output:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 添加前面的代码行会产生以下输出：
- en: '[PRE43]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'For those reasons, at least for other types than the built-in types (such as
    `bool`, `char`, `int`, `float`, `double` or pointers), you should prefer the constructor
    initializer list. However, to be consistent with your initialization style, you
    should always prefer the constructor initializer list when that is possible. There
    are several situations when using the initializer list is not possible; these
    include the following cases (but the list could be expanded with other cases):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，至少对于内置类型之外的其他类型（如`bool`、`char`、`int`、`float`、`double`或指针），你应该更喜欢构造函数初始化列表。然而，为了保持初始化风格的一致性，当可能时，你应该始终更喜欢构造函数初始化列表。有几种情况下使用初始化列表是不可能的；这些情况包括以下情况（但列表可能会扩展到其他情况）：
- en: If a member has to be initialized with a pointer or reference to the object
    that contains it, using the `this` pointer in the initialization list may trigger
    a warning with some compilers that it is used before the object is constructed.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个成员必须用指向包含它的对象的指针或引用进行初始化，使用初始化列表中的`this`指针可能会触发一些编译器的警告，因为它在对象构造之前被使用。
- en: If you have two data members that must contain references to each other.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有两个数据成员必须包含对彼此的引用。
- en: If you want to test an input parameter and throw an exception before initializing
    a non-static data member with the value of the parameter.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果要测试输入参数并在使用参数的值初始化非静态数据成员之前抛出异常。
- en: 'Starting with C++11, non-static data members can be initialized when declared
    in the class. This is called *default member initialization* because it is supposed
    to represent initialization with default values. Default member initialization
    is intended for constants and for members that are not initialized based on constructor
    parameters (in other words members whose value does not depend on the way the
    object is constructed):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 从C++11开始，非静态数据成员可以在类中声明时进行初始化。这称为*默认成员初始化*，因为它应该表示使用默认值进行初始化。默认成员初始化适用于常量和不是基于构造函数参数进行初始化的成员（换句话说，其值不取决于对象的构造方式）：
- en: '[PRE44]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the preceding example, `DefaultHeight` and `DefaultWidth` are both constants;
    therefore, the values do not depend on the way the object is constructed, so they
    are initialized when declared. The `textFlow` object is a non-constant non-static
    data member whose value also does not depend on the way the object is initialized
    (it could be changed via another member function), therefore, it is also initialized
    using default member initialization when it is declared. `text`, on the other
    hand, is also a non-constant non-static data member, but its initial value depends
    on the way the object is constructed and therefore it is initialized in the constructor's
    initializer list using a value passed as an argument to the constructor.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`DefaultHeight`和`DefaultWidth`都是常量；因此，这些值不取决于对象的构造方式，因此它们在声明时进行初始化。`textFlow`对象是一个非常量非静态数据成员，其值也不取决于对象的初始化方式（它可以通过另一个成员函数进行更改），因此在声明时也使用默认成员初始化进行初始化。另一方面，`text`也是一个非常量非静态数据成员，但它的初始值取决于对象的构造方式，因此它在构造函数的初始化列表中使用作为参数传递给构造函数的值进行初始化，而不是在构造函数体中进行赋值。
- en: 'If a data member is initialized both with the default member initialization
    and constructor initializer list, the latter takes precedence and the default
    value is discarded. To exemplify this, let''s again consider the `foo` class earlier
    and the following `bar` class that uses it:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据成员既使用默认成员初始化，又使用构造函数初始化列表进行初始化，后者优先，并且默认值将被丢弃。为了举例说明，让我们再次考虑之前的`foo`类和使用它的以下`bar`类：
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output differs, in this case, as follows, because the value from the default
    initializer list is discarded, and the object is not initialized twice:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，输出不同，因为默认初始化列表中的值被丢弃，对象不会被初始化两次：
- en: '[PRE46]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Using the appropriate initialization method for each member leads not only to
    more efficient code but also to better organized and more readable code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个成员使用适当的初始化方法不仅可以产生更高效的代码，还可以产生更有组织和更易读的代码。
- en: Controlling and querying object alignment
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制和查询对象对齐
- en: C++11 provides standardized methods for specifying and querying the alignment
    requirements of a type (something that was previously possible only through compiler-specific
    methods). Controlling the alignment is important in order to boost performance
    on different processors and enable the use of some instructions that only work
    with data on particular alignments. For example, Intel SSE and Intel SSE2 require
    16 bytes alignment of data, whereas for Intel Advanced Vector Extensions (or Intel
    AVX), it is highly recommended to use 32 bytes alignment. This recipe explores
    the `alignas` specifier for controlling the alignment requirements and the `alignof`
    operator that retrieves the alignment requirements of a type.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: C++11提供了标准化的方法来指定和查询类型的对齐要求（以前只能通过特定于编译器的方法实现）。控制对齐对于提高不同处理器上的性能并启用一些仅适用于特定对齐数据的指令非常重要。例如，Intel
    SSE和Intel SSE2要求数据的对齐为16字节，而对于Intel高级矢量扩展（或Intel AVX），强烈建议使用32字节对齐。本教程探讨了`alignas`说明符用于控制对齐要求以及`alignof`运算符用于检索类型的对齐要求。
- en: Getting ready
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should be familiar with what data alignment is and the way the compiler
    performs default data alignment. However, basic information about the latter is
    provided in the *How it works...* section.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该熟悉数据对齐是什么以及编译器如何执行默认数据对齐。但是，关于后者的基本信息在*它是如何工作的...*部分中提供。
- en: How to do it...
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To control the alignment of a type (both at the class level or data member
    level) or an object, use the `alignas` specifier:'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制类型的对齐方式（无论是在类级别还是数据成员级别）或对象时，请使用`alignas`说明符：
- en: '[PRE47]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To query the alignment of a type, use the `alignof` operator:'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要查询类型的对齐方式，请使用`alignof`运算符：
- en: '[PRE48]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works...
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Processors do not access memory one byte at a time, but in larger chunks of
    powers of twos (2, 4, 8, 16, 32, and so on). Owing to this, it is important that
    compilers align data in memory so that it can be easily accessed by the processor.
    Should this data be misaligned, the compiler has to do extra work for accessing
    data; it has to read multiple chunks of data, shift, and discard unnecessary bytes
    and combine the rest together.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器不是一次访问一个字节的内存，而是以2的幂次（2、4、8、16、32等）的较大块访问。因此，编译器对内存中的数据进行对齐非常重要，以便处理器可以轻松访问。如果这些数据未对齐，编译器必须额外工作来访问数据；它必须读取多个数据块，移位，丢弃不必要的字节并将其余部分组合在一起。
- en: 'C++ compilers align variables based on the size of their data type: 1 byte
    for `bool` and `char`, 2 bytes for `short`, 4 bytes for `int`, `long` and `float`,
    8 bytes for `double` and `long long`, and so on. When it comes to structures or
    unions, the alignment must match the size of the largest member in order to avoid
    performance issues. To exemplify, let''s consider the following data structures:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: C++编译器根据其数据类型的大小对变量进行对齐：`bool`和`char`为1字节，`short`为2字节，`int`、`long`和`float`为4字节，`double`和`long
    long`为8字节，依此类推。在涉及结构或联合时，对齐必须与最大成员的大小匹配，以避免性能问题。举例来说，让我们考虑以下数据结构：
- en: '[PRE49]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`foo1` and `foo2` have different sizes, but the alignment is the same--that
    is, 1--because all data members are of type `char`, which has a size of 1\. In
    structure `foo3`, the second member is an integer, whose size is 4\. As a result,
    the alignment of members of this structure is done at addresses that are multiples
    of 4\. To achieve that, the compiler introduces padding bytes. The structure `foo3`
    is actually transformed into the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`foo1`和`foo2`的大小不同，但对齐方式相同--即1--因为所有数据成员都是`char`类型，其大小为1。在结构`foo3`中，第二个成员是一个整数，其大小为4。因此，该结构的成员的对齐是在地址的倍数为4的地方进行的。为了实现这一点，编译器引入了填充字节。实际上，结构`foo3`被转换为以下内容：'
- en: '[PRE50]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Similarly, the following structure has a size of 32 bytes and an alignment
    of 8; that is because the largest member is a `double` whose size is 8\. This
    structure, however, requires padding in several places to make sure that all members
    can be accessed at addresses that are multiples of 8:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，以下结构的大小为32字节，对齐为8；这是因为最大的成员是一个大小为8的`double`。然而，该结构需要在几个地方填充，以确保所有成员都可以在地址的倍数为8的地方访问：
- en: '[PRE51]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The equivalent structure created by the compiler is as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器创建的等效结构如下：
- en: '[PRE52]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In C++11, specifying the alignment of an object or type is done using the `alignas`
    specifier. This can take either an expression (an integral constant expression
    that evaluates to 0 or a valid value for an alignment), a type-id, or a parameter
    pack. The `alignas` specifier can be applied to the declaration of a variable
    or a class data member that does not represent a bit field, or to the declaration
    of a class, union, or enumeration. The type or object on which an `alignas` specification
    is applied will have the alignment requirement equal to the largest, greater than
    zero, expression of all `alignas` specifications used in the declaration.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11中，使用`alignas`说明符指定对象或类型的对齐方式。这可以采用表达式（求值为0或对齐的有效值的整数常量表达式）、类型标识或参数包。`alignas`说明符可以应用于不表示位字段的变量或类数据成员的声明，也可以应用于类、联合或枚举的声明。应用`alignas`规范的类型或对象的对齐要求将等于声明中使用的所有`alignas`规范的最大且大于零的表达式。
- en: 'There are several restrictions when using the `alignas` specifier:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`alignas`说明符时有一些限制：
- en: The only valid alignments are the powers of two ( 1, 2, 4, 8, 16, 32, and so
    on). Any other values are illegal, and the program is considered ill-formed; that
    doesn't necessarily have to produce an error, as the compiler may choose to ignore
    the specification.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 唯一有效的对齐方式是2的幂次（1、2、4、8、16、32等）。任何其他值都是非法的，程序被视为不合法；这不一定会产生错误，因为编译器可能选择忽略该规范。
- en: An alignment of 0 is always ignored.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对齐方式为0始终被忽略。
- en: If the largest `alignas` on a declaration is smaller than the natural alignment
    without any `alignas` specifier, then the program is also considered ill-formed.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果声明中最大的`alignas`小于没有`alignas`说明符的自然对齐方式，则程序也被视为不合法。
- en: 'In the following example, the `alignas` specifier is applied on a class declaration.
    The natural alignment without the `alignas` specifier would have been 1, but with
    `alignas(4)` it becomes 4:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，`alignas`修饰符应用于类声明。没有`alignas`修饰符的自然对齐将是1，但是使用`alignas(4)`后变为4：
- en: '[PRE53]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In other words, the compiler transforms the preceding class into the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，编译器将前面的类转换为以下内容：
- en: '[PRE54]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `alignas` specifier can be applied both on the class declaration and the
    member data declarations. In this case, the strictest (that is, largest) value
    wins. In the following example, member `a` has a natural size of 1 and requires
    an alignment of 2; member `b` has a natural size of 4 and requires an alignment
    of 8, therefore, the strictest alignment would be 8\. The alignment requirement
    of the entire class is 4, which is weaker (that is, smaller) than the strictest
    required alignment and therefore it will be ignored, though the compiler will
    produce a warning:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`alignas`修饰符可以应用于类声明和成员数据声明。在这种情况下，最严格（即最大）的值获胜。在下面的例子中，成员`a`的自然大小为1，需要2的对齐；成员`b`的自然大小为4，需要8的对齐，因此，最严格的对齐将是8。整个类的对齐要求是4，这比最严格的所需对齐要弱（即更小），因此它将被忽略，尽管编译器会产生警告：'
- en: '[PRE55]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The result is a structure that looks like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个看起来像这样的结构：
- en: '[PRE56]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `alignas` specifier can also be applied on variables. In the next example,
    variable `a`, that is an integer, is required to be placed in memory at a multiple
    of 8\. The next variable, the array of 4 `a`, that is an integer, is required
    to be placed in memory at a multiple of 8\. The next variable, the array of 4
    `long`s, is required to be placed in memory at a multiple of 256\. As a result,
    the compiler will introduce up to 244 bytes of padding between the two variables
    (depending on where in memory, at an address multiple of 8, the variable `a` is
    located):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`alignas`修饰符也可以应用于变量。在下一个例子中，整数变量`a`需要放置在内存中的8的倍数处。下一个变量，4个整数的数组`a`，需要放置在内存中的8的倍数处。下一个变量，4个`long`的数组，需要放置在内存中的256的倍数处。因此，编译器将在两个变量之间引入多达244字节的填充（取决于变量`a`在内存中的位置，即8的倍数的地址）：'
- en: '[PRE57]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Looking at the addresses, we can see that the address of `a` is indeed a multiple
    of 8, and the address of `b` is a multiple of 256 (hexadecimal 100).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看地址，我们可以看到`a`的地址确实是8的倍数，而`b`的地址是256的倍数（十六进制100）。
- en: 'To query the alignment of a type, we use the `alignof` operator. Unlike `sizeof`,
    this operator can only be applied to type-ids, and not on variables or class data
    members. The types on which it can be applied can be complete types, an array
    type, or a reference type. For arrays, the value returned is the alignment of
    the element type; for references, the value returned is the alignment of the referenced
    type. Here are several examples:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要查询类型的对齐方式，我们使用`alignof`运算符。与`sizeof`不同，此运算符只能应用于类型标识，而不能应用于变量或类数据成员。它可以应用于的类型可以是完整类型、数组类型或引用类型。对于数组，返回的值是元素类型的对齐方式；对于引用，返回的值是引用类型的对齐方式。以下是几个例子：
- en: '| **Expression** | **Evaluation** |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: 表达式 | 评估
- en: '| `alignof(char)` | 1, because the natural alignment of `char` is 1 |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `alignof(char)` | 1，因为`char`的自然对齐是1 |'
- en: '| `alignof(int)` | 4, because the natural alignment of `int` is 4 |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `alignof(int)` | 4，因为`int`的自然对齐是4 |'
- en: '| `alignof(int*)` | 4 on 32-bit, 8 on 64-bit, the alignment for pointers |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `alignof(int*)` | 32位为4，64位为8，指针的对齐方式 |'
- en: '| `alignof(int[4])` | 4, because the natural alignment of the element type
    is 4 |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `alignof(int[4])` | 4，因为元素类型的自然对齐是4 |'
- en: '| `alignof(foo&)` | 8, because the specified alignment for class `foo` that
    is the referred type (as shown in the last example) was 8 |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `alignof(foo&)` | 8，因为类`foo`的指定对齐方式（如上例所示）是8 |'
- en: Using scoped enumerations
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用作用域的枚举
- en: Enumeration is a basic type in C++ that defines a collection of values, always
    of an integral underlying type. Their named values, that are constant, are called
    enumerators. Enumerations declared with keyword `enum` are called *unscoped enumerations*
    and enumerations declared with `enum class` or `enum struct` are called *scoped
    enumerations*. The latter ones were introduced in C++11 and are intended to solve
    several problems of the unscoped enumerations.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举是C++中的基本类型，定义了一组值，始终是整数基础类型。它们的命名值，即常量，称为枚举器。使用关键字`enum`声明的枚举称为*未作用域的枚举*，而使用`enum
    class`或`enum struct`声明的枚举称为*作用域的枚举*。后者是在C++11中引入的，旨在解决未作用域的枚举的几个问题。
- en: How to do it...
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Prefer to use scoped enumerations instead of unscoped ones.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最好使用作用域的枚举而不是未作用域的枚举。
- en: 'In order to use scoped enumerations, you should declare enumerations using
    `enum class` or `enum struct`:'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了使用作用域的枚举，应该使用`enum class`或`enum struct`声明枚举：
- en: '[PRE58]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `enum class` and `enum struct` declarations are equivalent, and throughout
    this recipe and the rest of the book, we will use `enum class`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum class`和`enum struct`声明是等效的，在本示例和本书的其余部分中，我们将使用`enum class`。 '
- en: How it works...
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Unscoped enumerations have several issues that are creating problems for developers:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 未作用域的枚举存在一些问题，给开发人员带来了问题：
- en: 'They export their enumerators to the surrounding scope (for which reason, they
    are called unscoped enumerations), and that has the following two drawbacks: it
    can lead to name clashes if two enumerations in the same namespace have enumerators
    with the same name, and it''s not possible to use an enumerator using its fully
    qualified name:'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们将它们的枚举器导出到周围的作用域（因此称为未作用域的枚举），这有以下两个缺点：如果同一命名空间中的两个枚举具有相同名称的枚举器，可能会导致名称冲突，并且不可能使用其完全限定的名称使用枚举器：
- en: '[PRE59]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Prior to C++ 11, they could not specify the underlying type that is required
    to be an integral type. This type must not be larger than `int`, unless the enumerator
    value cannot fit a signed or unsigned integer. Owing to this, forward declaration
    of enumerations was not possible. The reason was that the size of the enumeration
    was not known since the underlying type was not known until values of the enumerators
    were defined so that the compiler could pick the appropriate integer type. This
    has been fixed in C++11.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C++ 11之前，它们无法指定所需的基础类型，该类型必须是整数类型。除非枚举值无法适应有符号或无符号整数，否则该类型不得大于`int`。由于这个原因，无法进行枚举的前向声明。原因是枚举的大小是未知的，因为在定义枚举值之前，基础类型是未知的，以便编译器可以选择适当的整数类型。这在C++11中已经得到解决。
- en: 'Values of enumerators implicitly convert to `int`. That means you can intentionally
    or accidentally mix enumerations that have a certain meaning and integers (that
    may not even be related to the meaning of the enumeration) and the compiler will
    not be able to warn you:'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举器的值隐式转换为`int`。这意味着您可以故意或意外地混合具有特定含义的枚举和整数（甚至可能与枚举的含义无关），编译器将无法警告您：
- en: '[PRE60]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The scoped enumerations are basically strongly typed enumerations that behave
    differently than the unscoped enumerations:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域枚举基本上是不同于非作用域枚举的强类型枚举：
- en: 'They do not export their enumerators to the surrounding scope. The two enumerations
    shown earlier would change to the following, no longer generating a name collision
    and being possible to fully qualify the names of the enumerators:'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不会将它们的枚举器导出到周围的范围。前面显示的两个枚举将更改为以下内容，不再生成名称冲突，并且可以完全限定枚举器的名称：
- en: '[PRE61]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You can specify the underlying type. The same rules for underlying types of
    unscoped enumerations apply to scoped enumerations too, except that the user can
    specify explicitly the underlying type. This also solves the problem with forward
    declarations since the underlying type can be known before the definition is available:'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以指定基础类型。非作用域枚举的基础类型的相同规则也适用于作用域枚举，只是用户可以明确指定基础类型。这也解决了前向声明的问题，因为在定义可用之前可以知道基础类型：
- en: '[PRE62]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Values of scoped enumerations no longer convert implicitly to `int`. Assigning
    the value of an `enum class` to an integer variable would trigger a compiler error unless
    an explicit cast is specified:'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作用域枚举的值不再隐式转换为`int`。将`enum class`的值分配给整数变量将触发编译器错误，除非指定显式转换：
- en: '[PRE63]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Using override and final for virtual methods
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用override和final来进行虚方法
- en: Unlike other similar programming languages, C++ does not have a specific syntax
    for declaring interfaces (that are basically classes with pure virtual methods
    only) and also has some deficiencies related to how virtual methods are declared.
    In C++, the virtual methods are introduced with the `virtual` keyword. However,
    the keyword `virtual` is optional for declaring overrides in derived classes that
    can lead to confusion when dealing with large classes or hierarchies. You may
    need to navigate throughout the hierarchy up to the base to figure out whether
    a function is virtual or not. On the other hand, sometimes, it is useful to make
    sure that a virtual function or even a derived class can no longer be overridden
    or derived further. In this recipe, we will see how to use C++11 special identifiers
    `override` and `final` to declare virtual functions or classes.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他类似的编程语言不同，C++没有特定的语法来声明接口（基本上是只有纯虚方法的类），并且还存在一些与如何声明虚方法相关的缺陷。在C++中，虚方法是用`virtual`关键字引入的。但是，在派生类中声明覆盖时，`virtual`关键字是可选的，这可能会导致处理大型类或层次结构时产生混淆。您可能需要在整个层次结构中导航到基类，以确定函数是否是虚拟的。另一方面，有时，确保虚函数甚至派生类不能再被覆盖或进一步派生是有用的。在本教程中，我们将看到如何使用C++11的特殊标识符`override`和`final`来声明虚函数或类。
- en: Getting ready
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should be familiar with inheritance and polymorphism in C++ and concepts,
    such as abstract classes, pure specifiers, virtual, and overridden methods.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该熟悉C++中的继承和多态的概念，例如抽象类、纯虚指定符、虚拟和重写方法。
- en: How to do it...
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'To ensure correct declaration of virtual methods both in base and derived classes,
    but also increase readability, do the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保在基类和派生类中正确声明虚方法，并增加可读性，请执行以下操作：
- en: Always use the `virtual` keyword when declaring virtual functions in derived
    classes that are supposed to override virtual functions from a base class, and
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在派生类中声明虚函数时，始终使用`virtual`关键字，这些函数应该覆盖来自基类的虚函数，并且
- en: Always use the `override` special identifier after the declarator part of a
    virtual function declaration or definition.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在虚函数声明或定义的声明部分之后始终使用`override`特殊标识符。
- en: '[PRE64]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The declarator is the part of the type of a function that excludes the return
    type.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 声明符是函数类型的一部分，不包括返回类型。
- en: 'To ensure that functions cannot be overridden further or classes cannot be
    derived any more, use the `final` special identifier:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保函数不能进一步被覆盖或类不能再被派生，使用`final`特殊标识符：
- en: 'After the declarator part of a virtual function declaration or definition to
    prevent further overrides in a derived class:'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在虚函数声明或定义的声明部分之后，以防止在派生类中进行进一步的覆盖：
- en: '[PRE65]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'After the name of a class in the declaration of the class to prevent further
    derivations of the class:'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类的声明中类的名称之后，以防止进一步派生类：
- en: '[PRE66]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: How it works...
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The way `override` works is very simple; in a virtual function declaration or
    definition, it ensures that the function is actually overriding a base class function,
    otherwise, the compiler will trigger an error.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`override`的工作方式非常简单；在虚函数声明或定义中，它确保函数实际上是覆盖了基类函数，否则，编译器将触发错误。'
- en: It should be noted that both `override` and `final` keywords are special identifiers
    having a meaning only in a member function declaration or definition. They are
    not reserved keywords and can still be used elsewhere in a program as user-defined
    identifiers.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，`override` 和 `final` 关键字都是特殊标识符，只在成员函数声明或定义中具有特定含义。它们不是保留关键字，仍然可以在程序的其他地方作为用户定义的标识符使用。
- en: 'Using the `override` special identifier helps the compiler to detect situations
    when a virtual method does not override another one like shown in the following
    example:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`override`特殊标识符有助于编译器检测虚拟方法不像下面的示例中覆盖另一个方法的情况：
- en: '[PRE67]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The other special identifier, `final`, is used in a member function declaration
    or definition to indicate that the function is virtual and cannot be overridden
    in a derived class. If a derived class attempts to override the virtual function,
    the compiler triggers an error:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个特殊标识符`final`在成员函数声明或定义中使用，表示该函数是虚拟的，不能在派生类中被覆盖。如果派生类尝试覆盖虚拟函数，编译器会触发错误：
- en: '[PRE68]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `final` specifier can also be used in a class declaration to indicate that
    it cannot be derived:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`final`修饰符也可以在类声明中使用，表示它不能被派生：'
- en: '[PRE69]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Since both `override` and `final` have this special meaning when used in the
    defined context and are not in fact reserved keywords, you can still use them
    anywhere elsewhere in the C++ code. This ensured that existing code written before
    C++11 did not break because of the use of these names for identifiers:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`override`和`final`在定义的上下文中具有特殊含义，并且实际上不是保留关键字，因此您仍然可以在C++代码的其他任何地方使用它们。这确保了在C++11之前编写的现有代码不会因为使用这些标识符而中断：
- en: '[PRE70]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Using range-based for loops to iterate on a range
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用范围-based for循环迭代范围
- en: Many programming languages support a variant of a `for` loop called `for each`,
    that is, repeating a group of statements over the elements of a collection. C++
    did not have core language support for this until C++11\. The closest feature
    was the general purpose algorithm from the standard library called `std::for_each`,
    that applies a function to all the elements in a range. C++11 brought language
    support for `for each` that is actually called *range-based for loops*. The new
    C++17 standard provides several improvements to the original language feature.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编程语言支持一种称为`for each`的`for`循环变体，即在集合的元素上重复一组语句。直到C++11之前，C++没有对此提供核心语言支持。最接近的功能是标准库中的通用算法`std::for_each`，它将函数应用于范围内的所有元素。C++11为`for
    each`带来了语言支持，实际上称为*范围-based for循环*。新的C++17标准对原始语言功能进行了几项改进。
- en: Getting ready
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In C++11, a range-based for loop has the following general syntax:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11中，范围-based for循环具有以下一般语法：
- en: '[PRE71]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'To exemplify the various ways of using a range-based for loops, we will use
    the following functions that return sequences of elements:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明使用范围-based for循环的各种方式，我们将使用以下返回元素序列的函数：
- en: '[PRE72]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: How to do it...
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Range-based for loops can be used in various ways:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 范围-based for循环可以以各种方式使用：
- en: 'By committing to a specific type for the elements of the sequence:'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过承诺特定类型的元素序列：
- en: '[PRE73]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'By not specifying a type and letting the compiler deduce it:'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过不指定类型并让编译器推断它：
- en: '[PRE74]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'By using structured bindings and decomposition declaration in C++17:'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在C++17中使用结构化绑定和分解声明：
- en: '[PRE75]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: How it works...
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The expression for the range-based for loops shown earlier in the *How to do
    it...* section is basically syntactic sugar as the compiler transforms it into
    something else. Before C++17, the code generated by the compiler used to be the
    following:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在*如何做...*部分显示的范围-based for循环的表达式基本上是一种语法糖，因为编译器将其转换为其他形式。在C++17之前，编译器生成的代码通常是以下内容：
- en: '[PRE76]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'What `begin_expr` and `end_expr` are in this code depends on the type of the
    range:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码中的`begin_expr`和`end_expr`取决于范围的类型：
- en: 'For C-like arrays: `__range` and `__range + __bound` (where `__bound` is the
    number of elements in the array)'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于类似C的数组：`__range`和`__range + __bound`（其中`__bound`是数组中的元素数）
- en: 'For a class type with `begin` and `end` members (regardless of their type and
    accessibility): `__range.begin()` and `__range.end()`.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于具有`begin`和`end`成员（无论其类型和可访问性）的类类型：`__range.begin()`和`__range.end()`。
- en: For others it is `begin(__range)` and `end(__range)` that are determined via
    argument-dependent lookup.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于其他人来说，`begin(__range)`和`end(__range)`是通过参数相关查找确定的。
- en: It is important to note that if a class contains any members (function, data
    member, or enumerators) called `begin` or `end`, regardless of their type and
    accessibility, they will be picked for `begin_expr` and `end_expr`. Therefore,
    such a class type cannot be used in range-based for loops.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，如果一个类包含任何名为`begin`或`end`的成员（函数、数据成员或枚举器），无论其类型和可访问性如何，它们都将被选为`begin_expr`和`end_expr`。因此，这样的类类型不能用于范围-based
    for循环。
- en: 'In C++17, the code generated by the compiler is slightly different:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17中，编译器生成的代码略有不同：
- en: '[PRE77]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The new standard has removed the constraint that the begin expression and end
    expression must have the same type. The end expression does not need to be an
    actual iterator, but it has to be able to be compared for inequality with an iterator.
    A benefit of this is that the range can be delimited by a predicate.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 新标准已经删除了开始表达式和结束表达式必须具有相同类型的约束。结束表达式不需要是实际的迭代器，但必须能够与迭代器进行不等比较。其中一个好处是范围可以由谓词限定。
- en: See also
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Enabling range-based for loops for custom types*'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为自定义类型启用范围-based for循环*'
- en: Enabling range-based for loops for custom types
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为自定义类型启用范围-based for循环
- en: As we have seen in the preceding recipe, the range-based for loops, known as
    `for each` in other programming languages, allows you to iterate over the elements
    of a range, providing a simplified syntax over the standard `for` loops and making
    the code more readable in many situations. However, range-based for loops do not
    work out of the box with any type representing a range, but require the presence
    of a `begin()` and `end()` function (for non-array types) either as a member or
    free function. In this recipe, we will see how to enable a custom type to be used
    in range-based for loops.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的教程中所看到的，基于范围的for循环（在其他编程语言中称为`for each`）允许您在范围的元素上进行迭代，提供了一种简化的语法，使得代码在许多情况下更易读。但是，基于范围的for循环不能直接与表示范围的任何类型一起使用，而是需要存在`begin()`和`end()`函数（对于非数组类型）作为成员或自由函数。在本教程中，我们将看到如何使自定义类型可以在基于范围的for循环中使用。
- en: Getting ready
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: It is recommended that you read the recipe *Using range-based for loops to iterate
    on a range* before continuing with this one if you need to understand how range-based
    for loops work and what is the code the compiler generates for such a loop.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 建议在继续本教程之前阅读*使用基于范围的for循环对范围进行迭代*，以便了解基于范围的for循环的工作原理以及编译器为这样的循环生成的代码。
- en: 'To show how we can enable range-based for loops for custom types representing
    sequences, we will use the following implementation of a simple array:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何使自定义类型表示序列的范围可以用于基于范围的for循环，我们将使用以下简单数组的实现：
- en: '[PRE78]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The purpose of this recipe is to enable writing code like the following:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程的目的是使编写以下代码成为可能：
- en: '[PRE79]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: How to do it...
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'To enable a custom type to be used in range-based `for` loops, you need to
    do the following:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使自定义类型可以在基于范围的`for`循环中使用，您需要执行以下操作：
- en: 'Create mutable and constant iterators for the type that must implement the
    following operators:'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为必须实现以下运算符的类型创建可变和常量迭代器：
- en: '`operator++` for incrementing the iterator.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于增加迭代器的`operator++`。
- en: '`operator*` for dereferencing the iterator and accessing the actual element
    pointed by the iterator.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator*`用于对迭代器进行取消引用并访问迭代器指向的实际元素。'
- en: '`operator!=` for comparing with another iterator for inequality.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator!=`用于与另一个迭代器进行比较。'
- en: Provide free `begin()` and `end()` functions for the type.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为该类型提供自由的`begin()`和`end()`函数。
- en: 'Given the earlier example of a simple range, we need to provide the following:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于前面的简单范围示例，我们需要提供以下内容：
- en: 'The following minimal implementation of an iterator class:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代器类的以下最小实现：
- en: '[PRE80]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Alias templates for mutable and constant iterators:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可变和常量迭代器的别名模板：
- en: '[PRE81]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Free `begin()` and `end()` functions that return the corresponding begin and
    end iterators, with overloads for both alias templates:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回相应的开始和结束迭代器的自由`begin()`和`end()`函数，对于两个别名模板都进行重载：
- en: '[PRE82]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: How it works...
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Having this implementation available, the range-based for loop shown earlier
    compiles and executes as expected. When performing argument-dependent lookup,
    the compiler will identify the two `begin()` and `end()` functions that we wrote
    (that take a reference to a `dummy_array`) and therefore the code it generates
    becomes valid.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个实现，前面显示的基于范围的for循环将如预期般编译和执行。在执行参数相关查找时，编译器将识别我们编写的两个`begin()`和`end()`函数（它们接受对`dummy_array`的引用），因此生成的代码变得有效。
- en: 'In the preceding example, we have defined one iterator class template and two
    alias templates, called `dummy_array_iterator` and `dummy_array_const_iterator`.
    The `begin()` and `end()` functions both have two overloads for these two types
    of iterators. This is necessary so that the container we have considered could
    be used in range-based for loops with both constant and non-constant instances:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们定义了一个迭代器类模板和两个别名模板，称为`dummy_array_iterator`和`dummy_array_const_iterator`。`begin()`和`end()`函数都有这两种类型的迭代器的两个重载。这是必要的，以便我们考虑的容器可以在具有常量和非常量实例的基于范围的for循环中使用：
- en: '[PRE83]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: A possible alternative to enable range-based for loops for the simple range
    class we considered for this recipe is to provide member `begin()` and `end()`
    functions. In general, that could make sense only if you own and can modify the
    source code. On the other hand, the solution shown in this recipe works in all
    cases and should be preferred to other alternatives.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们在本教程中考虑的简单范围类能够用于基于范围的for循环，可能的替代方法是提供成员`begin()`和`end()`函数。一般来说，只有在您拥有并且可以修改源代码时才有意义。另一方面，本教程中展示的解决方案在所有情况下都适用，并且应优先于其他替代方案。
- en: See also
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Creating type aliases and alias templates*'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建类型别名和别名模板*'
- en: Using explicit constructors and conversion operators to avoid implicit conversion
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用显式构造函数和转换运算符以避免隐式转换
- en: Before C++11, a constructor with a single parameter was considered a converting
    constructor. With C++11, every constructor without the `explicit` specifier is
    considered a converting constructor. Such a constructor defines an implicit conversion
    from the type or types of its arguments to the type of the class. Classes can
    also define converting operators that convert the type of the class to another
    specified type. All these are useful in some cases, but can create problems in
    other cases. In this recipe, we will see how to use explicit constructors and
    conversion operators.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11之前，具有单个参数的构造函数被视为转换构造函数。使用C++11，没有`explicit`说明符的每个构造函数都被视为转换构造函数。这样的构造函数定义了从其参数的类型到类的类型的隐式转换。类还可以定义转换运算符，将类的类型转换为另一指定类型。所有这些在某些情况下很有用，但在其他情况下可能会创建问题。在本教程中，我们将看到如何使用显式构造函数和转换运算符。
- en: Getting ready
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: For this recipe, you need to be familiar with converting constructors and converting
    operators. In this recipe, you will learn how to write explicit constructors and
    conversion operators to avoid implicit conversions to and from a type. The use
    of explicit constructors and conversion operators (called *user-defined conversion
    functions*) enables the compiler to yield errors--that in some cases are coding
    errors--and allow developers to spot those errors quickly and fix them.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，您需要熟悉转换构造函数和转换运算符。在这个示例中，您将学习如何编写显式构造函数和转换运算符，以避免对类型进行隐式转换。显式构造函数和转换运算符（称为*用户定义的转换函数*）的使用使编译器能够产生错误--在某些情况下是编码错误--并允许开发人员快速发现并修复这些错误。
- en: How to do it...
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: To declare explicit constructors and conversion operators (regardless of whether
    they are functions or function templates), use the `explicit` specifier in the
    declaration.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明显式构造函数和转换运算符（无论它们是函数还是函数模板），在声明中使用 `explicit` 说明符。
- en: 'The following example shows both an explicit constructor and a converting operator:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了显式构造函数和转换运算符：
- en: '[PRE84]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: How it works...
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'To understand why explicit constructors are necessary and how they work, we
    will first look at converting constructors. The following class has three constructors:
    a default constructor (without parameters), a constructor that takes an `int`,
    and a constructor that takes two parameters, an `int` and a `double`. They don''t
    do anything, except printing a message. As of C++11, these are all considered
    converting constructors. The class also has a conversion operator that converts
    the type to a `bool`:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解为什么需要显式构造函数以及它们的工作原理，我们首先来看看转换构造函数。以下类有三个构造函数：一个默认构造函数（没有参数），一个带有 `int`
    参数的构造函数，以及一个带有两个参数的构造函数，一个 `int` 和一个 `double`。它们什么也不做，只是打印一条消息。从 C++11 开始，这些都被认为是转换构造函数。该类还有一个转换运算符，将类型转换为
    `bool`：
- en: '[PRE85]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Based on this, the following definitions of objects are possible (note that
    the comments represent the console output):'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，以下对象的定义是可能的（请注意，注释表示控制台输出）：
- en: '[PRE86]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '`f1` and `f2` invoke the default constructor. `f3`, `f4`, `f5`, and `f6` invoke
    the constructor that takes an `int`. Note that all the definitions of these objects
    are equivalent, even if they look different (`f3` is initialized using the functional
    form, `f4` and `f6` are copy-initialized, and `f5` is directly initialized using
    brace-init-list). Similarly, `f7`, `f8`, and `f9` invoke the constructor with
    two parameters.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`f1` 和 `f2` 调用默认构造函数。`f3`、`f4`、`f5` 和 `f6` 调用带有 `int` 参数的构造函数。请注意，所有这些对象的定义是等效的，即使它们看起来不同（`f3`
    使用函数形式初始化，`f4` 和 `f6` 使用复制初始化，`f5` 使用大括号初始化列表直接初始化）。同样，`f7`、`f8` 和 `f9` 调用带有两个参数的构造函数。'
- en: 'It may be important to note that if `foo` defines a constructor that takes
    an `std::initializer_list`, then all the initializations using `{}` would resolve
    to that constructor:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，如果 `foo` 定义了一个接受 `std::initializer_list` 的构造函数，那么所有使用 `{}` 进行初始化的情况都将解析为该构造函数：
- en: '[PRE87]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: In this case, `f5` and `f6` will `print foo(l)`, while `f8` and `f9` will generate
    compiler errors because all elements of the initializer list should be integers.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`f5` 和 `f6` 将打印 `foo(l)`，而 `f8` 和 `f9` 将生成编译器错误，因为初始化列表的所有元素都应该是整数。
- en: 'These may all look right, but the implicit conversion constructors enable scenarios
    where the implicit conversion may not be what we wanted:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这些看起来都是正确的，但隐式转换构造函数使得可能出现隐式转换不是我们想要的情况：
- en: '[PRE88]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The conversion operator to `bool` in the example above also enables us to use
    `foo` objects where boolean values are expected:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 上面示例中的转换运算符也使我们能够在需要布尔值的地方使用 `foo` 对象：
- en: '[PRE89]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The first two are examples where `foo` is expected to be used as boolean but
    the last two with addition and test for equality are probably incorrect, as we
    most likely expect to add `foo` objects and test `foo` objects for equality, not
    the booleans they implicitly convert to.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个例子中 `foo` 预期被用作布尔值，但最后两个例子中的加法和相等测试可能是不正确的，因为我们很可能期望添加 `foo` 对象并测试 `foo`
    对象的相等性，而不是它们隐式转换为的布尔值。
- en: 'Perhaps a more realistic example to understand where problems could arise would
    be to consider a string buffer implementation. This would be a class that contains
    an internal buffer of characters. The class may provide several conversion constructors:
    a default constructor, a constructor that takes a `size_t` parameter representing
    the size of the buffer to preallocate, and a constructor that takes a pointer
    to `char` that should be used to allocate and initialize the internal buffer.
    Succinctly, such a string buffer could look like this:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 也许一个更现实的例子来理解问题可能出现的地方是考虑一个字符串缓冲区实现。这将是一个包含字符内部缓冲区的类。该类可能提供几个转换构造函数：一个默认构造函数，一个带有
    `size_t` 参数表示预分配缓冲区大小的构造函数，以及一个带有 `char` 指针的构造函数，用于分配和初始化内部缓冲区。简而言之，这样的字符串缓冲区可能如下所示：
- en: '[PRE90]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Based on this definition, we could construct the following objects:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个定义，我们可以构造以下对象：
- en: '[PRE91]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '`sb1` is created using the default constructor and thus has an empty buffer;
    `sb2` is initialized using the constructor with a single parameter and the value
    of the parameter represents the size in characters of the internal buffer; `sb3`
    is initialized with an existing buffer and that is used to define the size of
    the internal buffer and to copy its value into the internal buffer. However, the
    same definition also enables the following object definitions:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`sb1` 是使用默认构造函数创建的，因此具有一个空缓冲区；`sb2` 是使用带有单个参数的构造函数初始化的，参数的值表示内部缓冲区的字符大小；`sb3`
    是用现有缓冲区初始化的，并且用于定义内部缓冲区的大小并将其值复制到内部缓冲区。然而，同样的定义也使以下对象定义成为可能：'
- en: '[PRE92]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: In this case, `b4` is initialized with a `char`. Since an implicit conversion
    to `size_t` exists, the constructor with a single parameter will be called. The
    intention here is not necessarily clear; perhaps it should have been `"a"` instead
    of `'a'`, in which case the third constructor would have been called. However,
    `b5` is most likely an error, because `MaxSize` is an enumerator representing
    an `ItemSizes` and should have nothing to do with a string buffer size. These
    erroneous situations are not flagged by the compiler in any way.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`b4`用`char`初始化。由于存在到`size_t`的隐式转换，将调用带有单个参数的构造函数。这里的意图并不一定清楚；也许应该是`"a"`而不是`'a'`，在这种情况下将调用第三个构造函数。然而，`b5`很可能是一个错误，因为`MaxSize`是代表`ItemSizes`的枚举器，与字符串缓冲区大小无关。这些错误的情况并不会以任何方式被编译器标记。
- en: 'Using the `explicit` specifier in the declaration of a constructor, that constructor
    becomes an explicit constructor and no longer allows implicit constructions of
    objects of a class type. To exemplify this, we will slightly change the `string_buffer`
    class earlier to declare all constructors explicit:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数的声明中使用`explicit`限定符，该构造函数将成为显式构造函数，不再允许隐式构造类类型的对象。为了举例说明这一点，我们将稍微修改之前的`string_buffer`类，声明所有构造函数为显式：
- en: '[PRE93]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The change is minimal, but the definitions of `b4` and `b5` in the earlier example
    no longer work, and are incorrect, since the implicit conversion from `char` or
    `int` to `size_t` are no longer available during overload resolution to figure
    out what constructor should be called. The result is compiler errors for both
    `b4` and `b5`. Note that `b1`, `b2`, and `b3` are still valid definitions even
    if the constructors are explicit.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 更改是微小的，但在之前的示例中`b4`和`b5`的定义不再起作用，并且是不正确的，因为从`char`或`int`到`size_t`的隐式转换在重载解析期间不再可用于确定应调用哪个构造函数。结果是`b4`和`b5`都会出现编译错误。请注意，即使构造函数是显式的，`b1`、`b2`和`b3`仍然是有效的定义。
- en: 'The only way to fix the problem, in this case, is to provide an explicit cast
    from `char` or `int` to `string_buffer`:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下解决问题的唯一方法是提供从`char`或`int`到`string_buffer`的显式转换：
- en: '[PRE94]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: With explicit constructors, the compiler is able to immediately flag erroneous
    situations and developers can react accordingly, either fixing the initialization
    with a correct value or providing an explicit cast.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 使用显式构造函数，编译器能够立即标记错误的情况，开发人员可以相应地做出反应，要么修复初始化并提供正确的值，要么提供显式转换。
- en: This is only the case when initialization is done with copy initialization and
    not when using the functional or universal initialization.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在使用复制初始化时才会出现这种情况，而在使用函数式或通用初始化时不会。
- en: 'The following definitions are still possible (and wrong) with explicit constructors:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 以下定义仍然可能（并且是错误的）使用显式构造函数：
- en: '[PRE95]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Similar to constructors, conversion operators can be declared explicit (as
    shown earlier). In this case, the implicit conversions from the object type to
    the type specified by the conversion operator are no longer possible and require
    an explicit cast. Considering `b1` and `b2`, the `string_buffer` objects defined
    earlier, the following are no longer possible with explicit conversion `operator
    bool`:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 与构造函数类似，转换运算符可以声明为显式（如前所示）。在这种情况下，从对象类型到转换运算符指定的类型的隐式转换不再可能，需要显式转换。考虑`b1`和`b2`，之前定义的`string_buffer`对象，以下不再可能使用显式转换`operator
    bool`：
- en: '[PRE96]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Instead, they require explicit conversion to `bool`:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，它们需要显式转换为`bool`：
- en: '[PRE97]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: See also
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Understanding uniform initialization*'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*理解统一初始化*'
- en: Using unnamed namespaces instead of static globals
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用未命名命名空间而不是静态全局变量
- en: The larger a program the greater the chances are you could run into name collisions
    with file locals when your program is linked. Functions or variables that are
    declared in a source file and are supposed to be local to the translation unit
    may collide with other similar functions or variables declared in another translation
    unit. That is because all symbols that are not declared static have external linkage
    and their names must be unique throughout the program. The typical C solution
    for this problem is to declare those symbols static, changing their linkage from
    external to internal and therefore making them local to a translation unit. In
    this recipe, we will look at the C++ solution for this problem.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 程序越大，您的程序在链接时可能遇到文件局部名称冲突的机会就越大。在源文件中声明并应该是翻译单元局部的函数或变量可能会与另一个翻译单元中声明的其他类似函数或变量发生冲突。这是因为所有未声明为静态的符号都具有外部链接，它们的名称必须在整个程序中是唯一的。这个问题的典型C解决方案是将这些符号声明为静态，将它们的链接从外部改为内部，从而使它们成为翻译单元的局部。在这个教程中，我们将看看C++对这个问题的解决方案。
- en: Getting ready
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In this recipe, we will discuss concepts such as global functions, static functions,
    and variables, namespaces, and translation units. Apart from these, it is required
    that you understand the difference between internal and external linkage; that
    is key for this recipe.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将讨论全局函数、静态函数和变量、命名空间和翻译单元等概念。除此之外，您需要理解内部链接和外部链接之间的区别；这对于这个教程至关重要。
- en: How to do it...
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'When you are in a situation where you need to declare global symbols as statics
    to avoid linkage problems, prefer to use unnamed namespaces:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 当您处于需要将全局符号声明为静态以避免链接问题的情况时，最好使用未命名的命名空间：
- en: Declare a namespace without a name in your source file.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的源文件中声明一个没有名称的命名空间。
- en: Put the definition of the global function or variable in the unnamed namespace
    without making them `static`.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将全局函数或变量的定义放在未命名的命名空间中，而不使它们成为`static`。
- en: 'The following example shows two functions called `print()` in two different
    translation units; each of them is defined in an unnamed namespace:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例显示了两个不同翻译单元中分别称为`print()`的函数；它们每个都在一个未命名的命名空间中定义：
- en: '[PRE98]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: How it works...
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When a function is declared in a translation unit, it has external linkage.
    That means two functions with the same name from two different translation units
    would generate a linkage error because it is not possible to have two symbols
    with the same name. The way this problem is solved in C, and by some in C++ also,
    is to declare the function or variable static and change its linkage from external
    to internal. In this case, its name is no longer exported outside the translation
    unit, and the linkage problem is avoided.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 当在翻译单元中声明函数时，它具有外部链接。这意味着来自两个不同翻译单元的具有相同名称的两个函数会生成链接错误，因为不可能有两个具有相同名称的符号。在C中以及一些C++中解决这个问题的方法是将函数或变量声明为静态，并将其链接从外部更改为内部。在这种情况下，它的名称不再在翻译单元之外导出，链接问题得到避免。
- en: 'The proper solution in C++ is to use unnamed namespaces. When you define a
    namespace like the ones shown above, the compiler transforms it to the following:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的正确解决方案是使用未命名命名空间。当您像上面所示地定义一个命名空间时，编译器将其转换为以下形式：
- en: '[PRE99]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: First of all, it declares a namespace with a unique name (what the name is and
    how it generates that name is a compiler implementation detail and should not
    be a concern). At this point, the namespace is empty, and the purpose of this
    line is to basically establish the namespace. Second, a using directive brings
    everything from the `_unique_name_` namespace into the current namespace. Third,
    the namespace, with the compiler-generated name, is defined as it was in the original
    source code (when it had no name).
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它声明了一个具有唯一名称的命名空间（名称是什么以及如何生成该名称是编译器实现的细节，不应该成为关注点）。此时，命名空间是空的，这一行的目的基本上是建立命名空间。其次，使用指令将`_unique_name_`命名空间中的所有内容引入当前命名空间。第三，使用编译器生成的名称定义了命名空间，就像在原始源代码中一样（当它没有名称时）。
- en: By defining the translation unit local `print()` functions in an unnamed namespace,
    they have local visibility only, yet their external linkage no longer produces
    linkage errors since they now have external unique names.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在未命名命名空间中定义翻译单元本地的`print()`函数，它们只有本地可见性，但它们的外部链接不再产生链接错误，因为它们现在具有外部唯一名称。
- en: Unnamed namespaces are also working in a perhaps more obscure situation involving
    templates. Prior to C++11 template non-type arguments could not be names with
    internal linkage so using static variables was not possible. On the other hand,
    symbols in an unnamed namespace have external linkage and could be used as template
    arguments. Although this linkage restriction for template non-type arguments was
    lifted in C++11, it is still present in the latest version of the VC++ compiler.
    This problem is shown in the following example where declaring t1 produces a compiler
    error, because the non-type argument expression has internal linkage, but `t2`
    is correct because `Size2` has external linkage. (Note that compiling the code
    below with Clang and gcc do not produce any error.)
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 未命名命名空间在涉及模板的可能更晦涩的情况下也可以工作。在C++11之前，模板非类型参数不能具有内部链接的名称，因此无法使用静态变量。另一方面，未命名命名空间中的符号具有外部链接，并且可以用作模板参数。尽管C++11解除了模板非类型参数的此链接限制，但在最新版本的VC++编译器中仍然存在。下面的示例显示了这个问题，其中声明t1会产生编译错误，因为非类型参数表达式具有内部链接，但`t2`是正确的，因为`Size2`具有外部链接。（请注意，使用Clang和gcc编译下面的代码不会产生任何错误。）
- en: '[PRE100]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: See also
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Using inline namespaces for symbol versioning*'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用内联命名空间进行符号版本控制*'
- en: Using inline namespaces for symbol versioning
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内联命名空间进行符号版本控制
- en: The C++11 standard has introduced a new type of namespace called *inline namespaces*
    that are basically a mechanism that makes declarations from a nested namespace
    look and act like they were part of the surrounding namespace. Inline namespaces
    are declared using the `inline` keyword in the namespace declaration (unnamed
    namespaces can also be inlined). This is a helpful feature for library versioning,
    and in this recipe, we will see how inline namespaces can be used for versioning
    symbols. From this recipe, you will learn how to version your source code using
    inline namespaces and conditional compilation.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: C++11标准引入了一种新类型的命名空间，称为*内联命名空间*，它基本上是一种使嵌套命名空间的声明看起来和行为像是属于周围命名空间的机制。内联命名空间使用`inline`关键字在命名空间声明中声明（未命名命名空间也可以内联）。这是一个有用的库版本控制功能，在这个示例中，我们将看到如何使用内联命名空间来对符号进行版本控制。从这个示例中，您将学习如何使用内联命名空间和条件编译对源代码进行版本控制。
- en: Getting ready
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will discuss namespaces and nested namespaces, templates
    and template specializations, and conditional compilation using preprocessor macros.
    Familiarity with these concepts is required in order to proceed with the recipe.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将讨论命名空间和嵌套命名空间、模板和模板特化，以及使用预处理器宏进行条件编译。熟悉这些概念是继续进行示例所必需的。
- en: How to do it...
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤如下：
- en: 'To provide multiple versions of a library and let the user decide what version
    to use, do the following:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 提供库的多个版本，并让用户决定使用哪个版本，可以采取以下步骤：
- en: Define the content of the library inside a namespace.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命名空间中定义库的内容。
- en: Define each version of the library or parts of it inside an inner inline namespace.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内部内联命名空间中定义库的每个版本或其部分。
- en: Use preprocessor macros and `#if` directives to enable a particular version
    of the library.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用预处理器宏和`#if`指令来启用库的特定版本。
- en: 'The following example shows a library that has two versions that clients can
    use:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了一个库，其中有两个客户可以使用的版本：
- en: '[PRE101]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: How it works...
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: A member of an inline namespace is treated as if it was a member of the surrounding
    namespace. Such a member can be partially specialized, explicitly instantiated,
    or explicitly specialized. This is a transitive property, which means that if
    a namespace A contains an inline namespace B that contains an inline namespace
    C, then the members of C appear as they were members of both B and A and the members
    of B appear as they were members of A.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 内联命名空间的成员被视为是周围命名空间的成员。这样的成员可以部分特化、显式实例化或显式特化。这是一个传递属性，这意味着如果命名空间A包含一个内联命名空间B，B包含一个内联命名空间C，那么C的成员会出现为B和A的成员，B的成员会出现为A的成员。
- en: 'To better understand why inline namespaces are helpful, let''s consider the
    case of developing a library that evolves over time from a first version to a
    second version (and further on). This library defines all its types and functions
    under a namespace called `modernlib`. In the first version, this library could
    look like this:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解内联命名空间的帮助，让我们考虑从第一个版本到第二个版本（以及更多版本）随时间演变的库的情况。这个库在名为`modernlib`的命名空间下定义了所有类型和函数。在第一个版本中，这个库可能是这样的：
- en: '[PRE102]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'A client of the library can make the following call and get back the value
    1:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 库的客户端可以进行以下调用并获得值1：
- en: '[PRE103]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'However, the client might decide to specialize the template function `test()`
    as the following:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，客户端可能决定将模板函数`test()`特化为以下内容：
- en: '[PRE104]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: In this case, the value of `y` is no longer 1, but 42 because the user-specialized
    function gets called.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`y`的值不再是1，而是42，因为调用了用户专用的函数。
- en: 'Everything is working correctly so far, but as a library developer you decide
    to create a second version of the library, yet still ship both the first and the
    second version and let the user control what to use with a macro. In this second
    version, you provide a new implementation of the `test()` function that no longer
    returns 1, but 2\. To be able to provide both the first and second implementations,
    you put them in nested namespaces called `version_1` and `version_2` and conditionally
    compile the library using preprocessor macros:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都运行正常，但作为库开发人员，您决定创建库的第二个版本，但仍然同时发布第一和第二个版本，并让用户使用宏来控制使用哪个版本。在第二个版本中，您提供了`test()`函数的新实现，不再返回1，而是返回2。为了能够提供第一和第二个版本的实现，您将它们放在名为`version_1`和`version_2`的嵌套命名空间中，并使用预处理宏有条件地编译库：
- en: '[PRE105]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Suddenly, the client code will break, regardless of whether it uses the first
    or second version of the library. That is because the test function is now inside
    a nested namespace, and the specialization for `foo` is done in the `modernlib`
    namespace, when it should actually be done in `modernlib::version_1` or `modernlib::version_2`.
    This is because the specialization of a template is required to be done in the
    same namespace where the template was declared. In this case, the client needs
    to change the code like this:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 突然之间，无论客户端使用库的第一个版本还是第二个版本，客户端代码都会中断。这是因为`test`函数现在位于嵌套命名空间中，并且对`foo`的特化是在`modernlib`命名空间中进行的，而实际上应该在`modernlib::version_1`或`modernlib::version_2`中进行。这是因为要求在模板的声明命名空间中进行模板特化。在这种情况下，客户端需要像这样更改代码：
- en: '[PRE106]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: This is a problem because the library leaks implementation details, and the
    client needs to be aware of those in order do the template specialization. These
    internal details are hidden with inline namespaces in the manner shown in the
    *How to do it...* section of this recipe. With that definition of the `modernlib`
    library, the client code with the specialization of the `test()` function in the
    `modernlib` namespace is no longer broken, because either `version_1::test()`
    or `version_2::test()` (depending on what version the client is actually using)
    acts as being part of the enclosing `modernlib` namespace when template specialization
    is done. The details of the implementation are now hidden to the client that only
    sees the surrounding namespace `modernlib`.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个问题，因为库泄漏了实现细节，客户端需要意识到这些细节才能进行模板特化。这些内部细节在本文中所示的内联命名空间中隐藏。有了`modernlib`库的定义，`modernlib`命名空间中`test()`函数的特化的客户端代码不再中断，因为`version_1::test()`或`version_2::test()`（取决于客户端实际使用的版本）在模板特化时作为封闭`modernlib`命名空间的一部分。实现的细节现在对客户端隐藏，客户端只看到周围的命名空间`modernlib`。
- en: 'However, you should keep in mind that:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您应该记住：
- en: The namespace `std` is reserved for the standard and should never be inlined.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std`命名空间保留用于标准，不应内联。'
- en: A namespace should not be defined inline if it was not inline in its first definition.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果命名空间在其第一次定义中不是内联的，则不应内联定义命名空间。
- en: See also
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Using unnamed namespaces instead of static globals*'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用未命名命名空间代替静态全局变量*'
- en: Using structured bindings to handle multi-return values
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用结构化绑定处理多返回值
- en: Returning multiple values from a function is something very common, yet there
    is no first-class solution in C++ to enable it directly. Developers have to choose
    between returning multiple values through reference parameters to a function,
    defining a structure to contain the multiple values or returning a `std::pair`
    or `std::tuple`. The first two use named variables that have the advantage that
    they clearly indicate the meaning of the return value, but have the disadvantage
    that they have to be explicitly defined. `std::pair` has its members called `first`
    and `second`, and `std::tuple` has unnamed members that can only be retrieved
    with a function call, but can be copied to named variables using `std::tie().`
    None of these solutions is ideal.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 从函数返回多个值是非常常见的事情，但在C++中没有直接启用它的一流解决方案。开发人员必须在通过引用参数返回多个值的函数之间进行选择，定义一个包含多个值的结构，或者返回`std::pair`或`std::tuple`。前两种方法使用具有优势的命名变量，它们清楚地指示返回值的含义，但缺点是它们必须明确定义。`std::pair`具有名为`first`和`second`的成员，而`std::tuple`具有无名成员，只能通过函数调用检索，但可以使用`std::tie()`将其复制到命名变量中。这些解决方案都不是理想的。
- en: C++17 extends the semantic use of `std::tie()` into a first-class core language
    feature that enables unpacking the values of a tuple to named variables. This
    feature is called *structured bindings*.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: C++17将`std::tie()`的语义用法扩展为一种一流的核心语言特性，它使得可以将元组的值解包到命名变量中。这个特性被称为*结构化绑定*。
- en: Getting ready
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you should be familiar with the standard utility types `std::pair`
    and `std::tuple` and the utility function `std::tie()`.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，您应该熟悉标准实用类型`std::pair`和`std::tuple`以及实用函数`std::tie()`。
- en: How to do it...
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To return multiple values from a function using a compiler that supports C++17 you
    should do the following:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用支持C++17的编译器从函数返回多个值，应该执行以下操作：
- en: Use an `std::tuple` for the return type.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`std::tuple`作为返回类型。
- en: '[PRE107]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Use structured bindings to unpack the values of the tuple into named objects.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用结构化绑定将元组的值解包到命名对象中。
- en: '[PRE108]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Use decomposition declaration to bind the returned values to variables inside
    an `if` statement or `switch` statement.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用分解声明将返回的值绑定到`if`语句或`switch`语句中的变量。
- en: '[PRE109]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: How it works...
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Structured bindings are a language feature that works just like `std::tie()`,
    except that we don't have to define named variables for each value that needs
    to be unpacked explicitly with `std::tie()`. With structured bindings, we define
    all named variables in a single definition using the `auto` specifier so that
    the compiler can infer the correct type for each variable.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化绑定是一种语言特性，其工作方式与`std::tie()`完全相同，只是我们不必为每个需要使用`std::tie()`显式解包的值定义命名变量。通过结构化绑定，我们可以使用`auto`说明符在单个定义中定义所有命名变量，以便编译器可以推断出每个变量的正确类型。
- en: 'To exemplify this, let''s consider the case of inserting items in a `std::map`.
    The insert method returns a `std::pair` containing an iterator to the inserted
    element or the element that prevented the insertion, and a boolean indicating
    whether the insertion was successful or not. The following code is very explicit
    and the use of `second` or `first->second` makes the code harder to read because
    you need to constantly figure out what they represent:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，让我们考虑在`std::map`中插入项目的情况。插入方法返回一个`std::pair`，其中包含插入的元素的迭代器或阻止插入的元素，以及一个布尔值，指示插入是否成功。下面的代码非常明确，使用`second`或`first->second`使得代码更难阅读，因为您需要不断弄清它们代表什么：
- en: '[PRE110]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The preceding code can be made more readable with the use of `std::tie`, that
    unpacks tuples into individual objects (and works with `std::pair` because `std::tuple`
    has a converting assignment from `std::pair`):'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`std::tie`，可以使上述代码更易读，它将元组解包为单独的对象（并且可以与`std::pair`一起使用，因为`std::tuple`从`std::pair`具有转换赋值）：
- en: '[PRE111]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The code is not necessarily simpler because it requires defining in advance
    the objects that the pair is unpacked to. Similarly, the more elements the tuple
    has the more objects you need to define, but using named objects makes the code
    easier to read.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码并不一定更简单，因为它需要预先定义成对解包的对象。同样，元组的元素越多，你需要定义的对象就越多，但使用命名对象使得代码更易于阅读。
- en: 'C++17 structured bindings elevate the unpacking of tuple elements into named
    objects to the rank of a language feature; it does not require the use of `std::tie()`,
    and objects are initialized when declared:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: C++17结构化绑定将元组元素的解包提升为一种语言特性；它不需要使用`std::tie()`，并且在声明时初始化对象：
- en: '[PRE112]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The use of multiple blocks in the above example is necessary because variables
    cannot be redeclared in the same block, and structured bindings imply a declaration
    using the `auto` specifier. Therefore, if you need to make multiple calls like
    in the example above and use structured bindings you must either use different
    variable names or multiple blocks as shown above. An alternative to that is to
    avoid structured bindings and use `std::tie()`, because it can be called multiple
    times with the same variables, therefore you only need to declare them once.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 上面示例中使用多个块是必要的，因为变量不能在同一块中重新声明，并且结构化绑定意味着使用`auto`说明符进行声明。因此，如果您需要像上面的示例中那样进行多次调用并使用结构化绑定，您必须使用不同的变量名称或像上面所示的多个块。一个替代方法是避免结构化绑定并使用`std::tie()`，因为它可以多次使用相同的变量进行调用，因此您只需要声明它们一次。
- en: 'In C++17, it is also possible to declare variables in `if` and `switch` statements
    with the form `if(init; condition)` and `switch(init; condition)`. This could
    be combined with structured bindings to produce simpler code. In the following
    example, we attempt to insert a new value into a map. The result of the call is
    unpacked into two variables, `it` and `inserted`, defined in the scope of the
    `if` statement in the initialization part. The condition of the `if` statement
    is evaluated from the value of the inserted object:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17中，还可以使用`if(init; condition)`和`switch(init; condition)`的形式在`if`和`switch`语句中声明变量。这可以与结构化绑定结合使用以生成更简单的代码。在下面的示例中，我们尝试将一个新值插入到map中。调用的结果被解包到两个变量`it`和`inserted`中，它们在`if`语句的初始化部分中定义。`if`语句的条件是从插入的对象的值中评估出来的：
- en: '[PRE113]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
