- en: Converting and Casting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换和转型
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Converting strings to numbers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将字符串转换为数字
- en: Converting numbers to strings
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数字转换为字符串
- en: Converting numbers to numbers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数字转换为数字
- en: Converting user-defined types to/from strings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将用户定义的类型转换为/从字符串
- en: Converting smart pointers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换智能指针
- en: Casting polymorphic objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换多态对象
- en: Parsing simple input
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析简单输入
- en: Parsing complex input
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析复杂输入
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Now, that we know some of the basic Boost types, it is time to get to know data-converting
    functions. In this chapter, we'll see how to convert strings, numbers, pointers,
    and user-defined types to each other, how to safely cast polymorphic types, and
    how to write small and big parsers right inside the C++ source files.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道了一些基本的Boost类型，是时候了解数据转换函数了。在本章中，我们将看到如何将字符串、数字、指针和用户定义的类型相互转换，如何安全地转换多态类型，以及如何在C++源文件中编写小型和大型解析器。
- en: Converting strings to numbers
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将字符串转换为数字
- en: 'Converting strings to numbers in C++ makes a lot of people depressed because
    of their inefficiency and user unfriendliness. See how string `100` can be converted
    to `int`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中将字符串转换为数字会让很多人感到沮丧，因为它们效率低下且不友好。看看如何将字符串`100`转换为`int`：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is better not to think, how many unnecessary operations, virtual function
    calls, atomic operations, and memory allocations occurred during the conversion
    from earlier. By the way, we do not need the `iss` variable any more, but it will
    be alive until the end of scope.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最好不要去想，之前的转换中发生了多少不必要的操作、虚函数调用、原子操作和内存分配。顺便说一句，我们不再需要`iss`变量，但它会一直存在直到作用域结束。
- en: 'C methods are not much better:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: C方法也不好：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Did it convert the whole value to `int` or stopped somewhere in the middle?
    To understand that we must check the content of the `end` variable. After that
    we'll have a useless `end` variable getting in the way until the end of scope.
    And we wanted an `int`, but `strtol` returns `long int`. Did the converted value
    fit in `int`?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 它是否将整个值转换为`int`，还是在中途停止了？要理解这一点，我们必须检查`end`变量的内容。之后，我们将有一个无用的`end`变量一直存在直到作用域结束。而我们想要一个`int`，但`strtol`返回`long
    int`。转换后的值是否适合`int`？
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: Only basic knowledge of C++ and standard library is required for this recipe.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方只需要基本的C++和标准库知识。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'There is a library in Boost, which will help you cope with depressing difficulty
    of string to number conversions. It is called `Boost.LexicalCast` and consists
    of a `boost::bad_lexical_cast` exception class and a few `boost::lexical_cast`
    and `boost::conversion::try_lexical_convert` functions:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Boost中有一个库，可以帮助您应对令人沮丧的字符串到数字转换困难。它被称为`Boost.LexicalCast`，包括一个`boost::bad_lexical_cast`异常类和一些`boost::lexical_cast`和`boost::conversion::try_lexical_convert`函数：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It can be used even for non-zero-terminated strings:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 它甚至可以用于非零终止的字符串：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `boost::lexical_cast` function accepts string as input and converts it
    to the type specified in triangular brackets. The `boost::lexical_cast` function
    will even check bounds for you:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::lexical_cast`函数接受字符串作为输入，并将其转换为三角括号中指定的类型。`boost::lexical_cast`函数甚至会为您检查边界：'
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code outputs:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码输出：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It also checks for the correct syntax of input and throws an exception if input
    is wrong:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 它还检查输入的正确语法，并在输入错误时抛出异常：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Since Boost 1.56, there is a `boost::conversion::try_lexical_convert` function
    that reports errors by return code. It could be useful in performance critical
    places where bad input could often occur:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 自Boost 1.56以来，有一个`boost::conversion::try_lexical_convert`函数，通过返回代码报告错误。它可能在性能关键的地方很有用，那里经常会出现错误的输入：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There's more...
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '`lexical_cast`, just like all `std::stringstream` classes, uses `std::locale`
    and can convert localized numbers, but also has an impressive set of optimizations
    for **C locale** and for locales without number groupings:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`lexical_cast`，就像所有`std::stringstream`类一样，使用`std::locale`并且可以转换本地化数字，但也具有对**C语言环境**和没有数字分组的环境的令人印象深刻的优化集：'
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The C++ standard library has no `lexical_cast`, but since C++17 has `std::from_chars`
    functions that could be used to create amazingly fast generic converters. Note
    that those converters do not use locales at all, so they have slightly different
    functionality because of that. `std::from_chars` functions were designed to not
    allocate memory, do not throw exceptions, and have no atomic or some other heavy
    operations.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库没有`lexical_cast`，但自C++17以来有`std::from_chars`函数，可以用于创建惊人快速的通用转换器。请注意，这些转换器根本不使用区域设置，因此它们具有略有不同的功能。`std::from_chars`函数旨在不分配内存，不抛出异常，并且没有原子或其他繁重的操作。
- en: See also
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Refer to the *Converting numbers to strings* recipe for information about the
    `boost::lexical_cast` performance.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`boost::lexical_cast`性能的信息，请参阅*将数字转换为字符串*配方。
- en: The official documentation of `Boost.LexicalCast` contains some examples, performance
    measures, and answers to frequently asked questions. It is available at [http://boost.org/libs/lexical_cast](http://boost.org/libs/lexical_cast).
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.LexicalCast`的官方文档包含一些示例、性能测量和常见问题的答案。它可以在[http://boost.org/libs/lexical_cast](http://boost.org/libs/lexical_cast)上找到。'
- en: Converting numbers to strings
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数字转换为字符串
- en: In this recipe, we will continue discussing the lexical conversions, but now
    we will be converting numbers to strings using `Boost.LexicalCast`. As usual,
    `boost::lexical_cast` will provide a very simple way to convert the data.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将继续讨论词法转换，但现在我们将使用`Boost.LexicalCast`将数字转换为字符串。与往常一样，`boost::lexical_cast`将提供一种非常简单的方法来转换数据。
- en: Getting ready
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: Only basic knowledge of C++ and a standard library is required for this recipe.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方只需要基本的C++和标准库知识。
- en: How to do it...
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s convert integer `100` to `std::string` using `boost::lexical_cast`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`boost::lexical_cast`将整数`100`转换为`std::string`：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Compare it against the traditional C++ conversion method:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的C++转换方法进行比较：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And against the C conversion method:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以及与C转换方法相比：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `boost::lexical_cast` function may also accept numbers as input and convert
    them to a string type specified as the template parameter (in triangular brackets).
    This is pretty close to what we have done in the previous recipe.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::lexical_cast`函数也可以接受数字作为输入，并将它们转换为模板参数（三角括号中）指定的字符串类型。这与我们在上一个食谱中所做的非常接近。'
- en: There's more...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: A careful reader will notice that in case of `lexical_cast`, we have an additional
    call to string copy the constructor and that such a call degrades performance.
    It is true, but only for old or bad compilers. Modern compilers implement a **Named
    Return Value Optimization** (**NRVO**), which eliminates the unnecessary calls
    to copy constructors and destructor. Even if the C++11-compatible compilers don't
    detect NRVO, they use a move constructor of `std::string`, which is fast and efficient.
    The *Performance* section of the `Boost.LexicalCast` documentation shows the conversion
    speed on different compilers for different types. In most cases, `lexical_cast`
    is faster than the `std::stringstream` and `printf` functions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 细心的读者会注意到，在`lexical_cast`的情况下，我们有一个额外的调用来复制字符串构造函数，这样的调用会降低性能。这是真的，但只对旧的或不好的编译器有效。现代编译器实现了**命名返回值优化**（**NRVO**），它消除了不必要的复制构造函数和析构函数的调用。即使C++11兼容的编译器没有检测到NRVO，它们也会使用`std::string`的移动构造函数，这是快速和高效的。`Boost.LexicalCast`文档的*性能*部分显示了不同编译器对不同类型的转换速度。在大多数情况下，`lexical_cast`比`std::stringstream`和`printf`函数更快。
- en: If `boost::array` or `std::array` is passed to `boost::lexical_cast` as the
    output parameter type, less dynamic memory allocations will occur (or there will
    be no memory allocations at all, it depends on the `std::locale` implementation).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`boost::array`或`std::array`作为输出参数类型传递给`boost::lexical_cast`，将会发生较少的动态内存分配（或者根本不会有内存分配，这取决于`std::locale`的实现）。
- en: C++11 has `std::to_string` and `std::to_wstring` functions that are declared
    in the `<string>` header. Those functions use locales and have behavior very close
    to `boost::lexical_cast<std::string>` and `boost::lexical_cast<std::wstring>`,
    respectively. C++17 has `std::to_chars` functions that convert numbers to char
    arrays amazingly fast. `std::to_chars` do not allocate memory, do not throw exception,
    and may report errors using error codes. If you need really fast conversion functions
    that do not use locales, then use `std::to_chars`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: C++11有`std::to_string`和`std::to_wstring`函数，它们声明在`<string>`头文件中。这些函数使用区域设置，并且行为非常接近`boost::lexical_cast<std::string>`和`boost::lexical_cast<std::wstring>`。C++17有`std::to_chars`函数，可以将数字转换为字符数组，速度非常快。`std::to_chars`不分配内存，不抛出异常，并且可以使用错误代码报告错误。如果需要真正快速的转换函数而不使用区域设置，那么使用`std::to_chars`。
- en: See also
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Boost's official documentation contains tables that compare the `lexical_cast`
    performance against other conversion approaches. In most cases, `lexical_cast`
    is faster than other approaches [http://boost.org/libs/lexical_cast](http://boost.org/libs/lexical_cast).
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost官方文档包含了比较`lexical_cast`性能与其他转换方法的表格。在大多数情况下，`lexical_cast`比其他方法更快[http://boost.org/libs/lexical_cast](http://boost.org/libs/lexical_cast)。
- en: The *Converting strings to numbers* recipe.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将字符串转换为数字*食谱。'
- en: The *Converting user defined types to/from strings* recipe.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将用户定义的类型转换为/从字符串*食谱。'
- en: Converting numbers to numbers
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数字转换为数字
- en: 'You might remember situations where you were writing the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得写以下代码的情况：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Usually, programmers just ignore such warnings by implicitly casting to the
    `unsigned short` datatype, as demonstrated in the following code snippet:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，程序员会通过将`unsigned short`数据类型隐式转换来忽略这些警告，就像以下代码片段中所示：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'But, what if `foo()` returns numbers that do not fit into `unsigned short`?
    This leads to hard detectable errors. Such errors may exist in code for years
    before they get caught and fixed. Take a look at the `foo()` definition:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果`foo()`返回的数字不适合`unsigned short`怎么办？这会导致难以检测的错误。这样的错误可能存在多年，直到被捕获和修复。看一下`foo()`的定义：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Getting ready
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Only basic knowledge of C++ is required for this recipe.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱需要对C++的基本知识。
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The library `Boost.NumericConversion` provides a solution for such cases. Just
    replace `static_cast` with `boost::numeric_cast`. The latter will throw an exception
    when the source value cannot be stored in target:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 库`Boost.NumericConversion`为这种情况提供了解决方案。只需用`boost::numeric_cast`替换`static_cast`。当源值无法存储在目标中时，后者将抛出异常：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, if we run `test_function()`, it will output the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行`test_function()`，它将输出如下：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can even detect specific overflow types:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以检测特定的溢出类型：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `test_function1()` function will output the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_function1()`函数将输出如下：'
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: '`boost::numeric_cast` checks if the value of the input parameter fits into
    the new type without losing data and throws an exception if something is lost
    during conversion.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::numeric_cast`检查输入参数的值是否适合新类型，而不会丢失数据，并且如果在转换过程中丢失了数据，则会抛出异常。'
- en: The `Boost.NumericConversion` library has a very fast implementation. It can
    do a lot of work at compile time, for example, when converting to types of a wider
    range, the source will be converted to target type by just via `static_cast`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.NumericConversion`库有一个非常快的实现。它可以在编译时完成大量工作，例如，当转换为更宽范围的类型时，源将通过`static_cast`转换为目标类型。'
- en: There's more...
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `boost::numeric_cast` function is implemented via `boost::numeric::converter`,
    which can be tuned to use different overflow, range checking, and rounding policies.
    But usually, `numeric_cast` is just what you need.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::numeric_cast`函数是通过`boost::numeric::converter`实现的，可以调整使用不同的溢出、范围检查和舍入策略。但通常，`numeric_cast`就是您需要的。'
- en: 'Here is a small example that demonstrates how to make our own overflow handler
    for `boost::numeric::cast`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个小例子，演示了如何为`boost::numeric::cast`制作我们自己的溢出处理程序：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here''s how to use our custom converter:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何使用我们的自定义转换器：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding code outputs the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码输出如下：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Even C++17 does not have facilities for safe numeric casts. However, work in
    that direction is ongoing. We have all the chances to see such facilities after
    the year 2020.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 即使C++17也没有提供安全的数字转换功能。然而，这方面的工作正在进行中。我们有望在2020年后看到这样的功能。
- en: See also
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The Boost''s official documentation contains detailed description of all the
    template parameters of numeric converter; it is available at the following link:
    [http://boost.org/libs/numeric/conversion](http://boost.org/libs/numeric/conversion)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Boost的官方文档包含了对数字转换器模板参数的详细描述；可以在以下链接找到：[http://boost.org/libs/numeric/conversion](http://boost.org/libs/numeric/conversion)
- en: Converting user-defined types to/from strings
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将用户定义的类型转换为字符串和从字符串转换为数字
- en: There is a feature in `Boost.LexicalCast` that allows users to use their own
    types with `lexical_cast`. This feature requires from the user to write the correct
    `std::ostream` and `std::istream` operators for the type.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.LexicalCast`中有一个功能，允许用户使用自己的类型进行`lexical_cast`。这需要用户为该类型编写正确的`std::ostream`和`std::istream`操作符。'
- en: How to do it...
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'All you need is to provide `operator<<` and `operator>>` stream operators.
    If your class is already streamable, nothing needs to be done:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你只需要提供`operator<<`和`operator>>`流操作符。如果你的类已经可以进行流操作，就不需要做任何事情：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we may use `boost::lexical_cast` for conversions to and from the `negative_number`
    class. Here''s an example:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`boost::lexical_cast`将`negative_number`类转换为字符串和从字符串转换为`negative_number`类。这里有一个例子：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `boost::lexical_cast` function can detect and use stream operators to convert
    user-defined types.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::lexical_cast`函数可以检测并使用流操作符来转换用户定义的类型。'
- en: The `Boost.LexicalCast` library has many optimizations for basic types and they
    will be triggered, when user-defined type is being cast to basic type or when
    basic type is being cast to user-defined type.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.LexicalCast`库对基本类型有许多优化，当用户定义的类型被转换为基本类型，或者基本类型被转换为用户定义的类型时，这些优化将被触发。'
- en: There's more...
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `boost::lexical_cast` function may also convert to wide character strings,
    but the correct `basic_istream` and `basic_ostream` operator overloads are required
    for that:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::lexical_cast`函数也可以将转换为宽字符字符串，但需要正确的`basic_istream`和`basic_ostream`操作符重载：'
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `Boost.LexicalCast` library is not a part of C++. A lot of Boost libraries
    use it, and I hope that it will make your life easier as well.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.LexicalCast`库不是C++的一部分。许多Boost库都使用它，我希望它也能让你的生活变得更轻松。'
- en: See also
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `Boost.LexicalCast` documentation contains some examples, performance measures,
    and answers to frequently asked questions; it is available at [http://boost.org/libs/lexical_cast](http://boost.org/libs/lexical_cast)
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.LexicalCast`文档包含了一些示例、性能测量和常见问题的解答；链接为[http://boost.org/libs/lexical_cast](http://boost.org/libs/lexical_cast)'
- en: The *Converting strings to numbers* recipe
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将字符串转换为数字*的方法'
- en: The *Converting numbers to strings* recipe
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将数字转换为字符串*的方法'
- en: Converting smart pointers
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换智能指针
- en: 'Here''s a problem:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个问题：
- en: 'You have a class named `some_class`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你有一个名为`some_class`的类：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You have a third-party API that returns constructed `derived` by shared pointer
    to `base` and accepts shared pointer to `const derived` in other functions:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你有一个第三方API，返回通过共享指针构造的`derived`，并在其他函数中接受共享指针到`const derived`：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You have to make the following code work:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你必须让以下代码工作：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How do you solve the problem in a nice manner?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如何以一种好的方式解决这个问题？
- en: Getting started
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: Basic knowledge of C++ and smart pointers is required for this recipe.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方需要对C++和智能指针有基本的了解。
- en: How to do it...
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The solution would be to use special casts for smart pointers. In this particular
    case, we need to use `dynamic_cast` functionality, so we are using `boost::dynamic_pointer_cast`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是使用智能指针的特殊转换。在这种特殊情况下，我们需要使用`dynamic_cast`功能，因此我们使用`boost::dynamic_pointer_cast`：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works...
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The Boost library has a lot of functions for smart pointer conversions. All
    of them accept a smart pointer and a template parameter `T`, where `T` is the
    desired template type of the smart pointer. Those conversion operator mimic the
    behavior of built-in casts while correctly managing the reference counting and
    other smart pointer internals:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Boost库有很多用于智能指针转换的函数。所有这些函数都接受一个智能指针和一个模板参数`T`，其中`T`是智能指针的所需模板类型。这些转换操作符模仿了内置转换的行为，同时正确管理引用计数和其他智能指针内部：
- en: '`boost::static_pointer_cast<T>(p)` - does `static_cast<T*>(p.get())`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::static_pointer_cast<T>(p)` - 执行`static_cast<T*>(p.get())`'
- en: '`boost::dynamic_pointer_cast<T>(p)` - does `dynamic_cast<T*>(p.get())`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::dynamic_pointer_cast<T>(p)` - 执行`dynamic_cast<T*>(p.get())`'
- en: '`boost::const_pointer_cast<T>(p)` - does `const_cast<T*>(p.get())`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::const_pointer_cast<T>(p)` - 执行`const_cast<T*>(p.get())`'
- en: '`boost::reinterpret_pointer_cast<T>(p)` - does `reinterpret_cast<T*>(p.get())`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::reinterpret_pointer_cast<T>(p)` - 执行`reinterpret_cast<T*>(p.get())`'
- en: There's more...
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: All the `boost::*_pointer_cast` functions can work with smart pointers from
    the standard library and C pointers if you include `<boost/pointer_cast.hpp>`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的`boost::*_pointer_cast`函数都可以使用标准库和C指针的智能指针，只要包含`<boost/pointer_cast.hpp>`。
- en: In C++11, the standard library has `std::static_pointer_cast`, `std::dynamic_pointer_cast`,
    and `std::const_pointer_cast` defined in the `<memory>` header, however, it is
    only for `std::shared_ptr`. The C++17 standard library has `std::reinterpret_pointer_cast`,
    but it is only for `std::shared_ptr`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11中，标准库在`<memory>`头文件中定义了`std::static_pointer_cast`、`std::dynamic_pointer_cast`和`std::const_pointer_cast`，但只适用于`std::shared_ptr`。C++17标准库有`std::reinterpret_pointer_cast`，但只适用于`std::shared_ptr`。
- en: See also
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `Boost.SmartPointer` library documentation contains more examples on pointer
    casts for a standard library at [http://boost.org/libs/smart_ptr/pointer_cast.html](http://boost.org/libs/smart_ptr/pointer_cast.html)
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.SmartPointer`库文档包含了有关标准库指针转换的更多示例，链接为[http://boost.org/libs/smart_ptr/pointer_cast.html](http://boost.org/libs/smart_ptr/pointer_cast.html)'
- en: Casts reference for `boost::shared_ptr` is available at [http://boost.org/libs/smart_ptr/shared_ptr.htm](http://boost.org/libs/smart_ptr/shared_ptr.htm)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::shared_ptr`的转换参考可在[http://boost.org/libs/smart_ptr/shared_ptr.htm](http://boost.org/libs/smart_ptr/shared_ptr.htm)上找到'
- en: The *Casting polymorphic objects* recipe in this chapter will show you a better
    way of doing dynamic casts
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*Casting polymorphic objects*食谱将向您展示进行动态转换的更好方法
- en: Casting polymorphic objects
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换多态对象
- en: 'Imagine that some programmer designed such an awful interface as follows (this
    is a good example of how interfaces should not be written):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，某个程序员设计了一个如下糟糕的接口（这是接口不应该编写的一个很好的例子）：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Our task is to make a function that eats bananas, and throws exceptions if something
    different came instead of banana ( `try_produce_banana()` may return `nullptr`)so
    if we dereference a value returned by it without checking we are in danger of
    dereferencing a null pointer.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务是编写一个吃香蕉的函数，并在有其他东西代替香蕉时抛出异常（`try_produce_banana()`可能返回`nullptr`），因此如果我们在不检查的情况下解引用它返回的值，我们有可能解引用空指针。
- en: Getting started
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: Basic knowledge of C++ is required for this recipe.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱需要基本的C++知识。
- en: How to do it...
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'So we need to write the following code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要编写以下代码：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Ugly, isn''t it? `Boost.Conversion` provides a slightly better solution:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 丑陋，不是吗？`Boost.Conversion`提供了一个稍微更好的解决方案：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `boost::polymorphic_cast` function just wraps around code from the first
    example, and that is all. It checks input for null and then tries to do a dynamic
    cast. Any error during those operations will throw a `std::bad_cast` exception.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::polymorphic_cast`函数只是包装了第一个示例中的代码，就是这样。它检查输入是否为空，然后尝试进行动态转换。在这些操作期间的任何错误都将抛出`std::bad_cast`异常。'
- en: There's more...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `Boost.Conversion` library also has a `polymorphic_downcast` function, which
    should be used only for downcasts that certainly shall succeed. In debug mode
    (when `NDEBUG` is not defined), it will check for the correct downcast using `dynamic_cast`.
    When `NDEBUG` is defined, the `polymorphic_downcast` function will just do a `static_cast`
    operation. It is a good function to use in performance-critical sections, still
    leaving the ability to detect errors in debug compilations.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Conversion`库还有一个`polymorphic_downcast`函数，仅应用于肯定会成功的向下转换。在调试模式下（未定义`NDEBUG`时），它将使用`dynamic_cast`检查正确的向下转换。当定义了`NDEBUG`时，`polymorphic_downcast`函数将执行`static_cast`操作。这是一个在性能关键部分使用的好函数，仍然具有在调试编译中检测错误的能力。'
- en: Since Boost 1.58 there is a `boost::polymorphic_pointer_downcast` and `boost::polymorphic_pointer_cast`
    function in `Boost.Conversion` libraries. Those functions allow you to safely
    cast smart pointers and have the same characteristics as `boost::polymorphic_cast`
    and `boost::polymorphic_downcast`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 自Boost 1.58以来，在Boost.Conversion库中有一个`boost::polymorphic_pointer_downcast`和`boost::polymorphic_pointer_cast`函数。这些函数允许您安全地转换智能指针，并具有与`boost::polymorphic_cast`和`boost::polymorphic_downcast`相同的特性。
- en: The C++ standard library lacks `polymorphic_cast` and `polymorphic_downcast`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库缺乏`polymorphic_cast`和`polymorphic_downcast`。
- en: See also
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Initially, the `polymorphic_cast` idea was proposed in the book *The C++ Programming
    Language*, *Bjarne Stroustrup*. Refer to this book for more information and some
    good ideas on different topics.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最初，`polymorphic_cast`的想法是在书籍*The C++ Programming Language*，*Bjarne Stroustrup*中提出的。有关更多信息和一些关于不同主题的好主意，请参考此书。
- en: The official documentation may also be helpful; it is available at [http://boost.org/libs/conversion](http://boost.org/libs/conversion).
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方文档也可能有所帮助；可在[http://boost.org/libs/conversion](http://boost.org/libs/conversion)上找到。
- en: Refer to the previous recipe for more information on casting smart pointers.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关转换智能指针的更多信息，请参考前一篇食谱。
- en: Parsing simple input
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析简单输入
- en: 'It is a common task to parse a small text. Such situations are always a dilemma:
    shall we use some third-party professional and good tools for parsing such as
    Bison or ANTLR, or shall we try to write it by hand using only C++ and standard
    library? The third-party tools are good for handling the parsing of complex texts,
    and it is easy to write parsers using them, but they require additional tools
    for creating C++ or C code from their grammar, and add more dependencies to your
    project.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 解析小文本是一项常见任务。这种情况总是一个两难选择：我们应该使用一些第三方专业和良好的解析工具，如Bison或ANTLR，还是应该尝试仅使用C++和标准库手动编写？第三方工具适用于处理复杂文本的解析，并且很容易使用它们编写解析器，但它们需要额外的工具来从它们的语法创建C++或C代码，并为您的项目添加更多依赖项。
- en: Handwritten parsers are usually hard to maintain, but they require nothing except
    a C++ compiler.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 手写解析器通常难以维护，但除了C++编译器外，不需要任何东西。
- en: '![](img/00005.jpeg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00005.jpeg)'
- en: 'Let''s start from a very simple task to parse a date in the ISO format as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个非常简单的任务开始，解析ISO格式的日期如下：
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following are the examples of possible input:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可能输入的示例：
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We will need parser's grammar from the following link [http://www.ietf.org/rfc/rfc333:](http://www.ietf.org/rfc/rfc3339.txt:)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从以下链接获取解析器的语法[http://www.ietf.org/rfc/rfc333:](http://www.ietf.org/rfc/rfc3339.txt:)
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure that you are familiar with the placeholder's concept or read the *Reordering
    parameters of function* and *Binding a value as a function parameter* recipes
    in [Chapter 1](part0029.html#RL0A0-712b4ba1126a4c7c89e1d44de61b4bdd), *Starting
    to Write Your Application*. Basic knowledge of parsing tools would be good.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您熟悉占位符的概念，或者阅读[第1章](part0029.html#RL0A0-712b4ba1126a4c7c89e1d44de61b4bdd)中的*重新排列函数的参数*和*将值绑定为函数参数*的示例，*开始编写您的应用程序*。了解解析工具的基本知识会很有帮助。
- en: How to do it...
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let me introduce to you a `Boost.Spirit` library. It allows writing parsers
    (as well as lexers and generators) directly in C++ code, which are immediately
    executable (do not require additional tools for C++ code generation). Grammar
    of `Boost.Spirit` is very close to **Extended Backus-Naur Form** (**EBNF**), which
    is used for expressing grammar by many standards and understood by other popular
    parsers. Grammar at the beginning of this chapter is in EBNF:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我向你介绍一下`Boost.Spirit`库。它允许直接在C++代码中编写解析器（以及词法分析器和生成器），这些解析器可以立即执行（不需要额外的工具来生成C++代码）。`Boost.Spirit`的语法非常接近**扩展巴科斯-瑙尔范式**（**EBNF**），这是许多标准用于表达语法并被其他流行的解析器理解的语法。本章开头的语法就是EBNF：
- en: 'We need to include the following headers:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要包括以下头文件：
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, it''s time to make a `date` structure to hold the parsed data:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候创建一个`date`结构来保存解析的数据了：
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s look at the parser (step-by-step description of how it works can be
    found in the next section):'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们来看看解析器（如何工作的逐步说明可以在下一节中找到）：
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, we may use this parser wherever we want:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在任何地方使用这个解析器：
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works...
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This is a very simple implementation; it does not check the count of digits
    for numbers. Parsing occurs in the `boost::spirit::qi::parse` function. Let''s
    simplify it a little bit, removing the actions on successful parsing:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的实现；它不检查数字的位数。解析发生在`boost::spirit::qi::parse`函数中。让我们简化一下，去掉成功解析时的动作：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `first` argument points to the beginning of data to parse. It must be a
    nonconstant variable because the `parse` function will modify it to point to the
    end of the parsed sequence.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`first`参数指向要解析的数据的开头。它必须是一个非常量变量，因为`parse`函数将修改它，使其指向解析序列的末尾。'
- en: The `end` argument points to the position that goes after the last element to
    parse. `first` and `end` shall be iterators or pointers.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`end`参数指向解析的最后一个元素之后的位置。`first`和`end`必须是迭代器或指针。'
- en: 'The third argument to the function is a parsing rule. It looks exactly like
    the EBNF rule:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的第三个参数是解析规则。它看起来就像EBNF规则一样：
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We just replaced white spaces with the `>>` operator.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是用`>>`运算符替换了空格。
- en: The `parse` function returns `true` on success. If we want to make sure that
    the whole string was successfully parsed, we need to check for the parser's return
    value and equality of the `end` and modified `first` iterators.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`parse`函数在成功时返回`true`。如果我们想确保整个字符串被成功解析，我们需要检查解析器的返回值以及`end`和修改后的`first`迭代器的相等性。'
- en: Now, we need to deal with actions on successful parse and this recipe will be
    over. Semantic actions in `Boost.Spirit` are written inside `[]` and they can
    be written using function pointers, function objects, `boost::bind`, `std::bind`
    (or the other `bind()` implementations), or C++11 lambda functions.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要处理成功解析时的动作，然后这个示例就结束了。`Boost.Spirit`中的语义动作写在`[]`中，可以使用函数指针、函数对象、`boost::bind`、`std::bind`（或其他`bind()`实现）或C++11
    lambda函数来编写。
- en: 'So, you could also write a rule for `YYYY` using C++11 lambda:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你也可以使用C++11 lambda为`YYYY`编写规则：
- en: '[PRE41]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You cannot put the lambda definition directly inside the `[]` because the C++
    compiler will think that it's an attribute. As a workaround, you can make an `auto`
    variable with the lambda function in it and use that variable in parser rule description
    (just like it was done in the preceding code snippet).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能直接将lambda定义放在`[]`中，因为C++编译器会认为它是一个属性。作为一种解决方法，你可以在其中创建一个带有lambda函数的`auto`变量，并在解析器规则描述中使用该变量（就像在前面的代码片段中所做的那样）。
- en: 'Now, let''s take a look at the month''s semantic action closer:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更仔细地看一下月份的语义动作：
- en: '[PRE42]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: For those who read the book from the beginning, the preceding code reminds about
    `boost::bind`, `boost::ref`, and placeholders. `ref(res.month)` means pass `res.month`
    as a modifiable reference and `_1` means the first input parameter, which would
    be a number (result of `ushort_` parsing).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从头开始阅读本书的人来说，前面的代码提醒了`boost::bind`、`boost::ref`和占位符。`ref(res.month)`表示将`res.month`作为可修改的引用传递，`_1`表示第一个输入参数，即一个数字（`ushort_`解析的结果）。
- en: There's more...
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Now let''s modify our parser, so it could take care of the digits count. For
    that purpose, we will take the `unit_parser` class template and just set up the
    correct parameters:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们修改我们的解析器，使其能够处理数字的位数。为此，我们将使用`unit_parser`类模板，并设置正确的参数：
- en: '[PRE43]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Don't worry if those examples seem complicated. The first time I was also frightened
    by `Boost.Spirit`, but now it really simplifies my life. You are extremely brave,
    if this code does not scare you.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些例子看起来复杂，不要担心。第一次我也被`Boost.Spirit`吓到了，但现在它真的简化了我的生活。如果这段代码不吓到你，那么你真的很勇敢。
- en: 'Do not write parsers in header files because it increases compilation times
    of your project. Write parsers in source files and hide all the `Boost.Spirit`
    internals in that file. If we adjust the previous example to follow that rule
    then the header file would look like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在头文件中编写解析器，因为这会增加项目的编译时间。在源文件中编写解析器，并将所有`Boost.Spirit`的内部内容隐藏在该文件中。如果我们调整前面的例子来遵循这个规则，那么头文件将如下所示：
- en: '[PRE44]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Also take care of iterator types passed to the `boost::spirit::parse` function.
    The less different types of iterators you use, the less size of binary you get.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意传递给`boost::spirit::parse`函数的迭代器类型。你使用的迭代器类型越少，二进制文件的大小就越小。
- en: If you are now thinking that parsing date was simpler to implement by hand using
    standard library, you are right! But only for now. Take a look at the next recipe,
    it will give you more examples on `Boost.Spirit` usage and extend this example
    for cases, when writing parser by hand is harder than using `Boost.Spirit`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在认为手动使用标准库解析日期更简单，那么你是对的！但仅限于现在。看看下一个示例，它将为你提供更多关于`Boost.Spirit`的用法，并扩展这个例子，以处理手动编写解析器比使用`Boost.Spirit`更困难的情况。
- en: 'The `Boost.Spirit` library is not a part of C++ and would not be proposed for
    inclusion in the nearest future. However, it works pretty well with modern C++
    features, so use them if your compiler supports C++11:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Spirit`库不是C++的一部分，并且在不久的将来也不会被提议包含在其中。但是，它与现代C++特性非常兼容，因此如果您的编译器支持C++11，请使用它们：'
- en: '[PRE45]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: See also
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Reordering parameters of function* recipe in [Chapter 1](part0029.html#RL0A0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Starting to Write Your Application*.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](part0029.html#RL0A0-712b4ba1126a4c7c89e1d44de61b4bdd)的*开始编写您的应用程序*中的*重新排列函数参数*教程。
- en: The *Binding a value as a function parameter* recipe.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将值绑定为函数参数*教程。'
- en: '`Boost.Spirit` is a huge header-only library. A separate book may be written
    about it. Feel free to use its documentation at [http://boost.org/libs/spirit.](http://boost.org/libs/spirit)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Spirit`是一个庞大的仅头文件库。可以单独编写一本书来介绍它。请随时使用其文档[http://boost.org/libs/spirit](http://boost.org/libs/spirit)。'
- en: Parsing complex input
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析复杂输入
- en: 'In the previous recipe, we were writing a simple parser for date. Imagine that
    some time has passed and the task has changed. Now, we need to write a date-time
    parser that supports multiple input formats and zone offsets. Our parser must
    understand the following inputs:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个教程中，我们编写了一个简单的日期解析器。想象一下，一些时间已经过去，任务已经改变。现在，我们需要编写一个支持多种输入格式和区域偏移的日期时间解析器。我们的解析器必须理解以下输入：
- en: '[PRE46]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Getting ready
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll be using the `Boost.Spirit` library, which was described in the *Parsing
    simple input* recipe. Read it before getting hands on with this recipe.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用在*解析简单输入*教程中描述的`Boost.Spirit`库。在开始本教程之前，请先阅读该教程。
- en: How to do it...
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start by writing a date-time structure that will hold a parsed result:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先编写一个日期时间结构，用于保存解析的结果：
- en: '[PRE47]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, let''s write a function for setting the zone offset:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个设置区域偏移的函数：
- en: '[PRE48]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Writing a parser can be split into writing a few simple parsers. We start with
    writing a zone-offset parser:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写解析器可以分为编写几个简单的解析器。我们首先编写一个区域偏移解析器：
- en: '[PRE49]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let''s finish our example by writing the remaining parsers:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过编写剩余的解析器来完成我们的示例：
- en: '[PRE50]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How it works...
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A very interesting variable here is `boost::spirit::qi::rule<const char*, void()>`.
    It erases the exact type of a resulting parser and allows you to write parsers
    for recursive grammars. It also allows you to write parsers in source files and
    export them to headers without significantly affecting compilation times of your
    project. For example:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这里非常有趣的一个变量是`boost::spirit::qi::rule<const char*, void()>`。它擦除了结果解析器的确切类型，并允许您为递归语法编写解析器。它还允许您在源文件中编写解析器并将其导出到头文件，而不会显著影响项目的编译时间。例如：
- en: '[PRE51]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note that this class implies optimization barrier for compilers, so do not use
    it when it is not required.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个类意味着编译器的优化障碍，因此在不需要时不要使用它。
- en: 'Sometimes we used `>> '':''` instead of `>> char_('':'')`. The first approach
    is more limited: you cannot bind actions to it and cannot do new rules by just
    combining chars (for example, you cannot write `char_(''+'')|char_(''-'')` without
    using `char_` at all). But for better performance use the first approach, because
    some compilers may optimize it slightly better.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们使用`>> ':'`而不是`>> char_(':')`。第一种方法更有限：您无法将操作绑定到它，也无法通过组合字符来创建新规则（例如，您无法只使用`char_`就写出`char_('+')|char_('-')`）。但是为了更好的性能，请使用第一种方法，因为一些编译器可能会对其进行轻微优化。
- en: There's more...
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We can make our example slightly faster by removing the `rule<>` objects that
    do type erasure. Just replace them with the C++11 `auto` keyword.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 通过删除进行类型擦除的`rule<>`对象，可以使我们的示例稍微更快。只需用C++11的`auto`关键字替换它们。
- en: The `Boost.Spirit` library generates very fast parsers; there are some performance
    measures at the official site. Official documentation contains advanced recommendations
    for writing faster parsers.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Spirit`库生成非常快速的解析器；官方网站上有一些性能指标。官方文档包含了编写更快解析器的高级建议。'
- en: The usage of `boost::phoenix::bind` is not mandatory, but without it the rule
    that parses specific zone offset in `timezone_parser` will be dealing with the
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`boost::phoenix::bind`并不是强制的，但是如果不使用它，`timezone_parser`中解析特定区域偏移的规则将会处理
- en: '`boost::fusion::vector<char, unsigned short, unsigned short>` type. Using `bind(&set_zone_offset,
    ref(ret), _1, _2, _3)` seems to be a more reader-friendly solution.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::fusion::vector<char, unsigned short, unsigned short>`类型。使用`bind(&set_zone_offset,
    ref(ret), _1, _2, _3)`似乎是一个更易读的解决方案。'
- en: When parsing big files, consider reading the *Fastest way to read files* recipe
    in [Chapter 11](part0569.html#GUKG20-712b4ba1126a4c7c89e1d44de61b4bdd), *Working
    with the System*, because incorrect work with files may slow down your program
    much more than parsing.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析大文件时，请考虑阅读[第11章](part0569.html#GUKG20-712b4ba1126a4c7c89e1d44de61b4bdd)的*读取文件的最快方法*教程，因为与文件的不正确处理相比，解析可能会使您的程序变慢得多。
- en: Compiling the code that uses the `Boost.Spirit` (or `Boost.Fusion`) library
    may take a lot of time, because of the huge amount of template instantiations.
    When experimenting with the `Boost.Spirit` library use modern compilers, they
    provide better compilation times.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Boost.Spirit`（或`Boost.Fusion`）库的代码编译可能需要很长时间，因为模板实例化的数量非常庞大。在尝试`Boost.Spirit`库时，请使用现代编译器，它们提供更好的编译时间。
- en: See also
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The `Boost.Spirit` library is worth writing a separate book, it's impossible
    to describe all of its features in a few recipes, so referring to the documentation
    will help you to get more information about it. It is available at [http://boost.org/libs/spirit](http://boost.org/libs/spirit)
    . There, you'll find much more examples, ready parsers, and information on how
    to write lexers and generators directly in C++11 code using Boost.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Spirit`库值得单独编写一本书，无法在几个教程中描述其所有特性，因此参考文档将帮助您获取更多信息。它可以在[http://boost.org/libs/spirit](http://boost.org/libs/spirit)找到。在那里，您将找到更多示例、准备好的解析器，以及如何使用Boost直接在C++11代码中编写词法分析器和生成器的信息。'
