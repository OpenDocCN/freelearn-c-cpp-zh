- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Writing Tests for the Project
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为项目编写测试
- en: 'In this chapter, we’re going to look at how CMake can help us with an incredibly
    important aspect of software development: **testing**. Testing is essential in
    any widely used or long-lived project to build confidence in its functionality
    and help avoid regressions as new features are added and improved. In a normal
    project, it’s strongly recommended to think about testing from the outset; introducing
    tests down the line can be a challenge. Fortunately, with how we’ve structured
    our project by breaking out functionality into separate libraries, testing becomes
    a lot simpler.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论 CMake 如何帮助我们处理软件开发中的一个极其重要的方面：**测试**。测试在任何广泛使用或长期存在的项目中都是至关重要的，它有助于建立对功能的信心，并在添加和改进新特性时帮助避免回归。在一个正常的项目中，强烈建议从一开始就考虑测试；之后引入测试会是一项挑战。幸运的是，借助我们通过将功能拆分为独立库的项目结构，测试变得更加简单。
- en: CMake provides a complimentary application called **CTest** to bring many kinds
    of testing together under one umbrella. We’ll see how to add tests to our libraries,
    as well as our application, and see how to leverage CTest to make running them
    from CMake easy.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 提供了一个名为 **CTest** 的附加应用程序，旨在将多种类型的测试整合到一个平台下。我们将看到如何将测试添加到我们的库中以及应用程序中，并了解如何利用
    CTest 使从 CMake 运行它们变得更简单。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding CTest
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 CTest
- en: Adding unit tests to a library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向库中添加单元测试
- en: Adding end-to-end tests to an application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向应用程序添加端到端测试
- en: Adding other kinds of tests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加其他类型的测试
- en: Using CDash with CTest
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CDash 与 CTest
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along, please ensure you have met the requirements outlined in [*Chapter
    1*](B21152_01.xhtml#_idTextAnchor019), *Getting Started*. These include the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章内容，请确保你已满足 [*第 1 章*](B21152_01.xhtml#_idTextAnchor019)《入门》的要求。这些要求包括以下内容：
- en: A Windows, Mac, or Linux machine with an up-to-date **operating** **system**
    (**OS**)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台运行最新 **操作系统**（**OS**）的 Windows、Mac 或 Linux 计算机
- en: A working C/C++ compiler (a system default is recommended for each platform
    if you don’t already have this)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可工作的 C/C++ 编译器（如果你还没有，建议使用每个平台的系统默认编译器）
- en: 'The code examples in this chapter can be found by following this link: [https://github.com/PacktPublishing/Minimal-CMake](https://github.com/PacktPublishing/Minimal-CMake).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例可以通过以下链接找到：[https://github.com/PacktPublishing/Minimal-CMake](https://github.com/PacktPublishing/Minimal-CMake)。
- en: Understanding CTest
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 CTest
- en: Before we begin looking at the details of adding CTest to our existing `CMakeLists.txt`
    files and using the `ctest` command-line application, it’s important to understand
    what CTest is, and, perhaps more importantly, what it is not.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始查看如何将 CTest 添加到现有的 `CMakeLists.txt` 文件并使用 `ctest` 命令行应用程序之前，理解 CTest 是什么，以及，或许更重要的是，理解它不是什麽，十分重要。
- en: There are two components to `CMakeLists.txt` files, used to describe and add
    tests, and the `ctest` **command-line interface** (**CLI**), which is used to
    run the tests after they have been compiled. CTest is not itself a language-specific
    testing library. It is perfectly reasonable to add tests to a project created
    with CMake without using CTest at all (for example, by creating a separate test
    executable that depends on a well-known testing library, such as Google Test ([https://github.com/google/googletest](https://github.com/google/googletest))
    or Catch2 ([https://github.com/catchorg/Catch2](https://github.com/catchorg/Catch2)).
    CTest is not a substitute for one of these libraries that provide excellent support
    for writing unit and integration style tests.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMakeLists.txt` 文件有两个组成部分，用于描述和添加测试，另一个是 `ctest` **命令行界面**（**CLI**），用于在编译测试后运行它们。CTest
    本身并不是一个特定语言的测试库。完全可以在一个由 CMake 创建的项目中添加测试，而根本不使用 CTest（例如，通过创建一个依赖于著名测试库的单独测试可执行文件，如
    Google Test ([https://github.com/google/googletest](https://github.com/google/googletest))
    或 Catch2 ([https://github.com/catchorg/Catch2](https://github.com/catchorg/Catch2))）。CTest
    并不是这些库的替代品，后者在编写单元测试和集成测试方面提供了极好的支持。'
- en: Types of tests
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类型
- en: 'Throughout this chapter, we’ll refer to three different kinds of tests: unit
    tests, integration tests, and end-to-end tests. Briefly, **unit tests** typically
    test an individual type or component without introducing any dependencies (for
    example, testing operations on a specific math type such as a vector or matrix
    would qualify as a unit test). **Integration tests** are a lot fuzzier; they usually
    sit on a spectrum and will involve multiple types/classes/components interacting
    together to ensure they perform as expected (for example, in a game, an integration
    test might check how the player character and camera component interact). At this
    stage, this is where stubs and/or mocks (a way to avoid the need to create expensive
    or unreliable dependencies, such as databases or remote APIs) enter the picture,
    and things can get a lot more complicated (as unit and integration tests in the
    context of CMake are very similar, we’ll focus on unit tests in this chapter).
    Finally, **end-to-end tests** exercise the application as if the end user were
    interacting with it. These tend to be the most complex and fragile kind of tests
    but do carry value, and maintaining a small number can help ensure the full application
    is performing as expected without manual checks. These three types of tests are
    often represented within the testing pyramid (unit tests at the bottom, integration
    tests in the middle, and end-to-end tests at the top). The general advice is the
    higher up the pyramid you go, the fewer types of that kind of test there are (lots
    of unit tests, not many end-to-end tests), and this is primarily driven by metrics,
    such as time, reliability, and cost.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将提到三种不同类型的测试：单元测试、集成测试和端到端测试。简而言之，**单元测试**通常测试一个独立的类型或组件，而不会引入任何依赖（例如，测试在特定数学类型（如向量或矩阵）上的操作就算作单元测试）。**集成测试**则模糊不清；它们通常位于一个范围内，涉及多个类型/类/组件的交互，以确保它们按预期执行（例如，在一个游戏中，集成测试可能会检查玩家角色和相机组件的交互）。在这一阶段，这也是引入桩（stubs）和/或模拟（mocks）的地方（这是一种避免创建昂贵或不可靠依赖（如数据库或远程
    API）的方法），事情可能会变得更加复杂（由于在 CMake 上下文中单元测试和集成测试非常相似，本章将专注于单元测试）。最后，**端到端测试**模拟最终用户与应用程序的交互。这些测试通常是最复杂且最脆弱的，但仍然具有价值，保持少量的端到端测试可以确保整个应用程序按预期执行，而无需手动检查。这三种测试类型通常在测试金字塔中表示（单元测试在底部，集成测试居中，端到端测试在顶部）。一般建议是，金字塔越高，这种类型的测试就越少（单元测试很多，端到端测试很少），这主要由时间、可靠性和成本等指标驱动。
- en: What CTest offers is a unified interface to run many kinds of tests together
    and report failures in a consistent manner. This can be incredibly valuable when
    working with different kinds of tests across a spectrum of languages and styles.
    For example, an application may have a suite of unit and integration tests written
    using C or C++ compiled as a separate test executable, end-to-end tests that launch
    and run the application to have it test itself (usually through the use of a scripting
    language, such as Python, or an in-built test runner) and ad hoc shell scripts
    to verify generated files. With CTest, all these testing approaches can be combined
    and executed with a single command, their output reduced to a pass or fail outcome.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: CTest 提供的是一个统一的接口，用于一起运行多种测试并以一致的方式报告失败。这在处理多种语言和风格的不同类型测试时非常有价值。例如，一个应用程序可能有一组使用
    C 或 C++ 编写的单元测试和集成测试，这些测试被编译为一个独立的测试可执行文件，还有端到端测试，它启动并运行应用程序让它自我测试（通常通过脚本语言，如
    Python，或内置的测试运行器），以及用来验证生成文件的临时 shell 脚本。通过 CTest，所有这些测试方法都可以结合起来并通过单一命令执行，输出结果只显示是否通过或失败。
- en: CTest is an incredibly flexible tool and supports a wide array of different
    kinds of tests (even compiling code during the testing phase). We won’t be covering
    everything it can do, but we will aim to cover some of the most useful operations
    and provide a starting point for using CTest in your own projects in the future.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: CTest 是一个极其灵活的工具，支持多种不同类型的测试（甚至可以在测试阶段编译代码）。我们不会涵盖它的所有功能，但我们会尽力覆盖一些最有用的操作，并为您将来在自己的项目中使用
    CTest 提供一个起点。
- en: Adding unit tests to a library
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向库添加单元测试
- en: 'Now that we understand what CTest offers, let’s look at a concrete example
    of adding unit tests to a couple of our existing libraries, we’ll start with `mc-array`.
    Just to note at the outset, there are a few different ways we can choose to structure
    our project to support testing. One choice is to create a subdirectory in the
    root of the project that is decoupled from our root-level `CMakeLists.txt` file:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了CTest提供的功能，让我们来看一个具体的例子，展示如何向现有的两个库添加单元测试，我们从`mc-array`开始。首先要说明的是，我们可以选择几种不同的方式来构建项目以支持测试。一个选择是创建一个与根目录`CMakeLists.txt`文件解耦的子目录：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With this setup, users are required to navigate to the subfolder and run the
    standard CMake configure and build commands. The test project would link against
    the top-level application, likely relying on `FetchContent` with a relative path
    using `SOURCE_DIR`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种设置，用户需要进入子文件夹并运行标准的CMake配置和构建命令。测试项目将会链接到顶层应用程序，可能依赖于使用`SOURCE_DIR`的相对路径的`FetchContent`。
- en: Another option is to keep the preceding layout but use `add_subdirectory` to
    add the `tests` subfolder if a testing option is enabled. The nested `CMakeLists.txt`
    file can link against the library as it will be in scope when `add_subdirectory`
    is called. If the library is small enough, it’s also fine to omit the `tests`
    folder entirely and keep the test executable inline in the root-level `CMakeLists.txt`
    file.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是保持前述布局，但在启用测试选项时使用`add_subdirectory`来添加`tests`子文件夹。嵌套的`CMakeLists.txt`文件可以链接到库，因为在调用`add_subdirectory`时，库会在作用域内。如果库足够小，也可以完全省略`tests`文件夹，将测试可执行文件直接放在根级别的`CMakeLists.txt`文件中。
- en: In `ch9/part-1/lib/array/CMakeLists.txt`, we have opted for keeping things in
    line, and in `ch9/part-1/lib/gol/CMakeLists.txt`, we use `add_subdirectory`. This
    is just to give an example of both versions; the content is almost identical.
    The only notable difference is specifying `CMAKE_SOURCE_DIR` when referring to
    the test file in our project in the nested folder example. This is so the path
    to the file is relative to the root `CMakeLists.txt` file, not the `tests` subfolder.
    There’s also one subtle difference needed when invoking `ctest` between the two
    versions, which we’ll cover later in this section.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ch9/part-1/lib/array/CMakeLists.txt`中，我们选择了将内容保持在一行，而在`ch9/part-1/lib/gol/CMakeLists.txt`中，我们使用了`add_subdirectory`。这只是为了给出两种版本的示例；内容几乎是相同的。唯一值得注意的区别是在引用项目中的测试文件时，在嵌套文件夹示例中指定了`CMAKE_SOURCE_DIR`。这是为了确保文件路径相对于根`CMakeLists.txt`文件，而不是`tests`子文件夹。此外，在调用`ctest`时，两个版本之间还需要一个细微的区别，我们将在本节后面讨论。
- en: CMakeLists.txt changes for CTest
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CMakeLists.txt的CTest更改
- en: Beginning with `ch9/part-1/lib/array/CMakeLists.txt`, let’s walk through the
    changes required to add CTest support.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从`ch9/part-1/lib/array/CMakeLists.txt`开始，让我们一步步了解如何添加CTest支持。
- en: 'The first change is adding a new option called `MC_ARRAY_BUILD_TESTING` to
    either enable or disable building the tests:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个更改是添加一个名为`MC_ARRAY_BUILD_TESTING`的新选项，用于启用或禁用构建测试：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that we use the `MC_ARRAY` prefix to reduce the likelihood of a collision
    with any other project. We also default it to `OFF` (a CMake constant for false;
    we could also use `0`, `NO`, or `FALSE`, but `OFF` is clearest in this context.
    See [https://cmake.org/cmake/help/latest/command/if.html#constant](https://cmake.org/cmake/help/latest/command/if.html#constant)
    for more information.) We do this to be good citizens and stop downstream users
    from inadvertently building the tests if they forget to disable `MC_ARRAY_BUILD_TESTING`
    themselves.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用`MC_ARRAY`前缀来减少与其他项目发生冲突的可能性。我们还将其默认为`OFF`（CMake常量表示假；我们也可以使用`0`、`NO`或`FALSE`，但在此上下文中`OFF`最为清晰。有关更多信息，请参见[https://cmake.org/cmake/help/latest/command/if.html#constant](https://cmake.org/cmake/help/latest/command/if.html#constant)）。我们这样做是为了成为一个负责任的公民，防止下游用户在忘记禁用`MC_ARRAY_BUILD_TESTING`时，不小心构建测试。
- en: 'At the bottom of the `CMakeLists.txt` file, we then check if the `MC_ARRAY_BUILD_TESTING`
    option is defined, and only if it is do we then bring in the CTest module:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CMakeLists.txt`文件的底部，我们检查`MC_ARRAY_BUILD_TESTING`选项是否已定义，只有在其定义时，我们才会引入CTest模块：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When we include this module, a new `BUILD_TESTING` option is created by CMake.
    This unfortunately defaults to `ON`, which from a user perspective isn’t ideal.
    If we decided to include the CTest module at the top of our `CMakeLists.txt` file,
    we could use the `if (BUILD_TESTING)` check around our test code; however, this
    is an all-or-nothing setting if including this project in the context of `FetchContent`.
    For example, our *Game of Life* library depends on `mc-array`, and if we included
    `mc-array` using `FetchContent`, and both it and `mc-gol` used `BUILD_TESTING`,
    we’d only be able to run all the tests or none of the tests. We likely only want
    to run our *Game of Life* tests when making changes to that library, so having
    a per-project option gives us more control and granularity over which projects
    build their tests or not.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们包含此模块时，CMake 会创建一个新的 `BUILD_TESTING` 选项。不幸的是，这个选项默认设置为 `ON`，从用户的角度来看并不理想。如果我们决定在
    `CMakeLists.txt` 文件的顶部包含 CTest 模块，我们可以在测试代码周围使用 `if (BUILD_TESTING)` 检查；然而，在 `FetchContent`
    的上下文中包含此项目时，这就是一个全有或全无的设置。例如，我们的 *生命游戏* 库依赖于 `mc-array`，如果我们使用 `FetchContent`
    包含了 `mc-array`，并且 `mc-array` 和 `mc-gol` 都使用 `BUILD_TESTING`，那么我们只能运行所有的测试或不运行任何测试。我们可能只希望在更改
    *生命游戏* 库时运行它的测试，因此每个项目的选项让我们能够更好地控制哪些项目构建它们的测试。
- en: 'After `include(CTest`), we use `FetchContent` to bring in a testing library
    called `dynamic-array-test`, and add the new test file we have that exercise its
    functionality:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `include(CTest)` 之后，我们使用 `FetchContent` 引入一个名为 `dynamic-array-test` 的测试库，并添加我们有的、能验证其功能的新测试文件：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Notice that we have added our new test file in the same physical location as
    `array.c`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已将新测试文件添加到与 `array.c` 相同的物理位置：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: target_link_libraries(
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: target_link_libraries(
- en: dynamic-array-test PRIVATE dynamic-array unity)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: dynamic-array-test PRIVATE dynamic-array unity)
- en: target_compile_features(
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: target_compile_features(
- en: dynamic-array-test PRIVATE c_std_17)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: dynamic-array-test PRIVATE c_std_17)
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: add_test(
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: add_test(
- en: NAME "dynamic array unit tests"
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 名称 "动态数组单元测试"
- en: COMMAND dynamic-array-test)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: COMMAND dynamic-array-test)
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: cmake --preset test
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: cmake --preset test
- en: cmake --build build/test
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: cmake --build build/test
- en: ctest --test-dir build/test-C Debug
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ctest --test-dir build/test-C Debug
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Internal ctest changing into directory: .../ch9/part-1/lib/array/build/test'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '内部 ctest 更改目录: .../ch9/part-1/lib/array/build/test'
- en: Test project ../ch9/part-1/lib/array/build/test
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 测试项目 ../ch9/part-1/lib/array/build/test
- en: 'Start 1: dynamic array unit tests'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '开始 1: 动态数组单元测试'
- en: '1/1 Test #1: dynamic array unit tests ... Passed 0.17 sec'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '1/1 测试 #1: 动态数组单元测试 ... 已通过 0.17 秒'
- en: 100% tests passed, 0 tests failed out of 1
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 100% 测试通过，1 个测试中没有失败
- en: Total Test time (real) = 0.17 sec
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 总测试时间（实际） = 0.17 秒
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ./build/test/Debug/dynamic-array-test
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ./build/test/Debug/dynamic-array-test
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'ctest --test-dir build -C Debug --output-on-failure argument can be used to
    have CTest output only when a test fails. This can help avoid clutter in the test
    output as the test suite grows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ctest --test-dir build -C Debug --output-on-failure 参数可用于使 CTest 仅在测试失败时输出。这可以帮助避免随着测试套件的增长而输出过多的杂乱信息：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: cmake --workflow --preset multi-ninja-super
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: cmake --workflow --preset multi-ninja-super
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ./build/multi-ninja-super/Release/minimal-cmake_game-of-life_window
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ./build/multi-ninja-super/Release/minimal-cmake_game-of-life_window
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: option(MC_GOL_APP_BUILD_TESTING "Enable testing" OFF)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: option(MC_GOL_APP_BUILD_TESTING "启用测试" OFF)
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: add_library(${PROJECT_NAME}-common INTERFACE)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: add_library(${PROJECT_NAME}-common INTERFACE)
- en: target_sources(
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: target_sources(
- en: ${PROJECT_NAME}-common
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ${PROJECT_NAME}-common
- en: INTERFACE
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: INTERFACE
- en: main.cpp imgui/sdl2/imgui_impl_sdl2.cpp
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: main.cpp imgui/sdl2/imgui_impl_sdl2.cpp
- en: imgui/bgfx/imgui_impl_bgfx.cpp)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: imgui/bgfx/imgui_impl_bgfx.cpp)
- en: '...'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: add_executable(${PROJECT_NAME})
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: add_executable(${PROJECT_NAME})
- en: target_link_libraries(
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: target_link_libraries(
- en: ${PROJECT_NAME} PRIVATE PROJECT_NAME variable with the common postfix, and mark
    it INTERFACE. We then add sources and libraries as we did before, only instead
    of adding them directly to the executable, we use the INTERFACE library. After
    creating the executable with add_executable, we then only need to link against
    ${PROJECT_NAME}-common to bring in all the usage requirements defined by it. The
    good news is we can then do the same thing with our ${PROJECT_NAME}-test executable
    target without any further duplication.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ${PROJECT_NAME} PRIVATE 项目名称变量带有通用后缀，并将其标记为 INTERFACE。然后像之前一样添加源文件和库，只是我们不再直接将它们添加到可执行文件中，而是使用
    INTERFACE 库。在通过 add_executable 创建可执行文件后，我们只需要链接 `${PROJECT_NAME}-common`，即可引入它所定义的所有使用要求。好消息是，我们随后可以对
    `${PROJECT_NAME}-test` 可执行目标做同样的事情，而无需进一步重复。
- en: 'Target properties only apply to the target they’re set on, so if we set them
    on `${PROJECT_NAME}-common`, they won’t carry over to our main application (`${PROJECT_NAME}`)
    or test target (`{PROJECT_NAME}-test`). One workaround to avoid duplication between
    the two targets is to create a CMake function called `set_common_target_properties`
    that takes a target as an argument. We can then move our shared code inside of
    it, and call the new function for both the main application and our test code.
    Below is a snippet of what this looks like (see `ch9/part-3/app/CMakeLists.txt`
    for a full example):'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目标属性仅适用于设置它们的目标，因此如果我们将它们设置在`${PROJECT_NAME}-common`上，它们不会传递到我们的主应用程序（`${PROJECT_NAME}`）或测试目标（`${PROJECT_NAME}-test`）。为了避免这两个目标之间的重复，一个解决方法是创建一个名为`set_common_target_properties`的CMake函数，它接受一个目标作为参数。我们可以将共享代码移到这个函数内，并为主应用程序和测试代码调用这个新函数。以下是这段代码的一个片段（完整示例见`ch9/part-3/app/CMakeLists.txt`）：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: target_compile_definitions(
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: target_compile_definitions(
- en: '${PROJECT_NAME}-test PRIVATE main.cpp file, we can then wrap our test initialization
    code in an #ifdef:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ${PROJECT_NAME}-test PRIVATE main.cpp文件，我们可以在其中包装我们的测试初始化代码，并用`#ifdef`进行条件编译：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We forward declare the `RegisterGolTests` function at the top of our `main.cpp`
    file and provide the implementation in a separate file called `gol-tests.cpp`,
    which we only include in the test target:'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在`main.cpp`文件的顶部前向声明了`RegisterGolTests`函数，并在一个单独的文件`gol-tests.cpp`中提供实现，我们仅在测试目标中包含这个文件：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: if (current_event.type == SDL_MOUSEBUTTONDOWN) {
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: if (current_event.type == SDL_MOUSEBUTTONDOWN) {
- en: SDL_MouseButtonEvent* mouse_button =
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: SDL_MouseButtonEvent* mouse_button =
- en: (SDL_MouseButtonEvent*)&current_event;
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: (SDL_MouseButtonEvent*)&current_event;
- en: if (mouse_button->button == SDL_BUTTON_LEFT) {
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: if (mouse_button->button == SDL_BUTTON_LEFT) {
- en: '...'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: if (ImGui::IsMouseClicked(ImGuiMouseButton_Left)) {
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: if (ImGui::IsMouseClicked(ImGuiMouseButton_Left)) {
- en: '...'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: t = IM_REGISTER_TEST(e, "gol-tests", "Click board");
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: t = IM_REGISTER_TEST(e, "gol-tests", "点击棋盘");
- en: t->UserData = board;
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: t->UserData = board;
- en: t->TestFunc = [](ImGuiTestContext* ctx) {
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: t->TestFunc = [](ImGuiTestContext* ctx) {
- en: const auto* board=(mc_gol_board_t*)ctx->Test->UserData;
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: const auto* board = (mc_gol_board_t*)ctx->Test->UserData;
- en: ctx->SetRef("Game of Life");
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ctx->SetRef("生命游戏");
- en: ctx->MouseMoveToPos(ImVec2(200, 200));
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ctx->MouseMoveToPos(ImVec2(200, 200));
- en: ctx->MouseClick(ImGuiMouseButton_Left);
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ctx->MouseClick(ImGuiMouseButton_Left);
- en: ctx->MouseMoveToPos(ImVec2(400, 200));
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ctx->MouseMoveToPos(ImVec2(400, 200));
- en: ctx->MouseClick(ImGuiMouseButton_Left);
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ctx->MouseClick(ImGuiMouseButton_Left);
- en: IM_CHECK_EQ(mc_gol_board_cell(board, 6, 6), true);
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: IM_CHECK_EQ(mc_gol_board_cell(board, 6, 6), true);
- en: IM_CHECK_EQ(mc_gol_board_cell(board, 19, 6), true);
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: IM_CHECK_EQ(mc_gol_board_cell(board, 19, 6), true);
- en: '};'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: add_test(
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: add_test(
- en: NAME "game of life end-to-end tests"
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: NAME "生命游戏端到端测试"
- en: COMMAND ${PROJECT_NAME}-test
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: COMMAND ${PROJECT_NAME}-test
- en: add_test command we saw when registering our library tests with CTest earlier
    in the chapter, only this time, we pass one additional argument, WORKING_DIRECTORY,
    which we set to CMAKE_SOURCE_DIR to ensure our application uses the CMake root
    directory so our shader files are available at the expected relative location.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章之前看到的`add_test`命令用于注册我们的库测试，这一次，我们传递了一个额外的参数`WORKING_DIRECTORY`，并将其设置为`CMAKE_SOURCE_DIR`，以确保我们的应用程序使用CMake根目录，从而确保着色器文件可以在预期的相对位置访问。
- en: Another option is to copy the compiled shader files in `app/shader/build` to
    the same folder as the compiled test application, and then set `WORKING_DIRECTORY`
    to `${CMAKE_BINARY_DIR}/$<CONFIG>` (this works correctly with both single and
    multi-config generators as `$<CONFIG>` will evaluate to an empty string in the
    single-config generator case).
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一种选择是将编译后的着色器文件从`app/shader/build`复制到与编译后的测试应用程序相同的文件夹中，然后将`WORKING_DIRECTORY`设置为`${CMAKE_BINARY_DIR}/$<CONFIG>`（这在单配置生成器和多配置生成器中都能正确工作，因为在单配置生成器中，`$<CONFIG>`会解析为空字符串）。
- en: 'With everything compiled and registered correctly, all that is left is to run
    the test application. This can be achieved by executing the following commands
    from the `ch9/part-3/app` folder:'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在一切编译和注册正确之后，剩下的就是运行测试应用程序。这可以通过从`ch9/part-3/app`文件夹执行以下命令来实现：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Before we wrap up this section, it’s also worth noting we can further improve
    this by adding support for test presets in our `CMakePreset.json` file. We can
    add a key called `"testPresets"` and a JSON object such as the following:'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们结束这一部分之前，值得注意的是，我们可以通过在`CMakePreset.json`文件中添加对测试预设的支持进一步改进这一点。我们可以添加一个名为`"testPresets"`的键，并使用如下所示的JSON对象：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We then need only run `ctest --preset multi-ninja-super-test` after configuring
    and building to launch our tests (this can store many of the configuration options
    we’d otherwise have to pass at the command line to `ctest`). Please see [https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html#test-preset](https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html#test-preset)
    for more information about the different options `testPresets` provides.
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们只需要在配置和构建完成后运行`ctest --preset multi-ninja-super-test`来启动我们的测试（这样可以存储许多我们原本需要在命令行中传递给`ctest`的配置选项）。有关`testPresets`提供的不同选项的更多信息，请参阅[https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html#test-preset](https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html#test-preset)。
- en: 'The final touch is to include a CMake workflow preset for all of the earlier
    code, which allows us to configure, build, and test everything with the following
    command:'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后一步是为之前的所有代码包含一个 CMake 工作流预设，这样我们就可以通过以下命令配置、构建和测试所有内容：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That covers a good chunk of what you need to know when it comes to creating
    a testable version of your application with the help of CMake and CTest. Next,
    we’re going to look at adding a few more kinds of tests directly to our application
    and integrating them with CTest.
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这涵盖了在使用 CMake 和 CTest 帮助下创建可测试版本的应用程序时需要了解的主要内容。接下来，我们将讨论如何将更多类型的测试直接添加到我们的应用程序中，并将它们与
    CTest 集成。
- en: Adding other kinds of tests
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加其他类型的测试
- en: Testing is an incredibly broad topic, and often applications require many kinds
    of tests to provide effective coverage of their behavior and functionality. A
    benefit of CTest is it integrates with these diverse types of tests and allows
    them to be managed and run together. In this section, we’re going to look at two
    more kinds of tests that CTest helps support.
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试是一个非常广泛的话题，通常应用程序需要多种类型的测试来有效地覆盖其行为和功能。CTest的一个优点是它可以与这些多样化的测试类型集成，并允许它们一起管理和运行。在本节中，我们将讨论
    CTest 支持的另外两种类型的测试。
- en: Internal tests
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 内部测试
- en: The first example we’ll cover is still technically a unit test, but we’re going
    to add it in the context of our application instead of going through the process
    of extracting the functionality to its own library. This can be useful to do in
    the short term if some functionality cannot or should not be extracted. The example
    we’ve selected is the viewport projection functions that map from world space
    to screen space and back again. Previously, these were added in our `main.c` (now
    `main.cpp`) file and could not be used in other files. We can extract these two
    functions to a new pair of files called `screen.h` and `screen.cpp` and include
    `screen.h` in `main.cpp`.
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将讨论的第一个示例仍然严格来说是单元测试，但我们将它添加到应用程序的上下文中，而不是通过提取功能到单独的库来进行。这在短期内很有用，特别是当某些功能无法或不应该被提取时。我们选择的示例是视口投影函数，它将从世界空间映射到屏幕空间，然后再返回。以前，这些函数是添加到我们的`main.c`（现在是`main.cpp`）文件中的，无法在其他文件中使用。我们可以将这两个函数提取到新的文件对中，命名为`screen.h`和`screen.cpp`，并在`main.cpp`中包含`screen.h`。
- en: 'This refactoring allows us to add tests to verify the behavior of the functions
    and help catch regressions should we in the future decide to restructure or optimize
    the internal implementations. To add the tests, we can follow the same approach
    we took with the library examples we saw at the beginning of the chapter, and
    add a new file called `screen.test.cpp` to hold our tests. We’ll use the well-known
    C++ testing library Catch2 for the tests. The reason we’re using Catch2 over the
    Unity testing library introduced at the start of the chapter is that Catch2 is
    built for C++, and comes with lots of useful features (function overloading and
    not requiring tests to be called manually, also known as automatic test registration,
    to name a few). We can add this as a dependency using either `FetchContent` or
    `ExternalProject_Add`. As Catch2 takes a little time to build, we’ve opted for
    the second approach. Our updated third-party `CMakeLists.txt` file in `ch9/part-4/app/third-party`
    now has the following additions:'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种重构使我们能够添加测试，以验证函数的行为，并帮助捕捉回归问题，以防将来我们决定重构或优化内部实现。为了添加测试，我们可以遵循与本章开始时看到的库示例相同的方法，新增一个名为`screen.test.cpp`的文件来保存我们的测试。我们将使用著名的C++测试库Catch2来进行测试。我们选择使用Catch2而不是本章开始时介绍的Unity测试库的原因是，Catch2是专为C++构建的，并且拥有许多有用的功能（如函数重载和不需要手动调用测试，也叫自动测试注册，等等）。我们可以通过`FetchContent`或`ExternalProject_Add`将其作为依赖项添加。由于Catch2构建需要一些时间，我们选择了第二种方法。我们在`ch9/part-4/app/third-party`中的更新后的第三方`CMakeLists.txt`文件现在包含以下内容：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: First off, we only include Catch2 if we’re building tests for our application.
    We then introduce a variable, `TEST_DEPENDENCIES`, which will evaluate to an empty
    string if `MC_GOL_APP_BUILD_TESTING` is not set, and `Catch2` if it is. We then
    ensure to pass this variable to the `DEPENDS` argument in the `ExternalProject_Add`
    call for our super build.
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们只有在构建应用程序的测试时才会包含Catch2。然后我们引入了一个变量`TEST_DEPENDENCIES`，如果未设置`MC_GOL_APP_BUILD_TESTING`，它将评估为空字符串，如果设置了，则为`Catch2`。然后我们确保将这个变量传递给`ExternalProject_Add`调用中的`DEPENDS`参数，用于我们的超级构建。
- en: If you review `ch9/part-4/app/third-party/CMakeLists.txt`, at the top of the
    file, we’ve also added the `MC_GOL_APP_BUILD_TESTING` CMake option, which appears
    in `ch9/part-4/app/CMakeLists.txt`. This is technically redundant but ensures
    consistency when building the third-party dependencies separately, or as a super
    build.
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你查看`ch9/part-4/app/third-party/CMakeLists.txt`，在文件的顶部，我们还添加了`MC_GOL_APP_BUILD_TESTING`
    CMake选项，它出现在`ch9/part-4/app/CMakeLists.txt`中。严格来说，这个设置是多余的，但它确保在单独构建第三方依赖项或作为超级构建时的一致性。
- en: 'Now that Catch2 is available as a third-party dependency, we can return to
    our application’s `CMakeLists.txt` file and review the changes needed there. Inside
    the `if(MC_GOL_APP_BUILD_TESTING)` block, after our end-to-end test executable
    configuration, we add the commands needed to test our refactored `screen.cpp`
    code. First, we use the `find_package` command to bring in the Catch2 library
    we added in the earlier section:'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在Catch2作为第三方依赖项可用后，我们可以返回到应用程序的`CMakeLists.txt`文件，并检查需要在那里进行的更改。在`if(MC_GOL_APP_BUILD_TESTING)`块内，在我们的端到端测试可执行文件配置之后，我们添加了测试重构后的`screen.cpp`代码所需的命令。首先，我们使用`find_package`命令来引入我们在前面部分中添加的Catch2库：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We then need to set up a new executable to compile our tests. Unfortunately,
    adding tests for an application in this way is a little more complicated than
    the library case we saw at the start of the chapter. As mentioned earlier, it
    is not possible to link against an executable file, so we can’t add a new test
    executable and link against the application to test. Instead, we need to specify
    the files we want to test and link against any libraries our main application
    uses that we may need when compiling them.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后我们需要设置一个新的可执行文件来编译我们的测试。不幸的是，像这样为应用程序添加测试比我们在本章开始时看到的库案例要复杂一些。正如前面提到的，不能将可执行文件链接到测试中，因此我们不能添加新的测试可执行文件并与应用程序链接进行测试。相反，我们需要指定我们想要测试的文件，并与主应用程序使用的任何库链接，这些库可能在编译时需要。
- en: 'The following extract from `ch9/part-4/app/CMakeLists.txt` shows one way to
    do this:'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是`ch9/part-4/app/CMakeLists.txt`中的一个提取，展示了如何进行操作：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We first create a new executable called `${PROJECT_NAME}-unit-test` (which will
    expand to `minimal-cmake_game-of-life_window-unit-test`). We next add the files
    we need to compile for the tests to build and run (`screen.cpp` and `screen.test.cpp`).
    We must link against Catch2 (`Catch2WithMain` is useful to avoid needing to create
    our own custom `main()` entry point for the tests; see [https://github.com/catchorg/Catch2/blob/devel/docs/cmake-integration.md#cmake-targets](https://github.com/catchorg/Catch2/blob/devel/docs/cmake-integration.md#cmake-targets)
    for more information) and `as-c-math`, which the interface and implementation
    of `screen.h/cpp` depend on. We finally ensure to explicitly set the language
    version (in this case, C++ `20`), to ensure a consistent language version across
    different compilers and platforms.
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的可执行文件 `${PROJECT_NAME}-unit-test`（它会扩展为 `minimal-cmake_game-of-life_window-unit-test`）。接下来，我们添加构建和运行测试所需编译的文件（`screen.cpp`
    和 `screen.test.cpp`）。我们必须链接 Catch2（`Catch2WithMain` 有助于避免为测试创建自定义的 `main()` 入口点；有关更多信息，请参见
    [https://github.com/catchorg/Catch2/blob/devel/docs/cmake-integration.md#cmake-targets](https://github.com/catchorg/Catch2/blob/devel/docs/cmake-integration.md#cmake-targets)）和
    `as-c-math`，这是 `screen.h/cpp` 接口和实现所依赖的。最后，我们确保明确设置语言版本（在此情况下为 C++ `20`），以确保在不同编译器和平台之间使用一致的语言版本。
- en: 'The last step is simply to register the test executable with CTest using the
    `add_test` command shown here:'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后的步骤就是使用这里显示的 `add_test` 命令将测试可执行文件注册到 CTest：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: By default, CTest will report success if it detects `0` returned from the command
    under test and failure for any non-zero value. This is a convention adhered to
    universally, not just by CTest, so Catch2 and Unity, the C testing library we
    saw earlier, handle this for us.
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，如果 CTest 检测到命令返回 `0`，它会报告成功；对于任何非零值，它会报告失败。这是一个普遍遵守的约定，不仅是 CTest，Catch2
    和之前提到的 C 测试库 Unity 也都处理这一点。
- en: 'To confirm this, it’s possible to check the return value of an executable on
    program exit with a simple console command. After running the application, use
    this command on Windows (if using PowerShell or Command Prompt):'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了确认这一点，可以通过一个简单的控制台命令检查可执行文件在程序退出时的返回值。在运行应用程序后，在 Windows 上使用此命令（如果使用 PowerShell
    或命令提示符）：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Use this command if using macOS or Linux (or GitBash or equivalent on Windows):'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果使用 macOS 或 Linux（或 Windows 上的 GitBash 或等效工具），请使用此命令：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the case of Catch2, the number returned is the number of failing tests.
    To verify this, we can change one or two of the expected outcome values in our
    `screen.test.cpp` file, compile the test executable again, run it, and then run
    one of the preceding commands. If two tests fail, then we’ll see the following
    output:'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Catch2 中，返回的数字是失败测试的数量。为了验证这一点，我们可以在 `screen.test.cpp` 文件中更改一个或两个期望结果值，重新编译测试可执行文件，运行它，然后运行前面的某个命令。如果两个测试失败，我们将看到以下输出：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If, for whatever reason, this default behavior is not sufficient, CTest provides
    a `PASS_REGULAR_EXPRESSION` and `FAIL_REGULAR_EXPRESSION` property that can be
    set on a test to check for a particular pattern coming from `stdout` or `stderr`.
    For example, to verify all tests Catch2 ran succeeded, we could use the following
    regular expression check:'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果由于某种原因，默认行为不足以满足需求，CTest 提供了一个 `PASS_REGULAR_EXPRESSION` 和 `FAIL_REGULAR_EXPRESSION`
    属性，可以在测试中设置，以检查来自 `stdout` 或 `stderr` 的特定模式。例如，要验证 Catch2 运行的所有测试都成功，我们可以使用以下正则表达式检查：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: if(NOT EXISTS
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: if(NOT EXISTS
- en: ${CMAKE_SOURCE_DIR}/shader/build/vs_vertcol.bin)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ${CMAKE_SOURCE_DIR}/shader/build/vs_vertcol.bin)
- en: message(FATAL_ERROR "vs_vertcol.bin missing")
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: message(FATAL_ERROR "vs_vertcol.bin 丢失")
- en: endif()
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: endif()
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: add_test(
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: add_test(
- en: NAME "shaders compiled"
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: NAME "着色器编译"
- en: COMMAND ${CMAKE_COMMAND} -P tests/shaders-compiled.cmake
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: COMMAND ${CMAKE_COMMAND} -P tests/shaders-compiled.cmake
- en: WORKING_DIRECTORY ${CMAKE_SOURCE_DIR})
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: WORKING_DIRECTORY ${CMAKE_SOURCE_DIR})
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ctest --test-dir build/multi-ninja-super-test -R "game of life unit tests" -C
    Debug
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ctest --test-dir build/multi-ninja-super-test -R "生命游戏单元测试" -C Debug
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: set_tests_properties(
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: set_tests_properties(
- en: '"game of life end-to-end tests"'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '"生命游戏端到端测试"'
- en: 'PROPERTIES --label-regex (-L) and the pattern to match to ctest:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: PROPERTIES --label-regex (-L) 和与 ctest 匹配的模式：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: set(CTEST_PROJECT_NAME minimal-cmake)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: set(CTEST_PROJECT_NAME minimal-cmake)
- en: set(
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: set(
- en: CTEST_SUBMIT_URL
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: CTEST_SUBMIT_URL
- en: https://my.cdash.org/submit.php?project=minimal-cmake)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: https://my.cdash.org/submit.php?project=minimal-cmake)
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ctest --test-dir <build-dir> -C Debug -D option in this context is slightly
    different from how we’ve used it before (to set CMake cache variables); here,
    -D refers to the CDash web dashboard (--dashboard) and informs CTest to act as
    a CDash client. This essentially means after the tests are run, the results will
    be uploaded to the CDash project we set in our CTestConfig.cmake file.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ctest --test-dir <build-dir> -C Debug -D选项在此上下文中与我们之前使用的方式略有不同（用于设置CMake缓存变量）；在这里，-D指的是CDash
    Web仪表板（--dashboard），并告知CTest充当CDash客户端。这基本上意味着在运行完测试后，结果将上传到我们在CTestConfig.cmake文件中设置的CDash项目。
- en: Here, `Experimental` refers to the mode, and `Experimental` is meant to be used
    by an individual developer to test local changes. There are multiple other modes
    (`Nightly`, `Continuous`) that can be configured independently and are used in
    different contexts.
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`Experimental`指的是模式，`Experimental`是供个人开发者测试本地更改的模式。还有多个其他模式（`Nightly`，`Continuous`）可以独立配置，并在不同的上下文中使用。
- en: With this change, we can review the CDash web interface and see which tests
    ran and whether they succeeded or failed.
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过此更改，我们可以查看CDash Web界面，了解哪些测试已运行以及它们是否成功或失败。
- en: '![Figure 9.2: CDash test results](img/B21152_09_2.jpg)'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图9.2：CDash测试结果](img/B21152_09_2.jpg)'
- en: 'Figure 9.2: CDash test results'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.2：CDash测试结果
- en: This increased visibility into which tests are passing or failing is great for
    a development team to stay on top of issues and detect regressions early.
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 增强的可视性可以让开发团队清楚地知道哪些测试通过或失败，这对于及时发现问题和早期检测回归非常有帮助。
- en: Adding code coverage
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加代码覆盖率
- en: One other useful feature CDash offers is a clean interface to report the lines
    of code executed while running our tests. This unfortunately is only supported
    in **GNU Compiler Collection** (**GCC**) and Clang compilers, so won’t work by
    default on Windows (although setting up Clang in a Windows environment isn’t too
    difficult if you’re determined).
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: CDash提供的另一个有用功能是一个干净的界面，用于报告在运行测试时执行的代码行。不幸的是，这仅在**GNU编译器集合**（**GCC**）和Clang编译器中受支持，因此默认情况下在Windows上无法使用（尽管在Windows环境中设置Clang并不困难，如果你有决心的话）。
- en: 'To support capturing code coverage information, we need to make some minor
    additions to our `CMakeLists.txt` file. Please see `ch9/part-5/app/CMakeLists.txt`
    for the full example, but the key lines are shown here:'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了支持捕获代码覆盖率信息，我们需要在`CMakeLists.txt`文件中做一些小的修改。完整示例请参见`ch9/part-5/app/CMakeLists.txt`，但关键的代码行如下所示：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: set(CTEST_CUSTOM_COVERAGE_EXCLUDE
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: set(CTEST_CUSTOM_COVERAGE_EXCLUDE
- en: ${CTEST_CUSTOM_COVERAGE_EXCLUDE}
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ${CTEST_CUSTOM_COVERAGE_EXCLUDE}
- en: '"src/imgui/sdl2" "third-party/install/include")'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '"src/imgui/sdl2" "third-party/install/include")'
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: configure_file(
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: configure_file(
- en: CTestCustom.cmake.in
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: CTestCustom.cmake.in
- en: '${CMAKE_BINARY_DIR}/CTestCustom.cmake COPYONLY to indicate no variable replacements
    should take place. Now, when we run the ctest command we saw earlier, coverage
    information will also be uploaded, along with the test results. It’s possible
    to see a file’s overall test coverage as a percentage, and see line by line what
    code was executed while running the tests:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ${CMAKE_BINARY_DIR}/CTestCustom.cmake COPYONLY，表示不应进行任何变量替换。现在，当我们运行之前看到的ctest命令时，覆盖率信息也会被上传，并与测试结果一起提交。可以查看文件的整体测试覆盖率百分比，并逐行查看在运行测试时执行了哪些代码：
- en: '![Figure 9.3: CDash coverage results](img/B21152_09_3.jpg)'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图9.3：CDash覆盖率结果](img/B21152_09_3.jpg)'
- en: 'Figure 9.3: CDash coverage results'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.3：CDash覆盖率结果
- en: This was an incredibly brief introduction to CDash and only really scratched
    the surface of what’s possible. As well as using the default `ctest` functionality,
    it’s possible to fully script `ctest` execution (see [https://cmake.org/cmake/help/latest/manual/cmake-commands.7.html#ctest-commands](https://cmake.org/cmake/help/latest/manual/cmake-commands.7.html#ctest-commands)
    for the full list of `ctest` commands). Setting up recurring nightly builds and
    different kinds of reports is also possible, as well as enabling several forms
    of static analysis (detection of source code errors). It’s also fine to not bother
    with CDash if you decide to opt for a different tool or don’t require the visibility
    features; CTest can be used independently without it.
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这只是对CDash的一个非常简短的介绍，仅仅触及了它的表面。除了使用默认的`ctest`功能外，还可以完全脚本化`ctest`的执行（请参阅[https://cmake.org/cmake/help/latest/manual/cmake-commands.7.html#ctest-commands](https://cmake.org/cmake/help/latest/manual/cmake-commands.7.html#ctest-commands)以查看`ctest`命令的完整列表）。还可以设置定期的夜间构建和各种类型的报告，以及启用几种形式的静态分析（源代码错误检测）。如果你决定选择其他工具或不需要可视化功能，也完全可以不使用CDash；CTests可以独立使用。
- en: Summary
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 摘要
- en: This brings us to the end of our first foray into testing. There is a huge amount
    we didn’t cover, but hopefully, this has given you a flavor of what is possible
    with CTest and how it can bring an array of different testing approaches together.
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这标志着我们第一次涉足测试的结束。虽然我们没有涵盖很多内容，但希望这已经让你对CTests的功能有所了解，并且理解它如何将多种不同的测试方法结合起来。
- en: In this chapter, we were introduced to CTest to understand what it is and how
    it can help us manage various kinds of tests across our libraries and applications.
    Testing is critical and understanding where CTest fits into the testing ecosystem
    is important. We saw how to use CTest when adding unit tests to our foundational
    libraries, how to structure unit tests within an application, and how to create
    a separate testable executable for running full end-to-end tests. We also saw
    how to author CMake scripts to test other parts of our project. This was all orchestrated
    and connected through CTest. These skills will help you build successful and reliable
    software projects.
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了CTest，以理解它是什么以及它如何帮助我们管理跨库和应用程序的各种测试。测试至关重要，理解CTest在测试生态系统中的定位非常重要。我们展示了如何在我们的基础库中添加单元测试时使用CTest，如何在应用程序内结构化单元测试，以及如何创建一个独立的可测试可执行文件来运行完整的端到端测试。我们还展示了如何编写CMake脚本来测试项目的其他部分。所有这些都通过CTest进行协调和连接。这些技能将帮助你构建成功且可靠的软件项目。
- en: We then took a brief tour of CDash to understand what it offers and how it integrates
    with CTest. We looked at reporting test results and code coverage and saw how
    a tool like CDash can help software teams work together more effectively.
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接着，我们简要浏览了CDash，了解它提供了哪些功能以及它如何与CTest集成。我们查看了测试结果和代码覆盖率报告，了解了像CDash这样的工具如何帮助软件团队更有效地协作。
- en: In the next chapter, we are going to turn our attention to another of CMake’s
    companion tools called CPack. We’ll use this to package our application ready
    for distribution and look at some of the challenges around handling platform-specific
    differences.
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下一章，我们将把注意力转向CMake的另一个配套工具——CPack。我们将使用它来打包我们的应用程序，使其准备好进行分发，并探讨一些与平台特定差异处理相关的挑战。
- en: '[PRE38]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
