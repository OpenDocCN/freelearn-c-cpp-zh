- en: Iterators
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器
- en: 'We cover the following recipes in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中涵盖以下内容：
- en: Building your own iterable range
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建自己的可迭代范围
- en: Making your own iterators compatible with STL iterator categories
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使自己的迭代器与 STL 迭代器类别兼容
- en: Using iterator wrappers to fill generic data structures
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用迭代器包装器填充通用数据结构
- en: Implementing algorithms in terms of iterators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按迭代器实现算法
- en: Iterating the other way around using reverse iterator adapters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用反向迭代器适配器进行反向迭代
- en: Terminating iterations over ranges with iterator sentinels
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用迭代器哨兵终止范围上的迭代
- en: Automatically checking iterator code with checked iterators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用检查迭代器自动检查迭代器代码
- en: Building your own zip iterator adapter
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建自己的 zip 迭代器适配器
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Iterators are an *extremely important concept* in C++. The STL aims to be as
    flexible and generic as possible, and iterators are a great help in that regard.
    Unfortunately, they are sometimes a bit tedious to use, which is why many novices
    *avoid* them and fall back to *C-Style C++*. A programmer who avoids iterators
    basically waives *half* the potential of the STL. This chapter deals with iterators
    and quickly casts some light on how they work. That very quick introduction is
    probably not enough, but the *recipes* are really here to give a good feeling
    for iterator internals.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器在 C++ 中是一个非常重要的概念。STL 的目标是尽可能灵活和通用，而迭代器在这方面非常有帮助。不幸的是，它们有时候使用起来有点乏味，这就是为什么许多新手会避免使用它们并退回到
    *C-Style C++* 的原因。一个避免使用迭代器的程序员基本上放弃了 STL 的一半潜力。本章涉及迭代器并快速地介绍了它们的工作原理。这种非常快速的介绍可能不够，但
    *配方* 真的是为了让人对迭代器内部有一个良好的感觉。
- en: 'Most container classes, but also old-school C-style arrays, in one or the other
    way, contain a *range* of data items. A lot of day-to-day tasks that process a
    lot of data items do not care how to get at that data. However, if we regard,
    for example, an array of integers and a *linked list* of integers and want to
    calculate the *sum* of all the items of both the structures, we would end up with
    two different algorithms, which could look like the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数容器类，但也包括老式的 C 风格数组，以某种方式都包含一组数据项的 *范围*。许多日常任务处理大量数据项时并不关心如何获取这些数据。然而，如果我们考虑，例如，一个整数数组和一个整数
    *链表* 并想要计算这两种结构中所有项目的 *总和*，我们最终会得到两种不同的算法，可能看起来像下面这样：
- en: 'One algorithm, which deals with the array by checking its size and summing
    it up as follows:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个处理数组并检查其大小并将其求和的算法如下：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Another algorithm, which deals with the linked list by iterating until it reaches
    its end:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个算法，通过迭代链表直到达到其末尾：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Both of them are about *summing up integers*, but how large is the percentage
    of characters that we typed, which is directly related to the *actual* summing
    up task? And does one of them work with a third kind of data structure, let's
    say `std::map`, or do we have to implement another version of it? Without iterators,
    this would lead us into ridiculous directions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都是关于 *整数求和*，但我们输入的字符中有多少是直接与 *实际* 求和任务相关的？其中一个是否适用于第三种数据结构，比如 `std::map`，还是我们必须实现另一个版本？没有迭代器，这将使我们陷入荒谬的方向。
- en: 'Only with the help of iterators is it possible to implement this in a generic
    form:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 只有通过迭代器的帮助，才能以通用形式实现这一点：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This pretty and short, so-called, range-based `for` loop has been in existence
    since C++11\. It is just a syntax sugar, which expands to something similar to
    the following code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这种漂亮而简短的所谓基于范围的 `for` 循环自 C++11 以来就存在了。它只是一种语法糖，类似于以下代码：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is an old hat for everyone who has worked with iterators already and looks
    completely magic for everyone who didn''t. Imagine our vector of integers looks
    like the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些已经使用过迭代器的人来说，这已经是老生常谈了，但对于那些没有使用过的人来说，这看起来完全像是魔术。想象一下我们的整数向量看起来像下面这样：
- en: '![](img/5fd26991-6353-4490-b01b-959c754fe5b5.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5fd26991-6353-4490-b01b-959c754fe5b5.png)'
- en: The `std::begin(vector)` command is the same as `vector.begin()` and returns
    us an iterator that points to the first item (the **1**). `std::end(vector)` is
    the same as `vector.end()` and returns an iterator that points at one item *past
    the last* item (past the **5**).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::begin(vector)` 命令与 `vector.begin()` 相同，返回一个指向第一个项目（**1**）的迭代器。`std::end(vector)`
    与 `vector.end()` 相同，返回一个指向最后一个项目之后一个项目的迭代器（**5**之后）。'
- en: In every iteration, the loop checks if the begin iterator is non-equal to the
    end iterator. If so, it will *dereference* the begin iterator and thus access
    the integer value it points to. Then, it *increments* the iterator, repeats the
    comparison against the end iterator, and so on. In that moment, it helps to read
    the loop code again while imagining that the iterators are plain *C*-style pointers.
    In fact, plain C-style pointers are also a valid kind of iterators.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代中，循环都会检查起始迭代器是否不等于结束迭代器。如果是这样，它将 *解引用* 起始迭代器，从而访问它指向的整数值。然后，它 *递增* 迭代器，重复与结束迭代器的比较，依此类推。在这一刻，帮助阅读循环代码时想象迭代器就是普通的
    *C* 风格指针。事实上，普通的 C 风格指针也是一种有效的迭代器。
- en: Iterator categories
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器类别
- en: There are multiple categories of iterators, and they have different limitations.
    They are not too hard to memorize, just remember that the capabilities one category
    requires are inherited from the next powerful category. The whole point of iterator
    categories is that if an algorithm knows what kind of iterator it is dealing with,
    it can be implemented in an optimized way. This way, the programmer can lean back
    and express his intent, while the compiler can choose the *optimal implementation*
    for the given task.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器有多个类别，它们有不同的限制。它们并不难记忆，只需记住一个类别所需的功能是从下一个更强大的类别继承的。迭代器类别的整个重点在于，如果算法知道它正在处理哪种类型的迭代器，它可以以一种优化的方式实现。这样，程序员可以放松并表达自己的意图，而编译器可以选择给定任务的
    *最佳实现*。
- en: 'Let''s go through them in the right order:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按正确的顺序来看一下：
- en: '![](img/d9d1c3e9-25b2-45d2-9630-3759bef7cb1d.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9d1c3e9-25b2-45d2-9630-3759bef7cb1d.png)'
- en: Input iterator
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入迭代器
- en: Input iterators can be dereferenced only for *reading* the values they point
    to. Once they are incremented, the last value they pointed to has been *invalidated*
    during the incrementation. This means that it is not possible to iterate over
    such a range multiple times. The `std::istream_iterator` is an example for this
    category.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 输入迭代器只能被解引用来*读取*它们指向的值。一旦它们被增加，它们指向的最后一个值在增加过程中被*失效*。这意味着不可能多次迭代这样的范围。`std::istream_iterator`就是这一类的例子。
- en: Forward iterator
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前向迭代器
- en: Forward iterators are the same as input iterators, but they differ in that regard
    that the ranges they represent can be iterated over multiple times. The `std::forward_list`
    iterators are an example of that. Such a list can only be iterated over *forward*,
    not backward, but it can be iterated over as often as we like to.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前向迭代器与输入迭代器相同，但它们的区别在于它们表示的范围可以被多次迭代。`std::forward_list`的迭代器就是一个例子。这样的列表只能*向前*迭代，不能向后，但可以随意多次迭代。
- en: Bidirectional iterator
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双向迭代器
- en: The bidirectional iterator, as the name suggests, can be incremented and decremented,
    in order to iterate forward or backward. The iterators of `std::list`, `std::set`,
    and `std::map`, for example, support that.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 双向迭代器，顾名思义，可以被增加和减少，以便向前或向后迭代。例如，`std::list`、`std::set`和`std::map`的迭代器支持这一点。
- en: Random access iterator
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随机访问迭代器
- en: Random access iterators allow jumping over multiple values at once, instead
    of single-stepping. This is the case for iterators of `std::vector` and `std::deque`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 随机访问迭代器允许一次跳过多个值，而不是逐个步进。这适用于`std::vector`和`std::deque`的迭代器。
- en: Contiguous iterator
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连续迭代器
- en: This category specifies all of the aforementioned requirements, plus the requirement
    that the data that is being iterated through lies in contiguous memory, like it
    does in an array, or `std::vector`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类别指定了前面提到的所有要求，还要求被迭代的数据位于连续的内存中，就像在数组或`std::vector`中一样。
- en: Output iterator
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输出迭代器
- en: Output iterators are detached from the other categories. This is because an
    iterator can be a pure output iterator, which can only be incremented and used
    to *write* to the data it points to. If they are being read from, the value will
    be undefined.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 输出迭代器与其他类别无关。这是因为迭代器可以是纯输出迭代器，只能被增加并用于*写入*它指向的数据。如果它们被读取，值将是未定义的。
- en: Mutable iterator
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变迭代器
- en: If an iterator is an output iterator and one of the other categories at the
    same time, it is a mutable iterator. It can be read from and written to. If we
    obtain an iterator from a non-const container instance, it will usually be of
    this kind.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个迭代器既是输出迭代器又是其他类别之一，它就是可变迭代器。它可以被读取和写入。如果我们从一个非const容器实例中获取迭代器，它通常会是这种类型。
- en: Building your own iterable range
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建自己的可迭代范围
- en: We already realized that iterators are, kind of, the *standard interface* for
    iterations over containers of all kinds. We just need to implement the prefix
    increment operator, `++`, the dereference operator, `*`, and the object comparison
    operator, `==`, and then we already have a primitive iterator that fits into the
    fancy C++11 range-based `for` loop.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经意识到迭代器在各种容器上进行迭代时，有点像*标准接口*。我们只需要实现前缀增量运算符`++`、解引用运算符`*`和对象比较运算符`==`，然后我们就已经有了一个原始迭代器，可以适应时髦的C++11基于范围的`for`循环。
- en: In order to get used to this a bit more, this recipe shows how to implement
    an iterator that just emits a range of numbers when iterating through it. It is
    not backed by any container structure or anything similar. The numbers are generated
    ad hoc while iterating.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地适应这一点，这个示例展示了如何实现一个迭代器，当通过迭代时只发出一系列数字。它不依赖于任何容器结构或类似的东西。这些数字是在迭代时临时生成的。
- en: How to do it...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we will implement our own iterator class, and then, we will
    iterate through it:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将实现自己的迭代器类，然后通过它进行迭代：
- en: 'First, we include the header, which enables us to print to the terminal:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们包含头文件，这样我们就可以打印到终端：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Our iterator class will be called `num_iterator`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的迭代器类将被称为`num_iterator`：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Its only data member is an integer. That integer is used for counting. The
    constructor is for initializing it. It is generally a good form to make constructors
    *explicit*, which create a type from another type to avoid *accidental* implicit
    conversion. Note that we also provide a default value for `position`. This makes
    the instances of the `num_iterator` class default-constructible. Although we will
    not use the default constructor in the whole recipe, this is really important
    because some STL algorithms depend on iterators being default-constructible:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它唯一的数据成员是一个整数。该整数用于计数。构造函数用于初始化它。通常最好将构造函数设为*显式*，这样可以避免*意外*的隐式转换。请注意，我们还为`position`提供了默认值。这使得`num_iterator`类的实例可以默认构造。尽管在整个示例中我们不会使用默认构造函数，但这真的很重要，因为一些STL算法依赖于迭代器是默认可构造的：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When dereferencing our iterator (`*it`), it will emit an integer:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当解引用我们的迭代器(`*it`)时，它将发出一个整数：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Incrementing the iterator (`++it`) will just increment its internal counter,
    `i`:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加迭代器(`++it`)只会增加它的内部计数器`i`：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A `for` loop will compare the iterator against the end iterator. If they are
    *unequal*, it will continue iterating:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`for`循环将迭代器与结束迭代器进行比较。如果它们*不相等*，它将继续迭代：'
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'That was the iterator class. We still need an intermediate object for writing
    `for (int i : intermediate(a, b)) {...}`, which then contains the begin and end
    iterator, which is preprogrammed to iterate from `a` to `b`. We call it `num_range`:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '这就是迭代器类。我们仍然需要一个中间对象来编写`for (int i : intermediate(a, b)) {...}`，然后包含开始和结束迭代器，它被预设为从`a`到`b`进行迭代。我们称之为`num_range`：'
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It contains two integer members, which denote at which number the iteration
    shall start, and which number is the first number past the last number. This means
    if we want to iterate from `0` to `9`, `a` is set to `0` and `b` to `10`:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它包含两个整数成员，表示迭代应该从哪个数字开始，以及第一个数字过去的数字是多少。这意味着如果我们想要从`0`到`9`进行迭代，`a`设置为`0`，`b`设置为`10`：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There are only two member functions that we need to implement: the `begin`
    and `end` functions. Both return iterators that point to the beginning and the
    end of the numeric range:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需要实现两个成员函数：`begin`和`end`函数。两者都返回指向数字范围开始和结束的迭代器：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'That''s it. We can use it. Let''s write a main function which just iterates
    over a range that goes from `100` to `109` and prints all its values:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就是这样。我们可以使用它。让我们编写一个主函数，它只是迭代从`100`到`109`的范围，并打印出所有的值：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Compiling and running the program yields the following terminal output:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序产生以下终端输出：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '工作原理... '
- en: 'Consider that we write the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们编写以下代码：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The compiler will evaluate it to the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将对其求值为以下内容：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'While looking at this code, it becomes obvious that the only requirements for
    the iterators are the following three operators:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看这段代码时，很明显迭代器的唯一要求是以下三个运算符：
- en: '`operator!=`: unequal comparison'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator!=`：不相等比较'
- en: '`operator++`: prefix increment'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator++`：前缀递增'
- en: '`operator*`: dereference'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator*`：解引用'
- en: The requirements of the range are that it has a `begin` and an `end` method,
    which return two iterators that denote the beginning and the end of a range.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 范围的要求是它有一个`begin`和一个`end`方法，返回两个迭代器，表示范围的开始和结束。
- en: In this book, we're mostly using `std::begin(x)` instead of `x.begin()`. This
    is generally a good style because `std::begin(x)` automatically calls `x.begin()`
    if that member method is available. If `x` is an array that does not have a `begin()`
    method, `std::begin(x)` will automatically find out how to deal with it. The same
    applies to `std::end(x)`. User defined types that do not provide `begin()`/`end()`
    members do not work with `std::begin`/`std::end`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们大多数时候使用`std::begin(x)`而不是`x.begin()`。这通常是一个很好的风格，因为`std::begin(x)`会自动调用`x.begin()`，如果该成员方法可用。如果`x`是一个没有`begin()`方法的数组，`std::begin(x)`会自动找出如何处理它。对`std::end(x)`也是一样。不提供`begin()`/`end()`成员的用户定义类型无法使用`std::begin`/`std::end`。
- en: What we did in this recipe is just fit a simple number counting algorithm into
    the forward iterator interface. Implementing an iterator and a range always involves
    this minimum amount of boilerplate code, which can be a little bit annoying on
    the one hand. A look at the loop that uses `num_range` is, on the other hand,
    very rewarding because it looks so *perfectly simple*!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们所做的只是将一个简单的数字计数算法适应到前向迭代器接口中。实现迭代器和范围总是涉及到这最少量的样板代码，这在一方面可能有点烦人。另一方面，查看使用`num_range`的循环是非常有益的，因为它看起来如此*完美简单*！
- en: Scroll back and have a thorough look on which of the methods of the iterator
    and the range class are `const`. Forgetting to make those functions `const` can
    make the compiler *reject* your code in a lot of situations because it is a common
    thing to iterate over `const` objects.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 回头仔细看看迭代器和范围类的方法中哪些是`const`。忘记使这些函数`const`可能会使编译器在许多情况下*拒绝*您的代码，因为迭代`const`对象是一件很常见的事情。
- en: Making your own iterators compatible with STL iterator categories
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使自己的迭代器与STL迭代器类别兼容
- en: Whatever own container data structure we come up with, in order to effectively
    *mix* it with all the STL goodness, we need to make them provide iterator interfaces.
    In the last section, we learned how to do that, but we do soon realize that *some*
    STL algorithms *do not compile* well with our custom iterators. Why?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们想出什么自己的容器数据结构，为了有效地*混合*它与所有STL的优点，我们需要使它们提供迭代器接口。在上一节中，我们学会了如何做到这一点，但我们很快意识到*一些*STL算法*无法*与我们的自定义迭代器很好地编译。为什么？
- en: The problem is that a lot of STL algorithms try to find out more about the iterators
    they are asked by us to deal with. Different iterator *categories* have different
    capabilities, and hence, there might be different possibilities to implement the
    *same* algorithm. For example, if we copy *plain numbers* from one `std::vector`
    to another, this may be implemented with a fast `memcpy` call. If we copy data
    from or to `std::list`, this is *not* possible any longer and the items have to
    be copied individually one by one. The implementers of the STL algorithms put
    a lot of thought into this kind of automatic optimization. In order to help them,
    we can equip our iterators with some *information* about them. This section shows
    how to achieve the same.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于很多STL算法试图找出更多关于它们被我们要求处理的迭代器的信息。不同的迭代器*类别*具有不同的功能，因此，可能有不同的可能性来实现*相同*的算法。例如，如果我们从一个`std::vector`复制*普通数字*到另一个，这可能是通过快速的`memcpy`调用来实现的。如果我们从`std::list`复制数据，这就不再可能了，项目必须一个接一个地逐个复制。STL算法的实现者对这种自动优化进行了大量思考。为了帮助他们，我们可以为我们的迭代器提供一些关于它们的*信息*。本节展示了如何实现相同的功能。
- en: How to do it...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this section, we will implement a primitive iterator that counts numbers
    and use it together with an STL algorithm, which initially does not compile with
    it. Then we do what's necessary to make it STL-compatible.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现一个原始迭代器，计数数字并将其与最初无法与之一起编译的STL算法一起使用。然后我们做必要的工作使其与STL兼容。
- en: 'First, we need to include some headers, as always:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要像往常一样包含一些头文件：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then we implement a primitive number counting iterator, as in the previous
    section. When iterating over it, it will emit plain increasing integers. The `num_range`
    acts as a handy *begin* and *end* iterator donor:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们实现一个原始的数字计数迭代器，就像前一节一样。在对其进行迭代时，它将发出普通递增的整数。`num_range`充当一个方便的*begin*和*end*迭代器捐赠者：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In order to keep the `std::` namespace prefix out and keep the code readable,
    we declare that we use namespace `std`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使`std::`命名空间前缀保持在外部并保持代码可读性，我们声明使用`std`命名空间：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s now just instantiate a range that goes from `100` to `109`. Note that
    the value `110` is the position of the end iterator. This means that `110` is
    the *first* number that is *outside* the range (which is why it goes from `100`
    to `109`):'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们实例化一个范围，从`100`到`109`。请注意，值`110`是结束迭代器的位置。这意味着`110`是范围之外的*第一个*数字（这就是为什么它从`100`到`109`）：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And now, we use it with `std::minmax_element`. This algorithm returns us `std::pair`
    with two members: an iterator pointing to the lowest value and another iterator
    pointing to the highest value in the range. These are, of course, `100` and `109`
    because that''s how we constructed the range:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用`std::minmax_element`。这个算法返回一个`std::pair`，其中包含两个成员：指向范围中最低值的迭代器和指向最高值的迭代器。当然，这些值是`100`和`109`，因为这是我们构造范围的方式：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Compiling the code leads to the following error message. It''s some error related
    to `std::iterator_traits`. More on that later. It *might* happen that there are
    *other* errors on other compilers and/or STL library implementations or *no* errors
    at all. This error message occurs with clang version 5.0.0 (trunk 299766):'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译代码会导致以下错误消息。这是与`std::iterator_traits`相关的错误。稍后会详细介绍。*可能*会发生其他编译器和/或STL库实现的错误，或者*根本没有*错误。这个错误消息出现在clang版本5.0.0（trunk
    299766）中：
- en: '![](img/52d1b385-6f1a-4731-97a4-4389d0e9047b.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/52d1b385-6f1a-4731-97a4-4389d0e9047b.png)'
- en: 'In order to fix this, we need to activate iterator trait functionality for
    our iterator class. Just after the definition of `num_iterator`, we write the
    following template structure specialization of the `std::iterator_traits` type.
    It tells the STL that our `num_iterator` is of the category forward iterator,
    and it iterates over `int` values:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要为我们的迭代器类激活迭代器特性功能。在`num_iterator`的定义之后，我们编写了`std::iterator_traits`类型的以下模板结构专门化。它告诉STL我们的`num_iterator`是前向迭代器类别，并且它迭代`int`值：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s compile it again; we can see that it works! The output of the min/max
    function is the following, which is just what we expect:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次编译它；我们可以看到它工作了！min/max函数的输出如下，这正是我们期望的：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Some STL algorithms need to know the characteristics of the iterator type they
    are used with. Some others need to know the type of items the iterators iterate
    over. This has different implementation reasons.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一些STL算法需要了解它们所使用的迭代器类型的特性。其他一些需要知道迭代器迭代的项目类型。这有不同的实现原因。
- en: 'However, all STL algorithms will access this type information via `std::iterator_traits<my_iterator>`,
    assuming that the iterator type is `my_iterator`. This traits class contains up
    to five different type member definitions:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，所有STL算法将通过`std::iterator_traits<my_iterator>`访问此类型信息，假设迭代器类型为`my_iterator`。这个特性类包含多达五种不同的类型成员定义：
- en: '`difference_type`: What type results from writing `it1 - it2`?'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`difference_type`：写`it1 - it2`的结果是什么类型？'
- en: '`value_type`: Of what type is the item which we access with `*it` (note that
    this is `void` for pure output iterators)?'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value_type`：我们使用`*it`访问的项目是什么类型（请注意，对于纯输出迭代器，这是`void`）？'
- en: '`pointer`: Of what type must a pointer be in order to point to an item?'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pointer`：为了指向一个项目，指针必须是什么类型？'
- en: '`reference`: Of what type must a reference be in order to reference an item?'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reference`：为了引用一个项目，引用必须是什么类型？'
- en: '`iterator_category`: Which category does the iterator belong to?'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iterator_category`：迭代器属于哪个类别？'
- en: The `pointer`, `reference`, and `difference_type` type definitions do not make
    sense for our `num_iterator`, as it doesn't iterate over real *memory* values
    (we just *return* `int` values but they are not persistently available like in
    an array). Therefore it's better to not define them because if an algorithm depends
    on those items being referenceable in memory, it might be *buggy* when combined
    with our iterator.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`pointer`、`reference`和`difference_type`类型定义对于我们的`num_iterator`来说是没有意义的，因为它不迭代真正的*内存*值（我们只是*返回*`int`值，但它们不像数组中那样持久可用）。因此最好不定义它们，因为如果算法依赖于这些项目在内存中可引用，当与我们的迭代器结合时可能会出现*错误*。'
- en: There's more...
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Until C++17, it was encouraged to let iterator types just inherit from `std::iterator<...>`,
    which automatically populates our class with all the type definitions. This still
    works, but it is discouraged since C++17.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 直到C++17，鼓励让迭代器类型直接继承自`std::iterator<...>`，这会自动填充我们的类所有类型定义。这仍然有效，但自C++17以来已不再鼓励。
- en: Using iterator adapters to fill generic data structures
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用迭代器适配器填充通用数据结构
- en: In a lot of situations, we want to fill any container with masses of data, but
    the data source and the container have *no common interface*. In such a situation,
    we would need to write our own hand-crafted algorithms that just deal with the
    question of how to shove data from the source to the sink. Usually, this distracts
    us from our actual work of *solving* a specific *problem*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们希望用大量数据填充任何容器，但数据源和容器没有*共同的接口*。在这种情况下，我们需要编写自己的手工制作的算法，只是处理如何将数据从源推送到接收端的问题。通常，这会让我们分心，无法专注于解决特定*问题*的实际工作。
- en: 'Tasks where we simply transport data between conceptually different data structures
    can be implemented with a one-liner code, thanks to another abstraction provided
    by the STL: **iterator adapters**. This section demonstrates the use of some of
    them in order to give a feeling how useful they are.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用一行代码实现在概念上不同的数据结构之间传输数据的任务，这要归功于STL提供的另一个抽象：**迭代器适配器**。本节演示了如何使用其中一些迭代器适配器，以便让人感受到它们有多么有用。
- en: How to do it...
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this section, we use some iterator wrappers just for the sake of showing
    that they exist and how they can help us in everyday programming tasks.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用一些迭代器包装器，只是为了展示它们的存在以及它们如何帮助我们在日常编程任务中。
- en: 'We need to include some headers first:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要首先包含一些头文件：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Declaring that we use namespace `std` spares us some typing later:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明我们使用命名空间`std`可以减少我们以后的输入：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We start with `std::istream_iterator`. We specialize it on `int`. This way,
    it will try to parse the standard input to integers. For example, if we iterate
    over it, it will look as if it was `std::vector<int>`. The end iterator is instantiated
    of the same type but without any constructor arguments:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`std::istream_iterator`开始。我们将其专门化为`int`。这样，它将尝试将标准输入解析为整数。例如，如果我们对其进行迭代，它看起来就像是`std::vector<int>`。结束迭代器也是用相同类型实例化的，但没有任何构造参数：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Next, we instantiate `std::deque<int>` and just copy over all the integers from
    the standard input into the deque. The deque itself is not an iterator, so we
    wrap it into `std::back_insert_iterator` using the `std::back_inserter` helper
    function. This special iterator wrapper will execute `v.push_back(item)` with
    each of the items we get from the standard input. This way the deque is grown
    automatically!
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们实例化`std::deque<int>`，并将所有整数从标准输入复制到deque中。deque本身不是一个迭代器，所以我们使用`std::back_inserter`辅助函数将其包装成`std::back_insert_iterator`。这个特殊的迭代器包装器将对我们从标准输入获取的每个项目执行`v.push_back(item)`。这样，deque会自动增长！
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the next exercise, we use `std::istringstream` to copy items into the *middle*
    of the deque. So, let''s first define some example numbers in the form of a string
    and instantiate the stream object from it:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们使用`std::istringstream`将项目复制到deque的*中间*。因此，让我们首先定义一些示例数字，以字符串的形式实例化流对象：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Then, we need a hint of where to insert into the deque. It will be the middle,
    so we use the begin pointer of the deque and feed it to the `std::next` function.
    The second argument of this function says that it will return an iterator advanced
    by `v.size() / 2` steps, that is, *half* the deque. (We cast `v.size()` to `int`
    because the second parameter of `std::next` is `difference_type` of the iterator
    used as the first parameter. In this case, this is a signed integer type. Depending
    on the compiler flags, the compiler might *warn* at this point if we didn't cast
    explicitly.)
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要一个提示，告诉我们在deque中插入的位置。这将是中间，所以我们使用deque的begin指针并将其传递给`std::next`函数。这个函数的第二个参数表示它将返回一个迭代器，向前移动了`v.size()
    / 2`步，也就是deque的*一半*。（我们将`v.size()`强制转换为`int`，因为`std::next`的第二个参数是作为第一个参数使用的迭代器的`difference_type`。在这种情况下，这是一个有符号整数类型。根据编译器标志，如果我们没有显式转换，编译器可能会在这一点*警告*。）
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we can copy parsed integers step by step from the input string stream
    into the deque. Again, the end iterator of a stream iterator wrapper is just an
    empty `std::istream_iterator<int>` without constructor arguments (that is, the
    empty `{}` braces in the code line). The deque is wrapped into an inserter wrapper,
    which is an `std::insert_iterator`, which is pointed to the deque''s middle using
    the `deque_middle` iterator:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以逐步将解析的整数从输入字符串流复制到deque中。再次强调，流迭代器包装器的结束迭代器只是一个没有构造参数的空的`std::istream_iterator<int>`（即代码行中的空`{}`括号）。deque被包装成插入器包装器，它是一个`std::insert_iterator`，使用`deque_middle`迭代器指向deque的中间：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, let''s use `std::front_insert_iterator` to insert some items at the front
    of the deque:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用`std::front_insert_iterator`在deque的前面插入一些项目：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the last step, we print the whole content of the deque out to the user shell.
    The `std::ostream_iterator` works like an output iterator which, in our case,
    just forwards all the integers it gets copied from to `std::cout` and then appends
    `", "` after each item:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一步，我们将整个deque的内容打印到用户shell上。`std::ostream_iterator`的工作原理类似于输出迭代器，在我们的例子中，它只是将所有从中复制的整数转发到`std::cout`，然后在每个项目后附加`",
    "`：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Compiling and running the program yields the following output. Can you identify
    which number was inserted by which code line?
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行程序会产生以下输出。你能辨别出哪个数字是由哪行代码插入的吗？
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works...
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: We used a lot of different iterator adapters in this section. They all have
    one thing in common, which is they wrap an object into an iterator that is not
    an iterator itself.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用了许多不同的迭代器适配器。它们都有一个共同点，就是它们将一个对象包装成一个不是迭代器本身的迭代器。
- en: std::back_insert_iterator
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::back_insert_iterator
- en: The `back_insert_iterator` can be wrapped around `std::vector`, `std::deque`,
    `std::list`, and so on. It will call the container's `push_back` method, which
    inserts the new item *past* the existing items. If the container instance is not
    large enough, it will be grown automatically.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`back_insert_iterator`可以包装`std::vector`、`std::deque`、`std::list`等。它将调用容器的`push_back`方法，将新项目*插入*到现有项目之后。如果容器实例不够大，它将自动增长。'
- en: std::front_insert_iterator
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::front_insert_iterator
- en: The `front_insert_iterator` does exactly the same thing as `back_insert_iterator`,
    but it calls the container's `push_front` method, which inserts the new item *before*
    all the existing items. Note that for a container like `std::vector`, this means
    that all the existing items need to be moved one slot further in order to leave
    space for the new item at the front.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`front_insert_iterator`和`back_insert_iterator`完全做相同的事情，但它调用容器的`push_front`方法，这会在所有现有项目*之前*插入新项目。请注意，对于像`std::vector`这样的容器，这意味着所有现有项目都需要向前移动一个位置，以便为前面的新项目留出空间。'
- en: std::insert_iterator
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::insert_iterator
- en: This iterator adapter is similar to the other inserters, but is able to insert
    new items *between* existing ones. The `std::inserter` helper function which constructs
    such a wrapper takes two arguments. The first argument is the container and the
    second argument is an iterator that points to the position where new items shall
    be inserted.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个迭代器适配器类似于其他插入器，但能够在现有项目*之间*插入新项目。构造这样一个包装器的`std::inserter`辅助函数需要两个参数。第一个参数是容器，第二个参数是指向新项目应该插入的位置的迭代器。
- en: std::istream_iterator
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::istream_iterator
- en: The `istream_iterator` is another very handy adapter. It can be used with any
    `std::istream` object (which can be the standard input or files for example) and
    will try to parse the input from that stream object according to the template
    parameter it was instantiated with. In this section, we used `std::istream_iterator<int>(std::cin)`,
    which pulls integers out of the standard input for us.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`istream_iterator`是另一个非常方便的适配器。它可以与任何`std::istream`对象一起使用（例如标准输入或文件），并将尝试根据实例化时的模板参数从该流对象中解析输入。在本节中，我们使用了`std::istream_iterator<int>(std::cin)`，它从标准输入中提取整数。'
- en: The special thing about streams is that we often cannot know in advance how
    long the stream is. That leaves the question, where will the *end* iterator point
    to if we do not know where the stream's end is? The way this works is that the
    iterator *knows* when it reaches the end of the stream. When it is compared to
    the end iterator, it will effectively *not really* compare itself with the end
    iterator but return if the stream has any tokens *left*. That's why the end iterator
    constructor does not take any arguments.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 流的特殊之处在于我们通常无法预先知道流的长度。这就引出了一个问题，如果我们不知道流的结束在哪里，*结束*迭代器将指向哪里？它的工作方式是，迭代器*知道*当它到达流的末尾时。当它与结束迭代器进行比较时，它实际上*不会真正*与结束迭代器进行比较，而是返回流是否还有标记*剩余*。这就是为什么结束迭代器的构造函数不接受任何参数。
- en: std::ostream_iterator
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::ostream_iterator
- en: 'The `ostream_iterator` is the same thing as the `istream_iterator`, but it
    works the other way around: It doesn''t take tokens *from* an *input* stream--it
    pushes tokens *into* an *output* stream. Another difference to `istream_iterator`
    is that its constructor takes a second argument, which is a string that shall
    be pushed into the output stream after each item. That is useful because this
    way we can print a separating `", "` or a new line after each item.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`ostream_iterator`与`istream_iterator`相同，但工作方式相反：它不从*输入*流中获取标记，而是将标记推送到*输出*流中。与`istream_iterator`的另一个不同之处在于，它的构造函数接受第二个参数，该参数是一个字符串，应在每个项目后推送到输出流中。这很有用，因为这样我们可以在每个项目后打印一个分隔符`",
    "`或一个新行。'
- en: Implementing algorithms in terms of iterators
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以迭代器实现算法
- en: Iterators usually iterate by *moving* their *position* from one item of a container
    to another. But they do not necessarily need to iterate over data structures at
    all. Iterators can also be used to implement algorithms, in which case, they would
    calculate the next value when they are incremented (`++it`) and return that value
    when they are dereferenced (`*it`).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器通常通过*移动*它们的*位置*从容器的一个项目迭代到另一个项目。但它们不一定需要在数据结构上进行迭代。迭代器也可以用于实现算法，在这种情况下，它们在递增（`++it`）时计算下一个值，并在解引用（`*it`）时返回该值。
- en: 'In this section, we demonstrate this by implementing the Fibonacci function
    in form of an iterator. The Fibonacci function is recursively defined like this:
    `F(n) = F(n - 1) + F(n - 2)`. It starts with the beginning values of `F(0) = 0`
    and `F(1) = 1`. This leads to the following number sequence:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们通过实现迭代器形式的斐波那契函数来演示这一点。斐波那契函数的递归定义如下：`F(n) = F(n - 1) + F(n - 2)`。它从`F(0)
    = 0`和`F(1) = 1`的初始值开始。这导致以下数字序列：
- en: '`F(0) = 0`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`F(0) = 0`'
- en: '`F(1) = 1`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`F(1) = 1`'
- en: '`F(2) = F(1) + F(0) = 1`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`F(2) = F(1) + F(0) = 1`'
- en: '`F(3) = F(2) + F(1) = 2`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`F(3) = F(2) + F(1) = 2`'
- en: '`F(4) = F(3) + F(2) = 3`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`F(4) = F(3) + F(2) = 3`'
- en: '`F(5) = F(4) + F(3) = 5`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`F(5) = F(4) + F(3) = 5`'
- en: '`F(6) = F(5) + F(4) = 8`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`F(6) = F(5) + F(4) = 8`'
- en: '... and so on'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '...等等'
- en: 'If we implement this in the form of a callable function that returns the Fibonacci
    value for any number, *n*, we will end up with a recursive self-calling function,
    or a loop implementation. This is fine, but what if we write some program where
    have to consume Fibonacci numbers in some pattern, one after the other? We would
    have two possibilities--either we recalculate all the recursive calls for every
    new Fibonacci number, which is a waste of computing time, or we save the last
    two Fibonacci numbers as temporary variables and use them to calculate the next.
    In the latter case, we reimplemented the Fibonacci algorithm loop implementation.
    It seems that we would end up *mixing* Fibonacci code with our actual code, which
    solves a different problem:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们以可调用函数的形式实现这一点，该函数将返回任何数字*n*的斐波那契值，我们最终将得到一个递归自调用函数，或者一个循环实现。这没问题，但是如果我们编写一些程序，需要按某种模式消耗斐波那契数，一个接一个地，我们将有两种可能性——要么我们为每个新的斐波那契数重新计算所有递归调用，这是一种浪费计算时间的做法，要么我们保存最后两个斐波那契数作为临时变量，并使用它们来计算下一个。在后一种情况下，我们重新实现了斐波那契算法的循环实现。看起来我们最终会*混合*斐波那契代码和解决不同问题的实际代码：
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Iterators are an interesting way out of this. How about wrapping the steps that
    we do in the loop-based iterative Fibonacci implementation in the prefix increment
    `++` operator implementation of a Fibonacci value *iterator*? This is pretty easy,
    as this section demonstrates.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是解决这个问题的一个有趣方法。我们可以将基于循环的迭代式斐波那契实现中的步骤包装在斐波那契值*迭代器*的前缀递增`++`运算符实现中。正如本节所示，这是非常容易的。
- en: How to do it...
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this section, we concentrate on implementing an iterator that generates numbers
    from the Fibonacci number sequence while iterating over it.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们专注于实现一个在迭代过程中生成斐波那契数列数字的迭代器。
- en: 'In order to be able to print the Fibonacci numbers to the terminal, we need
    to include a header first:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够将斐波那契数打印到终端，我们首先需要包含一个头文件：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We call the Fibonacci iterator, `fibit`. It will carry a member `i`, which
    saves the index position in the Fibonacci sequence, and `a` and `b` will be the
    variables that hold the last two Fibonacci values. If instantiated with the default
    constructor, a Fibonacci iterator will be initialized to the value `F(0)`:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们称斐波那契迭代器为`fibit`。它将携带一个成员`i`，用于保存斐波那契序列中的索引位置，`a`和`b`将是保存最后两个斐波那契值的变量。如果使用默认构造函数实例化，斐波那契迭代器将初始化为值`F(0)`：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, we define the standard constructor and another constructor, which allows
    us to initialize the iterator at any Fibonacci number step:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义标准构造函数和另一个构造函数，它允许我们在任何斐波那契数步骤上初始化迭代器：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When dereferencing our iterator (`*it`), it will just emit the Fibonacci number
    of the current step:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当解引用我们的迭代器（`*it`）时，它将只输出当前步骤的斐波那契数：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When incrementing the iterator (`++it`), it will move its state to the next
    Fibonacci number. This function contains the same code as the loop-based Fibonacci
    implementation:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在增加迭代器（++it）时，它将将其状态移动到下一个斐波那契数。这个函数包含与基于循环的斐波那契实现相同的代码：
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When used in a loop, the incremented iterator is compared against an end iterator,
    for which we need to define the `!=` operator. We are only comparing the *step*
    at which the Fibonacci iterators currently reside, which makes it easier to define
    the end iterator for step `1000000`, for example, as we do not need to expensively
    calculate such a high Fibonacci number *in advance*:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环中使用时，增加的迭代器与结束迭代器进行比较，因此我们需要定义`!=`运算符。我们只比较斐波那契迭代器当前所在的*步骤*，这样可以更容易地为步骤`1000000`定义结束迭代器，例如，因为我们不需要提前昂贵地计算这么高的斐波那契数：
- en: '[PRE40]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In order to be able to use the Fibonacci iterator in the range-based `for`
    loop, we have to implement a range class beforehand. We call it `fib_range`, and
    its constructor will accept one parameter that tells how far in the Fibonacci
    range we want to iterate:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够在基于范围的`for`循环中使用斐波那契迭代器，我们必须事先实现一个范围类。我们称之为`fib_range`，它的构造函数将接受一个参数，告诉我们要在斐波那契范围内迭代多远：
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Its `begin` and `end` functions return iterators which point to the positions,
    `F(0)` and `F(end_n)`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它的`begin`和`end`函数返回指向位置`F(0)`和`F(end_n)`的迭代器：
- en: '[PRE42]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Okay, now let''s forget about all the iterator-related boilerplate code. We
    do not need to touch it again as we have a helper class now which nicely hides
    all the implementation details from us! Let''s print the first 10 Fibonacci numbers:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好了，现在让我们忘记所有与迭代器相关的样板代码。因为我们现在有了一个辅助类，可以很好地隐藏所有的实现细节！让我们打印前10个斐波那契数：
- en: '[PRE43]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Compiling and running the program yields the following shell output:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序会产生以下shell输出：
- en: '[PRE44]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: There's more...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In order to use this iterator with the STL, it must support the `std::iterator_traits`
    class. To see how to do that, have a look at the *other* recipe, which deals with
    exactly that matter: *Making your own iterators compatible with STL iterator categories.*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在STL中使用这个迭代器，它必须支持`std::iterator_traits`类。要了解如何做到这一点，请看*其他*的食谱，它处理了这个问题：*使您自己的迭代器与STL迭代器类别兼容*。
- en: 'Try to think in terms of iterators. This leads to very elegant code in many
    situations. Don''t worry about performance: compilers find it *trivial* to optimize
    away the iterator-related boilerplate code!'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 试着以迭代器的方式思考。这在许多情况下会导致非常优雅的代码。不要担心性能：编译器发现优化掉与迭代器相关的样板代码是*微不足道*的！
- en: 'In order to keep the example simple, we did not do anything about this, but
    if we do publish the Fibonacci iterator as a library, it would become apparent
    that it has a usability flaw--a `fibit` instance that was created with a constructor
    parameter will only be used as an end iterator because it does not contain valid
    Fibonacci values. Our tiny library does not enforce such usage. There are different
    possibilities to fix it:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持示例简单，我们没有做任何处理，但如果我们将斐波那契迭代器发布为库，就会发现它存在一个可用性缺陷--使用构造函数参数创建的`fibit`实例只能用作结束迭代器，因为它不包含有效的斐波那契值。我们的小型库不强制这种用法。有不同的可能性来解决这个问题：
- en: Make the `fibit(size_t i_)` constructor private and declare the `fib_range`
    class as a friend of the `fibit` class. This way, users can only use it the right
    way.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`fibit(size_t i_)`构造函数设置为私有，并将`fib_range`类声明为`fibit`类的友元。这样，用户只能以正确的方式使用它。
- en: 'Use iterator sentinels in order to prevent users to dereference the end iterator.
    Have a look at the recipe in which we introduce those: *Terminating iterations
    over ranges with iterator sentinels*'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用迭代器哨兵来防止用户解引用结束迭代器。看看我们介绍的那个食谱：*使用迭代器哨兵终止范围上的迭代*。
- en: Iterating the other way around using reverse iterator adapters
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用反向迭代器适配器进行反向迭代
- en: Sometimes, it is valuable to iterate over a range the other way around, not
    forward but *backward*. The range-based `for` loop, as well as all STL algorithms
    usually iterate over the given ranges by *incrementing* iterators, although iterating
    backward requires *decrementing* them. Of course, it is possible to *wrap* iterators
    into a layer that transforms an *increment* call effectively into a *decrement*
    call. This sounds like a lot of boilerplate code for every type on which we would
    like to support that.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，逆向迭代一个范围是有价值的，不是向前，而是*向后*。基于范围的`for`循环，以及所有STL算法通常通过*递增*迭代器来迭代给定的范围，尽管向后迭代需要*递减*它们。当然，可以将迭代器*包装*成一个层，将*递增*调用有效地转换为*递减*调用。这听起来像是为我们想要支持的每种类型编写大量样板代码。
- en: The STL provides a helpful *reverse-iterator adapter*, which helps us set up
    such iterators.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: STL提供了一个有用的*反向迭代器适配器*，可以帮助我们设置这样的迭代器。
- en: How to do it...
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we will use reverse iterators in different ways, just to show
    how they are used:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将以不同的方式使用反向迭代器，只是为了展示它们的用法：
- en: 'We need to include some headers first, as always:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先需要包含一些头文件，就像往常一样：
- en: '[PRE45]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, we declare that we use namespace `std` in order to spare us some typing:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们声明我们使用`std`命名空间，以节省一些输入。
- en: '[PRE46]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'For the sake of having something to iterate over, let''s instantiate a list
    of integers:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了有一些可以迭代的东西，让我们实例化一个整数列表：
- en: '[PRE47]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now let''s print these integers in the reverse form. In order to do that, we
    iterate over the list by using the `rbegin` and `rend` functions of `std::list`
    and shove those values out via the standard output using the handy `ostream_iterator`
    adapter:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们以相反的形式打印这些整数。为了做到这一点，我们使用`std::list`的`rbegin`和`rend`函数来遍历列表，并通过标准输出使用方便的`ostream_iterator`适配器将这些值输出：
- en: '[PRE48]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If a container does not provide handy `rbegin` and `rend` functions but at
    least provides bidirectional iterators, the `std::make_reverse_iterator` function
    helps out. It accepts *normal* iterators and converts them to *reverse* iterators:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个容器没有提供方便的`rbegin`和`rend`函数，但至少提供了双向迭代器，`std::make_reverse_iterator`函数会提供帮助。它接受*普通*迭代器并将它们转换为*反向*迭代器：
- en: '[PRE49]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Compiling and running our program yields the following output:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行我们的程序会产生以下输出：
- en: '[PRE50]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How it works...
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In order to be able to transform a normal iterator into a reverse iterator,
    it must at least have support for bidirectional iteration. This requirement is
    fulfilled by any iterator of the *bidirectional* category or higher.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够将普通迭代器转换为反向迭代器，它必须至少支持双向迭代。这个要求由*双向*类别或更高级别的任何迭代器都可以满足。
- en: A reverse iterator kind of *contains* a normal iterator and *mimics* its interface
    completely, but it *rewires* the increment operation to a decrement operation.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 反向迭代器有点像包含一个普通迭代器并完全模拟其接口，但它将增量操作重定向为减量操作。
- en: 'The next detail is about the begin and end iterator positions. Let''s have
    a look at the following diagram, which shows a standard numeric sequence kept
    in an iterable range. If the sequence goes from `1` to `5`, then the begin iterator
    has to point to the element `1`, and the end iterator must point one element past
    `5`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个细节是关于开始和结束迭代器位置。让我们看一下下面的图表，它显示了一个可迭代范围中保留的标准数字序列。如果序列从`1`到`5`，那么开始迭代器必须指向元素`1`，结束迭代器必须指向`5`之后的一个元素：
- en: '![](img/5d43dc84-63ca-4492-ad21-1e3278268727.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d43dc84-63ca-4492-ad21-1e3278268727.png)'
- en: When defining reverse iterators, the `rbegin` iterator must point to `5`, and
    the `rend` iterator must point to the element *before* `1`. Turn the book upside
    down, and see that it completely makes sense.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义反向迭代器时，`rbegin`迭代器必须指向`5`，`rend`迭代器必须指向`1`*之前*的元素。把书倒过来看，就会完全合理。
- en: If we want our own custom container classes to support reverse iteration, we
    do not need to implement all these details ourselves; we can just wrap the normal
    iterators into reverse iterators by using the `std::make_reverse_iterator` helper
    function, and it does all the operator rewiring and offset corrections for us.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望我们自己的自定义容器类支持反向迭代，我们不需要自己实现所有这些细节；我们可以使用`std::make_reverse_iterator`辅助函数将普通迭代器包装成反向迭代器，它会为我们执行所有的操作重定向和偏移校正。
- en: Terminating iterations over ranges with iterator sentinels
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用迭代器标记终止范围的迭代
- en: Both STL algorithms and the range-based `for` loop assume that the begin and
    end positions of the iteration are known *in advance*. In some situations, however,
    it is hardly possible to know the end position *before reaching* it by iteration.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: STL算法和基于范围的`for`循环都假设迭代的开始和结束位置是*预先*已知的。然而，在某些情况下，很难在迭代*到达*之前知道结束位置。
- en: 'A very simple example for this is iterating over plain C-Style strings, the
    length of which is not known before *runtime*. The code which iterates over such
    strings usually looks like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常简单的例子是迭代普通的C风格字符串，其长度在*运行时*之前是未知的。通常迭代这样的字符串的代码看起来像这样：
- en: '[PRE51]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The only way to put this into a range-based `for` loop seems to be wrapping
    it into an `std::string`, which has `begin()` and `end()` functions:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 将其放入基于范围的`for`循环的唯一方法似乎是将其包装成一个`std::string`，它有`begin()`和`end()`函数：
- en: '[PRE52]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: However, the constructor of `std::string` will iterate over the whole string
    before our `for` loop can iterate over it. Since C++17, we also have `std::string_view`,
    but its constructor will also iterate through the string once. This is not worth
    the real hassle for *short* strings, but this is also only an example for a problem
    *class,* which can be worth the hassle in *other situations*. The `std::istream_iterator`
    also has to deal with this when it captures input from `std::cin`, as its end
    iterator cannot realistically point to the end of the user input while the user
    is *still typing* keys.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`std::string`的构造函数将在我们的`for`循环可以迭代它之前迭代整个字符串。自C++17以来，我们也有`std::string_view`，但它的构造函数也会遍历字符串一次。对于*短*字符串来说，这不值得真正的麻烦，但这也只是一个在*其他情况*中可能值得麻烦的问题*类*的例子。当`std::istream_iterator`从`std::cin`中捕获输入时，它也必须处理这个问题，因为它的结束迭代器在用户*仍在输入*键时实际上不能指向用户输入的结尾。
- en: C++17 comes with the great news that it does not constrain begin and end iterators
    to be of the same type. This section demonstrates how to put this *little rule
    change* to *great use*.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: C++17带来了一个伟大的消息，即它不限制开始和结束迭代器必须是相同类型。本节演示了如何将这个*小规则变更*发挥到*极大作用*。
- en: How to do it...
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this section, we will build an iterator together with a range class, which
    enables us to iterate over a string with unknown length, without finding the *end*
    position *in advance*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将一起构建一个迭代器和一个范围类，它使我们能够在不提前找到*结束*位置的情况下迭代一个未知长度的字符串。
- en: 'First, as always, we need to include headers:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，像往常一样，我们需要包含头文件：
- en: '[PRE53]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The iterator sentinel is a very central element of this section. Surprisingly,
    its class definition can stay completely empty:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代器标记是本节的一个非常核心的元素。令人惊讶的是，它的类定义可以完全为空：
- en: '[PRE54]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now we implement the iterator. It will contain a string pointer, which is the
    *container* we iterate over:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们实现迭代器。它将包含一个字符串指针，这是我们要迭代的*容器*：
- en: '[PRE55]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The constructor just initializes the internal string pointer to whatever string
    the user provides. Let''s make the constructor explicit in order to prevent accidental
    implicit conversions from strings to string iterators:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数只是将内部字符串指针初始化为用户提供的任何字符串。让我们将构造函数声明为显式的，以防止从字符串到字符串迭代器的意外隐式转换：
- en: '[PRE56]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'When dereferencing the iterator at some point, it will just return the character
    value at this position:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在某个位置对迭代器进行解引用时，它只会返回该位置的字符值：
- en: '[PRE57]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Incrementing the iterator just increments the position in the string:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递增迭代器只是递增字符串中的位置：
- en: '[PRE58]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This is the interesting part. We implement the `!=` operator for comparison,
    as it is used by STL algorithms and the range-based `for` loop. However, this
    time, we do not implement it for the comparison of iterators with other *iterators*,
    but for comparing iterators with *sentinels*. When we compare an iterator with
    another iterator we can only check if their internal string pointers both point
    to the same address, which is somewhat limiting. By comparing against an empty
    sentinel object, we can perform a completely different semantic–we check if the
    character our iterator points to is a terminating `''` character because this
    represents the *end* of the string!
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是有趣的部分。我们为比较实现了`!=`运算符，因为它被STL算法和基于范围的`for`循环使用。然而，这一次，我们不是为迭代器与其他*迭代器*的比较实现它，而是为迭代器与*哨兵*的比较实现它。当我们将一个迭代器与另一个迭代器进行比较时，我们只能检查它们的内部字符串指针是否都指向相同的地址，这有些限制。通过与空的哨兵对象进行比较，我们可以执行完全不同的语义——我们检查迭代器指向的字符是否是终止`''`字符，因为这代表了字符串的*结束*！
- en: '[PRE59]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In order to use this in a range-based `for` loop, we need a range class around
    it, which emits the begin and end iterators:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在基于范围的`for`循环中使用它，我们需要一个围绕它的范围类，它会发出开始和结束的迭代器：
- en: '[PRE60]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The only thing the user needs to provide during instantiation is the string
    that will be iterated over:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户在实例化期间唯一需要提供的是要迭代的字符串：
- en: '[PRE61]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We return a normal `cstring_iterator` from the `begin()` function, which points
    to the beginning of the string. From the `end()` function, we just return the
    *sentinel type*. Note that without the sentinel type, we would also return an
    iterator, but from where should we know the end of the string if we didn't search
    for it in advance?
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`begin()`函数返回一个普通的`cstring_iterator`，它指向字符串的开头。从`end()`函数返回的只是*哨兵类型*。请注意，如果没有哨兵类型，我们也会返回一个迭代器，但是我们怎么知道字符串的末尾呢，如果我们没有提前搜索呢？
- en: '[PRE62]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'That''s it. We can immediately use it. Strings that come from the user are
    one example of an input we cannot know the length of in advance. In order to force
    the user to give some input, we will abort the program if the user did not provide
    at least one parameter when launching the program in the shell:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就是这样。我们可以立即使用它。来自用户的字符串是我们无法提前知道长度的输入的一个例子。为了强制用户在启动程序时至少提供一个参数，如果用户没有在shell中启动程序时提供至少一个参数，我们将中止程序：
- en: '[PRE63]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'If the program is still being executed up to this point, then we know that
    `argv[1]` contains some user string:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果程序到这一点仍在执行，那么我们知道`argv[1]`包含一些用户字符串：
- en: '[PRE64]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Compiling and running the program yields the following output:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序会产生以下输出：
- en: '[PRE65]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: That the loop prints what we just entered is not a surprise, as this is just
    quite a micro-example for the implementation of a sentinel-based iterator range.
    This iteration termination method will help you in implementing your own iterators
    wherever you run into a situation where the *comparison with an end position*
    approach is not helpful.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 循环打印我们刚刚输入的内容并不奇怪，因为这只是一个关于基于哨兵的迭代器范围实现的微型示例。这种迭代终止方法将帮助您在遇到*与结束位置比较*方法无法帮助的情况下实现自己的迭代器时。
- en: Automatically checking iterator code with checked iterators
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用检查迭代器自动检查迭代器代码
- en: No matter how useful iterators are, and what generic interface they represent,
    iterators can easily be *misused*, just as pointers. When dealing with pointers,
    code must be written in a way that it *never* dereferences them when they point
    to invalid memory locations. Same applies to iterators, but there are *a lot of
    rules* that state when an iterator is valid and when it is invalidated. Those
    can easily be learned by studying the STL documentation a bit, but it will still
    *always* be possible to write buggy code.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 无论迭代器有多有用，以及它们代表的通用接口是什么，迭代器都很容易被*误用*，就像指针一样。在处理指针时，代码必须以一种方式编写，即当指向无效内存位置时*永远*不会取消引用它们。迭代器也是一样，但是有*很多规则*规定了迭代器何时有效以及何时失效。通过稍微研究STL文档，这些规则可以很容易地学习到，但仍然有可能编写错误的代码。
- en: In the best case, such buggy code blows up in front of the *developer* while
    it is being *tested*, and *not* on the client's machine. However, in many cases,
    the code just silently seems to work, although it dereferences dangling pointers,
    iterators, and so on. In such cases, we want to be *eagerly alarmed* if we produce
    code showing undefined behavior.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在最好的情况下，这种错误的代码会在*测试*时在*开发人员*面前爆炸，而不是在客户的机器上。然而，在许多情况下，代码似乎只是默默地工作，尽管它会取消引用悬空指针、迭代器等。在这种情况下，如果我们生成显示未定义行为的代码，我们希望能够*及早警告*。
- en: Fortunately, there's help! The GNU STL implementation has a *debug mode*, and
    the GNU C++ compiler as well as the LLVM clang C++ compiler both support *additional
    libraries* that can be used to produce *extra-sensitive* and *verbose* binaries
    for us, which immediately blow up on a large variety of bugs. This is *easy to
    use* and *super useful*, as we will demonstrate in this section. The Microsoft
    Visual C++ standard library also provides a possibility to activate additional
    checks.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有帮助！GNU STL实现有一个*调试模式*，GNU C++编译器以及LLVM clang C++编译器都支持用于为我们生成*额外敏感*和*冗长*的二进制文件的*额外库*，这些二进制文件可以立即在各种各样的错误上爆炸。这是*易于使用*和*非常有用*的，我们将在本节中进行演示。Microsoft
    Visual C++标准库也提供了激活额外检查的可能性。
- en: How to do it...
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we''ll write a program that deliberately accesses an invalidated
    iterator:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个故意访问无效迭代器的程序：
- en: First, we include headers.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们包括头文件。
- en: '[PRE66]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, let''s instantiate a vector of integers and get an iterator to the first
    item, the value `1`. We apply `shrink_to_fit()` on the vector in order to ensure
    that its capacity is *really* `3`, as its implementation *might* allocate more
    memory than necessary as a little reserve to make future item insertions faster:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们实例化一个整数向量，并获得指向第一个项目的迭代器，值为`1`。我们对向量应用`shrink_to_fit()`，以确保其容量*确实*为`3`，因为它的实现*可能*分配了比必要更多的内存作为未来项目插入的小保留：
- en: '[PRE67]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then we print the dereferenced iterator, which is completely fine:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们打印取消引用的迭代器，这是完全正常的：
- en: '[PRE68]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Next, let''s append a new number to the vector. As the vector is not large
    enough to take another number, it will automatically increase its size. It does
    this by allocating a new and larger chunk of memory, moving all the existing items
    to that new chunk and then deleting the *old* memory chunk:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们向向量追加一个新的数字。由于向量的大小不足以容纳另一个数字，它将自动增加其大小。它通过分配一个新的更大的内存块，将所有现有的项目移动到新的内存块，然后删除*旧*内存来实现这一点。
- en: '[PRE69]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, let''s print `1` from the vector through this iterator again. This is
    bad. Why? Well, when the vector moved all its values to the new chunk of memory
    and threw away the old chunk, it did not tell the iterator about this change.
    This means that the iterator is still pointing to the old location, and we cannot
    know what really happened to it since then:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们再次通过这个迭代器从向量中打印`1`。这很糟糕。为什么？嗯，当向量将所有的值移动到新的内存块并丢弃旧的内存块时，它没有告诉迭代器这个变化。这意味着迭代器仍然指向旧的位置，我们无法知道自那时起它到底发生了什么：
- en: '[PRE70]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Compiling and running this program leads to a flawless execution. The app doesn't
    crash, but what it prints when dereferencing the invalidated pointer is pretty
    much random. Leaving it like this is pretty dangerous, but at this point, no one
    tells us about that bug if we don't see it ourselves:![](img/a81a4f4e-651a-463e-9a47-9f537f7ef4a6.png)
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行这个程序会导致无缺陷的执行。应用程序不会崩溃，但当取消引用无效的指针时打印的内容几乎是随机的。把它留在这种状态下是非常危险的，但在这一点上，如果我们自己没有看到这个bug，就没有人告诉我们！[](img/a81a4f4e-651a-463e-9a47-9f537f7ef4a6.png)
- en: Debug flags come to the rescue! The *GNU* STL implementation supports a preprocessor
    macro called `_GLIBCXX_DEBUG`, which activates a lot of sanity checking code in
    the STL. This makes the program slower, but it *finds bugs*. We can activate it
    by adding a `-D_GLIBCXX_DEBUG` flag to our compiler command line, or define it
    in the head of the code file before the `include` lines. As you can see, it kills
    the app in the mactivate different sanitizers. Let's compile the code with clan
    useful (the activation flag for checked iterators with the Microsoft Visual C++
    compiler is `/D_ITERATOR_DEBUG_LEVEL=1`):![](img/abbbeeff-f181-453d-b88f-a5d9477b5b2c.png)
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调试标志来拯救！*GNU* STL实现支持一个名为`_GLIBCXX_DEBUG`的预处理宏，它在STL中激活了大量的健全性检查代码。这会使程序变慢，但它*找到了bug*。我们可以通过在编译器命令行中添加`-D_GLIBCXX_DEBUG`标志，或者在`include`行之前的代码文件头部定义它来激活它。正如你所看到的，它会在激活不同的sanitizers时杀死应用程序。让我们用clang有用（用于Microsoft
    Visual C++编译器的已检查迭代器的激活标志是`/D_ITERATOR_DEBUG_LEVEL=1`）编译代码！[](img/abbbeeff-f181-453d-b88f-a5d9477b5b2c.png)
- en: The LLVM/clang implementation of the STL also has debug flags, but they serve
    the purpose of debugging *the STL* itself, not user code. For user code, you can
    activate different sanitizers. Let's compile the code with clang using the `-fsanitize=address
    -fsanitize=undefined` flags and see what happens:![](img/907bccd5-a08c-449e-b970-98f763f65587.png)
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LLVM/clang实现的STL也有调试标志，但它们用于调试*STL*本身，而不是用户代码。对于用户代码，你可以激活不同的sanitizers。让我们使用clang编译代码，使用`-fsanitize=address
    -fsanitize=undefined`标志，看看会发生什么！[](img/907bccd5-a08c-449e-b970-98f763f65587.png)
- en: '*Wow*, this is a very precise description of what went wrong. The screenshot
    would have spanned *multiple pages* of this book if it had not been truncated.
    Note that this is not a clang-only feature, as it also works with GCC.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这是一个非常精确的描述出了什么问题。如果没有被截断，这个屏幕截图可能会跨越这本书的*多个页面*。请注意，这不是clang的专属功能，它也适用于GCC。
- en: If you get runtime errors because some library is missing, then your compiler
    did not automatically ship with **libasan** and **libubsan**. Try to install them
    via your package manager or something similar.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某个库丢失而出现运行时错误，那么你的编译器没有自动提供**libasan**和**libubsan**。尝试通过软件包管理器或类似的方式安装它们。
- en: How it works...
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As we have seen, we did not need to *change* anything in the code in order to
    get this kind of *tripwire* feature for buggy code. It basically came for *free*,
    just by appending some compiler flags to the command line when compiling the program.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们不需要改变代码就能获得这种对于有bug的代码的*触发器*功能。它基本上是*免费*的，只需在编译程序时在命令行中添加一些编译器标志即可。
- en: This feature is implemented by *sanitizers*. A sanitizer usually consists of
    an additional compiler module and a runtime library. When sanitizers are activated,
    the compiler will add *additional* *information* and *code* to the binary, which
    results from our program. At runtime, the sanitizer libraries that are then linked
    into the program binary can, for example, replace the `malloc` and `free` functions
    in order to *analyze* how the program deals with the memory it acquires.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能是由*sanitizers*实现的。通常，sanitizer由一个额外的编译器模块和一个运行时库组成。当sanitizers被激活时，编译器会向二进制文件中添加*额外的*
    *信息*和*代码*，这些信息是来自我们的程序。在运行时，链接到程序二进制文件中的sanitizer库可以，例如，替换`malloc`和`free`函数，以*分析*程序如何处理它获取的内存。
- en: 'Sanitizers can detect different kinds of bugs. Just to list a few valuable
    examples:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Sanitizers可以检测不同类型的bug。举几个有价值的例子：
- en: '**Out-of-bounds**: This triggers whenever we access an array, vector, or anything
    similar outside its legitimate memory range.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**越界**：每当我们访问数组、向量或类似的东西超出其合法内存范围时，就会触发这个功能。'
- en: '**Use-after-free**: This triggers if we reference heap memory after it was
    already freed (which we did in this section).'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**释放后使用**：如果我们在释放堆内存后引用它，sanitizers就会触发这个功能（我们在本节中就是这样做的）。'
- en: '**Integer overflow**: This triggers if an integer variable overflows by calculating
    with values that do not fit into the variable. For signed integers, the arithmetic
    wraparound is undefined behavior.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整数溢出**：如果整数变量通过计算与不适合该变量的值而溢出，就会触发这个功能。对于有符号整数，算术环绕是未定义行为。'
- en: '**Pointer alignment**: Some architectures cannot access memory if it has a
    weird alignment in memory.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指针对齐**：一些架构如果在内存中有奇怪的对齐方式就无法访问内存。'
- en: There are many more such bugs that sanitizers can detect.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多这样的bug可以被sanitizers检测到。
- en: It is *not feasible* to *always* activate all available sanitizers because they
    make the program *slower*. However, it is good style to always activate sanitizers
    in your *unit tests* and *integration tests*.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '*不可行*总是激活所有可用的消毒剂，因为它们会使程序变得*更慢*。然而，在你的*单元测试*和*集成测试*中总是激活消毒剂是一个很好的风格。'
- en: There's more...
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are a lot of different sanitizers for different bug categories, and they
    are all still under development. We can and should inform ourselves on the internet
    about how we can improve our test binaries. The GCC and LLVM project homepages
    list their sanitizing capabilities in their online documentation pages:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多不同的消毒剂用于不同的bug类别，它们仍在不断发展。我们可以和应该在互联网上了解如何改进我们的测试二进制文件。GCC和LLVM项目主页在它们的在线文档页面中列出了它们的消毒能力：
- en: '[https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html](https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html)'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html](https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html)'
- en: '[http://clang.llvm.org/docs/index.html](http://clang.llvm.org/docs/index.html)
    (look for *sanitizers* in the table of contents)'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://clang.llvm.org/docs/index.html](http://clang.llvm.org/docs/index.html)（在目录中查找*sanitizers*）'
- en: Thorough testing with sanitizers is something that *every* programmer should
    be aware of and should *always* be doing. Unfortunately, this is not the case
    in alarmingly many companies, although buggy code is the most important entry
    point for all the *malware* and *computer viruses* out there.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 彻底测试消毒剂是*每个*程序员都应该意识到并且*总是*应该做的事情。不幸的是，在许多公司中这并不是这样，尽管有bug的代码是所有*恶意软件*和*计算机病毒*的最重要入口点。
- en: When you get a new job as a software developer, check if your team really uses
    all the sanitizing possibilities there are. If not, you have the unique chance
    to fix important and sneaky bugs on your first day at work!
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当你作为软件开发人员得到一份新工作时，检查你的团队是否真的使用了所有可能的消毒方法。如果没有，你有机会在工作的第一天修复重要且隐蔽的错误！
- en: Building your own zip iterator adapter
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建你自己的拉链迭代器适配器
- en: Different programming languages lead to different programming styles. This is,
    because there are different ways to express things, and they are differing in
    their elegance for each use case. That is no surprise because every language was
    designed with specific objectives.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的编程语言导致不同的编程风格。这是因为表达事物的方式不同，它们在每种用例的优雅程度上也不同。这并不奇怪，因为每种语言都是根据特定的目标设计的。
- en: A very special kind of programming style is *purely* *functional programming*.
    It is magically different from the *imperative* programming which C or C++ programmers
    are used to. While this style is very different, it enables extremely elegant
    code in many situations.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 一种非常特殊的编程风格是*纯* *函数式编程*。它与C或C++程序员所习惯的*命令式*编程有着神奇的不同。虽然这种风格非常不同，但它在许多情况下能够产生极其优雅的代码。
- en: 'One example of this elegance is the implementation of formulas, such as the
    mathematical dot product. Given two mathematical vectors, applying the dot product
    to them means pairwise multiplying of the numbers at the same positions in the
    vector and then summing up all of those multiplied values. The dot product of
    two vectors `(a, b, c) * (d, e, f)` is `(a * e + b * e + c * f)`. Of course, we
    can do that with C and C++, too. It could look like the following:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这种优雅的实现之一是公式的实现，比如数学点积。给定两个数学向量，对它们应用点积意味着对向量中相同位置的数字进行成对乘法，然后将所有这些乘积值相加。两个向量`(a,
    b, c) * (d, e, f)`的点积是`(a * e + b * e + c * f)`。当然，我们也可以用C和C++来做。它可能看起来像下面这样：
- en: '[PRE71]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: How does it look like in those languages that can be considered *more elegant*?
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 那些被认为*更加优雅*的语言是什么样子的？
- en: '*Haskell* is a purely functional language, and this is how you can calculate
    the dot product of two vectors with a magical one-liner:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '*Haskell* 是一种纯函数式语言，这是你可以用一个神奇的一行代码计算两个向量的点积的方法：'
- en: '![](img/8fe01ef4-1b08-4026-b098-566e94367867.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8fe01ef4-1b08-4026-b098-566e94367867.png)'
- en: '*Python* is not a purely functional language, but it supports similar patterns
    to some extent, as seen in the next example:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python* 不是一种纯函数式语言，但它在某种程度上支持类似的模式，就像在下一个例子中所看到的那样：'
- en: '![](img/ae8dfd8b-886e-4c0f-9226-80d8f1619286.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae8dfd8b-886e-4c0f-9226-80d8f1619286.png)'
- en: The STL provides a specific algorithm called `std::inner_product`, which solves
    this specific problem in one line, too. But the point is that in many other languages,
    such code can be written *on the fly* in only one line *without* specific library
    functions that support that exact purpose.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: STL提供了一个特定的算法叫做`std::inner_product`，它也可以用一行代码解决这个特定的问题。但关键是，在许多其他语言中，这样的代码可以*即时*用一行代码写出，*不需要*支持这个确切目的的特定库函数。
- en: 'Without delving into the explanations of such foreign syntax, an important
    commonality in both examples is the magical `zip` function. What does it do? It
    takes the two vectors `a` and `b` and transforms them to a *mixed* vector. Example:
    `[a1, a2, a3]` and `[b1, b2, b3]` result in `[ (a1, b1), (a2, b2), (a3, b3) ]`
    when they are zipped together. Have a close look at it; it''s really similar to
    how zip fasteners work!'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 不用深入解释这种外来语法，两个例子中的一个重要共同点是神奇的`zip`函数。它是做什么的？它接受两个向量`a`和`b`，并将它们转换为一个*混合*向量。例如：`[a1,
    a2, a3]`和`[b1, b2, b3]`在被合并在一起时会得到`[ (a1, b1), (a2, b2), (a3, b3) ]`。仔细看一下；它真的很像拉链拉链一样工作！
- en: The relevant point is that it is now possible to iterate over *one* combined
    range where pairwise multiplications can be done and then summed up to an accumulator
    variable. Exactly the same happens in the Haskell and Python examples, without
    adding any loop or index variable noise.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 相关的一点是现在可以在*一个*组合范围上进行迭代，可以进行成对的乘法，然后将它们相加到一个累加变量中。在Haskell和Python的例子中，没有添加任何循环或索引变量的噪音。
- en: It will not be possible to make the C++ code exactly as elegant and generic
    as in Haskell or Python, but this section explains how to implement similar magic
    using iterators, by implementing a *zip iterator*. The example problem of calculating
    the dot product of two vectors is solved more elegantly by specific libraries,
    which are beyond the scope of this book. However, this section tries to show how
    much iterator-based libraries can help in writing expressive code by providing
    extremely generic building blocks.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 不可能使C++代码与Haskell或Python一样优雅和通用，但本节解释了如何使用迭代器实现类似魔术，通过实现*zip迭代器*。通过特定库更优雅地解决两个向量的点积的示例问题，这超出了本书的范围。但是，本节试图展示迭代器库可以通过提供极其通用的构建块来帮助编写表达力强的代码。
- en: How to do it...
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we will recreate the *zip* function as known from Haskell
    or Python. It will be hardcoded to vectors of `double` variables in order to not
    distract from iterator mechanics:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重新创建来自Haskell或Python的*zip*函数。它将被硬编码为`double`变量的向量，以免分散迭代器机制的注意力。
- en: 'First, we need to include some headers:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要包含一些头文件：
- en: '[PRE72]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Next, we define the `zip_iterator` class. While iterating over a `zip_iterator`
    range, we will get a pair of values from the two containers at every iteration
    step. This means that we iterate over two containers at the same time:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义`zip_iterator`类。在遍历`zip_iterator`范围时，我们将在每次迭代步骤中从两个容器中获得一对值。这意味着我们同时遍历两个容器：
- en: '[PRE73]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The zip iterator needs to save two iterators, one for each container:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: zip迭代器需要保存两个迭代器，每个容器一个：
- en: '[PRE74]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The constructor simply saves the iterators from the two containers that we
    would like to iterate over:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数只是保存我们想要迭代的两个容器的迭代器：
- en: '[PRE75]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Incrementing the zip iterator means incrementing both the member iterators:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加zip迭代器意味着增加成员迭代器：
- en: '[PRE76]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Two zip iterators are unequal if both the member iterators are unequal to their
    counterparts in the other zip iterator. Usually, one would use logical or (`||`)
    instead of and (`&&`), but imagine that the ranges are not of equal length. In
    such a case, it would not be possible to match *both* the end iterators at the
    same time. This way, we can abort the loop when we reach the *first* end iterator
    of *either* range:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果两个zip迭代器的成员迭代器都与另一个zip迭代器中的对应迭代器不相等，则两个zip迭代器是不相等的。通常，人们会使用逻辑或(`||`)而不是和(`&&`)，但想象一下，范围的长度不相等。在这种情况下，将不可能同时匹配*两个*结束迭代器。这样，当我们到达*任一*范围的*第一个*结束迭代器时，我们可以中止循环：
- en: '[PRE77]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The equality comparison operator is just implemented using the other operator,
    but negating the result:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相等比较运算符只是使用其他运算符实现，但否定结果：
- en: '[PRE78]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Dereferencing the zip iterator gives access to the elements of both the containers
    at the same position:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解引用zip迭代器可以访问两个容器在相同位置的元素：
- en: '[PRE79]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This was the iterator code. We need to make the iterator compatible with STL
    algorithms, so we define the needed type trait boilerplate code for that. It basically
    says that this iterator is just a forward iterator, and it returns pairs of double
    values when dereferenced. Although we do not use `difference_type` in this recipe,
    different implementations of the STL might need it in order to compile:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是迭代器代码。我们需要使迭代器与STL算法兼容，因此我们为此定义了所需的类型特征样板代码。它基本上表示这个迭代器只是一个前向迭代器，在解引用时返回一对双值。虽然在这个示例中我们没有使用`difference_type`，但STL的不同实现可能需要它才能编译：
- en: '[PRE80]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The next step is to define a range class that returns us zip iterators from
    its `begin` and `end` functions:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是定义一个范围类，从其`begin`和`end`函数返回zip迭代器：
- en: '[PRE81]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'It needs to reference two existing containers in order to form zip iterators
    from them:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它需要引用两个现有容器，以便从中形成zip迭代器：
- en: '[PRE82]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The `begin` and `end` functions just feed pairs of begin and end pointers in
    order to construct zip iterator instances from that:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`begin`和`end`函数只是提供开始和结束指针对，以便从中构造zip迭代器实例：'
- en: '[PRE83]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Just as in the Haskell and Python examples, we define two vectors of `double`
    values. We also define that we use namespace `std` within the main function by
    default:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像Haskell和Python示例中一样，我们定义了两个`double`值的向量。我们还在主函数中默认使用`std`命名空间：
- en: '[PRE84]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The zipper object combines them to one vector-like range where we see pairs
    of `a` and `b` values:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: zipper对象将它们组合成一个类似向量的范围，我们可以看到`a`和`b`值的对：
- en: '[PRE85]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We will use `std::accumulate` in order to sum all the items of the range together.
    We can''t do it directly because that would mean that we sum up the instances
    of `std::pair<double, double>` for which the concept of sum is not defined. Therefore,
    we will define a helper lambda that takes a pair, multiplies its members, and
    adds it to an accumulator. The `std::accumulate` works well with lambdas with
    such a signature:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`std::accumulate`来将范围中的所有项相加。我们不能直接这样做，因为这意味着我们要对`std::pair<double, double>`的实例求和，而这种情况下求和的概念是不被定义的。因此，我们将定义一个辅助lambda，它接受一对值，将其成员相乘，并将其添加到累加器中。`std::accumulate`可以很好地处理具有这种签名的lambda：
- en: '[PRE86]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now, we feed it to `std::accumulate`, together with the begin and end iterator
    pair of the zipped ranges and a start value of `0.0` for the accumulator variable,
    which, in the end, contains the sum of the products:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将它传递给`std::accumulate`，以及zipped范围的开始和结束迭代器对，以及累加器变量的起始值`0.0`，最终包含产品的总和：
- en: '[PRE87]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Let''s print the dot product result:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打印点积结果：
- en: '[PRE88]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Compiling and running the program yields the correct result:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行程序会产生正确的结果：
- en: '[PRE89]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: There's more...
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: OK, that was a *lot* of work for a little bit of syntax sugar, and it's still
    not as elegant as Haskell code can be without any effort. A big flaw is the hardcoded
    nature of our little zip iterator--it only works on the `std::vector` ranges of
    double variables. With a bit of template code and some type traits, the zipper
    can be made more generic. This way, it could combine lists and vectors, or deques
    and maps, even if these are specialized on completely different container item
    types.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这需要*很多*工作来获得一点点语法糖，而且仍然不像Haskell代码那样优雅，而且不费吹灰之力。一个很大的缺陷是我们的小zip迭代器的硬编码特性--它只适用于`std::vector`范围内的双变量。通过一些模板代码和一些类型特征，可以使拉链器更通用。这样，它可以组合列表和向量，或者双端队列和映射，即使它们是专门针对完全不同的容器项类型的。
- en: The amount of work and thought needed in order to really and correctly make
    such classes generic is not to be underestimated. Luckily, such libraries do already
    exist. One popular non-STL library is the *Boost* `zip_iterator`. It is very generic
    and easy to use.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 为了真正正确地使这样的类通用化，需要付出大量的工作和思考。幸运的是，这样的库已经存在。一个流行的非STL库是*Boost* `zip_iterator`。它非常通用且易于使用。
- en: 'By the way, if you came here to see the most elegant way to do a *dot product*
    in C++, and don''t really care about the concept of zip-iterators, you should
    have a look at `std::valarray`. See for yourself:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，如果你来这里是为了看到在C++中执行*点积*最优雅的方法，并且并不真的关心zip-iterators的概念，你应该看看`std::valarray`。自己看看：
- en: '[PRE90]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Ranges library
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ranges库
- en: 'There is a very, very interesting C++ library, which supports zippers and all
    other kinds of magic iterator adapters, filters, and so on: the *ranges* library.
    It is inspired by the Boost ranges library, and for some time, it looked like
    it would find its way into C++17, but unfortunately, we will have to wait for
    the *next* standard. The reason why this is so unfortunate is that it will *vigorously*
    improve the possibilities of writing *expressive* and *fast* code in C++ by composing
    *complex* functionality from *generic* and *simple* blocks of code.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个非常非常有趣的C++库，支持拉链器和所有其他类型的魔术迭代器适配器、过滤器等等：*ranges*库。它受到Boost ranges库的启发，有一段时间看起来它会进入C++17，但不幸的是，我们将不得不等待*下一个*标准。这样做的不幸之处在于，它将*大大*改进用C++编写*富有表现力*和*快速*代码的可能性，通过从*通用*和*简单*的代码块组合*复杂*功能。
- en: 'There are some very simple examples in its documentation:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 它的文档中有一些非常简单的例子：
- en: 'Calculating the sum of the squares of all numbers from `1` to `10`:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算从`1`到`10`的所有数字的平方和：
- en: '[PRE91]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Filtering out all uneven numbers from a numeric vector, and transforming the
    rest to strings:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数字向量中过滤出所有奇数，并将其余部分转换为字符串：
- en: '[PRE92]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: If you are interested and can't wait for the next C++ standard, have a look
    at the ranges documentation at [https://ericniebler.github.io/range-v3/](https://ericniebler.github.io/range-v3/).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣并且等不及下一个C++标准，可以查看[https://ericniebler.github.io/range-v3/](https://ericniebler.github.io/range-v3/)上的ranges文档。
