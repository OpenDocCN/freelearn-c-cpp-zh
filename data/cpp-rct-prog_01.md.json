["```cpp\n#include <X11/Xlib.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(void)\n{\n    Display *display;\n    Window window;\n    XEvent event;\n    char *msg = \"Hello, World!\";\n    int s;\n```", "```cpp\n    /* open connection with the server */\n    display = XOpenDisplay(NULL);\n    if (display == NULL){\n        fprintf(stderr, \"Cannot open display\\n\");\n        exit(1);\n    }\n    s = DefaultScreen(display);\n    /* create window */\n    window = XCreateSimpleWindow(display,\n             RootWindow(display, s), 10, 10, 200, 200, 1,\n             BlackPixel(display, s), WhitePixel(display, s));\n\n    /* select kind of events we are interested in */\n    XSelectInput(display, window, ExposureMask | KeyPressMask);\n\n    /* map (show) the window */\n    XMapWindow(display, window);\n```", "```cpp\n    /* event loop */\n    for (;;)\n    {\n        XNextEvent(display, &event);\n\n        /* draw or redraw the window */\n        if (event.type == Expose)\n        {\n            XFillRectangle(display, window,\n                DefaultGC(display, s), 20, 20, 10, 10);\n            XDrawString(display, window,\n                DefaultGC(display, s), 50, 50, msg, strlen(msg));\n        }\n        /* exit on key press */\n        if (event.type == KeyPress)\n        break;\n    }\n```", "```cpp\n    /* close connection to server */\n    XCloseDisplay(display);\n\n    return 0;\n    }\n```", "```cpp\n#include <windows.h>\n//----- Prtotype for the Event Handler Function\nLRESULT CALLBACK WndProc(HWND hWnd, UINT message,\n                         WPARAM wParam, LPARAM lParam);\n//--------------- Entry point for a Idiomatic Windows API function\nint WINAPI WinMain(HINSTANCE hInstance,\n              HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)\n{\n\nMSG msg = {0};\nWNDCLASS wc = {0};\nwc.lpfnWndProc = WndProc;\nwc.hInstance = hInstance;\nwc.hbrBackground = (HBRUSH)(COLOR_BACKGROUND);\nwc.lpszClassName = \"minwindowsapp\";\nif( !RegisterClass(&wc) )\n  return 1;\n```", "```cpp\nif( !CreateWindow(wc.lpszClassName,\n                  \"Minimal Windows Application\",\n                  WS_OVERLAPPEDWINDOW|WS_VISIBLE,\n                  0,0,640,480,0,0,hInstance,NULL))\n    return 2;\n```", "```cpp\n    while( GetMessage( &msg, NULL, 0, 0 ) > 0 )\n        DispatchMessage( &msg );\n    return 0;\n}\n```", "```cpp\nLRESULT CALLBACK WndProc(HWND hWnd, UINT message,\n                         WPARAM wParam, LPARAM lParam) {\nswitch(message){\n  case WM_CLOSE:\n    PostQuitMessage(0);break;\n  default:\n    return DefWindowProc(hWnd, message, wParam, lParam);\n}\nreturn 0;\n}\n```", "```cpp\n#include <qapplication.h>\n#include <qdialog.h>\n#include <qmessagebox.h>\n#include <qobject.h>\n#include <qpushbutton.h>\n\nclass MyApp : public QDialog {\n  Q_OBJECT\npublic:\n    MyApp(QObject* /*parent*/ = 0):\n    button(this)\n    {\n      button.setText(\"Hello world!\"); button.resize(100, 30);\n\n      // When the button is clicked, run button_clicked\n      connect(&button,\n              &QPushButton::clicked, this, &MyApp::button_clicked);\n    }\n```", "```cpp\npublic slots:\n    void button_clicked() {\n      QMessageBox box;\n      box.setWindowTitle(\"Howdy\");\n      box.setText(\"You clicked the button\");\n      box.show();\n      box.exec();\n    }\n\nprotected:\n  QPushButton button;\n};\n```", "```cpp\nint main(int argc, char** argv) {\n  QApplication app(argc, argv);\n  MyApp myapp;\n  myapp.show();\n  return app.exec();\n}\n```", "```cpp\nBEGIN_MESSAGE_MAP(CClockFrame,CFrameWnd)\n    ON_WM_CREATE()\n    ON_WM_PAINT()\n    ON_WM_TIMER()\nEND_MESSAGE_MAP()\n```", "```cpp\n#pragma once \n//Common2.h \n\nstruct CustomException /*:*public std::exception */ {\n   const char * what() const throw () { \n         return \"C++ Exception\"; \n   } \n}; \n```", "```cpp\ntemplate<class T> class IEnumerator {\npublic:\n      virtual bool HasMore() = 0;\n      virtual T next() = 0;\n      //--------- Omitted Virtual destructor for brevity\n};\ntemplate <class T> class IEnumerable{\npublic:\n      virtual IEnumerator<T> *GetEnumerator() = 0;\n      //---------- Omitted Virtual destructor for brevity\n};\n```", "```cpp\ntemplate<class T> class IObserver\n{\npublic:\n      virtual void OnCompleted() = 0;\n      virtual void OnError(CustomException *exception) = 0;\n      virtual void OnNext(T value) = 0;\n};\ntemplate<typename T>\nclass IObservable\n{\npublic:\n      virtual bool Subscribe(IObserver<T>& observer) = 0;\n};\n```", "```cpp\n#include <iostream>\n#include <vector>\n#include <iterator>\n#include <memory>\n#include \"../Common2.h\"\nusing namespace std;\n\nclass ConcreteEnumberable : public IEnumerable<int>\n{\n      int *numberlist,_count;\npublic:\n      ConcreteEnumberable(int numbers[], int count):\n            numberlist(numbers),_count(count){}\n      ~ConcreteEnumberable() {}\n\n      class Enumerator : public IEnumerator<int>\n      {\n      int *inumbers, icount, index;\n      public:\n      Enumerator(int *numbers,\n            int count):inumbers(numbers),icount(count),index(0) {}\n      bool HasMore() { return index < icount; }\n      //---------- ideally speaking, the next function should throw\n      //---------- an exception...instead it just returns -1 when the \n      //---------- bound has reached\n      int next() { return (index < icount) ?\n                   inumbers[index++] : -1; }\n      ~Enumerator() {}\n      };\n      IEnumerator<int> *GetEnumerator()\n            { return new Enumerator(numberlist, _count); }\n};\n```", "```cpp\nint main()\n{\n      int x[] = { 1,2,3,4,5 };\n      //-------- Has used Raw pointers on purpose here as we have\n      //------- not introduced unique_ptr,shared_ptr,weak_ptr yet\n      //-------- using auto_ptr will be confusting...otherwise\n      //-------- need to use boost library here... ( an overkill)\n      ConcreteEnumberable *t = new ConcreteEnumberable(x, 5);\n      IEnumerator<int> * numbers = t->GetEnumerator();\n      while (numbers->HasMore())\n            cout << numbers->next() << endl;\n      delete numbers;delete t;\n      return 0;\n}\n```", "```cpp\n#include \"stdafx.h\"\n#include <iostream>\n#include <vector>\n#include <iterator>\n#include <memory>\n#include \"../Common2.h\"\nusing namespace std;\n\nclass EvenNumberObservable : IObservable<int>{\n      int *_numbers,_count;\npublic:\n      EvenNumberObservable(int numbers[],\n            int count):_numbers(numbers),_count(count){}\n      bool Subscribe(IObserver<int>& observer){\n            for (int i = 0; i < _count; ++i)\n                  if (_numbers[i] % 2 == 0)\n                        observer.OnNext(_numbers[i]);\n            observer.OnCompleted();\n            return true;\n      }\n};\n```", "```cpp\nclass SimpleObserver : public IObserver<int>{\npublic:\n      void OnNext(int value) { cout << value << endl; }\n      void OnCompleted() { cout << _T(\"hello completed\") << endl; }\n      void OnError( CustomException * ex) {}\n};\n```", "```cpp\nint main()\n{\n      int x[] = { 1,2,3,4,5 };\n      EvenNumberObservable *t = new EvenNumberObservable(x, 5);\n      IObserver<int>> *xy = new SimpleObserver();\n      t->Subscribe(*xy);\n      delete xy; delete t;\n      return 0;\n}\n```", "```cpp\n#include \"stdafx.h\"\n#include <afxwin.h>\n#include <afxext.h>\n#include <math.h>\n#include <vector>\n#include \"../Common2.h\"\n\nusing namespace std;\nclass CMouseFrame :public CFrameWnd,IObservable<CPoint>\n{\nprivate:\n      RECT _rect;\n      POINT _curr_pos;\n      vector<IObserver<CPoint> *> _event_src;\npublic:\n      CMouseFrame(){\n            HBRUSH brush =\n                  (HBRUSH)::CreateSolidBrush(RGB(175, 238, 238));\n            CString mywindow = AfxRegisterWndClass(\n                  CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS,\n                  0, brush, 0);\n            Create(mywindow, _T(\"MFC Clock By Praseed Pai\"));\n      }\n```", "```cpp\n      virtual bool Subscribe(IObserver<CPoint>& observer) {\n            _event_src.push_back(&observer);\n            return true;\n      }\n```", "```cpp\n      bool FireEvent(const CPoint& pt) {\n            vector<IObserver<CPoint> *>::iterator it =\n                  _event_src.begin();\n            while (it != _event_src.end()){\n                  IObserver<CPoint> *observer = *it;\n                  observer->OnNext(pt);\n                  //---------- In a Real world Rx programs there is a \n                  //--------- sequence stipulated to call methods...\n                  //--------- OnCompleted will be called only when \n                  //--------- all the data is processed...this code\n                  //--------- is written to demonstrate the call schema\n                  observer->OnCompleted();\n                  it++;\n            }\n            return true;\n      }\n```", "```cpp\n      int OnCreate(LPCREATESTRUCT l){\n            return CFrameWnd::OnCreate(l);\n      }\n      void SetCurrentPoint(CPoint pt) {\n            this->_curr_pos = pt;\n            Invalidate(0);\n      }\n```", "```cpp\n      void OnPaint()\n      {\n            CPaintDC d(this);\n            CBrush b(RGB(100, 149, 237));\n            int x1 = -200, y1 = -220, x2 = 210, y2 = 200;\n            Transform(&x1, &y1); Transform(&x2, &y2);\n            CRect rect(x1, y1, x2, y2);\n            d.FillRect(&rect, &b);\n            CPen p2(PS_SOLID, 2, RGB(153, 0, 0));\n            d.SelectObject(&p2);\n\n            char *str = \"Hello Reactive C++\";\n            CFont f;\n            f.CreatePointFont(240, _T(\"Times New Roman\"));\n            d.SelectObject(&f);\n            d.SetTextColor(RGB(204, 0, 0));\n            d.SetBkMode(TRANSPARENT);\n            CRgn crgn;\n            crgn.CreateRectRgn(rect.left,rect.top,\n            rect.right ,rect.bottom);\n            d.SelectClipRgn(&crgn);\n            d.TextOut(_curr_pos.x, _curr_pos.y,\n            CString(str), strlen(str));\n      }\n```", "```cpp\n      void Transform(int *px, int *py) {\n            ::GetClientRect(m_hWnd, &_rect);\n            int width = (_rect.right - _rect.left) / 2,\n            height = (_rect.bottom - _rect.top) / 2;\n           *px = *px + width; *py = height - *py;\n      }\n```", "```cpp\n      void OnMouseMove(UINT nFlags, CPoint point)\n      {\n            int x1 = -200,y1= -220, x2 = 210,y2 = 200;\n            Transform(&x1, &y1);Transform(&x2, &y2);\n            CRect rect(x1, y1, x2, y2);\n            POINT pts;\n            pts.x = point.x; pts.y = point.y;\n            rect.NormalizeRect();\n            //--- In a real program, the points will be aggregated\n            //---- into a list (stream)\n            if (rect.PtInRect(point)) {\n                  //--- Ideally speaking this notification has to go\n                  //--- through a non blocking call\n                  FireEvent(point);\n            }\n      }\n```", "```cpp\n      DECLARE_MESSAGE_MAP();\n};\n\nBEGIN_MESSAGE_MAP(CMouseFrame, CFrameWnd)\n      ON_WM_CREATE()\n      ON_WM_PAINT()\n      ON_WM_MOUSEMOVE()\nEND_MESSAGE_MAP()\nclass WindowHandler : public IObserver<CPoint>\n{\nprivate:\n      CMouseFrame *window;\npublic:\n      WindowHandler(CMouseFrame *win) : window(win) { }\n      virtual ~WindowHandler() { window = 0; }\n      virtual void OnCompleted() {}\n      virtual void OnError(CustomException *exception) {}\n      virtual void OnNext(CPoint value) {\n            if (window) window->SetCurrentPoint(value);\n      }\n};\n```", "```cpp\nclass CMouseApp :public CWinApp\n{\n      WindowHandler *reactive_handler;\npublic:\n      int InitInstance(){\n            CMouseFrame *p = new CMouseFrame();\n            p->ShowWindow(1);\n            reactive_handler = new WindowHandler(p);\n            //--- Wire the observer to the Event Source\n            //--- which implements IObservable<T>\n            p->Subscribe(*reactive_handler);\n            m_pMainWnd = p;\n            return 1;\n      }\n      virtual ~CMouseApp() {\n            if (reactive_handler) {\n                  delete reactive_handler;\n                  reactive_handler = 0;\n           }\n      }\n};\n\nCMouseApp a;\n```"]