- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Writing C++ HAL
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写C++ HAL
- en: A **Hardware Abstraction Layer** (**HAL**) is a core software component in embedded
    projects. It simplifies interactions with hardware peripherals by providing an
    easy-to-use interface that abstracts the hardware details. The HAL manages the
    reading and writing of memory-mapped peripheral registers, allowing you to use
    peripherals such as GPIOs, timers, and serial communication interfaces, without
    dealing directly with low-level hardware specifics. It often supports multiple
    devices within the same family.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**硬件抽象层**（**HAL**）是嵌入式项目中的核心软件组件。它通过提供一个易于使用的接口来简化与硬件外围设备的交互，该接口抽象了硬件细节。HAL管理内存映射外围寄存器的读写，允许您使用GPIO、定时器和串行通信接口等外围设备，而无需直接处理低级硬件的细节。它通常支持同一系列内的多个设备。'
- en: By using a HAL, firmware becomes more portable across different devices and
    similar families from the same vendor. It hides the register layouts of memory-mapped
    peripherals, making it easier to reuse drivers and business logic on various devices.
    The HAL handles platform-specific details, enabling developers to focus on the
    application rather than hardware nuances. It also manages differences among different
    series of **microcontrollers** (**MCUs**).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用HAL，固件可以在不同设备和同一供应商的类似系列设备之间变得更加便携。它隐藏了内存映射外围设备的寄存器布局，使得在各种设备上重用驱动程序和业务逻辑变得更加容易。HAL处理特定平台的细节，使开发者能够专注于应用程序而不是硬件的细微差别。它还管理不同系列**微控制器**（**MCU**）之间的差异。
- en: 'It’s recommended to use vendor-provided HALs, typically delivered as C libraries,
    because they are well-tested and regularly maintained. Still, in some cases, it
    may be needed to work directly with memory-mapped peripherals, thus, in this chapter,
    we will explore C++ techniques that can help you write safer and more expressive
    HALs. In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 建议使用供应商提供的HAL，通常以C库的形式提供，因为它们经过充分测试并定期维护。然而，在某些情况下，可能需要直接与内存映射外围设备工作，因此在本章中，我们将探讨C++技术，这些技术可以帮助您编写更安全、更易于表达的HAL。在本章中，我们将涵盖以下主题：
- en: Memory-mapped peripherals
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存映射外围设备
- en: Timers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时器
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The examples from this chapter are available on GitHub ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter12](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter12)).
    To get the most out of this chapter, run the examples in the Renode simulator.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例可在GitHub上找到（[https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter12](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter12)）。为了充分利用本章内容，请在Renode模拟器中运行示例。
- en: Memory-mapped peripherals
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存映射外围设备
- en: '**Memory-mapped peripherals** allow programs to control hardware devices by
    reading from and writing to specific memory addresses. Both peripheral registers
    and RAM are mapped to the same address space, making communication with hardware
    registers as simple as writing and reading to a pointer that points to those locations.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存映射外围设备**允许程序通过读取和写入特定内存地址来控制硬件设备。外围寄存器和RAM都映射到相同的地址空间，使得与硬件寄存器的通信变得如同写入和读取指向这些位置的指针一样简单。'
- en: In previous examples in this book, we used an ST-provided HAL written in C,
    which controls hardware peripherals through **Common Microcontroller Software
    Interface Standard** (**CMSIS**) headers.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书前面的示例中，我们使用了一个用C语言编写的ST提供的HAL，它通过**通用微控制器软件接口标准**（**CMSIS**）头文件来控制硬件外围设备。
- en: CMSIS is a vendor-independent HAL and software library collection for Arm Cortex-based
    microcontrollers. Developed by Arm, it standardizes hardware access and configuration,
    simplifying software development and improving code portability across different
    manufacturers. Each microcontroller vendor provides its own CMSIS implementation,
    adapting the core APIs and drivers to their specific devices. Next, we will explore
    CMSIS implementation of access to memory-mapped peripherals for the STM32F072
    microcontroller.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: CMSIS是一个针对基于Arm Cortex的微控制器的供应商独立HAL和软件库集合。由Arm开发，它标准化了硬件访问和配置，简化了软件开发，并提高了不同制造商之间的代码可移植性。每个微控制器供应商都提供自己的CMSIS实现，将核心API和驱动程序适配到其特定设备。接下来，我们将探讨STM32F072微控制器的内存映射外围设备的CMSIS实现。
- en: CMSIS memory-mapped peripherals
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CMSIS内存映射外围设备
- en: Access to registers in CMSIS is modeled through pointers to structs that describe
    register layout. CMSIS defines macros representing pointers to memory-mapped peripherals.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: CMSIS中的寄存器访问通过指向描述寄存器布局的结构体的指针进行建模。CMSIS定义了表示内存映射外围设备指针的宏。
- en: 'Structs, according to CMSIS naming conventions, are named using the peripheral
    name abbreviation and `_TypeDef` postfix. The **reset and clock control** (**RCC**)
    peripheral struct is named `RCC_TypeDef`. It is defined in example projects in
    the `platform/CMSIS/Device/ST/STM32F0xx/Include/stm32f072xb.h` file, as shown
    here:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 根据CMSIS命名约定，结构体使用外设名称缩写和`_TypeDef`后缀命名。**复位和时钟控制**（**RCC**）外设结构体命名为`RCC_TypeDef`。它在示例项目中定义在`platform/CMSIS/Device/ST/STM32F0xx/Include/stm32f072xb.h`文件中，如下所示：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the same header file, along with the `RCC_TypeDef` struct, the following
    macros are defined:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个头文件中，除了`RCC_TypeDef`结构体外，还定义了以下宏：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this code, we are setting up the HSION bit of the clock control register
    (`CR`) or the `RCC` peripheral, and we know we are doing that because of the comment
    in the code. Also, nothing is preventing us from setting `CR` to any random value.
    Here is an example of usage of the clock configuration register (`CFGR`) from
    the `RCC` peripheral:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们正在设置时钟控制寄存器（`CR`）或`RCC`外设的HSION位，我们知道我们在做这件事是因为代码中的注释。此外，没有任何东西阻止我们将`CR`设置为任何随机值。以下是`RCC`外设的时钟配置寄存器（`CFGR`）的用法示例：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code sets PLL division, various prescaler, and clock settings. It’s not
    quite obvious which settings are applied from the hex value `0x08FFB80CU`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码设置了PLL分频、各种预分频器和时钟设置。从十六进制值`0x08FFB80CU`中并不明显可以看出应用了哪些设置。
- en: 'Even though this approach is common, there are several issues with modeling
    access to peripherals using register structs and a pointer pointing to the peripheral’s
    base address:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种方法很常见，但使用寄存器结构体和指向外设基地址的指针来模拟对外设的访问有几个问题：
- en: The first is reduced readability. We can write `arbitrary uint32_t` values in
    hex format, making the code meaningless and requiring us to refer to reference
    manuals of microcontrollers.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个问题是可读性降低。我们可以以十六进制格式写入任意的`uint32_t`值，这使得代码变得毫无意义，并需要我们查阅微控制器的参考手册。
- en: As we can write any value we want to a register, we can easily write wrong or
    even random values.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们可以向寄存器写入任何我们想要的值，我们很容易写错甚至随机写入值。
- en: Individual registers of a peripheral in a struct must be ordered according to
    their memory layout. Members named `RESERVERDn` are used to add space into the
    structure for adjusting the addresses of the peripheral registers and to prevent
    padding.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在结构体中，外设的各个寄存器必须按照它们的内存布局顺序排列。使用名为`RESERVERDn`的成员用于在结构体中添加空间以调整外设寄存器的地址，并防止填充。
- en: CMSIS headers may contain macros defining bit masks for accessing individual
    settings in a register, which simplifies access to peripheral registers. Still,
    these macros are not making the code any safer, just easier to work with.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMSIS头文件可能包含宏定义，用于访问寄存器中单个设置的位掩码，这简化了对外设寄存器的访问。然而，这些宏并没有使代码更安全，只是更容易使用。
- en: Let’s see how we can utilize C++ to address these concerns, making the code
    safer and more readable.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何利用C++来解决这些问题，使代码更安全、更易读。
- en: Memory-mapped peripherals in C++
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++中的内存映射外设
- en: 'We will use the knowledge we gained in previous chapters to create an expressive
    and type-safe interface to access memory-mapped peripherals in C++. We will create
    an interface with the following qualities:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用在前几章中学到的知识，创建一个表达性强且类型安全的接口来访问C++中的内存映射外设。我们将创建一个具有以下特性的接口：
- en: Read and write access control to a hardware register
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对硬件寄存器的读写访问控制
- en: Type-safe write to a register
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对寄存器的类型安全写入
- en: Expressive and easy to use
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达性强且易于使用
- en: 'Let us start with a basic implementation of an interface representing a memory-mapped
    register that will match the CMSIS approach in functionality. The code is shown
    here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实现一个表示内存映射寄存器的接口的基本示例开始，这个接口的功能将与CMSIS方法相匹配。代码如下所示：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this code, the class template `reg` models a hardware register. It has the
    following template parameters:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，类模板`reg`模拟了一个硬件寄存器。它有以下模板参数：
- en: '`uintptr_t Address`: The memory address of the hardware register'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uintptr_t Address`：硬件寄存器的内存地址'
- en: '`typename Access`: The access rights for the register (defaults to `read_write_access`)'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`typename Access`：寄存器的访问权限（默认为`read_write_access`）'
- en: '`typename T`: The data type matching the size of the register (defaults to
    `std::uint32_t`)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`typename T`：与寄存器大小匹配的数据类型（默认为`std::uint32_t`）'
- en: 'The class template `reg` has two static methods: `read` and `write`. These
    are used to read from and write to a register, respectively. Both methods are
    enabled or disabled at compile time using SFINAE, which we covered in [*Chapter
    8*](Chapter_08.xhtml). We are using the following types of access control:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板 `reg` 有两个静态方法：`read` 和 `write`。这些方法分别用于从寄存器读取和写入。这两个方法都通过 SFINAE 在编译时启用或禁用，我们已经在
    [*第 8 章*](Chapter_08.xhtml) 中讨论过。我们使用的访问控制类型如下：
- en: '`struct read_access`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct read_access`'
- en: '`struct write_access`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct write_access`'
- en: '`struct read_write_access`: This inherits from both `read_access` and `write_access`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct read_write_access`: 这个结构体从 `read_access` 和 `write_access` 继承'
- en: To enable and disable `write` and `read` methods at compile time using SFINAE,
    we made both methods template functions. This allows us to use the class template
    `enable_if` at the return type of these methods to either enable or disable them,
    depending on the condition provided to it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在编译时使用 SFINAE 启用和禁用 `write` 和 `read` 方法，我们将这两个方法都设计为模板函数。这允许我们在这些方法的返回类型中使用类模板
    `enable_if` 来根据提供的条件启用或禁用它们。
- en: The template parameter for both `write` and `read` is `Access_`, which defaults
    to `Access`. It ensures that SFINAE works correctly by making the substitution
    dependent on a template parameter of the function itself.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`write` 和 `read` 的模板参数都是 `Access_`，默认为 `Access`。它通过使替换依赖于函数本身的模板参数来确保 SFINAE
    正确工作。'
- en: We are enabling the `read` method using `std::enable_if_t<std::is_base_of_v<read_access,
    Access_>, T>`. This means that if `std::is_base_of_v<read_access, Access_>` is
    true (i.e., if `Access_` is derived from or is the same as `read_access`), `std::enable_if_t`
    resolves to `T`, and the function is enabled. Otherwise, it results in a substitution
    failure, and the function is not included in the overload set. We are enabling
    the `write` method in a similar fashion, by checking whether `Access_` type is
    derived from or the same as `write_access`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `std::enable_if_t<std::is_base_of_v<read_access, Access_>, T>` 启用 `read`
    方法。这意味着如果 `std::is_base_of_v<read_access, Access_>` 为真（即，如果 `Access_` 是从 `read_access`
    继承或与 `read_access` 相同），则 `std::enable_if_t` 解析为 `T`，函数被启用。否则，它会导致替换失败，函数不会被包含在重载集中。我们以类似的方式启用
    `write` 方法，通过检查 `Access_` 类型是否从 `write_access` 继承或与之相同。
- en: We use `reinterpret_cast<volatile T*>` to convert the integer template parameter
    `Address` into a pointer to a volatile variable of type `T` (which defaults to
    `std::uint32_t`). The `volatile` keyword informs the compiler that the value at
    this memory location can change at any time outside the program’s control – by
    hardware. This prevents the compiler from applying certain optimizations that
    might omit necessary reads or writes to this address.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `reinterpret_cast<volatile T*>` 将整数模板参数 `Address` 转换为指向类型 `T`（默认为 `std::uint32_t`）的
    volatile 变量的指针。`volatile` 关键字通知编译器该内存位置的值可能在程序控制之外任何时候改变——由硬件引起。这防止编译器应用可能省略对该地址必要读取或写入的某些优化。
- en: Without `volatile`, the compiler might assume that multiple reads from the same
    address yield the same value or that writes to the address can be reordered or
    even omitted, which can lead to incorrect behavior when interacting with hardware.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用 `volatile`，编译器可能会假设从同一地址的多次读取会产生相同的值，或者写入该地址的顺序可以重排，甚至可以省略，这可能导致与硬件交互时出现不正确的行为。
- en: As we discussed in [*Chapter 9*](Chapter_09.xhtml), casting an integer to a
    pointer using `reinterpret_cast` is considered an implementation-defined behavior
    in C++. This means the C++ standard doesn’t specify exactly how it should work,
    and different compilers or platforms might handle it differently. Writing directly
    to a specific memory location is inherently unsafe and relies on behavior that
    isn’t guaranteed to be portable across all systems. Therefore, we need to be cautious
    about the portability of this solution, as some platforms may implement pointer
    conversions differently.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [*第 9 章*](Chapter_09.xhtml) 中讨论的那样，使用 `reinterpret_cast` 将整数转换为指针在 C++
    中被认为是实现定义的行为。这意味着 C++ 标准没有指定它应该如何工作，不同的编译器或平台可能会有不同的处理方式。直接写入特定的内存位置固有不安全性，并且依赖于不一定能在所有系统间保证可移植性的行为。因此，我们需要谨慎考虑此解决方案的可移植性，因为某些平台可能以不同的方式实现指针转换。
- en: 'Here are a few examples of using the class template `reg`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用类模板 `reg` 的几个示例：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These examples demonstrate the usage of the implemented interface for accessing
    memory-mapped peripherals. When defining types using the class template `reg`,
    we provide it with the address of a register and `write` access if we are working
    with write-only or read-only registers. The default access type allows us both
    read and write privileges.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例演示了使用实现接口访问内存映射外设的用法。当使用类模板 `reg` 定义类型时，我们向它提供寄存器的地址以及 `write` 访问权限，如果我们正在处理只写或只读寄存器。默认访问类型允许我们同时具有读和写权限。
- en: 'The preceding solution is as effective as the CMSIS approach. You can experiment
    with the full example and compare binary sizes by running the full example in
    Renode. Start Visual Studio Code, attach it to the running container, open the
    `Chapter12/cpp_hal` project as described in [*Chapter 4*](Chapter_04.xhtml), and
    run the following commands in the Visual Studio Code terminal, or run them directly
    in the container terminal:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的解决方案与 CMSIS 方法一样有效。您可以通过在 Renode 中运行完整示例并比较二进制大小来实验完整的示例。启动 Visual Studio
    Code，将其附加到正在运行的容器，按照 [*第 4 章*](Chapter_04.xhtml) 中所述打开 `Chapter12/cpp_hal` 项目，在
    Visual Studio Code 终端中运行以下命令，或者在容器终端中直接运行它们：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Our current solution still allows us to write arbitrary values to registers.
    To address this, we will use strong types based on `enum` classes to model bit
    fields used to set different settings in registers.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的解决方案仍然允许我们向寄存器写入任意值。为了解决这个问题，我们将使用基于 `enum` 类的强类型来建模用于在寄存器中设置不同设置的位字段。
- en: Type-safe memory-mapped peripherals in C++
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++ 中的类型安全的内存映射外设
- en: 'To prevent arbitrary writings to a register using the class template `reg`,
    we will add a new static method, `set`, which will accept only types meeting certain
    criteria. We will model these types by creating a `BitFieldConcept`. We covered
    concepts in [*Chapter 8*](Chapter_08.xhtml). Also, we will remove public access
    to the `write` method and put it instead in the `private` section. The modified
    code is shown here:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止使用类模板 `reg` 对寄存器进行任意写入，我们将添加一个新的静态方法 `set`，它将只接受满足某些标准的类型。我们将通过创建 `BitFieldConcept`
    来建模这些类型。我们在 [*第 8 章*](Chapter_08.xhtml) 中介绍了概念。此外，我们将移除对 `write` 方法的公共访问权限，并将其放在
    `private` 部分。修改后的代码如下：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The template method `set` has a single template parameter – type `BitField`.
    We use `BitFieldConcept` to impose the following requirements on the `BitField`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法 `set` 有一个单独的模板参数 – 类型 `BitField`。我们使用 `BitFieldConcept` 对 `BitField` 强制以下要求：
- en: '`Reg` must be the same as `BitField::reg`. This ensures the bit field is associated
    with the correct register.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reg` 必须与 `BitField::reg` 相同。这确保了位字段与正确的寄存器相关联。'
- en: '`BitField::value` must be an `enum`.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BitField::value` 必须是一个 `enum`。'
- en: The underlying type of the `BitField::value` `enum` must be `T`. This ensures
    that values represented by the `enum` can fit in the registers.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BitField::value` `enum` 的底层类型必须是 `T`。这确保了 `enum` 表示的值可以适合寄存器。'
- en: 'The `set` function parameter is `BitField::value bits_val`. The function itself
    is simple, and it performs the following operations:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`set` 函数参数是 `BitField::value bits_val`。该函数本身很简单，并执行以下操作：'
- en: Reads the current register value
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取当前寄存器值
- en: Clears the bits specified by `BitField::c_mask`
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清除由 `BitField::c_mask` 指定的位
- en: Sets the new bits by shifting `bits_val` to the correct position (`BitField::c_position`)
    and applying the mask
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将 `bits_val` 移位到正确的位置（`BitField::c_position`）并应用掩码来设置新位
- en: Writes the modified value back to the register
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将修改后的值写回寄存器
- en: To use the `set` function, we need to define types that describe the register’s
    bit fields and that meet the requirements imposed by the `BitFieldConcept`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `set` 函数，我们需要定义描述寄存器位字段并满足 `BitFieldConcept` 强制要求的类型。
- en: Modeling HSION and HSITRIM bit fields from the RCC register
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 建模 RCC 寄存器中的 HSION 和 HSITRIM 位字段
- en: 'Let us examine bit fields in the RCC CR register defined in the STM32F0x2 reference
    manual document, as shown in *Figure 12**.1*:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 STM32F0x2 参考手册文档中定义的 RCC CR 寄存器中的位字段，如图 *图 12.1* 所示：
- en: '![Figure 12.1 – RCC CR register](img/B22402_12_01.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1 – RCC CR 寄存器](img/B22402_12_01.png)'
- en: Figure 12.1 – RCC CR register
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – RCC CR 寄存器
- en: '*Figure 12**.1* depicts bit fields in the RCC CR register. Let us define a
    struct `hsion` that describes the HSI clock `enable` bit field from the RCC CR
    register. It has only one bit on position `0`, so we can model it as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12.1* 展示了 RCC CR 寄存器中的位字段。让我们定义一个名为 `hsion` 的结构体，它描述了 RCC CR 寄存器中的 HSI 时钟
    `enable` 位字段。它只在位置 `0` 有一个位，因此我们可以将其建模如下：'
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this code, we declare type `rcc` as an instance of the class template `reg`
    by providing it with the address of the RCC register. Then, we create a struct
    `hsion` with the following properties:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们通过提供 RCC 寄存器的地址将类型 `rcc` 声明为类模板 `reg` 的一个实例。然后，我们创建一个具有以下属性的 `hsion`
    结构：
- en: A public `typedef` member `reg`, which we set to `rcc`. This “maps” `hsion`
    to the `rcc` register thanks to `BitFieldConcept`.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个公共 `typedef` 成员 `reg`，我们将其设置为 `rcc`。这“映射”了 `hsion` 到 `rcc` 寄存器，归功于 `BitFieldConcept`。
- en: The `constexpr` variables `c_position` and `c_mask`, used for bit manipulation
    by the `set` method.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`constexpr` 变量 `c_position` 和 `c_mask`，用于通过 `set` 方法进行位操作。'
- en: An `enum` class `value`, defining `enable` and `disable`.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义 `enable` 和 `disable` 的 `enum` 类 `value`。
- en: 'We can use the `hsion` struct to enable or disable the HSI clock using the
    following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `hsion` 结构通过以下代码启用或禁用 HSI 时钟：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This code allows us to safely set bits in a register. It is also expressive:
    the syntax `rcc::set<hsion>(hsion::value::enable);` clearly communicates the intent
    – setting the `hsion` bit field to `enable` on the `rcc` register.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码允许我们安全地在寄存器中设置位。它也非常清晰：语法 `rcc::set<hsion>(hsion::value::enable);` 明确传达了意图——在
    `rcc` 寄存器上将 `hsion` 位字段设置为 `enable`。
- en: 'As we can see in *Figure 12**.1*, most of the defined bit fields in the `CR`
    register are `enable`/`disable` bits. Exceptions are:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在 *图 12**.1 中所见，`CR` 寄存器中定义的大多数位字段是 `enable`/`disable` 位。例外情况包括：
- en: '`HSICAL[7:0]: HSI clock calibration`: These bits are automatically initialized
    at startup and can be adjusted by software via the `HSITRIM` setting.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HSICAL[7:0]: HSI 时钟校准`：这些位在启动时自动初始化，并且可以通过 `HSITRIM` 设置由软件进行调整。'
- en: '`HSITRIM[4:0]: HSI clock trimming`: These bits offer an additional user-programmable
    trimming value added to the `HSICAL[7:0]` bits. This setting allows adjustments
    for voltage and temperature variations that may affect the HSI frequency.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HSITRIM[4:0]: HSI 时钟微调`：这些位提供了额外的用户可编程微调值，并将其添加到 `HSICAL[7:0]` 位。此设置允许对电压和温度变化进行调整，这些变化可能会影响
    HSI 频率。'
- en: '`HSICAL` bits are initialized at startup, meaning we shouldn’t modify them.
    `HSITRIM` bits are user-programmable, and they occupy 5 bits. Defining all combinations
    of 5 bits in the `BitField` value `enum` wouldn’t be practical, so we will approach
    this by providing value through a template parameter, as shown in the code here:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`HSICAL` 位在启动时初始化，这意味着我们不应该修改它们。`HSITRIM` 位是用户可编程的，并占用 5 位。在 `BitField` 值 `enum`
    中定义所有 5 位的组合在实践上并不实用，因此我们将通过提供模板参数的方式来处理这个问题，如代码所示：'
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this code, we defined the class template `hsitrim` with the auto template
    parameter `Bits`. The `auto` keyword is used to indicate that we are using a non-type
    template parameter. We use `static_assert` to make sure that the type of provided
    parameter `Bits` (`decltype(Bits)`) is the same as the underlying registers type
    to satisfy requirements imposed by `BitFieldConcept`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们定义了具有自动模板参数 `Bits` 的类模板 `hsitrim`。`auto` 关键字用于表示我们正在使用非类型模板参数。我们使用 `static_assert`
    来确保提供的参数 `Bits`（`decltype(Bits)`）的类型与底层寄存器类型相同，以满足 `BitFieldConcept` 强加的要求。
- en: 'We encode the `enum` class value val with the `Bits`. This encodes the value
    in the type itself and makes it possible to use it with the `reg` struct `set`
    method. We also utilize `static_assert` to make sure that the provided value fits
    in the allocated number of bits – `static_assert(Bits <= 0x1F)`. Again, we are
    utilizing compile-time operations to ensure type safety. Here is an example of
    using the `hsitrim` struct:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `Bits` 对 `enum` 类值 `val` 进行编码。这将在类型本身中编码值，并使其能够与 `reg` 结构的 `set` 方法一起使用。我们还利用
    `static_assert` 来确保提供的值适合分配的位数数量——`static_assert(Bits <= 0x1F)`。再次，我们正在利用编译时操作来确保类型安全。以下是一个使用
    `hsitrim` 结构的示例：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This code sets the `hstrim` value in the `rcc` register to `0xF`. You can experiment
    with the full example in Renode. Start Visual Studio Code, attach it to the running
    container, open the `Chapter12/cpp_hal` project, as described in [*Chapter 4*](Chapter_04.xhtml),
    and run the following commands in the Visual Studio Code terminal, or run them
    directly in the container terminal:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将 `rcc` 寄存器中的 `hstrim` 值设置为 `0xF`。您可以在 Renode 中尝试完整的示例。启动 Visual Studio Code，将其附加到正在运行的容器，打开
    `Chapter12/cpp_hal` 项目，如 [*第 4 章*](Chapter_04.xhtml) 中所述，然后在 Visual Studio Code
    终端中运行以下命令，或者在容器终端中直接运行它们：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Generic versions of hsion and hsi_trim
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: hsion 和 hsi_trim 的通用版本
- en: 'To enable the reuse of bit fields that have a single bit (enable/disable) such
    as `hsion`, we will define the class template `reg_bits_enable_disable`, as shown
    here:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使具有单个位（启用/禁用）的单个位字段（如`hsion`）可重用，我们将定义类模板`reg_bits_enable_disable`，如下所示：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This defined template type, `reg_bits_enable_disable`, could be used to define
    the `hsion` type, as shown in the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此定义的模板类型`reg_bits_enable_disable`可以用来定义`hsion`类型，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we will create a generic version of the type used to set multiple fields
    with a value, such as `hsi_trim`. We will call it `reg_bits`, and the code is
    shown here:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建用于设置具有值的多个字段（如`hsi_trim`）的类型的一般版本。我们将称之为`reg_bits`，代码如下所示：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We could use the generic type `reg_bits` to define the `hsi_trim` template
    type, as shown here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用通用类型`reg_bits`来定义`hsi_trim`模板类型，如下所示：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Next, we will explore how to use C++ to create templates for peripherals that
    are similar but also have some implementation differences.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何使用C++创建类似但也有一些实现差异的外设模板。
- en: Timers
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计时器
- en: '`STM32F072` has multiple timers, including TIM2 and TIM3\. TIM2 is a 32-bit
    timer and TIM3 is a 16-bit timer.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`STM32F072`有多个计时器，包括TIM2和TIM3。TIM2是一个32位计时器，TIM3是一个16位计时器。'
- en: 'We will create a template class timer that will depend on timer traits structures
    containing timer-specific details. Here is the code for timer traits structures:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个依赖于包含计时器特定细节的计时器特性结构的模板类计时器。以下是计时器特性结构的代码：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this code, `timer2_traits` and `timer3_traits` are traits structures that
    encapsulate the hardware-specific details of TIM2 and TIM3 timers, respectively.
    They have the following members:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`timer2_traits`和`timer3_traits`是封装TIM2和TIM3计时器硬件特定细节的特性结构。它们具有以下成员：
- en: '`base_address`: The base memory address of the timer’s register map'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base_address`：计时器寄存器映射的基内存地址'
- en: '`irqn`: The interrupt request number associated with the timer'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irqn`：与计时器相关联的中断请求号'
- en: '`arr_bit_mask`: The bit mask for the auto-reload register (ARR):'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arr_bit_mask`：自动重载寄存器（ARR）的位掩码：'
- en: For TIM2, it’s `0xFFFFFFFF` (32-bit timer).
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于TIM2，它是`0xFFFFFFFF`（32位计时器）。
- en: For TIM3, it’s `0xFFFF` (16-bit timer).
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于TIM3，它是`0xFFFF`（16位计时器）。
- en: 'Next, let’s look at the template class timer:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看模板类计时器：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this code, we defined a template class timer with template parameter `TimerTraits`
    – a traits class that provides hardware-specific constants. The timer class template
    provides a generic interface to configure and control timers, customized for each
    specific timer via `TimerTraits`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们定义了一个模板类计时器，其模板参数为`TimerTraits` – 一个提供硬件特定常数的特性类。计时器类模板提供了一个通用的接口来配置和控制计时器，通过`TimerTraits`针对每个特定计时器进行定制。
- en: Please note that for the sake of simplicity of the example, this is the minimum
    code needed to set up the STM32 timer peripheral.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了简化示例，这是设置STM32计时器外设所需的最小代码。
- en: 'Within the timer class, we define register type aliases, as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在计时器类内部，我们定义寄存器类型别名，如下所示：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: These type aliases represent the timer’s hardware registers, each mapped to
    a specific memory address. Each register is an instantiation of the `reg` class
    template, which provides read/write access to hardware registers.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型别名代表计时器的硬件寄存器，每个映射到特定的内存地址。每个寄存器都是`reg`类模板的实例化，它提供了对硬件寄存器的读写访问。
- en: 'Next, we define type aliases for `BitFields`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为`BitFields`定义类型别名：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this code, we instantiate bit fields using the class templates `reg_bits`
    and `reg_bits_enable_disable`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们使用类模板`reg_bits`和`reg_bits_enable_disable`实例化位字段。
- en: 'Finally, we define the template static method `start` in the class template
    timer. This `static` function sets up the timer with the desired period and starts
    it. The code executes the following steps:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在类模板计时器中定义了模板静态方法`start`。此`static`函数使用所需的周期设置计时器并启动它。代码执行以下步骤：
- en: Calculate Prescaler and Auto-Reload values. The function uses the template parameter
    Period to calculate these values.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算预分频器和自动重载值。该函数使用模板参数Period来计算这些值。
- en: Set Prescaler (PSC) and Auto-Reload (ARR) registers.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置预分频器（PSC）和自动重载（ARR）寄存器。
- en: Enable the update interrupt on the DIER register. It uses the `uie` bit field
    to enable the update interrupt in the DIER register.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在DIER寄存器上启用更新中断。它使用`uie`位字段在DIER寄存器中启用更新中断。
- en: Configure NVIC for timer interrupts using CMSIS functions.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用CMSIS函数配置NVIC以启用计时器中断。
- en: Start the timer. It uses the `cen` bit field to enable the timer counter in
    the CR1 register.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始计时器。它使用 `cen` 位字段在 CR1 寄存器中启用计时器计数器。
- en: 'Let’s now see how we can use the provided timer template class:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们如何使用提供的计时器模板类：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this code, we create the type aliases `timer2` and `timer3` and implement
    **Interrupt Request (IRQ)** functions for the `TIM2` and `TIM3` interrupts. In
    the IRQs, we clear interrupt flags. We make calls to start functions of types
    `timer2` and `timer3` in the `main` function.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们创建了类型别名 `timer2` 和 `timer3`，并为 `TIM2` 和 `TIM3` 中断实现了**中断请求 (IRQ**) 函数。在
    IRQ 中，我们清除中断标志。我们在 `main` 函数中调用 `timer2` 和 `timer3` 类型的启动函数。
- en: 'You can run the full example in Renode. Start Visual Studio Code, attach it
    to the running container, open the `Chapter12/cpp_hal` project, as described in
    [*Chapter 4*](Chapter_04.xhtml), and run the following commands in the Visual
    Studio Code terminal, or run them directly in the container terminal:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Renode 中运行完整示例。启动 Visual Studio Code，将其附加到正在运行的容器，打开如[*第 4 章*](Chapter_04.xhtml)所述的
    `Chapter12/cpp_hal` 项目，并在 Visual Studio Code 终端中运行以下命令，或者在容器终端中直接运行它们：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this section, we learned how to create a generic, template-based timer interface
    by utilizing C++ templates and traits classes. By defining `TimerTraits` structures
    (`timer2_traits` and `timer3_traits`) that encapsulate hardware-specific details
    of the TIM2 and TIM3 timers, we can instantiate a flexible `timer` class template
    that abstracts the configuration and control of different timers. This approach
    offers two main benefits: it increases type safety by using templates to enforce
    correct usage at compile time, and it results in code that is as efficient as
    traditional C HAL implementations because the use of templates and constexpr allows
    the compiler to optimize the code thoroughly.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何通过利用 C++ 模板和特性类创建一个基于模板的通用计时器接口。通过定义封装 TIM2 和 TIM3 定时器硬件特定细节的 `TimerTraits`
    结构（`timer2_traits` 和 `timer3_traits`），我们可以实例化一个灵活的 `timer` 类模板，该模板抽象了不同计时器的配置和控制。这种方法提供了两个主要好处：它通过模板在编译时强制正确使用，从而增加了类型安全性；并且由于模板和
    constexpr 的使用，生成的代码与传统 C HAL 实现一样高效，因为模板的使用和 constexpr 允许编译器彻底优化代码。
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned techniques that we can apply to create safer HAL
    code in C++. We covered the implementation of memory-mapped peripherals. The design
    utilizes templates and advanced techniques such as SFINAE, which we discovered
    in [*Chapter 8*](Chapter_08.xhtml). We applied the knowledge from previous chapters
    in the embedded systems domain.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了可以应用于创建更安全的 C++ HAL 代码的技术。我们涵盖了内存映射外设的实现。该设计利用模板和诸如 SFINAE 等高级技术，这些技术我们在[*第
    8 章*](Chapter_08.xhtml)中发现了。我们将前几章中嵌入式系统领域的知识应用于实践。
- en: We also learned how to design classes that implement generic behavior and depend
    on traits classes to supply them with specific details. The code we developed
    is as efficient as a hand-coded (CMSIS-based) solution, thanks to the usage of
    templates and compile-time computations, enabling compiler optimizations.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何设计实现通用行为并依赖于特性类以提供具体细节的类。我们开发的代码与手编写的（基于 CMSIS 的）解决方案一样高效，这得益于模板的使用和编译时计算，使得编译器能够进行优化。
- en: In the next chapter, we will cover working with C libraries in C++.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何在 C++ 中使用 C 库。
