- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Working with Lua Tables
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Lua表格
- en: In this chapter, we will continue to improve our Lua executor to work with tables.
    Many of the mechanisms are extensions of the learnings from the previous chapter.
    You will also learn about **object-oriented programming** (**OOP**) in Lua and
    how to call Lua object methods. In all, Lua objects are Lua tables by nature.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续改进我们的Lua执行器以与表格一起工作。许多机制都是对上一章所学内容的扩展。你还将了解Lua中的**面向对象编程**（**OOP**）以及如何调用Lua对象方法。总的来说，Lua对象本质上就是Lua表格。
- en: 'We will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Working with Lua table entries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Lua表格条目
- en: Working with Lua arrays
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Lua数组
- en: OOP in Lua
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lua中的OOP
- en: Working with Lua table functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Lua表格函数
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Here are the technical requirements for this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是本章的技术要求：
- en: You can access the source code for this chapter at [https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter05](https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter05).
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在此章节的源代码[https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter05](https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter05)中找到。
- en: You can understand and execute the code in the `begin` folder from the preceding
    GitHub link. If you haven’t already done so, please try to do the exercises in
    the previous chapter on your own, or at least understand the solutions in the
    `begin` folder.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以理解并执行前一个GitHub链接中的`begin`文件夹中的代码。如果你还没有这样做，请尝试自己完成前一章的练习，或者至少理解`begin`文件夹中的解决方案。
- en: You can understand the `Makefile` located in GitHub and can build the projects.
    Alternatively, you can use your own way to build the source code.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以理解位于GitHub中的`Makefile`并构建项目。或者，你也可以使用自己的方式来构建源代码。
- en: Working with Lua table entries
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Lua表格条目
- en: A **table entry** is the key-value pair for a table element. Lua table keys
    can be of many data types – for example, of function type. For practical reasons,
    especially when integrating with C++, we only consider string keys and integer
    keys.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格条目**是表格元素的键值对。Lua表格键可以是多种数据类型——例如，函数类型。出于实际考虑，尤其是在与C++集成时，我们只考虑字符串键和整数键。'
- en: 'In `script.lua`, add a simple table as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在`script.lua`中添加一个简单的表格如下：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`position` is indexed by strings. We will learn how to read from and write
    to it in C++.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`position`通过字符串索引。我们将学习如何在C++中读取和写入它。'
- en: Getting a table entry value
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取表格条目值
- en: Up until now, in C++ code, we have only used one piece of information to locate
    a value in Lua. Consider how we implemented `LuaExecutor::getGlobal` and `LuaExecutor::call`.
    To locate a global variable or to call a function, we pass the name of the variable
    or the function to a Lua library method.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在C++代码中，我们只使用一条信息来定位Lua中的值。考虑我们如何实现`LuaExecutor::getGlobal`和`LuaExecutor::call`。为了定位全局变量或调用函数，我们将变量或函数的名称传递给Lua库方法。
- en: To work with a table entry, we would need two pieces of information – the table
    and the table entry key. First, we need to locate the table; after that, we can
    use the entry key to work on the entry value.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理表格条目，我们需要两个信息——表格和表格条目键。首先，我们需要定位表格；之后，我们可以使用条目键来处理条目值。
- en: 'The Lua library method to get an entry value is declared as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 获取条目值的Lua库方法声明如下：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Wait! We analyzed that we would need two pieces of information to locate a
    table entry, no? How is it possible that `lua_gettable` only takes one meaningful
    argument, `index`, besides the Lua state, `L`? Remember the Lua stack? The top
    of the stack is commonly used to pass additional information. To quote the Lua
    reference manual, `lua_gettable` does the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 等等！我们分析了我们需要两个信息来定位表格条目，不是吗？为什么`lua_gettable`除了Lua状态`L`之外，只接受一个有意义的参数`index`呢？还记得Lua栈吗？栈顶通常用于传递额外信息。引用Lua参考手册，`lua_gettable`执行以下操作：
- en: '*Pushes onto the stack the value* `t[k]`*, where* `t` *is the value at the
    given* `index` *and* `k` *is the value on the top of the stack. This function
    pops the key from the stack, pushing the resulting value in its place. (*[https://www.lua.org/manual/5.4/manual.xhtml#lua_gettable](https://www.lua.org/manual/5.4/manual.xhtml#lua_gettable)*)*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*将值`t[k]`*推入栈中，其中`t`是给定索引处的值，`k`是栈顶的值。此函数从栈中弹出键，用结果值替换它。（[https://www.lua.org/manual/5.4/manual.xhtml#lua_gettable](https://www.lua.org/manual/5.4/manual.xhtml#lua_gettable)）'
- en: 'As explained, the two keys are both located in the Lua stack. As seen in *Figure
    5**.1*, before the call, the table entry key must be at the top of the stack,
    while the table can be in any other position in the stack. This is a Lua design
    decision. Since you may work on the same table from time to time, you can keep
    the table reference somewhere in the stack to avoid repeatedly pushing it onto
    the stack for each access:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如解释所述，两个键都位于 Lua 栈中。如图 *图 5**.1* 所示，在调用之前，表格条目键必须位于栈顶，而表格可以位于栈中的任何其他位置。这是 Lua
    的设计决策。由于您可能有时会处理同一个表格，您可以在栈中某个位置保留表格引用，以避免每次访问时都重复将其推入栈中：
- en: '![Figure 5.1 – lua_gettable](img/B20927_05_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – lua_gettable](img/B20927_05_01.jpg)'
- en: Figure 5.1 – lua_gettable
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – lua_gettable
- en: 'After understanding the mechanism, it’s time to make a design decision. How
    should we implement the table access in C++? Here are some possibilities:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了机制之后，是时候做出设计决策了。我们应该如何在 C++ 中实现表格访问？以下是一些可能性：
- en: We can push the table onto the stack and keep it there. For example, if we are
    working with a complex table, we can implement a C++ class to load the table at
    the bottom of the stack and have the C++ object work exclusively with the table.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将表格推入栈中并保留它。例如，如果我们正在处理一个复杂的表格，我们可以实现一个 C++ 类来加载栈底部的表格，并让 C++ 对象专门与该表格工作。
- en: We can push the table onto the stack whenever we need to and pop it immediately
    after it’s no longer needed. This works well if the C++ class is working with
    many Lua values and it is not a performance concern to push the Lua table each
    time.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在需要时将表格推入栈中，并在不再需要时立即弹出。如果 C++ 类处理许多 Lua 值且每次推入 Lua 表格不是性能问题，这种方法效果很好。
- en: 'Since we are implementing a general Lua executor, we will choose the latter
    option. In `LuaExecutor.h`, declare the following function:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在实现一个通用的 Lua 执行器，我们将选择后者。在 `LuaExecutor.h` 中声明以下函数：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It takes the table name and the table entry key name and returns a `LuaValue`
    instance. We are only concerned about the string-type key at the moment. In `LuaExecutor.cc`,
    implement it as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 它获取表格名称和表格条目键名称，并返回一个 `LuaValue` 实例。目前我们只关心字符串类型的键。在 `LuaExecutor.cc` 中实现如下：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The code is doing the following things to get a table entry value:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 代码执行以下操作以获取表格条目值：
- en: It pushes the table reference onto the top of the stack with `lua_getglobal`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用 `lua_getglobal` 将表格引用推入栈顶。
- en: It pushes the table entry key onto the top of the stack with `lua_pushstring`.
    Now, the table is the second from the top.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用 `lua_pushstring` 将表格条目键推入栈顶。现在，表格位于栈顶的第二个位置。
- en: It calls `lua_gettable` to pop the entry key and push the entry value. Now,
    the entry value is at the top of the stack.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它调用 `lua_gettable` 弹出条目键并推入条目值。现在，条目值位于栈顶。
- en: It pops the top of the stack as a `LuaValue` with `LuaExecutor::popValue`. Now,
    the top of the stack is again the table reference.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用 `LuaExecutor::popValue` 弹出栈顶的 `LuaValue`。现在，栈顶再次是表格引用。
- en: It pops the table with `lua_pop`, as it’s no longer needed.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用 `lua_pop` 弹出表格，因为它不再需要。
- en: It returns the table entry value.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它返回表格条目值。
- en: In this implementation, we limit ourselves to only working with tables in the
    global scope. This is because we are implementing a general Lua executor. For
    special use cases, you can implement specific C++ classes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在此实现中，我们限制自己仅与全局作用域中的表格一起工作。这是因为我们正在实现一个通用的 Lua 执行器。对于特殊用例，您可以实现特定的 C++ 类。
- en: Now, let’s see how to set a table entry value.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何设置表格条目值。
- en: Setting a table entry value
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置表格条目值
- en: 'The Lua library function to set a table entry value is declared as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 设置表格条目值的 Lua 库函数声明如下：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And the quote from the Lua reference manual explains it well:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 参考手册中的引言很好地解释了这一点：
- en: '*Does the equivalent to* `t[k] = v`*, where* `t` *is the value at the given
    index*, `v` *is the value on the top of the stack, and* `k` *is the value just
    below the top. Pops both the key and the value from the stack. (*[https://www.lua.org/manual/5.4/manual.xhtml#lua_settable](https://www.lua.org/manual/5.4/manual.xhtml#lua_settable)*)*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*相当于* `t[k] = v`*，其中* `t` *是给定索引的值，* `v` *是栈顶的值，* `k` *是紧挨栈顶的值。从栈中弹出键和值。(*[https://www.lua.org/manual/5.4/manual.xhtml#lua_settable](https://www.lua.org/manual/5.4/manual.xhtml#lua_settable)*)*'
- en: 'This can be seen in *Figure 5**.2*. Now, we need to push both the entry key
    and the entry value onto the Lua stack:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在 *图 5**.2* 中看到。现在，我们需要将条目键和条目值都推入 Lua 栈：
- en: '![Figure 5.2 – lua_settable](img/B20927_05_02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – lua_settable](img/B20927_05_02.jpg)'
- en: Figure 5.2 – lua_settable
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – lua_settable
- en: 'In `LuaExecutor.h`, add the function declaration, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LuaExecutor.h`中添加函数声明，如下所示：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We are passing the value as a `LuaValue`. In `LuaExecutor.cc`, implement it
    as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将值作为`LuaValue`传递。在`LuaExecutor.cc`中实现如下：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The code is explained in the following steps:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的说明如下：
- en: It pushes the table reference onto the top of the stack with `lua_getglobal`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用`lua_getglobal`将表引用推送到栈顶。
- en: It pushes the table entry key onto the stack with `lua_pushstring`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用`lua_pushstring`将表条目键推送到栈上。
- en: It pushes the table entry value onto the stack with `LuaExecutor::pushValue`.
    Now, the table reference is the third from the top of the stack.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用`LuaExecutor::pushValue`将表条目值推送到栈上。现在，表引用是栈顶的第三个元素。
- en: It sets the table entry with `lua_settable`. This also pops the top two items
    from the stack.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用`lua_settable`设置表条目。这也从栈中弹出顶部两个元素。
- en: It pops the table with `lua_pop`. The table is pushed onto the stack in *step
    1*.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用`lua_pop`弹出表。表是在*步骤1*中推送到栈上的。
- en: Next, let’s test our implementations so far.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们测试我们到目前为止的实现。
- en: Testing table operations with string keys
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用字符串键测试表操作
- en: 'In `main.cpp`, add the following helper function to print out a `position`
    table:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.cpp`中，添加以下辅助函数以打印出`position`表：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`dumpPosition` calls `LuaExecutor::getTable`, which we have just implemented,
    to get and print the `x` field and the `y` field. In `main()`, change the test
    code as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`dumpPosition`调用`LuaExecutor::getTable`，这是我们刚刚实现的，以获取并打印`x`字段和`y`字段。在`main()`中，将测试代码更改为如下：'
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This first prints a `position` table, then changes `position.x` to `3` and
    `position.y` to `4` and prints the table again. If you have done everything correctly,
    you should see the following output:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这首先打印一个`position`表，然后将`position.x`更改为`3`，将`position.y`更改为`4`，并再次打印表。如果你一切都做对了，你应该看到以下输出：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Next, let’s learn how to work with integer types of table keys.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们学习如何处理整数类型的表键。
- en: Do you remember?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得吗？
- en: If a Lua table uses integer keys exclusively, what else can the table be called?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个Lua表只使用整数键，这个表还能被称为什么？
- en: Working with Lua arrays
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理Lua数组
- en: 'Yes – a Lua table with only integer keys is called an array or a sequence.
    In `script.lua`, add the following array:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 是的——只包含整数键的Lua表被称为数组或序列。在`script.lua`中添加以下数组：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'From the C++ side, compared with string keys, the only difference is the data
    type of the keys. It’s straightforward to overload the `getTable` and `setTable`
    functions by using integer keys. In `LuaExecutor.h`, add the following declarations:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从C++方面来看，与字符串键相比，唯一的区别是键的数据类型。通过使用整数键，可以简单地通过重载`getTable`和`setTable`函数来处理。在`LuaExecutor.h`中添加以下声明：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`index` is the Lua array index – starting from 1\. Do not confuse this with
    the Lua stack index. In the Lua executor’s public APIs, there should be no mention
    of the Lua stack or Lua state.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`index`是Lua数组索引——从1开始。不要与Lua栈索引混淆。在Lua执行器的公共API中，不应提及Lua栈或Lua状态。'
- en: One way to implement them is to copy the string key version, and instead of
    calling `lua_pushstring(L, key.c_str())`, call `lua_pushinteger(L, index)`. This
    will work. But what’s the point of repeating ourselves if this is what we would
    do? Is there another trick?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一种实现方法是复制字符串键版本，而不是调用`lua_pushstring(L, key.c_str())`，而是调用`lua_pushinteger(L,
    index)`。这会起作用。但如果我们这样做，重复自己有什么意义？有没有其他技巧？
- en: Using array index optimization
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数组索引优化
- en: 'Lua puts lots of emphasis on speed. Because an array is a common form of a
    Lua table, the Lua library provides special functions to work with arrays, as
    seen here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Lua非常注重速度。因为数组是Lua表的一种常见形式，Lua库提供了特殊函数来处理数组，如下所示：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These functions accept two pieces of information. The `index` argument is the
    position of the table in the Lua stack. The `key` argument is the array index,
    as it is also the table entry key. Compared with using `lua_gettable` and `lua_settable`,
    you no longer need to push the table entry key onto the stack. `lua_seti` expects
    the value to be at the top of the stack.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数接受两份数据。`index`参数是表在Lua栈中的位置。`key`参数是数组索引，因为它也是表条目的键。与使用`lua_gettable`和`lua_settable`相比，你不再需要将表条目键推送到栈上。`lua_seti`期望值在栈顶。
- en: 'Now, let’s implement the `getTable` function for arrays. In `LuaExecutor.cc`,
    add the code as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现数组的`getTable`函数。在`LuaExecutor.cc`中添加以下代码：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The code is doing the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 代码正在执行以下操作：
- en: It gets the table from a global variable and pushes its reference onto the top
    of the stack.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它从一个全局变量中获取表并将其引用推入栈顶。
- en: It calls `lua_geti` with the specified array index. The Lua library will push
    the value onto the stack.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用指定的数组索引调用 `lua_geti`。Lua 库会将值推入栈中。
- en: It pops the value as a `LuaValue` with `LuaExecutor::popValue`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用 `LuaExecutor::popValue` 将值作为 `LuaValue` 弹出。
- en: It pops the table reference.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它弹出表引用。
- en: It returns the value.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它返回值。
- en: 'This does not need to push the array index onto the stack at all. Similarly,
    implement the `setTable` function for arrays. In `LuaExecutor.cc`, add the following
    code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这根本不需要将数组索引推入栈中。同样，实现 `setTable` 函数用于数组。在 `LuaExecutor.cc` 中添加以下代码：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The previous code is explained as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码解释如下：
- en: It gets the table from a global variable and pushes its reference onto the top
    of the stack.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它从一个全局变量中获取表并将其引用推入栈顶。
- en: It pushes the value for the `index` array position with `LuaExecutor::pushValue`.
    Now, the table reference is second from the top of the stack.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用 `LuaExecutor::pushValue` 将 `index` 数组位置的值推入栈中。现在，表引用位于栈的第二个位置。
- en: It calls `lua_seti` to set the array position value. It also pops the value
    from the stack. Now, the table reference is again at the top of the stack.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它调用 `lua_seti` 来设置数组位置的值。它还从栈中弹出值。现在，表引用再次位于栈顶。
- en: It pops the table reference.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它弹出表引用。
- en: Next, let’s test this.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们测试一下。
- en: Testing the array index optimization
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试数组索引优化
- en: 'In `main.cpp`, add another helper function to print a `seq` Lua array, as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main.cpp` 中，添加另一个辅助函数以打印一个 `seq` Lua 数组，如下所示：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This uses `LuaExecutor::getTable` with integer keys. Replace the test code
    in `main()` with the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用 `LuaExecutor::getTable` 与整数键。将 `main()` 中的测试代码替换为以下内容：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This changes the `seq` array to `{ 3, 9, 27 }`. If you have done everything
    correctly, you should see the output as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 `seq` 数组更改为 `{ 3, 9, 27 }`。如果你一切都做对了，你应该看到以下输出：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Well done, Lua, for the optimization. And well done, yourself, for making it
    this far. But how about string keys? In real-world scenarios, more often than
    not, a Lua table is not an array.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好，Lua，对于优化。还有，你自己做得很好，能走到这一步。但是字符串键呢？在现实场景中，很多时候，Lua 表不是一个数组。
- en: Revisiting string keys
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾字符串键
- en: When we first learned to use a string key to access the Lua table, we chose
    the longer journey to push the key onto the stack. This is because it is a general
    mechanism, and once learned, you can change to use another data type as table
    keys.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次学习使用字符串键来访问 Lua 表时，我们选择了更长的路径将键推入栈中。这是因为它是一个通用机制，一旦学会，你就可以改为使用其他数据类型作为表键。
- en: 'It is fair to expect an optimization for string keys as well. Here are the
    Lua library functions for this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字符串键，我们也应该期望有优化。以下是 Lua 库为此提供的函数：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: These functions work similarly to `lua_geti` and `lua_seti`. `lua_getfield`
    also returns the type of the table entry value. At the end of this chapter, you
    will get homework to rewrite `LuaExecutor` with them. You can also choose to do
    it right now.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数与 `lua_geti` 和 `lua_seti` 类似。`lua_getfield` 还会返回表条目值的类型。在本章结束时，你将得到作业，用它们重写
    `LuaExecutor`。你也可以选择现在就做。
- en: Before learning how to call a function from a Lua table, let’s write a Lua class.
    Lua tables with functions are more like C++ objects.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习如何从 Lua 表中调用函数之前，让我们编写一个 Lua 类。带有函数的 Lua 表更像是 C++ 对象。
- en: OOP in Lua
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lua 中的 OOP
- en: OOP in Lua is different than that in C++. In C++, you define a class and create
    instances of the class. The classes defined are unique types at the language level.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 中的 OOP 与 C++ 中的不同。在 C++ 中，你定义一个类并创建类的实例。定义的类在语言级别上是唯一的类型。
- en: In Lua, there is no native class concept. OOP in Lua is prototype-based. This
    is more like JavaScript if you are familiar with it. For a Lua table, if an entry
    is not present, you can instruct Lua to check another table for it, which acts
    as the prototype for the table you are explicitly referencing.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Lua 中，没有原生的类概念。Lua 中的 OOP 是基于原型的。如果你熟悉 JavaScript，这更像是 JavaScript。对于 Lua 表，如果一个条目不存在，你可以指示
    Lua 检查另一个表，该表作为你显式引用的表的原型。
- en: For ease of understanding, it’s fine to call this prototype table the “class”
    and the table the “object”. Or, you can call the relationship “inheritance.” Although
    prototype and class are two different **object-oriented** (**OO**) methodologies,
    sometimes people use the two terms interchangeably.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于理解，我们可以将这个原型表称为“类”，将表称为“对象”。或者，你也可以将这种关系称为“继承”。尽管原型和类是两种不同的**面向对象**（**OO**）方法，但有时人们会交替使用这两个术语。
- en: 'Let’s write a class that we will use to learn how to call Lua table functions.
    Suppose we want to keep a list of places we want to go and note whether we have
    visited them. In `script.lua`, define a table to be used as the prototype as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个类，我们将用它来学习如何调用Lua表函数。假设我们想要保存一个我们想去的地方的列表，并记录我们是否访问过它们。在`script.lua`中，定义一个用作原型的表，如下所示：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We defined a table named `Destinations`. It contains a map named `places` to
    track locations and keep a tab on whether or not they were visited. The key will
    be the places we want to go, and the value will be *Booleans*. We will define
    table functions after we have explained how we can use **metatables** to achieve
    OO behavior.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`Destinations`的表。它包含一个名为`places`的映射，用于跟踪位置并记录是否访问过。键将是我们想去的地方，值将是*布尔值*。在我们解释了如何使用**元表**来实现面向对象行为之后，我们将定义表函数。
- en: Using Lua metatables to achieve inheritance
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Lua元表实现继承
- en: Since `Destinations` is first of all a plain table, by default you can modify
    its `places` entry. How can we prevent users from using it directly? Probably
    you already know or have guessed. We need to set a Lua metatable. We can use `setmetatable`
    to overwrite some operations on the tables. This is comparable to operator overloading
    in C++.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Destinations`首先是一个普通的表，默认情况下你可以修改它的`places`条目。我们如何防止用户直接使用它呢？你可能已经知道或者猜到了。我们需要设置一个Lua元表。我们可以使用`setmetatable`来覆盖表上的一些操作。这类似于C++中的运算符重载。
- en: In our case, we set the `__newindex` `Destinations.places` to a function that
    does nothing but print an error message. `__newindex` is called when we assign
    to an absent table key. This is similar to overloading the C++ subscript operator.
    We could go to more extremes, but it’s fine with this simple limitation to show
    an attitude.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将`__newindex` `Destinations.places`设置为一个只打印错误信息的函数。当我们将值赋给不存在的表键时，会调用`__newindex`。这类似于重载C++的索引运算符。我们可以做得更极端，但这个简单的限制已经足够展示我们的态度。
- en: There is also an `__index` metamethod we can provide that is used to access
    absent table keys. This is how we can achieve inheritance behavior. Suppose that
    we have a table named `dst` that uses `Destinations` as its prototype. When we
    call `dst.wish()` to add a city to the wish list, what Lua is really doing is
    first looking up the function via `dst["wish"]`. Since `dst` does not have a `wish`
    method, Lua calls the `__index` metamethod, in which we can call the `wish` method
    in the `Destinations` table. This is how `Destinations` acts as the prototype
    for `dst`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以提供一个`__index`元方法，用于访问不存在的表键。这就是我们如何实现继承行为。假设我们有一个名为`dst`的表，它使用`Destinations`作为其原型。当我们调用`dst.wish()`向愿望列表添加一个城市时，Lua实际上首先通过`dst["wish"]`查找函数。由于`dst`没有`wish`方法，Lua会调用`__index`元方法，在其中我们可以调用`Destinations`表中的`wish`方法。这就是`Destinations`如何作为`dst`的原型。
- en: 'To see it in action, in `script.lua`, add a constructor for `Destinations`
    to create new instances:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到它的实际应用，在`script.lua`中为`Destinations`添加一个构造函数以创建新实例：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `new` method involves the following steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`方法涉及以下步骤：'
- en: It creates a new `obj` local table with an entry named `places`, matching the
    prototype table.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它创建一个新的本地表`obj`，其中包含一个名为`places`的条目，与原型表匹配。
- en: It sets `obj`’s `__index` metamethod as the `Destination` table. This is another
    syntax sugar that you can use to set a table as the metamethod. Then, Lua will
    redirect the lookup for absent keys to the prototype table directly.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将`obj`的`__index`元方法设置为`Destination`表。这是你可以用来设置表作为元方法的另一种语法糖。然后，Lua将直接将缺失键的查找重定向到原型表。
- en: It assigns the newly created object to a global variable if `global_name` is
    provided. Global variables are held in the unique table, `_G`. If we used the
    code purely in Lua, we wouldn’t need this step. This is to make the new object
    easily accessible in C++.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果提供了`global_name`，它将新创建的对象分配给一个全局变量。全局变量存储在唯一的表`_G`中。如果我们只使用Lua代码，我们就不需要这一步。这是为了让新对象在C++中易于访问。
- en: It returns the new object.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它返回新的对象。
- en: More about design decisions
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于设计决策
- en: 'We provided an option to set a global variable in an object creator. This is
    a bit unusual and can be considered to cause a side effect from a constructor.
    You should not blindly copy this paradigm. Consider the following options:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个选项在对象创建器中设置全局变量。这有点不寻常，可以被认为是从构造函数中产生副作用。你不应该盲目地复制这种模式。考虑以下选项：
- en: You need to create a Lua executor, do something, and then let it go. This is
    like invoking a shell command. Most examples in this book use Lua in this way.
    There is little chance of abusing the global scope. So, assigning the object to
    a global variable is convenient and efficient.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要创建一个 Lua 执行器，执行一些操作，然后让它运行。这就像调用一个 shell 命令。本书中的大多数示例都是这样使用 Lua 的。滥用全局作用域的可能性很小。因此，将对象分配给全局变量既方便又高效。
- en: You need to work with a Lua executor heavily for many things. Then, you can
    implement a special C++ function to create and keep the table in the stack, and
    another function to remove it later.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要大量地与 Lua 执行器一起工作。然后，你可以实现一个特殊的 C++ 函数来创建并保留表在栈上，另一个函数用于稍后删除它。
- en: You need to work with a table object exclusively. You might create it in C++’s
    constructor and keep the table at the bottom of the Lua stack, as pointed out
    earlier in this chapter.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要专门与表对象一起工作。你可以在 C++ 的构造函数中创建它，并将表保持在 Lua 栈的底部，正如本章前面所指出的。
- en: Better yet, do not use Lua tables at all. In this book, we need to learn how
    to integrate Lua tables with C++ so that you can do very complex interactions
    when you need to. But maybe you could divide the C++ domain and the Lua domain
    more cleanly, and they only send each other simple instructions and results.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的做法是根本不使用 Lua 表。在这本书中，我们需要学习如何将 Lua 表与 C++ 集成，这样你就可以在需要时进行非常复杂的交互。但也许你可以更清晰地划分
    C++ 领域和 Lua 领域，它们只互相发送简单的指令和结果。
- en: With object construction sorted out, we can implement its member functions to
    make `Destinations` complete.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象构造完成之后，我们可以实现其成员函数以使 `Destinations` 完成。
- en: Implementing Lua class member functions
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 Lua 类成员函数
- en: 'For a fully functional destination wish list, we need methods to add a place
    to the wish list. Mark a place visited and check the status of the wish list.
    Let’s define the wish list modifying functions first. In `script.lua`, add the
    following code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现一个功能齐全的目的地愿望清单，我们需要添加地点到愿望清单的方法、标记地点为已访问以及检查愿望清单的状态。让我们首先定义愿望清单修改函数。在 `script.lua`
    中添加以下代码：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `wish` function takes a variable number of arguments, adds them to the `places`
    map as keys, and sets their values as `false` to indicate an unvisited state.
    The `went` function is similar and marks its arguments as visited.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`wish` 函数接受可变数量的参数，将它们作为键添加到 `places` 映射中，并将它们的值设置为 `false` 以指示未访问状态。`went`
    函数类似，它将参数标记为已访问。'
- en: 'The colon operator (`:`) is a syntax sugar to pass the table as the `self`
    parameter to the function. For example, our declaration of the `wish` function
    is equivalent to the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号运算符 (`:`) 是一种语法糖，用于将表作为 `self` 参数传递给函数。例如，我们的 `wish` 函数声明等同于以下内容：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, `self` will be the table referenced to call the `wish` method. This `self`
    argument is how most OOP languages work. C++ hides it from you and passes a `this`
    pointer to the compiled member methods. Python needs `self` as the first argument
    explicitly in member function definitions, with no syntax sugar available. But
    when calling the Python member functions, you do not need to pass `self` explicitly.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`self` 将是调用 `wish` 方法的引用表。这个 `self` 参数是大多数面向对象语言的工作方式。C++ 将它隐藏起来，并将 `this`
    指针传递给编译后的成员方法。Python 需要在成员函数定义中显式使用 `self` 作为第一个参数，没有语法糖可用。但是，在调用 Python 成员函数时，你不需要显式传递
    `self`。
- en: 'Next, implement the wish list query functions in `script.lua` as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `script.lua` 中实现愿望清单查询函数如下：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: These functions list visited places and unvisited places respectively.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数分别列出已访问地点和未访问地点。
- en: Testing it out
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试它
- en: 'You can test the `Destinations` class in a Lua interpreter to make sure it
    is implemented correctly before using it in C++. Here’s an example:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 C++ 之前，你可以在 Lua 解释器中测试 `Destinations` 类以确保其正确实现。以下是一个示例：
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You can add some cities to the wish list, mark one as visited, and print out
    the list.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向愿望清单中添加一些城市，标记其中一个为已访问，并打印出清单。
- en: With a Lua class ready, we can learn how to call Lua table functions from C++.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备好 Lua 类之后，我们可以学习如何从 C++ 调用 Lua 表函数。
- en: Working with Lua table functions
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 Lua 表函数一起工作
- en: For our Lua executor, we want to call table functions with the same level of
    support as calling global functions. Similar to `call` and `vcall`, we can define
    two functions named `tcall` and `vtcall` that call table functions and return
    a single value and a list of values respectively.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的 Lua 执行器，我们希望以调用全局函数相同的支持级别调用表函数。类似于 `call` 和 `vcall`，我们可以定义两个名为 `tcall`
    和 `vtcall` 的函数，分别调用表函数并分别返回单个值和值列表。
- en: 'We need to add two more pieces of information to the new C++ member functions
    – namely, the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要向新的 C++ 成员函数中添加两条更多信息——即以下内容：
- en: The table name, which is obvious
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表名，这是显而易见的
- en: Whether we should pass the `self` argument to the table function
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否应该将 `self` 参数传递给表函数
- en: 'More on the latter point:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 关于后者的更多内容：
- en: When the table function does not refer `self` and is used like C++ static member
    functions, we do not need to pass `self`
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当表函数不引用 `self` 并像 C++ 静态成员函数一样使用时，我们不需要传递 `self`
- en: When the table function refers `self` and is used like C++ member functions,
    we need to pass `self`
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当表函数引用 `self` 并像 C++ 成员函数一样使用时，我们需要传递 `self`
- en: Let’s implement the code to reinforce what we have just talked about.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现代码来巩固我们刚刚讨论的内容。
- en: Implementing table function support
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现表函数支持
- en: 'In `LuaExecutor.h`, add the following declarations:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `LuaExecutor.h` 中添加以下声明：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`table` is the table name. `function` is the function name, which is a key
    in the table. `shouldPassSelf` denotes whether we should pass the table as the
    first argument to the table function. `params` is a list of function arguments.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`table` 是表名。`function` 是函数名，它是表中的一个键。`shouldPassSelf` 表示我们是否应该将表作为第一个参数传递给表函数。`params`
    是函数参数的列表。'
- en: 'Next, let’s code the `tcall` function in `LuaExecutor.h` as follows; note that
    the parameter list has been omitted to save space:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在 `LuaExecutor.h` 中按照以下方式编写 `tcall` 函数；请注意，参数列表已被省略以节省空间：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the previous listing, it’s doing six steps separated by newlines, as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，它通过换行符分隔执行了六个步骤，如下所示：
- en: It gets a global table and pushes it onto the stack.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它获取一个全局表并将其推入栈中。
- en: It pushes the table function onto the stack. We are using the `lua_getfield`
    shortcut.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将表函数推入栈中。我们使用了 `lua_getfield` 快捷方式。
- en: It pushes the table reference onto the stack again, if `shouldPassSelf` is `true`.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `shouldPassSelf` 为 `true`，则再次将表引用推入栈中。
- en: It pushes the remaining function arguments.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它推入剩余的函数参数。
- en: It calls the table function. Pay attention to the number of parameters passed.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它调用表函数。请注意传递的参数数量。
- en: It pops the table function result, pops the table reference pushed in *step
    1*, and returns the function result.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它弹出表函数的结果，弹出在 *步骤 1* 中推入的表引用，并返回函数结果。
- en: If you have done your homework for the previous chapter, you can insert `dumpStack();`
    at the newlines and see how the Lua stack changes.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经完成了上一章的作业，你可以在新行中插入 `dumpStack();` 来查看 Lua 栈如何变化。
- en: Take a moment to digest the `vcall` implementation. And now, you need to implement
    `vtcall` on your own.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细消化一下 `vcall` 的实现。现在，你需要自己实现 `vtcall`。
- en: Tips
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Reference `vcall` and `tcall`. Pay special attention to getting the count of
    returned values and where you should put `int stackSz =` `lua_gettop(L);`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 参考 `vcall` 和 `tcall`。请注意获取返回值的数量以及你应该在哪里放置 `int stackSz = lua_gettop(L);`。
- en: You can test if you have implemented `vtcall` correctly with the test code that
    follows.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用下面的测试代码来测试你是否正确实现了 `vtcall`。
- en: Testing it out
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试它
- en: 'We will work with the Lua `Destinations` class in C++. In `main.cpp`, replace
    the test code with the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 C++ 中使用 Lua 的 `Destinations` 类。在 `main.cpp` 中，用以下代码替换测试代码：
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This is doing the same thing as when we tested `Destinations` in the interactive
    Lua interpreter. An explanation for this is provided here:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在交互式 Lua 解释器中测试 `Destinations` 时所做的是同一件事。对此的解释如下：
- en: It creates an instance of the class and stores the object in the `dst` global
    variable. In the `lua->tcall` invocation we set `shouldPassSelf` as `false`.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它创建了一个类的实例并将对象存储在 `dst` 全局变量中。在 `lua->tcall` 调用中，我们将 `shouldPassSelf` 设置为 `false`。
- en: It adds three cities to the wish list of `dst`. From now on, we are working
    with `dst` and are passing the instance as a `self` argument to the table functions.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将三个城市添加到 `dst` 的愿望清单中。从现在起，我们正在使用 `dst` 并将实例作为 `self` 参数传递给表函数。
- en: It marks `Paris` as `visited`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将 `Paris` 标记为已访问。
- en: It gets a list of visited cities.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它获取已访问城市的列表。
- en: It gets a list of unvisited cities.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它获取未访问城市的列表。
- en: 'Add the following lines to print the `visited` and `unvisited` lists:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下行以打印 `visited` 和 `unvisited` 列表：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Compile and run the code. If you have done everything correctly, you should
    see an output as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行代码。如果你一切都做得正确，你应该会看到以下输出：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Congratulations! You have implemented in C++ a mechanism to call Lua table functions.
    This is by far the most complex logic we have learned!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经在 C++ 中实现了一个调用 Lua 表格函数的机制。这到目前为止是我们学过的最复杂的逻辑！
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned how to work with Lua tables in C++. We also touched
    on OOP in Lua and how it differs from that in C++.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在 C++ 中使用 Lua 表格。我们还简要介绍了 Lua 中的面向对象编程（OOP）以及它与 C++ 中的 OOP 的不同之处。
- en: We also explored some design decisions and why `LuaExecutor` is implemented
    in the way it is. It is designed to learn how to integrate Lua with C++, with
    a structure that can be broken down into chapters.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了某些设计决策以及为什么 `LuaExecutor` 以这种方式实现。它是为了学习如何将 Lua 与 C++ 集成，具有可以分解为章节的结构。
- en: By now, you can use `LuaExecutor` to call most Lua scripts, although it has
    some limitations. For example, we do not support passing another table, except
    `self`, as a parameter to a function. You can try to implement such a function
    on your own, but it is likely not a good idea. It is better to keep the communication
    between Lua and C++ simple.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可以使用 `LuaExecutor` 调用大多数 Lua 脚本，尽管它有一些限制。例如，我们不支持将另一个表格（除了 `self`）作为参数传递给函数。你可以尝试自己实现这样的函数，但这可能不是一个好主意。最好是保持
    Lua 和 C++ 之间的通信简单。
- en: Take your time to experiment and practice what we have learned. The focus so
    far is on how to call Lua code from C++. In the next chapter, we will start to
    learn how to call C++ code from Lua.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 慢慢来，实验和实践我们所学的。到目前为止，重点是学习如何从 C++ 调用 Lua 代码。在下一章中，我们将开始学习如何从 Lua 调用 C++ 代码。
- en: Exercises
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Rewrite the string key overload version of `LuaExecutor::getTable` and `LuaExecutor::setTable`.
    Use the `lua_getfield` and `lua_setfield` Lua library functions. You can use the
    same test code in this chapter to test whether you have implemented them correctly.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新编写 `LuaExecutor::getTable` 和 `LuaExecutor::setTable` 的字符串键重载版本。使用 Lua 库函数
    `lua_getfield` 和 `lua_setfield`。你可以使用本章中的相同测试代码来测试你是否正确实现了它们。
- en: Implement `LuaExecutor::vtcall`. You should have already done so whether you
    have reached this point.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `LuaExecutor::vtcall`。无论你是否已经到达这个阶段，你都应该已经做到了。
- en: Part 3 – Calling C++ from Lua
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分 - 从 Lua 调用 C++
- en: With your knowledge of calling Lua from C++, in this part, you will continue
    to learn how to call C++ from Lua.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在你掌握了从 C++ 调用 Lua 的知识后，在这一部分，你将继续学习如何从 Lua 调用 C++。
- en: You will start by learning how to implement and export a C++ function that can
    be called from Lua scripts. Then, the complexity will increase step by step. You
    will export a C++ class as a Lua module and improve the process of how it is exported.
    Finally, you will have a general module exporter that can help you to export any
    C++ class to Lua.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你将首先学习如何实现和导出一个可以从 Lua 脚本中调用的 C++ 函数。然后，复杂性将逐步增加。你将导出一个 C++ 类作为 Lua 模块，并改进其导出过程。最后，你将拥有一个通用的模块导出器，可以帮助你导出任何
    C++ 类到 Lua。
- en: 'This part comprises the following chapters:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '*Chapter 6*, *How to Call C++ from Lua*'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 6 章*，*如何从 Lua 调用 C++*'
- en: '*Chapter 7*, *Working with C++ Types*'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 7 章*，*处理 C++ 类型*'
- en: '*Chapter 8*, *Abstracting a C++ Type Exporter*'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 8 章*，*抽象 C++ 类型导出器*'
