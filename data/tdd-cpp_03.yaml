- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: The TDD Process
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD 流程
- en: The first two chapters have introduced you to the TDD process by showing you
    the steps involved. You have seen build failures when declaring multiple tests.
    You have seen what can happen when we get ahead of ourselves and write code that
    isn’t needed yet. That was a small example with a test result, but it still showed
    how easy it is to sometimes let code slip into a project before there are tests
    to support the code. And you also saw how the code starts out with a simple or
    partial implementation, gets working first, and then is enhanced.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 前两章通过展示涉及步骤向您介绍了 TDD 流程。您在声明多个测试时看到了构建失败。您看到了当我们提前编写尚未需要的代码时可能发生的情况。这是一个带有测试结果的小例子，但它仍然展示了有时代码在没有测试支持的情况下就滑入项目的容易性。您还看到了代码从简单或部分实现开始，先使其工作，然后进行增强。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中将涵盖以下主题：
- en: How build failures come first and should be seen as part of the process
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建失败为何先出现，以及应将其视为流程的一部分
- en: Why you should write only enough code to pass your tests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么你应该只编写足够通过测试的代码
- en: How to enhance a test and get another pass
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何增强测试并获得另一次通过
- en: This chapter will begin by introducing you to the TDD process. For a more detailed
    walkthrough with more code, refer to [*Chapter 10*](B18567_10.xhtml#_idTextAnchor096),
    *The TDD Process in Depth*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将首先向您介绍 TDD 流程。要获取更详细的代码演示，请参阅[*第 10 章*](B18567_10.xhtml#_idTextAnchor096)，*深入探讨
    TDD 流程*。
- en: Now, it’s time to begin learning about the TDD process in a more deliberate
    manner.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候更刻意地学习 TDD 流程了。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All code in this chapter uses standard C++ that builds on any modern C++ 17
    or later compiler and standard library. The code is based on and continues from
    the previous chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有代码都使用标准 C++，它基于任何现代 C++ 17 或更高版本编译器和标准库构建。代码基于上一章并继续发展。
- en: 'You can find all the code for this chapter at the following GitHub repository:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下 GitHub 仓库找到本章的所有代码：
- en: '[https://github.com/PacktPublishing/Test-Driven-Development-with-CPP](https://github.com/PacktPublishing/Test-Driven-Development-with-CPP)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Test-Driven-Development-with-CPP](https://github.com/PacktPublishing/Test-Driven-Development-with-CPP)'
- en: Build failures come first
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建失败先出现
- en: In the previous chapter, you saw how the first step to getting multiple tests
    to run was to write multiple tests. This caused a build failure. When you’re programming,
    it’s common to write code that doesn’t build at first. These are normally considered
    mistakes or errors that need to be fixed right away. And gradually, most developers
    learn to anticipate build errors and avoid them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您看到了要使多个测试运行起来的第一步是编写多个测试。这导致了构建失败。在编程时，编写一开始就无法构建的代码是很常见的。这些通常被认为是需要立即修复的错误或错误。随着时间的推移，大多数开发者学会了预测构建错误并避免它们。
- en: When following TDD, I want to encourage you to stop avoiding build errors, because
    the way to avoid build errors usually means that you work on enabling a new feature
    or making changes to code before you try to use the new feature or updated code.
    This means that you’re making changes while focused on the details and it is easy
    to overlook bigger issues, such as how easy it will be to use the new feature
    or updated code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循 TDD 的过程中，我想鼓励你们停止避免构建错误，因为避免构建错误的方法通常意味着你在尝试使用新功能或更新后的代码之前，先工作于启用新功能或修改代码。这意味着你在关注细节的同时进行更改，很容易忽略更大的问题，例如使用新功能或更新代码的难易程度。
- en: 'Instead, start out by writing code in the way that you think it should be used.
    That’s what was done with the tests. I showed you in the previous chapter that
    the end result of adding another test should look like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，首先以你认为它应该被使用的方式编写代码。这就是测试所做的那样。我在上一章中向您展示了添加另一个测试的最终结果应该看起来像这样：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The project was built and was not completed due to errors. This lets us know
    what needed to be fixed. But before making the changes, I showed what we really
    wanted the tests to look like:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于错误，项目被构建但未完成。这让我们知道需要修复什么。但在进行更改之前，我展示了我们真正希望测试看起来像什么：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Changes were made to enable multiple tests only once we had a clear idea of
    what the tests should look like. Had I not taken this approach, it’s possible
    that some other solution would have been found to name the tests. It might have
    even worked. But would it have been as easy to use? Would we be able to simply
    declare a second `TEST` like the code showed and give each a name right away?
    I don’t know.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当我们对测试应该是什么样子有一个清晰的想法后，才会对测试进行修改。如果我没有采取这种做法，可能就会找到其他方法来命名测试。甚至可能有效。但使用起来会那么方便吗？我们能否像代码所示那样简单地声明第二个`TEST`，并立即为每个测试命名？我不知道。
- en: But I do know that there have been many times when I did not follow this advice
    and ended up with a solution that I did not like. I had to go back and redo the
    work until I was happy with the result. Had I started with the result that I wanted
    in the first place, then I would have made sure to write code that directly led
    to that result.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 但我知道，有很多次我没有遵循这个建议，结果得到了一个我不喜欢的解决方案。我不得不回去重新做工作，直到我对结果满意为止。如果一开始我就从想要的结果开始，那么我就会确保编写直接导致那个结果的代码。
- en: All of this is really just a shift in focus. Instead of diving into the detailed
    design of what you are coding, take a step back and first write test code to use
    what you intend to make.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些实际上只是关注点的转移。与其深入到你正在编写的代码的详细设计，不如退一步，首先编写测试代码来使用你打算制作的内容。
- en: In other words, *let the tests drive the design*. This is the essence of TDD.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，*让测试驱动设计*。这是TDD的本质。
- en: The code you write will not build yet because it relies on other code that doesn’t
    exist, but that’s OK because it gives you a direction that you’ll be happy about.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你写的代码还不能构建，因为它依赖于其他不存在的代码，但没关系，因为这为你指明了方向，你会对此感到高兴。
- en: In a way, writing code from this user point of view gives you a goal and makes
    that goal real before you even start. Don’t settle for a vague idea of what you
    want. Take the time to write the code as you want it to be used first, build the
    project, and then work to fix the build errors.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，从用户的角度编写代码为你设定了一个目标，在你甚至开始之前就使这个目标变得真实。不要满足于对想要的东西有一个模糊的想法。先花时间编写你希望它如何使用的代码，构建项目，然后努力修复构建错误。
- en: Is it really necessary to try building your project when you know it will fail
    to build? This is a shortcut that I’ll take sometimes, especially when the build
    takes a long time or when the build failure is obvious. I mean, if I call a method
    that doesn’t exist yet, I’ll often write the method next without building. I know
    it will fail to build and what needs to be done to fix it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 知道你的项目无法构建时，真的有必要尝试构建它吗？这是一个我有时会采取的捷径，尤其是在构建需要很长时间或构建失败很明显时。我的意思是，如果我现在调用一个还不存在的函数，我通常会先编写这个函数，而不进行构建。我知道它将无法构建，并且我知道需要做什么来修复它。
- en: But there are times when this shortcut can lead to problems, such as when working
    with overloaded methods or template methods. You might write code to use a new
    overload that doesn’t yet exist and think that the code will fail to build, when
    what actually happens is that the compiler will choose one of the existing overloaded
    versions to make the call. This is also the case with templates.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时这种捷径可能会导致问题，比如在处理重载方法或模板方法时。你可能会编写代码来使用一个尚未存在的新的重载版本，并认为代码将无法构建，而实际上编译器会选择现有的某个重载版本来执行调用。模板也是这样。
- en: You can find a good example of an expected build failure that actually built
    with no warnings or errors in [*Chapter 5*](B18567_05.xhtml#_idTextAnchor045),
    *Adding More Confirm Types*. The result was not what was wanted and building first
    allowed the problem to be caught right away.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[*第五章*](B18567_05.xhtml#_idTextAnchor045)中找到一个很好的例子，即预期的构建失败实际上构建了，没有任何警告或错误，*添加更多确认类型*。结果并不是想要的，而先进行构建允许立即发现问题。
- en: The point is that building your project will let you know about these situations.
    If you expect the build to fail but it compiles anyway, then you know that the
    compiler was able to figure out a way to make the code work that maybe you weren’t
    expecting. This can lead to valuable insight. Because when you add the intended
    new overload, it’s possible that existing code will start calling your new method
    too. It’s always better to be aware of this situation, rather than being surprised
    by a hard-to-find bug.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是构建你的项目会让你了解这些情况。如果你预期构建会失败，但编译器仍然能够编译，那么你就知道编译器找到了一种可能你没有预料到的方法来使代码工作。这可能会带来宝贵的见解。因为当你添加预期的新的重载时，现有的代码可能会开始调用你的新方法。总是最好意识到这种情况，而不是被难以找到的bug所惊吓。
- en: When you’re still working on getting your tests to build, you don’t need to
    worry about passing. In fact, it’s easier if you let the tests fail at first.
    Focus on the intended usage instead of getting passing tests.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当你还在努力使测试构建时，你不需要担心通过。事实上，如果最初让测试失败，这会更容易。专注于预期的用法，而不是获得通过测试。
- en: Once your code builds, how much should you implement? That’s the topic of the
    next section. The main idea is to do as little as possible.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的代码构建成功，你应该实现多少？这是下一节的主题。主要思想是尽可能少做。
- en: Do only what is needed to pass
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只做通过测试所必需的。
- en: When writing code, it’s easy to think of all the possibilities of how a method
    might be used, for example, and to write code to handle each possibility right
    away. This gets easier with experience and is normally viewed as a good way to
    write robust code without forgetting to handle different use cases or error conditions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时，很容易想到一个方法可能被使用的所有可能性，例如，并立即编写代码来处理每种可能性。随着经验的积累，这会变得更容易，通常被认为是一种编写健壮代码的好方法，不会忘记处理不同的用例或错误条件。
- en: I urge you to scale back your eagerness to write all this at once. Instead,
    do only what is needed to pass a test. Then, as you think of other use cases,
    write a test for each, before extending your code to handle them. The same applies
    to error cases. As you think of some new error handling that should be added,
    write a test that will cause that error condition to arise before handling it
    in your code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我敦促你减少一次性编写所有这些内容的热情。相反，只做通过测试所必需的。然后，当你想到其他用例时，为每个用例编写一个测试，在扩展你的代码来处理它们之前。同样适用于错误情况。当你想到应该添加的一些新错误处理时，在代码中处理之前，先编写一个会导致该错误条件出现的测试。
- en: 'To see how this is done, let’s extend the test library to allow for expected
    exceptions. We have two test cases right now:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这是如何完成的，让我们扩展测试库以允许预期异常。我们目前有两个测试用例：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first makes sure that a test can be created. It does nothing and passes.
    The second test throws an exception. It actually just throws a simple int value
    of `1`. This causes the test to fail. It might seem demotivating to see one or
    more of your tests fail. But remember, we just got the test to build and that
    is an accomplishment you should feel good about.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个确保可以创建一个测试。它什么都不做并通过。第二个测试抛出一个异常。它实际上只是抛出一个简单的整数值`1`。这导致测试失败。看到你的一个或多个测试失败可能会让你感到泄气。但记住，我们刚刚使测试构建成功，这是你应该感到自豪的成就。
- en: When we initially added the second test in the previous chapter, the goal was
    to make sure that multiple tests could be added. And the int was thrown to make
    sure that any exceptions would be treated as a failure. We weren’t yet ready to
    fully handle thrown exceptions. That’s what we’re going to do now.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在上一章最初添加第二个测试时，目标是确保可以添加多个测试。我们抛出一个整数是为了确保任何异常都会被视为失败。我们当时还没有准备好完全处理抛出的异常。这正是我们现在要做的。
- en: We’re going to take the existing code that throws an exception and turns it
    into an expected exception, but we are going to follow the advice given here and
    do the absolute minimum to get this working. That means we’re not going to jump
    right into a solution that tries to throw multiple different exceptions, and we’re
    not yet going to handle the case where we think an exception should be thrown
    but it doesn’t get thrown.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把现有的抛出异常的代码转换成预期的异常，但我们将遵循这里给出的建议，只做绝对最小的工作来使它工作。这意味着我们不会立即跳入一个尝试抛出多个不同异常的解决方案，我们也不会处理我们认为应该抛出异常但未抛出的情况。
- en: Because we’re writing the testing library itself, our focus sometimes will be
    on the tests themselves. In many ways, the tests become similar to whatever project-specific
    code you’ll be working with. So, while right now we need to be careful not to
    add a bunch of tests all at once, you’ll want to be careful later not to add a
    bunch of extra code that doesn’t yet have tests all at once. You’ll see this shift
    once we get the test library to a more feature-complete version and then start
    using it to create a logging library. At that point, the guidance will apply to
    the logging library and we’ll want to avoid adding extra logic to handle different
    logging scenarios without first adding tests to exercise those scenarios.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在编写测试库本身，我们的关注点有时会集中在测试本身上。在许多方面，测试变得与你要工作的任何特定项目代码相似。因此，虽然现在我们需要小心不要一次性添加大量测试，但稍后你将需要小心不要一次性添加大量尚未测试的额外代码。一旦我们将测试库发展到更完整的版本并开始使用它来创建日志库，你就会看到这种转变。到那时，这些指导原则将适用于日志库，我们希望避免在没有首先为这些场景添加测试的情况下添加处理不同日志场景的额外逻辑。
- en: Starting with the end usage in mind, we need to think about what the `TEST`
    macro usage should look like when there is an expected exception. The main thing
    we need to communicate is the type of exception that we expect to be thrown.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 从最终用途出发，我们需要考虑当存在预期异常时，`TEST` 宏的使用应该是什么样子。我们需要传达的主要信息是我们期望抛出的异常类型。
- en: There will only be one type of exception needed. Even if some code under test
    throws multiple exception types, we don’t want to list more than one exception
    type per test. That’s because, while it’s okay for code to check different error
    conditions and throw a different exception type for each error, each test itself
    should be written to only test one of these error conditions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 只需要一种类型的异常。即使测试中的某些代码抛出多个异常类型，我们也不希望在每次测试中列出超过一个异常类型。这是因为，虽然代码检查不同的错误条件并为每个错误抛出不同的异常类型是可以接受的，但每个测试本身应该只测试这些错误条件中的一个。
- en: If you have a method that can sometimes throw different exceptions, then you
    should have a test for each condition that leads to each exception. Each test
    should be specific and always either lead to a single exception or no exception
    at all. And if a test expects an exception to be thrown, then that exception should
    always be thrown in order for the test to be considered to pass.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个有时会抛出不同异常的方法，那么你应该为导致每个异常的条件编写一个测试。每个测试都应该具体，并且始终导致单个异常或没有任何异常。如果一个测试期望抛出异常，那么为了使测试被认为是通过的，该异常应该始终被抛出。
- en: 'Later in this chapter, we’ll get to the more complicated situation of not catching
    an exception when one is expected. For now, we want to do only what is needed.
    Here is what the new usage looks like:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将讨论一个更复杂的情况，即预期抛出异常但没有捕获到。现在，我们只想做必要的操作。以下是新用法的外观：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first thing you’ll notice is that we need a new macro in order to pass the
    type of exception that is expected to be thrown. I’m calling it `TEST_EX`, which
    stands for test exception. Right after the name of the test is a new macro argument
    for the type of exception that is expected. In this case, it’s an `int` because
    the code throws `1`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先会注意到，我们需要一个新的宏来传递预期抛出的异常类型。我将其命名为 `TEST_EX`，代表测试异常。在测试名称之后，有一个新的宏参数用于指定预期抛出的异常类型。在这种情况下，它是一个
    `int`，因为代码抛出了 `1`。
- en: '*Why do we need a new macro?*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们为什么需要一个新宏？*'
- en: Because macros are not really functions. They just work with simple text replacement.
    We want to be able to tell the difference between a test that doesn’t expect any
    exceptions to be thrown versus a test that does expect an exception to be thrown.
    Macros don’t have the ability to be overloaded like a method or function, with
    each different version declared with different parameters. A macro needs to be
    written with a specific number of parameters in mind.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因为宏并不是真正的函数。它们只是进行简单的文本替换。我们希望能够区分一个不期望抛出任何异常的测试与一个期望抛出异常的测试。宏没有像方法或函数那样重载的能力，每个不同版本都使用不同的参数声明。一个宏需要根据特定的参数数量来编写。
- en: When a test doesn’t expect any exception to be thrown, it doesn’t make any sense
    to pass some placeholder value for the exception type. It’s better to have one
    macro that takes just the name and means that no exception is expected, and another
    macro that takes a name and an exception type.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个测试不期望抛出任何异常时，传递一个占位符值给异常类型是没有意义的。最好有一个只接受名称的宏，表示不期望任何异常，另一个宏接受名称和异常类型。
- en: This is a real example of where the design needs to compromise. Ideally, there
    would not be a need for a new macro. We’re doing the best with what the language
    gives us here. Macros are an old technology with their own rules.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个设计需要妥协的真实例子。理想情况下，我们不需要一个新的宏。我们在这里尽我们所能利用语言提供的内容。宏是一种老技术，有自己的规则。
- en: Going back to the TDD process, you can see that we’re again starting with the
    end usage in mind. Is this solution acceptable? It doesn’t exist yet. But if it
    did, would it feel natural? I think so.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 回到TDD（测试驱动开发）流程，你会发现我们再次以最终用途为出发点。这个解决方案是否可接受？它目前还不存在。但如果它存在，会感觉自然吗？我认为会的。
- en: There’s no real point in trying to build right now. This is a time when we’ll
    take a shortcut and skip the actual build. In fact, in my editor, the `int` type
    is already highlighted as an error.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试构建并没有真正的意义。这是一个我们会走捷径并跳过实际构建的过程。实际上，在我的编辑器中，`int`类型已经被标记为错误。
- en: It complains that we’re using a keyword wrongly and it might look strange to
    you as well. You can’t just pass types, whether they are keywords or not, as method
    arguments. Remember that a macro is not really a method though. Once the macro
    has been fully expanded, the compiler will never see this strange usage of `int`.
    You can pass types as template parameters. But macros don’t support template parameters
    either.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 它抱怨我们错误地使用了关键字，这对你来说可能看起来也很奇怪。你不能简单地将类型（无论它们是否是关键字）作为方法参数传递。记住，尽管宏不是真正的方法，一旦宏被完全展开，编译器将永远不会看到这种奇怪的`int`使用方式。你可以将类型作为模板参数传递。但是，宏也不支持模板参数。
- en: Now that we have the intended usage, the next step is to think about the solution
    that will enable this usage. We don’t want the test author to have to write a
    `try/catch` block for the expected exception. That’s what the test library should
    do. This means we’ll need a new method inside the `Test` class that does have
    a `try/catch` block. This method can catch the expected exception and ignore it
    for now. We ignore it because we are expecting the exception, which means if we
    catch it, then the test should pass. If we let the expected exception continue
    outside of the test, then the `runTests` function will catch it and report a failure
    due to an unexpected exception.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了预期的使用方式，下一步是考虑实现这种使用的解决方案。我们不希望测试作者必须为期望的异常编写`try/catch`块。这正是测试库应该做的。这意味着我们需要在`Test`类中添加一个新的方法，该方法确实包含`try/catch`块。这个方法可以捕获期望的异常并暂时忽略它。我们忽略它是因为我们期望异常，这意味着如果我们捕获它，那么测试应该通过。如果我们让期望的异常在测试之外继续，那么`runTests`函数将捕获它并报告由于意外异常而失败的错误。
- en: We want to keep the catch all inside `runTests` because that’s how we detect
    unexpected exceptions. For unexpected exceptions, we don’t know what type to catch
    because we want to be ready to catch anything.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将捕获所有异常的操作放在`runTests`函数中，因为这是我们检测意外异常的方式。对于意外异常，我们不知道要捕获什么类型，因为我们希望准备好捕获任何东西。
- en: Here, we do know what type of exception to expect because it is being provided
    in the `TEST_EX` macro. We can have the new method in the `Test` class catch the
    expected exception. Let’s call this new method `runEx`. All the `runEx` method
    needs to do is look for the expected exception and ignore it. If the test throws
    something else, then `runEx` won’t catch it. But the `runTests` function will
    be sure to catch it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们知道期望哪种类型的异常，因为它是通过`TEST_EX`宏提供的。我们可以在`Test`类的新方法中捕获期望的异常。让我们把这个新方法叫做`runEx`。`runEx`方法需要做的只是查找期望的异常并忽略它。如果测试抛出了其他东西，`runEx`将不会捕获它。但`runTests`函数一定会捕获它。
- en: 'Let’s look at some code to understand better. Here is the `TEST_EX` macro in
    `Test.h`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些代码来更好地理解。这是`Test.h`中的`TEST_EX`宏：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can see that all `runEx` does is call the original `run` method inside of
    a `try/catch` block that catches the `exceptionType` specified. In our specific
    case, we will catch an int and ignore it. All this does is wrap up the `run` method
    with a `try/catch` block so that the test author doesn’t have to.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，`runEx` 所做的只是在一个捕获了指定 `exceptionType` 的 `try/catch` 块中调用原始的 `run` 方法。在我们的特定情况下，我们将捕获一个整数并忽略它。这仅仅是将
    `run` 方法包裹在一个 `try/catch` 块中，这样测试作者就不必这样做。
- en: The `runEx` method is also a *virtual override*. That’s because the `runTests`
    function needs to call `runEx` instead of calling `run` directly. Only then will
    expected exceptions be caught. We don’t want `runTests` to sometimes call `runEx`
    for tests with an expected exception and to call `run` for those tests without
    an expected exception. It will be better if `runTests` always calls `runEx`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`runEx` 方法也是一个 *虚拟覆盖*。这是因为 `runTests` 函数需要调用 `runEx` 而不是直接调用 `run`。只有这样，预期的异常才能被捕获。我们不希望
    `runTests` 有时为期望异常的测试调用 `runEx`，而为没有期望异常的测试调用 `run`。如果 `runTests` 总是调用 `runEx`
    会更好。'
- en: 'This means we need to have a default implementation of `runEx` that just calls
    `run` without a `try/catch` block. We can do that in the `TestBase` class, which
    will need to declare the virtual `runEx` method anyway. The `run` and `runEx`
    methods look like this inside `TestBase`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要一个默认的 `runEx` 实现来调用 `run` 而不带 `try/catch` 块。我们可以在 `TestBase` 类中这样做，因为这个类无论如何都需要声明虚拟的
    `runEx` 方法。在 `TestBase` 中，`run` 和 `runEx` 方法看起来是这样的：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `TEST_EX` macro that expects an exception will override `runEx` to catch
    the exception, and the `TEST` macro that does not expect an exception will use
    the base `runEx` class implementation, which just calls `run` directly.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 期望异常的 `TEST_EX` 宏将覆盖 `runEx` 以捕获异常，而不期望异常的 `TEST` 宏将使用基类 `runEx` 的实现，它直接调用 `run`。
- en: 'Now, we need to modify the `runTests` function to call `runEx` instead of `run`,
    like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要修改 `runTests` 函数，使其调用 `runEx` 而不是 `run`，如下所示：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Only the first half of the `runTests` function is shown here. The rest of the
    function remains unchanged. It’s really just the single line of code in the `try`
    block that now calls `runEx` that needed to be updated.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只显示了 `runTests` 函数的前半部分。函数的其余部分保持不变。实际上只需要更新 `try` 块中现在调用 `runEx` 的那行代码。
- en: 'We can now build the project and run it to see how the tests perform. The output
    looks like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以构建项目并运行它来查看测试的表现。输出如下：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The second test used to fail but now it passes because the exception is expected.
    We also followed the guidance for this section, which is to do only what is needed
    to pass. The next step in the TDD process is to enhance a test and get another
    pass.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试之前曾经失败，但现在它通过了，因为异常是预期的。我们还遵循了本节的指导原则，即只做通过测试所需的最少工作。TDD 流程的下一步是增强测试并获得另一个通过。
- en: Enhancing a test and getting another pass
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强测试并获得另一个通过
- en: What happens if a test that expects an exception does not see the exception?
    That should be a failure, and we’ll handle it next. This situation is a little
    different because the next *pass* is really going to be a *failure*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个期望异常的测试没有看到异常会发生什么？这应该是一个失败，我们将在下一部分处理它。这种情况有点不同，因为下一个 *通过* 实际上将会是一个 *失败*。
- en: When you’re writing tests and following the guidance to first do the minimum
    amount to get a first passing result and then enhancing the test to get another
    pass, you’ll be focused on passing. That’s good because we want all the tests
    to eventually pass.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写测试并遵循先做最少的工作以获得第一个通过结果，然后增强测试以获得另一个通过时，你将专注于通过。这是好的，因为我们希望所有测试最终都能通过。
- en: Any failure should almost always be a failure. It doesn’t usually make sense
    to have *expected failures* in your tests. What we’re about to do here is a bit
    out of the ordinary and it’s because we’re still developing the test library itself.
    We need to make sure that a missing exception that was expected and did not occur
    is able to be caught as a failed test. We then want to treat that failed test
    as a pass because we’re testing the ability of the test library to be able to
    catch these failures.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 任何失败几乎总是失败。在测试中拥有 *预期失败* 通常没有意义。我们接下来要做的事情有点不同寻常，这是因为我们仍在开发测试库本身。我们需要确保预期的缺失异常没有发生时能够被捕获为失败的测试。然后我们希望将这个失败的测试视为通过，因为我们正在测试测试库能够捕获这些失败的能力。
- en: 'Right now, we have a hole in the test library because adding a third test that
    expects an int to be thrown but never actually throws an int is seen as a passing
    test. In other words, the tests in this set all pass:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们在测试库中有一个漏洞，因为添加了一个预期抛出int但从未实际抛出int的第三个测试被视为通过测试。换句话说，这个集合中的所有测试都通过了：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Building this works okay and running it shows that all three tests pass:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 构建这个没有问题，运行它显示所有三个测试都通过：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is not what we want. The third test should fail because it expected an
    int to be thrown but that did not happen. But that also goes against the goal
    that all tests should pass. There is no way to have an expected failure. Sure,
    we might be able to add this concept into the testing library, but that would
    add extra complexity.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是我们想要的。第三个测试应该失败，因为它预期抛出一个int，但并没有发生。但这也违反了所有测试都应该通过的目标。没有办法有一个预期的失败。当然，我们可能能够将这个概念添加到测试库中，但这会增加额外的复杂性。
- en: If we were to add the ability for a test to fail but still be treated as if
    it passed, then what would happen if the test failed for some unexpected reason?
    It would be easy for a bad test to be written that fails for multiple reasons
    but actually gets reported as a pass because the failure was expected.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们添加测试失败但仍然被视为通过的能力，那么如果测试由于某些意外原因失败会发生什么？很容易编写一个坏测试，由于多个原因失败，但实际上报告为通过，因为失败是预期的。
- en: While writing this, I initially decided not to add the ability to have expected
    failures. My reasoning was that all tests should pass. But that left us in a bind,
    because how else can we verify that the test library itself can properly detect
    missing expected exceptions?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在写这篇文档的时候，我最初决定不添加预期失败的能力。我的理由是所有测试都应该通过。但这样我们就陷入了困境，因为否则我们如何验证测试库本身是否能够正确地检测到缺失的预期异常？
- en: We need to close the hole exposed by the third test.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要关闭第三次测试暴露的漏洞。
- en: There is no good answer to this dilemma. So, what I’m going to do is get this
    new test to fail and then add the ability to treat a failure as a success. I don’t
    like the alternatives, which is to leave the test in the code but comment it out
    so that it wouldn’t actually run, or to delete the third test entirely.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个困境没有好的答案。所以，我将做的是让这个新的测试失败，然后添加将失败视为成功的能力。我不喜欢其他选择，比如在代码中留下测试但将其注释掉，这样它实际上就不会运行，或者完全删除第三个测试。
- en: What finally convinced me to add support for successful failing tests was the
    idea that everything should be tested, especially big things, such as the ability
    to make sure that an expected exception is always thrown. You probably won’t need
    to use the ability to mark a test as an expected failure but if you do, then you
    will be able to do the same thing. We are in a unique situation because we need
    to test something about the test library itself.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最终说服我添加对成功失败测试支持的想法是，一切都应该被测试，特别是像确保总是抛出预期异常这样的大型功能。你可能不需要使用标记测试为预期失败的能力，但如果你需要，你将能够做同样的事情。我们处于一个独特的情况，因为我们需要测试关于测试库本身的一些东西。
- en: 'Alright, let’s get the new test to fail. The minimum amount of code needed
    for this is to return if the expected exception was caught. If the exception was
    not caught, then we throw something else. The code to update is the `TEST_EX`
    macro override of the `runEx` method, like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们让新的测试失败。为此需要的最小代码量是在捕获到预期异常时返回。如果没有捕获到异常，那么我们抛出其他东西。需要更新的代码是`runEx`方法的`TEST_EX`宏重写，如下所示：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The rest of the macro is unchanged, so only the `runEx` override is shown here.
    We return when the expected exception is caught, which will cause the test to
    pass. And after the `try/catch` block, we throw something else that will cause
    the test to fail.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 宏的其他部分没有变化，所以这里只展示了`runEx`重写。当捕获到预期异常时，我们返回，这将导致测试通过。在`try/catch`块之后，我们抛出其他东西，这将导致测试失败。
- en: If you find it strange to see a simple int value being thrown, remember that
    our goal is to do the absolute minimum needed at this point. You would never want
    to leave code that throws something like this and we will fix that next.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得看到简单的int值被抛出很奇怪，请记住，我们的目标是做到这一点。你永远不会想留下这样的代码，我们将在下一版本中修复这个问题。
- en: 'This works and is great because it is the minimum amount needed to do what
    we want, but the result looks strange and misleading. Here is the test result
    output:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有效，也很好，因为它是我们想要做到的最低限度的需求，但结果看起来很奇怪，具有误导性。以下是测试结果输出：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can see that we got a failure but the message says `Unexpected exception
    thrown.`. This message is almost the exact opposite of what we want. We want it
    to say that an expected exception was not thrown. Let’s fix this before we continue
    turning it into an expected failure.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们遇到了失败，但消息显示为`Unexpected exception thrown.`。这个消息几乎是我们不希望看到的。我们希望它显示为“预期的异常没有被抛出”。在我们继续将其转换为预期失败之前，让我们先修复这个问题。
- en: First, we need some way for the `runTests` function to detect the difference
    between an unexpected exception and a missing exception. Right now, it just catches
    everything and treats any exception as unexpected. If we were to throw something
    special and catch it first, then that could be the signal that an exception was
    missing. And anything else that gets caught would be unexpected. OK, what should
    this special throw be?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一种方法让`runTests`函数能够区分意外异常和缺失异常。目前，它只是捕获所有异常，并将任何异常都视为意外的。如果我们抛出一个特殊的异常并首先捕获它，那么这可以成为异常缺失的信号。其他被捕获的任何东西都将被视为意外的。好的，这个特殊的抛出应该是什么？
- en: The best thing to throw is going to be something that the test library defines
    specifically for this purpose. We can define a new class just for this.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出的最好的东西将是测试库专门为此目的定义的东西。我们可以定义一个新的类来专门处理这个。
- en: 'Let’s call it `MissingException` and define it inside the `MereTDD` namespace,
    like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们称它为`MissingException`，并在`MereTDD`命名空间内定义它，如下所示：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Not only will this class signal that an expected exception was not thrown but
    it will also keep track of the type of exception that should have been thrown.
    The type will not be a real type in the sense that the C++ compiler understands
    types. It will be the text representation of that type. This actually fits well
    with the design because that’s what the `TEST_EX` macro accepts, a piece of text
    that gets substituted in the code for the actual type when the macro is expanded.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅这个类会表明预期的异常没有被抛出，它还会跟踪应该抛出的异常类型。这个类型在C++编译器理解类型的意义上，不是一个真正的类型。它将是该类型的文本表示。这实际上与设计非常吻合，因为这正是`TEST_EX`宏接受的，一段文本，当宏展开时，会在代码中替换为实际类型。
- en: 'Inside the `TEST_EX` macro implementation of the `runEx` method, we can change
    it to look like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在`runEx`方法的`TEST_EX`宏实现中，我们可以将其更改为如下所示：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Instead of throwing an int like before, the code now throws a `MissingException`.
    Notice how it uses another feature of macros, which is the ability to turn a macro
    parameter into a string literal with the `#` operator. By placing `#` before `exceptionType`,
    it will turn the `int` provided in the `TEST_EX` macro usage into an `"int"` string
    literal, which can be used to initialize the `MissingException` with the name
    of the type of exception that is expected.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前抛出一个整数不同，现在的代码抛出了一个`MissingException`。注意它如何使用宏的另一个特性，即使用`#`运算符将宏参数转换为字符串字面量。通过在`exceptionType`前放置`#`，它将`TEST_EX`宏使用中提供的`int`转换为`"int"`字符串字面量，这样就可以用期望抛出的异常类型的名称来初始化`MissingException`。
- en: 'We’re now throwing a special type that can identify a missing exception, so
    the only piece remaining is to catch this exception type and handle it. This happens
    in the `runTests` function, like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在抛出了一个可以识别缺失异常的特殊类型，所以剩下的唯一部分就是捕获这个异常类型并处理它。这发生在`runTests`函数中，如下所示：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The order is important. We need to first try catching `MissingException` before
    catching everything else. If we do catch `MissingException`, then the code changes
    the message that gets displayed to let us know what type of exception was expected
    but not thrown.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序很重要。我们需要首先尝试捕获`MissingException`，然后再捕获其他所有异常。如果我们捕获到`MissingException`，那么代码会更改显示的消息，让我们知道期望抛出但未抛出的异常类型。
- en: 'Running the project now shows a more applicable message for the failure, like
    this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行项目会显示一个更适用于失败的更适用的消息，如下所示：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This clearly describes why the test failed. We now need to turn the failure
    into a passing test and it will be nice to keep the failure message. We’ll just
    change the status from **Failed** to **Expected failure**. Since we’re keeping
    the failure message, I have an idea for something that will make this ability
    to mark failed tests as passing a safer feature.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这清楚地描述了测试失败的原因。我们现在需要将失败转换为通过测试，并且保留失败消息会很好。我们只需将状态从**Failed**更改为**Expected
    failure**。由于我们保留了失败消息，我有一个想法，可以使将失败的测试标记为通过的功能更安全。
- en: What do I mean by a safer feature? Well, this was one of my biggest concerns
    with adding the ability to have expected failures. Once we mark a test as an expected
    failure, then it would be too easy for the test to fail for other reasons. Those
    other reasons should be treated as real failures because they were not the expected
    reason. In other words, if we just treat any failure as if a test passes, then
    what happens if a test fails for a different reason? That would be treated as
    a pass too and that would be bad. We want to mark failures as passing but only
    for expected failures.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我所说的更安全的功能是什么意思？嗯，这是我添加预期失败能力时最大的担忧之一。一旦我们将测试标记为预期失败，那么测试因其他原因失败就会变得太容易了。那些其他原因应该被视为真正的失败，因为它们不是预期的原因。换句话说，如果我们将任何失败都视为测试通过，那么如果测试因其他原因失败会怎样？这也会被视为通过，这是不好的。我们希望将失败标记为通过，但仅限于预期失败。
- en: In this particular case, if we were to just treat a failure as a pass, then
    what would happen if the test was supposed to throw an int but instead threw a
    string? That would definitely cause a failure and we need a test case for this
    too. We might as well add that test now. We don’t want to treat the throwing of
    a different exception the same as not throwing any exception at all. Both are
    failures but the tests should be specific. Anything else should cause a legitimate
    failure.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定情况下，如果我们只是将失败视为通过，那么如果测试本应抛出一个整数但反而抛出一个字符串会发生什么？这肯定会引起失败，我们还需要为这种情况添加一个测试用例。我们不妨现在就添加这个测试。我们不希望将抛出不同异常的行为与完全不抛出任何异常的行为同等对待。两者都是失败，但测试应该是具体的。任何其他情况都应导致合法的失败。
- en: 'Let’s start with the end usage in mind and explore how best to express the
    new concept. I thought about adding an expected failure message to the macro but
    that would require a new macro. And really, it would require a new macro for each
    macro we already have. We’d need to extend both the `TEST` macro and the `TEST_EX`
    macro with two new macros, such as `FAILED_TEST` and `FAILED_TEST_EX`. That doesn’t
    seem like a very good idea. What if, instead, we add a new method to the `TestBase`
    class? It should look like this when used in the new tests:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最终用途出发，探讨如何最好地表达新概念。我考虑过在宏中添加一个预期的失败消息，但这将需要一个新的宏。实际上，我们需要为每个现有的宏创建一个新的宏。我们需要扩展`TEST`宏和`TEST_EX`宏，添加两个新的宏，例如`FAILED_TEST`和`FAILED_TEST_EX`。这看起来并不是一个好主意。如果我们相反，给`TestBase`类添加一个新的方法会怎样？当在新测试中使用时，它应该看起来像这样：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Software design is all about trade-offs. We are adding the ability to have a
    failing test turn into a passing test. The cost is extra complexity. Users need
    to know that the `setExpectedFailureReason` method needs to be called inside the
    test body to enable this feature. But the benefit is that we can now test things
    in a safe manner that would not have been possible otherwise. The other thing
    to consider is that this ability to set expected failures will most likely not
    be needed outside of the test library itself.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 软件设计完全是关于权衡。我们正在添加将失败测试转换为通过测试的能力。代价是额外的复杂性。用户需要知道需要在测试体内部调用`setExpectedFailureReason`方法来启用此功能。但好处是，我们现在可以以安全的方式测试那些在其他情况下不可能测试的事情。另一件需要考虑的事情是，这种设置预期失败的能力很可能不需要在测试库之外使用。
- en: Expected failure reasons are also a little hard to get right. It’s easy to miss
    something, such as a period at the end of the failure reason. The best way I found
    to get the exact reason text is to let the test fail and then copy the reason
    from the summary description.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 预期失败的原因也有些难以正确理解。很容易遗漏一些东西，比如失败原因末尾的句号。我发现获取确切原因文本的最佳方式是让测试失败，然后从摘要描述中复制原因。
- en: Until now, we haven’t been able to have a test that specifically looks for a
    completely unexpected exception. Now, we can. And for the times when we expect
    an exception to be thrown, we can now check the two failure cases that go along
    with this, when the expected type is not thrown and when something else is thrown.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们无法有一个专门寻找完全意外异常的测试。现在我们可以了。当我们期望抛出异常时，我们现在可以检查与这种情况相关的两个失败情况，即当期望的类型没有被抛出时，以及当抛出其他类型时。
- en: 'All of this is better than the alternative of either leaving these tests out
    or commenting them out, and we can do all this without adding more macros. Of
    course, the tests won’t compile yet because we haven’t created the `setExpectedFailureReason`
    method. So, let’s add that now:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都比省略这些测试或注释掉它们的替代方案要好，而且我们可以做到这一切而不需要添加更多的宏。当然，测试现在还无法编译，因为我们还没有创建`setExpectedFailureReason`方法。所以，我们现在就添加它：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We need a new data member to hold the expected reason, which will be an empty
    string, unless set inside the test body. We need the `setExpectedFailureReason`
    method to set the expected failure reason and we also need an `expectedReason`
    getter method to retrieve the expected failure reason.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个新成员变量来保存预期的原因，它将是一个空字符串，除非在测试体内部设置。我们需要`setExpectedFailureReason`方法来设置预期的失败原因，我们还需要一个`expectedReason`获取方法来检索预期的失败原因。
- en: 'Now that we have this ability to mark tests with a specific failure reason
    that is expected, let’s look for the expected failures in the `runTests` function:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了标记测试为特定预期失败原因的能力，让我们在`runTests`函数中查找预期的失败：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can see the new test for tests that did not pass in the `else if` block.
    We first make sure that the expected reason is not empty and that it matches the
    actual failure reason. If the expected failure reason matches the actual failure
    reason, then we treat this test as a pass because of an expected failure.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到在`else if`块中为未通过测试添加的新测试。我们首先确保预期的原因不是空的，并且它与实际失败原因匹配。如果预期的失败原因与实际失败原因匹配，那么我们因为预期的失败而将这个测试视为通过。
- en: 'Building the project and running it now shows that all five tests are passing:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建项目并运行它显示所有五个测试都通过了：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can see the three new tests that have expected failures. All of these are
    passing tests and we now have an interesting ability to expect tests to fail.
    Use it wisely. It is not normal to expect tests to fail.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到有三个新的预期失败的测试。所有这些都是通过测试，我们现在有了期待测试失败的能力。要明智地使用它。期待测试失败并不正常。
- en: We still have one more scenario to consider. And I’ll be honest and say that
    I took a break for an hour or so before I thought of this. We need to make sure
    the test library covers everything we can think of because you’ll be using it
    to test your code. You need to have a high level of confidence that the test library
    itself is as bug-free as possible.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个场景需要考虑。我会坦白地说，在我想到这一点之前，我休息了一个小时左右。我们需要确保测试库覆盖了我们能想到的所有内容，因为你会用它来测试你的代码。你需要有很高的信心，即测试库本身尽可能没有错误。
- en: Here’s the case we need to handle. What if there is a test case that’s expected
    to fail for some reason but it actually passes? Right now, the test library first
    checks whether the test has passed, and if so, then it doesn’t even look to see
    whether it was supposed to have failed. If it passes, then it passes.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要处理的案例。如果有一个测试用例因为某种原因预期会失败，但实际上通过了怎么办？目前，测试库首先检查测试是否通过，如果是的话，它甚至不会查看它是否应该失败。如果通过了，那么它就通过了。
- en: But if you go to all the trouble to set an expected failure reason and the test
    passes instead, what should be the outcome? What we have is a failure that should
    have been treated as a pass that actually passed instead. Should this be a failure
    after all? A person could go dizzy thinking about these things.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你费尽周折设置了预期的失败原因，而测试却通过了，那么结果应该是什么？我们目前遇到的是一个本应被视为通过但实际上通过的失败。这最终应该算作失败吗？一个人可能会因为这些事情而感到头晕。
- en: If we treat this as a failure, then we’re back to where we started with a test
    case that we want to include but that is designed to ultimately fail. And that
    means we either have to live with a failure in the tests, ignore the scenario
    and skip the test, write the test and then comment it out so it doesn’t normally
    run, or find another solution.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这视为失败，那么我们就回到了起点，有一个我们想要包含但最终会失败的测试用例。这意味着我们不得不面对测试中的失败，忽略这个场景并跳过测试，或者写一个测试然后注释掉，这样它就不会正常运行，或者找到另一种解决方案。
- en: Living with a failure is not an option. When using TDD, you need to get all
    your tests to a passing state. It does no good to expect a failure. That’s the
    whole reason we went to all the trouble of allowing failing tests to be expected
    to fail. Then, we can call those failures passes because they were expected.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 与失败共存不是一种选择。在使用TDD时，你需要让你的所有测试都达到通过状态。期待失败没有任何好处。这就是我们费尽周折允许预期失败的测试失败的全部原因。然后，我们可以将这些失败称为通过，因为它们是预期的。
- en: Skipping a test is also not an option. If you decide something is really not
    an issue and doesn’t need to be tested, then that’s different. You don’t want
    a bunch of useless tests cluttering up your project. This seems like something
    important that we don’t want to skip, though.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过测试也不是一个选项。如果你决定某件事真的不是问题，不需要测试，那么就另当别论。你不想有一堆无用的测试让你的项目变得杂乱。尽管如此，这似乎是一个重要的内容，我们不想跳过。
- en: Writing a test and then disabling it so it doesn’t run is also a bad idea. It’s
    too easy to forget the test ever existed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个测试然后禁用它，让它不运行，也是一个坏主意。很容易忘记测试曾经存在过。
- en: We need another solution. And no, it’s not going to be to add another level
    where a passing test that should have failed in an expected way instead is treated
    as a failure, which we will then somehow mark as passing again. I’m not even sure
    how to write that sentence, so I’m going to leave it as confusing as it sounds.
    That path leads to a never-ending cycle of pass-fail-pass-fail-pass thinking.
    Too complicated.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要另一个解决方案。不，这并不是在增加一个层级，在这个层级中，一个本应按预期方式失败的通过测试被当作失败处理，然后我们再以某种方式将其标记为通过。我甚至不确定如何表达这个句子，所以我会让它听起来尽可能的混乱。这条路径会导致一个永无止境的通过-失败-通过-失败-通过思考循环。太复杂了。
- en: The best idea I can come up with is to treat this case as a **missed failure**.
    That will let us test for the scenario and always run the test but avoid the true
    failure that would cause automated tools to reject the build, due to failures
    found.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我能想到的最好的办法是将这种情况视为**未记录的失败**。这样我们可以测试这个场景，并且总是运行测试，但避免真正的失败，这会导致自动化工具因为发现失败而拒绝构建。
- en: 'Here is the new test that shows the scenario just described. It will currently
    pass without any problems:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是展示上述场景的新测试。它目前没有任何问题地通过：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Running this new test does indeed pass unnoticed like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个新的测试确实像这样悄无声息地通过：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We need to check in the `runTests` function for passed tests whether the expected
    error result has been set and, if so, then increment a new `numMissedFailed` count
    instead of the passed count. The new count should be summarized at the end too,
    but only if it’s anything other than zero.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`runTests`函数中检查通过测试时预期的错误结果是否已设置，如果是，那么就增加一个新的`numMissedFailed`计数而不是通过计数。新的计数也应该在最后总结，但只有当它不是零时。
- en: 'Here is the beginning of `runTests`, where the new `numMissedFailed` count
    is declared:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`runTests`的开始部分，其中声明了新的`numMissedFailed`计数：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here is the part of `runTests` that checks for passing tests. Inside of here
    is where we need to look for a passing test that was supposed to have failed with
    an expected failure reason:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`runTests`中检查通过测试的部分。在这里，我们需要寻找一个本应因预期失败而失败但实际通过的通过测试：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And here is the end of the `runTests` function that summarizes the results.
    This will now show the test failures missed, if there are any:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`runTests`函数的结尾，它总结了结果。现在，如果有任何未记录的测试失败，它将显示出来：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The summary at the end started getting more complicated than it needed to be.
    So, it now always shows the passed and failed count and only the failures missed
    if there were any. We now get a missed failure for the new test that was expected
    to fail but ended up passing.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 总结部分开始变得比必要的复杂。所以，现在它总是显示通过和失败的数量，如果有任何失败，只显示失败的次数。现在，对于预期会失败但最终通过的新的测试，我们会得到一个未记录的失败。
- en: Should the missed failures be included in the failure count? I thought about
    this and decided to only return the number of actual failures for all the reasons
    just explained that led to this scenario in the first place. Remember that it’s
    highly unlikely that you will ever find yourself needing to write a test that
    you intend to fail and then treat as a pass. So, you should not have missed failures
    either.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 未记录的失败是否应该包含在失败计数中？我考虑过这个问题，并决定只返回所有导致这种场景的实际失败数量。记住，你几乎不可能需要编写一个你打算失败并当作通过的测试。所以，你也不应该有未记录的失败。
- en: 'The output looks like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来像这样：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We should be good now for this part. You have the ability to expect an exception
    and rely on your test to fail if the exception is not thrown, and the test library
    fully tests itself with all the possible combinations around expected exceptions.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该对这部分内容很熟悉了。你具备预期能够抛出异常并依赖测试失败的能力，如果异常没有被抛出，测试库会全面测试所有可能的异常组合。
- en: This section also demonstrated multiple times how to continue enhancing your
    tests and getting them to pass again. If you follow this process, you’ll be able
    to gradually build your tests to cover more complicated scenarios.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节也多次展示了如何继续增强测试并使它们再次通过。如果你遵循这个过程，你将能够逐步构建测试以覆盖更复杂的场景。
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has taken the steps we’ve already been following and made them
    explicit.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 本章已经将我们之前遵循的步骤明确化。
- en: You now know to write code the way you want it to be used first, instead of
    diving into the details and working from the bottom up in order to avoid build
    failures. It’s better to work from the top, or an end user point of view, so that
    you will have a solution you’ll be happy with, instead of a buildable solution
    that is hard to use. You do this by writing tests as you would like your code
    to be used. Once you are happy with how your code will be used, then build it
    and look at the build errors to fix them. Getting the tests to pass is not the
    goal yet. This slight change in focus will lead to designs that are easier and
    more intuitive to use.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道首先以你希望代码被使用的方式编写代码，而不是深入细节并从底部向上工作以避免构建失败。从顶部工作，或者从最终用户的角度来看，会更好，这样你将得到一个让你满意的解决方案，而不是一个可构建但难以使用的解决方案。你可以通过编写你希望代码被使用的测试来实现这一点。一旦你对代码的使用方式感到满意，然后构建它并查看构建错误以修复它们。让测试通过还不是目标。这种关注点的微小变化将导致更易于使用和更直观的设计。
- en: Once your code builds, the next step is to do only what is needed to get the
    tests to pass. It’s always possible that a change will cause tests that used to
    pass to now fail. That’s okay and is another good reason to do only what is needed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的代码构建完成，下一步就是只做必要的操作以确保测试通过。总有可能某个更改会导致之前通过测试现在失败。这是正常的，也是只做必要操作的另一个好理由。
- en: And finally, you can enhance a test or add more tests before writing the code
    needed to pass everything again.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以在编写代码以通过所有测试之前，增强测试或添加更多测试。
- en: The test library is far from complete though. The only way to cause tests to
    fail right now is to throw an exception that is not expected. You can see that,
    even at a higher level, we’re following the practice of doing only what is needed,
    getting that working, and then enhancing the tests to add more.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管测试库远未完善。目前唯一导致测试失败的方法是抛出一个未预期的异常。你可以看到，即使在更高的层面，我们也在遵循只做必要操作、使其工作，然后增强测试以添加更多功能的做法。
- en: The next enhancement is to let the test programmer check conditions within a
    test to make sure everything is working correctly. The next chapter will begin
    this work.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个增强是让测试程序员检查测试中的条件，以确保一切正常工作。下一章将开始这项工作。
