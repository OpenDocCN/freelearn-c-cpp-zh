- en: Managing Resources
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理资源
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Managing local pointers to classes that do not leave scope
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理不离开作用域的类的本地指针
- en: Reference counting of pointers to classes used across functions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对跨函数使用的类指针进行引用计数
- en: Managing local pointers to arrays that do not leave scope
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理不离开作用域的数组的本地指针
- en: Reference counting of pointers to arrays used across functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对跨函数使用的数组指针进行引用计数
- en: Storing any functional objects in a variable
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在变量中存储任何功能对象
- en: Passing function pointer in a variable
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在变量中传递函数指针
- en: Passing C++11 lambda functions in a variable
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在变量中传递C++11 lambda函数
- en: Containers of pointers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针的容器
- en: Do it at scope exit!
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在作用域退出时执行！
- en: Initializing the base class by the member of the derived class
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过派生类的成员初始化基类
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we'll continue to deal with datatypes, introduced by the Boost
    libraries, mostly focusing on working with the pointers. We'll see how to easily
    manage resources, how to use a datatype capable of storing any functional objects,
    functions, and lambda expressions. After reading this chapter, your code will
    become more reliable and memory leaks will become history.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续处理Boost库引入的数据类型，主要关注指针的处理。我们将看到如何轻松管理资源，如何使用能够存储任何功能对象、函数和lambda表达式的数据类型。阅读完本章后，你的代码将变得更加可靠，内存泄漏将成为历史。
- en: Managing local pointers to classes that do not leave scope
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理不离开作用域的类的本地指针
- en: 'Sometimes, we are required to dynamically allocate memory and construct a class
    in that memory. That''s where the troubles start. Take a look at the following
    code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要动态分配内存并在该内存中构造一个类。问题就出在这里。看一下以下代码：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This code looks correct at first glance. But, what if `some_function1()` or
    `some_function2()` throws an exception? In that case, `p` won''t be deleted. Let''s
    fix it in the following way:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码乍一看是正确的。但是，如果`some_function1()`或`some_function2()`抛出异常怎么办？在这种情况下，`p`不会被删除。让我们以以下方式修复它：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now the code is correct, but ugly and hard to read. Can we do better than this?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码是正确的，但是丑陋且难以阅读。我们能做得比这更好吗？
- en: Getting started
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: Basic knowledge of C++ and code behavior during exceptions is required.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 需要对C++的基本知识和异常期间代码行为有所了解。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Just take a look at the `Boost.SmartPtr` library. There is a `boost::scoped_ptr`
    class that may help you out:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 只需看一下`Boost.SmartPtr`库。有一个`boost::scoped_ptr`类可能会帮到你：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, there is no chance that the resource will leak and the source code is much
    clearer.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，资源不会泄漏，源代码也更清晰。
- en: If you have control over `some_function2(foo_class*)`, you may wish to rewrite
    it to take a reference to `foo_class` instead of a pointer. An interface with
    references is more intuitive than an interface with pointers unless you have a
    special agreement in your company that output parameters are taken only by pointer.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你可以控制`some_function2(foo_class*)`，你可能希望将其重写为接受`foo_class`的引用而不是指针。具有引用的接口比具有指针的接口更直观，除非你的公司有一个特殊的约定，即输出参数只能通过指针传递。
- en: 'By the way, `Boost.Move` also has a `boost::movelib::unique_ptr` that you may
    use instead of `boost::scoped_ptr`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，`Boost.Move`还有一个`boost::movelib::unique_ptr`，你可以用它来代替`boost::scoped_ptr`：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`boost::scoped_ptr<T>` and `boost::movelib::unique_ptr` are typical **RAII**
    classes. When an exception is thrown or a variable goes out of scope, the stack
    is unwound and the destructor is called. In the destructor, `scoped_ptr<T>` and
    `unique_ptr<T>` call `delete` for a pointer that they store. Because both of these
    classes by default call `delete`, it is safe to hold a `derived` class by a pointer
    to the `base` class if destructor of the base class is virtual:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::scoped_ptr<T>`和`boost::movelib::unique_ptr`是典型的**RAII**类。当抛出异常或变量超出作用域时，堆栈被展开并调用析构函数。在析构函数中，`scoped_ptr<T>`和`unique_ptr<T>`调用`delete`来删除它们存储的指针。因为这两个类默认调用`delete`，所以如果基类的析构函数是虚拟的，通过指向`base`类的指针持有`derived`类是安全的：'
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Running the `base_and_derived()` function will produce the following output:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`base_and_derived()`函数将产生以下输出：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In C++, destructors for objects are called in the reverse construction order.
    That's why the destructor of `scoped_ptr` was called before the destructor of
    `unique_ptr`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，对象的析构函数是按照相反的构造顺序调用的。这就是为什么在`scoped_ptr`的析构函数之前调用了`unique_ptr`的析构函数。
- en: The `boost::scoped_ptr<T>` class template is neither copyable nor movable. The
    `boost::movelib::unique_ptr` class is a move-only class, and it uses move emulation
    on pre-C++11 compilers. Both classes store a pointer to the resource they own
    and do not require `T` to be a complete type (`T` can be forward declared).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::scoped_ptr<T>`类模板既不可复制也不可移动。`boost::movelib::unique_ptr`类是一个只能移动的类，并且在C++11之前的编译器上使用移动模拟。这两个类都存储指向它们拥有的资源的指针，并且不要求`T`是一个完整类型（`T`可以被前向声明）。'
- en: 'Some compilers do not warn when an incomplete type is deleted, which may lead
    to errors that are hard to detect. Fortunately, that''s not the case for Boost
    classes that have specific compile-time asserts for such cases. That makes `scoped_ptr`
    and `unique_ptr` perfect for implementing the **Pimpl** idiom:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有些编译器在删除不完整类型时不会发出警告，这可能导致难以检测的错误。幸运的是，Boost类具有特定的编译时断言来处理这种情况。这使得`scoped_ptr`和`unique_ptr`非常适合实现**Pimpl**习惯用法：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There's more...
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Those classes are extremely fast. Compiler optimizes the code that uses `scoped_ptr`
    and `unique_ptr` to the machine code, which involve no additional overhead compared
    to the handwritten manual memory management code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类非常快。编译器会将使用`scoped_ptr`和`unique_ptr`的代码优化为机器代码，与手动编写的内存管理代码相比，几乎没有额外的开销。
- en: C++11 has a `std::unique_ptr<T, D>` class that uniquely owns the resource and
    behaves exactly like `boost::movelib::unique_ptr<T, D>`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: C++11有一个`std::unique_ptr<T, D>`类，它独占资源，并且与`boost::movelib::unique_ptr<T, D>`的行为完全相同。
- en: The C++ standard library has no `boost::scoped_ptr<T>`, but you could use `const
    std::unique_ptr<T>` instead. The only difference is that `boost::scoped_ptr<T>`
    still can call `reset()` unlike `const std::unique_ptr<T>`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库没有`boost::scoped_ptr<T>`，但您可以使用`const std::unique_ptr<T>`代替。唯一的区别是`boost::scoped_ptr<T>`仍然可以调用`reset()`，而`const
    std::unique_ptr<T>`不行。
- en: See also
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The documentation of the `Boost.SmartPtr` library contains lots of examples
    and other useful information about all the smart pointers' classes. You can read
    about them at [http://boost.org/libs/smart_ptr.](http://boost.org/libs/smart_ptr)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.SmartPtr`库的文档包含了许多关于所有智能指针类的示例和其他有用信息。您可以在[http://boost.org/libs/smart_ptr](http://boost.org/libs/smart_ptr)上阅读有关它们的信息。'
- en: The `Boost.Move` docs may help you out if you use move emulation with `boost::movelib::unique_ptr`
    [http://boost.org/libs/move.](http://boost.org/libs/move)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您使用`boost::movelib::unique_ptr`进行移动模拟，`Boost.Move`文档可能会帮助您[http://boost.org/libs/move](http://boost.org/libs/move)。
- en: Reference counting of pointers to classes used across functions
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨函数使用的类指针的引用计数
- en: 'Imagine that you have some dynamically allocated structure containing data,
    and you want to process it in different threads of execution. The code to do this
    is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一些包含数据的动态分配的结构，并且您希望在不同的执行线程中处理它。要执行此操作的代码如下：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We cannot deallocate `p` at the end of the `while` loop because it still can
    be used by threads that run `process` functions. These `process` functions cannot
    delete `p`, because they do not know that other threads are not using it anymore.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在`while`循环结束时释放`p`，因为它仍然可以被运行`process`函数的线程使用。这些`process`函数不能删除`p`，因为它们不知道其他线程不再使用它。
- en: Getting ready
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe uses the `Boost.Thread` library, which is not a header-only library.
    Your program has to link against the `boost_thread`, `boost_chrono`, and `boost_system`
    libraries. Make sure that you do understand the concept of threads before reading
    further. Refer to the *See also* section for references on recipes that describe
    threads.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用`Boost.Thread`库，这不是一个仅头文件的库。您的程序必须链接到`boost_thread`、`boost_chrono`和`boost_system`库。在继续阅读之前，请确保您了解线程的概念。有关描述线程的配方的参考，请参阅*另请参阅*部分。
- en: You also need some basic knowledge on `boost::bind` or `std::bind`, which are
    almost the same.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要对`boost::bind`或`std::bind`有一些基本的了解，它们几乎是一样的。
- en: How to do it...
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'As you may have guessed, there is a class in Boost (and C++11) that may help
    you to deal with the problem. It is called `boost::shared_ptr`. It can be used
    as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经猜到的，Boost（和C++11）中有一个类可以帮助您解决这个问题。它被称为`boost::shared_ptr`。可以按以下方式使用：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Another example of this is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子如下：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `shared_ptr` class has an atomic reference counter inside. When you copy
    it, the reference counter is incremented, and when its `destructor` is called,
    the reference counter is decremented. When the count of references equals to zero,
    `delete` is called for the object pointed by `shred_ptr`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared_ptr`类内部有一个原子引用计数器。当您复制它时，引用计数会增加，当调用其`析构函数`时，引用计数会减少。当引用计数等于零时，将为`shred_ptr`指向的对象调用`delete`。'
- en: Now, let's find out what's happening in the case of `boost::thread (boost::bind(&process_sp1,
    p))`. The function `process_sp1` takes a parameter as a reference, so why is it
    not deallocated when we do get out of the `while` loop? The answer is simple.
    The functional object returned by `bind()` contains a copy of the `shared` pointer,
    and that means the data pointed by `p` won't be deallocated until the functional
    object is destroyed. The functional object is copied into the thread and is kept
    alive until the threads executes.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看在`boost::thread (boost::bind(&process_sp1, p))`的情况下发生了什么。函数`process_sp1`以引用参数作为参数，那么当我们退出`while`循环时为什么它不会被释放？答案很简单。`bind()`返回的函数对象包含`shared`指针的副本，这意味着`p`指向的数据直到函数对象被销毁才会被释放。函数对象被复制到线程中，并在线程执行时保持活动状态。
- en: 'Getting back to `boost::make_shared`, let''s take a look at `shared_ptr<std::string>
    ps(new int(0))`. In this case, we have two calls to `new`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`boost::make_shared`，让我们看看`shared_ptr<std::string> ps(new int(0))`。在这种情况下，我们有两个调用`new`：
- en: While constructing a pointer to an integer via `new int(0)`
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`new int(0)`构造一个指向整数的指针
- en: While constructing a `shared_ptr` class internal reference counter that is allocated
    on the heap
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构造`shared_ptr`类内部引用计数器分配在堆上
- en: Use `make_shared<T>` to have only one call to `new`. A `make_shared<T>` allocates
    a single chunk of memory and constructs an atomic counter and the `T` object in
    that chunk.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`make_shared<T>`只需一次调用`new`。`make_shared<T>`分配一个单一的内存块，并在该内存块中构造原子计数器和`T`对象。
- en: There's more...
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The atomic reference counter guarantees correct behavior of `shared_ptr` across
    the threads, but you must remember that atomic operations are not as fast as non-atomic.
    `shared_ptr` touches the atomic variable on assignments, copy constructions, and
    on destruction of a non moved away `shared_ptr`. It means that on C++11 compatible
    compilers, you may reduce atomic operation''s count using move constructions and
    move assignments where possible. Just use `shared_ptr<T> p1(std::move(p))` if
    you are not going to use the `p` variable any more. If you are not going to modify
    the pointed value, it is recommended to make it `const`. Just add `const` to the
    template parameter of the smart pointer, and the compiler will make sure that
    you do not modify memory:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 原子引用计数器保证了`shared_ptr`在线程之间的正确行为，但您必须记住原子操作不如非原子操作快。`shared_ptr`在赋值、复制构造和未移动的`shared_ptr`销毁时会触及原子变量。这意味着在兼容C++11的编译器上，您可以尽可能使用移动构造和移动赋值来减少原子操作的次数。如果您不打算再使用`p`变量，只需使用`shared_ptr<T>
    p1(std::move(p))`。如果您不打算修改指向的值，建议将其设置为`const`。只需将`const`添加到智能指针的模板参数中，编译器将确保您不会修改内存：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Confused with `const`? Here''s a mapping of smart pointer constness to simple
    pointer constness:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对`const`感到困惑？以下是智能指针constness到简单指针constness的映射：
- en: '| `shared_ptr<T>` | `T*`  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `shared_ptr<T>` | `T*`  |'
- en: '| `shared_ptr<const T>` | `const T*`  |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `shared_ptr<const T>` | `const T*`  |'
- en: '| `const shared_ptr<T>` | `T* const` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `const shared_ptr<T>` | `T* const` |'
- en: '| `const shared_ptr<const T>` | `const T* const` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `const shared_ptr<const T>` | `const T* const` |'
- en: The `shared_ptr` calls and the `make_shared` function are a part of C++11, and
    they are declared in the header `<memory>` in the `std::` namespace. They have
    almost the same characteristics as Boost versions.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared_ptr`调用和`make_shared`函数是C++11的一部分，它们在`std::`命名空间的头文件`<memory>`中声明。它们几乎具有与Boost版本相同的特性。'
- en: See also
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Refer to [Chapter 5](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd)*,*
    *Multithreading,* for more information about `Boost.Thread` and atomic operations.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`Boost.Thread`和原子操作的更多信息，请参阅[第5章](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd)*，*
    *多线程*。
- en: Refer to the *Binding and reordering function parameters* recipe in [Chapter
    1](part0029.html#RL0A0-712b4ba1126a4c7c89e1d44de61b4bdd), *Starting to Write Your
    Application*, for more information about `Boost.Bind`.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关如何绑定和重新排序函数参数的信息，请参阅[第1章](part0029.html#RL0A0-712b4ba1126a4c7c89e1d44de61b4bdd)的*开始编写您的应用程序*中的*绑定和重新排序函数参数*食谱，了解更多关于`Boost.Bind`的信息。
- en: Refer to the [Chapter 3](part0169.html#515F20-712b4ba1126a4c7c89e1d44de61b4bdd),
    recipe *Converting smart pointers* for some information on how to convert `shared_ptr<U>`
    to `shared_ptr<T>`.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关如何将`shared_ptr<U>`转换为`shared_ptr<T>`的信息，请参阅[第3章](part0169.html#515F20-712b4ba1126a4c7c89e1d44de61b4bdd)的*转换智能指针*。
- en: The documentation of the `Boost.SmartPtr` library contains lots of examples
    and other useful information about all the smart pointer's classes. Refer to the
    link [http://boost.org/libs/smart_ptr](http://boost.org/libs/smart_ptr) to read
    about them.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.SmartPtr`库的文档包含了许多关于所有智能指针类的示例和其他有用信息。请参阅链接[http://boost.org/libs/smart_ptr](http://boost.org/libs/smart_ptr)了解相关内容。'
- en: Managing pointers to arrays that do not leave scope
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理不离开作用域的数组指针
- en: 'We already saw how to manage pointers to a resource in the *Managing pointers
    to classes that do not leave scope* recipe. But, when we deal with arrays, we
    need to call `delete[]` instead of a simple `delete`. Otherwise, there will be
    a memory leak. Take a look at the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何在*管理不离开作用域的类的指针*食谱中管理指向资源的指针。但是，当我们处理数组时，我们需要调用`delete[]`而不是简单的`delete`。否则，将会发生内存泄漏。请看下面的代码：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Getting ready
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The knowledge of C++ exceptions and templates are required for this recipe.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱需要了解C++异常和模板的知识。
- en: How to do it...
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The `Boost.SmartPointer` library has not only the `scoped_ptr<>` class, but
    also a `scoped_array<>` class:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.SmartPointer`库不仅有`scoped_ptr<>`类，还有`scoped_array<>`类：'
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `Boost.Move` library''s `boost::movelib::unique_ptr<>` class can work with
    arrays too. You just need to indicate that it is storing an array by providing
    `[]` at the end of the template parameter:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Move`库的`boost::movelib::unique_ptr<>`类也可以与数组一起使用。您只需要在模板参数的末尾提供`[]`来指示它存储的是数组。'
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: '`scoped_array<>` works exactly like a `scoped_ptr<>` class, but calls `delete[]`
    in the destructor instead of `delete`. The `unique_ptr<T[]>` does the same thing.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`scoped_array<>`的工作原理与`scoped_ptr<>`类完全相同，但在析构函数中调用`delete[]`而不是`delete`。`unique_ptr<T[]>`也是这样做的。'
- en: There's more...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `scoped_array<>` class has same guarantees and design as `scoped_ptr<>`.
    It has neither additional memory allocations nor virtual function's call. It cannot
    be copied and also is not a part of C++11\. `std::unique_ptr<T[]>` is part of
    the C++11 and has the same guarantees and performance as the `boost::movelib::unique_ptr<T[]>`
    class.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`scoped_array<>`类与`scoped_ptr<>`具有相同的保证和设计。它既没有额外的内存分配，也没有虚函数的调用。它不能被复制，也不是C++11的一部分。`std::unique_ptr<T[]>`是C++11的一部分，具有与`boost::movelib::unique_ptr<T[]>`类相同的保证和性能。'
- en: Actually, `make_unique<char[]>(1024)` is not the same as `new char[1024]`, because
    the first one does value initialization and the second one does the default initialization.
    The equivalent function for default-initialization is `boost::movelib::make_unique_definit`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`make_unique<char[]>(1024)`与`new char[1024]`不同，因为第一个进行值初始化，而第二个进行默认初始化。默认初始化的等效函数是`boost::movelib::make_unique_definit`。
- en: Note that Boost version could also work on pre-C++11 compilers and even emulates
    rvalues on them, making `boost::movelib::unique_ptr` a move only type. If your
    standard library does not provide `std::make_unique` then `Boost.SmartPtr` may
    help you out. It provides `boost::make_unique` that returns a `std::unique_ptr`
    in header `boost/smart_ptr/make_unique.hpp`. It also provides `boost::make_unique_noinit`
    for default-initialization in the same header. C++17 does not have a `make_unique_noinit`
    function.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Boost版本也可以在C++11之前的编译器上工作，甚至在这些编译器上模拟rvalues，使`boost::movelib::unique_ptr`成为仅移动类型。如果您的标准库没有提供`std::make_unique`，那么`Boost.SmartPtr`可能会帮助您。它提供了`boost::make_unique`，在头文件`boost/smart_ptr/make_unique.hpp`中返回一个`std::unique_ptr`。它还提供了`boost::make_unique_noinit`，用于在相同的头文件中进行默认初始化。C++17没有`make_unique_noinit`函数。
- en: Using `new` for memory allocation and manual memory management in C++ is a bad
    habit. Use `make_unique` and `make_shared` functions wherever possible.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中使用`new`进行内存分配和手动内存管理是一种不好的习惯。尽可能使用`make_unique`和`make_shared`函数。
- en: See also
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The documentation of the `Boost.SmartPtr` library contains lots of examples
    and other useful information about all the smart pointer's classes, you can read
    about them at [http://boost.org/libs/smart_ptr.](http://boost.org/libs/smart_ptr)
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.SmartPtr`库的文档包含了许多关于所有智能指针类的示例和其他有用信息，您可以在[http://boost.org/libs/smart_ptr.](http://boost.org/libs/smart_ptr)上阅读相关内容。'
- en: "The `Boost.Move` docs may help you out if you wish to use move emulation with\
    \ `boost::movelib::unique_ptr`, read about them at [http://boost.org/libs/move.](http://boost.org/libs/move)\
    \ [\uFEFF](http://boost.org/libs/move)"
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: "如果您希望使用`boost::movelib::unique_ptr`进行移动模拟，`Boost.Move`文档可能会对您有所帮助，请阅读[http://boost.org/libs/move.](http://boost.org/libs/move)\
    \ [\uFEFF](http://boost.org/libs/move)"
- en: Reference counting of pointers to arrays used across functions
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用计数的指向跨函数使用的数组的指针
- en: 'We continue coping with pointers, and our next task is to reference count an
    array. Let''s take a look at the program that gets some data from the stream and
    processes it in different threads. The code to do this is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续处理指针，我们的下一个任务是对数组进行引用计数。让我们看一下从流中获取一些数据并在不同的线程中处理它的程序。代码如下：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Just the same problem that occurred in the *Reference counting of pointers to
    classes used across functions* recipe.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与*跨函数使用类指针的引用计数*示例中发生的相同问题。
- en: Getting ready
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe uses the `Boost.Thread` library, which is not a header-only library,
    so your program will need to link against the `boost_thread`, `boost_chrono`,
    and `boost_system` libraries. Make sure that you do understand the concept of
    threads before reading further.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例使用了`Boost.Thread`库，这不是一个仅包含头文件的库，所以你的程序需要链接`boost_thread`、`boost_chrono`和`boost_system`库。在继续阅读之前，请确保你理解了线程的概念。
- en: You'll also need some basic knowledge on `boost::bind` or `std::bind`, which
    is almost the same.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要一些关于`boost::bind`或`std::bind`的基本知识，它们几乎是一样的。
- en: How to do it...
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'There are four solutions. The main difference between them is of type and construction
    of the `data_cpy` variable. All those solutions do exactly the same things that
    are described in the beginning of this recipe, but without memory leaks. The solutions
    are as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种解决方案。它们之间的主要区别在于`data_cpy`变量的类型和构造方式。所有这些解决方案都完全做了本示例开头描述的相同的事情，但没有内存泄漏。这些解决方案如下：
- en: 'The first solution works well for cases when array size is known at compile
    time:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个解决方案适用于在编译时已知数组大小的情况：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Since Boost 1.53, `shared_ptr` itself can take care of arrays of unknown bound.
    The second solution:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自Boost 1.53以来，`shared_ptr`本身可以处理未知大小的数组。第二个解决方案：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The third solution:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个解决方案：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The last solution is deprecated since Boost 1.65, but may be of use in case
    of antique Boost versions:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个解决方案自Boost 1.65以来已经被弃用，但在古老的Boost版本中可能会有用：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In all examples, **smart pointer** classes count references and call `delete[]`
    for a pointer when the count of references becomes equal to zero. The first and
    second examples are simple. In the third example, we provide a custom `deleter`
    object for a `shared` pointer. The `deleter` object of a smart pointer is called
    when the smart pointer decides to free resources. When smart pointer is constructed
    without explicit `deleter`, the default `deleter` is constructed that calls `delete`
    or `delete[]` depending on the template type of the smart pointer.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有示例中，**智能指针**类计算引用并在引用计数变为零时调用`delete[]`释放指针。第一个和第二个示例很简单。在第三个示例中，我们为`shared`指针提供了一个自定义的`deleter`对象。当智能指针决定释放资源时，智能指针的`deleter`对象被调用。当智能指针在没有显式`deleter`的情况下构造时，会构造默认的`deleter`，它根据智能指针的模板类型调用`delete`或`delete[]`。
- en: There's more...
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The fourth solution is the most conservative, because prior to Boost 1.53 the
    functionality of the second solution was not implemented in `shared_ptr`. The
    first and second solutions are the fastest ones as they use only one memory allocation
    call. The third solution can be used with older versions of Boost and with C++11
    standard library's `std::shared_ptr<>` (just don't forget to change `boost::checked_array_deleter<T>()`
    to `std::default_delete<T[]>()`).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个解决方案是最保守的，因为在Boost 1.53之前，第二个解决方案的功能没有在`shared_ptr`中实现。第一个和第二个解决方案是最快的，因为它们只使用了一次内存分配调用。第三个解决方案可以与较旧版本的Boost和C++11标准库的`std::shared_ptr<>`一起使用（只需不要忘记将`boost::checked_array_deleter<T>()`更改为`std::default_delete<T[]>()`）。
- en: Actually, `boost::make_shared<char[]>(size)` is not the same as `new char[size]`,
    because it involves value-initialization of all elements. The equivalent function
    for default-initialization is `boost::make_shared_noinit`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`boost::make_shared<char[]>(size)`并不等同于`new char[size]`，因为它涉及到所有元素的值初始化。默认初始化的等效函数是`boost::make_shared_noinit`。
- en: Beware! C++11 and C++14 versions of `std::shared_ptr` cannot work with arrays!
    Only since C++17 `std::shared_ptr<T[]>` must work properly. If you are planning
    to write portable code, consider using `boost::shared_ptr`, `boost::shared_array`,
    or explicitly pass a `deleter` to `std::shared_ptr`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意！C++11和C++14版本的`std::shared_ptr`不能处理数组！只有在C++17中`std::shared_ptr<T[]>`才能正常工作。如果你计划编写可移植的代码，请考虑使用`boost::shared_ptr`、`boost::shared_array`，或者显式地将`deleter`传递给`std::shared_ptr`。
- en: '`boost::shared_ptr<T[]>`, `boost::shared_array`, and C++17 `std::shared_ptr<T[]>`
    have `operator[](std::size_t index)` that allows you to access elements of shared
    array by index. `boost::shared_ptr<T>` and `std::shared_ptr<T>` with custom `deleter`
    have no `operator[]`, which makes them less useful.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::shared_ptr<T[]>`、`boost::shared_array`和C++17的`std::shared_ptr<T[]>`都有`operator[](std::size_t
    index)`，允许你通过索引访问共享数组的元素。`boost::shared_ptr<T>`和带有自定义`deleter`的`std::shared_ptr<T>`没有`operator[]`，这使它们不太有用。'
- en: See also
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The documentation of the `Boost.SmartPtr` library contains lots of examples
    and other useful information about all the smart pointers classes. You can read
    about it at [http://boost.org/libs/smart_ptr](http://boost.org/libs/smart_ptr).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.SmartPtr`库的文档包含了许多关于所有智能指针类的示例和其他有用信息。你可以在[http://boost.org/libs/smart_ptr](http://boost.org/libs/smart_ptr)上阅读相关内容。'
- en: Storing any functional objects in a variable
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将任何功能对象存储在变量中
- en: 'Consider the situation when you are developing a library that has its API declared
    in the header files and implementation in the source files. This library shall
    have a function that accepts any functional objects. Take a look at the following
    code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一种情况，当你开发一个库，它的API在头文件中声明，而在源文件中实现。这个库应该有一个接受任何功能对象的函数。看一下下面的代码：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How do you change the `process_integers` function to accept any functional objects?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如何修改`process_integers`函数以接受任何功能对象？
- en: Getting ready
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Reading the *Storing any value in container/variable* recipe in [Chapter 1](part0029.html#RL0A0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Starting to Write Your Application*, is recommended before starting off with
    this recipe.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本教程之前，建议先阅读[第1章](part0029.html#RL0A0-712b4ba1126a4c7c89e1d44de61b4bdd)中的*在容器/变量中存储任何值*教程，*开始编写您的应用程序*。
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'There is a solution and it is called a `Boost.Function` library. It allows
    you to store any function, a member function, or a functional object if its signature
    is a match to the one described in the template argument:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个解决方案，它被称为`Boost.Function`库。它允许您存储任何函数、成员函数或者函数对象，只要它的签名与模板参数中描述的一致：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `fobject_t` object stores in itself functional objects and erases their
    exact type. It is safe to use the `boost::function` for stateful objects:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`fobject_t`对象在自身中存储函数对象并擦除它们的确切类型。使用`boost::function`来存储有状态的对象是安全的：'
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Does `boost::function` recall the `boost::any` class? That's because it uses
    the same technique **type erasure** for storing any function objects.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::function`是否记得`boost::any`类？那是因为它使用相同的技术**类型擦除**来存储任何函数对象。'
- en: There's more...
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `boost::function` class has a default constructor and has an empty state.
    Checking for an empty/default constructed state can be done like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::function`类有一个默认构造函数并且有一个空状态。可以像这样检查是否为空/默认构造状态：'
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `Boost.Function` library has an insane amount of optimizations. It may store
    small functional objects without additional memory allocations and has optimized
    move assignment operators. It is accepted as a part of C++11 standard library
    and is defined in the `<functional>` header in the `std::` namespace.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Function`库有大量的优化。它可以存储小型函数对象而无需额外的内存分配，并且具有优化的移动赋值运算符。它被接受为C++11标准库的一部分，并且在`std::`命名空间的`<functional>`头文件中定义。'
- en: '`boost::function` uses an RTTI for objects stored inside it. If you disable
    RTTI, the library will continue to work, but will dramatically increase the size
    of a compiled binary.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::function`对存储在其中的对象使用RTTI。如果禁用RTTI，库将继续工作，但会大幅增加编译后的二进制文件的大小。'
- en: See also
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The official documentation of `Boost.Function` contains more examples, performance
    measures, and class reference documentation. Refer to the link [http://boost.org/libs/function](http://boost.org/libs/function)
    to read about it.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost.Function的官方文档包含更多示例、性能测量和类参考文档。请参考链接[http://boost.org/libs/function](http://boost.org/libs/function)进行阅读。
- en: The *Passing function pointer in a variable* recipe.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在变量中传递函数指针*教程。'
- en: The *Passing C++11 lambda functions in a variable* recipe.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在变量中传递C++11 lambda函数*教程。'
- en: Passing function pointer in a variable
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在变量中传递函数指针
- en: We are continuing with the previous example, and now we want to pass a pointer
    to a function in our `process_integers()` method. Shall we add an overload for
    just function pointers, or is there a more elegant way?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用之前的示例，现在我们想在`process_integers()`方法中传递一个函数指针。我们应该为函数指针添加一个重载，还是有更加优雅的方法？
- en: Getting ready
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is continuing the previous one. You must read the previous recipe
    first.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程是前一个的延续。你必须先阅读前一个教程。
- en: How to do it...
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Nothing needs to be done as `boost::function<>` is also constructible from
    the function pointers:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要做任何事情，因为`boost::function<>`也可以从函数指针中构造：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A pointer to `my_ints_function` will be stored inside the `boost::function`
    class, and calls to `boost::function` will be forwarded to the stored pointer.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 指向`my_ints_function`的指针将被存储在`boost::function`类中，并且对`boost::function`的调用将被转发到存储的指针。
- en: There's more...
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `Boost.Function` library provides a good performance for pointers to functions,
    and it will not allocate memory on heap. Standard library `std::function` is also
    effective in storing function pointers. Since Boost 1.58, the `Boost.Function`
    library can store functions and functional objects that have call signature with
    rvalue references:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Function`库为函数指针提供了良好的性能，并且不会在堆上分配内存。标准库`std::function`也有效地存储函数指针。自Boost
    1.58以来，`Boost.Function`库可以存储具有rvalue引用调用签名的函数和函数对象：'
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: See also
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The official documentation of `Boost.Function` contains more examples, performance
    measures, and class reference documentation. Follow [http://boost.org/libs/function](http://boost.org/libs/function)
    to read about it.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost.Function的官方文档包含更多示例、性能测量和类参考文档。请访问[http://boost.org/libs/function](http://boost.org/libs/function)进行阅读。
- en: The *Passing C++11 lambda functions in a variable* recipe.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在变量中传递C++11 lambda函数*教程。'
- en: Passing C++11 lambda functions in a variable
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在变量中传递C++11 lambda函数
- en: We are continuing with the previous example, and now we want to use a lambda
    function with our `process_integers()` method.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用之前的示例，现在我们想在`process_integers()`方法中使用一个lambda函数。
- en: Getting ready
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is continuing the series of the previous two. You must read them
    first. You will also need a C++11 compatible compiler or at least a compiler with
    C++11 lambda support.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程是前两个教程的延续。你必须先阅读它们。你还需要一个兼容C++11的编译器，或者至少支持C++11 lambda的编译器。
- en: How to do it...
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Nothing needs to be done as `boost::function<>` is also usable with lambda
    functions of any difficulty:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要做任何事情，因为`boost::function<>`也可以用于任何难度的lambda函数：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There's more...
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Performance of the lambda function storage in `Boost.Functional` is the same
    as in other cases. While a functional object produced by the lambda expression
    is small enough to fit in an instance of `boost::function`, no dynamic memory
    allocation is performed. Calling an object stored in `boost::function` is close
    to the speed of calling a function by a pointer. Copying `boost::function` allocates
    heap memory only if initial `boost::function` has a stored object that does not
    fit in it without allocation. Moving instances does not allocate and deallocate
    memory.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Functional`中的lambda函数存储性能与其他情况相同。lambda表达式生成的函数对象足够小，可以适应`boost::function`的实例，不会执行动态内存分配。调用存储在`boost::function`中的对象的速度接近通过指针调用函数的速度。只有在初始`boost::function`中存储的对象不适合在没有分配的情况下存储时，复制`boost::function`才会分配堆内存。移动实例不会分配和释放内存。'
- en: 'Remember that `boost::function` implies an optimization barrier for the compiler.
    It means that:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`boost::function`意味着对编译器的优化障碍。这意味着：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Is usually better optimized by the compiler than:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通常由编译器优化得更好：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This is why you should try to avoid using `Boost.Function` when its usage is
    not really required. In some cases, the C++11 `auto` keyword can be handy instead:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么在不真正需要时应该尽量避免使用`Boost.Function`。在某些情况下，C++11的`auto`关键字可能更方便：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: See also
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Additional information about performance and `Boost.Function` can be found on
    the official documentation page at [http://www.boost.org/libs/function](http://www.boost.org/libs/function).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有关性能和`Boost.Function`的其他信息，请访问官方文档页面[http://www.boost.org/libs/function](http://www.boost.org/libs/function)。
- en: Containers of pointers
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针容器
- en: 'There are such cases when we need to store pointers in the container. The examples
    are: storing polymorphic data in containers, forcing fast copy of data in containers,
    and strict exception requirements for operations with data in containers. In such
    cases, C++ programmer has the following choices:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有这样的情况，当我们需要在容器中存储指针。示例包括：在容器中存储多态数据，强制在容器中快速复制数据，以及对容器中的数据操作有严格的异常要求。在这种情况下，C++程序员有以下选择：
- en: 'Store pointers in containers and take care of their destructions using `delete`:'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中存储指针并使用`delete`来处理它们的销毁：
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Such an approach is error prone and requires a lot of writing
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法容易出错，需要大量编写。
- en: 'Store C++11 smart pointers in containers:'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中存储C++11智能指针：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This solution is a good one, but it cannot be used in C++03, and you still need
    to write a comparator functional object.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案很好，但不能在C++03中使用，而且您仍然需要编写一个比较器函数对象。
- en: C++14 has a `std::make_unique` function for construction of `std::uniue_ptr`s.
    Using it instead of `new` is a good coding style!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: C++14有一个`std::make_unique`函数用于构造`std::uniue_ptr`。使用它而不是`new`是一个很好的编码风格！
- en: 'Use `Boost.SmartPtr` in the container:'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中使用`Boost.SmartPtr`：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This solution is portable, but it adds performance penalties (atomic counter
    requires additional memory, and its increments/decrements are not as fast as non-atomic
    operations) and you still need to write comparators.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案是可移植的，但会增加性能损失（原子计数器需要额外的内存，并且其增量/减量不如非原子操作快），而且您仍然需要编写比较器。
- en: Getting ready
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Knowledge of standard library containers is required for better understanding
    of this recipe.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 更好地理解本配方需要了解标准库容器的知识。
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The `Boost.PointerContainer` library provides a good and portable solution:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.PointerContainer`库提供了一个很好的可移植解决方案：'
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works...
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `Boost.PointerContainer` library has classes `ptr_array`, `ptr_vector`,
    `ptr_set`, `ptr_multimap`, and others. Those classes deallocate pointers as required
    and simplify access to data pointed by the pointer (no need for additional dereference
    in `assert(*s.begin() == 0);`).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.PointerContainer`库有`ptr_array`、`ptr_vector`、`ptr_set`、`ptr_multimap`等类。这些类根据需要释放指针，并简化了指针指向的数据的访问（在`assert(*s.begin()
    == 0);`中不需要额外的解引用）。'
- en: There's more...
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'When we want to clone some data, we need to define a freestanding function
    `T*new_clone(const T& r)` in the namespace of the object to be cloned. Moreover,
    you may use the default `T* new_clone(const T& r)` implementation if you include
    the header file `<boost/ptr_container/clone_allocator.hpp>`, as shown in the following
    code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要克隆一些数据时，我们需要在要克隆的对象的命名空间中定义一个独立的函数`T*new_clone(const T& r)`。此外，如果您包含头文件`<boost/ptr_container/clone_allocator.hpp>`，则可以使用默认的`T*
    new_clone(const T& r)`实现，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'C++ standard library has no pointer containers, but you can achieve the same
    functionality using a container of `std::unique_ptr`. By the way, since Boost
    1.58, there is a `boost::movelib::unique_ptr` class that is usable in C++03\.
    You can mix it with containers from the `Boost.Container` library to have C++11
    functionality for storing pointers:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库没有指针容器，但您可以使用`std::unique_ptr`的容器来实现相同的功能。顺便说一句，自Boost 1.58以来，有一个`boost::movelib::unique_ptr`类，可在C++03中使用。您可以将其与`Boost.Container`库中的容器混合使用，以获得存储指针的C++11功能：
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Not all the developers know the Boost libraries well. It is more developer-friendly
    to use functions and classes that have C++ standard library alternatives, as the
    developers usually are more aware of the standard library features. So if there's
    no big difference for you, use `Boost.Container` with `boost::movelib::unique_ptr`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有开发人员都很了解Boost库。使用具有C++标准库替代品的函数和类更加友好，因为开发人员通常更了解标准库的特性。因此，如果对您来说没有太大区别，请使用`Boost.Container`与`boost::movelib::unique_ptr`。
- en: See also
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The official documentation contains detailed reference for each class, follow
    the link [http://boost.org/libs/ptr_container](http://boost.org/libs/ptr_container)
    to read about it.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方文档包含了每个类的详细参考，请访问链接[http://boost.org/libs/ptr_container](http://boost.org/libs/ptr_container)了解更多信息。
- en: The first four recipes of this chapter give you some examples about smart pointers'
    usage.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的前四个配方为您提供了一些智能指针使用的示例。
- en: Multiple recipes in [Chapter 9](part0475.html#E4VR60-712b4ba1126a4c7c89e1d44de61b4bdd)*,
    Containers* describe the `Boost.Container` library features. Take a look at that
    chapter for cool, useful, and fast containers.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第9章](part0475.html#E4VR60-712b4ba1126a4c7c89e1d44de61b4bdd)*，容器*中的多个食谱描述了`Boost.Container`库的特性。查看该章节，了解有用的快速容器。'
- en: Do it at scope exit!
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在作用域退出时执行它！
- en: If you were dealing with languages, such as Java, C#, or Delphi, you obviously
    were using the `try {} finally{}` construction. Let me briefly describe to you
    what do these language constructions do.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您处理的是Java、C#或Delphi等语言，显然您正在使用`try {} finally{}`结构。让我简要地描述一下这些语言结构的作用。
- en: 'When a program leaves the current scope via return or exception, code in the
    `finally` block is executed. This mechanism is used as a replacement for the RAII
    pattern:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序通过返回或异常离开当前作用域时，`finally`块中的代码将被执行。这种机制用作RAII模式的替代：
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Is there a way to do such a thing in C++?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中有办法做到这一点吗？
- en: Getting ready
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic C++ knowledge is required for this recipe. Knowledge of code behavior
    during thrown exception will be appreciated.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱需要基本的C++知识。了解在抛出异常时代码的行为将会很有帮助。
- en: How to do it...
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'C++ uses the RAII pattern instead of `try {} finally{}` construction. The `Boost.ScopeExit`
    library was designed to allow user definition of RAII wrappers right in the function
    body:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: C++使用RAII模式而不是`try {} finally{}`结构。`Boost.ScopeExit`库旨在允许用户在函数体内定义RAII包装器：
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `f` is passed by the value via `BOOST_SCOPE_EXIT(f)`. When the program leaves
    the scope of execution, the code between `BOOST_SCOPE_EXIT(f) {` and `} BOOST_SCOPE_EXIT_END`
    is be executed. If we wish to pass the value by reference, use the `&` symbol
    in the `BOOST_SCOPE_EXIT` macro. If we wish to pass multiple values, just separate
    them by commas.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`f`通过`BOOST_SCOPE_EXIT(f)`按值传递。当程序离开执行范围时，`BOOST_SCOPE_EXIT(f) {`和`} BOOST_SCOPE_EXIT_END`之间的代码将被执行。如果我们希望通过引用传递值，使用`BOOST_SCOPE_EXIT`宏中的`&`符号。如果我们希望传递多个值，只需用逗号分隔它们。'
- en: Passing references to a pointer does not work well on some compilers. The `BOOST_SCOPE_EXIT(&f)`
    macro cannot be compiled there, which is why we do not capture it by reference
    in the example.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些编译器上，将引用传递给指针并不奏效。`BOOST_SCOPE_EXIT(&f)`宏在那里无法编译，这就是为什么我们在示例中没有通过引用捕获它的原因。
- en: There's more...
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多信息...
- en: 'To capture this inside a member function, we shall use a special symbol `this_`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在成员函数中捕获这个，我们将使用一个特殊的符号`this_`：
- en: '[PRE37]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `Boost.ScopeExit` library allocates no additional memory on heap and does
    not use virtual functions. Use the default syntax and do not define `BOOST_SCOPE_EXIT_CONFIG_USE_LAMBDAS`
    because otherwise scope exit will be implemented using `boost::function`, which
    may allocate additional memory and imply an optimization barrier. You may achieve
    close to the `BOOST_SCOPE_EXIT` results using `boost::movelib::unique_ptr` or
    `std::unique_ptr` by specifying a custom `deleter`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.ScopeExit`库在堆上不分配额外的内存，也不使用虚函数。使用默认语法，不要定义`BOOST_SCOPE_EXIT_CONFIG_USE_LAMBDAS`，否则将使用`boost::function`来实现作用域退出，这可能会分配额外的内存并意味着一个优化障碍。您可以通过指定自定义的`deleter`，使用`boost::movelib::unique_ptr`或`std::unique_ptr`来实现接近`BOOST_SCOPE_EXIT`结果：'
- en: '[PRE38]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If you write two or more similar bodies for `BOOST_SCOPE_EXIT`, then it's time
    to think about some refactoring and moving the code to a fully functional RAII
    class.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您为`BOOST_SCOPE_EXIT`编写了两个或更多类似的代码块，那么现在是时候考虑一些重构，并将代码移动到一个完全功能的RAII类中。
- en: See also
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The official documentation contains more examples and use cases. You can read
    about it at [http://boost.org/libs/scope_exit.](http://boost.org/libs/scope_exit)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 官方文档包含更多示例和用例。您可以在[http://boost.org/libs/scope_exit.](http://boost.org/libs/scope_exit)上阅读相关内容
- en: Initializing the base class by the member of the derived class
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过派生类的成员初始化基类
- en: 'Let''s take a look at the following example. We have some base class that has
    virtual functions and must be initialized with reference to the `std::ostream`
    object:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。我们有一个基类，它有虚函数，并且必须用`std::ostream`对象的引用进行初始化：
- en: '[PRE39]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We also have a derived class that has a `std::ostream` object and implements
    the `do_process()` function:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个派生类，它有一个`std::ostream`对象，并实现了`do_process()`函数：
- en: '[PRE40]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This is not a very common case in programming, but when such mistakes happen,
    it is not always simple to get the idea of bypassing it. Some people try to bypass
    it by changing the order of `logger_` and the base type initialization:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这在编程中并不是一个很常见的情况，但当发生这样的错误时，要想绕过它并不总是简单的。有些人试图通过改变`logger_`和基类型初始化的顺序来绕过它：
- en: '[PRE41]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: It won't work as per expectations because direct base classes are initialized
    before non-static data members, regardless of the order of the member initializers.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 直接基类在非静态数据成员之前初始化，而不管成员初始化器的顺序，这样不会按预期工作。
- en: Getting started
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: Basic knowledge of C++ is required for this recipe.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱需要基本的C++知识。
- en: How to do it...
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The `Boost.Utility` library provides a quick solution for such cases. Solution
    is called the `boost::base_from_member` template. To use it, you need to carry
    out the following steps:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Utility`库为这种情况提供了一个快速解决方案。解决方案称为`boost::base_from_member`模板。要使用它，您需要执行以下步骤：'
- en: 'Include the `base_from_member.hpp` header:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括`base_from_member.hpp`头文件：
- en: '[PRE42]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Derive your class from `boost::base_from_member<T>` where `T` is a type that
    must be initialized before the base (take care about the order of the base classes;
    `boost::base_from_member<T>` must be placed before the class that uses `T`):'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`boost::base_from_member<T>`派生您的类，其中`T`是在基类之前必须初始化的类型（注意基类的顺序；`boost::base_from_member<T>`必须放在使用`T`的类之前）：
- en: '[PRE43]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Correctly, write the constructor as follows:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确地，编写构造函数如下：
- en: '[PRE44]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How it works...
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Direct base classes are initialized before non-static data members and in declaration
    order as they appear in the base-specifier list. If we need to initialize base
    class `B` with *something*, we need to make that *something* a part of a base
    class `A` that is declared before `B`. In other words, `boost::base_from_member`
    is just a simple class that holds its template parameter as a non-static data
    member:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 直接基类在非静态数据成员之前进行初始化，并且按照它们在基类指定符列表中出现的顺序进行初始化。如果我们需要用*something*初始化基类`B`，我们需要将*something*作为在`B`之前声明的基类`A`的一部分。换句话说，`boost::base_from_member`只是一个简单的类，它将其模板参数作为非静态数据成员：
- en: '[PRE45]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: There's more...
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'As you may see, `base_from_member` has an integer as a second template argument.
    This is done for cases when we need multiple `base_from_member` classes of the
    same type:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`base_from_member`有一个整数作为第二个模板参数。这是为了在我们需要多个相同类型的`base_from_member`类的情况下使用：
- en: '[PRE46]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `boost::base_from_member` class neither applies additional dynamic memory
    allocations nor has virtual functions. The current implementation does support
    **perfect forwarding** and **variadic templates** if your compiler supports them.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::base_from_member`类既不应用额外的动态内存分配，也没有虚函数。如果您的编译器支持，当前实现支持**完美转发**和**可变模板**。'
- en: C++ standard library has no `base_from_member`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库中没有`base_from_member`。
- en: See also
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The `Boost.Utility` library contains many helpful classes and functions; documentation
    for getting more information about it is at [http://boost.org/libs/utility](http://boost.org/libs/utility)
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Utility`库包含许多有用的类和函数；有关更多信息的文档，请访问[http://boost.org/libs/utility](http://boost.org/libs/utility)'
- en: The *Making a noncopyable class* recipe in [Chapter 1](part0029.html#RL0A0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Starting to Write Your Application*, contains more examples of classes from `Boost.Utility`
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](part0029.html#RL0A0-712b4ba1126a4c7c89e1d44de61b4bdd) *开始编写您的应用程序*中的*制作不可复制的类*示例中，包含了来自`Boost.Utility`的更多类的示例
- en: Also, the *Using C++11 move emulation* recipe in [Chapter 1](part0029.html#RL0A0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Starting to Write Your Application*, contains more examples of classes from `Boost.Utility`
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，在[第1章](part0029.html#RL0A0-712b4ba1126a4c7c89e1d44de61b4bdd) *开始编写您的应用程序*中的*使用C++11移动模拟*示例中，包含了更多来自`Boost.Utility`的类的示例。
