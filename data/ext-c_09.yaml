- en: Chapter 09
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章
- en: Abstraction and OOP in C++
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++中的抽象和OOP
- en: This is the final chapter on OOP in C. In this chapter, we are going to cover
    the remaining topics and introduce you to a new programming paradigm. In addition,
    we explore C++ and look at how it implements object-oriented concepts behind the scenes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这是C中面向对象编程的最后一章。在本章中，我们将涵盖剩余的主题，并介绍一个新的编程范式。此外，我们将探索C++，并查看它如何在幕后实现面向对象的概念。
- en: 'As part of this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的一部分，我们将涵盖以下主题：
- en: Firstly, we discuss the *Abstraction*. This continues our discussion regarding
    inheritance and polymorphism and will be the last topic that we cover as part
    of OOP in C. We show how abstraction helps us in designing object models that
    have the maximum extendibility and the minimum dependencies between its various
    components.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们讨论*抽象*。这继续了我们关于继承和多态的讨论，并将是我们作为C中面向对象（OOP）的一部分要覆盖的最后一个主题。我们展示了抽象如何帮助我们设计具有最大可扩展性和最小组件之间依赖性的对象模型。
- en: We talk about how object-oriented concepts have been implemented in a famous
    C++ compiler, `g++` in this case. As part of this, we see that how close the approaches
    that we have discussed so far are in accordance with the approaches that `g++`
    has taken to provide the same concepts.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了面向对象的概念是如何在一个著名的C++编译器`g++`中实现的。作为这部分内容的一部分，我们看到我们之前讨论的方法与`g++`提供相同概念的方法是多么接近。
- en: Let's start the chapter by talking about abstraction.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过讨论抽象来开始本章。
- en: Abstraction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象
- en: Abstraction can have a very general meaning in various fields of science and
    engineering. But in programming, and especially in OOP, abstraction essentially
    deals with *abstract data types*. In class-based object orientation, abstract
    data types are the same as *abstract classes*. Abstract classes are special classes
    that we cannot create an object from; they are not ready or complete enough to
    be used for object creation. So, why do we need to have such classes or data types?
    This is because when we work with abstract and general data types, we avoid creating
    strong dependencies between various parts of code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象在科学和工程学的各个领域可以有一个非常广泛的意义。但在编程中，尤其是在面向对象编程（OOP）中，抽象本质上处理的是*抽象数据类型*。在基于类的面向对象中，抽象数据类型等同于*抽象类*。抽象类是特殊的类，我们不能从它们中创建对象；它们还没有准备好或足够完整，不能用于对象创建。那么，为什么我们需要这样的类或数据类型呢？这是因为当我们与抽象和通用数据类型一起工作时，我们避免了在代码的各个部分之间创建强烈的依赖关系。
- en: 'As an example, we can have the following relationships between the *Human*
    and *Apple* classes:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以有如下*人类*和*苹果*类之间的关系：
- en: '*An object of the Human class eats an object of the Apple class.*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*人类类的一个对象吃的是苹果类的一个对象*。'
- en: '*An object of the Human class eats an object of the Orange class.*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*人类类的一个对象吃的是橙子类的一个对象*。'
- en: 'If the classes that an object from the *Human* class can eat were expanded
    to more than just *Apple* and *Orange*, we would need to add more relations to
    the *Human* class. Instead, though, we could create an abstract class called *Fruit*
    that is the parent of both *Apple* and *Orange* classes, and we could set the
    relation to be between *Human* and *Fruit* only. Therefore, we can turn our preceding
    two statements into one:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个人类对象可以吃的类被扩展到不仅仅是*苹果*和*橙子*，我们就需要向*人类*类添加更多关系。然而，我们可以创建一个名为*水果*的抽象类，它是*苹果*和*橙子*类的父类，并且我们可以将关系设置为*人类*和*水果*之间。因此，我们可以将前面的两个陈述合并为一个：
- en: '*An object of the Human class eats an object from a subtype of the Fruit class.*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*人类类的一个对象吃的是水果类子类型的一个对象*。'
- en: The *Fruit* class is abstract because it lacks information about shape, taste,
    smell, color, and many more attributes of a specific fruit. Only when we have
    an apple or an orange do we know the exact values of the different attributes.
    The *Apple* and *Orange* classes are said to be *concrete types*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*水果*类是抽象的，因为它缺少关于形状、味道、气味、颜色以及更多特定水果属性的详细信息。只有当我们拥有一个苹果或一个橙子时，我们才知道不同属性的确切值。*苹果*和*橙子*类被称为*具体类型*。'
- en: 'We can even add more abstraction. The *Human* class can eat *Salad* or *Chocolate*
    as well. So, we can say:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以添加更多的抽象。*人类*类可以吃*沙拉*或*巧克力*。因此，我们可以这样说：
- en: '*An object of the Human type eats an object from a subtype of the Eatable class.*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*人类类型的一个对象吃的是可食用类子类型的一个对象*。'
- en: As you can see, the abstraction level of *Eatable* is even higher than that
    of *Fruit*. Abstraction is a great technique for designing an object model that
    has minimal dependency on concrete types and allows the maximum future extension
    to the object model when more concrete types are introduced to the system.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，*Eatable* 的抽象级别甚至高于 *Fruit*。抽象是设计一个具有最小具体类型依赖的对象模型的一种伟大技术，它允许在系统中引入更多具体类型时，对对象模型进行最大程度的未来扩展。
- en: 'Regarding the preceding example, we could also add further abstraction by using
    the fact that *Human* is an *Eater*. Then, we could make our statement even more
    abstract:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面的例子，我们还可以通过使用 *Human* 是一个 *Eater* 的这一事实来进一步抽象。然后，我们可以使我们的声明更加抽象：
- en: '*An object from a subtype of the Eater class eats an object from a subtype
    of the Eatable class.*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*来自 Eater 类子类的对象会吃来自 Eatable 类子类的对象*。'
- en: We can continue to abstract everything in an object model and find abstract
    data types that are more abstract than the level we need to solve our problem.
    This is usually called *over-abstraction*. It happens when you try to create abstract
    data types that have no real application, either for your current or your future
    needs. This should be avoided at all costs because abstraction can cause problems,
    despite all the benefits it provides.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续在对象模型中抽象一切，并找到比我们解决问题所需的级别更抽象的抽象数据类型。这通常被称为 *过度抽象*。这发生在你试图创建没有实际应用（无论是当前还是未来的需求）的抽象数据类型时。无论如何都应该避免这种情况，因为尽管抽象提供了许多好处，但它也可能引起问题。
- en: 'A general guide regarding the amount of abstraction that we need can be found
    as part of the *abstraction principle*. I got the following quote from its Wikipedia
    [page, https://en.wikipedia.org/wiki/Abstraction_principle_(computer_program](https://en.wikipedia.org/wiki/Abstraction_principle_(computer_programming))ming).
    It simply states:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们需要多少抽象的一般指南可以在 *抽象原则* 中找到。我从其维基百科 [页面](https://en.wikipedia.org/wiki/Abstraction_principle_(computer_programming))
    中获得了以下引言。它简单地陈述：
- en: '*Each significant piece of functionality in a program should be implemented
    in just one place in the source code. Where similar functions are carried out
    by distinct pieces of code, it is generally beneficial to combine them into one
    by abstracting out the varying parts.*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*程序中每个重要的功能部分都应该在源代码的单一位置实现。当相似的功能由不同的代码块执行时，通常通过抽象出不同的部分将它们组合在一起是有益的*。'
- en: While at first glance you may not see any sign of object orientation or inheritance
    in this statement, by giving some further thought to it you will notice that what
    we did with inheritance was based on this principle. Therefore, as a general rule,
    whenever you don't expect to have variations in a specific logic, there is no
    need to introduce abstraction at that point.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然乍一看你可能看不到任何面向对象或继承的迹象，但通过进一步思考，你会注意到我们使用继承所做的是基于这个原则。因此，作为一般规则，当你不期望在特定逻辑中存在变化时，在那个点引入抽象是没有必要的。
- en: In a programming language, inheritance and polymorphism are two capabilities
    that are required in order to create abstraction. An abstract class such as *Eatable*
    is a supertype in relation to its concrete classes, such as *Apple*, and this
    is accomplished by inheritance.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在一种编程语言中，继承和多态是创建抽象所必需的两个能力。例如，一个名为 *Eatable* 的抽象类相对于其具体类，如 *Apple*，是一个超类型，这是通过继承实现的。
- en: Polymorphism also plays an important role. There are behaviors in an abstract
    type that *cannot* have default implementation at that abstraction level. For
    example, *taste* as an attribute implemented using a behavior function such as
    `eatable_get_taste` as part of the *Eatable* class cannot have an exact value
    when we are talking about an *Eatable* object. In other words, we cannot create
    an object directly from the *Eatable* class if we don't know how to define the
    `eatable_get_taste` behavior function.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 多态也扮演着重要的角色。在抽象类型中，有一些行为在该抽象级别上 *不能* 有默认实现。例如，作为使用行为函数（如 `eatable_get_taste`）实现的属性
    *taste*，在谈论 *Eatable* 对象时不能有一个确切值。换句话说，如果我们不知道如何定义 `eatable_get_taste` 行为函数，我们就不能直接从
    *Eatable* 类创建对象。
- en: The preceding function can only be defined when the child class is concrete
    enough. For example, we know that *Apple* objects should return *sweet* for their
    taste (we've assumed here that all apples are sweet). This is where polymorphism
    helps. It allows a child class to override its parent's behaviors and return the
    proper taste, for example.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数只能在子类足够具体时才能定义。例如，我们知道 *Apple* 对象应该返回 *甜* 作为它们的味道（我们在这里假设所有苹果都是甜的）。这正是多态发挥作用的地方。它允许子类覆盖其父类的行为并返回适当的味道，例如。
- en: If you remember from the previous chapter, the behavior functions that can be
    overridden by child classes are called *virtual functions*. Note that it is possible
    that a virtual function doesn't have any definition at all. Of course, this makes
    the owner class abstract.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得上一章的内容，可以被子类重写的函数称为 *虚函数*。请注意，一个虚函数可能根本没有任何定义。当然，这会使拥有该函数的类成为抽象类。
- en: By adding more and more abstraction, at a certain level, we reach classes that
    have no attributes and contain only virtual functions with no default definitions.
    These classes are called *interfaces*. In other words, they expose functionalities
    but they don't offer any implementation at all, and they are usually used to create
    dependencies between various components in a software project. As an example,
    in our preceding examples, the *Eater* and *Eatable* classes are interfaces. Note
    that, just like abstract classes, you must not create an object from an interface.
    The following code shows why this cannot be done in a C code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过不断增加抽象层次，我们最终会到达没有任何属性且只包含没有默认定义的虚函数的类。这些类被称为 *接口*。换句话说，它们暴露了功能，但根本不提供任何实现，并且通常用于在软件项目中创建各种组件之间的依赖关系。例如，在我们前面的例子中，*Eater*
    和 *Eatable* 类是接口。请注意，就像抽象类一样，您绝对不应该从接口创建对象。以下代码展示了为什么在 C 代码中不能这样做。
- en: 'The following code box is the equivalent code written for the preceding interface
    *Eatable* in C using the techniques we introduced in the previous chapter to implement
    inheritance and polymorphism:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框是使用我们在上一章中介绍的技术为前面提到的接口 *Eatable* 在 C 中编写的等效代码，以实现继承和多态：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Code Box 9-1: The Eatable interface in C'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 9-1：C 中的 Eatable 接口
- en: As you can see, in the constructor function we have set the `get_taste_func`
    pointer to `NULL`. So, calling the `eatable_get_taste` virtual function can lead
    to a segmentation fault. From the coding perspective, that's basically why that
    we must not create an object from the *Eatable* interface other than the reasons
    we know from the definition of the interface and the design point of view.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在构造函数中，我们将 `get_taste_func` 指针设置为 `NULL`。因此，调用 `eatable_get_taste` 虚函数可能导致段错误。从编码的角度来看，这基本上是我们为什么不能从
    *Eatable* 接口创建对象，除了我们从接口的定义和设计角度知道的原因之外。
- en: 'The following code box demonstrates how creating an object from the *Eatable*
    interface, which is totally possible and allowed from a C point of view, can lead
    to a crash and must not be done:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框展示了从 *Eatable* 接口创建对象，这在 C 的角度来看是完全可能且允许的，但它可能导致崩溃，并且绝对不应该这样做：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Code Box 9-2: Segmentation fault when creating an object from the Eatable interface
    and calling a pure virtual function from it'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 9-2：从 Eatable 接口创建对象并调用其纯虚函数时发生段错误
- en: To prevent ourselves from creating an object from an abstract type, we can remove
    the *allocator function* from the class's public interface. If you remember the
    approaches that we took in the previous chapter to implement inheritance in C,
    by removing the allocator function, only child classes are able to create objects
    from the parent's attribute structure.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止我们从一个抽象类型创建对象，我们可以从类的公共接口中移除 *分配器函数*。如果您还记得我们在上一章中用于在 C 中实现继承的方法，通过移除分配器函数，只有子类能够从父类的属性结构中创建对象。
- en: External codes are then no longer able to do so. For instance, in the preceding
    example, we do not want any external code to be able to create any object from
    the structure `eatable_t`. In order to do that, we need to have the attribute
    structure forward declared and make it an incomplete type. Then, we need to remove
    the public memory allocator `eatable_new` from the class.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 外部代码随后将不再能够这样做。例如，在先前的例子中，我们不希望任何外部代码能够从结构 `eatable_t` 中创建任何对象。为了做到这一点，我们需要将属性结构提前声明并使其成为一个不完整类型。然后，我们需要从类中移除公共内存分配器
    `eatable_new`。
- en: To summarize what we need to do to have an abstract class in C, you need to
    nullify the virtual function pointers that are not meant to have a default definition
    at that abstraction level. At an extremely high level of abstraction, we have
    an interface whose all function pointers are null. To prevent any external code
    from creating objects from abstract types, we should remove the allocator function
    from the public interface.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 总结在 C 中创建抽象类所需做的事情，你需要将那些在该抽象级别不应该有默认定义的虚函数指针置为空。在极其高层次的抽象中，我们有一个所有函数指针都为空的接口。为了防止任何外部代码从抽象类型创建对象，我们应该从公共接口中移除分配器函数。
- en: In the following section, we are going to compare similar object-oriented features
    in C and C++. This gives us an idea how C++ has been developed from pure C.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将比较 C 和 C++ 中的类似面向对象特性。这让我们了解 C++ 是如何从纯 C 发展而来的。
- en: Object-oriented constructs in C++
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ 中的面向对象结构
- en: In this section, we are going to compare what we did in C and the underlying
    mechanisms employed in a famous C++ compiler, `g++` in this case, for supporting
    encapsulation, inheritance, polymorphism, and abstraction.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将比较我们在 C 中所做的工作以及著名 C++ 编译器 `g++` 使用的底层机制来支持封装、继承、多态和抽象。
- en: We want to show that there is a close accordance between the methods by which
    object-oriented concepts are implemented in C and C++. Note that, from now on,
    whenever we refer to C++, we are actually referring to the implementation of `g++`
    as one of the C++ compilers, and not the C++ standard. Of course, the underlying
    implementations can be different for various compilers, but we don't expect to
    see a lot of differences. We will also be using `g++` in a 64-bit Linux setup.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想展示在 C 和 C++ 中实现面向对象概念的方法之间有紧密的一致性。请注意，从现在开始，每当提到 C++ 时，我们实际上是在指 `g++` 作为
    C++ 编译器之一的具体实现，而不是 C++ 标准。当然，不同编译器的底层实现可能有所不同，但我们不期望看到很多差异。我们还将使用 `g++` 在 64 位
    Linux 环境中。
- en: We are going to use the previously discussed techniques to write an object-oriented
    code in C, and then we write the same program in C++, before jumping to the final
    conclusion.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前讨论的技术在 C 中编写面向对象的代码，然后我们将用 C++ 编写相同的程序，最后得出最终结论。
- en: Encapsulation
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装
- en: It is difficult to go deep into a C++ compiler and see how it uses the techniques
    that we've been exploring so far to produce the final executable, but there is
    one clever trick that we can use to actually see this. The way to do this is to
    compare the assembly instructions generated for two similar C and C++ programs.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 深入研究 C++ 编译器并查看它是如何使用我们迄今为止探索的技术来生成最终可执行文件是困难的，但我们可以使用一个巧妙的技巧来实际看到这一点。这样做的方法是比较两个类似
    C 和 C++ 程序生成的汇编指令。
- en: This is exactly what we are going to do to demonstrate that the C++ compiler
    ends up generating the same assembly instructions as a C program that uses the
    OOP techniques that we've been discussing in the previous chapters.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们将要做的，以证明 C++ 编译器最终生成的汇编指令与使用我们在前几章中讨论的 OOP 技术的 C 程序相同。
- en: '*Example 9.1* is about two C and C++ programs addressing the same simple object-oriented
    logic. There is a `Rectangle` class in this example, which has a behavior function
    for calculating its area. We want to see and compare the generated assembly codes
    for the same behavior function in both programs. The following code box demonstrates
    the C version:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9.1* 讲述了两个 C 和 C++ 程序实现相同的简单面向对象逻辑。在这个例子中有一个 `Rectangle` 类，它有一个用于计算面积的行为函数。我们想查看并比较两个程序中相同行为函数生成的汇编代码。以下代码框展示了
    C 版本：'
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Code Box 9-3 [ExtremeC_examples_chapter9_1.c]: Encapsulation example in C'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 9-3 [ExtremeC_examples_chapter9_1.c]：C 中的封装示例
- en: 'And the following code box shows the C++ version of the preceding program:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框显示了前面程序的 C++ 版本：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Code Box 9-4 [ExtremeC_examples_chapter9_1.cpp]: Encapsulation example in C++'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 9-4 [ExtremeC_examples_chapter9_1.cpp]：C++ 中的封装示例
- en: 'So, let''s generate the assembly codes for the preceding C and C++ programs:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们生成前面 C 和 C++ 程序的汇编代码：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Shell Box 9-1: Generating the assembly outputs for the C and C++ codes'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 9-1：生成 C 和 C++ 代码的汇编输出
- en: Now, let's dump the `ex9_1_c.s` and `ex9_1_cpp.s` files and look for the definition
    of the behavior functions. In `ex9_1_c.s`, we should look for the `rect_area`
    symbol, and in `ex9_1_cpp.s`, we should look for the `_ZN4Rect4AreaEv` symbol.
    Note that C++ mangles the symbol names, and that's why you need to search for
    this strange symbol. Name mangling in C++ has been discussed in *Chapter 2*, *Compilation
    and Linking*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们查看`ex9_1_c.s`和`ex9_1_cpp.s`文件，并寻找行为函数的定义。在`ex9_1_c.s`中，我们应该寻找`rect_area`符号，而在`ex9_1_cpp.s`中，我们应该寻找`_ZN4Rect4AreaEv`符号。请注意，C++会对符号名称进行名称修饰，这就是为什么你需要搜索这个奇怪的符号。C++中的名称修饰已在*第2章*，*编译和链接*中讨论过。
- en: 'For the C program, the following is the generated assembly for the `rect_area`
    function:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于C程序，以下是为`rect_area`函数生成的汇编代码：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Shell Box 9-2: The generated assembly code of the rect_area function'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 9-2：rect_area函数生成的汇编代码
- en: 'The following is the generated assembly instructions for the `Rect::Area` function:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为`Rect::Area`函数生成的汇编指令：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Shell Box 9-3: The generated assembly code of the Rect::Area function'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 9-3：Rect::Area函数生成的汇编代码
- en: Unbelievably, they are exactly the same! I'm not sure how the C++ code turns
    into the preceding assembly code, but I'm sure that the assembly code generated
    for the preceding C function is almost, to high degree of accuracy, equivalent
    to the assembly code generated for the C++ function.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 令人难以置信的是，它们确实是相同的！我不确定C++代码是如何变成前面的汇编代码的，但我确信为前面的C函数生成的汇编代码几乎在高度精确的程度上与为C++函数生成的汇编代码相当。
- en: We can conclude from this that the C++ compiler has used a similar approach
    to that which we used in C, introduced as *implicit encapsulation* as part of
    *Chapter 6*, *OOP and Encapsulation*, to implement the encapsulation. Like what
    we did with implicit encapsulation, you can see in *Code Box 9-3* that a pointer
    to the attribute structure is passed to the `rect_area` function as the first
    argument.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，我们可以得出结论，C++编译器使用了与我们用于C的方法类似的方法，这作为*第6章*，*面向对象编程和封装*中*隐式封装*的一部分来实现封装。就像我们处理隐式封装一样，你可以在*代码框9-3*中看到，将属性结构的指针传递给`rect_area`函数作为第一个参数。
- en: As part of the boldened assembly instructions in both shell boxes, the `width`
    and `length` variables are being read by adding to the memory address passed as
    the first argument. The first pointer argument can be found in the `%rdi` register
    according to *System V ABI*. So, we can infer that C++ has changed the `Area`
    function to accept a pointer argument as its first argument, which points to the
    object itself.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个shell框中加粗的汇编指令部分，`width`和`length`变量是通过向第一个参数传递的内存地址添加来读取的。根据*System V ABI*，第一个指针参数可以在`%rdi`寄存器中找到。因此，我们可以推断C++已经将`Area`函数修改为接受一个指针参数作为其第一个参数，该参数指向对象本身。
- en: As a final word on encapsulation, we saw how C and C++ are closely related regarding
    encapsulation, at least in this simple example. Let's see if the same is true
    regarding inheritance as well.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 关于封装的最后一句话，我们看到了C和C++在封装方面密切相关，至少在这个简单的例子中是这样。让我们看看关于继承是否也是同样的情况。
- en: Inheritance
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: Investigating inheritance is easier than encapsulation. In C++, the pointers
    from a child class can be assigned to the pointers from the parent class. Also,
    the child class should have access to the private definition of the parent class.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 调查继承比封装更容易。在C++中，子类的指针可以被分配给父类的指针。此外，子类应该能够访问父类的私有定义。
- en: Both of these behaviors imply that C++ is using our first approach to implementing
    inheritance, which was discussed in the previous chapter, *Chapter 8, Inheritance
    and Polymorphism*, along with the second approach. Please refer back to the previous
    chapter if you need to remind yourself of the two approaches.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种行为都表明C++正在使用我们之前章节中讨论的第一种实现继承的方法，以及第二种方法。如果你需要提醒自己这两种方法，请参阅上一章。
- en: However, C++ inheritance seems more complex because C++ supports multiple inheritances
    that we can't support in our first approach. In this section, we will check the
    memory layouts of two objects instantiated from two similar classes in C and C++,
    as demonstrated in *example 9.2*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，C++的继承似乎更复杂，因为C++支持多重继承，而我们的第一种方法无法支持。在本节中，我们将检查从C和C++中两个类似类实例化的两个对象的内存布局，如*示例9.2*所示。
- en: '*Example 9.2* is about a simple class inheriting from another simple class,
    both of which have no behavior functions. The C version is as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9.2* 是关于一个简单的类从另一个简单的类继承，这两个类都没有行为函数。C 版本如下：'
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Code Box 9-5 [ExtremeC_examples_chapter9_2.c]: Inheritance example in C'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 9-5 [ExtremeC_examples_chapter9_2.c]：C 中的继承示例
- en: 'And the C++ version comes within the following code box:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 版本如下所示：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Code Box 9-6 [ExtremeC_examples_chapter9_2.cpp]: Inheritance example in C++'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 9-6 [ExtremeC_examples_chapter9_2.cpp]：C++ 中的继承示例
- en: 'Firstly, we need to compile the C program and use `gdb` to set a breakpoint
    on the last line of the `main` function. When the execution pauses, we can examine
    the memory layout as well as the existing values:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要编译 C 程序并使用 `gdb` 在 `main` 函数的最后一行设置断点。当执行暂停时，我们可以检查内存布局以及现有的值：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Shell Box 9-4: Running the C version of example 9.2 in gdb'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 9-4：在 gdb 中运行示例 9.2 的 C 版本
- en: 'As you can see, we have printed seven characters, starting from the address
    of `b` object, which are as follows: `''A''`, `''B''`, `''1''`, `''2''`, `''3''`,
    `''4''`, `''\0''`. Let''s do the same for the C++ code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已从 `b` 对象的地址开始打印了七个字符，如下所示：`'A'`、`'B'`、`'1'`、`'2'`、`'3'`、`'4'`、`'\0'`。让我们对
    C++ 代码也做同样的操作：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Shell Box 9-5: Running the C++ version of example 9.2 in gdb'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 9-5：在 gdb 中运行示例 9.2 的 C++ 版本
- en: As you can see in the preceding two shell boxes, the memory layout and the values
    stored in the attributes are the same. You shouldn't get confused by having the
    behavior functions and attributes together in a class in C++; they are going to
    be treated separately from the class. In C++, the attributes, no matter where
    you put them in a class, are always collected within the same memory block regarding
    a specific object, and functions will always be independent of the attributes,
    just as we saw when looking at *implicit encapsulation* as part of *Chapter 6*,
    *OOP and Encapsulation*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的两个 Shell 框中看到的，内存布局和存储在属性中的值是相同的。您不应该因为 C++ 中类中行为函数和属性一起出现而感到困惑；它们将作为类外部分别处理。在
    C++ 中，无论您在类中将属性放在哪里，它们总是收集在特定对象的同一内存块中，而函数将始终独立于属性，正如我们在 *第 6 章*、*面向对象编程和封装* 中查看
    *隐式封装* 时所看到的。
- en: 'The previous example demonstrates *single inheritance*. So, what about *multiple
    inheritance*? In the previous chapter, we explained why our first approach to
    implementing inheritance in C could not support multiple inheritance. We again
    demonstrate the reason in the following code box:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例演示了 *单继承*。那么，*多继承*又是如何呢？在前一章中，我们解释了为什么我们的 C 中实现继承的第一种方法不能支持多继承。我们再次在以下代码框中演示了原因：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Code Box 9-7: Demonstration of why multiple inheritance cannot work with our
    proposed first approach for implementing inheritance in C'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 9-7：演示为什么多继承不能与我们在 C 中实现继承的提议的第一种方法一起工作
- en: In the preceding code box, the `c_t` class desires to inherit both `a_t` and
    `b_t` classes. After declaring the classes, we create the `c_obj` object. In the
    following lines of preceding code, we create different pointers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码框中，`c_t` 类希望继承 `a_t` 和 `b_t` 类。在声明这些类之后，我们创建了 `c_obj` 对象。在前面代码的以下行中，我们创建了不同的指针。
- en: An important note here is that *all of these pointers must be pointing to the
    same address*. The `a_ptr` and `c_ptr` pointers can be used safely with any behavior
    function from the `a_t` and `c_t` classes, but the `b_ptr` pointer is dangerous
    to use because it is pointing to the a field in the `c_t` class, which is an `a_t`
    object. Trying to access the fields inside `b_t` through `b_ptr` results in an
    undefined behavior.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个重要注意事项是，*所有这些指针都必须指向相同的地址*。`a_ptr` 和 `c_ptr` 指针可以安全地与 `a_t` 和 `c_t` 类的任何行为函数一起使用，但
    `b_ptr` 指针的使用是危险的，因为它指向 `c_t` 类中的 a 字段，这是一个 `a_t` 对象。尝试通过 `b_ptr` 访问 `b_t` 内部的字段会导致未定义的行为。
- en: 'The following code is the correct version of the preceding code, where all
    pointers can be used safely:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是前面代码的正确版本，其中所有指针都可以安全使用：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Code Box 9-8: Demonstration of how casts should be updated to point to the
    correct fields'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 9-8：演示如何更新类型转换以指向正确的字段
- en: As you can see on the third line in *Code Box 9-8*, we have added the size of
    an `a_t` object to the address of `c_obj`; this eventually results in a pointer
    pointing to the `b` field in `c_t`. Note that casting in C does not do any magic;
    it is there to convert types and it doesn't modify the transferring value, the
    memory address in the preceding case. Eventually, after the assignment, the address
    from the right-hand side would be copied to the left-hand side.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在 *Code Box 9-8* 的第三行所见，我们已将 `a_t` 对象的大小添加到 `c_obj` 的地址中；这最终导致一个指向 `c_t` 中
    `b` 字段的指针。请注意，C 中的类型转换并不做任何魔法；它在那里是为了转换类型，并且不会修改传递的值，即前一个案例中的内存地址。最终，在赋值之后，右侧的地址会被复制到左侧。
- en: 'For now, let''s see the same example in C++ with a look at *example 9.3*. Suppose
    that we have a `D` class that inherits from three different classes, `A`, `B`,
    and `C`. The following is the code written for *example 9.3*:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 C++ 中的相同示例，并查看 *example 9.3*。假设我们有一个 `D` 类，它从三个不同的类 `A`、`B` 和 `C` 继承。以下是为
    *example 9.3* 编写的代码：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Code Box 9-9 [ExtremeC_examples_chapter9_3.cpp]: Multiple inheritance in C++'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 9-9 [ExtremeC_examples_chapter9_3.cpp]：C++ 中的多重继承
- en: 'Let''s compile the example and run it with `gdb`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译这个示例，并用 `gdb` 运行它：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Shell Box 9-6: Compiling and running example 9.3 in gdb'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 9-6：在 gdb 中编译和运行示例 9.3
- en: As you can see, the attributes are placed adjacent to each other. This shows
    that multiple objects of the parent classes are being kept inside the same memory
    layout of the `d` object. What about the `ap`, `bp`, `cp`, and `dp` pointers?
    As you can see, in C++, we can cast implicitly when assigning a child pointer
    to a parent pointer (upcasting).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，属性被放置在彼此相邻的位置。这表明父类中的多个对象被保存在 `d` 对象相同的内存布局中。那么 `ap`、`bp`、`cp` 和 `dp` 指针呢？如你所见，在
    C++ 中，当我们将子指针赋值给父指针（向上转型）时，可以隐式地进行类型转换。
- en: 'Let''s examine the values of these pointers in the current execution:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查当前执行中这些指针的值：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Shell Box 9-7: Printing the addresses stored in the pointers as part of example
    9.3'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 9-7：打印指针中存储的地址，作为示例 9.3 的一部分
- en: The preceding shell box shows that the starting address of the d object, shown
    as `$4`, is the same as the address being pointed to by ap, shown as `$1`. So,
    this clearly shows that C++ puts an object of the type *A* as the first field
    in the corresponding attribute structure of the *D* class. Based on the addresses
    in the pointers and the result we got from the `x` command, an object of the *B*
    type and then an object of the *C* type, are put into the same memory layout belonging
    to object `d`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 shell box 显示，`d` 对象的起始地址，显示为 `$4`，与 `ap` 所指向的地址相同，显示为 `$1`。因此，这清楚地表明 C++
    将类型 *A* 的对象作为 *D* 类相应属性结构中的第一个字段。基于指针中的地址和从 `x` 命令得到的结果，类型为 *B* 的对象然后是类型为 *C*
    的对象，被放入属于对象 `d` 的相同内存布局中。
- en: In addition, the preceding addresses show that the cast in C++ is not a passive
    operation, and it can perform some pointer arithmetic on the transferring address
    while converting the types. For example, in *Code Box 9-9*, while assigning the
    `bp` pointer in the `main` function, five bytes or `sizeof(A)`, are added to the
    address of `d`. This is done in order to overcome the problem we found in implementing
    multiple inheritance in C. Now, these pointers can easily be used in all behavior
    functions without needing to do the arithmetic yourself. As an important note,
    C casts and C++ casts are different, and you may see different behavior if you
    assume that C++ casts are as passive as C casts.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，前面的地址显示，C++ 中的类型转换不是一个被动的操作，它可以在转换类型的同时对传递的地址执行一些指针算术。例如，在 *Code Box 9-9*
    中，当在 `main` 函数中赋值 `bp` 指针时，地址上增加了五个字节或 `sizeof(A)`。这是为了克服我们在 C 中实现多重继承时遇到的问题。现在，这些指针可以很容易地用于所有行为函数，而无需你自己进行算术运算。作为一个重要的注意事项，C
    的类型转换和 C++ 的类型转换是不同的，如果你假设 C++ 的类型转换与 C 的类型转换一样被动，你可能会看到不同的行为。
- en: Now it's time to look at the similarities between C and C++ in the case of polymorphism.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看 C 和 C++ 在多态情况下的相似之处了。
- en: Polymorphism
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态
- en: 'Comparing the underlying techniques for having polymorphism in C and C++ is
    not an easy task. In the previous chapter, we came up with a simple method for
    having a polymorphic behavior function in C, but C++ uses a much more sophisticated
    mechanism to bring about polymorphism, though the basic underlying idea is still
    the same. If we want to generalize our approach for implementing polymorphism
    in C, we can do it as the pseudo-code that can be seen in the following code box:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 比较C和C++中实现多态的底层技术并不是一件容易的事情。在前一章中，我们提出了在C中实现多态行为函数的简单方法，但C++使用了一种更复杂的多态实现机制，尽管基本理念仍然是相同的。如果我们想将我们的方法推广到C中的多态实现，我们可以像以下代码框中的伪代码那样做：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Code Box 9-10: Pseudo-code demonstrating how virtual functions can be declared
    and defined in a C code'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框9-10：伪代码，演示了如何在C代码中声明和定义虚函数
- en: As you can see in the preceding pseudo-code, the parent class has to maintain
    a list of function pointers in its attribute structure. These function pointers
    (in the parent class) either point to the default definitions for the virtual
    functions, or they are null. The pseudo-class defined as part of *Code Box 9-10*
    has `m` non-virtual behavior functions and `n` virtual behavior functions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面伪代码中看到的，父类必须在它的属性结构中维护一个函数指针列表。这些函数指针（在父类中）要么指向虚函数的默认定义，要么是空的。作为*代码框9-10*的一部分定义的伪类有`m`个非虚行为函数和`n`个虚行为函数。
- en: '**Note**:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: Not all behavior functions are polymorphic. Polymorphic behavior functions are
    called virtual behavior functions or simply virtual functions. In some languages,
    such as Java, they are called *virtual methods*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有行为函数都是多态的。多态行为函数被称为虚行为函数或简单地称为虚函数。在某些语言中，例如Java，它们被称为*虚方法*。
- en: Non-virtual functions are not polymorphic, and you never get various behaviors
    by calling them. In other words, a call to a non-virtual function is a simple
    function call and it just performs the logic inside the definition and doesn't
    relay the call to another function. However, virtual functions need to redirect
    the call to a proper function, set by either the parent or the child constructor.
    If a child class wants to override some of the inherited virtual functions, it
    should update the virtual function pointers.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 非虚函数不是多态的，调用它们永远不会得到各种行为。换句话说，对非虚函数的调用只是一个简单的函数调用，它只是执行定义中的逻辑，并不将调用传递给另一个函数。然而，虚函数需要将调用重定向到由父类或子类构造函数设置的适当函数。如果一个子类想要覆盖一些继承的虚函数，它应该更新虚函数指针。
- en: '**Note**:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: The `void*` type for the output variables can be replaced by any other pointer
    type. I used a generic pointer to show that anything can be returned from the
    functions in the pseudo-code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 输出变量的`void*`类型可以被替换为任何其他指针类型。我使用了一个通用指针来表明伪代码中的函数可以返回任何东西。
- en: 'The following pseudo-code shows how a child class overrides a few of the virtual
    functions found in *Code Box 9-10*:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下伪代码显示了子类如何覆盖*代码框9-10*中找到的一些虚函数：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Code Box 9-11: Pseudo-code in C demonstrating how a child class can override
    some virtual functions inherited from the parent class'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框9-11：C语言中的伪代码，演示了子类如何覆盖从父类继承的一些虚函数
- en: As you can see in *Code Box 9-11*, the child class needs only to update a few
    pointers in the parent's attribute structure. C++ takes a similar approach. When
    you declare a behavior function as virtual (using the `virtual` keyword), C++
    creates an array of function pointers, pretty similar to the way we did in *Code
    Box 9-10*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在*代码框9-11*中看到的，子类只需要更新父类属性结构中的几个指针。C++采取了类似的方法。当你将行为函数声明为虚函数（使用`virtual`关键字）时，C++创建一个函数指针数组，这与我们在*代码框9-10*中做的方式非常相似。
- en: As you can see, we added one function pointer attribute for each virtual function,
    but C++ has a smarter way of keeping these pointers. It just uses an array called
    a *virtual table* or *vtable*. The virtual table is created when an object is
    about to be created. It is first populated while calling the constructor of the
    base class, and then as part of the constructor of the child class, just as we've
    shown in *Code Boxes 9-10* and *9-11*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们为每个虚函数添加了一个函数指针属性，但C++有更智能的方式来保持这些指针。它只是使用一个名为*虚表*或*vtable*的数组。虚表是在创建对象之前创建的。它首先在调用基类的构造函数时填充，然后作为子类构造函数的一部分，正如我们在*代码框9-10*和*9-11*中所示。
- en: Since the virtual table is only populated in the constructors, calling a polymorphic
    method in a constructor, either in the parent or in the child class, should be
    avoided, as its pointer may have not been updated yet and it might be pointing
    to an incorrect definition.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于虚表仅在构造函数中填充，因此应避免在父类或子类构造函数中调用多态方法，因为其指针可能尚未更新，可能指向错误的定义。
- en: As our last discussion regarding the underlying mechanisms used for having various
    object-oriented concepts in C and C++, we are going to talk about abstraction.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们关于C和C++中实现各种面向对象概念的底层机制的最后一次讨论，我们将讨论抽象。
- en: Abstract classes
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象类
- en: 'Abstraction in C++ is possible using *pure virtual* functions. In C++ if you
    define a member function as a virtual function and set it to zero, you have declared
    a pure virtual function. Look at the following example:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，可以使用*纯虚*函数来实现抽象。在C++中，如果你将成员函数定义为虚函数并将其设置为零，你就声明了一个纯虚函数。看看以下示例：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Code Box 9-12: The Eatable interface in C++'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 9-12：C++中的`Eatable`接口
- en: Inside the class `Eatable`, we have a `GetTaste` virtual function that is set
    to zero. `GetTaste` is a pure virtual function and makes the whole class abstract.
    You can no longer create objects from the *Eatable* type, and C++ doesn't allow
    this. In addition, *Eatable* is an interface, because all of its member functions
    are purely virtual. This function can be overridden in a child class.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在类`Eatable`内部，我们有一个被设置为零的`GetTaste`虚函数。`GetTaste`是一个纯虚函数，这使得整个类成为抽象类。你不能再从`*Eatable*`类型创建对象，C++不允许这样做。此外，`*Eatable*`是一个接口，因为它的所有成员函数都是纯虚的。这个函数可以在子类中被重写。
- en: 'The following shows a class that is overriding the `GetTaste` function:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个重写`GetTaste`函数的类的示例：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Code Box 9-13: Two child classes implementing the Eatable interface'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 9-13：实现`Eatable`接口的两个子类
- en: Pure virtual functions are remarkably similar to virtual functions. The addresses
    to the actual definitions are being kept in the virtual table in the same way
    as virtual functions, but with one difference. The initial values for the pointers
    of pure virtual functions are null, unlike the pointers of normal virtual functions,
    which need to point to a default definition while the construction is in progress.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 纯虚函数与虚函数非常相似。实际定义的地址以与虚函数相同的方式保存在虚表中，但有一个区别。纯虚函数指针的初始值是null，而正常虚函数的指针需要在构造过程中指向默认定义。
- en: Unlike a C compiler, which doesn't know anything about abstract types, a C++
    compiler is aware of abstract types and generates a compilation error if you try
    to create an object from an abstract type.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 与不知道抽象类型的C编译器不同，C++编译器知道抽象类型，如果你尝试从抽象类型创建对象，它会生成编译错误。
- en: In this section, we took various object-oriented concepts and compared them
    in C, using the techniques introduced in the past three chapters, and in C++,
    using the `g++` compiler. We showed that, in most cases, the approaches we employed
    are in accordance with the techniques that a compiler like `g++` uses.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们比较了使用过去三章中介绍的技术在C中使用和`g++`编译器在C++中使用的各种面向对象的概念，并比较了它们。我们展示了我们采用的方法在大多数情况下与`g++`之类的编译器使用的技巧是一致的。
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we concluded our exploration of topics in OOP, picking up from
    abstraction and moving on by showing the similarities between C and C++ regarding
    object-oriented concepts.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们总结了面向对象编程（OOP）主题的探索，从抽象开始，通过展示C和C++在面向对象概念方面的相似性继续前进。
- en: 'The following topics were discussed as part of this chapter:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了以下主题：
- en: Abstract classes and interfaces were initially discussed. Using them, we can
    have an interface or a partially abstract class, which could be used to create
    concrete child classes with polymorphic and different behaviors.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们最初讨论了抽象类和接口。使用它们，我们可以有一个接口或部分抽象的类，这可以用来创建具有多态和不同行为的具体子类。
- en: We then compared the output of the techniques we used in C to bring in some
    OOP features, with the output of what `g++` produces. This was to demonstrate
    how similar the results are. We concluded that the techniques that we employed
    can be very similar in their outcomes.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们然后将我们在C中使用的技术带来的面向对象特征的输出与`g++`产生的输出进行了比较。这是为了展示结果是多么相似。我们得出结论，我们采用的技术在结果上可以非常相似。
- en: We discussed virtual tables in greater depth.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们更深入地讨论了虚拟表。
- en: We showed how pure virtual functions (which is a C++ concept but does have a
    C counterpart) can be used to declare virtual behaviors that have no default definition.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们展示了如何使用纯虚函数（这是一个C++概念，但确实有一个C语言的对应物）来声明没有默认定义的虚拟行为。
- en: The next chapter is about Unix and its correspondence to C. It will review the
    history of Unix and the invention of C. It will also explain the layered architecture
    of a Unix system.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍Unix及其与C的关系。它将回顾Unix的历史和C的发明。它还将解释Unix系统的分层架构。
