- en: Developing GUI Applications in C++
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C++中开发GUI应用程序
- en: 'In this chapter, you will learn the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下主题：
- en: A brief overview of Qt
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt简要概述
- en: The Qt Framework
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt框架
- en: Installing Qt on Ubuntu
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Ubuntu上安装Qt
- en: Developing Qt Core application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发Qt核心应用程序
- en: Developing a Qt GUI application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发Qt GUI应用程序
- en: Using layouts in the Qt GUI application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Qt GUI应用程序中使用布局
- en: Understanding signals and slots for event handling
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解事件处理的信号和槽
- en: Using multiple layouts in the Qt application
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Qt应用程序中使用多个布局
- en: 'Qt is a cross-platform application framework developed in C++. It is supported
    on various platforms, including Windows, Linux, Mac OS, Android, iOS, Embedded
    Linux, QNX, VxWorks, Windows CE/RT, Integrity, Wayland, X11, Embedded Devices,
    and so on. It is primarily used as a **human-machine-interface** (**HMI**) or
    **Graphical User Interface** (**GUI**) framework; however, it is also used to
    develop a **command-line interface** (**CLI**) applications. The correct way of
    pronouncing Qt is *cute*. The Qt application framework comes in two flavors: open
    source and with a commercial license.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Qt是一个用C++开发的跨平台应用程序框架。它支持多个平台，包括Windows、Linux、Mac OS、Android、iOS、嵌入式Linux、QNX、VxWorks、Windows
    CE/RT、Integrity、Wayland、X11、嵌入式设备等。它主要用作人机界面（HMI）或图形用户界面（GUI）框架；但也用于开发命令行界面（CLI）应用程序。正确发音为“cute”。Qt应用程序框架有两种版本：开源版本和商业许可版本。
- en: Qt is the brainchild of Haavard Nord and Eirik Chambe-Eng, the original developers,
    who developed it back in the year 1991.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Qt是Haavard Nord和Eirik Chambe-Eng的心血结晶，他们是最初的开发人员，在1991年开发了它。
- en: As C++ language doesn't support GUI natively, you must have guessed that there
    is no event management support in C++ language out of the box. Hence, there was
    a need for Qt to support its own event handling mechanism, which led to the signals
    and slots technique. Under the hood, signals and slots use the **observer design
    pattern** that allows Qt objects to talk to each other. Does this sound too hard
    to understand? No worries! Signals are nothing but events, such as a button click
    or window close, and slots are event handlers that can supply a response to these
    events in the way you wish to respond to them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C++语言本身不支持GUI，你可能已经猜到了，C++语言本身并不支持事件管理。因此，Qt需要支持自己的事件处理机制，这导致了信号和槽技术的出现。在底层，信号和槽使用了观察者设计模式，允许Qt对象相互通信。这听起来太难理解了吗？别担心！信号只是事件，比如按钮点击或窗口关闭，而槽是事件处理程序，可以以你希望的方式对这些事件做出响应。
- en: To make our life easier in terms of Qt application development, Qt supports
    various macros and Qt-specific keywords. As these keywords will not be understood
    by C++, Qt has to translate them and the macros into pure C++ code so that the
    C++ compiler can do its job as usual. To make this happen in a smoother fashion,
    Qt supports something called **Meta-Object Compiler**, also known as **moc**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们在Qt应用程序开发方面的生活更加轻松，Qt支持各种宏和Qt特定的关键字。由于这些关键字不会被C++理解，Qt必须将它们和宏转换为纯粹的C++代码，以便C++编译器可以像往常一样工作。为了使这一切更加顺利，Qt支持一种称为“元对象编译器”的东西，也被称为“moc”。
- en: Qt is a natural choice for C++ projects as it is out-and-out C++ code; hence,
    as a C++ developer, you will feel at home when you use Qt in your application.
    A typical application will have both complex logic and impressive UI. In small
    product teams, typically one developer does multiple stuff, which is good and
    bad.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Qt是C++项目的自然选择，因为它是纯粹的C++代码；因此，作为C++开发人员，在应用程序中使用Qt时会感到宾至如归。一个典型的应用程序将同时具有复杂的逻辑和令人印象深刻的UI。在小型产品团队中，通常一个开发人员会做多种工作，这既有利也有弊。
- en: Generally, professional developers have good problem-solving skills. Problem-solving
    skills are essential to solve a complex problem in an optimal fashion with a good
    choice of data structures and algorithms.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，专业开发人员具有良好的问题解决能力。问题解决能力对于以最佳方式解决复杂问题并选择良好的数据结构和算法至关重要。
- en: Developing an impressive UI requires creative design skills. While there are
    a countable number of developers who are either good at problem-solving or creative
    UI design, not all developers are good at both. This is where Qt stands out.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 开发令人印象深刻的UI需要创造性的设计技能。虽然有一定数量的开发人员擅长问题解决或创造性UI设计，但并非所有开发人员都擅长这两者。这就是Qt的优势所在。
- en: Say a start-up wants to develop an application for their internal purposes.
    For this, a simple GUI application would suffice, where a decent looking HMI/GUI
    might work for the team as the application is meant for internal purposes only.
    In such scenarios, the entire application can be developed in C++ and the Qt Widgets
    framework. The only prerequisite is that the development team must be proficient
    in C++.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，一家初创公司想要为内部目的开发一个应用程序。对于这个目的，一个简单的GUI应用程序就足够了，一个看起来不错的HMI/GUI可能对团队有用，因为应用程序只是为内部目的而设计的。在这种情况下，整个应用程序可以使用C++和Qt
    Widgets框架开发。唯一的前提是开发团队必须精通C++。
- en: However, in cases where a mobile app has to be developed, an impressive HMI
    becomes mandatory. Again, the mobile app can be developed with C++ and Qt Widgets.
    But now there are two parts to this choice. The good part is that the mobile app
    team has to be good at just C++. The bad part of this choice is that there is
    no guarantee that all good C++ developers will be good at designing a mobile app's
    HMI/GUI.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在必须开发移动应用程序的情况下，令人印象深刻的HMI变得必不可少。同样，移动应用程序可以使用C++和Qt Widgets开发。但现在这个选择有两个部分。好的一面是移动应用程序团队只需要擅长C++。这个选择的坏处是，并不是所有擅长C++的开发人员都擅长设计移动应用程序的HMI/GUI。
- en: Let's assume the team has one or two dedicated Photoshop professionals who are
    good at creating catchy images that can be used in the GUI and one or two UI designers
    who can make an impressive HMI/GUI with the images created by the Photoshop experts.
    Typically, UI designers are good at frontend technologies, such as JavaScript,
    HTML, and CSS. Complex business logic can be developed in the powerful Qt Framework,
    while the HMI/GUI can be developed in QML.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 假设团队有一两个专门的Photoshop专业人员，擅长创建引人注目的图像，可以在GUI中使用，还有一两个UI设计师，可以使用Photoshop专家创建的图像制作出令人印象深刻的HMI/GUI。通常，UI设计师擅长前端技术，如JavaScript、HTML和CSS。强大的Qt框架可以开发复杂的业务逻辑，而HMI/GUI可以在QML中开发。
- en: QML is a declarative scripting language that comes along with the Qt application
    framework. It is close to JavaScript and has Qt-specific extensions. It is good
    for rapid application development and allows UI designers to focus on HMI/GUI
    and C++ developers to focus on the complex business logic that can be developed
    in Qt Framework.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: QML是与Qt应用程序框架一起提供的一种声明性脚本语言。它类似于JavaScript，并具有Qt特定的扩展。它非常适合快速应用程序开发，并允许UI设计师专注于HMI/GUI，而C++开发人员则专注于可以在Qt框架中开发的复杂业务逻辑。
- en: Since both the C++ Qt Framework and QML are part of the same Qt application
    framework, they go hand in hand seamlessly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C++ Qt框架和QML都是同一Qt应用程序框架的一部分，它们可以无缝地配合使用。
- en: Qt is a vast and powerful framework; hence this chapter will focus on the basic
    essentials of Qt to get you started with Qt. If you are curious to learn more,
    you may want to check out my other upcoming book that I'm working on, namely *Mastering
    Qt and QML Programming*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Qt是一个庞大而强大的框架；因此，本章将重点介绍Qt的基本要点，以帮助您开始使用Qt。如果您想了解更多信息，您可能想查看我正在撰写的另一本即将推出的书，名为*精通Qt和QML编程*。
- en: Qt
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt
- en: The Qt Framework is developed in C++, hence it is guaranteed that it would be
    a cake walk for any good C++ developer. It supports CLI and GUI-based application
    development. At the time of writing this chapter, the latest version of the Qt
    application framework is Qt 5.7.0\. By the time you read this book, it is possible
    that a different version of Qt will be available for you to download. You can
    download the latest version from [https://www.qt.io](https://www.qt.io).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Qt框架是用C++开发的，因此可以保证对任何优秀的C++开发人员来说都是易如反掌。它支持CLI和基于GUI的应用程序开发。在撰写本章时，Qt应用程序框架的最新版本是Qt
    5.7.0。当您阅读本书时，可能会有不同版本的Qt可供您下载。您可以从[https://www.qt.io](https://www.qt.io)下载最新版本。
- en: Installing Qt 5.7.0 in Ubuntu 16.04
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Ubuntu 16.04中安装Qt 5.7.0
- en: Throughout this chapter, I'll be using Ubuntu 16.04 OS; however, the programs
    that are listed in this chapter should work on any platform that supports Qt.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将使用Ubuntu 16.04操作系统；但是，本章中列出的程序应该适用于支持Qt的任何平台。
- en: For detailed installation instructions, refer to [https://wiki.qt.io/install_Qt_5_on_Ubuntu](https://wiki.qt.io/install_Qt_5_on_Ubuntu).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有关详细的安装说明，请参阅[https://wiki.qt.io/install_Qt_5_on_Ubuntu](https://wiki.qt.io/install_Qt_5_on_Ubuntu)。
- en: 'At this point, you should have a C++ compiler installed on your system. If
    this is not the case, first ensure that you install a C++ compiler, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您应该在系统上安装了C++编译器。如果不是这种情况，请首先确保您安装了C++编译器，方法如下：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'From the Ubuntu Terminal, you should be able to download Qt 5.7.0, as shown
    in the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从Ubuntu终端，您应该能够下载Qt 5.7.0，如下命令所示：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Provide execute permission to the downloaded installer, as shown in the following
    command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为下载的安装程序提供执行权限，如下命令所示：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: I strongly recommend that you install Qt along with its source code. You can
    get help directly from the source code if you prefer to look up Qt Help the geeky
    way.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议您安装Qt及其源代码。如果您喜欢用极客的方式查找Qt帮助，您可以直接从源代码获取帮助。
- en: 'Launch the installer as shown in the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 启动安装程序，如下命令所示：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As Qt makes use of OpenGL, make sure you install the following before you start
    writing your first program in Qt. To install `libfontconfig1`, run the following
    command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Qt使用OpenGL，请确保在开始编写Qt中的第一个程序之前安装以下内容。要安装`libfontconfig1`，请运行以下命令：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To install `mesa-common-dev`, run the following command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`mesa-common-dev`，请运行以下命令：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'At this point, you should have a working Qt setup. You can verify the installation
    by issuing the following command in the Linux Terminal:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您应该有一个可用的Qt设置。您可以通过在Linux终端中发出以下命令来验证安装：
- en: '![](img/65eecd53-89f0-449e-8cab-d9358b5d29c6.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/65eecd53-89f0-449e-8cab-d9358b5d29c6.png)'
- en: Figure 5.1
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1
- en: 'In case the `qmake` command isn''t recognized, make sure you export the `bin`
    path of the Qt installation folder, as shown in the preceding screenshot. Additionally,
    creating a soft link might be useful too. The command for this is as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`qmake`命令无法识别，请确保导出Qt安装文件夹的`bin`路径，如前面的屏幕截图所示。此外，创建软链接也可能很有用。此命令如下：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The path where Qt is installed on your system might vary from mine, so please
    substitute the Qt path accordingly.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Qt在您的系统上安装的路径可能与我的不同，请相应地替换Qt路径。
- en: Qt Core
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt Core
- en: Qt Core is one of the modules supported by Qt. This module has loads of useful
    classes, such as `QObject`, `QCoreApplication`, `QDebug`, and so on. Almost every
    Qt application will require this module, hence they are linked implicitly by the
    Qt Framework. Every Qt class inherits from `QObject`, and the `QObject` class
    offers event handling support to Qt applications. `QObject` is the critical piece
    that supports the event handling mechanism; interestingly, even console-based
    applications can support event handling in Qt.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Core是Qt支持的模块之一。该模块具有大量有用的类，例如`QObject`、`QCoreApplication`、`QDebug`等。几乎每个Qt应用程序都需要此模块，因此它们会被Qt框架隐式链接。每个Qt类都继承自`QObject`，而`QObject`类为Qt应用程序提供事件处理支持。`QObject`是支持事件处理机制的关键部分；有趣的是，即使是基于控制台的应用程序也可以在Qt中支持事件处理。
- en: Writing our first Qt console application
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写我们的第一个Qt控制台应用程序
- en: 'If you get a similar output to that shown in *Figure 5.1*, you are all set
    to get your hands dirty. Let''s write our first Qt application, as shown in the
    following screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您得到了类似于*图5.1*所示的输出，那么您已经准备好动手了。让我们编写我们的第一个Qt应用程序，如下面的屏幕截图所示：
- en: '**![](img/460071b9-e368-4f76-b890-59164cb1120a.png)**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/460071b9-e368-4f76-b890-59164cb1120a.png)**'
- en: Figure 5.2
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2
- en: In the first line, we have included the QDebug header from the **QtCore** module.
    If you observe closely, the `qDebug()` function resembles the C++ `cout ostream`
    operator. The `qDebug()` function is going to be your good friend in the Qt world
    while you are debugging your code. The `QDebug` class has overloaded the C++ `ostream`
    operator in order to add support for Qt data types that aren't supported by the
    C++ compiler.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，我们从**QtCore**模块中包含了QDebug头文件。如果您仔细观察，`qDebug()`函数类似于C++的`cout ostream`操作符。在Qt世界中，当您调试代码时，`qDebug()`函数将成为您的好朋友。`QDebug`类已经重载了C++的`ostream`操作符，以支持Qt数据类型，这些类型不受C++编译器支持。
- en: In old school fashion, I'm kind of obsessed with the Terminal to achieve pretty
    much anything while coding as opposed to using some fancy **Integrated Development
    Environments** (**IDEs**). You may either love or hate this approach, which is
    quite natural. The good part is there is nothing going to stand between you and
    Qt/C++ as you are going to use plain and simple yet powerful text editors, such
    as Vim, Emacs, Sublime Text, Atom, Brackets, or Neovim, so you will learn almost
    all the essentials of how Qt projects and qmake work; IDEs make your life easy,
    but they hide a lot of the essential stuff that every serious developer must know.
    So it's a trade-off. I leave it to you to decide whether to use your favorite
    plain text editor or Qt Creator IDE or any other fancy IDE. I'm going to stick
    with the refactored Vim editor called Neovim, which looks really cool. *Figure
    5.2* will give you an idea of the Neovim editor's look and feel.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以老派的方式，我对终端有点着迷，可以在编码时实现几乎任何功能，而不是使用一些花哨的**集成开发环境**（**IDE**）。您可能会喜欢或讨厌这种方法，这是很自然的。好处是在Qt/C++中，您可以使用简单而强大的文本编辑器，如Vim、Emacs、Sublime
    Text、Atom、Brackets或Neovim，学习几乎所有Qt项目和qmake的基本知识；IDE可以让您的生活变得更轻松，但它们隐藏了许多每个严肃开发人员都必须了解的基本内容。所以这是一个权衡。我把决定权交给您，决定是使用您喜欢的纯文本编辑器、Qt
    Creator IDE还是其他花哨的IDE。我将坚持使用经过重构的Vim编辑器Neovim，看起来真的很酷。*图5.2*将给您一个关于Neovim编辑器外观和感觉的想法。
- en: Let's get back to business. Let's see how to compile this code in the command
    line the geeky way. Well, before that, you may want to know about the qmake tool.
    It is a proprietary `make` utility of Qt. The `qmake` utility is nothing more
    than a make tool, but it is aware of Qt-specific stuff so it knows about moc,
    signals, slots, and so on, which a typical `make` utility will be unaware of.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到正题。让我们看看如何以极客的方式在命令行中编译这段代码。在此之前，您可能想了解一下`qmake`工具。它是Qt的专有`make`实用程序。`qmake`实用程序不过是一个make工具，但它知道Qt特定的东西，因此它了解moc、signals、slots等，而典型的`make`实用程序则不知道。
- en: The following command should help you create a `.pro` file. The name of the
    `.pro` file will be decided by the `qmake` utility, based on the project folder
    name. The `.pro` file is the way the Qt Creator IDE combines related files as
    a single project. Since we aren't going to use Qt Creator, we will use the `.pro`
    file to create `Makefile` in order to compile our Qt project just like a plain
    C++ project.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令应该帮助您创建一个`.pro`文件。`.pro`文件的名称将由`qmake`实用程序根据项目文件夹名称决定。`.pro`文件是Qt Creator
    IDE将相关文件组合为单个项目的方式。由于我们不打算使用Qt Creator，我们将使用`.pro`文件创建`Makefile`，以便编译我们的Qt项目，就像编译普通的C++项目一样。
- en: '![](img/9c35fec8-d8ec-4996-91cb-6efd36564961.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c35fec8-d8ec-4996-91cb-6efd36564961.png)'
- en: Figure 5.3
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3
- en: 'When you issue the `qmake -project` command, qmake will scan through the current
    folder and all the subfolders under the current folder and include the headers
    and source files in `Ex1.pro`. By the way, the `.pro` file is a plain text file
    that can be opened using any text editor, as shown in *Figure 5.4*:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当您发出`qmake -project`命令时，qmake将扫描当前文件夹和当前文件夹下的所有子文件夹，并在`Ex1.pro`中包含头文件和源文件。顺便说一句，`.pro`文件是一个纯文本文件，可以使用任何文本编辑器打开，如*图5.4*所示：
- en: '![](img/590b8f23-7f56-44bd-b213-1003080d7ab9.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/590b8f23-7f56-44bd-b213-1003080d7ab9.png)'
- en: Figure 5.4
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4
- en: 'Now it''s time to create `Makefile` taking `Ex1.pro` as an input file. As the
    `Ex1.pro` file is present in the current directory, we don''t have to explicitly
    supply `Ex1.pro` as an input file to autogenerate `Makefile`. The idea is that
    once we have a `.pro` file, all we would need to do is generate `Makefile` from
    the `.pro` file issuing command: `qmake`. This will do all the magic of creating
    a full-blown `Makefile` for your project that you can use to build your project
    with the `make` utility, as shown in the following screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建`Makefile`，以`Ex1.pro`作为输入文件。由于`Ex1.pro`文件存在于当前目录中，我们不必显式提供`Ex1.pro`作为自动生成`Makefile`的输入文件。这个想法是，一旦我们有了`.pro`文件，我们只需要从`.pro`文件生成`Makefile`，发出命令：`qmake`。这将完成创建一个完整的`Makefile`的魔术，您可以使用`make`实用程序构建您的项目，如下面的屏幕截图所示：
- en: '![](img/cd138708-cae8-4ef5-bb3e-92cc989c010f.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd138708-cae8-4ef5-bb3e-92cc989c010f.png)'
- en: Figure 5.5
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5
- en: 'This is the point we have been waiting for, right? Yes, let''s execute our
    first Qt Hello World program, as shown in the following screenshot:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们一直在等待的时刻，对吧？是的，让我们执行我们的第一个Qt Hello World程序，如下面的屏幕截图所示：
- en: '![](img/acf0f31e-0484-41dc-970f-16c32065772d.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/acf0f31e-0484-41dc-970f-16c32065772d.png)'
- en: Figure 5.6
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6
- en: Congratulations! You have completed your first Qt application. In this exercise,
    you learned how to set up and configure Qt in Ubuntu and how to write a simple
    Qt console application and then build and run it. The best part is you learned
    all of this from the command line.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经完成了您的第一个Qt应用程序。在这个练习中，您学会了如何在Ubuntu中设置和配置Qt，以及如何编写一个简单的Qt控制台应用程序，然后构建和运行它。最好的部分是您从命令行学会了所有这些。
- en: Qt Widgets
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt小部件
- en: Qt Widgets is an interesting module that supports quite a lot of widgets, such
    as buttons, labels, edit, combo, list, dialog, and so on. `QWidget` is the base
    class of all of the widgets, while `QObject` is the base class of pretty much
    every Qt class. While many programming languages refer to as UI controls, Qt refers
    to them as widgets. Though Qt works on many platforms, its home remains Linux;
    widgets are common in the Linux world.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Widgets是一个有趣的模块，支持许多小部件，如按钮、标签、编辑、组合、列表、对话框等。`QWidget`是所有小部件的基类，而`QObject`是几乎每个Qt类的基类。许多编程语言称之为UI控件，Qt称之为小部件。尽管Qt可以在许多平台上运行，但它的主要平台仍然是Linux；小部件在Linux世界中很常见。
- en: Writing our first Qt GUI application
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写我们的第一个Qt GUI应用程序
- en: 'Our first console application is really cool, isn''t it? Let''s continue exploring
    further. This time, let''s write a simple GUI-based Hello World program. The procedure
    will remain almost the same, except for some minor changes in `main.cpp`. Refer
    to the following for the complete code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个控制台应用程序真的很酷，不是吗？让我们继续探索。这一次，让我们编写一个简单的基于GUI的Hello World程序。过程基本上是一样的，只是在`main.cpp`中有一些小的改变。请参考以下完整的代码：
- en: '![](img/6c567df7-c593-487b-b19b-ad47dec36316.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c567df7-c593-487b-b19b-ad47dec36316.png)'
- en: Figure 5.7
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7
- en: Wait a minute. Let me explain the need for `QApplication` in line number 23
    and line number 29\. Every Qt GUI application must have exactly one instance of
    the `QApplication` instance. `QApplication` provides support for command-line
    switches for our application, hence the need to supply the **argument count**
    (**argc**) and the **argument value** (**argv**). GUI-based applications are event-driven,
    so they must respond to events or, to be precise, signals in the Qt world. In
    line number 29, the `exec` function starts the `event` loop, which ensures the
    application waits for user interactions until the user closes the window. The
    idea is that all the user events will be received by the `QApplication` instance
    in an event queue, which will then be notified to its `Child` widgets. The event
    queue ensures all the events deposited in the queue are handled in the same sequence
    that they occur, that is, **first in, first out** (**FIFO**).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下。让我解释一下为什么第23行和第29行需要`QApplication`。每个Qt GUI应用程序必须有一个`QApplication`实例。`QApplication`为我们的应用程序提供了命令行开关的支持，因此需要提供**参数计数**（**argc**）和**参数值**（**argv**）。基于GUI的应用程序是事件驱动的，因此它们必须响应Qt世界中的事件或者更准确地说是信号。在第29行，`exec`函数启动了`event`循环，这确保应用程序等待用户交互，直到用户关闭窗口。所有用户事件将被接收到`QApplication`实例的事件队列中，然后通知给它的`Child`小部件。事件队列确保队列中存放的所有事件按照它们发生的顺序处理，即**先进先出**（**FIFO**）。
- en: In case you are curious to check what would happen if you comment line 29, the
    application will still compile and run but you may not see any window. The reason
    being the `main` thread or the `main` function creates an instance of `QWidget`
    in line number 25, which is the window that we see when we launch the application.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇地想要检查一下，如果你注释掉第29行会发生什么，应用程序仍然会编译和运行，但你可能看不到任何窗口。原因是`main`线程或`main`函数在第25行创建了一个`QWidget`的实例，这就是我们启动应用程序时看到的窗口。
- en: In line number 27, the window instance is displayed, but in the absence of line
    number 29, the `main` function will terminate the application immediately without
    giving a chance for you to check your first Qt GUI application. It's worth trying,
    so go ahead and see what happens with and without line number 29.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在第27行，窗口实例被显示，但在没有第29行的情况下，`main`函数将立即终止应用程序，而不给你检查你的第一个Qt GUI应用程序的机会。值得一试，所以继续看看有没有第29行会发生什么。
- en: 'Let''s generate `Makefile`, as shown in the following screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们生成`Makefile`，如下面的截图所示：
- en: '![](img/dc59da08-63b8-4545-9836-1c38e2c4189d.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc59da08-63b8-4545-9836-1c38e2c4189d.png)'
- en: Figure 5.8
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8
- en: 'Now let''s try to compile our project with the `make` utility, as shown in
    the following screenshot:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试使用`make`工具编译我们的项目，如下面的截图所示：
- en: '![](img/ff336644-971b-4307-b438-2ffe7361eaf6.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff336644-971b-4307-b438-2ffe7361eaf6.png)'
- en: Figure 5.9
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9
- en: 'Interesting, right? Our brand new Qt GUI program fails to compile. Did you
    notice the fatal error? No big deal; let''s understand why this happened. The
    reason is that we have not yet linked the Qt Widgets module, as the `QApplication`
    class is part of the Qt Widgets module. In that case, you may wonder how your
    first Hello World program compiled without any issue. In our first program, the `QDebug`
    class was part of the **QtCore** module that got linked implicitly, whereas other
    modules had to be linked explicitly. Let''s see how to get this done:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣，对吧？我们全新的Qt GUI程序无法编译。你注意到致命错误了吗？没关系，让我们了解一下为什么会发生这种情况。原因是我们还没有链接Qt Widgets模块，因为`QApplication`类是Qt
    Widgets模块的一部分。在这种情况下，你可能会想知道为什么你的第一个Hello World程序可以编译而没有任何问题。在我们的第一个程序中，`QDebug`类是**QtCore**模块的一部分，它隐式地被链接，而其他模块必须显式地被链接。让我们看看如何解决这个问题：
- en: '![](img/45cc4ead-89d9-4f78-9f2e-5dea69c94b2e.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/45cc4ead-89d9-4f78-9f2e-5dea69c94b2e.png)'
- en: Figure 5.10
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10
- en: 'We need to add `QT += widgets` to the `Ex2.pro` file so that the `qmake` utility
    understands that it needs to link Qt Widgets''s **shared object** (the `.so` file)
    in Linux, also known as the **Dynamic Link Library** (the `.dll` file) in Windows,
    while creating the final executable. Once this is taken care of, we must `qmake` so
    that `Makefile` could reflect the new change in our `Ex2.pro` file, as demonstrated
    in the following screenshot:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`Ex2.pro`文件中添加`QT += widgets`，这样`qmake`工具就能理解在创建最终可执行文件时需要链接Qt Widgets的**共享对象**（在Linux中是`.so`文件），也就是在Windows中被称为**动态链接库**（`.dll`文件）。一旦这个问题得到解决，我们必须运行`qmake`，这样`Makefile`就能反映出我们`Ex2.pro`文件中的新变化，如下面的截图所示：
- en: '![](img/14886507-41d6-436d-81fa-40f95117fbdc.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/14886507-41d6-436d-81fa-40f95117fbdc.png)'
- en: Figure 5.11
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11
- en: 'Cool. Let''s check our first GUI-based Qt app now. In my system, the application
    output looks as shown in *Figure 5.12;* you should get a similar output as well if
    all goes well at your end:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。现在让我们检查我们的第一个基于GUI的Qt应用程序。在我的系统中，应用程序输出如*图5.12*所示；如果一切顺利，您也应该得到类似的输出：
- en: '![](img/0f688d71-2a1a-4879-8c9f-84179d1e1e82.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f688d71-2a1a-4879-8c9f-84179d1e1e82.png)'
- en: Figure 5.12
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.12
- en: 'It would be nice if we set the title of our window as `Hello Qt`, right? Let''s
    do this right away:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将窗口的标题设置为`Hello Qt`，那就太好了，对吧？让我们马上做到这一点：
- en: '![](img/37d8967f-b767-4ab1-8b00-ea6011eda546.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/37d8967f-b767-4ab1-8b00-ea6011eda546.png)'
- en: Figure 5.13
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.13
- en: 'Add the code presented at line number 26 to ensure you build your project with
    the `make` utility before you test your new change:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 添加第26行呈现的代码，以确保在测试新更改之前使用`make`实用程序构建项目：
- en: '![](img/0600d685-72d1-43bb-94c3-902244b571d6.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0600d685-72d1-43bb-94c3-902244b571d6.png)'
- en: Figure 5.14
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.14
- en: Layouts
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局
- en: Qt is cross-platform application framework, hence it supports concepts such
    as layouts for developing applications that look consistent in all platforms,
    irrespective of the different screen resolutions. When we develop GUI/HMI-based
    Qt applications, an application developed in one system shouldn't appear different
    on another system with a different screen size and resolution. This is achieved
    in the Qt Framework via layouts. Layouts come in different flavors. This helps
    a developer design a professional-looking HMI/GUI by organizing various widgets
    within a window or dialog. Layouts differ in the way they arrange their child
    widgets. While one arranges its child widgets in a horizontal fashion, another
    will arrange them in a vertical or grid fashion. When a window or dialog gets
    resized, the layouts resize their child widgets so they don't get truncated or
    go out of focus.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Qt是跨平台应用程序框架，因此支持诸如布局之类的概念，用于开发在所有平台上看起来一致的应用程序，而不管不同的屏幕分辨率如何。当我们开发基于GUI/HMI的Qt应用程序时，在一个系统中开发的应用程序不应该在具有不同屏幕大小和分辨率的另一个系统上看起来不同。这是通过布局在Qt框架中实现的。布局有不同的风格。这有助于开发人员通过在窗口或对话框中组织各种小部件来设计专业外观的HMI/GUI。布局在安排其子小部件的方式上有所不同。一个布局以水平方式排列其子小部件，另一个则以垂直或网格方式排列。当窗口或对话框调整大小时，布局会调整其子小部件，以便它们不会被截断或失焦。
- en: Writing a GUI application with a horizontal layout
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用水平布局编写GUI应用程序
- en: Let's write a Qt application that has a couple of buttons in the dialog. Qt
    supports a variety of useful layout managers that act as an invisible canvas where
    many `QWidgets` can be arranged before they are attached to a window or dialog.
    Each dialog or window can have only one layout. Every widget can be added to only
    one layout; however, many layouts can be combined to design a professional UI.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个Qt应用程序，在对话框中放置一些按钮。Qt支持各种有用的布局管理器，它们充当一个无形的画布，在那里可以将许多`QWidgets`排列好，然后再将它们附加到窗口或对话框上。每个对话框或窗口只能有一个布局。每个小部件只能添加到一个布局中；但是，可以组合多个布局来设计专业的用户界面。
- en: Let's start writing the code now. In this project, we are going to write code
    in a modular fashion, hence we are going to create three files with the names
    `MyDlg.h`, `MyDlg.cpp`, and `main.cpp`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始编写代码。在这个项目中，我们将以模块化的方式编写代码，因此我们将创建三个文件，分别命名为`MyDlg.h`、`MyDlg.cpp`和`main.cpp`。
- en: 'The game plan is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏计划如下：
- en: Create a single instance of `QApplication`.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`QApplication`的单个实例。
- en: Create a custom dialog by inheriting `QDialog`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过继承`QDialog`创建自定义对话框。
- en: Create three buttons.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个按钮。
- en: Create a horizontal box layout.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个水平框布局。
- en: Add the three buttons to the invisible horizontal box layout.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将三个按钮添加到不可见的水平框布局中。
- en: Set the horizontal box layout's instance as our dialog's layout.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将水平框布局的实例设置为我们对话框的布局。
- en: Show the dialog.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示对话框。
- en: Start the event loop on `QApplication`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`QApplication`上启动事件循环。
- en: It is important that we follow clean code practices so that our code is easy
    to understand and can be maintained by anyone. As we are going to follow industry
    best practices, let's declare the dialog in a header file called `MyDlg.h`, define
    the dialog in the source file called `MyDlg.cpp`, and use `MyDlg.cpp` in `main.cpp`
    that has the `main` function. Every time `MyDlg.cpp` requires a header file, let's
    make it a practice to include all the headers only in `MyDlg.h`; with this, the
    only header we will see in `MyDlg.cpp` is `MyDlg.h`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，我们遵循清晰的代码规范，以便我们的代码易于理解，并且可以由任何人维护。由于我们将遵循行业最佳实践，让我们在名为`MyDlg.h`的头文件中声明对话框，在名为`MyDlg.cpp`的源文件中定义对话框，并在具有`main`函数的`main.cpp`中使用`MyDlg.cpp`。每次`MyDlg.cpp`需要一个头文件时，让我们养成一个习惯，只在`MyDlg.h`中包含所有头文件；通过这样做，我们在`MyDlg.cpp`中看到的唯一头文件将是`MyDlg.h`。
- en: By the way, did I tell you Qt follows the camel casing coding convention? Yes,
    I did mention it right now. By now, you will have observed that all Qt classes
    start with the letter *Q* because Qt inventors loved the letter "Q" in Emacs and
    they were so obsessed with that font type that they decided to use the letter
    Q everywhere in Qt.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，我有没有告诉过你Qt遵循驼峰命名约定？是的，我刚刚提到了。到目前为止，您可能已经注意到所有Qt类都以字母*Q*开头，因为Qt的发明者喜欢Emacs中的字母“Q”，他们对该字体类型如此着迷，以至于决定在Qt中到处使用字母Q。
- en: 'One last suggestion. Wouldn''t it be easy for others to locate the dialog class
    if the name of the file and the name of the class were similar? I can hear you
    say yes. All set! Let''s start coding our Qt application. First, refer to the
    following screenshot:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个建议。如果文件名和类名相似，其他人是否会更容易找到对话框类？我可以听到你说是的。一切准备就绪！让我们开始编写我们的Qt应用程序。首先，参考以下屏幕截图：
- en: '![](img/3a3adb3b-5468-4eec-9d3d-74288453c48c.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3a3adb3b-5468-4eec-9d3d-74288453c48c.png)'
- en: Figure 5.15
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.15
- en: 'In the preceding screenshot, we declared a class with the name `MyDlg`. It
    has one layout, three buttons, and a constructor. Now refer to this screenshot:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们声明了一个名为`MyDlg`的类。它有一个布局，三个按钮和一个构造函数。现在请参考这个屏幕截图：
- en: '![](img/144ade69-a5a6-4eb9-bfa6-8ee0f7d1e614.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/144ade69-a5a6-4eb9-bfa6-8ee0f7d1e614.png)'
- en: Figure 5.16
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.16
- en: 'As you can see in the preceding screenshot, we defined the `MyDlg` constructor
    and instantiated the layout and the three buttons. In lines 27 through 29, we
    added three buttons to the layout. In line number 31, we associated the layout
    to our dialog. That''s all it takes. In the following screenshot, we defined our `main` function,
    which creates an instance of `QApplication`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的屏幕截图中所看到的，我们定义了`MyDlg`构造函数并实例化了布局和三个按钮。在第27到29行，我们向布局添加了三个按钮。在第31行，我们将布局与我们的对话框关联起来。就是这样。在下一个屏幕截图中，我们定义了我们的`main`函数，它创建了一个`QApplication`的实例：
- en: '![](img/3de3ec35-9b38-486c-9213-c70fc7b1ce81.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3de3ec35-9b38-486c-9213-c70fc7b1ce81.png)'
- en: Figure 5.17
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.17
- en: 'We followed this up by creating our custom dialog instance and displaying the
    dialog. Finally, at line 27, we started the `event` loop so that `MyDlg` could
    respond to user interactions. Refer to the following screenshot:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们创建了我们的自定义对话框实例并显示了对话框。最后，在第27行，我们启动了`event`循环，以便`MyDlg`可以响应用户交互。请参考以下屏幕截图：
- en: '![](img/b95f5be3-8fee-4e72-995d-6dc4c40cb130.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b95f5be3-8fee-4e72-995d-6dc4c40cb130.png)'
- en: Figure 5.18
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.18
- en: The preceding screenshot demonstrates the build and execution procedures, and
    there is our cute application. Actually, you can try playing with the dialog to
    understand the horizontal layout better. First, stretch the dialog horizontally
    and notice all the buttons' width increase; then, see whether you can reduce the
    dialog's width to notice all the buttons' width decrease. That's the job of any
    layout manager. A layout manager arranges widgets and retrieves the size of the
    window and divides the height and width equally among all its child widgets. Layout
    managers keep notifying all their child widgets about any resize events. However,
    it is up to the respective child widget to decide whether they want to resize
    themselves or ignore the layout resize signals.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的屏幕截图演示了构建和执行过程，还有我们可爱的应用程序。实际上，您可以尝试使用对话框来更好地理解水平布局。首先，水平拉伸对话框，注意所有按钮的宽度增加；然后，看看是否可以减小对话框的宽度以注意到所有按钮的宽度减小。这是任何布局管理器的工作。布局管理器安排小部件并检索窗口的大小，并在所有子小部件之间平均分配高度和宽度。布局管理器不断通知所有子小部件有关任何调整大小事件。但是，由各自的子小部件决定他们是否要调整大小或忽略布局调整信号。
- en: To check this behavior, try stretching out the dialog vertically. As you increase
    the height of the dialog, the dialog's height should increase, but the buttons
    will not increase their height. This is because every Qt Widget has its own preferred
    size policy; as per their size policy, they may respond or ignore certain layout
    resize signals.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查这种行为，请尝试垂直拉伸对话框。当您增加对话框的高度时，对话框的高度应该增加，但按钮不会增加其高度。这是因为每个Qt小部件都有自己的首选大小策略；根据其大小策略，它们可能会响应或忽略某些布局调整信号。
- en: 'If you want the buttons to stretch vertically as well, `QPushButton` offers
    a way to get this done. In fact, `QPushButton` extends from `QWidget` just like
    any other widget. The `setSizePolicy()` method comes to `QPushButton` from its
    base class, that is, `QWidget`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望按钮在垂直方向上也能拉伸，`QPushButton`提供了一种方法来实现这一点。实际上，`QPushButton`与任何其他小部件一样都是从`QWidget`继承的。`setSizePolicy()`方法来自`QWidget`的基类，即`QPushButton`：
- en: '![](img/ab724d3c-fea2-4b78-8e93-452c4f47a3fd.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab724d3c-fea2-4b78-8e93-452c4f47a3fd.png)'
- en: Figure 5.19
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.19
- en: Did you notice line number 37? Yes, I have set the window title within the constructor
    of `MyDlg` to keep our `main` function compact and clean.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您注意到了第37行吗？是的，我在`MyDlg`的构造函数中设置了窗口标题，以保持我们的`main`函数简洁和干净。
- en: 'Make sure you have built your project using the `make` utility before launching
    your application:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动应用程序之前，请确保使用`make`实用程序构建了您的项目：
- en: '![](img/6df8dfd7-47b0-4bb6-b60d-58a35c1dd6fa.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6df8dfd7-47b0-4bb6-b60d-58a35c1dd6fa.png)'
- en: Figure 5.20
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.20
- en: 'In the highlighted section, we have overridden the default size policy of all
    the buttons. In line number 27, the first parameter `QSizePolicy::Expanding` refers
    to the horizontal policy and the second parameter refers to the vertical policy.
    To find other possible values of `QSizePolicy`, refer to the assistant that comes
    in handy with the Qt API reference, as shown in the following screenshot:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在突出显示的部分，我们覆盖了所有按钮的默认大小策略。在第27行，第一个参数`QSizePolicy::Expanding`是指水平策略，第二个参数是指垂直策略。要查找`QSizePolicy`的其他可能值，请参考Qt
    API参考中随时可用的助手，如下面的屏幕截图所示：
- en: '![](img/67710ba2-8d4f-4912-a0a6-d6019fc02a68.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67710ba2-8d4f-4912-a0a6-d6019fc02a68.png)'
- en: Figure 5.21
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.21
- en: Writing a GUI application with a vertical layout
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用垂直布局编写GUI应用程序
- en: In the previous section, you learned how to use a horizontal box layout. In
    this section, you will see how to use a vertical box layout in your application.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您学会了如何使用水平框布局。在本节中，您将看到如何在应用程序中使用垂直框布局。
- en: As a matter of fact, the horizontal and vertical box layouts vary only in terms
    of how they arrange the widgets. For instance, the horizontal box layout will
    arrange its child widgets in a horizontal fashion from left to right, whereas
    the vertical box layout will arrange its child widgets in a vertical fashion from
    top to bottom.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，水平和垂直框布局只在它们如何排列小部件方面有所不同。例如，水平框布局将以从左到右的水平方式排列其子小部件，而垂直框布局将以从上到下的垂直方式排列其子小部件。
- en: 'You can copy the source code from the previous section, as the changes are
    minor in nature. Once you have copied the code, your project directory should
    look as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从上一节中复制源代码，因为更改的性质很小。一旦您复制了代码，您的项目目录应该如下所示：
- en: '![](img/10c56178-6d0b-460b-8c0d-4c0fa46fefd2.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/10c56178-6d0b-460b-8c0d-4c0fa46fefd2.png)'
- en: Figure 5.22
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.22
- en: 'Let me demonstrate the changes starting from the `MyDlg.h` header file, as
    follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我从`MyDlg.h`头文件开始演示更改，如下所示：
- en: '![](img/63c0b936-c4f1-4f08-b18c-09cadc8da460.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/63c0b936-c4f1-4f08-b18c-09cadc8da460.png)'
- en: Figure 5.23
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.23
- en: 'I have replaced `QHBoxLayout` with `QVBoxLayout`; that is all. Yes, let''s
    proceed with file changes related to `MyDlg.cpp`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经用`QVBoxLayout`替换了`QHBoxLayout`；就是这样。是的，让我们继续进行与`MyDlg.cpp`相关的文件更改：
- en: '![](img/d7c45242-efb4-4030-b8bf-c6ef897a184b.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7c45242-efb4-4030-b8bf-c6ef897a184b.png)'
- en: Figure 5.24
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.24
- en: 'There are no changes to be done in `main.cpp`; however, I have shown `main.cpp`
    for your reference, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.cpp`中没有要做的更改；但是，我已经展示了`main.cpp`供您参考，如下所示：'
- en: '![](img/ee30bcb7-c152-400d-bdb2-525969afb1ca.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee30bcb7-c152-400d-bdb2-525969afb1ca.png)'
- en: Figure 5.25
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.25
- en: 'Now all we need to do is autogenerate `Makefile` and then make and run the
    program as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要做的就是自动生成`Makefile`，然后编译和运行程序，如下所示：
- en: '![](img/7f2e631e-18c5-4b13-b952-538fbb5b7d11.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f2e631e-18c5-4b13-b952-538fbb5b7d11.png)'
- en: Figure 5.26
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.26
- en: 'Let''s execute our brand new program and check the output. The following output
    demonstrates that `QVBoxLayout` arranges the widgets in a vertical top to bottom
    fashion. When the window is stretched, all the buttons'' width will increase/decrease
    depending on whether the window is stretched out or stretched in:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行我们全新的程序并检查输出。以下输出演示了`QVBoxLayout`以垂直的从上到下的方式排列小部件。当窗口被拉伸时，所有按钮的宽度将根据窗口的拉伸程度增加/减少：
- en: '![](img/142bbe72-7b70-48ce-8ce4-4f5e36ba4b6f.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/142bbe72-7b70-48ce-8ce4-4f5e36ba4b6f.png)'
- en: Figure 5.27
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.27
- en: Writing a GUI application with a box layout
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用框布局编写GUI应用程序
- en: In the previous sections, you learned how to make use of `QHBoxLayout` and `QVBoxLayout`.
    Actually, these two classes are the convenience classes for `QBoxLayout`**.**
    In the case of `QHBoxLayout`, the `QHBoxLayout` class has subclassed `QBoxLayout`
    and configured `QBoxLayout::Direction` to `QBoxLayout::LeftToRight`, whereas the `QVBoxLayout`
    class has subclassed `QBoxLayout` and configured `QBoxLayout::Direction` to `QBoxLayout::TopToBottom`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学会了如何使用`QHBoxLayout`和`QVBoxLayout`。实际上，这两个类都是`QBoxLayout`的便利类。在`QHBoxLayout`的情况下，`QHBoxLayout`类已经成为`QBoxLayout`的子类，并配置了`QBoxLayout::Direction`为`QBoxLayout::LeftToRight`，而`QVBoxLayout`类已经成为`QBoxLayout`的子类，并配置了`QBoxLayout::Direction`为`QBoxLayout::TopToBottom`。
- en: 'Apart from these values, `QBoxLayout::Direction` supports various other values,
    as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些值，`QBoxLayout::Direction`还支持其他各种值，如下所示：
- en: '`QBoxLayout::LeftToRight`: This arranges the widgets from left to right'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QBoxLayout::LeftToRight`：这将从左到右排列小部件'
- en: '`QBoxLayout::RightToLeft`: This arranges the widgets from right to left'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QBoxLayout::RightToLeft`：这将从右到左排列小部件'
- en: '`QBoxLayout::TopToBottom`: This arranges the widgets from top to bottom'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QBoxLayout::TopToBottom`：这将从上到下排列小部件'
- en: '`QBoxLayout::BottomToTop`: This arranges the widgets from bottom to top'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QBoxLayout::BottomToTop`：这将从下到上排列小部件'
- en: Let's write a simple program using `QBoxLayout` with five buttons.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`QBoxLayout`和五个按钮编写一个简单的程序。
- en: 'Let''s start with the `MyDlg.h` header file. I have declared five button pointers
    in the `MyDlg` class and a `QBoxLayout` pointer:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`MyDlg.h`头文件开始。我在`MyDlg`类中声明了五个按钮指针和一个`QBoxLayout`指针：
- en: '![](img/5d082e8f-d0fd-4411-b77a-611aca0ac21f.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d082e8f-d0fd-4411-b77a-611aca0ac21f.png)'
- en: Figure 5.28
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.28
- en: Let's take a look at our `MyDlg.cpp` source file. If you notice line number
    21 in the following screenshot, the `QBoxLayout` constructor takes two arguments.
    The first argument is the direction in which you wish to arrange the widgets and
    the second argument is an optional argument that expects the parent address of
    the layout instance.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的`MyDlg.cpp`源文件。如果你注意到截图中的第21行，`QBoxLayout`构造函数需要两个参数。第一个参数是你希望排列小部件的方向，第二个参数是一个可选参数，期望布局实例的父地址。
- en: As you may have guessed, the `this` pointer refers to the `MyDlg` instance pointer,
    which happens to be the parent of the layout.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的那样，`this`指针指的是`MyDlg`实例指针，它恰好是布局的父指针。
- en: '![](img/6e2eac95-3aa9-4a94-b45a-2162642703bc.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e2eac95-3aa9-4a94-b45a-2162642703bc.png)'
- en: Figure 5.29
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.29
- en: 'Again, as you may have guessed, the `main.cpp` file isn''t going to change
    from our past exercises, as shown in the following screenshot:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，正如你可能已经猜到的那样，`main.cpp`文件不会改变，就像在下面的截图中所示的那样：
- en: '![](img/19b90e2a-596c-463d-bad1-5ff2b362040c.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/19b90e2a-596c-463d-bad1-5ff2b362040c.png)'
- en: Figure 5.30
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.30
- en: 'Let''s compile and run our program, as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译和运行我们的程序，如下所示：
- en: '![](img/90aef4bb-5118-4e93-b092-8d121e54bea9.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90aef4bb-5118-4e93-b092-8d121e54bea9.png)'
- en: Figure 5.31
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.31
- en: 'If you notice the output, it looks like a horizontal box layout output, right?
    Exactly, because we have set the direction to `QBoxLayout::LeftToRight`. If you
    modify the direction to, say, `QBoxLayout::RightToLeft`, then Button 1 would appear
    on the right-hand side, Button 2 would appear on the left-hand side of Button
    1, and so on. Hence, the output would look as shown in the following screenshot:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到输出，它看起来像是一个水平框布局的输出，对吧？确实，因为我们已经将方向设置为`QBoxLayout::LeftToRight`。如果你将方向修改为，比如`QBoxLayout::RightToLeft`，那么按钮1将出现在右侧，按钮2将出现在按钮1的左侧，依此类推。因此，输出将如下截图所示：
- en: 'If the direction is set to `QBoxLayout::RightToLeft`, you''ll see the following
    output:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果方向设置为`QBoxLayout::RightToLeft`，你会看到以下输出：
- en: '![](img/d7470732-aadf-410b-b650-a79d0a8bb76a.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7470732-aadf-410b-b650-a79d0a8bb76a.png)'
- en: Figure 5.32
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.32
- en: 'If the direction is set to `QBoxLayout::TopToBottom`, you''ll see the following
    output:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果方向设置为`QBoxLayout::TopToBottom`，你会看到以下输出：
- en: '![](img/3e04081c-dd1a-4bcc-b4e3-56e3dbaadad7.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e04081c-dd1a-4bcc-b4e3-56e3dbaadad7.png)'
- en: Figure 5.33
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.33
- en: 'If the direction is set to `QBoxLayout::BottomToTop`, you''ll see the following
    output:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果方向设置为`QBoxLayout::BottomToTop`，你会看到以下输出：
- en: '![](img/733e373e-9738-4faf-b285-4d370eefee75.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/733e373e-9738-4faf-b285-4d370eefee75.png)'
- en: Figure 5.34
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.34
- en: In all the preceding scenarios, the buttons are added to the layout exactly
    in the same sequence, starting from Button 1 through Button 5, respectively. However,
    depending on the direction chosen in the `QBoxLayout` constructor, the box layout
    will arrange the buttons, hence the difference in the output.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有前述的情况下，按钮都是按照相同的顺序添加到布局中，从按钮1到按钮5。然而，根据`QBoxLayout`构造函数中选择的方向，框布局将安排按钮，因此输出会有所不同。
- en: Writing a GUI application with a grid layout
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用网格布局编写GUI应用程序
- en: A grid layout allows us to arrange widgets in a tabular fashion. It is quite
    easy, just like a box layout. All we need to do is indicate the row and column
    where each widget must be added to the layout. As the row and column index starts
    from a zero-based index, the value of row 0 indicates the first row and the value
    of column 0 indicates the first column. Enough of theory; let's start writing
    some code.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 网格布局允许我们以表格方式排列小部件。这很容易，就像盒式布局一样。我们只需要指定每个小部件必须添加到布局的行和列。由于行和列索引从基于零的索引开始，因此行0的值表示第一行，列0的值表示第一列。理论够了；让我们开始写一些代码。
- en: Let's declare 10 buttons and add them in two rows and five columns. Other than
    the specific `QGridLayout` differences, the rest of the stuff will remain the
    same as the previous exercises, so go ahead and create `MyDlg.h`**, **`MyDl.cpp`,
    and `main.cpp` if you have understood the concepts discussed so far.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们声明10个按钮，并将它们添加到两行和五列中。除了特定的`QGridLayout`差异外，其余的东西将与以前的练习保持一致，因此，如果您已经理解了到目前为止讨论的概念，请继续创建`MyDlg.h`，`MyDl.cpp`和`main.cpp`。
- en: 'Let me present the `MyDlg.h` source code in the following screenshot:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我在以下截图中呈现`MyDlg.h`源代码：
- en: '![](img/c4c76aa2-b3b5-4b31-afa6-395bfe97f078.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c4c76aa2-b3b5-4b31-afa6-395bfe97f078.png)'
- en: Figure 5.35
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.35
- en: 'The following is the code snippet of `MyDlg.cpp`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`MyDlg.cpp`的代码片段：
- en: '![](img/fe8972d9-c42f-4b37-972f-e2e8dc75951c.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe8972d9-c42f-4b37-972f-e2e8dc75951c.png)'
- en: Figure 5.36
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.36
- en: The `main.cpp` source file content will remain the same as our previous exercises;
    hence, I have skipped the `main.cpp` code snippet. As you are familiar with the
    build process, I have skipped it too. If you have forgotten about this, just check
    the previous sections to understand the build procedure.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.cpp`源文件内容将与我们以前的练习保持一致；因此，我已经跳过了`main.cpp`的代码片段。由于您熟悉构建过程，我也跳过了它。如果您忘记了这一点，只需查看以前的部分以了解构建过程。'
- en: 'If you have typed the code correctly, you should get the following output:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已正确输入代码，则应该获得以下输出：
- en: '![](img/af657f1a-8876-4fc0-b9e9-ee467bd00b1c.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af657f1a-8876-4fc0-b9e9-ee467bd00b1c.png)'
- en: Figure 5.37
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.37
- en: Actually, the grid layout has more stuff to offer. Let's explore how we can
    make a button span across multiple cells. I guarantee what you are about to see
    is going to be more interesting.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，网格布局还有更多功能可供使用。让我们探索如何使按钮跨越多个单元格。我保证您将看到的内容更有趣。
- en: 'I''m going to modify `MyDlg.h` and `MyDlg.cpp` and keep `main.cpp` the same
    as the previous exercises:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我将修改`MyDlg.h`和`MyDlg.cpp`，并保持`main.cpp`与以前的练习相同：
- en: '![](img/d51e3923-f36d-4920-8b16-9b36e96b0aa7.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d51e3923-f36d-4920-8b16-9b36e96b0aa7.png)'
- en: Figure 5.38
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.38
- en: 'Here goes our `MyDlg.cpp`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`MyDlg.cpp`：
- en: '![](img/f2a8a9d8-8b10-49e5-b873-d9968a02567a.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2a8a9d8-8b10-49e5-b873-d9968a02567a.png)'
- en: Figure 5.39
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.39
- en: Notice the lines 35 through 38\. Let's discuss the `addWidget()` function in
    detail now.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第35到38行。现在让我们详细讨论`addWidget()`函数。
- en: 'In line number 35, the `pLayout->addWidget ( pBttn1, 0, 0, 1, 1 )` code does
    the following things:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在第35行，`pLayout->addWidget(pBttn1, 0, 0, 1, 1)`代码执行以下操作：
- en: The first three arguments add Button 1 to the grid layout at the first row and
    first column
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前三个参数将“按钮1”添加到网格布局的第一行和第一列
- en: The fourth argument `1` instructs that Button 1 will occupy just one row
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个参数“1”指示按钮1将仅占用一行
- en: The fifth argument `1` instructs that Button 1 will occupy just one column
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第五个参数“1”指示按钮1将仅占用一列
- en: Hence, it's clear that `pBttn1` should be rendered at cell (0, 0) and it should
    occupy just one grid cell
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，很明显`pBttn1`应该呈现在单元格（0,0）处，它应该只占用一个网格单元
- en: 'In line number 36, the `pLayout->addWidget ( pBttn2, 0, 1, 1, 2 )` code does
    the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在第36行，`pLayout->addWidget(pBttn2, 0, 1, 1, 2)`代码执行以下操作：
- en: The first three arguments add `Button 2` to the grid layout at the first row
    and second column
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前三个参数将“按钮2”添加到网格布局的第一行和第二列
- en: The fourth argument instructs that `Button 2` will occupy one row
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个参数指示“按钮2”将占用一行
- en: The fifth argument instructs that `Button 2` will occupy two columns (that is,
    the second column and the third column in the first row)
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第五个参数指示“按钮2”将占用两列（即第一行的第二列和第三列）
- en: At the bottom line, Button 2 will be rendered at cell (0,1) and it should occupy
    one row and two columns
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在底部行，“按钮2”将呈现在单元格（0,1）处，它应该占用一行和两列
- en: 'In line number 37, the `pLayout->addWidget ( pBttn3, 0, 3, 2, 1 )` code does
    the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在第37行，`pLayout->addWidget(pBttn3, 0, 3, 2, 1)`代码执行以下操作：
- en: The first three arguments add Button 3 to the grid layout at the first row and
    fourth column
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前三个参数将“按钮3”添加到网格布局的第一行和第四列
- en: The fourth argument instructs that Button 3 will occupy two rows (that is, the
    first row and the fourth column and the second row and the fourth column)
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个参数指示“按钮3”将占用两行（即第一行和第四列以及第二行和第四列）
- en: The fifth argument instructs that Button 3 will occupy one column
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第五个参数指示“按钮3”将占用一列
- en: 'In line number 38, the `pLayout->addWidget ( pBttn4, 1, 0, 1, 3 )` code does
    the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在第38行，`pLayout->addWidget(pBttn4, 1, 0, 1, 3)`代码执行以下操作：
- en: The first three arguments add Button 4 to the grid layout at the second row
    and first column
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前三个参数将“按钮4”添加到网格布局的第二行和第一列
- en: The fourth argument instructs that Button 4 will occupy one row
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个参数指示“按钮4”将占用一行
- en: The fifth argument instructs that Button 4 will occupy three columns (that is,
    the second row first, then the second and third column)
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第五个参数指示“按钮4”将占用三列（即第二行的第一列，然后是第二列和第三列）
- en: 'Check out the output of the program:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 检查程序的输出：
- en: '![](img/1872682b-e251-4ff5-adbd-28fd1a5ac2db.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1872682b-e251-4ff5-adbd-28fd1a5ac2db.png)'
- en: Figure 5.40
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.40
- en: Signals and slots
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号和槽
- en: Signals and slots are an integral part of the Qt Framework. So far, we have
    written some simple but interesting Qt applications, but we haven't handled events.
    Now it's time to understand how to support events in our application.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 信号和槽是Qt框架的一个重要部分。到目前为止，我们编写了一些简单但有趣的Qt应用程序，但我们还没有处理事件。现在是时候了解如何在我们的应用程序中支持事件了。
- en: Let's write a simple application with just one button. When the button is clicked,
    check whether we can print something on the console.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的应用程序，只有一个按钮。当点击按钮时，检查是否可以在控制台上打印一些内容。
- en: 'The `MyDlg.h` header demonstrates how the `MyDlg` class shall be declared:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyDlg.h`头文件演示了如何声明`MyDlg`类：'
- en: '![](img/7d50a778-9a10-43fa-b724-d9afd6315c10.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d50a778-9a10-43fa-b724-d9afd6315c10.png)'
- en: Figure 5.41
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.41
- en: 'The following screenshot demonstrates how the `MyDlg` constructor shall be
    defined to add a single button to our dialog window:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图演示了如何定义`MyDlg`构造函数以向对话框窗口添加一个按钮：
- en: '![](img/6ba01a0d-7362-4ba9-a7aa-d3f8ead60b96.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ba01a0d-7362-4ba9-a7aa-d3f8ead60b96.png)'
- en: Figure 5.42
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.42
- en: 'The `main.cpp` looks as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.cpp`如下所示：'
- en: '![](img/ebeea2e4-cdea-45cb-b3b0-79f67fef12f4.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ebeea2e4-cdea-45cb-b3b0-79f67fef12f4.png)'
- en: Figure 5.43
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.43
- en: 'Let''s build and run our program and later add support for signals and slots.
    If you have followed the instructions correctly, your output should resemble the
    following screenshot:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建并运行我们的程序，然后添加对信号和槽的支持。如果你正确地按照说明操作，你的输出应该类似于以下截图：
- en: '![](img/0e296050-9288-4558-b0b5-4fa80a5b8834.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e296050-9288-4558-b0b5-4fa80a5b8834.png)'
- en: Figure 5.44
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.44
- en: If you click on the button, you will notice that nothing happens, as we are
    yet to add support for signals and slots in our application. Okay, it's time to
    reveal the secret instruction that will help you make the button respond to a
    button-click signal. Hold on, it's time for some more information. Don't worry, it's
    related to Qt.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击按钮，你会注意到什么都没有发生，因为我们还没有在我们的应用程序中添加对信号和槽的支持。好吧，是时候揭示一个秘密指令，这将帮助你使按钮响应按钮点击信号。等一下，是时候获取更多信息了。别担心，这和Qt有关。
- en: Qt signals are nothing but events, and slot functions are event handler functions.
    Interestingly, both signals and slots are normal C++ functions; only when they
    are marked as signals or slots, will the Qt Framework understand their purpose
    and provide the necessary boilerplate code.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Qt信号只是事件，槽函数是事件处理程序函数。有趣的是，信号和槽都是普通的C++函数；只有当它们被标记为信号或槽时，Qt框架才能理解它们的目的并提供必要的样板代码。
- en: Every widget in Qt supports one or more signal and may also optionally support
    one or more slot. So let's explore which signals `QPushButton` supports before
    we write any further code.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Qt中的每个小部件都支持一个或多个信号，也可以选择支持一个或多个槽。因此，在我们编写任何进一步的代码之前，让我们探索一下`QPushButton`支持哪些信号。
- en: 'Let''s make use of the Qt assistant for API reference:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Qt助手进行API参考：
- en: '![](img/9f329dcb-c999-4440-b838-6cf1ac7df528.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f329dcb-c999-4440-b838-6cf1ac7df528.png)'
- en: Figure 5.45
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.45
- en: 'If you observe the preceding screenshot, it has a Contents section that seems
    to cover Public Slots, but we don''t see any signals listed there. That''s a lot
    of information. If the Contents section doesn''t list out signals, `QPushButton` wouldn''t
    support signals directly. However, maybe its base class, that is, `QAbstractButton`,
    would support some signals. The `QPushButton` class section gives loads of useful
    information, such as the header filename, which Qt module must be linked to the
    application--that is, qmake entries that must be added to `.pro`--and so on. It
    also mentions the base class of `QPushButton`. If you scroll down further, your
    Qt assistant window should look like this:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你观察前面的截图，它有一个似乎涵盖了公共槽的内容部分，但我们没有看到任何列出的信号。这是很多信息。如果内容部分没有列出信号，`QPushButton`就不会直接支持信号。然而，也许它的基类，即`QAbstractButton`，会支持一些信号。`QPushButton`类部分提供了大量有用的信息，比如头文件名，必须链接到应用程序的Qt模块，即必须添加到`.pro`文件的qmake条目等。它还提到了`QPushButton`的基类。如果你继续向下滚动，你的Qt助手窗口应该看起来像这样：
- en: '![](img/c26ffb57-4b25-428e-b3b7-c28a23363a7a.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c26ffb57-4b25-428e-b3b7-c28a23363a7a.png)'
- en: Figure 5.46
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.46
- en: If you observe the highlighted section under Additional Inherited Members, apparently
    the Qt assistant implies that `QPushButton` has inherited four signals from `QAbstractButton`.
    So we need to explore the signals supported by `QAbstractButton` in order to support
    the signals in `QPushButton`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你观察到`Additional Inherited Members`下面的突出部分，显然Qt助手暗示`QPushButton`已经从`QAbstractButton`继承了四个信号。因此，我们需要探索`QAbstractButton`支持的信号，以便在`QPushButton`中支持这些信号。
- en: '![](img/b59281a2-2562-49bf-8baf-4518b9ed3768.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b59281a2-2562-49bf-8baf-4518b9ed3768.png)'
- en: Figure 5.47
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.47
- en: With the help of the Qt assistant, as shown in the preceding screenshot, it
    is evident that the `QAbstractButton` class supports four signals that are also
    available for `QPushButton`, as `QPushButton` is a child class of `QAbstractButton`.
    So let's use the `clicked()` signal in this exercise.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Qt助手的帮助，如前面的截图所示，很明显`QAbstractButton`类支持四个信号，这些信号也适用于`QPushButton`，因为`QPushButton`是`QAbstractButton`的子类。因此，让我们在这个练习中使用`clicked()`信号。
- en: 'We need to make some minor changes in `MyDlg.h` and `MyDlg.cpp` in order to
    use the `clicked()` signal. Hence, I have presented these two files with changes
    highlighted in the following screenshot:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`MyDlg.h`和`MyDlg.cpp`中进行一些小的更改，以便使用`clicked()`信号。因此，我已经在以下截图中呈现了这两个文件，并突出显示了更改：
- en: '![](img/88feed21-ddd1-416c-ae24-b77ef4aff1ae.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88feed21-ddd1-416c-ae24-b77ef4aff1ae.png)'
- en: Figure 5.48
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.48
- en: As you are aware, the `QDebug` class is used for debugging purposes. It offers
    functionalities to Qt applications that are similar to `cout`, but they aren't
    really required for signals and slots. We are using them here just for debugging
    purposes. In *Figure 5.48*, line number 34, void `MyDlg::onButtonClicked()` is
    our slot function that we are intending to use as an event handler function that
    must be invoked in response to the button click.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，`QDebug`类用于调试目的。它为Qt应用程序提供了类似于`cout`的功能，但实际上并不需要用于信号和槽。我们在这里使用它们只是为了调试目的。在*图5.48*中，第34行，`MyDlg::onButtonClicked()`是我们打算用作事件处理程序函数的槽函数，必须在按钮点击时调用。
- en: 'The following screenshot should give you an idea of what changes you will have
    to perform in `MyDlg.cpp` for signal and slot support:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的屏幕截图应该让你了解在`MyDlg.cpp`中需要进行哪些更改以支持信号和槽：
- en: '![](img/d58b2aa7-c768-4f29-b336-f198fbc67422.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d58b2aa7-c768-4f29-b336-f198fbc67422.png)'
- en: Figure 5.49
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.49
- en: If you observe line 40 through 42 in the preceding screenshot, the `MyDlg::onButtonClicked()`
    method is a slot function that must be invoked whenever the button is clicked.
    But unless the button's `clicked()` signal is mapped to the `MyDlg::onButtonClicked()` slot,
    the Qt Framework wouldn't know that it must invoke `MyDlg::onButtonClicked()`
    when the button is clicked. Hence, in line numbers 32 through 37, we have connected
    the button signal `clicked()` with the `MyDlg` instance's `onButtonClicked()`
    slot function. The connect function is inherited by `MyDlg` from `QDialog`. This,
    in turn, has inherited the function from its ultimate base class, called `QObject`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你观察前面屏幕截图中的第40到42行，`MyDlg::onButtonClicked()`方法是一个槽函数，必须在按钮被点击时调用。但是除非按钮的`clicked()`信号映射到`MyDlg::onButtonClicked()`槽，否则Qt框架不会知道它必须在按钮被点击时调用`MyDlg::onButtonClicked()`。因此，在32到37行，我们将按钮信号`clicked()`与`MyDlg`实例的`onButtonClicked()`槽函数连接起来。connect函数是从`QDialog`继承的。这又从它的最终基类`QObject`继承了这个函数。
- en: The mantra is that every class that would like to participate in signal and
    slot communication must be either `QObject` or its subclass. `QObject` offers
    quite a good amount of signal and slot support, and `QObject` is part of the `QtCore`
    module. What's amazing is that the Qt Framework has made signal and slot available
    to even command-line applications. This is the reason signals and slots support
    is built into the ultimate base class `QObject`, which is part of the **QtCore**
    module.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是，每个希望参与信号和槽通信的类都必须是`QObject`或其子类。`QObject`提供了相当多的信号和槽支持，`QObject`是`QtCore`模块的一部分。令人惊奇的是，Qt框架甚至为命令行应用程序提供了信号和槽支持。这就是为什么信号和槽支持内置到最终基类`QObject`中的原因，它是`QtCore`模块的一部分。
- en: 'Okay, let''s build and run our program and see whether the signals work in
    our application:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们构建和运行我们的程序，看看信号在我们的应用程序中是否起作用：
- en: '![](img/f2941fec-a600-491b-a3a3-89a453ec7f2f.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2941fec-a600-491b-a3a3-89a453ec7f2f.png)'
- en: Figure 5.50
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.50
- en: Interestingly, we don't get a compilation error, but when we click on the button,
    the highlighted warning message appears automatically. This is a hint from the
    Qt Framework that we have missed out on an important procedure that is mandatory
    to make signals and slots work.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们并没有得到编译错误，但当我们点击按钮时，突出显示的警告消息会自动出现。这是Qt框架的提示，表明我们错过了一个重要的程序，这是使信号和槽工作所必需的。
- en: 'Let''s recollect the procedure we followed to autogenerate `Makefile` in our
    headers and source files:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们在头文件和源文件中自动生成`Makefile`的过程：
- en: The `qmake -project` command ensures that all the header files and source files
    that are present in the current folder are included in the `.pro` file.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`qmake -project`命令确保当前文件夹中存在的所有头文件和源文件都包含在`.pro`文件中。'
- en: The `qmake` command picks up the `.pro` file present in the current folder and
    generates `Makefile` for our project.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`qmake`命令会读取当前文件夹中的`.pro`文件，并为我们的项目生成`Makefile`。'
- en: The `make` commandwill invoke the `make` utility. It then executes `Makefile`
    in the current directory and builds our project based on the make rules defined
    in `Makefile`.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`make`命令将调用`make`实用程序。然后在当前目录中执行`Makefile`，并根据`Makefile`中定义的make规则构建我们的项目。'
- en: 'In step 1, the `qmake` utility scans through all our custom header files and
    checks whether they need signal and slot support. Any header file that has the `Q_OBJECT`
    macro hints the `qmake` utility that it needs signal and slot support. Hence we
    must use the `Q_OBJECT` macro in our `MyDlg.h` header file:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1步中，`qmake`实用程序扫描我们所有的自定义头文件，并检查它们是否需要信号和槽支持。任何具有`Q_OBJECT`宏的头文件都会提示`qmake`实用程序需要信号和槽支持。因此，我们必须在我们的`MyDlg.h`头文件中使用`Q_OBJECT`宏：
- en: '![](img/48974fec-be32-4a9a-9619-cd2cf91f5f19.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48974fec-be32-4a9a-9619-cd2cf91f5f19.png)'
- en: Figure 5.51
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.51
- en: Once the recommended changes are done in the header file, we need to ensure
    that the `qmake` command is issued. Now the `qmake` utility will open the `Ex8.pro`
    file to get our project headers and source files. When `qmake` parses `MyDlg.h`
    and finds the `Q_OBJECT` macro, it will learn that our `MyDlg.h` requires signals
    and slots, then it will ensure that the moc compiler is invoked on `MyDlg.h` so
    that the boilerplate code can be autogenerated in a file called `moc_MyDlg.cpp`. This
    will then go ahead and add the necessary rules to `Makefile` so that the autogenerated
    `moc_MyDlg.cpp` file gets built along with the other source files.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在头文件中进行了推荐的更改，我们需要确保发出`qmake`命令。现在`qmake`实用程序将打开`Ex8.pro`文件，获取我们的项目头文件和源文件。当`qmake`解析`MyDlg.h`并找到`Q_OBJECT`宏时，它将了解到我们的`MyDlg.h`需要信号和槽，然后它将确保在`MyDlg.h`上调用moc编译器，以便在一个名为`moc_MyDlg.cpp`的文件中自动生成样板代码。然后，它将继续添加必要的规则到`Makefile`中，以便自动生成的`moc_MyDlg.cpp`文件与其他源文件一起构建。
- en: 'Now that you know the secrets of Qt signals and slots, go ahead and try out
    this procedure and check whether your button click prints the Button clicked ... message.
    I have gone ahead and built our project with the changes recommended. In the following
    screenshot, I have highlighted the interesting stuff that goes on behind the scenes;
    these are some of the advantages one would get when working in the command line
    versus using fancy IDEs:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了Qt信号和槽的秘密，继续尝试这个过程，并检查你的按钮点击是否打印了“按钮点击...”的消息。我已经根据建议对我们的项目进行了构建。在下面的截图中，我已经突出显示了幕后发生的有趣的事情；这些是在命令行中工作与使用花哨的IDE时会得到的一些优势：
- en: '![](img/70c69c4b-3796-4773-bdec-395bf62d9a83.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](img/70c69c4b-3796-4773-bdec-395bf62d9a83.png)'
- en: Figure 5.52
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.52
- en: 'Now it''s time that we test the output of our cool and simple application that
    supports signals and slots. The output is presented in the following screenshot:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候测试我们支持信号和槽的酷而简单的应用程序的输出了。输出如下截图所示：
- en: '![](img/b3c2b725-57d1-4e46-814a-0301e48cd9d6.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b3c2b725-57d1-4e46-814a-0301e48cd9d6.png)'
- en: Figure 5.53
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.53
- en: Congratulations! You can pat your back. You have learned enough to do cool stuff
    in Qt.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你可以为自己鼓掌。你已经学会了在Qt中做一些很酷的东西。
- en: Using stacked layout in Qt applications
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Qt应用程序中使用堆叠布局
- en: As you have learned about signals and slots, in this section, let's explore
    how to use a stacked layout in an application that has multiple windows; each
    window could be either a **QWidget** or **QDialog.** Each page may have its own
    child widgets. The application we are about to develop will demonstrate the use
    of a stacked layout and how to navigate from one window to the other within the
    stacked layout.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你已经了解了信号和槽，所以在这一部分，让我们探讨如何在具有多个窗口的应用程序中使用堆叠布局；每个窗口可以是**QWidget**或**QDialog**。每个页面可能有自己的子窗口部件。我们即将开发的应用程序将演示堆叠布局的使用以及如何在堆叠布局中从一个窗口导航到另一个窗口。
- en: '![](img/48d99ea8-fb90-4158-9a92-e1fb06f4a6aa.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48d99ea8-fb90-4158-9a92-e1fb06f4a6aa.png)'
- en: Figure 5.54
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.54
- en: This application is going to require a decent amount of code, hence it is important
    that we ensure our code is structured carefully so that it meets both the structural
    and functional quality, avoiding code smells as much as possible.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序将需要相当多的代码，因此很重要的是我们确保我们的代码结构良好，以满足结构和功能质量，尽量避免代码异味。
- en: Let's create four widgets/windows that could be stacked up in a stacked layout,
    where each page could be developed as a separate class split across two files: `HBoxDlg.h`
    and `HBoxDlg.cpp` and so on.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建四个可以堆叠在堆叠布局中的小部件/窗口，其中每个页面可以作为一个单独的类分割成两个文件：`HBoxDlg.h`和`HBoxDlg.cpp`等等。
- en: Let's start with `HBoxDlg.h`. As you are familiar with layouts, in this exercise,
    we are going to create each dialog with one layout so that while navigating between
    the subwindows, you can differentiate between the pages. Otherwise, there will
    be no connection between the stacked layout and other layouts as such.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`HBoxDlg.h`开始。由于你熟悉布局，所以在这个练习中，我们将使用一个布局创建每个对话框，这样在子窗口之间导航时，你可以区分页面。否则，堆叠布局和其他布局之间将没有连接。
- en: '![](img/648725bf-2273-4c88-85a2-edf4bad4aeed.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![](img/648725bf-2273-4c88-85a2-edf4bad4aeed.png)'
- en: Figure 5.55
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.55
- en: 'The following code snippet is from the `HBoxDlg.cpp` file:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段来自`HBoxDlg.cpp`文件：
- en: '![](img/82c5a5d3-a595-431c-815f-ca283191e6aa.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82c5a5d3-a595-431c-815f-ca283191e6aa.png)'
- en: Figure 5.56
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.56
- en: 'Similarly, let''s write `VBoxDlg.h` as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，让我们按照以下方式编写`VBoxDlg.h`：
- en: '![](img/92f5c298-a8c2-41ee-8069-922eed5ef25c.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](img/92f5c298-a8c2-41ee-8069-922eed5ef25c.png)'
- en: Figure 5.57
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.57
- en: 'Let''s create the third dialog `BoxDlg.h` with a box layout, as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式创建第三个对话框`BoxDlg.h`，使用框布局：
- en: '![](img/366c132e-4488-4695-b5c1-b171ce04c694.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](img/366c132e-4488-4695-b5c1-b171ce04c694.png)'
- en: Figure 5.58
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.58
- en: 'The respective `BoxDlg.cpp` source file will look as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的`BoxDlg.cpp`源文件如下：
- en: '![](img/3add6abe-d750-47fd-9505-3e32e4404528.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3add6abe-d750-47fd-9505-3e32e4404528.png)'
- en: Figure 5.59
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.59
- en: 'The fourth dialog that we would like to stack up is `GridDlg`, so let''s see
    how `GridDlg.h` can be written, which is illustrated in the following screenshot:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要堆叠的第四个对话框是`GridDlg`，所以让我们看看`GridDlg.h`可以如何编写，如下截图所示：
- en: '![](img/f82f99e2-26a0-40a9-b490-fa7ea0f81cd3.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f82f99e2-26a0-40a9-b490-fa7ea0f81cd3.png)'
- en: Figure 5.60
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.60
- en: 'The respective `GridDlg.cpp` will look like this:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的`GridDlg.cpp`将如下所示：
- en: '![](img/757214dd-790a-4858-94d6-15d2684afa1b.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](img/757214dd-790a-4858-94d6-15d2684afa1b.png)'
- en: Figure 5.61
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.61
- en: Cool, we are done with creating four widgets that can be stacked up in `MainDlg`.
    `MainDlg` is the one that's going to use `QStackedLayout`, so the crux of this
    exercise is understanding how a stacked layout works.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，我们已经创建了四个可以堆叠在`MainDlg`中的小部件。`MainDlg`将使用`QStackedLayout`，所以这个练习的关键是理解堆叠布局的工作原理。
- en: 'Let''s see how `MainDlg.h` shall be written:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`MainDlg.h`应该如何编写：
- en: '![](img/fa25ec43-d0c3-4493-8c97-57857582caa7.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa25ec43-d0c3-4493-8c97-57857582caa7.png)'
- en: Figure 5.62
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.62
- en: In `MainDlg`, we have declared three slot functions, one for each button, in
    order to support the navigation logic among the four windows. A stacked layout
    is similar to a tabbed widget, except that a tabbed widget will provide its own
    visual way to switch between the tabs, whereas in the case of a stacked layout,
    it is up to us to provide the switching logic.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainDlg`中，我们声明了三个槽函数，每个按钮一个，以支持四个窗口之间的导航逻辑。堆叠布局类似于选项卡小部件，只是选项卡小部件将提供自己的视觉方式来在选项卡之间切换，而在堆叠布局的情况下，由我们提供切换逻辑。
- en: 'The `MainDlg.cpp` will look like this:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainDlg.cpp`将如下所示：'
- en: '![](img/1aa26b3a-b763-434b-8644-81e84a7e4422.png)Figure 5.63'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/1aa26b3a-b763-434b-8644-81e84a7e4422.png)图5.63'
- en: You can choose a box layout to hold the three buttons, as we prefer buttons aligned
    to the right. However, in order to ensure that extra spaces are consumed by some
    invisible glue, we have added a stretch item at line number 44.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择一个框布局来容纳这三个按钮，因为我们希望按钮对齐到右边。然而，为了确保额外的空间被一些看不见的粘合剂占用，我们在第44行添加了一个拉伸项。
- en: Between lines 30 through 33, we have added all the four subwindows in a stacked
    layout so that windows can be made visible one at a time. The `HBox` dialog is
    added at index 0, the `VBox` dialog is added at index 1, and so on.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在30到33行之间，我们已经将所有四个子窗口添加到堆叠布局中，以便窗口可以逐个显示。`HBox`对话框添加到索引0，`VBox`对话框添加到索引1，依此类推。
- en: 'Lines 53 through 58 demonstrate how the previous button''s clicked signal is
    wired with its corresponding `MainDlg::onPrevPage()` slot function. Similar connections
    must be configured for next and exit buttons:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 53到58行展示了如何将上一个按钮的点击信号与其对应的`MainDlg::onPrevPage()`槽函数连接起来。类似的连接必须为下一个和退出按钮配置：
- en: '![](img/f3016f3b-3565-444f-94e7-060d9d85adcd.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3016f3b-3565-444f-94e7-060d9d85adcd.png)'
- en: Figure 5.64
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.64
- en: The `if` condition in line 78 ensures that the switching logic happens only
    if we are in the second or later subwindows. As the horizontal dialog is at index
    0, we can't navigate to the previous window in cases where the current window
    happens to be a horizontal dialog. A similar validation is in place for switching
    to the next subwindow in line 85.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 78行的`if`条件确保只有在我们处于第二个或更后续的子窗口时才发生切换逻辑。由于水平对话框位于索引0，所以在当前窗口是水平对话框的情况下，我们无法导航到上一个窗口。类似的验证也适用于在85行切换到下一个子窗口。
- en: The stacked layout supports the `setCurrentIndex()` method to switch to a particular
    index position; alternatively, you could try the `setCurrentWidget()` method as
    well if it works better in your scenario.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 堆叠布局支持`setCurrentIndex()`方法以切换到特定的索引位置；或者，如果在您的情况下更有效，也可以尝试`setCurrentWidget()`方法。
- en: 'The `main.cpp` looks short and simple, as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.cpp`看起来简短而简单，如下所示：'
- en: '![](img/d25aba55-f0d3-4f49-80c4-b5ba45675cda.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d25aba55-f0d3-4f49-80c4-b5ba45675cda.png)'
- en: Figure 5.65
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.65
- en: The best part of our `main` function is that irrespective of the complexity
    of the application logic, the `main` function doesn't have any business logic.
    This makes our code clean and easily maintainable.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`main`函数的最好部分是，无论应用程序逻辑的复杂性如何，`main`函数都没有任何业务逻辑。这使得我们的代码清晰易懂，易于维护。
- en: Writing a simple math application combining multiple layouts
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个简单的数学应用程序，结合多个布局
- en: 'In this section, let''s explore how to write a simple math application. As
    part of this exercise, we will use `QLineEdit` and `QLabel` widgets and `QFormLayout`.
    We need to design a UI, as shown in the following screenshot:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们探讨如何编写一个简单的数学应用程序。作为这个练习的一部分，我们将使用`QLineEdit`和`QLabel`小部件以及`QFormLayout`。我们需要设计一个UI，如下面的屏幕截图所示：
- en: '![](img/82d57bed-0031-4138-a002-611c3d9f7934.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82d57bed-0031-4138-a002-611c3d9f7934.png)'
- en: Figure 5.66
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.66
- en: '`QLabel` is a widget typically used for static text, and `QLineEdit` will allow
    a user to supply a single line input. As shown in the preceding screenshot, we
    will use `QVBoxLayout` as the main layout in order to arrange `QFormLayout` and
    `QBoxLayout` in a vertical fashion. `QFormLayout` comes in handy when you need
    to create a form where there will be a caption on the left-hand side followed
    by some widget on its right. `QGridLayout` might also do the job, but `QFormLayout`
    is easy to use in such scenarios.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`QLabel`是一个通常用于静态文本的小部件，`QLineEdit`允许用户提供单行输入。如前面的屏幕截图所示，我们将使用`QVBoxLayout`作为主要布局，以便以垂直方式排列`QFormLayout`和`QBoxLayout`。`QFormLayout`在需要创建一个表单的情况下非常方便，在左侧将有一个标题，右侧将有一些小部件。`QGridLayout`也可能适用，但在这种情况下使用`QFormLayout`更容易。'
- en: 'In this exercise, we will create three files, namely `MyDlg.h`, `MyDlg.cpp`,
    and `main.cpp`. Let''s start with the `MyDlg.h` source code and then move on to
    other files:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建三个文件，分别是`MyDlg.h`、`MyDlg.cpp`和`main.cpp`。让我们从`MyDlg.h`源代码开始，然后再转到其他文件：
- en: '![](img/d55649f7-978f-487a-8ca6-7358f1977612.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d55649f7-978f-487a-8ca6-7358f1977612.png)'
- en: Figure 5.67
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.67
- en: In the preceding figure, three layouts are declared. The vertical box layout
    is used as the main layout, while the box layout is used to arrange the buttons
    in the right-aligned fashion. The form layout is used to add the labels, that
    is, line edit widgets. This exercise will also help you understand how one can
    combine multiple layouts to design a professional HMI.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，声明了三种布局。垂直框布局用作主要布局，而框布局用于以右对齐的方式排列按钮。表单布局用于添加标签，即行编辑小部件。这个练习还将帮助您了解如何结合多个布局来设计专业的HMI。
- en: Qt doesn't have any documented restriction in the number of layouts that can
    be combined in a single window. However, when possible, it is a good idea to consider
    designing an HMI with a minimal number of layouts if you are striving to develop
    a small memory footprint application. Otherwise, there is certainly no harm in
    using multiple layouts in your application.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: Qt没有记录在单个窗口中可以组合的布局数量的限制。然而，如果可能的话，考虑使用最少的布局来设计HMI是一个好主意，特别是如果您正在努力开发一个内存占用小的应用程序。否则，在您的应用程序中使用多个布局也没有坏处。
- en: In the following screenshot, you will get an idea of how the `MyDlg.cpp` source
    file shall be implemented. In the `MyDlg` constructor, all the buttons are instantiated
    and laid out in the box layout for right alignment. The form layout is used to
    hold the `QLineEdit` widgets and their corresponding `QLabel` widgets in a grid-like
    fashion. `QLineEdit` widgets typically help supply a single line input; in this
    particular exercise, they help us supply a number input that must be added, subtracted,
    and so on, depending on the user's choice.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您将了解到`MyDlg.cpp`源文件应该如何实现。在`MyDlg`构造函数中，所有按钮都被实例化并在框布局中以右对齐的方式布局。表单布局用于以类似网格的方式容纳`QLineEdit`小部件和它们对应的`QLabel`小部件。`QLineEdit`小部件通常用于提供单行输入；在这个特定的练习中，它们帮助我们提供必须根据用户的选择进行加法、减法等操作的数字输入。
- en: '![](img/6a4b7279-2794-43b7-ab4a-d41d7e5445a9.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a4b7279-2794-43b7-ab4a-d41d7e5445a9.png)'
- en: Figure 5.68
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.68
- en: The best part of our `main.cpp` source file is that it remains pretty much the
    same, irrespective of the complexity of our application. In this exercise, I would
    like to tell you a secret about `MyDlg`. Did you notice that the `MyDlg` constructor
    is instantiated in the stack as opposed to the heap? The idea is that when the
    `main()` function exits, the stack used by the `main` function gets unwinded,
    eventually freeing up all the stack variables present in the stack. When `MyDlg`
    gets freed up, it results in calling the `MyDlg` destructor. In the Qt Framework,
    every widget constructor takes an optional parent widget pointer, which is used
    by the topmost window destructor to free up its child widgets. Interestingly,
    Qt maintains a tree-like data structure to manage the memory of all its child
    widgets. So, if all goes well, the Qt Framework will take care of freeing up all
    its child widgets' memory locations "automagically".
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`main.cpp`源文件的最好部分是，它基本上保持不变，无论我们的应用程序的复杂性如何。在这个练习中，我想告诉你一个关于`MyDlg`的秘密。你有没有注意到`MyDlg`的构造函数是在堆栈中实例化的，而不是在堆中？这个想法是，当`main()`函数退出时，`main`函数使用的堆栈会被解开，最终释放堆栈中存在的所有堆栈变量。当`MyDlg`被释放时，会导致调用`MyDlg`的析构函数。在Qt框架中，每个窗口部件构造函数都接受一个可选的父窗口部件指针，这个指针被顶层窗口的析构函数用来释放它的子窗口部件。有趣的是，Qt维护一个类似树的数据结构来管理所有子窗口部件的内存。因此，如果一切顺利，Qt框架将负责自动释放所有子窗口部件的内存位置。
- en: This helps Qt developers focus on the application aspect, while the Qt Framework
    will take care of memory management.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于Qt开发人员专注于应用程序方面，而Qt框架将负责内存管理。
- en: '![](img/5dce506b-58e0-4325-99b9-b4f43fbff988.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5dce506b-58e0-4325-99b9-b4f43fbff988.png)'
- en: Figure 5.69
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.69
- en: 'Aren''t you excited to check the output of our new application? If you build
    and execute the application, then you are supposed to get an output similar to
    the following screenshot**.** Of course, we are yet to add signal and slot support,
    but it''s a good idea to design the GUI to our satisfaction and then shift our
    focus to event handling:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 你是不是很兴奋地想要检查我们新应用程序的输出？如果你构建并执行应用程序，那么你应该得到类似以下截图的输出。当然，我们还没有添加信号和槽支持，但设计GUI满意后再转向事件处理是个好主意：
- en: '![](img/9f4f2619-07f8-4a7b-957e-3a0efdeea9a4.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f4f2619-07f8-4a7b-957e-3a0efdeea9a4.png)'
- en: Figure 5.70
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.70
- en: 'If you observe closely, though the buttons are laid out on `QBoxLayout` in
    the right to left direction, the buttons aren''t aligned to the right. The reason
    for this behavior is when the window is stretched out, the box layout seems to
    have divided and allocated the extra horizontal space available among all the
    buttons. So let''s go ahead and throw in a stretch item to the leftmost position
    on the box layout such that the stretch will eat up all the extra spaces, leaving
    the buttons no room to expand. This will get us the right-aligned effect. After
    adding the stretch, the code will look as shown in the following screenshot:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，尽管按钮在`QBoxLayout`上是从右到左排列的，但按钮并没有对齐到右边。这种行为的原因是当窗口被拉伸时，框布局似乎已经将额外的水平空间分配给了所有的按钮。因此，让我们在框布局的最左边位置添加一个拉伸项，这样拉伸就会占据所有额外的空间，让按钮没有空间可以扩展。这样就可以得到右对齐的效果。添加拉伸后，代码将如下截图所示：
- en: '![](img/f18dca21-9c3a-456a-b302-61e669805250.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f18dca21-9c3a-456a-b302-61e669805250.png)'
- en: Figure 5.71
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.71
- en: 'Go ahead and check whether your output looks as shown in the following screenshot.
    Sometimes, as developers, we get excited to see the output in a rush and forget
    to compile our changes, so ensure the project is built again. If you don''t see
    any change in output, no worries; just try to stretch out the window horizontally
    and you should see the right-aligned effect, as shown in the following screenshot:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 继续检查你的输出是否与以下截图一样。有时，作为开发人员，我们会急于看到输出而忘记编译我们的更改，所以确保项目再次构建。如果你没有看到输出中的任何变化，不用担心；只需尝试水平拉伸窗口，你应该会看到右对齐的效果，如下截图所示：
- en: '![](img/ddf4ea30-7cc3-4d86-ad69-0be08675e87b.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ddf4ea30-7cc3-4d86-ad69-0be08675e87b.png)'
- en: Figure 5.72
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.72
- en: Now since we have a decent-looking application, let's add signal and slot support
    to add the response to button clicks. Let's not rush and include the add and subtract
    functionalities for now. We will use some `qDebug()` print statements to check
    whether the signals and slots are connected properly and then gradually replace
    them with the actual functionalities.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，既然我们有了一个看起来不错的应用程序，让我们添加信号和槽支持来响应按钮点击。我们不要急于现在包括加法和减法功能。我们将使用一些`qDebug()`打印语句来检查信号和槽是否连接正确，然后逐渐用实际功能替换它们。
- en: 'If you remember the earlier signal and slot exercise, any Qt window that is
    interested in supporting signals and slots must be `QObject` and should include
    the `Q_OBJECT` macro in the `MyDlg.h` header file, as shown in the following screenshot:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得之前的信号和槽练习，任何有兴趣支持信号和槽的Qt窗口都必须是`QObject`，并且应该在`MyDlg.h`头文件中包含`Q_OBJECT`宏，如下截图所示：
- en: '![](img/82424603-a5f1-40e6-b887-5a0de59c643a.png)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82424603-a5f1-40e6-b887-5a0de59c643a.png)'
- en: Figure 5.73
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.73
- en: In lines starting from 41 through 45, four slot methods are declared in the
    private section. Slot functions are regular C++ functions that could be invoked
    directly just like other C++ functions. However, in this scenario, the slot functions
    are intended to be invoked only with `MyDlg`. Hence they are declared as private
    functions, but they could be made public if you believe that others might find
    it useful to connect to your public slot.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 从第41行到45行开始，私有部分声明了四个槽方法。槽函数是常规的C++函数，可以像其他C++函数一样直接调用。然而，在这种情况下，槽函数只打算与`MyDlg`一起调用。因此它们被声明为私有函数，但如果你认为其他人可能会发现连接到你的公共槽有用，它们也可以被设为公共的。
- en: 'Cool, if you have come this far, it says that you have understood the things
    discussed so far. Alright, let''s go ahead and implement the definitions for the
    slot functions in `MyDlg.cpp` and then connect the `clicked()` button''s signals
    with the respective slot functions:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，如果您已经走到这一步，这意味着您已经理解了到目前为止讨论的内容。好吧，让我们继续并在“MyDlg.cpp”中实现槽函数的定义，然后将“clicked（）”按钮的信号连接到相应的槽函数：
- en: '![](img/369bc1df-bea7-42fb-b1e6-31a158593ea3.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/369bc1df-bea7-42fb-b1e6-31a158593ea3.png)
- en: Figure 5.74
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.74
- en: 'Now it''s time to wire up the signals to their respective slots. As you may
    have guessed, we need to use the `connect` function in the `MyDlg` constructor,
    as shown in the following screenshot, to get the button clicks to the corresponding
    slots:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是将信号连接到它们各自的槽的时间。正如您可能已经猜到的那样，我们需要在“MyDlg”构造函数中使用“connect”函数，如下面的屏幕截图所示，以将按钮点击传递到相应的槽中：
- en: '![](img/08482ed2-2a04-4e2c-aa8e-0c7250b6891c.png)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/08482ed2-2a04-4e2c-aa8e-0c7250b6891c.png)
- en: Figure 5.75
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.75
- en: 'We are all set. Yes, it''s showtime now. As we have taken care of most of the
    stuff, let''s compile and check the output of our little Qt application:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了。是的，现在是展示时间。由于我们已经处理了大部分事情，让我们编译并检查我们小小的Qt应用程序的输出：
- en: '![](img/8ccc8ebe-6f19-4eab-8e26-60c76d2e28cb.png)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/8ccc8ebe-6f19-4eab-8e26-60c76d2e28cb.png)
- en: Figure 5.76
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.76
- en: 'Oops! We got some linker error. The root cause of this issue is that we forgot
    to invoke `qmake` after enabling signal and slot support in our application. No
    worries, let''s invoke `qmake` and `make` and run our application:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！我们遇到了一些链接器错误。这个问题的根本原因是我们在启用应用程序中的信号和槽支持后忘记调用“qmake”。别担心，让我们调用“qmake”和“make”，然后运行我们的应用程序：
- en: '![](img/4fd3db0f-e95a-46f0-8683-b88d34daa45b.png)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/4fd3db0f-e95a-46f0-8683-b88d34daa45b.png)
- en: Figure 5.77
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.77
- en: 'Great, we have fixed the issue. The make utility doesn''t seem to make any
    noise this time and we are able to launch the application. Let''s check whether
    the signals and slots are working as expected. For this, click on the Add button
    and see what happens:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，我们已经解决了问题。这次制作工具似乎没有发出任何声音，我们能够启动应用程序。让我们检查信号和槽是否按预期工作。为此，请单击“添加”按钮，看看会发生什么：
- en: '![](img/b62dd11c-18ca-416c-ad2c-cbdbcb6fbf0a.png)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/b62dd11c-18ca-416c-ad2c-cbdbcb6fbf0a.png)
- en: Figure 5.78
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.78
- en: Wow! When we click on the Add button, the `qDebug()` console message confirms
    that the `MyDlg::onAddButtonClicked()` slot is invoked. If you are curious to
    check the slots of other buttons, go ahead and try clicking on the rest of the
    buttons.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '哇！当我们点击“添加”按钮时，“qDebug（）”控制台消息确认“MyDlg :: onAddButtonClicked（）”槽被调用。如果您想要检查其他按钮的槽，请继续尝试点击其他按钮。'
- en: 'Our application will be incomplete without business logic. So let''s add business
    logic to the `MyDlg::onAddButtonClicked()` slot function to perform the addition
    and display the result. Once you learn how to integrate the added business logic,
    you can follow the same approach and implement the rest of the slot functions:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '我们的应用程序将不完整，没有业务逻辑。因此，让我们将业务逻辑添加到“MyDlg :: onAddButtonClicked（）”槽函数中，以执行添加并显示结果。一旦您学会了如何集成添加的业务逻辑，您可以遵循相同的方法并实现其余的槽函数：'
- en: '![](img/31e93df6-fc6e-4c0f-b5b6-2d334173592e.png)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/31e93df6-fc6e-4c0f-b5b6-2d334173592e.png)
- en: Figure 5.79
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.79
- en: In the `MyDlg::onAddButtonClicked()` function, the business logic is integrated.
    In lines 82 and 83, we are trying to extract the values typed by the user in the
    `QLineEdit` widgets. The `text()` function in `QLineEdit` returns `QString`**.**
    The `QString` object provides `toInt()` that comes in handy to extract the integer
    value represented by `QString`. Once the values are added and stored in the result
    variable, we need to convert the result integer value back to `QString`, as shown
    in line number 86, so that the result can be fed into `QLineEdit`, as shown in
    line number 88.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '在“MyDlg :: onAddButtonClicked（）”函数中，业务逻辑已经集成。在第82行和第83行，我们试图提取用户在“QLineEdit”小部件中键入的值。“QLineEdit”中的“text（）”函数返回“QString”。
    “QString”对象提供了“toInt（）”，非常方便地提取由“QString”表示的整数值。一旦将值添加并存储在结果变量中，我们需要将结果整数值转换回“QString”，如第86行所示，以便将结果输入到“QLineEdit”中，如第88行所示。'
- en: Similarly, you can go ahead and integrate the business logic for other math
    operations. Once you have thoroughly tested the application, you can remove the
    `qDebug()` console's output. We added the `qDebug()` messages for debugging purposes,
    hence they can be cleaned up now.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，您可以继续并集成其他数学运算的业务逻辑。一旦您彻底测试了应用程序，就可以删除“qDebug（）”控制台的输出。我们添加了“qDebug（）”消息以进行调试，因此现在可以清理它们了。
- en: Summary
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned developing C++ GUI applications using Qt application
    framework. The key takeaway points are listed below.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学会了使用Qt应用程序框架开发C ++ GUI应用程序。以下是要点。
- en: You learned installing Qt and required tools in Linux.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您学会了在Linux中安装Qt和所需的工具。
- en: You learned writing simple console based application with Qt Framework.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您学会了使用Qt框架编写简单的基于控制台的应用程序。
- en: You learned writing simple GUI based applications with Qt Framework.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您学会了使用Qt框架编写简单的基于GUI的应用程序。
- en: You learned event handling with Qt Signal and Slots mechanism and how Meta Object
    Compiler helps us generate the crucial boiler plate code required for Signal and
    Slots.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您学会了使用Qt信号和槽机制进行事件处理，以及元对象编译器如何帮助我们生成信号和槽所需的关键样板代码。
- en: You learned using various Qt Layouts in application development to develop an
    appealing HMI that looks great in many Qt supported platforms.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您学会了在应用程序开发中使用各种Qt布局来开发吸引人的HMI，在许多Qt支持的平台上看起来很棒。
- en: You learned combining multiple layouts in a single HMI to develop professional
    HMI.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您学会了将多个布局组合到单个HMI中，以开发专业的HMI。
- en: You learned quite a lot of Qt Widgets and how they could help you develop impressive
    HMIs.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您学会了许多Qt小部件，以及它们如何帮助您开发令人印象深刻的HMI。
- en: Overall you learned developing cross-platform GUI applications using Qt application
    framework.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总的来说，您学会了使用Qt应用程序框架开发跨平台GUI应用程序。
- en: In the next chapter, you will be learning multithread programming and IPC in
    C++.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习在C ++ 中进行多线程编程和IPC。
