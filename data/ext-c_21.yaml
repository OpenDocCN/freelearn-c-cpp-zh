- en: Chapter 21
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第21章
- en: Integration with Other Languages
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与其他语言的集成
- en: Knowing how to write a C program or library can be more valuable than you might
    expect. Due to the important role of C in developing operating systems, C is not
    limited to its own world. C libraries have the potential to be loaded and used
    in other programming languages as well. While you are reaping the benefits of
    writing code in a higher-level programming language, you can have the rocket power
    of C as a loaded library inside your language environment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何编写C程序或库可能比你想象的更有价值。由于C在开发操作系统中的重要作用，C并不仅限于其自身的世界。C库有潜力在其他编程语言中加载和使用。当你从编写高级编程语言的代码中获得好处时，你可以在你的语言环境中作为加载的库拥有C的火箭动力。
- en: In this chapter we are going to talk more about this, and demonstrate how C
    shared libraries can be integrated with some well-known programming languages.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更详细地讨论这个问题，并演示如何将C共享库与其他一些知名编程语言集成。
- en: 'In this chapter, we will cover the following key topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下关键主题：
- en: We discuss why integration is possible in the first place. The discussion is
    important because it gives you the basic idea of how integration works.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了集成之所以可能的原因。这次讨论很重要，因为它为你提供了集成是如何工作的基本概念。
- en: We design a C stack library. We build it as a shared object file. This shared
    object file is going to be used by a number of other programming languages.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们设计了一个C堆栈库。我们将其构建为一个共享对象文件。这个共享对象文件将被许多其他编程语言使用。
- en: We go through C++, Java, Python, and Golang and see how the stack library can
    be loaded first and then used.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将探讨C++、Java、Python和Golang，看看堆栈库是如何首先加载然后使用的。
- en: As a general note in this chapter, since we are going to work on five different
    subprojects, each having different programming languages, we only present the
    builds for Linux in order to prevent any issues regarding the builds and executions.
    Of course, we give enough information about the macOS system, but our focus is
    to build and run sources on Linux. Further scripts are available in the book's
    GitHub repository that help you to build the sources for macOS.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的一般说明，由于我们将要处理五个不同的子项目，每个项目都有不同的编程语言，我们只展示了Linux的构建，以防止任何关于构建和执行的问题。当然，我们提供了足够关于macOS系统的信息，但我们的重点是构建和运行Linux上的源代码。本书的GitHub仓库中还有其他脚本，可以帮助你构建macOS的源代码。
- en: The first section talks about the integration itself. We see why the integration
    with other programming languages is possible and it makes a basis for expanding
    our discussion within other environments rather than C.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分讨论了集成本身。我们探讨了为什么与其他编程语言的集成是可能的，这为我们扩展在其他环境中的讨论而不是C环境中的讨论奠定了基础。
- en: Why integration is possible?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么集成是可能的？
- en: As we have explained in *Chapter 10*, *Unix – History and Architecture*, C revolutionized
    the way we were developing operating systems. That's not the only magic of C;
    it also gave us the power to build other general-purpose programming languages
    on top of it. Nowadays, we call them higher-level programming languages. The compilers
    of these languages are mostly written in C and if not, they've been developed
    by other tools and compilers written in C.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在*第10章*，*Unix – 历史 与 架构*中所述，C彻底改变了我们开发操作系统的方法。这不仅仅是C的魔法；它还赋予了我们构建其他通用编程语言的能力，这些语言我们现在称之为高级编程语言。这些语言的编译器大多是用C编写的，如果不是，它们也是由用C编写的其他工具和编译器开发的。
- en: A general-purpose programming language that is not able to use or provide the
    functionalities of a system is not doing anything at all. You can write things
    with it, but you cannot execute it on any system. While there could be usages
    for such a programming language from a theoretical point of view, certainly it
    is not plausible from an industrial point of view. Therefore, the programming
    language, especially through its compiler, should be able to produce programs
    that work. As you know, the functionalities of a system are exposed through the
    operating system. Regardless of the operating system itself, a programming language
    should be able to provide those functionalities, and the programs written in that
    language, and being run on that system, should be able to use them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不能使用或提供系统功能的通用编程语言实际上什么都没做。你可以用它写东西，但无法在任何系统上执行它。虽然从理论角度来看，这样的编程语言可能有用途，但从工业角度来看，这显然是不切实际的。因此，编程语言，特别是通过其编译器，应该能够生成可工作的程序。正如你所知，系统的功能是通过操作系统暴露的。无论操作系统本身如何，编程语言都应该能够提供这些功能，并且在该语言编写的程序，在运行在该系统上时，应该能够使用它们。
- en: This is where C comes in. In Unix-like operating systems, the C standard library
    provides the API to use the available functionalities of the system. If a compiler
    wants to create a working program, it should be able to allow the compiled program
    to use the C standard library in an indirect fashion. No matter what the programming
    language is and whether it offers some specific and native standard library, like
    Java, which offers **Java Standard Edition** (**Java SE**), any request for a specific
    functionality made by the written program (such as opening a file) should be passed
    down to the C standard library and from there, it can reach the kernel and get
    performed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是C语言的作用所在。在类Unix操作系统中，C标准库提供了使用系统可用功能的API。如果编译器想要创建一个可工作的程序，它应该能够允许编译后的程序以间接的方式使用C标准库。无论编程语言是什么，以及它是否提供一些特定的和本机标准库，例如Java提供的**Java标准版**（**Java
    SE**），任何由编写的程序提出的特定功能请求（如打开文件）都应该传递给C标准库，然后从那里，它可以到达内核并执行。
- en: As an example, let's talk a bit more about Java. Java programs are compiled
    to an intermediate language called *bytecode*. In order to execute a Java bytecode,
    one needs to have **Java Runtime Environment** (**JRE**) installed. JRE has a
    virtual machine at its heart that loads the Java bytecode and runs it within itself.
    This virtual machine must be able to simulate the functionalities and services
    exposed by the C standard library and provide them to the program running within.
    Since every platform can be different in terms of the C standard library and its
    compliance with POSIX and SUS standards, we need to have some virtual machines
    built specifically for each platform.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们再详细谈谈Java。Java程序被编译成一种称为*字节码*的中间语言。为了执行Java字节码，需要安装**Java运行时环境**（**JRE**）。JRE的核心是一个虚拟机，它加载Java字节码并在其中运行。这个虚拟机必须能够模拟C标准库暴露的功能和服务，并将它们提供给运行在其内部的程序。由于每个平台在C标准库及其对POSIX和SUS标准的兼容性方面都可能不同，因此我们需要为每个平台构建一些特定的虚拟机。
- en: As a final note about the libraries that can be loaded in other languages, we
    can only load shared object files and it is not possible to load and use static
    libraries. Static libraries can only be linked to an executable or a shared object
    file. Shared object files have the `.so` extension in most Unix-like systems but
    they have the `.dylib` extension in macOS.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最后关于在其他语言中可以加载的库的说明，我们只能加载共享对象文件，并且无法加载和使用静态库。静态库只能链接到可执行文件或共享对象文件。在大多数类Unix系统中，共享对象文件有`.so`扩展名，但在macOS中它们有`.dylib`扩展名。
- en: In this section, despite its short length, I tried to give you a basic idea
    of why we are able to load C libraries, shared libraries specifically, and how
    most programming languages are already using C libraries, since the ability to
    load a shared object library and use it exists in most of them.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，尽管篇幅很短，但我试图给你一个基本的概念，解释为什么我们能够加载C库，特别是共享库，以及大多数编程语言是如何已经使用C库的，因为它们中的大多数都存在加载共享对象库并使用它的能力。
- en: The next step would be writing a C library and then loading it in various programming
    languages in order to use it. That's exactly what we want to do soon but before
    that you need to know how to get the chapter material and how to run the commands
    seen in the shell boxes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是编写一个C库，然后将其加载到各种编程语言中以供使用。这正是我们很快就要做的事情，但在那之前，你需要知道如何获取章节材料以及如何运行在shell框中看到的命令。
- en: Obtaining the necessary materials
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取必要的材料
- en: Since this chapter is full of sources from five different programming languages,
    and my hope is to have you all able to build and run the examples, I dedicated
    this section to going through some basic notes that you should be aware of regarding
    building the source code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章充满了来自五种不同编程语言的源代码，而且我的希望是让你们所有人都能构建和运行示例，所以我将这一节专门用于介绍一些基本注意事项，这些注意事项你应该在构建源代码时注意。
- en: 'First of all, you need to obtain the chapter material. As you should know by
    now, the book has a repository in which this chapter has a specific directory
    named `ch21-integration-with-other-languages`. The following commands show you
    how to clone the repository and change to the chapter''s root directory:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要获取章节材料。正如你现在应该知道的，这本书有一个仓库，其中这一章有一个名为`ch21-integration-with-other-languages`的特定目录。以下命令显示了如何克隆仓库并切换到章节的根目录：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Shell Code 21-1: Cloning the book''s GitHub repository and changing to the
    chapter''s root directory'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Shell代码 21-1：克隆书籍的GitHub仓库并切换到章节的根目录
- en: Regarding the shell boxes in this chapter, we assume that before executing the
    commands in a shell box, we are located in the root of the chapter, in the `ch21-integration-with-other-languages`
    folder. If we needed to change to other directories, we provide the required commands
    for that, but everything is happening inside the chapter's directory.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本章中的shell框，我们假设在执行shell框中的命令之前，我们位于章节的根目录`ch21-integration-with-other-languages`文件夹中。如果我们需要切换到其他目录，我们将提供所需的命令，但所有操作都在章节目录内进行。
- en: In addition, in order to be able to build source code, you need to have **Java
    Development Kit** (**JDK**), Python, and Golang installed on your machine. Depending
    on whether you're using Linux or macOS, and on your Linux distribution, the installation
    commands can be different.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了能够构建源代码，你需要在你的机器上安装**Java开发工具包**（**JDK**）、Python和Golang。根据你使用的是Linux还是macOS，以及你的Linux发行版，安装命令可能会有所不同。
- en: As the final note, the source code written in other languages than C should
    be able to use the C stack library that we discuss in the upcoming section. Building
    those sources requires that you've already built the C library. Therefore, make
    sure that you read the following section first and have its shared object library
    built before moving on to the next sections. Now that you know how to obtain the
    chapter's material, we can proceed to discuss our target C library.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的注意事项，用除C以外的其他语言编写的源代码应该能够使用我们在下一节中讨论的C栈库。构建这些源代码需要你已经构建了C库。因此，请确保你首先阅读以下章节，并在继续下一章节之前构建其共享对象库。现在，既然你知道了如何获取章节材料，我们就可以继续讨论我们的目标C库。
- en: Stack library
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈库
- en: In this section, we are going to write a small library that is going to be loaded
    and used by programs written in other programming languages. The library is about
    a Stack class that offers some basic operations like *push* or *pop* on stack
    objects. Stack objects are created and destroyed by the library itself and there
    is a constructor function, as well as a destructor function, to fulfill this purpose.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个小型库，该库将被其他编程语言编写的程序加载和使用。该库是关于一个栈类，它提供了一些基本的操作，如对栈对象进行*push*或*pop*。栈对象由库本身创建和销毁，并且有一个构造函数以及一个析构函数来满足这一目的。
- en: 'Next, you can find the library''s public interface, which exists as part of
    the `cstack.h` header file:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以找到库的公共接口，它作为`cstack.h`头文件的一部分存在：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Code Box 21-1 [cstack.h]: The public interface of the Stack library'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 21-1 [cstack.h]：栈库的公共接口
- en: As we have explained in *Chapter 6*, *OOP and Encapsulation*, the preceding
    declarations introduce the public interface of the Stack class. As you see, the
    companion attribute structure of the class is `cstack_t`. We have used `cstack_t`
    instead of `stack_t` because the latter is used in the C standard library and
    I prefer to avoid any ambiguity in this code. By the preceding declarations, the
    attribute structure is forward declared and has no fields in it. Instead, the
    details will come in the source file that does the actual implementation. The
    class also has a constructor, a destructor, and some other behaviors such as push
    and pop. As you can see, all of them accept a pointer of type `cstack_t` as their
    first argument that indicates the object they should act on. The way we wrote
    the Stack class is explained as part of *implicit encapsulation* in *Chapter 6*,
    *OOP and Encapsulation*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在 *第 6 章*，*面向对象编程和封装* 中所解释的，前述声明引入了 Stack 类的公共接口。正如你所见，类的伴随属性结构是 `cstack_t`。我们使用
    `cstack_t` 而不是 `stack_t`，因为后者在 C 标准库中使用，并且我更喜欢避免在此代码中产生任何歧义。通过前述声明，属性结构被前置声明且其中没有字段。相反，细节将在实际实现该结构的源文件中给出。该类还有一个构造函数、一个析构函数以及一些其他行为，如
    push 和 pop。正如你所见，所有这些函数都将 `cstack_t` 类型的指针作为它们的第一个参数，该指针指示它们应该作用的对象。我们编写 Stack
    类的方式在第 6 章，*面向对象编程和封装* 中的 *隐式封装* 部分进行了说明。
- en: '*Code Box 21-2* contains the implementation of the stack class. It also contains
    the actual definition for the `cstack_t` attribute structure:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码框 21-2* 包含了栈类的实现。它还包含了 `cstack_t` 属性结构的实际定义：'
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Code Box 21-2 [cstack.c]: The definition of the stack class'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 21-2 [cstack.c]: 栈类的定义'
- en: As you see, the definition implies that every stack object is backed with an
    array, and more than that, we can store any value in the stack. Let's build the
    library and produce a shared object library out of it. This would be the library
    file that is going to be loaded by other programming languages in the upcoming
    sections.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，定义暗示了每个栈对象都由一个数组支持，而且不仅如此，我们可以在栈中存储任何值。让我们构建库并从中生成一个共享对象库。这将是在接下来的章节中将被其他编程语言加载的库文件。
- en: 'The following shell box shows how to create a shared object library using the
    existing source files. The commands found in the text box work in Linux and they
    should be slightly changed in order to work in macOS. Note that before running
    the build commands, you should be in this chapter''s root directory as explained
    before:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 Shell 框展示了如何使用现有的源文件创建共享对象库。文本框中的命令在 Linux 上有效，并且为了在 macOS 上运行，它们应该进行轻微的修改。请注意，在运行构建命令之前，你应该处于该章节的根目录，正如之前所解释的：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Shell Box 21-2: Building the stack library and producing the shared object
    library file in Linux'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 21-2：在 Linux 中构建栈库并生成共享对象库文件
- en: 'As a side note, in macOS, we can run the preceding exact commands if the `gcc`
    is a known command and it is pointing to the `clang` compiler. Otherwise, we can
    use the following commands to build the library on macOS. Note that the extension
    of shared object files is .`dylib` in macOS:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，在 macOS 中，如果我们知道 `gcc` 是一个命令并且它指向 `clang` 编译器，我们可以运行前述的精确命令。否则，我们可以使用以下命令在
    macOS 上构建库。请注意，在 macOS 中共享对象文件的扩展名是 .`dylib`：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Shell Box 21-3: Building the stack library and producing the shared object
    library file in macOS'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 21-3：在 macOS 中构建栈库并生成共享对象库文件
- en: 'We now have the shared object library file, and we can write programs in other
    languages that can load it. Before giving our demonstration on how the preceding
    library can be loaded and used in other environments, we need to write some tests
    in order to verify its functionality. The following code creates a stack and performs
    some of the available operations and checks the results against the expectations:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了共享对象库文件，我们可以编写其他语言中的程序来加载它。在我们演示如何在前述库中加载和使用它在其他环境中的方法之前，我们需要编写一些测试来验证其功能。以下代码创建了一个栈并执行了一些可用的操作，并将结果与预期进行了比较：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Code Box 21-3 [cstack_tests.c]: The code testing the functionality of the Stack
    class'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 21-3 [cstack_tests.c]: 测试 Stack 类功能性的代码'
- en: 'As you can see, we have used assertions to check the returned values. The following
    is the output of the preceding code after being built and executed in Linux. Again,
    note that we are in the chapter''s root directory:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们使用了断言来检查返回的值。以下是在 Linux 环境下构建并执行前述代码的输出。再次提醒，我们处于该章节的根目录：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Shell Box 21-4: Building and running the library tests'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 'Shell 框 21-4: 构建和运行库测试'
- en: Note that in the preceding shell box, when running the final executable file
    `cstack_tests.out`, we have to set the environment variable `LD_LIBRARY_PATH`
    to point to the directory that contains the `libcstack.so`, because the executed
    program needs to find the shared object libraries and load them.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的 Shell 框中，当运行最终的可执行文件 `cstack_tests.out` 时，我们必须设置环境变量 `LD_LIBRARY_PATH`
    以指向包含 `libcstack.so` 的目录，因为执行程序需要找到共享对象库并将它们加载。
- en: As you see in *Shell Box 21-4*, all tests have passed successfully. This means
    that from the functional point of view, our library is performing correctly. It
    would be nice to check the library against a non-functional requirement like memory
    usage or having no memory leaks.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在 *Shell 框 21-4* 中所见，所有测试都成功通过。这意味着从功能角度来看，我们的库运行正确。检查库是否符合非功能性要求，如内存使用或没有内存泄漏，将会很棒。
- en: 'The following command shows how to use `valgrind` to check the execution of
    the tests for any possible memory leaks:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令显示了如何使用 `valgrind` 检查测试的执行以检查任何可能的内存泄漏：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Shell Box 21-5: Running the tests using valgrind'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 'Shell 框 21-5: 使用 valgrind 运行测试'
- en: As you can see, we don't have any memory leaks, and this gives us more trust
    in the library that we have written. Therefore, if we see any memory issue in
    another environment, the root cause should be investigated there first.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们没有任何内存泄漏，这使我们对我们编写的库更有信心。因此，如果我们看到另一个环境中的任何内存问题，首先应该在那里调查根本原因。
- en: In the following chapter, we will cover unit testing in C. As a proper replacement
    for the `assert` statements seen in *Code Box 21-3*, we could write unit tests
    and use a unit testing framework like CMocka to execute them.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍 C 的单元测试。作为 *代码框 21-3* 中看到的 `assert` 语句的合适替代品，我们可以编写单元测试并使用单元测试框架如
    CMocka 来执行它们。
- en: In the following sections, we are going to integrate the stack library in programs
    written by four programming languages. We'll start with C++.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将把堆栈库集成到用四种编程语言编写的程序中。我们将从 C++ 开始。
- en: Integration with C++
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 C++ 的集成
- en: Integration with C++ can be assumed as the easiest. C++ can be thought of as
    an object-oriented extension to C. A C++ compiler produces similar object files
    to those that a C compiler produces. Therefore, a C++ program can load and use
    a C shared object library easier than any other programming language. In other
    words, it doesn't matter whether a shared object file is the output of a C or
    C++ project; both can be consumed by a C++ program. The only thing that can be
    problematic in some cases is the C++ *name mangling* feature that is described
    in *Chapter 2*, *Compilation and Linking*. As a reminder, we'll briefly review
    it in the following section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C++ 的集成可以认为是最容易的。C++ 可以被视为 C 的面向对象扩展。C++ 编译器生成的目标文件与 C 编译器生成的类似。因此，C++ 程序比其他任何编程语言更容易加载和使用
    C 共享对象库。换句话说，共享对象文件是 C 还是 C++ 项目的输出并不重要；两者都可以被 C++ 程序消费。在某些情况下可能存在问题的唯一事情是 *第
    2 章* 中描述的 C++ *名称修饰* 功能。作为提醒，我们将在以下部分简要回顾它。
- en: Name mangling in C++
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++ 中的名称修饰
- en: 'To elaborate more on this, we should say that symbol names corresponding to
    functions (both global and member functions in classes) are mangled in C++. Name
    mangling is mainly there to support *namespaces* and *function overloading*, which
    are missing in C. Name mangling is enabled by default, therefore if C code gets
    compiled using a C++ compiler, we expect to see mangled symbol names. Look at
    the following example in *Code Box 21-4*:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更详细地说明这一点，我们应该说，与函数（类中的全局函数和成员函数）对应的符号名称在 C++ 中会被修饰。名称修饰主要是为了支持 *命名空间* 和 *函数重载*，这些在
    C 中是缺失的。名称修饰默认启用，因此如果 C 代码使用 C++ 编译器编译，我们期望看到修饰过的符号名称。看看以下 *代码框 21-4* 中的示例：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Code Box 21-4 [test.c]: A simple function in C'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 21-4 [test.c]: C 语言中的一个简单函数'
- en: 'If we compile the preceding file using a C compiler, in this case `clang`,
    we see the following symbols in the generated object file, shown in *Shell Box
    21-6*. Note that the file `test.c` doesn''t exist in the book''s GitHub repository:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 C 编译器编译前面的文件，在这种情况下是 `clang`，我们将在生成的目标文件中看到以下符号，如 *Shell 框 21-6* 所示。请注意，书中的
    GitHub 仓库中不存在 `test.c` 文件：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Shell Box 21-6: Compiling test.c with a C compiler'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 'Shell 框 21-6: 使用 C 编译器编译 test.c'
- en: 'As you see, we have a symbol named `_add` that refers to the function `add`
    defined above. Now, let''s compile the file with a C++ compiler, in this case
    `clang++`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们有一个名为 `_add` 的符号，它指向上面定义的 `add` 函数。现在，让我们使用 C++ 编译器编译这个文件，在这种情况下是 `clang++`：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Shell Box 21-7: Compiling test.c with a C++ compiler'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 21-7：使用 C++ 编译器编译 test.c
- en: As you can see, `clang++` has generated a warning that says that in the near
    future, the support for compiling C code as C++ code will be dropped. But since
    this behavior is not removed yet (and it is just deprecated), we see that the
    symbol name generated for the preceding function is mangled and is different from
    the one generated by `clang`. This can definitely lead to problems in the linking
    phase when looking for a specific symbol.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`clang++` 生成了一条警告，说明在不久的将来，将 C 代码编译为 C++ 代码的支持将被删除。但是，由于这种行为尚未被删除（并且只是已弃用），我们看到为前面函数生成的符号名称被修饰，并且与
    `clang` 生成的不同。这肯定会在链接阶段查找特定符号时导致问题。
- en: 'To eliminate this issue, one needs to wrap the C code inside a special scope
    that prevents a C++ compiler from mangling the symbol names. Then, compiling it
    with `clang` and `clang++` produces the same symbol names. Look at the following
    code in *Code Box 21-5,* which is a changed version of the code introduced in
    *Code Box 21-4*:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除这个问题，需要将 C 代码封装在一个特殊的范围内，以防止 C++ 编译器对符号名称进行修饰。然后，使用 `clang` 和 `clang++`
    编译它会产生相同的符号名称。看看 *代码框 21-5* 中的以下代码，这是 *代码框 21-4* 中引入的代码的修改版本：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Code Box 21-5 [test.c]: Putting the function declaration into the special C
    scope'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 21-5 [test.c]：将函数声明放入特殊的 C 范围
- en: 'The preceding function is put in the scope `extern "C" { ... }` only if the
    macro `__cplusplus` is already defined. Having the macro `__cplusplus` is a sign
    that the code is being compiled by a C++ compiler. Let''s compile the preceding
    code with `clang++` again:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数仅在宏 `__cplusplus` 已经定义的情况下放入 `extern "C" { ... }` 范围内。拥有宏 `__cplusplus`
    是代码正在由 C++ 编译器编译的标志。让我们再次使用 `clang++` 编译前面的代码：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Shell Box 21-8: Compiling the new version of test.c with clang++'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 21-8：使用 clang++ 编译 test.c 的新版本
- en: As you see, the generated symbol is not mangled anymore. Regarding our stack
    library, based on what we explained so far, we need to put all declarations in
    the scope `extern "C" { … }` and this is exactly the reason behind having that
    scope in *Code Box 21-1*. Therefore, when linking a C++ program with the stack
    library, the symbols can be found inside `libcstack.so` (or `libcstack.dylib`).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，生成的符号不再被修饰。关于我们的堆栈库，根据我们到目前为止的解释，我们需要将所有声明放在 `extern "C" { … }` 范围内，这正是
    *代码框 21-1* 中存在该范围的原因。因此，当将 C++ 程序与堆栈库链接时，符号可以在 `libcstack.so`（或 `libcstack.dylib`）中找到。
- en: '**Note**:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**:'
- en: '`extern "C"` is a *linkage specification*. More information can be found via
    the following links:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`extern "C"` 是一个 *链接规范*。更多信息可以通过以下链接找到：'
- en: https://isocpp.org/wiki/faq/mixing-c-and-cpp
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: https://isocpp.org/wiki/faq/mixing-c-and-cpp
- en: https://stackoverflow.com/questions/1041866/what-is-the-effect-of-extern-c-in-c.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: https://stackoverflow.com/questions/1041866/what-is-the-effect-of-extern-c-in-c.
- en: Now, it's time to write the C++ code that uses our stack library. As you'll
    see shortly, it's an easy integration.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候编写使用我们的堆栈库的 C++ 代码了。正如你很快就会看到的，这是一个简单的集成。
- en: C++ code
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++ 代码
- en: Now that we know how to disable name mangling when bringing C code into a C++
    project, we can proceed by writing a C++ program that uses the stack library.
    We start by wrapping the stack library in a C++ class, which is the main building
    block of an object-oriented C++ program. It is more appropriate to expose the
    stack functionality in an object-oriented fashion instead of having the stack
    library's C functions be called directly.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了如何在将 C 代码引入 C++ 项目时禁用名称修饰，我们可以通过编写一个使用堆栈库的 C++ 程序来继续。我们首先将堆栈库封装在一个
    C++ 类中，这是面向对象 C++ 程序的主要构建块。以面向对象的方式暴露堆栈功能，而不是直接调用堆栈库的 C 函数，更为合适。
- en: '*Code Box 21-6* contains the class that wraps the stack functionality derived
    from the stack library:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码框 21-6* 包含了从堆栈库派生出的封装堆栈功能的类：'
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Code Box 21-6 [c++/Stack.cpp]: A C++ class that wraps the functionalities exposed
    by the stack library'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 21-6 [c++/Stack.cpp]: 一个封装了堆栈库暴露的功能的 C++ 类'
- en: 'Regarding the preceding class, we can point out the following important notes:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面的类，我们可以指出以下重要注意事项：
- en: The preceding class keeps a private pointer to a `cstack_t` variable. This pointer
    addresses the object created by the static library's `cstack_new` function. This
    pointer can be thought of as a *handle* to an object that exists at the C level,
    created and managed by a separate C library. The pointer `mStack` is analogous
    to a file descriptor (or file handle) that refers to a file.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前面的类保留了一个指向 `cstack_t` 变量的私有指针。这个指针指向由静态库的 `cstack_new` 函数创建的对象。这个指针可以被视为一个指向在
    C 级别存在的对象的 *句柄*，由一个单独的 C 库创建和管理。指针 `mStack` 类似于文件描述符（或文件句柄），它指向一个文件。
- en: The class wraps all behavior functions exposed by the stack library. This is
    not essentially true for any object-oriented wrapper around a C library, and usually
    a limited set of functionalities is exposed.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类封装了堆栈库公开的所有行为函数。这并不一定适用于围绕 C 库的任何面向对象的包装器，通常只公开有限的功能集。
- en: 'The preceding class is a template class. This means that it can operate on
    a variety of data types. As you can see, we have declared two template functions
    for serializing and deserializing objects with various types: `CreateValue` and
    `ExtractValue`. The preceding class uses these functions to create a byte array
    from a C++ object (serialization) and to create a C++ object from a byte array
    (deserialization) respectively.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前面的类是一个模板类。这意味着它可以操作多种数据类型。正如你所看到的，我们声明了两个模板函数用于序列化和反序列化具有各种类型的对象：`CreateValue`
    和 `ExtractValue`。前面的类使用这些函数从 C++ 对象创建字节数组（序列化）以及从字节数组创建 C++ 对象（反序列化）。
- en: We define a specialized template function for the type `std::string`. Therefore,
    we can use the preceding class to store values with the `std::string` type. Note
    that `std::string` is the standard type in C++ for having a string variable.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为 `std::string` 类型定义了一个专门的模板函数。因此，我们可以使用前面的类来存储 `std::string` 类型的值。请注意，`std::string`
    是 C++ 中用于字符串变量的标准类型。
- en: As part of the stack library, you can have multiple values from different types
    pushed into a single stack instance. The value can be converted to/from a character
    array. Look at the `value_t` structure in *Code Box 21-1*. It only needs a `char`
    pointer and that's all. Unlike the stack library, the preceding C++ class is *type-safe*
    and every instance of it can operate only on a specific data type.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为堆栈库的一部分，你可以将来自不同类型的多个值推入单个堆栈实例。值可以转换为/从字符数组转换。查看 *代码框 21-1* 中的 `value_t` 结构。它只需要一个
    `char` 指针，仅此而已。与堆栈库不同，前面的 C++ 类是 *类型安全的*，并且它的每个实例只能操作特定的数据类型。
- en: In C++, every class has at least one constructor and one destructor. Therefore,
    it would be easy to initialize the underlying stack object as part of the constructor
    and finalize it in the destructor. That's exactly what you see in the preceding
    code.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C++ 中，每个类至少有一个构造函数和一个析构函数。因此，将底层堆栈对象作为构造函数的一部分进行初始化，并在析构函数中终止它是非常容易的。这正是前面代码所展示的。
- en: 'We want our C++ class to be able to operate on string values. Therefore, we
    need to write proper serializer and deserializer functions that can be used within
    the class. The following code contains the function definitions that convert a
    C char array to an `std::string` object and vice versa:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的 C++ 类能够操作字符串值。因此，我们需要编写适当的序列化和反序列化函数，这些函数可以在类内部使用。以下代码包含将 C 字符数组转换为
    `std::string` 对象以及相反转换的函数定义：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Code Box 21-7 [c++/Stack.cpp]: Specialized template functions meant for serialization/deserialization
    of the std::string type. These functions are used as part of the C++ class.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 21-7 [c++/Stack.cpp]：专门为 `std::string` 类型的序列化和反序列化设计的模板函数。这些函数作为 C++ 类的一部分被使用。
- en: The preceding functions are `std::string` *specialization* for the declared
    template function used in the class. As you can see, it defines how a `std::string`
    object should be converted to a C char array, and conversely how a C char array
    can be turned into an `std::string` object.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数是类中声明的模板函数的 `std::string` *特化*。正如你所看到的，它定义了如何将 `std::string` 对象转换为 C 字符数组，以及相反地，如何将
    C 字符数组转换为 `std::string` 对象。
- en: '*Code Box 21-8* contains the `main` method that uses the C++ class:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码框 21-8* 包含使用 C++ 类的 `main` 方法：'
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Code Box 21-8 [c++/Stack.cpp]: The main function using the C++ stack class'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 21-8 [c++/Stack.cpp]：使用 C++ 堆栈类的主体函数
- en: The preceding scenario covers all the functions exposed by the stack library.
    We execute a number of operations and we check their results. Note that the preceding
    code uses a `Stack<std::string>` object for testing functionality. Therefore,
    one can only push/pop `std::string` values into/from the stack.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 上述场景涵盖了栈库公开的所有功能。我们执行了一系列操作并检查了它们的结果。请注意，前面的代码使用`Stack<std::string>`对象进行功能测试。因此，只能将`std::string`值推入或从栈中弹出。
- en: 'The following shell box shows how to build and run the preceding code. Note
    that all the C++ code that you''ve seen in this section is written using C++11,
    hence it should be compiled using a compliant compiler. Like we said before, we
    are running the following commands when we are in the chapter''s root directory:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的shell box展示了如何构建和运行前面的代码。请注意，本节中所有看到的C++代码都是使用C++11编写的，因此应该使用兼容的编译器进行编译。正如我们之前所说的，当我们处于章节的根目录时，我们将运行以下命令：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Shell Box 21-9: Building and running the C++ code'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 21-9：构建和运行C++代码
- en: As you can see, we have indicated that we are going to use a C++11 compiler
    by passing the `-std=c++11` option. Note the `-I` and `-L` options, which are
    used for specifying custom include and library directories respectively. The option
    `-lcstack` asks the linker to link the C++ code with the library file `libcstack.so`.
    Note that on macOS systems, the shared object libraries have the `.dylib` extension,
    and therefore you might find `libcstack.dylib` instead of `libcstack.so`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经通过传递`-std=c++11`选项来指示我们将使用C++11编译器。请注意`-I`和`-L`选项，它们分别用于指定自定义包含和库目录。选项`-lcstack`要求链接器将C++代码与库文件`libcstack.so`链接起来。请注意，在macOS系统上，共享对象库具有`.dylib`扩展名，因此您可能会找到`libcstack.dylib`而不是`libcstack.so`。
- en: For running the `cstack_cpp.out` executable file, the loader needs to find `libcstack.so`.
    Note that this is different from building the executable. Here we want to run
    it, and the library file must be located before having the executable run. Therefore,
    by changing the environment variable `LD_LIBRARY_PATH`, we let the loader know
    where it should look for the shared objects. We have discussed more regarding
    this in *Chapter 2*, *Compilation and Linking*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行`cstack_cpp.out`可执行文件，加载器需要找到`libcstack.so`。请注意，这与构建可执行文件不同。在这里，我们想要运行它，并且库文件必须在可执行文件运行之前位于正确的位置。因此，通过更改环境变量`LD_LIBRARY_PATH`，我们让加载器知道它应该在何处查找共享对象。我们已在*第2章*，*编译和链接*中对此进行了更多讨论。
- en: 'The C++ code should also be tested against memory leaks. `valgrind` helps us
    to see the memory leaks and we use it to analyze the resulting executable. The
    following shell box shows the output of `valgrind` running the `cstack_cpp.out`
    executable file:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: C++代码也应该针对内存泄漏进行测试。`valgrind`帮助我们查看内存泄漏，我们用它来分析生成的可执行文件。下面的shell box展示了`valgrind`运行`cstack_cpp.out`可执行文件的输出：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Shell Box 21-10: Building and running the C++ code using valgrind'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 21-10：使用valgrind构建和运行C++代码
- en: As is clear from the preceding output, we don't have any leaks in the code.
    Note that having 1081 bytes in the `still reachable` section doesn't mean that
    you have had a leak in your code. You can find more about this in `valgrind`'s
    manual.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述输出所示，我们的代码中没有泄漏。请注意，`still reachable`部分中有1081字节并不意味着您的代码中存在泄漏。您可以在`valgrind`的手册中找到更多关于此的信息。
- en: In this section, we explained how to write a C++ wrapper around our C stack
    library. While mixing C and C++ code seems to be easy, some extra care about name
    mangling rules in C++ should be taken. In the next section, we are going to briefly
    talk about the Java programming language and the way that we are going to load
    our C library in a program written in Java.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们解释了如何编写一个围绕我们的C栈库的C++包装器。虽然混合C和C++代码看起来很简单，但在C++中应该注意一些额外的名称修饰规则。在下一节中，我们将简要介绍Java编程语言以及我们将如何在Java编写的程序中加载我们的C库。
- en: Integration with Java
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Java的集成
- en: Java programs are compiled by a Java compiler into Java bytecode. Java bytecode
    is analogous to the object file format specified in the **Application Binary Interface**
    (**ABI**). Files containing Java bytecode cannot be executed like ordinary executable
    files, and they need a special environment to be run.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Java程序由Java编译器编译成Java字节码。Java字节码类似于在**应用程序二进制接口**（**ABI**）中指定的对象文件格式。包含Java字节码的文件不能像普通可执行文件那样执行，它们需要一个特殊的环境来运行。
- en: Java bytecode can only be run within a **Java Virtual Machine** (**JVM**). The
    JVM is itself a process that simulates a working environment for the Java bytecode.
    It is usually written in C or C++ and has the power to load and use the C standard
    library and the functionalities exposed in that layer.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Java 字节码只能在 **Java 虚拟机** (**JVM**) 中运行。JVM 本身是一个模拟 Java 字节码工作环境的进程。它通常用 C 或
    C++ 编写，并且具有加载和使用 C 标准库以及在该层公开的功能的能力。
- en: The Java programming language is not the only language that can be compiled
    into Java bytecode. Scala, Kotlin, and Groovy are among programming languages
    that can be compiled to Java bytecode hence they can be run within a JVM. They
    are usually called *JVM languages*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Java 编程语言不是唯一可以编译成 Java 字节码的语言。Scala、Kotlin 和 Groovy 等编程语言也可以编译成 Java 字节码，因此它们可以在
    JVM 中运行。它们通常被称为 *JVM 语言*。
- en: In this section, we are going to load our already built stack library into a
    Java program. For those who have no prior knowledge of Java, the steps we take
    may seem complicated and hard to grasp. Therefore, it is strongly recommended
    that readers come into this section with some basic knowledge about Java programming.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将把已经构建的栈库加载到 Java 程序中。对于那些没有 Java 基础知识的人来说，我们采取的步骤可能看起来很复杂，难以理解。因此，强烈建议读者在进入本节之前对
    Java 编程有一些基本了解。
- en: Writing the Java part
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 Java 部分
- en: Suppose that we have a C project that it is built into a shared object library.
    We want to bring it into Java and use its functions. Fortunately, we can write
    and compile the Java part without having any C (or native) code. They are well
    separated by the *native methods* in Java. Obviously, you cannot run the Java
    program with just the Java part, and have the C functions called, without the
    shared object library file being loaded. We give the necessary steps and source
    code to make this happen and run a Java program that loads a shared object library
    and invokes its functions successfully.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个构建成共享对象库的 C 项目。我们希望将其引入 Java 并使用其函数。幸运的是，我们可以编写和编译 Java 部分，而无需任何 C（或本地）代码。它们通过
    Java 中的 *native 方法* 被很好地分离。显然，如果没有加载共享对象库文件，仅使用 Java 部分运行 Java 程序并调用 C 函数是不可能的。我们提供了必要的步骤和源代码来实现这一点，并成功运行了一个加载共享对象库并调用其函数的
    Java 程序。
- en: The JVM uses **Java Native Interface** (**JNI**) to load shared object libraries.
    Note that JNI is not part of the Java programming language; rather, it is part
    of the JVM specification, therefore an imported shared object library can be used
    in all JVM languages such as Scala.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 使用 **Java 本地接口** (**JNI**) 来加载共享对象库。请注意，JNI 不是 Java 编程语言的一部分；相反，它是 JVM 规范的一部分，因此导入的共享对象库可以在所有
    JVM 语言（如 Scala）中使用。
- en: In the following paragraphs, we show how to use JNI to load our target shared
    object library file.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的段落中，我们将展示如何使用 JNI 加载我们的目标共享对象库文件。
- en: 'As we said before, JNI uses native methods. Native methods don''t have any
    definition in Java; their actual definitions are written using C or C++ and they
    reside in external shared libraries. In other words, native methods are ports
    for the Java programs to communicate to the world outside of the JVM. The following
    code shows a class that contains a number of static native methods and it is supposed
    to expose the functionalities provided by our stack library:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所说，JNI 使用本地方法。本地方法在 Java 中没有定义；它们的实际定义是用 C 或 C++ 编写的，并驻留在外部共享库中。换句话说，本地方法是
    Java 程序与 JVM 外部世界通信的端口。以下代码显示了一个包含多个静态本地方法的类，它应该公开我们的栈库提供的功能：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Code Box 21-9 [java/src/com/packt/extreme_c/ch21/ex1/Main.java]: The NativeStack
    class'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 21-9 [java/src/com/packt/extreme_c/ch21/ex1/Main.java]: NativeStack 类'
- en: As the method signatures imply, they correspond to the functions we have in
    the C stack library. Note that the first operand is a `long` variable. It contains
    a native address read from the native library and acts as a pointer that should
    be passed to other methods to denote the stack instance. Note that, for writing
    the preceding class, we don't need to have a fully working shared object file
    beforehand. The only thing we need is the list of required declarations to define
    the stack API.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如方法签名所示，它们对应于我们在 C 栈库中的函数。请注意，第一个操作数是一个 `long` 变量。它包含从本地库中读取的本地地址，并作为指针传递给其他方法以表示栈实例。请注意，在编写前面的类时，我们不需要事先有一个完全工作的共享对象文件。我们所需的是定义栈
    API 所需的声明列表。
- en: The preceding class has also a *static constructor*. The constructor loads a
    shared object library file located on the filesystem and tries to match the native
    methods with the symbols found in that shared object library. Note that the preceding
    shared object library is not `libcstack.so`. In other words, this is not the shared
    object file that we produced for our stack library. JNI has a very precise recipe
    for finding symbols that correspond to native methods. Therefore, we cannot use
    our symbols defined in `libcstack.so`; instead we need to create the symbols that
    JNI is looking for and then use our stack library from there.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个类还有一个*静态构造函数*。构造函数加载位于文件系统上的共享对象库文件，并尝试将本地方法与该共享对象库中找到的符号匹配。请注意，前面的共享对象库不是`libcstack.so`。换句话说，这并不是为我们自己的堆栈库生成的共享对象文件。JNI有一个非常精确的配方来查找与本地方法相对应的符号。因此，我们不能使用定义在`libcstack.so`中的符号；相反，我们需要创建JNI正在寻找的符号，然后从那里使用我们的堆栈库。
- en: This might be a bit unclear at the moment, but in the following section, we
    clarify this and you'll see how this can be done. Let's continue with the Java
    part. We still need to add some more Java code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能目前有点不清楚，但在下一节中，我们将澄清这一点，你将看到如何实现。让我们继续Java部分。我们仍然需要添加一些更多的Java代码。
- en: The following is a generic Java class named `Stack<T>` that wraps the native
    methods exposed by JNI. Generic Java classes can be regarded as twin concepts
    for the template classes that we had in C++. They are used to specify some generic
    types that can operate on other types.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的是一个名为`Stack<T>`的通用Java类，它封装了JNI公开的本地方法。通用Java类可以被视为与C++中我们拥有的模板类的孪生概念。它们用于指定可以操作其他类型的某些通用类型。
- en: 'As you see in the `Stack<T>` class, there is a *marshaller* object, from the
    type `Marshaller<T>`, that is used to serialize and deserialize the methods''
    input arguments (from type `T`) in order to put them into, or retrieve them from,
    the underlying C stack:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在`Stack<T>`类中看到的，有一个`marshaller`对象，其类型为`Marshaller<T>`，用于序列化和反序列化方法的输入参数（类型为`T`），以便将它们放入或从底层C堆栈中检索：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Code Box 21-10 [java/src/com/packt/extreme_c/ch21/ex1/Main.java]: The Stack<T>
    class and the Marshaller<T> interface'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框21-10 [java/src/com/packt/extreme_c/ch21/ex1/Main.java]: `Stack<T>`类和`Marshaller<T>`接口'
- en: 'The following points seem to be noticeable regarding the preceding code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面的代码，以下几点似乎值得关注：
- en: The class `Stack<T>` is a generic class. It means that its different instances
    can operate on various classes like `String`, `Integer`, `Point`, and so on, but
    every instance can operate only on the type specified upon instantiation.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stack<T>`类是一个通用类。这意味着它的不同实例可以操作各种类，如`String`、`Integer`、`Point`等，但每个实例只能操作在实例化时指定的类型。'
- en: The ability to store any data type in the underlying stack requires the stack
    to use an external marshaller to perform serialization and deserialization of
    the objects. The C stack library is able to store byte arrays in a stack data
    structure and higher-level languages willing to use its functionalities should
    be able to provide that byte array through serialization of the input objects.
    You will see shortly the implementation of the `Marshaller` interface for the
    `String` class.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在底层堆栈中存储任何数据类型的能力需要堆栈使用外部marshaller来执行对象的序列化和反序列化。C堆栈库能够将字节数组存储在堆栈数据结构中，而愿意使用其功能的高级语言应该能够通过序列化输入对象来提供该字节数组。你很快就会看到`String`类的`Marshaller`接口的实现。
- en: We inject the `Marshaller` instance using the constructor. This means that we
    should have an already created marshaller instance that is compatible with the
    *generic* type of the class `T`.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用构造函数注入`Marshaller`实例。这意味着我们应该有一个已经创建的与类`T`的*通用*类型兼容的marshaller实例。
- en: The `Stack<T>` class implements the `AutoCloseable` interface. This simply means
    that it has some native resources that should be freed upon destruction. Note
    that the actual stack is created in the native code and not in the Java code.
    Therefore, the JVM's *garbage collector* cannot free the stack when it is not
    needed anymore. `AutoCloseable` objects can be used as resources which have a
    specific scope and when they are not needed anymore, their `close` method is called
    automatically. Shortly, you will see how we use the preceding class in a test
    scenario.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stack<T>`类实现了`AutoCloseable`接口。这仅仅意味着它有一些应该在销毁时释放的本地资源。请注意，实际的栈是在本地代码中创建的，而不是在Java代码中。因此，当不再需要栈时，JVM的*垃圾回收器*无法释放栈。`AutoCloseable`对象可以用作具有特定作用域的资源，当它们不再需要时，它们的`close`方法会被自动调用。简而言之，你将看到我们如何在测试场景中使用前面的类。'
- en: As you see, we have the constructor method and we have initialized the underlying
    stack using the native methods. We keep a handler to the stack as a `long` field
    in the class. Note that unlike in C++, we don't have any destructors in the class.
    Therefore, it is possible not to have the underlying stack freed and for it eventually
    to become a memory leak. That's why we have marked the class as an `AutoCloseable`.
    When an `AutoCloseable` object is not needed anymore, its `close` method is called
    and as you see in the preceding code, we call the destructor function from the
    C stack library to release the resources allocated by the C stack.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如你所见，我们有一个构造函数，并且使用本地方法初始化了底层的栈。我们在类中保留了一个指向栈的`long`字段。请注意，与C++不同，我们在这个类中没有任何析构函数。因此，有可能不释放底层的栈，并且最终可能导致内存泄漏。这就是为什么我们将这个类标记为`AutoCloseable`。当一个`AutoCloseable`对象不再需要时，它的`close`方法会被调用，正如你在前面的代码中所看到的，我们调用了C栈库的析构函数来释放由C栈分配的资源。
- en: Generally, you cannot trust the garbage collector mechanism to call *finalizer
    methods* on Java objects and using the `AutoCloseable` resources is the correct
    way to manage native resources.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你不能信任垃圾回收器机制在Java对象上调用*终结器方法*，使用`AutoCloseable`资源是管理本地资源的正确方式。
- en: 'The following is the implementation of `StringMarshaller`. The implementation
    is very straightforward thanks to the great support of the `String` class in working
    with byte arrays:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的内容是`StringMarshaller`的实现。由于`String`类在处理字节数组方面提供了很好的支持，所以实现非常直接：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Code Box 21-11 [java/src/com/packt/extreme_c/ch21/ex1/Main.java]: The StringMarshaller
    class'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 21-11 [java/src/com/packt/extreme_c/ch21/ex1/Main.java]: `StringMarshaller`类'
- en: 'The following code is our `Main` class that contains the test scenario for
    demonstration of C stack functionalities through Java code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是我们的`Main`类，它包含了通过Java代码演示C栈功能的测试场景：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Code Box 21-12 [java/src/com/packt/extreme_c/ch21/ex1/Main.java]: The Main
    class that contains the test scenario to check the functionalities of the C stack
    library'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 21-12 [java/src/com/packt/extreme_c/ch21/ex1/Main.java]: 包含测试场景以检查C栈库功能的`Main`类'
- en: As you see, the reference variable `stack` is being created and used inside
    a `try` block. This syntax is usually called *try-with-resources* and it has been
    introduced as part of Java 7\. When the `try` block is finished, the method `close`
    is called on the resource object and the underlying stack becomes freed. The test
    scenario is the same as the scenario we wrote for C++ in the previous section,
    but this time in Java.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，引用变量`stack`是在一个`try`块内部创建和使用的。这种语法通常被称为*try-with-resources*，并且它是作为Java
    7的一部分被引入的。当`try`块执行完毕后，会在资源对象上调用`close`方法，并且底层的栈被释放。测试场景与我们在上一节为C++编写的场景相同，但这次是在Java中。
- en: In this section, we covered the Java part and all the Java code that we need
    to import the native part. All the sources above can be compiled but you cannot
    run them because you need the native part as well. Only together can they lead
    to an executable program. In the next section, we talk about the steps we should
    take to write the native part.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们涵盖了Java部分以及我们需要导入本地部分的所有Java代码。上述所有源代码都可以编译，但你不能运行它们，因为你还需要本地部分。只有两者结合才能生成可执行程序。在下一节中，我们将讨论我们应该采取的步骤来编写本地部分。
- en: Writing the native part
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写本地部分
- en: 'The most important thing we introduced in the previous section was the idea
    of native methods. Native methods are declared within Java, but their definitions
    reside outside of the JVM in a shared object library. But how does the JVM find
    the definition of a native method in the loaded shared object files? The answer
    is simple: by looking up certain symbol names in the shared object files. The
    JVM extracts a symbol name for every native method based on its various properties
    like the package, the containing class, and its name. Then, it looks for that
    symbol in the loaded shared object libraries and if it cannot find it, it gives
    you an error.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们介绍的最重要的事情是本地方法的概念。本地方法在 Java 中声明，但其定义位于 JVM 外部的共享对象库中。但是 JVM 如何在加载的共享对象文件中找到本地方法的定义呢？答案是简单的：通过在共享对象文件中查找某些符号名称。JVM
    根据其各种属性（如包、包含的类和名称）为每个本地方法提取一个符号名称。然后，它在加载的共享对象库中查找该符号，如果找不到，它会给你一个错误。
- en: Based on what we established in the previous section, the JVM forces us to use
    specific symbol names for the functions we write as part of the loaded shared
    object file. But we didn't use any specific convention while creating the stack
    library. So, the JVM won't be able to find our exposed functions from the stack
    library and we must come up with another way. Generally, C libraries are written
    without any assumption about being used in a JVM environment.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们在上一节中建立的内容，JVM 强制我们使用特定的符号名称来编写作为加载的共享对象文件一部分的函数。但我们在创建栈库时没有使用任何特定的约定。因此，JVM
    将无法从栈库中找到我们公开的函数，我们必须想出另一种方法。通常，C 库是在没有任何假设会被用于 JVM 环境的情况下编写的。
- en: '*Figure 21-1* shows how we can use an intermediate C or C++ library to act
    as a glue between the Java part and the native part. We give the JVM the symbols
    it wants, and we delegate the function calls made to the functions representing
    those symbols to the correct function inside the C library. This is basically
    how JNI works.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 21-1* 展示了我们可以如何使用一个中间的 C 或 C++ 库作为 Java 部分和本地部分之间的粘合剂。我们给 JVM 它想要的符号，并将对代表这些符号的函数的调用委托给
    C 库中的正确函数。这基本上就是 JNI 的工作方式。'
- en: We'll explain this with an imaginary example. Suppose that we want to make a
    call to a C function, `func`, from Java, and the definition of the function can
    be found in the `libfunc.so` shared object file. We also have a class `Clazz`
    in the Java part with a native function called `doFunc`. We know that the JVM
    would be looking for the symbol `Java_Clazz_doFunc` while trying to find the definition
    of the native function `doFunc`. We create an intermediate shared object library
    `libNativeLibrary.so` that contains a function with exactly the same symbol that
    the JVM is looking for. Then, inside that function, we make a call to the `func`
    function. We can say that the function `Java_Clazz_doFunc` acts as a relay and
    delegates the call to the underlying C library and eventually the `func` function.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个假设的例子来解释这一点。假设我们想从 Java 中调用一个 C 函数 `func`，该函数的定义可以在 `libfunc.so` 共享对象文件中找到。我们还在
    Java 部分有一个名为 `Clazz` 的类，其中有一个名为 `doFunc` 的本地函数。我们知道 JVM 在尝试找到本地函数 `doFunc` 的定义时会查找符号
    `Java_Clazz_doFunc`。我们创建一个中间共享对象库 `libNativeLibrary.so`，其中包含一个具有与 JVM 寻找的符号完全相同的函数。然后，在该函数内部，我们调用
    `func` 函数。我们可以这样说，函数 `Java_Clazz_doFunc` 作为中继，将调用委托给底层的 C 库，最终是 `func` 函数。
- en: '![fig10-1](img/B11046_21_01.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![fig10-1](img/B11046_21_01.png)'
- en: 'Figure 21-1: The intermediate shared object libNativeStack.so which is used
    to delegate function calls from Java to the actual underlying C stack library,
    libcstack.so.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21-1：中间共享对象库 libNativeStack.so，用于将函数调用从 Java 委托到实际的底层 C 栈库，libcstack.so。
- en: In order to stay aligned with JVM symbol names, the Java compiler usually generates
    a C header file out of the native methods found in a Java code. This way, you
    only need to write the definitions of those functions found in the header file.
    This prevents us from making any mistakes in the symbol names that the JVM eventually
    would be looking for.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与 JVM 符号名称保持一致，Java 编译器通常会将 Java 代码中找到的本地方法生成一个 C 头文件。这样，你只需要编写头文件中找到的函数的定义。这可以防止我们在符号名称上犯任何错误，这些错误最终会被
    JVM 查找。
- en: 'The following commands demonstrate how to compile a Java source file and how
    to ask the compiler to generate a header file for the found native methods in
    it. Here, we are going to compile our only Java file, `Main.java`, which contains
    all the Java code introduced in the previous code boxes. Note that we should be
    in the chapter''s root directory when running the following commands:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令展示了如何编译一个 Java 源文件，以及如何请求编译器为其中找到的本地方法生成头文件。在这里，我们将编译我们唯一的 Java 文件 `Main.java`，它包含了之前代码框中引入的所有
    Java 代码。请注意，在运行以下命令时，我们应该位于章节的根目录中：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Shell Box 21-11: Compiling the Main.java while generating a header for native
    methods found in the file'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 21-11：编译 Main.java 并为文件中找到的本地方法生成头文件
- en: As shown in the preceding shell box, we have passed the option `-h` to `javac,`
    which is the Java compiler. We have also specified a directory that all headers
    should go to. The `tree` utility shows the content of the `build` directory in
    a tree-like format. Note the `.class` files. They contain the Java bytecode which
    will be used when loading these classes into a JVM instance.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述 shell box 所示，我们向 Java 编译器 `javac` 传递了选项 `-h`。我们还指定了一个目录，所有头文件都应该放在那里。`tree`
    工具以树形格式显示了 `build` 目录的内容。注意 `.class` 文件。它们包含 Java 字节码，当将这些类加载到 JVM 实例时将使用这些字节码。
- en: In addition to class files we see a header file, `com_packt_extreme_c_ch21_ex1_NativeStack.h`,
    that contains the corresponding C function declarations for the native methods
    found in the `NativeStack` class.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 除了类文件外，我们还看到了一个头文件 `com_packt_extreme_c_ch21_ex1_NativeStack.h`，它包含了在 `NativeStack`
    类中找到的本地方法的相应 C 函数声明。
- en: 'If you open the header file, you will see something like *Code Box 21-13*.
    It has a number of function declarations with long and strange names each of which
    being made up of the package name, the class name, and the name of the corresponding
    native method:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开头文件，你会看到类似于 *Code Box 21-13* 的内容。它包含了许多具有长而奇怪的名称的函数声明，每个名称都由包名、类名和相应的本地方法名称组成：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Code Box 21-13: The (incomplete) content of the generated JNI header file'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 21-13：生成的 JNI 头文件的内容（不完整）
- en: 'The functions declared in the preceding header file carry the symbol names
    that the JVM would be looking for when loading the corresponding C function for
    a native method. We have modified the preceding header file and used macros to
    make it compact in order to have all the function declarations in a smaller area.
    You can see it in *Code Box 21-14*:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的头文件中声明的函数携带了 JVM 在加载对应于本地方法的 C 函数时将寻找的符号名称。我们已经修改了前面的头文件，并使用宏使其紧凑，以便在更小的区域内放置所有函数声明。你可以在
    *Code Box 21-14* 中看到它：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Code Box 21-14 [java/native/NativeStack.h]: The modified version of the generated
    JNI header file'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 21-14 [java/native/NativeStack.h]：生成的 JNI 头文件的修改版本
- en: As you see, we have created a new macro `JNI_FUNC` that factors out a big portion
    of the function name that is common for all of the declarations. We have also
    removed the comments in order to make the header file even more compact.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们创建了一个新的宏 `JNI_FUNC`，它提取了所有声明中通用的函数名的大部分。我们还移除了注释，以便使头文件更加紧凑。
- en: We will be using the macro `JNI_FUNC` in both the header file and the following
    source file, which are shown as part of *Code Box 21-15*.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在头文件和随后的源文件中使用宏 `JNI_FUNC`，这些文件作为 *Code Box 21-15* 的一部分展示。
- en: '**Note**:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: It is not an accepted behavior to modify the generated header file. We did it
    because of educational purposes. In real build environments, it is desired to
    use the generated files directly without any modification.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 修改生成的头文件不是一个被接受的行为。我们这样做是因为教育目的。在真实的构建环境中，我们希望直接使用生成的文件，而不做任何修改。
- en: 'In *Code Box 21-15*, you will find the definitions of the preceding functions.
    As you see, the definitions only relay the calls to the underlying C functions
    included from the C stack library:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Code Box 21-15* 中，你可以找到前面函数的定义。正如你所见，定义仅将调用传递给从 C 栈库包含的底层 C 函数：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Code Box 21-15 [java/native/NativeStack.cpp]: The definitions of the functions
    declared in the JNI header file'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 21-15 [java/native/NativeStack.cpp]：JNI 头文件中声明的函数的定义
- en: The preceding code is written in C++. It is possible to write the definitions
    in C as well. The only thing demanding attention is the conversion from C byte
    arrays into Java byte arrays happening in push and pop functions. The function
    `extractFromJByteArray` has been added to create a C byte array based on a Java
    byte array received from the Java part.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码是用 C++ 编写的。也可以用 C 语言编写定义。唯一需要关注的是在 push 和 pop 函数中发生的从 C 字节数组到 Java 字节数组的转换。已经添加了
    `extractFromJByteArray` 函数，用于根据从 Java 部分接收到的 Java 字节数组创建一个 C 字节数组。
- en: 'The following commands create the intermediate shared object `libNativeStack.so`
    in Linux, which is going to be loaded and used by the JVM. Note that you need
    to set the environment variable `JAVA_HOME` before running the following commands:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令在 Linux 中创建中间共享对象 `libNativeStack.so`，它将被 JVM 加载和使用。注意，在运行以下命令之前，您需要设置环境变量
    `JAVA_HOME`：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Shell Box 21-12: Building the intermediate shared object library libNativeStack.so'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 'Shell Box 21-12: 构建中间共享对象库 libNativeStack.so'
- en: As you see, the final shared object file is linked against the C stack library's
    shared object file `libcstack.so` which simply means the `libNativeStack.so` has
    to load `libcstack.so` in order to work. Therefore, the JVM loads the `libNativeStack.so`
    library and then it loads `libcstack.so` library, and eventually the Java part
    and the native part can cooperate and let the Java program be executed.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，最终的共享对象文件链接到 C 堆栈库的共享对象文件 `libcstack.so`，这仅仅意味着 `libNativeStack.so` 必须加载
    `libcstack.so` 才能工作。因此，JVM 加载 `libNativeStack.so` 库，然后加载 `libcstack.so` 库，最终 Java
    部分和本地部分可以合作，使 Java 程序得以执行。
- en: 'The following commands run the test scenario shown in *Code Box 21-12*:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令运行 *代码框 21-12* 中显示的测试场景：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Shell Box 21-13: Running the Java test scenario'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 'Shell Box 21-13: 运行 Java 测试场景'
- en: As you see, we have passed the option `-Djava.library.path=...` to the JVM.
    It specifies the place where shared object libraries can be found. As you see,
    we have specified the directory which should contain the `libNativeStack.so` shared
    object library.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已将选项 `-Djava.library.path=...` 传递给 JVM。它指定了共享对象库可以找到的位置。如您所见，我们已指定应包含
    `libNativeStack.so` 共享对象库的目录。
- en: In this section, we showed how to load a native C library into the JVM and use
    it together with other Java source code. The same mechanism can be applied for
    loading bigger and multi-part native libraries.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们展示了如何将本地 C 库加载到 JVM 中，并与其他 Java 源代码一起使用。相同的机制也可以用于加载更大的多部分本地库。
- en: Now, it's time to go through the Python integration and see how the C stack
    library can be used from Python code.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候通过 Python 集成来了解如何从 Python 代码中使用 C 堆栈库了。
- en: Integration with Python
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 Python 集成
- en: Python is an *interpreted* programming language. This means that the Python
    code is read and run by an intermediate program that is called an *interpreter*.
    If we are going to use an external native shared library, it is the interpreter
    that loads the shared library and makes it available to the Python code. Python
    has a special framework for loading external shared libraries. It is called *ctypes*
    and we are going to use it in this section.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种 *解释型* 编程语言。这意味着 Python 代码是由一个称为 *解释器* 的中间程序读取和运行的。如果我们打算使用外部本地共享库，那么是解释器加载共享库并将其提供给
    Python 代码。Python 有一个用于加载外部共享库的特殊框架。它被称为 *ctypes*，我们将在本节中使用它。
- en: 'Loading the shared libraries using `ctypes` is very straightforward. It only
    requires loading the library and defining the inputs and output of the functions
    that are going to be used. The following class wraps the ctypes-related logic
    and makes it available to our main `Stack` class, shown in the upcoming code boxes:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ctypes` 加载共享库非常简单。它只需要加载库并定义将要使用的函数的输入和输出。以下类封装了 ctypes 相关逻辑，并将其提供给我们的主
    `Stack` 类，如即将显示的代码框所示：
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Code Box 21-17 [python/stack.py]: The ctypes-related code that makes the stack
    library''s C functions available to the rest of Python'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 21-17 [python/stack.py]: 使堆栈库的 C 函数对 Python 的其余部分可用的 ctypes 相关代码'
- en: As you can see, all the functions required to be used in our Python code are
    put in the class definition. The handles to the C functions are stored as private
    fields in the class instance (private fields have `_` on both sides) and they
    can be used to call the underlying C function. Note that in the above code, we
    have loaded the `libcstack.dylib`, as we are in a macOS system. And for Linux
    systems, we need to load `libcstack.so`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，所有需要在我们的 Python 代码中使用的函数都被放在了类定义中。C 函数的句柄存储在类的实例的私有字段中（私有字段在两边都有 `_`），并且可以用来调用底层的
    C 函数。请注意，在上面的代码中，我们加载了 `libcstack.dylib`，因为我们是在 macOS 系统上。而对于 Linux 系统，我们需要加载
    `libcstack.so`。
- en: 'The following class is the main Python component that uses the above wrapper
    class. All other Python code uses this class to have the stack functionality:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的类是主要的 Python 组件，它使用了上面的包装类。所有其他的 Python 代码都使用这个类来获得栈功能：
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Code Box 21-16 [python/stack.py]: The Stack class in Python that uses the loaded
    C functions from the stack library'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 21-16 [python/stack.py]：使用从栈库加载的 C 函数的 Python 中的 `Stack` 类
- en: As you see, the Stack class keeps a reference to the `_NativeStack` class in
    order to be able to call the underlying C functions. Note that the preceding class
    overrides `__enter__` and `__exit__` functions. This allows the class to be used
    as a resource class and be consumed in the `with` syntax in Python. You will see
    shortly what the syntax looks like. Please note that the preceding Stack class
    only operates on string items.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`Stack` 类保持对 `_NativeStack` 类的引用，以便能够调用底层的 C 函数。请注意，前面的类覆盖了 `__enter__`
    和 `__exit__` 函数。这使得该类可以用作资源类，并在 Python 的 `with` 语法中使用。你很快就会看到这种语法的样子。请注意，前面的 `Stack`
    类仅对字符串项进行操作。
- en: 'The following is the test scenario, which is very similar to the Java and C++
    test scenarios:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个测试场景，它与 Java 和 C++ 的测试场景非常相似：
- en: '[PRE30]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Code Box 21-18 [python/stack.py]: The test scenario written in Python and using
    the Stack class'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 21-18 [python/stack.py]：使用 `Stack` 类编写的 Python 测试场景
- en: In the preceding code, you can see Python's `with` statement.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你可以看到 Python 的 `with` 语句。
- en: Upon entering the `with` block, the `__enter__` function is called and an instance
    of the `Stack` class is referenced by the `stack` variable. When leaving the `with`
    block, the `__exit__` function is called. This gives us the opportunity to free
    the underlying native resources, the C stack object in this case, when they are
    not needed anymore.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当进入 `with` 块时，会调用 `__enter__` 函数，并通过 `stack` 变量引用 `Stack` 类的实例。当离开 `with` 块时，会调用
    `__exit__` 函数。这给了我们机会在不需要底层原生资源（在这种情况下是 C 栈对象）时释放它们。
- en: 'Next, you can see how to run the preceding code. Note that all the Python code
    boxes exist within the same file named `stack.py`. Before running the following
    commands, you need to be in the chapter''s root directory:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以看到如何运行前面的代码。请注意，所有的 Python 代码框都存在于同一个名为 `stack.py` 的文件中。在运行以下命令之前，你需要位于章节的根目录中：
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Shell Box 21-14: Running the Python test scenario'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 21-14：运行 Python 测试场景
- en: Note that the interpreter should be able to find and load the C stack shared
    library; therefore, we set the `LD_LIBRARY_PATH` environment variable to point
    to the directory that contains the actual shared library file.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，解释器应该能够找到并加载 C 栈共享库；因此，我们将 `LD_LIBRARY_PATH` 环境变量设置为指向包含实际共享库文件的目录。
- en: In the following section, we show how to load and use the C stack library in
    the Go language.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将展示如何在 Go 语言中加载和使用 C 栈库。
- en: Integration with Go
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 Go 的集成
- en: The Go programming language (or simply Golang) has an easy integration with
    native shared libraries. It can be considered as the next generation of the C
    and C++ programming languages and it calls itself a system programming language.
    Therefore, we expect to load and use the native libraries easily when using Golang.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Go 编程语言（或简称 Golang）与本地共享库的集成非常容易。它可以被认为是 C 和 C++ 编程语言的下一代，并且它将自己称为系统编程语言。因此，当我们使用
    Golang 时，我们期望能够轻松地加载和使用本地库。
- en: 'In Golang, we use a built-in package called *cgo* to call C code and load the
    shared object files. In the following Go code, you see how to use the `cgo` package
    and use it to call the C functions loaded from the C stack library file. It also
    defines a new class, `Stack`, which is used by other Go code to use the C stack
    functionalities:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Golang 中，我们使用一个名为 *cgo* 的内置包来调用 C 代码和加载共享对象文件。在下面的 Go 代码中，你可以看到如何使用 `cgo`
    包，并使用它来调用从 C 栈库文件加载的 C 函数。它还定义了一个新的类，`Stack`，该类被其他 Go 代码用来使用 C 栈功能：
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Code Box 21-19 [go/stack.go]: The Stack class using the loaded libcstack.so
    shared object file'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 21-19 [go/stack.go]：使用加载的libcstack.so共享对象文件的Stack类
- en: 'In order to use the cgo package, one needs to import the `C` package. It loads
    the shared object libraries specified in the pseudo `#cgo` directives. As you
    see, we have specified the `libcstack.so` library to be loaded as part of the
    directive `#cgo LDFLAGS: -L.. -lcstack`. Note that the `CFLAGS` and `LDFLAGS`
    contain the flags that are directly passed to the C compiler and to the linker
    respectively.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '为了使用cgo包，需要导入`C`包。它加载在伪`#cgo`指令中指定的共享对象库。正如你所看到的，我们指定了`libcstack.so`库作为指令`#cgo
    LDFLAGS: -L.. -lcstack`的一部分。请注意，`CFLAGS`和`LDFLAGS`包含直接传递给C编译器和链接器的标志。'
- en: We have also indicated the path that should be searched for the shared object
    file. After that, we can use the `C` struct to call the loaded native functions.
    For example, we have used `C.cstack_new()` to call the corresponding function
    from the stack library. It is pretty easy with cgo. Note that the preceding `Stack`
    class only works on string items.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还指出了应该搜索共享对象文件的路径。之后，我们可以使用`C`结构体来调用加载的本地函数。例如，我们使用了`C.cstack_new()`来调用栈库中的相应函数。使用cgo非常简单。请注意，前面的`Stack`类仅适用于字符串项。
- en: 'The following code shows the test scenario written in Golang. Note that we
    have to call the `Destroy` function on the `stack` object when quitting the `main`
    function:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了用Golang编写的测试场景。请注意，当退出`main`函数时，我们必须在`stack`对象上调用`Destroy`函数：
- en: '[PRE33]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Code Box 21-20 [go/stack.go]: The test scenario written in Go and using the
    Stack class'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 21-20 [go/stack.go]：使用Stack类的Go测试场景
- en: 'The following shell box demonstrates how to build and run the test scenario:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下shell box演示了如何构建和运行测试场景：
- en: '[PRE34]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Shell Box 21-15: Running the Go test scenario'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 21-15：运行Go测试场景
- en: As you see in Golang, unlike Python, you need to compile your program first,
    and then run it. In addition, we still need to set the `LD_LIBRARY_PATH` environment
    variable in order to allow the executable to locate the `libcstack.so` library
    and load it.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在Golang中看到的，与Python不同，你需要首先编译你的程序，然后运行它。此外，我们仍然需要设置`LD_LIBRARY_PATH`环境变量，以便允许可执行文件定位`libcstack.so`库并将其加载。
- en: In this section, we showed how to use the `cgo` package in Golang to load and
    use shared object libraries. Since Golang behaves like a thin wrapper around C
    code, it has been easier than using Python and Java to load an external shared
    object library and use it.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们展示了如何使用Golang中的`cgo`包加载和使用共享对象库。由于Golang类似于C代码的薄包装器，因此它比使用Python和Java加载外部共享对象库并使用它更容易。
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we went through the integration of C within other programming
    languages. As part of this chapter:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了C语言与其他编程语言的集成。作为本章的一部分：
- en: We designed a C library that was exposing some stack functionality such as push,
    pop, and so on. We built the library and as the final output we generated a shared
    object library to be used by other languages.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们设计了一个C库，该库暴露了一些栈功能，例如push、pop等。我们构建了库，并最终生成了一个共享对象库，供其他语言使用。
- en: We discussed the name mangling feature in C++, and how we should avoid it in
    C when using a C++ compiler.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了C++中的名称混淆功能，以及我们在使用C++编译器时应该如何避免在C中使用它。
- en: We wrote a C++ wrapper around the stack library that could load the library's
    shared object file and execute the loaded functionalities within C++.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们编写了一个围绕栈库的C++包装器，该包装器可以加载库的共享对象文件并在C++中执行加载的功能。
- en: We continued by writing a JNI wrapper around the C library. We used native methods
    to achieve that.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们继续编写了一个围绕C库的JNI包装器。我们使用了本地方法来实现这一点。
- en: We showed how to write native code in JNI and connect the native part and Java
    part together, and finally run a Java program that uses the C stack library.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们展示了如何使用JNI编写本地代码，并将本地部分和Java部分连接起来，最终运行一个使用C栈库的Java程序。
- en: We managed to write Python code that was using the ctypes package to load and
    use the library's shared object file.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们成功地编写了使用ctypes包加载和使用库的共享对象文件的Python代码。
- en: As the final section, we wrote a program in Golang that could load the library's
    shared object file with help from the `cgo` package.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为最后一部分，我们用Golang编写了一个程序，该程序可以在`cgo`包的帮助下加载库的共享对象文件。
- en: The next chapter is about unit testing and debugging in C. We will introduce
    some C libraries meant for writing unit tests. More than that, we talk about debugging
    in C, and some of the existing tools that could be used to debug or monitor a
    program.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍 C 语言中的单元测试和调试。我们将介绍一些用于编写单元测试的 C 语言库。不仅如此，我们还将讨论 C 语言的调试，以及一些可用于调试或监控程序的现有工具。
