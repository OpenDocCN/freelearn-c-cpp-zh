- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: The Async Function
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步函数
- en: In the previous chapter, we learned about promises, futures, and packaged tasks.
    When we introduced packaged tasks, we mentioned that **std::async** provides a
    simpler way to achieve the same result, with less code and thus being cleaner
    and more concise.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了关于承诺、未来和封装任务的内容。当我们介绍封装任务时，我们提到 **std::async** 提供了一种更简单的方法来实现相同的结果，代码更少，因此更简洁。
- en: The **async function** ( **std::async** ) is a function template that runs a
    callable object asynchronously where we can also select the method of execution
    by passing some flags defining the launch policy. It is a powerful tool for handling
    asynchronous operations, but its automatic management and lack of control over
    the thread of execution, among other aspects, can also make it unsuitable for
    certain tasks where fine-grained control or cancellation is required.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步函数**（**std::async**）是一个函数模板，它异步运行可调用对象，我们还可以通过传递定义启动策略的标志来选择执行方法。它是处理异步操作的有力工具，但它的自动管理和对执行线程缺乏控制，以及其他方面，也可能使其不适合需要精细控制或取消的任务。'
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: What is the async function and how do we use it?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步函数是什么，以及我们如何使用它？
- en: What are the different launch policies?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有哪些不同的启动策略？
- en: What are the differences from previous methods, especially packaged tasks?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与之前的方法相比，有哪些不同，尤其是封装任务？
- en: What are the advantages and disadvantages of using **std::async** ?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **std::async** 的优缺点是什么？
- en: Practical scenarios and examples
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际场景和示例
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The async function has been available since C++11, but some examples use features
    from C++14, such as **chrono_literals** , and C++20, such as **counting_semaphore**
    , so the code shown in this chapter can be compiled by compilers supporting C++20.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 异步函数自 C++11 以来一直可用，但一些示例使用了 C++14 的功能，例如 **chrono_literals**，以及 C++20 的功能，例如
    **counting_semaphore**，因此本章中显示的代码可以由支持 C++20 的编译器编译。
- en: Please check the *Technical requirements* section in [*Chapter 3*](B22219_03.xhtml#_idTextAnchor051)
    , for guidance on how to install GCC 13 and Clang 8 compilers.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 请查阅 [*第3章*](B22219_03.xhtml#_idTextAnchor051) 中的 *技术要求* 部分，以获取如何安装 GCC 13 和
    Clang 8 编译器的指导。
- en: 'You can find all the complete code in the following GitHub repository:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下 GitHub 仓库中找到所有完整的代码：
- en: '[https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP](https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP](https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP)'
- en: 'The examples for this chapter are located under the **Chapter_07** folder.
    All source code files can be compiled using CMake as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例位于 **Chapter_07** 文件夹下。所有源代码文件都可以使用 CMake 编译，如下所示：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Executable binaries will be generated under the **bin** directory.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行二进制文件将在 **bin** 目录下生成。
- en: What is std::async?
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::async 是什么？
- en: '**std::async** is a function template in C++ introduced by the C++ standard
    in the **<future>** header as part of the thread support library from C++11. It
    is used to run a function asynchronously, allowing the main thread (or other threads)
    to continue running concurrently.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**std::async** 是 C++ 中由 C++ 标准在 **<future>** 头文件中引入的函数模板，作为 C++11 的线程支持库的一部分。它用于异步运行函数，允许主线程（或其他线程）继续并发运行。'
- en: In summary, **std::async** is a powerful tool for asynchronous programming in
    C++, making it easier to run tasks in parallel and manage their results efficiently.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，**std::async** 是 C++ 中异步编程的强大工具，使并行运行任务和管理其结果更加高效。
- en: Launching an asynchronous task
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动异步任务
- en: To execute a function asynchronously using **std::async** , we can use the same
    approaches we used when starting threads in [*Chapter 3*](B22219_03.xhtml#_idTextAnchor051)
    , with the different callable objects.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 **std::async** 异步执行函数，我们可以使用与在 [*第3章*](B22219_03.xhtml#_idTextAnchor051)
    中启动线程时相同的方法，但使用不同的可调用对象。
- en: 'One approach is using a function pointer:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是使用函数指针：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Another approach is using a lambda function:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用 lambda 函数：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can also use an embedded lambda function:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用内嵌的 lambda 函数：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can use a function object where **operator()** is overloaded:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个重载了 **operator()** 的函数对象：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can use a non-static member function by passing the address of the member
    function and the address of an object to call the member function:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过传递成员函数的地址和对象的地址来调用成员函数的非静态成员函数：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can also use a static member function where only the address of the member
    function is needed as the method is static:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用静态成员函数，其中只需要成员函数的地址，因为方法是静态的：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When **std::async** is called, it returns a future where the result of the function
    will be stored, as we already learned in the previous chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用**std::async**时，它返回一个future，其中将存储函数的结果，正如我们在上一章所学到的。
- en: Passing values
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递值
- en: Again, similarly to when we passed arguments when creating threads, arguments
    can be passed to the thread by value, by reference, or as pointers.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，类似于我们在创建线程时传递参数的方式，参数可以通过值、引用或指针传递给线程。
- en: 'Here, we can see how to pass arguments by value:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们可以看到如何通过值传递参数：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Passing by value implies a copy as a temporary object is created and the argument
    value is copied into it. This avoids data races, but it is much more costly.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过值传递意味着创建一个临时对象并复制参数值到其中。这避免了数据竞争，但成本较高。
- en: 'The next example shows how to pass values by reference:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子展示了如何通过引用传递值：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can also pass values as a **const reference** :'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将值作为**const引用**传递：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Passing by reference is achieved by using **std::ref()** (non-constant references)
    or **std::cref()** (constant references), both defined in the **<functional>**
    header file, letting the variadic template (a class or function template that
    supports an arbitrary number of arguments) defining the thread constructor to
    treat the argument as a reference. Missing these functions when passing arguments
    means passing the arguments by value, which implies a copy, as mentioned earlier,
    making the function call more costly.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引用传递是通过使用**std::ref()**（非常量引用）或**std::cref()**（常量引用）实现的，这两个都在**<functional>**头文件中定义，让定义线程构造函数的变长模板（一个支持任意数量参数的类或函数模板）将参数作为引用处理。在传递参数时缺少这些函数意味着通过值传递参数，如前所述，这会使函数调用成本更高。
- en: 'You can also move an object into the thread created by **std::async** , as
    follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将对象移动到由**std::async**创建的线程中，如下所示：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that the vector **v** is in a valid but empty state after its content being
    moved.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在内容被移动后，向量**v**处于一个有效但为空的状态。
- en: 'Finally, we can also pass values by lambda captures:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还可以通过lambda捕获传递值：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, the **str** variable is accessed by the lambda function executed
    by **std::async** as a reference.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，**str**变量被**std::async**执行的lambda函数通过引用访问。
- en: Returning values
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回值
- en: When **std:async** is called, it immediately returns a future that will hold
    the value that the function or callable object will compute, as we saw in the
    previous chapter when using promises and futures.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用**std:async**时，它立即返回一个future，该future将包含函数或可调用对象将计算出的值，正如我们在上一章使用promises和futures时所见。
- en: 'In the previous examples, we didn´t use the returned object from **std::async**
    at all. Let’s rewrite the last example from the *Packaged tasks* section in [*Chapter
    6*](B22219_06.xhtml#_idTextAnchor125) , where we used a **std::packaged_task**
    object to compute the power of two values. But in this case, we will spawn several
    asynchronous tasks using **std::async** to compute these values, wait for the
    tasks to finish, store the results, and finally, show them in the console:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们没有使用**std::async**返回的对象。让我们重写*包装任务*部分中的最后一个例子，在[*第6章*](B22219_06.xhtml#_idTextAnchor125)中，我们使用了一个**std::packaged_task**对象来计算两个值的幂。但在这个例子中，我们将使用**std::async**来生成几个异步任务来计算这些值，等待任务完成，存储结果，并最终在控制台显示它们：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The **compute()** function simply gets two numbers, **x** and **y** , and computes
    ![<mml:math  ><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>y</mml:mi></mml:mrow></mml:msup></mml:math>](img/5.png)
    . It also gets a number representing the task identifier and waits for up to two
    seconds before printing a message in the console and computing the result.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**compute()**函数简单地获取两个数字，**x**和**y**，并计算![<mml:math  ><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>y</mml:mi></mml:mrow></mml:msup></mml:math>](img/5.png)
    . 它还获取一个表示任务标识符的数字，并在控制台打印消息并计算结果之前等待最多两秒钟。'
- en: In the **main()** function, the main thread launches several tasks computing
    a sequence of power-of-two values. The futures returned by calling **std::async**
    are stored in the **futVec** vector. Then, the main thread waits for one second,
    emulating some work. Finally, we traverse the **futVec** vector and call the **get()**
    function in each future element, thus waiting for that specific task to finish
    and return a value, and we store the returned value in another vector called **results**
    . Then, we print the content of the **results** vector before exiting the program.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **main()** 函数中，主线程启动了几个计算2的幂次序列值的任务。通过调用 **std::async** 返回的未来存储在 **futVec**
    向量中。然后，主线程等待一秒钟，模拟一些工作。最后，我们遍历 **futVec** 向量，并在每个未来元素中调用 **get()** 函数，从而等待该特定任务完成并返回一个值，我们将返回的值存储在另一个名为
    **results** 的向量中。然后，在退出程序之前，我们打印 **results** 向量的内容。
- en: 'This is the output when running that program:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行该程序时的输出：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As we can see, each task took a different amount of time to complete, thus the
    output is not ordered by task identifier. But as we traverse the **futVec** vector
    in order when getting the results, these are shown as in order.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，每个任务完成所需的时间不同，因此输出不是按任务标识符排序的。但是，当我们按顺序遍历在获取结果时 **futVec** 向量，这些结果被显示为有序。
- en: Now that we have seen how to launch asynchronous tasks and pass arguments and
    return values, let’s learn how to use launch policies to control the methods of
    execution.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何启动异步任务并传递参数和返回值，让我们学习如何使用启动策略来控制执行方法。
- en: Launch policies
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动策略
- en: Apart from specifying the function or callable object as an argument when using
    the **std::async** function, we can also specify the **launch policy** . Launch
    policies control how **std::async** schedules the execution of asynchronous task.
    These are defined in the **<** **future>** library.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在调用 **std::async** 函数时将函数或可调用对象作为参数外，我们还可以指定 **launch policy**。启动策略控制 **std::async**
    如何调度异步任务的执行。这些定义在 **<future>** 库中。
- en: 'The launch policy must be specified as the first argument when calling **std::async**
    . This argument is of the type **std::launch** , a bitmask value where its bits
    control the allowed methods of execution, which can be one or more of the following
    enumeration constants:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 **std::async** 时，必须将启动策略指定为第一个参数。此参数的类型为 **std::launch**，它是一个位掩码值，其中其位控制允许的执行方法，可以是以下枚举常量之一：
- en: '**std::launch::async** : The task is executed in a separate thread.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**std::launch::async**：任务将在一个单独的线程中执行。'
- en: '**std::launch::deferred** : Enables lazy evaluation by executing the task in
    the calling thread the first time its result is requested via the future **get()**
    or **wait()** method. All further accesses to the same **std::future** will return
    the result immediately. That means that the task will only be executed when the
    result is explicitly requested, which can lead to unexpected delays.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**std::launch::deferred**：通过在第一次通过未来 **get()** 或 **wait()** 方法请求结果时在调用线程中执行任务，启用延迟评估。所有对同一
    **std::future** 的进一步访问都将立即返回结果。这意味着任务只有在显式请求结果时才会执行，这可能导致意外的延迟。'
- en: If not defined, by default the launch policy will be **std::launch::async |
    std::launch::deferred** . Also, implementations can provide additional launch
    policies.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未定义，默认的启动策略将是 **std::launch::async | std::launch::deferred**。此外，实现可以提供额外的启动策略。
- en: Therefore, by default the C++ standard states that **std::async** can run in
    either asynchronous or deferred mode.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，默认情况下，C++标准声明 **std::async** 可以在异步或延迟模式下运行。
- en: Note that when more than one flag is specified, the behavior is implementation-defined,
    so depending on the compiler we are using. The standard recommends using available
    concurrency and deferring the task if the default launch policy is specified.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当指定多个标志时，行为是实现定义的，因此取决于我们使用的编译器。标准建议使用可用的并发性和在指定默认启动策略时延迟任务。
- en: 'Let’s implement the following example to test the different launch policy behaviors.
    First, we define the **square()** function, which will serve as the asynchronous
    task:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现以下示例来测试不同的启动策略行为。首先，我们定义 **square()** 函数，它将作为异步任务：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, in the **main()** function, the program starts by launching three different
    asynchronous tasks, one using the **std::launch::async** launch policy, another
    task using the **std::launch::deferred** launch policy, and a third task using
    the default launch policy:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在**main()**函数中，程序首先启动三个不同的异步任务，一个使用**std::launch::async**启动策略，另一个任务使用**std::launch::deferred**启动策略，第三个任务使用默认启动策略：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As mentioned in the previous chapter, **wait_for()** returns a **std::future_status**
    object indicating whether the future is ready, deferred, or has timed out. Therefore,
    we can use that function to check whether any of the returned futures are deferred.
    We do that by using a lambda function, **is_deferred()** , that returns **true**
    in that case. At least one future object, **fut_deferred** , is expected to return
    **true** :'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，**wait_for()**返回一个**std::future_status**对象，指示未来是否就绪、延迟还是超时。因此，我们可以使用该函数来检查返回的任何未来对象是否延迟。我们通过使用返回**true**的lambda函数**is_deferred()**来实现这一点。至少有一个未来对象**fut_deferred**预期会返回**true**：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, the main program waits for one second, emulating some processing, and
    finally retrieves the results from the asynchronous tasks and prints their value:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，主程序等待一秒钟，模拟一些处理，最后从异步任务中检索结果并打印它们的值：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is the output from running the preceding code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行前面代码的输出：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note how the tasks with the default and **std::launch::async** launch policies
    are executed while the main thread is sleeping. Therefore, the task is started
    as soon as it can be scheduled. Also note how the deferred task, using the **std::launch::deferred**
    launch policy, starts executing once the value is requested.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，具有默认和**std::launch::async**启动策略的任务在主线程睡眠时执行。因此，任务一旦可以调度就会立即启动。同时注意，使用**std::launch::deferred**启动策略的延迟任务在请求值时开始执行。
- en: Next, let’s learn how to handle exceptions happening in the asynchronous task.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们学习如何处理异步任务中发生的异常。
- en: Handling exceptions
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理异常
- en: Exception propagation from the asynchronous task to the main thread is not supported
    when using **std::async** . To enable exception propagation, we might need a promise
    object to store the exception that later can be accessed by the future returned
    when calling **std::async** . But that promise object is not accessible or provided
    by **std::async** .
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用**std::async**时，不支持从异步任务到主线程的异常传播。为了启用异常传播，我们可能需要一个承诺对象来存储异常，稍后可以通过调用**std::async**时返回的未来来访问该异常。但该承诺对象不是由**std::async**提供的或可访问的。
- en: One feasible way to achieve this is to use a **std::packaged_task** object wrapping
    the asynchronous task. But if that is the case, we should directly use a packaged
    task as described in the previous chapter.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的可行方法之一是使用一个包装异步任务的**std::packaged_task**对象。但如果那样做，我们应该直接使用前一章中描述的包装任务。
- en: We could also use nested exceptions, available since C++11, by using **std::nested_exception**
    , a polymorphic mixin class that can capture and store the current exception,
    allowing nested exceptions of arbitrary types. From a **std::nested_exception**
    object, we can retrieve the stored exception by using the **nested_ptr()** method
    or rethrow it by calling **rethrow_nested()** .
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用自C++11以来可用的嵌套异常，通过使用**std::nested_exception**，这是一个可以捕获和存储当前异常的多态混合类，允许任意类型的嵌套异常。从**std::nested_exception**对象中，我们可以使用**nested_ptr()**方法检索存储的异常或通过调用**rethrow_nested()**重新抛出它。
- en: To create a nested exception, we can throw an exception using the **std::throw_with_nested()**
    method. If we want to rethrow an exception only if it’s nested, we can use **std::rethrow_if_nested()**
    . All these functions are defined in the **<** **exception>** header.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个嵌套异常，我们可以使用**std::throw_with_nested()**方法抛出异常。如果我们只想在异常嵌套的情况下重新抛出异常，我们可以使用**std::rethrow_if_nested()**。所有这些函数都在**<exception>**头文件中定义。
- en: 'Using all these functions, we can implement the following example, where an
    asynchronous task throws a **std::runtime_error** exception, which is caught in
    the main body of the asynchronous task and rethrown as a nested exception. This
    nested exception object is then caught again in the main function and the sequence
    of exceptions is printed out, as shown in the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用所有这些函数，我们可以实现以下示例，其中异步任务抛出一个**std::runtime_error**异常，该异常在异步任务的主体中被捕获并作为嵌套异常重新抛出。然后，在主函数中再次捕获该嵌套异常对象，并打印出异常序列，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As we can see in the example, an asynchronous task is created that executes
    the **func_throwing()** function inside a **try-catch** block. This function simply
    throws a **std::runtime_error** exception, which is caught and then rethrown as
    part of a **std::nested_exception** class by using the **std::throw_with_nested()**
    function. Later, in the main thread, when we try to retrieve the result from the
    **fut** future object by calling its **get()** method, the nested exception is
    thrown and captured again in the main try-catch block, where the **print_exceptions()**
    function is called with the captured nested exception as an argument.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，创建了一个异步任务，该任务在**try-catch**块中执行**func_throwing()**函数。这个函数简单地抛出一个**std::runtime_error**异常，该异常被捕获，然后通过使用**std::throw_with_nested()**函数作为**std::nested_exception**类的一部分重新抛出。稍后，在主线程中，当我们尝试通过调用其**get()**方法从**fut**未来对象检索结果时，嵌套异常被抛出并再次在主**try-catch**块中捕获，其中调用**print_exceptions()**函数，并将捕获的嵌套异常作为参数。
- en: The **print_exceptions()** function prints the reason for the current exception
    ( **e.what()** ) and rethrows the exception if nested, thus catching it again
    and recursively printing exception reasons with indentation by nesting level.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**print_exceptions()**函数打印当前异常的原因（**e.what()**），如果异常嵌套，则重新抛出异常，从而再次捕获它并以缩进的形式递归打印异常原因。'
- en: As each asynchronous task has its own future, the program can handle exceptions
    from multiple tasks separately.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个异步任务都有自己的未来对象，程序可以单独处理多个任务的异常。
- en: Exceptions when calling std::async
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用std::async时的异常
- en: 'Apart from exceptions happening in the asynchronous task, there are also some
    cases when **std::async** might throw an exception. These exceptions are as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 除了异步任务中发生的异常之外，还有**std::async**可能会抛出异常的情况。这些异常如下：
- en: '**std::bad_alloc** : If there is not enough memory to store internal data structures
    needed by **std::async** .'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**std::bad_alloc**：如果存储**std::async**所需内部数据结构的内存不足。'
- en: '**std:system_error** : If a new thread cannot be started when using **std::launch::async**
    as the launch policy. In this case, the error condition will be **std::errc::resource_unavailable_try_again**
    . Depending on the implementation, if the policy is the default one, it might
    fall back to deferred invocation or implementation-defined policies.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**std::system_error**：当使用**std::launch::async**作为启动策略时，无法启动新线程。在这种情况下，错误条件将是**std::errc::resource_unavailable_try_again**。根据实现，如果策略是默认的，它可能会回退到延迟调用或实现定义的策略。'
- en: Most of the time, these exceptions are thrown out due to resource exhaustion.
    A solution can be retrying later when some asynchronous tasks currently working
    have finished and released their resources. Another, more reliable, solution is
    to limit the number of asynchronous tasks running at a given time. We will implement
    this solution shortly, but first, let’s understand the futures returned by **std::async**
    and how to achieve better performance when dealing with them.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，这些异常是由于资源耗尽而抛出的。一种解决方案是在一些异步任务当前正在运行并释放其资源后稍后重试。另一种更可靠的解决方案是限制给定时间内运行的异步任务数量。我们将很快实现这个解决方案，但首先，让我们了解**std::async**返回的未来对象以及如何在使用它们时实现更好的性能。
- en: Async futures and performance
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步未来与性能
- en: Futures returned by **std::async** behave differently from the ones obtained
    from promises when their destructors are called. When these futures are destroyed,
    their **~future** destructor is called where the **wait()** function is executed,
    causing the thread that was spawned at creation to join.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用其析构函数时，**std::async**返回的未来对象的行为与从承诺中获得的行为不同。当这些未来对象被销毁时，它们的**~future**析构函数被调用，其中执行**wait()**函数，导致在创建时产生的线程加入。
- en: That would impact the program performance by adding some overhead if the thread
    used by **std::async** has not already been joined, therefore we need to understand
    when the future object will go out of scope and thus its destructor will be called.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果**std::async**使用的线程尚未加入，这将通过添加一些开销影响程序性能，因此我们需要了解未来对象何时将超出作用域，从而其析构函数将被调用。
- en: Let’s see, with several short examples, how these futures behave and some recommendations
    on how to use them.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过几个简短的示例来看看这些未来对象的行为，以及一些关于如何使用它们的建议。
- en: 'We start by defining a task, **func** , that simply multiplies its input value
    by 2 and also waits for some time, emulating a costly operation:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个任务**func**，该任务简单地将其输入值乘以2，并等待一段时间，模拟一个昂贵的操作：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To measure the performance of a block of code, we will asynchronously run several
    tasks (in this example, **NUM_TASKS = 32** ) and measure the running time using
    the steady clock from the **<chrono>** library. To do that, we simply record a
    time point representing the current point in time when the task starts by using
    the following command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测量代码块的性能，我们将异步运行几个任务（在这个例子中，**NUM_TASKS = 32**），并使用来自 **<chrono>** 库的稳定时钟来测量运行时间。为此，我们只需使用以下命令记录表示任务开始时当前时间点的时刻：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can define in the **main()** function the following lambda function to be
    called when the task finishes to obtain the duration in milliseconds:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 **main()** 函数中定义以下 lambda 函数，以便在任务完成时调用以获取以毫秒为单位的时间：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With that code in place, we can start measuring different approaches to how
    futures can be used.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置该代码后，我们可以开始测量如何使用未来的不同方法。
- en: 'Let’s start by running several asynchronous tasks but discarding the future
    returned by **std::async** :'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从运行几个异步任务开始，但丢弃由 **std::async** 返回的未来：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The duration of this test is 334 ms on my PC, a Pentium i7 4790K at 4 GHz with
    four cores and eight threads.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试在我的电脑上持续了 334 毫秒，这是一台 4 GHz 的 Pentium i7 4790K，有四个核心和八个线程。
- en: 'For the next test, let’s store the returned future, but don’t wait for the
    result to be ready. Obviously, this is not the right way of using computer power
    by spawning asynchronous tasks as consuming resources and not processing the results,
    but we are doing this for testing and learning purposes:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个测试，让我们存储返回的未来，但不要等待结果准备好。显然，这不是通过产生异步任务来使用计算机功率的正确方式，因为我们消耗资源而不处理结果，但我们这样做是为了测试和学习目的：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this case, the duration is still 334 ms. In both cases, a future is created,
    and when going out of scope at the end of each loop iteration, it must wait for
    the thread spawn by **std::async** to finish and join.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，持续时间仍然是 334 毫秒。在两种情况下，都会创建一个未来，当每个循环迭代的末尾超出作用域时，它必须等待由 **std::async**
    生成的线程完成并加入。
- en: As you can see, we are launching 32 tasks, each one consuming at least 10 ms.
    That totals 320 ms, a value equivalent to 334 ms obtained in these tests. The
    remaining performance cost comes from starting threads, checking the **for** loop
    variable, storing the time points when using the steady clock, and so on.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在启动 32 个任务，每个任务至少消耗 10 毫秒。总共是 320 毫秒，这是一个与这些测试中获得的 334 毫秒等效的值。剩余的性能成本来自启动线程、检查
    **for** 循环变量、使用稳定时钟存储时间点等。
- en: 'To avoid creating a new future object each time **std::async** is called, and
    waiting for its destructor to be called, let’s reuse the future object as shown
    in the following code. Again, this is not the proper way as we are discarding
    access to the results of previous tasks:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免每次调用 **std::async** 时都创建一个新的未来对象，并等待其析构函数被调用，让我们像以下代码所示重用未来对象。同样，这并不是正确的方式，因为我们正在丢弃对先前任务结果的处理：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now the duration is 166 ms. The reductions are due to not waiting for each future,
    as they are not destroyed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的持续时间是 166 毫秒。这种减少是由于我们没有等待每个未来，因为它们没有被销毁。
- en: 'But this is not ideal as we might be interested in knowing the result of the
    asynchronous tasks. Therefore, we need to store the results in a vector. Let’s
    modify the previous example by using the **res** vector to store the results from
    each task:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不理想，因为我们可能对异步任务的结果感兴趣。因此，我们需要将结果存储在一个向量中。让我们通过使用 **res** 向量来存储每个任务的结果来修改之前的示例：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this case, the duration goes back to 334 ms. This is because we are again
    waiting for the results after spawning each task by calling **fut.get()** before
    launching another asynchronous task. We are serializing the tasks’ execution.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，持续时间回到了 334 毫秒。这是因为我们再次在启动另一个异步任务之前通过调用 **fut.get()** 等待结果，我们在序列化任务的执行。
- en: 'A solution could be to store the futures returned by **std::async** in a vector,
    and later traverse that vector and get the results. The following code illustrates
    how to do this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是将 **std::async** 返回的未来存储在一个向量中，然后遍历该向量并获取结果。以下代码说明了如何做到这一点：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now the duration is only 22 ms! But why is that possible?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在持续时间仅为 22 毫秒！但为什么会这样？
- en: Now all tasks are truly running asynchronously. The first loop launches all
    tasks and stores the futures in the **futsVec** vector. There is no longer any
    waiting period due to future destructors being called.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有任务都在真正地异步运行。第一个循环启动所有任务并将未来存储在 **futsVec** 向量中。由于未来析构函数被调用，不再有任何等待期。
- en: The second loop traverses **futsVec** , retrieves each result, and stores them
    in the results vector, **res** . The time to execute the second loop will be approximately
    the time needed to traverse the **res** vector plus the time used by the slowest
    task to be scheduled and executed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个循环遍历**futsVec**，检索每个结果，并将它们存储在结果向量**res**中。执行第二个循环的时间将大约等于遍历**res**向量所需的时间加上调度和执行最慢任务所用的时间。
- en: If the system where the tests were running had enough threads to run all asynchronous
    tasks at once, the runtime could be halved. There are systems that can automatically
    manage several asynchronous tasks under the hood by letting the scheduler decide
    what tasks to run. In other systems, when trying to launch many threads at once,
    they might complain by raising an exception. In the next section, we implement
    a thread limiter by using semaphores.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试运行的系统有足够的线程一次性运行所有异步任务，运行时间可以减半。有些系统可以在底层自动管理多个异步任务，让调度器决定运行哪些任务。在其他系统中，当尝试一次性启动许多线程时，它们可能会通过抛出异常来抱怨。在下一节中，我们将通过使用信号量实现线程限制器。
- en: Limiting the number of threads
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制线程数量
- en: As we saw earlier, if there are not enough threads to run several **std::async**
    calls, a **std::runtime_system** exception can be thrown and indicate resource
    exhaustion.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，如果线程不足以运行多个**std::async**调用，可能会抛出**std::runtime_system**异常，并指示资源耗尽。
- en: We can implement a simple solution by creating a thread limiter using counting
    semaphores ( **std::counting_semaphore** ), a multithreading synchronization mechanism
    explained in [*Chapter 4*](B22219_04.xhtml#_idTextAnchor074) .
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个使用计数信号量（**std::counting_semaphore**）的线程限制器来实现一个简单的解决方案，这是一种在[*第4章*](B22219_04.xhtml#_idTextAnchor074)中解释的多线程同步机制。
- en: The idea is to use a **std::counting_semaphore** object, setting its initial
    value to the maximum concurrent tasks that the system allows, which can be retrieved
    by calling the **std::thread::hardware_concurrency()** function, as learned in
    [*Chapter 2*](B22219_02.xhtml#_idTextAnchor035) , and then use that semaphore
    in the task function to block if the total number of asynchronous tasks exceed
    the maximum concurrent tasks.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是使用一个**std::counting_semaphore**对象，将其初始值设置为系统允许的最大并发任务数，这可以通过调用**std::thread::hardware_concurrency()**函数来检索，正如我们在[*第2章*](B22219_02.xhtml#_idTextAnchor035)中学到的，然后在任务函数中使用该信号量来阻塞，如果总异步任务数超过最大并发任务数。
- en: 'The following snippet implements this idea:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段实现了这个想法：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The program starts by setting the total number of tasks that will be launched.
    Then, it creates a counting semaphore, **sem** , setting its initial value to
    the hardware concurrency value, as explained earlier. Finally, it just launches
    all tasks and waits for their futures to be ready, as usual.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 程序首先设置将要启动的总任务数。然后，它创建一个计数信号量**sem**，将其初始值设置为前面解释的硬件并发值。最后，它只是启动所有任务，并等待它们的未来准备好，就像通常一样。
- en: The key point in this example is that each task, before performing its job,
    acquires the semaphore, thus decrementing the internal counter or blocking until
    the counter can be decremented. When the job is done, the semaphore is released,
    which increments the internal counter and unblocks other tasks that try to acquire
    the semaphore at that time. That means that a task will launch only if there is
    a free hardware thread to be used for that task. Otherwise, it will be blocked
    until another task releases the semaphore.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中的关键点是，每个任务在执行其工作之前，都会获取信号量，从而减少内部计数器或阻塞，直到计数器可以减少。当工作完成时，信号量被释放，这会增加内部计数器并解除其他任务在那时尝试获取信号量的阻塞。这意味着，只有在有可用于该任务的空闲硬件线程时，任务才会启动。否则，它将被阻塞，直到另一个任务释放信号量。
- en: Before exploring some real-life scenarios, let’s first understand some drawbacks
    of using **std::async** .
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索一些实际场景之前，让我们首先了解使用**std::async**的一些缺点。
- en: When not to use std::async
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不使用std::async的情况
- en: As we have seen during this chapter, **std::async** does not provide direct
    control over the number of threads used or access to the thread objects themselves.
    We know now how to limit the number of asynchronous tasks by using counting semaphores,
    but there might be some applications where this is not the optimal solution and
    fine-grained control is required.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中看到的，**std::async**不提供对线程数量的直接控制或对线程对象的直接访问。我们现在知道如何通过使用计数信号量来限制异步任务的数量，但可能有一些应用程序，这种方法不是最佳解决方案，需要更精细的控制。
- en: Also, the automatic management of threads can reduce performance by introducing
    overhead, especially when many small tasks are launched, leading to excessive
    context switching and resource contention.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，线程的自动管理可能会通过引入开销来降低性能，尤其是在启动许多小任务时，会导致过多的上下文切换和资源竞争。
- en: The implementation imposes some limit on the number of concurrent threads that
    can be used, which can degrade performance or even throw exceptions. As **std::async**
    and the available **std::launch** policies are implementation-dependent, the performance
    is not uniform across different compilers and platforms.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 实现对可用的并发线程数施加了一些限制，这可能会降低性能甚至抛出异常。由于 **std::async** 和可用的 **std::launch** 策略是依赖于实现的，因此性能在不同编译器和平台之间并不一致。
- en: Finally, in this chapter, we didn’t mention how to cancel an asynchronous task
    started by **std::async** as there is no standard way of doing so before completion.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在本章中，我们没有提到如何取消由 **std::async** 启动的异步任务，因为在任务完成之前没有标准的方法来做这件事。
- en: Practical examples
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际示例
- en: 'Now it’s time to implement some examples to tackle real-life scenarios using
    **std::async** . We will learn how to do the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候实现一些示例，使用 **std::async** 来解决现实生活中的场景了。我们将学习如何做以下事情：
- en: Perform parallel computation and aggregation
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行并行计算和聚合
- en: Asynchronously search across different containers or a large dataset
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步搜索不同的容器或大型数据集
- en: Asynchronously multiply two matrices
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步乘以两个矩阵
- en: Chain asynchronous operations
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接异步操作
- en: Improve the pipeline example from the last chapter
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进上一章的管道示例
- en: Parallel computation and aggregation
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行计算和聚合
- en: '**Data aggregation** is the process of collecting raw data from multiple sources
    and organizing, processing, and providing a summary of the data for easy consumption.
    This process is useful in many fields, such as business reporting, financial services,
    healthcare, social media monitoring, research, and academia.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据聚合** 是从多个来源收集原始数据并组织、处理以及提供数据摘要以便于消费的过程。这个过程在许多领域都很有用，例如商业报告、金融服务、医疗保健、社交媒体监控、研究和学术界。'
- en: As a naive example, let’s compute the result of squaring all numbers between
    *1* and *n* and obtaining their average value. We know that using the following
    formula to compute the sum of square values would be much quicker and require
    less computer power. Also, the task could be more meaningful, but the purpose
    of this example is to understand the relationship between the tasks, not the task
    itself.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个简单的例子，让我们计算 *1* 到 *n* 之间所有数的平方值并获取它们的平均值。我们知道使用以下公式来计算平方值的总和会更快，并且需要更少的计算机资源。此外，这个任务可能更有意义，但这个示例的目的是理解任务之间的关系，而不是任务本身。
- en: '![<math  display="block"><mrow><mrow><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msup><mi>i</mi><mn>2</mn></msup></mrow><mo>=</mo><mfrac><mrow><mi>n</mi><mfenced
    open="(" close=")"><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfenced><mstyle
    scriptlevel="+1"><mfrac><mrow><mi>n</mi><mfenced open="(" close=")"><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfenced><mfenced
    open="(" close=")"><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfenced></mrow><mn>6</mn></mfrac></mstyle><mo>(</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><mn>6</mn></mfrac></mrow></mrow></math>](img/6.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![<math  display="block"><mrow><mrow><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msup><mi>i</mi><mn>2</mn></msup></mrow><mo>=</mo><mfrac><mrow><mi>n</mi><mfenced
    open="(" close=")"><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfenced><mstyle
    scriptlevel="+1"><mfrac><mrow><mi>n</mi><mfenced open="(" close=")"><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfenced><mfenced
    open="(" close=")"><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfenced></mrow><mn>6</mn></mfrac></mstyle><mo>(</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><mn>6</mn></mfrac></mrow></mrow></math>](img/6.png)'
- en: 'The **average_squares()** function in the following example launches an asynchronous
    task per value between *1* and *n* to compute the square value. The resulting
    future objects are stored in the **futsVec** vector, which is later used by the
    **sum_results()** function to compute the sum of the squared values. The result
    is then divided by **n** to obtain the average value:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例中的 **average_squares()** 函数为 *1* 到 *n* 之间的每个值启动一个异步任务来计算平方值。结果的未来对象存储在 **futsVec**
    向量中，稍后由 **sum_results()** 函数用来计算平方值的总和。然后将结果除以 **n** 以获得平均值：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: For example, for ![<mml:math  ><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>100</mml:mn></mml:math>](img/7.png)
    , we can check that the value will be the same as the one returned by   the function
    divided by * n * , * 3,383.50 * .
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于 ![<mml:math  ><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>100</mml:mn></mml:math>](img/7.png)
    ，我们可以检查该值将与函数返回值除以 * n * 、* 3,383.50 * 相同。
- en: This example can easily be modified to implement a solution using the **MapReduce**
    programming model to handle large datasets efficiently. MapReduce works by dividing
    the data processing into two phases; the Map phase, where independent chunks of
    data are filtered, sorted, and processed in parallel across multiple computers,
    and the Reduce phase where results from the Map phase are aggregated, summarizing
    the data. This is like what we just implemented, using the **square()** function
    in the Map phase, and the **average_squares()** and **sum_results()** functions
    in the Reduce phase.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可以轻松修改以实现使用 **MapReduce** 编程模型来高效处理大数据集的解决方案。MapReduce 通过将数据处理分为两个阶段来工作；Map
    阶段，在该阶段独立的数据块被过滤、排序并在多台计算机上并行处理，以及 Reduce 阶段，在该阶段聚合 Map 阶段的结果，总结数据。这就像我们刚刚实现的那样，使用
    Map 阶段中的 **square()** 函数，以及 Reduce 阶段中的 **average_squares()** 和 **sum_results()**
    函数。
- en: Asynchronous searches
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步搜索
- en: One way to speed up searching a target value into large containers is to parallelize
    the search. Next, we will present two examples. The first one involves searching
    across different containers by using one task per container, while the second
    one involves searching across a large container, dividing it into smaller segments,
    and using a task per segment.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 加快在大容器中搜索目标值的一种方法是将搜索并行化。接下来，我们将展示两个示例。第一个示例涉及通过每个容器使用一个任务来跨不同容器进行搜索，而第二个示例涉及跨一个大容器进行搜索，将其分割成更小的段，并使用每个段一个任务：
- en: Searching across different containers
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在不同的容器中进行搜索
- en: 'In this example, we need to search for a **target** value in different containers
    of diverse types ( **vector** , **list** , **forward_list** , and **set** ) containing
    names of animals:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们需要在包含动物名称的不同类型容器（**vector**、**list**、**forward_list** 和 **set**）中搜索一个**目标**值：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To search for the target value, we launch an asynchronous task for each container,
    using the **search()** template function, which simply calls the **std::find**
    function in a container and returns **true** if the target value is found, or
    **false** otherwise:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要搜索目标值，我们为每个容器启动一个异步任务，使用 **search()** 模板函数，该函数简单地在一个容器中调用 **std::find** 函数，如果找到目标值则返回
    **true**，否则返回 **false**：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'These asynchronous tasks are launched using the **std::async** function with
    the **std::launch::async** launch policy:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这些异步任务使用带有 **std::launch::async** 启动策略的 **std::async** 函数启动：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, we simply retrieve all return values from the futures created when
    using **std::async** and bitwise OR them:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们简单地从使用 **std::async** 创建的 futures 中检索所有返回值，并通过位或操作它们：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This example also shows the power of the **Standard Template Library** ( **STL**
    ) as it provides generic and reusable algorithms that can be applied to different
    containers and data types.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例还展示了 **标准模板库**（**STL**）的强大功能，因为它提供了通用的可重用算法，可以应用于不同的容器和数据类型。
- en: Searching in a large container
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在大容器中进行搜索
- en: In the next example, we will implement a solution to find a target value in
    a large vector containing 5 million integer values.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将实现一个解决方案，以在包含 500 万个整数值的大型向量中查找目标值。
- en: 'To generate the vector, we use a random number generator with a uniform integer
    distribution:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成向量，我们使用具有均匀整数分布的随机数生成器：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To search for a target value in a segment of a vector, we can use the **std::find**
    function with **begin** and **end** iterators pointing to the segment limits:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要在向量的一个段中搜索目标值，我们可以使用带有指向段限制的 **begin** 和 **end** 迭代器的 **std::find** 函数：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the **main()** function, we start by generating the large vector using the
    **generate_vector()** function, then defining the **target** value to find and
    the number of segments ( **num_segments** ) which the vector will be split for
    parallel searches:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **main()** 函数中，我们首先使用 **generate_vector()** 函数生成大型向量，然后定义要查找的 **目标** 值和向量将被分割进行并行搜索的段数（**num_segments**）：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, for each segment, we define its **begin** and **end** iterators and launch
    an asynchronous task to search for the target value in that segment. Thus, we
    execute **search_segment** asynchronously in a separate thread by using **std::async**
    with the **std::launch::async** launch policy. To avoid copying the large vector
    when passing it as an input argument of **search_segment** , we use a constant
    reference, **std::cref** . The futures returned by **std::async** are stored in
    the **futs** vector:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于每个段，我们定义其 **begin** 和 **end** 迭代器，并启动一个异步任务在该段中搜索目标值。因此，我们通过使用带有 **std::launch::async**
    启动策略的 **std::async** 在单独的线程中异步执行 **search_segment**。为了避免在将大向量作为 **search_segment**
    的输入参数传递时复制它，我们使用常量引用，**std::cref**。由 **std::async** 返回的 futures 存储在 **futs** 向量中：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that the vector size is not always a multiple of the segment size, thus
    the last segment might be shorter than the others. To deal with this situation
    and avoid issues when accessing out-of-bounds memory when checking the last segment,
    we need to properly set the **begin** and **end** indexes for each segment. For
    that, we use **std::min** to get the minimum value between the size of the vector
    and the hypothetical index of the last element in the current segment.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，向量的大小并不总是段大小的倍数，因此最后一个段可能比其他段短。为了处理这种情况并避免在检查最后一个段时访问越界内存的问题，我们需要为每个段适当地设置
    **begin** 和 **end** 索引。为此，我们使用 **std::min** 来获取向量大小和当前段中最后一个元素的假设索引之间的最小值。
- en: 'Finally, we check all results by calling **get()** on each future and print
    a message to the console if the target value was found in any of the segments:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过在每个 future 上调用 **get()** 来检查所有结果，并在控制台打印一条消息，如果任何段中找到了目标值：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This solution can be used as the base for more advanced solutions dealing with
    huge datasets in distributed systems where each asynchronous task tries to find
    a target value in a specific machine or cluster.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此解决方案可以作为处理分布式系统中大数据集的更高级解决方案的基础，其中每个异步任务都试图在特定的机器或集群中找到目标值。
- en: Asynchronous matrix multiplication
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步矩阵乘法
- en: '**Matrix multiplication** is one of the most relevant operations in computer
    science, used in many domains, such as computer graphics, computer vision, machine
    learning, and scientific computing.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**矩阵乘法** 是计算机科学中最相关的操作之一，在许多领域中使用，例如计算机图形学、计算机视觉、机器学习和科学计算。'
- en: In the following example, we will implement a parallel computing solution by
    distributing the computation across multiple threads.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们将通过在多个线程之间分配计算来实现并行计算解决方案。
- en: 'Let’s start by defining a matrix type, **matrix_t** , as a vector of vectors
    holding integer values:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个矩阵类型，**matrix_t**，作为一个包含整数值的向量向量：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Then, we implement the **matrix_multiply** function, which accepts two matrices,
    **A** and **B** , passing them as constant references, and returns their multiplication.
    We know that if **A** is a matrix ![<mml:math  ><mml:mi>m</mml:mi><mml:mi>x</mml:mi><mml:mi>n</mml:mi></mml:math>](img/8.png)
    ( * m * stands for rows and * n * for columns) and ** B ** is a matrix ![<mml:math  ><mml:mi>p</mml:mi><mml:mi>x</mml:mi><mml:mi>q</mml:mi></mml:math>](img/9.png)
    , we can multiply ** A ** and ** B ** if ![<mml:math  ><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mi>p</mml:mi></mml:math>](img/10.png)
    , and the resulting matrix will be of dimensions ![<mml:math  ><mml:mi>m</mml:mi><mml:mi>x</mml:mi><mml:mi>q</mml:mi></mml:math>](img/11.png)
    ( * m * rows and * q * columns).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们实现 **matrix_multiply** 函数，该函数接受两个矩阵 **A** 和 **B**，将它们作为常量引用传递，并返回它们的乘积。我们知道如果
    **A** 是一个矩阵 ![<mml:math  ><mml:mi>m</mml:mi><mml:mi>x</mml:mi><mml:mi>n</mml:mi></mml:math>](img/8.png)（其中
    *m* 代表行，*n* 代表列）并且 **B** 是一个矩阵 ![<mml:math  ><mml:mi>p</mml:mi><mml:mi>x</mml:mi><mml:mi>q</mml:mi></mml:math>](img/9.png)，当
    ![<mml:math  ><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mi>p</mml:mi></mml:math>](img/10.png)
    时，我们可以乘以 **A** 和 **B**，结果矩阵的维度将是 ![<mml:math  ><mml:mi>m</mml:mi><mml:mi>x</mml:mi><mml:mi>q</mml:mi></mml:math>](img/11.png)（*m*
    行和 *q* 列）。
- en: 'The **matrix_multiply** function just starts by reserving some space to the
    result matrix, **res** . Then, it loops over the matrix by extracting column **j**
    from **B** and multiplying it by row **i** from **A** :'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**matrix_multiply** 函数首先为结果矩阵 **res** 预留一些空间，然后通过从 **B** 中提取列 **j** 并将其与 **A**
    中的行 **i** 相乘来遍历矩阵：'
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The multiplication is done asynchronously by using **std::async** with the
    **std::launch::async** launch policy, running the **dot_product** function. Each
    returned future from **std::async** is stored in the **futs** vector. The **dot_product**
    function computes the dot product of vectors **a** and **b** , representing a
    row from **A** and a column from **B** , by multiplying element by element and
    returning the sum of these products:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法是通过使用**std::async**和**std::launch::async**启动策略异步进行的，运行**dot_product**函数。**std::async**返回的每个future都存储在**futs**向量中。**dot_product**函数通过逐元素相乘并返回这些乘积的总和来计算向量**a**和**b**的点积，代表**A**中的一行和**B**中的一列：
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As the **dot_product** function expects two vectors, we need to extract each
    column from **B** before launching each asynchronous task. This also enhances
    the overall performance as the vectors might be stored in contiguous blocks of
    memory, thus being more cache-friendly during computation.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**dot_product**函数期望两个向量，我们需要在启动每个异步任务之前从**B**中提取每一列。这也提高了整体性能，因为向量可能存储在连续的内存块中，因此在计算时更缓存友好。
- en: 'In the **main()** function, we just define two matrices, **A** and **B** ,
    and use the **matrix_multipy** function to compute their product. All matrices
    are printed into the console using the **show_matrix** lambda function:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在**main()**函数中，我们只定义了两个矩阵**A**和**B**，并使用**matrix_multipy**函数来计算它们的乘积。所有矩阵都使用**show_matrix**lambda函数打印到控制台：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This is the output from running this example:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行此示例的输出：
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Using contiguous memory blocks improves performance when traversing vectors
    as many of their elements can be read at once into the cache. Using contiguous
    memory allocation is not guaranteed when using **std::vector** , therefore it
    might be better to use **new** or **malloc** .
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用连续内存块在遍历向量时可以提高性能，因为许多元素可以一次读入缓存。使用**std::vector**时，不保证连续内存分配，因此可能最好使用**new**或**malloc**。
- en: Chain asynchronous operations
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接异步操作
- en: In this example, we will implement a simple pipeline composed of three stages
    where each stage takes the result from the previous stage and computes a value.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将实现一个由三个阶段组成的简单管道，每个阶段都从前一个阶段的结果中获取并计算一个值。
- en: '![Figure 7.1 – Simple pipeline example](img/B22219_07_01.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 简单管道示例](img/B22219_07_01.jpg)'
- en: Figure 7.1 – Simple pipeline example
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 简单管道示例
- en: 'The first stage only accepts positive integers as input, otherwise it raises
    an exception, and adds 10 to that value before returning the result. The second
    stage multiplies its input by 2, and the third subtracts 5 from its input:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 第一阶段仅接受正整数作为输入，否则会抛出异常，并在返回结果之前将10加到该值上。第二阶段将其输入乘以2，第三阶段从其输入中减去5：
- en: '[PRE44]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the **main()** function, for the intermediate and final stages, we define
    the pipeline by using as input the futures generated by the previous stages. These
    futures are passed by reference to the lambda expression running the asynchronous
    code, where their **get()** function is used to get their result.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在**main()**函数中，对于中间和最终阶段，我们通过使用前一个阶段生成的futures作为输入来定义管道。这些futures通过引用传递给运行异步代码的lambda表达式，其中使用它们的**get()**函数来获取它们的结果。
- en: 'To retrieve the result from the pipeline, we just need to call the **get()**
    function from the future returned by the last stage. If an exception happens,
    for example, when **input_value** is negative, it is caught by the try-catch block:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要从管道中检索结果，我们只需调用最后阶段返回的future的**get()**函数。如果发生异常，例如，当**input_value**为负时，它会被try-catch块捕获：
- en: '[PRE45]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The pipeline defined in this example is a simple one where each stage uses the
    future from the previous stage to get the input value and produce its result.
    In the next example, we will rewrite the pipeline implemented in the previous
    chapter using **std:async** with deferred launch policies to only execute the
    stages that are needed.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中定义的管道是一个简单的管道，其中每个阶段都使用前一个阶段的future来获取输入值并产生其结果。在下一个例子中，我们将使用**std:async**和延迟启动策略重写上一章中实现的管道，以仅执行所需的阶段。
- en: Asynchronous pipeline
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步管道
- en: As promised, in the last chapter, when we were implementing a pipeline, we mentioned
    that the different tasks could be kept switched off until needed by using futures
    with deferred execution. As also mentioned, this is useful in scenarios where
    the computation cost is high, but the result may not always be needed. As futures
    with deferred status can only be created by using **std::async** , now it’s time
    to see how to do that.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 正如承诺的那样，在前一章中，当我们实现管道时，我们提到可以使用具有延迟执行的 futures 来保持不同的任务关闭，直到需要时。正如也提到的，这在计算成本高但结果不一定总是需要的情况下很有用。由于只有使用
    **std::async** 才能创建具有延迟状态的 futures，现在我们来看看如何做到这一点。
- en: 'We will implement the same pipeline described in the previous chapter, which
    follows the next task graph:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现前一章中描述的相同管道，它遵循以下任务图：
- en: '![Figure 7.2 – Pipeline example](img/B22219_07_02.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – 管道示例](img/B22219_07_02.jpg)'
- en: Figure 7.2 – Pipeline example
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 管道示例
- en: We start by defining the **Task** class. This class is like the one implemented
    in an example in the previous chapter but using the **std::async** function and
    storing the returned future instead of the promise used previously. Here, we will
    only comment on the relevant code changes from that example, so please look at
    that example for a full explanation of the **Task** class or check it out in the
    GitHub repository.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义 **Task** 类。这个类类似于前一章示例中实现的类，但使用 **std::async** 函数并存储返回的 future 而不是之前使用的
    promise。在这里，我们只将评论与示例中的相关代码更改相关联，因此请查看该示例以获取 **Task** 类的完整解释或检查 GitHub 仓库。
- en: '**Task** constructors store the task identifier ( **id_** ), the function to
    launch ( **func_** ), and whether the task has dependencies ( **has_dependency_**
    ). It also starts the asynchronous task in deferred launch mode by using **std::async**
    with the **std::launch::deferred** launch policy, meaning that the task is created
    but not started until needed. The returned future is stored in the **fut_** variable:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**Task** 构造函数存储任务标识符（**id_**）、要启动的函数（**func_**）以及任务是否有依赖关系（**has_dependency_**）。它还通过使用具有
    **std::launch::deferred** 启动策略的 **std::async** 以延迟启动模式启动异步任务。这意味着任务被创建但直到需要时才启动。返回的
    future 存储在 **fut_** 变量中：'
- en: '[PRE46]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The asynchronous tasks started by **std::async** call the **operator()** of
    their own instance (the **this** object). When that happens, **wait_completion()**
    is called, checking whether all futures in the shared future vector, **deps_**
    , storing dependent tasks are valid by calling their **valid()** function, and
    if so, waiting for them to finish by calling the **get()** function. When all
    dependent tasks are complete, the **func_** function is called:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 由 **std::async** 启动的异步任务调用它们自己的实例（即 **this** 对象）的 **operator()**。当发生这种情况时，会调用
    **wait_completion()**，通过调用存储依赖任务的共享 future 向量 **deps_** 的 **valid()** 函数来检查所有
    futures 是否有效，如果是，则通过调用 **get()** 函数等待它们完成。当所有依赖任务完成时，会调用 **func_** 函数：
- en: '[PRE47]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'There is also a new member function, **start()** , that waits for the **fut_**
    future created during the task construction when calling **std::async** . This
    will be used to trigger the pipeline by requesting the result of the last task:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个新的成员函数，**start()**，它在调用 **std::async** 期间任务构造时等待创建的 **fut_** future。这将用于通过请求最后一个任务的结果来触发管道：
- en: '[PRE48]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As in the example in the previous chapter, we also define a member function
    called **get_dependency()** that returns a shared future constructed from **fut_**
    :'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章中的示例所示，我们也定义了一个名为 **get_dependency()** 的成员函数，它返回由 **fut_** 构造的共享 future：
- en: '[PRE49]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the **main()** function, we define the pipeline by chaining task objects
    and setting their dependencies and the lambda function to run, **sleep1s** or
    **sleep2s** , following the diagram shown in *Figure 7* *.2* :'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **main()** 函数中，我们通过链式任务对象并设置它们的依赖关系以及要运行的 lambda 函数（**sleep1s** 或 **sleep2s**），根据图
    *7.2* 中所示的图来定义管道：
- en: '[PRE50]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Starting the pipeline is as simple as getting the result from the last task’s
    future. We can do that by calling the **start()** method of **task5** . This will
    recursively call their dependency tasks by using the dependency vector and start
    the deferred asynchronous tasks.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 启动管道就像从最后一个任务的 future 获取结果一样简单。我们可以通过调用 **task5** 的 **start()** 方法来实现这一点。这将递归地通过依赖关系向量调用它们的依赖任务并启动延迟异步任务。
- en: 'This is the output of executing the preceding code:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这是执行前述代码的输出：
- en: '[PRE51]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We can see how the pipeline is created by calling each task’s constructor and
    getting the futures from previous dependent tasks.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用每个任务的构造函数并从先前依赖任务获取 futures 来看到管道是如何创建的。
- en: Then, when the pipeline is triggered, **task5** is started, starting **task3**
    , **task2** , and **task1** recursively. As **task1** has no dependencies, it
    doesn’t need to wait for any other task to run its work, so it completes, allowing
    **task2** to complete, and later **task3** .
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当管道被触发时，**task5** 开始执行，递归地启动 **task3**、**task2** 和 **task1**。由于 **task1**
    没有依赖项，它不需要等待其他任何任务运行其工作，因此它完成，允许 **task2** 完成，然后是 **task3**。
- en: Next, **task5** continues checking its dependent tasks, so it’s now **task4**
    ‘s turn to run. Since all **task4** ‘s dependent tasks are complete, **task4**
    just executes, allowing **task5** to run afterward, thus completing the pipeline.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，**task5** 继续检查其依赖任务，因此现在是 **task4** 的运行时间。由于 **task4** 的所有依赖任务都已完成，**task4**
    只需执行，允许 **task5** 在之后运行，从而完成管道。
- en: This example can be improved by performing real computations and transferring
    results between tasks. Also, instead of deferred tasks, we could also think of
    stages with several parallel steps that can be computed in separate threads. Feel
    free to implement these improvements as an additional exercise.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可以通过执行实际计算并在任务之间传输结果来改进。此外，我们也可以考虑具有几个并行步骤的阶段，这些步骤可以在单独的线程中计算。请随意将这些改进作为附加练习实现。
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about **std::async** , how to use this function
    to execute asynchronous tasks, how to define its behavior by using launch policies,
    and how to handle exceptions.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 **std::async**，如何使用此函数执行异步任务，如何通过使用启动策略来定义其行为，以及如何处理异常。
- en: We also now understand how the futures returned by the async function can impact
    performance and how to use them wisely. Also, we saw how to limit the number of
    asynchronous tasks by the number of available threads in the system by using counting
    semaphores.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在还了解异步函数返回的未来如何影响性能，以及如何明智地使用它们。我们还看到了如何通过使用计数信号量来限制系统可用线程数来限制异步任务的数量。
- en: We also mentioned some scenarios where **std::async** might not be the best
    tool for the job.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提到了一些场景，在这些场景中，**std::async** 可能不是最佳工具。
- en: Finally, we implemented several examples covering real-life scenarios, which
    is useful for parallelizing many common tasks.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现了几个涵盖现实场景的示例，这对于并行化许多常见任务很有用。
- en: With all the knowledge acquired in this chapter, now we know when (and when
    not) to use the **std::async** function to run asynchronous tasks in parallel,
    improving the overall performance of applications, achieving better computer resource
    usage, and reducing resource exhaustion.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章获得的所有知识，现在我们知道了何时（以及何时不）使用 **std::async** 函数来并行运行异步任务，从而提高应用程序的整体性能，实现更好的计算机资源使用，并减少资源耗尽。
- en: In the next chapter, we will learn how to achieve asynchronous execution by
    using coroutines, which have been available since C++20.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何通过使用自 C++20 起可用的协程来实现异步执行。
- en: Further reading
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Effective Modern C++* : *42 Specific Ways to Improve Your Use of C++11 and
    C++14* , Scott Meyers, O’Reilly Media, Inc., 1st Edition – Chapter 7 , Item 35
    and Item 36'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《有效现代 C++》*：*42 种提高您对 C++11 和 C++14 使用的方法*，Scott Meyers 著，O''Reilly 媒体公司，第一版
    – 第七章，项目 35 和项目 36'
- en: '**std::async** : [https://en.cppreference.com/w/cpp/thread/async](https://en.cppreference.com/w/cpp/thread/async)'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**std::async** : [https://en.cppreference.com/w/cpp/thread/async](https://en.cppreference.com/w/cpp/thread/async)'
- en: '**std::launch** : [https://en.cppreference.com/w/cpp/thread/launch](https://en.cppreference.com/w/cpp/thread/launch)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**std::launch** : [https://en.cppreference.com/w/cpp/thread/launch](https://en.cppreference.com/w/cpp/thread/launch)'
- en: 'Strassen algorithm: [https://en.wikipedia.org/wiki/Strassen_algorithm](https://en.wikipedia.org/wiki/Strassen_algorithm)'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Strassen 算法: [https://en.wikipedia.org/wiki/Strassen_algorithm](https://en.wikipedia.org/wiki/Strassen_algorithm)'
- en: 'Karatsuba algorithm: [https://en.wikipedia.org/wiki/Karatsuba_algorithm](https://en.wikipedia.org/wiki/Karatsuba_algorithm)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Karatsuba 算法: [https://en.wikipedia.org/wiki/Karatsuba_algorithm](https://en.wikipedia.org/wiki/Karatsuba_algorithm)'
- en: 'OpenBLAS: [https://www.openblas.net](https://www.openblas.net)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'OpenBLAS: [https://www.openblas.net](https://www.openblas.net)'
- en: 'BLIS library: [https://github.com/flame/blis](https://github.com/flame/blis)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'BLIS 库: [https://github.com/flame/blis](https://github.com/flame/blis)'
- en: 'MapReduce: [https://hadoop.apache.org/docs/r1.2.1/mapred_tutorial.html](https://hadoop.apache.org/docs/r1.2.1/mapred_tutorial.html)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'MapReduce: [https://hadoop.apache.org/docs/r1.2.1/mapred_tutorial.html](https://hadoop.apache.org/docs/r1.2.1/mapred_tutorial.html)'
