- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Working with Unreal Engine
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Unreal Engine
- en: In the previous chapter, we went through the basics of the Epic Games Launcher,
    along with Unreal Editor fundamentals. We learned how to work with objects and
    what Blueprints are at a basic level, in addition to exploring the First Person
    template. In this chapter, we’ll be building upon those fundamentals by exploring
    the Third Person template and working with input and animations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了 Epic Games Launcher 的基础知识以及 Unreal 编辑器的基本功能。我们学习了如何处理对象以及蓝图的基本概念，还探索了第一人称模板。在本章中，我们将在此基础上，通过探索第三人称模板和处理输入和动画来进一步探索这些基础知识。
- en: Game development can be done in a wide variety of languages, such as C, C++,
    Java, C#, and even Python. While each language has pros and cons, we will be using
    C++ throughout this book as it is the primary programming language that’s used
    within Unreal Engine.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开发可以使用多种语言，例如 C、C++、Java、C#，甚至 Python。虽然每种语言都有其优缺点，但在这本书中，我们将使用 C++，因为它是 Unreal
    Engine 中使用的首选编程语言。
- en: In this chapter, we will get you up to speed on how to create a C++ project
    and perform basic-level debugging in UE5\. It is very important to be able to
    debug code as it helps the developer while dealing with bugs. The tools provided
    come in very handy and are essential for any Unreal Engine developer.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向您介绍如何创建 C++ 项目并在 UE5 中进行基本调试。能够调试代码非常重要，因为它有助于开发者处理错误。提供的工具非常实用，对于任何
    Unreal Engine 开发者来说都是必不可少的。
- en: Following this, we will get up close and personal with the core classes involved
    in creating games and experiences in Unreal Engine. You will explore Game Mode
    and the relevant class concepts, followed by an exercise to gain a hands-on understanding
    of this.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入了解 Unreal Engine 中创建游戏和体验的核心类。您将探索游戏模式和相关的类概念，然后通过练习来获得实际操作的理解。
- en: The final section in this chapter is all about animations. Almost every single
    game features animations, some to a very basic extent, but some to a very high
    level, which includes captivating details that are key to the gameplay experience.
    Unreal Engine offers several tools you can use to create and deal with animations,
    including the Animation Blueprint, which provides complex graphs, and a State
    Machine.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后部分全部关于动画。几乎每款游戏都有动画，有的非常基础，有的则非常高级，包括对游戏体验至关重要的吸引人的细节。Unreal Engine 提供了多种工具，您可以使用这些工具创建和处理动画，包括提供复杂图的动画蓝图和状态机。
- en: This chapter will focus on many of the basic concepts and features within Unreal
    Engine. You will be shown how to create a C++ project, how to perform some basic
    debugging, and how to work with character-specific animations.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍 Unreal Engine 中许多基本概念和功能。您将了解如何创建 C++ 项目，如何进行一些基本的调试，以及如何处理特定于角色的动画。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Creating and setting up a blank C++ project
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建并设置一个空的 C++ 项目
- en: The Content folder’s structure in Unreal Engine
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unreal Engine 中内容文件夹的结构
- en: Working with the Visual Studio solution
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Visual Studio 解决方案
- en: Importing the required assets
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入所需的资源
- en: The Unreal Game Mode class
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unreal 游戏模式类
- en: Understanding levels and the Level Blueprint
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解关卡和关卡蓝图
- en: Animations
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画
- en: By the end of this chapter, you’ll be able to create C++ template projects and
    debug code within Visual Studio, understand the folder structure and the best
    practices involved, and be able to set up character animations based on their
    states.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够创建 C++ 模板项目并在 Visual Studio 中进行代码调试，理解文件夹结构和涉及的最佳实践，并能够根据其状态设置角色动画。
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter has the following technical requirements:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求如下：
- en: UE5 installed
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UE5 已安装
- en: Visual Studio 2019 installed
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2019 已安装
- en: The complete code for this chapter can be downloaded from this book’s GitHub
    repository at [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition).
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的完整代码可以从本书的 GitHub 仓库下载，网址为 [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition)。
- en: Creating and setting up a blank C++ project
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建并设置一个空的 C++ 项目
- en: At the start of every project, you may want to start with any of the templates
    provided by Epic (which contain ready-to-execute basic code) and build on top
    of that. Most/some of the time, you may need to set up a blank or empty project
    that you can mold and sculpt to your requirements. We’ll learn how to do that
    in the following exercise.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个项目的开始，你可能希望从 Epic 提供的任何模板（其中包含可执行的基本代码）开始，并在其基础上构建。大多数/一些时候，你可能需要设置一个空白或空项目，你可以根据需求对其进行塑形。我们将在接下来的练习中学习如何做到这一点。
- en: Exercise 2.01 – creating an empty C++ project
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.01 – 创建一个空的 C++ 项目
- en: In this exercise, you will learn how to create an empty C++ project from the
    template provided by Epic. This will serve as the foundation for many of your
    future C++ projects.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将学习如何从 Epic 提供的模板中创建一个空的 C++ 项目。这将成为你未来许多 C++ 项目的基石。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个练习：
- en: Launch UE5 from the Epic Games Launcher.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Epic Games Launcher 启动 UE5。
- en: Click on the `BLANK PROJECT` section and click `Blank`.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `BLANK PROJECT` 部分，然后点击 `Blank`。
- en: Under the **Project Defaults** section on the right pane, select **C++****.**
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧面板的 **项目默认值** 部分下，选择 **C++**。
- en: Note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure that the project folder and project name are specified with an appropriate
    directory and name, respectively.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 确保项目文件夹和项目名称分别使用适当的目录和名称指定。
- en: When everything is set up, click on the `UnrealProjects`, which is inside the
    `E` drive. The project name is set to `MyBlankProj` (it is recommended that you
    use these names and project directories, but you can use your own if you wish
    to do so).
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当一切设置完毕后，点击 `E` 驱动器内的 `UnrealProjects`。项目名称设置为 `MyBlankProj`（建议使用这些名称和项目目录，但如果你愿意，也可以使用自己的名称）。请注意，你可以使用自己的名称，但最好将
    Unreal 目录放置在驱动器根目录附近（以避免在创建或导入项目工作目录中的资源时遇到问题，例如 256 个字符路径限制；对于小型项目，这可能没问题，但对于更大规模的项目，其中文件夹层次结构可能变得过于复杂，这一步很重要）。
- en: Note
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The project name cannot have any spaces in it. It is preferable to have an Unreal
    directory as close to the root of a drive as possible (to avoid running into issues
    such as the 256-character path limit when creating or importing assets into your
    project’s working directory; for small projects, it may be fine, but for more
    large-scale projects, where the folder hierarchy may become too complex, this
    step is important).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 项目名称中不能包含任何空格。最好将 Unreal 目录放置在驱动器根目录附近（以避免在创建或导入项目工作目录中的资源时遇到问题，例如 256 个字符路径限制；对于小型项目，这可能没问题，但对于更大规模的项目，其中文件夹层次结构可能变得过于复杂，这一步很重要）。
- en: After it’s done generating the code and creating the project files, the project
    will open, along with its Visual Studio solution (`.sln`) file.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成代码并创建项目文件后，项目将打开，包括其 Visual Studio 解决方案文件（`.sln`）。
- en: 'Make sure that the Visual Studio solution configuration is set to **Development
    Editor** and that the solution platform is set to **Win64** for desktop development:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 确保 Visual Studio 解决方案配置设置为 **开发编辑器**，并且解决方案平台设置为 **Win64** 以进行桌面开发：
- en: '![Figure 2.1 – Visual Studio deployment settings ](img/Figure_2.01_B18531.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – Visual Studio 部署设置](img/Figure_2.01_B18531.jpg)'
- en: Figure 2.1 – Visual Studio deployment settings
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – Visual Studio 部署设置
- en: By completing this exercise, you know how to create an empty C++ project on
    UE5, along with its considerations.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你将了解如何在 UE5 上创建一个空的 C++ 项目，以及相关的注意事项。
- en: In the next section, we’ll talk about the folder structure, along with the most
    basic and most used folder structure format that’s used by Unreal developers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论文件夹结构，以及 Unreal 开发者使用的最基本和最常用的文件夹结构格式。
- en: The Content folder’s structure in Unreal Engine
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unreal Engine 中内容文件夹的结构
- en: In your project directory (in our case, `E:/UnrealProjects/MyBlankProj`), you
    will see a `Content` folder. This is the primary folder that your project uses
    for different types of assets and project-relevant data (including Blueprints).
    The C++ code goes into the `Source` folder in your project. Please note that the
    best practice is to create new C++ code files directly through the Unreal Editor
    as this simplifies the process and results in fewer errors.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目目录中（在我们的例子中，`E:/UnrealProjects/MyBlankProj`），你会看到一个 `Content` 文件夹。这是你的项目用于不同类型资源和项目相关数据的主体文件夹（包括蓝图）。C++
    代码放入你项目中的 `Source` 文件夹。请注意，最佳实践是直接通过 Unreal 编辑器创建新的 C++ 代码文件，因为这简化了过程并减少了错误。
- en: There are many different strategies you can use to organize the data inside
    your `Content` folder. The most basic and easy-to-understand is using folder names
    to depict the type of content inside. Therefore, a `Content` folder directory
    structure may resemble the example at [https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/blob/master/Chapter02/Images/06New.png](https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/blob/master/Chapter02/Images/06New.png).
    In this example, you can see that each file is categorically placed under the
    name of the folder representing its type at the first level, with the following
    levels further grouping it into meaningful folders.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用许多不同的策略来组织`Content`文件夹内的数据。最基本且易于理解的是使用文件夹名称来表示文件夹内的内容类型。因此，`Content`文件夹的目录结构可能类似于[https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/blob/master/Chapter02/Images/06New.png](https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/blob/master/Chapter02/Images/06New.png)中的示例。在这个例子中，您可以看到每个文件都被分类放置在代表其类型的文件夹名称下，下一级进一步将其分组到有意义的文件夹中。
- en: Note
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: All Blueprints should prefix `BP` to their name (to differentiate them from
    the default blueprints used by Unreal Engine). The rest of the prefixes are optional
    (however, it is best practice to format them with the prefixes shown earlier).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 所有蓝图都应该在其名称前缀`BP`（以区分Unreal Engine使用的默认蓝图）来区分。其余的前缀是可选的（然而，最佳实践是使用前面显示的前缀来格式化它们）。
- en: In the next section, we will look at the Visual Studio solution.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看Visual Studio解决方案。
- en: Working with the Visual Studio solution
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Visual Studio解决方案
- en: Every C++ project in Unreal Engine has a Visual Studio solution. This, in turn,
    drives all the code and allows developers to set up execution logic and debug
    code in its running state.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal Engine中的每个C++项目都有一个Visual Studio解决方案。这反过来又驱动了所有代码，并允许开发者在运行状态下设置执行逻辑和调试代码。
- en: '**Solution Analysis**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案分析**'
- en: The Visual Studio solution (.`sln`) file that’s produced inside the project
    directory contains the entire project and any associated code that’s been added
    to it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目目录内生成的Visual Studio解决方案（.`sln`）文件包含整个项目和任何添加到其中的相关代码。
- en: Let’s have a look at the files present in Visual Studio. Double-click the .`sln`
    file to open it within Visual Studio.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Visual Studio中的文件。双击`.sln`文件以在Visual Studio中打开它。
- en: In `Engine` and `Games`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Engine`和`Games`中。
- en: '**The Engine Project**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**Engine项目**'
- en: At the base level, Unreal Engine itself is a Visual Studio project and has a
    solution file. This contains all the code and third-party integrations that work
    together in Unreal Engine. All the code within this project is called the **source**
    code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本层面上，Unreal Engine本身是一个Visual Studio项目，并有一个解决方案文件。这个文件包含了在Unreal Engine中协同工作的所有代码和第三方集成。此项目中的所有代码被称为**源代码**。
- en: The Engine project consists of the external dependencies, configurations, plugins,
    shaders, and source code of Unreal Engine that are currently being used for this
    project. You can, at any time, browse the `UE5` | `Source` folder to view any
    of the engine code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Engine项目包括用于此项目的Unreal Engine的外部依赖项、配置、插件、着色器和源代码。您可以在任何时候浏览`UE5` | `Source`文件夹以查看任何引擎代码。
- en: Note
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'As Unreal Engine is open source, Epic allows developers to both view and edit
    source code to suit their needs and requirements. However, you cannot edit the
    source code in the version of Unreal Engine that’s installed via the Epic Games
    Launcher. To be able to make and build changes in source code, you need to download
    the source version of Unreal Engine, which can be found via GitHub. You can use
    the following guide to download the source version of Unreal Engine: [https://docs.unrealengine.com/en-US/GettingStarted/DownloadingUnrealEngine/index.xhtml](https://docs.unrealengine.com/en-US/GettingStarted/DownloadingUnrealEngine/index.xhtml).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Unreal Engine是开源的，Epic允许开发者查看和编辑源代码以满足他们的需求和需求。但是，您不能在通过Epic Games Launcher安装的Unreal
    Engine版本中编辑源代码。要能够对源代码进行修改和构建，您需要下载Unreal Engine的源代码版本，这可以通过GitHub找到。您可以使用以下指南下载Unreal
    Engine的源代码版本：[https://docs.unrealengine.com/en-US/GettingStarted/DownloadingUnrealEngine/index.xhtml](https://docs.unrealengine.com/en-US/GettingStarted/DownloadingUnrealEngine/index.xhtml)。
- en: 'After downloading, you can also refer to the following guide to compile/build
    the newly downloaded engine: [https://docs.unrealengine.com/en-US/Programming/Development/BuildingUnrealEngine/index.xhtml](https://docs.unrealengine.com/en-US/Programming/Development/BuildingUnrealEngine/index.xhtml).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下载后，您还可以参考以下指南来编译/构建新下载的引擎：[https://docs.unrealengine.com/en-US/Programming/Development/BuildingUnrealEngine/index.xhtml](https://docs.unrealengine.com/en-US/Programming/Development/BuildingUnrealEngine/index.xhtml)。
- en: '**Game Project**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**游戏项目**'
- en: 'Under the `Games` directory is the solution folder that’s named after your
    project. Upon expansion, you’ll find a set of folders. You will need to understand
    the following ones:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Games`目录下是名为您项目的解决方案文件夹。展开后，您将找到一组文件夹。您需要了解以下内容：
- en: '**Config folder**: This folder carries all the configurations that have been
    set up for the project and the build (these can optionally have platform-specific
    (such as Windows, Android, iOS, Xbox, or PlayStation) settings as well).'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置文件夹**：此文件夹包含为项目及其构建（这些可以可选地具有特定平台（如Windows、Android、iOS、Xbox或PlayStation）的设置）设置的所有配置。'
- en: '**Plugins folder**: This is an optional folder that’s created when you add
    any third-party plugin (downloaded from the Epic Marketplace or obtained through
    the internet). This folder will contain all of the source code of the plugins
    associated with this project.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插件文件夹**：这是一个可选文件夹，当您添加任何第三方插件（从Epic Marketplace下载或通过互联网获得）时创建。此文件夹将包含与此项目关联的所有插件的源代码。'
- en: '`Build Target` files, as well as all the source code for the project. The following
    is a description of the default files in the source folder:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Build Target`文件以及项目的所有源代码。以下是源文件夹中默认文件的描述：'
- en: '`.Target.cs` extension, and one build file that ends with `Build.cs`.'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.Target.cs`扩展名，以及一个以`Build.cs`结尾的构建文件。'
- en: '**ProjectName code files (.cpp and .h)**: By default, these files are created
    for each project and contain the code that’s used to run the default game module
    code.'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ProjectName代码文件 (.cpp和.h)**：默认情况下，这些文件为每个项目创建，包含用于运行默认游戏模块代码的代码。'
- en: '**ProjectNameGameModeBase code files (.cpp and .h)**: By default, an empty
    **Project Game Mode Base** is created. It’s not used in most cases.'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ProjectNameGameModeBase代码文件 (.cpp和.h)**：默认情况下，创建了一个空的**Project Game Mode
    Base**。在大多数情况下不使用。'
- en: '**ProjectName.uproject file**: This file contains the descriptors used to provide
    basic information about the project and the list of plugins associated with it.'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ProjectName.uproject文件**：此文件包含用于提供项目基本信息和与其关联的插件列表的描述符。'
- en: Debugging code in Visual Studio
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Visual Studio中调试代码
- en: Visual Studio provides powerful debugging features with the help of breakpoints
    in code. This allows users to pause the game at a particular line of code so that
    the developer can see the current values of variables and step through the code
    and game in a controlled fashion (they can proceed line by line, function by function,
    and so on).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio通过代码中的断点提供强大的调试功能。这允许用户在特定代码行暂停游戏，以便开发者可以查看变量的当前值，并以受控的方式逐步通过代码和游戏（他们可以逐行、逐函数地继续，等等）。
- en: This is useful when you have a lot of variables and code files in your game
    project, and you want to see the values of the variables being updated and used
    in a step-by-step fashion to debug the code, find out what issues there are, and
    solve them. Debugging is a fundamental process of any developer’s work, and only
    after many continuous debugging, profiling, and optimization cycles does a project
    get polished enough for deployment.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在游戏项目中有很多变量和代码文件时，这很有用，您想以逐步的方式查看变量的更新和使用情况以调试代码，找出问题并解决它们。调试是任何开发者工作的基本过程，只有经过许多连续的调试、分析和优化周期，项目才能足够完善以供部署。
- en: Now that you’ve got the basic idea of the Visual Studio solution, we’ll move
    on and cover a practical exercise on it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了Visual Studio解决方案的基本概念，我们将继续并介绍关于它的实际练习。
- en: Exercise 2.02 – debugging the Third Person template code
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.02 – 调试第三人称模板代码
- en: In this exercise, you’ll be creating a project using the `BaseTurnRate` in the
    `Character` class of this template project. We’ll learn how the value updates
    as we move through the code, line by line.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将使用此模板项目中的`Character`类的`BaseTurnRate`创建一个项目。我们将学习值如何在代码中逐行更新。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: Launch Unreal Engine from the Epic Games Launcher.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Epic Games Launcher启动Unreal Engine。
- en: Click on the **Games** section and click **Next**.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**游戏**部分，然后点击**下一步**。
- en: Select **Third Person** and click **Next**.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**第三人称**，然后点击**下一步**。
- en: Select `ThirdPersonDebug`, and click the **Create Project** button.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`ThirdPersonDebug`，然后点击**创建项目**按钮。
- en: 'Now, close Unreal Editor, go to the Visual Studio solution, and open the `ThirdPersonDebugCharacter.cpp`
    file:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，关闭Unreal编辑器，转到Visual Studio解决方案，并打开`ThirdPersonDebugCharacter.cpp`文件：
- en: '![Figure 2.2 – The ThirdPersonDebugCharacter.cpp file’s location ](img/Figure_2.02_B18531.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 第三人称调试角色.cpp文件的位置](img/Figure_2.02_B18531.jpg)'
- en: Figure 2.2 – The ThirdPersonDebugCharacter.cpp file’s location
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 第三人称调试角色.cpp文件的位置
- en: 'Left-click on the bar on the left-hand side of line `18`. A red dot icon should
    appear on it (*you can toggle it off by clicking on it again*):'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第`18`行的左侧栏上左键单击。应该会在其上出现一个红色圆点图标（*你可以通过再次单击来切换它*）：
- en: '![Figure 2.3 – Collision capsule init code ](img/Figure_2.03_B18531.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3 – 碰撞胶囊初始化代码](img/Figure_2.03_B18531.jpg)'
- en: Figure 2.3 – Collision capsule init code
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – 碰撞胶囊初始化代码
- en: 'Here, we are getting the `capsule` component (explained further in [*Chapter
    3*](B18531_03.xhtml#_idTextAnchor090), *Character Class Components and Blueprint
    Setup*) of the character, which, by default, is the root component. Then, we are
    calling its `InitCapsuleSize` method, which takes in two parameters: the `InRadius`
    float and the `InHalfHeight` float, respectively.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们正在获取角色的`capsule`组件（在[*第3章*](B18531_03.xhtml#_idTextAnchor090)，*角色类组件和蓝图设置*）中进一步解释），默认情况下是根组件。然后，我们调用它的`InitCapsuleSize`方法，该方法接受两个参数：分别是`InRadius`浮点数和`InHalfHeight`浮点数。
- en: 'Make sure that the solution configuration setting in VS is set to **Development
    Editor** and click on the **Local Windows Debugger** button:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保VS中的解决方案配置设置设置为**开发编辑器**，然后点击**本地Windows调试器**按钮：
- en: '![Figure 2.4 – Visual Studio build settings ](img/Figure_2.04_B18531.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4 – Visual Studio构建设置](img/Figure_2.04_B18531.jpg)'
- en: Figure 2.4 – Visual Studio build settings
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – Visual Studio构建设置
- en: 'Wait until you’re able to see the following window in the bottom-left corner:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待直到你能在左下角看到以下窗口：
- en: Note
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If the window doesn’t pop up, you can open the window manually by opening `locals`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果窗口没有弹出，你可以通过打开`locals`手动打开窗口。
- en: '![Figure 2.5 – Visual Studio variable watch window ](img/Figure_2.05_B18531.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – Visual Studio变量监视窗口](img/Figure_2.05_B18531.jpg)'
- en: Figure 2.5 – Visual Studio variable watch window
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – Visual Studio变量监视窗口
- en: '`this` shows the object itself. The object contains variables and methods that
    it stores, and by expanding it, we’re able to see the state of the entire object
    and its variables at the current line of code execution.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`表示对象本身。对象包含它存储的变量和方法，通过展开它，我们能够看到当前代码执行行上整个对象及其变量的状态。'
- en: Expand `this`, then `ACharacter`, and then `CapsuleComponent`. Here, you can
    see the values for the `CapsuleHalfHeight = 88.0` and `CapsuleRadius = 34.0` variables.
    Next to line `18`, where the red dot initially was, you will see an arrow. This
    means that the code is at the end of line `17` and has not executed line `18`
    yet.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开`this`，然后是`ACharacter`，然后是`CapsuleComponent`。在这里，你可以看到`CapsuleHalfHeight =
    88.0`和`CapsuleRadius = 34.0`变量的值。在最初红色圆点所在的第`18`行旁边，你会看到一个箭头。这意味着代码在`17`行的末尾，并且还没有执行`18`行。
- en: 'Click the **Step Into** button to go to the next line of code (shortcut: *F11*).
    **Step Into** will move into code inside the function (if present) on the line.
    On the other hand, **Step Over** will just execute the current code and move to
    the next line. Since there is no function on the current line, **Step Into** will
    mimic the **Step Over** functionality:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**进入下一步**按钮进入下一行代码（快捷键：*F11*）。**进入下一步**会进入函数内部的代码（如果有的话）（如果当前行有函数，则**进入下一步**将模拟**进入下一步**的功能）：
- en: '![Figure 2.6 – Debug step into ](img/Figure_2.06_B18531.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6 – 调试进入](img/Figure_2.06_B18531.jpg)'
- en: Figure 2.6 – Debug step into
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 调试进入
- en: 'Notice that the arrow has moved to line `21` and that the variables have been
    updated. `CapsuleHalfHeight = 96.0` and `CapsuleRadius = 42.0` are highlighted
    in red. Also, notice that the `BaseTurnRate` variable has been initialized to
    `0.0`:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意到箭头已经移动到第`21`行，并且变量已经被更新。`CapsuleHalfHeight = 96.0`和`CapsuleRadius = 42.0`被红色突出显示。此外，注意`BaseTurnRate`变量已经被初始化为`0.0`：
- en: '![Figure 2.7 – BaseTurnRate initial value ](img/Figure_2.07_B18531.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 – BaseTurnRate初始值](img/Figure_2.07_B18531.jpg)'
- en: Figure 2.7 – BaseTurnRate initial value
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – BaseTurnRate初始值
- en: 'Step in (*F11*) once again to go to line `22`. Now, the `BaseTurnRate` variable
    has a value of `45.0`, and `BaseLookUpRate` has been initialized to `0.0`, as
    shown in the following screenshot:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次按(*F11*)进入，跳转到行`22`。现在，`BaseTurnRate`变量的值为`45.0`，而`BaseLookUpRate`已被初始化为`0.0`，如下截图所示：
- en: '![Figure 2.8 – BaseTurnRate updated value ](img/Figure_2.08_B18531.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8 – BaseTurnRate更新值](img/Figure_2.08_B18531.jpg)'
- en: Figure 2.8 – BaseTurnRate updated value
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – BaseTurnRate更新值
- en: Step in (*F11*) once again to go to line `27`. Now, the `BaseLookUpRate` variable
    has a value of `45.0`.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次按(*F11*)进入，跳转到行`27`。现在，`BaseLookUpRate`变量的值为`45.0`。
- en: Similarly, you are encouraged to step in and debug other sections of the code
    to not only familiarize yourself with the debugger but also to understand how
    the code works behind the scenes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，鼓励你进入并调试代码的其他部分，不仅为了熟悉调试器，而且为了理解代码背后的工作原理。
- en: By completing this exercise, you’ve learned how to set up debug points in Visual
    Studio, as well as stop debugging at a point, and then continue line by line while
    watching an object and its variable’s values. This is an important aspect for
    any developer, and many often use this tool to get rid of pesky bugs within code,
    especially when there are a lot of code flows and the number of variables is quite
    large.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你已经学会了如何在Visual Studio中设置调试点，以及在某个点停止调试，然后逐行查看对象及其变量的值。这对于任何开发者来说都是一个重要的方面，许多人经常使用这个工具来消除代码中的讨厌的bug，尤其是在代码流程很多且变量数量相当大时。
- en: 'At any point, you can stop debugging, restart debugging, or continue with the
    rest of the code by using the buttons on the top menu bar, as shown here:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时候，你可以通过使用顶部菜单栏上的按钮停止调试、重新启动调试或继续执行剩余的代码，如下所示：
- en: '![Figure 2.9 – Debugging tools in Visual Studio ](img/Figure_2.09_B18531.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9 – Visual Studio中的调试工具](img/Figure_2.09_B18531.jpg)'
- en: Figure 2.9 – Debugging tools in Visual Studio
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – Visual Studio中的调试工具
- en: Now, we’ll look at importing assets into an Unreal project.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将查看如何将资源导入到Unreal项目中。
- en: Importing the required assets
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入所需的资源
- en: Unreal Engine allows users to import a wide range of file types for users to
    customize their projects. There are several import options that developers can
    tweak and play around with to match their required settings.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal Engine允许用户导入多种文件类型，以便用户自定义他们的项目。开发者可以调整和尝试几种导入选项，以匹配他们所需的设置。
- en: Some common file types that game developers often import are FBX for scenes,
    meshes, animations (exported from Maya and other similar software), movie files,
    images (mostly for the user interface), textures, sounds, data in CSV files, and
    fonts. These files may be obtained from the Epic Marketplace or any other means
    (such as the internet) and used within the project.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开发者经常导入的一些常见文件类型包括FBX用于场景、网格、动画（从Maya和其他类似软件导出）、电影文件、图像（主要用于用户界面）、纹理、声音、CSV文件中的数据以及字体。这些文件可以从Epic
    Marketplace或其他途径（如互联网）获得，并在项目中使用。
- en: Assets can be imported by dragging and dropping them into the `Content` folder,
    or by clicking the **Import** button in the **Content Browser** area.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将资源拖放到`Content`文件夹中，或者通过在**内容浏览器**区域点击**导入**按钮来导入资源。
- en: Now let’s tackle an exercise where we’ll learn how to import FBX files and see
    how this is done.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来做一个练习，学习如何导入FBX文件，并看看这是如何完成的。
- en: Exercise 2.03 – importing a character FBX file
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.03 – 导入FBX角色文件
- en: This exercise will focus on importing a 3D model from an FBX file. FBX files
    are widely used to export and import 3D models, along with their materials, animations,
    and textures.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习将专注于从FBX文件中导入3D模型。FBX文件广泛用于导出和导入3D模型，包括其材质、动画和纹理。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: Download the `SK_Mannequin.FBX`, `ThirdPersonIdle.FBX`, `ThirdPersonRun.FBX`,
    and `ThirdPersonWalk.FBX` files from the `Chapter02` | `Exercise2.03` | `ExerciseFiles`
    directory, which can be found on GitHub.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从GitHub上的`Chapter02` | `Exercise2.03` | `ExerciseFiles`目录下载`SK_Mannequin.FBX`、`ThirdPersonIdle.FBX`、`ThirdPersonRun.FBX`和`ThirdPersonWalk.FBX`文件。
- en: Note
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `ExerciseFiles` directory can be found on GitHub at [https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter02/Exercise2.03/ExerciseFiles](https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter02/Exercise2.03/ExerciseFiles).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExerciseFiles` 目录可以在 GitHub 上找到，网址为 [https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter02/Exercise2.03/ExerciseFiles](https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter02/Exercise2.03/ExerciseFiles)。'
- en: Open the blank project we created in *Exercise 2.01 – creating an empty C++
    project*.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们在 *练习 2.01 – 创建一个空的 C++ 项目* 中创建的空白项目。
- en: 'In the **Content Browser** area of the project, click **Import**:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的 **内容浏览器** 区域中，点击 **导入**：
- en: '![Figure 2.10 – The Content Browser area’s Import button ](img/Figure_2.10_B18531.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.10 – 内容浏览器区域的导入按钮](img/Figure_2.10_B18531.jpg)'
- en: Figure 2.10 – The Content Browser area’s Import button
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – 内容浏览器区域的导入按钮
- en: Browse to the directory of the files we downloaded in *Step 1*, select `SK_Mannequin.FBX`,
    and click on the **Open** button.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到我们在 *步骤 1* 中下载的文件目录，选择 `SK_Mannequin.FBX`，然后点击 **打开** 按钮。
- en: Make sure that the **Import Animations** button is **unchecked** and click the
    **Import All** button. You may get a warning here stating that **There are no
    smoothing groups**. You can ignore this for now. With that, you have successfully
    imported a skeletal mesh from an FBX file. Now, we need to import its animations.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保将 **导入动画** 按钮取消选中，然后点击 **导入全部** 按钮。你可能会收到一个警告，指出 **没有平滑组**。现在你可以忽略这个警告。这样，你就成功从
    FBX 文件中导入了一个骨骼网格。现在，我们需要导入它的动画。
- en: Click the `ThirdPersonIdle.fbx`, `ThirdPersonRun.fbx`, and `ThirdPersonWalk.fbx`.
    Then, click on the **Open** button.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `ThirdPersonIdle.fbx`、`ThirdPersonRun.fbx` 和 `ThirdPersonWalk.fbx`。然后，点击
    **打开** 按钮。
- en: 'Make sure that the skeleton is set to the one you imported in *Step 5* and
    click **Import All**:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保骨骼设置为你在 *步骤 5* 中导入的那个，然后点击 **导入全部**：
- en: '![Figure 2.11 – FBX Import Options](img/Figure_2.11_B18531.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.11 – FBX 导入选项](img/Figure_2.11_B18531.jpg)'
- en: Figure 2.11 – FBX Import Options
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11 – FBX 导入选项
- en: Now, you will see the three animations (`ThirdPersonIdle`, `ThirdPersonRun`,
    and `ThirdPersonWalk`) inside the **Content Browser** area.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你将在 **内容浏览器** 区域看到三个动画（`ThirdPersonIdle`、`ThirdPersonRun` 和 `ThirdPersonWalk`）。
- en: 'If you double-click on `ThirdPersonIdle`, you’ll notice that the left arm is
    hanging down. This means that there’s a retargeting issue. When the animations
    are imported separately from the skeleton, the Unreal Engine internally maps all
    the bones from the animation to the skeleton. However, sometimes, that results
    in a glitch. Let’s resolve this:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你双击 `ThirdPersonIdle`，你会注意到左臂垂下来。这意味着存在重定向问题。当动画与骨骼分开导入时，虚幻引擎内部将所有动画骨骼映射到骨骼上。然而，有时这会导致故障。让我们解决这个问题：
- en: '![Figure 2.12 – ThirdPersonIdle UE4 mannequin animation glitch ](img/Figure_2.12_B18531.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.12 – 第三人称空闲 UE4 人偶动画故障](img/Figure_2.12_B18531.jpg)'
- en: Figure 2.12 – ThirdPersonIdle UE4 mannequin animation glitch
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12 – 第三人称空闲 UE4 人偶动画故障
- en: 'Open the `SK_Mannequin` Skeletal Mesh and open the **Skeleton Tree** tab if
    it wasn’t opened previously:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `SK_Mannequin` 骨骼网格，如果之前没有打开，请打开 **骨骼树** 标签页：
- en: '![Figure 2.13 – SK_Mannequin Skeleton Tree tab](img/Figure_2.13_B18531.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.13 – SK_Mannequin 骨骼树标签页](img/Figure_2.13_B18531.jpg)'
- en: Figure 2.13 – SK_Mannequin Skeleton Tree tab
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13 – SK_Mannequin 骨骼树标签页
- en: 'Under **Options**, enable the **Show Retargeting Options** setting:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **选项** 下，启用 **显示重定向选项** 设置：
- en: '![Figure 2.14 – Show Retargeting Options ](img/Figure_2.14_B18531.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.14 – 显示重定向选项](img/Figure_2.14_B18531.jpg)'
- en: Figure 2.14 – Show Retargeting Options
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.14 – 显示重定向选项
- en: Now, inside the skeleton tree, reduce the `spine_01`, `thigh_l`, and `thigh_r`
    bones to enable better visibility.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在骨骼树中，将 `spine_01`、`thigh_l` 和 `thigh_r` 骨折调整到适当大小以增强可见性。
- en: Now, select the `spine_01`, `thigh_l`, and `thigh_r` bones. Right-click on them
    and, in the menu, click the **Recursively Set Translation Retargeting Skeleton**
    button. This will fix the bone translation issues we encountered previously.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，选择 `spine_01`、`thigh_l` 和 `thigh_r` 骨折。右键单击它们，在菜单中点击 **递归设置平移重定向骨骼** 按钮。这将解决我们之前遇到的骨骼平移问题。
- en: 'Re-open the `ThirdPersonIdle` animation to verify the hanging arm has been
    fixed:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新打开 `ThirdPersonIdle` 动画以验证悬垂手臂已被修复：
- en: '![Figure 2.15 – Fixed ThirdPersonIdle animation ](img/Figure_2.15_B18531.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.15 – 修复后的 ThirdPersonIdle 动画](img/Figure_2.15_B18531.jpg)'
- en: Figure 2.15 – Fixed ThirdPersonIdle animation
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.15 – 修复后的 ThirdPersonIdle 动画
- en: Note
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the complete exercise code files on GitHub in the `Chapter02`
    | `Exercise2.03` | `Ex2.03-Completed.rar` directory by going to the following
    link: [https://packt.live/2U8AScR](https://packt.live/2U8AScR).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下链接访问GitHub上的完整练习代码文件，位于`Chapter02` | `Exercise2.03` | `Ex2.03-Completed.rar`目录：[https://packt.live/2U8AScR](https://packt.live/2U8AScR)。
- en: After extracting the `.rar` file, double-click the `.uproject` file. You will
    see a prompt asking `Would you like to rebuild now?`. Click `Yes` on that prompt
    so that it can build the necessary intermediate files, after which it should open
    the project in Unreal Editor automatically.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 解压`.rar`文件后，双击`.uproject`文件。您将看到一个提示要求“现在要重建吗？”。点击提示中的“是”，以便它构建必要的中间文件，之后应该会自动在Unreal编辑器中打开项目。
- en: By completing this exercise, you’ve understood how to import assets and, more
    specifically, imported an FBX skeletal mesh and animation data into your project.
    This is crucial for the workflows of many game developers as assets are the building
    blocks of the entire game.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你已经理解了如何导入资源，更具体地说，是将FBX骨骼网格和动画数据导入到你的项目中。这对于许多游戏开发者的工作流程至关重要，因为资源是整个游戏的基石。
- en: In the next section, we’ll look at the Unreal core classes for creating a game,
    how important they are for creating a game or experience, and how to use them
    inside a project.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨创建游戏所需的Unreal核心类，它们对于创建游戏或体验的重要性，以及如何在项目中使用它们。
- en: The Unreal Game Mode class
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unreal游戏模式类
- en: Consider a situation where you want to be able to pause your game. All the logic
    and implementation that’s required to be able to pause the game will be placed
    inside a single class. This class will be responsible for handling the game flow
    when a player enters the game. The game flow can be any action or a set of actions
    that occur in the game. For example, game pause, play, and restart are considered
    simple game flow actions. Similarly, in the case of a multiplayer game, we require
    all the network-related gameplay logic to be placed together. This is exactly
    what the Game Mode class is there for.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一种情况，你想能够暂停你的游戏。所有必要的逻辑和实现，以便能够暂停游戏，都将放置在一个单独的类中。这个类将负责处理玩家进入游戏时的游戏流程。游戏流程可以是游戏中的任何动作或一系列动作。例如，游戏暂停、播放和重新开始被认为是简单的游戏流程动作。同样，在多人游戏的情况下，我们需要将所有与网络相关的游戏逻辑放在一起。这正是游戏模式类存在的目的。
- en: Game Mode is a class that drives the game logic and imposes game-related rules
    on players. It essentially contains information about the current game being played,
    including gameplay variables and events, which will be mentioned later in this
    chapter. Game Mode can hold all the managers of the gameplay objects, it’s a singleton
    class, and it can be accessed by any object or abstract class present in the game.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏模式是一个驱动游戏逻辑并强制对玩家施加游戏相关规则的类。它本质上包含有关正在进行的当前游戏的信息，包括游戏变量和事件，这些将在本章后面提到。游戏模式可以包含所有游戏对象的管理器，它是一个单例类，并且可以被游戏中存在的任何对象或抽象类访问。
- en: As with all the other classes, the Game Mode class can be extended in Blueprints
    or C++. This can be done to include extra functionality and logic that may be
    required to keep players updated about what’s happening inside the game.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有其他类一样，游戏模式类可以在蓝图或C++中扩展。这可以做到包括可能需要包含的额外功能和逻辑，以使玩家了解游戏内部发生的情况。
- en: 'Let’s go over some example game logic that goes inside the Game Mode class:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一些在游戏模式类内部的示例游戏逻辑：
- en: Limiting the number of players that are allowed to enter the game
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制允许进入游戏玩家的数量
- en: Controlling the Spawn location and Player Controller logic of newly connected
    players
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制新连接玩家的出生点和玩家控制器逻辑
- en: Keeping track of the Game Score
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪游戏得分
- en: Keeping track of the Game Win/Lose condition
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪游戏胜利/失败条件
- en: Implementing the Game Over/Restart Game scenario
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现游戏结束/重新开始游戏场景
- en: In the next section, we will look at the default classes provided by Game Mode.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看游戏模式提供的默认类。
- en: Game Mode default classes
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏模式默认类
- en: 'In addition to itself, Game Mode uses several classes to implement game logic.
    It allows you to specify classes for its following defaults:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 除了自身之外，游戏模式使用几个类来实现游戏逻辑。它允许您指定以下默认类：
- en: '**Game Session Class**: Handles admin-level game flow such as login approval.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏会话类**：处理管理员级别的游戏流程，如登录批准。'
- en: '**Game State Class**: Handles the state of the game so that clients can see
    what’s going on inside the game.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏状态类**：处理游戏状态，以便客户端可以看到游戏内部发生的情况。'
- en: '**Player Controller Class**: The main class that’s used to possess and control
    a pawn. It can be thought of as a brain that decides what to do.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玩家控制器类**：用于控制角色的主要类。它可以被视为一个大脑，决定要做什么。'
- en: '**Player State Class**: Holds the current state of a player inside the game.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玩家状态类**：存储游戏内玩家的当前状态。'
- en: '**HUD Class**: Handles the user interface shown to the player.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户界面类**：处理显示给玩家的用户界面。'
- en: '**Default Pawn Class**: The main actor that the player controls. This is essentially
    the player character.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认角色类**：玩家控制的主要演员。这实际上是玩家角色。'
- en: '`DefaultPawn` class, the `SpectatorPawn` class specifies the pawn responsible
    for spectating the game.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DefaultPawn`类，`SpectatorPawn`类指定负责观看游戏的角色。'
- en: '**Replay Spectator Player Controller**: The Player Controller that’s responsible
    for manipulating the replay during playback, within the game.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回放观众玩家控制器**：负责在游戏回放期间操纵回放的玩家控制器。'
- en: '**Server Stat Replicator Class**: Responsible for replicating server stat net
    data.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器统计信息复制器类**：负责复制服务器统计信息网络数据。'
- en: You can either use the default classes as-is or you can specify your own for
    custom implementation and behavior. These classes will work in conjunction with
    Game Mode and will automatically run without being placed inside the world.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用默认类直接使用，或者指定自己的类以进行自定义实现和行为。这些类将与游戏模式协同工作，并会自动运行，无需放置在世界中。
- en: Gameplay events
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏事件
- en: In terms of a multiplayer game, when many players enter the game, it becomes
    essential to handle logic to allow them to enter the game and maintain their state,
    as well as viewing other players’ states and handling their interactions.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在多人游戏方面，当许多玩家进入游戏时，处理逻辑以允许他们进入游戏并保持他们的状态，以及查看其他玩家的状态和处理他们的交互变得至关重要。
- en: 'Game Mode provides you with several events that can be overridden to handle
    such multiplayer gameplay logic. The following events are especially useful for
    networking features and abilities (which they are mostly used for):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏模式为您提供了几个可以覆盖的事件，用于处理此类多人游戏逻辑。以下事件对于网络功能和能力特别有用（它们主要用于）：
- en: '`On Post Log In`: This event is called after the player is logged into the
    game successfully. From this point onward, it is safe to call replicated logic
    (used for networking in multiplayer games) on the `Player Controller` class.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`登录后执行`：此事件在玩家成功登录游戏后调用。从这一点开始，可以在`Player Controller`类上安全地调用复制逻辑（用于多人游戏中的网络）。'
- en: '`Handle Starting New Player`: This event is called after the `On Post Log In`
    event and can be used to define what happens to the newly entered player. By default,
    it creates a pawn for the newly connected player.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`处理新玩家启动`：此事件在`登录后执行`事件之后调用，可以用来定义新进入的玩家会发生什么。默认情况下，它为新连接的玩家创建一个角色。'
- en: '`SpawnDefaultPawnAtTransform`: This event triggers the actual pawn spawning
    within the game. Newly connected players can be spawned at particular transforms
    or at preset player start positions placed within the level (which can be added
    by dragging and dropping the `Player Start` from the **Models** window into the
    world).'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`在变换处生成默认角色`：此事件触发游戏中的实际角色生成。新连接的玩家可以在特定的变换处或预设的玩家起始位置（可以通过将**模型**窗口中的`Player
    Start`拖放到世界中添加）生成。'
- en: '`On Logout`: This event is called when a player leaves the game or is destroyed.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`登出时执行`：当玩家离开游戏或被销毁时调用此事件。'
- en: '`On Restart Player`: This event is called to respawn the player. Similar to
    `SpawnDefaultPawnAtTransform`, the player can be respawned at specific transforms
    or pre-specified locations (using the player start position).'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`重启玩家`：此事件用于重生玩家。类似于`SpawnDefaultPawnAtTransform`，玩家可以在特定的变换处或预指定的位置重生（使用玩家起始位置）。'
- en: Networking
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络通信
- en: The Game Mode class is not replicated to any clients or joined players. Its
    scope is only limited to the server where it is spawned. Essentially, the client-server
    model dictates that the clients only act as inputs within the game that is being
    played on the server. Therefore, the gameplay logic should not exist for the clients;
    it should only exist for the server.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏模式类不会复制到任何客户端或加入的玩家。其作用域仅限于在服务器上生成的地方。本质上，客户端-服务器模型规定客户端仅作为在服务器上玩的游戏的输入进行操作。因此，游戏逻辑不应存在于客户端；它应仅存在于服务器上。
- en: GameModeBase versus Game Mode
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GameModeBase与游戏模式
- en: From version 4.14 onward, Epic introduced the `AGameModeBase` class, which acts
    as the parent class for all Game Mode classes. It is essentially a simplified
    version of the `AGameMode` class.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 从4.14版本开始，Epic引入了`AGameModeBase`类，该类作为所有游戏模式类的父类。它本质上是一个`AGameMode`类的简化版本。
- en: However, the Game Mode class contains some additional functionality that is
    better suited for multiplayer shooter-type games as it implements the `Match State`
    concept. By default, the Game Mode Base is included in new template-based projects.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，游戏模式类包含一些额外的功能，这些功能更适合多人射击游戏，因为它实现了`Match State`概念。默认情况下，游戏模式基类包含在新模板项目的基础上。
- en: Game Mode also contains a State Machine that handles and keeps track of the
    player’s state.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏模式还包含一个状态机，用于处理和跟踪玩家的状态。
- en: Now that you have some understanding of Game Mode and its relevant classes,
    in the next section, you will learn about levels and the Level Blueprint, and
    how they tie to the Game Mode class.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对游戏模式和相关的类有了些了解，在下一节中，你将学习关于级别和级别蓝图，以及它们如何与游戏模式类相关联。
- en: Understanding levels and the Level Blueprint
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解级别和级别蓝图
- en: Levels, in gaming, are sections or parts of a game. Since many games are quite
    large, they are broken down into different levels. A level of interest is loaded
    into the game for the player to play. When they are done with that level, another
    level may be loaded in (while the current one will be loaded out) so that the
    player can proceed. To complete a game, a player usually needs to complete a set
    of specific tasks to move on to the next level, eventually completing the game.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，级别是游戏的部分或部分。由于许多游戏相当大，它们被分解成不同的级别。一个级别的兴趣被加载到游戏中供玩家游玩。当玩家完成该级别后，另一个级别可能会被加载进来（同时当前级别将被加载出去），以便玩家可以继续游戏。为了完成游戏，玩家通常需要完成一组特定的任务才能进入下一级别，最终完成游戏。
- en: A Game Mode can be directly applied to the level. The level, upon loading, will
    use the assigned Game Mode class to handle all the logic and gameplay for that
    particular level and override the game mode of the project for this level. This
    can be applied using the **World Settings** tab after opening a level.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏模式可以直接应用于级别。当级别加载时，它将使用分配的游戏模式类来处理该特定级别的所有逻辑和游戏玩法，并覆盖该级别的项目游戏模式。这可以通过在打开级别后使用**世界设置**选项卡来实现。
- en: A Level Blueprint is a Blueprint that runs within the level, but cannot be accessed
    outside the scope of the level. Game Mode can be accessed in any blueprint (including
    the Level Blueprint) by the `Get Game Mode` node. This can later be cast to your
    Game Mode class, to obtain a reference to it.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 级别蓝图是一个在级别内运行的蓝图，但不能在级别范围外访问。可以通过`Get Game Mode`节点在任何蓝图（包括级别蓝图）中访问游戏模式。这可以稍后转换为你的游戏模式类，以获取对其的引用。
- en: Note
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A level can only have one Game Mode class assigned to it. However, a single
    Game Mode class can be assigned to multiple levels to imitate similar functionality
    and logic.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一个级别只能分配一个游戏模式类。然而，一个游戏模式类可以被分配给多个级别，以模仿类似的功能和逻辑。
- en: The Unreal Pawn class
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unreal Pawn类
- en: The `Pawn` class, in Unreal, is the most basic class of actors that can be possessed
    (either by a player or AI). It also graphically represents the player/bot in the
    game. Code inside this class should have everything to do with the game entities,
    including interaction, movement, and ability logic. The player can still only
    possess a single pawn at any time in the game. Also, the player can *unpossess*
    one pawn and *possess* another pawn during gameplay.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unreal中，`Pawn`类是可以被控制（无论是玩家还是AI）的最基本的演员类。它还以图形方式表示游戏中的玩家/机器人。这个类内部的代码应该与游戏实体有关的一切，包括交互、移动和技能逻辑。在游戏中，玩家在任何时候只能控制一个`Pawn`。此外，玩家可以在游戏过程中*解除控制*一个`Pawn`并*控制*另一个`Pawn`。
- en: The DefaultPawn class
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认Pawn类
- en: Unreal Engine gives developers a `DefaultPawn` class (which inherits from the
    base `Pawn` class). On top of the `Pawn` class, this class contains additional
    code that allows it to move within the world, as you would in the editor version
    of the game.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal Engine为开发者提供了一个`DefaultPawn`类（它继承自基本`Pawn`类）。在`Pawn`类之上，这个类包含额外的代码，允许它在世界中移动，就像在游戏编辑器版本中一样。
- en: The Spectator Pawn class
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 观众Pawn类
- en: Some games offer features to spectate games. Let’s say you’re waiting for a
    friend to finish their game before joining you, so you go ahead and spectate their
    game. This allows you to observe the game the player is playing, through a camera
    that you can move around to get a view of the players or the game. Some games
    also offer spectate modes that can travel back in time, to show a particular action
    of the game that happened in the past or at any point in the game.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一些游戏提供观看游戏的功能。比如说，你正在等待一个朋友完成他们的游戏然后加入你，所以你先去观看他们的游戏。这允许你通过一个可以移动以获得玩家或游戏视图的相机来观察玩家正在玩的游戏。一些游戏还提供可以回溯时间的观看模式，以显示游戏过去发生的特定动作或游戏中的任何一点。
- en: As the name suggests, this is a special type of pawn that provides sample functionality
    to spectate a game. It contains all the basic tools (such as the Spectator Pawn
    Movement component) required to do so.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，这是一种特殊的兵类型，它提供了观看游戏的示例功能。它包含所有必需的基本工具（例如，观众兵移动组件），以便执行此操作。
- en: The Unreal Player Controller class
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unreal 玩家控制器类
- en: 'The Player Controller class can be thought of as the player. It is essentially
    the *soul* of a pawn. A Player Controller takes input from the user and feeds
    it to the pawn and other classes for the player to interact with the game. However,
    you must take note of the following points while dealing with this class:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家控制器类可以被视为玩家。它本质上是一个兵的 *灵魂*。玩家控制器从用户那里获取输入并将其传递给兵和其他类，以便玩家与游戏进行交互。然而，在处理这个类时，你必须注意以下几点：
- en: Unlike the pawn, there can only be one Player Controller that the player represents
    in a level. (This is just like when you travel in an elevator. While inside one,
    you can only control that elevator, but you can then exit it and enter another
    elevator to control that one.)
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与兵不同，在关卡中只能有一个玩家控制器代表玩家。（这就像当你乘坐电梯时一样。当你在一个电梯内时，你只能控制那个电梯，但你可以离开它并进入另一个电梯来控制那个电梯。）
- en: The Player Controller persists throughout the game, but the pawn may not (for
    example, in a battle game, the player character may die and respawn, but the Player
    Controller would remain the same).
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家控制器在整个游戏过程中持续存在，但兵可能不会（例如，在战斗游戏中，玩家角色可能会死亡并重生，但玩家控制器会保持不变）。
- en: Due to the temporary nature of the pawn and the permanent nature of the Player
    Controller, developers need to keep in mind which code should be added to which
    class.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于兵是临时的，而玩家控制器是永久的，开发者需要记住哪些代码应该添加到哪个类中。
- en: Let’s understand this better through the next exercise.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过下一个练习更好地理解这一点。
- en: Exercise 2.04 – setting up the Game Mode, Player Controller, and Pawn classes
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.04 – 设置游戏模式、玩家控制器和兵类
- en: This exercise will use the blank project we created in *Exercise 2.01 – creating
    an empty C++ project*. We’ll be adding our Game Mode, Player Controller, and `Pawn`
    classes to the game and testing if our code works in Blueprints.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习将使用我们在 *练习 2.01 – 创建一个空的 C++ 项目* 中创建的空白项目。我们将向游戏中添加我们的游戏模式、玩家控制器和 `Pawn`
    类，并测试我们的代码在蓝图中的工作情况。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: Open the project we created in *Exercise 2.01 – creating an empty C++ project*.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们在 *练习 2.01 – 创建一个空的 C++ 项目* 中创建的项目。
- en: Right-click inside the **Content Browser** area and select **Blueprint Class**.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **内容浏览器** 区域内右键单击并选择 **蓝图类**。
- en: 'Under the **ALL CLASSES** section, find and select **Game Mode**:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **所有类** 部分下，找到并选择 **游戏模式**：
- en: '![Figure 2.16 – Selecting the Game Mode class ](img/Figure_2.16_B18531.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.16 – 选择游戏模式类](img/Figure_2.16_B18531.jpg)'
- en: Figure 2.16 – Selecting the Game Mode class
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16 – 选择游戏模式类
- en: Set its name to `BP_MyGameMode`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其名称设置为 `BP_MyGameMode`。
- en: Repeat *steps 2* to *4* and select the `Pawn` class from under the `BP_MyPawn`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复 *步骤 2* 到 *4* 并从 `BP_MyPawn` 下选择 `Pawn` 类。
- en: 'Repeat *steps 2* to *4* and select the `Player Controller` class under the
    `BP_MyPC`:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复 *步骤 2* 到 *4* 并在 `BP_MyPC` 下选择 `Player Controller` 类：
- en: '![Figure 2.17 – Game Mode, Pawn, and Player Controller names ](img/Figure_2.17_B18531.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.17 – 游戏模式、兵和玩家控制器名称](img/Figure_2.17_B18531.jpg)'
- en: Figure 2.17 – Game Mode, Pawn, and Player Controller names
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.17 – 游戏模式、兵和玩家控制器名称
- en: 'Open `BP_MyGameMode` and open the **Event Graph** tab:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `BP_MyGameMode` 并打开 **事件图** 选项卡：
- en: '![Figure 2.18 – The Event Graph tab in Blueprint ](img/Figure_2.18_B18531.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.18 – 蓝图中的事件图选项卡](img/Figure_2.18_B18531.jpg)'
- en: Figure 2.18 – The Event Graph tab in Blueprint
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.18 – 蓝图中的事件图选项卡
- en: 'Left-click and drag from the white pin in the `Event BeginPlay` node and then
    release the *left mouse button* to open the `print` and select the `print` node
    highlighted in the list:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Event BeginPlay`节点中的白色针上左键单击并拖动，然后释放**左鼠标按钮**以打开`print`并选择列表中突出显示的`print`节点：
- en: '![Figure 2.19 – The Print String node (Blueprint) ](img/Figure_2.19_B18531.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.19 – 打印字符串节点（蓝图）](img/Figure_2.19_B18531.jpg)'
- en: Figure 2.19 – The Print String node (Blueprint)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.19 – 打印字符串节点（蓝图）
- en: In the resultant `Print String` node that gets placed under the `In String`
    parameter, type `My Game Mode has started!`.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在放置在`In String`参数下的结果`Print String`节点中，键入`My Game Mode has started!`。
- en: Now, press the **Compile** and **Save** buttons on the top menu bar.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，请在上面的菜单栏中按下**编译**和**保存**按钮。
- en: Repeat *steps 7* to *10* for both the `BP_MyPawn` and `BP_MyPC` classes, setting
    the `In String` parameter to `My Pawn has started!` and `My PC has started!`,
    respectively.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`BP_MyPawn`和`BP_MyPC`类，重复*步骤 7*到*10*，将`In String`参数分别设置为`My Pawn has started!`和`My
    PC has started!`。
- en: 'Finally, open the **World Settings** tab by clicking Settings on the right
    of the editor and clicking on **World Settings**:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过在编辑器的右侧单击设置并单击**世界设置**来打开**世界设置**选项卡：
- en: '![Figure 2.20 – World Settings ](img/Figure_2.20_B18531.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.20 – 世界设置](img/Figure_2.20_B18531.jpg)'
- en: Figure 2.20 – World Settings
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.20 – 世界设置
- en: 'Under the **Game Mode** section, use the dropdown to set the **GameMode Override**,
    **Default Pawn Class**, and **Player Controller Class** options to our respective
    classes:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**游戏模式**部分，使用下拉菜单将**游戏模式覆盖**、**默认角色类**和**玩家控制器类**选项设置为相应的类：
- en: '![Figure 2.21 – World Settings and Game Mode setup ](img/Figure_2.21_B18531.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.21 – 世界设置和游戏模式设置](img/Figure_2.21_B18531.jpg)'
- en: Figure 2.21 – World Settings and Game Mode setup
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.21 – 世界设置和游戏模式设置
- en: 'Click **Play** to play your game and see the three print statements on the
    top. This means that the current **GameMode Override**, **Default Pawn Class**,
    and **Player Controller Class** options have been set to your specified classes
    and are running their code:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**播放**来播放你的游戏，并查看顶部的三个打印语句。这意味着当前的**游戏模式覆盖**、**默认角色类**和**玩家控制器类**选项已设置为指定的类，并且正在运行它们的代码：
- en: '![Figure 2.22 – Output prints ](img/Figure_2.22_B18531.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.22 – 输出打印](img/Figure_2.22_B18531.jpg)'
- en: Figure 2.22 – Output prints
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.22 – 输出打印
- en: Note
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the completed exercise code files on GitHub, in the `Chapter02`
    | `Exercise2.04` | `Ex2.04-Completed.rar` directory, at [https://packt.live/3k7nS1K](https://packt.live/3k7nS1K).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上的`Chapter02` | `Exercise2.04` | `Ex2.04-Completed.rar`目录中找到完成的练习代码文件，网址为[https://packt.live/3k7nS1K](https://packt.live/3k7nS1K)。
- en: After extracting the `.rar` file, double-click the `.uproject` file. You will
    see a prompt asking `Would you like to rebuild now?`. Click `Yes` on that prompt
    so that it can build the necessary intermediate files, after which it should open
    the project in Unreal Editor automatically.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 解压`.rar`文件后，双击`.uproject`文件。你将看到一个提示要求`Would you like to rebuild now?`。在该提示中点击**是**，以便它构建必要的中间文件，之后它应该会自动在
    Unreal 编辑器中打开项目。
- en: Now that you know the basic classes and how they work in Unreal, in the next
    section, we will look at animations, what processes are involved, and how they
    complete them. We’ll follow this with an exercise.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了基本类及其在 Unreal 中的工作方式，在下一节中，我们将探讨动画，涉及哪些过程以及如何完成它们。之后，我们将进行一个练习。
- en: Working with animations
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动画
- en: Animation is essential for adding life and richness to a game. Superb animations
    are one of the major factors that differentiate average games from the good and
    the great from the best. Visual fidelity is what keeps gamers excited and immersed
    in games, and hence animations are a core part of all games and experiences created
    in Unreal Engine.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 动画对于为游戏增添生命和丰富性至关重要。出色的动画是区分普通游戏与优秀和卓越游戏的主要因素之一。视觉保真度是保持玩家对游戏兴奋和沉浸感的原因，因此动画是所有在
    Unreal Engine 中创建的游戏和体验的核心部分。
- en: Note
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This chapter seeks to cover animation basics. A more in-depth approach to animation
    will be taken in [*Chapter 11*](B18531_11.xhtml#_idTextAnchor222)*, Working with
    Blend Space 1D, Key Bindings, and State Machines*
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在介绍动画基础知识。更深入的方法将在[*第 11 章*](B18531_11.xhtml#_idTextAnchor222)*，使用 1D 混合空间、按键绑定和状态机*中进行。
- en: Animation Blueprints
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画蓝图
- en: An Animation Blueprint is a specific kind of blueprint that allows you to control
    the animation of a Skeletal Mesh. It provides users with a graph specifically
    for animation-related tasks. Here, you can define the logic for computing the
    poses of a skeleton.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 动画蓝图是一种特定的蓝图，允许您控制骨骼网格的动画。它为用户提供了一个专门用于动画相关任务的图形。在这里，您可以定义计算骨骼姿态的逻辑。
- en: Note
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A Skeletal Mesh is a skeleton-based mesh that contains bones, all of which come
    together to give form to the mesh, whereas a Static Mesh (as the name suggests)
    is an un-animatable mesh. Skeletal Meshes are normally used for characters and
    life-like objects (for example, a player hero), whereas Static Meshes are used
    for basic or lifeless objects (for example, a wall).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 骨骼网格是一种基于骨骼的网格，其中包含骨骼，所有骨骼共同作用以赋予网格形状，而静态网格（正如其名所示）是一种不可动画化的网格。骨骼网格通常用于角色和逼真的物体（例如，玩家英雄），而静态网格用于基本或无生命的物体（例如，墙壁）。
- en: 'Animation Blueprints provide two kinds of graphs: `EventGraph` and `AnimGraph`.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 动画蓝图提供两种类型的图：`EventGraph`和`AnimGraph`。
- en: Event Graph
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件图
- en: 'The Event Graph within an Animation Blueprint provides setup events related
    to animations, as we learned in *Chapter 1*, *Introduction to Unreal Engine*,
    that can be used for variable manipulation and logic. Event graphs are mostly
    used within Animation Blueprints to update Blend Space values, which, in turn,
    drive the animations within `AnimGraph`. The most common events that are used
    here are as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 动画蓝图中的事件图提供了与动画相关的设置事件，正如我们在*第一章*，*Unreal Engine 简介*中学到的，可用于变量操作和逻辑。事件图主要用于动画蓝图内更新混合空间值，这反过来又驱动了`AnimGraph`中的动画。这里使用最常见的事件如下：
- en: '`Event Blueprint Initialize Animation`: Used to initialize the animation.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Event Blueprint Initialize Animation`：用于初始化动画。'
- en: '`Event Blueprint Update Animation`: This event is executed every frame, allowing
    developers to perform calculations and update its values as required:'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Event Blueprint Update Animation`：此事件每帧执行一次，允许开发者执行计算并按要求更新其值：'
- en: '![Figure 2.23 – Animation Event Graph ](img/Figure_2.23_B18531.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.23 – 动画事件图](img/Figure_2.23_B18531.jpg)'
- en: Figure 2.23 – Animation Event Graph
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.23 – 动画事件图
- en: In the preceding screenshot, you can see the default Event Graph. The `Event
    Blueprint Update Animation` and `Try Get Pawn Owner` nodes are here. You created
    new nodes and appended them to a graph to complete some meaningful tasks in *Exercise
    2.04 – setting up the Game Mode, Player Controller, and Pawn classes*.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，您可以看到默认的事件图。这里包含了`Event Blueprint Update Animation`和`Try Get Pawn
    Owner`节点。您创建了新的节点并将它们附加到图中以完成*练习 2.04 – 设置游戏模式、玩家控制器和角色类*中的某些有意义任务。
- en: The Anim Graph
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画图
- en: The Anim Graph is dedicated to and responsible for playing animations and outputting
    the final pose of the skeleton on a per-frame basis. It provides developers with
    special nodes to execute different logic. For example, the `Blend` node takes
    in multiple inputs and is used to decide which input is currently being used in
    the execution. This decision is usually dependent on some external input (such
    as an alpha value).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 动画图专门用于播放动画并在每帧基础上输出骨骼的最终姿态。它为开发者提供了执行不同逻辑的特殊节点。例如，`Blend`节点接受多个输入，并用于决定当前正在执行的输入。这个决定通常依赖于某些外部输入（例如，alpha值）。
- en: The Anim Graph works by evaluating nodes by following the flow of execution
    between the exec pins on the nodes being used.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 动画图通过评估节点，按照节点上使用的执行引脚之间的执行流程来工作。
- en: 'In the following screenshot, you can see a single `Output Pose` node on the
    graph. This is the final pose output of the animation that will be visible on
    the relevant Skeletal Mesh within the game. We will be using this in *Exercise
    2.05 – creating a mannequin animation*:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您可以看到图中的一个单独的`Output Pose`节点。这是动画的最终姿态输出，将在游戏中的相关骨骼网格上可见。我们将在*练习 2.05
    – 创建木偶动画*中使用它：
- en: '![Figure 2.24 – Animation AnimGraph ](img/Figure_2.24_B18531.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.24 – 动画 AnimGraph](img/Figure_2.24_B18531.jpg)'
- en: Figure 2.24 – Animation AnimGraph
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.24 – 动画 AnimGraph
- en: State Machines
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态机
- en: You have already learned how animation nodes and logic can be set up, but one
    essential component is missing. Who decides when a particular animation or piece
    of logic should play or execute? This is where State Machines come into the picture.
    For example, a player may need to shift from crouching to a standing pose, so
    the animation needs to be updated. The code will call the Animation Blueprint,
    access the State Machine, and let it know that the state of the animation needs
    to be changed, resulting in a smooth animation transition.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学习了如何设置动画节点和逻辑，但还缺少一个基本组件。谁决定特定的动画或逻辑何时应该播放或执行？这就是状态机发挥作用的地方。例如，玩家可能需要从蹲姿切换到站立姿势，因此动画需要更新。代码将调用动画蓝图，访问状态机，并让它知道动画的状态需要改变，从而实现平滑的动画转换。
- en: A State Machine consists of states and rules that can be thought of as depicting
    the state of an animation. A State Machine can always be in one state at a particular
    time. A transition from one state to another is carried out when certain conditions
    (which are defined by rules) are met.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机由状态和规则组成，可以将其视为描述动画的状态。状态机在特定时间总处于一个状态。当满足某些条件（由规则定义）时，从一个状态到另一个状态的转换就会执行。
- en: Transition Rules
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换规则
- en: 'Each Transition Rule contains a Boolean node called `Result`. If the Boolean
    is true, the transition can occur and vice versa:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 每个转换规则都包含一个名为 `Result` 的布尔节点。如果布尔值为真，则可以发生转换，反之亦然：
- en: '![Figure 2.25 – Transition Rules ](img/Figure_2.25_B18531.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图2.25 – 转换规则](img/Figure_2.25_B18531.jpg)'
- en: Figure 2.25 – Transition Rules
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.25 – 转换规则
- en: Blend Spaces
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合空间
- en: When you’re provided with a bunch of animations, you can create a State Machine
    and run those animations. However, a problem is presented when you need to transition
    from one animation to another. If you simply switch the animation, it will glitch
    since the new animation’s starting pose might be different from the old animation’s
    ending pose.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当你提供了一组动画时，你可以创建一个状态机并运行这些动画。然而，当你需要从一个动画转换到另一个动画时，会出现问题。如果你简单地切换动画，由于新动画的起始姿势可能与旧动画的结束姿势不同，它将出现故障。
- en: Blend Spaces are special assets that are used to interpolate between different
    animations based on their alpha values. This, in turn, removes the glitch issue
    and interpolates between the two animations, causing a swift and smooth change
    in animation.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 混合空间是特殊资产，用于根据它们的alpha值在不同的动画之间进行插值。这反过来消除了故障问题，并在两个动画之间进行插值，导致动画快速而平滑地变化。
- en: Blend Spaces are created either in one dimension, known as a Blend Space 1D,
    or two dimensions, known as a Blend Space. These blend any number of animations
    based on one or two input(s), respectively.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 混合空间可以创建在一维，称为混合空间1D，或二维，称为混合空间。它们分别基于一个或两个输入（参数）混合任意数量的动画。
- en: Exercise 2.05 – creating a mannequin animation
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 练习2.05 – 创建一个人体模型动画
- en: Now that you’ve gone through most of the concepts related to animations, we’ll
    be diving in hands-on by adding some animation logic to the default mannequin.
    We’ll be creating a Blend Space 1D, a State Machine, and Animation logic.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了与动画相关的多数概念，我们将通过向默认人体模型添加一些动画逻辑来亲自动手。我们将创建一个混合空间1D、一个状态机和动画逻辑。
- en: Our goal here is to create a running animation of our characters and thus gain
    insight into how animations work, as well as the way they are bound to the actual
    character in a 3D world.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是创建一个角色跑步动画，从而深入了解动画的工作原理，以及它们如何在3D世界中绑定到实际角色上。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: Download and extract all the contents of the `Chapter02` | `Exercise2.05` |
    `ExerciseFiles` directory, which can be found on GitHub. You can extract this
    to any directory you’re comfortable with using on your machine.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并解压 `Chapter02` | `Exercise2.05` | `ExerciseFiles` 目录的所有内容，该目录可以在GitHub上找到。您可以将这些内容解压到您在计算机上使用的任何目录中。
- en: Note
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `ExerciseFiles` directory can be found on GitHub at the following link:
    [https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter02/Exercise2.05/ExerciseFiles](https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter02/Exercise2.05/ExerciseFiles).'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExerciseFiles` 目录可以在以下链接的GitHub上找到：[https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter02/Exercise2.05/ExerciseFiles](https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter02/Exercise2.05/ExerciseFiles)。'
- en: Double-click the `CharAnim.uproject` file to start the project.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击 `CharAnim.uproject` 文件以启动项目。
- en: Press **Play**. Use the keyboard’s *W*, *A*, *S*, and *D* keys to move and the
    spacebar to jump. Notice that, currently, there are no animations on the mannequin.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 **播放**。使用键盘的 *W*、*A*、*S* 和 *D* 键进行移动，使用空格键跳跃。注意，目前，模特上没有动画。
- en: In the `Content` folder, browse to `Content` | `Mannequin` | `Animations`.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Content` 文件夹中，浏览到 `Content` | `Mannequin` | `Animations`。
- en: Right-click the `Content` folder and, from the `Animation` section, select `Blend
    Space 1D`.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 `Content` 文件夹，然后从 `Animation` 部分选择 `Blend Space 1D`。
- en: Select `UE4_Mannequin_Skeleton`.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `UE4_Mannequin_Skeleton`。
- en: Rename the newly created file `BS_IdleRun`.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新创建的文件重命名为 `BS_IdleRun`。
- en: Double-click `BS_IdleRun` to open it.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击 `BS_IdleRun` 以打开它。
- en: 'Under the `Speed` and `375.0`:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Speed` 和 `375.0` 下方：
- en: '![Figure 2.26 – Blend Space 1D – Axis Settings](img/Figure_2.26_B18531.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.26 – Blend Space 1D – 轴设置](img/Figure_2.26_B18531.jpg)'
- en: Figure 2.26 – Blend Space 1D – Axis Settings
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.26 – Blend Space 1D – 轴设置
- en: Go to the `5.0`.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到 `5.0`。
- en: 'Drag and drop the `ThirdPersonIdle`, `ThirdPersonWalk`, and `ThirdPersonRun`
    animations into the graph separately:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分别将 `ThirdPersonIdle`、`ThirdPersonWalk` 和 `ThirdPersonRun` 动画拖放到图中：
- en: '![Figure 2.27 – Blend Space previewer ](img/Figure_2.27_B18531.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.27 – Blend Space 预览器](img/Figure_2.27_B18531.jpg)'
- en: Figure 2.27 – Blend Space previewer
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.27 – Blend Space 预览器
- en: 'In the **Asset Details** tab, under **Blend Samples**, set the following variable
    values:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **资产详情** 选项卡下，在 **Blend 样本** 中设置以下变量值：
- en: '![Figure 2.28 – Blend Samples ](img/Figure_2.28_B18531.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.28 – Blend 样本](img/Figure_2.28_B18531.jpg)'
- en: Figure 2.28 – Blend Samples
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.28 – Blend 样本
- en: Click **Save** and close this **Asset**.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **保存** 并关闭此 **资产**。
- en: Right-click inside the `Content` folder and, from the `Animation Blueprint`.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 `Content` 文件夹，然后从 `Animation Blueprint`。
- en: 'In the `UE4_Mannequin_Skeleton` and then click the **OK** button:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `UE4_Mannequin_Skeleton` 中然后点击 **确定** 按钮：
- en: '![Figure 2.29 – Creating the Animation Blueprint asset ](img/Figure_2.29_B18531.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.29 – 创建动画蓝图资产](img/Figure_2.29_B18531.jpg)'
- en: Figure 2.29 – Creating the Animation Blueprint asset
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.29 – 创建动画蓝图资产
- en: Name the file `Anim_Mannequin` and press *Enter*.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件命名为 `Anim_Mannequin` 并按 *Enter*。
- en: Double-click the newly created `Anim_Mannequin` file.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击新创建的 `Anim_Mannequin` 文件。
- en: Next, go to the **Event Graph** tab.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到 **Event Graph** 选项卡。
- en: 'Create a `boolean` variable called `IsInAir?` by clicking the **+** icon in
    the variable section on the bottom left-hand side. Be sure to assign the proper
    type:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击左下角的变量部分中的 **+** 图标创建一个名为 `IsInAir?` 的布尔变量。务必分配正确的类型：
- en: '![Figure 2.30 – Adding variables ](img/Figure_2.30_B18531.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.30 – 添加变量](img/Figure_2.30_B18531.jpg)'
- en: Figure 2.30 – Adding variables
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.30 – 添加变量
- en: Create a float variable called `Speed`.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Speed` 的浮点变量。
- en: 'Drag off the `Try Get Pawn Owner` return value node and type `Is Valid`. Select
    the bottom one:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Try Get Pawn Owner` 返回值节点拖出，并输入 `Is Valid`。选择下面的一个：
- en: '![Figure 2.31 – Event Graph Is Valid node ](img/Figure_2.31_B18531.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.31 – 事件图 Is Valid 节点](img/Figure_2.31_B18531.jpg)'
- en: Figure 2.31 – Event Graph Is Valid node
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.31 – 事件图 Is Valid 节点
- en: 'Connect the `Exec` pin from the `Event Blueprint Update Animation` node to
    the `Is Valid` node:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Event Blueprint Update Animation` 节点的 `Exec` 插针连接到 `Is Valid` 节点：
- en: '![Figure 2.32 – Connecting nodes](img/Figure_2.32_B18531.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.32 – 连接节点](img/Figure_2.32_B18531.jpg)'
- en: Figure 2.32 – Connecting nodes
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.32 – 连接节点
- en: From the `Try Get Pawn Owner` node, use the `Get Movement Component` node.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Try Get Pawn Owner` 节点，使用 `Get Movement Component` 节点。
- en: 'From the node obtained in *step 22*, get the `Is Falling` node and connect
    the Boolean return value to a set node for the `Is in Air?` Boolean. Connect the
    `SET` node exec pin to the `Is Valid` exec pin:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从步骤 22 中获得的节点获取 `Is Falling` 节点，并将布尔返回值连接到 `Is in Air?` 布尔设置的节点。将 `SET` 节点的执行插针连接到
    `Is Valid` 执行插针：
- en: '![Figure 2.33 – Is in Air Boolean setup](img/Figure_2.33_B18531.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.33 – 在空中布尔设置](img/Figure_2.33_B18531.jpg)'
- en: Figure 2.33 – Is in Air Boolean setup
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.33 – 在空中布尔设置
- en: 'From the `Try Get Pawn Owner` node, use the `Get Velocity` node, get its `VectorLength`,
    and connect the output to the `A Variable Set` node of `Speed`:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Try Get Pawn Owner` 节点，使用 `Get Velocity` 节点，获取其 `VectorLength`，并将输出连接到 `Speed`
    的 `A Variable Set` 节点：
- en: '![Figure 2.34 – Speed Boolean setup ](img/Figure_2.34_B18531.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.34 – 速度布尔设置](img/Figure_2.34_B18531.jpg)'
- en: Figure 2.34 – Speed Boolean setup
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.34 – 速度布尔设置
- en: Next, go to the **Anim Graph** tab.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到 **Anim Graph** 选项卡。
- en: 'Right-click anywhere inside `state machine`, and click on **Add New State Machine**:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 `state machine` 内的任何位置，然后点击 **添加新状态机**：
- en: '![Figure 2.35 – The Add New State Machine option ](img/Figure_2.35_B18531.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.35 – 添加新状态机的选项](img/Figure_2.35_B18531.jpg)'
- en: Figure 2.35 – The Add New State Machine option
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.35 – 添加新状态机的选项
- en: Make sure that the node is selected and press *F2* to rename it `MannequinStateMachine`.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保节点被选中，然后按 *F2* 键将其重命名为 `MannequinStateMachine`。
- en: 'Connect the output pin of `MannequinStateMachine` to the input pin of the `Output
    Pose` node and click the **compile** button on the top bar:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `MannequinStateMachine` 的输出引脚连接到 `Output Pose` 节点的输入引脚，并点击顶部栏上的 **编译** 按钮：
- en: '![Figure 2.36 – Configuring the State Machine result in the Output Pose node
    ](img/Figure_2.36_B18531.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.36 – 在输出姿态节点中配置状态机结果](img/Figure_2.36_B18531.jpg)'
- en: Figure 2.36 – Configuring the State Machine result in the Output Pose node
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.36 – 在输出姿态节点中配置状态机结果
- en: Double-click the `MannequinstateMachine` node to enter the State Machine. You
    will see an `Entry` node. The state that will be connected to it will become the
    default state of the mannequin. In this exercise, this will be our `Idle Animation`.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击 `MannequinstateMachine` 节点进入状态机。您将看到一个 `Entry` 节点。将要连接到它的状态将成为模型的默认状态。在这个练习中，这将是我们
    `Idle Animation`。
- en: Right-click on an empty area inside the State Machine and, from the menu, select
    `Idle/Run`.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在状态机内部空白区域右键单击，从菜单中选择 `Idle/Run`。
- en: 'Drag from the icon next to the `Entry` text, point it inside the `Idle/Run`
    node, and then release it to connect it:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Entry` 文字旁边的图标拖动，指向 `Idle/Run` 节点内部，然后释放以连接它：
- en: '![Figure 2.37 – Connecting Added State to Entry ](img/Figure_2.37_B18531.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.37 – 将附加状态连接到入口](img/Figure_2.37_B18531.jpg)'
- en: Figure 2.37 – Connecting Added State to Entry
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.37 – 将附加状态连接到入口
- en: Double-click on the `Idle/Run` state to open it.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击 `Idle/Run` 状态以打开它。
- en: 'From the `BS_IdleRun` animation onto the graph. Get the `Speed` variable from
    the **Variable** section on the left and connect it, as shown here:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `BS_IdleRun` 动画到图中。从左侧的 **变量** 部分获取 `Speed` 变量并将其连接，如图所示：
- en: '![Figure 2.38 – Idle/Run state setup ](img/Figure_2.38_B18531.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.38 – 空闲/运行状态设置](img/Figure_2.38_B18531.jpg)'
- en: Figure 2.38 – Idle/Run state setup
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.38 – 空闲/运行状态设置
- en: 'Head back to `MannequinStateMachine` by clicking on its breadcrumb in the top
    banner:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击顶部横幅中的其面包屑回到 `MannequinStateMachine`：
- en: '![Figure 2.39 – State Machine navigation breadcrumb](img/Figure_2.39_B18531.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.39 – 状态机导航面包屑](img/Figure_2.39_B18531.jpg)'
- en: Figure 2.39 – State Machine navigation breadcrumb
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.39 – 状态机导航面包屑
- en: From the `ThirdPersonJump_Start` animation into the graph. Rename it `Jump_Start`.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `ThirdPersonJump_Start` 动画到图中。将其重命名为 `Jump_Start`。
- en: 'Repeat *step 35* for `ThirdPersonJump_Loop` and `ThirdPerson_Jump` and rename
    them `Jump_Loop` and `Jump_End`, respectively:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 `ThirdPersonJump_Loop` 和 `ThirdPerson_Jump` 重复 *步骤 35* 并分别重命名为 `Jump_Loop`
    和 `Jump_End`：
- en: '![Figure 2.40 – State setup ](img/Figure_2.40_B18531.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.40 – 状态设置](img/Figure_2.40_B18531.jpg)'
- en: Figure 2.40 – State setup
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.40 – 状态设置
- en: Open the `Jump_Start` state. Click on the `Play ThirdPersonJump_Start` node.
    *Uncheck* `Loop Animation` in the `Settings` section.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Jump_Start` 状态。点击 `Play ThirdPersonJump_Start` 节点。在 `设置` 部分取消勾选 `Loop Animation`。
- en: Open the `Jump_Loop` state and click on the `Play ThirdPersonJump_Loop` node.
    Set `Play Rate` to `0.75`.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Jump_Loop` 状态并点击 `Play ThirdPersonJump_Loop` 节点。将 `Play Rate` 设置为 `0.75`。
- en: Open the `Jump_End` state and click on the `Play ThirdPerson_Jump` node. *Uncheck*
    the `Loop Animation` Boolean.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Jump_End` 状态并点击 `Play ThirdPerson_Jump` 节点。取消勾选布尔值 `Loop Animation`。
- en: Since we can shift from `Idle/Run` to `Jump_Start`, drag from the `Idle/Run`
    state and drop it to the `Jump_Start` state. Similarly, `Jump_Start` leads to
    `Jump_Loop`, then to `Jump_End`, and finally back to `Idle/Run`.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们可以从 `Idle/Run` 切换到 `Jump_Start`，从 `Idle/Run` 状态拖动并将其放到 `Jump_Start` 状态。同样，`Jump_Start`
    引导到 `Jump_Loop`，然后到 `Jump_End`，最后回到 `Idle/Run`。
- en: 'Drag and drop the arrows to set up the State Machine, as follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 拖放箭头以设置状态机，如下所示：
- en: '![Figure 2.41 – State connections ](img/Figure_2.41_B18531.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.41 – 状态连接](img/Figure_2.41_B18531.jpg)'
- en: Figure 2.41 – State connections
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.41 – 状态连接
- en: 'Double-click the `Idle/Run` to `Jump_Start` transition rule icon and connect
    the output of the `Is in Air?` variable to the result:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击 `Idle/Run` 到 `Jump_Start` 转换规则图标，并将 `Is in Air?` 变量的输出连接到结果：
- en: '![Figure 2.42 – Idle/Run to Jump_Start transition rule setup ](img/Figure_2.42_B18531.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.42 – 空闲/运行到 Jump_Start 转换规则设置](img/Figure_2.42_B18531.jpg)'
- en: Figure 2.42 – Idle/Run to Jump_Start transition rule setup
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.42 – 空闲/运行到 Jump_Start 转换规则设置
- en: 'Open the `Jump_Start` to `Jump_Loop` transition rule. Get the `Time Remaining
    (ratio)` node for `ThirdPersonJump_Start` and check whether it is less than `0.1`.
    Connect the resulting bool to the result:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开从 `Jump_Start` 到 `Jump_Loop` 的转换规则。获取 `ThirdPersonJump_Start` 的 `Time Remaining
    (ratio)` 节点并检查它是否小于 `0.1`。将得到的布尔值连接到结果：
- en: '![Figure 2.43 – Jump_Start to Jump_End transition rule setup ](img/Figure_2.43_B18531.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![图2.43 – 从 Jump_Start 到 Jump_End 转换规则设置](img/Figure_2.43_B18531.jpg)'
- en: Figure 2.43 – Jump_Start to Jump_End transition rule setup
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.43 – 从 Jump_Start 到 Jump_End 转换规则设置
- en: 'Open the `Jump_Loop` to `Jump_End` transition rule. Connect the output of the
    inverse of the `Is in Air?` variable to the result:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开从 `Jump_Loop` 到 `Jump_End` 的转换规则。将 `Is in Air?` 变量的逆输出连接到结果：
- en: '![Figure 2.44 – Jump_Loop to Jump_End transition rule setup ](img/Figure_2.44_B18531.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![图2.44 – 从 Jump_Loop 到 Jump_End 转换规则设置](img/Figure_2.44_B18531.jpg)'
- en: Figure 2.44 – Jump_Loop to Jump_End transition rule setup
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.44 – 从 Jump_Loop 到 Jump_End 转换规则设置
- en: 'Open the `Jump_End` to `Idle/Run` transition rule. Get the `Time Remaining
    (ratio)` node for `ThirdPerson_Jump` and check whether it is less than `0.1`.
    Connect the resulting bool to the result:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开从 `Jump_End` 到 `Idle/Run` 的转换规则。获取 `ThirdPerson_Jump` 的 `Time Remaining (ratio)`
    节点并检查它是否小于 `0.1`。将得到的布尔值连接到结果：
- en: '![Figure 2.45 – Jump_End to Idle/Run transition rule setup ](img/Figure_2.45_B18531.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![图2.45 – 从 Jump_End 到 Idle/Run 转换规则设置](img/Figure_2.45_B18531.jpg)'
- en: Figure 2.45 – Jump_End to Idle/Run transition rule setup
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.45 – 从 Jump_End 到 Idle/Run 转换规则设置
- en: Close the Animation Blueprint.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭动画蓝图。
- en: In the `Content` folder, browse to `Content` | `ThirdPersonBP` | `Blueprints`
    and open the `ThirdPersonCharacter` Blueprint.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Content` 文件夹中，浏览到 `Content` | `ThirdPersonBP` | `Blueprints` 并打开 `ThirdPersonCharacter`
    蓝图。
- en: 'Select `Mesh` in the **Components** tab:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **组件** 选项卡中选择 `Mesh`：
- en: '![Figure 2.46 – The Mesh component ](img/Figure_2.46_B18531.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![图2.46 – 网格组件](img/Figure_2.46_B18531.jpg)'
- en: Figure 2.46 – The Mesh component
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.46 – 网格组件
- en: 'In the `Animation Blueprint` class that you created:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你创建的 `Animation Blueprint` 类中：
- en: '![Figure 2.47 – Specifying the Animation Blueprint in the Skeletal Mesh component
    ](img/Figure_2.47_B18531.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![图2.47 – 在骨骼网格组件中指定动画蓝图](img/Figure_2.47_B18531.jpg)'
- en: Figure 2.47 – Specifying the Animation Blueprint in the Skeletal Mesh component
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.47 – 在骨骼网格组件中指定动画蓝图
- en: Close the Blueprint.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭蓝图。
- en: Play the game again and notice the animations.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次玩游戏并注意动画。
- en: 'You should have achieved the following output. As you can see, our character
    is running, and the running animation is being shown:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经实现了以下输出。如图所示，我们的角色正在跑步，并且正在显示跑步动画：
- en: '![Figure 2.48 – Character running animation ](img/Figure_2.48_B18531.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![图2.48 – 角色跑步动画](img/Figure_2.48_B18531.jpg)'
- en: Figure 2.48 – Character running animation
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.48 – 角色跑步动画
- en: Note
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the complete exercise code files on GitHub, in the `Chapter02`
    | `Exercise2.05` | `Ex2.05-Completed.rar` directory at [https://packt.live/3kdIlSL](https://packt.live/3kdIlSL).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上的 `Chapter02` | `Exercise2.05` | `Ex2.05-Completed.rar` 目录中找到完整的练习代码文件，链接为
    [https://packt.live/3kdIlSL](https://packt.live/3kdIlSL)。
- en: After extracting the `.rar` file, double-click the `.uproject` file. You will
    see a prompt asking `Would you like to rebuild now?`. Click `Yes` on that prompt
    so that it can build the necessary intermediate files, after which it should open
    the project in Unreal Editor automatically.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 解压 `.rar` 文件后，双击 `.uproject` 文件。你将看到一个提示要求 `Would you like to rebuild now?`。点击该提示中的
    `Yes`，以便它构建必要的中间文件，之后它应该会自动在 Unreal 编辑器中打开项目。
- en: By completing this exercise, you’ve understood how to create State Machines,
    a Blend Space 1D, an Animation Blueprint, and how to tie it all together with
    the Skeletal Mesh of a character. You’ve also worked on play rates, transitional
    speed, and the transitional states, helping you understand how the world of animation
    intricately ties in together.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你了解了如何创建状态机、1D 混合空间、动画蓝图，以及如何将它们与角色的骨骼网格结合在一起。你还处理了播放速率、过渡速度和过渡状态，帮助你理解动画世界的复杂联系。
- en: We kicked off this section by understanding how State Machines are used to represent
    and transition in-between Animation States. Next, we learned how a Blend Space
    1D gives us blending in-between those transitions. All this is used by the Animation
    Blueprint to decide what the current animation of the character is. Now, let’s
    combine all these concepts in an activity.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从这个部分开始，通过了解状态机如何表示和在不同动画状态之间转换来启动本节。接下来，我们学习了如何使用一维混合空间在这些转换之间进行混合。所有这些都被动画蓝图用来决定角色的当前动画。现在，让我们在一个活动中结合所有这些概念。
- en: Activity 2.01 – linking animations to a character
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动二.01 – 将动画链接到角色
- en: Let’s say, as an Unreal games developer, you’ve been provided with a character
    Skeletal Mesh and its animations, and you’ve been tasked with integrating them
    inside a project. To do that, in this activity, you’ll be creating an Animation
    Blueprint, State Machines, and a Blend Space 1D of a new character. By completing
    this activity, you should be able to work with animations in Unreal Engine and
    link them to Skeletal Meshes.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，作为一个虚幻游戏开发者，你被提供了一个角色骨骼网格及其动画，并且你被分配了一个将它们集成到项目中的任务。为了做到这一点，在这个活动中，你将创建一个新角色的动画蓝图、状态机和一维混合空间。通过完成这个活动，你应该能够使用虚幻引擎中的动画并将它们链接到骨骼网格。
- en: This activity’s project folder contains a `Ganfault`.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的项目文件夹包含一个 `Ganfault`。
- en: Note
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'This character and its animations were downloaded from [mixamo.com](http://mixamo.com).
    These have been placed in the `Content` |`Ganfault` folder of this book’s GitHub
    repository: [https://packt.live/35eCGrk](https://packt.live/35eCGrk).'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这个角色及其动画是从 [mixamo.com](http://mixamo.com) 下载的。这些已经被放置在本书的GitHub仓库的 `内容` | `Ganfault`
    文件夹中：[https://packt.live/35eCGrk](https://packt.live/35eCGrk)。
- en: '*Mixamo.com* is a website that sells 3D characters with animations and is sort
    of an asset marketplace for 3D models. It also contains a library of free models,
    alongside the paid ones.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '*Mixamo.com* 是一个销售带有动画的3D角色的网站，它类似于3D模型的资产市场。它还包含了一个免费模型库，以及付费模型。'
- en: 'Follow these steps to complete this activity:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个活动：
- en: Create a Blend Space 1D for the Walking/Running animation and set up the Animation
    Blueprint.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为行走/跑步动画创建一个一维混合空间并设置动画蓝图。
- en: Next, go to `Content` | `ThirdPersonBP` | `Blueprints` and open the `ThirdPersonCharacter`
    Blueprint.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到 `内容` | `ThirdPersonBP` | `蓝图` 并打开 `ThirdPersonCharacter` 蓝图。
- en: Click the Skeletal Mesh component on the left and, inside the `SkeletalMesh`
    reference with `Ganfault`.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧的骨骼网格组件，并在 `SkeletalMesh` 引用中的 `Ganfault` 内部。
- en: Similarly, update the `Ganfault`.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，更新 `Ganfault`。
- en: Note
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For the State Machine, only implement Idle/Run and Jump State.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 对于状态机，只需实现空闲/跑和跳跃状态。
- en: 'Once you’ve completed this activity, the Walk/Run and Jump animations should
    be working properly, as shown in the following output:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了这个活动，行走/跑步和跳跃动画应该能够正常工作，如下面的输出所示：
- en: '![Figure 2.49 – Activity 2.01 expected output (left: Run; right: Jump) ](img/Figure_2.49_B18531.jpg)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![图2.49 – 活动二.01预期输出（左：跑；右：跳）](img/Figure_2.49_B18531.jpg)'
- en: 'Figure 2.49 – Activity 2.01 expected output (left: Run; right: Jump)'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.49 – 活动二.01预期输出（左：跑；右：跳）
- en: Note
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found on GitHub here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在GitHub上找到：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).
- en: By completing this activity, you now know how to navigate Unreal Engine for
    the project, debug code, and work with animations. You also understand State Machines,
    which represent transitions between the Animation States and the Blend Spaces
    1D that are used in that transition. You can now add animation to 3D models based
    on gameplay events and inputs.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个活动，你现在知道如何导航虚幻引擎的项目、调试代码以及处理动画。你还理解了状态机，它表示动画状态之间的转换以及在该转换中使用的1D混合空间。你现在可以根据游戏事件和输入向3D模型添加动画。
- en: Summary
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to create an empty project. Then, we learned
    about the folder structure and how to organize files in the project directory.
    After that, we looked at template-based projects. We learned how to set breakpoints
    in code so that we can watch variable values and debug entire objects while the
    game is running, which would help us find and eradicate bugs in our code.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何创建一个空项目。然后，我们了解了文件夹结构以及如何在项目目录中组织文件。之后，我们探讨了基于模板的项目。我们学习了如何在代码中设置断点，以便在游戏运行时观察变量值和调试整个对象，这有助于我们找到并消除代码中的错误。
- en: Thereafter, we saw how Game Mode, Player Pawn, and Player Controller are relevant
    classes that are used in Unreal Engine for setting up game flows (the execution
    order of code), as well as how they are set up inside a project.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们看到了Game Mode、Player Pawn和Player Controller是如何相关的类，它们在Unreal Engine中用于设置游戏流程（代码的执行顺序），以及它们如何在项目中设置。
- en: Finally, we looked at animation basics and worked with State Machines, Blend
    Spaces 1D, and Animation Blueprints to make our character animate (walk/run and
    jump) within the game according to the keyboard input.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了动画基础知识，并使用状态机、一维混合空间和动画蓝图来使我们的角色根据键盘输入在游戏中进行动画（行走/跑步和跳跃）。
- en: Throughout this chapter, we became more familiar with the powerful tools in
    Unreal Engine that are essential for game development. Unreal’s Game Mode and
    its default classes are required to make any kind of game or experience in Unreal
    Engine. Additionally, animations bring life to your character and help add layers
    of immersion to your games. All game studios have animations, characters, and
    game logic since these are the core components that drive any game. These skills
    will help you numerous times throughout your game development journey.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们更加熟悉了Unreal Engine中用于游戏开发的重要强大工具。Unreal的Game Mode及其默认类是制作任何类型的游戏或体验在Unreal
    Engine中必需的。此外，动画为你的角色带来生命，并有助于为你的游戏增加沉浸感。所有游戏工作室都有动画、角色和游戏逻辑，因为这些是驱动任何游戏的核心组件。这些技能将在你的游戏开发之旅中多次帮助你。
- en: In the next chapter, we will talk about the `Character` class in Unreal Engine,
    its components, and how to extend the class for additional setup. You’ll be working
    on various exercises, followed by an activity.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论Unreal Engine中的`Character`类，其组件以及如何扩展该类以进行额外设置。你将进行各种练习，然后是一个活动。
