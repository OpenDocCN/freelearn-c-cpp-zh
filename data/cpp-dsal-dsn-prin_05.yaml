- en: 5\. Greedy Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 贪婪算法
- en: Learning Objectives
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够：
- en: Describe the greedy approach to algorithm design
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述算法设计的贪婪方法
- en: Identify the optimal substructure and greedy choice properties of a problem
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别问题的最优子结构和贪婪选择属性
- en: Implement greedy algorithms such as fractional knapsack and greedy graph coloring
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现贪婪算法，如分数背包和贪婪图着色
- en: Implement Kruskal's Minimum Spanning Tree algorithm using a disjoint-set data
    structure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不相交集数据结构实现Kruskal的最小生成树算法
- en: In this chapter, we will look at various 'greedy' approaches to algorithm design
    and see how they can be applied in order to solve real-world problems.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究各种用于算法设计的“贪婪”方法，并看看它们如何应用于解决现实世界的问题。
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: 'In the previous chapter, we discussed the divide-and-conquer algorithm design
    technique, which solves a given problem by dividing the input into smaller subproblems,
    solving each subproblem, and subsequently merging the results. Continuing our
    theme of algorithm design paradigms, we will now look at our next topic: the **greedy
    approach**.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了分治算法设计技术，该技术通过将输入分解为较小的子问题，解决每个子问题，然后合并结果来解决给定问题。继续我们的算法设计范式主题，我们现在将看看我们的下一个主题：**贪婪方法**。
- en: 'On each iteration, a greedy algorithm is one that picks the ''seemingly best''
    alternative. In other words, a greedy solution to a problem composes a globally
    optimal solution to the given problem from a series of locally optimal solutions.
    For example, the following screenshot shows the shortest path that a car can take
    from Dulles International Airport in Washington DC to an office building in East
    Riverdale. Naturally, the path shown is also the shortest for any two points on
    the path that are not the starting and ending points:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代中，贪婪算法是选择“看似最佳”替代方案的算法。换句话说，问题的贪婪解决方案由一系列局部最优解组成，从而构成了给定问题的全局最优解。例如，以下屏幕截图显示了一辆汽车从华盛顿特区杜勒斯国际机场到东里弗代尔办公大楼的最短路径。自然地，所示路径也是任何不是起点和终点的路径上任意两点的最短路径：
- en: '![Figure 5.1: A route from an airport to an office in Washington DC (Source:
    project-osrm.org)](img/C14498_05_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1：从机场到华盛顿特区办公室的路线（来源：project-osrm.org）](img/C14498_05_01.jpg)'
- en: 'Figure 5.1: A route from an airport to an office in Washington DC (Source:
    project-osrm.org)'
  id: totrans-12
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.1：从机场到华盛顿特区办公室的路线（来源：project-osrm.org）
- en: 'Therefore, we can infer that the whole shortest path, P, is, in effect, a concatenation
    of several shortest paths between the vertices of the road network that lie along
    P. So, if we were asked to design a shortest path algorithm, one possible strategy
    would be as follows: start from the origin vertex and draw a path to the closest
    vertex that hasn''t been explored yet, and then repeat until we reach the destination
    vertex. Congratulations – you have just solved the shortest path problem using
    Dijkstra''s algorithm, which is the same one that powers commercial software such
    as Google Maps and Bing Maps!'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以推断整个最短路径P实际上是沿P的道路网络顶点之间的几条最短路径的连接。因此，如果我们被要求设计一个最短路径算法，一种可能的策略是：从起点顶点开始，绘制一条到尚未探索的最近顶点的路径，然后重复直到到达目标顶点。恭喜
    - 您刚刚使用Dijkstra算法解决了最短路径问题，这也是商业软件如Google Maps和Bing Maps使用的算法！
- en: Expectedly, the simple approach taken by greedy algorithms makes them applicable
    only to a small subset of algorithmic problems. However, the simplicity of the
    greedy approach often makes it an excellent tool for 'first attack', by which
    we can understand the properties and behavior of the underlying problem, which
    can then be solved using other, more complex approaches.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 可以预料到，贪婪算法采用的简单方法使它们只适用于算法问题的一小部分。然而，贪婪方法的简单性通常使它成为“第一攻击”的绝佳工具，通过它我们可以了解底层问题的属性和行为，然后可以使用其他更复杂的方法来解决问题。
- en: In this chapter, we will study the conditions under which a given problem is
    suitable for a greedy solution – the optimal substructure and greedy choice properties.
    We will see that when a problem can be shown to have these two properties, a greedy
    solution is guaranteed to yield the correct results. We will also see a few examples
    of real-world problems for which greedy solutions are used in practice, and we
    will end this chapter with a discussion of the minimum spanning tree problem,
    which commonly arises in cases of telecommunication and water supply networks,
    electrical grids, and circuit design. But first, let's start by taking a look
    at some simpler problems that can be solved using greedy algorithms.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究给定问题适合贪婪解决方案的条件 - 最优子结构和贪婪选择属性。我们将看到，当问题可以证明具有这两个属性时，贪婪解决方案保证产生正确的结果。我们还将看到一些实际中使用贪婪解决方案的示例，最后我们将讨论最小生成树问题，这在电信和供水网络、电网和电路设计中常见。但首先，让我们从一些可以使用贪婪算法解决的更简单的问题开始。
- en: Basic Greedy Algorithms
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本贪婪算法
- en: 'In this section, we will study two standard problems that can be solved using
    the greedy approach: **shortest-job-first scheduling** and the **fractional knapsack**
    problem.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习可以使用贪婪方法解决的两个标准问题：**最短作业优先调度**和**分数背包**问题。
- en: Shortest-Job-First Scheduling
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最短作业优先调度
- en: Say you are standing in a queue at your bank. It's a busy day and there are
    *N* people in the queue, but the bank has only one counter open (it's also a really
    bad day!). Let's assume that it takes a person, *p**i*, the amount of time of
    *a**i* to get served at the counter. Since the people in the queue are quite rational,
    everyone agrees to reorder their places in the queue so that the *average waiting
    time* for everyone in the queue is minimized. You are tasked with finding a way
    of reordering the people in the queue. How would you solve this problem?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你站在银行的队列中。今天很忙，队列中有*N*个人，但银行只开了一个柜台（今天也是个糟糕的日子！）。假设一个人*p**i*在柜台上被服务需要*a**i*的时间。由于队列中的人都很理性，每个人都同意重新排队，以使得队列中每个人的*平均等待时间*最小化。你的任务是找到一种重新排队的方法。你会如何解决这个问题？
- en: '![Figure 5.2: The original queue](img/C14498_05_02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2：原始队列](img/C14498_05_02.jpg)'
- en: 'Figure 5.2: The original queue'
  id: totrans-21
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.2：原始队列
- en: To take this problem apart further, let's look at an example. The preceding
    figure shows an example of the original queue, where *A**i* shows the service
    time and *W**i* shows the waiting time for the *i**th* person. The person closest
    to the counter can start getting served immediately, so the waiting time for them
    is 0\. The person who's second in the queue must wait until the first person is
    done, so they have to wait for *a**1* *= 8* units of time before getting served.
    Continuing in a similar fashion, the *i**th* person has a waiting time equal to
    the sum of the service times for all of the *i – 1* people before them in the
    queue.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步分解这个问题，让我们看一个例子。前面的图示显示了原始队列的一个例子，其中*A**i*表示服务时间，*W**i*表示第*i*个人的等待时间。离柜台最近的人可以立即开始被服务，所以他们的等待时间为0。队列中第二个人必须等到第一个人完成，所以他们必须等待*a**1*
    *= 8*单位时间才能被服务。以类似的方式继续，第*i*个人的等待时间等于队列中他们之前的*i – 1*个人的服务时间之和。
- en: 'A clue to solving this problem is as follows: since we are looking to minimize
    the *average waiting time*, we must find a way to reduce the waiting time for
    the largest possible set of people, as much as possible. One way to reduce the
    waiting time for all people is the job that can be completed the quickest. By
    repeating this idea for all the people in the queue, our solution results in the
    following reordered queue:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的线索如下：由于我们希望最小化*平均等待时间*，我们必须找到一种方法来尽可能减少最大可能的一组人的等待时间。减少所有人的等待时间的一种方法是完成时间最短的工作。通过对队列中的所有人重复这个想法，我们的解决方案导致了以下重新排序后的队列：
- en: '![Figure 5.3: The reordered queue with the minimum average waiting time](img/C14498_05_03.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3：重新排序后的队列，平均等待时间最短](img/C14498_05_03.jpg)'
- en: 'Figure 5.3: The reordered queue with the minimum average waiting time'
  id: totrans-25
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.3：重新排序后的队列，平均等待时间最短
- en: Notice that our reordered queue has an average waiting time of 8.87 units versus
    15.25 units for the original ordering, which is an improvement by a factor of
    approximately 2.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们重新排序后的队列的平均等待时间为8.87单位，而原始排序的平均等待时间为15.25单位，这是一个大约2倍的改进。
- en: 'Exercise 24: Shortest-Job-First Scheduling'
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习24：最短作业优先调度
- en: 'In this exercise, we will implement a shortest-job-first scheduling solution
    by taking a similar example to the one shown in the preceding figure. We will
    consider 10 people in a queue and try to minimize the average waiting time for
    all of them. Let''s get started:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将通过一个类似于前面图示的示例来实现最短作业优先调度解决方案。我们将考虑队列中的10个人，并尝试最小化所有人的平均等待时间。让我们开始吧：
- en: 'Begin by adding the required headers and creating functions for computing the
    waiting times and input/output:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先添加所需的头文件并创建用于计算等待时间和输入/输出的函数：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the main solver and driver code, as shown here:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加主求解器和驱动代码，如下所示：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Compile and run the code! Your output should look as follows:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行代码！你的输出应该如下所示：
- en: '![Figure 5.4: Output of the program to schedule the shortest job first](img/C14498_05_04.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4：调度最短作业的程序输出](img/C14498_05_04.jpg)'
- en: 'Figure 5.4: Output of the program to schedule the shortest job first'
  id: totrans-35
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.4：调度最短作业的程序输出
- en: The Knapsack Problem(s)
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背包问题
- en: In this section, we will discuss the standard **knapsack problem**, also known
    as the 0-1 knapsack problem, which is known to be NP-complete, and thereby does
    not allow us to have any polynomial-time solution. Then, we will turn our discussion
    toward a version of the knapsack problem called the **fractional knapsack problem**,
    which can be solved using a greedy approach. Our focus in this section is to demonstrate
    how even subtle differences between how a problem is defined can lead to large
    changes in the solution strategies.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论标准的**背包问题**，也称为0-1背包问题，它被认为是NP完全的，因此不允许我们有任何多项式时间的解决方案。然后，我们将把讨论转向背包问题的一个版本，称为**分数背包问题**，它可以使用贪婪方法来解决。本节的重点是演示问题定义方式的细微差别如何导致解决方案策略的巨大变化。
- en: The Knapsack Problem
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 背包问题
- en: Suppose you are given a set of objects, *O = {O**1**, O**2**, …, O**n**}*, with
    each having a certain weight, *W**i*, and a value of *V**i**.* You are also given
    a bag (or a knapsack) that can carry only a total weight of T units. Now, say
    you are tasked with finding out about a set of objects to keep in your bag so
    that the total weight is less than or equal to T, and the total value of the objects
    is the maximum it can possibly be.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一组物体，*O = {O**1**, O**2**, …, O**n**}*, 每个物体都有一个特定的重量 *W**i* 和价值 *V**i*。你还有一个只能携带总重量为T单位的袋子（或者背包）。现在，假设你的任务是找出一组物体放入你的袋子中，使得总重量小于或等于T，并且物体的总价值尽可能最大。
- en: A real-world example of this problem can be understood if you imagine a traveling
    trader who earns a fixed percentage profit on all their trades. They would want
    to carry the maximum value of goods to maximize their profit, but their vehicle
    (or knapsack) can hold only up to T units of weight. The trader knows the exact
    weight and value of each object. Which set of objects should they carry so that
    the total value of the objects carried for trade is the maximum possible?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果想象一个旅行商人，他在所有交易中都能获得固定百分比的利润，就可以理解这个问题的现实世界例子。他想携带最大价值的商品以最大化利润，但他的车辆（或背包）最多只能承载T单位的重量。商人知道每个物品的确切重量和价值。他应该携带哪组物品，以便携带的物品的总价值是可能的最大值？
- en: '![Figure 5.5: The knapsack problem](img/C14498_05_05.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图5.5：背包问题](img/C14498_05_05.jpg)'
- en: 'Figure 5.5: The knapsack problem'
  id: totrans-42
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.5：背包问题
- en: The problem that's presented in the preceding figure is the well-known knapsack
    problem and has been proven to be NP-complete. In other words, there is no known
    polynomial-time solution to this problem. As a result, we must look at all the
    possible combinations of the objects to find the combination that has the greatest
    value while having a total weight of only *T* units. The preceding diagram shows
    two ways a knapsack with a capacity of 8 units can be filled. The objects shown
    in grey are the ones that have been chosen to be put in the knapsack. We can see
    that the first set of objects has a total value of 40, the second set of objects
    has a total value of 37, and that the total weight in both cases is 8 units. Therefore,
    the second set of objects is a better choice than the first. To find the best
    possible set of objects, we must list all possible combinations and choose the
    one with the maximum value.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面图中呈现的问题是著名的背包问题，已被证明是NP完全的。换句话说，目前没有已知的多项式时间解决方案。因此，我们必须查看所有可能的物品组合，以找到价值最大且总重量仅为*T*单位的组合。前面的图表显示了填充容量为8单位的背包的两种方式。灰色显示的物品是被选择放入背包的物品。我们可以看到第一组物品的总价值为40，第二组物品的总价值为37，而在两种情况下的总重量均为8单位。因此，第二组物品比第一组更好。为了找到最佳的物品组合，我们必须列出所有可能的组合，并选择具有最大价值的组合。
- en: The Fractional Knapsack Problem
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分数背包问题
- en: 'Now, we will make a small change to the knapsack problem that was given in
    the previous subsection: let''s say we are now allowed to break each object into
    as many parts as we need, and then we can choose what fraction of each object
    we want to keep in the knapsack.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将对前面小节中给出的背包问题进行一点改动：假设我们现在可以将每个物品分成我们需要的任意部分，然后我们可以选择要在背包中保留每个物品的什么比例。
- en: In terms of the real-world analogy, let's say that the trader in our previous
    analogy is trading items such as oil, grains, and flour. The trader may take any
    smaller measure of weight.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 就现实世界的类比而言，假设我们之前的类比中的交易商正在交易石油、谷物和面粉等物品。交易商可以取任何较小的重量。
- en: 'Contrary to the NP-completeness of the standard knapsack, the fractional knapsack
    problem has a simple solution: order the elements according to their value per
    weight ratio and ''greedily'' choose as many objects as possible with the maximum
    ratio. The following figure shows the optimal selection of a given set of objects
    when the knapsack''s capacity is set to 8 units. Notice that the chosen objects
    are the ones with the highest value per weight ratio:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准背包问题的NP完全性相反，分数背包问题有一个简单的解决方案：根据它们的价值/重量比对元素进行排序，并“贪婪地”选择尽可能多的具有最大比率的物品。下图显示了在背包容量设置为8单位时给定一组物品的最佳选择。请注意，所选的物品是具有最高价值/重量比的物品。
- en: '![Figure 5.6: The fractional knapsack problem](img/C14498_05_06.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图5.6：分数背包问题](img/C14498_05_06.jpg)'
- en: 'Figure 5.6: The fractional knapsack problem'
  id: totrans-49
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.6：分数背包问题
- en: We will implement this solution in the following exercise.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的练习中实现这个解决方案。
- en: 'Exercise 25: Fractional Knapsack Problem'
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习25：分数背包问题
- en: 'In this exercise, we will consider 10 items and try to maximize the value in
    our knapsack, which can hold a maximum weight of 25 units. Let''s get started:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将考虑10个物品，并尝试最大化我们的背包中的价值，背包最大承重为25单位。让我们开始吧：
- en: 'First, we will begin by adding the required headers and defining an `Object`
    struct that will represent one object in our solution:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将添加所需的头文件并定义一个`Object`结构，它将代表我们解决方案中的一个物品：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that we have overloaded the `<` and `==` operators since we will use `std::sort()`
    over a vector of `objects`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经重载了`<`和`==`运算符，因为我们将在`objects`的向量上使用`std::sort()`。
- en: 'The code for the fractional knapsack solver is as follows:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分数背包求解器的代码如下：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding function sorts the objects in decreasing order of their value/weight
    ratio and then picks all the fractions of objects that can fit in the knapsack
    until the knapsack is full.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数按照价值/重量比的递减顺序对物品进行排序，然后选择所有可以放入背包的物品的分数，直到背包装满为止。
- en: 'Finally, to test our implementation, add the following test and driver code:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了测试我们的实现，添加以下测试和驱动代码：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding function creates objects and initializes them with random data
    from the STL random number generator. Next, it calls our implementation of the
    fractional knapsack solver and then displays the results.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数创建物品并使用STL随机数生成器中的随机数据对其进行初始化。接下来，它调用我们的分数背包求解器的实现，然后显示结果。
- en: 'Compile and run this code! Your output should look as follows:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行此代码！您的输出应如下所示：
- en: '![Figure 5.7: Output of Exercise 25](img/C14498_05_07.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图5.7：练习25的输出](img/C14498_05_07.jpg)'
- en: 'Figure 5.7: Output of Exercise 25'
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.7：练习25的输出
- en: Note how the solver took a fraction, that is, only 4 of the 5 units of the last
    object by weight. This is an example of how objects can be partitioned before
    being chosen to be kept in the knapsack, which differentiates the fractional knapsack
    from the 0-1 (standard) knapsack problem.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意求解器如何取了一个分数，也就是说，只取了最后一个物体的5个单位中的4个单位。这是一个例子，说明在被选择放入背包之前，物体可以被分割，这使得分数背包问题与0-1（标准）背包问题有所不同。
- en: 'Activity 11: The Interval Scheduling Problem'
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动11：区间调度问题
- en: Imagine that you have a set of tasks on your to-do list (doing the dishes, going
    to the supermarket to buy groceries, working on a secret project for world domination,
    and other similar chores). Each task is identified by an ID and can be completed
    only between a particular start and end time. Let's say you wish to complete the
    maximum number of tasks. On what subset, and in what order, should you work on
    your tasks to achieve your objective? Assume that you can work on only one task
    at any point in time.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的待办事项清单上有一系列任务（洗碗、去超市买食品、做一个世界统治的秘密项目等类似的琐事）。每个任务都有一个ID，并且只能在特定的开始和结束时间之间完成。假设你希望完成尽可能多的任务。你应该在哪个子集上，以及以什么顺序，来完成你的任务以实现你的目标？假设你一次只能完成一个任务。
- en: 'As an example, consider the problem instance shown in the following figure.
    We have been given four different tasks that we could possibly spend our time
    working on (the rectangular boxes represent the time interval in which the task
    can be completed):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑下图中显示的问题实例。我们有四个不同的任务，可能花费我们的时间来完成（矩形框表示任务可以完成的时间间隔）：
- en: '![Figure 5.8: Given task schedules](img/C14498_05_08.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图5.8：给定任务安排](img/C14498_05_08.jpg)'
- en: 'Figure 5.8: Given task schedules'
  id: totrans-70
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.8：给定任务安排
- en: 'The following figure shows the optimal scheduling of tasks, which maximizes
    the total number of tasks completed:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了任务的最佳调度，最大化完成的任务总数：
- en: '![Figure 5.9: Optimal selection of tasks](img/C14498_05_09.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图5.9：任务的最佳选择](img/C14498_05_09.jpg)'
- en: 'Figure 5.9: Optimal selection of tasks'
  id: totrans-73
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.9：任务的最佳选择
- en: Notice how not completing task 3 allows us to complete tasks 1 and 2 instead,
    increasing the total number of completed tasks. In this activity, you will need
    to implement this greedy interval scheduling solution.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，不完成任务3使我们能够完成任务1和2，增加了完成任务的总数。在这个活动中，你需要实现这个贪婪的区间调度解决方案。
- en: 'The high-level steps for solving this activity are as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个活动的高层步骤如下：
- en: Assume that each task has a start time, an end time, and an ID. Create a struct
    that describes a task. We will represent different tasks with different instances
    of this struct.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设每个任务都有一个开始时间、一个结束时间和一个ID。创建一个描述任务的结构体。我们将用这个结构体的不同实例表示不同的任务。
- en: Implement a function that creates an `std::list` of N tasks, set their IDs sequentially
    from 1 to N, and use the values from a random number generator for the start and
    end times.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个函数，创建一个包含N个任务的`std::list`，将它们的ID从1到N依次设置，并使用随机数生成器的值作为开始和结束时间。
- en: 'Implement the scheduling function as follows:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式实现调度函数：
- en: a. Sort the list of tasks in increasing order of their ending times.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: a. 按照它们的结束时间递增的顺序对任务列表进行排序。
- en: b. Greedily choose to complete the task with the earliest ending time.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: b. 贪婪地选择完成最早结束的任务。
- en: c. Remove all the tasks that overlap with the currently chosen task (all the
    tasks that start before the current task ends).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: c. 删除所有与当前选择的任务重叠的任务（所有在当前任务结束之前开始的任务）。
- en: d. If tasks remain on the list, go to *step b*. Otherwise, return the chosen
    vector of tasks.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: d. 如果任务列表中仍有任务，转到*步骤b*。否则，返回所选的任务向量。
- en: 'Your final output should look similar to the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你的最终输出应该类似于以下内容：
- en: '![Figure 5.10: Expected output of Activity 11](img/C14498_05_10.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图5.10：活动11的预期输出](img/C14498_05_10.jpg)'
- en: 'Figure 5.10: Expected output of Activity 11'
  id: totrans-85
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.10：活动11的预期输出
- en: Note
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 516.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第516页找到。
- en: Requirements for Greedy Algorithms
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 贪婪算法的要求
- en: 'In the previous section, we looked at examples of problems where the greedy
    approach gives optimal solutions. However, a problem can be optimally solved using
    the greedy approach if and only if it has two properties: the **optimal substructure**
    property and the **greedy choice** property. In this section, we will attempt
    to understand these properties and show you how to identify whether a problem
    exhibits them.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们看了一些问题的例子，贪婪方法给出了最优解。然而，只有当一个问题具有两个属性时，贪婪方法才能给出最优解：**最优子结构**属性和**贪婪选择**属性。在本节中，我们将尝试理解这些属性，并向你展示如何确定一个问题是否具有这些属性。
- en: '**Optimal substructure**: When an optimal solution to a given problem, P, is
    composed of the optimal solutions to its subproblems, then P is said to have an
    optimal substructure.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**最优子结构**：当给定问题P的最优解由其子问题的最优解组成时，P被认为具有最优子结构。'
- en: '**Greedy choice**: When an optimal solution to a given problem, P, can be reached
    by selecting the locally optimal solution on each iteration, P is said to have
    the greedy choice property.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**贪婪选择**：当给定问题P的最优解可以通过在每次迭代中选择局部最优解来达到时，P被认为具有贪婪选择属性。'
- en: To understand the optimal substructure and greedy choice properties, we will
    implement Kruskal's minimum spanning tree algorithm.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解最优子结构和贪婪选择属性，我们将实现Kruskal的最小生成树算法。
- en: The Minimum Spanning Tree (MST) Problem
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最小生成树（MST）问题
- en: 'The minimum spanning tree problem can be stated as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最小生成树问题可以陈述如下：
- en: '*"Given a graph, G = < V, E >, where V is the set of vertices and E is the
    set of edges, each associated with an edge weight, find a tree, T, that spans
    all the vertices in V and has the minimum total weight."*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: “给定一个图G = <V，E>，其中V是顶点集，E是边集，每个边关联一个边权重，找到一棵树T，它跨越V中的所有顶点，并且具有最小的总权重。”
- en: A real-life application of the MST problem is the design of water supply and
    transportation networks since the designers typically wish to minimize the total
    length of the pipeline that's used or the roads that are created and still make
    sure that the services reach all designated users. Let's try to take the problem
    apart with the following example.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: MST问题的一个现实应用是设计供水和交通网络，因为设计者通常希望最小化使用的管道总长度或创建的道路总长度，并确保服务能够到达所有指定的用户。让我们尝试通过以下示例来解决这个问题。
- en: 'Let''s say that you are given the locations of 12 villages on a map and are
    asked to find the minimum total length of road that would need to be built so
    that all the villages are reachable from one another, and that the roads do not
    form a cycle. Assume that each road can be traversed in either direction. A natural
    representation of villages in this problem is using a graph data structure. Let''s
    assume that the vertices of the following graph, *G* represent the locations of
    the 12 given villages and that the edges of *G* represent the distances between
    the vertices:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你被给定地图上12个村庄的位置，并被要求找到需要修建的道路的最小总长度，以便所有村庄彼此可达，并且道路不形成循环。假设每条道路都可以双向行驶。这个问题中村庄的自然表示是使用图数据结构。假设以下图G的顶点代表12个给定村庄的位置，图G的边代表顶点之间的距离：
- en: '![Figure 5.11: Graph G representing the villages and distances between them](img/C14498_05_11.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图5.11：代表村庄和它们之间距离的图G](img/C14498_05_11.jpg)'
- en: 'Figure 5.11: Graph G representing the villages and distances between them'
  id: totrans-99
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.11：代表村庄和它们之间距离的图G
- en: 'A simple greedy algorithm to construct the minimum spanning tree, T, could
    be as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 构建最小生成树T的一个简单贪婪算法可能如下：
- en: Add all the edges of *G* in a min-heap, *H*.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图G的所有边添加到最小堆H中。
- en: From *H*, pop an edge, *e*. Naturally, *e* has the minimum cost among all edges
    in *H*.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从H中弹出一条边e。显然，e在H中的所有边中具有最小成本。
- en: If both vertices of *e* are already in *T*, this means that adding *e* would
    create a cycle in *T*. Therefore, discard *e* and go to step 2\. Otherwise, proceed
    to the next step.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果e的两个顶点已经在T中，这意味着添加e会在T中创建一个循环。因此，丢弃e并转到步骤2。否则，继续下一步。
- en: Insert *e* in the minimum spanning tree, *T*.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最小生成树T中插入e。
- en: 'Let''s take a moment to think about why this strategy works. At each iteration
    of the loop in steps 2 and 3, we take the edge with the lowest cost and check
    whether it adds any vertex to our solution. This is stored in the minimum spanning
    tree, *T*. If it does, we add the edge to *T*; otherwise, we discard that edge
    and choose another edge with the minimum value. Our algorithm is greedy in the
    sense that at each iteration, it chooses the minimum edge weight to add to the
    solution. The preceding algorithm was invented in 1956 and is called **Kruskal''s
    minimum spanning tree algorithm**. Applying this algorithm to the graph shown
    in *figure 5.11* gives the following result:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间思考为什么这个策略有效。在步骤2和3的循环的每次迭代中，我们选择具有最低成本的边，并检查它是否向我们的解决方案中添加了任何顶点。这存储在最小生成树T中。如果是，我们将边添加到T；否则，我们丢弃该边并选择另一条具有最小值的边。我们的算法是贪婪的，因为在每次迭代中，它选择要添加到解决方案中的最小边权重。上述算法是在1956年发明的，称为**Kruskal的最小生成树算法**。将该算法应用于图5.11中显示的图将得到以下结果：
- en: '![Figure 5.12: Graph G showing the minimum spanning tree, T (with red edges)](img/C14498_05_12.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图5.12：图G显示最小生成树T（带有红色边）](img/C14498_05_12.jpg)'
- en: 'Figure 5.12: Graph G showing the minimum spanning tree, T (with red edges)'
  id: totrans-107
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.12：显示最小生成树T的图G（带有红色边）
- en: The total weight of edges in the minimum spanning tree, T, is *(2 × 1) + (3
    × 2) + (2 × 3) = 14* units. Therefore, the answer to our problem is that at least
    12 units of road would need to be built.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最小生成树T中边的总权重为（2×1）+（3×2）+（2×3）= 14个单位。因此，我们的问题的答案是至少需要修建12个单位的道路。
- en: 'How do we know that our algorithm is indeed correct? We need to return to the
    definitions of optimal substructure and greedy choice and show that the MST problem
    exhibits these two properties. While a rigorous mathematical proof of the properties
    is beyond the ambit of this book, here are the intuitive ideas behind the proofs:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道我们的算法确实是正确的？我们需要回到最优子结构和贪婪选择的定义，并展示MST问题具有这两个属性。虽然对这些属性的严格数学证明超出了本书的范围，但以下是证明背后的直观思想：
- en: '**Optimal substructure**: We will prove this by using contradiction. Let''s
    assume that the MST problem does not exhibit an optimal substructure; that is,
    a minimum spanning tree was not composed of a set of smaller minimum spanning
    trees:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**最优子结构**：我们将通过反证法来证明这一点。假设MST问题没有最优子结构；也就是说，最小生成树不是由一组较小的最小生成树组成的：'
- en: Let's say we are given a minimum spanning tree, *T*, over the vertices of graph
    *G* Let's remove any edge, *e*, from *T*. Removing *e* decomposes *T* into smaller
    trees, *T**1* and *T**2*.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们得到了图G的顶点上的最小生成树T。让我们从T中移除任意边e。移除e会将T分解成较小的树T1和T2。
- en: Since we assumed that the MST problem does not exhibit optimal substructure,
    there must exist a spanning tree with a lesser total weight over the vertices
    of *T**1*. Take this spanning tree and add the edges *e* and *T**2* to it. This
    new tree will be *T'*.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们假设MST问题没有最优子结构，因此必须存在一个跨越T1顶点的总权重更小的生成树。将这个生成树和边e和T2添加到一起。这个新树将是T'。
- en: Now, since the total weight of *T'* is less than that of *T*, this contradicts
    our original assumption that *T* is an MST. Therefore, the MST problem must exhibit
    the optimal substructure property.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，由于T'的总权重小于T的总权重，这与我们最初的假设相矛盾，即T是MST。因此，MST问题必须具有最优子结构性质。
- en: '**Greedy choice**: If the MST problem exhibits greedy choice property, then
    for a vertex, *v*, the minimum weight edge connecting *v* to the rest of the graph,
    *G*, should always be a part of the minimum spanning tree, *T*. We can prove this
    hypothesis by contradiction, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**贪婪选择**：如果MST问题具有贪婪选择属性，则对于顶点*v*，连接*v*到图*G*的其余部分的最小权重边应始终是最小生成树*T*的一部分。我们可以通过反证法证明这个假设，如下所示：'
- en: Say an edge *(u, v)* is the minimum weight edge connecting *v* to any other
    vertex in *G*. Assume that *(u, v)* is not a part of *T*.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设边*(u, v)*是连接*v*到*G*中任何其他顶点的最小权重边。假设*(u, v)*不是*T*的一部分。
- en: If *(u, v)* is not a part of *T*, then *T* must consist of some other edge connecting
    *v* to the rest of *G*. Let this edge be *(x, v)*. Since *(u, v)* is the minimum
    weight edge, by definition, the weight of *(x, v)* is greater than the weight
    of *(u, v)*.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*(u, v)*不是*T*的一部分，则*T*必须由连接*v*到*G*的其他某条边组成。让这条边为*(x, v)*。由于*(u, v)*是最小权重边，根据定义，*(x,
    v)*的权重大于*(u, v)*的权重。
- en: A tree with a lesser total weight than *T* can be obtained if *(x, v)* is replaced
    with *(u, v)* in *T*. This contradicts our assumption that *T* is the minimum
    spanning tree. Therefore, the MST problem must exhibit the greedy choice property.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在*T*中用*(u, v)*替换*(x, v)*，则可以获得总权重小于*T*的树。这与我们假设的*T*是最小生成树相矛盾。因此，MST问题必须具有贪婪选择属性。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'As we mentioned earlier, we can also take a rigorous mathematical approach
    to show that the MST problem exhibits the optimal substructure property and is
    suitable for the greedy choice property. You can find it here: [https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2015/lecture-notes/MIT6_046JS15_lec12.pdf](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2015/lecture-notes/MIT6_046JS15_lec12.pdf).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，我们也可以采用严格的数学方法来证明MST问题具有最优子结构属性，并适用于贪婪选择属性。您可以在这里找到它：[https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2015/lecture-notes/MIT6_046JS15_lec12.pdf](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2015/lecture-notes/MIT6_046JS15_lec12.pdf)。
- en: Let's think about how to implement Kruskal's algorithm. We covered graph and
    heap data structures in *Chapter 2*, *Trees, Heaps, and Graphs*, so we know how
    to implement steps 1 and 2\. Step 3 is somewhat more complicated. We need a data
    structure that stores the edges of the graph and tells us whether adding a new
    edge would create a cycle with any possible combination of the edges already stored
    in it. This problem can be solved using a disjoint-set data structure.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑如何实现Kruskal算法。我们在*第2章*“树、堆和图”中介绍了图和堆数据结构，因此我们知道如何实现步骤1和2。第3步有点更复杂。我们需要一个数据结构来存储图的边，并告诉我们是否添加新边会与已存储的任何可能的边组合创建循环。这个问题可以使用不相交集数据结构来解决。
- en: Disjoint-Set (or Union-Find) Data Structures
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不相交集（或并查集）数据结构
- en: 'A **disjoint-set data structure** consists of a forest (a set of trees) of
    elements, where each element is represented by a numerical ID, has a ''rank,''
    and contains a pointer to its parent. When the data structure is initialized,
    it starts with *N* independent elements of rank 0, each of which is a part of
    a tree that contains only the element itself. The data structure supports two
    other operations:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 不相交集数据结构由一个元素的森林（一组树）组成，其中每个元素由一个数字ID表示，具有“等级”，并包含指向其父元素的指针。当数据结构初始化时，它从等级为0的*N*个独立元素开始，每个元素都是树的一部分，该树只包含元素本身。数据结构支持另外两种操作：
- en: A `find` operation on a tree returns the root element of that tree
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对树进行`find`操作会返回该树的根元素
- en: A `union` operation applied on two trees merges the smaller trees into a larger
    tree, where the size of the tree is stored as the rank of its root.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对两棵树进行`union`操作会将较小的树合并为较大的树，树的大小存储为其根的等级。
- en: 'More precisely, the disjoint-set data structure supports the following operations:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 更准确地说，不相交集数据结构支持以下操作：
- en: '`Make-Set`: This initializes the data structure with N elements, setting the
    rank of each element to 0, and the parent pointer to itself. The following figure
    shows an example of a disjoint-set *DS* initialized with five elements. The digits
    inside the circles show the element IDs, the digit in parentheses shows the rank,
    and the arrows represent the pointer to the root element:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Make-Set`：这将使用N个元素初始化数据结构，将每个元素的等级设置为0，并将父指针设置为自身。下图显示了一个用五个元素初始化的不相交集*DS*的示例。圆圈内的数字显示元素ID，括号中的数字显示等级，箭头表示指向根元素的指针：'
- en: '![Figure 5.13: Initializing disjoint set with five elements](img/C14498_05_13.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图5.13：用五个元素初始化不相交集](img/C14498_05_13.jpg)'
- en: 'Figure 5.13: Initializing disjoint set with five elements'
  id: totrans-128
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.13：用五个元素初始化不相交集
- en: At this stage, the data structure consists of five trees, each consisting of
    one element.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，数据结构由五棵树组成，每棵树都包含一个元素。
- en: '`Find`: Starting from a given element, *x*, the `find` operation follows the
    parent pointers of elements until the root of the tree is reached. The parent
    of a root element is the root itself. In the example in the previous set, each
    element is the root of the tree, and hence this operation will return the lone
    element in the tree.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Find`：从给定元素*x*开始，`find`操作遵循元素的父指针，直到到达树的根。根元素的父元素是根本身。在前面的示例中，每个元素都是树的根，因此此操作将返回树中的孤立元素。'
- en: '`Union`: Given two elements, *x* and *y*, the `union` operation finds the roots
    of *x* and *y*. If the two roots are the same, this means that *x* and *y* belong
    to the same tree. Therefore, it does nothing. Otherwise, it sets the root with
    a higher rank as the parent of the root with a lower rank. The following figure
    shows the result of implementing the `Union(1, 2)` and `Union(4, 5)` operations
    on *DS*:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Union`：给定两个元素*x*和*y*，`union`操作找到*x*和*y*的根。如果两个根相同，这意味着*x*和*y*属于同一棵树。因此，它什么也不做。否则，它将具有较低秩的根设置为具有较高秩的根的父节点。下图显示了在*DS*上实现`Union(1,2)`和`Union(4,5)`操作的结果：'
- en: '![Figure 5.14: Merging 1,2 and 4,5](img/C14498_05_14.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图5.14：合并1,2和4,5](img/C14498_05_14.jpg)'
- en: 'Figure 5.14: Merging 1,2 and 4,5'
  id: totrans-133
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.14：合并1,2和4,5
- en: 'As subsequent union operations are applied, more trees merge into fewer (but
    larger) trees. The following figure shows the trees in *DS* after applying `Union(2,
    3)`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 随着后续的并操作的应用，更多的树合并成了更少（但更大）的树。下图显示了在应用`Union(2, 3)`后*DS*中的树：
- en: '![Figure 5.15: Merging 2,3](img/C14498_05_15.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图5.15：合并2,3](img/C14498_05_15.jpg)'
- en: 'Figure 5.15: Merging 2,3'
  id: totrans-136
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.15：合并2,3
- en: 'The following diagram shows the trees in *DS* after applying `Union(2, 4)`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用`Union(2, 4)`后，*DS*中的树如下图所示：
- en: '![Figure 5.16: Merging 2,4](img/C14498_05_16.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图5.16：合并2,4](img/C14498_05_16.jpg)'
- en: 'Figure 5.16: Merging 2,4'
  id: totrans-139
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.16：合并2,4
- en: 'Now, let''s understand how the disjoint-set data structure helps us implement
    Kruskal''s algorithm. At the start of the algorithm, before step 1, we initialize
    a disjoint-set data structure with *N* equal to the number of vertices in our
    graph, *G*. Then, step 2 takes an edge from the min heap and step 3 checks whether
    the edge under consideration forms a cycle. Notice that this check for cycles
    can be implemented using the `union` operation on *DS*, which is applied to the
    two vertices of the edge. If the `union` operation succeeds in merging the two
    trees, then the edge is added to the MST; otherwise, the edge can safely be discarded
    as it would introduce a cycle in the MST. The following illustrated steps explain
    this logic:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解不相交集数据结构如何帮助我们实现Kruskal算法。在算法开始之前，在步骤1之前，我们使用*DS*初始化了一个包含图*G*中顶点数量*N*的不相交集数据结构。然后，步骤2从最小堆中取出一条边，步骤3检查正在考虑的边是否形成循环。请注意，可以使用在*DS*上的`union`操作来实现对循环的检查，该操作应用于边的两个顶点。如果`union`操作成功合并了两棵树，那么边将被添加到MST；否则，边可以安全地丢弃，因为它会在MST中引入一个循环。以下详细说明了这个逻辑：
- en: 'First, we begin by initializing a disjoint-set data structure, *DS*, containing
    all of the given vertices in the graph:![Figure 5.17: Step 1 of Kruskal’s algorithm
    – initialization](img/C14498_05_17.jpg)'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们开始初始化一个包含图中所有给定顶点的不相交集数据结构*DS*：![图5.17：Kruskal算法的第1步-初始化](img/C14498_05_17.jpg)
- en: 'Figure 5.17: Step 1 of Kruskal''s algorithm – initialization'
  id: totrans-142
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.17：Kruskal算法的第1步-初始化
- en: Let's proceed to add the edge with the lowest weight to our MST. As you can
    see from the following figure, as we add *edge (2,4)*, we also apply `Union(2,4)`
    to the elements in *DS*:![](img/C14498_05_18.jpg)
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续向我们的MST中添加权重最低的边。如下图所示，当我们添加*边(2,4)*时，我们也将`Union(2,4)`应用于*DS*中的元素：![](img/C14498_05_18.jpg)
- en: 'Figure 5.18: Adding edge (2, 4) to the MST after applying Union (2, 4) to the
    disjoint-set'
  id: totrans-144
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.18：在将Union(2, 4)应用于不相交集之后，将边(2, 4)添加到MST
- en: As we proceed with adding edges as per the algorithm, we reach *edge (1,5)*.
    As you can see, in *DS*, the corresponding elements are in the same tree. Hence,
    we cannot add that edge. As you can see from the following graph, adding that
    would have created a cycle:![](img/C14498_05_19.jpg)
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照算法添加边的过程中，我们到达了*边(1,5)*。如您所见，在*DS*中，相应的元素在同一棵树中。因此，我们无法添加该边。如下图所示，添加该边将会创建一个循环：![](img/C14498_05_19.jpg)
- en: 'Figure 5.19: Trying to add edge (1, 5) to MST fails because vertices 1 and
    5 are in the same tree in DS'
  id: totrans-146
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.19：尝试将边(1,5)添加到MST失败，因为顶点1和5在DS中的同一棵树中
- en: In the following exercise, we will implement Kruskal's minimum spanning tree
    algorithm using the disjoint-set data structure.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，我们将使用不相交集数据结构实现Kruskal的最小生成树算法。
- en: 'Exercise 26: Kruskal''s MST Algorithm'
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习26：Kruskal的MST算法
- en: 'In this exercise, we will implement the disjoint-set data structure and Kruskal''s
    algorithm to find an MST in the graph. Let''s get started:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实现不相交集数据结构和Kruskal算法来找到图中的最小生成树。让我们开始：
- en: 'Begin by adding the following headers and declaring the `Graph` data structure:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始添加以下头文件并声明`Graph`数据结构：
- en: '[PRE5]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'First, we will implement the disjoint set:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将实现不相交集：
- en: '[PRE6]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the constructor for the class and implement the `Make-set` and `Find` operations,
    as shown here:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加类的构造函数并实现`Make-set`和`Find`操作，如下所示：
- en: '[PRE7]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we will implement the `Union` operation between two trees in the disjoint-set,
    as shown here:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将实现不相交集中两棵树之间的`Union`操作，如下所示：
- en: '[PRE8]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that our implementation of the disjoint set is complete, let''s start implementing
    the graph. We will use an edge-list representation. The `edge` struct is defined
    as follows:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的不相交集的实现已经完成，让我们开始实现图。我们将使用边列表表示。`edge`结构定义如下：
- en: '[PRE9]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since our implementation of an edge is templatized, the edge weights are allowed
    to be of any datatype that implements the `<` and `>` operations.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的边的实现是模板化的，边的权重允许是实现了`<`和`>`操作的任何数据类型。
- en: 'The following function allows a graph to be serialized and output to streams:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下函数允许图被序列化并输出到流中：
- en: '[PRE10]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The graph data structure can now be implemented with the following code:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以使用以下代码实现图数据结构：
- en: '[PRE11]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Our implementation of the graph does not allow changing the number of vertices
    in the graph after it has been created. Also, although we can add as many edges
    as needed, the deletion of edges is not implemented since it is not needed in
    this exercise.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图的实现在创建后不允许更改图中顶点的数量。此外，虽然我们可以添加任意数量的边，但是删除边没有实现，因为在这个练习中不需要。
- en: 'Now, we can implement Kruskal''s algorithm like so:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以这样实现Kruskal算法：
- en: '[PRE12]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Lastly, add the driver code shown here:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加以下驱动代码：
- en: '[PRE13]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, run the program! Your output should look as follows:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，运行程序！您的输出应如下所示：
- en: '![Figure 5.20: Getting an MST from a given graph](img/C14498_05_20.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图5.20：从给定图中获取最小生成树](img/C14498_05_20.jpg)'
- en: 'Figure 5.20: Getting an MST from a given graph'
  id: totrans-173
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.20：从给定图中获取最小生成树
- en: Verify that the output of our algorithm is indeed the MST that was shown in
    *figure 5.12.*
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 验证我们的算法的输出确实是*图5.12*中显示的最小生成树。
- en: The complexity of Kruskal's algorithm without using the disjoint set is *O(E
    log E)*, where E is the number of edges in the graph. With the disjoint set, however,
    the total complexity comes down to *O(E**α**(V))*, where *α**(v)* is the inverse
    of the Ackermann function. Since the inverse Ackermann function grows much slower
    than the logarithm function, the difference in the performance of the two implementations
    is small for graphs with a few vertices but can be notably large for larger graph
    instances.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Kruskal算法的复杂度，如果不使用不相交集，为*O(E log E)*，其中E是图中的边数。然而，使用不相交集后，总复杂度降至*O(E**α**(V))*，其中*α**(v)*是Ackermann函数的倒数。由于倒数Ackermann函数增长速度远远慢于对数函数，因此对于顶点较少的图，两种实现的性能差异很小，但对于较大的图实例，性能差异可能显著。
- en: The Vertex Coloring Problem
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 顶点着色问题
- en: 'The vertex coloring problem can be stated as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色问题可以陈述如下：
- en: '*"Given a graph, G, assign a color to each vertex of the graph so that no two
    adjacent vertices have the same color."*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: “给定一个图G，为图的每个顶点分配一个颜色，以便相邻的两个顶点没有相同的颜色。”
- en: 'As an example, the following figure shows a valid coloring of the graph that
    was shown in *figure 5.11*:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下图显示了*图5.11*中显示的图的有效着色：
- en: '![Figure 5.21: Coloring an uncolored graph](img/C14498_05_21.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图5.21：给未着色的图着色](img/C14498_05_21.jpg)'
- en: 'Figure 5.21: Coloring an uncolored graph'
  id: totrans-181
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.21：给未着色的图着色
- en: Graph coloring has applications in solving a large variety of problems in the
    real world – making schedules for taxis, solving sudoku puzzles, and creating
    timetables for exams can all be mapped to finding a valid coloring of the problem,
    modeled as a graph. However, finding the minimum number of colors required to
    produce a valid vertex coloring (also called the chromatic number) is known to
    be an NP-complete problem. Thus, a minor change in the nature of the problem can
    make a massive difference to its complexity.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图着色在解决现实世界中的各种问题中有应用——为出租车制定时间表，解决数独谜题，为考试制定时间表都可以映射到找到问题的有效着色，建模为图。然而，找到产生有效顶点着色所需的最小颜色数量（也称为色数）被认为是一个NP完全问题。因此，问题性质的微小变化可能会对其复杂性产生巨大影响。
- en: 'As an example of the applications of the graph coloring problem, let''s consider
    the case of sudoku solvers. Sudoku is a number-placement puzzle where the objective
    is to fill a 9 × 9 box with numbers from 1 to 9 with no number being repeated
    in each row. Each column is a 3 × 3 block. An example of a sudoku puzzle is shown
    here:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图着色问题的应用示例，让我们考虑数独求解器的情况。数独是一个数字放置谜题，其目标是用1到9的数字填充一个9×9的盒子，每行中没有重复的数字。每列是一个3×3的块。数独谜题的示例如下：
- en: '![Figure 5.22: (Left) a sudoku puzzle, (Right) its solution](img/C14498_05_22.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图5.22：（左）数独谜题，（右）它的解决方案](img/C14498_05_22.jpg)'
- en: 'Figure 5.22: (Left) a sudoku puzzle, (Right) its solution'
  id: totrans-185
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.22：（左）数独谜题，（右）它的解决方案
- en: 'We can model an instance of the puzzle to the graph coloring problem as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将谜题的一个实例建模为图着色问题：
- en: Represent each cell in the puzzle by a vertex in graph *G*.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用图*G*中的顶点来表示谜题中的每个单元格。
- en: Add edges between the vertices that are in the same column, row, or are in the
    same 3 × 3 block.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在相同列、行或相同的3×3块中的顶点之间添加边。
- en: A valid coloring of *G* then gives us a solution to the original sudoku puzzle.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*G*的有效着色然后给出了原始数独谜题的解决方案。'
- en: We will take a look at the implementation of graph coloring in the following
    exercise.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下面的练习中看一下图着色的实现。
- en: 'Exercise 27: Greedy Graph Coloring'
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习27：贪婪图着色
- en: 'In this exercise, we will implement a greedy algorithm that produces a graph
    coloring for the graph shown in *figure 5.21* when the maximum number of colors
    that can be used is six. Let''s get started:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实现一个贪婪算法，为图着色，当可以使用的最大颜色数为六时，如*图5.21*所示。让我们开始吧：
- en: 'Begin by including the required header files and declaring the `Graph` data
    structure, which we will implement later in this exercise:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，包括所需的头文件并声明`Graph`数据结构，稍后我们将在本练习中实现：
- en: '[PRE14]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following struct implements an edge in our graph:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下结构实现了我们图中的一条边：
- en: '[PRE15]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following function allows us to write the graph directly to the output
    stream:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下函数允许我们将图直接写入输出流：
- en: '[PRE16]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Implement the graph as an edge list, as shown here:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图实现为边列表，如下所示：
- en: '[PRE17]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following hash map stores the list of colors that will be used by our coloring
    algorithm:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哈希映射存储了我们的着色算法将使用的颜色列表：
- en: '[PRE18]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, let''s implement a helper function that prints the colors that have been
    assigned to each vertex:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们实现一个辅助函数，打印已分配给每个顶点的颜色：
- en: '[PRE19]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following function implements our coloring algorithm:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下函数实现了我们的着色算法：
- en: '[PRE20]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, add the driver code, as shown here:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加驱动代码，如下所示：
- en: '[PRE21]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run the implementation! Your output should look as follows:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行实现！您的输出应如下所示：
- en: '![](img/C14498_05_23.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14498_05_23.jpg)'
- en: 'Figure 5.23: Output of the graph coloring implementation'
  id: totrans-211
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.23：图着色实现的输出
- en: Our implementation always starts coloring the vertices starting with vertex
    ID 1\. However, this choice is arbitrary, and starting the greedy coloring algorithm
    with different vertices even on the same graph is very likely to result in different
    graph colorings that require a different number of colors.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现总是从顶点ID 1开始着色顶点。但是，这个选择是任意的，即使在相同的图上，从不同的顶点开始贪婪着色算法很可能会导致需要不同颜色数量的不同图着色。
- en: The quality of a graph coloring is usually measured by how few colors it uses
    to color the graph. While finding the optimal graph coloring that uses the least
    possible number of colors is NP-complete, greedy graph coloring often serves as
    a useful approximation. For example, when designing a compiler, graph coloring
    is used to allocate CPU registers to the variables of the program that's being
    compiled. The greedy coloring algorithm is used with a set of heuristics to arrive
    at a "good enough" solution to the problem, which is desirable in practice since
    we need compilers to be fast in order to be useful.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图的着色质量通常通过着色图所使用的颜色数量来衡量。虽然找到使用尽可能少的颜色的最佳图着色是NP完全的，但贪婪图着色通常作为有用的近似。例如，在设计编译器时，图着色用于将CPU寄存器分配给正在编译的程序的变量。贪婪着色算法与一组启发式方法一起使用，以得到问题的“足够好”的解决方案，在实践中这是可取的，因为我们需要编译器快速才能有用。
- en: 'Activity 12: The Welsh-Powell Algorithm'
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动12：威尔士-鲍威尔算法
- en: An improvement to the simple approach of starting greedy coloring with a fixed
    vertex ID is to color the vertices in decreasing order of the number of edges
    incident on the vertices (or in decreasing order of the degree of vertices).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 改进简单方法的方法之一是按顶点的边数递减顺序着色顶点（或按顶点的度递减顺序）。
- en: 'The algorithm works as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的工作方式如下：
- en: Sort all the vertices in decreasing order of degree and store them in an array.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按度的递减顺序对所有顶点进行排序，并将它们存储在数组中。
- en: Take the first uncolored vertex in the sorted array and assign to it the first
    color that hasn't been assigned to any of its neighbors. Let this color be *C*.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取排序后数组中的第一个未着色顶点，并将尚未分配给其任何邻居的第一个颜色分配给它。让这个颜色为*C*。
- en: Traverse the sorted array and assign the color *C* to each uncolored vertex
    that doesn't have any neighbors who have been assigned *C*.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历排序后的数组，并将颜色*C*分配给每个未着色的顶点，这些顶点没有被分配颜色*C*的邻居。
- en: If any uncolored vertices remain in the array, go to step 2\. Else, end the
    program. The colors that have been assigned to the vertices so far is the final
    output.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果数组中仍有未着色的顶点，则转到步骤2。否则，结束程序。到目前为止已分配给顶点的颜色是最终输出。
- en: 'The following is an illustrated example of the four iterations of the algorithm
    that are required to find a valid coloring of the graph shown in *figure 5.21*:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是算法的四次迭代的图示示例，这些迭代需要找到*图5.21*中所示图的有效着色：
- en: 'Here is the graph that we start with:![Figure 5.24: Starting with an uncolored
    graph](img/C14498_05_24.jpg)'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们开始的图：![图5.24：从未着色的图开始](img/C14498_05_24.jpg)
- en: 'Figure 5.24: Starting with an uncolored graph'
  id: totrans-223
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.24：从未着色的图开始
- en: 'Next, we sort by decreasing order of vertices, and start by coloring red:![Figure
    5.25: Coloring red](img/C14498_05_25.jpg)'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，按顶点的递减顺序排序，并从红色开始着色：![图5.25：红色着色](img/C14498_05_25.jpg)
- en: 'Figure 5.25: Coloring red'
  id: totrans-225
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.25：红色着色
- en: In the next round, we start coloring blue:![](img/C14498_05_26.jpg)
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一轮中，我们开始着蓝色：![](img/C14498_05_26.jpg)
- en: 'Figure 5.26: Coloring blue'
  id: totrans-227
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.26：蓝色着色
- en: 'In the last round, we color green:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一轮中，我们着绿色：
- en: '![](img/C14498_05_27.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14498_05_27.jpg)'
- en: 'Figure 5.27: Coloring green'
  id: totrans-230
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.27：绿色着色
- en: 'The high-level steps to complete this activity are as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此活动的高级步骤如下：
- en: Assume that each edge of the graph holds the source vertex ID, destination vertex
    ID, and the edge weight. Implement a struct that represents an edge of the graph.
    We will use instances of this struct to create different edges in our graph representation.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设图的每条边都保存源顶点ID、目标顶点ID和边权重。实现一个表示图边的结构。我们将使用该结构的实例来创建图表示中的不同边。
- en: Implement a graph using the edge list representation.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用边列表表示实现图。
- en: Implement a function that implements the Welsh-Powell graph coloring and returns
    a vector of colors. The color at index *i* in the vector should be the one that's
    assigned to vertex ID *i*.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个实现威尔士-鲍威尔图着色并返回颜色向量的函数。向量中索引*i*处的颜色应该是分配给顶点ID *i*的颜色。
- en: Add the driver and input/output code as required to create the graph shown in
    *figure 5.24*. It is okay to assume that the coloring always starts with vertex
    ID *1*.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要添加驱动程序和输入/输出代码以创建*图5.24*中显示的图。假设着色始终从顶点ID *1*开始是可以的。
- en: 'Your output should look as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您的输出应如下所示：
- en: '![Figure 5.28: Expected output of Activity 12](img/C14498_05_28.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图5.28：活动12的预期输出](img/C14498_05_28.jpg)'
- en: 'Figure 5.28: Expected output of Activity 12'
  id: totrans-238
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.28：活动12的预期输出
- en: Note
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 518.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第518页找到。
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'The greedy approach is simple: at each iteration of the algorithm, pick the
    seemingly best alternative out of all the possible alternatives. In other words,
    greedy solutions to problems are applicable when choosing the locally ''best''
    alternative at each iteration leads to the globally optimal solution to the problem.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 贪婪方法很简单：在算法的每次迭代中，从所有可能的选择中选择看似最佳的选择。换句话说，当在每次迭代中选择局部“最佳”选择导致问题的全局最优解时，贪婪解决方案适用于问题。
- en: In this chapter, we looked at examples of problems where the greedy approach
    is optimal and leads to correct solutions to the given problem; that is, shortest-job-first
    scheduling. We also discussed how slightly modified versions of NP-complete problems
    such as the 0-1 knapsack and the graph coloring problem can have simple greedy
    solutions. This makes the greedy approach an important algorithm design tool for
    difficult problems. For problems that have a greedy solution, it is likely to
    be the simplest way to solve them; and even for problems that do not have a greedy
    solution, it can often be used to solve relaxed versions of the problem that might
    be 'good enough' in practice (for example, greedy graph coloring is used while
    allocating registers to variables in programming language compilers).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了贪婪方法在问题中是最优的，并且可以导致给定问题的正确解决方案的示例；也就是说，最短作业优先调度。我们还讨论了稍微修改过的NP完全问题的例子，比如0-1背包和图着色问题，可以有简单的贪婪解决方案。这使得贪婪方法成为解决困难问题的重要算法设计工具。对于具有贪婪解决方案的问题，它很可能是解决它们的最简单方法；即使对于没有贪婪解决方案的问题，它通常也可以用来解决问题的放松版本，这在实践中可能是“足够好的”（例如，在编程语言编译器中分配寄存器给变量时使用贪婪图着色）。
- en: 'Next, we discussed the greedy choice and optimal substructure properties and
    looked at an example of proof that a given problem exhibits these properties.
    We concluded this chapter with two solutions to the minimum spanning tree problem:
    Kruskal''s algorithm and the Welsh-Powell algorithm. Our discussion of Kruskal''s
    algorithm also introduced the disjoint-set data structure.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讨论了贪婪选择和最优子结构属性，并看了一个给定问题展现这些属性的证明示例。我们用Kruskal算法和Welsh-Powell算法解决了最小生成树问题。我们对Kruskal算法的讨论还介绍了不相交集数据结构。
- en: 'In the next chapter, we will focus on graph algorithms, starting with breadth-first
    and depth-first search, and then move on to Dijkstra''s shortest path algorithm.
    We will also look at another solution to the minimum spanning tree problem: Prim''s
    algorithm.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于图算法，从广度优先和深度优先搜索开始，然后转向Dijkstra的最短路径算法。我们还将看看另一个解决最小生成树问题的方法：Prim算法。
