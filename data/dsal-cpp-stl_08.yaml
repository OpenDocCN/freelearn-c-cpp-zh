- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Advanced Unordered Associative Container Usage
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级无序关联容器使用
- en: 'While our journey with ordered associative containers has provided us with
    the prowess of relationship mapping and the power of ordering, it is time to venture
    into a domain that prioritizes speed over sorted behavior: unordered associative
    containers. As their name suggests, these containers do not guarantee any specific
    order of their elements, but they make up for it with potentially faster access
    times.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的有序关联容器之旅为我们提供了关系映射的技能和排序的权力时，现在是时候进入一个优先考虑速度而不是排序行为的领域：无序关联容器。正如它们的名称所暗示的，这些容器不保证它们元素的具体顺序，但它们通过可能更快的访问时间来弥补这一点。
- en: In the world of computing, there are always trade-offs. Unordered associative
    containers might relinquish the beauty of order, but in many scenarios, they make
    up for it with speed, especially when hashing operates at its best. Whether you’re
    developing a high-frequency trading system, a caching mechanism, or a real-time
    multiplayer game backend, understanding when to harness the power of unordered
    associated containers can make a difference.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算的世界里，总是有权衡。无序关联容器可能会放弃顺序的美感，但在许多场景中，它们通过速度来弥补这一点，尤其是在哈希操作最佳时。无论你是开发高频交易系统、缓存机制还是实时多人游戏后端，了解何时利用无序关联容器的力量可以有所区别。
- en: 'This chapter provides references for the following containers:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了以下容器的参考：
- en: '`std::unordered_set`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_set`'
- en: '`std::unordered_map`'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_map`'
- en: '`std::unordered_multiset`'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_multiset`'
- en: '`std::unordered_multimap`'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_multimap`'
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code in this chapter can be found on GitHub:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
- en: std::unordered_set
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`std::unordered_set`'
- en: 'This container is akin to `std::set` but with a twist: it does not maintain
    the elements in any particular order. Instead, it employs a hashing mechanism
    to access its elements quickly. This hash-based approach can offer constant time
    average complexity for most operations, given a good hash function.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个容器类似于`std::set`，但有一个转折：它不保持元素在任何特定的顺序。相反，它使用哈希机制快速访问其元素。在给定一个好的哈希函数的情况下，这种基于哈希的方法可以为大多数操作提供平均常数时间复杂度。
- en: Purpose and suitability
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目的和适用性
- en: '`std::unordered_set` is a hash-based container in the C++ **Standard Template
    Library** (**STL**) that stores unique elements in no particular order. Its core
    strengths include the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unordered_set`是C++ **标准模板库**（**STL**）中的一个基于哈希的容器，它以无特定顺序存储唯一元素。其核心优势包括以下内容：'
- en: Providing average constant-time operations for insertions, deletions, and searches
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供插入、删除和搜索的平均常数时间操作
- en: Handling non-trivial data types effectively
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效处理非平凡的数据类型
- en: 'You should choose `std::unordered_set` in the following scenarios:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下场景中，你应该选择`std::unordered_set`：
- en: When you need rapid checks for the existence of elements
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要快速检查元素的存在时
- en: When the order of elements is not a concern
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当元素顺序不是关注点时
- en: When frequent insertions and deletions are expected
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当预期频繁的插入和删除时
- en: However, if the ordering of elements is crucial, `std::set` might be a better
    alternative.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果元素的排序至关重要，`std::set`可能是一个更好的选择。
- en: Ideal use cases
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理想使用场景
- en: 'The following are some of the ideal use cases for `std::unordered_set`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些`std::unordered_set`的理想使用场景：
- en: '`std::unordered_set` is your candidate.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_set`是你的候选。'
- en: '`std::unordered_set` to create a collection of unique items from an existing
    dataset.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::unordered_set`从现有数据集中创建唯一项的集合。
- en: '`std::unordered_set` where quick insertions and deletions are more critical
    than maintaining order.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在快速插入和删除比保持顺序更重要的情况下使用`std::unordered_set`。
- en: '`std::unordered_set` over `std::set` when the order of elements doesn’t matter
    since `std::unordered_set` provides faster lookup, insertion, and removal operations.
    However, `std::unordered_set` may use more memory than `std::set`.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当元素的顺序不重要时，使用`std::unordered_set`比`std::set`更优，因为`std::unordered_set`提供了更快的查找、插入和删除操作。然而，`std::unordered_set`可能比`std::set`使用更多的内存。
- en: Performance
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: 'The algorithmic performance of `std::unordered_set` is characterized as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unordered_set`的算法性能如下：'
- en: '**Insertion**: Average-case *O(1)*, worst-case *O(n)* due to potential hash
    collisions'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入**：平均情况 *O(1)*，最坏情况 *O(n)*，由于潜在的哈希冲突'
- en: '**Deletion**: Average-case *O(1)*, worst-case *O(n)* due to potential hash
    collisions'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除**：平均情况 *O(1)*，最坏情况 *O(n)*，由于潜在的哈希冲突'
- en: '**Access**: *O(1)*'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问**：*O(1)*'
- en: '**Memory overhead**: Generally higher than ordered containers due to hashing
    mechanisms'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存开销**：由于哈希机制，通常高于有序容器'
- en: The key trade-off here revolves around average versus worst-case scenarios,
    especially concerning hash collisions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键权衡在于平均情况与最坏情况，特别是关于哈希冲突的问题。
- en: Memory management
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理
- en: '`std::unordered_set` manages its memory using a series of buckets to store
    elements. The number of buckets can grow, usually when the load factor exceeds
    a certain threshold. Using custom allocators can help tailor this behavior.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unordered_set` 使用一系列桶来管理其内存以存储元素。桶的数量可以增长，通常在负载因子超过某个阈值时。使用自定义分配器可以帮助调整这种行为。'
- en: Thread safety
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全
- en: Concurrent reading is safe. However, operations that modify the set (such as
    insertions or deletions) require external synchronization mechanisms, such as
    mutexes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 并发读取是安全的。然而，修改集合的操作（如插入或删除）需要外部同步机制，例如互斥锁。
- en: Extensions and variants
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展和变体
- en: '`std::unordered_multiset` is a close relative, allowing multiple instances
    of an element to be used. If ordered storage is vital, `std::set` and `std::multiset`
    come into play.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unordered_multiset` 是一个近亲，允许使用元素的多个实例。如果有序存储至关重要，`std::set` 和 `std::multiset`
    就派上用场。'
- en: Sorting and searching complexity
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序和搜索复杂度
- en: 'Its sorting and search complexity is characterized as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 其排序和搜索复杂度如下：
- en: '`std::unordered_set` is not ordered.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_set` 是无序的。'
- en: '**Searching**: It has an average *O(1)* time due to hashing, but its worst-case
    scenario can be *O(n)* with poor hashing.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索**：由于哈希，平均时间复杂度为 *O(1)*，但最坏情况可能为 *O(n)*，这取决于哈希质量。'
- en: Special interface and member functions
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊接口和成员函数
- en: 'Some handy member functions to note are as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一些值得注意的成员函数如下：
- en: '`emplace`: This allows elements to be constructed directly.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emplace`：这允许直接构造元素。'
- en: '`bucket`: This can retrieve the bucket number for a given element.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bucket`：这可以检索给定元素的桶号。'
- en: '`load_factor` and `max_load_factor`: These are required for managing performance
    characteristics.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load_factor` 和 `max_load_factor`：这些是管理性能特征所必需的。'
- en: Comparisons
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较
- en: Compared to `std::set`, `std::unordered_set` generally offers faster operations
    but loses the inherent order and might have a higher memory overhead.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `std::set` 相比，`std::unordered_set` 通常提供更快的操作，但失去了固有的顺序，并且可能具有更高的内存开销。
- en: Interactions with algorithms
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与算法的交互
- en: Due to its unordered nature, `std::unordered_set` might not be the best candidate
    for STL algorithms that require ordered data. However, algorithms revolving around
    unique elements can fit well.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其无序性，`std::unordered_set` 可能不是需要有序数据的 STL 算法的最佳候选者。然而，围绕唯一元素的算法可以很好地适应。
- en: Exceptions
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: Operations can throw exceptions if allocations fail or if hash functions throw.
    Ensure your hash functions are exception-free to guarantee the container’s exception
    safety.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果分配失败或哈希函数抛出异常，操作可能会抛出异常。确保您的哈希函数无异常，以保证容器的异常安全性。
- en: Customization
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义
- en: Custom hash functions and equality predicates can be applied to fine-tune the
    container’s behavior for specific data types. Moreover, custom allocators can
    also be beneficial in some scenarios.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 可以应用自定义哈希函数和等价谓词来微调容器针对特定数据类型的操作行为。此外，在某些场景下，自定义分配器也可能有益。
- en: Example
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: '`std::unordered_set` stores unique elements in no particular order. The primary
    operations it supports are insertion, deletion, and member checking. Unlike `std::set`,
    which uses a balanced binary tree internally, `std::unordered_set` uses a hash
    table, making the average insertion, deletion, and search complexities *O(1)*,
    albeit with higher constants and worse worst-case performance.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unordered_set` 以无特定顺序存储唯一元素。它支持的主要操作是插入、删除和成员检查。与使用平衡二叉树内部实现的 `std::set`
    不同，`std::unordered_set` 使用哈希表，使得平均插入、删除和搜索复杂度为 *O(1)*，尽管常数较高且最坏情况性能较差。'
- en: 'The following code shows an example demonstrating best practices when using
    `std::unordered_set`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了使用 `std::unordered_set` 的最佳实践：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here’s the example output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例输出：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here are some key takeaways from the preceding code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从前面代码中得出的几个关键要点：
- en: '`std::unordered_set` allows rapid insertions, deletions, and lookups.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_set`允许快速插入、删除和查找。'
- en: '`find` can be used to check for the existence of an element.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find`可用于检查元素的存在。'
- en: The `rehash` method can change the number of buckets in the underlying hash
    table, which might help when you know the number of elements in advance and wish
    to reduce the overhead of rehashing.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rehash`方法可以改变底层哈希表中的桶数，这在你事先知道元素数量并希望减少重新散列开销时可能有所帮助。'
- en: Always be cautious about the load factor (covered in the following Best practices
    section) and consider rehashing when necessary to maintain efficient performance.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是小心地考虑负载因子（在下面的最佳实践部分有介绍）并在必要时考虑重新散列以保持高效性能。
- en: Remember that the order of elements in `std::unordered_set` is not guaranteed.
    The order can change over time as elements are inserted or deleted.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住，`std::unordered_set`中元素的顺序是不保证的。随着元素的插入或删除，顺序可能会随时间改变。
- en: Using `std::unordered_set` is appropriate when you need rapid lookups and are
    not worried about the order of elements. If ordering is essential, you might want
    to consider using `std::set` instead.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要快速查找且不关心元素顺序时，使用`std::unordered_set`是合适的。如果顺序是必需的，你可能想考虑使用`std::set`。
- en: Best practices
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Let’s explore the best practices of using `std::unordered_set`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨使用`std::unordered_set`的最佳实践：
- en: '`std::unordered_set` is designed without the need to maintain any specific
    order of its elements. Never rely on any sequential consistency within this container.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_set`设计时无需维护其元素的具体顺序。不要依赖于此容器内的任何顺序一致性。'
- en: '**Hash collision awareness**: Hash collisions can detrimentally affect performance,
    transforming average-case constant-time operations into worst-case linear-time
    operations. Always be aware of this, especially when designing hash functions
    or handling large datasets.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**哈希冲突意识**：哈希冲突会损害性能，将平均情况下的常数时间操作转换为最坏情况下的线性时间操作。始终对此保持警觉，尤其是在设计哈希函数或处理大数据集时。'
- en: '`std::unordered_set` can be intimately tied to its bucket count and load factor.
    Consider the load factor and rehashing policies of `std::unordered_set` for performance
    tuning. The `bucket_count()`: The current number of buckets'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_set`与其桶数和负载因子紧密相关。考虑`std::unordered_set`的负载因子和重新散列策略以进行性能调整。`bucket_count()`:
    当前桶数'
- en: '`load_factor()`: The current number of elements divided by the bucket count'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load_factor()`: 当前元素数量除以桶数'
- en: '`max_load_factor()`: The load factor threshold, which, when surpassed, triggers
    a rehash'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_load_factor()`: 负载因子阈值，当超过此阈值时触发重新散列'
- en: '`std::hash` standard template specialization. This allows hashing behavior
    to be fine-tuned.*   `rehash()` or `reserve()` when necessary. This can help prevent
    unexpected performance drops, especially when inserting new elements.*   **Uniform
    hash distribution**: A good hash function will distribute values uniformly across
    buckets, minimizing the chance of collisions. Ensure your hash function achieves
    this by testing its distribution with sample data before deploying it in performance-critical
    applications. Use a well-designed hash function that distributes elements evenly
    across the buckets to avoid performance degradation.*   `std::unordered_set` is
    not the ideal choice. Consider migrating to `std::set` or leveraging other ordered
    containers within the STL.*   `std::unordered_set` in multi-threaded applications,
    ensure proper synchronization mechanisms are in place. Concurrent reads are safe,
    but writes or simultaneous reads and writes demand external synchronization.*   `std::unordered_set`
    dynamically manages its size, it is beneficial to use functions such as `reserve()`
    if you have an estimate of the number of elements to be stored. This can help
    in reducing the number of rehashes and improve performance.*   `erase` member
    function judiciously. Remember that erasing by the iterator is faster (*O(1)*)
    than erasing by the key value (*O(n)* in the worst case.*   `std::unordered_set`,
    due to its hashing mechanism, might have a higher memory overhead than other containers.
    Consider this aspect, especially in memory-sensitive applications.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::hash` 标准模板特化。这允许对哈希行为进行微调。*   在必要时进行 `rehash()` 或 `reserve()`。这可以帮助防止性能意外下降，尤其是在插入新元素时。*   **均匀的哈希分布**：一个好的哈希函数将在桶之间均匀分布值，最小化冲突的可能性。在将哈希函数部署到性能关键应用之前，通过测试其分布来确保您的哈希函数实现这一点。使用设计良好的哈希函数，将元素均匀分布到桶中，以避免性能下降。*   `std::unordered_set`
    不是理想的选择。考虑迁移到 `std::set` 或利用 STL 中的其他有序容器。*   在多线程应用程序中，`std::unordered_set` 确保适当的位置同步机制。并发读取是安全的，但写入或同时读取和写入需要外部同步。*   `std::unordered_set`
    动态管理其大小，如果您对要存储的元素数量有一个估计，则使用 `reserve()` 等函数是有益的。这有助于减少重新哈希的次数并提高性能。*   适度使用
    `erase` 成员函数。记住，通过迭代器删除比通过键值删除更快（最坏情况下为 *O(1)*，而通过键值删除为 *O(n)*）。*   由于 `std::unordered_set`
    的哈希机制，它可能比其他容器具有更高的内存开销。在内存敏感的应用程序中，请考虑这一点。'
- en: std::unordered_map
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::unordered_map
- en: Think of this container as an unsorted version of `std::map`. It associates
    keys with values but without imposing any order. Instead, it banks on hashing
    for swift operations.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个容器视为 `std::map` 的无序版本。它将键与值关联起来，但不强加任何顺序。相反，它依赖于哈希以实现快速操作。
- en: Purpose and suitability
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目的和适用性
- en: '`std::unordered_map` is a hash table-based key-value container in the STL.
    Its core strengths are as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unordered_map` 是 STL 中基于哈希表的键值容器。其核心优势如下：'
- en: Fast average-case key-based access, insertion, and removal
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速的平均情况基于键的访问、插入和删除
- en: Ability to maintain a key-value association
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护键值关联的能力
- en: 'This container is the go-to in the following circumstances:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这个容器是首选：
- en: When insertions, deletions, and lookups must be swift on average
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当插入、删除和查找必须平均快速时
- en: When the order of elements isn’t a concern
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当元素顺序不是关注点时
- en: Ideal use cases
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理想用例
- en: 'The following are some of the ideal use cases for `std::unordered_map`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 `std::unordered_map` 的理想用例：
- en: '`std::unordered_map` provides average constant-time complexity for `search`,
    `insert`, and `delete` operations'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_map` 提供了平均常数时间复杂度用于 `search`、`insert` 和 `delete` 操作'
- en: '`std::unordered_map` is ideal'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_map` 是理想的'
- en: '`std::unordered_map` allows you to map items to their occurrence counts efficiently'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_map` 允许您有效地将项目映射到它们的出现次数'
- en: '`std::unordered_map` can map the attribute to a list or set of objects'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_map` 可以将属性映射到对象列表或集合'
- en: '`std::unordered_map` can associate setting keys with their current values for
    quick lookups and modifications'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_map` 可以将设置键与其当前值关联起来，以便快速查找和修改'
- en: '`std::unordered_map` can serve as an efficient index for quick record access
    based on unique identifiers'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_map` 可以作为基于唯一标识符快速记录访问的索引'
- en: '`std::unordered_map` offers an efficient way to update and access data categories
    or counters based on unique keys'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_map` 提供了一种有效的方法来根据唯一键更新和访问数据类别或计数器'
- en: '`std::unordered_map` provides an efficient structure to handle key-value pairs'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_map` 提供了一种高效的结构来处理键值对'
- en: '`std::unordered_map` proves invaluable'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_map` 非常宝贵'
- en: '`std::unordered_map` can associate resource keys with their status or attributes'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_map` 可以将资源键与其状态或属性关联起来'
- en: To summarize, `std::unordered_map` is optimal for scenarios that demand quick
    associative lookups, insertions, and deletions without needing the keys to maintain
    any specific order. If a key’s sequence or sorted nature is a priority, structures
    such as `std::map` would be more suitable.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`std::unordered_map` 对于需要快速关联查找、插入和删除，且不需要键保持任何特定顺序的场景是最佳的。如果键的序列或排序性质是优先考虑的，那么像
    `std::map` 这样的结构会更合适。
- en: Performance
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: 'The algorithmic performance of `std::unordered_map` is characterized as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unordered_map` 的算法性能如下所述：'
- en: '**Insertion**: *O(1)* average-case, *O(n)* worst-case'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入**：平均情况下的 *O(1)*，最坏情况下的 *O(n)*'
- en: '**Deletion**: *O(1)* average-case, *O(n)* worst-case'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除**：平均情况下的 *O(1)*，最坏情况下的 *O(n)*'
- en: '**Access**: *O(1)* average-case, *O(n)* worst-case due to potential hash collisions'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问**：平均情况下的 *O(1)*，由于潜在的哈希冲突，最坏情况下的 *O(n)*'
- en: '**Memory overhead**: Generally higher than ordered map counterparts due to
    the hashing infrastructure'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存开销**：由于哈希基础设施，通常高于有序映射的对应项'
- en: Memory management
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理
- en: '`std::unordered_map` manages its memory automatically, resizing when load factors
    exceed certain thresholds. Allocators can offer finer control over this process.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unordered_map` 自动管理其内存，当负载因子超过某些阈值时进行扩容。分配器可以提供对此过程的更精细控制。'
- en: Thread safety
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全
- en: Concurrent reading is safe. However, modifications or mixed read-writes necessitate
    external synchronization, such as using mutexes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 并发读取是安全的。然而，修改或混合读写需要外部同步，例如使用互斥锁。
- en: Extensions and variants
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展和变体
- en: '`std::map` is the ordered counterpart, providing log(n) guarantees at the cost
    of maintaining order. Based on your requirements, decide whether you need order
    or average-case speed.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::map` 是有序的对应项，以维护顺序为代价提供 log(n) 的保证。根据您的需求，决定您是否需要顺序或平均情况的速度。'
- en: Sorting and searching complexity
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序和搜索复杂度
- en: 'Its sorting and search complexity is characterized as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 其排序和搜索复杂度如下所述：
- en: '`std::unordered_map` is inherently unordered'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_map` 本质上是无序的'
- en: '**Searching**: Fast *O(1)* average-case key-based lookups'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索**：基于键的快速 *O(1)* 平均情况查找'
- en: Special interface and member functions
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊接口和成员函数
- en: 'Apart from the standard functions (`insert`, `erase`, `find`), become familiar
    with the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准函数（`insert`、`erase`、`find`）之外，熟悉以下内容：
- en: '`emplace`: Constructs key-value pairs in place'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emplace`：就地构建键值对'
- en: '`bucket_count`: Returns the number of buckets'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bucket_count`：返回桶的数量'
- en: '`load_factor`: Provides the current load factor'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load_factor`：提供当前的负载因子'
- en: Comparisons
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较项
- en: Compared to `std::map`, `std::unordered_map` trades order for faster average-case
    operations. The unordered variant often outperforms in scenarios where constant
    order isn’t vital.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `std::map` 相比，`std::unordered_map` 以牺牲顺序为代价换取了更快的平均情况操作。无序版本在常数顺序不是关键的场景中通常表现更好。
- en: Interactions with algorithms
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与算法的交互
- en: Most STL algorithms that work with sequences aren’t directly applicable to key-value
    map structures. Still, the container provides methods that are optimized for its
    use case.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数与序列一起工作的 STL 算法不能直接应用于键值映射结构。尽管如此，容器提供了针对其用例优化的方法。
- en: Exceptions
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: Failures in memory allocation or the hash function can throw exceptions. Some
    operations, such as `at()`, can throw `std::out_of_range`. It’s crucial to ensure
    exception safety, especially during insertions or emplacements.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 内存分配或哈希函数的失败可以抛出异常。一些操作，如 `at()`，可以抛出 `std::out_of_range`。确保异常安全性至关重要，尤其是在插入或就地构造时。
- en: Customization
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义
- en: You can supply custom hash functions and key equality functions to optimize
    further or adapt behavior. Additionally, custom allocators are available for memory
    management tweaks.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以提供自定义哈希函数和键相等函数以进一步优化或调整行为。此外，还提供了自定义分配器以进行内存管理调整。
- en: Example
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: '`std::unordered_map` is a container that associates keys with values. It is
    similar to `std::map`, but while `std::map` maintains its elements in a sorted
    manner (based on keys), `std::unordered_map` does not maintain any order. Internally,
    it uses a hash table, which gives it an *O(1)* complexity for insertions, deletions,
    and lookups.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unordered_map` 是一个将键与值关联的容器。它与 `std::map` 类似，但 `std::map` 按照键的顺序维护其元素，而
    `std::unordered_map` 不维护任何顺序。内部，它使用哈希表，这使得插入、删除和查找具有 *O(1)* 的复杂度。'
- en: 'The following code shows an example demonstrating best practices when using
    `std::unordered_map`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了使用`std::unordered_map`时的最佳实践：
- en: '[PRE2]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here’s the example output:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE3]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here are some key takeaways from the preceding code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从前面的代码中得出的关键要点：
- en: Use the `operator[]` or the `insert` method to add elements to the map. Note
    that using an index operator on a non-existent key will create it with a default
    value.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`operator[]`或`insert`方法向映射中添加元素。请注意，在不存在键上使用索引操作符将创建它并使用默认值。
- en: The `find` method checks for the existence of a key. It’s more efficient than
    using the `index` operator when you want to check a key’s existence without potential
    insertion.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find`方法检查键的存在。当你想检查键的存在而不进行潜在插入时，它比使用`index`操作符更有效。'
- en: Always be aware of the map’s load factor and consider rehashing if necessary
    to maintain efficient performance.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是注意地图的负载因子，并在必要时考虑重新散列以保持高效性能。
- en: As with `std::unordered_set`, the order of elements in `std::unordered_map`
    is not guaranteed. It can change as elements are inserted or removed.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与`std::unordered_set`一样，`std::unordered_map`中元素的顺序是不保证的。随着元素的插入或删除，顺序可能会改变。
- en: '`std::unordered_map` is suitable when you need quick key-based access and don’t
    care about the order of elements. If ordering is essential, then `std::map` would
    be a more appropriate choice.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要快速基于键的访问且不关心元素顺序时，`std::unordered_map`是合适的。如果顺序很重要，那么`std::map`将是一个更合适的选择。
- en: Best practices
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Let’s explore the best practices of using `std::unordered_map`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨使用`std::unordered_map`的最佳实践：
- en: '**Element order is not guaranteed**: Do not assume the map maintains element
    order.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元素顺序不保证**：不要假设映射保持元素顺序。'
- en: '**Beware of hash collisions**: Ensure you account for potential worst-case
    performance in hash-collision scenarios.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注意哈希冲突**：确保在哈希冲突场景中考虑潜在的糟糕性能。'
- en: '`std::unordered_map` to maintain optimal performance. Regularly check the load
    factor and consider rehashing if necessary.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::unordered_map`以保持最佳性能。定期检查负载因子，并在必要时考虑重新散列。
- en: '`std::unordered_map` is highly dependent on the effectiveness of the hash function
    used. A poorly designed hash function can lead to poor performance due to cache
    misses and collision resolution overhead.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_map`高度依赖于所使用的哈希函数的有效性。一个设计不良的哈希函数可能导致性能不佳，因为缓存未命中和冲突解决开销。'
- en: '`std::unordered_map` to improve memory efficiency, particularly in scenarios
    with high insertions and deletions.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::unordered_map`来提高内存效率，尤其是在插入和删除频繁的场景中。
- en: '**Check for an existing key**: Always check for an existing key before insertion
    to avoid overwriting.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查现有键**：在插入之前始终检查现有键以避免覆盖。'
- en: '`emplace` to construct entries in place, reducing overhead.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`emplace`就地构建条目，减少开销。
- en: '`std::unordered_map` is expensive when using `operator[]` for accessing elements,
    which can be a performance pitfall.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`operator[]`访问元素时，`std::unordered_map`成本较高，这可能是性能陷阱。
- en: std::unordered_multiset
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`std::unordered_multiset`'
- en: This container is a flexible counterpart to `std::unordered_set`, allowing multiple
    occurrences of an element. It amalgamates the speed of hashing with the liberty
    of non-unique elements.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此容器是`std::unordered_set`的灵活对应物，允许元素出现多次。它结合了散列的速度和非唯一元素的自由度。
- en: Purpose and suitability
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目的和适用性
- en: '`std::unordered_multiset` is a hash table-based container that allows you to
    store multiple equivalent items in an unordered manner. Its primary attractions
    are as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unordered_multiset`是一个基于哈希表的容器，允许你以无序方式存储多个等效项。其主要吸引力如下：'
- en: Quick average-case insertion and lookup times
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速的平均情况插入和查找时间
- en: The ability to store multiple items with the same value
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储具有相同值的多个项的能力
- en: 'It’s particularly suitable in the following scenarios:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 它特别适合以下场景：
- en: When the order of elements doesn’t matter
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当元素的顺序不重要时
- en: When you anticipate having multiple elements with the same value
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你预期有多个具有相同值的元素
- en: When you want average-case constant time complexity for insertions and lookups
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你希望插入和查找的平均情况时间复杂度为常数时
- en: When searching for a container where duplicates are permissible and order isn’t
    crucial, `std::unordered_multiset` is a compelling choice.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在搜索允许重复且顺序不重要的容器时，`std::unordered_multiset`是一个有力的选择。
- en: Ideal use cases
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理想用例
- en: 'The following are some of the ideal use cases for `std::unordered_multiset`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些`std::unordered_multiset`的理想用例：
- en: '`std::unordered_multiset` is suitable. It permits the storage of multiple identical
    elements.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_multiset`是合适的。它允许存储多个相同的元素。'
- en: '`std::unordered_multiset` can be an efficient structure where each unique value
    is stored alongside its duplicates.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_multiset`可以是一个有效的结构，其中每个唯一值都与其重复项一起存储。'
- en: '`std::unordered_multiset` can be useful for managing hash collisions by storing
    collided items together.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_multiset`可以通过存储碰撞项来有效地管理哈希冲突。'
- en: '`std::unordered_multiset` can store these repeating patterns for further analysis.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_multiset`可以存储这些重复模式以供进一步分析。'
- en: '`std::unordered_multiset` is efficient as it allows constant time average complexity
    for inserts.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_multiset`效率高，因为它允许插入的平均复杂度为常数时间。'
- en: '`std::unordered_multiset` can efficiently manage these tag occurrences.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_multiset`可以有效地管理这些标签出现。'
- en: '`std::unordered_multiset` provides a way to manage these grouped items.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_multiset`提供了一种管理这些分组项的方法。'
- en: '`std::unordered_multiset` can be an efficient in-memory tool to manage these
    redundant data points.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_multiset`可以作为一个高效的内存工具来管理这些冗余数据点。'
- en: '`std::unordered_multiset` is best suited for scenarios where quick insertions
    and lookups are needed, duplicates are allowed, and the order of elements is not
    significant. When unique keys or ordered data structures are a requirement, other
    containers, such as `std::unordered_set` or `std::map`, may be more appropriate.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unordered_multiset`最适合需要快速插入和查找、允许重复元素且元素顺序不重要的场景。当需要唯一键或有序数据结构时，其他容器，如`std::unordered_set`或`std::map`可能更合适。'
- en: Performance
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: 'The algorithmic performance of `std::unordered_multiset` is characterized as
    follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unordered_multiset`的算法性能如下：'
- en: '**Insertion**: *O(1)* average-case though worst-case can be *O(n)*'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入**：平均情况下为*O(1)*，但最坏情况下可以是*O(n)*'
- en: '**Deletion:** *O(1)* average-case'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除**：平均情况下为*O(1)*'
- en: '**Access**: No direct access like an array, but finding an element is *O(1)*
    average-case'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问**：没有像数组那样的直接访问，但查找元素的平均情况下为*O(1)*'
- en: '**Memory overhead**: Typically, this is higher than ordered containers due
    to hashing mechanisms'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存开销**：通常，由于哈希机制，这比有序容器要高'
- en: One trade-off is that while `std::unordered_multiset` offers average-case *O(1)*
    insertion, lookup, and deletion, worst-case performance can degrade to *O(n)*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一个权衡是，虽然`std::unordered_multiset`在平均情况下提供*O(1)*的插入、查找和删除性能，但在最坏情况下性能可能会下降到*O(n)*。
- en: Memory management
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理
- en: '`std::unordered_multiset` dynamically manages its bucket list. The container
    can be resized, which might happen automatically when elements are inserted and
    the size exceeds `max_load_factor`. Allocators can be used to influence memory
    allocation.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unordered_multiset`动态管理其桶列表。容器可以调整大小，这可能在元素插入且大小超过`max_load_factor`时自动发生。可以使用分配器来影响内存分配。'
- en: Thread safety
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全
- en: Reading from the container is thread-safe, but modifications (for example, insertions
    or deletions) require external synchronization. Multiple threads writing to `std::unordered_multiset`
    simultaneously can lead to race conditions.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 从容器中读取是线程安全的，但修改（例如，插入或删除）需要外部同步。多个线程同时写入`std::unordered_multiset`可能导致竞争条件。
- en: Extensions and variants
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展和变体
- en: '`std::unordered_set` functions similarly but doesn’t allow duplicate elements.
    It contrasts with `std::multiset`, which keeps its elements ordered but permits
    duplicates.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unordered_set`功能类似，但不允许重复元素。它与`std::multiset`形成对比，后者保持其元素有序但允许重复。'
- en: Sorting and searching complexity
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序和搜索复杂度
- en: 'Its sorting and search complexity is characterized as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 它的排序和搜索复杂度如下：
- en: '**Sorting**: Not inherently sorted, but you can copy elements to a vector and
    sort them'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**排序**：不是天生有序的，但你可以将元素复制到向量中并对其进行排序'
- en: '**Searching**: *O(1)* average-case complexity for lookups due to hashing'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索**：由于哈希，查找的平均复杂度为*O(1)*'
- en: Special interface and member functions
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊接口和成员函数
- en: 'While it offers standard functions (`insert`, `erase`, `find`), you can also
    explore the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它提供了标准函数（`insert`、`erase`、`find`），但你也可以探索以下内容：
- en: '`count`: Returns the number of elements that match a specific value'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count`：返回与特定值匹配的元素数量'
- en: '`bucket`: Returns the bucket number for a given value'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bucket`：返回给定值的桶号'
- en: '`max_load_factor`: Manages when the container decides to resize'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_load_factor`：管理容器决定何时进行大小调整'
- en: Comparisons
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较操作
- en: Compared to `std::multiset`, this container offers faster average-case performance
    but at the expense of order and potentially higher memory usage.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `std::multiset` 相比，这个容器提供了更快的平均性能，但牺牲了顺序和可能更高的内存使用。
- en: Interactions with algorithms
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与算法的交互
- en: Hash-based containers such as `std::unordered_multiset` don’t always benefit
    as much from STL algorithms that have been optimized for ordered containers. Algorithms
    that don’t rely on element order are preferable (that is, `std::for_each`, `std::count`,
    `std::all_of`, `std::transform`, and others).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 基于哈希的容器，如 `std::unordered_multiset`，并不总是像针对有序容器优化过的 STL 算法那样受益。不依赖于元素顺序的算法更可取（即
    `std::for_each`、`std::count`、`std::all_of`、`std::transform` 等）。
- en: Exceptions
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: Standard exceptions can be thrown for bad allocations. It’s critical to know
    that operations on `std::unordered_multiset` offer strong exception safety.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不良分配可能会抛出标准异常。重要的是要知道对 `std::unordered_multiset` 的操作提供了强大的异常安全性。
- en: Customization
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定制化
- en: The container supports custom allocators and hash functions, allowing for refined
    control over memory allocation and hashing behavior.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 容器支持自定义分配器和哈希函数，允许对内存分配和哈希行为进行精细控制。
- en: Example
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: '`std::unordered_multiset` is similar to `std::unordered_set` but allows multiple
    occurrences of the same element. Like other unordered containers, it uses a hash
    table internally, so it doesn’t maintain any order of elements. The key characteristic
    of `unordered_multiset` is its ability to store duplicates, which can be useful
    in certain applications, such as counting or categorizing items based on some
    criterion.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unordered_multiset` 与 `std::unordered_set` 类似，但允许相同元素的多重出现。与其他无序容器一样，它内部使用哈希表，因此不维护元素的任何顺序。`unordered_multiset`
    的关键特性是其存储重复元素的能力，这在某些应用中可能很有用，例如根据某些标准对项目进行计数或分类。'
- en: 'The following example demonstrates some best practices when using `std::unordered_multiset`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了使用 `std::unordered_multiset` 时的几个最佳实践：
- en: '[PRE4]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here’s the example output:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是示例输出：
- en: '[PRE5]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here are some key takeaways from the preceding code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从前面代码中得出的几个关键要点：
- en: '`std::unordered_multiset` can store duplicate values. Use the `count` method
    to check how many occurrences of a given element exist in the container.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_multiset` 可以存储重复值。使用 `count` 方法检查容器中给定元素出现的次数。'
- en: The `equal_range` function provides a range of iterators pointing to all instances
    of a specific element.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equal_range` 函数提供了一个迭代器范围，指向特定元素的所有实例。'
- en: As with other unordered containers, be conscious of the load factor and consider
    rehashing when necessary.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他无序容器一样，要意识到负载因子，并在必要时考虑重新哈希。
- en: Remember that the elements in `unordered_multiset` are unordered. If you need
    ordered data with duplicate values, you should use `std::multiset`.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住，`unordered_multiset` 中的元素是无序的。如果您需要有序数据且允许重复值，应使用 `std::multiset`。
- en: You’d need to iterate through the set and use the iterator-based `erase()` method
    to erase specific occurrences of a duplicate value. In the preceding example,
    we removed all occurrences of `apple` for simplicity.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要遍历集合并使用基于迭代器的 `erase()` 方法来删除特定重复值的实例。在前面的示例中，我们为了简单起见移除了所有 `apple` 的实例。
- en: Use `std::unordered_multiset` to keep track of elements where the order doesn’t
    matter, and duplicates are allowed. It offers efficient constant-time average
    complexity for insertions, deletions, and lookups.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `std::unordered_multiset` 来跟踪顺序不重要且允许重复的元素。它为插入、删除和查找提供了高效的平均常数时间复杂度。
- en: Best practices
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Let’s explore the best practices of using `std::unordered_multiset`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨使用 `std::unordered_multiset` 的最佳实践：
- en: '`std::unordered_multiset` and `std::unordered_set`. Unlike `std::unordered_set`,
    `std::unordered_multiset` allows duplicates. Choose `std::unordered_multiset`
    if your application must store multiple equivalent keys.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_multiset` 和 `std::unordered_set`。与 `std::unordered_set` 不同，`std::unordered_multiset`
    允许重复。如果您的应用程序必须存储多个等效键，请选择 `std::unordered_multiset`。'
- en: '`std::unordered_multiset` is its ability to handle duplicate elements. This
    is particularly useful in scenarios where you need to track multiple instances
    of an element. However, this also means that operations such as `find()` will
    return an iterator to the first instance of the element, and iterating through
    all duplicates might be necessary for certain operations.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_multiset` 的能力在于处理重复元素。这在需要跟踪元素多个实例的场景中特别有用。然而，这也意味着像 `find()`
    这样的操作将返回元素第一个实例的迭代器，并且对于某些操作可能需要遍历所有重复项。'
- en: '`std::unordered_set`, the performance of `std::unordered_multiset` is affected
    by the load factor. A higher load factor can cause more hash collisions, impacting
    performance. Conversely, a lower load factor, while reducing collisions, can lead
    to memory inefficiency. Use `load_factor()` to monitor and `rehash()` or `max_load_factor()`
    to manage the load factor effectively.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_set`，`std::unordered_multiset` 的性能会受到负载因子的影响。较高的负载因子可能导致更多的哈希冲突，影响性能。相反，较低的负载因子虽然减少了冲突，但可能导致内存效率低下。使用
    `load_factor()` 来监控，并使用 `rehash()` 或 `max_load_factor()` 来有效地管理负载因子。'
- en: '`std::unordered_multiset` for efficient element distribution, especially when
    dealing with custom or complex data types. Implement a specialized hash function
    using `std::hash` template specialization to ensure uniform distribution and minimize
    collision.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::unordered_multiset` 进行高效的元素分布，尤其是在处理自定义或复杂数据类型时。使用 `std::hash` 模板特化实现专门的哈希函数，以确保均匀分布并最小化冲突。
- en: '`std::unordered_multiset` may not be the right choice due to its unordered
    nature. In such cases, consider using `std::multiset`, which maintains order but
    still allows duplicates.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于其无序性，`std::unordered_multiset` 可能不是最佳选择。在这种情况下，考虑使用 `std::multiset`，它维护顺序但仍然允许重复。
- en: '`erase()` function to remove elements. Removing an element by an iterator is
    an *O(1)* operation, whereas removing by value can take up to *O(n)* in the worst
    case. Be mindful of this when designing your erasure strategy, especially in performance-critical
    applications.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `erase()` 函数来删除元素。通过迭代器删除元素是一个 *O(1)* 操作，而通过值删除在最坏情况下可能需要 *O(n)*。在设计删除策略时请注意这一点，尤其是在性能关键的应用中。
- en: '`std::unordered_set`, `std::unordered_multiset` can have higher memory overhead
    due to its hashing mechanism. This should be a consideration in environments where
    memory is a constraint.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_set`，`std::unordered_multiset` 由于其哈希机制，可能会有更高的内存开销。在内存受限的环境中，这应该是一个考虑因素。'
- en: '`std::unordered_multiset` supports concurrent reads but requires external synchronization
    mechanisms for writes or concurrent reads and writes. This is crucial in multi-threaded
    environments to avoid data races and maintain data integrity.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_multiset` 支持并发读取，但写入或并发读取和写入需要外部同步机制。这在多线程环境中至关重要，以避免数据竞争并保持数据完整性。'
- en: '`std::unordered_multiset`, be aware of algorithms that expect a sorted range
    since they are not suitable for an unordered container. Always ensure that the
    chosen algorithm aligns with the characteristics of `std::unordered_multiset`.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_multiset`，请注意那些期望有序范围的算法，因为它们不适合无序容器。始终确保所选算法与 `std::unordered_multiset`
    的特性相匹配。'
- en: std::unordered_multimap
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::unordered_multimap
- en: By blending the principles of `std::unordered_map` and the flexibility of multiplicity,
    this container allows a single key to be associated with multiple values without
    the need to maintain a specific order.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合 `std::unordered_map` 的原则和多重性的灵活性，这个容器允许单个键与多个值相关联，而无需维护特定的顺序。
- en: Purpose and suitability
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目的和适用性
- en: '`std::unordered_multimap` is a hash-based container that permits multiple values
    to be associated with a single key. Unlike `std::unordered_map`, it doesn’t enforce
    unique keys. It’s especially apt in the following scenarios:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unordered_multimap` 是一种基于哈希的容器，允许单个键与多个值相关联。与 `std::unordered_map` 不同，它不强制唯一键。它特别适用于以下场景：'
- en: When quick average-case lookup times are desired
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要快速的平均情况查找时间时
- en: When you anticipate multiple values for the same key
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你预期同一个键会有多个值时
- en: When key order doesn’t matter, as elements aren’t stored in any particular order
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当键的顺序不重要时，因为元素没有存储在任何特定的顺序
- en: Choose `std::unordered_multimap` for situations that require non-unique keys
    and swift lookups. If order or unique keys matter, consider other options.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要非唯一键和快速查找的情况下选择 `std::unordered_multimap`。如果顺序或唯一键很重要，请考虑其他选项。
- en: Ideal use cases
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理想用例
- en: 'The following are some of the ideal use cases for `std::unordered_multimap`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 `std::unordered_multimap` 的理想用例：
- en: '`std::unordered_multimap` is a suitable container. For example, one author
    (key) can have numerous books in a database of authors and their books (values).'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_multimap` 是一个合适的容器。例如，一个作者（键）可以在作者及其书籍（值）的数据库中拥有多本书。'
- en: '`std::unordered_multimap` is beneficial.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_multimap` 是有益的。'
- en: '`std::unordered_multimap` can manage hash collisions by linking collided keys
    to their respective values.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_multimap` 可以通过将冲突键链接到它们相应的值来管理哈希冲突。'
- en: '`std::unordered_multimap` can organize these tag-to-item or item-to-tag relationships.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_multimap` 可以组织这些标签到项目或项目到标签的关系。'
- en: '`std::unordered_multimap` can be an efficient in-memory tool.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_multimap` 可以是一个高效的内存工具。'
- en: '`std::unordered_multimap` can serve as a storage system. As an example, this
    can be useful if you’re grouping people by their birth year, where one year (key)
    can correspond to many people (values).'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_multimap` 可以作为存储系统。例如，如果你按出生年份分组人员，其中一年（键）可以对应许多人（值）。'
- en: '`std::unordered_multimap` is useful. An example would be color-naming systems,
    where one color can have several associated names.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_multimap` 很有用。一个例子是颜色命名系统，其中一种颜色可以有多个相关名称。'
- en: '`std::unordered_multimap` can associate one coordinate with multiple objects
    in that space.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_multimap` 可以将一个坐标与该空间中的多个对象关联起来。'
- en: '`std::unordered_multimap` is a highly versatile tool that’s apt for applications
    where fast insertions and lookups are crucial, and one key should be linked to
    multiple values. When unique keys or ordered data structures are required, other
    containers, such as `std::unordered_map` or `std::set`, might be more fitting.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unordered_multimap` 是一个高度通用的工具，适用于需要快速插入和查找的应用程序，并且一个键应与多个值相关联。当需要唯一键或有序数据结构时，其他容器，如
    `std::unordered_map` 或 `std::set`，可能更合适。'
- en: Performance
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: 'The algorithmic performance of `std::unordered_multimap` is characterized as
    follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unordered_multimap` 的算法性能如下：'
- en: '**Insertion**: Average-case *O(1)*, worst-case *O(n)*'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入**：平均情况 *O(1)*，最坏情况 *O(n)*'
- en: '**Deletion**: Average-case *O(1)*, worst-case *O(n)*'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除**：平均情况 *O(1)*，最坏情况 *O(n)*'
- en: '**Access**: Average-case *O(1)*, worst-case *O(n)*'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问**：平均情况 *O(1)*，最坏情况 *O(n)*'
- en: '**Memory overhead**: Moderate due to hashing infrastructure, potentially increasing
    with hash collisions'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存开销**：由于哈希基础设施，适中，可能因哈希冲突而增加'
- en: Its trade-offs include speedy average-case operations but potential slowdowns
    if hash collisions become prevalent.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 它的权衡包括快速的平均情况操作，但如果哈希冲突变得普遍，可能会出现潜在的减速。
- en: Memory management
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理
- en: '`std::unordered_multimap` resizes when the load factor exceeds its maximum
    value. Allocators can be used to customize memory behavior, including allocation
    and deallocation strategies.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当负载因子超过其最大值时，`std::unordered_multimap` 会进行大小调整。可以使用分配器来定制内存行为，包括分配和释放策略。
- en: Thread safety
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全
- en: Reading from different instances is thread-safe. However, concurrent reading
    and writing to the same instance necessitates external synchronization.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 从不同实例读取是线程安全的。然而，对同一实例的并发读取和写入需要外部同步。
- en: Extensions and variants
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展和变体
- en: '`std::unordered_map` is a variant that holds unique keys. If you need ordered
    key behavior, `std::multimap` and `std::map` are tree-based alternatives.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unordered_map` 是一个包含唯一键的变体。如果你需要有序键行为，`std::multimap` 和 `std::map` 是基于树的替代方案。'
- en: Sorting and searching complexity
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序和搜索复杂度
- en: 'Its sorting and search complexity is characterized as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 它的排序和搜索复杂度如下：
- en: '**Sorting**: Not inherently sortable as it is unordered; must be copied to
    a sortable container'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**排序**：由于其无序性，本身不可排序；必须复制到可排序的容器中'
- en: '**Searching**: Average-case *O(1)* due to hashing, but can degrade in the presence
    of many hash collisions'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索**：由于哈希，平均情况 *O(1)*，但在存在许多哈希冲突的情况下可能会降低'
- en: Special interface and member functions
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊接口和成员函数
- en: 'Beyond common functions (`insert`, `find`, `erase`), dive into the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常见的函数（`insert`、`find`、`erase`）之外，深入了解以下内容：
- en: '`emplace`: Directly constructs the element in the container'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emplace`：直接在容器中构建元素'
- en: '`bucket`: Fetches the bucket number for a given key'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bucket`：获取给定键的桶号'
- en: '`load_factor`: Provides the ratio of elements to buckets'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load_factor`：提供元素到桶的比率'
- en: Comparisons
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较操作
- en: Compared to `std::unordered_map`, this container allows non-unique keys. If
    key order matters, `std::multimap` is a tree-based alternative.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `std::unordered_map` 相比，这个容器允许非唯一键。如果键顺序很重要，`std::multimap` 是一个基于树的替代方案。
- en: Interactions with algorithms
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与算法的交互
- en: Being unordered, many STL algorithms designed for ordered sequences might not
    be directly applicable or would necessitate a different approach.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 由于是无序的，许多为有序序列设计的 STL 算法可能不直接适用，或者需要不同的方法。
- en: Exceptions
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常处理
- en: Failures in memory allocation or hash function complications can throw exceptions.
    Container operations offer basic exception safety, ensuring the container remains
    valid.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 内存分配失败或哈希函数复杂性问题可能会抛出异常。容器操作提供基本的异常安全性，确保容器保持有效。
- en: Customization
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义
- en: You can use custom allocators for memory adjustments. Custom hash functions
    or key equality predicates can also optimize behavior for specific use cases.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用自定义分配器进行内存调整。自定义哈希函数或键相等谓词也可以针对特定用例优化行为。
- en: Example
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: '`std::unordered_multimap` is similar to `std::unordered_map` but allows for
    multiple key-value pairs with equivalent keys. It is an associative container,
    meaning its value type is formed by combining its key and mapped types.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unordered_multimap` 与 `std::unordered_map` 类似，但允许具有等效键的多个键值对。它是一个关联容器，其值类型是通过结合其键和映射类型形成的。'
- en: 'The following code example demonstrates some best practices when using `std::unordered_multimap`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例演示了使用 `std::unordered_multimap` 的一些最佳实践：
- en: '[PRE6]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here’s the example output:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是示例输出：
- en: '[PRE7]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here are some key takeaways from the preceding code:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是从前面的代码中得出的几个要点：
- en: With `std::unordered_multimap`, it is possible to insert multiple key-value
    pairs with the same key.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `std::unordered_multimap` 中，可以插入具有相同键的多个键值对。
- en: You can use `equal_range` to get a range of iterators to all the key-value pairs
    with a specific key.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `equal_range` 获取与特定键关联的所有键值对的迭代器范围。
- en: The `count` method helps you determine the number of key-value pairs with a
    specific key.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count` 方法可以帮助您确定具有特定键的键值对数量。'
- en: Like other unordered containers, you should be aware of the load factor and
    might want to rehash it if necessary to achieve optimal performance.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如同其他无序容器一样，您应该注意负载因子，并在必要时重新散列以实现最佳性能。
- en: Using the `erase()` method with a key will remove all the key-value pairs associated
    with that key.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用带有键的 `erase()` 方法将删除与该键关联的所有键值对。
- en: Since it is an unordered container, the order of the elements is not guaranteed.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它是一个无序容器，元素的顺序是不保证的。
- en: Use `std::unordered_multimap` when you need to keep track of multiple values
    associated with the same key and don’t need the key-value pairs to be sorted.
    It provides average constant-time complexity for most operations.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您需要跟踪与同一键关联的多个值且不需要对键值对进行排序时，请使用 `std::unordered_multimap`。它为大多数操作提供平均常数时间复杂度。
- en: Best practices
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Let’s explore the best practices of using `std::unordered_multimap`:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索使用 `std::unordered_multimap` 的最佳实践：
- en: '`std::unordered_multimap` signifies that the container maintains no specific
    order for its key-value pairs. Iterating through the container does not guarantee
    any particular sequence.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_multimap` 表示容器不维护其键值对的具体顺序。遍历容器不保证任何特定序列。'
- en: '`std::unordered_multimap` is its ability to store multiple entries for a single
    key. Remember this when inserting, erasing, or searching to avoid unintended logic
    errors.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_multimap` 的能力是存储单个键的多个条目。在插入、删除或搜索时记住这一点，以避免意外的逻辑错误。'
- en: '`load_factor()` function to monitor the current load factor. If it gets too
    high, consider rehashing the container using the `rehash()` function. It’s also
    possible to set a desired upper limit on the load factor with the `max_load_factor()`
    function.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `load_factor()` 函数来监控当前的负载因子。如果它变得过高，可以考虑使用 `rehash()` 函数重新散列容器。也可以使用 `max_load_factor()`
    函数设置负载因子的期望上限。
- en: '`std::hash` template specialization for custom data types to ensure efficient
    and consistent hashing.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为自定义数据类型提供 `std::hash` 模板特化，以确保高效且一致的散列。
- en: '**Handle hash collisions**: Even with an efficient hash function, collisions
    might occur. The container handles these internally, but awareness of them helps
    with making better design decisions. Collisions can lead to a performance drop
    in insertion and search operations, so balancing the load factor and the number
    of buckets is essential.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理哈希冲突**：即使有高效的哈希函数，也可能发生冲突。容器内部处理这些冲突，但了解它们有助于做出更好的设计决策。冲突可能导致插入和搜索操作的性能下降，因此平衡负载因子和桶的数量是至关重要的。'
- en: '`equal_range()` when iterating through all values associated with a specific
    key.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在遍历与特定键关联的所有值时使用 `equal_range()`。
- en: '**Iterator invalidation**: Iterator invalidation can be a concern, especially
    after operations such as rehashing. Always ensure that iterators, pointers, or
    references to the elements are not used after they might have been invalidated.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迭代器失效**：迭代器失效可能是一个问题，尤其是在重新散列等操作之后。始终确保在可能失效之后不使用指向元素的迭代器、指针或引用。'
- en: '`emplace` or `emplace_hint` methods. These allow the key-value pair to be constructed
    directly within the container.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emplace` 或 `emplace_hint` 方法。这些方法允许在容器内直接构造键值对。'
- en: '**Concurrency considerations**: Concurrent reads are thread-safe, but you’ll
    need external synchronization for any modifications or concurrent reads and writes.
    Use synchronization primitives such as mutexes in multi-threaded scenarios.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发考虑**: 并发读取是线程安全的，但对于任何修改或并发读取和写入，你需要外部同步。在多线程场景中使用同步原语，如互斥锁（mutexes）。'
- en: '`std::unordered_multimap`. However, ensure the selected algorithm doesn’t expect
    ordering or unique keys, since those assumptions would contradict the container’s
    properties.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_multimap`。然而，确保选定的算法不期望排序或唯一键，因为这些假设会与容器的属性相矛盾。'
