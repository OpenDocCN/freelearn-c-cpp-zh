- en: Objects, Classes, and Inheritance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象、类和继承
- en: In the previous chapter, we discussed functions as a way to bundle up a bunch
    of lines of related code. We talked about how functions abstract away implementation
    details and how the `sqrt()` function does not require you to understand how it
    works internally to use it to find roots. This is a good thing, primarily because
    it saves programmers time and effort, while making the actual work of finding
    square roots easier. This principle of abstraction will come up again here, when
    we discuss objects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了函数作为捆绑一堆相关代码行的方式。我们谈到了函数如何抽象出实现细节，以及`sqrt()`函数不需要您了解其内部工作原理就可以使用它来查找根。这是一件好事，主要是因为它节省了程序员的时间和精力，同时使查找平方根的实际工作变得更容易。当我们讨论对象时，这种抽象原则将再次出现。
- en: 'In this chapter, we will be covering:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: What is an object?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是对象？
- en: Structs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体
- en: Class versus struct
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类与结构体
- en: Getters and setters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取器和设置器
- en: Constructors and destructors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数和析构函数
- en: Class inheritance
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类继承
- en: Multiple inheritance
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多重继承
- en: Putting your class into headers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您的类放入头文件
- en: Object oriented programming design patterns
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象的编程设计模式
- en: Callable objects and invoke
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可调用对象和调用
- en: This chapter contains a lot of keywords that might be difficult to grasp at
    first, including `virtual` and `abstract`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含许多关键字，可能一开始很难理解，包括`virtual`和`abstract`。
- en: Don't let the more difficult sections of this chapter bog you down. I included
    descriptions of many advanced concepts for completeness. However, bear in mind
    that you don't need to completely understand everything in this chapter to write
    working C++ code in UE4\. It helps to understand everything, but if something
    doesn't make sense, don't get stuck. Give it a read and then move on. Probably
    what will happen is you will not get it at first, but remember a reference to
    the concept in question when you're coding. Then, when you open this book up again,
    voilà! It will make sense.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 不要让本章中更困难的部分拖住你。我包括了许多高级概念的描述以确保完整性。但请记住，您不需要完全理解本章的所有内容才能编写在UE4中工作的C++代码。理解一切是有帮助的，但如果有些东西不合理，不要陷入困境。阅读一下，然后继续。可能会发生的情况是，一开始你可能不明白，但在编码时记住相关概念的参考。然后，当您再次打开这本书时，哇！它就会有意义了。
- en: What is an object?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是对象？
- en: In a nutshell, objects tie together methods (another word for functions) and
    their related data into a single structure. This structure is called a class.
    The main idea behind using objects is to create a code representation for everything
    inside your game. Every object represented in the code will have data and associated
    functions that operate on that data. So, you'd have an object to represent your
    `Player` and related functions that make the `Player` `jump()`, `shoot()`, and
    `pickupItem()`. You'd also have an object to represent every monster instance
    and related functions, such as `growl()`, `attack()`, and possibly `follow()`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，对象将方法（另一个词是函数）及其相关数据绑定到一个结构中。这个结构称为类。使用对象的主要思想是为游戏中的每个事物创建一个代码表示。代码中表示的每个对象都将具有操作该数据的数据和相关函数。因此，您将有一个对象来表示您的`Player`和相关函数，使`Player`可以`jump()`、`shoot()`和`pickupItem()`。您还将有一个对象来表示每个怪物实例和相关函数，如`growl()`、`attack()`，可能还有`follow()`。
- en: Objects are types of variables, though, and objects will stay in memory as long
    as you keep them there. You create an instance, or a specific representation of
    an object with it's own set of values, once when the thing in your game it represents
    is created, and you destroy the object instance when the thing in your game it
    represents dies.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是变量类型，对象将在内存中保留，只要您保留它们。当您的游戏中的事物创建时，您创建一个实例或特定表示对象的实例，并在表示的事物死亡时销毁对象实例。
- en: Objects can be used to represent in-game things, but they can also be used to
    represent any other type of thing. For example, you can store an image as an object.
    The data fields will be the image's width of the image, its height, and the collection
    of pixels inside it. C++ strings are also objects.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对象可以用来表示游戏中的事物，但也可以用来表示任何其他类型的事物。例如，您可以将图像存储为对象。数据字段将是图像的宽度，高度和其中的像素集合。C++字符串也是对象。
- en: The struct object
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构对象
- en: 'An object in C++ is basically any variable type that is made up of a conglomerate
    of simpler types. The most basic object in C++ is `struct`. We use the `struct`
    keyword to glue together a bunch of smaller variables into one big variable. If
    you recall, we did introduce `struct` briefly in [Chapter 2](080d0c73-c0d8-42b6-a2ad-7025ee001924.xhtml),
    *Variables and Memory*. Let''s revise that simple example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，对象基本上是由一堆更简单的类型组成的任何变量类型。C++中最基本的对象是`struct`。我们使用`struct`关键字将一堆较小的变量粘合成一个大变量。如果您回忆起来，我们在[第2章](080d0c73-c0d8-42b6-a2ad-7025ee001924.xhtml)
    *变量和内存*中简要介绍了`struct`。让我们回顾一下那个简单的例子：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is the structure definition for what makes a `Player` object. The `Player`
    has a `string` for their `name` and an integer for their `hp` value.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是定义`Player`对象的结构。`Player`有一个`name`的`string`和一个`hp`值的整数。
- en: 'If you recall from [Chapter 2](080d0c73-c0d8-42b6-a2ad-7025ee001924.xhtml),
    *Variables and Memory*, the way we make an instance of the `Player` object is
    like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您回忆一下[第2章](080d0c73-c0d8-42b6-a2ad-7025ee001924.xhtml) *变量和内存*，我们创建`Player`对象的实例的方式如下：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'From here, we can access the fields of the `me` object like so:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以这样访问`me`对象的字段：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Member functions
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成员函数
- en: 'Now, here''s the exciting part. We can attach member functions to the `struct`
    definition simply by writing these functions inside the `struct Player` definition:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是令人兴奋的部分。我们可以通过在`struct Player`定义内部编写这些函数来将成员函数附加到`struct`定义中：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A member function is just a C++ function that is declared inside a `struct`
    or `class` definition.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 成员函数只是在`struct`或`class`定义内声明的C++函数。
- en: There is a bit of a funny idea here, so I'll just come out and say it. The variables
    of `struct Player` are accessible to all the functions inside `struct Player`.
    Inside each of the member functions of `struct Player`, we can actually access
    the `name` and `hp` variables as if they were local to the function. In other
    words, the `name` and `hp` variables of `struct Player` are shared between all
    the member functions of `struct Player`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有趣的想法，所以我会直接说出来。`struct Player`的变量对`struct Player`内部的所有函数都是可访问的。在`struct
    Player`的每个成员函数内部，我们实际上可以访问`name`和`hp`变量，就好像它们是函数内部的局部变量一样。换句话说，`struct Player`的`name`和`hp`变量在`struct
    Player`的所有成员函数之间是共享的。
- en: The this keyword
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: this关键字
- en: 'In some C++ code (in later chapters), you will see more references to the `this`
    keyword. The `this` keyword is a pointer that refers to the current object. Inside
    the `Player::damage()` function, for example, we can write our reference to `this`
    explicitly:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些C++代码（在后面的章节中），你会看到更多关于`this`关键字的引用。`this`关键字是一个指针，指向当前对象。例如，在`Player::damage()`函数内部，我们可以显式地写出对`this`的引用：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `this` keyword only makes sense inside a member function. We could explicitly
    include the use of the `this` keyword inside member functions, but without writing
    `this`, it is implied that we are talking about the `hp` of the current object.
    So, while this is not strictly necessary in most cases, it may be a personal or
    company preference and could make the code more readable.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`关键字只在成员函数内部有意义。我们可以在成员函数内部显式地包含`this`关键字的使用，但是不写`this`时，暗示着我们正在谈论当前对象的`hp`。因此，虽然在大多数情况下这并不是严格必要的，但这可能是个人或公司的偏好，并且可以使代码更易读。'
- en: Are strings objects?
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串是对象吗？
- en: Yes, strings are objects! Every time you've used a `string` variable in the
    past, you were using an object. Let's try out some of the member functions of
    the `string` class.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，字符串是对象！每次你过去使用`string`变量时，你都在使用一个对象。让我们尝试一些`string`类的成员函数。
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What we've done here is use the `append()` member function to add on two extra
    characters to the end of the string (`!!`). Member functions always apply to the
    object that calls the member function (the object to the left of the dot).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是使用`append()`成员函数在字符串的末尾添加两个额外的字符(`!!`)。成员函数总是适用于调用成员函数的对象（点左边的对象）。
- en: 'To see the listing of members and member functions available on an object,
    follow these steps:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看对象上可用的成员和成员函数的列表，请按照以下步骤操作：
- en: Type the object's variable name in Visual Studio
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中输入对象的变量名
- en: Then type a dot (`.`)
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后输入一个点(`.`)
- en: Then press *Ctrl* and the spacebar
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后按下*Ctrl*和空格键
- en: 'A member listing will pop up as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 成员列表将如下弹出：
- en: '![](img/5b34de60-8c71-4702-9af6-e80b967e0264.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b34de60-8c71-4702-9af6-e80b967e0264.png)'
- en: Pressing Ctrl and the spacebar will make the member listing appear
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 按下Ctrl和空格键将使成员列表出现
- en: Invoking a member function
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用成员函数
- en: 'Member functions can be invoked with the following syntax:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 成员函数可以用以下语法调用：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The object invoking the member function is on the left of the dot. The member
    function to call is on the right of the dot. A member function invocation is always
    followed by round brackets `()`, even when no arguments are passed to the brackets.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 调用成员函数的对象在点的左边。要调用的成员函数在点的右边。成员函数调用总是在圆括号`()`后面，即使没有参数传递给括号。
- en: 'So, in the part of the program where the monster attacks, we can reduce the
    `player`''s `hp` value as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在程序中怪物攻击的部分，我们可以按如下方式减少`player`的`hp`值：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Isn't that more readable than the following?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这比以下更可读吗？
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When member functions and objects are used effectively, your code will read
    more like prose or poetry than a bunch of operator symbols slammed together.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当成员函数和对象有效地使用时，你的代码将更像散文或诗歌，而不是一堆操作符符号拼在一起。
- en: Besides beauty and readability, what is the point of writing member functions?
    Outside the `Player` object, we can now do more with a single line of code than
    just reduce the `hp` member by `15`. We can also do other things as we're reducing
    the `player`'s `hp`, such as take into account the `player`'s armor, check whether
    the player is invulnerable, or have other effects occur when the `Player` is damaged.
    What happens when the player is damaged should be abstracted away by the `damage()`
    function.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 除了美观和可读性，编写成员函数的目的是什么？在`Player`对象之外，我们现在可以用一行代码做更多事情，而不仅仅是减少`hp`成员15。当`player`受到伤害时，我们还可以做其他事情，比如考虑`player`的护甲，检查玩家是否无敌，或者在`Player`受到伤害时发生其他效果。玩家受到伤害时发生的事情应该由`damage()`函数抽象出来。
- en: 'Now, imagine the `Player` had an `armorClass`. Let''s add a field to `struct
    Player` for `armorClass`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下`Player`有一个`armorClass`。让我们为`struct Player`添加一个`armorClass`字段：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We''d need to reduce the damage received by the `Player` by the armor class
    of the `Player`. So, we''d type a formula to reduce `hp`. We can do it the non-object-oriented
    way by accessing the data fields of the `Player` object directly:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要减少`Player`的护甲等级所受到的伤害。因此，我们需要输入一个公式来减少`hp`。我们可以通过直接访问`Player`对象的数据字段来以非面向对象的方式进行：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Otherwise, we can do it the object-oriented way by writing a member function
    that changes the data members of the `Player` object as needed. Inside the `Player`
    object, we can write a `damage()` member function:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们可以通过编写一个更改`Player`对象的数据成员的成员函数来以面向对象的方式进行。在`Player`对象内部，我们可以编写一个`damage()`成员函数：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Exercises
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'There is a subtle bug in the `Player`''s `damage` function in the preceding
    code. Can you find and fix it? Hint: what happens if the damage dealt is less
    than the `armorClass` of the `Player`?'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上述代码中`Player`的`damage`函数中存在一个细微的错误。你能找到并修复它吗？提示：如果造成的伤害小于`Player`的`armorClass`会发生什么？
- en: Having only a number for armor class doesn't give enough information about the
    armor! What is the armor's name? What does it look like? Devise a `struct` function
    for the `Player`'s armor with fields for `name`, `armorClass`, and `durability`
    rating.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有一个装甲等级的数字并不能提供关于装甲的足够信息！装甲的名字是什么？它是什么样子？为“Player”的装甲设计一个`struct`函数，其中包括`name`、`armorClass`和`durability`等字段。
- en: Solutions
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: The solution to the first exercise is in the `struct Player` code listed in
    the next section, *Privates and encapsulation*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个练习的解决方案在下一节“私有和封装”中列出的“struct Player”代码中。
- en: For the second, how about using the following code?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个问题，如何使用以下代码？
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'An instance of `Armor` will then be placed inside `struct Player`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在“struct Player”内放置一个“Armor”的实例：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This means the `Player` has an armor. Keep this in mind—we'll explore `has-a`
    versus `is-a` relationships later.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着“Player”有一套装甲。记住这一点——我们将在以后探讨“有一个”与“是一个”关系。
- en: All variable names thus far start with a lowercase character. This is a good
    convention with C++ code. You may find some cases where specific teams or other
    languages prefer to use uppercase characters to start variable names, in which
    case it's better to just do what people at your company expect.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有变量名称都以小写字符开头。这是C++代码的一个良好约定。你可能会发现一些特定团队或其他语言更喜欢使用大写字符来开始变量名称的情况，在这种情况下，最好只做你的公司的人们期望你做的事情。
- en: Privates and encapsulation
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 私有和封装
- en: So now we've defined a couple of member functions, whose purpose it is to modify
    and maintain the data members of our `Player` object, but some people have come
    up with an argument.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在我们定义了一些成员函数，其目的是修改和维护我们的“Player”对象的数据成员，但有些人提出了一个论点。
- en: 'The argument is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 论点如下：
- en: An object's data members should only ever be accessed through its member functions,
    never directly.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的数据成员应该只能通过其成员函数访问，而不是直接访问。
- en: 'This means that you should never access an object''s data members from outside
    the object directly, in other words, modify the `player`''s `hp` directly:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你不应该直接从对象外部访问对象的数据成员，换句话说，直接修改“player”的“hp”：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This should be forbidden, and users of the class should be forced to use the
    proper member functions to change the values of data members instead:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该是被禁止的，类的用户应该被强制使用正确的成员函数来改变数据成员的值：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This principle is called *encapsulation*. Encapsulation is the concept that
    every object should be interacted via its member functions only. Encapsulation
    says that raw data members should never be accessed directly.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则被称为*封装*。封装是每个对象都应该只通过其成员函数进行交互的概念。封装表示不应直接访问原始数据成员。
- en: 'The reasons behind encapsulation are as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 封装背后的原因如下：
- en: '**To make the class self-contained**: The primary idea behind encapsulation
    is that objects work best when they are programmed such that they manage and maintain
    their own internal state variables without the need for code outside the class
    to examine that class''s private data. When objects are coded this way, it makes
    the object much easier to work with, that is, easier to read and maintain. To
    make the `Player` object jump, you should just have to call `player.jump()`; let
    the `Player` object manage state changes to its `y-height` position (making the
    `Player` jump!). When an object''s internal members are not exposed, interacting
    with that object is much easier and more efficient. Interact only with an object''s
    public member functions; let the object manage its internal state (we will explain
    the keywords `private` and `public` in a moment).'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使类自包含：封装背后的主要思想是，对象在被编程时最好是这样的，即它们管理和维护自己的内部状态变量，而不需要类外部的代码来检查该类的私有数据。当对象以这种方式编码时，使对象更容易使用，即更容易阅读和维护。要使“Player”对象跳跃，你只需调用“player.jump()”；让“Player”对象管理其“y-height”位置的状态变化（使“Player”跳跃！）。当对象的内部成员未暴露时，与该对象的交互变得更加容易和高效。只与对象的公共成员函数交互；让对象管理其内部状态（我们将在下一节中解释关键字“private”和“public”）。
- en: '**To avoid breaking code**: When code outside of a class interacts with that
    class''s public member functions only (the class''s public interface), then an
    object''s internal state management is free to change, without breaking any of
    the calling code. This way, if an object''s internal data members change for any
    reason, all code using the object still remains valid, as long as the member functions''
    signatures - the names, return types, and any parameters—remain the same.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了避免破坏代码：当类外部的代码只与该类的公共成员函数（类的公共接口）交互时，对象的内部状态管理可以自由更改，而不会破坏任何调用代码。这样，如果对象的内部数据成员因任何原因而更改，只要成员函数的签名（名称、返回类型和任何参数）保持不变，所有使用对象的代码仍然有效。
- en: So, how can we prevent a programmer from doing the wrong thing and accessing
    data members directly? C++ introduces the concept of *access modifiers* to prevent
    accessing an object's internal data.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何防止程序员做错事并直接访问数据成员？C++引入了*访问修饰符*的概念，以防止访问对象的内部数据。
- en: Here is how we'd use access modifiers to forbid access to certain sections of
    `struct Player` from outside of `struct Player`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何使用访问修饰符来禁止从“struct Player”外部访问某些部分。
- en: The first thing you'd do is decide which sections of the `struct` definition
    you want to be accessible outside of the class. These sections will be labelled
    `public`. All other regions that will not be accessible outside of `struct` will
    be labelled `private`,
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你要做的第一件事是决定“struct”定义的哪些部分可以在类外部访问。这些部分将被标记为“public”。所有其他不可在“struct”外部访问的区域将被标记为“private”。
- en: 'as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如下：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Some people like it public
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有些人喜欢公开
- en: Some people do unabashedly use `public` data members and do not encapsulate
    their objects. This is a matter of preference, though is considered bad object-oriented
    programming practice.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人毫不掩饰地使用`public`数据成员，并且不封装他们的对象。尽管这是一种偏好，但被认为是不良的面向对象编程实践。
- en: However, classes in UE4 do use `public` members sometimes. It's a judgment call;
    whether a data member should be `public` or `private` is really up to the programmer.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在UE4中的类有时会使用`public`成员。这是一个判断;数据成员应该是`public`还是`private`，这真的取决于程序员。
- en: With experience, you will find that, sometimes, you get into a situation that
    requires quite a bit of refactoring (modifying code) when you make a data member
    `public` that should have been `private`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过经验，您会发现，有时，当您将应该是`private`的数据成员变为`public`时，您需要进行相当多的重构（修改代码）。
- en: The class keyword versus struct
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类关键字与结构体
- en: 'You might have seen a different way of declaring an object, using the `class`
    keyword, instead of `struct`, as shown in the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经看到了使用`class`关键字而不是`struct`来声明对象的不同方式，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `class` and `struct` keywords in C++ are almost identical. There is only
    one difference between `class` and `struct`, and that is that the data members
    inside a `struct` keyword will be declared `public` by default, while in a `class`
    keyword, the data members inside the class will be declared `private` by default.
    (This is why I introduced objects using `struct`; I didn't want to inexplicably put
    `public` as the first line of `class`.)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的`class`和`struct`关键字几乎是相同的。`class`和`struct`之间只有一个区别，那就是`struct`关键字内部的数据成员将默认声明为`public`，而在`class`关键字内部，类内部的数据成员将默认声明为`private`。（这就是我使用`struct`引入对象的原因；我不想莫名其妙地将`public`作为`class`的第一行。）
- en: In general, `struct` is preferred for simple types that don't use encapsulation,
    don't have many member functions, and must be backward-compatible with C. Classes
    are used almost everywhere else.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，`struct`更适用于不使用封装、没有许多成员函数并且必须向后兼容C的简单类型。类几乎在任何其他地方都可以使用。
- en: From now on, let's use the `class` keyword instead of `struct`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，让我们使用`class`关键字而不是`struct`。
- en: Getters and setters
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取器和设置器
- en: You might have noticed that, once we slap `private` onto the `Player` class
    definition, we can no longer read or write the name of the `Player` from outside
    the `Player` class.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，一旦我们在`Player`类定义中加入`private`，我们就无法从`Player`类外部读取或写入`Player`的名称。
- en: 'Say we try and read the name with the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们尝试使用以下代码读取名称：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Or write to the name, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 或者写入名称，如下：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Using the `struct Player` definition with `private` members, we will get the
    following error:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有`private`成员的`struct Player`定义，我们将得到以下错误：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is just what we asked for when we labeled the `name` field `private`. We
    made it completely inaccessible outside the `Player` class.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们在将`name`字段标记为`private`时所要求的。我们使其在`Player`类外部完全无法访问。
- en: Getters
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取器
- en: 'A getter (also known as an accessor function) is used to pass back copies of
    internal data members to the caller. To read the `Player`''s name, we''d deck
    out the `Player` class with a member function, specifically to retrieve a copy
    of that `private` data member:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 获取器（也称为访问器函数）用于将内部数据成员的副本传递给调用者。要读取`Player`的名称，我们将`Player`类装饰为一个成员函数，专门用于检索该`private`数据成员的副本：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'So, now it is possible to read the `player`''s `name` information. We can do
    this by using the following code statement:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在可以读取`player`的`name`信息。我们可以使用以下代码语句来实现：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Getters are used to retrieve `private` members that would otherwise be inaccessible
    to you from outside the class.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 获取器用于检索`private`成员，否则您将无法从类外部访问。
- en: Real world tip - the const keyword
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界提示-const关键字
- en: 'Inside a class, you can add the `const` keyword to a member function declaration.
    What the `const` keyword does is promise to the compiler that the internal state
    of the object will not change as a result of running this function. Attaching
    the `const` keyword will look something like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在类内部，您可以在成员函数声明中添加`const`关键字。`const`关键字的作用是向编译器承诺，对象的内部状态不会因运行此函数而改变。附加`const`关键字看起来像这样：
- en: '`string getName() const`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`string getName() const`'
- en: '`{`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '`return name;`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 返回名称;
- en: '`}`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: No assignments to data members can happen inside a member function that is marked `const`.
    As the internal state of the object is guaranteed not to change as a result of
    running a `const` function, the compiler can make some optimizations regarding
    function calls to `const` member functions.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在标记为`const`的成员函数内部不能对数据成员进行赋值。由于对象的内部状态保证不会因运行`const`函数而改变，编译器可以对`const`成员函数的函数调用进行一些优化。
- en: Setters
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置器
- en: 'A setter (also known as a modifier function or mutator function) is a member
    function whose sole purpose is to change the value of an internal variable inside
    the class, as shown in the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 设置器（也称为修改器函数或变异器函数）是一个成员函数，其唯一目的是更改类内部变量的值，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So we can still change a `private` variable in a `class` from outside the `class`
    function, but only if we do so through a setter function.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们仍然可以从类函数外部更改`private`变量，但只能通过设置函数来实现。
- en: But what's the point of get/set operations?
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 但是获取/设置操作有什么意义呢？
- en: So, the first question that crosses a newbie programmer's mind when they first
    encounter get/set operations on `private` members is, isn't get / set self-defeating?
    I mean, what's the point in hiding access to data members when we're just going
    to expose that same data again in another way? It's like saying, *"You can't have
    any chocolates because they are private, unless you say please* `getMeTheChocolate()`.
    *Then, you can have the chocolates."*
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当新手程序员第一次遇到对`private`成员进行获取/设置操作时，脑海中首先出现的问题是，获取/设置不是自相矛盾吗？我的意思是，当我们以另一种方式公开相同数据时，隐藏对数据成员的访问有什么意义呢？这就像说，“你不能吃巧克力，因为它们是私有的，除非你说请*
    `getMeTheChocolate()`。*然后，你可以吃巧克力。”
- en: 'Some expert programmers even shorten the get/set functions to one-liners, like
    this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一些专家程序员甚至将获取/设置函数缩短为一行，就像这样：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Let's answer the question. Doesn't a get/set pair break encapsulation by exposing
    the data completely?
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来回答这个问题。获取/设置对暴露数据会破坏封装吗？
- en: The answer is twofold. First, get member functions typically only return a copy
    of the data member being accessed. This means that the original data member's
    value remains protected and is not modifiable through a `get()` operation.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是双重的。首先，获取成员函数通常只返回被访问的数据成员的副本。这意味着原始数据成员的值保持受保护，并且不能通过`get()`操作进行修改。
- en: A `set()` (mutator method) operation is a little bit counter-intuitive though.
    If the setter is a `passthru` operation, such as `void setName( string newName
    ) { name=newName; }`, then having the setter might seem pointless. What is the
    advantage of using a mutator method instead of overwriting the variable directly?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`set()`（mutator方法）操作有点反直觉。如果setter是一个`passthru`操作，比如`void setName( string newName
    ) { name=newName; }`，那么拥有setter可能看起来毫无意义。使用mutator方法而不是直接覆盖变量的优势是什么？'
- en: The argument for using mutator methods is to write additional code before the
    assignment of a variable to guard the variable from taking on incorrect values.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用mutator方法的论点是在变量分配之前编写额外的代码，以防止变量采用不正确的值。
- en: 'Say, for example, we have a setter for the `hp` data member, which will look
    like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们为`hp`数据成员创建一个setter，它将如下所示：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The mutator method is supposed to prevent the internal `hp` data member from
    taking on negative values. You might consider mutator methods a bit retroactive.
    Should the responsibility lie with the calling code to check the value it is setting
    before calling `setHp( -2 )`, and not let that only get caught in the mutator
    method? Can't you use a `public` member variable and put the responsibility for
    making sure the variable doesn't take on invalid values in the calling code, instead
    of in the setter? You can.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: mutator方法应该防止内部的`hp`数据成员采用负值。您可能认为mutator方法有点事后诸葛亮。调用代码应该在调用`setHp( -2 )`之前检查它设置的值，而不是只在mutator方法中捕获。您可以使用`public`成员变量，并将确保变量不采用无效值的责任放在调用代码中，而不是在setter中。
- en: This is the core reason behind using mutator methods. The idea behind mutator
    methods is that the calling code can pass any value it wants to the `setHp` function
    (for example, `setHp( -2 )`), without having to worry whether the value it is
    passing to the function is valid or not. The `setHp` function then takes the responsibility
    of ensuring that the value is valid for the `hp` variable.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用mutator方法的核心原因。mutator方法的理念是，调用代码可以将任何值传递给`setHp`函数（例如`setHp( -2 )`），而无需担心传递给函数的值是否有效。然后，`setHp`函数负责确保该值对于`hp`变量是有效的。
- en: Some programmers consider direct mutator functions such as `getHp()`/`setHp()`
    a code smell. A code smell is, in general, a bad programming practice that people
    don't overtly take notice of, except for a niggling feeling that something is
    being done sub-optimally. They argue that higher-level member functions can be
    written instead of mutators. For example, instead of a `setHp()` member function,
    we should have `public` member functions such as `heal()` and `damage()` instead.
    An article on this topic is available at [http://c2.com/cgi/wiki?AccessorsAreEvil](http://c2.com/cgi/wiki?AccessorsAreEvil).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员认为直接的mutator函数，如`getHp()`/`setHp()`是一种代码异味。代码异味通常是一种糟糕的编程实践，人们通常不会明显注意到，只是会有一种不太优化的感觉。他们认为可以编写更高级别的成员函数来代替mutators。例如，我们应该有`public`成员函数`heal()`和`damage()`，而不是`setHp()`成员函数。关于这个主题的文章可以在[http://c2.com/cgi/wiki?AccessorsAreEvil](http://c2.com/cgi/wiki?AccessorsAreEvil)找到。
- en: Constructors and destructors
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数和析构函数
- en: 'The constructor in your C++ code is a simple little function that runs once
    when the C++ object instance is first created. The destructor runs once when the
    C++ object instance is destroyed. Say we have the following program:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的C++代码中，构造函数是一个简单的小函数，当C++对象实例首次创建时运行一次。析构函数在C++对象实例被销毁时运行一次。假设我们有以下程序：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, we have created a `Player` object. The output of this code will be as
    follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个`Player`对象。这段代码的输出将如下所示：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The first thing that happens during object construction is that the constructor
    actually runs. This prints the line `Player object constructed`. Following this,
    the line with the `Player`''s name gets printed: `Player named ''Diplo''`. Why
    is the `Player` named Diplo? Because that is the name assigned in the `Player()`
    constructor.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对象构造期间发生的第一件事是构造函数实际运行。这打印出`Player object constructed`。随后，打印出带有`Player`名称的行：`Player
    named 'Diplo'`。为什么`Player`被命名为Diplo？因为这是在`Player()`构造函数中分配的名称。
- en: Finally, at the end of the program, the `Player` destructor gets called, and
    we see `Player object destroyed`. The `Player` object gets destroyed when it goes
    out of scope at the end of `main()` (at `}` of `main`).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在程序结束时，`Player`析构函数被调用，我们看到`Player object destroyed`。当`Player`对象在`main()`结束时（在`main`的`}`处）超出范围时，`Player`对象被销毁。
- en: 'So, what are constructors and destructors good for? Exactly what they appear
    to be for: setting up and tearing down an object. The constructor can be used
    for the initialization of data fields, and the destructor to call `delete` on
    any dynamically allocated resources (we haven''t covered dynamically allocated
    resources yet, so don''t worry about this last point).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，构造函数和析构函数有什么好处？确切地说，它们的作用是设置和销毁对象。构造函数可用于初始化数据字段，析构函数可调用`delete`释放任何动态分配的资源（我们还没有涵盖动态分配的资源，所以不用担心这一点）。
- en: Class inheritance
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类继承
- en: You use inheritance when you want to create a new, more functional class of
    code, based on an existing class of code. Inheritance is a tricky topic to cover.
    Let's start with the concept of a derived class (or subclass).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要基于现有代码类创建一个新的、更功能强大的代码类时，您使用继承。继承是一个棘手的话题。让我们从派生类（或子类）的概念开始。
- en: Derived classes
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 派生类
- en: 'The most natural way to consider inheritance is by analogy with the animal
    kingdom. The classification of living things is shown in the following diagram:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑继承的最自然的方式是通过与动物王国的类比。生物的分类如下图所示：
- en: '![](img/b3b310e9-d3c3-4849-bf72-f2a09006fd81.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b3b310e9-d3c3-4849-bf72-f2a09006fd81.png)'
- en: What this diagram means is that **Dog**, **Cat**, **Horse**, and **Human** are
    all mammals. What that means is that they all all share some common characteristics,
    such as having common organs (a brain with a neocortex, lungs, a liver, and a
    uterus in females), while being completely different in other regards. How each
    walks is different. How each communicates is also different.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表的意思是**Dog**、**Cat**、**Horse**和**Human**都是哺乳动物。这意味着它们都共享一些共同的特征，比如拥有共同的器官（带有新皮质的大脑、肺、肝脏和雌性子宫），而在其他方面完全不同。它们的行走方式不同。它们的交流方式也不同。
- en: What would that mean if you were coding creatures? You would only have to program
    the common functionality once. Then, you would implement the code for the different
    parts specifically for each of the `Dog`, `Cat`, `Horse`, and `Human` classes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在编写生物代码，那意味着你只需要编写一次共同的功能。然后，你会为`Dog`、`Cat`、`Horse`和`Human`类中的每个不同部分专门实现代码。
- en: 'A concrete example of the preceding diagram is as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 前面图表的一个具体例子如下：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: All of `Dog`, `Cat`, and `Human` inherit from `class Mammal`. This means that
    `dog`, `cat`, and `human` are mammals, and many more.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的`Dog`、`Cat`和`Human`都继承自`class Mammal`。这意味着`dog`、`cat`和`human`都是哺乳动物，还有更多。
- en: Syntax of inheritance
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承的语法
- en: 'The syntax of inheritance is quite simple. Let''s take the `Human` class definition
    as an example. The following screenshot is a typical inheritance statement:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 继承的语法非常简单。让我们以`Human`类定义为例。以下屏幕截图是典型的继承语句：
- en: '![](img/06c5e550-28b0-4346-8bdb-8aaae6895259.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/06c5e550-28b0-4346-8bdb-8aaae6895259.png)'
- en: The class on the left of the colon (**:**) is the new, derived class, and the
    class on the right of the colon is the base class.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号（**:**）左边的类是新的派生类，冒号右边的类是基类。
- en: What does inheritance do?
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承的作用是什么？
- en: The point of inheritance is for the derived class to take on all the characteristics
    (data members and member functions) of the base class, and then to extend it with
    even more functionality. For instance, all mammals have a `breathe()` function.
    By inheriting from the `Mammal` class, the `Dog`, `Cat`, and `Human` classes all
    automatically gain the ability to `breathe()`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 继承的目的是让派生类继承基类的所有特征（数据成员和成员函数），然后通过更多功能来扩展它。例如，所有哺乳动物都有一个`breathe()`函数。通过从`Mammal`类继承，`Dog`、`Cat`和`Human`类都自动获得了`breathe()`的能力。
- en: Inheritance reduces replication of code, since we don't have to re-implement
    common functionalities (such as `.breathe()`) for `Dog`, `Cat`, and `Human`. Instead,
    each of these derived classes enjoys the reuse of the `breathe()` function defined
    in `class Mammal`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 继承减少了代码的重复，因为我们不必为`Dog`、`Cat`和`Human`重新实现共同的功能（比如`.breathe()`）。相反，这些派生类中的每一个都可以重用`class
    Mammal`中定义的`breathe()`函数。
- en: However, only the `Human` class has the `attack()` member function. This would
    mean that, in our code, only the `Human` class attacks. The `cat.attack()` function
    will introduce a compiler error, unless you write an `attack()` member function inside
    `class Cat` (or in `class Mammal`).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，只有`Human`类有`attack()`成员函数。这意味着在我们的代码中，只有`Human`类会攻击。`cat.attack()`函数会引发编译错误，除非你在`class
    Cat`（或`class Mammal`）中编写一个`attack()`成员函数。
- en: The is-a relationship
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: is-a关系
- en: 'Inheritance is often said to be an `is-a` relationship. When a `Human` class
    inherits from the `Mammal` class, then we say that a human *is-a* mammal:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 继承通常被称为`is-a`关系。当`Human`类从`Mammal`类继承时，我们说人类*是*哺乳动物：
- en: '![](img/994a96f0-b90d-4752-bbb0-7e736de6bbed.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/994a96f0-b90d-4752-bbb0-7e736de6bbed.png)'
- en: A human inherits all the traits a mammal has.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 人类继承了哺乳动物的所有特征。
- en: But what if a `Human` object contains a `Mammal` object inside it, as follows?
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果`Human`对象内部包含一个`Mammal`对象，如下所示？
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this example, we would say the human has a`Mammal` on it somewhere (which
    would make sense if the human were pregnant, or somehow carrying a mammal):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们会说人类身上有一个`Mammal`（如果人类怀孕或者以某种方式携带哺乳动物，这是有意义的）：
- en: '![](img/8ec61aa4-5a39-4f71-a182-48a5f68439c7.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ec61aa4-5a39-4f71-a182-48a5f68439c7.png)'
- en: This `Human` class instance has some kind of mammal attached to it
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Human`类实例身上有一个哺乳动物
- en: Remember that we previously gave `Player` an `Armor` object inside it? It wouldn't
    make sense for the `Player` object to inherit from the `Armor` class, because
    it wouldn't make sense to say the `Player` *is-an Armor*. When deciding whether
    one class inherits from another or not in code design (for example, the `Human`
    class inherits from the `Mammal` class), you must always be able to comfortably
    say something like the `Human` class *is-a* `Mammal`. If the *is-a* statement
    sounds wrong, then it is likely that inheritance is the wrong relationship for
    that pair of objects.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们之前给`Player`一个`Armor`对象内部吗？`Player`对象继承`Armor`类是没有意义的，因为说`Player`*是一种Armor*是没有意义的。在代码设计中决定一个类是否从另一个类继承时（例如，`Human`类是否从`Mammal`类继承），你必须始终能够自如地说`Human`类*是*`Mammal`。如果*是*语句听起来不对，那么很可能继承是那对对象的错误关系。
- en: In the preceding example, we're introducing a few new C++ keywords. The first
    is `protected`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们引入了一些新的C++关键字。第一个是`protected`。
- en: Protected variables
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 受保护的变量
- en: A `protected` member variable is different from a `public` or `private` variable.
    All three classes of variables are accessible inside the class in which they are
    defined. The difference between them is with regard to accessibility outside the
    class. A `public` variable is accessible anywhere inside the class and outside
    the class. A `private` variable is accessible inside the class but not outside
    the class. A `protected` variable is accessible inside the class, and inside of
    derived subclasses, but is not accessible outside the class. So, the `hp` and
    `speed` members of `class Mammal` will be accessible in the derived classes `Dog`,
    `Cat`, `Horse`, and `Human`, but not outside of these classes (in `main()`, for
    instance).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`protected`成员变量与`public`或`private`变量不同。这三类变量在定义它们的类内部都是可访问的。它们之间的区别在于对类外部的可访问性。`public`变量在类内部和类外部都是可访问的。`private`变量在类内部是可访问的，但在类外部不可访问。`protected`变量在类内部和派生子类内部是可访问的，但在类外部不可访问。因此，`class
    Mammal`的`hp`和`speed`成员在派生类`Dog`、`Cat`、`Horse`和`Human`中是可访问的，但在这些类的外部（例如`main()`）是不可访问的。'
- en: Virtual functions
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚函数
- en: A virtual function is a member function whose implementation can be overridden
    in a derived class. In this example, the `talk()` member function (defined in
    `class Mammal`) is marked `virtual`. This means that the derived classes might
    or might not choose to implement their own version of what the `talk()` member
    function means.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 虚函数是一个成员函数，其实现可以在派生类中被覆盖。在这个例子中，`talk()`成员函数（在`class Mammal`中定义）被标记为`virtual`。这意味着派生类可能会选择实现自己的`talk()`成员函数的版本，也可能不选择。
- en: Purely virtual functions
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯虚函数
- en: 'A purely `virtual` function (and abstract classes) is one whose implementation
    you are required to override in the derived class. The `walk()` function in `class
    Mammal` is purely virtual; it was declared like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 纯`virtual`函数（和抽象类）是指你必须在派生类中覆盖其实现的函数。`class Mammal`中的`walk()`函数是纯虚函数；它是这样声明的：
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `= 0` part at the end of the preceding code is what makes the function purely
    virtual.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中的`= 0`部分是使函数成为纯虚函数的部分。
- en: The `walk()` function in `class Mammal` is purely virtual and this makes the
    `Mammal` class abstract. An abstract class in C++ is any class that has at least
    one purely virtual function.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`class Mammal`中的`walk()`函数是纯虚函数，这使得`Mammal`类是抽象的。在C++中，抽象类是指至少有一个纯虚函数的类。'
- en: 'If a class contains a purely virtual function and is abstract, then that class
    cannot be instantiated directly. That is, you cannot create a `Mammal` object
    now, on account of the purely virtual function `walk()`. If you tried to do the
    following code, you would get an error:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类包含一个纯虚函数并且是抽象的，那么该类不能直接实例化。也就是说，你现在不能创建一个`Mammal`对象，因为有纯虚函数`walk()`。如果你尝试以下代码，你会得到一个错误：
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If you try to create a `Mammal` object, you will get the following error:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试创建一个`Mammal`对象，你会得到以下错误：
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You can, however, create instances of derivatives of `class Mammal`, as long
    as the derived classes have all of the purely virtual member functions implemented.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以创建`class Mammal`的派生实例，只要派生类实现了所有的纯虚成员函数。
- en: You may wonder why you'd want to use one of these. Well, do you really think
    you'd want to create a `Mammal` object in a game? No, you'd want to create an
    object of the types you derive from `Mammal`, such as `Cat` or `Dog`. This way,
    you can't accidentally create a `Mammal`, which would be very confusing to the
    `Player`!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想为什么要使用其中之一。好吧，你真的认为你会想在游戏中创建一个`Mammal`对象吗？不，你会想创建一个从`Mammal`派生的类型的对象，比如`Cat`或`Dog`。这样，你就不会意外地创建一个`Mammal`，这对`Player`来说会非常令人困惑！
- en: Multiple inheritance
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多重继承
- en: Not everything multiple is as good as it sounds. Multiple inheritance is when
    a derived class inherits from more than one base class. Usually, this works without
    a hitch if the multiple base classes we are inheriting from are completely unrelated.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是所有的多重继承都像听起来那么好。多重继承是指派生类从多个基类继承。通常，如果我们从完全不相关的多个基类继承，这通常可以顺利进行。
- en: 'For example, we can have a class `Window` that inherits from the `SoundManager`
    and `GraphicsManager` base classes. If `SoundManager` provides a member function
    `playSound()` and `GraphicsManager` provides a member function `drawSprite()`,
    then the `Window` class will be able to use those additional capabilities without
    a hitch:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以有一个从`SoundManager`和`GraphicsManager`基类继承的`Window`类。如果`SoundManager`提供了一个成员函数`playSound()`，`GraphicsManager`提供了一个成员函数`drawSprite()`，那么`Window`类将能够毫无问题地使用这些额外的功能：
- en: '![](img/d58d2f1d-0fea-4c2e-84d1-d5e23b7151c4.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d58d2f1d-0fea-4c2e-84d1-d5e23b7151c4.png)'
- en: Game Window inheriting from Sound Man and Graphics Man means Game Window will
    have both sets of capabilities
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Game Window从Sound Man和Graphics Man继承意味着Game Window将拥有两组功能
- en: However, multiple inheritance can have negative consequences. Say we want to
    create a `Mule` class that derives from both the `Donkey` and `Horse` classes.
    The `Donkey` and `Horse` classes, however, both inherit from the `Mammal` base
    class. We instantly have an issue! If we were to call `mule.talk()`, but `mule`
    did not override the `talk()` function, which member function should be invoked,
    that of `Horse` or `Donkey`? It's ambiguous.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，多重继承可能会产生负面后果。假设我们想创建一个从`Donkey`和`Horse`类派生的`Mule`类。然而，`Donkey`和`Horse`类都继承自`Mammal`基类。我们立即遇到了问题！如果我们调用`mule.talk()`，但`mule`没有覆盖`talk()`函数，应该调用哪个成员函数，`Horse`还是`Donkey`的？这是模棱两可的。
- en: Private inheritance
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 私有继承
- en: 'A less talked about feature of C++ is `private` inheritance. Whenever a class
    inherits from another class publicly, it is known to all code whose parent class
    it belongs to, for example:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: C++中很少谈到的一个特性是`private`继承。每当一个类公开地继承另一个类时，所有代码都知道它属于哪个父类，例如：
- en: '[PRE33]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This means that all code will know that `Cat` is an object of `Mammal`, and
    it will be possible to point to a `Cat*` instance using a base class `Mammal*`
    pointer. For example, the following code would be valid:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着所有的代码都将知道`Cat`是`Mammal`的一个对象，并且将能够使用基类`Mammal*`指针指向`Cat*`实例。例如，以下代码将是有效的：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Putting an object of one class into a variable of the type of the parent class
    is called casting. The preceding code is fine if `Cat` inherits from `Mammal`
    publicly. Private inheritance is where code outside the `Cat` class is not allowed
    to know the parent class:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个类的对象放入父类类型的变量中称为转换。如果`Cat`公开继承自`Mammal`，则前面的代码是正确的。私有继承是指`Cat`类外部的代码不允许知道父类：
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, externally called code will not "know" that the `Cat` class derives from
    the `Mammal` class. Casting a `Cat` instance to the `Mammal` base class is not
    allowed by the compiler when inheritance is `private`. Use `private` inheritance
    when you need to hide the fact that a certain class derives from a certain parent
    class.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，外部调用的代码将不会“知道”`Cat`类是从`Mammal`类派生的。当继承是私有的时候，编译器不允许将`Cat`实例转换为`Mammal`基类。当你需要隐藏某个类是从某个父类派生时，使用私有继承。
- en: However, `private` inheritance is rarely used in practice. Most classes just
    use `public` inheritance. If you want to know more about `private` inheritance,
    see [http://stackoverflow.com/questions/406081/why-should-i-avoid-multiple-inheritance-in-c](http://stackoverflow.com/questions/406081/why-should-i-avoid-multiple-inheritance-in-c).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，私有继承在实践中很少使用。大多数类都使用公共继承。如果你想了解更多关于私有继承的信息，请参阅[http://stackoverflow.com/questions/406081/why-should-i-avoid-multiple-inheritance-in-c](http://stackoverflow.com/questions/406081/why-should-i-avoid-multiple-inheritance-in-c)。
- en: Putting your classes into headers
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将你的类放入头文件
- en: So far, our classes have just been pasted before `main()`. If you continue to
    program that way, your code will all be in one file and will appear as one big
    disorganized mess.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的类都只是被粘贴到了`main()`之前。如果你继续以这种方式编程，你的代码将全部在一个文件中，并且看起来会像一个大杂乱的混乱。
- en: Therefore, it is a good programming practice to organize your classes into separate
    files. This makes editing each class's code individually much easier when there
    are multiple classes inside the project.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将你的类组织到单独的文件中是一个很好的编程实践。当项目中有多个类时，这样做可以更轻松地单独编辑每个类的代码。
- en: 'Take `class Mammal` and its derived classes from earlier. We will properly
    organize that example into separate files. Let''s do this in steps:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 拿`class Mammal`和它的派生类来说。我们将把之前的例子正确地组织到单独的文件中。让我们分步骤来做：
- en: Create a new file in your C++ project called `Mammal.h`. Cut and paste the entire
    `Mammal` class into that file. Notice that, since the `Mammal` class included
    the use of `cout`, we write a `#include <iostream>` statement in that file as
    well.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的C++项目中创建一个名为`Mammal.h`的新文件。将整个`Mammal`类剪切并粘贴到该文件中。请注意，由于`Mammal`类包含了对`cout`的使用，我们在该文件中也写入了`#include
    <iostream>`语句。
- en: Write an `"#include``Mammal.h"` statement at the top of your `Source.cpp` file.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`Source.cpp`文件顶部写入`"#include``Mammal.h"`语句。
- en: 'An example of what this looks like is shown in the following screenshot:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，如下截图所示：
- en: '![](img/dbddea3d-8b13-4b3d-8753-a7deb036398e.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dbddea3d-8b13-4b3d-8753-a7deb036398e.png)'
- en: What's happening here when the code is compiled is that the entire `Mammal`
    class is copied and pasted (`#include`) into the `Source.cpp` file, which contains
    the `main()` function, and the rest of the classes are derived from `Mammal`.
    Since `#include` is a copy and paste function, the code will function exactly
    the same as it did before; the only difference is that it will be much better
    organized and easier to look at. Compile and run your code during this step to
    make sure it still works.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码编译时，发生的情况是整个`Mammal`类被复制并粘贴（`#include`）到包含`main()`函数的`Source.cpp`文件中，其余的类都是从`Mammal`派生的。由于`#include`是一个复制和粘贴的功能，代码的功能将与之前完全相同；唯一的区别是它将更加有组织和易于查看。在此步骤中编译和运行你的代码，以确保它仍然有效。
- en: Check that your code compiles and runs often, especially when refactoring. When
    you don't know the rules, you're bound to make a lot of mistakes. This is why
    you should do your refactoring only in small steps. Refactoring is the name for
    the activity we are doing now - we are reorganizing the source to make more sense
    to other readers of our code base. Refactoring usually does not involve rewriting
    too much of it.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 经常检查你的代码是否能够编译和运行，特别是在重构时。当你不知道规则时，你很容易犯很多错误。这就是为什么你应该只在小步骤中进行重构。重构是我们现在正在做的活动的名称
    - 我们正在重新组织源代码，使其对我们代码库的其他读者更有意义。重构通常不涉及太多的重写。
- en: The next thing you need to do is isolate the `Dog`, `Cat`, and `Human` classes
    into their own files. To do so, create the `Dog.h`, `Cat.h`, and `Human.h` files
    and add them to your project.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来你需要做的是将`Dog`，`Cat`和`Human`类分别放入它们自己的文件中。为此，创建`Dog.h`，`Cat.h`和`Human.h`文件，并将它们添加到你的项目中。
- en: Let's start with the `Dog` class, as shown in the following screenshot.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`Dog`类开始，如下截图所示。
- en: 'If you use exactly this setup and try to compile and run your project, you
    will see the ''Mammal'' : ''class'' type redefinition error, as shown in the following
    screenshot:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用这个设置并尝试编译和运行你的项目，你会看到“Mammal”：'class'类型重定义错误，如下截图所示：
- en: '![](img/300eff3f-4a48-41eb-9547-e9c95e432595.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/300eff3f-4a48-41eb-9547-e9c95e432595.png)'
- en: What this error means is that `Mammal.h` has been included twice in your project,
    once in `Source.cpp` and then again in `Dog.h`. This means, effectively, two versions
    of the `Mammal` class got added to the compiling code, and C++ is unsure which
    version to use.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误的意思是`Mammal.h`已经在你的项目中被包含了两次，一次在`Source.cpp`中，然后又在`Dog.h`中。这意味着，在编译代码中实际上添加了两个版本的`Mammal`类，C++不确定使用哪个版本。
- en: 'There are a few ways to fix this issue, but the easiest (and the one that Unreal
    Engine uses) is the `#pragma once` macro, as shown in the following screenshot:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以解决这个问题，但最简单的方法（也是虚幻引擎使用的方法）是`#pragma once`宏，如下截图所示：
- en: '![](img/e4a0f4c4-3aee-4358-be65-a55683d8e697.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e4a0f4c4-3aee-4358-be65-a55683d8e697.png)'
- en: We write `#pragma once` at the top of each header file. This way, the second
    time `Mammal.h` is included, the compiler doesn't copy and paste its contents
    again, since it  has already been included before, and its content is actually
    already in the compiling group of files.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在每个头文件的顶部写上`#pragma once`。这样，第二次包含`Mammal.h`时，编译器不会再次复制和粘贴它的内容，因为它已经被包含过了，它的内容实际上已经在编译组的文件中。
- en: 'Do the same thing for `Cat.h` and `Human.h`, then `include` them both in your
    `Source.cpp` file where your `main()` function resides:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对`Cat.h`和`Human.h`做同样的事情，然后在您的`Source.cpp`文件中包含它们，您的`main()`函数位于其中：
- en: '![](img/b28030e8-77f6-4bdd-84c2-be4d67edb365.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b28030e8-77f6-4bdd-84c2-be4d67edb365.png)'
- en: Screenshot with all classes included
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 包含所有类的屏幕截图
- en: Now that we've included all classes into your project, the code should compile
    and run.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经将所有类包含到您的项目中，代码应该可以编译和运行。
- en: Using .h and .cpp files
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`.h`和`.cpp`文件
- en: The next level of organization is to leave the class declarations in the header
    files (`.h`) and put the actual function implementation bodies inside some new
    `.cpp` files. Also, leave existing members inside the `class Mammal` declaration.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 组织的下一个级别是将类声明留在头文件（`.h`）中，并将实际函数实现体放在一些新的`.cpp`文件中。同时，保留`class Mammal`声明中的现有成员。
- en: 'For each class, perform the following operations:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个类，执行以下操作：
- en: 'Delete all function bodies (code between `{` and `}`) and replace them with
    just a semicolon. For the `Mammal` class, this would look as follows:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除所有函数体（在`{`和`}`之间的代码），并用分号替换它们。对于`Mammal`类，这将如下所示：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create a new `.cpp` file called `Mammal.cpp`. Then, simply put the member function
    bodies inside this file:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Mammal.cpp`的新`.cpp`文件。然后，简单地将成员函数体放在这个文件中：
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It is important to note the use of the class name and scope resolution operator
    (double colon) when declaring the member function bodies. We prefix all member
    functions belonging to the `Mammal` class with `Mammal::`. This shows that they
    belong to the class (this differentiates them from `.`, which is used for specific
    object instances of that class type).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明成员函数体时，使用类名和作用域解析运算符（双冒号）是很重要的。我们在属于`Mammal`类的所有成员函数前面加上`Mammal::`。这表明它们属于该类（这使它们与`.`有所不同，`.`用于该类类型的特定对象实例）。
- en: Notice how the purely virtual function does not have a body; it's not supposed
    to! Purely virtual functions are simply declared (and initialized to `0`) in the
    base class, but implemented later in derived classes.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意纯虚函数没有函数体；它不应该有！纯虚函数只是在基类中声明（并初始化为`0`），但稍后在派生类中实现。
- en: Exercise
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Complete the separation of the different creature classes above into class header
    (`.h`) and class definition files (`.cpp`).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 将上面不同生物类的分离完全转换为类头（`.h`）和类定义文件（`.cpp`）。
- en: Object-oriented programming design patterns
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象的编程设计模式
- en: If you've been looking into programming, you have probably come across the term
    *design patterns*. Design patterns are important to know because they are standard
    ways of doing things that can be applied to many programming projects. For an
    in-depth look at design patterns if you want to know more, a classic book is *Design
    Patterns* ([https://www.goodreads.com/book/show/85009.Design_Patterns](https://www.goodreads.com/book/show/85009.Design_Patterns)).
    Once you familiar them, you will find many uses for them throughout your career.
    Not all specifically relate to objects, but here are a few examples that do.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您一直在研究编程，您可能已经遇到了*设计模式*这个术语。设计模式很重要，因为它们是可以应用于许多编程项目的标准做事方式。如果您想了解更多，经典书籍*设计模式*是很重要的([https://www.goodreads.com/book/show/85009.Design_Patterns](https://www.goodreads.com/book/show/85009.Design_Patterns))。一旦您熟悉它们，您将在整个职业生涯中发现许多用途。并非所有都与对象有关，但以下是一些与对象有关的例子。
- en: Singletons
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例
- en: Sometimes, you only want to have one instance of an object. Say you're doing
    a kingdom simulator. You only want there to be one king. Otherwise, you risk a
    *Game of Thrones-*type situation with intrigue and Red Weddings everywhere, and
    that's not the type of game you were aiming for, is it? (Of course, you might
    keep that in mind for a different game.) But for this particular game, you want
    one king running things.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您只想要一个对象的实例。比如你在做一个王国模拟器。你只想要有一个国王。否则，你就会面临*权力的游戏*类型的情况，到处都是阴谋和红色婚礼，这不是你想要的游戏类型，对吧？（当然，你可能会记住这一点，用在另一个游戏中。）但对于这个特定的游戏，你只想要一个国王来管理一切。
- en: 'So, how can you make sure other kings don''t start turning up everywhere? You
    use a singleton. A singleton is a class that keeps an instance of an object, and
    anywhere you want to use it, instead of creating a new object, you call a function
    that gives you a way to access an instance of an object, and you can then call
    functions on that. To make sure you only create one instance of an object, it
    keeps a copy of itself in a static variable inside the class (note: we will be
    talking more about static class members in the next section), and when you call
    `GetInstance()`, it checks to see whether you''ve already created an instance
    of the object. If you have, it uses the existing one. If you haven''t, it creates
    a new one. Here''s an example:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，您如何确保其他国王不会到处出现？您可以使用单例。单例是一个保留对象实例的类，您想在任何地方使用它时，而不是创建一个新对象，您调用一个函数，该函数会给您访问对象实例的方法，然后您可以在其上调用函数。为了确保只创建一个对象实例，它在类内部的静态变量中保留了自身的副本（注意：我们将在下一节中更多地讨论静态类成员），当您调用`GetInstance()`时，它会检查您是否已经创建了对象的实例。如果有，它使用现有的实例。如果没有，它会创建一个新的。这里有一个例子：
- en: '[PRE38]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here is the code for the `cpp`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`cpp`的代码：
- en: '[PRE39]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The constructor is listed in the `private:` section of the code. This is important.
    If you do this, the constructor will not be accessible from outside the class,
    meaning that no other programmers, who may not realize that this is a singleton,
    can start creating new `King` objects and wreak havoc on the game. If they try,
    they will get an error. So, this enforces that this class can only be accessed
    through the `getInstance()` function.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数在代码的`private:`部分中列出。这很重要。如果你这样做，构造函数将无法从类外部访问，这意味着其他程序员，可能意识不到这是一个单例，就不能开始创建新的`King`对象并在游戏中造成混乱。如果他们尝试，他们会得到一个错误。因此，这强制了这个类只能通过`getInstance()`函数访问。
- en: 'To use this new singleton class, you would do something like this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个新的单例类，你可以这样做：
- en: '[PRE40]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Once you set the name, it will output `I am King Arthur`, no matter where in
    the code you call it from (just make sure to add `#include "King.h"` at the top
    of the file).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你设置了名称，它将输出“我是亚瑟王”，无论你从代码的哪个位置调用它（只需确保在文件顶部添加`#include "King.h"`）。
- en: Factories
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂
- en: What do you think of when you think of the term *factory*? Probably a place
    where they mass-produce objects, such as cars, shoes, or computers. In code, a
    `Factory` works the same way. A factory is a class that can create objects of
    other types. But it's even more flexible because it can create objects of different
    types.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想到术语“工厂”时，你会想到什么？可能是一个大量生产物体的地方，比如汽车、鞋子或计算机。在代码中，`工厂`的工作方式也是一样的。工厂是一个可以创建其他类型对象的类。但它更加灵活，因为它可以创建不同类型的对象。
- en: We saw earlier that a mammal can be a dog, cat, horse, or human. Because all
    four types are derived from `Mammal`, a `Factory` object can have a function where
    you tell it which type of `Mammal` you want, and it will create an object of that
    type, do any setup necessary, and return it. Because of a principle called polymorphism,
    you can get an object of type `Mammal`, but when you call any virtual functions,
    it knows to use the ones for `Cat`, `Dog`, or `Human`, depending on the type of
    object created. Your C++ compiler knows this because it maintains a virtual function
    table behind the scenes, which keeps a pointer to the version of each virtual
    function you really want to be using, and stores those in each object.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到，哺乳动物可以是狗、猫、马或人类。因为所有四种类型都是从“哺乳动物”派生出来的，一个“工厂”对象可以有一个函数，你告诉它你想要哪种类型的“哺乳动物”，它就会创建一个该类型的对象，进行任何必要的设置，并返回它。由于一个叫做多态性的原则，你可以得到一个类型为“哺乳动物”的对象，但当你调用任何虚函数时，它知道要使用为“猫”、“狗”或“人类”创建的函数，取决于创建的对象类型。你的C++编译器知道这一点，因为它在幕后维护一个虚函数表，它保留了你真正想要使用的每个虚函数的版本的指针，并将它们存储在每个对象中。
- en: Object pools
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象池
- en: Say you're creating a lot of objects, such as a particle system to display fireworks,
    and you have to constantly create new firework animations all over the screen.
    After a while, you'll notice things slowing down, and you might even run out of
    memory and crash. Fortunately, there is a way around this.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在创建大量对象，比如用于显示烟花的粒子系统，并且你不断需要在屏幕上创建新的烟花动画。过一段时间，你会注意到事情变慢了，甚至可能会耗尽内存并崩溃。幸运的是，有一个解决方法。
- en: You can create an object pool, which is basically a group of objects that should
    be large enough to contain every one on screen at any given time. When one finishes
    its animation and disappears, instead of creating a new one, you throw it back
    into the pool, and when you need another one, you can pull that one back out and
    reuse it (you may want to change the color or other settings first). Reusing objects
    from a pool is much faster and takes less processing than creating new objects
    constantly. It also helps avoid memory leaks.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个对象池，它基本上是一组对象，应该足够大，以便在任何给定时间屏幕上包含每一个对象。当一个对象完成其动画并消失时，你不需要创建一个新的对象，而是将它扔回到池中，当你需要另一个对象时，你可以将它拿出来并重用它（你可能需要先更改颜色或其他设置）。从池中重用对象比不断创建新对象要快得多，处理时间也更短。它还有助于避免内存泄漏。
- en: Static members
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态成员
- en: 'As we saw in the singleton example, classes can have static members. A static
    member of a class exists once for all instances of the class, instead of being
    different for each one. You generally access them as we did for the singleton:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在单例示例中看到的，类可以有静态成员。类的静态成员对于类的所有实例只存在一次，而不是对于每个实例都不同。你通常像我们为单例所做的那样访问它们：
- en: '[PRE41]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Static variables are also commonly used for constants related to a class. But
    they can also be used to track something, such as how many instances of an object
    you have, by incrementing the static variable in a constructor and then decrementing
    it in the destructor. This is similar to how smart pointers can keep track of
    how many references to an object still exist.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 静态变量也常用于与类相关的常量。但它们也可以用于跟踪某些东西，比如你有多少个对象的实例，通过在构造函数中递增静态变量，然后在析构函数中递减它。这类似于智能指针如何跟踪对象的引用数量。
- en: Callable objects and invoke
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可调用对象和调用
- en: Another new C++ feature is callable objects. This is an advanced topic, so don't
    worry too much about understanding it at this point, but I'll give you a brief
    overview. But to explain it, first, I need to mention another topic — operator
    overloading.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个新的C++特性是可调用对象。这是一个高级话题，所以不要太担心在这一点上理解它，但我会给你一个简要的概述。但要解释它，首先，我需要提到另一个话题——运算符重载。
- en: You may think you can't change the meaning of operators such as  `+`, `-`, `*`,
    and `/`. Actually, in C++, you can. You can add a function called `operator(symbol)`.
    So, if you have a string class, you can create an `operator+` function that causes
    strings to be concatenated instead of trying to figure out how to add two objects
    that aren't actually numbers.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为你不能改变诸如`+`、`-`、`*`和`/`这样的运算符的含义。实际上，在C++中，你可以。你可以添加一个名为`operator(symbol)`的函数。因此，如果你有一个字符串类，你可以创建一个`operator+`函数，使字符串被连接起来，而不是试图弄清楚如何添加两个实际上不是数字的对象。
- en: Callable objects go even further by overriding `()` with `operator()`. So, you
    can have a class that can be called as an object. C++ 17 has added a new function,
    `invoke()`, that will let you call a callable object with parameters.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 可调用对象通过重载`()`与`operator()`更进一步。因此，你可以拥有一个可以作为对象调用的类。C++ 17添加了一个新函数`invoke()`，它可以让你调用带参数的可调用对象。
- en: Summary
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about objects in C++; they are pieces of code that
    tie data members and member functions together into a bundle of code called a `class`
    or `struct`. Object-oriented programming means that your code will be filled with
    things instead of just `int`, `float`, and `char` variables. You will have a variable
    that represents `Barrel`, another variable that represents `Player`, and so on,
    that is, a variable to represent every entity in your game. You will be able to
    reuse code by using inheritance; if you have to code implementations of `Cat`
    and `Dog`, you can code a common functionality in the base class `Mammal`. We
    also discussed encapsulation and how it is easier and more efficient to program
    objects such that they maintain their own internal state. We also introduced a
    few design patterns for objects (you'll find there are many more out there).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了C++中的对象；它们是将数据成员和成员函数绑定在一起形成的一组代码，称为`class`或`struct`。面向对象编程意味着你的代码将充满各种东西，而不仅仅是`int`、`float`和`char`变量。你将拥有一个代表`Barrel`的变量，另一个代表`Player`的变量，以此类推，也就是说，一个变量代表游戏中的每个实体。你可以通过继承来重用代码；如果你需要编写`Cat`和`Dog`的实现，你可以在基类`Mammal`中编写通用功能。我们还讨论了封装以及如何更轻松、更高效地编写对象，使它们保持自己的内部状态。我们还介绍了一些对象的设计模式（你会发现还有许多其他设计模式）。
- en: In the next chapter, we'll talk about how to allocate memory dynamically, and
    about arrays and vectors.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何动态分配内存，以及数组和向量。
