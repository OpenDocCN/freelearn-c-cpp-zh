- en: Improving UI Feedback with UMG and Audio
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过UMG和音频改进UI反馈
- en: User feedback is very important in games, because the user needs information
    about what is going on in the game (score, hp, displaying inventory, and so on).
    In previous chapters, we've created a very simple HUD to display text and items
    in your inventory, but if you want a game that looks professional you'll want
    to have a much nicer **User Interface** (**UI**) than that!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，用户反馈非常重要，因为用户需要了解游戏中发生的情况（得分、生命值、显示库存等）。在以前的章节中，我们创建了一个非常简单的HUD来显示文本和库存中的物品，但是如果您想要一个看起来专业的游戏，您将需要一个比那更好得多的**用户界面**（**UI**）！
- en: Fortunately, there are easier ways of building a UI now with Unreal Motion Graphics
    UI Designer (UMG), a system included with UE4, just for this purpose. This chapter
    will show you how to use it to take what we've done before and make something
    that looks much better and has more functionality. We'll start updating the inventory
    window, and I will make suggestions on how you can continue the process and update
    the rest of the UI.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，现在有更简单的方法来使用虚幻动态图形UI设计师（UMG）构建UI，这是UE4附带的系统，专门用于此目的。本章将向您展示如何使用它来接管我们之前所做的工作，并制作看起来更好并具有更多功能的东西。我们将开始更新库存窗口，并我将提出您可以继续该过程并更新其余UI的建议。
- en: Another way of providing feedback is through audio, either in the game itself
    or through the UI when you interact with it, so we will also be introducing how
    to play sounds.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过音频提供反馈的另一种方法是，无论是在游戏本身还是通过UI与其交互时，我们还将介绍如何播放声音。
- en: 'The topics we''ll be covering are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要涵盖的主题如下：
- en: What is UMG?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UMG是什么？
- en: Updating the inventory window
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新库存窗口
- en: Laying out your UI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布局您的UI
- en: Updating your HUD and adding health bars
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新您的HUD并添加生命条
- en: Playing audio
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放音频
- en: What is UMG?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UMG是什么？
- en: You may have noticed that the code we've used to draw on the screen has been
    very complicated. Every element needs to be placed onscreen manually. You might
    ask yourself if there's an easier way. And there is! It's the Unreal Motion Graphics
    UI Designer, or UMG.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我们用来在屏幕上绘制的代码非常复杂。每个元素都需要手动放置在屏幕上。您可能会问自己是否有更简单的方法。有！那就是虚幻动态图形UI设计师，或者UMG。
- en: UMG simplifies the process of creating a UI by using special blueprints to allow
    you to lay out the interface visually. This can also let you have a tech-savvy
    artist do the layout for you, while you hook everything up. We will be using this,
    but since this is a C++ book we will be handling most of the behind the scenes
    functionality in C++.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: UMG通过使用特殊蓝图简化了创建UI的过程，允许您以可视方式布局界面。这也可以让您让精通技术的艺术家为您设计布局，而您则将一切连接起来。我们将使用这个，但由于这是一本C++书，我们将在C++中处理大部分幕后功能。
- en: 'In order to use UMG, first you need for find the `GoldenEgg.Build.cs` file
    in your Visual Studio project. `.cs` files are generally C#, not C++, but you
    don''t have to worry about that since we''ll only be making minor changes to this
    file. Find this line:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用UMG，首先需要在Visual Studio项目中找到`GoldenEgg.Build.cs`文件。`.cs`文件通常是C#，而不是C++，但您不必担心，因为我们只会对此文件进行轻微更改。找到这一行：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And add the following to that list:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 并将以下内容添加到列表中：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You may want to restart the engine once you do that. Then you'll be ready to
    code in UMG!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要在这样做后重新启动引擎。然后您将准备好在UMG中编码！
- en: Updating the inventory window
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新库存窗口
- en: We're going to start by updating the inventory window. What we have right now
    isn't a real window, just images and text drawn on the screen, but now you'll
    see how you can easily create something that looks more like a real window—with
    a background and a Close button, and the code will be much simpler.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从更新库存窗口开始。我们现在拥有的不是一个真正的窗口，只是在屏幕上绘制的图像和文本，但现在您将看到如何轻松创建看起来更像真正窗口的东西——带有背景和关闭按钮，代码将更简单。
- en: The WidgetBase class
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WidgetBase类
- en: 'To create a C++ class for a UMG Widget, you need to create a new class based
    on `UserWidget`. To find it when adding a new C++ class, you need to check Show
    All Classes and search for it:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '要为UMG小部件创建C++类，您需要基于`UserWidget`创建一个新类。在添加新的C++类时，需要检查显示所有类并搜索它以找到它： '
- en: '![](img/bf64bda7-1e63-4817-b4d7-48e14dd54e41.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf64bda7-1e63-4817-b4d7-48e14dd54e41.png)'
- en: Name your class `WidgetBase`. This will be the base class from which you will
    derive any other Widget classes you create. This allows you to put functionality
    in this class that will be reused in many different Widgets. In this case, I put
    the functionality for `CloseButton` in there. Not all Widgets will need one, but
    if you're trying for a standard window it is generally a good idea.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的类命名为`WidgetBase`。这将是您派生任何其他小部件类的基类。这使您可以在此类中放置将在许多不同小部件中重复使用的功能。在这种情况下，我在那里放置了`CloseButton`的功能。并非所有小部件都需要一个，但是如果您想要一个标准窗口，通常是一个好主意。
- en: 'Here is the code for `WidgetBase.h`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`WidgetBase.h`的代码：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This sets up all the code that allows you to use a button to close the window.
    `CloseButton` will be the name of the button we create in the design Blueprint.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这将设置允许您使用按钮关闭窗口的所有代码。`CloseButton`将是我们在设计蓝图中创建的按钮的名称。
- en: The line  `UPROPERTY(meta = (BindWidgetOptional))` should automatically link
    the `CloseWindow` variable to the `Button` object with the same name in the blueprint
    we will create in a little while. If you know the widget will always be there
    you can use `UPROPERTY(meta = (BindWidget))` instead, but in this case there may
    be cases where there is no button needed to close a window.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 行`UPROPERTY(meta = (BindWidgetOptional))`应自动将`CloseWindow`变量链接到稍后将在蓝图中创建的具有相同名称的`Button`对象。如果您知道小部件将始终存在，则可以改用`UPROPERTY(meta
    = (BindWidget))`，但在这种情况下，可能存在不需要关闭窗口的按钮的情况。
- en: 'And here is `WidgetBase.cpp`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`WidgetBase.cpp`：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If the UMG includes in this chapter don't work for you you might need to add
    `Runtime/` to the front of the path. But they should work like this (and do work
    in my project).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果本章中包含的UMG对您不起作用，您可能需要在路径前面添加“Runtime/”。但它们应该像这样工作（并且在我的项目中确实工作）。
- en: 'The following line is what sets the `OnClicked` event to call a specific function:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行是将`OnClicked`事件设置为调用特定函数的内容：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We no longer need to set up everything in the input settings like we did previously,
    since UMG buttons already are set up to handle `OnClicked`, and you just need
    to tell it what function to call. If for some reason that doesn't work, I'll show
    you how to work around it by setting up `OnClicked` in the blueprint later. Since
    `CloseButton` is optional, you do need to check it to make sure it's not set to
    `NULL` to avoid errors.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要像以前那样在输入设置中设置所有内容，因为UMG按钮已经设置好处理`OnClicked`，您只需要告诉它要调用哪个函数。如果由于某种原因它不起作用，我将向您展示如何通过稍后在蓝图中设置`OnClicked`来解决问题。由于`CloseButton`是可选的，您确实需要检查它以确保它未设置为`NULL`以避免错误。
- en: The `isOpen` variable is there to handle the common UI issue where sometimes
    clicks (or key presses) register multiple times, causing the function to be called
    more than once, which could cause errors. By setting `isOpen` to true the first
    time you call the `OnClicked` function you are making sure it doesn't run it more
    than once, since it will only run if the value is false. Of course, you also need
    to make sure the value is reset if you reopen the window, which is where the `NativeConstruct()`
    function comes in.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`isOpen`变量用于处理常见的UI问题，有时点击（或按键）会注册多次，导致函数被调用多次，这可能会导致错误。通过将`isOpen`设置为true，第一次调用`OnClicked`函数时，您确保它不会运行多次，因为它只会在值为false时运行。当然，您还需要确保在重新打开窗口时重置该值，这就是`NativeConstruct()`函数的作用。'
- en: The InventoryWidget class
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库存小部件类
- en: Now you will want to create the specialized class for handling the inventory
    widget, derived from `WidgetBase`. If for some reason you can't find `WidgetBase`
    to create the class the usual way, uncheck Actors Only under Filters. Call this
    one `InventoryWidget`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将要创建一个专门处理库存小部件的类，该类派生自`WidgetBase`。如果由于某种原因找不到`WidgetBase`以通常的方式创建类，则在过滤器下取消选中仅限于演员。将其命名为`InventoryWidget`。
- en: 'Once you''ve created that class you can start adding the code. First, here''s
    `InventoryWidget.h`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了该类后，您可以开始添加代码。首先，这是`InventoryWidget.h`：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This file is much more complicated. We are again using `BindWidget` to set up
    objects in the Blueprint. While you could lay out widgets in code like we did
    previously (but you should be able to create a subwidget including the image,
    text, and button), to keep things simpler I just laid out two on screen and referenced
    them separately. You can always add more yourself later for practice.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件要复杂得多。我们再次使用`BindWidget`来在蓝图中设置对象。虽然您可以像以前一样在代码中布置小部件（但您应该能够创建包括图像、文本和按钮的子小部件），但为了保持简单，我只在屏幕上布置了两个小部件，并分别引用它们。您随时可以自己添加更多以供练习。
- en: So, in this particular case we have widgets set up for two images, two text
    blocks, and two buttons. There is an `Initialize` function to set those up, as
    well as functions to add a widget, hide all widgets, and mouse click handlers
    for each button.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种特殊情况下，我们为两个图像、两个文本块和两个按钮设置了小部件。有一个`Initialize`函数来设置它们，以及用于添加小部件、隐藏所有小部件以及每个按钮的鼠标点击处理程序的函数。
- en: 'Then we need to write `InventoryWidget.cpp`. First, add the includes at the
    top of the file:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要编写`InventoryWidget.cpp`。首先，在文件顶部添加包含：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then set up the `Initialize` function:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后设置`Initialize`函数：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This function sets up the `OnClicked` functions for the buttons. Then add the
    functions to handle Widgets:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数为按钮设置了`OnClicked`函数。然后添加处理小部件的函数：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`HideWidgets` hides all the Widgets in the window so they won''t show up at
    all if there is nothing there. `AddWidget` takes an index, a name, and a texture
    for the image itself, then sets up the Widgets for that index. The Text Widget
    has a `SetText` function that lets you pass in `FText` (`FText::FromString` converts
    it from `FString` to `FText`). The Image Widget has `SetBrushFromTexture` that
    sets the image.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`HideWidgets`隐藏窗口中的所有小部件，因此如果没有任何内容，它们将不会显示出来。`AddWidget`接受索引、名称和图像本身的纹理，然后为该索引设置小部件。文本小部件具有`SetText`函数，允许您传递`FText`（`FText::FromString`将其从`FString`转换为`FText`）。图像小部件具有`SetBrushFromTexture`，用于设置图像。'
- en: 'Finally, you will need to set up the `MouseClicked` functions:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要设置`MouseClicked`函数：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'These just call the HUD''s `MouseClicked` function with the button''s index
    (Hint: this won''t compile until those HUD functions are updated to take the index).
    If you want to experiment further, later you can look into another way to get
    the index based on the button that was clicked, so you can use the same function
    for all the buttons.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是使用HUD的`MouseClicked`函数调用按钮的索引（提示：在更新HUD函数以接受索引之前，这不会编译）。如果您想进一步实验，稍后可以研究另一种根据单击的按钮获取索引的方法，以便您可以为所有按钮使用相同的函数。
- en: Setting up the widget blueprint
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置小部件蓝图
- en: Next, you will need to set up the blueprint. Since this is a special kind of
    blueprint, setting one up with its own class is a little trickier. You can't just
    create a blueprint of the class or you won't have a design blueprint. Instead,
    you have to create the design blueprint first, and then change the parent.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要设置蓝图。由于这是一种特殊类型的蓝图，因此使用其自己的类设置一个蓝图有点棘手。您不能只创建该类的蓝图，否则您将没有设计蓝图。相反，您必须首先创建设计蓝图，然后更改父级。
- en: 'To do this, go into the Content Browser and select the directory you want to
    put it in, and then select Add New | User Interface | Widget Blueprint:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请进入内容浏览器，选择要放置的目录，然后选择添加新项|用户界面|小部件蓝图：
- en: '![](img/21cb9202-5a8a-4914-b4d2-865824109afb.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21cb9202-5a8a-4914-b4d2-865824109afb.png)'
- en: 'Rename it `BP_InventoryWidget` and then double-click to open it. You should
    see something like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 将其重命名为`BP_InventoryWidget`，然后双击打开它。您应该会看到类似于这样的东西：
- en: '![](img/e677d439-c58d-4973-a2ef-31d64e6b4f4d.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e677d439-c58d-4973-a2ef-31d64e6b4f4d.png)'
- en: In the center you will visually lay out the screen, and the box represents the
    edges of the theoretical screen you are aiming for. On the left side the Palette
    shows you the basic UI objects you can add to the screen. You'll see many common
    objects such as images, text fields, progress bars, buttons, checkboxes, and sliders.
    That's a lot of functionality you basically get for free. Once you get to the
    point of setting up a settings window for your game many of those will come in
    handy.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在中心，您将直观地布置屏幕，方框代表您所瞄准的理论屏幕的边缘。在左侧，调色板向您展示了可以添加到屏幕上的基本UI对象。您将看到许多常见的对象，例如图像、文本字段、进度条、按钮、复选框和滑块。这基本上是您免费获得的许多功能。一旦您开始为游戏设置设置窗口，其中许多功能将派上用场。
- en: 'But first, we need to change the parent class on this, which you will do here.
    Select Graph on the top-right corner and Class Settings on the top toolbar, then
    look under Details for Class Options and choose the dropdown by Parent Class.
    Select InventoryWidget there:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们需要更改此处的父类。在右上角选择图表，顶部工具栏上的类设置，然后在详细信息下查找类选项，并选择父类旁边的下拉菜单。在那里选择InventoryWidget：
- en: '![](img/b60f8599-1131-4736-8ba9-13aa326477a4.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b60f8599-1131-4736-8ba9-13aa326477a4.png)'
- en: Now we'll want to go back to Designer and start laying out the screen!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要回到设计师，开始布置屏幕！
- en: There should already be a Canvas Panel on the screen. You can click on the bottom
    right corner and drag to make it the size you want. The canvas should usually
    be the size of the full screen. All other UI widgets will go inside the canvas.
    When you drag this, it will show the various resolutions on screen that you are
    aiming for. You will want to pick one similar to the resolution you are aiming
    for.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上应该已经有一个画布面板。您可以单击右下角并拖动以使其成为所需的大小。画布通常应该是整个屏幕的大小。所有其他UI小部件都将放在画布内。当您拖动时，它将显示您所瞄准的各种分辨率。您将要选择与您所瞄准的分辨率类似的分辨率。
- en: 'Then select Border under the Palette and drag it out onto the screen. This
    will be the background of the window. You can click the corner and drag it to
    the size you want. You can also find the color bar on the right (next to Appearance
    > Brush Color under Details) and click on it to open a Color Picker to choose
    the color of the background:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在调色板下选择边框，并将其拖出到屏幕上。这将是窗口的背景。您可以单击角落并将其拖动到所需的大小。您还可以在右侧找到颜色条（在详细信息下的外观>刷子颜色旁边），单击它以打开颜色选择器选择背景的颜色：
- en: '![](img/0ec86d68-7381-4e7b-8928-d64953fd59c6.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ec86d68-7381-4e7b-8928-d64953fd59c6.png)'
- en: You can also rename the object under Details. Once you have that, click and
    drag a Button onscreen and position it on the top-right corner of the background.
    If it tries to fill the entire Border object make sure you select Canvas Panel
    in the hierarchy or drag it outside the Border object and then drag it on top
    of it. Make sure you name this `CloseButton`. You can also put a text object with
    the letter X in it if you want to make it look more like a close button. You should
    uncheck Is Enabled under Behavior in the Details so it won't block mouse clicks.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在详细信息下重命名对象。一旦您完成了这些操作，点击并拖动一个按钮到屏幕上，并将其定位在背景的右上角。如果它试图填满整个边框对象，请确保您在层次结构中选择了画布面板，或者将其拖到边框对象之外，然后将其拖到其上方。确保将其命名为`CloseButton`。如果您想使其看起来更像关闭按钮，还可以在其中放置一个带有字母X的文本对象。您应该在详细信息中的行为下取消选中“已启用”，以便它不会阻止鼠标点击。
- en: Next, you will want to position two image objects and two text objects (you
    can add more later). Make sure the names exactly match the names you used in the
    code or they won't work. In the Text fields, you will find it much easier to set
    a font. Under Details | Appearance you will find font options like you're used
    to in any word processor, and you can use fonts already on your computer (although,
    if you still want to download a font there is nothing stopping you). You can also
    use the font you added earlier.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将要定位两个图像对象和两个文本对象（稍后可以添加更多）。确保名称与您在代码中使用的名称完全匹配，否则它们将无法工作。在文本字段中，设置字体会更容易。在详细信息|外观下，您将找到字体选项，就像您在任何文字处理器中习惯的那样，并且您可以使用计算机上已有的字体（尽管，如果您仍然想要下载字体，没有任何阻止您的东西）。您还可以使用之前添加的字体。
- en: 'Also, for `OnClicked`, you will want to add a button. You could just add one
    underneath, but I used a common UI method: the invisible button. Drag a button
    out and have it cover both the image and the text for one of them. Then go into
    the Background color and set the alpha (A) to `0`. Alpha is a measurement of how
    transparent a color is, and `0` means you won''t be able to see it at all.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，对于`OnClicked`，您将要添加一个按钮。您可以只在下面添加一个，但我使用了一种常见的UI方法：隐形按钮。拖动一个按钮出来，让它覆盖一个图像和一个文本。然后进入背景颜色并将alpha（A）设置为`0`。Alpha是颜色透明度的度量，`0`表示您根本看不到它。
- en: If you later have trouble clicking the buttons other objects might be in the
    way. Try dragging them so they are behind the button or look into ways of disabling
    clicks on those objects.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以后点击按钮时遇到麻烦，可能会有其他对象挡住了。尝试将它们拖到按钮后面，或者研究一下如何禁用这些对象上的点击。
- en: 'In the end, you should have something like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您应该有类似于这样的东西：
- en: '![](img/3c7d7aed-0bfc-4ded-88be-e5c08bb2d320.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c7d7aed-0bfc-4ded-88be-e5c08bb2d320.png)'
- en: Also, carefully note the options under Content on the right when you have Border
    selected. Here is where you can set Horizontal and Vertical alignment. Always
    try to set these, so if you want something to always be positioned in the top-left
    corner of the screen the alignment will be set to Horizontally Align Left and
    Vertically Align Top. If you don't set alignment for every object the results
    could be unpredictable in different screen resolutions. I'll get into that more
    later.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 还要仔细注意在选择边框时右侧的内容选项。这是您可以设置水平和垂直对齐的地方。始终尝试设置这些，因此如果您希望某些内容始终位于屏幕的左上角，对齐将设置为水平对齐左侧和垂直对齐顶部。如果您没有为每个对象设置对齐，不同屏幕分辨率下的结果可能是不可预测的。稍后我会更详细地介绍这一点。
- en: But for now, this will be your inventory window. It doesn't have to look exactly
    like mine, so have fun and experiment with the visual layout! Although, remember
    that you probably don't want it to take up the entire screen so you can see the
    spell being cast after you click (although you can look into closing the window
    when you click on a spell later).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，这将是你的库存窗口。它不一定要看起来和我的一样，所以玩得开心，尝试一下视觉布局！尽管记住，你可能不希望它占据整个屏幕，这样你就可以在点击后看到施放的咒语（尽管你可以在以后点击咒语时关闭窗口）。
- en: AMyHUD changes
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AMyHUD更改
- en: But that's not all! We still have to modify our existing classes to support
    this new Widget, starting with the `AMyHud` class. To make things simpler we won't
    be replicating all the previous functionality here. Instead, we will just be setting
    up the `OnClicked` function to cast spells, since that's going to be a lot more
    useful in game than dragging items around on the screen. Right-clicks aren't handled
    automatically by UMG but you can look into that more yourself if you want to add
    it later, and you can also look into the previous click and drag functionality,
    so you might want to comment out the older code instead of deleting it if you
    think you might want it later.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 但这还不是全部！我们仍然需要修改我们现有的类来支持这个新的小部件，首先是`AMyHud`类。为了简化事情，我们不会在这里复制所有以前的功能。相反，我们将设置`OnClicked`函数来施放咒语，因为在游戏中这将比在屏幕上拖动物品更有用。右键点击不会被UMG自动处理，但如果你想以后添加它，你可以自己更深入地了解一下，你也可以查看以前的点击和拖动功能，所以如果你认为以后可能会用到它，你可能会想注释掉旧的代码而不是删除它。
- en: 'For now, the `MouseMoved` and `MouseRightClicked` functions are gone, and the
    `MouseClicked` function now takes an `int` index. We also have new functions for
    `OpenInventory` and `CloseInventory`, so `MyHUD.h` should have this now:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`MouseMoved`和`MouseRightClicked`函数已经消失，`MouseClicked`函数现在接受一个`int`索引。我们还有新的函数`OpenInventory`和`CloseInventory`，所以`MyHUD.h`现在应该是这样的：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Also add #include "InventoryWidget.h" at the top of the file. Some of the other
    functions will also be modified. So, now we will look at `AMyHUD.cpp` and you
    will see just how much simpler the new versions of functions are. Here are the
    new functions for handling widgets:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 还要在文件顶部添加#include "InventoryWidget.h"。一些其他函数也将被修改。所以，现在我们将看一下`AMyHUD.cpp`，你将看到新版本的函数有多么简单。以下是处理小部件的新函数：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We also need to update the `MouseClicked` function to this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将`MouseClicked`函数更新为这样：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will cast the spell based on the index passed in. Then there are the new
    functions to open and close the inventory:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这将根据传入的索引施放咒语。然后有新的函数来打开和关闭库存：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The main part is to add or remove the new Widget from the `Viewport`. We also
    want to hide the widgets visually to keep empty widgets from displaying, and to
    clear out all the widgets when the window is closed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 主要部分是向`Viewport`添加或删除新的小部件。我们还希望在视觉上隐藏小部件，以防止空的小部件显示，并在关闭窗口时清除所有小部件。
- en: 'We also changed `struct Widget` to remove all the positioning information.
    Any reference to it should have been removed, but if you get any errors later
    (you won''t be able to compile until you make the changes to the Avatar class)
    make sure `MouseMoved` and `MouseRightClicked` are gone or commented out, and
    nothing else is referencing them. The newer, simpler widget should look like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还改变了`struct Widget`以删除所有的定位信息。对它的任何引用都应该被删除，但如果你以后遇到任何错误（在你修改Avatar类之前，你将无法编译），确保`MouseMoved`和`MouseRightClicked`已经消失或被注释掉，并且没有其他东西在引用它们。新的、更简单的小部件应该看起来像这样：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: AAvatar changes
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AAvatar更改
- en: 'In `AAvatar` we will primarily be modifying the `ToggleInventory` function.
    The newer function will look like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AAvatar`中，我们主要将修改`ToggleInventory`函数。新的函数将如下所示：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, many of the same HUD functions were reused, but the new functions
    for `OpenInventory` and `CloseInventory` are now called from here, so the HUD
    can display the window before adding the widgets, and remove the window to close
    it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，许多相同的HUD函数被重用，但现在从这里调用`OpenInventory`和`CloseInventory`的新函数，所以HUD可以在添加小部件之前显示窗口，并在关闭窗口时删除窗口。
- en: 'Also, delete the following lines from both the `Yaw` and `Pitch` functions:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 还要从`Yaw`和`Pitch`函数中删除以下行：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Also delete the following lines from `MouseRightClicked` (or delete the function,
    but if you do make sure you remove it from `SetupPlayerInputComponent` as well):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 还要从`MouseRightClicked`中删除以下行（或删除该函数，但如果你这样做，请确保你也从`SetupPlayerInputComponent`中删除它）：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, remove these lines from `MouseClicked` (since you don''t want to accidentally
    trigger a spell when you click somewhere that''s not part of the inventory):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，从`MouseClicked`中删除这些行（因为你不希望在点击不属于库存的地方时意外触发一个咒语）：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now you should be able to compile. Once you do that, go into BP_MyHUD and change
    the Class Defaults > Widgets > W Inventory dropdown to BP_InventoryWidget.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能够编译了。一旦你这样做了，进入BP_MyHUD并将类默认值>小部件>W库存下拉菜单更改为BP_InventoryWidget。
- en: A note on OnClicked
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于OnClicked的说明
- en: It's possible your `OnClicked` functions might not work correctly (I ran into
    that problem myself). If you can't find a solution, you can bypass with with blueprints,
    which is why I made all the mouse click functions blueprint callable.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你的`OnClicked`函数可能无法正常工作（我自己遇到了这个问题）。如果你找不到解决办法，你可以通过蓝图绕过，这就是为什么我把所有的鼠标点击函数都设置为蓝图可调用的原因。
- en: 'If this happens to you, go into the designer for your Widget blueprint and
    for each button click on it and find Events under Details and click the green
    + button next to On Clicked. This will add `OnClicked` for that button to the
    graph and switch to that. You will need to go back to add the other 2 buttons.
    Then, drag out from the node and add the function you want. It should look something
    like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这种情况发生在你身上，进入你的小部件蓝图的设计师，对于每个按钮点击它并找到详细信息下的事件，然后点击旁边的绿色+按钮。这将为该按钮添加`OnClicked`到图表并切换到该按钮。然后，从节点中拖出并添加你想要的功能。它应该看起来像这样：
- en: '![](img/168d8986-d61f-4867-82fa-656e1ce75423.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/168d8986-d61f-4867-82fa-656e1ce75423.png)'
- en: Laying out your UI
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局您的UI
- en: When you're laying out a UI, there are important things to keep in mind, and
    UMG has tools to make this easier for you. One of the most important things to
    keep in mind is that your game won't always run in the same resolution. If you're
    doing a mobile game there could be many different devices with different resolutions,
    and you want your game to look essentially the same on all of them. Even consoles
    are no longer free from this problem, since both Xbox One and PS4 now have 4K
    options. So, your game needs to be set up in a way that makes this possible.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当您布局UI时，有一些重要的事情需要牢记，UMG有工具可以让这更容易。其中最重要的一点是，您的游戏不会总是以相同的分辨率运行。如果您在做移动游戏，可能会有许多不同分辨率的设备，您希望您的游戏在所有设备上看起来基本相同。即使是游戏机也不再免于这个问题，因为Xbox
    One和PS4现在都有4K选项。因此，您的游戏需要以一种可以实现这一点的方式设置。
- en: If you make all your widgets a specific pixel size and then run it in a resolution
    much bigger, it could be so small it seems unreadable and buttons could be difficult
    to click on. In a smaller resolution it could be too big to fit on screen. So,
    keep this in mind.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将所有的小部件都设置为特定的像素大小，然后在分辨率更高的情况下运行，它可能会变得非常小，看起来难以阅读，按钮可能也很难点击。在较低的分辨率下，它可能太大而无法适应屏幕。所以，请记住这一点。
- en: The Canvas Panel you set up earlier will show you visually how it will look
    in the size you are aiming for. But for variations on the size you need to keep
    several things in mind.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您之前设置的画布面板将直观地显示您所追求的大小。但是对于所需大小的变化，您需要牢记几件事情。
- en: 'First of all, always use anchors. Under details you will see a dropdown list
    for Anchors. When you open it, you should see something like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，始终使用锚点。在详细信息下，您将看到一个锚点的下拉列表。打开它，您应该会看到类似这样的内容：
- en: '![](img/fc965460-7745-4f64-b872-a92b8a533d53.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc965460-7745-4f64-b872-a92b8a533d53.png)'
- en: The nine options on the top-left corner of the blue lines are to align objects.
    The rows align to the top, middle, and bottom of the screen, while the columns
    align to the left, middle, and right. So, if you have something you always want
    to appear at the top-left corner of the screen (like a score, or health bars)
    you will choose the option on the top-left corner. If you want something else
    to be centered both horizontally and vertically choose the second row, second
    column. The little white square basically shows you the positioning.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝线左上角的九个选项是用来对齐对象的。行对齐到屏幕的顶部、中部和底部，而列对齐到屏幕的左侧、中部和右侧。因此，如果您希望某些内容始终出现在屏幕的左上角（比如得分或生命条），您将选择左上角的选项。如果您希望其他内容水平和垂直居中，请选择第二行、第二列。小白色方块基本上显示了您的定位。
- en: The remaining options give you ways to have something stretch across the entire
    screen (no matter what size it is). So, if you want something stretched horizontally
    on the top, middle, or bottom, look at the right column. For vertical, look at
    the bottom row. And the one in the bottom-right corner is great if you want a
    window to stretch across the entire screen.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的选项可以让您在整个屏幕上拉伸某些内容（无论大小如何）。因此，如果您希望在顶部、中部或底部水平拉伸某些内容，请查看右列。对于垂直方向，请查看底部行。如果您希望窗口横跨整个屏幕，请查看右下角的选项。
- en: You can also add a Scale Box from the palette if you want everything inside
    it to scale to fit the screen size. Although if you have something you want to
    remain a fixed size, like an image, you can check Size to Content to prevent it
    from automatically resizing.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从调色板中添加一个比例框，如果您希望其中的所有内容都按比例缩放以适应屏幕大小。虽然如果您有一些希望保持固定大小的东西，比如一张图片，您可以勾选“大小自适应内容”来防止它自动调整大小。
- en: If you want to get more advanced, you can add code to check the screen size
    and swap out parts of, or the entire, UI, but that's out of the scope of this
    book, so just keep it in mind if you want to try it later on your own!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要更高级一点，您可以添加代码来检查屏幕大小并交换部分或整个UI，但这超出了本书的范围，所以如果您想在自己的项目中稍后尝试，请记住这一点！
- en: 'Another important things to keep in mind with your UI is localization. If you
    want to release your game anywhere outside your own country you will need to localize.
    This means you will have to get used to not just hardcoding text but use the built-in
    localization system to add string ids you''ve set up instead of hardcoding the
    text. The code will look for specific ids and swap them for the appropriate localized
    text. You can look into the built-in localization system here: [https://docs.unrealengine.com/en-us/Gameplay/Localization](https://docs.unrealengine.com/en-us/Gameplay/Localization).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您的UI的另一个重要事项是本地化。如果您希望在自己国家之外的任何地方发布游戏，您将需要进行本地化。这意味着您不仅要习惯于不直接编写文本，而是使用内置的本地化系统来添加您设置的字符串ID，而不是直接编写文本。代码将寻找特定的ID，并将其替换为相应的本地化文本。您可以在这里了解内置的本地化系统：[https://docs.unrealengine.com/en-us/Gameplay/Localization](https://docs.unrealengine.com/en-us/Gameplay/Localization)。
- en: This will also affect how you lay out your UI. The first time you localize your
    game in German, you'll find out that everything is twice as long! While you may
    be able to get your translators to come up with shorter ways to say the same thing,
    you will probably want to make text blocks longer than you think they need to
    be, or consider finding ways to make the text shrink to fit or scroll.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这也会影响您布局UI的方式。当您第一次将游戏本地化为德语时，您会发现一切都变成了两倍长！虽然您可能能让翻译人员想出更短的表达方式，但您可能会希望使文本块比您认为需要的更长，或者考虑找到使文本收缩以适应或滚动的方法。
- en: Updating your HUD and adding health bars
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新您的HUD并添加生命条
- en: I won't be giving full instructions here, but here are some hints on updating
    your HUD. Once you do this, it will simplify your code even more!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在这里给出完整的说明，但以下是一些关于更新HUD的提示。一旦您这样做，它将进一步简化您的代码！
- en: Creating a HUD class
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个HUD类
- en: You will need to create a new class deriving from WidgetBase for your new HUD.
    In this case, you will need the Canvas Panel but no background. Make sure everything
    will stretch across the entire screen.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要创建一个从WidgetBase派生的新类，用于您的新HUD。在这种情况下，您将需要Canvas Panel，但不需要背景。确保所有内容都会延伸到整个屏幕。
- en: You will want to keep most of your UI in the corners, so you can add a Progress
    Bar widget to the top-left corner of the screen to display health. Also, consider
    adding a Text widget to tell what it is and/or put the actual numbers onscreen.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您将希望将大部分UI放在角落里，因此您可以在屏幕的左上角添加一个进度条小部件来显示健康。此外，考虑添加一个文本小部件来告诉它是什么，和/或在屏幕上显示实际数字。
- en: For the messages, you can align Text widget to the top-middle of the screen
    and use those to display the text.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于消息，您可以将文本小部件对齐到屏幕的顶部中间，并使用它们来显示文本。
- en: Adding health bars
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加健康条
- en: If you've added the recommended Progress Bar widget, you'll find drawing health
    bars to be a lot easier now. You will need to get a reference to it just like
    you did with the other widgets. Then, all you need to do is call `SetPercent`
    to show the current health (and reset it whenever it changes).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已添加了推荐的进度条小部件，您会发现绘制健康条现在更容易了。您需要像其他小部件一样获取对它的引用。然后，您所需要做的就是调用“SetPercent”来显示当前的健康值（并在健康值改变时重置它）。
- en: You no longer have to draw the whole thing yourself, but you can use `SetFillColorAndOpacity`
    to customize how it looks!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您不再需要自己绘制整个东西，但是您可以使用“SetFillColorAndOpacity”来自定义外观！
- en: Playing audio
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放音频
- en: 'We''re going to go back to your code to do one last thing that really helps
    your game''s feedback, yet it somehow tends to be one of the last things anyone
    thinks about when creating a game: audio.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回到您的代码，做最后一件真正有助于您的游戏反馈的事情，但是在创建游戏时，这似乎总是最后一个人会考虑到的事情：音频。
- en: Audio can really enhance your game, from playing a sound when you click a button
    to adding sound effects, dialog, background music, and ambience. If you're walking
    alone in the woods at night, the sounds of crickets chirping, your own footsteps,
    and ominous music can really set the mood. Or, you can have bird sounds and happy
    music for a completely different mood. It's all up to you!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 音频可以真正增强您的游戏，从在单击按钮时播放声音到添加音效、对话、背景音乐和环境音效。如果您在夜晚独自在树林中行走，蟋蟀的鸣叫声、您自己的脚步声和不祥的音乐可以真正营造氛围。或者，您可以播放鸟鸣和愉快的音乐，营造完全不同的氛围。这都取决于您！
- en: We're just going to add a sound when you cast your blizzard spell. So look for
    a free wind sound. There are plenty of sites that offer royalty-free sound files.
    Some of them want you to mention them in your credits if you use them. For this,
    I found a public domain sound on a site called [SoundBible.com](http://www.soundbible.com),
    which means anyone can use it. But look for one you like.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在你施放暴风雪咒语时添加一个声音。因此，请寻找一个免费的风声。有很多网站提供免版税的声音文件。其中一些要求您在使用它们时在您的制作人员名单中提到他们。对于这个，我在一个名为[SoundBible.com](http://www.soundbible.com)的网站上找到了一个公共领域的声音，这意味着任何人都可以使用它。但是请寻找您喜欢的声音。
- en: Some sites might make you register to download the sounds. You can even record
    one yourself if you're feeling ambitious!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有些网站可能会要求您注册以下载声音。如果您感到有雄心壮志，甚至可以自己录制一个！
- en: I used a .wav file, a standard format, although other formats will probably
    work. But for small sounds, you may want to stick to .wav because MP3s use compression,
    which might slow down your game slightly because it needs to de-compress it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了.wav文件，这是一种标准格式，尽管其他格式可能也有效。但是对于小声音，您可能希望坚持使用.wav，因为MP3使用了压缩，这可能会稍微减慢游戏速度，因为它需要对其进行解压缩。
- en: 'Once you have a file you like, create a folder for Sounds and drag your sound
    file into it from your file manager. Then right-click in the same folder and select
    Sounds | Sound Cue:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您找到喜欢的文件，请为声音创建一个文件夹，并从文件管理器将声音文件拖入其中。然后在同一文件夹中右键单击并选择Sounds | Sound Cue：
- en: '![](img/2b52b6f2-364a-4485-8585-a519d7ae5a5e.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b52b6f2-364a-4485-8585-a519d7ae5a5e.png)'
- en: 'Rename that to WindCue and double-click on it to open it in the Blueprint editor.
    It should look something like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将其重命名为WindCue，然后双击它以在蓝图编辑器中打开它。它应该看起来像这样：
- en: '![](img/131d3ae3-3a8b-4994-a0da-109a867a4541.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/131d3ae3-3a8b-4994-a0da-109a867a4541.png)'
- en: 'The SoundCue is where we will set up our sound. First, right-click anywhere
    and select Wave Player to add one:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 声音提示是我们设置声音的地方。首先，右键单击任何位置，然后选择Wave Player添加一个：
- en: '![](img/500545b1-f0ba-4555-8f2f-fdea977a5965.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/500545b1-f0ba-4555-8f2f-fdea977a5965.png)'
- en: 'Then, select the Wave Player. In the details, you will see an option for Sound
    Wave. Select the dropdown list and search for the `.wav` file you added to select
    it:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，选择Wave Player。在详细信息中，您将看到一个名为Sound Wave的选项。选择下拉列表并搜索您添加的.wav文件以选择它：
- en: '![](img/279db068-abc1-4cde-8025-315c2bb495c0.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/279db068-abc1-4cde-8025-315c2bb495c0.png)'
- en: 'Then, click and drag from the output of your Wave Player into the Output (with
    the small speaker image). This will hook it up. To test it, you can select Play
    Cue and you should hear it and see the line light up orange as the sound is transferred
    to the Output:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从Wave Player的输出处拖动并放入输出（带有小扬声器图像）。这将连接它。要测试它，您可以选择播放提示，然后您应该听到声音，并且看到线条变成橙色，表示声音被传输到输出：
- en: '![](img/9be39afa-c610-4f29-aa53-d6ea16ec7fc1.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9be39afa-c610-4f29-aa53-d6ea16ec7fc1.png)'
- en: If you don't like the way it sounds, experiment with the options under details.
    The one I used was too quiet for what I wanted, so I increased the Volume Multiplier
    to make it much louder.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不喜欢声音的方式，请尝试详细信息下的选项。我使用的声音对我想要的效果太安静了，所以我增加了音量倍增器使其响亮得多。
- en: 'Now that we have the sound set up, it''s time to add it to the code. In this
    case, we''ll be updating the `AMyHUD` class. First, add the following line to
    the top of `MyHUD.h`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好声音，是时候将其添加到代码中了。在这种情况下，我们将更新“AMyHUD”类。首先，在“MyHUD.h”的顶部添加以下行：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Also, add the following in the same file:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在同一文件中添加以下内容：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You will want to store the `SoundCue` reference in the blueprint to make it
    easy to update.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您将希望将“SoundCue”引用存储在蓝图中以便于更新。
- en: 'Now, go to `MyHUD.cpp` and add the following line to your `MouseClicked` function
    right after the call to `CastSpell`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到`MyHUD.cpp`并在`MouseClicked`函数中的`CastSpell`调用之后添加以下行：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will actually play the sound. Make sure you have `#include "Kismet/GameplayStatics.h"`
    in that file for it to work. For this case, since it is right by the player whenever
    you cast it, a 2D sound will be fine. If you want things in your environment (like
    the monsters) to make their own sounds, you will want to look into 3D sounds.
    UE4 will let you do that!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这将实际播放声音。确保在该文件中包含`#include "Kismet/GameplayStatics.h"`才能正常工作。对于这种情况，因为它在玩家附近每当您施放它时，2D声音就可以了。如果您希望环境中的事物（如怪物）发出自己的声音，您将需要研究3D声音。UE4将让您做到这一点！
- en: Now, go back into the editor and compile everything, then go back into the HUD
    blueprint. You will need to add the `SoundCue` you created to the blueprint.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，返回编辑器并编译所有内容，然后返回HUD蓝图。您需要将创建的`SoundCue`添加到蓝图中。
- en: 'You can select it from the dropdown list and search for it like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从下拉列表中选择它，并像这样搜索它：
- en: '![](img/0e38e675-aeb7-418a-b880-9cc392463579.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e38e675-aeb7-418a-b880-9cc392463579.png)'
- en: Now, save and compile and run the game. Run around until you pick up a Blizzard
    spell and hit *I* to open the inventory. Click on the Blizzard spell. You should
    not only see the spell cast, but you should hear it too!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，保存、编译并运行游戏。四处奔跑，直到您捡起了一个暴风雪咒语并按*I*打开库存。点击暴风雪咒语。您不仅应该看到咒语施放，还应该听到它！
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You've now gotten a good look at how User Interfaces are created with UMG, and
    how audio can be added to enhance your experience even further! There is still
    a lot of work to do, but consider that practice!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经深入了解了如何使用UMG创建用户界面，以及如何添加音频以进一步增强您的体验！还有很多工作要做，但请考虑练习！
- en: We're done with the code for this, but not with the book. Next, we'll be looking
    at how to take what we have and view it in virtual reality! I'll give you a few
    hints on that, and then we'll finish things off with an overview of some other
    advanced features in UE4.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了这部分的代码，但书还没有完成。接下来，我们将看看如何将我们所拥有的内容在虚拟现实中查看！我会给你一些建议，然后我们将以UE4中的一些其他高级功能概述结束。
