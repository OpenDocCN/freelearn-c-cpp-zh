["```cpp\nclass Image { /* ... */ };                   // Buffer with JPG data\nauto load(std::string_view path) -> Image;   // Load image at path\nclass ScoreView {\npublic:\n  // Eager, requires loaded bonus image\n  void display(const Image& bonus);\n  // Lazy, only load bonus image if necessary\n  void display(std::function<Image()> bonus);\n  // ...\n}; \n```", "```cpp\n// Always load bonus image eagerly\nconst auto eager = load(\"/images/stars.jpg\");\nscore.display(eager); \n```", "```cpp\n// Load default image lazily if needed\nauto lazy = [] { return load(\"/images/stars.jpg\"); }; \nscore.display(lazy); \n```", "```cpp\nauto a = std::string{\"Cole\"}; \nauto b = std::string{\"Porter\"}; \nauto c = std::string{\"ColePorter\"}; \nauto is_equal = (a + b) == c;        // true \n```", "```cpp\nauto is_concat_equal(const std::string& a, const std::string& b,\n                     const std::string& c) { \n  return  \n    a.size() + b.size() == c.size() && \n    std::equal(a.begin(), a.end(), c.begin()) &&  \n    std::equal(b.begin(), b.end(), c.begin() + a.size()); \n} \n```", "```cpp\nauto is_equal = is_concat_equal(a, b, c); \n```", "```cpp\nstruct ConcatProxy { \n  const std::string& a; \n  const std::string& b; \n}; \n```", "```cpp\nclass String { \npublic: \n  String() = default; \n  String(std::string str) : str_{std::move(str)} {} \n  std::string str_{};\n}; \n\nauto operator+(const String& a, const String& b) {\n   return ConcatProxy{a.str_, b.str_};\n} \n```", "```cpp\nauto operator==(ConcatProxy&& concat, const String& str) {\n  return is_concat_equal(concat.a, concat.b, str.str_); \n} \n```", "```cpp\nauto a = String{\"Cole\"}; \nauto b = String{\"Porter\"}; \nauto c = String{\"ColePorter\"}; \nauto is_equal = (a + b) == c;     // true \n```", "```cpp\nauto operator==(ConcatProxy&& concat, const String& str) { // ... \n```", "```cpp\nauto concat = String{\"Cole\"} + String{\"Porter\"};\nauto is_cole_porter = concat == String{\"ColePorter\"}; \n```", "```cpp\nstruct ConcatProxy {\n  const std::string& a;\n  const std::string& b;\n  operator String() const && { return String{a + b}; }\n}; \n```", "```cpp\nString c = String{\"Marc\"} + String{\"Chagall\"}; \n```", "```cpp\nauto c = String{\"Marc\"} + String{\"Chagall\"};\n// c is a ConcatProxy due to the auto keyword here \n```", "```cpp\ntemplate <typename T>\nauto create_strings(int n, size_t length) -> std::vector<T> {\n  // Create n random strings of the specified length\n  // ...\n}\ntemplate <typename T> \nvoid bm_string_compare(benchmark::State& state) {\n  const auto n = 10'000, length = 50;\n  const auto a = create_strings<T>(n, length);\n  const auto b = create_strings<T>(n, length);\n  const auto c = create_strings<T>(n, length * 2);\n  for (auto _ : state) {\n    for (auto i = 0; i < n; ++i) {\n      auto is_equal = a[i] + b[i] == c[i];\n      benchmark::DoNotOptimize(is_equal);\n    }\n  }\n}\nBENCHMARK_TEMPLATE(bm_string_compare, std::string);\nBENCHMARK_TEMPLATE(bm_string_compare, String);\nBENCHMARK_MAIN(); \n```", "```cpp\nclass Vec2D {\npublic:\n  Vec2D(float x, float y) : x_{x}, y_{y} {}\n  auto length() const {\n    auto squared = x_*x_ + y_*y_;\n    return std::sqrt(squared);\n  }\nprivate:\n  float x_{};\n  float y_{};\n}; \n```", "```cpp\nauto a = Vec2D{3, 4}; \nauto b = Vec2D{4, 4};\nauto shortest = a.length() < b.length() ? a : b;\nauto length = shortest.length();\nstd::cout << length; // Prints 5 \n```", "```cpp\nclass Vec2D {\npublic:\n  Vec2D(float x, float y) : x_{x}, y_{y} {}  \n  auto length_squared() const {\n    return x_*x_ + y_*y_;  \n  }\n  auto length() const {\n    return std::sqrt(length_squared());\n  }\nprivate:\n  float x_{};\n  float y_{};\n}; \n```", "```cpp\n// Simple version using length()\nauto min_length(const auto& r) -> float {\n  assert(!r.empty());\n  auto cmp = [](auto&& a, auto&& b) {\n    return a.length () < b.length();\n  };\n  auto it = std::ranges::min_element(r, cmp);\n  return it->length();\n} \n```", "```cpp\n// Fast version using length_squared()\nauto min_length(const auto& r) -> float {\n  assert(!r.empty());\n  auto cmp = [](auto&& a, auto&& b) {\n    return a.length_squared() < b.length_squared(); // Faster\n  };\n  auto it = std::ranges::min_element(r, cmp);\n  return it->length(); // But remember to use length() here!\n} \n```", "```cpp\nclass LengthProxy { \npublic: \n  LengthProxy(float x, float y) : squared_{x * x + y * y} {} \n  bool operator==(const LengthProxy& other) const = default; \n  auto operator<=>(const LengthProxy& other) const = default; \n  friend auto operator<=>(const LengthProxy& proxy, float len) { \n    return proxy.squared_ <=> len*len;   // C++20\n  } \n  operator float() const {      // Allow implicit cast to float\n    return std::sqrt(squared_); \n  }  \nprivate: \n  float squared_{}; \n}; \n```", "```cpp\nclass Vec2D { \npublic: \n  Vec2D(float x, float y) : x_{x}, y_{y} {} \n  auto length() const { \n    return LengthProxy{x_, y_};    // Return proxy object\n  } \n  float x_{}; \n  float y_{}; \n}; \n```", "```cpp\nauto a = Vec2D{23, 42}; \nauto b = Vec2D{33, 40}; \nbool a_is_shortest = a.length() < b.length(); \n```", "```cpp\n// These LengthProxy objects are never visible from the outside\nLengthProxy a_length = a.length(); \nLengthProxy b_length = b.length(); \n// Member operator< on LengthProxy is invoked, \n// which compares member squared_ \nauto a_is_shortest = a_length < b_length; \n```", "```cpp\n// Simple and efficient \nauto min_length(const auto& r) -> float { \n  assert(!r.empty()); \n  auto cmp = [](auto&& a, auto&& b) { \n    return a.length () < b.length(); \n  }; \n  auto it = std::ranges::min_element(r, cmp); \n  return it->length(); \n} \n```", "```cpp\nauto a = Vec2D{23, 42};\nfloat len = a.length(); // Note, we cannot use auto here \n```", "```cpp\nauto a = Vec2D{23, 42};\nauto len = a.length();\nfloat f0 = len;       // Assignment invoked std::sqrt()\nfloat f1 = len;       // std::sqrt() of len is invoked again \n```", "```cpp\noperator float() const && { return std::sqrt(squared_); } \n```", "```cpp\nauto a = Vec2D{23, 42};\nauto len = a.length(); // len is of type LenghtProxy\nfloat f = len;         // Doesn't compile: len is not an rvalue \n```", "```cpp\nauto a = Vec2D{23, 42}; \nfloat f = a.length();    // OK: call operator float() on rvalue \n```", "```cpp\nauto min_length(const auto& r) -> float {\n  assert(!r.empty());\n  auto it = std::ranges::min_element(r, [](auto&& a, auto&& b) {\n    return a.length () < b.length(); });\n  return it->length();\n} \n```", "```cpp\nstruct Vec2DSlow {\n  float length() const {                  // Always compute\n    auto squared = x_ * x_ + y_ * y_;     // actual length\n    return std::sqrt(squared);            // using sqrt()\n  }\n  float x_, y_;\n}; \n```", "```cpp\ntemplate <typename T> \nvoid bm_min_length(benchmark::State& state) {\n  auto v = std::vector<T>{};\n  std::generate_n(std::back_inserter(v), 1000, [] {\n    auto x = static_cast<float>(std::rand());\n    auto y = static_cast<float>(std::rand());\n    return T{x, y};\n  });\n  for (auto _ : state) {\n    auto res = min_length(v);\n    benchmark::DoNotOptimize(res);\n  }\n}\nBENCHMARK_TEMPLATE(bm_min_length, Vec2DSlow);\nBENCHMARK_TEMPLATE(bm_min_length, Vec2D);\nBENCHMARK_MAIN(); \n```", "```cpp\nstd::cout << \"iostream \" << \"uses \" << \"overloaded \" << \"operators.\"; \n```", "```cpp\nconst auto r = {-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5};\nauto odd_positive_numbers = r \n  | std::views::filter([](auto v) { return v > 0; }) \n  | std::views::filter([](auto v) { return (v % 2) == 1; }); \n```", "```cpp\nauto numbers = std::vector{1, 2, 3, 4};\nauto has_two = numbers.contains(2); \n```", "```cpp\nauto has_two = numbers | contains(2); \n```", "```cpp\nauto numbers = std::vector{1, 3, 5, 7, 9}; \nauto seven = 7; \nbool has_seven = numbers | contains(seven); \n```", "```cpp\ntemplate <typename T>\nstruct ContainsProxy { const T& value_; };\ntemplate <typename Range, typename T>\nauto operator|(const Range& r, const ContainsProxy<T>& proxy) {\n  const auto& v = proxy.value_;\n  return std::find(r.begin(), r.end(), v) != r.end();\n} \n```", "```cpp\nauto numbers = std::vector{1, 3, 5, 7, 9}; \nauto seven = 7; \nauto proxy = ContainsProxy<decltype(seven)>{seven};  \nbool has_seven = numbers | proxy; \n```", "```cpp\ntemplate <typename T>\nauto contains(const T& v) { return ContainsProxy<T>{v}; } \n```", "```cpp\nauto penguins = std::vector<std::string>{\"Ping\",\"Roy\",\"Silo\"};\nbool has_silo = penguins | contains(\"Silo\"); \n```"]