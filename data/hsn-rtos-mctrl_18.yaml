- en: Choosing an RTOS API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择RTOS API
- en: So far, we've only used the native FreeRTOS API in all of our examples. However,
    this isn't the only API available for using FreeRTOS. Sometimes, there are secondary
    goals when developing code – it might need to be reused across other projects
    with other MCU-based embedded operating systems. Other times, code needs to be
    interoperable with fully featured operating systems. You may also want to utilize
    code that has been previously developed for a full operating system. In order
    to support these goals, there are two other APIs for FreeRTOS that are worth considering
    alongside the native API – CMSIS-RTOS and POSIX.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在所有示例中使用本地的FreeRTOS API。然而，这并不是使用FreeRTOS的唯一API。有时，在开发代码时可能会有次要目标——它可能需要在其他项目（这些项目使用基于其他MCU的嵌入式操作系统）中重用。有时，代码需要与功能齐全的操作系统互操作。你也可能希望利用为全操作系统之前开发的代码。为了支持这些目标，除了本机API之外，还有两个其他API值得考虑——CMSIS-RTOS和POSIX。
- en: In this chapter, we'll investigate the features, trade-offs, and limitations
    of these three APIs when creating applications based on FreeRTOS.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究这三个API在基于FreeRTOS创建应用程序时的功能、权衡和限制。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Understanding generic RTOS APIs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解通用的 RTOS API
- en: Comparing FreeRTOS and CMSIS-RTOS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较FreeRTOS和CMSIS-RTOS
- en: Comparing FreeRTOS and POSIX
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较FreeRTOS和POSIX
- en: Deciding which API to use
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定使用哪个API
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete the hands-on exercises in this chapter, you will require the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章的动手练习，你需要以下设备：
- en: A Nucleo F767 dev board
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块Nucleo F767开发板
- en: A micro-USB cable
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条微型 USB 线
- en: STM32CubeIDE and source code (for instructions, visit [Chapter 5](84a945dc-ff6c-4ec8-8b9c-84842db68a85.xhtml),
    *Selecting an IDE, *and read the section *Setting up our IDE*
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STM32CubeIDE和源代码（有关说明，请访问[第5章](84a945dc-ff6c-4ec8-8b9c-84842db68a85.xhtml)，*选择IDE*，并阅读*设置我们的IDE*部分）
- en: SEGGER JLink, Ozone, and SystemView (for instructions, read [Chapter 6](699daa80-06ae-4acc-8b93-a81af2eb774b.xhtml),
    *Debugging Tools for Real-Time Systems*)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SEGGER JLink、Ozone和SystemView（有关说明，请阅读[第6章](699daa80-06ae-4acc-8b93-a81af2eb774b.xhtml)，*实时系统的调试工具*）
- en: All the source code for this chapter is available from [https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_14](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_13).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有源代码均可在以下链接中找到：[https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_14](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_13)。
- en: Understanding generic RTOS APIs
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解通用RTOS API
- en: An RTOS API defines the programming interface that the user interacts with when
    using the RTOS. Native APIs expose all of the RTOS's functionality. So far in
    this book, we've been using the native FreeRTOS API only. This was done to make
    it easier to search for help for a given function and to rule out any possibility
    of a poorly behaving wrapper layer between FreeRTOS and a generic API. However,
    this is not the only API option for FreeRTOS. There are also generic APIs available
    that can be used to interface with the RTOS functionality – but instead of being
    tied to a specific RTOS, they can be used across multiple operating systems.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: RTOS API定义了用户在使用RTOS时与之交互的编程接口。本机API公开RTOS的所有功能。到目前为止，在这本书中，我们只使用了本机FreeRTOS
    API。这样做是为了使查找给定函数的帮助更容易，并排除在FreeRTOS和通用API之间存在表现不佳的包装层的任何可能性。然而，这并不是FreeRTOS的唯一API选项。还有可用的通用API，可以用来与RTOS功能接口——但它们不是绑定到特定RTOS，而是可以在多个操作系统之间使用。
- en: 'These generic APIs are usually implemented as a wrapper layer above the native
    RTOS API (the exception to this is RTX, which has only the CMSIS-RTOS API). Here
    we can see where a typical API would live in a generic **Advanced RISC Machines** (**ARM**)
    firmware stack:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些通用API通常作为本机RTOS API（RTX是例外，它只有CMSIS-RTOS API）之上的包装层实现。在这里，我们可以看到典型API在通用**ARM**固件堆栈中的位置：
- en: '![](img/b39ecd2b-e4eb-40a4-977a-3915ca5de469.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b39ecd2b-e4eb-40a4-977a-3915ca5de469.png)'
- en: As we can see from the arrows in the preceding diagram, there is no single abstraction
    that blocks the user code from accessing the lowest level of functionality. Each
    layer adds another potential API to be used, while the lower-level functionality
    is still available.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图中的箭头所示，没有单一的抽象可以阻止用户代码访问最低级别的功能。每一层都添加了另一个潜在的API，而较低级别的功能仍然可用。
- en: 'There are two generic APIs that can be used to access a subset of FreeRTOS''s
    functionality:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个通用的 API 可以用来访问 FreeRTOS 功能的一部分：
- en: '**CMSIS-RTOS**: ARM has defined a vendor-agnostic API targeting MCUs called
    the **Cortex Microcontroller Software Interface-RTOS** (CMSIS-RTOS).'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CMSIS-RTOS**：ARM 定义了一个针对 MCU 的无供应商 API，称为 **Cortex 微控制器软件接口-RTOS**（CMSIS-RTOS）。'
- en: '**POSIX**: The **Portable Operating System Interface** (**POSIX**) is another
    example of a generic interface that is common across multiple vendors and hardware.
    This API is more commonly used in full general-purpose operating systems, such
    as Linux.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**POSIX**：**可移植操作系统接口**（**POSIX**）是另一个在多个供应商和硬件中常见的通用接口的例子。这个 API 更常用于全通用操作系统，如
    Linux。'
- en: We will be discussing these generic APIs in depth throughout this chapter. But
    first, let's take a look at their advantages and disadvantages.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中深入讨论这些通用 API。但首先，让我们看看它们的优缺点。
- en: Advantages of generic APIs
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用 API 的优点
- en: Using a generic RTOS API such as CMSIS-RTOS or POSIX provides several benefits
    to programmers and middleware vendors. A programmer can write code once and run
    it on multiple MCUs, changing out the RTOS as desired with few or no changes to
    their application code. Middleware vendors are also able to write their code to
    interact with a single API and then support multiple RTOSes and hardware.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用通用的 RTOS API，如 CMSIS-RTOS 或 POSIX，为程序员和中间件供应商提供了几个好处。程序员可以编写一次代码，然后在多个 MCU
    上运行，只需对应用程序代码进行少量或没有更改，就可以根据需要更改 RTOS。中间件供应商也能够编写他们的代码以与单个 API 交互，然后支持多个 RTOS
    和硬件。
- en: As you may have noticed from the previous diagram, CMSIS-RTOS and POSIX APIs
    do not require exclusive access to FreeRTOS. Since these APIs are implemented
    as layers on top of the native FreeRTOS API, code can make use of either the more
    generic API or the native RTOS API at the same time. So, it is perfectly acceptable
    for some portions of an application to use the CMSIS-RTOS interface while others
    use the native FreeRTOS API.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能从之前的图中注意到的那样，CMSIS-RTOS 和 POSIX API 不需要独占访问 FreeRTOS。由于这些 API 作为层在原生 FreeRTOS
    API 之上实现，代码可以同时使用更通用的 API 或原生 RTOS API。因此，应用程序的部分部分使用 CMSIS-RTOS 接口，而其他部分使用原生
    FreeRTOS API 是完全可以接受的。
- en: For example, if a GUI provider ships their code and it interfaces to CMSIS-RTOS,
    there is nothing to prevent additional development with the native FreeRTOS API.
    The GUI vendor's code can be brought in using CMSIS-RTOS, while other code in
    the system uses the native FreeRTOS API, without the CMSIS-RTOS wrapper.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果 GUI 提供商发布了他们的代码并与 CMSIS-RTOS 交互，那么就没有什么可以阻止他们使用原生 FreeRTOS API 进行额外开发。GUI
    供应商的代码可以使用 CMSIS-RTOS 带入，而系统中的其他代码则使用原生 FreeRTOS API，而不需要 CMSIS-RTOS 包装器。
- en: With these benefits, it seems that a generic API would be the obvious answer
    to everything. But that's not true.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有这些好处，但似乎通用 API 会是解决所有问题的明显答案。但这并不正确。
- en: Disadvantages of generic APIs
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用 API 的缺点
- en: What a general-purpose API gains in uniformity, it loses in specificity. A general-purpose,
    one-size-fits-all implementation needs to be generic enough to be applicable for
    the majority of RTOSes. This leads to the unique portions being left out of the
    standardized interface, which can sometimes include some very interesting features.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个通用 API 在统一性方面获得的收益，它就会在特定性方面失去。一个通用、一刀切的实现需要足够通用，以便适用于大多数 RTOS。这导致独特的部分被排除在标准化接口之外，有时甚至包括一些非常有趣的功能。
- en: Since the RTOS vendors themselves aren't always the ones providing support for
    CMSIS-RTOS, there is the potential that the version of CMSIS-RTOS being shipped
    is lagging behind the RTOS release cycle. This means that RTOS updates to CMSIS-RTOS *might* not
    be included as often as for the native API.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 RTOS 供应商本身并不总是提供 CMSIS-RTOS 的支持，因此存在 CMSIS-RTOS 版本落后于 RTOS 发布周期的可能性。这意味着
    RTOS 更新可能不会像原生 API 那样频繁地包含到 CMSIS-RTOS 中。
- en: There is also the problem of obtaining support if problems are encountered –
    an RTOS vendor will generally be more willing (and capable) to help with code
    they actually provided. Often, it will be very difficult to get support for an
    abstraction that the RTOS vendor hasn't written – both because they are likely
    to be unfamiliar with it and the abstraction itself can contain bugs/functionality
    that isn't present in the base RTOS code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到问题，获得支持也存在问题——RTOS供应商通常更愿意（并且有能力）帮助解决他们实际提供的代码。通常，对于RTOS供应商没有编写的抽象，获得支持会非常困难——因为它们可能不熟悉它，而且抽象本身可能包含基RTOS代码中不存在的错误/功能。
- en: Now that we have a general idea of what a general-purpose RTOS API is, let's
    take a closer look and compare the FreeRTOS and CMSIS-RTOS APIs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对通用RTOS API有一个大致的了解，让我们更深入地了解并比较FreeRTOS和CMSIS-RTOS API。
- en: Comparing FreeRTOS and CMSIS-RTOS
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较FreeRTOS和CMSIS-RTOS
- en: There is a common misconception that there is an RTOS named CMSIS-RTOS. CMSIS-RTOS
    is actually just an API definition. Its *implementation* is largely a glue layer
    to the underlying RTOS, but where functional differences exist between the two,
    some *glue code* will be present to map functionality.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种常见的误解，即存在一个名为CMSIS-RTOS的RTOS。实际上，CMSIS-RTOS只是一个API定义。它的*实现*主要是底层RTOS的粘合层，但在两个之间存在功能差异的地方，将存在一些*粘合代码*来映射功能。
- en: 'ARM developed CMSIS-RTOS with the same goal in mind as when CMSIS was developed:
    to add a consistent layer of abstraction that reduces vendor lock-in. The original
    CMSIS was meant to reduce Silicon vendor lock-in by providing uniform methods
    for middleware to access common Cortex-M functionality. It accomplished this goal
    – there are only a few variants of FreeRTOS *ports* for the thousands of Cortex-M-based
    MCUs it supports. Likewise, ARM is now attempting to reduce RTOS vendor lock-in
    by making the RTOS itself easier to change out – by providing a consistent API
    (CMSIS-RTOS) that is vendor-agnostic.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ARM开发CMSIS-RTOS的目的是与开发CMSIS时的目标相同：添加一个一致的抽象层，以减少供应商锁定。原始CMSIS的目的是通过为中间件提供访问常见Cortex-M功能的一致方法来减少硅供应商锁定。它实现了这一目标——对于它支持的数千个基于Cortex-M的MCU，只有FreeRTOS
    *端口*的几个变体。同样，ARM现在正试图通过使RTOS本身更容易更换来减少RTOS供应商锁定——通过提供一个供应商无关的一致API（CMSIS-RTOS）。
- en: This chapter refers to CMSIS-RTOS, but this information is specific to the current
    version of CMSIS-RTOS, which is CMSIS-RTOS v2 (which has a different API from
    CMSIS-RTOS v1). CMSIS-RTOS v2 is also commonly referred to as CMSIS-RTOS2\. The
    exact version that this chapter references is CMSIS-RTOS 2.1.3.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要介绍CMSIS-RTOS，但这里的信息仅针对CMSIS-RTOS的当前版本，即CMSIS-RTOS v2（与CMSIS-RTOS v1的API不同）。CMSIS-RTOS
    v2也常被称为CMSIS-RTOS2。本章所引用的确切版本是CMSIS-RTOS 2.1.3。
- en: 'There are some primary FreeRTOS features that are also exposed by CMSIS-RTOS.
    Here''s a quick overview (more details are included in the *Cross-referencing
    CMSIS-RTOS and FreeRTOS functions* section):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一些主要的FreeRTOS功能也由CMSIS-RTOS暴露。以下是一个简要概述（更多详细信息请参阅“CMSIS-RTOS和FreeRTOS函数交叉引用”部分）：
- en: '**Tasks**: This is the functionality for creating and deleting tasks with both
    static and dynamically allocated stacks.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务**：这是创建和删除具有静态和动态分配堆栈的任务的功能。'
- en: '**Semaphores/mutexes**: Binary and counting semaphores as well as mutexes are
    present in CMSIS-RTOS.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信号量/互斥锁**：CMSIS-RTOS中存在二进制和计数信号量以及互斥锁。'
- en: '**Queues**: The Queue APIs are very similar between FreeRTOS''s native API
    and the CMSIS-RTOS API.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**队列**：队列API在FreeRTOS原生API和CMSIS-RTOS API之间非常相似。'
- en: '**Software timers**: The Software Timer APIs are very similar between FreeRTOS''s
    native API and the CMSIS-RTOS API.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件定时器**：软件定时器API在FreeRTOS原生API和CMSIS-RTOS API之间非常相似。'
- en: '**Event groups**: This is used to synchronize multiple tasks.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件组**：用于同步多个任务。'
- en: '**Kernel/scheduler control**: Both APIs have the ability to start/stop tasks
    and monitor the system.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内核/调度器控制**：这两个API都有启动/停止任务和监控系统的能力。'
- en: 'The feature sets of FreeRTOS and CMSIS-RTOS do not overlap completely. There
    are some features of FreeRTOS that are not available through CMSIS-RTOS:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: FreeRTOS和CMSIS-RTOS的功能集并不完全重叠。有一些FreeRTOS的功能在CMSIS-RTOS中不可用：
- en: '**Stream and message buffers**: The flexible and efficient queue alternative'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流和消息缓冲区**：灵活且高效的队列替代方案。'
- en: '**Queue sets**: Used for blocking on multiple queues or semaphores'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**队列集**：用于在多个队列或信号量上阻塞。'
- en: '**Co-routines**: An explicit time-shared solution for running multiple functions
    when RAM is too limited to run multiple tasks'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协程**：当 RAM 不足以运行多个任务时，运行多个函数的显式时间共享解决方案'
- en: Likewise, there are also some features of CMSIS-RTOS that are not available
    from an off-the-shelf version of FreeRTOS, primarily MemoryPools. For a current
    list of CMSIS-RTOS2 functions, see [https://arm-software.github.io/CMSIS-FreeRTOS/General/html/functionOverview.html#rtos_api2](https://arm-software.github.io/CMSIS-FreeRTOS/General/html/functionOverview.html#rtos_api2).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，CMSIS-RTOS 也有一些功能在现成的 FreeRTOS 版本中不可用，主要是 MemoryPools。有关 CMSIS-RTOS2 函数的当前列表，请参阅
    [https://arm-software.github.io/CMSIS-FreeRTOS/General/html/functionOverview.html#rtos_api2](https://arm-software.github.io/CMSIS-FreeRTOS/General/html/functionOverview.html#rtos_api2)。
- en: '**A special Note on ST Cube CMSIS-RTOS**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于 ST Cube CMSIS-RTOS 的特别说明**'
- en: It is important to note that when applications are developed using ST Cube,
    the CMSIS-RTOS version adaptation layer, `cmsis_os2.c`, is a fork from the original
    API written by ARM. Many of the changes relate to how the CMSIS-RTOS layer interacts
    with the system clock. For documentation for the original ARM-supplied CMSIS-FreeRTOS
    implementation, visit [https://arm-software.github.io/CMSIS-FreeRTOS](https://arm-software.github.io/CMSIS-FreeRTOS).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，当使用 ST Cube 开发应用程序时，CMSIS-RTOS 版本适配层 `cmsis_os2.c` 是从 ARM 编写的原始 API
    分支出来的。许多更改都与 CMSIS-RTOS 层如何与系统时钟交互有关。有关原始 ARM 提供的 CMSIS-FreeRTOS 实现的文档，请访问 [https://arm-software.github.io/CMSIS-FreeRTOS](https://arm-software.github.io/CMSIS-FreeRTOS)。
- en: Considerations during migration
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移过程中的注意事项
- en: There are a few noteworthy differences between programming with the CMSIS-RTOS
    API compared with doing so using the FreeRTOS API.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用 FreeRTOS API 相比，使用 CMSIS-RTOS API 编程有一些值得注意的差异。
- en: CMSIS-RTOS task creation functions take the stack size in *bytes*, as opposed
    to in *words* in FreeRTOS. So, making calls to `xTaskCreate` in FreeRTOS with
    a stack size of 128 words equates to calling CMSIS-RTOS `osThreadNew` with an
    argument of 512 bytes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: CMSIS-RTOS 任务创建函数接受以 *字节* 为单位的堆栈大小，而 FreeRTOS 中是以 *字* 为单位的。因此，在 FreeRTOS 中使用堆栈大小为
    128 字的 `xTaskCreate` 调用等同于调用 CMSIS-RTOS 的 `osThreadNew` 并以 512 字节作为参数。
- en: CMSIS-RTOS has fewer functions than FreeRTOS but relies on attribute structs
    as input to those functions. For example, in FreeRTOS, there are many families
    of functions that have `FromISR` equivalents. The `FromISR` variants typically
    won't block at all – they *need* to be called if an RTOS API call is made from
    inside an ISR, but they can also be used selectively in other places. In the CMSIS-RTOS
    layer, the ISR context is automatically detected. The `FromISR` API is *automatically* used,
    depending on whether the caller is being executed within the ISR context or the
    application context.  `portYIELD_FROM_ISR` is also called automatically. The trade-off
    for simplicity here is that any blocking delays specified inside an ISR call will
    be ignored, since the `FromISR` variants are all non-blocking (since it is never
    a good idea to block for multiple milliseconds inside an ISR). This is in contrast
    to the FreeRTOS method of protecting against misuse of the RTOS API from within
    an ISR context – a `configASSERT` instance will fail, resulting in an infinite
    loop that halts the entire application.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: CMSIS-RTOS 的功能比 FreeRTOS 少，但那些函数依赖于属性结构体作为输入。例如，在 FreeRTOS 中，有许多具有 `FromISR`
    等效函数的函数系列。`FromISR` 变体通常不会阻塞——如果从 ISR 内部调用 RTOS API，它们*需要*被调用，但它们也可以在其他地方有选择性地使用。在
    CMSIS-RTOS 层中，ISR 上下文会自动检测。`FromISR` API 会*自动*使用，取决于调用者是在 ISR 上下文还是应用上下文中执行。`portYIELD_FROM_ISR`
    也会自动调用。这里的简单性是以忽略 ISR 调用内指定的任何阻塞延迟为代价的，因为 `FromISR` 变体都是非阻塞的（因为永远不希望在 ISR 内部阻塞数毫秒是不好的主意）。这与
    FreeRTOS 方法中防止在 ISR 上下文中误用 RTOS API 相比——一个 `configASSERT` 实例将失败，导致无限循环并停止整个应用程序。
- en: With respect to protecting against misuse of RTOS API functionality from an
    ISR context, CMSIS-RTOS will return error codes when its functions are misused
    from inside an ISR context. In FreeRTOS, the same misuse will generally result
    in a failed `configASSERT` instance with a detailed comment, which halts the entire
    program. As long as the programmer is being responsible and rigorously checking
    return values, these errors will be detected. FreeRTOS is a bit more vocal about
    the errors, by not allowing program execution to continue (verbose comments explaining
    the reason for the misconfiguration and suggested solutions are almost always
    present in the FreeRTOS source code when this happens).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 关于从ISR上下文防止滥用RTOS API功能，CMSIS-RTOS在其函数被从ISR上下文中误用时将返回错误代码。在FreeRTOS中，同样的误用通常会导致一个失败的`configASSERT`实例，并带有详细的注释，这将使整个程序停止。只要程序员负责任并严格检查返回值，这些错误就会被检测到。FreeRTOS在错误方面更为直言不讳，因为它不允许程序继续执行（在这种情况下，几乎总是会在FreeRTOS源代码中找到解释误配置原因和提出解决方案的详细注释）。
- en: Cross-referencing CMIS-RTOS and FreeRTOS functions
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CMSIS-RTOS和FreeRTOS函数的交叉引用
- en: Here is a complete comparison of CMSIS-RTOS functions and their associated FreeRTOS
    functions. Feel free to skim the tables now if you're interested in finding out
    how various FreeRTOS functions are called from the CMSIS-RTOS API. Otherwise,
    use the tables as a reference when porting code between the CMSIS-RTOS and FreeRTOS
    APIs.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是CMSIS-RTOS函数及其相关FreeRTOS函数的完整比较。如果你对了解各种FreeRTOS函数如何在CMSIS-RTOS API中被调用感兴趣，现在可以随意浏览这些表格。否则，在代码在CMSIS-RTOS和FreeRTOS
    API之间移植时，请将这些表格作为参考。
- en: Delay functions
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟函数
- en: 'Delay functions map cleanly between the two APIs:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟函数在这两个API之间映射得很好：
- en: '| **CMSIS-RTOS name** | **FreeRTOS functions called** | **Notes** |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| **CMSIS-RTOS名称** | **调用的FreeRTOS函数** | **注释** |'
- en: '| `osDelay ` | `vTaskDelay` | `osDelay` is in ms or ticks, depending on which
    documentation and comments you believe. Be sure to check your CMSIS-RTOS implementation
    of `osDelay()` if a `Systick` frequency of something other than 1 kHz is used!
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `osDelay ` | `vTaskDelay` | `osDelay`的值以毫秒或滴答数表示，具体取决于你相信的文档和注释。如果使用非1 kHz的`Systick`频率，务必检查你的CMSIS-RTOS对`osDelay()`的实现！
    |'
- en: '| `osDelayUntil` | `vTaskDelayUntil`, `xTaskGetTickCount` |  |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `osDelayUntil` | `vTaskDelayUntil`, `xTaskGetTickCount` |  |'
- en: These basic delay functions work in very similar ways – the biggest difference
    to keep in mind is that CMSIS-RTOS specifies `osDelay` in milliseconds instead
    of *ticks*, as FreeRTOS does.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基本的延迟函数工作方式非常相似——需要记住的最大区别是CMSIS-RTOS指定`osDelay`以毫秒为单位，而不是FreeRTOS中的*滴答数*。
- en: EventFlags
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EventFlags
- en: '`oseventFlags` in CMSIS-RTOS maps to `EventGroups` in FreeRTOS. The `FromISR`
    variant of the FreeRTOS API is automatically used when CMSIS-RTOS functions are
    called from inside an ISR:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: CMSIS-RTOS中的`oseventFlags`映射到FreeRTOS中的`EventGroups`。当CMSIS-RTOS函数在ISR内部被调用时，将自动使用FreeRTOS
    API的`FromISR`变体：
- en: '| **CMSIS-RTOS name** | **FreeRTOS functions called** | **Notes** |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **CMSIS-RTOS名称** | **调用的FreeRTOS函数** | **注释** |'
- en: '| `oseventFlagsClear` | `xEventGroupsClearBits`, `xEventGroupGetBitsFromISR`
    |  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `oseventFlagsClear` | `xEventGroupsClearBits`, `xEventGroupGetBitsFromISR`
    |  |'
- en: '| `osEventFlagsDelete` | `vEventGroupDelete` |  |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `osEventFlagsDelete` | `vEventGroupDelete` |  |'
- en: '| `osEventFlagsGet` | `xEventGroupGetBits, xEventGroupGetBitsFromISR` |  |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `osEventFlagsGet` | `xEventGroupGetBits, xEventGroupGetBitsFromISR` |  |'
- en: '| `osEventFlagsNew` | `xEventGroupCreateStatic`, `xEventGroupCreate` |  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `osEventFlagsNew` | `xEventGroupCreateStatic`, `xEventGroupCreate` |  |'
- en: '| `osEventFlagsSet` | `xEventGroupSetBits, xEventGroupSetBitsFromISR` |  |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `osEventFlagsSet` | `xEventGroupSetBits, xEventGroupSetBitsFromISR` |  |'
- en: '| `osEventFlagsWait` | `xEventGroupWaitBits` |  |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `osEventFlagsWait` | `xEventGroupWaitBits` |  |'
- en: '`EventFlags` in CMSIS-RTOS work similarly to `EventGroups` in FreeRTOS, with
    nearly 1:1 mapping.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: CMSIS-RTOS中的EventFlags与FreeRTOS中的EventGroups工作方式相似，几乎是一对一映射。
- en: Kernel control and information
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核控制和信息
- en: 'The kernel interfaces are similar, although some timer implementations that
    STM has provided aren''t all that intuitive, specifically `osKernelGetSysTimerCount` and `osKernelGetSysTimerCount`.
    Also, some functions will return errors if there are issues within the context
    of an ISR:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 内核接口相似，尽管STM提供的某些定时器实现并不那么直观，特别是`osKernelGetSysTimerCount`和`osKernelGetSysTimerCount`。此外，如果ISR上下文中有问题，某些函数将返回错误：
- en: '`osKernelInitialize`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`osKernelInitialize`'
- en: '`osKernelRestoreLock`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`osKernelRestoreLock`'
- en: '`osKernelStart3`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`osKernelStart3`'
- en: '`osKernelUnlock`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`osKernelUnlock`'
- en: 'Pay special attention to the notes in this table:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请特别注意本表中的注释：
- en: '| **CMSIS-RTOS name** | **FreeRTOS functions called** | **Notes** |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| **CMSIS-RTOS名称** | **调用的FreeRTOS函数** | **注释** |'
- en: '| `osKernelGetInfo` | `static strings representing FreeRTOS version` |  |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `osKernelGetInfo` | 表示FreeRTOS版本的静态字符串 |  |'
- en: '| `osKernelGetState` | `xTaskGetSchedulerState` |  |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `osKernelGetState` | `xTaskGetSchedulerState` |  |'
- en: '| `osKernelGetSysTimerCount` | `xTaskGetTickCount` | This returns `xTaskGetTickCount()
    *` (`SysClockFreq` / `configTICK_RATE_HZ`). |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `osKernelGetSysTimerCount` | `xTaskGetTickCount` | 这返回 `xTaskGetTickCount()
    *` (`SysClockFreq` / `configTICK_RATE_HZ`)。 |'
- en: '| `osKernelGetSysTimerFreq` | ST HAL SystemCoreClock global variable |  |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `osKernelGetSysTimerFreq` | ST HAL SystemCoreClock全局变量 |  |'
- en: '| `osKernelGetTickCount` | `xTaskGetTickCount` |  |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `osKernelGetTickCount` | `xTaskGetTickCount` |  |'
- en: '| `osKernelGetTickFreq` | `configTICK_RATE_HZ` | This is *not* the `SysTick` frequency
    (that is, `1` `kHz)(SysClockFreq` is being returned (160 MHz)). |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `osKernelGetTickFreq` | `configTICK_RATE_HZ` | 这**不是**`SysTick`频率（即`1` kHz）（返回`SysClockFreq`，即160
    MHz）。 |'
- en: '| `osKernelInitialize` | `vPortDefineHeapRegions` (only if `Heap5` is used)
    |  |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `osKernelInitialize` | `vPortDefineHeapRegions`（仅当使用`Heap5`时） |  |'
- en: '| `osKernelLock` | `xTaskGetSchedulerState`, `vTaskSuspendAll` |  |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `osKernelLock` | `xTaskGetSchedulerState`, `vTaskSuspendAll` |  |'
- en: '| `osKernelRestoreLock` | `xTaskGetSchedulerState`, `vTaskSuspendAll` |  |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `osKernelRestoreLock` | `xTaskGetSchedulerState`, `vTaskSuspendAll` |  |'
- en: '| `osKernelStart` | `vTaskStartScheduler` |  |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `osKernelStart` | `vTaskStartScheduler` |  |'
- en: '| `osKernelUnlock` | `xTaskGetSchedulerState`, `xTaskResumeAll` |  |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `osKernelUnlock` | `xTaskGetSchedulerState`, `xTaskResumeAll` |  |'
- en: Be aware of the slight differences in time units when moving between kernel-oriented
    functions using the STM-supplied CMSIS-RTOS port and the native FreeRTOS API.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用STM提供的CMSIS-RTOS端口和原生FreeRTOS API在面向内核的函数之间移动时，请注意时间单位之间的细微差异。
- en: Message queues
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息队列
- en: Message queues are quite similar. In CMSIS-RTOS, all queues are registered by
    name, which can make for a richer debugging experience. Also, CMSIS-RTOS supports
    static allocation via attributes passed in as function parameters.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 消息队列相当相似。在CMSIS-RTOS中，所有队列都通过名称注册，这可以提供更丰富的调试体验。此外，CMSIS-RTOS支持通过作为函数参数传递的属性进行静态分配。
- en: 'Any functions called from inside an ISR will automatically be forced to use
    the `FromISR` equivalent functions and finish the ISR with a call to `portYIELD_FROM_ISR`.
    This results in any blocking times being effectively set to `0`. So, for example,
    if a queue doesn''t have space available, a call to `osMessageQueuePut` will return
    immediately from inside an ISR, even if a blocking timeout is specified:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 从ISR内部调用的任何函数都将自动强制使用`FromISR`等效函数，并通过调用`portYIELD_FROM_ISR`完成ISR。这导致任何阻塞时间实际上被设置为`0`。因此，例如，如果队列没有可用空间，则即使在ISR内部指定了阻塞超时，对`osMessageQueuePut`的调用也将立即从ISR返回：
- en: '| **CMSIS-RTOS name** | **FreeRTOS functions called** | **Notes** |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **CMSIS-RTOS名称** | **调用的FreeRTOS函数** | **注意** |'
- en: '| `osMessageQueueDelete` | `vQueueUnregisterQueue`, `vQueueDelete` |  |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `osMessageQueueDelete` | `vQueueUnregisterQueue`, `vQueueDelete` |  |'
- en: '| `osMessageQueueGet` | `xQueueReceive` | The `FromISR` variant is automatically
    called and `portYIELD_FROM_ISR` is automatically called if inside an ISR. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `osMessageQueueGet` | `xQueueReceive` | 如果在ISR内部，则自动调用`FromISR`变体，并自动调用`portYIELD_FROM_ISR`。
    |'
- en: '| `osMessageQueueGetCapacity` | `pxQueue->uxLength` |  |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `osMessageQueueGetCapacity` | `pxQueue->uxLength` |  |'
- en: '| `osMessageQueueGetCount` | `uxQueueMessagesWaiting`, `uxQueueMessagesWaitingFromISR`
    |  |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `osMessageQueueGetCount` | `uxQueueMessagesWaiting`, `uxQueueMessagesWaitingFromISR`
    |  |'
- en: '| `osMessageQueueGetMsgSize` | `pxQueue->uxItemSize` |  |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `osMessageQueueGetMsgSize` | `pxQueue->uxItemSize` |  |'
- en: '| `osMessageQueueGetSpace` | `uxQueueSpacesAvailable` | `taskENTER_CRITICAL_FROM_ISR` is
    automatically called if this function is executed from within an ISR. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `osMessageQueueGetSpace` | `uxQueueSpacesAvailable` | 如果此函数在ISR中执行，则自动调用`taskENTER_CRITICAL_FROM_ISR`。
    |'
- en: '| `osMessageQueueNew` | `xQueueCreateStatic`, `xQueueCreate` |  |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `osMessageQueueNew` | `xQueueCreateStatic`, `xQueueCreate` |  |'
- en: '| `osMessageQueuePut` | `xQueueSendToBack`, `xQueueSendToBackFromISR` | The
    `msg_prior` parameter is ignored in the STM port. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `osMessageQueuePut` | `xQueueSendToBack`, `xQueueSendToBackFromISR` | 在STM端口中忽略`msg_prior`参数。
    |'
- en: '| `osMessageQueueReset` | `xQueueReset` |  |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `osMessageQueueReset` | `xQueueReset` |  |'
- en: Queues are very similar between CMSIS-RTOS and FreeRTOS, but it is worth noting
    that CMSIS-RTOS doesn't have an equivalent of `xQueueSendToFront`, so it will
    not be possible to place items at the front of a queue using CMSIS-RTOS.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: CMSIS-RTOS和FreeRTOS之间的队列非常相似，但值得注意的是，CMSIS-RTOS没有`xQueueSendToFront`的等效项，因此无法使用CMSIS-RTOS将项目放置在队列的前面。
- en: Mutexes and semaphores
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互斥锁和信号量
- en: 'Mutexes are also similar between the two APIs, with some considerations to
    keep in mind:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥锁在这两个API之间也相当相似，但需要注意以下几点：
- en: In CMSIS-RTOS, the recursive mutex API functions are automatically called, depending
    on the type of mutex created.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CMSIS-RTOS中，递归互斥量API函数会根据创建的互斥量类型自动调用。
- en: In CMSIS-RTOS, static allocation is supported via attributes passed in as function
    parameters.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CMSIS-RTOS中，通过作为函数参数传递的属性支持静态分配。
- en: '`osMutexAcquire`, `osMutexRelease`, `osMutexDelete`, and `osMutexRelease` will
    always fail by returning `osErrorISR` if called within an ISR context.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在ISR上下文中调用`osMutexAcquire`、`osMutexRelease`、`osMutexDelete`和`osMutexRelease`时，将始终通过返回`osErrorISR`失败。
- en: '`osMutexGetOwner` and `osMutexNew` will always return `NULL` when called from
    within an ISR.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从ISR内部调用`osMutexGetOwner`和`osMutexNew`时，将始终返回`NULL`。
- en: 'With those points in mind, here are the relationships between mutexes in CMSIS-RTOS
    and FreeRTOS APIs:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些点，以下是CMSIS-RTOS和FreeRTOS API中互斥量之间的关系：
- en: '| **CMSIS-RTOS name** | **FreeRTOS functions called** | **Notes** |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| **CMSIS-RTOS名称** | **调用的FreeRTOS函数** | **注意事项** |'
- en: '| `osMutexAcquire` | `xSemaphoreTake`, `xSemaphoreTakeRecursive` | The `takeRecursive`
    variant is automatically called when the mutex is recursive. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `osMutexAcquire` | `xSemaphoreTake`, `xSemaphoreTakeRecursive` | 当互斥量是递归的时，会自动调用`takeRecursive`变体。|'
- en: '| `osMutexRelease` | `xSemaphoreGive`, `xSemaphoreGiveRecursive` | The `takeRecursive`
    variant is automatically called when the mutex is recursive. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `osMutexRelease` | `xSemaphoreGive`, `xSemaphoreGiveRecursive` | 当互斥量是递归的时，会自动调用`takeRecursive`变体。|'
- en: '| `osMutexDelete` | `vSemaphoreDelete`, `vQueueUnregisterQueue` |  |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `osMutexDelete` | `vSemaphoreDelete`, `vQueueUnregisterQueue` |  |'
- en: '| `osMutexGetOwner` | `xSemaphoreGetMutexHolder` | This always returns `NULL`
    if called from inside an ISR, which is identical to the expected behavior when
    the mutex is available. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `osMutexGetOwner` | `xSemaphoreGetMutexHolder` | 如果在ISR内部调用，则始终返回`NULL`，这与互斥量可用时的预期行为相同。|'
- en: '| `osMutexNew` | `xSemaphoreCreateRecursiveMutexStatic`, `xSemaphoreCreateMutexStatic`,`xSemaphoreCreateRecursiveMutex`,
    `xSemaphoreCreateMutex`, `vQueueAddToRegistry` | Different mutex types are created
    depending on the value of the `osMutexAttr_t` pointer passed into the function.
    |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `osMutexNew` | `xSemaphoreCreateRecursiveMutexStatic`, `xSemaphoreCreateMutexStatic`,`xSemaphoreCreateRecursiveMutex`,
    `xSemaphoreCreateMutex`, `vQueueAddToRegistry` | 根据传递给函数的`osMutexAttr_t`指针的值，创建不同的互斥量类型。|'
- en: '| `osMutexRelease` | `xSemaphoreGiveRecursive`, `xSemaphoreGive` |  |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `osMutexRelease` | `xSemaphoreGiveRecursive`, `xSemaphoreGive` |  |'
- en: While the mutex functionality is very similar between the APIs, the way in which
    it is achieved is quite different. FreeRTOS uses many different functions to create
    mutexes, while CMSIS-RTOS achieves the same functionality by adding parameters
    to fewer functions. It also records the mutex type and automatically calls the
    appropriate FreeRTOS function for recursive mutexes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在API之间互斥功能非常相似，但实现方式却相当不同。FreeRTOS使用许多不同的函数来创建互斥量，而CMSIS-RTOS通过向少量函数添加参数来实现相同的功能。它还会记录互斥量类型，并自动调用递归互斥量适当的FreeRTOS函数。
- en: Semaphores
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号量
- en: The `FromISR` equivalents of semaphore functions are automatically used when
    necessary. Static and dynamically allocated semaphores, along with binary and
    counting semaphores, are all created using `osSemaphoreNew`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要时，会自动使用信号量函数的`FromISR`等效函数。静态和动态分配的信号量，以及二进制和计数信号量，都是使用`osSemaphoreNew`创建的。
- en: 'The fact that semaphores are implemented using queues under the hood in FreeRTOS
    is evident here, as evidenced by the use of the Queue API to extract information
    for the semaphores:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，FreeRTOS底层使用队列实现信号量的事实显而易见，这可以从使用队列API提取信号量信息中看出：
- en: '| **CMSIS-RTOS name** | **FreeRTOS functions called** | **Notes** |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| **CMSIS-RTOS名称** | **调用的FreeRTOS函数** | **注意事项** |'
- en: '| `osSemaphoreAcquire` | `xSemaphoreTakeFromISR`, `xSemaphoreTake`, `portYIELD_FROM_ISR`
    | The automatic ISR context is accounted for. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `osSemaphoreAcquire` | `xSemaphoreTakeFromISR`, `xSemaphoreTake`, `portYIELD_FROM_ISR`
    | 考虑到自动ISR上下文。|'
- en: '| `osSemaphoreDelete` | `vSemaphoreDelete`, `vQueueUnregisterQueue` |  |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `osSemaphoreDelete` | `vSemaphoreDelete`, `vQueueUnregisterQueue` |  |'
- en: '| `osSemaphoreGetCount` | `osSemaphoreGetCount`, `uxQueueMessagesWaitingFromISR`
    |  |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `osSemaphoreGetCount` | `osSemaphoreGetCount`, `uxQueueMessagesWaitingFromISR`
    |  |'
- en: '| `osSemaphoreNew` | `xSemaphoreCreateBinaryStatic`, `xSemaphoreCreateBinary`,
    `xSemaphoreCreateCountingStatic`, `xSemaphoreCreateCounting`, `xSemaphoreGive`,
    `vQueueAddToRegistry` | All semaphore types are created using this function. Semaphores
    are automatically given unless the initial count is specified as `0`. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `osSemaphoreNew` | `xSemaphoreCreateBinaryStatic`, `xSemaphoreCreateBinary`,
    `xSemaphoreCreateCountingStatic`, `xSemaphoreCreateCounting`, `xSemaphoreGive`,
    `vQueueAddToRegistry` | 所有信号量类型都是使用此函数创建的。除非指定初始计数为`0`，否则信号量会自动释放。|'
- en: '| `osSemaphoreRelease` | `xSemaphoreGive`, `xSemaphoreGiveFromISR` |  |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `osSemaphoreRelease` | `xSemaphoreGive,` `xSemaphoreGiveFromISR` |  |'
- en: In general, semaphore functionality maps very cleanly between CMSIS-RTOS and
    FreeRTOS, although the function names differ.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，信号量功能在CMSIS-RTOS和FreeRTOS之间映射得非常清晰，尽管函数名不同。
- en: Thread flags
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程标志
- en: 'CMSIS-RTOS thread flag usage should be reviewed independently (a link to the
    detailed documentation is provided). As you can see from the FreeRTOS fuctions
    called, they are built on top of `TaskNotifications`. Again, ISR-safe equivalents
    are automatically substituted when the calls are made within an ISR context:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 应独立审查CMSIS-RTOS线程标志的使用（提供了详细文档的链接）。正如从FreeRTOS调用的函数中可以看到，它们建立在`TaskNotifications`之上。同样，当在ISR上下文中调用时，会自动替换ISR安全的等效函数：
- en: '| **CMSIS-RTOS name** | **FreeRTOS functions called** | **Notes** |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| **CMSIS-RTOS名称** | **FreeRTOS调用的函数** | **注意事项** |'
- en: '| `osThreadFlagsClear` | `xTaskGetCurrentTaskHandle`, `xTaskNotifyAndQuery`,
    `xTaskNotify` | [https://www.keil.com/pack/doc/CMSIS/RTOS2/html/group__CMSIS__RTOS__ThreadFlagsMgmt.html](https://www.keil.com/pack/doc/CMSIS/RTOS2/html/group__CMSIS__RTOS__ThreadFlagsMgmt.html)
    |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `osThreadFlagsClear` | `xTaskGetCurrentTaskHandle,` `xTaskNotifyAndQuery,`
    `xTaskNotify` | [https://www.keil.com/pack/doc/CMSIS/RTOS2/html/group__CMSIS__RTOS__ThreadFlagsMgmt.html](https://www.keil.com/pack/doc/CMSIS/RTOS2/html/group__CMSIS__RTOS__ThreadFlagsMgmt.html)
    |'
- en: '| `osThreadFlagsGet` | `xTaskGetCurrentTaskHandle`, `xTaskNotifyAndQuery` |  |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `osThreadFlagsGet` | `xTaskGetCurrentTaskHandle,` `xTaskNotifyAndQuery` |  |'
- en: '| `osThreadFlagsSet` | `xTaskNotifyFromISR`, `xTaskNotifyAndQueryFromISR`,
    `portYIELD_FROM_ISR`, `xTaskNotify`, `xTaskNotifyAndQuery` |  |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `osThreadFlagsSet` | `xTaskNotifyFromISR,` `xTaskNotifyAndQueryFromISR,`
    `portYIELD_FROM_ISR,` `xTaskNotify,` `xTaskNotifyAndQuery` |  |'
- en: '| `osThreadFlagsWait` | `xTaskNotifyWait` |  |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `osThreadFlagsWait` | `xTaskNotifyWait` |  |'
- en: '`ThreadFlags` and `TaskNotifications` have the largest potential for different
    behavior between the two APIs. Most of this will depend on how they are used in
    a specific application, so it is best to review the `ThreadFlags` documentation
    in detail before attempting to port `TaskNofications` to `ThreadFlags`.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadFlags`和`TaskNotifications`在两个API之间具有最大的潜在行为差异。这大部分将取决于它们在特定应用中的使用方式，因此在尝试将`TaskNotifications`移植到`ThreadFlags`之前，最好详细审查`ThreadFlags`的文档。'
- en: Thread control/information
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程控制/信息
- en: The basic threading API is very similar between CMSIS-RTOS and FreeRTOS, with
    the exception of CMSIS-RTOS's `osThreadGetStackSize`, which has no equivalent
    in FreeRTOS. Other minor differences include the addition of `osThreadEnumerate`,
    which uses several FreeRTOS functions while it lists the tasks in the system,
    as well as different names for states (CMSIS-RTOS lacks a `suspend` state). In
    CMSIS-RTOS, both static and dynamic thread/task stack allocation is supported
    through the same function, `osThreadNew`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: CMSIS-RTOS的基本线程API在CMSIS-RTOS和FreeRTOS之间非常相似，除了CMSIS-RTOS的`osThreadGetStackSize`在FreeRTOS中没有等效之外。其他一些小的差异包括添加了`osThreadEnumerate`，它在列出系统中的任务时使用几个FreeRTOS函数，以及状态名称的不同（CMSIS-RTOS缺少`suspend`状态）。在CMSIS-RTOS中，静态和动态线程/任务堆栈分配都通过同一个函数`osThreadNew`支持。
- en: If `osThreadTerminate` is called while using the FreeRTOS Heap1 implementation
    (discussed in the next chapter), an infinite loop with no delay will be entered.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在使用FreeRTOS Heap1实现（下一章将讨论）时调用`osThreadTerminate`，将会进入一个没有延迟的无穷循环。
- en: 'Be aware that CMSIS-RTOS v2  `osThreadAttr_t.osThreadPriority` requires 56
    different task priorities! Therefore, `configMAX_PRIORITIES` in `FreeRTOSConfig.h` must
    have a value of 56, or the implementation of `osThreadNew()` will need to be scaled
    to fit into the available number of priorities:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，CMSIS-RTOS v2的`osThreadAttr_t.osThreadPriority`需要56个不同的任务优先级！因此，`FreeRTOSConfig.h`中的`configMAX_PRIORITIES`必须设置为56，否则`osThreadNew()`的实现需要缩放以适应可用的优先级数量：
- en: '| **CMSIS-RTOS name** | **FreeRTOS functions called** | **Notes** |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| **CMSIS-RTOS名称** | **FreeRTOS调用的函数** | **注意事项** |'
- en: '| `osThreadEnumerate` | `vTaskSuspendAll,``uxTaskGetNumberOfTasks,``uxTaskGetSystemState,``xTaskResumeAll`
    | This suspends the system and populates an array of task handles. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `osThreadEnumerate` | `vTaskSuspendAll,` `uxTaskGetNumberOfTasks,` `uxTaskGetSystemState,`
    `xTaskResumeAll` | 这将挂起系统并填充一个任务句柄数组。|'
- en: '| `osThreadExit` | `vTaskDelete` | This ends the current thread if `HEAP1`
    is being used. This function will cause the caller to go into a tight infinite
    loop, consuming as many CPU cycles as available given the caller''s priority.
    |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `osThreadExit` | `vTaskDelete` | 如果使用`HEAP1`，这将结束当前线程。此函数将导致调用者进入一个紧密的无穷循环，消耗尽可能多的CPU周期，这取决于调用者的优先级。|'
- en: '| `osThreadGetCount` | `uxTaskGetNumberOfTasks` |  |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `osThreadGetCount` | `uxTaskGetNumberOfTasks` |  |'
- en: '| `osThreadGetId` | `xTaskGetCurrentTaskHandle` |  |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '`osThreadGetId` `xTaskGetCurrentTaskHandle`'
- en: '| `osThreadGetName` | `pcTaskGetName` |  |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '`osThreadGetName` `pcTaskGetName`'
- en: '| `osThreadGetPriority` | `uxTaskPriorityGet` |  |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '`osThreadGetPriority` `uxTaskPriorityGet`'
- en: '| `osThreadGetStackSize` | always returns `0` | `https://github.com/ARM-software/CMSISFreeRTOS/issues/14`
    |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '`osThreadGetStackSize` 总是返回 `0` `[https://github.com/ARM-software/CMSISFreeRTOS/issues/14](https://github.com/ARM-software/CMSISFreeRTOS/issues/14)`'
- en: '| `osThreadGetStackSpace` | `uxTaskGetStackHighWaterMark` |  |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '`osThreadGetStackSpace` `uxTaskGetStackHighWaterMark`'
- en: '| `osThreadGetState` | `eTaskGetState` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '`osThreadGetState` `eTaskGetState`'
- en: '&#124; **FreeRTOS Task State** &#124; **CMSIS-RTOS** &#124;'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`**FreeRTOS 任务状态**` `**CMSIS-RTOS**`'
- en: '&#124; `eRunning` &#124; `osThreadRunning` &#124;'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`eRunning` `osThreadRunning`'
- en: '&#124; `eReady` &#124; `osThreadReady` &#124;'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`eReady` `osThreadReady`'
- en: '&#124; `eBlocked` &#124; `osThreadBlocked` &#124;'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`eBlocked` `osThreadBlocked`'
- en: '&#124; `eSuspended` &#124;  &#124;'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`eSuspended`'
- en: '&#124; `eDeleted` &#124; `osThreadTerminated` &#124;'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`eDeleted` `osThreadTerminated`'
- en: '&#124; `eInvalid` &#124; `osThreadError` &#124;'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`eInvalid` `osThreadError`'
- en: '|'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `osThreadNew` | `xTaskCreateStatic`,`xTaskCreate` |  |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '`osThreadNew` `xTaskCreateStatic`,`xTaskCreate`'
- en: '| `osThreadResume` | `vTaskResume` |  |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '`osThreadResume` `vTaskResume`'
- en: '| `osThreadSetPriority` | `vTaskPrioritySet` |  |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '`osThreadSetPriority` `vTaskPrioritySet`'
- en: '| `osThreadSuspend` | `vTaskSuspend` |  |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '`osThreadSuspend` `vTaskSuspend`'
- en: '| `osThreadTerminate` | `vTaskDelete` | If `Heap1` is used, this function returns
    `osError`. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '`osThreadTerminate` `vTaskDelete` 如果使用 `Heap1`，此函数返回 `osError`。'
- en: '| `osThreadYield` | `taskYIELD` |  |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '`osThreadYield` `taskYIELD`'
- en: Most of the thread controls are a simple 1:1 mapping, so they are straightforward
    to substitute between the two APIs.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数线程控制都是简单的 1:1 映射，因此它们在两个 API 之间替换起来非常直接。
- en: Timers
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计时器
- en: 'Timers are equivalent, with static and dynamic allocation both being defined
    by the same `osTimerNew` function:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器是等效的，静态和动态分配都由相同的 `osTimerNew` 函数定义：
- en: '| **CMSIS-RTOS name** | **FreeRTOS functions called** | **Notes** |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '`**CMSIS-RTOS 名称**` `**FreeRTOS 调用的函数**` `**注意**`'
- en: '| `osTimerDelete` | `xTimerDelete` | If `Heap1` is used, this function returns
    `osError`. It also frees up `TimerCallback_t*` used by the timer to be deleted.
    |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '`osTimerDelete` `xTimerDelete` 如果使用 `Heap1`，此函数返回 `osError`。它还释放了由要删除的计时器使用的
    `TimerCallback_t*`。'
- en: '| `osTimerGetName` | `pcTimerGetName` |  |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '`osTimerGetName` `pcTimerGetName`'
- en: '| `osTimerIsRunning` | `xTimerIsTimerActive` |  |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '`osTimerIsRunning` `xTimerIsTimerActive`'
- en: '| `osTimerNew` | `xTimerCreateStatic`, `xTimerCreate` | Automatic allocation
    for `TimerCallback_t`. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '`osTimerNew` `xTimerCreateStatic`, `xTimerCreate` 为 `TimerCallback_t` 自动分配。'
- en: '| `osTimerStart` | `xTimerChangePeriod` |  |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '`osTimerStart` `xTimerChangePeriod`'
- en: '| `osTimerStop` | `xTimerStop` |  |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '`osTimerStop` `xTimerStop`'
- en: Timers are very similar between the two APIs, but beware of attempting to use
    `osTimerDelete` with `Heap1`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 API 中的计时器非常相似，但请注意不要尝试使用 `osTimerDelete` 与 `Heap1` 一起使用。
- en: Memory pools
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存池
- en: Memory pools are a popular dynamic allocation technique commonly found in embedded
    RTOSes. FreeRTOS does not currently supply a memory pool implementation out of
    the box. A design decision was made in early development to eliminate it because
    it added extra user-facing complexity and wasted too much RAM.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 内存池是嵌入式 RTOS 中常见的流行动态分配技术。FreeRTOS 目前没有提供内存池实现。在早期开发中，做出了一项设计决策，即消除它，因为它增加了额外的用户界面复杂性，并且浪费了太多的
    RAM。
- en: ARM and ST have elected to not supply any memory pool implementations on top
    of FreeRTOS.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 和 ST 选择不在 FreeRTOS 之上提供任何内存池实现。
- en: That concludes our complete cross-reference of the CMSIS-RTOS and FreeRTOS APIs.
    It should have been helpful in quickly determining what differences you need to
    be aware of. While CMSIS-RTOS can be used with RTOSes from different vendors,
    it does not contain all of the features that FreeRTOS has to offer (such as stream
    buffers).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们对 CMSIS-RTOS 和 FreeRTOS API 的完整交叉引用。这应该有助于快速确定你需要注意的差异。虽然 CMSIS-RTOS
    可以与不同供应商的 RTOS 一起使用，但它并不包含 FreeRTOS 提供的所有功能（例如流缓冲区）。
- en: Now that we've seen a comparison between the native FreeRTOS API and the CMSIS-RTOS
    v2 API, let's take a look at an example of an application using CMSSI-RTOS v2.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了原生 FreeRTOS API 和 CMSIS-RTOS v2 API 之间的比较，让我们看看一个使用 CMSSI-RTOS v2 的应用程序示例。
- en: Creating a simple CMSIS-RTOS v2 application
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的 CMSIS-RTOS v2 应用程序
- en: Armed with an understanding of the differences between the native FreeRTOS API
    and the CMSIS-RTOS v2 API, we can develop a bare-bones application with two tasks
    that blink some LEDs. The goal of this application is to develop code that is
    only dependent on the CMCSIS-RTOS API rather than the FreeRTOS API. All the code
    found here resides in `main_taskCreation_CMSIS_RTOSV2.c`*.*
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 带着对原生 FreeRTOS API 和 CMSIS-RTOS v2 API 之间差异的理解，我们可以开发一个仅依赖于 CMSIS-RTOS API 而不是
    FreeRTOS API 的裸机应用程序，其中包含两个闪烁 LED 的任务。此应用程序的目标是开发仅依赖于 CMSIS-RTOS API 的代码。这里找到的所有代码都位于`main_taskCreation_CMSIS_RTOSV2.c`中。
- en: 'This example is similar to those found in [Chapter 7](2fa909fe-91a6-48c1-8802-8aa767100b8f.xhtml), *The
    FreeRTOS Scheduler*; this one only sets up tasks and blinks LEDs. Follow these
    steps:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例与[第7章](2fa909fe-91a6-48c1-8802-8aa767100b8f.xhtml)中找到的类似，*FreeRTOS 调度器*；此示例仅设置任务并闪烁
    LED。请按照以下步骤操作：
- en: 'Initialize the RTOS using `osStatus_t osKernelInitialize (void)`, checking
    the return value before continuing:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`osKernelInitialize(void)`初始化 RTOS，在继续之前检查返回值：
- en: '[PRE0]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Since CMSIS-RTOS uses structs to pass in thread attributes, populate an `osThreadAttr_t`
    structure from `cmsis_os2.h`:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 CMSIS-RTOS 使用结构体传递线程属性，因此请从`cmsis_os2.h`中填充一个`osThreadAttr_t`结构：
- en: '[PRE1]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Note**: Unlike FreeRTOS stack sizes, which are defined in the number of *words*
    the stack will consume (4 bytes for Cortex-M7), CMSIS-RTOS sizes are always defined
    in *bytes.* Previously, when using the FreeRTOS API, we were using 128 words for
    the stack size. Here, to achieve the same stack size, we''ll use 128 * 4 = 512
    bytes.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：与 FreeRTOS 栈大小不同，FreeRTOS 栈大小是以堆栈将消耗的*字数*定义的（Cortex-M7 为 4 字节），CMSIS-RTOS
    的大小始终以*字节*定义。以前，当使用 FreeRTOS API 时，我们使用 128 字节作为栈大小。在这里，为了达到相同的栈大小，我们将使用 128 *
    4 = 512 字节。'
- en: '[PRE2]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding code, we can see the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到以下内容：
- en: Only `osThreadDetachted` is supported for `attr_bits`.
  id: totrans-196
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅支持`osThreadDetachted`用于`attr_bits`。
- en: The first task to be created will use dynamic allocation, so the control block
    and stack-related variables (`cb_mem, cb_size, stack_mem, stack_size`) will be
    set to `0` and `NULL`.
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要创建的第一个任务将使用动态分配，因此控制块和与堆栈相关的变量（`cb_mem, cb_size, stack_mem, stack_size`）将被设置为`0`和`NULL`。
- en: Normal priority will be used here.
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里将使用正常优先级。
- en: Cortex-M7 MCUs (STM32F759) do not have a trust zone.
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cortex-M7 微控制器（STM32F759）没有信任区域。
- en: 'Create the thread by calling `osThreadNew()` and passing in a pointer to the
    function that implements the desired thread, any task arguments, and a pointer
    to the `osThreadAttr_t` structure. The prototype for `osThreadNew(` is as follows:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`osThreadNew()`并传递实现所需线程的函数指针、任何任务参数以及指向`osThreadAttr_t`结构的指针来创建线程。`osThreadNew()`的原型如下：
- en: '[PRE3]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is the actual call to `osThreadNew()`, which creates the `GreenTask` thread.
    Again, be sure to check that the thread has been successfully created before moving
    on:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是实际调用`osThreadNew()`的代码，它创建`GreenTask`线程。再次提醒，在继续之前，请确保线程已成功创建：
- en: '[PRE4]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `GreenTask` function will blink the green LED (on for 200 ms and off for
    200 ms):'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GreenTask`函数将闪烁绿色 LED（开启 200 毫秒，关闭 200 毫秒）：'
- en: '[PRE5]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is worth noting that, unlike the case in FreeRTOS's `vTaskDelay()` where
    the delay is dependent on the underlying tick frequency, CMSIS-RTOS's `osDelay()`
    is suggested by Keil/ARM documentation to be specified in milliseconds.  However,
    the documentation also refers to the argument as *ticks.* Since a tick isn't necessarily
    1 ms long, be sure to check your implementation of `osDelay()` in `cmsis_os2.c`.
    For example, in the copy of `cmsis_os2.c`obtained from STM, no conversion is performed
    between ticks and ms.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，与 FreeRTOS 的`vTaskDelay()`不同，其中延迟取决于底层滴答频率，CMSIS-RTOS 的`osDelay()`根据
    Keil/ARM 文档建议指定为毫秒。然而，文档还提到该参数为*滴答*。由于滴答不一定是 1 毫秒，请确保检查您在`cmsis_os2.c`中实现的`osDelay()`。例如，从
    STM 获得的`cmsis_os2.c`副本中，没有在滴答和毫秒之间进行转换。
- en: 'Start the scheduler:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动调度器：
- en: '[PRE6]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This call should not return when successful.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 此调用在成功时不应返回。
- en: '`main_taskCreation_CMSIS_RTOSV2.c` also contains an example of starting a task
    with statically allocated memory for the task control block and task stack.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`main_taskCreation_CMSIS_RTOSV2.c`还包含了一个示例，展示了如何使用静态分配的内存启动任务控制块和任务堆栈。'
- en: Static allocation requires computing the sizes of RTOS control blocks (such
    as `StaticTask_t`) that are specific to the underlying RTOS. To reduce the coupling
    of code to the underlying RTOS, an additional header file should be used to encapsulate
    all RTOS-specific sizes. In this example, this file is named `RTOS_Dependencies.h`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分配需要计算底层 RTOS 控制块（例如 `StaticTask_t`）的大小，这些控制块是针对底层 RTOS 特定的。为了减少代码与底层 RTOS
    的耦合，应该使用一个额外的头文件来封装所有 RTOS 特定的大小。在这个例子中，这个文件被命名为 `RTOS_Dependencies.h`。
- en: Tasks created from statically allocated memory use the same `osThreadCreate()`
    function call as before. This time, the `cb_mem, cb_size, stack_mem, stack_size` variables will
    be populated with pointers and sizes.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 从静态分配的内存中创建的任务使用与之前相同的 `osThreadCreate()` 函数调用。这次，`cb_mem, cb_size, stack_mem,
    stack_size` 变量将被填充为指针和大小。
- en: 'Define an array, which will be used as the task stack:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个数组，该数组将用作任务堆栈：
- en: '[PRE7]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Populate `RTOS_Dependencies.h` with the size of the FreeRTOS task control block
    used for static tasks:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RTOS_Dependencies.h` 中填充用于静态任务的 FreeRTOS 任务控制块的大小：
- en: '[PRE8]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Define an array that''s large enough to hold the task control block:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个足够大的数组来存储任务控制块：
- en: '[PRE9]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create an `osThreadAttr_t` struct containing all of the name, pointer, and
    task priorities:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含所有名称、指针和任务优先级的 `osThreadAttr_t` 结构体：
- en: '[PRE10]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create the `RedTask` thread, making sure that it has been successfully created
    before moving on:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `RedTask` 线程，确保在继续之前它已经成功创建：
- en: '[PRE11]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`main_taskCreate_CMSIS_RTOSV2.c` can be compiled and flashed onto the Nucleo
    board and used as a starting point to experiment with the remainder of the CMSIS-RTOSv2
    API. You can use this basic program to jump-start additional CMSIS-RTOSv2 API
    experimentation.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`main_taskCreate_CMSIS_RTOSV2.c` 可以编译并烧录到 Nucleo 板上，用作实验 CMSIS-RTOSv2 API 的起点。您可以使用这个基本程序来启动对
    CMSIS-RTOSv2 API 的进一步实验。'
- en: Now that we have an understanding of a commonly used MCU-centric API for FreeRTOS,
    let's move on to a standard that has been around since the 1980s and is still
    going strong.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 FreeRTOS 常用的以 MCU 为主的 API，让我们继续探讨一个自 1980 年代以来一直存在且仍然活跃的标准。
- en: FreeRTOS and POSIX
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FreeRTOS 和 POSIX
- en: The **Portable Operating System Interface **(**POSIX**) was developed to provide
    a unified interface for interacting with operating systems, making code more portable
    between systems.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**可移植操作系统接口**（**POSIX**）的开发是为了提供一个统一的接口来与操作系统交互，使得代码在不同系统之间更加可移植。'
- en: 'At the time of writing, FreeRTOS has a beta implementation for a subset of
    the POSIX API. The POSIX headers that have been (partly) ported are listed here:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，FreeRTOS 为 POSIX API 的一个子集提供了一个测试版实现。已经（部分）移植的 POSIX 头文件列表如下：
- en: '`errno.h`'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`errno.h`'
- en: '`fcntl.h`'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fcntl.h`'
- en: '`mqueue.h`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mqueue.h`'
- en: '`mqueue.h`'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mqueue.h`'
- en: '`sched.h`'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sched.h`'
- en: '`semaphore.h`'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`semaphore.h`'
- en: '`signal.h`'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`signal.h`'
- en: '`sys/types.h`'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sys/types.h`'
- en: '`time.h`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time.h`'
- en: '`unistd.h`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unistd.h`'
- en: Generally speaking, threading, queues, mutexes, semaphores, timers, sleep, and
    some clock functions are implemented by the port. This feature set sometimes covers
    enough of a real-world use case to enable porting applications that have been
    written to be POSIX-compliant to an MCU supporting FreeRTOS. Keep in mind that FreeRTOS
    does not supply a filesystem on its own without additional middleware, so any
    application requiring filesystem access will need some additional components before
    it will be functional.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，线程、队列、互斥锁、信号量、定时器、睡眠以及一些时钟函数是由端口实现的。这个功能集有时足以覆盖足够的实际用例，从而使得将已经编写为 POSIX
    兼容的应用程序移植到支持 FreeRTOS 的 MCU 上成为可能。请注意，FreeRTOS 本身不提供文件系统，除非有额外的中间件，因此任何需要文件系统访问的应用程序在功能正常之前都需要一些额外的组件。
- en: Let's take a look at what a minimal application using the POSIX API looks like.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用 POSIX API 的最小应用程序是什么样的。
- en: Creating a simple FreeRTOS POSIX application
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的 FreeRTOS POSIX 应用程序
- en: Similarly to the CMSIS API example, the POSIX API example will just blink two
    LEDs at different intervals.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 与 CMSIS API 示例类似，POSIX API 示例将只是在不同间隔下闪烁两个 LED。
- en: Note that after FreeRTOS POSIX moves out of FreeRTOS Labs, the download location
    (and the corresponding instructions) will likely change.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当 FreeRTOS POSIX 从 FreeRTOS Labs 移出后，下载位置（以及相应的说明）可能会发生变化。
- en: 'First, the POSIX wrapper needs to be downloaded and brought into the source
    tree. Perform the following steps:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，需要下载 POSIX 包装器并将其引入到源代码树中。执行以下步骤：
- en: Download the FreeRTOS Labs distribution ( [https://www.freertos.org/a00104.html](https://www.freertos.org/a00104.html)
    ). Go to [https://www.freertos.org/FreeRTOS-Plus/FreeRTOS_Plus_POSIX/index.html](https://www.freertos.org/FreeRTOS-Plus/FreeRTOS_Plus_POSIX/index.html)
    for up-to-date download instructions.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载FreeRTOS Labs发行版（[https://www.freertos.org/a00104.html](https://www.freertos.org/a00104.html)）。前往[https://www.freertos.org/FreeRTOS-Plus/FreeRTOS_Plus_POSIX/index.html](https://www.freertos.org/FreeRTOS-Plus/FreeRTOS_Plus_POSIX/index.html)获取最新的下载说明。
- en: Import the selected `FreeRTOS_POSIX` files into your source tree. In the example,
    they reside in `Middleware\Third_Party\FreeRTOS\FreeRTOS_POSIX`.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将选定的 `FreeRTOS_POSIX` 文件导入到源树中。在示例中，它们位于 `Middleware\Third_Party\FreeRTOS\FreeRTOS_POSIX`。
- en: 'Add the necessary `include` paths to the compiler and linker by modifying the
    project properties within STM32CubeIDE:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过修改STM32CubeIDE中的项目属性，向编译器和链接器添加必要的 `include` 路径：
- en: '![](img/8e80008c-b3c6-4cb5-8e1a-3f47a5134084.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e80008c-b3c6-4cb5-8e1a-3f47a5134084.png)'
- en: 'Make sure to add the following `#define` lines to `Inc/FreeRTOSConfig.h`:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保将以下 `#define` 行添加到 `Inc/FreeRTOSConfig.h`：
- en: '[PRE12]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that POSIX APIs are available, we''ll use `pthreads` and `sleep` in `main_task_Creation_POSIX.c`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在POSIX API可用后，我们将在 `main_task_Creation_POSIX.c` 中使用 `pthreads` 和 `sleep`：
- en: 'Bring in the necessary header files:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引入必要的头文件：
- en: '[PRE13]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Define the necessary function prototypes:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义必要的函数原型：
- en: '[PRE14]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Define global variables to store the thread IDs:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义全局变量以存储线程ID：
- en: '[PRE15]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Use `pthread_create()` to create a thread/task:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `pthread_create()` 创建线程/任务：
- en: '[PRE16]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here''s some information about the preceding code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于前面代码的信息：
- en: '`thread`: A pointer to a `pthread_t` struct, which will be filled out by `pthread_create()`'
  id: totrans-260
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thread`：指向 `pthread_t` 结构的指针，它将由 `pthread_create()` 填充'
- en: '`attr`: A pointer to a struct containing the attributes of the thread'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attr`：指向包含线程属性的结构的指针'
- en: '`start_routine`: A pointer to the function implementing the thread'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start_routine`：指向实现线程的函数的指针'
- en: '`arg`: The arguments to pass to the thread''s function'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arg`：传递给线程函数的参数'
- en: Returns `0` in the case of success and `errrno` in the case of failure (the
    contents of `pthread_t *thread` will be undefined in the case of failure)
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功时返回 `0`，失败时返回 `errrno`（失败时 `pthread_t *thread` 的内容将是未定义的）
- en: 'Here, two threads are started using the functions declared earlier – `GreenTask()`
    and `RedTask()`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用之前声明的函数启动两个线程 – `GreenTask()` 和 `RedTask()`：
- en: '[PRE17]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Start the scheduler:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动调度器：
- en: '[PRE18]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When the scheduler is started, both `GreenTask()` and `ReadTask()` will be switched
    into context as required. Let's have a quick look at each of these functions.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当调度器启动时，`GreenTask()` 和 `ReadTask()` 将根据需要切换到上下文。让我们快速看一下这些函数中的每一个。
- en: '`GreenTask()` is using `sleep()`, brought in from `unistd.h`. Now, `sleep()`
    will force the task to block for the desired number of seconds (in this case,
    1 second after turning the LED on and 1 second after turning the LED off):'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`GreenTask()` 使用从 `unistd.h` 中引入的 `sleep()`，现在 `sleep()` 将强制任务阻塞所需的时间（在这种情况下，LED打开后1秒和关闭后1秒）：'
- en: '[PRE19]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`RedTask()` is similar, sleeping for 2 seconds after the red LED is turned
    off:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`RedTask()` 类似，在关闭红色LED后睡眠2秒：'
- en: '[PRE20]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now `TaskCreation_POSIX` can be compiled and loaded onto the Nucleo board. 
    You're free to use this as a starting point for experimenting with more portions
    of the POSIX API. Next, let's look at some of the reasons why you might want to
    use the POSIX API.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `TaskCreation_POSIX` 可以编译并加载到Nucleo板上。你可以自由地将其作为实验POSIX API更多部分的起点。接下来，让我们看看你可能想要使用POSIX
    API的一些原因。
- en: Pros and cons to using the POSIX API
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 POSIX API 的优缺点
- en: 'There are two primary reasons to consider using the POSIX API for FreeRTOS:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑使用FreeRTOS的POSIX API有两个主要的原因：
- en: '**Portability to general-purpose operating systems: **By definition, the goal
    of POSIX is *portability. *There are many general-purpose operating systems meant
    to be run on CPUs with MMUs that are POSIX-compliant. Increasingly, there are
    also several lightweight operating systems aimed at MCUs that are also POSIX-compliant.
    If your goal is to run your code base on these types of systems, the POSIX API
    is the interface to use. It is the only API for FreeRTOS that will allow code
    to be portable to a fully fledged operating system (rather than a real-time kernel).'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用操作系统的可移植性：**根据定义，POSIX的目标是*可移植性。*有许多通用操作系统旨在在符合POSIX的MMU CPU上运行。日益增多的是，也有针对符合POSIX的MCU的几个轻量级操作系统。如果你的目标是让代码库在这些类型的系统上运行，POSIX
    API是使用的接口。它是FreeRTOS唯一允许代码可移植到完整操作系统的API（而不是实时内核）。'
- en: '**Third-party POSIX libraries**: Many open source libraries are written to
    interface via POSIX. Having the ability to bring in *some* POSIX-compatible third-party
    code (as long as it only accesses the portions that have been ported by FreeRTOS)
    has the potential to quickly boost a project''s functionality.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三方 POSIX 库**：许多开源库都是通过 POSIX 接口编写的。拥有引入一些 POSIX 兼容的第三方代码的能力（只要它只访问 FreeRTOS
    已移植的部分），有可能快速提升项目的功能。'
- en: 'Of course, there are some drawbacks to using the POSIX API as well:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，使用 POSIX API 也有一些缺点：
- en: '**Still in beta**: At the time of writing (early 2020), the POSIX API is still
    in FreeRTOS Labs. Here''s an explanation from `freertos.org`:'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仍在测试阶段**：在撰写本文时（2020 年初），POSIX API 仍在 FreeRTOS 实验室。以下是来自 `freertos.org` 的解释：'
- en: <q>The POSIX library and documentation are in the FreeRTOS Labs.  The libraries
    in the FreeRTOS Labs download directory are fully functional, but undergoing optimizations
    or refactoring to improve memory usage, modularity, documentation, demo usability,
    or test coverage.  They are available as part of the FreeRTOS-Labs download: [https://www.freertos.org/a00104.html](https://www.freertos.org/a00104.html).</q>
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: <q>POSIX 库和文档位于 FreeRTOS 实验室。FreeRTOS 实验室下载目录中的库功能齐全，但正在优化或重构以提高内存使用、模块化、文档、演示可用性和测试覆盖率。它们作为
    FreeRTOS-Labs 下载的一部分提供：[https://www.freertos.org/a00104.html](https://www.freertos.org/a00104.html)。</q>
- en: '**Being limited to the POSIX API may reduce efficiency**: Having code that
    is portable between many different operating systems running on both MCUs and
    CPUs will come with a cost. Any code that you''d like to make portable to any
    platform that supports POSIX will need to contain only POSIX functionality (that
    is implemented by FreeRTOS). Since only a small subset of the FreeRTOS API is
    exposed through POSIX, you''ll be giving up some of the more efficient implementations.
    Some of the most time- and CPU-efficient functionality (such as stream buffers
    and direct task notifications) won''t be available if you''re aiming to have ultra-portable
    code that uses only the POSIX API.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅限于 POSIX API 可能会降低效率**：在运行在 MCU 和 CPU 上的多种不同操作系统之间具有可移植性的代码将付出一定的代价。任何你想移植到支持
    POSIX 的任何平台的代码都需要只包含 POSIX 功能（由 FreeRTOS 实现）。由于只有 FreeRTOS API 的一小部分通过 POSIX 暴露，你将放弃一些更高效的实现。如果你旨在拥有仅使用
    POSIX API 的超可移植代码，一些最耗时和 CPU 效率最高的功能（如流缓冲区和直接任务通知）将不可用。'
- en: 'Having the POSIX API available to ease the addition of third-party code is
    an exciting development for embedded developers. It has the potential to bring
    a large amount of functionality into the embedded space very quickly. But keep
    this in mind: although today''s MCUs are extremely powerful, they''re not general-purpose
    processors. You''ll need to be mindful of all of the code''s interaction and resource
    requirements, especially with systems that have real-time requirements.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 将 POSIX API 提供给嵌入式开发者以简化第三方代码的添加是一个令人兴奋的发展。它有可能非常快速地将大量功能引入嵌入式空间。但请记住：尽管今天的
    MCU 非常强大，但它们不是通用处理器。你需要注意所有代码的交互和资源需求，尤其是对有实时要求的系统。
- en: So, we have three primary options regarding which API to utilize when interacting
    with FreeRTOS. What kinds of considerations should be made when choosing between
    them?
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在选择与 FreeRTOS 交互时使用的 API 方面有三个主要选项。在选择它们时应该考虑哪些因素？
- en: Deciding which API to use
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 决定使用哪个 API
- en: Deciding which API to use is largely based on *where* you'd like your code to
    be portable to and *what* experience various team members have. For example, if
    you're interested in being able to try out different Cortex-M RTOS vendors, CMSIS-RTOS
    is a natural choice. It will allow different operating systems to be brought in
    without changing the application-level code.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 决定使用哪个 API 主要取决于你希望你的代码可移植到哪个地方以及团队成员有哪些经验。例如，如果你对尝试不同的 Cortex-M RTOS 供应商感兴趣，CMSIS-RTOS
    是一个自然的选择。它将允许引入不同的操作系统，而无需更改应用层代码。
- en: Similarly, if your application code needs to be capable of running both in a
    Linux environment on a fully featured CPU as well as on an MCU, the FreeRTOS POSIX
    implementation would make a lot of sense.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果你的应用程序代码需要在功能齐全的 CPU 上的 Linux 环境以及 MCU 上运行，FreeRTOS 的 POSIX 实现将非常有意义。
- en: Since both of these APIs are layered *on top of* the native FreeRTOS API, you'll
    still be able to use any FreeRTOS-specific functionality that is required. The
    following sections should provide some points for consideration and help you decide
    when each API should be chosen. As usual, there is often no right or wrong choice
    – just a set of trade-offs to be made.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个 API 都是建立在原生 FreeRTOS API 之上的，因此你仍然可以使用任何所需的特定于 FreeRTOS 的功能。以下章节应提供一些考虑要点，并帮助你决定何时选择每个
    API。通常情况下，没有绝对的对错选择，只是需要做出一系列权衡。
- en: When to use the native FreeRTOS API
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用原生 FreeRTOS API
- en: 'There are some cases when using only the native FreeRTOS API is advantageous:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况下，仅使用原生 FreeRTOS API 是有利的：
- en: '**Code consistency**:If an existing code base is already using the native FreeRTOS
    API, there is little benefit to writing new code that adds an additional layer
    of complexity (and a different API) on top of it. Although the functionality is
    similar, the actual function signatures and data structures are different. Because
    of these differences, having inconsistency between which API is used by old and
    new code might be very confusing for programmers unfamiliar with the code base.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码一致性**：如果现有的代码库已经使用原生 FreeRTOS API，那么在它之上编写增加额外复杂度（和不同 API）的新代码几乎没有好处。尽管功能相似，但实际函数签名和数据结构是不同的。由于这些差异，新旧代码之间
    API 的不一致性可能会让不熟悉代码库的程序员感到非常困惑。'
- en: '**Support**:If the API you''d like to use is not written by the same writer
    as the RTOS, there is a very good chance that the RTOS vendor won''t be able/willing
    to provide support for problems that arise (since the issue could be relevant
    only to the generic API wrapper layer and not the underlying RTOS). When you''re
    first starting out with an RTOS, you''ll likely find it is easier to get support
    (both by the vendor and forums) if you''re referencing their code rather than
    a third-party wrapper.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持**：如果你想使用的 API 不是由 RTOS 的同一作者编写的，那么 RTOS 供应商很可能无法/愿意为出现的问题提供支持（因为问题可能只与通用
    API 包装器层相关，而不是底层的 RTOS）。当你刚开始使用 RTOS 时，如果你引用的是他们的代码而不是第三方包装器，你可能会发现更容易获得支持（无论是供应商还是论坛）。'
- en: '**Simplicity**: When asking an RTOS vendor which API to use, the response will
    generally be "*the native API we wrote*." On the surface, this may seem a bit
    self-serving. After all, if you''re using their native API, porting your code
    to another vendor''s operating system won''t be as easy. However, there''s a bit
    more to this recommendation than first meets the eye. Each RTOS vendor generally
    has a strong preference for the style they''ve chosen when writing their code
    (and API). Gluing this native API to a different one may be a bit of a paradigm
    shift. Sometimes this extra layer of glue is so thin as to barely be noticed.
    Other times, it can turn into a sticky mess, requiring considerable extra code
    to be written on top of a native API and making it more confusing for developers
    well versed with the native API.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单性**：当询问 RTOS 供应商使用哪个 API 时，通常的回答将是 "*我们编写的原生 API*"。表面上，这可能看起来有点自私。毕竟，如果你使用他们的原生
    API，将代码移植到另一个供应商的操作系统中可能不会那么容易。然而，这个建议的深层含义远不止于此。每个 RTOS 供应商通常对其代码（和 API）所选择的风格有很强的偏好。将这个原生
    API 与另一个 API 粘合可能是一种范式转变。有时，这个额外的粘合层非常薄，几乎不被注意。有时，它可能变成一个粘稠的混乱，需要在原生 API 上编写相当多的额外代码，使熟悉原生
    API 的开发者感到更加困惑。'
- en: '**Code space**:Since each of the generic APIs is a wrapper around the native
    FreeRTOS API, they will require a small amount of additional code space. On larger
    32-bit MCUs, this will rarely be a consideration.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码空间**：由于每个通用 API 都是原生 FreeRTOS API 的包装器，它们将需要少量的额外代码空间。在较大的 32 位 MCU 上，这通常不会成为考虑因素。'
- en: When to use the CMSIS-RTOS API
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用 CMSIS-RTOS API
- en: 'Use CMSIS-RTOS when you''d like your code to be portable to other ARM-based
    MCUs. Some of the other RTOSes that are aimed at MCUs and support the CMSIS-RTOS
    API include the following:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想让你的代码可移植到其他基于 ARM 的 MCU 时，请使用 CMSIS-RTOS。一些旨在针对 MCU 并支持 CMSIS-RTOS API 的其他
    RTOS 包括以下内容：
- en: Micrium uCOS
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Micrium uCOS
- en: Express Logic ThreadX
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Express Logic ThreadX
- en: Keil RTX
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Keil RTX
- en: Zephyr Project
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zephyr 项目
- en: By using only functions provided by CMSIS-RTOS API, your code will run on top
    of any compatible operating system without modification.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仅使用 CMSIS-RTOS API 提供的函数，你的代码可以在任何兼容的操作系统中运行，而无需修改。
- en: When to use the POSIX API
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用 POSIX API
- en: 'Use the POSIX port when you''d like your code to be portable to these operating
    systems, or if there is a library that relies on the POSIX API that you''d like
    to include in your MCU project:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想让你的代码可移植到这些操作系统，或者如果你想在 MCU 项目中包含依赖 POSIX API 的库时，请使用 POSIX 端口：
- en: Linux
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux
- en: Android
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android
- en: Zephyr
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zephyr
- en: Nuttx (POSIX)
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nuttx (POSIX)
- en: Blackberry QNX
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黑莓 QNX
- en: While each of the POSIX-compatible operating systems just listed implements
    portions of POSIX, not all of the feature sets will necessarily intersect. When
    writing code that is intended to be run across multiple targets, a *least common
    denominator* approach will need to be taken – be sure to only use the smallest
    number of features commonly available across all target platforms.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然上面列出的每个 POSIX 兼容的操作系统都实现了 POSIX 的一部分，但并非所有功能集都会必然相交。当编写旨在在多个目标上运行的代码时，需要采取
    *最小公倍数* 方法 - 确保只使用所有目标平台都普遍可用的最少功能。
- en: It is also worth noting that since POSIX-compliant open source applications
    are designed for fully fledged PCs, they may utilize libraries that are not suitable
    for an MCU (for example, a filesystem that is not present using the core FreeRTOS
    kernel).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，由于 POSIX 兼容的开源应用程序是为功能齐全的 PC 设计的，它们可能使用不适合 MCU 的库（例如，使用核心 FreeRTOS 内核不存在的文件系统）。
- en: Summary
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've covered three different APIs that can be used with FreeRTOS
    – the native FreeRTOS API, CMSIS-RTOS, and POSIX. You should now be familiar with
    all of the different APIs available for interacting with FreeRTOS and have an
    understanding of why they exist, as well as an understanding of when it is appropriate
    to use each one. Moving forward, you will be well positioned to make informed
    decisions about which API to use, depending on your particular project's requirements.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了三种可以与 FreeRTOS 一起使用的 API - 原生 FreeRTOS API、CMSIS-RTOS 和 POSIX。你现在应该熟悉所有可用的
    API，了解它们为什么存在，以及何时使用每个 API 是合适的。向前看，你将能够根据你特定项目的需求做出明智的 API 选择。
- en: In the next chapter, we'll switch gears from discussing how to interact with
    FreeRTOS at a high level and discuss some of the low-level details of memory allocation.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从讨论如何以高级别与 FreeRTOS 交互转向讨论内存分配的一些低级细节。
- en: Questions
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments*
    section of the *Appendix*:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束之前，这里有一些问题供你测试你对本章材料的了解。你将在附录的 *评估* 部分找到答案：
- en: What is CMSIS-RTOS, and which vendor supplies its implementation?
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CMSIS-RTOS 是什么，哪个供应商提供其实现？
- en: Name a common operating system that makes heavy use of POSIX.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举一个大量使用 POSIX 的常见操作系统。
- en: 'It is important to choose wisely between the CMSIS-RTOS and FreeRTOS APIs because
    only one is available at a time:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 CMSIS-RTOS 和 FreeRTOS API 之间明智地选择很重要，因为一次只能使用一个：
- en: 'True'
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'True'
- en: 'False'
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'False'
- en: 'By using the POSIX API, any program written for Linux can be easily ported
    to run on FreeRTOS:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用 POSIX API，任何为 Linux 编写的程序都可以轻松移植到 FreeRTOS 上运行：
- en: 'True'
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'True'
- en: 'False'
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'False'
- en: Further reading
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The CMSIS-RTOS v2 API documentation: [https://www.keil.com/pack/doc/CMSIS/RTOS2/html/](https://www.keil.com/pack/doc/CMSIS/RTOS2/html/group__CMSIS__RTOS.html)'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMSIS-RTOS v2 API 文档：[https://www.keil.com/pack/doc/CMSIS/RTOS2/html/](https://www.keil.com/pack/doc/CMSIS/RTOS2/html/group__CMSIS__RTOS.html)
- en: FreeRTOS POSIX API - [https://www.freertos.org/FreeRTOS-Plus/FreeRTOS_Plus_POSIX/index.html](https://www.freertos.org/FreeRTOS-Plus/FreeRTOS_Plus_POSIX/index.html)
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FreeRTOS POSIX API - [https://www.freertos.org/FreeRTOS-Plus/FreeRTOS_Plus_POSIX/index.html](https://www.freertos.org/FreeRTOS-Plus/FreeRTOS_Plus_POSIX/index.html)
- en: A detailed list of FreeRTOS POSIX ported functions
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FreeRTOS POSIX 端口函数的详细列表
- en: 'Zephyr POSIX implementation for the STM32 F7 Nucleo-144 dev board: [https://docs.zephyrproject.org/latest/boards/arm/nucleo_f767zi/doc/index.html](https://docs.zephyrproject.org/latest/boards/arm/nucleo_f767zi/doc/index.html)'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STM32 F7 Nucleo-144 开发板的 Zephyr POSIX 实现文档：[https://docs.zephyrproject.org/latest/boards/arm/nucleo_f767zi/doc/index.html](https://docs.zephyrproject.org/latest/boards/arm/nucleo_f767zi/doc/index.html)
