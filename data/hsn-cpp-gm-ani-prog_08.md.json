["```cpp\n    template<typename T>\n    class Bezier {\n    public:\n    \u00a0\u00a0\u00a0\u00a0T P1; // Point 1\n    \u00a0\u00a0\u00a0\u00a0T C1; // Control 1\n    \u00a0\u00a0\u00a0\u00a0T P2; // Point 2\n    \u00a0\u00a0\u00a0\u00a0T C2; // Control 2\n    };\n    ```", "```cpp\n    template<typename T>\n    inline T Interpolate(Bezier<T>& curve, float t) {\n    \u00a0\u00a0\u00a0\u00a0T A = lerp(curve.P1, curve.C1, t);\n    \u00a0\u00a0\u00a0\u00a0T B = lerp(curve.C2, curve.P2, t);\n    \u00a0\u00a0\u00a0\u00a0T C = lerp(curve.C1, curve.C2, t);\n    \u00a0\u00a0\u00a0\u00a0T D = lerp(A, C, t);\n    \u00a0\u00a0\u00a0\u00a0T E = lerp(C, B, t);\n    \u00a0\u00a0\u00a0\u00a0T R = lerp(D, E, t);\n    \u00a0\u00a0\u00a0\u00a0return R;\n    }\n    ```", "```cpp\n    Bezier<vec3> curve;\n    curve.P1 = vec3(-5, 0, 0);\n    curve.P2 = vec3(5, 0, 0);\n    curve.C1 = vec3(-2, 1, 0);\n    curve.C2 = vec3(2, 1, 0);\n\n    vec3 red = vec3(1, 0, 0);\n    vec3 green = vec3(0, 1, 0);\n    vec3 blue = vec3(0, 0, 1);\n    vec3 magenta = vec3(1, 0, 1);\n    ```", "```cpp\n    // Draw all relevant points\n    DrawPoint(curve.P1, red);\n    DrawPoint(curve.C1, green);\n    DrawPoint(curve.P2, red);\n    DrawPoint(curve.C2, green);\n    // Draw handles\n    DrawLine(curve.P1, curve.C1, blue);\n    DrawLine(curve.P2, curve.C2, blue);\n    ```", "```cpp\n    // Draw the actual curve\n    // Resolution is 200 steps since last point is i + 1\n    for (int i = 0; i < 199; ++i) {\n    \u00a0\u00a0\u00a0\u00a0float t0 = (float)i / 199.0f;\n    \u00a0\u00a0\u00a0\u00a0float t1 = (float)(i + 1) / 199.0f;\n    \u00a0\u00a0\u00a0\u00a0vec3 thisPoint = Interpolate(curve, t0);\n    \u00a0\u00a0\u00a0\u00a0vec3 nextPoint = Interpolate(curve, t1);\n    \u00a0\u00a0\u00a0\u00a0DrawLine(thisPoint, nextPoint, magenta);\n    }\n    ```", "```cpp\n    template<typename T>\n    inline T Interpolate(const Bezier<T>& curve, float t) {\n    \u00a0\u00a0\u00a0\u00a0T A = curve.P1 * (1.0f - t) + curve.C1 * t;\n    \u00a0\u00a0\u00a0\u00a0T B = curve.C2 * (1.0f - t) + curve.P2 * t;\n    \u00a0\u00a0\u00a0\u00a0T C = curve.C1 * (1.0f - t) + curve.C2 * t;\n    \u00a0\u00a0\u00a0\u00a0T D = A * (1.0f - t) + C * t;\n    \u00a0\u00a0\u00a0\u00a0T E = C * (1.0f - t) + B * t;\n    \u00a0\u00a0\u00a0\u00a0T R = D * (1.0f - t) + E * t;\n    \u00a0\u00a0\u00a0\u00a0return R;\n    }\n    ```", "```cpp\n    ((P1 * (1 - t) + C1 * t) * (1 - t) + (C1 * (1 - t) \n    + C2 * t) * t) * (1 - t) + ((C1 * (1 - t) + C2 * t) \n    * (1 - t) + (C2 * (1 - t) + P2 * t) * t) * t\n    ```", "```cpp\n    template<typename T>\n    inline T Interpolate(const Bezier<T>& c, float t) {\n    \u00a0\u00a0 return \n    \u00a0\u00a0\u00a0\u00a0 ((c.P1 * (1.0f - t) + c.C1 * t) * (1.0f - t) + \n    \u00a0\u00a0\u00a0\u00a0 (c.C1 * (1.0f - t) + c.C2 * t) * t) * (1.0f - t) \n    \u00a0\u00a0\u00a0\u00a0 + ((c.C1 * (1.0f - t) + c.C2 * t) * (1.0f - t) + \n    \u00a0\u00a0\u00a0\u00a0 (c.C2 * (1.0f - t) + c.P2 * t) * t) * t;\n    }\n    ```", "```cpp\n    -P1t3 + 3P1t2 - 3P1t + P1 + 3C1t3 - 6C1t2 + 3C1t - 3C2t3 + 3C2t2 + P2t3\n    ```", "```cpp\n    template<typename T>\n    inline T Interpolate(const Bezier<T>& curve, float t) {\n    \u00a0\u00a0\u00a0\u00a0return\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0curve.P1 * (t * t * t) * -1.0f +\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0curve.P1 * 3.0f * (t * t) -\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0curve.P1 * 3.0f * t +\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0curve.P1 +\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0curve.C1 * 3.0f * (t * t * t) -\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0curve.C1 * 6.0f * (t * t) +\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0curve.C1 * 3.0f * t -\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0curve.C2 * 3.0f * (t * t * t) +\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0curve.C2 * 3.0f * (t * t) +\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0curve.P2 * (t * t * t);\n    }\n    ```", "```cpp\n    P1( -t3 + 3t2 - 3t + 1) +\n    C1( 3t3 - 6t2 + 3t)+\n    C2(-3t3 + 3t2)+\n    P2(\u00a0\u00a0t3)\n    ```", "```cpp\n    template<typename T>\n    inline T Interpolate(const Bezier<T>& c, float t) {\n    \u00a0\u00a0\u00a0\u00a0float ttt = t * t * t;\n    \u00a0\u00a0\u00a0\u00a0float tt = t * t;\n    \u00a0\u00a0\u00a0\u00a0return \n    \u00a0\u00a0\u00a0\u00a0c.P1 * (-1.0f * ttt + 3.0f * tt - 3.0f * t + 1.0f) +\n    \u00a0\u00a0\u00a0\u00a0c.C1 * (3.0f * ttt - 6.0f * tt + 3.0f * t) +\n    \u00a0\u00a0\u00a0\u00a0c.C2 * (-3.0f * ttt + 3.0f * tt) +\n    \u00a0\u00a0\u00a0\u00a0c.P2 * ttt;\n    }\n    ```", "```cpp\n    P1((1-t)3) +\n    C1(3(1-t)2t) +\n    C2(3(1-t)t2) +\n    P2(t3)\n    ```", "```cpp\n    template<typename T>\n    inline T Interpolate(const Bezier<T>& curve, float t) {\n    \u00a0\u00a0\u00a0\u00a0return curve.P1 * ((1 - t) * (1 - t) * (1 - t)) +\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0curve.C1 * (3.0f * ((1 - t) * (1 - t)) * t) +\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0curve.C2 * (3.0f * (1 - t) * (t * t)) +\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0curve.P2 *(t * t * t);\n    }\n    ```", "```cpp\ntemplate<typename T>\nT Hermite(float t, T& p1, T& s1, T& p2, T& s2) {\n\u00a0\u00a0 return \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0p1 * ((1.0f + 2.0f * t) * ((1.0f - t) * (1.0f - t))) +\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s1 * (t * ((1.0f - t) * (1.0f - t))) +\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0p2 * ((t * t) * (3.0f - 2.0f * t)) +\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s2 * ((t * t) * (t - 1.0f));\n}\n```", "```cpp\nenum class Interpolation { \n\u00a0\u00a0\u00a0\u00a0Constant, \n\u00a0\u00a0\u00a0\u00a0Linear, \n\u00a0\u00a0\u00a0\u00a0Cubic \n};\n```", "```cpp\n    template<unsigned int N>\n    class Frame {\n    public:\n    \u00a0\u00a0\u00a0\u00a0float mValue[N];\n    \u00a0\u00a0\u00a0\u00a0float mIn[N];\n    \u00a0\u00a0\u00a0\u00a0float mOut[N];\n    \u00a0\u00a0\u00a0\u00a0float mTime;\n    };\n    ```", "```cpp\n    typedef Frame<1> ScalarFrame;\n    typedef Frame<3> VectorFrame;\n    typedef Frame<4> QuaternionFrame;\n    ```", "```cpp\n    template<typename T, int N>\n    class Track {\n    protected:\n    \u00a0\u00a0\u00a0\u00a0std::vector<Frame<N>> mFrames;\n    \u00a0\u00a0\u00a0\u00a0Interpolation mInterpolation;\n    ```", "```cpp\n    public:\n    \u00a0\u00a0\u00a0\u00a0Track();\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0void Resize(unsigned int size);\n    \u00a0\u00a0\u00a0\u00a0unsigned int Size();\n    \u00a0\u00a0\u00a0\u00a0Interpolation GetInterpolation();\n    \u00a0\u00a0\u00a0\u00a0void SetInterpolation(Interpolation interp);\n    \u00a0\u00a0\u00a0\u00a0float GetStartTime();\n    \u00a0\u00a0\u00a0\u00a0float GetEndTime();\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0T Sample(float time, bool looping);\n    \u00a0\u00a0\u00a0\u00a0Frame<N>& operator[](unsigned int index);\n    ```", "```cpp\n    protected:\n    \u00a0\u00a0\u00a0\u00a0T SampleConstant(float time, bool looping);\n    \u00a0\u00a0\u00a0\u00a0T SampleLinear(float time, bool looping);\n    \u00a0\u00a0\u00a0\u00a0T SampleCubic(float time, bool looping);\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0T Hermite(float time, const T& p1, const T& s1, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const T& p2, const T& s2);\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0int FrameIndex(float time, bool looping);\n    \u00a0\u00a0\u00a0\u00a0float AdjustTimeToFitTrack(float t, bool loop);\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0T Cast(float* value); // Will be specialized\n    };\n    ```", "```cpp\n    typedef Track<float, 1> ScalarTrack;\n    typedef Track<vec3, 3> VectorTrack;\n    typedef Track<quat, 4> QuaternionTrack;\n    ```", "```cpp\ntemplate Track<float, 1>;\ntemplate Track<vec3, 3>;\ntemplate Track<quat, 4>;\n```", "```cpp\n    namespace TrackHelpers {\n    \u00a0\u00a0 inline float Interpolate(float a, float b, float t) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return a + (b - a) * t;\n    \u00a0\u00a0 }\n    \u00a0\u00a0 inline vec3 Interpolate(const vec3& a, const vec3& b,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 float t) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return lerp(a, b, t);\n    \u00a0\u00a0 }\n    \u00a0\u00a0 inline quat Interpolate(const quat& a, const quat& b,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 float t) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 quat result = mix(a, b, t);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if (dot(a, b) < 0) { // Neighborhood\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 result = mix(a, -b, t);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return normalized(result); //NLerp, not slerp\n    \u00a0\u00a0 }\n    ```", "```cpp\n    \u00a0\u00a0 inline float AdjustHermiteResult(float f) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return f;\n    \u00a0\u00a0 }\n    \u00a0\u00a0 inline vec3 AdjustHermiteResult(const vec3& v) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return v;\n    \u00a0\u00a0 }\n    \u00a0\u00a0 inline quat AdjustHermiteResult(const quat& q) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return normalized(q);\n    \u00a0\u00a0 }\n    ```", "```cpp\n    \u00a0\u00a0 inline void Neighborhood(const float& a, float& b){}\n    \u00a0\u00a0 inline void Neighborhood(const vec3& a, vec3& b){}\n    \u00a0\u00a0 inline void Neighborhood(const quat& a, quat& b) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (dot(a, b) < 0) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 b = -b;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0 }\n    }; // End Track Helpers namespace\n    ```", "```cpp\n    template<typename T, int N>\n    Track<T, N>::Track() {\n    \u00a0\u00a0\u00a0\u00a0mInterpolation = Interpolation::Linear;\n    }\n    template<typename T, int N>\n    float Track<T, N>::GetStartTime() {\n    \u00a0\u00a0\u00a0\u00a0return mFrames[0].mTime;\n    }\n    template<typename T, int N>\n    float Track<T, N>::GetEndTime() {\n    \u00a0\u00a0\u00a0\u00a0return mFrames[mFrames.size() - 1].mTime;\n    }\n    ```", "```cpp\n    template<typename T, int N>\n    T Track<T, N>::Sample(float time, bool looping) {\n    \u00a0\u00a0\u00a0\u00a0if (mInterpolation == Interpolation::Constant) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return SampleConstant(time, looping);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0else if (mInterpolation == Interpolation::Linear) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return SampleLinear(time, looping);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return SampleCubic(time, looping);\n    }\n    template<typename T, int N>\n    Frame<N>& Track<T, N>::operator[](unsigned int index) {\n    \u00a0\u00a0\u00a0\u00a0return mFrames[index];\n    }\n    ```", "```cpp\n    template<typename T, int N>\n    void Track<T, N>::Resize(unsigned int size) {\n    \u00a0\u00a0\u00a0\u00a0mFrames.resize(size);\n    }\n    template<typename T, int N>\n    unsigned int Track<T, N>::Size() {\n    \u00a0\u00a0\u00a0\u00a0return mFrames.size();\n    }\n    ```", "```cpp\n    template<typename T, int N>\n    Interpolation Track<T, N>::GetInterpolation() {\n    \u00a0\u00a0\u00a0\u00a0return mInterpolation;\n    }\n    template<typename T, int N>\n    void Track<T, N>::SetInterpolation(Interpolation interpolation) {\n    \u00a0\u00a0\u00a0\u00a0mInterpolation = interpolation;\n    }\n    ```", "```cpp\n    template<typename T, int N>\n    T Track<T, N>::Hermite(float t, const T& p1, const T& s1,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 const T& _p2, const T& s2) {\n    \u00a0\u00a0\u00a0\u00a0float tt = t * t;\n    \u00a0\u00a0\u00a0\u00a0float ttt = tt * t;\n    \u00a0\u00a0\u00a0\u00a0T p2 = _p2;\n    \u00a0\u00a0\u00a0\u00a0TrackHelpers::Neighborhood(p1, p2);\n    \u00a0\u00a0\u00a0\u00a0float h1 = 2.0f * ttt - 3.0f * tt + 1.0f;\n    \u00a0\u00a0\u00a0\u00a0float h2 = -2.0f * ttt + 3.0f * tt;\n    \u00a0\u00a0\u00a0\u00a0float h3 = ttt - 2.0f * tt + t;\n    \u00a0\u00a0\u00a0\u00a0float h4 = ttt - tt;\n    \u00a0\u00a0\u00a0\u00a0T result = p1 * h1 + p2 * h2 + s1 * h3 + s2 * h4;\n    \u00a0\u00a0\u00a0\u00a0return TrackHelpers::AdjustHermiteResult(result);\n    }\n    ```", "```cpp\n    template<typename T, int N>\n    int Track<T, N>::FrameIndex(float time, bool looping) {\n    \u00a0\u00a0\u00a0\u00a0unsigned int size = (unsigned int)mFrames.size();\n    \u00a0\u00a0\u00a0\u00a0if (size <= 1) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -1;\n    \u00a0\u00a0\u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0if (looping) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float startTime = mFrames[0].mTime;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float endTime = mFrames[size - 1].mTime;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float duration = endTime - startTime;\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0time = fmodf(time - startTime, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 endTime - startTime);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (time < 0.0f) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0time += endTime - startTime;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0time = time + startTime;\n    \u00a0\u00a0\u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0else {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (time <= mFrames[0].mTime) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (time >= mFrames[size - 2].mTime) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return (int)size - 2;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0for (int i = (int)size - 1; i >= 0; --i) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (time >= mFrames[i].mTime) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return i;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Invalid code, we should not reach here!\n    \u00a0\u00a0\u00a0\u00a0return -1;\n    } // End of FrameIndex\n    ```", "```cpp\n    template<typename T, int N>\n    float Track<T, N>::AdjustTimeToFitTrack(float time, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0bool looping) {\n    \u00a0\u00a0\u00a0\u00a0unsigned int size = (unsigned int)mFrames.size();\n    \u00a0\u00a0\u00a0\u00a0if (size <= 1) { \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0.0f; \n    \u00a0\u00a0\u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0float startTime = mFrames[0].mTime;\n    \u00a0\u00a0\u00a0\u00a0float endTime = mFrames[size - 1].mTime;\n    \u00a0\u00a0\u00a0\u00a0float duration = endTime - startTime;\n    \u00a0\u00a0\u00a0\u00a0if (duration <= 0.0f) { \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0.0f; \n    \u00a0\u00a0\u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0if (looping) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0time = fmodf(time - startTime, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 endTime - startTime);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (time < 0.0f) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0time += endTime - startTime;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0time = time + startTime;\n    \u00a0\u00a0\u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0else {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (time <= mFrames[0].mTime) { \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0time = startTime;\u00a0\u00a0\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (time >= mFrames[size - 1].mTime) { \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0time = endTime; \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return time;\n    }\n    ```", "```cpp\nTrack<float, 1> t;\nfloat mAnimTime = 0.0f;\nvoid Update(float dt) { // dt: delta time of frame\n\u00a0\u00a0\u00a0\u00a0mAnimTime = t. AdjustTimeToFitTrack (mAnimTime + dt);\n}\n```", "```cpp\ntemplate<> float Track<float, 1>::Cast(float* value) {\n\u00a0\u00a0\u00a0\u00a0return value[0];\n}\ntemplate<> vec3 Track<vec3, 3>::Cast(float* value) {\n\u00a0\u00a0\u00a0\u00a0return vec3(value[0], value[1], value[2]);\n}\ntemplate<> quat Track<quat, 4>::Cast(float* value) {\n\u00a0\u00a0\u00a0\u00a0quat r = quat(value[0], value[1], value[2], value[3]);\n\u00a0\u00a0\u00a0\u00a0return normalized(r);\n}\n```", "```cpp\ntemplate<typename T, int N>\nT Track<T, N>::SampleConstant(float t, bool loop) {\n\u00a0\u00a0\u00a0\u00a0int frame = FrameIndex(t, loop);\n\u00a0\u00a0\u00a0\u00a0if (frame < 0 || frame >= (int)mFrames.size()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return T();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return Cast(&mFrames[frame].mValue[0]);\n}\n```", "```cpp\ntemplate<typename T, int N>\nT Track<T, N>::SampleLinear(float time, bool looping) {\n\u00a0\u00a0\u00a0\u00a0int thisFrame = FrameIndex(time, looping);\n\u00a0\u00a0\u00a0\u00a0if (thisFrame < 0 || thisFrame >= mFrames.size() - 1) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return T();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0int nextFrame = thisFrame + 1;\n\u00a0\u00a0\u00a0\u00a0float trackTime = AdjustTimeToFitTrack(time, looping);\n\u00a0\u00a0\u00a0\u00a0float thisTime = mFrames[thisFrame].mTime;\n\u00a0\u00a0\u00a0\u00a0float frameDelta = mFrames[nextFrame].mTime \u2013 thisTime;\n\u00a0\u00a0\u00a0\u00a0if (frameDelta <= 0.0f) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return T();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0float t = (trackTime - thisTime) / frameDelta;\n\u00a0\u00a0\u00a0\u00a0T start = Cast(&mFrames[thisFrame].mValue[0]);\n\u00a0\u00a0\u00a0\u00a0T end = Cast(&mFrames[nextFrame].mValue[0]);\n\u00a0\u00a0\u00a0\u00a0return TrackHelpers::Interpolate(start, end, t);\n}\n```", "```cpp\ntemplate<typename T, int N>\nT Track<T, N>::SampleCubic(float time, bool looping) {\n\u00a0\u00a0\u00a0\u00a0int thisFrame = FrameIndex(time, looping);\n\u00a0\u00a0\u00a0\u00a0if (thisFrame < 0 || thisFrame >= mFrames.size() - 1) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return T();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0int nextFrame = thisFrame + 1;\n\u00a0\u00a0\u00a0\u00a0float trackTime = AdjustTimeToFitTrack(time, looping);\n\u00a0\u00a0\u00a0\u00a0float thisTime = mFrames[thisFrame].mTime;\n\u00a0\u00a0\u00a0\u00a0float frameDelta = mFrames[nextFrame].mTime - thisTime;\n\u00a0\u00a0\u00a0\u00a0if (frameDelta <= 0.0f) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return T();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0float t = (trackTime - thisTime) / frameDelta;\n\u00a0\u00a0\u00a0\u00a0size_t fltSize = sizeof(float);\n\u00a0\u00a0\u00a0\u00a0T point1 = Cast(&mFrames[thisFrame].mValue[0]);\n\u00a0\u00a0\u00a0\u00a0T slope1;// = mFrames[thisFrame].mOut * frameDelta;\n\u00a0\u00a0\u00a0\u00a0memcpy(&slope1, mFrames[thisFrame].mOut, N * fltSize);\n\u00a0\u00a0\u00a0\u00a0slope1 = slope1 * frameDelta;\n\u00a0\u00a0\u00a0\u00a0T point2 = Cast(&mFrames[nextFrame].mValue[0]);\n\u00a0\u00a0\u00a0\u00a0T slope2;// = mFrames[nextFrame].mIn[0] * frameDelta;\n\u00a0\u00a0\u00a0\u00a0memcpy(&slope2, mFrames[nextFrame].mIn, N * fltSize);\n\u00a0\u00a0\u00a0\u00a0slope2 = slope2 * frameDelta;\n\u00a0\u00a0\u00a0\u00a0return Hermite(t, point1, slope1, point2, slope2);\n}\n```", "```cpp\n    class TransformTrack {\n    protected:\n    \u00a0\u00a0\u00a0\u00a0unsigned int mId;\n    \u00a0\u00a0\u00a0\u00a0VectorTrack mPosition;\n    \u00a0\u00a0\u00a0\u00a0QuaternionTrack mRotation;\n    \u00a0\u00a0\u00a0\u00a0VectorTrack mScale;\n    ```", "```cpp\n    public:\n    \u00a0\u00a0\u00a0\u00a0TransformTrack();\n    \u00a0\u00a0\u00a0\u00a0unsigned int GetId();\n    \u00a0\u00a0\u00a0\u00a0void SetId(unsigned int id);\n    \u00a0\u00a0\u00a0\u00a0VectorTrack& GetPositionTrack();\n    \u00a0\u00a0\u00a0\u00a0QuaternionTrack& GetRotationTrack();\n    \u00a0\u00a0\u00a0\u00a0VectorTrack& GetScaleTrack();\n    \u00a0\u00a0\u00a0\u00a0float GetStartTime();\n    \u00a0\u00a0\u00a0\u00a0float GetEndTime();\n    \u00a0\u00a0\u00a0\u00a0bool IsValid();\n    \u00a0\u00a0\u00a0\u00a0Transform Sample(const Transform& ref, float time, bool looping);\n    };\n    ```", "```cpp\n    TransformTrack::TransformTrack() {\n    \u00a0\u00a0\u00a0\u00a0mId = 0;\n    }\n    unsigned int TransformTrack::GetId() {\n    \u00a0\u00a0\u00a0\u00a0return mId;\n    }\n    void TransformTrack::SetId(unsigned int id) {\n    \u00a0\u00a0\u00a0\u00a0mId = id;\n    }\n    ```", "```cpp\n    VectorTrack& TransformTrack::GetPositionTrack() {\n    \u00a0\u00a0\u00a0\u00a0return mPosition;\n    }\n    QuaternionTrack& TransformTrack::GetRotationTrack() {\n    \u00a0\u00a0\u00a0\u00a0return mRotation;\n    }\n    VectorTrack& TransformTrack::GetScaleTrack() {\n    \u00a0\u00a0\u00a0\u00a0return mScale;\n    }\n    ```", "```cpp\n    bool TransformTrack::IsValid() {\n    \u00a0\u00a0\u00a0\u00a0return mPosition.Size() > 1 || \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 mRotation.Size() > 1 || \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 mScale.Size() > 1;\n    }\n    ```", "```cpp\n    float TransformTrack::GetStartTime() {\n    \u00a0\u00a0\u00a0\u00a0float result = 0.0f;\n    \u00a0\u00a0\u00a0\u00a0bool isSet = false;\n    \u00a0\u00a0\u00a0\u00a0if (mPosition.Size() > 1) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result = mPosition.GetStartTime();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0isSet = true;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if (mRotation.Size() > 1) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float rotationStart = mRotation.GetStartTime();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (rotationStart < result || !isSet) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result = rotationStart;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0isSet = true;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if (mScale.Size() > 1) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float scaleStart = mScale.GetStartTime();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (scaleStart < result || !isSet) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result = scaleStart;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0isSet = true;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return result;\n    }\n    ```", "```cpp\n    float TransformTrack::GetEndTime() {\n    \u00a0\u00a0\u00a0\u00a0float result = 0.0f;\n    \u00a0\u00a0\u00a0\u00a0bool isSet = false;\n    \u00a0\u00a0\u00a0\u00a0if (mPosition.Size() > 1) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result = mPosition.GetEndTime();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0isSet = true;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if (mRotation.Size() > 1) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float rotationEnd = mRotation.GetEndTime();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (rotationEnd > result || !isSet) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result = rotationEnd;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0isSet = true;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if (mScale.Size() > 1) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float scaleEnd = mScale.GetEndTime();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (scaleEnd > result || !isSet) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result = scaleEnd;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0isSet = true;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return result;\n    }\n    ```", "```cpp\n    Transform TransformTrack::Sample(const Transform& ref,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float time, bool loop) {\n    \u00a0\u00a0\u00a0\u00a0Transform result = ref; // Assign default values\n    \u00a0\u00a0\u00a0\u00a0if (mPosition.Size() > 1) { // Only if valid\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 result.position = mPosition.Sample(time, loop);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if (mRotation.Size() > 1) { // Only if valid\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 result.rotation = mRotation.Sample(time, loop);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if (mScale.Size() > 1) { // Only if valid\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 result.scale = mScale.Sample(time, loop);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return result;\n    }\n    ```"]