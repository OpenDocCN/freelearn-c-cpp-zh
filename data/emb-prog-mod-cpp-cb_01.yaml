- en: Fundamentals of Embedded Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入式系统基础
- en: Embedded systems are computer systems that combine hardware and software components
    to solve a specific task within a larger system or device. Unlike general-purpose
    computers, they are heavily specialized and optimized to perform only one task
    but do it really well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统是将硬件和软件组件结合起来解决更大系统或设备中的特定任务的计算机系统。与通用计算机不同，它们非常专业化和优化，只执行一个任务，但执行得非常出色。
- en: They are everywhere around us, but we rarely notice them. You can find them
    in virtually every home appliance or gadget, such as a microwave oven, TV set,
    network-attached storage, or smart thermostat. Your car contains several interconnected
    embedded systems that handle brakes, fuel injection, and infotainment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 它们无处不在，但我们很少注意到它们。您可以在几乎每个家用电器或小工具中找到它们，例如微波炉、电视机、网络附加存储或智能恒温器。您的汽车包含了几个相互连接的嵌入式系统，用于处理制动、燃油喷射和信息娱乐。
- en: 'In this chapter, we are going to deal with the following topics on embedded
    systems:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将处理嵌入式系统的以下主题：
- en: Exploring embedded systems
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索嵌入式系统
- en: Working with limited resources
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用有限资源
- en: Looking at performance implications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能影响
- en: Working with different architectures
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不同的架构
- en: Working with hardware errors
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理硬件错误
- en: Using C++ for embedded development
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C++进行嵌入式开发
- en: Deploying software remotely
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程部署软件
- en: Running software remotely
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程运行软件
- en: Logging and diagnostics
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志记录和诊断
- en: Exploring embedded systems
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索嵌入式系统
- en: Every computer system created to solve a particular problem as part of a larger
    system or device is an embedded system. Even your general-purpose PC or laptop
    contains many embedded systems. A keyboard, a hard drive, a network card, or a
    Wi-Fi module—each of these is an embedded system with a processor, often called
    a **microcontroller**, and its own software, often called **firmware**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每个计算机系统都是为了解决更大系统或设备的特定问题而创建的嵌入式系统。即使您的通用PC或笔记本电脑也包含许多嵌入式系统。键盘、硬盘驱动器、网络卡或Wi-Fi模块——每个都是具有处理器（通常称为**微控制器**）和自己的软件（通常称为**固件**）的嵌入式系统。
- en: Let's now dive into the different features of an embedded system.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入了解嵌入式系统的不同特性。
- en: How are they different from desktop or web applications?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它们与桌面或Web应用程序有何不同？
- en: The most distinctive feature of embedded systems compared to desktops or servers
    is their tight coupling of hardware and software specialized to accomplish a particular
    task.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与桌面或服务器相比，嵌入式系统最显著的特点是其紧密耦合的硬件和软件，专门用于完成特定任务。
- en: Embedded devices work in a wide range of physical and environmental conditions.
    Most of them are not designed to work only in dedicated conditioned data centers
    or offices. They have to be functional in uncontrollable environments, often without
    any supervision and maintenance.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式设备在各种物理和环境条件下工作。大多数嵌入式系统不是设计为仅在专用条件数据中心或办公室中工作。它们必须在无法控制的环境中正常工作，通常没有任何监督和维护。
- en: Since they are specialized, hardware requirements are precisely calculated to
    accomplish the task of being as cost-efficient as possible. As a result, the software
    aims to utilize 100% of the available resources with minimal or no reserves.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们是专业化的，硬件要求被精确计算，以尽可能地节约成本。因此，软件旨在利用可用资源的100%，并且最小化或没有储备。
- en: The hardware of embedded systems is much more differentiated compared to regular
    desktops and servers. The design of each system is individual. They may require
    very specific CPUs and schematics that connect them to memory and peripheral hardware.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规桌面和服务器相比，嵌入式系统的硬件差异更大。每个系统的设计都是独特的。它们可能需要非常特定的CPU和将它们连接到存储器和外围硬件的电路图。
- en: Embedded systems are designed to communicate with peripheral hardware. A major
    part of an embedded program is checking the status, reading input, sending data,
    or controlling the external device. It is common for an embedded system to not
    have a user interface. This makes development, debugging, and diagnostics much
    more difficult compared to doing the same on traditional desktop or web applications.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统旨在与外围硬件通信。嵌入式程序的主要部分是检查状态、读取输入、发送数据或控制外部设备。嵌入式系统通常没有用户界面。与在传统桌面或Web应用程序上进行相同操作相比，这使得开发、调试和诊断更加困难。
- en: Types of embedded systems
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入式系统类型
- en: Embedded systems span a wide range of use cases and technologies—from powerful
    systems used for autonomous driving or large-scale storage systems to tiny microcontrollers
    used to control light bulbs or LED displays.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统涵盖了广泛的用例和技术，从用于自动驾驶或大规模存储系统的强大系统到用于控制灯泡或LED显示器的微型微控制器。
- en: 'Based on the level of integration and specialization of hardware, embedded
    systems can roughly be divided into the following categories:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 根据硬件的集成和专业化程度，嵌入式系统大致可以分为以下几类：
- en: '**Microcontrollers **(**MCUs**)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微控制器**（**MCUs**）'
- en: '**A** **System on Chip** (**SoC**)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**片上系统**（**SoC**）'
- en: '**Application-Specific Integrated Circuits** (**ASICs**)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特定应用集成电路**（**ASICs**）'
- en: '**Field Programmable Gate Arrays** (**FPGAs**)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**现场可编程门阵列**（**FPGAs**）'
- en: Microcontrollers
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微控制器
- en: MCUs are general-purpose integrated circuits designed for embedded applications.
    A single MCU chip typically contains one or more CPUs, memory, and programmable
    input/output peripherals. Their design allows them to interface directly with
    sensors or actuators without adding any additional components.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: MCUs是为嵌入式应用设计的通用集成电路。单个MCU芯片通常包含一个或多个CPU、存储器和可编程输入/输出外设。它们的设计允许它们直接与传感器或执行器接口，而无需添加任何其他组件。
- en: MCUs are widely used in automobile engine control systems, medical devices,
    remote controls, office machines, appliances, power tools, and toys.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: MCUs广泛应用于汽车发动机控制系统、医疗设备、遥控器、办公设备、家用电器、电动工具和玩具。
- en: Their CPUs vary from simple 8-bit processors to the more complex 32-bit and
    even 64-bit processors.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的CPU从简单的8位处理器到更复杂的32位甚至64位处理器都有。
- en: 'Lots of MCUs exist; the most common ones nowadays are the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多MCUs；如今最常见的是以下几种：
- en: The Intel MCS-51 or 8051 MCU.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 英特尔MCS-51或8051 MCU。
- en: AVR by Atmel
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Atmel的AVR
- en: The **Programmable Interface Controller** (**PIC**) from Microchip Technology
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自Microchip Technology的可编程接口控制器（PIC）
- en: Various ARM-based MCUs
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种基于ARM的MCU
- en: System on Chip
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 片上系统
- en: An SoC is an integrated circuit that combines all the electronic circuits and
    parts needed to solve a particular class of problem on a single chip.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: SoC是一种集成电路，它将解决特定类别问题所需的所有电子电路和部件集成在一个芯片上。
- en: 'It may contain digital, analog, or mixed-signal functions, depending on the
    application. The integration of most electronic parts in a single chip gives two
    major benefits: miniaturization and low power consumption. Compared to a less-integrated
    hardware design, an SoC requires significantly less power. The optimization of
    power consumption on the hardware and software levels allows it to create systems
    that can work for days, months, and even years on a battery without an external
    power source. Often, it also integrates radio frequency signal processing, which,
    along with its compact physical size, makes it an ideal solution for mobile applications.
    Besides that, SoCs are commonly used in the automotive industry, in wearable electronics,
    and in the **Internet of Things** (**IoT**):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能包含数字、模拟或混合信号功能，取决于应用。在单个芯片中集成大多数电子部件的两个主要好处是：小型化和低功耗。与较少集成的硬件设计相比，SoC需要明显更少的功耗。在硬件和软件层面对功耗的优化使其能够在没有外部电源的情况下工作数天、数月甚至数年。通常，它还集成了射频信号处理，加上其紧凑的物理尺寸，使其成为移动应用的理想解决方案。此外，SoC通常用于汽车行业、可穿戴电子产品和物联网（IoT）。
- en: '![](img/5075c1bd-7414-4cbc-bfd7-19097332a3de.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5075c1bd-7414-4cbc-bfd7-19097332a3de.png)'
- en: 'Figure 1.1: A Raspberry Pi Model B+'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：树莓派B+型号
- en: A Raspberry Pi family of single-board computers is an example of a system based
    on the SoC design. Model B+ is built on top of a Broadcom BCM2837B0 SoC with an
    integrated quad-core 1.4 Hz ARM-based CPU, 1 GB memory, a network interface controller,
    and four Ethernet interfaces.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派系列单板计算机是基于SoC设计的系统的一个例子。B+型号建立在Broadcom BCM2837B0 SoC之上，具有集成的四核1.4 GHz基于ARM的CPU，1
    GB内存，网络接口控制器和四个以太网接口。
- en: The board has four USB interfaces, a MicroSD card port to boot an operating
    system and store data, Ethernet and Wi-Fi network interfaces, HDMI video output,
    and a 40-pin GPIO header to connect custom peripheral hardware.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 该板具有四个USB接口，MicroSD卡插槽用于引导操作系统和存储数据，以太网和Wi-Fi网络接口，HDMI视频输出，以及一个40针GPIO头，用于连接自定义外围硬件。
- en: It is shipped with the Linux operating system and is an excellent choice for
    educational and **DIY** projects.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 它配备了Linux操作系统，是教育和DIY项目的绝佳选择。
- en: Application-specific integrated circuits
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特定应用集成电路
- en: '**Application-specific integrated circuits**, or **ASICs**, are integrated
    circuits customized by their manufactures for a particular use. The customization
    is an expensive process but allows them to meet the requirements that are often
    infeasible for solutions based on general-purpose hardware. For example, modern
    high-efficiency Bitcoin miners are usually built on top of specialized ASIC chips.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 特定应用集成电路（ASICs）是由制造商定制用于特定用途的集成电路。定制是一个昂贵的过程，但允许它们满足通常对通用硬件解决方案不可行的要求。例如，现代高效的比特币矿工通常建立在专用ASIC芯片之上。
- en: To define the functionality of ASICs, hardware designers use one of the hardware
    description languages, such as Verilog or VHDL.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义ASIC的功能，硬件设计师使用硬件描述语言之一，如Verilog或VHDL。
- en: Field programmable gate arrays
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现场可编程门阵列
- en: Unlike SoCs, ASICs, and MCUs, **field programmable gate arrays**, or **FPGAs**,
    are semiconductor devices that can be reprogrammed on a hardware level after manufacturing.
    They are based around a matrix of **configurable logic blocks** (**CLBs**), which
    are connected via programmable interconnects. The interconnects can be programmed
    by developers to perform a specific function according to their requirements.
    The FPGA is programmed with a **Hardware Definition Language** (**HDL**). It allows
    the implementation of any combination of digital functions in order to process
    a massive amount of data very quickly and efficiently.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与SoCs、ASICs和MCUs不同，现场可编程门阵列（FPGAs）是半导体器件，可以在制造后在硬件级别上重新编程。它们基于一组可配置逻辑块（CLBs），通过可编程互连连接。开发人员可以根据自己的需求编程互连以执行特定功能。FPGA使用硬件定义语言（HDL）进行编程。它允许实现任何数字功能的组合，以便快速高效地处理大量数据。
- en: Working with limited resources
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用有限资源
- en: It is a common misconception that embedded systems are based on hardware that
    is much slower compared to regular desktop or server hardware. Although this is
    commonly the case, it is not always true.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 人们普遍错误地认为嵌入式系统是基于比常规台式机或服务器硬件慢得多的硬件。尽管这通常是情况，但并非总是如此。
- en: Some particular applications may require lots of computation power of large
    amounts of memory. For example, autonomous driving requires both memory and CPU
    resources to handle the large amount of data that comes from various sensors using
    AI algorithms in real time. Another example is high-end storage systems that utilize
    large amounts of memory and resources for data caching, replication, and encryption.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一些特定的应用可能需要大量的计算能力或大量的内存。例如，自动驾驶需要处理来自各种传感器的大量数据，使用实时AI算法需要内存和CPU资源。另一个例子是利用大量内存和资源进行数据缓存、复制和加密的高端存储系统。
- en: In either case, the embedded system hardware is designed to minimize the cost
    of the overall system. The results for software engineers working with embedded
    systems is that resources are scarce. They are expected to utilize all of the
    available resources and take performance and memory optimizations very seriously.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，嵌入式系统硬件都设计成最小化整个系统的成本。对嵌入式系统的软件工程师来说，资源是稀缺的。他们被期望利用所有可用资源，并严肃对待性能和内存优化。
- en: Looking at performance implications
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑性能影响
- en: Most embedded applications are optimized for performance. As discussed earlier,
    the target CPU is chosen to be cost-efficient and developers extract all the computation
    power that it is capable of. An additional factor is communication with peripheral
    hardware. This often requires precise and fast reaction times. As a result, there
    is only limited room for the scripting, interpretable, bytecode languages such
    as Python or Java. Most of the embedded programs are written in languages that
    compile into the native code, primarily C and C++.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数嵌入式应用都针对性能进行了优化。如前所述，目标CPU被选择为成本效益高，开发人员会提取其所有的计算能力。另一个因素是与外围硬件的通信。这通常需要精确和快速的反应时间。因此，对于像Python或Java这样的脚本、可解释、字节码语言，只有有限的空间。大多数嵌入式程序都是用编译成本机代码的语言编写的，主要是C和C++。
- en: To achieve maximum performance, embedded programs utilize all the performance
    optimization capabilities of compilers. Modern compilers are so good at code optimization
    that they can outperform code in assembly language written by skilled developers.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现最大性能，嵌入式程序利用编译器的所有性能优化能力。现代编译器在代码优化方面非常出色，以至于它们可以胜过由熟练开发人员用汇编语言编写的代码。
- en: However, engineers cannot rely solely on the performance optimizations provided
    by compilers. To achieve maximum efficiency, they have to take into account the
    specifics of the target platform. Coding practices that are commonly used for
    desktop or server applications running on an x86 platform may be inefficient for
    different architectures such as ARM or MIPS. The utilization of specific features
    of the target architecture often gives a significant performance boost to the
    program.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，工程师不能仅仅依赖编译器提供的性能优化。为了实现最大效率，他们必须考虑目标平台的具体情况。通常用于在x86平台上运行的桌面或服务器应用程序的编码实践，对于ARM或MIPS等不同架构可能是低效的。利用目标架构的特定特性通常会显著提高程序的性能。
- en: Working with different architectures
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与不同架构一起工作
- en: Developers of desktop applications usually pay little attention to the hardware
    architecture. First, they often use high-level programming languages that hide
    these complexities at the cost of some performance drop. Second, in most cases,
    their code runs on x86 architecture and they often take its features for granted.
    For example, they may assume that the size of `int` is `32` bits, which is not
    true in many cases.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面应用程序的开发人员通常很少关注硬件架构。首先，他们经常使用高级编程语言，隐藏了这些复杂性，但牺牲了一些性能。其次，在大多数情况下，他们的代码在x86架构上运行，并且他们经常认为其特性是理所当然的。例如，他们可能假设`int`的大小是`32`位，这在许多情况下是不正确的。
- en: Embedded developers deal with a much wider variety of architectures. Even if
    they do not write code in assembly language native to the target platform, they
    should be aware that all C and C++ fundamental types are architecture-dependent;
    the standard only guarantees that `int` is at least `16` bits. They should also
    know the traits of particular architectures, such as **endianness** and **alignment**,
    and take into account that operations with floating point or 64-bit numbers, which
    are relatively cheap on x86 architecture, may be much more expensive on other
    architectures.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式开发人员处理更广泛的架构。即使他们不是用目标平台本地的汇编语言编写代码，他们也应该意识到所有C和C++基本类型都依赖于架构；标准只保证`int`至少是`16`位。他们还应该了解特定架构的特性，如**字节序**和**对齐**，并考虑到浮点数或64位数字的操作，在x86架构上相对便宜，但在其他架构上可能更昂贵。
- en: Endianness
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字节序
- en: '**Endianness** defines the order in which bytes that represent large numerical
    values are stored in memory.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 字节序定义了表示大数值的字节在内存中存储的顺序。
- en: 'There are two types of endianness:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种字节序：
- en: '**Big-endian**: The most significant byte is stored first. The `0x01020304`
    32-bit value is stored at the `ptr` address as follows:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大端**：最重要的字节被首先存储。`0x01020304` 32位值存储在`ptr`地址如下：'
- en: '| **Offset in memory** | **Value** |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| **内存中的偏移** | **值** |'
- en: '| `ptr` | 0x01 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `ptr` | 0x01 |'
- en: '| `ptr + 1` | 0x02 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `ptr + 1` | 0x02 |'
- en: '| `ptr + 2` | 0x03 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `ptr + 2` | 0x03 |'
- en: '| `ptr + 3` | 0x04 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `ptr + 3` | 0x04 |'
- en: Examples of big-endian architectures are AVR32 and Motorola 68000.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 大端架构的例子包括AVR32和Motorola 68000。
- en: '**Little-endian**: The least significant byte is stored first. The `0x01020304`
    32-bit value is stored at the `ptr` address as follows:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小端**：最不重要的字节被首先存储。`0x01020304` 32位值存储在`ptr`地址如下：'
- en: '| **Offset in memory** | **Value** |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| **内存中的偏移** | **值** |'
- en: '| `ptr` | 0x04 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `ptr` | 0x04 |'
- en: '| `ptr + 1` | 0x03 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `ptr + 1` | 0x03 |'
- en: '| `ptr + 2` | 0x02 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `ptr + 2` | 0x02 |'
- en: '| `ptr + 3` | 0x01 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `ptr + 3` | 0x01 |'
- en: The x86 architecture is little-endian.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: x86架构是小端的。
- en: '**Bi-endian**: Hardware supports switchable endianness. Some examples are PowerPC,
    ARMv3, and the preceding examples.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双端**：硬件支持可切换的字节序。一些例子是PowerPC、ARMv3和前面的例子。'
- en: Endianness is particularly essential when exchanging data with other systems.
    If a developer sends the `0x01020304` 32-bit integer as is, it may be read as
    `0x04030201` if the endianness of the receiver does not match the endianness of
    the sender. That is why data should be **serialized**.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 字节序在与其他系统交换数据时特别重要。如果开发人员按原样发送`0x01020304` 32位整数，如果接收者的字节序与发送者的字节序不匹配，它可能被读取为`0x04030201`。这就是为什么数据应该进行**序列化**。
- en: 'This C++ snippet can be used to determine the endianness of a system:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这段C++代码可以用来确定系统的字节序：
- en: '[PRE0]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Alignment
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对齐
- en: Processors don't read and write data in bytes but in **memory words**—chunks
    that match their data address size. 32-bit processors work with 32-bit words,
    64-bit processors with 64-bit words, and so on.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器不是按字节而是按**内存字**来读写数据——与其数据地址大小匹配的块。32位处理器使用32位字，64位处理器使用64位字，依此类推。
- en: Reads and writes are most efficient when words are aligned—the data address
    is a multiple of the word size. For example, for 32-bit architectures, the `0x00000004`
    address is aligned, while `0x00000005` is unaligned.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当字对齐时，读写是最有效的——数据地址是字大小的倍数。例如，对于32位架构，`0x00000004`地址是对齐的，而`0x00000005`是不对齐的。
- en: 'Compilers align data automatically to achieve the most efficient data access.
    When it comes to structures, the result may be surprising for developers who are
    not aware of alignment:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会自动对齐数据以实现最有效的数据访问。当涉及到结构时，对于不了解对齐的开发人员来说，结果可能会令人惊讶：
- en: '[PRE1]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What is the output of the preceding code snippet? The size of `uint8_t` is `1` and
    the size of  `uint32_t` is `4`. A developer may expect that the size of the structure
    is the sum of the individual sizes. However, the result highly depends on the
    target architecture.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段的输出是什么？`uint8_t`的大小是`1`，而`uint32_t`的大小是`4`。开发人员可能期望结构的大小是各个部分大小的总和。然而，结果高度取决于目标架构。
- en: 'For x86, the result is `8`. Let''s add one more `uint8_t` field before `i`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于x86，结果是`8`。让我们在`i`之前再添加一个`uint8_t`字段：
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The result is still `8`! The compiler optimizes the placement of the data fields
    within a structure according to alignment rules by adding padding bytes. The rules
    are architecture-dependent and the result may be different for other architectures.
    As a result, structures cannot be exchanged directly between two different systems
    without serialization*, *which will be explained in more depth in [Chapter 8](24063f32-0b00-46d8-a65d-12e09b599ade.xhtml),
    *Communication and Serialization*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 结果仍然是`8`！编译器通过添加填充字节根据对齐规则优化结构内数据字段的放置。这些规则是与架构相关的，对于其他架构，结果可能会有所不同。因此，结构不能在两个不同系统之间直接交换，而需要进行序列化，这将在[第8章](24063f32-0b00-46d8-a65d-12e09b599ade.xhtml)中更详细地解释，即通信和序列化。
- en: Besides the CPU, access data alignment is also crucial for efficient memory
    mapping through hardware address translation mechanisms. Modern operating systems
    operate 4 KB memory blocks or pages to map a process virtual address space to
    physical memory. Aligning data structures on 4 KB boundaries can lead to performance
    gain.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 除了CPU，访问数据对齐对于通过硬件地址转换机制进行有效的内存映射也是至关重要的。现代操作系统使用4 KB内存块或页面来将进程虚拟地址空间映射到物理内存。将数据结构对齐到4
    KB边界可以提高性能。
- en: Fixed-width integer types
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 固定宽度整数类型
- en: C and C++ developers often forget that the size of fundamental data types, such
    as `char`, `short`, or `int`, is architecture-dependent. To make the code portable,
    embedded developers often use fixed-size integer types that explicitly specify
    the size of a data field.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: C和C++开发人员经常忘记基本数据类型（如`char`、`short`或`int`）的大小是与架构相关的。为了使代码具有可移植性，嵌入式开发人员经常使用明确指定数据字段大小的固定大小整数类型。
- en: 'The most commonly used data types are as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的数据类型如下：
- en: '| **Width** | **Signed** | **Unsigned** |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **宽度** | **有符号** | **无符号** |'
- en: '| 8-bit | `int8_t` | `uint8_t` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 8位 | `int8_t` | `uint8_t` |'
- en: '| 16-bit | `int16_t` | `uint16_t` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 16位 | `int16_t` | `uint16_t` |'
- en: '| 32-bit | `int32_t` | `uint32_t` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 32位 | `int32_t` | `uint32_t` |'
- en: The pointer size also depends on the architecture. Developers often need to
    address elements of arrays and since arrays are internally represented as pointers,
    the offset representation depends on the pointer size. `size_t` is a special data
    type to represent the offset and data sizes in an architecture-independent way.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 指针大小也取决于架构。开发人员经常需要访问数组的元素，由于数组在内部表示为指针，偏移量表示取决于指针大小。`size_t`是一种特殊的数据类型，以一种与架构无关的方式表示偏移量和数据大小。
- en: Working with hardware errors
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理硬件错误
- en: A significant part of an embedded developer's work is dealing with hardware.
    Unlike most application developers, embedded developers cannot rely on hardware.
    Hardware fails for different reasons and embedded developers have to distinguish
    purely software failures from software failures caused by hardware failures or
    glitches.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式开发人员工作的重要部分是处理硬件。与大多数应用程序开发人员不同，嵌入式开发人员不能依赖硬件。硬件因不同原因而失败，嵌入式开发人员必须区分纯粹的软件故障和由硬件故障或故障引起的软件故障。
- en: Early versions of hardware
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 早期版本的硬件
- en: Embedded systems are based on specialized hardware designed and manufactured
    for a particular use case. This implies that at the time that the software for
    the embedded system is being developed, its hardware is not yet stable and well
    tested. When software developers encounter an error in their code behavior, it
    does not necessarily mean there is a software bug but it might be a result of
    incorrectly working hardware.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统基于专门设计和制造用于特定用例的专用硬件。这意味着在为嵌入式系统开发软件时，其硬件尚未稳定且经过充分测试。当软件开发人员在其代码行为中遇到错误时，这并不一定意味着存在软件错误，而可能是由于不正确工作的硬件引起的。
- en: It is hard to triage these kinds of problems. They require knowledge, intuition,
    and sometimes the use of an oscilloscope to narrow the root cause of an issue
    down to hardware.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 很难对这些问题进行分类。它们需要知识、直觉，有时需要使用示波器来将问题的根本原因缩小到硬件层面。
- en: Hardware is unreliable
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件是不可靠的
- en: Hardware is inherently unreliable. Each hardware component has a probability
    of failure and developers should be aware that hardware can fail at any time.
    Data stored in memory can be corrupted because of memory failure. Messages being
    transmitted over a communication channel can be altered because of external noise.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件本质上是不可靠的。每个硬件组件都有失败的可能性，开发人员应该意识到硬件随时可能出现故障。由于内存故障，存储在内存中的数据可能会损坏。由于外部噪音，通过通信渠道传输的消息可能会被更改。
- en: Embedded developers are prepared for these situations. They use checksums or
    **cyclic redundancy check** (**CRC**) code to detect and, if possible, correct
    corrupted data.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式开发人员已经为这些情况做好了准备。他们使用校验和或**循环冗余检查**（**CRC**）码来检测并在可能的情况下纠正损坏的数据。
- en: The influence of environmental conditions
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境条件的影响
- en: High temperature, low temperature, high humidity, vibration, dust, and other
    environmental factors can significantly affect the performance and reliability
    of hardware. While developers design their software to handle all potential hardware
    errors, it is common practice to test the system in different environments. Besides
    that, knowledge of environmental conditions can give an important clue when working
    on the root-cause analysis of an issue.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 高温、低温、高湿度、振动、灰尘和其他环境因素都会显著影响硬件的性能和可靠性。虽然开发人员设计他们的软件来处理所有潜在的硬件错误，但在不同的环境中测试系统是常见的做法。此外，了解环境条件可以在解决问题的根本原因分析时提供重要线索。
- en: Using C++ for embedded development
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在嵌入式开发中使用C++
- en: For many years, the vast majority of an embedded project was developed using
    the C programming language. This language perfectly fits the needs of embedded
    software developers. It provides feature-rich and convenient syntax but at the
    same time, it is relatively low-level and does not hide platform specifics from
    developers.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，绝大多数嵌入式项目都是使用C编程语言开发的。这种语言非常适合嵌入式软件开发人员的需求。它提供了功能丰富和方便的语法，但与此同时，它相对低级，并且不会向开发人员隐藏平台特定的细节。
- en: Due to its versatility, compactness, and the high performance of the compiled
    code, it became a de facto standard development language in the embedded world.
    Compilers for the C language exist for most, if not all, architectures; they are
    optimized to generate machine code that is more efficient than those that are
    written manually.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其多功能性、紧凑性和编译代码的高性能，它成为了嵌入式世界中的事实标准开发语言。C语言的编译器存在于大多数，如果不是所有的架构中；它们被优化为生成比手动编写的机器代码更有效的代码。
- en: Over time, the complexity of embedded systems increased and developers faced
    the limitations of C, the most notable being error-prone resource management and
    a lack of high-level abstractions. The development of complex applications in
    C requires a lot of effort and time.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 随着嵌入式系统的复杂性不断增加，开发人员面临C语言的限制，其中最显著的是容易出错的资源管理和缺乏高级抽象。在C中开发复杂的应用程序需要大量的工作和时间。
- en: 'At the same time, C++ was evolving, gaining new features and adopting programming
    techniques that make it the best choice for developers of modern embedded systems.
    These new features and techniques are as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，C++在不断发展，获得新的功能，并采用使其成为现代嵌入式系统开发人员的最佳选择的编程技术。这些新功能和技术如下：
- en: You don't pay for what you don't use.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不用为你不使用的东西付费。
- en: Object-oriented programming to time the code complexity.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程来处理代码复杂性。
- en: '**Resource acquisition is initialization** (**RAII**).'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源获取即初始化**（**RAII**）。'
- en: Exceptions.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常。
- en: A powerful standard library.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强大的标准库。
- en: Threads and memory model as part of the language specification.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程和内存模型作为语言规范的一部分。
- en: You don't pay for what you don't use
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你不用为你不使用的东西付费
- en: One of the mottos of C++ is *You don't pay for what you don't use*. This language
    is packed with many more features than C, yet it promises zero overhead for those
    that are not used.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: C++的座右铭之一是*你不用为你不使用的东西付费*。这种语言比C语言还要多很多功能，但对于那些不被使用的功能，它承诺零开销。
- en: 'Take, for example, virtual functions:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，虚函数：
- en: '[PRE3]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code will output `A`, despite `obj` pointing to the object of
    the `B` class. To make it work as expected, the developer adds a keyword—`virtual`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`obj`指向`B`类的对象，上面的代码将输出`A`。为了使其按预期工作，开发人员添加了一个关键字——`virtual`：
- en: '[PRE4]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After this change, the code outputs `B`, which is what most developers expect
    to get as a result. You may ask why C++ does not enforce every method to be `virtual`
    by default. This approach is adopted by Java and doesn't seem to have any downsides.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个改变之后，代码输出`B`，这是大多数开发人员期望得到的结果。你可能会问为什么C++不默认强制每个方法都是`virtual`。这种方法是Java采用的，似乎没有任何不利之处。
- en: The reason is that `virtual` functions are not free. Function resolution is
    performed at runtime via the virtual table—an array of function pointers. It adds
    a slight overhead to the function invocation time. If you do not need dynamic
    polymorphism, you do not pay for it. That is why C++ developers add the `virtual`
    keyboard, to explicitly agree with functionality that adds performance overhead.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是`virtual`函数并不是免费的。函数解析是通过虚拟表在运行时执行的——这是一个函数指针数组。它会给函数调用时间增加一点开销。如果你不需要动态多态性，你就不用为它付费。这就是为什么C++开发人员添加`virtual`关键字，以明确同意会增加性能开销的功能。
- en: Object-oriented programming to time the code complexity
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程来处理代码复杂性
- en: As the complexity of embedded programs grows over time, it becomes more and
    more difficult to manage them using the traditional procedural approach provided
    by the C language. If you take a look at a large C project, such as the Linux
    kernel, you will see that it adopts many aspects of object-oriented programming.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 随着嵌入式程序的复杂性随着时间的推移而增长，使用C语言提供的传统过程化方法来管理它们变得越来越困难。如果你看一下一个大型的C项目，比如Linux内核，你会发现它采用了许多面向对象编程的方面。
- en: The Linux kernel extensively uses encapsulation, hiding implementation details
    and providing object interfaces using C structures.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核广泛使用封装，隐藏实现细节，并使用C结构提供对象接口。
- en: Though it is possible to write object-oriented code in C, it is much easier
    and convenient to do it in C++, where a compiler does all the heavy lifting for
    the developers.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在C中编写面向对象的代码是可能的，但在C++中进行这样的操作要容易得多，也更方便，因为编译器为开发人员做了所有繁重的工作。
- en: Resource acquisition is initialization
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源获取即初始化
- en: 'Embedded developers work a lot with the resources provided by the operating
    system: memory, files, and network sockets. C developers use pairs of API functions
    to acquire and free resources; for example, `malloc` to claim a block of memory
    and `free` to return it to the system. If for some reason the developer forgets
    to invoke `free`, this block of memory leaks. Memory leaking, or resource leaking,
    is generally a common problem in applications written in C:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式开发人员经常使用操作系统提供的资源：内存、文件和网络套接字。C开发人员使用API函数对资源进行获取和释放；例如，使用`malloc`来申请一块内存，使用`free`将其返回给系统。如果开发人员因某种原因忘记调用`free`，这块内存就会泄漏。内存泄漏或资源泄漏通常是C编写的应用程序中的常见问题：
- en: '[PRE5]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This preceding code looks correct, but it contains several serious issues. If
    the `write` function returns an error or writes less data than requested (and
    this is correct behavior), the `AppendString` function logs an error and returns.
    However, if it forgets to close the file descriptor, it leaks. Over time, more
    and more file descriptors leak and at some point, the program reaches the limit
    of open file descriptors, making *all* calls to the `open` function fail.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码看起来是正确的，但它包含了几个严重的问题。如果`write`函数返回错误或写入的数据少于请求的数据（这是正确的行为），`AppendString`函数会记录错误并返回。然而，如果它忘记关闭文件描述符，就会发生内存泄漏。随着时间的推移，越来越多的文件描述符泄漏，最终程序达到打开文件描述符的限制，导致*所有*对`open`函数的调用失败。
- en: 'C++ provides a powerful programming idiom that prevents resource leakage: **RAII**.
    A resource is allocated in an object constructor and deallocated in the object
    destructor. This means that the resource is only held while the object is alive.
    It is automatically freed when the object is destroyed:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: C++提供了一个强大的编程习惯，可以防止资源泄漏：**RAII**。资源在对象构造函数中分配，在对象析构函数中释放。这意味着只有在对象存活时才持有资源。当对象被销毁时，资源会自动释放：
- en: '[PRE6]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that this function does not call `close` explicitly. The file is closed
    in the destructor of the output object, which is automatically invoked when the `AppendString`
    function returns.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此函数不会显式调用`close`。文件在输出对象的析构函数中关闭，当`AppendString`函数返回时会自动调用该析构函数。
- en: Exceptions
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常
- en: 'Traditionally, C developers handled errors using error codes. This approach
    requires lots of attention from the coders and is a constant source of hard-to-find
    bugs in C programs. It is too easy to omit or overlook missing check-for-a-return
    code, masking the error:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，C开发人员使用错误代码来处理错误。这种方法需要程序员的大量注意力，并且是C程序中难以找到的错误的不断来源。很容易忽略或忽视缺少检查返回代码的情况，掩盖了错误：
- en: '[PRE7]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code has at least two issues related to error handling. First,
    the result of the `lseek` function call is not checked. If `lseek` returns an
    error, the function will work incorrectly. The second issue is more subtle, yet
    more important and harder to fix. The `read_last_byte` function returns `-1` to
    indicate an error, but it is also a valid value of a byte. It is not possible
    to distinguish whether the last byte of a file is `0xFF` or whether the function
    encountered an error. To correctly handle this case, the function interface should
    be redefined as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码至少有两个与错误处理相关的问题。首先，未检查`lseek`函数调用的结果。如果`lseek`返回错误，函数将无法正确工作。第二个问题更微妙，但更重要且更难修复。`read_last_byte`函数返回`-1`表示错误，但它也是一个字节的有效值。无法区分文件的最后一个字节是`0xFF`还是函数遇到了错误。为了正确处理这种情况，函数接口应重新定义如下：
- en: '[PRE8]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The function returns `-1` in the case of an error and `0` otherwise. The result
    is stored in a `char` variable passed by reference. Although this interface is
    correct, it is not as convenient for developers as the original one.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在发生错误的情况下，函数返回`-1`，否则返回`0`。结果存储在通过引用传递的`char`变量中。虽然这个接口是正确的，但对开发人员来说并不像原来的接口那样方便。
- en: A program that eventually crashes randomly may be considered the best outcome
    for these kinds of errors. It would be worse if it keeps working, silently corrupting
    data or generating incorrect results.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一个最终会随机崩溃的程序可能被认为是这类错误的最佳结果。如果它继续工作，悄悄地损坏数据或生成不正确的结果将更糟。
- en: Besides that, the code that implements the logic and the code responsible for
    error checks are intertwined. The code becomes hard to read and hard to understand
    and, as a result, even more error-prone.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，实现逻辑的代码和负责错误检查的代码交织在一起。代码变得难以阅读和理解，结果更容易出错。
- en: Although developers can still keep using return codes, the recommended way of
    error handling in modern C++ is exceptions. Correctly designed and correctly used
    exceptions significantly reduce the complexity of error handling, making code
    readable and robust.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管开发人员仍然可以继续使用返回代码，但现代C++中错误处理的推荐方式是异常。正确设计和正确使用异常显著减少了错误处理的复杂性，使代码更易读和更健壮。
- en: 'The same function written in C++ using exceptions looks much cleaner:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异常编写的相同函数在C++中看起来更加清晰：
- en: '[PRE9]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The powerful standard library
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强大的标准库
- en: C++ comes with a feature-rich and powerful standard library. Many functions
    that required C developers to use third-party libraries are now part of the standard
    C++ library. This means less external dependencies, more stable and predictable
    behavior, and improved portability between hardware architectures.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: C++带有功能丰富且强大的标准库。许多以前需要C开发人员使用第三方库的函数现在已经成为标准C++库的一部分。这意味着更少的外部依赖，更稳定和可预测的行为，以及在硬件架构之间的更好可移植性。
- en: The C++ standard library comes with containers built on top of the most commonly
    used data structures, such as arrays, binary trees, and hash tables. These containers
    are generic and efficiently cover most of the developer's everyday needs. Developers
    do not need to spend time and effort creating their own, often error-prone, implementations
    of the essential data structures.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库提供了建立在最常用的数据结构（如数组、二叉树和哈希表）之上的容器。这些容器是通用的，有效地满足了开发人员日常需求的大部分。开发人员不需要花费时间和精力创建自己的基本数据结构的实现，这通常容易出错。
- en: The containers are carefully designed in a way that minimizes the need for explicit
    resources, allocation, or deallocation, leading to significantly lower chances
    of memory or other system resources leaking.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 容器被精心设计，以最小化对显式资源、分配或释放的需求，从而大大降低了内存或其他系统资源泄漏的可能性。
- en: The standard library also provides many standard algorithms, such as `find`,
    `sort`, `replace`, binary search, operations with sets, and permutations. The
    algorithms can be applied to any containers that expose integrator interfaces.
    Combined with standard containers, they help developers focus on high-level abstractions
    and build them on top of well-tested functionality with a minimal amount of additional
    code.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库还提供许多标准算法，如`find`、`sort`、`replace`、二进制搜索、集合操作和排列。这些算法可以应用于任何公开的集成器接口的容器。结合标准容器，它们帮助开发人员专注于高级抽象，并在经过充分测试的功能之上构建它们，而只需最少量的额外代码。
- en: Threads and a memory model as part of the language specification
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程和内存模型作为语言规范的一部分
- en: The C++11 standard introduced a memory model that clearly defines the behavior
    of a C++ program in a multithreaded environment.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: C++11标准引入了一个内存模型，清楚地定义了C++程序在多线程环境中的行为。
- en: For the C language specifications, the memory model was out of scope. The language
    itself was not aware of threads or parallel execution semantics. It was up to
    the third-party libraries, such as pthreads, to provide all the necessary support
    for multithread applications.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于C语言规范，内存模型不在范围内。语言本身不知道线程或并行执行语义。这取决于第三方库，例如pthread，提供多线程应用程序所需的所有支持。
- en: Earlier versions of C++ followed the same principle. Multithreading was out
    of the scope of the language specification. However, modern CPUs with multiple
    pipelines supporting instruction reordering demanded more deterministic behavior
    of compilers.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 早期版本的C++遵循了相同的原则。多线程不在语言规范的范围内。然而，支持指令重排序的多管线现代CPU需要编译器更确定的行为。
- en: As a result, modern specifications of C++ explicitly define classes for threads,
    various types of locks and mutexes, condition variables, and atomic variables.
    This gives embedded developers a powerful tool kit to design and implement applications
    capable of utilizing all the power of modern multicore CPUs. Since the tool kit
    is part of the language specification, these applications have deterministic behavior
    and are portable to all supported architectures.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，C++的现代规范明确定义了线程类、各种类型的锁和互斥锁、条件变量和原子变量。这为嵌入式开发人员提供了一个强大的工具包，用于设计和实现能够利用现代多核CPU所有功能的应用程序。由于工具包是语言规范的一部分，这些应用程序具有确定的行为，并且可移植到所有支持的架构。
- en: Deploying software remotely
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程部署软件
- en: 'The deployment of software for embedded systems is often a complex procedure
    that should be carefully designed, implemented, and tested. There are two major
    challenges:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统的软件部署通常是一个复杂的过程，应该经过精心设计、实施和测试。有两个主要挑战：
- en: Embedded systems are often deployed in places that are difficult or impractical
    for a human operator to access.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入式系统通常部署在人类操作员难以或不切实际访问的地方。
- en: If software deployment fails, the system can become inoperable. It will require
    the intervention of a skilled technician and additional tools for recovery. This
    is expensive and often impossible.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果软件部署失败，系统可能无法运行。这将需要技术熟练的技术人员和额外的工具来进行恢复。这是昂贵的，而且通常是不可能的。
- en: A solution for the first challenge of embedded systems that are connected to
    the internet was found in the form of **Over-the-Air** (**OTA**) updates. A system
    periodically connects to the dedicated server and checks for available updates.
    If the updated version of the software is found, it is downloaded to the device
    and installed to the persistent memory.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到互联网的嵌入式系统的第一个挑战的解决方案是**OTA**（Over-the-Air）更新。系统定期连接到专用服务器，检查是否有可用的更新。如果找到软件的更新版本，它将被下载到设备并安装到持久内存中。
- en: This approach is widely adopted by manufacturers of smartphones, **Set-Top-Box**
    (**STB**) appliances, smart TVs, and game consoles connected to the internet.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法被智能手机、机顶盒、智能电视和连接到互联网的游戏机制造商广泛采用。
- en: When designing OTA updates, system architects should take into account many
    factors that affect the scalability and reliability of the overall solution. For
    example, if all devices check for updates at approximately the same time, it creates
    high peak loads in the update servers, while leaving them idle all other time.
    Randomizing the check time keeps the load distributed evenly. The target system
    should be designed to reserve enough persistent memory to download the complete
    update image before applying it. The code implementing the updated software image
    download should handle network connection drops and resume download once the connection
    is recovered, rather than start over. Another important factor of OTA update is
    security. The updated process should only accept genuine update images. Updates
    are cryptographically signed by the manufacturer and an image is not accepted
    by the installer running on the device unless the signature matches.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计OTA更新时，系统架构师应考虑影响整体解决方案的许多因素。例如，如果所有设备几乎同时检查更新，会在更新服务器上创建高峰负载，同时让它们在其他时间处于空闲状态。随机化检查时间可以使负载均匀分布。目标系统应设计为保留足够的持久内存以下载完整的更新映像，然后应用它。实现更新软件映像下载的代码应处理网络连接中断，并在连接恢复后恢复下载，而不是重新开始。OTA更新的另一个重要因素是安全性。更新过程应仅接受真实的更新映像。更新由制造商进行加密签名，只有在设备上运行的安装程序接受签名匹配的映像。
- en: Developers of embedded systems are aware that the update may fail for different
    reasons; for example, a power outage during the update. Even if the update completes
    successfully, the new version of the software may be unstable and crash on startup.
    It is expected that even in such situations the system will be able to recover.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统的开发人员知道更新可能因不同原因而失败；例如，在更新过程中断电。即使更新成功完成，新版本的软件可能不稳定，并在启动时崩溃。预期即使在这种情况下，系统也能够恢复。
- en: This is achieved by separating the main software components and the bootloader.
    The bootloader validates the consistency of the main components, such as the operating
    system kernel and root filesystem that contains all the executables, data, and
    scripts. Then, it tries to run the operating system. In the case of failure, it
    switches to the previous version, which should be kept in the persistent memory
    along with the new one. Hardware watchdog timers are used to detect and prevent
    situations where a software update causes the system to hang.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过分离主要软件组件和引导加载程序来实现的。引导加载程序验证主要组件的一致性，例如包含所有可执行文件、数据和脚本的操作系统内核和根文件系统。然后，它尝试运行操作系统。在失败的情况下，它切换到先前的版本，该版本应与新版本一起保存在持久内存中。硬件看门狗定时器用于检测和防止软件更新导致系统挂起的情况。
- en: It is impractical to use OTA or complete image re-flashing during software development
    and testing. It significantly slows down the development process. Engineers use
    other ways to deploy their software builds to the development systems, such as
    a remote shell or network filesystems that allow file sharing between developers'
    workstations and target boards.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发和测试过程中使用OTA或完整的镜像重新刷写是不切实际的。它会显著减慢开发过程。工程师使用其他方式将他们的软件构建部署到开发系统，例如远程外壳或允许开发人员工作站和目标板之间共享文件的网络文件系统。
- en: Running software remotely
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程运行软件
- en: Embedded systems are designed to solve a particular problem using a specific
    combination of hardware and software components. That is why all software components
    in a system are tailored to fulfill this goal. Everything non-essential is disabled
    and all custom software is integrated into the boot sequence.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统旨在使用特定的硬件和软件组件组合解决特定问题。这就是为什么系统中的所有软件组件都经过定制以实现这个目标。所有非必要的东西都被禁用，所有定制软件都集成到引导序列中。
- en: Users do not launch embedded programs; they start on system boot. However, during
    the development process, engineers need to run their applications without rebooting
    the system.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 用户不启动嵌入式程序；它们在系统启动时启动。然而，在开发过程中，工程师需要在不重新启动系统的情况下运行他们的应用程序。
- en: This is done differently depending on the type of the target platform. For powerful-enough
    systems based on SoC and running a preemptive multitasking operating system such
    as Linux, it can be done using a remote shell.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于目标平台的类型而有所不同。对于基于SoC并运行像Linux这样的抢占式多任务操作系统的足够强大的系统，可以使用远程shell来实现。
- en: Modern systems usually use a **secure shell** (**SSH**) as a remote shell. The
    target system runs an SSH daemon waiting for incoming connections. Developers
    connect using a client SSH program, such as SSH in Linux or PuTTY in Windows,
    to get access to the target system. Once connected, they can work with the Linux
    shell on the embedded board in the same way as on a local computer.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现代系统通常使用**安全外壳**（**SSH**）作为远程外壳。目标系统运行一个等待传入连接的SSH守护程序。开发人员使用客户端SSH程序，如Linux中的SSH或Windows中的PuTTY，连接到目标系统以访问目标系统。一旦连接，他们可以像在本地计算机上一样使用嵌入式板上的Linux
    shell进行工作。
- en: 'The common workflow for running the program remotely is as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 远程运行程序的常见工作流程如下：
- en: Build a program executable in your local system using a cross-compilation toolkit.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用交叉编译工具包在本地系统中构建可执行程序。
- en: Copy it to the remote system using the `scp` tool.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`scp`工具将其复制到远程系统。
- en: Connect to the remote system using SSH and run the executable from the command
    line.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用SSH连接到远程系统，并从命令行运行可执行文件。
- en: Using the same SSH connection, analyze the program output.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的SSH连接，分析程序输出。
- en: When the program terminates or gets interrupted by the developer, fetch its
    logs back to the developer's workstation for in-depth analysis.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当程序终止或被开发人员中断时，将其日志取回开发人员的工作站进行深入分析。
- en: MCUs do not have enough resources for a remote shell. Developers usually upload
    the compiled code directly into the platform memory and initiate the code execution
    from the particular memory address.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: MCU没有足够的资源来运行远程shell。开发人员通常直接将编译后的代码上传到平台内存，并从特定的内存地址启动代码执行。
- en: Logging and diagnostics
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录和诊断
- en: Logging and diagnostics are an important aspect of any embedded project.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录和诊断是任何嵌入式项目的重要方面。
- en: In many cases, using an interactive debugger is not possible or practical. Hardware
    state can change in a few milliseconds. After a program stops on a breakpoint,
    a developer does not have enough time to analyze it. Collecting detailed log data
    and using tools for their analysis and visualization is a better approach for
    high-performance, multithreaded, time-sensitive embedded systems.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，使用交互式调试器是不可能或不切实际的。硬件状态可能在几毫秒内发生变化。程序在断点上停止后，开发人员没有足够的时间来分析它。收集详细的日志数据并使用工具进行分析和可视化是高性能、多线程、时间敏感的嵌入式系统的更好方法。
- en: Since in most cases resources are limited, developers often have to make tradeoffs.
    On the one hand, they need to collect as much data as possible to identify the
    root cause of failure—whether it is the software or hardware, the status of the
    hardware components at the time of the failure, and the accurate timing of the
    hardware and software events handled by the system. On the other hand, the space
    available for the log is limited, and each time writing the log affects the overall
    performance.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在大多数情况下资源是有限的，开发人员经常不得不做出权衡。一方面，他们需要收集尽可能多的数据来确定故障的根本原因——无论是软件还是硬件，故障发生时硬件组件的状态，以及系统处理的硬件和软件事件的准确时间。另一方面，日志可用空间有限，每次写日志都会影响整体性能。
- en: The solution is buffering log data locally on a device and sending it to a remote
    system for detailed analysis.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是在设备上本地缓冲日志数据，并将其发送到远程系统进行详细分析。
- en: This approach works fine for the development of embedded software. However,
    the diagnostics of the deployed systems require more sophisticated techniques.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法对于嵌入式软件的开发效果很好。然而，部署系统的诊断需要更复杂的技术。
- en: Many embedded systems work offline and do not provide convenient access to internal
    logs. Developers need to design and implement other ways of diagnostics and reporting
    carefully. If a system does not have a display, LED indicators or beeps are often
    used to encode various error conditions. They are sufficient for giving information
    about the failure category but in most cases cannot provide the necessary details
    to nail it down to the root cause.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 许多嵌入式系统脱机工作，不提供方便的内部日志访问。开发人员需要仔细设计和实施其他诊断和报告方式。如果系统没有显示器，LED指示灯或蜂鸣器通常用于编码各种错误条件。它们足以提供有关故障类别的信息，但在大多数情况下无法提供必要的细节以确定根本原因。
- en: Embedded devices have dedicated diagnostics modes that are used to test the
    hardware components. After powering up, virtually any device or appliance performs
    a **Power-On Self-Test** (**POST**), which runs quick tests of the hardware. These
    tests are supposed to be fast and do not cover all testing scenarios. That is
    why many devices have hidden **service modes** that can be activated by developers
    or field engineers to perform more thorough tests.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式设备具有专用的诊断模式，用于测试硬件组件。在上电后，几乎任何设备或电器都会执行**上电自检**（**POST**），对硬件进行快速测试。这些测试应该快速进行，不涵盖所有测试场景。这就是为什么许多设备都有隐藏的**服务模式**，可以由开发人员或现场工程师激活，以执行更彻底的测试。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed a high-level overview of embedded software, what
    makes it different, and also learned why and how C++ can be used efficiently in
    this area.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了嵌入式软件的高级概述，以及它的不同之处，还了解了为什么以及如何在这个领域高效地使用C++。
