- en: Programming POSIX Sockets Using C++
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C++编程POSIX套接字
- en: In this chapter, you will learn how to program POSIX sockets using C++17, including
    more common C++ paradigms, such as **Resource Aquisition Is Initialization** (**RAII**).
    To begin with, this chapter will discuss what a socket is, and the difference
    between UDP and TCP. The POSIX APIs will be explained in detail prior to walking
    you through five different examples. The first example will step you through programming
    with POSIX sockets by creating a UDP echo server example. The second example will
    create this same example using TCP instead of UDP and explain the differences.
    The third example will expand upon our existing debug logger that has been created
    in previous chapters, while the fourth and fifth examples will explain how to
    safely process a packet.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用C++17编程POSIX套接字，包括更常见的C++范例，如**资源获取即初始化**（**RAII**）。首先，本章将讨论套接字是什么，以及UDP和TCP之间的区别。在向您介绍五个不同的示例之前，将详细解释POSIX
    API。第一个示例将引导您通过使用POSIX套接字创建UDP回显服务器示例。第二个示例将使用TCP而不是UDP创建相同的示例，并解释其中的区别。第三个示例将扩展我们在以前章节中创建的现有调试记录器，而第四和第五个示例将解释如何安全地处理数据包。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: POSIX sockets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX套接字
- en: Leveraging C++ and RAII with sockets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用C++和RAII进行套接字编程
- en: TCP vs UDP
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP vs UDP
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to compile and execute the examples in this chapter, the reader must
    have the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编译和执行本章中的示例，读者必须具备以下条件：
- en: A Linux-based system capable of compiling and executing C++17 (for example,
    Ubuntu 17.10+)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够编译和执行C++17的基于Linux的系统（例如，Ubuntu 17.10+）
- en: GCC 7+
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCC 7+
- en: CMake 3.6+
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake 3.6+
- en: An internet connection
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网连接
- en: To download all of the code in this chapter, including the examples, and code
    snippets, please see the following link: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter10).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载本章中的所有代码，包括示例和代码片段，请参见以下链接：[https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter10)。
- en: Beginning with POSIX sockets
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从POSIX套接字开始
- en: Unfortunately, C++ does not contain a native networking library (something that
    will hopefully be addressed with C++20). For this reason, POSIX sockets are needed
    to perform networking with C++.  The POSIX sockets API defines an API for sending
    and receiving network packets using the standard, Unix file-descriptor paradigm.
    When programming with sockets, both a server and a client must be created. Servers
    are responsible for binding a specific port to the socket protocol that is being
    developed by the user of the sockets library. Clients are any other application
    that is connected to a previously-bound port. Both servers and clients have their
    own IP addresses.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，C++不包含本地网络库（希望C++20能够解决这个问题）。因此，需要使用POSIX套接字来执行C++网络编程。POSIX套接字API定义了使用标准Unix文件描述符范式发送和接收网络数据包的API。在使用套接字进行编程时，必须创建服务器和客户端。服务器负责将特定端口绑定到套接字协议，该协议由套接字库的用户开发。客户端是连接到先前绑定端口的任何其他应用程序。服务器和客户端都有自己的IP地址。
- en: When programming sockets, besides picking address types, such as IPv4 versus
    IPv6, typically the programmer must also choose between UDP versus TCP. UDP is
    a connectionless protocol that provides no assurances that a packet is reliably
    sent, with the advantage being speed and simplicity. UDP is commonly used for
    data that does not have to be received 100% of the time, such as your position
    in a video game. TCP, on the other hand, is a connection-based protocol that ensures
    all packets are received in the order they are sent and is the typical protocol
    used for its reliability.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程套接字时，除了选择地址类型（例如IPv4与IPv6），通常程序员还必须在UDP与TCP之间进行选择。UDP是一种无连接协议，不保证可靠发送数据包，其优势在于速度和简单性。UDP通常用于不需要100%接收的数据，例如在视频游戏中的位置。另一方面，TCP是一种基于连接的协议，确保所有数据包按发送顺序接收，并且是其可靠性的典型协议。
- en: Beginning with APIs
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从API开始
- en: The following sections will explain, in detail, the different socket APIs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将详细解释不同的套接字API。
- en: The socket() API
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: socket() API
- en: 'All POSIX socket programming starts with the creation of a socket file descriptor
    using the `socket()` API, which takes the following form:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所有POSIX套接字编程都始于使用`socket()` API创建套接字文件描述符，其形式如下：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The domain defines the address type used when creating the socket. In most cases,
    this would be `AF_INET` for IPv4 or `AF_INET6` for IPv6\. In the case of our examples
    in this chapter, we will use `AF_INET.` The type field usually takes on `SOCK_STREAM`
    for a TCP connection or `SOCK_DGRAM` for a UDP connection, both of which will
    be demonstrated in this chapter. Finally, the protocol field in this API will
    be set to `0` in all of our examples, telling the API to use the default protocol
    for whichever socket type is specified.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 域定义了创建套接字时使用的地址类型。在大多数情况下，这将是IPv4的`AF_INET`或IPv6的`AF_INET6`。在本章的示例中，我们将使用`AF_INET`。类型字段通常采用`SOCK_STREAM`用于TCP连接或`SOCK_DGRAM`用于UDP连接，这两者都将在本章中进行演示。最后，此API中的协议字段将在所有示例中设置为`0`，告诉API使用指定套接字类型的默认协议。
- en: 'Upon completion of this API, a socket file descriptor is returned, which will
    be needed by the remaining POSIX APIs. If this API fails, `-1` is returned, and
    `errno` is set to an appropriate error code. It should be noted that `errno` is
    not thread-safe and its use should be handled with care. A great way to handle
    these types of errors is to immediately convert the `errno` into a C++ exception,
    which can be done using the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此API后，将返回套接字文件描述符，这将是剩余POSIX API所需的。如果此API失败，则返回`-1`，并将`errno`设置为适当的错误代码。应注意`errno`不是线程安全的，其使用应谨慎处理。处理这些类型的错误的一个很好的方法是立即将`errno`转换为C++异常，可以使用以下方法完成：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding example, an IPv4 TCP socket is created. The resulting file
    descriptor is saved into a memory variable, `m_fd`. Using C++17 syntax, the file
    descriptor is checked for validity, and if an error is reported (that is, `-1`),
    an exception is thrown. To provide a human-readable version of the error, `errno` is
    converted into a string using `strerror()`. Not only does this provide a string
    version of `errno`, it also ensures that the process of recording the error doesn't
    change `errno` in the process, which can happen if a more complicated approach
    is used.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，创建了一个IPv4 TCP套接字。生成的文件描述符保存在内存变量`m_fd`中。使用C++17语法，检查文件描述符的有效性，如果报告错误（即`-1`），则抛出异常。为了提供错误的人类可读版本，`errno`被转换为字符串使用`strerror()`。这不仅提供了`errno`的字符串版本，还确保记录错误的过程不会在过程中更改`errno`，如果使用更复杂的方法可能会发生这种情况。
- en: Finally, when the socket is no longer needed, it should be closed like any other
    file descriptor using the POSIX `close()` function. It should be noted that most
    POSIX operating systems will automatically close sockets that are still open when
    the application closes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当套接字不再需要时，应像使用POSIX`close()`函数关闭任何其他文件描述符一样关闭。应该注意，大多数POSIX操作系统在应用程序关闭时仍然打开的套接字将自动关闭。
- en: 'To prevent possible descriptor leaks, the socket file descriptor may be encapsulated
    in a class, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止可能的描述符泄漏，套接字文件描述符可以封装在一个类中，如下所示：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding example, we open an IPv4 TCP socket using the logic in the
    prior example, ensuring any errors are detected and properly reported. The difference
    is that we store the file descriptor as a member variable, and when `mytcpsocket{}`
    loses scope, we automatically ensure the file descriptor is properly released
    back to the operating system. Any time the file descriptor is needed, the `descriptor()`
    accessor may be used.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用先前示例中的逻辑打开了一个IPv4 TCP套接字，确保检测到任何错误并正确报告。不同之处在于我们将文件描述符存储为成员变量，并且当`mytcpsocket{}`失去作用域时，我们会自动确保文件描述符被正确释放回操作系统。每当需要文件描述符时，可以使用`descriptor()`访问器。
- en: The bind() and connect() APIs
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: bind()和connect() API
- en: Once a socket file descriptor is created, the socket must be bound, or connected,
    depending on whether the socket is creating the connection (the server), or is
    connecting to an existing bound socket (client). When communicating via TCP or
    UDP, binding a socket dedicates a port for the socket. Ports `0`-`1024` are reserved
    for specific services and are often managed by the operating system (requiring
    special privileges to bind). The remaining ports are user-defined and often may
    be bound without privileges. Determining which port to use is dependent on the
    implementation. Some ports are predetermined for a specific application, or the
    application can ask the operating system for an open port to use, which has the
    added complication of communicating this newly-allocated port to potential client
    applications.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 创建套接字文件描述符后，套接字必须绑定或连接，具体取决于套接字是创建连接（服务器）还是连接到现有绑定套接字（客户端）。通过TCP或UDP进行通信时，绑定套接字会为套接字分配一个端口。端口`0`-`1024`保留用于特定服务，并且通常由操作系统管理（需要特殊权限进行绑定）。其余端口是用户定义的，并且通常可以在没有特权的情况下绑定。确定要使用的端口取决于实现。某些端口预先为特定应用程序确定，或者应用程序可以向操作系统请求一个可用的端口，还可以将这个新分配的端口通知给潜在的客户端应用程序，这增加了通信的复杂性。
- en: 'The `bind()` API takes the following form:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind()` API采用以下形式：'
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `socket` integer parameter is the socket file descriptor that was previously
    provided by the `socket()` API. The `address` parameter tells the operating system
    which port to bind to, and which IP address to accept incoming connections from,
    usually `INADDR_ANY` which tells the operating system that an incoming connection
    may be accepted from any IP address. Finally, the `address_len` parameter tells
    the API what the total size of the address structure is.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket`整数参数是先前由`socket()` API提供的套接字文件描述符。`address`参数告诉操作系统要绑定到哪个端口，并且要接受来自哪个IP地址的传入连接，通常是`INADDR_ANY`，告诉操作系统可以接受来自任何IP地址的传入连接。最后，`address_len`参数告诉API地址结构的总大小是多少。'
- en: 'The total size (in bytes) is needed for the address structure because different
    structures are supported depending on the socket type you''re using. For example,
    an IPv6 socket has a larger IP address compared to an IPv4 socket. In this chapter,
    we will discuss IPv4, which uses the `sockaddr_in{}` structure, which defines
    the following fields:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 地址结构需要总大小（以字节为单位），因为根据您使用的套接字类型，支持不同的结构。例如，IPv6套接字的IP地址比IPv4套接字大。在本章中，我们将讨论使用`sockaddr_in{}`结构的IPv4，该结构定义以下字段：
- en: '`sin_family`: This is identical to the socket domain, which, in the case of
    IPv4, is `AF_INET`.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sin_family`：这与套接字域相同，在IPv4的情况下是`AF_INET`。'
- en: '`sin_port`: This defines the port to bind to, which must be converted into
    network byte order using `htons()`.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sin_port`：这定义了要绑定到的端口，必须使用`htons()`转换为网络字节顺序。'
- en: '`sin_address`: This defines the IP address to accept incoming connections from,
    which must also be converted into network byte order using `htonl()`. Often, this
    is set to `htonl(INADDR_ANY)`, indicating connections are accepted from any IP
    address.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sin_address`：这定义了要接受传入连接的IP地址，也必须使用`htonl()`转换为网络字节顺序。通常，这被设置为`htonl(INADDR_ANY)`，表示可以接受来自任何IP地址的连接。'
- en: Since the address structure is variable in length, the `bind()` API takes a
    pointer to an opaque structure type and uses the length field to ensure the proper
    information was provided. It should be noted that this type of API is not encouraged
    by the C++ Core Guidelines as there is no type-safe way of implementing this API.
    In fact, in order to use this API, `reinterpret_cast()` is needed to convert a `sockaddr_in{}`
    to the opaque `sockaddr{}` structure. Although the use of `reinterpret_cast()`
    is not supported by the C++ Core Guidelines, there is no alternative and therefore
    if sockets are needed, this rule must be broken.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于地址结构的长度是可变的，`bind()`API接受一个指向不透明结构类型的指针，并使用长度字段来确保提供了正确的信息。应该注意，C++核心指南不鼓励这种类型的API，因为没有类型安全的实现方式。事实上，为了使用这个API，需要使用`reinterpret_cast()`将`sockaddr_in{}`转换为不透明的`sockaddr{}`结构。尽管C++核心指南不支持使用`reinterpret_cast()`，但没有其他选择，因此如果需要套接字，必须违反这个规则。
- en: 'While servers use `bind()` to dedicate a port for the socket, clients use `connect()`
    to connect to an already-bound port. The `connect()` API has the following form:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器使用`bind()`为套接字专用端口，客户端使用`connect()`连接到已绑定的端口。`connect()`API的形式如下：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It should be noted that the parameters for `connect()` are identical to `bind()`.
    Like `bind()`, you must provide the file descriptor returned by the call to `socket()`,
    and like `bind()`, you must provide, in the case of IPv4, a pointer to a `sockaddr_in{}`
    structure as well as the size of the `sockaddr_in{}` structure. When filling out
    the `sockaddr_in{}` structure, you would use the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，`connect()`的参数与`bind()`相同。与`bind()`一样，必须提供`socket()`调用返回的文件描述符，并且在IPv4的情况下，必须提供指向`sockaddr_in{}`结构的指针以及`sockaddr_in{}`结构的大小。在填写`sockaddr_in{}`结构时，可以使用以下内容：
- en: '`sin_family`: This is identical to the socket domain, which, in the case of
    IPv4, is `AF_INET`.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sin_family`：与套接字域相同，在IPv4的情况下为`AF_INET`。'
- en: '`sin_port`: This defines the port to connect to, which must be converted into
    network byte order using `htons()`.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sin_port`：定义要连接的端口，必须使用`htons()`转换为网络字节顺序。'
- en: '`sin_address`: This defines the IP address to connect to, which must also be
    converted into network byte order using `htonl()`. For loopback connections, this
    would be set to `htonl(INADDR_LOOPBACK)`.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sin_address`：定义要连接的IP地址，也必须使用`htonl()`转换为网络字节顺序。对于环回连接，这将设置为`htonl(INADDR_LOOPBACK)`。'
- en: Finally, both `bind()` and `connect()` return `0` on success or `-1` on failure,
    setting `errno` in the event of an error.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`bind()`和`connect()`在成功时返回`0`，失败时返回`-1`，并在发生错误时设置`errno`。
- en: The listen() and accept() APIs
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`listen()`和`accept()`API'
- en: For TCP servers, two additional APIs exist that provide the server with a means
    to listen for and accept incoming TCP connections—`listen()` and `accept()`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于TCP服务器，还存在两个额外的API，提供了服务器监听和接受传入TCP连接的方法——`listen()`和`accept()`。
- en: 'The `listen()` API has the following form:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`listen()`API的形式如下：'
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The socket parameter is the file descriptor returned by the `socket()` API,
    and the backlog parameter limits the total number of outstanding connections that
    may be made. In the examples in this chapter, we will use a backlog of `0`, which
    tells the API to use an implementation-specific value for the backlog.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字参数是`socket()`API返回的文件描述符，backlog参数限制可以建立的未决连接的总数。在本章的示例中，我们将使用`0`的backlog，这告诉API使用实现特定的值作为backlog。
- en: If `listen()` succeeds, `0` is returned, otherwise `-1` is returned and `errno`
    is set to the appropriate error code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`listen()`成功，返回`0`，否则返回`-1`，并设置`errno`为适当的错误代码。
- en: 'Once your application is set up to listen for incoming connections, the `accept()`
    API may be used to accept a connection once it is ready. The `accept()` API has
    the following form:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序设置好监听传入连接的准备，`accept()`API可以用来接受连接。`accept()`API的形式如下：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Like the other APIs, the `socket` parameter is the file descriptor returned
    by the `socket()` API and the address, and the `address_len` parameter returns
    information about the connection. `nullptr` may also be provided for both the
    address and `address_len` if the connection information is not needed. Upon successful
    completion of the `accept()` API, a socket file descriptor for the client connection
    is returned, which may be used to send and receive data to and from the client.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他API一样，`socket`参数是`socket()`API返回的文件描述符和地址，`address_len`参数返回连接的信息。如果不需要连接信息，也可以为地址和`address_len`提供`nullptr`。成功完成`accept()`API后，将返回客户端连接的套接字文件描述符，可用于与客户端发送和接收数据。
- en: If accept fails to execute, instead of a valid socket file descriptor being
    returned, `-1` is returned, and `errno` is set appropriately.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果accept执行失败，返回的不是有效的套接字文件描述符，而是返回`-1`，并且适当地设置了`errno`。
- en: It should be noted that both `listen()` and `accept()` are only needed for TCP
    connections. With a TCP connection, the server creates two or more socket descriptors;
    the first one is used to bind to a port and listen for connections, while the
    second one is the socket file descriptor for the client, which is used to send
    and receive data. UDP, on the other hand, is a connectionless protocol and thus
    the same socket that is used to bind to a port is also used to send and receive
    data with the client.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，`listen()`和`accept()`仅适用于TCP连接。对于TCP连接，服务器创建两个或多个套接字描述符；第一个用于绑定到端口并监听连接，而第二个是客户端的套接字文件描述符，用于发送和接收数据。另一方面，UDP是一种无连接的协议，因此用于绑定到端口的套接字也用于与客户端发送和接收数据。
- en: The send(), recv(), sendto(), and recvfrom() APIs
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`send()`、`recv()`、`sendto()`和`recvfrom()`API'
- en: 'To send information to a server or client after opening a socket, POSIX provides
    the `send()` and `sendto()` APIs. The `send()` API has the following form:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开套接字后向服务器或客户端发送信息，POSIX提供了`send()`和`sendto()`API。`send()`API的形式如下：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first parameter is the socket file descriptor for the server or client you
    wish to send data to. It should be noted that the socket must be connected to
    a specific client or server to work (such as communicating back to a server, or
    to a client opened using TCP). The `buffer` parameter points to the buffer you
    wish to send, `length` defines the length of the buffer you wish to send, and
    `flags` provides various different settings for how you wish to send the buffer,
    which in most cases is just set to `0`. It should also be noted that when `flags` is
    set to `0`, there is typically no difference between the `write()` function and
    the `send()` function, and both may be used.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是要发送数据的服务器或客户端的套接字文件描述符。应该注意的是，套接字必须连接到特定的客户端或服务器才能工作（例如，与服务器进行通信，或者使用TCP打开的客户端）。`buffer`参数指向要发送的缓冲区，`length`定义了要发送的缓冲区的长度，`flags`提供了各种不同的设置，用于指定发送缓冲区的方式，在大多数情况下只需设置为`0`。还应该注意，当`flags`设置为`0`时，`write()`函数和`send()`函数通常没有区别，两者都可以使用。
- en: 'If a server is attempting to communicate with a client using UDP, the server
    won''t know who or how to send information to the client as the server binds to
    a specific port, not to a specific client. Likewise, if a client using UDP doesn''t
    connect to a specific server, it will not know who or how to send information
    to the server. For this reason, POSIX provides `sendto()`, which adds the `sockaddr{}`
    structure to define who and how you wish to send the buffer. `sendto()` has the
    following form:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器尝试使用UDP与客户端通信，服务器将不知道如何将信息发送给客户端，因为服务器绑定到特定端口，而不是特定客户端。同样，如果使用UDP的客户端不连接到特定服务器，它将不知道如何将信息发送给服务器。因此，POSIX提供了`sendto()`，它添加了`sockaddr{}`结构，用于定义要发送缓冲区的对象和方式。`sendto()`的形式如下：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The only difference between `send()` and `sendto()` is that `sendto()` also
    provides the destination `address` and `len` parameters, which provide the user
    with a way to define who the buffer is sent to.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`send()`和`sendto()`之间唯一的区别是`sendto()`还提供了目标`address`和`len`参数，这为用户提供了一种定义缓冲区发送对象的方式。'
- en: 'To receive data from a client or server, POSIX provides the `recv()` API, which
    has the following form:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要从客户端或服务器接收数据，POSIX提供了`recv()`API，其形式如下：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `recv()` API takes the same parameters as the `send()` API, with the difference
    being that the buffer will be written to (which is why it's not labeled `const`)
    when data is received, and the length field describes the total size of the buffer
    and not the total number of bytes received.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`recv()`API与`send()`API具有相同的参数，不同之处在于当接收到数据时，将写入缓冲区（这就是为什么它没有标记为`const`），并且长度字段描述了缓冲区的总大小，而不是接收到的字节数。'
- en: 'Likewise, POSIX provides a `recvfrom()` API, which is similar to the `sendto()`
    API and has the following form:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，POSIX提供了`recvfrom()`API，类似于`sendto()`API，其形式如下：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Both the `send()` and `sendto()` functions return the total number of bytes
    that were sent, while the `recv()` and `recvfrom()` functions return the total
    number of bytes received. All of these functions return `-1` and set `errno` to
    an appropriate value in the event of an error.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`send()`和`sendto()`函数都返回发送的总字节数，而`recv()`和`recvfrom()`函数返回接收到的总字节数。所有这些函数在发生错误时都返回`-1`并将`errno`设置为适当的值。'
- en: Studying an example on the UDP echo server
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习UDP回显服务器的示例
- en: In this example, we will walk you through a simple echo server example using
    UDP. An echo server (as is the same with our previous chapters) echoes any input
    to its output. In the case of this UDP example, the server echoes data sent to
    it from a client back to the client. To keep the example simple, character buffers
    will be echoed. How to properly process structured packets will be covered in
    the following examples.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将通过一个简单的UDP回显服务器示例来引导您。回显服务器（与我们之前的章节相同）会将任何输入回显到其输出。在这个UDP示例中，服务器将从客户端接收到的数据回显回客户端。为了保持示例简单，将回显字符缓冲区。如何正确处理结构化数据包将在接下来的示例中介绍。
- en: Server
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器
- en: 'To start, we must define the maximum buffer size we plan to send from the client
    to the server and back, and we must also define the port we wish to use:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须定义从客户端发送到服务器和返回的最大缓冲区大小，并且我们还必须定义要使用的端口：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It should be noted that any port number will do so long as it is above `1024`,
    to prevent the need for privileges. In this example, the following includes are
    needed for the server:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，只要端口号在`1024`以上，任何端口号都可以，以避免需要特权。在本例中，服务器需要以下包括：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The server will be defined using a class to take advantage of RAII, providing
    a clean method for closing the socket opened by the server when it is no longer
    needed. We also define three private member variables. The first variable will
    store the socket file descriptor that the server will use throughout the example.
    The second variable stores the address information of the server, which will be
    provided to the `bind()` function, while the third parameter stores the address
    information of the client, which will be used by the `recvfrom()` and `sendto()`
    functions:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将使用一个类来定义，以利用RAII，提供一个在不再需要时关闭服务器打开的套接字的清理方法。我们还定义了三个私有成员变量。第一个变量将存储服务器在整个示例中将使用的套接字文件描述符。第二个变量存储服务器的地址信息，将提供给`bind()`函数，而第三个参数存储客户端的地址信息，将被`recvfrom()`和`sendto()`函数使用。
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The constructor of the server will open the socket and bind the provided port
    to the socket, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的构造函数将打开套接字并将提供的端口绑定到套接字，如下所示：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The socket is opened using `AF_INET`, which tells the socket API that IPv4 is
    desired. Additionally, `SOCK_DGRAM` is provided, which tells the socket API that
    UDP is desired instead of TCP. The result of the call to `::socket()` is saved
    into the `m_fd` variable, which stores the servers socket file descriptor. Leveraging
    C++17, if the resulting file descriptor is `-1`, an error occurred, and we throw
    the error, which will be recovered later.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字使用`AF_INET`打开，这告诉套接字API需要IPv4。此外，提供了`SOCK_DGRAM`，这告诉套接字API需要UDP而不是TCP。对`::socket()`的调用结果保存在`m_fd`变量中，该变量存储服务器的套接字文件描述符。利用C++17，如果结果文件描述符为`-1`，则发生错误，我们会抛出错误，稍后会恢复。
- en: 'Next, we fill in a `sockaddr_in{}` structure:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们填写一个`sockaddr_in{}`结构：
- en: '`sin_family` is set to `AF_INET` to match the socket, telling the socket API
    we wish to use IPv4.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sin_family`被设置为`AF_INET`以匹配套接字，告诉套接字API我们希望使用IPv4。'
- en: '`sin_port` is set to the port number, and `htons` is used to convert host byte
    order into network byte order for a short.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sin_port`被设置为端口号，`htons`用于将主机字节顺序转换为短网络字节顺序。'
- en: '`sin_addr` is set to `INADDR_ANY`, which tells the socket API that the server
    will accept data from any client. Since UDP is a connectionless protocol, this
    means we may receive data from any client if desired.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sin_addr` 被设置为 `INADDR_ANY`，这告诉套接字 API 服务器将接受来自任何客户端的数据。由于UDP是一种无连接的协议，这意味着我们可以从任何客户端接收数据。'
- en: Finally, a call to a member function, called `bind()`, is made and the result
    is checked for an error. If an error occurs, an exception is thrown.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用一个名为`bind()`的成员函数，并检查结果是否有错误。如果发生错误，就会抛出异常。
- en: 'The bind function is nothing more than a wrapper around the `::bind()` socket
    API, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定函数实际上只是`::bind()`套接字API的包装器，如下所示：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code snippet, we call `bind` with the socket file descriptor
    that is opened in the constructor of our server class, and we provide the `bind`
    API with the port and address that was also initialized in the constructor prior
    to calling this function, which tells the socket to bind to port `22000` and any
    IP address.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用在服务器类的构造函数中打开的套接字文件描述符调用`bind`，并在调用此函数之前提供了在构造函数中初始化的端口和地址给`bind`
    API，这告诉套接字绑定到端口`22000`和任何IP地址。
- en: 'Once the socket has been bound, the server is ready to receive data from a
    client. Since we bound the socket to any IP address, any client can send us information.
    We could use the `recv()` POSIX API for this, but the problem with this approach
    is that once we receive data, we will not know who sent us the information. This
    is fine if we don''t need to send that client any information in return, or we
    embed the client information in the data received, but in the case of a simple
    echo server, we need to know who to echo the data to. To solve this problem, we
    use `recvfrom()` instead of `recv()`, as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦套接字被绑定，服务器就准备好从客户端接收数据。由于我们将套接字绑定到任何IP地址，任何客户端都可以向我们发送信息。我们可以使用`recv()` POSIX
    API来实现这一点，但这种方法的问题在于一旦我们接收到数据，我们就不知道是谁发送给我们信息。如果我们不需要向该客户端发送任何信息，或者我们将客户端信息嵌入接收到的数据中，这是可以接受的，但在简单的回显服务器的情况下，我们需要知道要将数据回显给谁。为了解决这个问题，我们使用`recvfrom()`而不是`recv()`，如下所示：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first parameter is the socket file descriptor that was created during construction,
    while the second and third parameters are the buffer and its maximum size. Note
    that our `recv()` member function takes `std::array` instead of a pointer and
    a size, as a pointer and a size parameter would not be C++-Core-compliant because
    doing so provides an opportunity for error in reporting the actual size of the
    array. The last two parameters are a pointer to a `sockaddr_in{}` structure and
    its size.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是在构造过程中创建的套接字文件描述符，而第二个和第三个参数是缓冲区及其最大大小。请注意，我们的`recv()`成员函数使用`std::array`而不是指针和大小，因为使用指针和大小参数不符合C++核心规范，因为这样做会提供报告数组实际大小的错误机会。最后两个参数是指向`sockaddr_in{}`结构和其大小的指针。
- en: It should be noted that in our example we provide `recvfrom()` with a `sockaddr_in{}`
    structure, as we know that the client that will be connecting will use an IPv4
    address. If this is not the case, the `recvfrom()` function will fail, as we will
    have provided it with a structure that is too small to provide, say, an IPv6 address
    if it is used. To overcome this issue, you may use `sockaddr_storage{}` instead
    of `sockaddr_in{}`. The `sockaddr_storage{}` structure is large enough to store
    an incoming address type. To determine which address type you received, the `sin_family`
    field may be used, which is required in all of the structures.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在我们的示例中，我们向`recvfrom()`提供了一个`sockaddr_in{}`结构，因为我们知道将要连接的客户端将使用IPv4地址。如果不是这种情况，`recvfrom()`函数将失败，因为我们提供了一个太小的结构，无法提供例如IPv6地址（如果使用）的结构。为了解决这个问题，可以使用`sockaddr_storage{}`而不是`sockaddr_in{}`。`sockaddr_storage{}`结构足够大，可以存储传入的地址类型。要确定收到的地址类型，可以使用所有结构中都需要的`sin_family`字段。
- en: Finally, we return the result of the call to `recvfrom()`, which could either
    be the number of bytes received, or `-1` in the event of an error.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们返回对`recvfrom()`的调用结果，这可能是接收到的字节数，或者在发生错误时为`-1`。
- en: 'To send a buffer to a client that connects to the UDP server, we use the `sendto()`
    API, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要将缓冲区发送给连接到UDP服务器的客户端，我们使用`sendto()` API，如下所示：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As with the other APIs, the first parameter is the socket file descriptor that
    was opened in the constructor. The buffer is then provided. The difference between
    `recvrom()` and `sendto()` in this case is that the number of bytes to send is
    provided instead of the total size of the buffer. This doesn''t break C++ Core
    Guidance as the total size of the buffer is still attached to the buffer itself,
    and instead the number of bytes to send is a second value used to determine how
    far into an array we plan to address. We do, however, need to ensure the length
    field is not out of range. This could be done using a call to `Expects()`, as
    follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他API一样，第一个参数是在构造函数中打开的套接字文件描述符。然后提供缓冲区。在这种情况下，“recvfrom（）”和“sendto（）”之间的区别在于提供要发送的字节数，而不是缓冲区的总大小。这不会违反C++核心指导，因为缓冲区的总大小仍然附加到缓冲区本身，而要发送的字节数是用于确定我们计划寻址数组的位置的第二个值。但是，我们需要确保长度字段不超出范围。这可以使用“Expects（）”调用来完成，如下所示：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the case of this example, we explicitly check for an out-of-range error and
    throw a more verbose error if this should occur. Either approach would work.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们明确检查了是否超出范围的错误，并在发生这种情况时抛出了更详细的错误。任何一种方法都可以。
- en: As with the `recvfrom()` call, we provide the `sendto()` API with a pointer
    to a `sockaddr_in{}` structure, which tells the socket which client to send data
    to. In this case, since the API does not modify the address structure (and thus
    the structure cannot change in size), a pointer to the length field is not needed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与“recvfrom（）”调用一样，我们向“sendto（）”API提供了指向“sockaddr_in{}”结构的指针，告诉套接字要向哪个客户端发送数据。在这种情况下，由于API不修改地址结构（因此结构的大小不会改变），因此不需要指向长度字段的指针。
- en: 'The next step is to put all of these together to create the echo server itself,
    as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将所有这些组合在一起，创建回显服务器本身，如下所示：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The echo server is designed to receive a buffer of data from a client, send
    it back to the same client, and repeat. To start, we create an infinite loop that
    is capable of echoing data from any client until we are told the client has disconnected.
    The next step is to define a buffer that will be used to both send and receive
    data to the client. We then call the `recv()` member function and provide it with
    the buffer we wish the receive function to fill in with data from the client and
    check whether the number of bytes returned from the client is greater than `0`.
    If the number of bytes returned from the client is greater than `0`, we use the
    `send` member function to send (or echo) the buffer back to the client. If the
    number of bytes is `0`, we assume the client has disconnected as a result, and
    we stop the infinite loop, which in turn completes the echo process.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 回显服务器设计用于从客户端接收数据缓冲区，将其发送回同一客户端，并重复。首先，我们创建一个无限循环，能够从任何客户端回显数据，直到我们被告知客户端已断开连接。下一步是定义一个缓冲区，该缓冲区将用于向客户端发送和接收数据。然后调用“recv（）”成员函数，并向其提供我们希望接收函数用来填充来自客户端的数据的缓冲区，并检查来自客户端返回的字节数是否大于“0”。如果来自客户端返回的字节数大于“0”，我们使用“send”成员函数将缓冲区发送（或回显）回客户端。如果字节数为“0”，我们假设客户端已断开连接，因此停止无限循环，从而完成回显过程。
- en: The client-information structure (that is, `m_client`) is provided to both the
    `recvfrom()` and `sendto()` POSIX APIs. This is done intentionally. The only assumption
    we are making is that all clients connecting will use IPv4\. The `recvfrom()`
    function will fill in the `m_client` structure for us when data is received from
    a client, telling us who the client was that sent us the information. We then
    provide this same structure back to the `sendto()` function to tell the API who
    to echo the data to.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端信息结构（即“m_client”）提供给“recvfrom（）”和“sendto（）”POSIX API。这是故意的。我们唯一假设的是所有连接的客户端都将使用IPv4。当从客户端接收到数据时，“recvfrom（）”函数将为我们填充“m_client”结构，告诉我们发送给我们信息的客户端是谁。然后我们将相同的结构提供回“sendto（）”函数，告诉API要将数据回显给谁。
- en: 'As stated before, when the server class is destroyed we close the socket, as
    follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当服务器类被销毁时，我们关闭套接字，如下所示：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we complete the server by instantiating the server in a `protected_main()`
    function, and then begin echoing:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过在“protected_main（）”函数中实例化服务器来完成服务器，并开始回显：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As shown, the `main` function is protected from possible exceptions, and in
    the `protected_main()` function, we instantiate the server and call its `echo()`
    member function, which starts the infinite loop for echoing client data.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，“main”函数受到可能异常的保护，在“protected_main（）”函数中，我们实例化服务器并调用其“echo（）”成员函数，这将启动用于回显客户端数据的无限循环。
- en: The client logic
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端逻辑
- en: 'In this example, the following includes are needed for the client:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，客户端需要以下包含：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Like the server, the client is created using a class to take advantage of RAII:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务器一样，客户端是使用类创建的，以利用RAII：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In addition to the class definition, two private member variables are defined.
    The first, like the server, is the socket file descriptor that will be used by
    the client. The second defines the address information for the server the client
    desires to communicate with.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 除了类定义之外，还定义了两个私有成员变量。第一个，像服务器一样，是客户端将使用的套接字文件描述符。第二个定义了客户端希望与之通信的服务器的地址信息。
- en: 'The constructor of the client is similar to the server''s, with some minor
    differences:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的构造函数与服务器的类似，有一些细微的差异：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Like the server, the client creates a socket file descriptor for IPv4 by using
    `AF_INET` and the protocol type is set to UDP by using `SOCK_DGRAM`. If the `socket()`
    API returns an error, an exception is thrown. The `sockaddr_in{}` structure that
    is set up is different from the server. The server's `sockaddr_in{}` structure
    defines how the server will bind the socket, while the client `sockaddr_in{}`
    structure defines what server the client will connect to. In the case of this
    example, we set the address to `INADDR_LOOPBACK` as the server will be running
    on the same computer. Finally, the `connect()` member function is called, which
    connects to the server, and if an error occurs, an exception is thrown.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 像服务器一样，客户端使用`AF_INET`创建IPv4的套接字文件描述符，并且使用`SOCK_DGRAM`将协议类型设置为UDP。如果`socket()`API返回错误，则会抛出异常。设置的`sockaddr_in{}`结构与服务器不同。服务器的`sockaddr_in{}`结构定义了服务器将如何绑定套接字，而客户端的`sockaddr_in{}`结构定义了客户端将连接到哪个服务器。在这个例子中，我们将地址设置为`INADDR_LOOPBACK`，因为服务器将在同一台计算机上运行。最后，调用`connect()`成员函数，连接到服务器，如果发生错误，则抛出异常。
- en: 'To connect to the server, the following `connect()` member function is used:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到服务器，使用以下`connect()`成员函数：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It should be noted that connecting to a server with UDP is optional as UDP is
    a connectionless protocol. The `connect` function, in this case, tells the operating
    system which server you plan to communicate with such that `send()` and `recv()`
    may be used, instead of `sendto()` and `recvfrom()` on the client side. Like the
    `bind()` member function for the server, the `connect()` function leverages the
    `sockaddr_in{}` structure filled in by the constructor.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，使用UDP连接到服务器是可选的，因为UDP是一种无连接的协议。在这种情况下，`connect`函数告诉操作系统您计划与哪个服务器通信，以便在客户端使用`send()`和`recv()`，而不是`sendto()`和`recvfrom()`。像服务器的`bind()`成员函数一样，`connect()`函数利用构造函数填充的`sockaddr_in{}`结构。
- en: 'To send data to the server to be echoed, the following `send()` member variable
    is used:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送数据到服务器进行回显，使用以下`send()`成员变量：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Since we plan to send the server a string, we pass the `send()` member function
    a string reference. The `send()` POSIX API is then given the socket file descriptor
    created in the constructor, the buffer to send to the server to be echoed, and
    the total length of the buffer being sent. Since we don''t use the `flags` field,
    the `send()` member function could also be written using the `write()` function,
    as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们计划向服务器发送一个字符串，所以我们将`send()`成员函数传递一个字符串引用。然后`send()` POSIX API被赋予在构造函数中创建的套接字文件描述符，要发送到服务器进行回显的缓冲区以及要发送的缓冲区的总长度。由于我们不使用`flags`字段，`send()`成员函数也可以使用`write()`函数编写如下：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To receive data from the server after it has been echoed, we use the following
    `recv()` member function:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要在服务器回显数据后从服务器接收数据，我们使用以下`recv()`成员函数：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There are many ways to implement the `recv()` member function. Since we know
    the total size of the string being sent to the server, and we know the server
    will echo the same-sized string back to us, we could always create a second string
    the same size as the first (or simply reuse the original string if you trust echo
    actually is occurring). In the case of this example, we create a receive buffer
    with a specific maximum size to demonstrate a more likely scenario. As a result,
    in this example, we can send any size string we wish, but the server has its own,
    internal maximum buffer size that it can accept. The server will then echo the
    data back to the client. The client itself has its own maximum-sized receive buffer,
    which ultimately limits the total number of bytes that may be echoed. Since the
    client is echoing strings, we must reserve one byte for a trailing `'\0'` to null
    terminate any string that is received by the client that fills the entire receive
    buffer.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以实现`recv()`成员函数。由于我们知道要发送到服务器的字符串的总大小，并且我们知道服务器将向我们回显相同大小的字符串，我们可以始终创建一个与第一个字符串大小相同的第二个字符串（或者如果您信任回显实际上正在发生，可以简单地重用原始字符串）。在这个例子中，我们创建一个具有特定最大大小的接收缓冲区，以演示更有可能的情况。因此，在这个例子中，我们可以发送任意大小的字符串，但是服务器有自己的内部最大缓冲区大小可以接受。然后服务器将数据回显到客户端。客户端本身有自己的最大接收缓冲区大小，这最终限制了可能被回显的总字节数。由于客户端正在回显字符串，我们必须为尾随的`'\0'`保留一个字节，以便终止由客户端接收到的填满整个接收缓冲区的任何字符串。
- en: 'To send and receive data to and from the server, we create an `echo` function,
    as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要向服务器发送和接收数据，我们创建一个`echo`函数，如下所示：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `echo` function, like the server, first creates an infinite loop so that
    it can send multiple strings to the server to be echoed. Inside the infinite loop,
    two buffers are created. The first is the string that will take in user input.
    The second defines the receive buffer to be used. Once the buffers are defined,
    we use `std::cin` to get from the user the string to be sent to the server (which
    will ultimately be echoed).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo`函数，就像服务器一样，首先创建一个无限循环，以便可以向服务器发送多个字符串进行回显。在无限循环内，创建了两个缓冲区。第一个是将接收用户输入的字符串。第二个定义了要使用的接收缓冲区。一旦定义了缓冲区，我们使用`std::cin`从用户那里获取要发送到服务器的字符串（最终将被回显）。'
- en: If the string is the word `exit`, we send 0 bytes to the server and exit the
    infinite loop. Since UDP is a connectionless protocol, the server has no way of
    knowing whether the client has disconnected because no such construct exists.
    Therefore, without sending a signal to the server to stop (in this case we send
    0 bytes), the server would stay in an infinite loop as it has no way of knowing
    when to stop. In this example, this poses an interesting problem because if the
    client crashes or is killed (for example, with *Ctrl* + *C*), the server will
    never be given the 0 byte signal, and thus remain in an infinite loop. There are
    many ways to solve this issue (that is, by sending a keep-alive signal), but once
    you go down the path of trying to solve this problem, you quickly end up with
    a protocol that is so similar to TCP, you might as well use TCP.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符串是单词`exit`，我们向服务器发送0字节并退出无限循环。由于UDP是一种无连接的协议，服务器无法知道客户端是否已断开连接，因为没有这样的构造存在。因此，如果不向服务器发送停止的信号（在这种情况下我们发送0字节），服务器将保持在无限循环中，因为它无法知道何时停止。在这个例子中，这带来了一个有趣的问题，因为如果客户端崩溃或被杀死（例如，使用*Ctrl*
    + *C*），服务器将永远不会收到0字节的信号，因此仍然保持在无限循环中。有许多方法可以解决这个问题（即发送保持活动的信号），但一旦你开始尝试解决这个问题，你很快就会得到一个与TCP如此相似的协议，你可能会选择使用TCP。
- en: Finally, the user-inputted buffer is sent to the server using the `send()` member
    function, the server echoes the string, and then the client then receives the
    string using the `recv()` member function. Once the string is received, the data
    is output to `stdout` using `std::cout`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，用户输入的缓冲区使用`send()`成员函数发送到服务器，服务器回显字符串，然后客户端使用`recv()`成员函数接收字符串。一旦接收到字符串，数据将使用`std::cout`输出到`stdout`。
- en: 'Like the server, when the client class is destroyed, the socket file descriptor
    is closed, closing the socket:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务器一样，当客户端类被销毁时，套接字文件描述符将被关闭，关闭套接字：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, the client is created using the same `protected_main()` function as
    the server and our previous examples:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，客户端是使用与服务器和我们先前的示例相同的`protected_main()`函数创建的：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding code, the client is instantiated in the `protected_main()`
    function, and the `echo` function is called, which accepts user input, sends the
    input to the server, and outputs any echoed data to `stdout`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，客户端是在`protected_main()`函数中实例化的，并调用了`echo`函数，该函数接受用户输入，将输入发送到服务器，并将任何回显的数据输出到`stdout`。
- en: Compiling and testing
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和测试
- en: To compile this code, we leverage the same `CMakeLists.txt` file that we have
    been using for the other examples: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译此代码，我们利用了我们一直在使用的相同的`CMakeLists.txt`文件：[https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt)。
- en: 'With this code in place, we can compile this code using the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个代码，我们可以使用以下命令编译这个代码：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To execute the server, run the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行服务器，请运行以下命令：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To execute the client, open a new terminal and run the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行客户端，请打开一个新的终端并运行以下命令：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As shown in the preceding snippet, when the client is executed, and input is
    entered, the input is echoed back to the terminal. Once complete and the word
    `exit` is entered, the client exits. Also the server will exit when the client
    is complete. To demonstrate the connection issue with UDP, instead of entering
    `exit`, hit *Ctrl *+ *C* on the client—the client will exit but the server will
    continue to execute, waiting for more input from the client as it will not know
    the client has completed. To solve this issue, out next example will create the
    same echo server but using TCP instead.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的片段所示，当客户端执行并输入时，输入将回显到终端。完成后，输入单词`exit`，客户端退出。服务器也将在客户端完成时退出。为了演示UDP的连接问题，而不是输入`exit`，在客户端上按*Ctrl *+ *C*，客户端将退出，但服务器将继续执行，等待来自客户端的更多输入，因为它不知道客户端已完成。为了解决这个问题，我们的下一个示例将创建相同的回声服务器，但使用TCP。
- en: Studying an example on the TCP echo server
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习TCP回声服务器的示例
- en: In this example, we will walk the reader through creating an echo server, but
    using TCP instead of UDP. Just like with the previous example, an echo server
    echoes any input to its output. Unlike the UDP example, TCP is a connection-based
    protocol, and thus some of the specifics of how to establish a connection and
    send/receive data are different in this example.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将引导读者创建一个回声服务器，但是使用TCP而不是UDP。就像之前的例子一样，回声服务器会将任何输入回显到其输出。与UDP示例不同，TCP是一种基于连接的协议，因此在这个例子中建立连接和发送/接收数据的一些具体细节是不同的。
- en: Server
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器
- en: 'To start, we must define the maximum buffer size we plan to send from the client
    to the server and back, and we must also define the port we wish to use:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须定义从客户端发送到服务器和返回的最大缓冲区大小，并且我们还必须定义要使用的端口：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'For the server, we will need the following includes:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务器，我们将需要以下包含：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As with the previous examples, we will create the server using a class to take
    advantage of RAII:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的例子一样，我们将使用一个类来创建服务器，以便利用RAII：
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As with UDP, three member variables will be used. The first member variable,
    `m_fd`, stores the socket file descriptor for the socket associated with the server.
    Unlike UDP, this descriptor will not be used to send/receive data with a client.
    Instead, `m_client` represents a second socket file descriptor that will be used
    to send/receive data with the client. Like with UDP, the `sockaddr_in{}` structure,
    `m_addr`, will be filled in with the server address type, which will be bound.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 与UDP一样，将使用三个成员变量。第一个成员变量`m_fd`存储与服务器关联的套接字文件描述符。与UDP不同，此描述符将不用于与客户端发送/接收数据。相反，`m_client`表示将用于与客户端发送/接收数据的第二个套接字文件描述符。与UDP一样，`sockaddr_in{}`结构`m_addr`将填充服务器地址类型，该类型将被绑定。
- en: 'The constructor for the server is similar to the UDP example:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的构造函数与UDP示例类似：
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Like the UDP example, a socket file descriptor for the server is created, but
    instead of `SOCK_DGRAM` being used, `SOCK_STREAM` is used instead. The `sockaddr_in{}`
    structure is identical to the UDP example with IPv4 being used (that is, `AF_INET`),
    the port, and any IP address being used to signal that connections from any IP
    address will be accepted.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 与UDP示例类似，创建了服务器的套接字文件描述符，但是使用的不是`SOCK_DGRAM`，而是使用`SOCK_STREAM`。`sockaddr_in{}`结构与UDP示例相同，使用了IPv4（即`AF_INET`），端口和任何IP地址用于表示将接受来自任何IP地址的连接。
- en: 'Like the UDP example, the `sockaddr_in{}` structure is then bound using the
    following member function:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 与UDP示例类似，`sockaddr_in{}`结构然后使用以下成员函数进行绑定：
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding `bind()` function is identical to the `bind()` function used in
    the UDP example.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`bind()`函数与UDP示例中使用的`bind()`函数相同。
- en: Unlike UDP, a second, client-specific socket descriptor is created, and the
    IP address, port, and address type are all set for that socket type, meaning communicating
    with the client does not require `sendto()` or `recvfrom()` since we have a specific
    socket file descriptor that already has this additional information bound to it.
    For this reason, `send()` and `recv()` may be used instead of `sendto()` and `recvfrom()`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 与UDP不同，创建了第二个特定于客户端的套接字描述符，并为该套接字类型设置了IP地址、端口和地址类型，这意味着与客户端通信不需要`sendto()`或`recvfrom()`，因为我们已经有了一个特定的套接字文件描述符，其中已经绑定了这些额外的信息。因此，可以使用`send()`和`recv()`而不是`sendto()`和`recvfrom()`。
- en: 'To receive data from the client, the following member function will be used:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要从客户端接收数据，将使用以下成员函数：
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The only difference between the UDP example and this example is the use of `recv()`
    instead of `recvfrom()`, which omits the additional `sockaddr_in{}` structure.
    If you recall from the previous UDP example, `m_fd` was used with `recvfrom()`
    instead of `m_client` with `recv()`. The difference is that `m_client` in the
    UDP example is a `sockaddr_in{}` structure that defines who to receive data from.
    With TCP, `m_client` is instead a socket descriptor, and who to receive data from
    is bound to the descriptor, which is why the additional `sockaddr_in{}` structure
    is not needed.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: UDP示例和这个示例之间唯一的区别是使用`recv()`而不是`recvfrom()`，这省略了额外的`sockaddr_in{}`结构。如果你还记得之前的UDP示例，`m_fd`是与`recvfrom()`一起使用的，而不是`m_client`与`recv()`一起使用的。不同之处在于UDP示例中的`m_client`是一个`sockaddr_in{}`结构，用于定义从哪里接收数据。而在TCP中，`m_client`实际上是一个套接字描述符，从描述符绑定接收数据，这就是为什么不需要额外的`sockaddr_in{}`结构。
- en: 'The same is also true for the `send()` member function:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`send()`成员函数也是如此：'
- en: '[PRE41]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Unlike in the UDP example, the preceding `send()` function may use the `send()`
    POSIX API instead of `sendto()`, as the address information about who and how
    to send data to the client is bound to the descriptor and, as such, the additional
    `sockaddr_in{}` information may be omitted. The rest of the `send()` function
    is identical to the UDP example.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 与UDP示例不同，前面的`send()`函数可能使用`send()` POSIX API而不是`sendto()`，因为关于如何向客户端发送数据的地址信息已经绑定到描述符上，因此可以省略额外的`sockaddr_in{}`信息。`send()`函数的其余部分与UDP示例相同。
- en: 'The `echo` function is quite a bit different from its UDP counterpart:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo`函数与其UDP对应函数有很大不同：'
- en: '[PRE42]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Since TCP requires connections, the first step in the `echo` function for the
    server is to tell the POSIX API that you wish to begin listening for incoming
    connections. In our example, we tell the API to use the default connection backlog,
    which is implementation-specific, by setting the backlog to `0`. The next step
    is to wait for an incoming connection from a client using the `accept()` POSIX
    API. By default, this function is a blocking function. The `accept()` function
    returns a socket file descriptor with the address information bound to the descriptor
    and as a result, we pass `nullptr` to the address fields in the `accept()` POSIX
    API as this information is not needed in our example (but might be needed if you,
    for example, need to filter certain incoming clients).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于TCP需要连接，服务器`echo`函数的第一步是告诉POSIX API您希望开始监听传入连接。在我们的示例中，通过将backlog设置为`0`来告诉API使用默认连接backlog，这是特定于实现的。下一步是使用`accept()`
    POSIX API等待来自客户端的传入连接。默认情况下，此函数是一个阻塞函数。`accept()`函数返回一个带有地址信息绑定到描述符的套接字文件描述符，因此在`accept()`
    POSIX API的地址字段中传递`nullptr`，因为在我们的示例中不需要这些信息（但是如果需要过滤某些传入客户端，可能需要这些信息）。
- en: The next step is to wait for data to be received by the client and then echo
    that data back to the client using the `send()` member function. This logic is
    identical to the UDP example. It should be noted that if we receive `0` bytes
    from the client, we stop processing data from the client, similar to what was
    done with UDP. The difference is that, as will be shown, on the client side, we
    do not need to explicitly send 0 bytes to the server for this condition to occur.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是等待客户端接收数据，然后使用`send()`成员函数将数据回传给客户端。这个逻辑与UDP示例相同。值得注意的是，如果我们从客户端接收到`0`字节，我们将停止处理来自客户端的数据，类似于UDP。不同之处在于，如将会展示的，客户端端不需要显式地向服务器发送0字节以发生这种情况。
- en: 'The last step in the `echo` function is to close the client socket file descriptor
    once the client has finished:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo`函数中的最后一步是在客户端完成后关闭客户端套接字文件描述符：'
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'As with the other examples, we close the server''s socket file descriptor when
    the server class is destroyed. Finally, the server is instantiated in a `protected_main()`
    function, as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他示例一样，当服务器类被销毁时，关闭服务器的套接字文件描述符。最后，在`protected_main()`函数中实例化服务器，如下所示：
- en: '[PRE44]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Like the UDP example, the server is instantiated, and the `echo()` function
    is executed.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与UDP示例类似，实例化了服务器，并执行了`echo()`函数。
- en: The client logic
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端逻辑
- en: 'The client logic is similar to the UDP client logic with a few minor exceptions.
    The following includes are needed:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端逻辑与UDP客户端逻辑类似，有一些细微的例外。需要以下包含：
- en: '[PRE45]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Just like with the UDP example, a client class is created to leverage RAII,
    and the `m_fd` and `m_addr` private member variables are defined to store the
    socket file descriptor for the client, and the address information for the server
    the client wishes to connect to:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 与UDP示例一样，创建了一个客户端类来利用RAII，并定义了`m_fd`和`m_addr`私有成员变量，用于存储客户端的套接字文件描述符和客户端希望连接到的服务器的地址信息：
- en: '[PRE46]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Unlike the UDP example, but like the TCP server logic, the constructor creates
    a socket for IPv4 and TCP using both `AF_INET` and `SOCK_STREAM`, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与UDP示例不同，但与TCP服务器逻辑相同，构造函数创建了一个用于IPv4和TCP的套接字，使用了`AF_INET`和`SOCK_STREAM`：
- en: '[PRE47]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The rest of the constructor is identical to the UDP example, as are the `connect()`,
    `send()`, and `recv()` functions:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的其余部分与UDP示例相同，`connect()`、`send()`和`recv()`函数也是如此：
- en: '[PRE48]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As shown in the preceding snippet, the client functions almost exactly the
    same as a UDP client. The difference between a UDP client and a TCP client, other
    than the use of `SOCK_STREAM`, lies in the implementation of the `echo` function:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，客户端的功能几乎与UDP客户端完全相同。UDP客户端和TCP客户端之间的区别，除了使用`SOCK_STREAM`之外，还在于`echo`函数的实现：
- en: '[PRE49]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Unlike the UDP example, the TCP client does not need to check for the `exit` string.
    This is because if the client disconnects (for example, *Ctrl *+ *C* is used to
    kill the client), `0` bytes are received on the server side, telling the server
    logic the client has been disconnected. This is possible because TCP is a connection-based
    protocol, and thus, the operating system is maintaining an open connection, including
    keep-alive signals between the server and the client so that the user of the API
    doesn''t have to do this explicitly. For this reason, in most cases, this is the
    desired socket type, as it prevents a lot of common problems with connection status:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 与UDP示例不同，TCP客户端不需要检查`exit`字符串。这是因为如果客户端断开连接（例如，使用*Ctrl*+*C*杀死客户端），服务器端会接收到0字节，告诉服务器逻辑客户端已断开连接。这是可能的，因为TCP是一种基于连接的协议，因此操作系统正在维护一个开放的连接，包括服务器和客户端之间的保持活动信号，以便API的用户不必显式地执行此操作。因此，在大多数情况下，这是期望的套接字类型，因为它可以防止许多与连接状态相关的常见问题：
- en: '[PRE50]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As shown in the preceding code, like all of the other examples, when the client
    is destroyed, the socket file descriptor is closed, as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，与所有其他示例一样，当客户端被销毁时，套接字文件描述符将被关闭，如下所示：
- en: '[PRE51]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Finally, the client is instantiated in a `protected_main()` function, and the
    `echo` function is called.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，客户端在`protected_main()`函数中实例化，并调用`echo`函数。
- en: Compiling and testing
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和测试
- en: To compile this code, we leverage the same `CMakeLists.txt` file that we have
    been using for the other examples: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译此代码，我们利用了与本章其他示例相同的`CMakeLists.txt`文件：[https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt)。
- en: 'With this code in place, we can compile this code using the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些代码，我们可以使用以下命令编译此代码：
- en: '[PRE52]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To execute the server, run the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行服务器，请运行以下命令：
- en: '[PRE53]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To execute the client, open a new terminal and run the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行客户端，请打开一个新的终端并运行以下命令：
- en: '[PRE54]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As shown in the preceding snippet, when the client is executed, and input is
    entered, the input is echoed back to the terminal. Once complete, and *Ctrl *+
    *C* is entered, the client exits. As you can see, the server will exit when the
    client is complete. The preceding example demonstrates the ease of use of TCP,
    and its advantages over UDP. The next example will demonstrate how to use TCP
    for something more useful.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，当客户端被执行并输入时，输入将被回显到终端。完成后，输入*Ctrl*+*C*，客户端退出。如您所见，服务器将在客户端完成时退出。上面的示例演示了TCP的易用性及其优于UDP的优势。下一个示例将演示如何使用TCP进行更有用的操作。
- en: Exploring an example on TCP Logger
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索TCP记录器示例
- en: To demonstrate something more useful, the following example implements the same
    logger that we have been developing throughout this book, but as a remote logging
    facility.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示更有用的功能，以下示例实现了我们在整本书中一直在开发的相同记录器，但作为远程记录设施。
- en: Server
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器
- en: 'The same macros and includes are needed for this example as with the previous
    examples in this chapter. To start the server, we must define the log file:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章前面的示例一样，此示例也需要相同的宏和包含文件。要启动服务器，我们必须定义日志文件：
- en: '[PRE55]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Since the logger will be executing on the same computer to keep the example
    simple, we will name the file the server is logging to as `server_log.txt`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于记录器将在同一台计算机上执行，为了保持示例简单，我们将命名服务器正在记录的文件为`server_log.txt`。
- en: 'The server is identical to the TCP server in the previous example, with the
    exception that only a `recv()` member function is needed (that is, there is no
    need for a `send()` function as the server will only be receiving log data):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器与前面示例中的TCP服务器相同，唯一的区别是只需要一个`recv()`成员函数（即不需要`send()`函数，因为服务器只会接收日志数据）：
- en: '[PRE56]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The difference between the previous TCP example and this example is the use
    of the `log()` function instead of the `echo` function. Both functions are similar
    in that they listen for an incoming connection and then loop infinitely until
    data is received by the server:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个TCP示例和此示例之间的区别在于使用`log()`函数而不是`echo`函数。这两个函数都类似，它们监听传入的连接，然后无限循环，直到服务器接收到数据：
- en: '[PRE57]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The difference with the `log` function is that when data is received by the
    client, instead of echoing the data back to the server, the data is output to
    `stdout` and written to the `server_log.txt` log file.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`log`函数的不同之处在于，当客户端接收到数据时，不会将数据回显到服务器，而是将数据输出到`stdout`并写入`server_log.txt`日志文件。'
- en: 'As shown here, the rest of the server logic is the same as the previous example:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如此所示，服务器逻辑的其余部分与前面的示例相同：
- en: '[PRE58]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The socket file descriptor is closed when the server object is destroyed, the
    server is instantiated in a `protected_main()` function, and the `log()` function
    is then executed.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器对象被销毁时，套接字文件描述符被关闭，在`protected_main()`函数中实例化服务器，然后执行`log()`函数。
- en: The client logic
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端逻辑
- en: The client logic for this example is a combination of the debug examples in
    previous chapters (which we have been building upon) and the previous TCP example.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例的客户端逻辑是前几章中的调试示例（我们一直在构建）和之前的TCP示例的组合。
- en: 'We start by defining the debug level and enable macros, as with previous examples:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义调试级别并启用宏，与之前的示例一样：
- en: '[PRE59]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The client class is identical to the client class in the previous TCP example:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端类与之前的TCP示例中的客户端类相同：
- en: '[PRE60]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The only difference between the client in this example and the client in the
    previous example is that in this example, there is no need for a `recv()` function
    (as no data is being received from the server), and there is no need for the `echo()`
    function (or anything similar) as the client will be used directly to send data
    to the server as needed.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例中的客户端与上一个示例中的客户端唯一的区别在于，在本示例中不需要`recv()`函数（因为不会从服务器接收数据），也不需要`echo()`函数（或类似的东西），因为客户端将直接用于根据需要向服务器发送数据。
- en: 'As with the previous debug example, a log file for the client is needed, and
    in this example, we will also globally instantiate the client, as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的调试示例一样，需要为客户端创建一个日志文件，在本示例中，我们还将全局实例化客户端，如下所示：
- en: '[PRE61]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As shown, the client log file will be named `client_log.txt`, to prevent a collision
    with the server log file as both will be running on the same computer to simplify
    the example.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，客户端日志文件将被命名为`client_log.txt`，以防止与服务器日志文件发生冲突，因为两者将在同一台计算机上运行，以简化示例。
- en: 'The `log` function is identical to the `log` function defined in [Chapter 8](da2d2789-8a5d-4da0-b374-668d06e322ec.xhtml), *Learning
    to Program File Input/Output,* with the exception that in addition to logging
    to `stderr` and the client-side log file, the debug string will also be logged
    to the server:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`log`函数与[第8章](da2d2789-8a5d-4da0-b374-668d06e322ec.xhtml)中定义的`log`函数相同，*学习编程文件输入/输出*，唯一的区别是除了记录到`stderr`和客户端日志文件外，调试字符串还将记录到服务器上：'
- en: '[PRE62]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As shown in preceding code, the `log` function encapsulates any output to `std::clog`,
    and redirects the resulting string to `stderr`, the log file, and for the purpose
    of this example, to the client object that sends the string to the server to be
    logged on the server side.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，`log`函数封装了对`std::clog`的任何输出，并将结果字符串重定向到`stderr`，日志文件，并且为了本示例的目的，发送字符串到服务器的客户端对象上，以便在服务器端记录。
- en: 'The remaining portion of the example is identical to the previous examples:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 示例的其余部分与之前的示例相同：
- en: '[PRE63]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `protected_main()` function outputs `Hello World\n` to `stderr`, which is
    redirected to include `stderr`, the log file, and finally sent to the server.
    Another call to `std::clog` is made to show that only calls to `std:clog` that
    are encapsulated in the `log()` function are redirected.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`protected_main()`函数将`Hello World\n`输出到`stderr`，它被重定向到包括`stderr`，日志文件，并最终发送到服务器。另外调用`std::clog`用于显示只有封装在`log()`函数中的`std:clog`调用才会被重定向。'
- en: Compiling and testing
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和测试
- en: To compile this code, we leverage the same `CMakeLists.txt` file that we have
    been using for the other examples: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译此代码，我们利用了与其他示例相同的`CMakeLists.txt`文件：[https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt)。
- en: 'With this code in place, we can compile this code using the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这段代码，我们可以使用以下命令编译这段代码：
- en: '[PRE64]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'To execute the server, run the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行服务器，请运行以下命令：
- en: '[PRE65]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'To execute the client, open a new terminal and run the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行客户端，请打开一个新的终端并运行以下命令：
- en: '[PRE66]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'As shown in the preceding snippet, when the client is executed, the client
    and server side both output `DEBUG: Hello World` to `stderr.` In addition, the
    client outputs `Hello World` to `stderr` as the second call to `std::clog` is
    not redirected. Finally, both log files contain the redirected `DEBUG: Hello World`.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '如前面的片段所示，当客户端执行时，客户端和服务器端都将在`stderr`输出`DEBUG: Hello World`。此外，客户端还将`Hello World`输出到`stderr`，因为第二次对`std::clog`的调用没有被重定向。最后，两个日志文件都包含重定向的`DEBUG:
    Hello World`。'
- en: In all of the examples so far, the one thing that has been ignored is what happens
    if more than one client attempts to connect to the server. In the examples in
    this chapter, only one client is supported. To support additional clients, threading
    is needed, which will be covered in [Chapter 12](3bc6e6a9-5b8d-46b1-aeae-8d6b07c3ad18.xhtml),
    *Learning to Program POSIC and C++ Threads *where we will expand upon this example
    to create a logging server capable of logging the debug output of more than one
    application. The final two examples in this chapter will demonstrate how to process
    non-string data packets using TCP.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在所有示例中，忽略的一件事是如果多个客户端尝试连接到服务器会发生什么。在本章的示例中，只支持一个客户端。要支持额外的客户端，需要使用线程，这将在[第12章](3bc6e6a9-5b8d-46b1-aeae-8d6b07c3ad18.xhtml)中介绍，*学习编程POSIC和C++线程*，在那里我们将扩展此示例以创建一个能够记录多个应用程序的调试输出的日志服务器。本章的最后两个示例将演示如何使用TCP处理非字符串数据包。
- en: Trying out an example for processing packets
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试处理数据包的示例
- en: 'In this example, we will discuss how to process the following packet from the
    client to the server:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将讨论如何处理从客户端到服务器的以下数据包：
- en: '[PRE67]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The packet consists of some fixed-width integer data and a string (fields in
    a network must always be fixed width, as you might not have control of the type
    of computer your application is running on and non-fixed width types, such as
    `int` and `long`, might change depending on the computer).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包由一些固定宽度的整数数据和一个字符串组成（网络中的字段必须始终是固定宽度，因为您可能无法控制应用程序运行的计算机类型，非固定宽度类型，如`int`和`long`，可能会根据计算机而变化）。
- en: This type of packet is common among many programs, but as will be demonstrated,
    this type of packet has challenges with respect to safely parsing.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的数据包在许多程序中很常见，但正如将要演示的那样，这种类型的数据包在安全解析方面存在挑战。
- en: 'The server is identical to the previous TCP examples, minus the `recv_packet()`
    function (and the `recv()` function processes packets instead of `std::arrays`):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器与之前的TCP示例相同，减去了`recv_packet()`函数（`recv()`函数处理数据包而不是`std::arrays`）：
- en: '[PRE68]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In the `recv_packet()` function, we wait to receive data from the client. Once
    the packet is received from the client, we parse the packet received. The integer
    data associated with the packet is read and output to `stdout` without issue.
    The string data, however, is more problematic. Since we don't know the total size
    of the string data being received, we must account for the entire buffer to safely
    process the string, and in a sense, maintain type-safety. Of course, in our example,
    to reduce the total size of the packet, we could have placed the integer data
    first in the packet, and then created a variable length packet, but this is both
    unsafe and hard to control or accomplish in more complicated scenarios. Most attempts
    to solve this problem (of having to send and receive more data than is actually
    needed) result in an operation that is variable in length, and thus, unsafe.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在`recv_packet()`函数中，我们等待从客户端接收数据。一旦从客户端接收到数据包，我们就解析接收到的数据包。与数据包相关的整数数据被读取并输出到`stdout`而没有问题。然而，字符串数据更加棘手。由于我们不知道接收到的字符串数据的总大小，我们必须考虑整个缓冲区来安全地处理字符串，并在某种程度上保持类型安全。当然，在我们的示例中，为了减小数据包的总大小，我们可以先将整数数据放在数据包中，然后创建一个可变长度的数据包，但这既不安全，也难以在更复杂的情况下控制或实现。大多数解决这个问题的尝试（需要发送和接收比实际需要的更多数据）都会导致长度可变的操作，因此是不安全的。
- en: 'The rest of the server is identical to the previous examples:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的其余部分与之前的示例相同：
- en: '[PRE69]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: As shown in preceding code, the server is instantiated in a `protected_main()`
    function and the `recv_packet()` function is called.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，服务器在`protected_main()`函数中实例化，并调用`recv_packet()`函数。
- en: The client logic
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端逻辑
- en: 'The bulk of the client is also identical to the previous examples:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的大部分部分也与之前的示例相同：
- en: '[PRE70]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The `send_packet()` function is the only  part that's different from the previous
    examples (minus the fact that the `send()` function sends packets instead of a
    `std::array()`). In the `send_packet()` function, we create a packet without our
    `"Hello World"` string. It should be noted that to create this packet, we still
    require some processing, including a memory copy. Once the packet is created,
    we send it to the server for processing.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`send_packet()`函数是与之前的示例唯一不同的部分（减去`send()`函数发送的是数据包而不是`std::array()`）。在`send_packet()`函数中，我们创建一个不包含`"Hello
    World"`字符串的数据包。值得注意的是，为了创建这个数据包，我们仍然需要一些处理，包括内存复制。一旦数据包创建完成，我们就将其发送到服务器进行处理。'
- en: 'The rest of the client is identical to the previous examples:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的其余部分与之前的示例相同：
- en: '[PRE71]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The client is instantiated in a `proceted_main()` function, and the `send_packet()`
    function is executed.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端在`proceted_main()`函数中实例化，并执行`send_packet()`函数。
- en: Compiling and testing
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和测试
- en: To compile this code, we leverage the same `CMakeLists.txt` file that we have
    been using for the other examples: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译此代码，我们利用了与其他示例相同的`CMakeLists.txt`文件：[https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt)。
- en: 'With this code in place, we can compile this code using the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这段代码，我们可以使用以下命令编译这段代码：
- en: '[PRE72]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'To execute the server, run the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行服务器，运行以下命令：
- en: '[PRE73]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'To execute the client, open a new terminal and run the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行客户端，打开一个新的终端并运行以下命令：
- en: '[PRE74]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'On the server side, the following is output to `stdout`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，以下内容输出到`stdout`：
- en: '[PRE75]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: As shown in the preceding snippet, the packet data is sent by the client and
    received by the server. The total size of the packet received by the server is
    280 bytes, even though the total size of the string is far smaller. In the next
    example, we will demonstrate how marshaling packets can safely reduce the total
    size of a packet at the expense of some additional processing (although likely
    negligible depending on your use case).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的片段所示，客户端发送数据包，服务器接收。服务器接收到的数据包总大小为280字节，尽管字符串的总大小要小得多。在下一个示例中，我们将演示如何通过数据包编组安全地减小数据包的总大小，尽管这会增加一些额外的处理（尽管根据您的用例可能是可以忽略的）。
- en: Processing an example of processing JSON
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理JSON处理的示例
- en: In this final example, we will demonstrate how packets can be marshaled using
    JSON to safely reduce the size of a network packet, at the expense of some additional
    processing. To support this example, the following C++ JSON library will be used: [https://github.com/nlohmann/json](https://github.com/nlohmann/json).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个示例中，我们将演示如何使用JSON对数据包进行编组，以安全地减小网络数据包的大小，尽管这会增加一些额外的处理。为支持此示例，将使用以下C++
    JSON库：[https://github.com/nlohmann/json](https://github.com/nlohmann/json)。
- en: 'To incorporate this JSON library into our example, the following will have
    to be added to our `CMakeLists.txt`, which downloads this header-only library
    and installs it into our build folder to be used:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此JSON库纳入我们的示例中，需要将以下内容添加到我们的`CMakeLists.txt`中，该文件将下载这个仅包含头文件的库并将其安装到我们的构建文件夹中以供使用：
- en: '[PRE76]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Server
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器
- en: 'The server includes and macros are the same, with the exception that JSON must
    be added, as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器包括和宏是一样的，唯一的区别是必须添加JSON，如下所示：
- en: '[PRE77]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The server in this example is identical to the previous examples, with the
    exception of the `recv_packet()` function:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，服务器与之前的示例相同，唯一的区别是`recv_packet()`函数：
- en: '[PRE78]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: In the `recv_packet()` function, we need to allocate a buffer with some maximum
    size; this buffer is not required to be received in full, but rather is a placeholder
    for our JSON buffer, which could be any size up to our maximum. Parsing the JSON
    data is simple. The integer data and the string data are safely parsed into their
    integer and `std::string` types, respectively, all adhering to the C++ Core Guidelines
    in the process. The code is simple to read and follow, and the packet can be changed
    in the future without having to change any additional logic.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在`recv_packet()`函数中，我们需要分配一个具有一定最大大小的缓冲区；这个缓冲区不需要完全接收，而是作为我们的JSON缓冲区的占位符，其大小可以达到我们的最大值。解析JSON数据很简单。整数数据和字符串数据都被安全地解析为它们的整数和`std::string`类型，都遵循C++核心指南。代码易于阅读和理解，未来可以更改数据包而无需更改任何其他逻辑。
- en: 'The rest of the server is identical:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的其余部分是相同的：
- en: '[PRE79]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The server is instantiated in a `protected_main()` function and the `recv_packet()`
    function is called.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器在`protected_main()`函数中实例化，然后调用`recv_packet()`函数。
- en: The client logic
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端逻辑
- en: 'Like the server, the client must also include the JSON header:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务器一样，客户端也必须包括JSON头：
- en: '[PRE80]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'As with the server, the client is the same as the previous examples, minus
    the `send_packet()` function:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务器一样，客户端与之前的示例相同，只是没有`send_packet()`函数：
- en: '[PRE81]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The `send_packet()` function is equally simple. A JSON packet is constructed
    and sent to the server. The difference is that the packet is marshaled into a
    JSON string before being sent (using the `dump()` function). This converts all
    of the data into a single string with special syntax to define the start and end
    of each field in a well-established, well-tested fashion to prevent unsafe parsing.
    In addition, as will be shown shortly, the total number of bytes being sent is
    dramatically reduced.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`send_packet()`函数同样简单。构造一个JSON数据包并发送到服务器。不同之处在于，在发送之前将数据包编组成JSON字符串（使用`dump()`函数）。这将把所有数据转换为一个字符串，其中包含特殊语法来定义每个字段的开始和结束，以防止不安全的解析，以一种经过良好建立和测试的方式。此外，如将很快展示的那样，发送的字节数总量大大减少。'
- en: 'The rest of the client is identical:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的其余部分是相同的：
- en: '[PRE82]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The client is instantiated in a `protected_main()` function, and the `send_packet()`
    function is called.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端在`protected_main()`函数中实例化，并调用`send_packet()`函数。
- en: Compiling and testing
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和测试
- en: To compile this code, we leverage the same `CMakeLists.txt` file that we have
    been using for the other examples: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译这些代码，我们利用了与其他示例相同的`CMakeLists.txt`文件：[https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt)。
- en: 'With this code in place, we can compile this code using the following:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些代码，我们可以使用以下命令编译这些代码：
- en: '[PRE83]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'To execute the server, run the following:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行服务器，请运行以下命令：
- en: '[PRE84]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'To execute the client, open a new terminal and run the following:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行客户端，请打开一个新的终端并运行以下命令：
- en: '[PRE85]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'On the server side, the following is output to `stdout`:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，将以下内容输出到`stdout`：
- en: '[PRE86]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: As shown in the preceding snippet, the packet data is sent by the client and
    received by the server. The total size of the packet received by the server is
    43 bytes, which is 6.5 times more efficient compared to the previous example.
    In addition to providing a smaller packet, the logic for creating and parsing
    the packet is similar, and easier to read and modify in the future. Furthermore,
    with things such as JSON Schema, packets may even be validated prior to processing,
    a topic outside the scope of this book.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的片段所示，客户端发送数据包，服务器接收数据包。服务器接收的数据包总大小为43字节，与之前的示例相比，效率提高了6.5倍。除了提供更小的数据包外，创建和解析数据包的逻辑相似，未来更改也更容易阅读和修改。此外，使用JSON
    Schema等内容，甚至可以在处理之前验证数据包，这是本书范围之外的主题。
- en: Summary
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to program POSIX sockets using C++17\. Specifically,
    we learned the common APIs associated with POSIX sockets, and how to use them.
    We concluded this chapter with five different examples. The first example created
    a UDP echo server, while the second example created a similar echo server using
    TCP instead of UDP, outlining the differences between the different approaches.
    The third example expanded upon our debug example by adding a server component
    to our debugger. The fourth and fifth examples demonstrated how to process a simple
    network packet, and the benefits of using marshaling to simplify the process.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用C++17编程POSIX套接字。具体来说，我们学习了与POSIX套接字相关的常见API，并学习了如何使用它们。我们用五个不同的示例结束了本章。第一个示例创建了一个UDP回显服务器，而第二个示例创建了一个类似的回显服务器，但使用的是TCP而不是UDP，概述了不同方法之间的区别。第三个示例通过向我们的调试器添加服务器组件来扩展了我们的调试示例。第四和第五个示例演示了如何处理简单的网络数据包，以及使用编组来简化该过程的好处。
- en: In the next chapter, we will discuss the C and C++ time interfaces that can
    be used to get the wall clock, measure elapsed time and perform benchmarking.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论可用于获取挂钟时间、测量经过的时间和执行基准测试的C和C++时间接口。
- en: Questions
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the main difference between UDP and TCP?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: UDP和TCP之间的主要区别是什么？
- en: What protocol type does UDP use?
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: UDP使用什么协议类型？
- en: What protocol type does TCP use?
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TCP使用什么协议类型？
- en: What address type does `AF_INET` represent?
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AF_INET`代表什么地址类型？'
- en: What is the difference between `bind()` and `connect()`?
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bind()`和`connect()`之间有什么区别？'
- en: What is the difference between `sendto()` and `send()`?
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sendto()`和`send()`之间有什么区别？'
- en: How does a UDP server detect when a UDP client is dropped or crashed?
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: UDP服务器如何检测UDP客户端何时断开或崩溃？
- en: What are the benefits of using packet marshaling?
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用数据包编组的好处是什么？
- en: Further reading
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)'
- en: '[https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)'
