- en: Building on the Game Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于 Game 对象构建
- en: n the last chapter, we looked at how to draw basic shapes using OpenGL. Now
    that we have covered the basics, let's improve our objects by adding some textures
    to them so that the objects don't just look like a plain cube and sphere.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章，我们探讨了如何使用OpenGL绘制基本形状。现在我们已经掌握了基础知识，让我们通过给对象添加一些纹理来提高它们，这样对象就不会仅仅看起来像一个普通的立方体和球体。
- en: We can write our physics as we did last time, but when dealing with 3D objects,
    writing our own physics can become difficult and time consuming. To simplify the
    process, we will use the help of an external physics library to handle the physics
    and collision detection.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像上次那样编写我们的物理代码，但是当处理3D对象时，编写自己的物理代码可能会变得困难且耗时。为了简化过程，我们将使用外部物理库来处理物理和碰撞检测。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中涵盖以下主题：
- en: Creating the `MeshRenderer` class
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `MeshRenderer` 类
- en: Creating the `TextureLoader` class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `TextureLoader` 类
- en: Adding Bullet Physics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 Bullet 物理引擎
- en: Adding rigid bodies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加刚体
- en: Creating the MeshRenderer class
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 `MeshRenderer` 类
- en: For drawing regular game objects, we will create a separate class from the `LightRenderer`
    class by adding texture, and we will also add motion to the object by adding physical
    properties. We will draw a textured object and then add physics to this object
    in the next section of this chapter. To do this, we will create a new `.h` and
    `.cpp` file called `MeshRenderer`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于绘制常规游戏对象，我们将从 `LightRenderer` 类中创建一个单独的类，通过添加纹理，并且我们还将通过添加物理属性来给对象添加运动。我们将在本章的下一节中绘制一个纹理对象，并给这个对象添加物理。为此，我们将创建一个新的
    `.h` 和 `.cpp` 文件，名为 `MeshRenderer`。
- en: 'In the `MeshRenderer.h` file, we will do the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MeshRenderer.h` 文件中，我们将执行以下操作：
- en: 'First, we will add the includes as follows:'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将添加以下包含：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we will create the class itself as follows:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建类本身，如下所示：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will create the `public` section first as follows:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建 `public` 部分，如下所示：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this section, we create the constructor, which takes a `ModelType` and the
    `_camera`. We add the destructor afterward. We have a separate function for drawing
    the object.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建一个构造函数，它接受 `ModelType` 和 `_camera`。之后，我们添加析构函数。我们有一个单独的函数用于绘制对象。
- en: We then use some `setter` functions to set the position, scale, the shader program,
    and the `textureID` function , which we will be using to set the texture on the
    object.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们使用一些 `setter` 函数来设置位置、缩放、着色器程序以及 `textureID` 函数，我们将使用它来设置对象上的纹理。
- en: 'Next, we will add the `private` section as follows:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加 `private` 部分，如下所示：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the `private` section, we have vectors to store the vertices and the indices.
    Then, we have a `glm::mat4` variable called `modelMatrix` to store the model matrix
    value in.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `private` 部分，我们有向量来存储顶点和索引。然后，我们有一个名为 `modelMatrix` 的 `glm::mat4` 变量，用于存储模型矩阵值。
- en: We create a local variable for the camera and `vec3s` for storing the position
    and scale value.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为相机创建一个局部变量，并为存储位置和缩放值创建 `vec3s`。
- en: Finally, we have `Gluint` to store `vao`, `vbo`, `ebo`, `textureID`, and the
    shader program.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有 `Gluint` 来存储 `vao`、`vbo`、`ebo`、`textureID` 和着色器程序。
- en: 'We will now move on to setting up the `MeshRenderer.cpp` file by going through
    the following steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将接着通过以下步骤来设置 `MeshRenderer.cpp` 文件：
- en: First, we will include the `MeshRenderer.h` file at the top of `MeshRenderer.cpp`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将在 `MeshRenderer.cpp` 的顶部包含 `MeshRenderer.h` 文件。
- en: 'Next, we will create the constructor for `MeshRenderer` as follows:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为 `MeshRenderer` 创建构造函数，如下所示：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For this, we first initialize the `camera`, `position`, and `scale` local values
    as follows:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了这个，我们首先初始化 `camera`、`position` 和 `scale` 本地值，如下所示：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then we create a `switch` statement, as we did in `LightRenderer`, to get the
    mesh data, as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建一个 `switch` 语句，就像我们在 `LightRenderer` 中做的那样，以获取网格数据，如下所示：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we generate and bind `vao`, `vbo`, and `ebo`. In addition to this, we
    set the data for `vbo` and `ebo` as follows:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们生成并绑定 `vao`、`vbo` 和 `ebo`。此外，我们按照以下方式设置 `vbo` 和 `ebo` 的数据：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The next step is to set the attributes. In this case, we will be setting the
    `position` attribute, but instead of color, we will set the texture coordinate
    attribute, as it will be required to set the texture on top of the object.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是设置属性。在这种情况下，我们将设置 `position` 属性，但不是颜色，我们将设置纹理坐标属性，因为它将用于在对象上设置纹理。
- en: 'The attribute at the 0th index will still be a vertex position, but the attribute
    of the first index will be a texture coordinate this time, as shown in the following
    code:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 0索引处的属性仍然是一个顶点位置，但这次第一个索引处的属性将是一个纹理坐标，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, the attribute for the vertex position remains the same, but for the texture
    coordinate, the first index is enabled as before. The change occurs in the number
    of components. The texture coordinate is defined in the *x*- and *y*-axes, as
    this is a 2D texture, so for the second parameter, we specify `2` instead of `3`.
    The stride still remains the same, but the offset is changed to `texCoords`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，顶点位置的属性保持不变，但对于纹理坐标，第一个索引如之前一样被启用。变化发生在组件数量上。纹理坐标在*x*轴和*y*轴上定义，因为这是一个2D纹理，所以对于第二个参数，我们指定`2`而不是`3`。步长仍然保持不变，但偏移量改为`texCoords`。
- en: 'To close the constructor, we unbind the buffers and `vertexArray` as follows:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了关闭构造函数，我们解绑缓冲区和`vertexArray`，如下所示：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We now add the `draw` function as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在添加`draw`函数，如下所示：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this `draw` function, we will first set the model matrix as follows:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个`draw`函数中，我们首先将模型矩阵设置为以下内容：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We will create two matrices for storing `translationMatrix` and `scaleMatrix`
    and then we set the values.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建两个矩阵来存储`translationMatrix`和`scaleMatrix`，然后设置它们的值。
- en: We will then initialize the `modelMatrix` variable and the multiply scale and
    translation matrix and assign them to the `modelMatrix` variable.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将初始化`modelMatrix`变量，将缩放和变换矩阵相乘，并将它们赋值给`modelMatrix`变量。
- en: 'Next, instead of creating a separate view and projection matrix, we can create
    a single matrix called `vp` and assign the multiplied view and projection matrices
    to it as follows:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们不再创建单独的视图和投影矩阵，而是可以创建一个名为`vp`的单个矩阵，并将乘积的视图和投影矩阵赋值给它，如下所示：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Obviously, the order in which the view and projection matrices are multiplied
    matters and cannot be reversed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，视图和投影矩阵相乘的顺序很重要，不能颠倒。
- en: We can now send the values to the GPU.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以将值发送到GPU。
- en: 'Before we send the values to the shader, the first thing we have to do is call
    `glUseProgram` and set the shader program so that the data is sent to the correct
    program. Once this is complete, we can set the values for `vp` and `modelMatrix`
    as follows:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们将值发送到着色器之前，我们必须做的第一件事是调用`glUseProgram`并设置着色器程序，以便数据被发送到正确的程序。一旦完成，我们就可以设置`vp`和`modelMatrix`的值，如下所示：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we will bind the `texture` object. We use the `glBindTexture` function
    to bind the texture. The function takes two parameters, with the first being the
    texture target. We have a 2D texture, so we pass in `GL_TEXTURE_2D` as the first
    parameter and the second parameter as a texture ID. To do this, we add the following
    line to bind the texture:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将绑定`texture`对象。我们使用`glBindTexture`函数来绑定纹理。该函数接受两个参数，第一个是纹理目标。我们有一个2D纹理，因此我们将`GL_TEXTURE_2D`作为第一个参数传递，并将纹理ID作为第二个参数。为此，我们添加以下行来绑定纹理：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You might be wondering why we aren't using `glUniformMatrix4fv` or something
    similar while setting the texture location, as we did for the matrices. Well,
    since we have just the one texture, the program sets the uniform location as the
    0th index by default so we don't have to worry about it. This all that we require
    to bind the texture.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么在设置纹理位置时我们没有使用`glUniformMatrix4fv`或类似函数，就像我们为矩阵所做的那样。嗯，因为我们只有一个纹理，程序默认将统一位置设置为0索引，所以我们不必担心这一点。这就是我们绑定纹理所需的所有内容。
- en: 'Next, we can bind the `vao` and draw the object as follows:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以绑定`vao`并绘制对象，如下所示：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Unbind the `VertexArray` at the end as follows:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，按照以下方式解绑`VertexArray`：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we will add the definition for the destructor and `setters` as follows:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加析构函数和`setters`的定义，如下所示：
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Creating the TextureLoader class
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建TextureLoader类
- en: We created the `MeshRenderer` class, but we still need to load the texture and
    set the texture ID, which can be passed to the `MeshRendered` object. For this,
    we will create a `TextureLoader` class that will be responsible for loading the
    textures. Let's see how to do this.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了`MeshRenderer`类，但我们仍然需要加载纹理并设置纹理ID，这可以传递给`MeshRenderer`对象。为此，我们将创建一个`TextureLoader`类，该类将负责加载纹理。让我们看看如何做到这一点。
- en: We first need to create the new `.h` and `.cpp` file called `TextureLoader`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要创建一个新的`.h`和`.cpp`文件，名为`TextureLoader`。
- en: To load the JPEG or PNG image, we will use a header-only library called STB.
    This can be downloaded from [https://github.com/nothings/stb](https://github.com/nothings/stb).
    Clone or download the source from the link and place the `stb-master` folder in
    the `Dependencies` folder.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载JPEG或PNG图像，我们将使用一个仅包含头文件的库，称为STB。可以从[https://github.com/nothings/stb](https://github.com/nothings/stb)下载。从链接克隆或下载源代码，并将`stb-master`文件夹放置在`Dependencies`文件夹中。
- en: 'In the `TextureLoader` class, add the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TextureLoader`类中，添加以下内容：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We will then use the `string` and `glew.h` libraries, as we will be passing
    the location of the file where the JPEG is located and `STB` will load the file
    from there. We will add a constructor and a destructor as they are required; otherwise,
    the compiler will give an error. We will then create a function called `getTextureID`,
    which takes a string as an input and returns `GLuint`, which will be the texture
    ID.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用`string`和`glew.h`库，因为我们将会传递JPEG所在文件的路径，`STB`将从那里加载文件。我们将添加构造函数和析构函数，因为它们是必需的；否则，编译器会给出错误。然后，我们将创建一个名为`getTextureID`的函数，它接受一个字符串作为输入并返回`GLuint`，这将作为纹理ID。
- en: 'In the `TextureLoader.cpp` file, we include `TextureLoader.h`. We then add
    the following to include `STB`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TextureLoader.cpp`文件中，我们包含了`TextureLoader.h`。然后添加以下代码以包含`STB`：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We add `#define` as it is required in a `TextureLoader.cpp` file, navigate
    to `stb_image.h`, and include it in the project. We then add the constructor and
    destructor as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加`#define`，因为它在`TextureLoader.cpp`文件中是必需的，导航到`stb_image.h`，并将其包含到项目中。然后添加构造函数和析构函数，如下所示：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we create the `getTextureID` function as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建`getTextureID`函数，如下所示：
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the `getTextureID` function, we will first create three `int` variables
    to store the width, height, and number of channels. An image usually only has
    three channels: red, green, and blue. However, it could have a fourth channel,
    the alpha channel, which is used for transparency. JPEG pictures have only three
    channels, but the PNG file could have three or four channels.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getTextureID`函数中，我们首先创建三个`int`变量来存储宽度、高度和通道数。图像通常只有三个通道：红色、绿色和蓝色。然而，它可能有一个第四个通道，即alpha通道，用于透明度。JPEG图片只有三个通道，但PNG文件可能有三个或四个通道。
- en: 'In our game, we will only be using a JPEG file, so the `channels` parameter
    will always be three, as shown in the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，我们只会使用JPEG文件，因此`channels`参数始终为三个，如下代码所示：
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will use the `stbi_load` function to load the image data to an unsigned
    char pointer, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`stbi_load`函数将图像数据加载到无符号字符指针中，如下所示：
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The function takes five parameters. The first is the string of the location
    of the file/filename. Then, it returns the width, height, and number of channels
    as the second, third, and fourth parameters, and in the fifth parameter, you set
    the required components. In this case, we want just the `r`, `g`, and `b` channels,
    so we specify `STBI_rgb`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 函数接受五个参数。第一个是文件/文件名的字符串。然后，它作为第二、第三和第四个参数返回宽度、高度和通道数，并在第五个参数中设置所需的组件。在这种情况下，我们只想有`r`、`g`和`b`通道，所以我们指定`STBI_rgb`。
- en: 'We then have to generate and bind the texture as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须按照以下方式生成和绑定纹理：
- en: '[PRE24]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: First, a texture ID called `mtexture` of the `GLuint` type is created. Then,
    we call the `glGenTextures` function, pass in the number of objects we want to
    create, and pass in the array names, which is `mtexture`. We also have to bind
    the texture type by calling `glBindTexture` and pass in the texture type, which
    is `GL_TEXTURE_2D`, specifying that it is a 2D texture and stating the texture
    ID.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个名为`mtexture`的`GLuint`类型的纹理ID。然后，我们调用`glGenTextures`函数，传入我们想要创建的对象数量，并传入数组名称，即`mtexture`。我们还需要通过调用`glBindTexture`并传入纹理类型来绑定纹理类型，即`GL_TEXTURE_2D`，指定它是一个2D纹理，并声明纹理ID。
- en: Next, we have to set the texture wrapping. Texture wrapping dictates what happens
    when the texture coordinate is greater or less than `1` in *x* and *y*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须设置纹理包裹。纹理包裹决定了当纹理坐标在*x*和*y*方向上大于或小于`1`时会发生什么。
- en: 'Textures can be wrapped in one of four ways: `GL_REPEAT`, `GL_MIRRORED_REPEAT`,
    `GL_CLAMP_TO_EDGE`, or `GL_CLAMP_TO_BORDER`.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理可以以四种方式之一进行包裹：`GL_REPEAT`、`GL_MIRRORED_REPEAT`、`GL_CLAMP_TO_EDGE`或`GL_CLAMP_TO_BORDER`。
- en: 'If we imagine a texture applied to a quad, then the positive *s**-*axis runs
    horizontally and the *t*-axis runs vertically, starting at the origin (the bottom-left
    corner), as shown in the following screenshot:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想象一个纹理被应用到四边形上，那么正的*s*轴水平运行，而*t*轴垂直运行，从原点（左下角）开始，如下面的截图所示：
- en: '![](img/4d8df6ec-bef3-40c7-95b5-795dd859db2b.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d8df6ec-bef3-40c7-95b5-795dd859db2b.png)'
- en: 'Let''s look at the different ways that the textures can be wrapped, as shown
    in the following list:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看纹理可以如何被包裹的不同方式，如下列所示：
- en: '`GL_REPEAT` just repeats the texture when applied to a quad.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GL_REPEAT` 在应用于四边形时只是重复纹理。'
- en: '`GL_MIRRORER_REPEAT` repeats the texture, but also mirrors the texture the
    next time.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GL_MIRROR_MIRROR_REPEAT` 重复纹理，但下一次也会镜像纹理。'
- en: '`GL_CLAMP_TO_EDGE` takes the `rgb` value at the edge of the texture and repeats
    the value for the entire object. In the following screenshot, the red border pixels
    are repeated.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GL_CLAMP_TO_EDGE` 将纹理边缘的 `rgb` 值重复应用于整个对象。在下面的截图中，红色边缘像素被重复。'
- en: '`GL_CLAMP_TO_BORDER` takes a user-specific value and applies it to the end
    of the object instead of applying the edge color, as shown in the following screenshot:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GL_CLAMP_TO_BORDER` 采用用户特定的值并将其应用于对象的末端，而不是应用边缘颜色，如下面的截图所示：'
- en: '![](img/4d87c32b-008b-4a1c-8d45-e3446ca4d721.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d87c32b-008b-4a1c-8d45-e3446ca4d721.png)'
- en: 'For our purposes, we need `GL_REPEAT`, which is set as the default anyway,
    but if you had to set it, you will need to add the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们需要 `GL_REPEAT`，这已经是默认设置，但如果你必须设置它，你需要添加以下内容：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You use the `glTexParameteri` function, which takes three parameters. The first
    is the texture type, which is `GL_TEXTURE_2D`. The next parameter is the direction
    in which you want the wrapping to apply, which is `S` or `T`. The `S` direction
    is the same as *x* and `T` is the same as *y*. The last parameter is the wrapping
    parameter itself.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用 `glTexParameteri` 函数，它接受三个参数。第一个是纹理类型，即 `GL_TEXTURE_2D`。下一个参数是你想要应用包裹方向的参数，即
    `S` 或 `T`。`S` 方向与 *x* 相同，`T` 与 *y* 相同。最后一个参数是包裹参数本身。
- en: 'Next, we can set the texture filtering. Sometimes, when you apply a low-quality
    texture to a big quad, if you zoom in closer, the texture will be pixelated, as
    shown in the left-hand picture in the following screenshot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以设置纹理过滤。有时，当你将低质量纹理应用于大四边形时，如果你放大查看，纹理将会出现像素化，如下面截图的左侧所示：
- en: '![](img/9d41fb43-47e4-4d47-9ae8-495d188392d7.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d41fb43-47e4-4d47-9ae8-495d188392d7.png)'
- en: The picture on the left is the output of setting the texture filtering to `GL_NEAREST`,
    and the picture on the right is the result of applying texture filtering to `GL_LINEAR`. The `GL_LINEAR`
    wrapping linearly interpolates with the texel value of the surrounding values
    to give a much smoother result when compared to `GL_NEAREST`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的图片是设置纹理过滤为 `GL_NEAREST` 的输出，右侧的图片是应用纹理过滤到 `GL_LINEAR` 的结果。`GL_LINEAR` 包裹线性插值周围的纹理元素值，与
    `GL_NEAREST` 相比，给出了更平滑的结果。
- en: When the texture is magnified, it is better to set the value to `GL_LINEAR`
    to get a smoother picture, and when the picture is minimized, it can then be set
    to `GL_NEAREST`, as the texels (which are texture elements) will be so small that
    we won't be able to see them anyway.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当纹理被放大时，最好将值设置为 `GL_LINEAR` 以获得更平滑的图像，而当图像被缩小时，可以将其设置为 `GL_NEAREST`，因为纹理元素（即纹理元素）将非常小，我们无论如何都看不到它们。
- en: 'To set the texture filtering, we use the same `glTexParameteri` function, but
    instead of passing in the wrapping direction as the second parameter we specify
    `GL_TEXTURE_MIN_FILTER` and `GL_TEXTURE_MAG_FILTER` as the second parameter and
    pass in `GL_NEAREST` or `GL_LINEAR` as the third parameter, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置纹理过滤，我们使用相同的 `glTexParameteri` 函数，但不是将包裹方向作为第二个参数传递，而是指定 `GL_TEXTURE_MIN_FILTER`
    和 `GL_TEXTURE_MAG_FILTER` 作为第二个参数，并将 `GL_NEAREST` 或 `GL_LINEAR` 作为第三个参数，如下所示：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It doesn't make sense to load a huge image with the object so far away that
    you can't even see it, so for optimization purposes, you can create mipmaps. Mipmaps
    basically take the texture and converts it to a lower resolution. This will automatically
    change the image to a lower resolution image when the texture is too far away
    from the camera. It will also change to a higher resolution image when the camera
    is closer.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 加载一个巨大的图像与对象如此之远以至于你甚至看不到它是没有意义的，因此出于优化的目的，你可以创建米普图。米普图基本上是将纹理转换为较低的分辨率。当纹理远离相机时，它将自动将图像转换为较低的分辨率图像。当相机更近时，它也会转换为较高的分辨率图像。
- en: 'Here is the mipmap chain for the texture we are using:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们所使用纹理的米普链：
- en: '![](img/e794d3ff-8581-4313-b14c-52eafa2f18ef.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e794d3ff-8581-4313-b14c-52eafa2f18ef.png)'
- en: The mipmap quality can be set using the `glTexParameteri` function again. This
    basically replaces `GL_NEAREST` with either `GL_NEAREST_MIPMAP_NEAREST`, `GL_LINEAR_MIPMAP_NEAREST`,
    `GL_NEAREST_MIPMAP_LINEAR`, or `GL_LINEAR_ MIPMAP_LINEAR`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`glTexParameteri`函数再次设置米普图质量。这基本上是用`GL_NEAREST`替换为`GL_NEAREST_MIPMAP_NEAREST`、`GL_LINEAR_MIPMAP_NEAREST`、`GL_NEAREST_MIPMAP_LINEAR`或`GL_LINEAR_MIPMAP_LINEAR`。
- en: The best option is `GL_LINEAR_MIPMAP_LINEAR` because it linearly interpolates
    the value of the texel between two mipmaps, as well as samples, by linearly interpolating
    between the surrounding texels (a texel is the lowest unit of an image in the
    same way that a pixel is the smallest unit of a screen to represent a color at
    a location on the screen. If a 1080p picture is shown on a 1080p screen, then
    1 texel is mapped to 1 pixel).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳选项是`GL_LINEAR_MIPMAP_LINEAR`，因为它在两个米普图中以及样本之间线性插值了纹理单元的值，同样也在周围的纹理单元之间进行线性插值（纹理单元是图像中最低的单位，就像像素是屏幕上表示颜色的最小单位一样。如果在一台1080p的屏幕上显示一张1080p的图片，那么1个纹理单元就映射到1个像素）。
- en: 'So, we will use the following as our new filtering/mipmap values:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将使用以下作为我们新的过滤/米普图值：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once this has been set, we can finally create the texture using the `glTexImage2D`
    function, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置完毕，我们就可以最终使用`glTexImage2D`函数创建纹理，如下所示：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `glTexImage2D` function takes nine parameters. These are described as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`glTexImage2D`函数接受九个参数。这些参数如下所述：'
- en: The first is the texture type, which is `GL_TEXTURE_2D`.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是纹理类型，它是`GL_TEXTURE_2D`。
- en: The second is the mipmap level. If we want to use a lower quality picture, we
    can set this value to `1`, `2`, or `3`. For our purposes, we will leave this value
    as `0`, which is the base level.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个是米普图级别。如果我们想使用较低质量的图片，可以将此值设置为`1`、`2`或`3`。为了我们的目的，我们将保留此值为`0`，这是基本级别。
- en: For the third parameter, we will specify which all-color channels we want to
    store from the image. Since we want to store all three channels, we specify `GL_RGB`.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第三个参数，我们将指定我们想要从图像中存储的所有全色通道。由于我们想要存储所有三个通道，我们指定`GL_RGB`。
- en: The fourth and fifth parameters that we specify are the width and height of
    the picture.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们指定的第四和第五个参数是图片的宽度和高度。
- en: The next parameter has to be set to `0`, as specified in the documentation (which
    can be found at [https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage2D.xhtml](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage2D.xhtml)).
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个参数必须设置为`0`，如文档中指定（文档可以在[https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage2D.xhtml](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage2D.xhtml)找到）。
- en: The next parameter that we specify is the data format of the image source.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们指定的下一个参数是图像源的数据格式。
- en: The next parameter is the type of data that is passed in, which is `GL_UNSIGNED_BYTE`.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个参数是传入的数据类型，它是`GL_UNSIGNED_BYTE`。
- en: Finally, we set the image data.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们设置图像数据。
- en: 'Now that the texture is created, we call `glGenerateMipmap` and pass in the
    `GL_TEXTURE_2D` texture type, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在纹理已经创建，我们调用`glGenerateMipmap`并传入`GL_TEXTURE_2D`纹理类型，如下所示：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We then unbind the texture, free the picture, and finally return the `textureID` function
    like so:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们解绑纹理，释放图片，并最终像这样返回`textureID`函数：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With all that done, we call finally add our texture to the game object.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的这些工作完成后，我们最终将我们的纹理添加到游戏对象中。
- en: 'In the `source.cpp`, include `MeshRenderer.h` and `TextureLoader.h` by going
    through  the following steps:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在`source.cpp`中，通过以下步骤包含`MeshRenderer.h`和`TextureLoader.h`：
- en: 'At the top, create a `MeshRenderer` pointer object called a sphere as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部，创建一个名为球体的`MeshRenderer`指针对象，如下所示：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the `init` function, create a new shader program called `texturedShaderProgram`
    of the `GLuint` type as follows:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`init`函数中，创建一个新的`GLuint`类型的着色器程序，名为`texturedShaderProgram`，如下所示：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We will now load the two shaders called `TexturedModel.vs` and `TexturedModel.fs` as
    follows:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将加载两个名为`TexturedModel.vs`和`TexturedModel.fs`的着色器，如下所示：
- en: 'Here is the `TexturedModel.vs` shader:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里是`TexturedModel.vs`着色器：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The only difference between this and `FlatModel.vs` is that here, the second
    location is a `vec2` called `texCoord`. We create an out `vec2` called `TexCoord`,
    into which we will store this value in the `main` function.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与`FlatModel.vs`的唯一区别是，在这里，第二个位置是一个名为`texCoord`的`vec2`。我们在`main`函数中创建一个输出`vec2`，名为`TexCoord`，我们将在这个值中存储这个值。
- en: 'Here is the `TexturedModel.fs` shader:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里是`TexturedModel.fs`着色器：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We create a new `vec2` called `TexCoord` to receive the value from the vertex
    shader.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个新的`vec2`，名为`TexCoord`，以接收从顶点着色器传来的值。
- en: We then create a new uniform type called `sampler2D` and call it `Texture`.
    The texture is received through a sampler that will be used to sample the texture
    depending upon the wrap and filtering parameters we set while creating the texture.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个新的统一类型`sampler2D`，并命名为`Texture`。纹理通过一个采样器接收，该采样器将根据我们在创建纹理时设置的包装和过滤参数来采样纹理。
- en: Then, the color is set depending upon the sampler and texture coordinates using
    the `texture` function. This function takes sampler and texture coordinates as
    parameters. The texel at a texture coordinate is sampled based on the sampler,
    and that color value is returned and assigned to the object at that texture coordinate.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，根据采样器和纹理坐标使用`texture`函数设置颜色。此函数将采样器和纹理坐标作为参数。根据采样器，在纹理坐标处的texel被采样，并返回该颜色值，并将其分配给该纹理坐标处的对象。
- en: 'Let''s continue creating the `MeshRenderer` object. Load the `globe.jpg` texture file
    using the `getTextureID` function of the `TextureLoader` class and set it to a
    `GLuint` called `sphereTexture` as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建`MeshRenderer`对象。使用`TextureLoader`类的`getTextureID`函数加载`globe.jpg`纹理文件，并将其设置为名为`sphereTexture`的`GLuint`，如下所示：
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create the sphere `MeshRederer` object, set the mesh type, and pass the camera.
    Set the program, texture, position, and scale as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 创建球体`MeshRederer`对象，设置网格类型，并传递摄像机。设置程序、纹理、位置和缩放，如下所示：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the `renderScene` function, draw the `sphere` object as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在`renderScene`函数中，按照以下方式绘制`sphere`对象：
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You should now see the textured globe when you run the project, as shown in
    the following screenshot:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目后，您应该会看到带有纹理的地球，如下面的截图所示：
- en: '![](img/9ef6e337-5eec-4eec-8aa6-9d83485789fe.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/9ef6e337-5eec-4eec-8aa6-9d83485789fe.png)'
- en: 'The camera is created as follows, and is set at the *z* position of four units:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 摄像机创建如下，并将其设置为四单位的*z*位置：
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Adding Bullet Physics
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Bullet物理
- en: To add physics to our game, we will be using the Bullet Physics engine. This
    is an open source project that is widely used in AAA games and movies. It is used
    for collision detection as well as soft- and rigid-body dynamics. The library
    is free for commercial use.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要将物理元素添加到我们的游戏中，我们将使用Bullet物理引擎。这是一个开源项目，在AAA游戏和电影中得到了广泛应用。它用于碰撞检测以及软体和刚体动力学。该库对商业用途免费。
- en: Download the source from [https://github.com/bulletphysics/bullet3](https://github.com/bulletphysics/bullet3) ,
    and using CMake you will need to build the project for the release version of
    x64\. For your convenience, the header and `lib` files are included in the project
    for the chapter. You can take the folder and paste it into the `dependencies`
    folder.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 从[https://github.com/bulletphysics/bullet3](https://github.com/bulletphysics/bullet3)下载源代码，并使用CMake构建x64的发布版本项目。为了方便起见，该章节的项目中包含了头文件和`lib`文件。您可以将文件夹复制并粘贴到`dependencies`文件夹中。
- en: 'Now that we have the folder, let''s take a look at how to add Bullet Physics
    by following these steps:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了文件夹，让我们看看如何按照以下步骤添加Bullet物理：
- en: 'Add the `include` folder in C/C++ | General | Additional Include Directories as
    shown in the following screenshot:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下截图所示，将`include`文件夹添加到“C/C++ | 一般 | 额外包含目录”：
- en: '![](img/76e2dde2-5097-4e5e-bf7f-6eed3826eaaa.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/76e2dde2-5097-4e5e-bf7f-6eed3826eaaa.png)'
- en: 'Add the `lib/win64/Rls` folder in Linker | General | Additional Library Directories:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在链接器设置中，将`lib/win64/Rls`文件夹添加到“链接器 | 一般 | 额外库目录”：
- en: '![](img/51590433-e7ac-4e36-b063-09cac2f2fbb6.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/51590433-e7ac-4e36-b063-09cac2f2fbb6.png)'
- en: 'Add `BulletCollision.lib`, `BulletDynamics.lib`, and `LinearMath.lib` to Linker
    | Input | Additional Dependencies, as shown in the following screenshot:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`BulletCollision.lib`、`BulletDynamics.lib`和`LinearMath.lib`添加到“链接器 | 输入 | 额外依赖项”，如下面的截图所示：
- en: '![](img/1369c25b-a19e-4dd4-b3f7-b0f325fbf94f.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/1369c25b-a19e-4dd4-b3f7-b0f325fbf94f.png)'
- en: These libraries are responsible for the calculation of the movement of the game
    objects based on conditions such as gravity and external force, collision detection,
    and memory allocation.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这些库负责根据重力、外力等条件计算游戏对象的运动，进行碰撞检测和内存分配。
- en: 'With the prep work out of the way, we can start adding physics to the game.
    In the `source.cpp` file, include `btBulletDynamicsCommon.h` at the top of the
    file, as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备工作完成之后，我们就可以开始将物理元素添加到游戏中了。在`source.cpp`文件中，将`btBulletDynamicsCommon.h`包含在文件顶部，如下所示：
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'After this, create a new pointer object to `btDiscreteDynamicsWorld` as follows:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个新的指向`btDiscreteDynamicsWorld`的指针对象，如下所示：
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This object keeps track of all the physics settings and objects in the current
    scene.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此对象跟踪当前场景中所有物理设置和对象。
- en: However, before we create `dynamicWorld`, the Bullet Physics library requires
    some objects to be initialized first.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在创建`dynamicWorld`之前，Bullet物理库需要首先初始化一些对象。
- en: 'These required objects are listed as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这些必需的对象如下列出：
- en: '`btBroadPhaseInerface`: Collision detection is actually done in two phases: `broadphase`
    and `narrowphase`. In the `broadphase`, the physics engine eliminates all the
    objects that are unlikely to collide. This check is done using the objects'' bounding
    boxes. Then, in the `narrowphase`, the actual shape of the object is used to check
    the likelihood of a collision. Pairs of objects are created with a strong likelihood
    of collision. In the following screenshot, the red box around the sphere is used
    for `broadphase` collision and the white wiremesh of the sphere is used for `narrowphase`
    collision:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`btBroadPhaseInerface`：碰撞检测实际上分为两个阶段：`broadphase`和`narrowphase`。在`broadphase`阶段，物理引擎消除所有不太可能发生碰撞的对象。这个检查是通过使用对象的边界框来完成的。然后，在`narrowphase`阶段，使用对象的实际形状来检查碰撞的可能性。具有强烈碰撞可能性的对象对被创建。在以下屏幕截图中，围绕球体的红色框用于`broadphase`碰撞，而球体的白色线网用于`narrowphase`碰撞：'
- en: '![](img/f0bc4f36-35eb-4c02-b8bc-eef4a2ce1530.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f0bc4f36-35eb-4c02-b8bc-eef4a2ce1530.png)'
- en: '`btDefaultColliusion` **configuration**: This is used for setting up default
    memory.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`btDefaultColliusion` **configuration**：这用于设置默认内存。'
- en: '`btCollisionDispatcher`**:** A pair of objects that have a strong likelihood
    of colliding are tested for collision using actual shapes. This is used for getting
    details of the collision detection, such as which object collided with which other
    object.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`btCollisionDispatcher`**:** 使用实际形状测试具有强烈碰撞可能性的对象对以检测碰撞。这用于获取碰撞检测的详细信息，例如哪个对象与哪个其他对象发生了碰撞。'
- en: '`btSequentialImpulseConstraintSolver`: You can create constraints, such as
    a hinge constraint or slider constraint, which can restrict the motion or rotation
    of one object about another object. For example, if there is a hinge joint between
    the wall and the door, then the door can only rotate around the joint and cannot
    be moved about, as it is fixed at the hinge joint. The constraint solver is responsible
    for calculating this correctly. The calculation is repeated a number of times
    to get close to the optimal solution.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`btSequentialImpulseConstraintSolver`：你可以创建约束，例如铰链约束或滑块约束，这些约束可以限制一个物体相对于另一个物体的运动或旋转。例如，如果墙壁和门之间存在铰链关节，那么门只能绕着关节旋转，不能移动，因为它在铰链关节处是固定的。约束求解器负责正确计算这一点。计算会重复多次，以接近最优解。'
- en: 'In the `init` function, before we create the `sphere` object, we will initialize
    these objects as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init`函数中，在我们创建`sphere`对象之前，我们将按照以下方式初始化这些对象：
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, we will create a new `dynamicWorld` by passing the `dispatcher`, `broadphase`,
    `solver`, and `collisionConfiguration` as parameters to the `btDiscreteDynamicsWorld`
    function, as follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将通过将`dispatcher`、`broadphase`、`solver`和`collisionConfiguration`作为参数传递给`btDiscreteDynamicsWorld`函数来创建一个新的`dynamicWorld`，如下所示：
- en: '[PRE42]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now that our physics world is created, we can set the parameters for our physics.
    The basic parameter is gravity. We set its value to real-world conditions, as
    follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了物理世界，我们可以设置物理参数。基本参数是重力。我们将其值设置为现实世界的条件，如下所示：
- en: '[PRE43]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Adding rigid bodies
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加刚体
- en: Now we can create rigid bodies or soft bodies and watch them interact with other
    rigid or soft bodies. A rigid body is an animate or inanimate object that doesn't
    change its shape or physical properties. Soft bodies, on the other hand, can be
    squishy and made to change shape.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建刚体或软体，并观察它们与其他刚体或软体的相互作用。刚体是一个不会改变其形状或物理特性的有生命或无生命物体。另一方面，软体可以是可挤压的，并使其形状发生变化。
- en: In the following example, we will focus on the creation of a rigid body.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将专注于创建刚体。
- en: To create a rigid body, we have to specify the shape of the object and the motion
    state, and then set the mass and inertia of the objects. Shapes are defined using
    `btCollisionShape`. An object can have different shapes, or sometimes even a combination
    of shapes, called a compound shape. We use `btBoxShape` to create cubes and cuboids
    and `btSphereShape` to create spheres. We can also create other shapes, such as `btCapsuleShape`,
    `btCylinderShape`, and `btConeShape`, which will be used for `narrowphase` collision
    by the library.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个刚体，我们必须指定物体的形状和运动状态，然后设置物体的质量和惯性。形状是通过`btCollisionShape`定义的。一个物体可以有不同的形状，有时甚至是一个形状的组合，称为复合形状。我们使用`btBoxShape`来创建立方体和长方体，使用`btSphereShape`来创建球体。我们还可以创建其他形状，如`btCapsuleShape`、`btCylinderShape`和`btConeShape`，这些形状将由库用于`narrowphase`碰撞。
- en: 'In our case, we are going to create a sphere shape and see our Earth sphere
    bounce around. So, let''s begin:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将创建一个球体形状并观察我们的地球球体弹跳。所以，让我们开始吧：
- en: 'Using the following code, create a `btSphere` for creating a sphere shape and
    set the radius as `1.0`, which is the radius of our rendered sphere as well:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码创建一个`btSphere`用于创建球形，并将半径设置为`1.0`，这也是我们渲染的球体的半径：
- en: '[PRE44]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, set the `btDefaultMotionState`, where we specify the rotation and position
    of the sphere, as follows:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，设置`btDefaultMotionState`，其中我们指定球体的旋转和位置，如下所示：
- en: '[PRE45]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We set the rotation to `0` and set the position of the rigid body to a distance
    of `10.0f` along the *y*-axis. We should also set the mass and inertia and calculate
    the inertia of the `sphereShape` as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将旋转设置为`0`，并将刚体的位置设置为沿*y*轴的`10.0f`距离。我们还应该设置质量和惯性，并计算`sphereShape`的惯性，如下所示：
- en: '[PRE46]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To create the rigid body, we first have to create `btRiigidBodyConstructionInfo` and
    pass the variables to it as follows:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建刚体，我们首先必须创建`btRigidBodyConstructionInfo`并将其变量传递给它，如下所示：
- en: '[PRE47]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, create the rigid body object by passing `btRiigidBodyConstructionInfo`
    into it using the following code:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过将`btRigidBodyConstructionInfo`传递给它来创建刚体对象，如下所示：
- en: '[PRE48]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, set the physical properties of the rigid body, including friction and
    restitution, using the following code:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下代码设置刚体的物理属性，包括摩擦和恢复力：
- en: '[PRE49]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: These values are between `0.0f` and `1.0.0.0`, meaning that the object is really
    smooth and has no friction, and has no restitution or bounciness. The `1.0` figure,
    on the other hand, means that the object is rough on the outside and extremely
    bouncy, like a bouncy ball.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值介于`0.0f`和`1.0.0.0`之间，意味着物体非常光滑且没有摩擦，没有恢复力或弹性。另一方面，`1.0`表示物体外部粗糙且弹性极强，就像一个弹跳球。
- en: 'After these necessary parameters are set, we need to add the rigid body to
    the `dynamicWorld` we created as follows, using the `addRigidBody` function of
    the `dynamicsWorld`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置完这些必要的参数后，我们需要将刚体添加到我们创建的`dynamicWorld`中，如下所示，使用`dynamicsWorld`的`addRigidBody`函数：
- en: '[PRE50]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, for our sphere mesh to actually behave like the sphere body, we have to
    pass the rigid body to the sphere mesh class and make some minor changes. Open
    the `MeshRenderer.h` and `.cpp` files. In the `MeshRenderer.h` file, include the
    `btBulletDynamicsCommon.h` header and add a local `btRigidBody` called `rigidBody`
    to the `private` section. You should also change the constructor to take a rigid
    body, as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了让我们的球体网格真正像球体刚体一样表现，我们必须将刚体传递给球体网格类并做一些小的修改。打开`MeshRenderer.h`和`.cpp`文件。在`MeshRenderer.h`文件中，包含`btBulletDynamicsCommon.h`头文件，并在`private`部分添加一个名为`rigidBody`的本地`btRigidBody`。您还应该将构造函数修改为接受一个刚体，如下所示：
- en: '[PRE51]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the `MeshRenderer.cpp` file, change the constructor to take a `rigidBody` variable
    and set the local `rigidBody` variable to it as follows:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MeshRenderer.cpp`文件中，将构造函数修改为接受一个`rigidBody`变量，并将局部`rigidBody`变量设置为它，如下所示：
- en: '[PRE52]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, in the `draw` function, we have to replace the code where we set the
    `modelMatrix` variable with the code where we get the sphere rigid body value,
    as follows:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`draw`函数中，我们必须替换设置`modelMatrix`变量的代码，使用获取球体刚体值的代码，如下所示：
- en: '[PRE53]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We use the `btTransform` variable to get the transformation from the rigid
    body''s `getMotionState` function and then get the `WorldTransform` variable and
    set it to our `brTransform` variable `t`, as follows:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`btTransform`变量从刚体的`getMotionState`函数中获取变换，然后获取`WorldTransform`变量并将其设置为我们的`brTransform`变量`t`，如下所示：
- en: '[PRE54]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We create two new variables of the `btQuaternion` type to store rotation and
    `btVector3` to store the translation values using the `getRotation` and `getOrigin`
    functions of the `btTransform` class, as follows:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建两个新的 `btQuaternion` 类型的变量来存储旋转，以及一个 `btVector3` 类型的变量来存储变换值，使用 `btTransform`
    类的 `getRotation` 和 `getOrigin` 函数，如下所示：
- en: '[PRE55]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, we create three `glm::mat4` variables, called `RotationMatrix`, `TranslationMatrix`,
    and `ScaleMatrix`, and set the values of rotation and translation using the `glm::rotate`
    and `glm:: translation` functions. We then pass in the rotation and translation
    values we stored earlier, as shown in the following code. We will keep the `ScaleMatrix` variable
    as is:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建三个 `glm::mat4` 类型的变量，分别称为 `RotationMatrix`、`TranslationMatrix` 和 `ScaleMatrix`，并使用
    `glm::rotate` 和 `glm::translation` 函数设置旋转和变换的值。然后，我们将之前存储的旋转和变换值传递进去，如下所示。我们将保持
    `ScaleMatrix` 变量不变：
- en: '[PRE56]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The new `modelMatrix` variable will be the multiplication of the scale, rotation,
    and translation matrices in that order. The rest of the code will remain the same
    in the `draw` function.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `modelMatrix` 变量将是按照顺序缩放、旋转和变换矩阵的乘积。在 `draw` 函数中，其余的代码将保持不变。
- en: 'In the `init` function, change the code to reflect the modified `MeshRenderer`
    constructor:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `init` 函数中，更改代码以反映修改后的 `MeshRenderer` 构造函数：
- en: '[PRE57]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We don''t have to set the position, as that will be set by the rigid body.
    Set the camera as shown in the following code so that we can see the sphere:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不需要设置位置，因为这将由刚体设置。按照以下代码设置相机，以便我们可以看到球体：
- en: '[PRE58]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Now, run the project. We can see the sphere being drawn, but it is not moving.
    That's because we have to update the physics bodies.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行项目。我们可以看到球体正在被绘制，但它没有移动。这是因为我们必须更新物理体。
- en: We have to use the `dynamicsWorld` and `stepSimulation` functions to update
    the simulation every frame. To do this, we have to calculate the delta time between
    the previous and current frames.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须使用 `dynamicsWorld` 和 `stepSimulation` 函数来每帧更新模拟。为此，我们必须计算前一个帧和当前帧之间的时间差。
- en: 'At the top of the `source.cpp`, include `<chrono>` so that we can calculate
    the tick update. Now, we have to make changes to the `main` function and the `while`
    loop as follows:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `source.cpp` 的顶部包含 `<chrono>`，这样我们就可以计算tick更新。现在，我们必须对 `main` 函数和 `while`
    循环进行如下更改：
- en: '[PRE59]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Just before the `while` loop, we create a variable called `previousTime` and
    initialize it with the current time. In the `while` loop, we get the current time
    and store it in the variable. Then, we calculate the delta time between the previous
    time and the current time by subtracting the two. We have the delta time now,
    so we call the `stepSimulation` and pass in the delta time. Then we render the
    scene and swap the buffer and poll for events as usual. Finally, we set the current
    time as the previous time.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `while` 循环之前，我们创建一个名为 `previousTime` 的变量，并用当前时间初始化它。在 `while` 循环中，我们获取当前时间并将其存储在变量中。然后，我们通过减去两个时间来计算前一个时间和当前时间之间的时间差。现在我们有了时间差，所以我们调用
    `stepSimulation` 并传入时间差。然后我们渲染场景，交换缓冲区并轮询事件，就像平常一样。最后，我们将当前时间设置为前一个时间。
- en: Now, when we run the project, we can see the sphere falling down, which is pretty
    cool. However, the sphere doesn't interact with anything.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行项目时，我们可以看到球体正在下落，这非常酷。然而，球体没有与任何东西互动。
- en: 'Let''s add a box rigid body at the bottom and watch the sphere bounce off it.
    After the sphere `MeshRenderer` object, add the following code to create a box
    rigid body:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在底部添加一个盒子刚体，并观察球体如何从它弹起。在球体 `MeshRenderer` 对象之后，添加以下代码来创建一个盒子刚体：
- en: '[PRE60]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, we first create a shape of the `btBoxShape` type with the length, height,
    and depth set as `4.0`, `0.5`, and `4.0` respectively. Next, we will set the motion
    state, where we set the rotation to zero and the position at `-2.0` in the *y*-axis
    and `0` along the *x*- and *z*-axis. For the construction information, we set
    the mass and intertia to `0`. We also set the default motion state and pass in
    the shape. Next, we create the rigid body by passing the rigid body information
    into it. Once the rigid body is created, we set the restitution and friction value.
    Next, we use the `setCollisionFlags` function of `rigidBody` to set the rigid
    body type as static. This means that it will be like a brick wall or won't move
    and be affected by forces from other rigid bodies, but other bodies will still
    be affected by it.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先创建一个 `btBoxShape` 类型的形状，长度、高度和深度分别设置为 `4.0`、`0.5` 和 `4.0`。接下来，我们将设置运动状态，其中我们将旋转设置为零，并将位置设置为
    *y* 轴上的 `-2.0` 和 *x* 轴和 *z* 轴上的 `0`。对于构造信息，我们将质量和惯性设置为 `0`。我们还设置了默认的运动状态并将形状传入。接下来，我们通过将刚体信息传入其中来创建刚体。一旦创建了刚体，我们就设置了恢复力和摩擦值。接下来，我们使用
    `rigidBody` 的 `setCollisionFlags` 函数将刚体类型设置为静态。这意味着它将像砖墙一样，不会移动并且不受其他刚体作用力的影响，但其他物体仍然会受到它的影响。
- en: 'Finally, we add the ground rigid body to the world so that the box rigid body
    will be part of the physics simulation as well. We now have to create a `MeshRenderer` cube
    to render the ground rigid body. Create a new `MeshRenderer` object called `Ground`
    at the top, under which you created the sphere `MeshRenderer` object. In the `init`
    function, under which we added the code for the ground rigid body, add the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将地面刚体添加到世界中，这样盒子刚体也将成为物理模拟的一部分。我们现在必须创建一个用于渲染地面刚体的 `MeshRenderer` 立方体。在顶部创建一个新的
    `MeshRenderer` 对象，称为 `Ground`，在其下方你创建了球体 `MeshRenderer` 对象。在 `init` 函数中，我们在其中添加了地面刚体的代码，添加以下内容：
- en: '[PRE61]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We will create a new texture by loading `ground.jpg`, so make sure you add it
    to the `Assets/ Textures` directory. Call the constructor and set the `meshtype`
    to `cube`, and then set the camera and pass in the ground rigid body. We then
    set the shader program, texture, and scale of the object.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过加载 `ground.jpg` 创建一个新的纹理，所以请确保你已经将它添加到 `Assets/ Textures` 目录中。调用构造函数并将
    `meshtype` 设置为 `cube`，然后设置相机并传入地面刚体。接下来，我们设置着色器程序、纹理和物体的比例。
- en: 'In the `renderScene` function, draw the ground `MeshRenderer` object as follows:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `renderScene` 函数中，按照以下方式绘制地面 `MeshRenderer` 对象：
- en: '[PRE62]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, when you run the project, you will see the sphere bouncing on the ground
    box:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当你运行项目时，你将看到球体在地面上弹跳：
- en: '![](img/5aa9e70f-6bc0-4e07-8212-24d7cebc2dbf.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5aa9e70f-6bc0-4e07-8212-24d7cebc2dbf.png)'
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created a new class called `MeshRenderer`, which will be
    used to render textured 3D objects to our scene. We created a texture-loaded class,
    which will be used to load the textures from the images provided. Then, we added
    physics to the object by adding the Bullet Physics library. We then initialized
    the physics world and created and added the rigid body to the mesh renderer by
    adding the body itself to the world, causing the rendered object to be affected
    by physics.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个名为 `MeshRenderer` 的新类，它将被用来将纹理化的 3D 对象渲染到场景中。我们创建了一个纹理加载类，它将被用来从提供的图像中加载纹理。然后，我们通过添加
    Bullet Physics 库给对象添加了物理效果。然后我们初始化了物理世界，并通过将刚体本身添加到世界中，创建了并添加了刚体到网格渲染器中，使得渲染的物体受到物理影响。
- en: In the next chapter, we will add a gameplay loop, as well as scoring and text
    rendering to display the score on the viewport. We will also add lighting to our
    world.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将添加游戏循环，以及计分和文本渲染来在视口中显示分数。我们还将向我们的世界添加光照。
