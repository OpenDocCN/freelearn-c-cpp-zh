- en: '*Chapter 2*: Exploring LLVM''s Build System Features'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第2章*：探索LLVM的构建系统功能'
- en: 'In the previous chapter, we saw that LLVM''s build system is a behemoth: it
    contains hundreds of build files with thousands of interleaving build dependencies.
    Not to mention, it contains targets that require custom build instructions for
    heterogeneous source files. These complexities drove LLVM to adopt some advanced
    build system features and, more importantly, a more structural build system design.
    In this chapter, our goal will be to learn about some important directives for
    the sake of writing more concise and expressive build files when doing both in-tree
    and out-of-tree LLVM developments.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解到LLVM的构建系统是一个庞然大物：它包含数百个构建文件，有成千上万的交错构建依赖。更不用说，它还包含需要为异构源文件定制构建指令的目标。这些复杂性驱使LLVM采用了一些高级构建系统特性，更重要的是，一个更结构化的构建系统设计。在本章中，我们的目标将是了解一些重要的指令，以便在树内和树外进行LLVM开发时编写更简洁和更具表现力的构建文件。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Exploring a glossary of LLVM's important CMake directives
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索LLVM重要CMake指令的词汇表
- en: Integrating LLVM via CMake in out-of-tree projects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在树外项目中通过CMake集成LLVM
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Similar to [*Chapter 1*](B14590_01_Final_JC_ePub.xhtml#_idTextAnchor014), *Saving
    Resources When Building LLVM*, you might want to have a copy of LLVM built from
    its source. Optionally, since this chapter will touch on quite a lot of CMake
    build files, you may wish to prepare a syntax highlighting plugin for `CMakeLists.txt`
    (for example, VSCode's *CMake Tools* plugin). All major IDEs and editors should
    have it off-the-shelf. Also, familiarity with basic `CMakeLists.txt` syntax is
    preferable.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 与[*第1章*](B14590_01_Final_JC_ePub.xhtml#_idTextAnchor014)的*构建LLVM时的资源节约*类似，你可能想要有一个从源代码构建的LLVM副本。可选地，由于本章将涉及大量的CMake构建文件，你可能希望为`CMakeLists.txt`准备一个语法高亮插件（例如，VSCode的*CMake
    Tools*插件）。所有主流IDE和编辑器都应该有现成的。此外，熟悉基本的`CMakeLists.txt`语法是首选的。
- en: 'All the code examples in this chapter can be found in this book''s GitHub repository:
    [https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices/tree/main/Chapter02](https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices/tree/main/Chapter02).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有的代码示例都可以在这个书的GitHub仓库中找到：[https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices/tree/main/Chapter02](https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices/tree/main/Chapter02).
- en: Exploring a glossary of LLVM's important CMake directives
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索LLVM重要CMake指令的词汇表
- en: LLVM has switched to **CMake** from **GNU autoconf** due to higher flexibility
    in terms of choosing underlying build systems. Ever since, LLVM has come up with
    many custom CMake functions, macros, and rules to optimize its own usage. This
    section will give you an overview of the most important and frequently used ones
    among them. We will learn how and when to use them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在选择底层构建系统方面的更高灵活性，LLVM已经从**GNU autoconf**切换到**CMake**。从那时起，LLVM已经提出了许多自定义的CMake函数、宏和规则来优化其自身的使用。本节将为您概述其中最重要的和最常用的几个。我们将学习如何以及何时使用它们。
- en: Using the CMake function to add new libraries
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CMake函数添加新库
- en: 'Libraries are the building blocks of the LLVM framework. However, when writing
    `CMakeLists.txt` for a new library, you shouldn''t use the normal `add_library`
    directive that appears in normal `CMakeLists.txt` files, as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 库是LLVM框架的构建块。然而，在为新的库编写`CMakeLists.txt`时，你不应该使用在正常的`CMakeLists.txt`文件中出现的普通`add_library`指令，如下所示：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There are several drawbacks of using the vanilla `add_library` here, as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用普通的`add_library`有几个缺点，如下所示：
- en: As shown in [*Chapter 1*](B14590_01_Final_JC_ePub.xhtml#_idTextAnchor014), *Saving
    Resources When Building LLVM,* LLVM prefers to use a global CMake argument (that
    is, `BUILD_SHARED_LIBS`) to control whether all its component libraries should
    be built statically or dynamically. It's pretty hard to do that using the built-in
    directives.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如[*第1章*](B14590_01_Final_JC_ePub.xhtml#_idTextAnchor014)所示，*构建LLVM时的资源节约*，LLVM更倾向于使用全局CMake参数（即`BUILD_SHARED_LIBS`）来控制其所有组件库是否应该静态或动态构建。使用内置指令来做这一点相当困难。
- en: Similar to the previous point, LLVM prefers to use a global CMake arguments
    to control some compile flags, such as whether or not to enable **Runtime Type
    Information** (**RTTI**) and **C++ exception handling** in the code base.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与前一点类似，LLVM更倾向于使用全局CMake参数来控制一些编译标志，例如是否在代码库中启用**运行时类型信息**（**RTTI**）和**C++异常处理**。
- en: By using custom CMake functions/macros, LLVM can create its own component system,
    which provides a higher level of abstraction for developers to designate build
    target dependencies in an easier way.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用自定义 CMake 函数/宏，LLVM 可以创建自己的组件系统，这为开发者提供了更高层次的抽象，以便以更简单的方式指定构建目标依赖项。
- en: 'Therefore, you should always use the `add_llvm_component_library` CMake function
    shown here:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你应该始终使用这里所示的 `add_llvm_component_library` CMake 函数：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, `LLVMFancyOpt` is the final library name and `FancyOpt.cpp` is the source
    file.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`LLVMFancyOpt` 是最终的库名称，而 `FancyOpt.cpp` 是源文件。
- en: In regular CMake scripts, you can use `target_link_libraries` to designate a
    given target's library dependencies, and then use `add_dependencies` to assign
    dependencies among different build targets to create explicit build orderings.
    There is an easier way to do those tasks when you're using LLVM's custom CMake
    functions to create library targets.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在常规的 CMake 脚本中，你可以使用 `target_link_libraries` 来指定给定目标的库依赖项，然后使用 `add_dependencies`
    来在不同构建目标之间分配依赖关系，以创建明确的构建顺序。当你使用 LLVM 的自定义 CMake 函数创建库目标时，有更简单的方法来完成这些任务。
- en: 'By using the `LINK_COMPONENTS` argument in `add_llvm_component_library` (or
    `add_llvm_library`, which is the underlying implementation of the former one),
    you can designate the target''s linked components:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `add_llvm_component_library`（或 `add_llvm_library`，这是前者的底层实现）中使用 `LINK_COMPONENTS`
    参数，你可以指定目标的链接组件：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively, you can do the same thing with the `LLVM_LINK_COMPONENTS` variable,
    which is defined before the function call:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用在函数调用之前定义的 `LLVM_LINK_COMPONENTS` 变量来完成相同的事情：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Component libraries are nothing but normal libraries with a special meaning
    when it comes to the *LLVM building blocks you can use*. They''re also included
    in the gigantic `libLLVM` library if you choose to build it. The component names
    are slightly different from the real library names. If you need the mapping from
    component names to library names, you can use the following CMake function:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 组件库只是具有特殊意义的普通库，当涉及到你可以使用的 *LLVM 构建块* 时。如果你选择构建它，它们也包含在庞大的 `libLLVM` 库中。组件名称与真实库名称略有不同。如果你需要从组件名称到库名称的映射，你可以使用以下
    CMake 函数：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you want to directly link against a *normal* library (the non-LLVM component
    one), you can use the `LINK_LIBS` argument:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要直接链接到一个 *普通* 库（非 LLVM 组件的库），你可以使用 `LINK_LIBS` 参数：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To assign general build target dependencies to a library target (equivalent
    to `add_dependencies`), you can use the `DEPENDS` argument:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一般构建目标依赖项分配给库目标（相当于 `add_dependencies`），你可以使用 `DEPENDS` 参数：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`intrinsics_gen` is a common target representing the procedure of generating
    header files containing LLVM intrinsics definitions.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`intrinsics_gen` 是一个表示生成包含 LLVM 内置定义的头文件过程的通用目标。'
- en: Adding one build target per folder
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 每个文件夹添加一个构建目标
- en: 'Many LLVM custom CMake functions have a pitfall that involves source file detection.
    Let''s say you have a directory structure like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 LLVM 自定义 CMake 函数存在一个涉及源文件检测的陷阱。假设你有一个如下的目录结构：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, you have two source files, `FancyOpt.cpp` and `AggressiveFancyOpt.cpp`.
    As their names suggest, `FancyOpt.cpp` is the basic version of this optimization,
    while `AggressiveFancyOpt.cpp` is an alternative, more aggressive version of the
    same functionality. Naturally, you will want to split them into separate libraries
    so that users can choose if they wish to include the more aggressive one in their
    normal workload. So, you might write a `CMakeLists.txt` file like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你有两个源文件，`FancyOpt.cpp` 和 `AggressiveFancyOpt.cpp`。正如它们的名称所暗示的，`FancyOpt.cpp`
    是这种优化的基本版本，而 `AggressiveFancyOpt.cpp` 是相同功能的替代、更激进的版本。自然地，你将希望将它们分成单独的库，以便用户可以选择是否在他们的正常工作量中包含更激进的版本。因此，你可能编写一个
    `CMakeLists.txt` 文件如下：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Unfortunately, this would generate error messages telling you something to the
    effect of `Found unknown source AggressiveFancyOpt.cpp …` when processing the
    first `add_llvm_component_library` statement.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这会在处理第一个 `add_llvm_component_library` 语句时生成错误消息，告诉你类似 `Found unknown source
    AggressiveFancyOpt.cpp …` 的事情。
- en: 'LLVM''s build system enforces a stricter rule to make sure that *all* C/C++
    source files in the same folder are added to the same library, executable, or
    plugin. To fix this, it is necessary to split either file into a separate folder,
    like so:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 的构建系统强制执行更严格的规则，以确保同一文件夹中的所有 C/C++ 源文件都被添加到同一个库、可执行文件或插件中。为了解决这个问题，有必要将其中一个文件拆分到一个单独的文件夹中，如下所示：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In `/FancyOpt/CMakeLists.txt`, we have the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `/FancyOpt/CMakeLists.txt` 中，我们有以下内容：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, in `/FancyOpt/AggressiveFancyOpt/CMakeLists.txt`, we have the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `/FancyOpt/AggressiveFancyOpt/CMakeLists.txt` 文件中，我们有以下内容：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: These are the essentials of adding build targets for (component) libraries using
    LLVM's custom CMake directives. In the next two sections, we will show you how
    to add executable and Pass plugin build targets using a different set of LLVM-specific
    CMake directives.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是使用 LLVM 的自定义 CMake 指令添加（组件）库构建目标的基本要素。在接下来的两个部分中，我们将向您展示如何使用一组不同的 LLVM 特定
    CMake 指令添加可执行文件和 Pass 插件构建目标。
- en: Using the CMake function to add executables and tools
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 CMake 函数添加可执行文件和工具
- en: 'Similar to `add_llvm_component_library`, to add a new executable target, we
    can use `add_llvm_executable` or `add_llvm_tool`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `add_llvm_component_library` 类似，要添加新的可执行目标，我们可以使用 `add_llvm_executable` 或
    `add_llvm_tool`：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These two functions have the same syntax. However, only targets created by `add_llvm_tool`
    will be included in the installations. There is also a global CMake variable,
    `LLVM_BUILD_TOOLS`, that enables/disables those LLVM tool targets.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数具有相同的语法。然而，只有由 `add_llvm_tool` 创建的目标才会包含在安装中。还有一个全局 CMake 变量 `LLVM_BUILD_TOOLS`，它启用/禁用这些
    LLVM 工具目标。
- en: Both functions can also use the `DEPENDS` argument to assign dependencies, similar
    to `add_llvm_library`, which we introduced earlier. However, you can only use
    the `LLVM_LINK_COMPONENTS` variable to designate components to link.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数也可以使用 `DEPENDS` 参数来指定依赖项，类似于我们之前介绍的 `add_llvm_library`。然而，您只能使用 `LLVM_LINK_COMPONENTS`
    变量来指定要链接的组件。
- en: Using the CMake function to add Pass plugins
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 CMake 函数添加 Pass 插件
- en: 'While we will cover Pass plugin development later in this book, adding a build
    target for a Pass plugin couldn''t be any easier than now (compared to earlier
    LLVM versions, which were still using `add_llvm_library` with some special arguments).
    We can simply use the following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们将在本书的后面部分介绍 Pass 插件开发，但添加 Pass 插件的构建目标现在（与早期仍使用带有一些特殊参数的 `add_llvm_library`
    的 LLVM 版本相比）不可能更简单了。我们可以简单地使用以下命令：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `LINK_COMPONENTS`, `LINK_LIBS`, and `DEPENDS` arguments are also available
    here, with the same usages and functionalities as in `add_llvm_component_library`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`LINK_COMPONENTS`、`LINK_LIBS` 和 `DEPENDS` 参数也在这里可用，其用法和功能与 `add_llvm_component_library`
    中相同。'
- en: These are some of the most common and important LLVM-specific CMake directives.
    Using these directives can not only make your CMake code more concise but also
    help synchronize it with LLVM's own build system, in case you want to do some
    in-tree development. In the next section, we will show you how to integrate LLVM
    into an out-of-tree CMake project, and leverage the knowledge we learned in this
    chapter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些最常见且最重要的 LLVM 特定 CMake 指令。使用这些指令不仅可以使您的 CMake 代码更加简洁，还可以帮助它与 LLVM 的自身构建系统同步，以防您想进行一些树内开发。在下一节中，我们将向您展示如何将
    LLVM 集成到树外 CMake 项目中，并利用我们在本章中学到的知识。
- en: In-tree versus out-of-tree development
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 树内与树外开发
- en: In this book, *in-tree* development means contributing code directly to the
    LLVM project, such as fixing LLVM bugs or adding new features to the existing
    LLVM libraries. *Out-of-tree* development, on the other hand, either represents
    creating extensions for LLVM (writing an LLVM pass, for example) or using LLVM
    libraries in some other projects (using LLVM's code generation libraries to implement
    your own programming language, for example).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，*树内* 开发意味着直接向 LLVM 项目贡献代码，例如修复 LLVM 缺陷或向现有的 LLVM 库添加新功能。另一方面，*树外* 开发可能代表为
    LLVM 创建扩展（例如编写 LLVM Pass）或在其他项目中使用 LLVM 库（例如使用 LLVM 的代码生成库来实现您自己的编程语言）。
- en: Understanding CMake integration for out-of-tree projects
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解树外项目的 CMake 集成
- en: Implementing your features in an in-tree project is good for prototyping, since
    most of the infrastructure is already there. However, there are many scenarios
    where pulling the entire LLVM source tree into your code base is not the best
    idea, compared to creating an **out-of-tree project** and linking it against the
    LLVM libraries. For example, you only want to create a small code refactoring
    tool using LLVM's features and open source it on GitHub, so telling developers
    on GitHub to download a multi-gigabyte LLVM source tree along with your little
    tool might not be a pleasant experience.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在树内项目中实现你的功能对于原型设计是有益的，因为大部分基础设施已经存在。然而，与创建一个 **树外项目** 并将其链接到 LLVM 库相比，有许多场景将整个
    LLVM 源代码树拉入你的代码库并不是最佳选择。例如，你可能只想创建一个使用 LLVM 功能的小型代码重构工具并在 GitHub 上开源，那么让 GitHub
    上的开发者下载与你小巧的工具一起的多吉字节 LLVM 源代码树可能不会是一个愉快的体验。
- en: 'There are at least two ways to configure out-of-tree projects to link against
    LLVM:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 配置树外项目以链接到 LLVM 至少有两种方式：
- en: Using the `llvm-config` tool
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `llvm-config` 工具
- en: Using LLVM's CMake modules
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 LLVM 的 CMake 模块
- en: Both approaches help you sort out all the details, including header files and
    library paths. However, the latter creates more concise and readable CMake scripts,
    which is preferable for projects that are already using CMake. This section will
    show the essential steps of using LLVM's CMake modules to integrate it into an
    out-of-tree CMake project.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都有助于你整理所有细节，包括头文件和库路径。然而，后者创建的 CMake 脚本更简洁、更易读，这对于已经使用 CMake 的项目来说更可取。本节将展示使用
    LLVM 的 CMake 模块将 LLVM 集成到树外 CMake 项目的必要步骤。
- en: 'First, we need to prepare an out-of-tree (C/C++) CMake project. The core CMake
    functions/macros we discussed in the previous section will help us work our way
    through this. Let''s look at our steps:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要准备一个树外（C/C++）CMake 项目。我们在上一节中讨论的核心 CMake 函数/宏将帮助我们完成这项工作。让我们看看我们的步骤：
- en: 'We are assuming that you already have the following `CMakeLists.txt` skeleton
    for a project that needs to be linked against LLVM libraries:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们假设你已经为需要链接到 LLVM 库的项目准备好了以下 `CMakeLists.txt` 框架：
- en: '[PRE14]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Regardless of whether you're trying to create a project generating executable,
    just like the one we saw in the preceding code block, or other artifacts such
    as libraries or even LLVM Pass plugins, the biggest question now is how to get
    `include path`, as well as `library path`.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 无论你是在尝试创建一个生成可执行文件的项目，就像我们在前面的代码块中看到的那样，还是其他如库或甚至 LLVM Pass 插件等工件，现在最大的问题是如何获取
    `包含路径` 以及 `库路径`。
- en: 'To resolve `include path` and `library path`, LLVM provides the standard CMake
    package interface for you to use the `find_package` CMake directive to import
    various configurations, as follows:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决 `包含路径` 和 `库路径`，LLVM 为你提供了标准的 CMake 包接口，你可以使用 `find_package` CMake 指令导入各种配置，如下所示：
- en: '[PRE15]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: lib/cmake/llvm subdirectory under LLVM install path.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: LLVM 安装路径下的 `lib/cmake/llvm` 子目录。
- en: '[PRE16]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After resolving the include path and library, it's time to link the main executable
    against LLVM's libraries. LLVM's custom CMake functions (for example, `add_llvm_executable`)
    will be really useful here. But first, CMake needs to be able to *find* those
    functions.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决包含路径和库之后，是时候将主可执行文件链接到 LLVM 的库上了。LLVM 的自定义 CMake 函数（例如，`add_llvm_executable`）在这里将非常有用。但首先，CMake
    需要能够 *找到* 这些函数。
- en: 'The following snippet imports LLVM''s CMake module (more specifically, the
    `AddLLVM` CMake module), which contains those LLVM-specific functions/macros that
    we introduced in the previous section:'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下片段导入了 LLVM 的 CMake 模块（更具体地说，是 `AddLLVM` CMake 模块），其中包含我们在上一节中介绍过的那些 LLVM 特定函数/宏：
- en: '[PRE17]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following snippet adds the executable build target using the CMake function
    we learned about in the previous section:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下片段使用我们在上一节中介绍过的 CMake 函数添加了可执行文件的构建目标：
- en: '[PRE18]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Adding the library target makes no difference:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加库目标没有区别：
- en: '[PRE19]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, add the LLVM Pass plugin:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加 LLVM Pass 插件：
- en: '[PRE20]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In practice, you also need to be careful of **LLVM-specific definitions** and
    the RTTI setting:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实践中，你还需要注意 **LLVM 特定定义** 和 RTTI 设置：
- en: '[PRE21]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is especially true for the RTTI part because, by default, LLVM is not built
    with RTTI support, but normal C++ applications are. A compilation error will be
    thrown if there is an RTTI mismatch between your code and LLVM's libraries.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这对于 RTTI 部分尤其如此，因为默认情况下，LLVM 并未构建 RTTI 支持，而正常的 C++ 应用程序是支持的。如果你的代码和 LLVM 库之间存在
    RTTI 不匹配，将会抛出编译错误。
- en: Despite the convenience of developing inside LLVM's source tree, sometimes,
    enclosing the entire LLVM source in your project might not be feasible. So, instead,
    we must create an out-of-tree project and integrate LLVM as a library. This section
    showed you how to integrate LLVM into your CMake-based out-of-tree projects and
    make good use of the LLVM-specific CMake directives we learned about in the *Exploring
    a glossary of LLVM's important CMake directives* section.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在LLVM源树内开发很方便，但有时将整个LLVM源代码包含在你的项目中可能并不可行。因此，我们必须创建一个树外项目，并将LLVM作为库进行集成。本节展示了如何将LLVM集成到基于CMake的树外项目中，并充分利用我们在“探索LLVM重要CMake指令词汇表”部分学到的LLVM特定CMake指令。
- en: Summary
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter dug deeper into LLVM's CMake build system. We saw how to use LLVM's
    own CMake directives to write concise and effective build scripts, for both in-tree
    and out-of-tree development. Learning these CMake skills can make your LLVM development
    more efficient and provide you with more options to engage LLVM features with
    other existing code bases or custom logic.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了LLVM的CMake构建系统。我们看到了如何使用LLVM自己的CMake指令来编写简洁有效的构建脚本，无论是树内还是树外开发。掌握这些CMake技能可以使你的LLVM开发更加高效，并为你提供更多与现有代码库或自定义逻辑交互LLVM功能的选择。
- en: In the next chapter, we will introduce another important infrastructure in the
    LLVM project known as the LLVM LIT, which is an easy-to-use yet general framework
    for running various kinds of tests.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍LLVM项目中另一个重要的基础设施，称为LLVM LIT，这是一个易于使用且通用的框架，用于运行各种类型的测试。
