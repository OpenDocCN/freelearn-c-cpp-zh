- en: '*Chapter 7*: Utilizing Dynamic Binding through Polymorphism'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：通过多态利用动态绑定'
- en: This chapter will further extend our knowledge of object-oriented programming
    in C++. We will begin by introducing a powerful OO concept, **polymorphism**,
    and then understand how this idea is implemented in C++ through *direct language
    support*. We will implement polymorphism using virtual functions in hierarchies
    of related classes, and understand how we can achieve runtime binding of a specific
    derived class method to a more generic, base class operation. We will understand
    how the OO concept of polymorphism presented in this chapter will support versatile
    and robust designs and easily extensible code in C++.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将进一步扩展我们对C++中面向对象编程的知识。我们将首先介绍一个强大的面向对象概念，**多态**，然后理解这一概念是如何通过*直接语言支持*在C++中实现的。我们将使用虚函数在相关类的层次结构中实现多态，并理解如何将特定派生类方法的运行时绑定到更通用的基类操作。我们将理解本章中呈现的多态的面向对象概念将支持多样化和健壮的设计，并在C++中轻松实现可扩展的代码。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding the OO concept of polymorphism and why it is important to OOP
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解多态的面向对象概念以及它对面向对象编程的重要性。
- en: Defining virtual functions, understanding how virtual functions override base
    class methods, generalizing derived class objects, the need for virtual destructors,
    and function hiding
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义虚函数，理解虚函数如何覆盖基类方法，泛化派生类对象，虚析构函数的必要性以及函数隐藏
- en: Understanding dynamic (runtime) binding of methods to operations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解方法对操作的动态（运行时）绑定
- en: A detailed understanding of the **virtual function table** (**v-table**)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对**虚函数表**（**v-table**）的详细理解
- en: By the end of this chapter, you will understand the OO concept of polymorphism,
    and how to implement this idea in C++ through virtual functions. You will understand
    how virtual functions enable runtime binding of methods to operations in C++.
    You will see how an operation can be specified in a base class and overridden
    with a preferred implementation in a derived class. You will understand when and
    why it is important to utilize a virtual destructor.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将理解多态的面向对象概念，以及如何通过虚函数在C++中实现这一概念。您将理解虚函数如何使得C++中方法对操作的运行时绑定成为可能。您将看到如何在基类中指定一个操作，并在派生类中用首选实现进行覆盖。您将理解何时以及为何重要利用虚析构函数。
- en: You will see how instances of derived classes are often stored using base class
    pointers and why this is significant. We will discover that regardless of how
    an instance is stored (as its own type or as that of a base class), the correct
    version of a virtual function will always be applied through dynamic binding.
    Specifically, you will see how runtime binding works under the hood as we examine
    virtual function pointers and virtual function tables in C++.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到派生类的实例通常使用基类指针存储的原因，以及这一点的重要性。我们将发现，无论实例是如何存储的（作为其自身类型还是作为基类的类型），虚函数的正确版本始终会通过动态绑定应用。具体来说，当我们检查C++中的虚函数指针和虚函数表时，您将看到运行时绑定是如何在幕后工作的。
- en: By understanding the direct language support of polymorphism in C++ using virtual
    functions, you will be on your way to creating an extensible hierarchy of related
    classes, featuring dynamic binding of methods to operations. Let's augment our
    understanding of C++ as an OOP language by detailing these ideals.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解C++中虚函数对多态的直接语言支持，您将能够创建一组相关类的可扩展层次结构，实现方法对操作的动态绑定。让我们通过详细介绍这些理想来增进对C++作为面向对象编程语言的理解。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Online code for full program examples can be found at the following GitHub
    URL: [https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter07](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter07).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds with the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter07` in a file named `Chp7-Ex1.cpp` under the aforementioned GitHub directory.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 完整程序示例的在线代码可在以下GitHub网址找到：[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter07](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter07)。每个完整程序示例都可以在GitHub存储库中找到，位于相应章节标题（子目录）下的文件中，文件名由章节号后跟当前章节中的示例号组成。例如，本章的第一个完整程序可以在名为`Chp7-Ex1.cpp`的文件中的`Chapter07`子目录下找到。
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/317dxf3](https://bit.ly/317dxf3).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可在以下网址观看：[https://bit.ly/317dxf3](https://bit.ly/317dxf3)。
- en: Understanding the OO concept of polymorphism
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解多态的面向对象概念
- en: In this section, we will introduce an essential object-oriented concept, polymorphism.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一个重要的面向对象概念，多态。
- en: From [*Chapter 5*](B15702_05_Final_NM_ePub.xhtml#_idTextAnchor199), *Exploring
    Classes in Detail*, and [*Chapter 6*](B15702_06_Final_NM_ePub.xhtml#_idTextAnchor262),
    *Implementing Hierarchies with Single Inheritance*, you now understand the key
    OO ideas of encapsulation, information hiding, generalization, and specialization.
    You know how to encapsulate a class, build inheritance hierarchies using single
    inheritance, and various reasons to build hierarchies (such as supporting Is-A
    relationships or for the lesser-used reason of supporting implementation inheritance).
    Let's begin by extending our basic OO terminology by exploring **polymorphism**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从[*第5章*](B15702_05_Final_NM_ePub.xhtml#_idTextAnchor199) *详细探索类*，和[*第6章*](B15702_06_Final_NM_ePub.xhtml#_idTextAnchor262)
    *使用单继承实现层次结构*，您现在理解了封装、信息隐藏、泛化和特化的关键面向对象的思想。您知道如何封装一个类，使用单继承构建继承层次结构，以及构建层次结构的各种原因（例如支持Is-A关系或支持实现继承的较少使用的原因）。让我们通过探索**多态**来扩展我们的基本面向对象术语。
- en: 'When a base class specifies an operation such that a derived class may redefine
    the operation in its class with a more suitable method, the operation is said
    to be **polymorphic**. Let''s revisit our definitions of operation and method,
    as well as their implications, to understand how these concepts lay the groundwork
    for polymorphism:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当基类指定一个操作，使得派生类可以用更合适的方法重新定义该操作时，该操作被称为**多态的**。让我们重新审视我们对操作和方法的定义，以及它们的含义，以了解这些概念如何为多态性奠定基础：
- en: In C++, an **operation** maps to the complete signature of the member function
    (name plus type and number of arguments – no return type).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C++中，**操作**映射到成员函数的完整签名（名称加上参数的类型和数量 - 没有返回类型）。
- en: Additionally, in C++, a **method** maps to the definition or body of the operation
    (that is, the implementation or body of the member function).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，在C++中，**方法**映射到操作的定义或主体（即成员函数的实现或主体）。
- en: Recall, in OO terms, an **operation** implements a behavior of a class. The
    implementation of a base class operation may be via several distinct derived class
    **methods**.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾一下，在面向对象的术语中，**操作**实现了类的行为。基类操作的实现可以通过几个不同的派生类**方法**来实现。
- en: '`Student` Is-A `Person`. Yet, a polymorphic operation will allow `Student`
    behaviors to be revealed on `Student` objects, even when they have *taken on the
    form* of a `Person`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`Student` 是 `Person`。然而，多态操作将允许在`Student`对象上显示`Student`行为，即使它们已经*采用了*`Person`的形式。'
- en: As we progress through this chapter, we will see derived class objects taking
    on the form of their public base classes, that is, taking on *many forms* (**polymorphism**).
    We will see how a polymorphic operation can be specified in a base class and overridden
    with a preferred implementation in a derived class.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到派生类对象采用其公共基类的形式，即采用*多种形式*（**多态性**）。我们将看到如何在基类中指定多态操作，并在派生类中用首选实现进行重写。
- en: Let's start by looking at the C++ language feature that allows us to implement
    polymorphism, namely, virtual functions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从C++语言特性开始，这些特性允许我们实现多态性，即虚函数。
- en: Implementing polymorphism with virtual functions
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用虚函数实现多态性
- en: Polymorphism allows dynamic binding of a method to an operation. Dynamic, or
    runtime, binding of a method to an operation is important because derived class
    instances may be pointed to by base class objects (that is, by pointers of a base
    class type). In these situations, the pointer type does not provide adequate information
    regarding the correct method that should be applied to the referenced instance.
    We need another way – one done at runtime – to determine which method applies
    to each instance.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性允许将方法动态绑定到操作。将方法动态绑定到操作是重要的，因为派生类实例可能被基类对象指向（即，通过基类类型的指针）。在这些情况下，指针类型无法提供关于应该应用于引用实例的正确方法的足够信息。我们需要另一种方式
    - 在运行时完成 - 来确定哪种方法适用于每个实例。
- en: Often, it is the case that a pointer to an instance of a derived class type
    will be generalized as a pointer to the base class type. When an operation is
    applied to the pointer, the correct method for what the object truly is should
    be applied, rather than the method that *seems* appropriate for the generalized
    pointer type.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，指向派生类实例的指针会被泛化为指向基类类型的指针。当对指针应用操作时，应该应用对象真正的方法，而不是对泛化指针类型似乎合适的方法。
- en: Let's begin with the relevant keywords and logistics necessary to define virtual
    functions so that we may implement polymorphism.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义虚函数所需的相关关键字和逻辑开始，以便我们可以实现多态性。
- en: Defining virtual functions and overriding base class methods
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义虚函数并重写基类方法
- en: '**Virtual functions** in C++ directly support polymorphism. A **virtual function**
    is:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的**虚函数**直接支持多态性。**虚函数**是：
- en: A member function that correctly allows methods for a given operation to be
    overridden successively in a hierarchy to provide more suitable definitions.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个成员函数，允许为给定操作的方法在层次结构中被连续重写以提供更合适的定义。
- en: A member function that allows dynamic, rather than the usual static binding
    for methods.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许动态绑定方法而不是通常的静态绑定的成员函数。
- en: 'A virtual function is specified using the keyword **virtual**. More specifically:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用关键字**virtual**指定虚函数。更具体地说：
- en: The keyword `virtual` should precede the return type of the function in its
    prototype.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字`virtual`应该在函数原型中的返回类型之前。
- en: Functions in the derived class with the same name and signature as a virtual
    function in any ancestor class redefine the virtual function in those base classes.
    Here, the keyword `virtual` is optional but recommended in the derived class prototype.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在派生类中具有与任何祖先类中虚函数相同名称和签名的函数会重新定义这些基类中的虚函数。在这里，关键字`virtual`是可选的，但在派生类原型中是推荐的。
- en: Functions with the same name, yet a different signature in a derived class,
    do not redefine a virtual function in their base class; rather they hide the methods
    found in their base classes.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在派生类中具有相同名称但不同签名的函数不会重新定义其基类中的虚函数；而是隐藏其基类中的方法。
- en: Optionally, the keyword `override` can be added as part of the extended signature
    in the derived class prototype. This recommended practice will allow the compiler
    to flag an error if the signature of the intended overridden method does not match
    the signature as specified in the base class. The `override` keyword can eliminate
    un-intended function hiding.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在派生类原型中，可以选择性地添加关键字`override`作为扩展签名的一部分。这种推荐做法将允许编译器在预期重写的方法的签名与基类中指定的签名不匹配时标记错误。`override`关键字可以消除意外的函数隐藏。
- en: The derived class need not redefine virtual functions specified in its base
    class if the inherited methods are suitable. However, should a derived class redefine
    an operation with a new method, the same signature (as specified by the base class)
    must be used for the overridden method. Furthermore, derived classes should only
    redefine virtual functions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 派生类如果继承的方法适用，就不需要重新定义基类中指定的虚函数。然而，如果派生类用新方法重新定义一个操作，必须使用与被覆盖方法相同的签名（由基类指定）。此外，派生类应该只重新定义虚函数。
- en: 'Here is a simple example to illustrate the basic syntax:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子来说明基本语法：
- en: '`Print()` is a virtual function defined in the base class `Person`. It will
    be overridden with a more appropriate implementation in the `Student` class:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Print()`是在基类`Person`中定义的虚函数。它将被`Student`类中更合适的实现所覆盖：'
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The virtual function defined in the base class `Person` is, in fact, overridden
    with a more appropriate implementation in the `Student` class:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基类`Person`中定义的虚函数实际上是在`Student`类中用更合适的实现进行了覆盖：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Remember, polymorphic functions are meant to have the ability to override or
    replace base class versions of a given function. Function overriding differs from
    function overloading.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，多态函数的目的是具有覆盖或替换给定函数的基类版本的能力。函数重写与函数重载不同。
- en: Important distinction
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 重要区别
- en: '**Function overriding** is defined by introducing the same function name with
    the same signature, in a hierarchy of related classes (via virtual functions),
    whereas the derived class version is meant to replace the base class version.
    In contrast, **function overloading** is defined when two or more functions with
    the same name, but with different signatures, exist in the same scope of the program
    (such as in the same class).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数重写**是通过在相关类的层次结构中引入相同的函数名称和签名（通过虚函数）来定义的，而派生类版本旨在替换基类版本。相比之下，**函数重载**是在程序的同一作用域中存在两个或更多具有相同名称但不同签名的函数时定义的（比如在同一个类中）。'
- en: Additionally, operations not initially specified as virtual when introduced
    in a base class definition are not polymorphic and therefore should not be overridden
    in any derived class. This means that if a base class does not use the keyword
    `virtual` when defining an operation, the base class does not intend for the derived
    class to redefine this operation with a more suitable derived class method. The
    base class instead is insisting that the implementation it has provided is suitable
    for *any* of its descendants. Should the derived class attempt to redefine a non-virtual
    base class operation, a subtle bug will be introduced into the application. The
    error will be that derived class instances stored using derived class pointers
    will use the derived class method, yet derived class instances stored using base
    class pointers will use the base class definition. Instances should always use
    their own behavior irrespective of how they are stored – this is the point of
    polymorphism. Never redefine a non-virtual function.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在基类定义中最初未指定为虚拟的操作也不是多态的，因此不应该在任何派生类中被覆盖。这意味着，如果基类在定义操作时没有使用关键字`virtual`，那么基类并不打算让派生类用更合适的派生类方法重新定义这个操作。相反，基类坚持认为它提供的实现适用于*任何*它的后代。如果派生类尝试重新定义一个非虚拟的基类操作，将会在应用程序中引入一个微妙的错误。错误将是，使用派生类指针存储的派生类实例将使用派生类方法，而使用基类指针存储的派生类实例将使用基类定义。实例应该始终使用自己的行为，而不管它们是如何存储的
    - 这就是多态的意义。永远不要重新定义非虚函数。
- en: Important note
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Operations not specified in a base class as virtual in C++ are not polymorphic,
    and should never be overridden by a derived class.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，未在基类中指定为虚拟的操作不是多态的，也不应该被派生类覆盖。
- en: Let's move forward and discover scenarios when we may desire to collect derived
    class objects by a base class type, and when we may then need to qualify our destructors
    as virtual.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进，发现我们可能希望通过基类类型收集派生类对象的情况，以及我们可能需要将我们的析构函数标记为虚拟的情况。
- en: Generalizing derived class objects
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛化派生类对象
- en: When we view an inheritance hierarchy, it is typically one that employs public
    base classes; that is, it is a hierarchy that utilizes public inheritance to express
    Is-A relationships. When using inheritance in this manner, we may be motivated
    to collect groups of related instances together. For example, a hierarchy of `Student`
    specializations might include `GraduateStudent`, `UnderGraduateStudent`, and `NonDegreeStudent`.
    Assuming each of these derived classes has a public base class of `Student`, it
    would be appropriate to say a `GraduateStudent` *Is-A* `Student`, and so on.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看继承层次结构时，通常是使用公共基类的层次结构；也就是说，这是一个使用公共继承来表达Is-A关系的层次结构。以这种方式使用继承时，我们可能会被激励将相关实例的组合在一起。例如，`Student`专业化的层次结构可能包括`GraduateStudent`、`UnderGraduateStudent`和`NonDegreeStudent`。假设这些派生类中的每一个都有一个名为`Student`的公共基类，那么说`GraduateStudent`
    *是一个* `Student`，等等，就是合适的。
- en: We may find a reason in our application to group these somewhat like instances
    together into one common set. For example, imagine that we are implementing a
    billing system for a university. The university may wish for us to collect all
    students, regardless of their derived class types, into one set to process them
    uniformly, such as to calculate their semester bills.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会在我们的应用程序中找到一个理由，将这些类似的实例组合到一个共同的集合中。例如，想象一下，我们正在为一所大学实现一个计费系统。大学可能希望我们将所有学生，无论其派生类类型如何，收集到一个集合中以便统一处理，比如计算他们的学期账单。
- en: The `Student` class may have a polymorphic operation to `CalculateSemesterBill()`,
    which is implemented as a virtual function in `Student` with a default method.
    However, selected derived classes, such as `GraduateStudent`, may have preferred
    implementations that they wish to provide by overriding the operation in their
    own class with a more appropriate method. A `GraduateStudent`, for example, may
    have a different method to compute their total bill versus `NonDegreeStudent`.
    Hence, each derived class may override the default implementation of `CalculateSemesterBill()`
    in each of their classes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Student`类可能有一个多态操作`CalculateSemesterBill()`，它在`Student`中作为一个虚拟函数实现了一个默认方法。然而，选择的派生类，比如`GraduateStudent`，可能有他们希望通过在自己的类中覆盖操作来提供的首选实现。例如，`GraduateStudent`可能有一个不同的方法来计算他们的总账单与`NonDegreeStudent`。因此，每个派生类可以覆盖其类中`CalculateSemesterBill()`的默认实现。'
- en: Nonetheless, in our bursar application, we can create a set of pointers of type
    `Student`, though each pointer will inevitably point to instances of the derived
    class types, such as `GraduateStudent`, `UnderGraduateStudent`, and `NonDegreeStudent`.
    When instances of derived class types have been generalized in this fashion, it
    is appropriate to apply functions (often virtual) to the set as are defined in
    the base class level corresponding to the pointer type of the collection. Virtual
    functions allow these generalized instances to invoke a polymorphic operation
    to yield their individual, derived class methods or implementations of these functions.
    This is exactly what we want. But, there are still more details to understand.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，在我们的财务应用程序中，我们可以创建一个`Student`类型的指针集合，尽管每个指针最终都会指向派生类类型的实例，比如`GraduateStudent`、`UnderGraduateStudent`和`NonDegreeStudent`。当以这种方式泛化派生类类型的实例时，适用于集合指针类型的基类级别中定义的函数（通常是虚拟函数）是合适的。虚拟函数允许这些泛化的实例调用多态操作，以产生它们各自的派生类方法或这些函数的实现。这正是我们想要的。但是，还有更多细节需要理解。
- en: This basic premise of generalizing derived class instances will allow us to
    understand why we may need virtual destructors within many of our class definitions.
    Let's take a look.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个推广派生类实例的基本前提将使我们理解为什么我们可能需要在许多类定义中使用虚拟析构函数。让我们来看一下。
- en: Utilizing virtual destructors
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用虚拟析构函数
- en: We can now conceptualize situations when grouping derived class instances into
    a somewhat alike set, stored by their common base class type, may be useful. It
    is actually very powerful to collect sibling-type derived class instances by their
    base class type and employ virtual functions to allow their distinct behaviors
    to shine through.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以概念化一下，将派生类实例按其共同的基类类型分组，并通过虚拟函数允许它们的不同行为显现出来可能是有用的情况。通过它们的基类类型收集同类派生类实例，并利用虚拟函数允许它们独特的行为显现出来，实际上是非常强大的。
- en: But let's consider what happens when the memory for a derived class instance,
    stored by a base class pointer, goes away. We know its destructor is called, but
    which one? We actually know that a chain of destructors is called, starting with
    the destructor of the object type in question. But how do we know the actual derived
    class object type if the instance has been genericized by being stored using a
    base class pointer? A **virtual destructor** solves this issue.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当存储在基类指针中的派生类实例的内存消失时会发生什么呢？我们知道它的析构函数被调用了，但是哪一个？实际上，我们知道一系列的析构函数被调用，从问题对象类型的析构函数开始。但是，如果实例通过存储使用基类指针而被泛型化，我们如何知道实际的派生类对象类型呢？一个**虚拟析构函数**解决了这个问题。
- en: By labeling a destructor as `virtual`, we are allowing it to be overridden as
    the *starting point* in the destruction sequence for a class and any of its descendants.
    The choice as to which destructor to use as the entry point of destruction will
    be deferred to runtime, using dynamic binding, based on the object's actual type,
    not what pointer type may be which references it. We will soon see how this process
    is automated by examining C++'s underlying virtual function table.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将析构函数标记为`virtual`，我们允许它被覆盖为类及其后代的销毁序列的*起点*。选择使用哪个析构函数作为销毁的入口点将推迟到运行时，使用动态绑定，基于对象的实际类型，而不是引用它的指针类型。我们很快将看到，这个过程是如何通过检查C++的底层虚拟函数表自动化的。
- en: A virtual destructor, unlike all other virtual functions, actually specifies
    the starting point for a full sequence of functions to be executed. Recall, as
    the last line of code in a destructor, the compiler automatically patches in a
    call to call the immediate base class destructor, and so on, until we reach the
    initial base class in the hierarchy. The destruction chain exists to provide a
    forum to release dynamically allocated data members in all sub-objects of a given
    instance. Contrasting this behavior to other virtual functions, those merely allow
    the single, correct version of the function to be executed (unless the programmer
    chooses to call a base class version of the same function as a helper function
    during the derived method implementation).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有其他虚拟函数不同，虚拟析构函数实际上指定了要执行的一系列函数的起点。回想一下，作为析构函数的最后一行代码，编译器会自动修补一个调用来调用直接基类的析构函数，依此类推，直到我们达到层次结构中的初始基类。销毁链的存在是为了提供一个释放给定实例的所有子对象中动态分配的数据成员的论坛。将这种行为与其他虚拟函数进行对比，其他虚拟函数仅允许执行函数的单一正确版本（除非程序员选择在派生方法实现期间调用相同函数的基类版本作为辅助函数）。
- en: You may ask why is it important to start the destruction sequence at the proper
    level? That is, at the level that matches the object's actual type (versus a generalized
    pointer type, which may point to the object). Recall, each class may have dynamically
    allocated data members. The destructor will deallocate these data members. Starting
    with the correct level destructor will ensure that you do not introduce any memory
    leaks into your application by forgoing appropriate destructors and their corresponding
    memory deallocations.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问为什么在正确的级别开始销毁序列很重要？也就是说，在与对象的实际类型匹配的级别（而不是通用指针类型，可能指向对象）。请记住，每个类可能有动态分配的数据成员。析构函数将释放这些数据成员。从正确级别的析构函数开始将确保您不会通过放弃适当的析构函数及其相应的内存释放而引入任何内存泄漏到您的应用程序中。
- en: Are virtual destructors always necessary? That is a good question! Virtual destructors
    are always necessary when using a public base class hierarchy, that is, when using
    public inheritance. Recall, public base classes support Is-A relationships, which
    easily leads to allowing a derived class instance to be stored using a pointer
    of its base class type. For example, a `GraduateStudent` *Is-A* `Student`, so
    we can store a `GraduateStudent` as a `Student` at times when we require more
    generic processing along with its sibling types. We can always upcast in this
    fashion across a public inheritance boundary. However, when we use implementation
    inheritance (that is, private or protected base classes), upcasting is not allowed.
    So, for hierarchies employing private or protected inheritance, virtual destructors
    are not necessary because upcasting is simply disallowed; hence, it would never
    be ambiguous as to which destructor should be the entry point for classes in private
    and protected base class hierarchies. As a second example, we did not include
    a virtual destructor in our `LinkedList` class in [*Chapter 6*](B15702_06_Final_NM_ePub.xhtml#_idTextAnchor262),
    *Implementing Hierarchies with Single Inheritance*; therefore, `LinkedList` should
    only be extended as a protected or private base class. We did, however, include
    a virtual destructor in our `Queue` and `PriorityQueue` classes because `PriorityQueue`
    uses `Queue` as a public base class. A `PriorityQueue` may be upcast to a `Queue`
    (but not to a `LinkedList`), necessitating the virtual destructor introduction
    at the `Queue` and its descendent levels in the hierarchy.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 虚析构函数总是必要的吗？这是一个很好的问题！当使用公共基类层次结构时，即使用公共继承时，虚析构函数总是必要的。请记住，公共基类支持Is-A关系，这很容易导致允许使用其基类类型的指针存储派生类实例。例如，`研究生`
    *是* `学生`，因此我们有时可以将`研究生`存储为`学生`，以便在需要更通用的处理时与其兄弟类型一起处理。我们可以始终以这种方式在公共继承边界上进行向上转型。然而，当我们使用实现继承（即私有或受保护的基类）时，不允许向上转型。因此，在使用私有或受保护继承的层次结构中，虚析构函数是不必要的，因为向上转型是被简单地禁止的；因此，对于私有和受保护基类层次结构中的类，哪个析构函数应该是入口点永远不会是模糊的。作为第二个例子，在[*第6章*](B15702_06_Final_NM_ePub.xhtml#_idTextAnchor262)中，我们的`LinkedList`类中没有包含虚析构函数；因此，`LinkedList`应该只作为受保护或私有基类扩展。然而，我们在`Queue`和`PriorityQueue`类中包含了虚析构函数，因为`PriorityQueue`使用`Queue`作为公共基类。`PriorityQueue`可以向上转型为`Queue`（但不能向上转型为`LinkedList`），因此在层次结构中的`Queue`及其后代级别引入虚析构函数是必要的。
- en: Are the optional keywords `virtual` and `override` recommended when overriding
    a virtual destructor? That's also a good question. We know that an overridden
    destructor is only the starting point in the destruction sequence. We also know
    that unlike other virtual functions, the derived class destructor will have a
    unique name from the base class destructor. Even though a derived class destructor
    automatically overrides a base class destructor that has been declared as `virtual`,
    the usage of the *optional* keyword `virtual` is recommended in the derived class
    destructor prototype for documentation. However, the usage of the *optional* keyword
    `override` in the derived class destructor is generally not used. The reasoning
    is that the `override` keyword is meant to provide a safety net to catch spelling
    mistakes between originally defined and overridden functions. With destructors,
    the function names are not the same, hence this safety net is not an error-checking
    advantage.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在重写虚析构函数时，是否建议使用可选关键字`virtual`和`override`？这也是一个很好的问题。我们知道，重写的析构函数只是销毁顺序的起点。我们也知道，与其他虚函数不同，派生类的析构函数将与基类的析构函数有一个唯一的名称。尽管派生类的析构函数会自动重写已声明为`virtual`的基类析构函数，但在派生类析构函数原型中使用*可选*关键字`virtual`是为了文档化而推荐的。然而，在派生类析构函数中通常不使用*可选*关键字`override`。原因是`override`关键字旨在提供一个安全网，以捕捉原始定义和重写函数之间的拼写错误。对于析构函数，函数名称并不相同，因此这个安全网并不是一个错误检查的优势。
- en: Let's continue by putting all the necessary pieces together so we can see virtual
    functions of all varieties, including destructors, in action.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续把所有必要的部分放在一起，这样我们就可以看到各种类型的虚函数，包括析构函数，如何发挥作用。
- en: Putting all the pieces together
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 把所有的部分放在一起
- en: So far, in this chapter, we have understood the nuances of virtual functions,
    including virtual destructors. It is important to see our code in action, with
    all its various components and details. We need to see in one cohesive program
    the basic syntax to specify virtual functions, including how we may collect derived
    class instances by base class types, and see how virtual destructors play a role.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经了解了虚函数的微妙之处，包括虚析构函数。重要的是要看到我们的代码在实际操作中，以及它的各种组件和细节。我们需要在一个连贯的程序中看到基本语法来指定虚函数，包括如何通过基类类型收集派生类实例，以及虚析构函数如何发挥作用。
- en: 'Let''s take a look at a more complex, full program example to fully illustrate
    polymorphism, implemented using virtual functions in C++. This example will be
    broken into many segments; the full program can be found at the following GitHub
    location:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个更复杂的、完整的程序示例，以完全说明多态性，使用C++中的虚函数实现。这个例子将被分成许多段；完整的程序可以在以下GitHub位置找到：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter07/Chp7-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter07/Chp7-Ex1.cpp)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter07/Chp7-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter07/Chp7-Ex1.cpp)'
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the aforementioned class definition, we have augmented our familiar class
    for `Person`, adding four virtual functions, namely, the destructor (`~Person()`),
    `Print()`, `IsA()`, and `Greeting(const char *)`. Notice that we have simply placed
    the keyword `virtual` in front of the return type (if any) of each member function.
    The remainder of the class definition is as we have explored in depth in the previous
    chapter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述的类定义中，我们对`Person`这个熟悉的类进行了扩充，添加了四个虚函数，即析构函数(`~Person()`)，`Print()`，`IsA()`和`Greeting(const
    char *)`。请注意，我们只是在每个成员函数的返回类型（如果有的话）前面加上了关键字`virtual`。类定义的其余部分就像我们在上一章中深入探讨过的那样。
- en: 'Now, let''s examine the non-inline member function definitions for `Person`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下`Person`的非内联成员函数定义：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the previous segment of code, we have specified all of the non-inline member
    functions of `Person`. Notice that the four virtual functions—the destructor,
    `Print()`, `IsA()`, and `Greeting()`—do not include the `virtual` keyword in the
    methods (that is, member function definitions) themselves.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码段中，我们指定了`Person`的所有非内联成员函数。请注意，这四个虚函数——析构函数，`Print()`，`IsA()`和`Greeting()`——在方法（即成员函数定义）本身中不包括`virtual`关键字。
- en: 'Next, let''s examine the `Student` class definition:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来看一下`Student`类的定义：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the previous class definition for `Student`, we again have all of the assorted
    components we are accustomed to seeing to comprise this class. Additionally, notice
    that we have defined three virtual functions—the destructor, `Print()`, and `IsA()`.
    These preferred definitions essentially replace or override the default methods
    specified for these operations in the base class. Notice, however, that we choose
    not to redefine `void Person::Greeting(const char *)`, which was introduced as
    a virtual function in the `Person` class. Simply inheriting this method is fine
    if we find the inherited definition acceptable for instances of the `Student`
    class.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的`Student`类定义中，我们再次看到了构成这个类的所有各种组件。另外，请注意，我们定义了三个虚函数——析构函数，`Print()`和`IsA()`。这些首选定义基本上取代了这些操作在基类中指定的默认方法。然而，请注意，我们选择不重新定义`void
    Person::Greeting(const char *)`，这个方法在`Person`类中被引入为虚函数。如果我们发现继承的定义对`Student`类的实例是可以接受的，那么简单地继承这个方法就可以了。
- en: Recall, the meaning of `virtual` when paired with a destructor is unique, in
    that it does not imply that the derived class destructor replaces the base class
    destructor. Instead, it means that the derived class destructor is the correct
    beginning point for the *chain of destruction* sequence when initiated by derived
    class instances (irrespective of how they are stored).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当虚函数与析构函数配对时，它的含义是独特的，它并不意味着派生类的析构函数取代了基类的析构函数。相反，它意味着当由派生类实例发起*销毁链*序列时，派生类析构函数是正确的起始点（无论它们是如何存储的）。
- en: Also, remember, the derived class of `Student` is not required to override a
    virtual function that is defined in `Person`. Should the `Student` class find
    the base class method acceptable, it is automatically inherited. Virtual functions
    merely allow the derived class to redefine an operation with a more appropriate
    method when so needed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，`Student`的派生类不需要覆盖在`Person`中定义的虚函数。如果`Student`类发现基类方法是可以接受的，它会自动继承。虚函数只是允许派生类在需要时用更合适的方法重新定义操作。
- en: 'Next, let''s examine the non-inline `Student` class member functions:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来看一下`Student`类的非内联成员函数：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the previously listed section of code, we list the non-inline member function
    definitions for `Student`. Again, notice that the keyword `virtual` will not appear
    in any of the non-inline member function definitions themselves, only in their
    respective prototypes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前列出的代码段中，我们列出了`Student`的非内联成员函数定义。同样，请注意，关键字`virtual`不会出现在任何非内联成员函数定义本身中，只会出现在它们各自的原型中。
- en: 'Lastly, let''s examine the `main()` function:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来看一下`main()`函数：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, in `main()`, we declare an array of pointers to `Person`. Doing so allows
    us to collect both `Person` and `Student` instances in this set. Of course, the
    only operations we may apply to instances stored in this generalized fashion are
    those found in the base class, `Person`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`中，我们声明了一个指向`Person`的指针数组。这样做可以让我们在这个集合中收集`Person`和`Student`的实例。当然，我们可以对以这种泛化方式存储的实例应用的唯一操作是在基类`Person`中找到的操作。
- en: Next, we allocate several `Person` and several `Student` instances, storing
    each instance via an element in the generalized set of pointers. When a `Student`
    is stored in this fashion, an up-cast to the base class type is performed (but
    the instance is not altered in any fashion). Recall, when we looked at memory
    layout for derived class instances in [*Chapter 6*](B15702_06_Final_NM_ePub.xhtml#_idTextAnchor262),
    *Implementing Hierarchies with Single Inheritance*, we noticed that a `Student`
    instance first includes the memory layout of a `Person`, followed by the additional
    memory required for `Student` data members. This up-cast merely points to the
    starting point of this collective memory.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们分配了几个`Person`和几个`Student`的实例，将每个实例通过一个指针的泛化集合中的元素存储起来。当以这种方式存储`Student`时，会执行向基类类型的向上转型（但实例本身不会被改变）。请记住，当我们在[*第6章*](B15702_06_Final_NM_ePub.xhtml#_idTextAnchor262)中查看单继承的层次结构的内存布局时，我们注意到`Student`实例首先包括`Person`的内存布局，然后是`Student`数据成员所需的额外内存。这种向上转型只是指向这个集体内存的起始点。
- en: Now, we proceed through a loop to apply operations as found in the `Person`
    class to all instances in this generalized collection. These operations happen
    to be polymorphic. That is, the virtual functions allow the specific implementation
    for methods to be called through runtime binding to match the actual object type
    (irrespective of the fact that the object may be stored in a generalized pointer).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们通过循环将`Person`类中找到的操作应用于这个泛化集合中的所有实例。这些操作恰好是多态的。也就是说，虚拟函数允许通过运行时绑定调用方法的具体实现，以匹配实际对象类型（不管对象是否存储在泛化指针中）。
- en: Lastly, we loop through deleting the dynamically allocated instances of `Person`
    and `Student`, again using the generalized `Person` pointers. Because we know
    `delete()` will patch in a call to the destructor, we wisely have made the destructors
    `virtual`, enabling dynamic binding to choose the appropriate starting destructor
    (in the destruction chain) for each object.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过循环删除动态分配的`Person`和`Student`实例，再次使用泛化的`Person`指针。因为我们知道`delete()`会调用析构函数，我们明智地将析构函数设为`virtual`，使得动态绑定可以选择适当的起始析构函数（在销毁链中）来销毁每个对象。
- en: 'When we look at the output for the aforementioned program, we can see that
    the specific method for each object is appropriately called for each virtual function,
    including the destruction sequence. Here is the output for the full program example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看上述程序的输出时，可以看到对于每个虚拟函数，都适当地调用了每个对象的特定方法，包括销毁序列。以下是完整程序示例的输出：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that we have competency utilizing the concept of polymorphism and the mechanics
    of virtual functions, let's take a look at a less usual situation relating to
    virtual functions, that of function hiding.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了多态的概念和虚拟函数的机制，让我们来看一下与虚拟函数相关的不太常见的情况，即函数隐藏。
- en: Considering function hiding
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 考虑函数隐藏
- en: '**Function hiding** is not an often-used feature of C++. In fact, it is often
    employed quite by accident! Let''s review a key point we know about inherited
    member functions to get started. When an operation is specified by a base class,
    it is intended to provide a protocol for usage and redefinition (in the case of
    virtual functions) for all derived class methods.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数隐藏**并不是C++中经常使用的特性。事实上，它经常是意外使用的！让我们回顾一下我们对继承成员函数的了解。当一个操作由基类指定时，它旨在为所有派生类方法提供使用和重新定义的协议（对于虚函数的情况）。'
- en: Sometimes, a derived class will alter the signature of a method that is intended
    to redefine an operation specified by a base class (let's think of virtual functions).
    In this case, the new function, which differs in signature from the operation
    specified in its ancestor class, will not be considered a virtual redefinition
    of the inherited operation. In fact, it will *hide* inherited methods for the
    virtual function that have the same name specified in ancestor classes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，派生类会改变一个方法的签名，这个方法是用来重新定义基类指定的操作（比如虚函数）。在这种情况下，新的函数与祖先类中指定的操作在签名上不同，将不被视为继承操作的虚拟重新定义。事实上，它会*隐藏*祖先类中具有相同名称的虚拟函数的继承方法。
- en: 'When programs are compiled, the signature of each function is compared against
    the class definition for correct usage. Typically, when a member function is not
    found in the class that *seemingly* matches the instance type, the hierarchy is
    traversed in an upward fashion until such a match is found or until the hierarchy
    is exhausted. Let us take a closer look at what the compiler contemplates:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序编译时，会将每个函数的签名与类定义进行比较，以确保正确使用。通常情况下，当在类中找不到与实例类型*看似*匹配的成员函数时，会向上遍历继承链，直到找到匹配项或者继承链耗尽为止。让我们更仔细地看一下编译器考虑的内容：
- en: When a function is found with the same name as the function being sought out,
    the signature is examined to see if it matches the function call exactly, or if
    type conversion can be applied. When the function is found, yet type conversion
    cannot be applied, the normal traversal sequence is ended.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当找到一个与所寻找的函数同名的函数时，将检查其签名，看它是否与函数调用完全匹配，或者是否可以应用类型转换。当找到函数时，但无法应用类型转换时，正常的遍历顺序就结束了。
- en: Functions that hide virtual functions normally halt this upward search sequence,
    thus hiding a virtual function that otherwise may have been invoked. Recall, at
    compile time, we are just checking syntax (not deciding which version of a virtual
    function to call). But if we can't find a match, an error is flagged.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常情况下，隐藏虚拟函数的函数会中止这种向上搜索序列，从而隐藏了本来可能被调用的虚拟函数。请记住，在编译时，我们只是检查语法（而不是决定调用哪个版本的虚拟函数）。但如果我们找不到匹配项，就会报错。
- en: Function hiding is actually considered helpful and was intended by the language.
    If the class designer provided a specific function with a given signature and
    interface, that function should be used for instances of that type. Hidden or
    unsuspected functions mentioned previously in the hierarchy should not be used
    in this specific scenario.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数隐藏实际上被认为是有帮助的，并且是语言所期望的。如果类设计者提供了一个具有特定签名和接口的特定函数，那么该函数应该用于该类型的实例。在这种特定情况下，不应该使用在继承链中之前隐藏或未知的函数。
- en: 'Consider the following modification to our previous full program example to
    first illustrate function hiding, and to then provide a more flexible solution
    managing function hiding:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑对我们之前的完整程序示例进行以下修改，首先说明函数隐藏，然后提供一个更灵活的解决方案来管理函数隐藏：
- en: 'Recall that the `Person` class introduces `virtual void Print()` with no parameters.
    Imagine that `Student`, instead of overriding `Print()` with the same signature,
    changes the signature to `virtual void Print(const char *)`:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请记住，`Person`类引入了没有参数的`virtual void Print()`。想象一下，`Student`不是用相同的签名覆盖`Print()`，而是将签名更改为`virtual
    void Print(const char *)`。
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s look at some of the cumbersome code that might ensue:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些可能出现的冗长代码：
- en: 'Explicit down casting or use of the scope resolution operator may be required
    to reveal an otherwise hidden function:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能需要显式向下转型或使用作用域解析运算符来揭示一个被隐藏的函数：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the aforementioned example, we have a generalized set of two `Person` pointers.
    One entry points to a `Person` and one entry points to a `Student`. Once the `Student`
    is generalized, the only applicable operations are those found in the `Person`
    base class. Therefore, a call to `people[1]->Print();` works and a call to `people[1]->Print("Go
    Team!");` does not work. The latter call to `Print(const char *)` is an error
    at the generalized base class level, even though the object truly is a `Student`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，我们有一个包含两个`Person`指针的广义集合。一个指向`Person`，一个指向`Student`。一旦`Student`被泛化，唯一适用的操作就是在`Person`基类中找到的操作。因此，对`people[1]->Print();`的调用有效，而对`people[1]->Print("Go
    Team!");`的调用无效。对`Print(const char *)`的后者调用在广义基类级别上是一个错误，尽管对象实际上是`Student`。
- en: If, from a generalized pointer, we wish to call specific functions found at
    the `Student` level in the hierarchy, we will then need to downcast the instance
    back to its own type (`Student`). We add a downcast with the call `((Student *)
    people[1])->Print("I have to study");`. Here, we are taking a risk – if `people[1]`
    was actually a `Person` and not a `Student`, this would generate a runtime error.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望从一个广义指针调用层次结构中`Student`级别的特定函数，我们就需要将实例向下转型回其自身类型（`Student`）。我们通过调用`((Student
    *) people[1])->Print("I have to study");`来进行向下转型。在这里，我们承担了一定的风险 - 如果`people[1]`实际上是`Person`而不是`Student`，这将生成运行时错误。
- en: Next, we instantiate `Student s1;`. Should we try to call `s1.Print()`, we'll
    get a compiler error – `Student::Print(const char *)` hides the base class presence
    of `Person::Print()`. Remember, `s1` is stored in its own type, `Student`, and
    since `Student::Print(const char *)` is found, the traversal upward to otherwise
    uncover `Person::Print()` is halted.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实例化`Student s1;`。如果我们尝试调用`s1.Print()`，我们将会得到一个编译器错误 - `Student::Print(const
    char *)`隐藏了`Person::Print()`的存在。请记住，`s1`存储在其自身类型`Student`中，因此找到`Student::Print(const
    char *)`后，向上遍历以揭示`Person::Print()`被阻止了。
- en: Nonetheless, our call to `s1.Print("I got an A!");` is successful because `Print(const
    char *)` is found at the `Student` class level. Lastly, notice that the call to
    `s1.Person::Print();` works, but requires knowledge of the otherwise hidden function.
    By using the scope resolution operator (`::`), we can find the base class version
    of `Print()`. Even though `Print()` is virtual in the base class (implying dynamic
    binding), using the scope resolution operation reverts this call to a statically
    bound function call.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们对`s1.Print("I got an A!");`的调用是成功的，因为`Print(const char *)`在`Student`类级别找到了。最后，请注意，对`s1.Person::Print();`的调用是有效的，但需要了解被隐藏的函数。通过使用作用域解析运算符（`::`），我们可以找到`Print()`的基类版本。即使`Print()`在基类中是虚拟的（意味着动态绑定），使用作用域解析操作将此调用恢复为静态绑定的函数调用。
- en: Let's propose that we would like to add a new interface to a derived class with
    a function that would otherwise hide a base class function. Knowing about function
    hiding, what should we ideally do? We could simply override the virtual function
    as found in the base class with a new method in the derived class, and then we
    could overload that function to add the additional interface. Yes, we're now both
    overriding and overloading. That is, we are overriding the base class function,
    and overloading the overridden function in the derived class.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要向派生类添加一个新的接口，其中的函数会隐藏基类函数。了解函数隐藏后，我们应该怎么做？我们可以简单地在派生类中重写基类中找到的虚函数，并且可以重载该函数以添加额外的接口。是的，我们现在既重写又重载。也就是说，我们重写了基类函数，并在派生类中重载了被重写的函数。
- en: 'Let''s take a look at what we would now have:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们现在会得到什么：
- en: 'Here is the more flexible interface to add the new member function while keeping
    the existing interface that would otherwise be hidden:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是添加新成员函数的更灵活接口，同时保留原本可能被隐藏的现有接口：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Overall, function hiding does not surface often. But when it does, it is often
    an unwelcome surprise. Now you understand what may happen and why, making you
    a better programmer.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，函数隐藏并不经常出现。但当出现时，通常会给人带来不必要的惊喜。现在你了解了可能发生的情况以及原因，这会让你成为一个更好的程序员。
- en: Now that we have looked at all the uses surrounding virtual functions, let's
    look under the hood to see why virtual functions are able to support the dynamic
    binding of a specific method to an operation. To thoroughly understand runtime
    binding, we will need to look at the v-table. Let's move forward!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过了所有关于虚函数的用法，让我们来看看为什么虚函数能够支持将特定方法动态绑定到操作上。为了彻底理解运行时绑定，我们需要看一下虚函数表。让我们继续前进！
- en: Understanding dynamic binding
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解动态绑定
- en: Now that we have seen how polymorphism is implemented with virtual functions
    to allow for dynamic binding of an operation to a specific implementation or method,
    let's understand why virtual functions allow for runtime binding.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了多态是如何通过虚函数实现的，以允许将操作动态绑定到特定的实现或方法，让我们了解为什么虚函数允许运行时绑定。
- en: Non-virtual functions are statically bound at compile time. That is, the address
    of the function in question is determined at compile time, based on the assumed
    type of the object at hand. For example, if an object is instantiated of type
    `Student`, a function call would have its prototype verified starting with the
    `Student` class, and if not found, the hierarchy would be traversed upward to
    each base class, such as `Person`, to look for the matching prototype. When found,
    the correct function call would be patched in. This is how static binding works.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 非虚函数在编译时静态绑定。也就是说，所涉及函数的地址是在编译时确定的，基于手头对象的假定类型。例如，如果实例化了类型为`Student`的对象，函数调用将从`Student`类开始验证其原型，并且如果找不到，将向上遍历每个基类，如`Person`，以寻找匹配的原型。找到后，正确的函数调用将被修补。这就是静态绑定的工作原理。
- en: However, a virtual function is a type of function in C++ that employs a dynamic
    binding at runtime. At compile time, any virtual function call is merely replaced
    with a lookup mechanism to delay binding until runtime. Certainly, each compiler
    vendor may differ in their implementation of automating virtual functions. However,
    there is a widely utilized implementation that involves virtual function pointers,
    a virtual function table, and virtual function table entries for each object type
    containing virtual functions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，虚函数是C++中一种在运行时使用动态绑定的函数类型。在编译时，任何虚函数调用都仅仅被替换为一个查找机制，以延迟绑定直到运行时。当然，每个编译器供应商在自动化虚函数方面的实现可能有所不同。然而，有一种广泛使用的实现涉及虚函数指针、虚函数表和包含虚函数的每种对象类型的虚函数表条目。
- en: Let's move forward to investigate how dynamic binding is commonly implemented
    in C++.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续调查C++中动态绑定是如何常见实现的。
- en: Comprehending runtime binding of methods to operations
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解方法与操作的运行时绑定
- en: We know that virtual functions allow for the dynamic binding of an operation
    (specified in a base class) to a specific implementation or method (often specified
    in a derived class). How does this work?
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道虚函数允许将操作（在基类中指定）动态绑定到特定的实现或方法（通常在派生类中指定）。这是如何工作的？
- en: When a base class specifies one or more new virtual functions (not just redefinitions
    of an ancestor's virtual functions), a **virtual function pointer** (**vptr**)
    is created below the memory comprising a given instance of that type. This happens
    at runtime when the memory for an instance is created (on the stack, heap, or
    static/extern area). When the instance in question is constructed, not only will
    the appropriate constructor be called to initialize the instance, but this VPTR
    will be initialized to point to the **virtual function pointer table** (**v-table**)
    entry for that class type.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当基类指定一个或多个新的虚函数（不仅仅是祖先虚函数的重新定义）时，在给定类型的实例的内存下方将创建一个**虚函数指针**（vptr）。这发生在运行时，当为实例创建内存时（在堆栈、堆或静态/外部区域）。当涉及的实例被构造时，不仅将调用适当的构造函数来初始化实例，而且这个VPTR将被初始化为指向该类类型的**虚函数指针表**（v-table）条目。
- en: The v-table entry for a given class type will consist of a set of function pointers.
    These function pointers are often organized into an array of function pointers.
    A **function pointer** is a pointer to an actual function. By dereferencing this
    pointer, you will actually invoke the function to which the pointer points. There
    is an opportunity to pass arguments to the function, however, in order for this
    call to be generic through a function pointer, the arguments must be uniform for
    any version of this function that the pointer in question may point to. The premise
    of a function pointer gives us the ability to point to different versions of a
    particular function. That is, we could point to different methods for a given
    operation. This is the basis for which we can automate dynamic binding in C++
    for virtual functions.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 给定类类型的虚函数表（v-table）条目将由一组函数指针组成。这些函数指针通常组织成一个函数指针数组。**函数指针**是指向实际函数的指针。通过解引用这个指针，您实际上会调用指针所指向的函数。有机会向函数传递参数，但是为了通过函数指针进行通用调用，参数必须对该指针可能指向的任何版本的函数都是统一的。函数指针的前提条件使我们能够指向特定函数的不同版本。也就是说，我们可以指向给定操作的不同方法。这是我们可以在C++中为虚函数自动绑定动态的基础。
- en: Let's consider the particular v-table entry for a specific object type. We know
    that this table entry will consist of a set of function pointers, such as an array
    of function pointers. The order in which these function pointers are arranged
    will be consistent with the order in which the virtual functions are newly introduced
    by a given class. Functions overriding existing virtual functions that were newly
    introduced at a higher level in the hierarchy will simply replace table entries
    with preferred versions of functions to be called, but will not cause an additional
    entry to be allocated in the array of function pointers.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑特定对象类型的虚函数表条目。我们知道这个表条目将由一组函数指针组成，例如函数指针数组。这些函数指针排列的顺序将与给定类引入的虚函数的顺序一致。重写现有虚函数的函数将简单地用要调用的函数的首选版本替换表条目，但不会导致在函数指针数组中分配额外的条目。
- en: So, when the program begins running, first in global memory (as a hidden external
    variable), a v-table will be set up. This table will contain entries for each
    object type that contains virtual functions. The entry for a given object type
    will contain a set of function pointers (such as an array of function pointers),
    which organizes and initializes the dynamically bound functions for that class.
    The specific order of the function pointers will correspond to the order in which
    the virtual functions were introduced (possibly by their ancestor class), and
    the specific function pointers will be initialized to the preferred versions of
    these functions for the specific class type in question. That is, the function
    pointers may point to overridden methods as specified at their own class level.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当程序开始运行时，首先在全局内存中（作为隐藏的外部变量），将设置一个虚函数表。该表将包含包含虚函数的每种对象类型的条目。给定对象类型的条目将包含一组函数指针（例如函数指针数组），它组织和初始化该类的动态绑定函数。函数指针的特定顺序将与引入虚函数的顺序相对应（可能是由它们的祖先类引入的），并且特定的函数指针将被初始化为该类类型的特定函数的首选版本。也就是说，函数指针可能指向其自己类级别指定的重写方法。
- en: Then, when an object of a given type is instantiated, the vptr within that object
    (there will be one per sub-object level of newly introduced – not redefined –
    virtual functions) will be set to point to the corresponding v-table entry for
    that instance.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当实例化给定类型的对象时，该对象内部的vptr（每个新引入的子对象级别的虚函数，而不是重新定义的虚函数，将有一个）将被设置为指向该实例的相应v-table条目。
- en: It will be useful to see this detail with code and a memory diagram. Let's look
    under the hood to see the code in action!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过代码和内存图，看到这些细节将是有用的。让我们深入了解代码的运行情况！
- en: Interpreting the virtual function table (v-table) in detail
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 详细解释虚函数表（v-table）
- en: 'In order to detail the memory model and see the underlying C++ mechanics that
    will be set up at runtime, let''s consider our detailed, full program example
    from this section with base class `Person` and derived class `Student`. As a reminder,
    we will show the key elements of the program:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了详细说明内存模型并查看运行时设置的底层C++机制，让我们考虑来自本节的详细完整程序示例，其中包括基类`Person`和派生类`Student`的关键元素。作为提醒，我们将展示程序的关键元素：
- en: 'Abbreviated definitions of the `Person` and `Student` classes (we''ll omit
    the data members and most member function definitions to save space):'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Person`和`Student`类的缩写定义（我们将省略数据成员和大多数成员函数定义以节省空间）：'
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Revisiting key elements of our `main()` function, in abbreviated form:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新审视我们`main()`函数的关键元素，以缩写形式：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice in our `main()` function that we instantiate one `Person` instance and
    two `Student` instances. All are stored in a generic array of pointers of the
    base class type `Person`. We then iterate through the set, calling virtual functions
    on each instance, namely `IsA()`, `Print()`, `Greeting()`, and the destructor
    (which is implicitly called when we delete each instance).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main()`函数中，注意我们实例化了一个`Person`实例和两个`Student`实例。所有这些都存储在基类类型`Person`的指针的通用数组中。然后，我们通过集合进行迭代，对每个实例调用虚函数，即`IsA()`，`Print()`，`Greeting()`和析构函数（在我们删除每个实例时隐式调用）。
- en: 'Considering the memory model for the previous example, we have the following
    diagram:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到先前示例的内存模型，我们有以下图表：
- en: '![Figure 7.1 – Memory model for the current example](img/Figure_7.1_B15702.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 - 当前示例的内存模型](img/Figure_7.1_B15702.jpg)'
- en: Figure 7.1 – Memory model for the current example
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 - 当前示例的内存模型
- en: In the aforementioned memory diagram (which follows the preceding program),
    notice that we have an array of pointers to the genericized instances of `Person`.
    The first instance is, in fact, a `Person`, and the second two instances are of
    type `Student`. But, as a `Student` *Is-A* `Person`, it is acceptable to up-cast
    a `Student` to a `Person`. The top part of the memory layout is in fact, a `Person`
    for each of the `Student` instances. For instances that are in fact of type `Student`,
    the additional data members for `Student` will follow all the memory required
    for the `Person` sub-object.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述的内存图中（遵循前面的程序），请注意我们有一个指向`Person`的通用化实例的指针数组。第一个实例实际上是一个`Person`，而另外两个实例是`Student`类型。但是，由于`Student`
    *是* `Person`，因此将`Student`向上转型为`Person`是可以接受的。内存布局的顶部部分实际上是每个`Student`实例的`Person`。对于实际上是`Student`类型的实例，`Student`的额外数据成员将跟随`Person`子对象所需的所有内存。
- en: Notice that the `vptr` entries immediately follow the data members for the `Person`
    object (or sub-object) for each of the three instances. The location for the `vptr`
    is the same offset from the top of each object. This is because the virtual functions
    in question are all introduced at the `Person` level in the hierarchy. Some may
    be overridden in the `Student` class with more appropriate definitions for `Student`,
    but the level at which each is introduced is the `Person` level, hence the `vptr`
    below the `Person` object (or sub-object) will reflect a pointer to the list of
    operations introduced at the `Person` level.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`vptr`条目紧随每个三个实例的`Person`对象（或子对象）的数据成员之后。`vptr`的位置与每个对象顶部的偏移量相同。这是因为所讨论的虚函数都是在层次结构的`Person`级别引入的。一些可能在`Student`类中被更合适地定义为`Student`的虚函数可能会被覆盖，但是每个引入的级别都是`Person`级别，因此`Person`对象（或子对象）下面的`vptr`将反映指向在`Person`级别引入的操作列表的指针。
- en: As an aside, let's say that `Student` introduced wholly new virtual functions
    (and not merely redefinitions of existing virtual functions), as we saw in the
    previous function-hiding scenario. There would then be a second `vptr` entry below
    the `Student` sub-object with those additional (new virtual) operations added.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，假设`Student`引入了全新的虚函数（而不仅仅是重新定义现有的虚函数），就像我们在前面的函数隐藏场景中看到的那样。然后，在`Student`子对象下方将有第二个`vptr`条目，其中包含这些额外的（新的虚）操作。
- en: When each object is instantiated, first the appropriate constructors (proceeding
    up the hierarchy) will be called for each instance. Additionally, the compiler
    will patch in a pointer assignment for each instance's `vptr` to be set to the
    `v-table` entry corresponding to the object's type. That is, when a `Person` is
    instantiated, its `vptr` will point to the `v-table` entry for `Person`. When
    a `Student` is instantiated, its `vptr` will point to the `v-table` entry for
    `Student`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当每个对象被实例化时，首先将为每个实例调用适当的构造函数（按层次结构向上进行）。此外，编译器将为每个实例的`vptr`补丁分配指针，以设置为与对象类型对应的`v-table`条目。也就是说，当实例化`Person`时，其`vptr`将指向`Person`的`v-table`条目。当实例化`Student`时，其`vptr`将指向`Student`的`v-table`条目。
- en: Let's assume that the `v-table` entry for `Person` or `Student` contains an
    array of function pointers to the appropriate virtual functions for that type.
    The `v-table` entry for each type actually has more information embedded, such
    as the size of an instance of that type, and so on. To simplify, we will just
    look at the portion of the `v-table` entries that automate the dynamic binding
    for each class type.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`Person`或`Student`的`v-table`条目包含一个指向该类型适当虚函数的函数指针数组。每种类型的`v-table`条目实际上嵌入了更多信息，例如该类型的实例大小等。为简化起见，我们将只查看自动执行每个类类型的动态绑定的`v-table`条目的部分。
- en: Notice that the `v-table` entry for `Person` is an array of four function pointers.
    Each function pointer will point to the most suitable version of the destructor,
    `Print()`, `IsA()`, and `Greeting()` for a `Person`. The order in which these
    function pointers are laid corresponds to the order in which these virtual functions
    were introduced by this class. That is, `vptr[0]` will point to the `Person` destructor,
    `vptr[1]` will point to `Person::Print()`, and so on.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Person`的`v-table`条目是一个包含四个函数指针的数组。每个函数指针将指向`Person`的最合适版本的析构函数，`Print()`，`IsA()`和`Greeting()`。这些函数指针的排列顺序与这些虚函数由该类引入的顺序相对应。也就是说，`vptr[0]`将指向`Person`的析构函数，`vptr[1]`将指向`Person::Print()`，依此类推。
- en: Now, let's look at the v-table entry for `Student`. The order in which the virtual
    functions (as function pointers) are laid in the array is the same order as for
    the `Person` class. This is because the base class introduced these functions
    and the ordering in this array of pointers is set by that level. But notice that
    the actual functions that are pointed to have been overridden for `Student` instances
    to mostly be methods that were redefined by the derived class, `Student`. That
    is, the `Student` destructor is specified (as the starting point for destruction),
    followed by `Student::Print()`, then `Student::IsA()`, and then `Person::Greeting()`.
    Notice that `vptr[3]` points to `Person::Greeting()`. This is because `Student`
    did not redefine this function in its class definition; `Student` found the `Person`
    definition, which is inherited, to be acceptable.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下`Student`的`v-table`条目。虚函数（作为函数指针）在数组中的排列顺序与`Person`类的顺序相同。这是因为基类引入了这些函数，并且指针数组中的排序是由该级别设置的。但请注意，指向的实际函数已被`Student`实例重写，大部分是由派生类`Student`重新定义的方法。也就是说，`Student`的析构函数被指定为（作为销毁的起点），然后是`Student::Print()`，然后是`Student::IsA()`，然后是`Person::Greeting()`。请注意，`vptr[3]`指向`Person::Greeting()`。这是因为`Student`没有在其类定义中重新定义这个函数；`Student`发现继承的`Person`定义是可以接受的。
- en: Pairing this memory diagram with the code in our `main()` function, notice that
    after we instantiate a `Person` and two `Student` instances, storing each in the
    genericized `Person` array of pointers, we iterate through a loop containing several
    operations. We uniformly call `people[i]->Print();`, then `people[i]->IsA();`,
    then `people[i]->Greeting();`, and then `delete people[i];` (which patches in
    a destructor call).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个内存图与我们`main()`函数中的代码配对，注意在我们实例化一个`Person`和两个`Student`实例后，将每个实例存储在泛型化的`Person`指针数组中，我们通过包含多个操作的循环进行迭代。我们统一调用`people[i]->Print();`，然后是`people[i]->IsA();`，然后是`people[i]->Greeting();`，最后是`delete
    people[i];`（这会插入一个析构函数调用）。
- en: Because each of these functions is virtual, the decision as to which function
    should be called is deferred to be looked up at runtime. This is done by accessing
    each instance's hidden `vptr` member, indexing into the appropriate `v-table`
    entry based on the operation at hand, and then dereferencing the function pointer
    found at that entry to call the appropriate method. The compiler knows, for example,
    that `vptr[0]` will be the destructor, `vptr[1]` will be the next virtual function
    introduced in the base class definition, and so on, so that which element position
    in the v-table should be activated is easily determined by the name of the polymorphic
    operation.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些函数都是虚函数，决定调用哪个函数的决定被推迟到运行时进行查找。这是通过访问每个实例的隐藏`vptr`成员来完成的，根据手头的操作索引到适当的`v-table`条目，然后解引用在该条目中找到的函数指针来调用适当的方法。编译器知道，例如`vptr[0]`将是析构函数，`vptr[1]`将是基类定义中引入的下一个虚函数，依此类推，因此可以轻松确定应该激活v-table中的哪个元素位置，这是多态操作的名称决定的。
- en: Imagine that a call in `main()` to `people[i]->Print();` was replaced with `*(people[i]->vptr[1])();`,
    which is the syntax for dereferencing a function pointer to call the function
    at hand. Notice that we are first accessing which function using `people[i]->vptr[1]`,
    then dereferencing the function pointer using `*`. Notice the parentheses, `()`,
    at the end of the statement, which is where any parameters would be passed to
    the function. Because the code to dereference the function pointer needs to be
    uniform, the parameters to any such function must also be uniform. That is why
    any virtual functions overridden in a derived class must use the same signature
    as specified by the base class. It all makes sense when you look under the hood.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，在`main()`中对`people[i]->Print();`的调用被替换为`*(people[i]->vptr[1])();`，这是解引用函数指针以调用手头的函数的语法。请注意，我们首先使用`people[i]->vptr[1]`来访问哪个函数，然后使用`*`来解引用函数指针。请注意语句末尾的括号`()`，这是传递参数给函数的地方。因为解引用函数指针的代码需要是统一的，任何这样的函数的参数也必须是统一的。这就是为什么在派生类中重写的任何虚函数都必须使用与基类指定的相同签名。当你深入了解时，这一切都是有道理的。
- en: We have now thoroughly examined the OO idea of polymorphism and how it is implemented
    in C++ using virtual functions. Let's briefly recap what we've covered in this
    chapter before moving onward to our next chapter.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经彻底研究了面向对象的多态思想以及在C++中如何使用虚函数实现它。在继续前进到下一章之前，让我们简要回顾一下本章涵盖的内容。
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have moved even further along our journey with object-oriented
    programming by understanding how virtual functions in C++ provide direct language
    support for the OO idea of polymorphism. We have seen how virtual functions provide
    the dynamic binding of a specific method to an operation in our inheritance hierarchy.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过理解C++中虚函数如何直接支持面向对象的多态思想，进一步深入了解了面向对象编程。我们已经看到虚函数如何为继承层次结构中的操作提供特定方法的动态绑定。
- en: We have seen how, using virtual functions, an operation specified by a base
    class can be overridden by a derived class, providing a more suitable implementation.
    We have seen that the correct method for each object can be selected using runtime
    binding, regardless of whether the object is stored in its own type or in a generalized
    type.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，使用虚函数，基类指定的操作可以被派生类覆盖，提供更合适的实现。我们已经看到，可以使用运行时绑定选择每个对象的正确方法，无论对象是存储在其自己的类型还是在泛化类型中。
- en: We have seen that objects are often generalized using base class pointers and
    how this can allow uniform processing of related derived class types. We have
    seen that regardless of how an instance is stored (as its own type or as that
    of a base class using a pointer), that the correct version of a virtual function
    will always be applied through dynamic binding. We have seen that in public inheritance
    hierarchies, where upcasting may be routinely done, having a virtual destructor
    is essential.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到对象通常使用基类指针进行泛化，以及这如何允许对相关派生类类型进行统一处理。我们已经看到，无论实例是如何存储的（作为其自己的类型或作为使用指针的基类的类型），正确版本的虚函数始终会通过动态绑定应用。我们已经看到，在公共继承层次结构中，其中向上转型可能会经常进行，拥有虚析构函数是必不可少的。
- en: We have also seen how dynamic binding works through examining a typical compiler
    implementation of embedding a vptr into instances, and how these pointers reference
    v-table entries (containing sets of member function pointers) relevant to each
    object type.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了动态绑定是如何工作的，通过检查编译器实现将vptr嵌入实例，以及这些指针引用与每个对象类型相关的v表条目（包含成员函数指针集）。
- en: We have seen that virtual functions allow us to take advantage of dynamic binding
    of operations to the most appropriate methods, enabling us to use C++ as an OOP
    language to implement robust designs featuring polymorphism, which promotes easily
    extensible code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，虚函数允许我们利用操作的动态绑定到最合适的方法，使我们能够将C++作为一个OOP语言来实现具有多态性的健壮设计，从而促进易于扩展的代码。
- en: Through extending our OOP knowledge with the utilization of virtual functions,
    we can now move forward to include additional object-oriented concepts and details
    relating to inheritance and polymorphism. Continuing to [*Chapter 8*](B15702_08_Final_NM_ePub.xhtml#_idTextAnchor335),
    *Mastering Abstract Classes*, we will next learn how to employ the OO ideal of
    abstract classes, along with all the assorted OOP considerations surrounding this
    next object-oriented concept. Let's continue!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展我们对OOP知识的理解，利用虚函数，我们现在可以继续包括与继承和多态性相关的其他面向对象的概念和细节。继续到[*第8章*](B15702_08_Final_NM_ePub.xhtml#_idTextAnchor335)，*掌握抽象类*，我们将学习如何应用抽象类的OO理想，以及围绕这一下一个面向对象概念的各种OOP考虑。让我们继续！
- en: Questions
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Using your [*Chapter 6*](B15702_06_Final_NM_ePub.xhtml#_idTextAnchor262), *Implementing
    Hierarchies with Single Inheritance*, solution, augment your inheritance hierarchy
    to further specialize `Student` with `GraduateStudent` and `NonDegreeStudent`.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的[*第6章*](B15702_06_Final_NM_ePub.xhtml#_idTextAnchor262)，*使用单继承实现层次结构*，解决方案，扩展您的继承层次结构，以进一步专门化`Student`与`GraduateStudent`和`NonDegreeStudent`。
- en: a. Add necessary data members to your `GraduateStudent` class. Data members
    to consider might be dissertation topic or graduate advisor. Include appropriate
    constructors (default, alternate, and copy), a destructor, access member functions,
    and a suitable public interface. Be sure to place your data members in the private
    access region. Do the same for `NonDegreeStudent`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: a. 为您的`GraduateStudent`类添加必要的数据成员。要考虑的数据成员可能是论文题目或研究生导师。包括适当的构造函数（默认，替代和复制），析构函数，访问成员函数和合适的公共接口。一定要将数据成员放在私有访问区域。对于`NonDegreeStudent`也是一样。
- en: b. Add polymorphic operations to `Person`, `Student`, `GraduateStudent`, and
    `NonDegreeStudent` as necessary. Introduce, at the `Person` level, virtual functions
    `IsA()` and `Print()`. Override `IsA()` and `Print()` in your derived classes,
    as necessary. It may be that you override `IsA()` in `Student` and `GraduateStudent`,
    but choose to override `Print()` only in the `Student()` class. Be sure to include
    virtual destructors in each of your classes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: b. 根据需要为`Person`，`Student`，`GraduateStudent`和`NonDegreeStudent`添加多态操作。在`Person`级别引入虚函数`IsA()`和`Print()`。根据需要在派生类中重写`IsA()`和`Print()`。可能会在`Student`和`GraduateStudent`中重写`IsA()`，但选择仅在`Student()`类中重写`Print()`。一定要在每个类中包含虚析构函数。
- en: c. Instantiate `Student`, `GraduateStudent`, `NonDegreeStudent`, and `Person`
    several times and utilize the appropriate `public` interfaces on each. Be sure
    to dynamically allocate several instances.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: c. 实例化`Student`，`GraduateStudent`，`NonDegreeStudent`和`Person`多次，并利用每个适当的`public`接口。一定要动态分配多个实例。
- en: d. Create an array of pointers to `Person` and allocate instances of `Person`,
    `Student`, `GraduateStudent`, and `NonDegreeStudent` to be members of this array.
    Once generalized, only call polymorphic operations that are found at the `Person`
    level (and other public methods of `Person`). Be sure to delete any dynamically
    allocated instances.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: d. 创建一个指向`Person`的指针数组，并分配`Person`，`Student`，`GraduateStudent`和`NonDegreeStudent`的实例作为该数组的成员。一旦泛化，只调用在`Person`级别找到的多态操作（以及`Person`的其他公共方法）。一定要删除任何动态分配的实例。
- en: e. Now, create an array of pointers to `Student` and allocate only instances
    of `GraduateStudent` and `NonDegreeStudent` to be members of this array. Now,
    call operations that are found at the `Student` level to be applied to these generalized
    instances. Additionally, utilize operations found at the `Person` level – they
    are inherited and additionally available for generalized `Student` instances.
    Be sure to delete any dynamically allocated instances pointed to in your array.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: e. 现在，创建一个指向`Student`的指针数组，并只分配`GraduateStudent`和`NonDegreeStudent`的实例作为该数组的成员。现在，调用在`Student`级别找到的操作，以应用于这些泛化实例。此外，利用在`Person`级别找到的操作-它们被继承并且对于泛化的`Student`实例也可用。一定要删除数组中指向的任何动态分配的实例。
