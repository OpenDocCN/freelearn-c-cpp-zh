- en: Chapter 14. Qt Hat Tips and Tricks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 14 章。Qt 小贴士和技巧
- en: The previous chapter taught you how to package a Qt application on all the major
    desktop and mobile platforms. This was the final step before shipping your application
    to your users. This chapter gathers some tips and tricks that will help you to
    develop your Qt applications with more ease.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章教了你如何在所有主要的桌面和移动平台上打包 Qt 应用程序。这是将你的应用程序发送给用户之前的最后一步。本章汇集了一些技巧和窍门，将帮助你更轻松地开发你的
    Qt 应用程序。
- en: 'This chapter covers the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Qt Creator tips - Useful keyboard shortcuts, session management, and more
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt Creator 小贴士 - 有用的键盘快捷键、会话管理以及更多
- en: Examining the memory with Qt Creator
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Qt Creator 检查内存
- en: Generating random numbers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成随机数
- en: Silencing unused variables and compiler warnings
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静默未使用变量和编译器警告
- en: How to easily log an object's content to `QDebug`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何轻松地将对象的内容记录到 `QDebug`
- en: Customizing `QDebug` formatting
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义 `QDebug` 格式化
- en: Saving logs to a file
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将日志保存到文件
- en: Creating a friendly command-line interface
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建友好的命令行界面
- en: Sending `HTTP``GET` and `POST` requests
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送 `HTTP` `GET` 和 `POST` 请求
- en: Managing your workspace with sessions
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用会话管理你的工作空间
- en: It is common for a commercial product to be composed of several Qt projects.
    We regularly encountered this practice in this book-for example, an application
    composed of a core project and a GUI project. The Qt subdirs project is a nice
    way of handling inter-dependent projects within the same application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于商业产品通常由几个 Qt 项目组成是很常见的。我们在本书中经常遇到这种做法——例如，由核心项目和 GUI 项目组成的应用程序。Qt 子目录项目是在同一应用程序内处理相互依赖项目的一种很好的方式。
- en: However, when your product grows up, you'll want to open some unrelated projects
    in Qt Creator. In this case, you should use a **session**. A session is a complete
    snapshot of your workspace in Qt Creator. You can easily create a new session
    from **File** | **Session Manager** | **New**. Do not forget to switch to the
    new session. For example, you can create a session "Mastering Qt5" and load all
    project examples in a common workspace.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你的产品成长起来时，你可能会想在 Qt Creator 中打开一些无关的项目。在这种情况下，你应该使用一个 **会话**。会话是 Qt Creator
    中工作空间的一个完整快照。你可以轻松地从 **文件** | **会话管理器** | **新建** 创建一个新的会话。不要忘记切换到新的会话。例如，你可以创建一个名为
    "Mastering Qt5" 的会话，并在一个公共工作空间中加载所有项目示例。
- en: 'The sessions are useful when you need to quickly switch between two different
    workspaces. The following items in Qt Creator will be automatically saved in the
    session:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要快速在两个不同的工作空间之间切换时，会话非常有用。以下在 Qt Creator 中的项目将在会话中自动保存：
- en: Opened projects of the hierarchical view
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 层次视图打开的项目
- en: Editor's windows (including the splits)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑器窗口（包括分割）
- en: Debug breakpoints and expressions views
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试断点和表达式视图
- en: Bookmarks
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书签
- en: You can change to a different session with **File** | **Session Manager** or
    by using the **Welcome** tab. A session can be destroyed without any impact on
    your projects.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **文件** | **会话管理器** 或 **欢迎** 选项卡来切换到不同的会话。会话可以被销毁，而不会对你的项目产生任何影响。
- en: Searching with the Locator
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用定位器搜索
- en: 'Another way to improve your productivity with Qt Creator is to use keyboard
    shortcuts. Qt Creator provides a lot of great keyboard shortcuts. Here is our
    selection:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Qt Creator 提高你的生产力的另一种方法是使用键盘快捷键。Qt Creator 提供了许多优秀的键盘快捷键。以下是我们的选择：
- en: '![Searching with the Locator](img/image00455.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![使用定位器搜索](img/image00455.jpeg)'
- en: 'One of our favorites is the Locator. Press *Ctrl* + *K* to activate it. Then
    you can enjoy several features:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最喜欢的一个是定位器。按 *Ctrl* + *K* 激活它。然后你可以享受以下功能：
- en: Enter a filename (you can even use a partial entry) and press *Enter* to open
    this file. If the Locator suggests multiple files, you can use the arrows up and
    down to navigate.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入一个文件名（你甚至可以使用部分输入）并按 *Enter* 键打开此文件。如果定位器建议多个文件，你可以使用上下箭头进行导航。
- en: Prefix your search by `.`  (a dot followed by a space) to search C++ symbols
    in the current document. For example, on the `Task.cpp` file of the first chapter,
    try to use the Locator with `. set` and press *Enter* to go to the  `Task::setName()` function.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在搜索前加上 `.` （一个点后跟一个空格）以在当前文档中搜索 C++ 符号。例如，在第一章的 `Task.cpp` 文件中，尝试使用定位器输入 `.
    set` 并按 *Enter* 键跳转到 `Task::setName()` 函数。
- en: Enter `l`  (*L* followed by a space) to go to a specific line. For example,
    "l 37" will bring us to line 37 of the current file
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入 `l` （*L* 后跟一个空格）以跳转到特定的行。例如，"l 37" 将将我们带到当前文件的第 37 行
- en: The Locator provides plenty of features; take a look when you press *Ctrl* + *K*
    the next time!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 定位器提供了丰富的功能；下次您按下 *Ctrl* + *K* 时，请查看一下！
- en: Increasing the compilation speed
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高编译速度
- en: You can speed up the compilation on a multicore computer. By default, when you
    build your project with Qt Creator, you only use one job (and, therefore, one
    core). But `make` supports the compilation with multiple jobs. You can use the `make
    -j N` option to allow N jobs at once. Do not forget to update your packaging scripts!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在多核计算机上加快编译速度。默认情况下，当您使用 Qt Creator 构建项目时，您只使用一个作业（因此，一个核心）。但是`make`支持使用多个作业进行编译。您可以使用`make
    -j N`选项一次允许 N 个作业。不要忘记更新您的打包脚本！
- en: 'If you build your project from Qt Creator, you can set this option from **Projects**
    | **Build Steps** | **Make**. Click on **Details**, then, in the **Make arguments**
    field, put the value `-j 8` to allow eight jobs during the compilation, as shown
    in the following screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从 Qt Creator 构建项目，您可以从**项目** | **构建步骤** | **构建**设置此选项。点击**详细信息**，然后在**构建参数**字段中，输入值`-j
    8`以允许在编译期间进行八个作业，如下面的截图所示：
- en: '![Increasing the compilation speed](img/image00456.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![提高编译速度](img/image00456.jpeg)'
- en: Examining the memory with Qt Creator
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Qt Creator 检查内存
- en: 'For this section, we will use the following code snippet:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，我们将使用以下代码片段：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We declared three primitive types: `boolean`, `integer`, and `character`. We
    also added a  `integerPointer` pointer that refers to the `integer` variable.
    Put a breakpoint at the last line and start the debugging. On the Debug pane,
    you should have the **Locals and Expressions** view. You can easily add/remove
    it from **Window** | **Views** | **Locals and Expressions**. Here is a screenshot
    of it:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了三种原始类型：`boolean`、`integer`和`character`。我们还添加了一个指向`integer`变量的`integerPointer`指针。在最后一行设置断点并开始调试。在调试面板上，您应该有**局部变量和表达式**视图。您可以从**窗口**
    | **视图** | **局部变量和表达式**轻松添加/删除它。以下是它的截图：
- en: '![Examining the memory with Qt Creator](img/image00457.jpeg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Qt Creator 检查内存](img/image00457.jpeg)'
- en: 'You can see that all our local variables are displayed with their values. The
    `character` line even displays three formats (ASCII, integer, and hexadecimal)
    of the letter **''A''**. You may also notice that the `integerPointer` line displays
    the automatically dereferenced value, not the pointer address. You can disable
    it with a right-click on the background of the **Locals and Expressions** window
    and then select **Dereference Pointers automatically**. You can see the pointer
    address and the dereferenced value appearing as shown in the following screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，所有我们的局部变量都显示其值。`字符`行甚至显示了字母 **'A'** 的三种格式（ASCII、整数和十六进制）。您可能还会注意到，`integerPointer`行显示的是自动解引用的值，而不是指针地址。您可以通过在**局部变量和表达式**窗口的背景上右键单击并选择**自动解引用指针**来禁用它。您可以看到指针地址和解引用值如以下截图所示：
- en: '![Examining the memory with Qt Creator](img/image00458.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Qt Creator 检查内存](img/image00458.jpeg)'
- en: 'The console output displays the following information:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出显示以下信息：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can see that we retrieve the same information in the console output. The
    **Locals and Expressions** view helps you to save time. You can display a lot
    of information without logging it with a `qDebug()` function.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，我们在控制台输出中检索到相同的信息。**局部变量和表达式**视图可以帮助您节省时间。您可以在不使用`qDebug()`函数记录的情况下显示大量信息。
- en: Qt Creator provides a useful memory editor. You can open it with a right-click
    on a variable name in the **Locals and Expressions** window, and then select **Open
    Memory Editor** | **Open Memory Editor at Object's Address**.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Creator 提供了一个有用的内存编辑器。您可以通过在**局部变量和表达式**窗口中变量名上右键单击来打开它，然后选择**打开内存编辑器** |
    **在对象的地址处打开内存编辑器**。
- en: 'Within the memory editor, look at the value of the `boolean` variable:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存编辑器中，查看`boolean`变量的值：
- en: '![Examining the memory with Qt Creator](img/image00459.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Qt Creator 检查内存](img/image00459.jpeg)'
- en: 'A hexadecimal editor appears with three parts (from the left to the right):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个十六进制编辑器出现，分为三个部分（从左到右）：
- en: The memory address of the data
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据的内存地址
- en: The hexadecimal representation of the data
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据的十六进制表示
- en: The ASCII representation of the data
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据的 ASCII 表示
- en: The selection in the hexadecimal representation corresponds to the variable.
    We can confirm that the `boolean` variable is represented in memory by 1 byte.
    Because the value is `true`, the memory representation is **0x01**.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制表示中的选择对应于变量。我们可以确认`boolean`变量在内存中以1个字节表示。因为值是`true`，内存表示为**0x01**。
- en: 'Let''s examine the `character` memory with the **Memory Editor** tool:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用**内存编辑器**工具检查`character`内存：
- en: '![Examining the memory with Qt Creator](img/image00460.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Qt Creator 检查内存](img/image00460.jpeg)'
- en: The character is also stored in memory with 1 byte. The hexadecimal representation
    is **0x41**. The character is encoded with the well-known ASCII format. Note that,
    on the right-hand side, the ASCII representation displays the **'A'**.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 字符也以1个字节存储在内存中。十六进制表示为**0x41**。字符使用众所周知的ASCII格式编码。请注意，在右侧，ASCII表示显示为**'A'**。
- en: 'Here is the **Memory Editor** location of the `integer` variable:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`integer`变量的**内存编辑器**位置：
- en: '![Examining the memory with Qt Creator](img/image00461.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Qt Creator 检查内存](img/image00461.jpeg)'
- en: There are two interesting facts to note. The integer is stored on 4 bytes. The
    value **05** is stored in hexadecimal as **05 00 00 00**. The byte order depends
    on the endianness of your processor. We are using an Intel CPU that is Little-Endian.
    Another CPU architecture with a Big-Endian memory storage will display the variable
    as **00 00 00 05**.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个有趣的事实需要注意。整数存储在4个字节中。值**05**以十六进制形式存储为**05 00 00 00**。字节顺序取决于处理器的端序。我们使用的是Little-Endian的Intel
    CPU。具有Big-Endian内存存储的其他CPU架构将变量显示为**00 00 00 05**。
- en: Before we continue to dive into the memory of our application, look at the last
    three screenshots closely. You might notice that, in this case, the three variables
    are contiguous in the stack memory. This behavior is not guaranteed depending
    on the implementation of your OS.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续深入了解应用程序的内存之前，仔细查看最后三个屏幕截图。你可能注意到，在这种情况下，三个变量在堆栈内存中是连续的。这取决于你操作系统实现的行为并不保证。
- en: 'Try to open the memory editor on the `integerPointer` variable. The context
    menu offers you two different ways:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在`integerPointer`变量上打开内存编辑器。上下文菜单提供了两种不同的方式：
- en: The **Open Memory Editor at Object's Address** option dereferences the pointer
    and brings you directly to the pointed value. You get the same result as the integer
    memory view.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在对象的地址打开内存编辑器**选项取消引用指针，直接带你到指向的值。你得到与整数内存视图相同的结果。'
- en: The **Open Memory Editor at Pointer's Address** option displays the raw pointer
    data, which is a memory address to where it is pointing.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在指针地址打开内存编辑器**选项显示原始指针数据，这是一个指向其所在位置的内存地址。'
- en: 'Here is the **Memory Editor** tool showing the pointer''s address of `integerPointer`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是显示`integerPointer`指针地址的**内存编辑器**工具：
- en: '![Examining the memory with Qt Creator](img/image00462.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Qt Creator 检查内存](img/image00462.jpeg)'
- en: We are on a 64-bit OS, so our pointer is stored on 8 bytes. The data of this
    pointer is the hexadecimal value `ac 53 11 60 fe 7f 00 00`. This is the Little-Endian
    representation of the memory address `0x7ffe601153ac` displayed by the **Locals
    and Expressions** and by our console output.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行在64位操作系统上，因此我们的指针存储在8个字节中。这个指针的数据是十六进制值`ac 53 11 60 fe 7f 00 00`。这是内存地址`0x7ffe601153ac`的Little-Endian表示，该地址由**局部变量和表达式**以及我们的控制台输出显示。
- en: 'We display the memory, but we can also change it. Follow these steps:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们显示内存，但我们也可以更改它。按照以下步骤操作：
- en: Remove the current breakpoint and add a new one on the first `qDebug()` line.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除当前断点并在第一个`qDebug()`行上添加一个新的断点。
- en: Restart the debugging and look at the **Locals and Expressions**. If you double-click
    a variable's value, you can edit it. Note that the **Memory Editor** window immediately
    updates its representation.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动调试并查看**局部变量和表达式**。如果你双击一个变量的值，你可以编辑它。请注意，**内存编辑器**窗口会立即更新其表示。
- en: In our case, we set `boolean` value to false, `character` to 68 (that is 'D')
    and `integer` to 9\. When you are confident with your changes, continue the debugging.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将`boolean`值设置为false，`character`设置为68（即'D'），`integer`设置为9。当你对自己的更改有信心时，继续调试。
- en: 'Here is the final console output reflecting our modifications:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是反映我们修改的最终控制台输出：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The **Memory Editor** is a powerful tool: You can display and change your variable''s
    value, at runtime, without changing your source code and recompiling your application.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存编辑器**是一个强大的工具：你可以在不更改源代码和重新编译应用程序的情况下，在运行时显示和更改变量的值。'
- en: Generating random numbers
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成随机数
- en: 'Generating real random numbers is quite a difficult task for a computer. Commonly,
    we are using only a **pseudo-random number generation** (**PRNG**). The Qt framework
    provides the function `qrand()`, a thread-safe version of `std::rand()`. This
    function returns an integer between 0 and `RAND_MAX` (defined in `stdlib.h`).
    The following code shows two pseudo-random numbers:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于计算机来说，生成真正的随机数是一项相当困难的任务。通常，我们只使用**伪随机数生成**（**PRNG**）。Qt框架提供了函数`qrand()`，这是`std::rand()`的一个线程安全版本。这个函数返回一个介于0和`RAND_MAX`（在`stdlib.h`中定义）之间的整数。以下代码显示了两个伪随机数：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We are using a modulo operator to get a value between 0 and 9\. Try to run
    your application several times. The numbers are always the same, in our case,
    3 then 7\. That is because each time we call `qrand()`, we retrieve the next number
    of the pseudo-random sequence, but the sequence is always the same! Fortunately,
    we can use `qsrand()` to initialize the PRNG with a seed. A seed is an unsigned
    integer that is used to generate a sequence. Try the next snippet:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用模运算符来获取介于0和9之间的值。尝试多次运行你的应用程序。数字总是相同的，在我们的例子中，先是3然后是7。那是因为每次我们调用`qrand()`时，我们都会检索伪随机序列的下一个数字，但序列总是相同的！幸运的是，我们可以使用`qsrand()`来使用种子初始化PRNG。种子是一个用于生成序列的无符号整数。尝试下一个代码片段：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this example, we are using the seed 3, and we get a different value from
    `qrand()`--on our computer it is 5 and 4\. Great, but if you run this application
    several times, you will always have this sequence. One way of generating a different
    sequence each time you run your application is to use a different seed on each
    run. Run the following code snippet:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了种子3，并从`qrand()`得到了不同的值——在我们的计算机上它是5和4。很好，但如果多次运行这个应用程序，你总是会得到这个序列。每次运行应用程序时生成不同序列的一种方法是在每次运行时使用不同的种子。运行以下代码片段：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, we are now initializing the PRNG with the epoch time from `QDateTime`.
    You can try to run your application multiple times to see that we get different
    numbers each time! However, this solution is not recommended for cryptography.
    In this case, you should use a stronger random number engine.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们现在正在使用`QDateTime`的纪元时间初始化PRNG。你可以尝试多次运行你的应用程序，以查看我们每次都会得到不同的数字！然而，这个解决方案不建议用于加密。在这种情况下，你应该使用更强的随机数生成器。
- en: Silencing unused variable warnings
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关闭未使用变量的警告
- en: 'If your compiler is configured to output its warnings, you will probably sometimes
    see this kind of log:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的编译器配置为输出其警告，你可能会看到这种类型的日志：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is a safety warning to tell the developer to keep their code clean and
    avoid dead variables. It is a good practice to try to minimize this kind of warning.
    However, sometimes you have no choice: You override an existing function and you
    do not use all the parameters. You now face a conundrum: On the one hand you can
    silence the warning for your whole application, and on the other hand, you can
    let these safety warnings pile up in your compile output. There must be a better
    option.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个安全警告，告诉开发者保持他们的代码整洁并避免死变量。尽量减少这种类型的警告是一种好的做法。然而，有时你不得不这样做：你重写了一个现有的函数，但没有使用所有参数。你现在面临一个困境：一方面，你可以为整个应用程序关闭警告，另一方面，你可以让这些安全警告在编译输出中累积。必须有一个更好的选择。
- en: 'Indeed, you can silence the warning for your function only. There are two ways
    of doing this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，你只能为你的函数关闭警告。有两种方法可以做到这一点：
- en: Using the C/C++ syntax
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C/C++语法
- en: Using a Qt macro
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Qt宏
- en: 'Let''s say you override `myFunction(QString name, QString myVariable)` and
    you do not use `myVariable`. Using the C/C++ syntax, you just have to implement `myFunction()`
    like so:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你重写了`myFunction(QString name, QString myVariable)`函数，但你没有使用`myVariable`。使用C/C++语法，你只需像这样实现`myFunction()`：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By commenting the variable's name, `myVariable`, in the function signature,
    you ensure that you will not (that is, cannot) use the variable in the function
    body. The compiler will also interpret it like this and will not output any warning.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在函数签名中注释变量的名称`myVariable`，你确保你不会（即不能）在函数体中使用这个变量。编译器也会这样解释，并且不会输出任何警告。
- en: 'Qt also provides a way of marking unused variables with the `Q_UNUSED` macro.
    Let''s see it in action:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Qt还提供了使用`Q_UNUSED`宏标记未使用变量的方法。让我们看看它是如何工作的：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Simply pass `myVariable` to `Q_UNUSED` and it will remove the warning from
    the compiler output. Behind the curtain, `Q_UNUSED` does not do anything magical
    with the variable:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地将`myVariable`传递给`Q_UNUSED`，它将从编译器输出中移除警告。幕后，`Q_UNUSED`对变量没有任何神奇的操作：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It is a simple trick to fool the compiler; it sees `myVariable` "used", but
    nothing is done with it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个愚弄编译器的简单技巧；它看到 `myVariable` “被使用”，但实际上并没有对它做任何事情。
- en: Logging custom objects to QDebug
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将自定义对象记录到 QDebug
- en: When you are debugging complex objects, it is nice to output their current members'
    value to `qDebug()`. In other languages (such as Java), you may have encountered
    the `toString()` method or equivalent, which is very convenient.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调试复杂对象时，将它们当前成员的值输出到 `qDebug()` 中是很方便的。在其他语言（如 Java）中，您可能已经遇到了 `toString()`
    方法或类似的方法，这非常方便。
- en: 'Sure, you could add a function void `toString()` to each object you want to
    log in order to write code with the following syntax:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以为每个想要记录的对象添加一个 `void toString()` 函数，以便使用以下语法编写代码：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There must be a more natural way of doing this in C++. Moreover, Qt already
    provides this kind of feature:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，肯定有更自然的方式来做到这一点。此外，Qt 已经提供了这种功能：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To achieve this, we will rely on a C++ operator overload. This will look very
    similar to what we did with `QDataStream` operators in [Chapter 10](part0097.xhtml#aid-2SG6I2
    "Chapter 10.  Need IPC? Get Your Minions to Work"), *Need IPC? Get Your Minions
    to Work*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将依赖于 C++ 操作符重载。这看起来将非常类似于我们在第 10 章[需要 IPC？让你的仆人去工作](part0097.xhtml#aid-2SG6I2
    "第 10 章。需要 IPC？让你的仆人去工作")中使用的 `QDataStream` 操作符，*需要 IPC？让你的仆人去工作*。
- en: 'Consider a `struct Person`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个 `struct Person`：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To add the ability to properly output to `QDebug`, you just have to override
    the `<<` operator between `QDebug` and `Person` like so:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加将正确输出到 `QDebug` 的功能，您只需覆盖 `QDebug` 和 `Person` 之间的 `<<` 操作符，如下所示：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `QDebugStateSaver` is a convenience class to save the settings of `QDebug`
    and restore them automatically upon destruction. It is good practice to always
    use it to be sure that you do not break `QDebug` in an `<<` operator overload.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`QDebugStateSaver` 是一个便利类，用于保存 `QDebug` 的设置，并在销毁时自动恢复它们。始终使用它是良好的实践，以确保您不会在
    `<<` 操作符重载中破坏 `QDebug`。'
- en: 'The rest of the function is the usual way of using `QDebug` and finally returning
    the modified `debug` variable. You can now use `Person` like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的其余部分是使用 `QDebug` 的常规方式，最后返回修改后的 `debug` 变量。现在您可以使用 `Person` 如此：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: No need for a `toString()` function; simply use the person object. For those
    of you who wondered, yes, `Lenna` is really `64` at the time of wrting (2016).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要 `toString()` 函数；只需使用 person 对象。对于那些想知道的人，是的，`Lenna` 在写作时（2016年）确实是 `64`。
- en: Improving log messages
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进日志消息
- en: Qt offers multiple ways of doing this. A good compromise between the result
    and its complexity is to combine the Qt log type with a custom message pattern.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 提供了多种实现方式。在结果和复杂性之间取得良好平衡的方法是将 Qt 日志类型与自定义消息模式相结合。
- en: 'Qt defines five log types, from the least to the most critical level:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 定义了五种日志类型，从最不严重到最关键级别：
- en: '`qDebug()`: This is used to write custom debug messages'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qDebug()`：用于写入自定义调试消息'
- en: '`qInfo()`: This is used to write informational messages'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qInfo()`：用于写入信息性消息'
- en: '`qWarning()`: This is used to write warnings and recoverable errors in your
    applications'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qWarning()`：用于在您的应用程序中写入警告和可恢复的错误'
- en: '`qCrtitical()`: This is used to write critical error messages and report system
    errors'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qCritical()`：用于写入关键错误消息和报告系统错误'
- en: '`qFatal()`: This is used to write a last message before automatically existing'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qFatal()`：用于在自动退出前写入最后一条消息'
- en: Try to always use the most appropriate one!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试始终使用最合适的一个！
- en: By default, the message pattern is configured to only display your message without
    any extra data, but you can customize the pattern to display more information.
    This pattern can be changed at runtime by setting the `QT_MESSAGE_PATTERN` environment
    variable. You can also call the `qSetMessagePattern` function from your software
    to change the pattern. The pattern is just a string with some placeholders.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，消息模式配置为仅显示您的消息而不显示任何额外数据，但您可以自定义模式以显示更多信息。此模式可以通过设置 `QT_MESSAGE_PATTERN`
    环境变量在运行时更改。您还可以从您的软件中调用 `qSetMessagePattern` 函数来更改模式。模式只是一个包含一些占位符的字符串。
- en: 'These are the most common placeholders you can use:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是最常用的占位符，您可以使用：
- en: '`%{appname}`: This is your application name'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%{appname}`：这是您的应用程序名称'
- en: '`%{file}`: This is the path to the source file'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%{file}`：这是源文件的路径'
- en: '`%{function}`: This is the function name'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%{function}`：这是函数名'
- en: '`%{line}`: This is a line in the source file'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%{line}`：这是源文件中的一行'
- en: '`%{message}`: This is an original message'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%{message}`：这是原始消息'
- en: '`%{type}`: This is the Qt log type ("debug", "info", "warning", "critical"
    or "fatal")'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%{type}`：这是 Qt 日志类型（"debug"、"info"、"warning"、"critical" 或 "fatal"）'
- en: '`%{time [format]}`: This is the system time when the message occurred'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%{time [format]}`: 这是消息发生时的系统时间'
- en: 'An easy way to use it is to edit your `main.cpp` file like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它的一个简单方法是像这样编辑你的`main.cpp`文件：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You should get something like this in your application output:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序输出应该类似于以下内容：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Try to play around with the Qt log types and the custom message pattern until
    you find a useful pattern for you.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试玩转Qt日志类型和自定义消息模式，直到找到对你有用的模式。
- en: Tip
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For more complex applications, you can use the `QLoggingCategory` class to define
    categories of logging. Visit [http://doc.qt.io/qt-5/qloggingcategory.html](http://doc.qt.io/qt-5/qloggingcategory.html)
    for more information on this.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的应用程序，你可以使用`QLoggingCategory`类来定义日志类别。有关更多信息，请访问[http://doc.qt.io/qt-5/qloggingcategory.html](http://doc.qt.io/qt-5/qloggingcategory.html)。
- en: Saving your logs to a file
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将日志保存到文件中
- en: A common need for a developer is to have logs. In some situations, you cannot
    have access to the console output, or you have to study the application state
    afterwards. In both cases, the log has to be outputted to a file.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者通常需要日志。在某些情况下，你可能无法访问控制台输出，或者你可能需要在之后研究应用程序状态。在这两种情况下，日志必须输出到文件。
- en: Qt provides a practical way of redirecting your logs (`qDebug`, `qInfo`, `qWarning`,
    and so on) to any device that is convenient for you: `QtMessageHandler`. To use
    it, you have to register a function that will save the logs to the desired output.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Qt提供了一个将你的日志（`qDebug`, `qInfo`, `qWarning`等）重定向到任何方便的设备的实用方法：`QtMessageHandler`。要使用它，你必须注册一个函数，该函数将日志保存到所需的输出。
- en: 'For example, in your `main.cpp`, add the following function:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在你的`main.cpp`文件中添加以下函数：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The signature of the function must be respected to be properly called by Qt.
    Let''s review the parameters:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的签名必须被尊重，以便Qt能够正确调用。让我们回顾一下参数：
- en: '`QtMsgType type`: This is an `enum` that describes the function that generated
    the message (`qDebug()`, `qInfo()`, `qWarning()`, and so on)'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtMsgType type`: 这是一个`enum`类型，用于描述生成消息的函数（例如`qDebug()`, `qInfo()`, `qWarning()`等）'
- en: '`QMessageLogContext& context`: This contains additional information about the
    log message (source file where the log was produced, name of the function, line
    number, and so on)'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QMessageLogContext& context`: 这包含有关日志消息的附加信息（日志产生的源文件、函数名称、行号等）'
- en: '`const QString& message`: This is the actual message that was logged'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const QString& message`: 这是实际记录的消息'
- en: The body of the function formats the log message before appending it to a file
    named `app.log`. You can easily add features in this function by adding a rotating
    log file, sending the logs through the network, or anything else.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 函数体在将日志消息附加到名为`app.log`的文件之前格式化日志消息。你可以通过添加循环日志文件、通过网络发送日志或进行其他操作来轻松地在此函数中添加功能。
- en: 'The last missing part is the registration of `messageHandler()`, which is done
    in the `main()` function:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后缺少的部分是`messageHandler()`的注册，这通常在`main()`函数中完成：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The call to the `qInstallMessageHander()` function is enough to reroute all
    the log messages to `app.log`. Once this is done, the logs will no longer be displayed
    in the console output and will be appended to `app.log` only.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`qInstallMessageHander()`函数足以将所有日志消息重路由到`app.log`。一旦完成，日志将不再显示在控制台输出中，而只会附加到`app.log`。
- en: Tip
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you need to unregister your custom message handler function, call `qInstallMessageHandler(0)`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要注销你的自定义消息处理函数，请调用`qInstallMessageHandler(0)`。
- en: Generating a command-line interface
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成命令行界面
- en: The command-line interface can be a wonderful way to start your application
    with some specific options. The Qt framework provides an easy way to define your
    options with the `QCommandLineParser` class. You can provide a short (for example, `-t`)
    or a long (for example, `--test`) option name. The application version and help
    menu is automatically generated. You can easily retrieve in your code if an option
    is set or not. An option can take a value and you can define a default value.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行界面可以是一个以一些特定选项启动应用程序的好方法。Qt框架提供了一个使用`QCommandLineParser`类定义选项的简单方法。你可以提供一个简短（例如，`-t`）或长（例如，`--test`）的选项名称。应用程序版本和帮助菜单将自动生成。你可以在代码中轻松检索是否设置了选项。一个选项可以接受一个值，并且你可以定义一个默认值。
- en: 'For example, we can create a CLI to configure the log files. We want to define
    three options:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以创建一个命令行界面来配置日志文件。我们希望定义三个选项：
- en: The `-debug` command, if set, enables the log file writing
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果设置了，`-debug`命令将启用日志文件写入
- en: The `-f` or `--file` command to define where to write the logs
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f`或`--file`命令用于定义日志的写入位置'
- en: The `-l` or `--level <level>` command to specify the minimum log level
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-l`或`--level <level>`命令用于指定最小日志级别'
- en: 'Look at the following snippet:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的片段：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s talk about each step:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论每个步骤：
- en: The first part uses the functions from `QCoreApplication` to set the application
    name and version. This information will be used by the `--version` option.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一部分使用`QCoreApplication`的函数来设置应用程序名称和版本。这些信息将被`--version`选项使用。
- en: Instantiate a `QCommandLineParser` class. Then we instruct it to automatically
    add the help (`-h` or `--help`) and version (`-v` or `--version`) options.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个`QCommandLineParser`类。然后我们指示它自动添加帮助（`-h`或`--help`）和版本（`-v`或`--version`）选项。
- en: Add our options with the `QCommandLineParser::addOptions()` function.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`QCommandLineParser::addOptions()`函数添加我们的选项。
- en: Request the `QCommandLineParser` class to process the command-line arguments.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求`QCommandLineParser`类处理命令行参数。
- en: Retrieve and use the options.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检索并使用选项。
- en: 'Here are the parameters to create an option:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是创建选项的参数：
- en: '`optionName`: By using this parameter, you can use a single or multiple names'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`optionName`: 通过使用此参数，你可以使用单个或多个名称'
- en: '`description`: In this parameter, the description of the option is displayed
    in the help menu'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`：在这个参数中，选项的描述将在帮助菜单中显示'
- en: '`valueName` (Optional): This shows the value name if your option expects one'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`valueName`（可选）：如果您的选项期望一个值，则显示值名称'
- en: '`defaultValue` (Optional): This shows the default value of the option'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultValue`（可选）：这显示了选项的默认值'
- en: You can retrieve and use the option using `QCommandLineParser::isSet()`, which
    returns true if the option was set by the user. If your option requires a value,
    you can retrieve it with `QCommandLineParser::value()`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`QCommandLineParser::isSet()`检索并使用选项，如果用户设置了选项，则返回true。如果您的选项需要值，您可以使用`QCommandLineParser::value()`检索它。
- en: 'Here is the display of the generated help menu:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是生成的帮助菜单的显示：
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, the following snippet displays the CLI in use:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下片段显示了正在使用的CLI：
- en: '[PRE21]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Sending and receiving HTTP data
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送和接收HTTP数据
- en: 'Requesting information to an HTTP server is a common task. Here again, the
    Qt folks prepared some useful classes to make it easy. To achieve this, we will
    rely on three classes:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 向HTTP服务器请求信息是一个常见任务。在这里，Qt的人们也准备了一些有用的类来简化这个过程。为了实现这一点，我们将依赖于三个类：
- en: '`QNetworkAccessManager`: This class allows your application to send requests
    and receive replies'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QNetworkAccessManager`：这个类允许您的应用程序发送请求并接收回复'
- en: '`QNetworkRequest`: This class holds the request to be sent with all the information
    (headers, URL, data, and so on)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QNetworkRequest`：这个类包含要发送的请求以及所有信息（头信息、URL、数据等）'
- en: '`QNetworkReply`: This class contains the result of a `QNetworkRequest` class
    with the headers and the data'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QNetworkReply`：这个类包含`QNetworkRequest`类的结果，包括头信息和数据'
- en: The `QNetworkAccessManager` class is the pivot point of the whole Qt HTTP API.
    It is built around a single `QNetworkAccessManager` object that holds the configuration
    of the client, proxy settings, cache information, and much more. This class is
    designed to be asynchronous, so you do not need to worry about blocking your current
    thread.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`QNetworkAccessManager`类是整个Qt HTTP API的枢纽点。它围绕一个单一的`QNetworkAccessManager`对象构建，该对象包含客户端的配置、代理设置、缓存信息等等。这个类被设计为异步的，所以你不需要担心阻塞当前线程。'
- en: 'Let''s see it in action in a custom `HttpRequest` class. First, the header:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在自定义的`HttpRequest`类中看看它的实际应用。首先，是头文件：
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `QNetworkAccessManager` class works with the signal/slot mechanism, so `HttpRequest`
    inherits from `QObject` and uses the `Q_OBJECT` macro. We declare the following
    functions and member:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`QNetworkAccessManager`类与信号/槽机制一起工作，所以`HttpRequest`从`QObject`继承并使用`Q_OBJECT`宏。我们声明以下函数和成员：'
- en: '`executeGet()`: This is used to trigger an `HTTP GET` request'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`executeGet()`: 这用于触发一个`HTTP GET`请求'
- en: '`replyFinished()`: This is the slot called when the `GET` request has completed'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replyFinished()`：这是在`GET`请求完成时调用的槽'
- en: '`mAccessManager`: This is the object that will be used for all our asynchronous
    requests'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mAccessManager`：这是我们用于所有异步请求的对象'
- en: 'Let''s turn our attention to the constructor of the `HttpRequest` class in
    the `HttpRequest.cpp`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把注意力转向`HttpRequest.cpp`中的`HttpRequest`类的构造函数：
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the body of the constructor, we connect the `finished()` signal from `mAccessManager`
    to our `replyFinished()` slot. This implies that every request sent through `mAccessManager`
    will trigger this slot.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数体中，我们将`mAccessManager`的`finished()`信号连接到我们的`replyFinished()`槽。这意味着通过`mAccessManager`发送的每个请求都会触发此槽。
- en: 'Enough with the preparation; let''s see the request and reply in action:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 准备工作就到这里；让我们看看请求和回复的实际操作：
- en: '[PRE24]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `HTTP GET` request is processed using `mAccessManager.get()`. The `QNetworkAccessManager`
    class provides the function for other HTTP verbs (`head()`, `post()`, `put()`, `delete()`,
    and so on. It expects a `QNetworkRequest` access, which takes a URL in its constructor.
    This is the simplest form of an HTTP request.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `mAccessManager.get()` 处理 `HTTP GET` 请求。`QNetworkAccessManager` 类提供了其他 HTTP
    动词（`head()`、`post()`、`put()`、`delete()` 等）的函数。它期望一个 `QNetworkRequest` 访问，该访问在其构造函数中接受一个
    URL。这是 HTTP 请求的最简单形式。
- en: 'Note that we did our request using the URL [http://httpbin.org/ip](http://httpbin.org/ip),
    which will respond to the emitter''s IP address in the JSON format:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用 URL [http://httpbin.org/ip](http://httpbin.org/ip) 进行了请求，它将以 JSON 格式响应发射器的
    IP 地址：
- en: '[PRE25]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This website is a practical developer resource, where you can send your test
    requests and have useful information sent back to you. It avoids having to launch
    a custom web server to only test a few requests. This website is an open-source
    project freely hosted by Runscope. Of course, you can replace the request URL
    with anything you wish.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个网站是一个实用的开发者资源，你可以发送你的测试请求，并收到有用的信息反馈。它避免了需要启动一个自定义的 Web 服务器来测试几个请求。这个网站是一个由
    Runscope 免费托管的开源项目。当然，你可以用你想要的任何内容替换请求 URL。
- en: Note
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Take a look at [http://httpbin.org/](http://httpbin.org/) to see all the supported
    request types.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 查看网址 [http://httpbin.org/](http://httpbin.org/) 以查看所有支持请求类型。
- en: After the `executeGet()` function is completed, the `mAccessManager` object
    executes the request in a separate thread and calls our slot, `replyFinished()`,
    with the resulting `QNetworkReply*` object. In this code snippet, you can see
    how to retrieve the HTTP status code and check if any network error happened,
    as well as how to get the body of the response with `reply->readAll()`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `executeGet()` 函数完成后，`mAccessManager` 对象在单独的线程中执行请求，并使用结果 `QNetworkReply*`
    对象调用我们的槽 `replyFinished()`。在这个代码片段中，你可以看到如何检索 HTTP 状态码并检查是否发生了任何网络错误，以及如何使用 `reply->readAll()`
    获取响应体。
- en: The `QNetworkReply` class inherits from `QIODevice`, and therefore, you can
    read it all at once with `readAll()`, or by chunks with a loop on `read()`. This
    lets you adapt the reading to your needs using a familiar `QIODevice` API.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`QNetworkReply` 类继承自 `QIODevice`，因此你可以使用 `readAll()` 一次性读取它，或者通过在 `read()`
    上的循环以块的形式读取。这让你能够使用熟悉的 `QIODevice` API 根据你的需求调整读取。'
- en: Note that you are the owner of the `QNetworkReply*` object. You should not delete
    it by hand (your application might crash if you do so); instead, it's better to
    use the `reply->deleteLater()` function, which will let the Qt event loop pick
    the appropriate moment to delete this object.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你是 `QNetworkReply*` 对象的所有者。你不应该手动删除它（如果你这样做，你的应用程序可能会崩溃）；相反，最好使用 `reply->deleteLater()`
    函数，这将让 Qt 事件循环选择合适的时机来删除此对象。
- en: Now let's see a more complex example of `QNetworkReply` with an `HTTP POST`
    method. There are times where you will need to keep track of the `QNetworkReply`
    class and have a more fine-grained control over its life cycle.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看一个更复杂的 `QNetworkReply` 示例，它使用 `HTTP POST` 方法。有时你需要跟踪 `QNetworkReply`
    类并对其生命周期有更精细的控制。
- en: 'Here is the implementation of an `HTTP POST` method that also relies on `HttpRequest::mAccessManager`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个依赖于 `HttpRequest::mAccessManager` 的 `HTTP POST` 方法的实现：
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We start by creating a `QNetworkRequest` class with a custom header: `Content-Type`
    is now `application/x-www-form-urlencoded` to respect the HTTP RFC. After that,
    a URL form is built, ready to be sent with the request. You can add as many items
    as you wish to the `urlQuery` object.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个带有自定义头部的 `QNetworkRequest` 类：`Content-Type` 现在是 `application/x-www-form-urlencoded`
    以遵守 HTTP RFC。之后，构建一个 URL 表单，准备与请求一起发送。你可以向 `urlQuery` 对象添加你想要的任何项目。
- en: The next part gets interesting. When executing `mAccessManager.post()` with
    the request and the URL encoded form, the `QNetworkReply*` object is immediately
    returned to us. From here, we use some lambdas slots connected directly to reply
    rather than using `mAccessManage` slots. This lets you have precise control over
    what happens for each reply.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分很有趣。当使用请求和 URL 编码表单执行 `mAccessManager.post()` 时，`QNetworkReply*` 对象立即返回给我们。从这里，我们使用一些直接连接到回复的
    lambda 插槽，而不是使用 `mAccessManage` 插槽。这让你能够精确控制每个回复发生的情况。
- en: Note that the `QNetworkReploy::readyRead` signal comes from the `QIODevice`
    API and that it does not pass the `QNetworkReply*` object in the parameter. It
    is your job to store the reply in a member field somewhere or retrieve the emitter
    of the signal.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`QNetworkReply::readyRead` 信号来自 `QIODevice` API，并且它不会在参数中传递 `QNetworkReply*`
    对象。将回复存储在某个成员字段中或检索信号发射者的责任在于您。
- en: 'Finally, this code snippet does not undo our preceding slot, `replyFinished()`,
    which is connected to `mAccessManager`. If you execute this code, you will have
    the following output sequence:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个代码片段不会撤销我们之前定义的槽函数 `replyFinished()`，该函数连接到 `mAccessManager`。如果您执行此代码，您将得到以下输出序列：
- en: '[PRE27]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The lambda connected to the `QNetworkReply::readyRead` signal is first called,
    and after that, the `HttpRequest::replyFinished` signal is called.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到 `QNetworkReply::readyRead` 信号的 lambda 表达式首先被调用，然后调用 `HttpRequest::replyFinished`
    信号。
- en: 'The last feature we will cover on the Qt HTTP stack is synchronous requests.
    If you happen to need to manage the request threading yourself, the default asynchronous
    work mode of `QNetworkAccessManager` can get in your way. To circumvent this,
    you can use a custom `QEventLoop`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Qt HTTP 栈上介绍的最后特性是同步请求。如果您需要自己管理请求线程，`QNetworkAccessManager` 的默认异步工作模式可能会给您带来麻烦。为了绕过这个问题，您可以使用自定义的
    `QEventLoop`：
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this function, we declare another `QNetworkAccessManager` that will not interfere
    with the one declared in `HttpRequest`. Right after, a `QEventLoop` object is
    declared and connected to `localManager`. When `QNetworkAccessManager` emits the `finished()`
    signal, `eventLoop` will quit and the calling function will resume.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们声明了另一个 `QNetworkAccessManager`，它不会干扰在 `HttpRequest` 中声明的那个。紧接着，声明了一个
    `QEventLoop` 对象并将其连接到 `localManager`。当 `QNetworkAccessManager` 发射 `finished()`
    信号时，`eventLoop` 将退出，调用函数将恢复。
- en: The `request` is built as usual, the `reply` object is retrieved, and the function
    becomes blocked with the call to `eventLoop.exec()`. The function is blocked until `localManager`
    has emitted its finished signal. In other words, the request is still done asynchronously;
    the sole difference is that the function is blocked until the request is completed.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`request` 按照常规构建，检索到 `reply` 对象，函数因调用 `eventLoop.exec()` 而阻塞。函数会一直阻塞，直到 `localManager`
    发射其完成信号。换句话说，请求仍然是异步完成的；唯一的不同是函数会阻塞直到请求完成。'
- en: Finally, the `reply` object can be safely read and deleted at the end of the
    function. This `QEventLoop` trick can be used any time a synchronous wait for
    a Qt signal is needed; use it wisely to avoid blocking the UI thread!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以在函数的末尾安全地读取和删除 `reply` 对象。这个 `QEventLoop` 技巧可以在需要同步等待 Qt 信号时使用；明智地使用它以避免阻塞
    UI 线程！
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned some tips that complete your Qt knowledge. You
    should now have the ability to use Qt Creator with ease and efficiency. The `QDebug`
    format should not hold any secrets now, and you can now save your logs to a file
    without even blinking. You can create a good-looking CLI interface, debug the
    memory of any program without shaking, and execute an HTTP request with confidence.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学到了一些完善您 Qt 知识的技巧。现在您应该能够轻松高效地使用 Qt Creator。`QDebug` 格式现在不应该有任何秘密了，您现在可以轻松地将日志保存到文件中，甚至不需要眨眼。您可以创建一个看起来不错的
    CLI 接口，无需颤抖地调试任何程序的内存，并且可以自信地执行 HTTP 请求。
- en: We sincerely hope that you had as much fun reading this book as we did writing
    it. In our opinion, Qt is a great framework, and it covers many areas that deserve
    to be deepened with a book (or several books!). We hope you keep coding C++ Qt
    code with fun and pleasure by building efficient and beautifully crafted applications.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们衷心希望您阅读这本书时能像我们写作时一样享受乐趣。在我们看来，Qt 是一个优秀的框架，它涵盖了众多值得通过书籍（或几本书）深入探讨的领域！我们希望您在构建高效且精美构建的应用程序时，能够愉快地编码
    C++ Qt 代码。
