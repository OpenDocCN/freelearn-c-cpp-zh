- en: '*Chapter 4*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第四章*'
- en: Generic Programming and Templates
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型编程和模板
- en: Lesson Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 课程目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Understand how templates work and when to use them
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解模板的工作原理以及何时使用它们
- en: Identify and implement templated functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别和实现模板函数
- en: Implement template classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现模板类
- en: Write code that works for multiple types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写适用于多种类型的代码
- en: In this chapter, you will learn how to use templates effectively in your program.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何在程序中有效地使用模板。
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: When programming, it is common to face problems that are recurring for different
    types of objects, such as storing a list of objects, or searching elements in
    a list, or finding the maximum between two elements.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程时，经常会遇到针对不同类型对象重复出现的问题，例如存储对象列表、在列表中搜索元素或找到两个元素之间的最大值。
- en: 'Let''s say that in our program we want to be able to find the maximum between
    two elements, either integers or doubles. With the features we have learned so
    far, we could write the following code:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在我们的程序中，我们想要能够找到两个元素之间的最大值，无论是整数还是双精度浮点数。使用我们迄今为止学到的特性，我们可以编写以下代码：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the previous code, the two functions are identical except for the *types*
    of the parameters and the *return type*. Ideally, we would like to write these
    kind of operations only once and reuse them in the entire program.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，两个函数除了参数的 *类型* 和 *返回类型* 之外是相同的。理想情况下，我们希望只编写这类操作一次，并在整个程序中重用它们。
- en: 'Moreover, our `max()` function can only be called with types for which an overload
    exists: `int` and `double` in this case. If we wanted it to work with any numerical
    type, we would need to write an **overload** for each of the numerical types:
    we would need to know in advance about all the types that will be used to call
    it, especially when the function is part of a library that is intended to be used
    by other developers, as it becomes impossible for us to know the types that will
    be used when calling the function.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的 `max()` 函数只能用存在重载的类型来调用：在这种情况下是 `int` 和 `double`。如果我们希望它能够与任何数值类型一起工作，我们就需要为每种数值类型编写一个
    **重载**：我们需要提前知道所有将要用于调用它的类型，特别是当函数是面向其他开发者使用的库的一部分时，因为我们无法知道调用函数时使用的类型。
- en: We can see that there is nothing specific to integers being required to find
    the maximum elements; if the elements implement `operator<`, then it is possible
    to find the greater of the two numbers, and the algorithm does not change. In
    these situations, C++ offers an effective tool—**templates**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在找到最大元素时，并不需要特定于整数的要求；如果元素实现了 `operator<`，则可以找到两个数中的较大者，算法不会改变。在这些情况下，C++提供了一个有效的工具——**模板**。
- en: Templates
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板
- en: Templates are a way to define functions or classes that can work for many different
    types, while still writing them only once.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是一种定义函数或类的方法，它们可以适用于许多不同的类型，同时只需编写一次。
- en: They do so by having special kinds of parameters—**type parameters**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 它们通过具有特殊类型的参数——**类型参数**来实现。
- en: When writing the template code, we can use this type parameter as if it were
    a real type, such as `int` or `string`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写模板代码时，我们可以使用这个类型参数，就像它是一个真实类型一样，例如 `int` 或 `string`。
- en: When the templated function is called or the template class is instantiated,
    the type parameter is substituted with the real type that's used by the calling
    code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用模板函数或实例化模板类时，类型参数会被替换为调用代码实际使用的真实类型。
- en: 'Now let''s look at an example of a template in C++ code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看C++代码中的一个模板示例：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A template always starts with the `template` keyword, followed by the list of
    template parameters enclosed in *angle* brackets.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 模板总是以 `template` 关键字开头，后跟用 *尖括号* 包围的模板参数列表。
- en: A template parameter list is a list of comma-separated parameters. In this case,
    we only have one—`typename T`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 模板参数列表是由逗号分隔的参数列表。在这种情况下，我们只有一个——`typename T`。
- en: The `typename` keyword tells the template that we are writing a templated function
    that uses a generic type, which we are going to name `T`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`typename` 关键字告诉模板我们正在编写一个使用泛型类型的模板函数，我们将将其命名为 `T`。'
- en: Note
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: You can also use the `class` keyword in place of `typename`, since there is
    no difference between them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以用 `class` 关键字代替 `typename`，因为它们之间没有区别。
- en: Then, the definition of the function follows. In the function definition, we
    can use the name `T` when we want to refer to the generic type.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，函数的定义紧随其后。在函数定义中，当我们想要引用泛型类型时，我们可以使用名称 `T`。
- en: 'To call the template, we specify the name of the template, followed by the
    list of types we want to use as *type arguments*, enclosed in angle brackets:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用模板，我们指定模板的名称，然后是我们要用作 *类型参数* 的类型的列表，用尖括号括起来：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This calls the templated function `max`, specifying `int` as the type parameter.
    We say that we instantiated the templated function `max` with type `int`, and
    then called that instance.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这调用了模板函数 `max`，指定 `int` 作为类型参数。我们说我们用类型 `int` 实例化了模板函数 `max`，然后调用了该实例。
- en: We do not always need to specify the type parameters of a template; the compiler
    can deduce them from the calling code. A later section will describe this feature.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不总是需要指定模板的类型参数；编译器可以从调用代码中推断它们。稍后的部分将描述这个特性。
- en: Because of how powerful templates are, the big part of the C++ standard library
    is based on templates, as we will see in *Chapter 5*, *Standard Library Containers
    and Algorithms*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模板非常强大，C++ 标准库的大部分内容都是基于模板的，我们将在 *第 5 章*，*标准库容器和算法* 中看到。
- en: Now we'll explore in depth what happens when we compile the code that contains
    templates.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将深入探讨当我们编译包含模板的代码时会发生什么。
- en: Compiling the Template Code
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译模板代码
- en: Similar to functions and classes, a template needs to be *declared* before being
    used.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与函数和类类似，模板在使用之前需要被 *声明*。
- en: When the compiler first encounters a template definition in the program, it
    parses it and performs only *part* of the checks it usually does on the rest of
    the code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器首次遇到程序中的模板定义时，它会解析它并仅执行通常对其他代码所做的部分检查。
- en: This happens because the compiler does not know which type is going to be used
    with the template when it parses it, since the types are parameters themselves.
    This prevents the compiler from performing checks that involve the parameter types,
    or anything that depends on them.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为编译器在解析模板时不知道将要使用哪种类型，因为类型本身就是参数。这阻止编译器执行涉及参数类型的检查，或任何依赖于它们的检查。
- en: Because of this, you get notified of some errors in the template only when you
    instantiate it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你只有在实例化模板时才会收到一些错误的提示。
- en: Once we define a template, we can instantiate it in our code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了一个模板，我们就可以在我们的代码中实例化它。
- en: When a template is instantiated, the compiler looks at the definition of the
    template and uses it to generate a new instance of the code, where all the references
    to the type parameters are replaced by the types that are provided when instantiating
    it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当模板被实例化时，编译器查看模板的定义，并使用它生成一个新的代码实例，其中所有对类型参数的引用都被在实例化时提供的类型所替换。
- en: 'For example: when we call `max<int>(1,2)`, the compiler looks at the template
    definition we specified earlier and generates code as if we wrote the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：当我们调用 `max<int>(1,2)` 时，编译器查看我们之前指定的模板定义，并生成如下代码：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Since the compiler generates the code from the template definition, it means
    that the full definitions need to be visible to the calling code, not only the
    declaration, as was the case for functions and classes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于编译器从模板定义生成代码，这意味着完整的定义需要对调用代码可见，而不仅仅是声明，就像函数和类的情况一样。
- en: The template can still be forward declared, but the compiler must also see the
    definition. Because of this, when writing templates that should be accessed by
    several files, both the definition and the declaration of the templates must be
    in the **header** file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 模板仍然可以提前声明，但编译器也必须看到定义。因此，当编写应该由多个文件访问的模板时，模板的定义和声明都必须在 **头文件** 中。
- en: This restriction does not apply if the template is used only in one file.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模板仅在一个文件中使用，则此限制不适用。
- en: 'Exercise 11: Finding the Bank Account of the User with the Highest Balance'
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 11：查找余额最高的用户的银行账户
- en: Write a template function that accepts details of two bank accounts (of the
    same type) and returns the balance of the bank account with the highest balance.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个模板函数，该函数接受两个银行账户（相同类型）的详细信息，并返回余额最高的银行账户的余额。
- en: 'For this exercise, perform the following steps:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，执行以下步骤：
- en: 'Let''s create two structs named `EUBankAccount` and `UKBankAccount` to represent
    the **European Union** bank account and the **United Kingdom** bank account with
    the required basic information, as shown in the following code:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建两个名为 `EUBankAccount` 和 `UKBankAccount` 的结构体，以表示具有所需基本信息的**欧盟**银行账户和**英国**银行账户，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The template function will have to compare the amount of the bank accounts.
    We want to work with different bank account types, so we need to use a template:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板函数将不得不比较银行账户的金额。我们想要与不同的银行账户类型一起工作，因此我们需要使用一个模板：
- en: '[PRE5]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, in the `main` function, call both the structs and the template function,
    as shown here:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`main`函数中，调用结构体和模板函数，如下所示：
- en: '[PRE6]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output is as follows:'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE7]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using Template Type Parameters
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用模板类型参数
- en: As we saw earlier, the compiler uses the template as a guide to generate a template
    instance with some concrete type when the template is used.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，当模板被使用时，编译器将其用作指南来生成一个具有某些具体类型的模板实例。
- en: This means that we can use the type as a *concrete* type, including applying
    type modifiers to it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以将类型用作一个*具体*类型，包括对其应用类型修饰符。
- en: 'We saw earlier, a type can be modified by making it constant with the `const`
    modifier, and we can also take a reference to an object of a specific type by
    using the *reference* modifier:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到，类型可以通过使用`const`修饰符使其成为常量来修改，我们还可以通过使用*引用*修饰符来获取特定类型的对象的引用：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we can see a `template` function that creates a new object from a different
    instance of an object.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们可以看到一个`template`函数，它从一个对象的另一个实例创建一个新的对象。
- en: Since the function does not modify the original type, the function would like
    to accept it as a `const` reference.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该函数不修改原始类型，该函数希望将其作为`const`引用接受。
- en: Since we are declaring the type `T` in the template, in the function definition
    we can use the modifiers on the type to accept the parameter in the way we deem
    more appropriate.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在模板中声明了类型`T`，在函数定义中我们可以使用类型修饰符以我们认为更合适的方式接受参数。
- en: 'Notice that we used the type two times: once with some modifiers and once with
    no modifiers.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用了两次类型：一次带有一些修饰符，一次没有修饰符。
- en: This gives a lot of flexibility when using templates and writing functions,
    as we can liberally modify the type to suit our needs.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这在使用模板和编写函数时提供了很大的灵活性，因为我们可以自由地修改类型以适应我们的需求。
- en: Similarly, we have a lot of freedom in where we can use the template arguments.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们在哪里使用模板参数有很高的自由度。
- en: 'Let''s see two templates with a multiple template type argument:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看两个具有多个模板类型参数的模板：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can see that we can use the template argument in the function parameter,
    in the return type, or instantiate it directly in the function body.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们可以在函数参数、返回类型或直接在函数体中实例化模板参数中使用模板参数。
- en: Also, the order in which the template arguments are declared does not impact
    where and how the template parameters can be used.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，模板参数声明的顺序不会影响模板参数可以在哪里以及如何使用。
- en: Requirements of Template Parameter Types
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板参数类型的要求
- en: 'In the code snippet at the beginning of this chapter, we wrote some templates
    that accept any kind of type. In reality, our code does not work for any kind
    of type; for example: `max()` requires the types to support the `<` operation.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开头代码片段中，我们编写了一些接受任何类型的模板。实际上，我们的代码对任何类型都不起作用；例如：`max()`需要类型支持`<`操作。
- en: We can see that there were some requirements on the type.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到对类型有一些要求。
- en: 'Let''s try to understand what having a requirement on a type means when using
    templates in C++ code. We will do so by using the following template code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试理解在C++代码中使用模板时对类型有要求意味着什么。我们将通过使用以下模板代码来做到这一点：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can then write the following function as main and compile the program:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将以下函数作为主函数并编译程序：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When we compile this program, the compilation ends successfully without any
    error.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编译这个程序时，编译成功结束，没有任何错误。
- en: 'Let''s say we change the `main` function to be the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将`main`函数改为以下内容：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: We did not specify the type to the template. We will see later in this chapter
    when the compiler can automatically deduce the types from the call.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有指定类型给模板。我们将在本章后面看到，当编译器可以从调用中自动推断类型时。
- en: 'The compiler will give us an error when we compile it:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器在编译时会给我们一个错误：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note how the error appeared when we used the template function, and that it
    was not detected before.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意当我们使用模板函数时错误是如何出现的，并且它之前没有被检测到。
- en: The error is telling us that we tried to call the `getAccount` method on an
    integer, which does not have such a method.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 错误告诉我们我们试图在一个没有此类方法的整数上调用`getAccount`方法。
- en: Why didn't the compiler tell us this when we were writing the template?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么编译器在我们编写模板时没有告诉我们这一点？
- en: The reason for this is that the compiler does not know what type `User` will
    be; therefore, it cannot tell whether the `getAccount` method will exist or not.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于编译器不知道类型 `User` 将会是什么；因此，它无法判断 `getAccount` 方法是否存在。
- en: When we tried to use the template, we tried to generate the code with two specific
    types, and the compiler checked that these two types were suitable for the template;
    they were not, and the compiler gave us an error.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试使用模板时，我们尝试使用两种特定的类型生成代码，编译器检查了这些类型是否适合模板；它们不适合，编译器给出了错误。
- en: The types we used were not satisfying the requirements of the template types.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的类型没有满足模板类型的要求数据。
- en: Unfortunately, there is no easy way in the current C++ standard, even the most
    recent C++17, to specify the requirements of templates in the code—for that, we
    need good documentation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在当前的 C++ 标准中，即使是最近的 C++17，也没有简单的方法来指定模板的要求——为此，我们需要良好的文档。
- en: 'The template has two type arguments, so we can look at the requirements for
    each type:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 模板有两个类型参数，因此我们可以查看每个类型的要求数据：
- en: '`User` object must have a `getAccount` method'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`User` 对象必须有一个 `getAccount` 方法'
- en: '`Container` object must have a `push_back` method'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Container` 对象必须有一个 `push_back` 方法'
- en: The compiler finds the first problem when we call the `getAccount()` function
    and it notifies us.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `getAccount()` 函数时，编译器发现了第一个问题，并通知我们。
- en: 'To solve this issue, let''s declare a suitable class, as shown here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，让我们声明一个合适的类，如下所示：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, let''s call the template with the help of the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们借助以下代码调用模板：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We still get an error:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然得到一个错误：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This time, the error message is less clear, but the compiler is telling us that
    there is no method called `push_back` that accepts an account in `basic_string<char>`
    (`std::string` is an alias for it). The reason for this is that `std::string`
    has a method called `push_back`, but it only accepts characters. Since we are
    calling it with an `Account`, it fails.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，错误信息不太清晰，但编译器告诉我们没有名为 `push_back` 的方法可以接受 `basic_string<char>`（`std::string`
    是它的别名）中的账户。原因是 `std::string` 有一个名为 `push_back` 的方法，但它只接受字符。由于我们用 `Account` 调用它，所以失败了。
- en: 'We need to be more precise in the requirements for our template:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对模板的要求更加精确：
- en: '`getAccount` method that returns an object'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回对象的 `getAccount` 方法
- en: '`push_back` method that accepts objects of the type returned by `getAccount`
    on the user'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受用户 `getAccount` 返回类型对象的 `push_back` 方法
- en: Note
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The `std::vector` type in the C++ standard library allows to store sequences
    of elements of an arbitrary type. `push_back` is a method that's used for adding
    a new element at the end of the vector. We will see more about vectors in *Chapter
    5*, *Standard Library Containers and Algorithms*.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C++标准库中的 `std::vector` 类型允许存储任意类型的元素序列。`push_back` 是一个用于在向量末尾添加新元素的方法。我们将在 *第五章*，*标准库容器和算法*
    中了解更多关于向量的内容。
- en: 'We now change the calling code to consider all the requirements:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将调用代码修改为考虑所有要求：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This time, the code compiles correctly!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，代码编译正确了！
- en: This shows us how the compiler checks most of the errors, but only when we instantiate
    the template.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明编译器是如何检查大多数错误的，但只有在实例化模板时才会这样做。
- en: It is also very important to clearly document the requirements of the template
    so that the user does not have to read complicated error messages to understand
    which requirement is not respected.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这也非常重要，要清楚地记录模板的要求，以便用户不必阅读复杂的错误信息来了解哪个要求没有被遵守。
- en: Note
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: To make it easy to use our templates with many types, we should try to set the
    least requirements we can on the types.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的模板易于与许多类型一起使用，我们应该尽量对类型设置最少的要求。
- en: Defining Function and Class Templates
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义函数和类模板
- en: In the previous section, we saw the advantages of templates in writing abstractions.
    In this section, we are going to explore how we can effectively use templates
    in our code to create **templated functions** and **templated classes**.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了模板在编写抽象方面的优势。在本节中，我们将探讨如何有效地在我们的代码中使用模板来创建 **模板函数** 和 **模板类**。
- en: Function Template
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数模板
- en: In the previous section, we learned how function templates are written.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何编写函数模板。
- en: In this section, we will learn about the two features that were introduced by
    C++11 that make it easier to write template functions. These two functions are
    trailing return types and `decltype`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习 C++11 引入的两个特性，使编写模板函数更容易。这两个函数是尾随返回类型和 `decltype`。
- en: 'Let''s start with the `decltype`. The `decltype` is a keyword that accepts
    an expression and returns the type of that expression. Let''s examine the following
    code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `decltype` 开始。`decltype` 是一个关键字，它接受一个表达式并返回该表达式的类型。让我们看看以下代码：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the previous code, `y` is declared as an integer, because we are using the
    type of the expression `x`, which is `int`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，`y` 被声明为整数类型，因为我们正在使用表达式 `x` 的类型，它是 `int`。
- en: 'Any expression can be used inside `decltype`, even complex ones, for example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`decltype` 内部可以使用任何表达式，即使是复杂的表达式，例如：'
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let's look at the second feature—**trailing return types**.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看第二个特性——**尾随返回类型**。
- en: 'We saw that a function definition starts with the return type, followed by
    the name of the function and then the parameters. For example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到函数定义以返回类型开始，然后是函数名，然后是参数。例如：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Starting from C++11, it is possible to use a trailing return type: specifying
    the return type at the end of the function signature. The syntax to declare a
    function with a trailing return type is to use the keyword `auto`, followed by
    the name of the function and the parameters, and then by an *arrow* and the *return
    type*.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C++11 开始，可以使用尾随返回类型：在函数签名末尾指定返回类型。声明具有尾随返回类型的函数的语法是使用关键字 `auto`，然后是函数名和参数，然后是一个
    *箭头* 和 *返回类型*。
- en: 'The following is an example of a trailing return type:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个尾随返回类型的示例：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is not beneficial when writing regular functions, but it becomes useful
    when writing templates and when combined with `decltype`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写常规函数时，这并不有利，但当编写模板并与 `decltype` 结合使用时，它变得很有用。
- en: 'The reason for this is that `decltype` has access to the variables defined
    in the parameters of the function, and the return type can be computed from them:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是 `decltype` 可以访问函数参数中定义的变量，返回类型可以从中计算得出：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is an example of a `forward declaration` of a function template.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个函数模板的 `前向声明` 示例。
- en: Note
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: When the user wants to provide a definition, it needs to provide the same template
    declaration, followed by the body of the function.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户想要提供定义时，它需要提供相同的模板声明，然后是函数体。
- en: Without the trailing return type, we would have to know what the type returned
    by `user.getAccount()` is to use it as the return type of the `getAccount()` function.
    The return type of `user.getAccount()` can be different depending on the type
    of the template parameter `User`, which in turn means that the return type of
    the `getAccount` function could change depending on the `User` type. With the
    trailing return type, we don't need to know what type is returned by `user.getAccount()`,
    as it is determined automatically. Even better, when different types are used
    in our function or a user changes the return type of the `getAccount` method in
    one of the types that's used to instantiate the template, our code will handle
    it automatically.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 没有尾随返回类型，我们必须知道 `user.getAccount()` 返回的类型才能将其用作 `getAccount()` 函数的返回类型。`user.getAccount()`
    的返回类型可能因模板参数 `User` 的类型而异，这意味着 `getAccount` 函数的返回类型可能会根据 `User` 类型而变化。有了尾随返回类型，我们不需要知道
    `user.getAccount()` 返回的类型，因为它会自动确定。更好的是，当我们在函数中使用不同类型或用户更改用于实例化模板的类型之一的 `getAccount`
    方法的返回类型时，我们的代码会自动处理它。
- en: 'More recently, C++14 introduced the ability to simply specify `auto` in the
    function declaration, without the need for the trailing return type:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，C++14 引入了在函数声明中简单地指定 `auto` 的能力，而不需要尾随返回类型：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The return type is automatically deduced by the compiler, and to do so, the
    compiler needs to see the definition of the function—we cannot forward declare
    functions that return `auto`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型由编译器自动推导，为此，编译器需要看到函数的定义——我们不能前向声明返回 `auto` 的函数。
- en: 'Additionally, `auto` always returns a value—it never returns a reference: this
    is something to be aware of when using it, as we could unintentionally create
    copies of the returned value.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`auto` 总是返回一个值——它永远不会返回一个引用：在使用它时要注意这一点，因为我们可能会无意中创建返回值的副本。
- en: One last useful feature of function templates is how to reference them without
    calling them.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 函数模板的一个最后但很有用的特性是，如何在不需要调用它们的情况下引用它们。
- en: 'Up until now, we have only seen how to call the function templates, but C++
    allows us to pass functions as parameters as well. For example: when sorting a
    container, a custom comparison function can be provided.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了如何调用函数模板，但C++允许我们将函数作为参数传递。例如：在排序容器时，可以提供自定义的比较函数。
- en: We know that a template is just a blueprint for a function, and the real function
    is going to be created only when the template is instantiated. C++ allows us to
    instantiate the template function even without calling it. We can do this by specifying
    the name of the template function, followed by the template parameters, without
    adding the parameters for the call.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道模板只是一个函数的蓝图，而真正的函数只有在模板实例化时才会创建。C++允许我们在不调用它的情况下实例化模板函数。我们可以通过指定模板函数的名称，然后是模板参数，而不添加调用参数来完成此操作。
- en: 'Let''s understand the following example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解以下示例：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `sort` is a function that takes an array of five elements and a pointer
    to the function to compare two elements:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort`是一个接受五个元素数组和两个元素比较函数指针的函数：'
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To call `sort` with an instance of the `less` template for integers, we would
    write the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用整数`less`模板的实例调用`sort`，我们将编写以下代码：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we take a pointer to the instance of `less` for integers. This is particularly
    useful when using the Standard Template Library, which we will see in *Chapter
    5*, *Standard Library Containers and Algorithms*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们取一个指向整数`less`实例的指针。这在使用标准模板库时特别有用，我们将在*第5章*，*标准库容器和算法*中看到。
- en: Class Templates
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类模板
- en: 'In the previous section, we learned how to write template functions. The syntax
    for class templates is equivalent to the one for functions: first, there is the
    template declaration, followed by the declaration of the class:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何编写模板函数。类模板的语法与函数的语法等效：首先，是模板声明，然后是类的声明：
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And equivalently to functions, to instantiate a class template, we use the
    angle brackets containing a list of types:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 并且与函数等效，要实例化一个类模板，我们使用包含类型列表的尖括号：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Like functions, class template code gets generated when the template is instantiated,
    and the same restrictions apply: the definition needs to be available to the compiler
    and some of the error-checking is executed when the template is instantiated.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于函数，当模板实例化时，会生成类模板代码，并且适用相同的限制：定义需要对编译器可用，并且在模板实例化时执行一些错误检查。
- en: As we saw in *Lesson 3*, *Classes*, while writing the body of a class, the name
    of the class is sometimes used with a special meaning. For example, the name of
    the constructor functions must match the name of the class.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*第3课*，*类*中看到的，在编写类的主体时，类的名称有时会带有特殊含义。例如，构造函数函数的名称必须与类的名称匹配。
- en: 'In the same way, when writing a class template, the name of the class can be
    used directly, and it will refer to the specific template instance being created:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以同样的方式，在编写类模板时，可以直接使用类的名称，它将引用正在创建的特定模板实例：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This makes writing template classes a similar experience to writing regular
    classes, with the added benefit of being able to use the template parameters to
    make the class work with generic types.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得编写模板类与编写常规类有相似的经验，并且增加了能够使用模板参数使类与泛型类型一起工作的额外好处。
- en: 'Like regular classes, template classes can have fields and methods. The field
    can depend on the type declared by the template. Let''s review the following code
    example:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规类一样，模板类可以有字段和方法。字段可以依赖于模板声明的类型。让我们回顾以下代码示例：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Also when writing methods, the class can use the type parameter of the class:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在编写方法时，类可以使用类的类型参数：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Classes can also have templated methods. Templated methods are similar to template
    functions, but they can access the class instance data.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 类也可以有模板方法。模板方法类似于模板函数，但它们可以访问类实例数据。
- en: 'Let''s review the following example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾以下示例：
- en: '[PRE32]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `sort` method will accept any type and will compile if the type satisfies
    all the requirements that the method imposes on the type.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort`方法将接受任何类型，并且如果类型满足方法对类型的所有要求，它将编译。'
- en: 'To call the method, the syntax follows the one for calling functions:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 调用方法时，语法遵循调用函数的语法：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The method template can be part of a non-template class.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 方法模板可以是非模板类的一部分。
- en: In these situations, the compiler can sometimes deduce the type of the parameter,
    where the user does not have to specify it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，编译器有时可以推断出参数的类型，而用户不必指定它。
- en: 'If a method is only declared in the class, as we did in the example with `sort`,
    the user can later implement it by specifying the template types of both the class
    and the method:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个方法仅在类中声明，就像我们在`sort`示例中所做的那样，用户可以在以后通过指定类和方法的双重模板类型来实现它：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The name of the types does not have to match, but it is a good practice to be
    consistent with the names.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 类型名称不必匹配，但保持名称一致性是一个好习惯。
- en: Similar to methods, the class can also have templated overloaded operators.
    The approach is identical to writing the operator overloads for regular classes,
    with the difference that the declaration of a template must precede the overload
    declaration like we saw for method templates.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于方法，类也可以有模板重载运算符。方法与常规类重载运算符的编写方式相同，区别在于模板的声明必须先于重载声明的声明，就像我们在方法模板中看到的那样。
- en: Finally, something to be aware of is how static methods and static fields interact
    with the class template.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，需要注意的一点是静态方法和静态字段如何与类模板交互。
- en: 'We need to remember that the template is a guide on the code that will be generated
    for the specific types. This means that when a template class declares a static
    member, the member is shared only between the instantiations of the template with
    the same template parameters:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要记住，模板是针对将生成的特定类型的代码的指南。这意味着当模板类声明一个静态成员时，该成员仅在具有相同模板参数的模板实例之间共享：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`int_array1` and `int_array2` will share the same static variable, `element_size`,
    since they are both of the same type: `MyArray<int>`. On the other hand, `string_array`
    has a different one, because its class type is `MyArray<std::string>`. `MyArray<int>`
    and `MyArray<std::string>`, even if generated from the same class template, are
    two different classes, and thus do not share static fields.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`int_array1`和`int_array2`将共享同一个静态变量`element_size`，因为它们都是同一类型：`MyArray<int>`。另一方面，`string_array`有一个不同的，因为它的类类型是`MyArray<std::string>`。`MyArray<int>`和`MyArray<std::string>`，即使是从同一个类模板生成的，也是两个不同的类，因此不共享静态字段。'
- en: Dependent Types
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖类型
- en: It's fairly common, especially for code that interacts with templates, to define
    some public aliases to types.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这在代码中相当常见，尤其是在与模板交互的代码中，通常会定义一些公共别名来表示类型。
- en: 'A typical example would be the `value_type` `type alias` for containers, which
    specifies the type contained:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的例子是容器的`value_type` `type alias`，它指定了包含的类型：
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Why is this being done?
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这样做？
- en: The reason for this is that if we are accepting a generic array as a template
    parameter, we might want to find out the contained type.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于，如果我们接受一个泛型数组作为模板参数，我们可能想找出包含的类型。
- en: 'If we were accepting a specific type, this problem would not arise. Since we
    know the type of vector, we could write the following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们接受一个特定的类型，这个问题就不会出现。由于我们知道向量的类型，我们可以编写以下代码：
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: But how can we do this when we accept any container that provides the `push_back`
    method?
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 但当我们接受任何提供`push_back`方法的容器时，我们如何做到这一点？
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can access the `type alias` declared inside the container, which specifies
    which kind of values it contains, and we use it to instantiate a new value:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以访问容器内声明的`type alias`，它指定了它包含哪种类型的值，并使用它来实例化新值：
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This code, unfortunately, does not compile.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，此代码无法编译。
- en: The reason for this is that `value_type` is a **dependent type**. A dependent
    type is a type that is derived from one of the template parameters.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于`value_type`是一个**依赖类型**。依赖类型是从模板参数之一派生出的类型。
- en: When the compiler compiles this code, it notices that we are accessing the `value_type`
    identifier in the `Container` class.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器编译此代码时，它会注意到我们在`Container`类中访问了`value_type`标识符。
- en: That could either be a static field or a `type alias`. The compiler cannot know
    when it parses the template, since it does not know what the `Container` type
    will be and whether it has a `type alias` or a static variable. Therefore, it
    assumes we are accessing a static value. If this is the case, the syntax we are
    using is not valid, since we still have `new_element{}` after access to the field.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以是静态字段或`type alias`。编译器在解析模板时无法知道，因为它不知道`Container`类型是什么，以及它是否有`type alias`或静态变量。因此，它假设我们正在访问一个静态值。如果这是情况，我们使用的语法是不正确的，因为我们仍然在访问字段后有`new_element{}`。
- en: 'To solve this issue, we can tell the compiler that we are accessing a type
    in the class, and we do so by prepending the `typename` keyword to the type we
    are accessing:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以告诉编译器我们正在访问类中的类型，我们通过在要访问的类型前加上 `typename` 关键字来实现：
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Activity 13: Reading Objects from a Connection'
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 13：从连接中读取对象
- en: The user is creating an online game which require to send and receive its current
    state over an internet connection. The application has several types of connections
    (TCP, UDP, socket) each of them has a `readNext()` method which returns an `std::array`
    of 100 chars containing the data inside the connection, and a `writeNext()` method
    which takes an `std::array` of 100 characters which puts data into the connection.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 用户正在创建一个需要通过互联网连接发送和接收其当前状态的在线游戏。应用程序有几种类型的连接（TCP、UDP、套接字），每种连接都有一个 `readNext()`
    方法，该方法返回一个包含连接内部数据的 100 个字符的 `std::array`，以及一个 `writeNext()` 方法，该方法接受一个 100 个字符的
    `std::array`，并将数据放入连接中。
- en: 'Let''s follow these steps to create our online application:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤创建我们的在线应用程序：
- en: The objects that the application wants to send and receive over the connection
    have a `serialize()` static method which takes an instance of the object and return
    an `std::array` of 100 characters representing the object.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序想要通过连接发送和接收的对象有一个 `serialize()` 静态方法，它接受对象的实例并返回一个表示该对象的 100 个字符的 `std::array`。
- en: '[PRE41]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `deserialize()` static method takes an `std::array` of 100 characters representing
    the object, and creates an object from it.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`deserialize()` 静态方法接受一个表示对象的 100 个字符的 `std::array`，并从中创建一个对象。'
- en: 'The connection objects are already provided. Create the header `connection.h`
    with the following declarations:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接对象已经提供。创建具有以下声明的头文件 `connection.h`：
- en: '[PRE42]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Write a function template called `readObjectFromConnection` that takes a connection
    as the only parameter and the type of the object to read from the connection as
    a template type parameter. The function returns an instance of the object constructed
    after deserializing the data in the connection.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为 `readObjectFromConnection` 的函数模板，该模板接受一个连接作为唯一参数，以及从连接中读取的对象的类型作为模板类型参数。该函数返回在反序列化连接中的数据后构造的对象实例。
- en: 'Then, call the function with an instance of the `TcpConnection` class, extracting
    an object of type `UserAccount`:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用 `TcpConnection` 类的实例调用该函数，提取 `UserAccount` 类型的对象：
- en: '[PRE43]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The aim is to be able to send the information on the account of a user to the
    other users connected to the same online game, so that they can see the user information
    like their username and the level of their character.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是能够将用户的账户信息发送给同一在线游戏的其他连接用户，以便他们可以看到用户信息，如他们的用户名和角色的等级。
- en: Note
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 295.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第 295 页找到。
- en: 'Activity 14: Creating a User Account to Support Multiple Currencies'
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 14：创建支持多种货币的用户账户
- en: 'Write a program that supports and stores multiple currencies. Follow these
    steps:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个支持并存储多种货币的程序。按照以下步骤：
- en: We want to create an `Account` class that stores the account balance in different
    currencies.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要创建一个 `Account` 类，它可以存储不同货币的账户余额。
- en: 'A `Currency` is a class that represents a certain value in a specific currency.
    It has a public field called `value` and a template function called `to()` that
    takes the argument as a `Currency` type and returns an instance of that currency
    with the value set to the appropriate conversion of the current value of the class:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Currency` 是一个表示特定货币中一定价值的类。它有一个名为 `value` 的公共字段和一个名为 `to()` 的模板函数，该函数接受一个
    `Currency` 类型的参数，并返回一个具有适当转换当前类值的该货币类型的实例：'
- en: '[PRE44]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Our aim is to write an `Account` class that stores the current balance in any
    currency provided by the `template` parameter.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的目标是编写一个 `Account` 类，它可以存储由 `template` 参数提供的任何货币的当前余额。
- en: 'The user account must provide a method called `addToBalance` that accepts any
    kind of currency, and after converting it to the correct currency that''s used
    for the account, it should sum the value to the balance:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户账户必须提供一个名为 `addToBalance` 的方法，该方法接受任何类型的货币，并在将其转换为账户使用的正确货币后，将值加到余额上：
- en: '[PRE45]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The user now understands how to write class templates, how to instantiate them,
    and how to call their templates.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户现在理解了如何编写类模板，如何实例化它们，以及如何调用它们的模板。
- en: Note
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 296.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第 296 页找到。
- en: Non-Type Template Parameters
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非类型模板参数
- en: We learned how templates allow you to provide the types as parameters and how
    we can make use of this to write generic code.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用模板来提供类型作为参数，以及我们如何利用这一点来编写通用代码。
- en: Templates in C++ have an additional feature—**non-type template parameters**.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的模板有一个额外的特性——**非类型模板参数**。
- en: A non-type template parameter is a template parameter that is not a type—it
    is a value.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 非类型模板参数是一种模板参数，它不是类型——它是一个值。
- en: We made use of such non-type template parameters many times when using `std::array<int,
    10>;`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`std::array<int, 10>`时，我们多次使用了这种非类型模板参数。
- en: Here, the second parameter is a non-type template parameter, which represents
    the size of the array.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第二个参数是一个非类型模板参数，它表示数组的大小。
- en: The declaration of a non-type template parameter is in the parameter list of
    the template, but instead of starting with a `typename` keyword such as the type
    parameters, it starts with the type of the value, followed by the identifier.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 非类型模板参数的声明在模板的参数列表中，但与类型参数的`typename`关键字不同，它以值的类型开始，后面跟着标识符。
- en: 'There are strict restrictions on the types that are supported as non-type template
    parameters: they must be of integral type.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 对于作为非类型模板参数支持的类型有严格的限制：它们必须是整型。
- en: 'Let''s examine the following example of the declaration of a non-type template
    parameter:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查以下非类型模板参数声明的示例：
- en: '[PRE46]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'For example: here, we declared a class template that takes a type parameter
    and a non-type parameter.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：在这里，我们声明了一个类模板，它接受一个类型参数和一个非类型参数。
- en: We already saw that functions can take parameters directly and classes can accept
    parameters in the constructor. Additionally, the type of regular parameters is
    not restricted to be an integral type.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到函数可以直接接受参数，类可以在构造函数中接受参数。此外，常规参数的类型并不限于必须是整型。
- en: What is the difference between template and non-template parameters? Why would
    we use a non-type template parameter instead of a regular parameter?
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 模板参数和非模板参数之间有什么区别？为什么我们会使用非类型模板参数而不是常规参数？
- en: The main difference is when the parameter is known to the program. Like all
    the template parameters and unlike the non-template parameters, the value must
    be known at compile time.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于参数是否为程序所知。像所有模板参数一样，与非模板参数不同，值必须在编译时已知。
- en: This is useful when we want to use the parameters in expressions that need to
    be evaluated at compile time, as we do when declaring the size of an array.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想在需要编译时评估的表达式中使用参数时，这很有用，就像我们在声明数组大小时所做的那样。
- en: The other advantage is that the compiler has access to the value when compiling
    the code, so it can perform some computations during compilation, reducing the
    amount of instruction to execute at runtime, thus making the program faster.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优点是编译器在编译代码时可以访问该值，因此它可以在编译期间执行一些计算，从而减少在运行时执行的指令数量，使程序更快。
- en: Additionally, knowing some values at compile time allows our program to perform
    additional checks so that we can identify problems when we compile the program
    instead of when the program is executed.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在编译时知道一些值可以让我们的程序执行额外的检查，这样我们就可以在编译程序时而不是在程序执行时识别问题。
- en: 'Activity 15: Writing a Matrix Class for Mathematical Operations in a Game'
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动15：为游戏中的数学运算编写矩阵类
- en: 'In a game, it is common to represent the orientation of a character in a special
    kind of matrix: a *quaternion*. We would like to write a `Matrix` class that will
    be the base of the mathematical operations inside our game.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，通常用一种特殊的矩阵来表示角色的方向：一个*四元数*。我们希望编写一个`Matrix`类，它将成为我们游戏内部数学运算的基础。
- en: Our `Matrix` class should be a template that accepts a type, a number of rows,
    and a number of columns.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Matrix`类应该是一个模板，它接受一个类型、行数和列数。
- en: We should store the elements of the matrix inside an `std::array`, stored inside
    the class.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该将矩阵的元素存储在类内部的`std::array`中。
- en: The class should have a method called `get()` that takes a row and a column,
    and returns a reference to the element in that position.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 该类应该有一个名为`get()`的方法，它接受行和列作为参数，并返回该位置的元素引用。
- en: If the row or column is outside of the matrix, we should call `std::abort()`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果行或列超出了矩阵的范围，我们应该调用`std::abort()`。
- en: 'Let''s follow these steps:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们遵循以下步骤：
- en: The `Matrix` class takes three template parameters—one type and the two dimensions
    of the `Matrix` class. The dimensions are of type `int`.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Matrix`类接受三个模板参数——一个类型和`Matrix`类的两个维度。维度是`int`类型。'
- en: '[PRE47]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now, create a `std::array` with a size of the number of rows times the number
    of columns so that we have enough space for all the elements of the matrix.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个大小为行数乘以列数的`std::array`，以便我们有足够的空间存储矩阵的所有元素。
- en: 'Add a constructor to initialize the array:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个构造函数以初始化数组：
- en: We add a `get()` method to the class to return a reference to the element `T`.
    The method needs to take the row and column we want to access.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们向类中添加一个`get()`方法，该方法返回对元素`T`的引用。该方法需要接受我们想要访问的行和列。
- en: 'If the index are outside of the bounds of the matrix, we call `std::abort()`.
    In the array, we store all the elements of the first row, then all the elements
    of the second row, and so on. So, when we want to access the elements of the nth
    row, we need to skip all the elements of the previous rows, which are going to
    be the number of elements per row (so the number of columns) times the previous
    rows:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果索引超出矩阵的范围，我们调用`std::abort()`。在数组中，我们存储第一行的所有元素，然后是第二行的所有元素，依此类推。因此，当我们想要访问第n行的元素时，我们需要跳过之前行的所有元素，这些元素的数量将是每行的元素数量（即列数）乘以之前的行数：
- en: '[PRE48]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output is as follows:'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE49]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 298.
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在第298页找到。
- en: '**Bonus step:**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**附加步骤：**'
- en: In games, multiplying a matrix by a vector is a common operation.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，矩阵乘以向量是一个常见的操作。
- en: Add a method to the class that takes a `std::array` containing elements of the
    same type of the matrix, and returns a `std::array` containing the result of the
    multiplication. See the definition of a matrix-vector product at [https://mathinsight.org/matrix_vector_multiplication](https://mathinsight.org/matrix_vector_multiplication).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 向类中添加一个方法，该方法接受一个包含矩阵相同类型元素的`std::array`，并返回一个包含乘法结果的`std::array`。请参阅矩阵-向量乘法的定义[https://mathinsight.org/matrix_vector_multiplication](https://mathinsight.org/matrix_vector_multiplication)。
- en: '**Bonus step**:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**附加步骤：**'
- en: We add a new method, `multiply`, which takes a `std::array` of type `T` with
    the length of `C` by const reference, since we are not modifying it.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个新方法`multiply`，它以常量引用的方式接受一个类型为`T`、长度为`C`的`std::array`，因为我们没有修改它。
- en: The function returns an array of the same type, but a length of `R`?
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 函数返回一个与相同类型的数组，但长度为`R`？
- en: 'We follow the definition of the matrix-vector multiplication to compute the
    result:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循矩阵-向量乘法的定义来计算结果：
- en: '[PRE50]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Making Templates Easier to Use
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使模板更容易使用
- en: We always said that we need to provide the template arguments to the parameters
    of a template function or class. Now, in this section, we are going to see two
    features that C++ offers to make it easier to use templates.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是说我们需要为模板函数或类的参数提供模板参数。现在，在本节中，我们将看到C++提供的两个特性，使模板的使用更加容易。
- en: These features are default template arguments and template argument deduction.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性是默认模板参数和模板参数推导。
- en: Default Template Arguments
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认模板参数
- en: Like function arguments, template arguments can also have default values, both
    for type and non-type template parameters.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 与函数参数一样，模板参数也可以具有默认值，包括类型和非类型模板参数。
- en: 'The syntax for default template arguments is to add after the template identifier
    the equal, followed by the value:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 默认模板参数的语法是在模板标识符后添加等号，后跟值：
- en: '[PRE51]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: When a template provides a default value for a parameter, the user does not
    have to specify the parameter when instantiating the template. The default parameter
    must come after the parameters that do not have a default value.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当模板为参数提供一个默认值时，用户在实例化模板时不必指定该参数。默认参数必须在不具有默认值的参数之后。
- en: Additionally, you can reference the previous template parameters when defining
    the default type for a subsequent template parameter.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在定义后续模板参数的默认类型时，可以引用之前的模板参数。
- en: 'Let''s see some examples of both errors and valid declarations:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些错误和有效声明的示例：
- en: '[PRE52]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`T`, which has a default type, comes before the template parameter `A`, which
    does not have a default parameter:'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T`，具有默认类型，位于模板参数`A`之前，`A`没有默认参数：'
- en: '[PRE53]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`T` references the template parameter `A`, which comes after `T`:'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T`引用模板参数`A`，它位于`T`之后：'
- en: '[PRE54]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`A` has a default value, and no other template parameter without default value
    comes after it. It also references `T`, which is declared before the template
    parameter `A`.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A`有一个默认值，并且没有其他没有默认值的模板参数跟在它后面。它还引用了`T`，这是在模板参数`A`之前声明的。'
- en: The reason to use the default arguments is to provide a sensible option for
    the template, but still allowing the user to provide their own type or value when
    needed.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认参数的原因是为模板提供一个合理的选项，但仍然允许用户在需要时提供他们自己的类型或值。
- en: 'Let''s see an example of type arguments:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看类型参数的一个例子：
- en: '[PRE55]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The hypothetical type `SortedArray` is an array that keeps its elements always
    sorted. It accepts the type of the elements it should hold and a comparator. To
    make it easy to use for the user, it sets the comparator to use the `less` operator
    by default.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 假设的类型`SortedArray`是一个始终保持其元素排序的数组。它接受它应该持有的元素类型和一个比较器。为了方便用户使用，它默认使用`less`运算符作为比较器。
- en: 'The following code shows how a user can implement it:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了用户如何实现它：
- en: '[PRE56]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can also see an example of a default non-type template parameter:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到一个默认的非类型模板参数的例子：
- en: '[PRE57]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The hypothetical type `MemoryBuffer` is an object that reserves an amount of
    memory on the stack; the program will then allocate objects into that memory.
    By default, it uses 512 bytes of memory, but the user can specify a different
    size:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 假设的类型`MemoryBuffer`是一个在栈上预留内存的对象；程序然后将对象分配到该内存中。默认情况下，它使用512字节的内存，但用户可以指定不同的大小：
- en: '[PRE58]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note the empty angle brackets in the `buffer1` declaration. They are needed
    to signal to the compiler that we are making use of a template. This requirement
    has been removed in C++17, and we can write `MemoryBuffer buffer1;`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`buffer1`声明中的空尖括号。它们是必要的，以向编译器发出信号，表明我们正在使用模板。这个要求在C++17中被移除，我们可以写`MemoryBuffer
    buffer1;`。
- en: Template Argument Deduction
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板参数推导
- en: All the template parameters need to be known to instantiate a template, but
    not all of them need to be explicitly provided by the caller.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 所有模板参数都需要为实例化模板而知道，但并非所有参数都需要由调用者显式提供。
- en: '**Template argument deduction** refers to the ability of the compiler to automatically
    understand some of the types that are used to instantiate the template, without
    the user having to explicitly type them.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板参数推导**指的是编译器自动理解用于实例化模板的一些类型的能力，而无需用户显式地输入它们。'
- en: We are going to see them for functions as that is supported by most of the versions
    of C++. C++17 introduced **deduction guides**, which allow the compiler to perform
    template argument deduction for class templates from the constructor, but we are
    not going to see them.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到对于函数，因为这是大多数C++版本所支持的。C++17引入了**推导指南**，允许编译器从构造函数中为类模板执行模板参数推导，但我们不会看到它们。
- en: The detailed rules for template argument deduction are very complex, and so
    we are going to see them by example so that we can understand them.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 模板参数推导的详细规则非常复杂，因此我们将通过例子来了解它们，以便我们能理解它们。
- en: In general, the compiler tries to find the type for which the provided argument
    and the parameter match the closest.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，编译器试图找到与提供的参数最接近的类型。
- en: 'The code we are going to analyze is as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要分析的代码如下：
- en: '[PRE59]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The calling code is as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 调用代码如下：
- en: '[PRE60]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Parameter and Argument Types
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数和参数类型
- en: 'We are going to see how, based on different pairs of parameters and arguments,
    the type is deduced:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何根据不同的参数和参数对，推导出类型：
- en: '![Figure 4.1: Different parameter and argument types](img/C11557_04_01.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1：不同的参数和参数类型](img/C11557_04_01.jpg)'
- en: 'Figure 4.1: Different parameter and argument types'
  id: totrans-312
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.1：不同的参数和参数类型
- en: The error happens because we cannot bind a temporary value, like 1, to a non-`const`
    reference.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 错误发生是因为我们不能将临时值，如1，绑定到一个非`const`引用。
- en: As we can see, the compiler tries to deduce a type so that when it is substituted
    in the parameter, it matches the argument as best as possible.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，编译器试图推导出一个类型，当它被代入参数时，尽可能与参数匹配。
- en: The compiler cannot always find such a type; in those situations, it gives an
    error and it's up to the user to provide the type.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器并不总是能找到这样的类型；在这些情况下，它会报错，用户需要提供类型。
- en: 'The compiler cannot deduce a type for any of the following reasons:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器不能推导出以下任何原因的类型：
- en: 'The type is not used in the parameters. For example: the compiler cannot deduce
    a type if it is only used in the return type, or only used inside the body of
    the function.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 类型在参数中未使用。例如：如果类型仅在返回类型中使用，或者仅在函数体内部使用，则编译器无法推导出该类型。
- en: 'The type in the parameter is a derived type. For example: `template<typename
    T> void foo(T::value_type a)`. The compiler cannot find the type `T` given the
    parameter that''s used to call the function.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 参数中的类型是一个派生类型。例如：`template<typename T> void foo(T::value_type a)`。编译器无法根据用于调用函数的参数找到类型`T`。
- en: 'Knowing these rules, we can derive a best practice for the order of the template
    parameters when writing templates: the types that we expect the user to provide
    need to come before the types that are deduced.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这些规则后，我们可以总结出编写模板时模板参数顺序的最佳实践：我们期望用户提供的类型需要放在可以推导出的类型之前。
- en: The reason for this is that a user can only provide the template arguments in
    the same order they have been declared.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是用户只能以它们声明的相同顺序提供模板参数。
- en: 'Let''s consider the following template:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下模板：
- en: '[PRE61]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'When calling `foo(1, 2.23)`, the compiler can deduce `A` and `B`, but cannot
    deduce `C`. Since we need all the types, and the user has to provide them in order,
    the user has to provide all of the types: `foo<int, double, and float>(1, 2.23);`.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`foo(1, 2.23)`时，编译器可以推导出`A`和`B`，但不能推导出`C`。由于我们需要所有类型，并且用户必须按顺序提供它们，因此用户必须提供所有类型：`foo<int,
    double, and float>(1, 2.23);`。
- en: 'Let''s say we put the types that cannot be deduced before the types that can
    be deduced, as in the following example:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将无法推导出的类型放在可以推导出的类型之前，如下例所示：
- en: '[PRE62]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We could call the function with `foo<float>(1, 2.23)`. We would then provide
    the type to use for `C` and the compiler would automatically deduce `A` and `B`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用`foo<float>(1, 2.23)`调用该函数。然后，我们会提供用于`C`的类型，编译器会自动推导出`A`和`B`。
- en: In a similar way, we need to reason about default template arguments.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们需要对默认模板参数进行推理。
- en: Since they need to come last, we need to make sure to put the types that the
    user is more likely to want to modify first, since that will force them to provide
    all the template arguments up to that parameter.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们需要放在最后，我们需要确保将用户更有可能想要修改的类型放在前面，因为这将迫使用户提供所有模板参数直到该参数。
- en: 'Activity 16: Making the Matrix Class Easier to Use'
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动十六：使矩阵类更容易使用
- en: 'The `Matrix` class we created in *Activity 15: Writing a Matrix Class for Mathematical
    Operations in a Game,* requires that we provide three template parameters.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在*活动十五：为游戏中的数学运算编写矩阵类*中创建的`Matrix`类要求我们提供三个模板参数。
- en: 'Now, in this activity, we want to make the class easier to use by requiring
    that the user is required to only pass two parameters: the number of rows and
    the number of columns in the `Matrix` class. The class should also take a third
    argument: the type contained in the `Matrix` class. If not provided, it should
    default to `int`.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在这个活动中，我们希望通过要求用户只传递两个参数来使类更容易使用：`Matrix`类中的行数和列数。该类还应接受第三个参数：`Matrix`类中包含的类型。如果没有提供，则默认为`int`。
- en: 'In the previous activity, we added to the matrix a `multiply` operation. We
    now want to let the user customize the function by specifying how the multiplication
    between the types should be executed. By default, we want to use the `*` operator.
    For that, a `class` template named `std::multiplies` from the `<functional>` header
    exists. It works like the `Less` class we saw previously in this chapter:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个活动中，我们在矩阵中添加了一个`multiply`操作。现在我们希望用户能够通过指定类型之间如何执行乘法来自定义函数。默认情况下，我们希望使用`*`运算符。为此，`<functional>`头文件中存在一个名为`std::multiplies`的`class`模板。它的工作方式与我们之前在本章中看到的`Less`类类似：
- en: We start by importing `<functional>` so that we have access to `std::multiplies`.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先导入`<functional>`，以便我们可以访问`std::multiplies`。
- en: We then change the order of the template parameters in the class template so
    that the size parameters come first. We also add a new template parameter, `Multiply`,
    which is the type we use for computing the multiplication between the elements
    in the vector by default, and we store an instance of it in the class.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将类模板中模板参数的顺序改变，使得大小参数首先出现。我们还添加了一个新的模板参数`Multiply`，这是我们用于计算向量中元素乘法的默认类型，并将其实例存储在类中。
- en: We now need to make sure that the `multiply` method uses the `Multiply` type
    provided by the user to perform the multiplication.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要确保`multiply`方法使用用户提供的`Multiply`类型来执行乘法。
- en: 'To do so, we need to make sure we call `multiplier(operand1, operand2)` instead
    of `operand1 * operand2` so that we use the instance we stored inside the class:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要确保我们调用`multiplier(operand1, operand2)`而不是`operand1 * operand2`，这样我们就可以使用我们存储在类内部的实例：
- en: '[PRE63]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Add an example of how we can use the class:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个我们可以如何使用该类的示例：
- en: '[PRE64]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The output is as follows:'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE65]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 300.
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第300页找到。
- en: Being Generic in Templates
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在模板中实现泛型
- en: So far, we have learned how the compiler can make our templated functions easier
    to use by automatically deducing the types used. The template code decides whether
    to accept a parameter as a value or a reference, and the compiler finds the type
    for us. But what do we do if we want to be agnostic regarding whether an argument
    is a value or a reference, and we want to work with it regardless?
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了编译器如何通过自动推断使用的类型来使我们的模板函数更容易使用。模板代码决定是否将参数作为值或引用接受，编译器为我们找到类型。但如果我们想对参数是值还是引用保持无知，并且想无论怎样都与之工作，我们该怎么办？
- en: 'An example would be `std::invoke` in C++17\. `std::invoke` is a function that
    takes a function as the first argument, followed by a list of arguments, and calls
    the function with the arguments. For example:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是C++17中的`std::invoke`。`std::invoke`是一个函数，它接受一个函数作为第一个参数，后面跟着一系列参数，并使用这些参数调用函数。例如：
- en: '[PRE66]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Similar examples would apply if you wanted to log before calling a function,
    or you wanted to execute the function in a different thread, such as `std::async`
    does.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在调用函数之前进行日志记录，或者你想在不同的线程中执行函数，例如`std::async`所做的那样，类似的例子也会适用。
- en: 'Let''s demystify the difference by using the following code:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下代码来消除差异：
- en: '[PRE67]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Note
  id: totrans-351
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '`use_printoncopyormove_obj` always accepts the parameter by value.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`use_printoncopyormove_obj`总是通过值接受参数。'
- en: 'Let''s say we execute the following code:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们执行以下代码：
- en: '[PRE68]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The code would print the following:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将打印以下内容：
- en: '[PRE69]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: How can we write a function such as `std::invoke` that works regardless of the
    kind of reference (colloquially referred to as "ref-ness", similarly to how "const-ness"
    is used to talk about whether a type is const qualified) of the parameters?
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何编写一个像`std::invoke`这样的函数，它无论参数的引用类型（口语中称为“ref-ness”，类似于如何使用“const-ness”来讨论类型是否具有const资格）如何都能正常工作？
- en: The answer to that is **forwarding references**.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是**转发引用**。
- en: 'Forwarding references look like r-value references, but they only apply where
    the type is deduced by the compiler:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 转发引用看起来像右值引用，但它们只适用于编译器推断类型的场景：
- en: '[PRE70]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Note
  id: totrans-361
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: If you see a type identifier declared in the template, the type is deduced,
    and the type has &&, then it is a forwarding reference.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个模板中看到一个类型标识符被声明，那么类型是被推断出来的，并且类型有&&，那么它是一个转发引用。
- en: 'Let''s see how the deduction works for forwarding references:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看转发引用的推断是如何工作的：
- en: '![Figure 4.2: Forward reference function. ](img/C11557_04_02.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2：转发引用函数](img/C11557_04_02.jpg)'
- en: 'Figure 4.2: Forward reference function.'
  id: totrans-365
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.2：转发引用函数。
- en: Note
  id: totrans-366
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'Let''s say the type is not deduced, but, it is provided explicitly, for example:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 假设类型没有被推断出来，而是被明确提供，例如：
- en: '`int x = 0;`'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`int x = 0;`'
- en: '`do_action<int>(x);`'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`do_action<int>(x);`'
- en: Here, `T` will be `int`, since it was explicitly stated.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`T`将是`int`，因为它被明确地说明了。
- en: The advantage, as we saw before, is that we work with any kind of reference,
    and when the calling code knows it can move the object, then we can make use of
    the additional performance provided by the move constructor, but when a reference
    is preferred, then the code can use it as well.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 优势，正如我们之前看到的，是我们可以与任何类型的引用一起工作，当调用代码知道它可以移动对象时，我们可以利用移动构造函数提供的额外性能，但当引用更受欢迎时，代码也可以使用它。
- en: Additionally, some types do not support copying, and we can make our template
    work with those types as well.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一些类型不支持复制，我们可以使我们的模板也能与这些类型一起工作。
- en: 'When we write the body of the template function, the parameter is used as an
    `l-value` reference, and we can write code ignoring whether `T` is an `l-value`
    reference or an `r-value` one:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写模板函数的主体时，参数被用作`l-value`引用，我们可以编写忽略`T`是`l-value`引用还是`r-value`引用的代码：
- en: '[PRE71]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In *Chapter 3*, *Classes*, we learned that `std::move` can make our code more
    efficient when we need to use an object that we are not going to access after
    the call happens.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 3 章*，*类* 中，我们学习了当需要使用在调用后不再访问的对象时，`std::move` 可以使我们的代码更高效。
- en: But we saw that we should never move objects we receive as an `l-value` reference
    parameter, since the code that called us might still use the object after we return.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们看到了，我们永远不应该移动作为左值引用参数接收的对象，因为调用我们的代码可能在我们返回后仍然使用该对象。
- en: 'When we are writing templates using a forwarding reference, we are in front
    of a dilemma: our type might be a value or a reference, so how do we decide whether
    we can use `std::move`?'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用前向引用编写模板时，我们面临一个困境：我们的类型可能是一个值或一个引用，那么我们如何决定是否可以使用 `std::move`？
- en: Does it mean we cannot make use of the benefit that `std::move` brings us?
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着我们不能利用 `std::move` 带来的好处？
- en: 'The answer, of course, is *no*:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，答案是 *不*：
- en: '[PRE72]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Should we use move or not in this case?
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们应该使用移动还是不使用移动？
- en: 'The answer is *yes*: we should move if `T` is a value, and, no, we should not
    move if `T` is a reference.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是 *是*：如果 `T` 是一个值，我们应该移动；如果不是，则不应该移动。
- en: 'C++ provides us with a tool to do exactly this: `std::forward`.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 为我们提供了一个工具来做这件事：`std::forward`。
- en: '`std::forward` is a function template that always takes an explicit template
    parameter and a function parameter: `std::forward<T>(obj)`.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::forward` 是一个函数模板，它始终接受一个显式模板参数和一个函数参数：`std::forward<T>(obj)`。'
- en: '`Forward` looks at the type of `T`, and if it''s an `l-value` reference, then
    it simply returns a reference to the `obj`, but if it''s not, then it is equivalent
    to calling `std::move` on the object.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`Forward` 会查看 `T` 的类型，如果是左值引用，则简单地返回 `obj` 的引用，如果不是，则相当于在对象上调用 `std::move`。'
- en: 'Let''s see it in action:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的：
- en: '[PRE73]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now, we call it by using the following code:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用以下代码来调用它：
- en: '[PRE74]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'When executed, the code will print the following output:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行时，代码将打印以下输出：
- en: '[PRE75]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We successfully managed to write code that is independent on whether the type
    is passed as reference or value, removing a possible requirement on the template
    type parameter.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功地编写了不依赖于类型是作为引用还是值传递的代码，消除了对模板类型参数的可能要求。
- en: Note
  id: totrans-393
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: A template can have many type parameters. Forwarding references can apply to
    any of the type parameters independently.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 模板可以有许多类型参数。前向引用可以独立应用于任何类型参数。
- en: This is important because the caller of the templated code might know whether
    it is better to pass values or pass references, and our code should work regardless
    of whether there is a requirement to ask for a specific ref-ness.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为模板代码的调用者可能知道传递值或传递引用更好，而我们的代码应该能够在需要请求特定引用类型的情况下正常工作。
- en: 'We also saw how we can still maintain the advantages of moving, which is required
    for some types that do not support copying. This can make our code run much faster,
    even for types that support copying, without complicating our code: when we have
    forwarding references we use `std::forward` where we would have used `std::move`.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了如何仍然保持移动的优势，这对于不支持复制的某些类型是必需的。这可以使我们的代码运行得更快，即使对于支持复制的类型也是如此，而不会使我们的代码复杂化：当我们有前向引用时，我们在本应使用
    `std::move` 的地方使用 `std::forward`。
- en: 'Activity 17: Ensuring Users are Logged in When Performing Actions on the Account'
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 17：确保在执行账户操作时用户已登录
- en: We want to allow the users of our e-commerce website to perform arbitrary actions
    (for the scope of this activity, they will be adding and removing items) on their
    shopping carts.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望允许我们的电子商务网站的用户执行任意操作（在这个活动的范围内，他们将添加和删除项目）在他们的购物车中。
- en: 'Before performing any action, we want to make sure that the user is logged
    in. Now, let''s follow these instructions:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行任何操作之前，我们想确保用户已登录。现在，让我们遵循以下指示：
- en: 'Ensure that there is a `UserIdentifier` type for identifying the user, a `Cart`
    type that represents the shopping cart of the user, and a `CartItem` type that
    represents any item in the cart:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保存在一个用于识别用户的 `UserIdentifier` 类型，一个表示用户购物车的 `Cart` 类型，以及一个表示购物车中任何项目的 `CartItem`
    类型：
- en: '[PRE76]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Ensure that there is also a function with the signature `bool isLoggedIn(const
    UserIdentifier& user)` and a function to retrieve the cart for an user, `Cart
    getUserCart(const UserIdentifier& user)`:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '确保存在一个具有签名 `bool isLoggedIn(const UserIdentifier& user)` 的函数，以及一个用于获取用户购物车的函数
    `Cart getUserCart(const UserIdentifier& user)`:'
- en: '[PRE77]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In most of our code, we only have access to the `UserIdentifier` for a user,
    and we want to make sure that we always check whether the user is logged in before
    doing any action on the cart.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的大部分代码中，我们只能访问用户的`UserIdentifier`，我们想确保在进行任何购物车操作之前，我们总是检查用户是否已登录。
- en: 'To solve this problem, we decide to write a function template called `execute_on_user_cart`,
    which takes the user identifier, an action, and a single parameter. The function
    will check if the user is logged in and if so, retrieve their cart, then perform
    the action of passing the cart and the single parameter:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们决定编写一个名为`execute_on_user_cart`的函数模板，它接受用户标识符、一个操作和一个单一参数。该函数将检查用户是否已登录，如果是，则检索其购物车，然后执行传递购物车和单一参数的操作：
- en: '[PRE78]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'One of the actions we want to perform is `void remove_item(Cart, CartItem)`.
    A second action we want to perform is `void add_items(Cart, std::vector<CartItem>)`:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要执行的一项操作是`void remove_item(Cart, CartItem)`。我们想要执行的另一项操作是`void add_items(Cart,
    std::vector<CartItem>)`：
- en: '[PRE79]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Note
  id: totrans-409
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: A parameter of a function template can be used to accept functions as parameters.
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数模板的参数可以用来接受函数作为参数。
- en: The aim is to create a function that performs the necessary checks on whether
    the user is logged in so that throughout our program we can use it to perform
    safely any actions that are required by our business on the user cart, without
    the risk of forgetting to check the logged status of the user.
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目标是创建一个函数，它会在用户登录的情况下执行必要的检查，以便在整个程序中我们可以使用它来安全地执行对用户购物车所需的所有业务操作，而不会忘记检查用户的登录状态。
- en: 'We can also move the types that are not forwarding references:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以移动不是前向引用的类型：
- en: '[PRE80]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Examples of how the `execute_on_user_cart` function can be used with the actions
    we described earlier in the activity is as follows:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用我们在活动早期描述的操作来使用`execute_on_user_cart`函数的示例如下：
- en: '[PRE81]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The developers in our software can write the functions they need to execute
    on the cart, and call `execute_on_user_cart` to safely execute them.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们软件中的开发者可以编写他们需要在购物车中执行的功能，并调用`execute_on_user_cart`来安全地执行它们。
- en: Note
  id: totrans-417
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 302.
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解决这个活动的解决方案可以在第302页找到。
- en: Variadic Templates
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变模板
- en: We just saw how we can write a template that accepts parameters independently
    from their ref-ness.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了如何编写一个可以独立于它们的引用性接受参数的模板。
- en: 'But the two functions we talked about from the standard library, `std::invoke`
    and `std::async`, have an additional property: they can accept any number of arguments.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们之前提到的标准库中的两个函数`std::invoke`和`std::async`有一个额外的属性：它们可以接受任意数量的参数。
- en: In a similar way, `std::tuple`, a type similar to a `std::array` but that can
    contain values of different types, can contain an arbitrary number of types.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，`std::tuple`，一种类似于`std::array`的类型，但可以包含不同类型的值，可以包含任意数量的类型。
- en: How is it possible for a template to accept an arbitrary number of arguments
    of different types?
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 模板如何接受任意数量的不同类型的参数？
- en: In the past, a solution to this problem was to provide a great number of overloads
    for the same function, or multiple implementations of the class or struct, one
    for each number of the parameters.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，解决这个问题的方法是为同一个函数提供大量的重载，或者为类或结构体提供多个实现，每个参数数量一个。
- en: This is clearly code that is not easy to maintain, as it forces us to write
    the same code multiple times. Another drawback is that there is a limit to the
    number of template parameters, so if your code requires more parameters than what
    is provided, you do not have a way to use the function.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是难以维护的代码，因为它迫使我们多次编写相同的代码。另一个缺点是模板参数的数量有限，所以如果你的代码需要比提供的更多的参数，你将没有方法来使用该函数。
- en: 'C++11 introduced a nice solution for this problem: **parameter pack**.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: C++11为这个问题提供了一个很好的解决方案：**参数包**。
- en: A parameter pack is a template parameter that can accept zero or more template
    arguments.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 参数包是一个可以接受零个或多个模板参数的模板参数。
- en: A parameter pack is declared by appending `…` to the type of the template parameter.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在模板参数的类型后附加`…`来声明参数包。
- en: 'Parameter packs are a functionality that works with any template: both functions
    and classes:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 参数包是与任何模板一起工作的功能：函数和类：
- en: '[PRE82]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: A template that has a parameter pack is called a **variadic template**, since
    it is a template that accepts a varying number of parameters.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 具有参数包的模板称为**可变模板**，因为它是一个接受可变数量参数的模板。
- en: 'When instantiating a variadic template, any number of arguments can be provided
    to the parameter pack by separating them with a comma:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化变长模板时，可以通过用逗号分隔来向参数包提供任意数量的参数：
- en: '[PRE83]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '`Types` will contain the list of arguments that are provided when instantiating
    the template.'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '`Types` 将包含在实例化模板时提供的参数列表。'
- en: A parameter pack by itself is a list of types and the code cannot interact with
    it directly.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 参数包本身是一系列类型，代码不能直接与之交互。
- en: The variadic template can use the parameter pack by expanding it, which happens
    by appending `…` to a pattern.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 变长模板可以通过在模式后附加 `…` 来展开参数包，从而使用参数包。
- en: When a pattern is expanded, it is repeated as many times as there are types
    in its parameter pack, separating it with a comma. Of course, to be expanded,
    a pattern must contain at least a parameter pack. If multiple parameters are present
    in the pattern, or the same parameter is present several times, they are all expanded
    at the same time.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个模式展开时，它会根据其参数包中的类型数量重复，用逗号分隔。当然，为了展开，一个模式必须至少包含一个参数包。如果模式中存在多个参数，或者相同的参数出现多次，它们将同时展开。
- en: 'The simplest pattern is the name of the parameter pack: `Types…`.'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的模式是参数包的名称：`Types…`。
- en: 'For example: to let a function accept multiple arguments, it would expand the
    parameter pack in the function arguments:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：为了让函数接受多个参数，它会在函数参数中展开参数包：
- en: '[PRE84]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: When we call the function, the compiler automatically deduces the types of the
    parameter pack. In the last call, `MyTypes` will contain `int`, `double`, and
    `float`, and the signature of the generated function would be `void do_action(int
    __p0, int __p1, double __p2, float __p3)`.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用函数时，编译器会自动推导参数包的类型。在最后一次调用中，`MyTypes` 将包含 `int`、`double` 和 `float`，生成的函数签名将是
    `void do_action(int __p0, int __p1, double __p2, float __p3)`。
- en: Note
  id: totrans-442
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: A parameter pack in the list of template parameters can only be followed by
    template parameters that have a default value, or those that are deduced by the
    compiler.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 模板参数列表中的参数包只能后面跟着具有默认值的模板参数，或者由编译器推导的模板参数。
- en: Most commonly, the parameter pack is the last in the list of template parameters.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的是，参数包是模板参数列表中的最后一个。
- en: The function parameter `my_types` is called a **function parameter pack** and
    needs to be expanded as well so that it can access the single parameters.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数 `my_types` 被称为**函数参数包**，也需要展开以便能够访问单个参数。
- en: 'For example: let''s write a variadic struct:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：让我们写一个变长结构体：
- en: '[PRE85]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Let''s write a function that creates the struct:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个创建结构体的函数：
- en: '[PRE86]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Here, we have a variadic function that takes a parameter pack and expands it
    when calling the constructor of another variadic struct.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个接受参数包并在其调用另一个变长结构体的构造函数时展开的变长函数。
- en: The function `parameter packs`, which is the function variadic parameter, can
    be expanded only in some locations—the most common is as parameters when calling
    a function.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '`parameter packs` 函数，这是一个变长参数函数，只能在某些位置展开——最常见的是在调用函数时作为参数。'
- en: 'The template `parameter packs`, which is a type variadic parameter, can be
    expanded in template argument lists: the list of arguments between `<>` when instantiating
    a template.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 模板 `parameter packs`，这是一个类型变长参数，可以在模板参数列表中展开：实例化模板时 `<>` 之间的参数列表。
- en: As we mentioned previously, the pattern for the expansion might be more complex
    than just the name of the argument.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，展开的模式可能比仅仅参数名称更复杂。
- en: 'For example: we can access type aliases declared in the type or we can call
    a function on the parameter:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：我们可以访问在类型中声明的类型别名，或者我们可以对参数调用一个函数：
- en: '[PRE87]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We call it like so:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样调用：
- en: '[PRE88]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Alternatively, we can pass the parameter as an argument to a function:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以将参数作为函数的参数传递：
- en: '[PRE89]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: This will call the `modify` function for each argument and pass the result to
    `do_things`.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 这将调用每个参数的 `modify` 函数，并将结果传递给 `do_things`。
- en: In this section, we saw how the variadic parameter functionality of C++ lets
    us write functions and classes that work with any number and type of parameters.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了 C++ 的变长参数功能如何让我们编写可以与任何数量和类型的参数一起工作的函数和类。
- en: While it is not a common everyday task to write variadic templates, almost every
    programmer uses a variadic template in their day-to-day coding, since it makes
    it so much easier to write powerful abstractions, and the standard library makes
    vast use of it.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然编写变长模板不是日常任务，但几乎每个程序员在日常编码中都使用变长模板，因为它使得编写强大的抽象变得容易得多，标准库也广泛使用了它。
- en: Additionally, in the right situation, variadic templates can allow us to write
    expressive code that works in the multitude of situations we need.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在适当的情况下，变长模板可以让我们编写出在多种我们需要的情况下都能工作的表达性代码。
- en: 'Activity 18: Safely Performing Operations on the User Cart with an Arbitrary
    Number of Parameters'
  id: totrans-464
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动十八：使用任意数量的参数安全地在用户购物车上执行操作
- en: In the previous activity, we saw a function, `execute_on_user_cart`, which allows
    us to execute arbitrary functions that take an object of type `Cart` and a single
    parameter.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的活动中，我们看到了一个函数，`execute_on_user_cart`，它允许我们执行接受类型为`Cart`的对象和单个参数的任意函数。
- en: 'In this activity, we want to expand on the supported types of actions we can
    perform on the shopping cart of the user by allowing any function that takes an
    object of type `Cart` and an arbitrary number of arguments:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们希望通过允许任何接受类型为`Cart`的对象和任意数量参数的函数来扩展我们对用户购物车可以执行的操作类型：
- en: Expand the previous activity to accept any number of the parameter with any
    kind of ref-ness and pass it to the action provided.
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前面的活动扩展到接受任何类型的参数数量，并传递给提供的操作。
- en: 'Write variadic templates and learn how to expand them:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写变长模板并学习如何扩展它们：
- en: '[PRE90]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Note
  id: totrans-470
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 303.
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第303页找到。
- en: Writing Easy-to-Read Templates
  id: totrans-472
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写易于阅读的模板
- en: Up until now, we have seen many features that we can use to write powerful templates
    that allow us to create high-level abstractions over the specific problems we
    face.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了许多我们可以用来编写强大模板的功能，这些模板允许我们在面对特定问题时创建高级抽象。
- en: 'But, as usual, code is more often read than written, and we should optimize
    for readability: the code should express the intentions of the code more than
    what operation is achieved.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 但，就像往常一样，代码更多地是被阅读而不是被编写，我们应该优化可读性：代码应该表达代码的意图，而不仅仅是实现的操作。
- en: Template code can sometimes make that hard to do, but there are a few patterns
    that can help.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 模板代码有时会使得做到这一点变得困难，但有一些模式可以帮助。
- en: Type Alias
  id: totrans-476
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型别名
- en: Type `name = type`.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 `name = type`.
- en: After the declaration, everywhere *Name* is used is going to be equivalent to
    having used *Type*.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明之后，任何使用*Name*的地方都将等同于使用*Type*。
- en: 'This is very powerful for three reasons:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常强大，原因有三：
- en: It can give a shorter and more meaningful name to complex types
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以为复杂类型提供一个更短且更有意义的名称
- en: It can declare a nested type to simplify access to it
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以声明一个嵌套类型以简化对其的访问
- en: It allows you to avoid having to specify the `typename` keyword in front of
    a dependent type
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许你避免在依赖类型前指定`typename`关键字
- en: Let's see examples for these two points.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这两个点的示例。
- en: Imagine we have a type, `UserAccount`, which contains several fields on the
    user, such as user ID, user balance, user email, and more.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个类型，`UserAccount`，它包含用户的一些字段，例如用户ID、用户余额、用户电子邮件等。
- en: We want to organize the user accounts into a high scoreboard based on their
    account balances to visualize which users are most actively using our service.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望根据账户余额将用户账户组织到一个高分数榜中，以可视化哪些用户最积极地使用我们的服务。
- en: 'To do so. we can use a data structure that requires a few parameters: the type
    to store, a way for ordering the types, a way to compare the types, and possibly
    others.'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们可以使用需要一些参数的数据结构：要存储的类型、排序类型的方式、比较类型的方式，以及可能的其他方式。
- en: 'The type could be as follows:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 类型可能如下所示：
- en: '[PRE91]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'To be easy to use, the template correctly provided some default values for
    `Comparison` and `Equality`, which use the `<` and `==` operators, but our `UserAccount`
    type does not implement the `<` operator, as there is no clear ordering, and the
    `==` operator does not do what we want, as we are only interested in comparing
    balances. To solve this, we implemented two structures to provide the functionality
    we need:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于使用，模板正确地提供了一些默认值给`Comparison`和`Equality`，它们使用`<`和`==`运算符，但我们的`UserAccount`类型没有实现`<`运算符，因为没有明确的排序，而`==`运算符也没有达到我们的预期，因为我们只对比较余额感兴趣。为了解决这个问题，我们实现了两个结构来提供我们需要的功能：
- en: '[PRE92]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The creation of a high scoreboard is both verbose.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个高分数榜既冗长。
- en: 'Using a type alias, we could write the following:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型别名，我们可以编写以下内容：
- en: '[PRE93]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Following this, we could create instances of `HighScoreBoard` directly, with
    little typing and clearly specify the intent:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们可以直接创建`HighScoreBoard`的实例，输入很少，并且清楚地指定意图：
- en: '[PRE94]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We now also have a single place to update if we want to change the way in which
    we want to sort the accounts. For example: if we also wanted to consider how long
    the user has been registered in the service, we could change the comparator the
    comparator. Every user of the type alias will be updated, without the risk of
    forgetting to update one location.'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想更改排序账户的方式，我们也有一个单独的地方可以更新。例如：如果我们还想考虑用户在服务中注册的时间长短，我们可以更改比较器。每个类型别名的用户都会更新，而不用担心忘记更新某个位置。
- en: Additionally, we clearly have a location where we can put the documentation
    on the decision made for using the type we picked.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们清楚地有一个位置可以放置关于使用所选类型的决策的文档。
- en: Note
  id: totrans-498
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: When using type aliases, give a name that represents what the type is for, not
    how it works. `UserAccountSortedContainerByBalance` is a not a good name because
    it tells us how the type works instead of what its intention is.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用类型别名时，给出一个代表类型用途的名称，而不是它的工作方式。`UserAccountSortedContainerByBalance`不是一个好的名称，因为它告诉我们类型是如何工作的，而不是它的意图。
- en: 'The second case is extremely useful for allowing code to introspect the class,
    that is, looking into some of the details of the class:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况对于允许代码进行自我检查（即查看类的某些细节）非常有用：
- en: '[PRE95]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We have several containers, which mostly support the same operations. We would
    like to write a template function that takes any container and returns the first
    element, `front`:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几个容器，它们大多支持相同的操作。我们希望编写一个模板函数，它接受任何容器并返回第一个元素，即`front`：
- en: '[PRE96]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: How can we find out what type is returned?
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何找出返回的类型是什么？
- en: 'A common pattern is to add a type alias inside the class, like so:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的模式是在类内部添加类型别名，如下所示：
- en: '[PRE97]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Now the function can access the type of the contained element:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，函数可以访问包含元素的类型：
- en: '[PRE98]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Note
  id: totrans-509
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that `value_type` depends on the `Container` type, so it is a dependent
    type. When we use dependent types, we must use the `typename` keyword in `front`.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`value_type`依赖于`Container`类型，因此它是一个依赖类型。当我们使用依赖类型时，必须在`front`中使用`typename`关键字。
- en: This way, our code can work with any type that declares the nested type `value_type`.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的代码就可以与声明了嵌套类型`value_type`的任何类型一起工作。
- en: The third use case, that is, to avoid having to type the `typename` keyword
    repeatedly, is common when interacting with code that follows the previous pattern.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个用例，即避免重复输入`typename`关键字，在与遵循先前模式的代码交互时很常见。
- en: 'For example: we can have a class that accepts a type:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：我们可以有一个接受类型的类：
- en: '[PRE99]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: In the rest of the class, we can use `value_type` directly, without having to
    type `typename` anymore. This allows us to avoid a lot of repetitions.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的其余部分，我们可以直接使用`value_type`，而无需再输入`typename`。这使我们能够避免大量的重复。
- en: 'The three techniques can also be combined. For example: you can have the following:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种技术也可以组合使用。例如：你可以有如下所示的内容：
- en: '[PRE100]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Template Type Alias
  id: totrans-518
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板类型别名
- en: The ability to create type aliases, as described in the previous part of this
    chapter, is already very useful for improving the readability of our code.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前一部分所述，创建类型别名的功能已经非常有助于提高我们代码的可读性。
- en: C++ gives us the ability to define generic type aliases so that they can simply
    be reused by the users of our code.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: C++赋予我们定义泛型类型别名的功能，以便它们可以被我们的代码的用户简单地重用。
- en: A template alias is a template that generates aliases.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 模板别名是一个生成别名的模板。
- en: 'Like all the templates we saw in this chapter, they start with a template declaration
    and follow with the alias declaration, which can depend on the type that''s declared
    in the template:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章中我们看到的所有模板一样，它们以模板声明开始，然后是别名声明，该声明可以依赖于模板中声明的类型：
- en: '[PRE101]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'A `ValueType` is a template alias that can be instantiated with the usual template
    syntax: `ValueType<SortedContainer> myValue;`.'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValueType`是一个模板别名，可以使用常规模板语法实例化：`ValueType<SortedContainer> myValue;`。'
- en: This allows the code to just use the alias `ValueType` whenever they want to
    access the `value_type` type inside any container.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许代码在需要访问任何容器内的`value_type`类型时，只需使用别名`ValueType`。
- en: 'Template aliases can combine all the features of templates: they can accept
    multiple parameters, accept non-type parameters, and even use parameter packs.'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 模板别名可以结合模板的所有特性：它们可以接受多个参数，接受非类型参数，甚至使用参数包。
- en: Summary
  id: totrans-527
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, the students were introduced to templates in C++. We saw that
    templates exist to create high-level abstractions that work independently from
    the types of the objects at zero overhead at runtime. We explained the concept
    of type requirements: the requirements a type must satisfy to work correctly with
    the templates. We then showed the students how to write function templates and
    class templates, mentioning dependent types as well, to give the students the
    tools to understand a class of errors that happen when writing template code.'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，学生们被引入了C++中的模板。我们了解到模板的存在是为了创建在运行时零开销且独立于对象类型的高层抽象。我们解释了类型要求的概念：类型必须满足的要求才能与模板正确工作。然后我们向学生们展示了如何编写函数模板和类模板，并提到了依赖类型，以给学生提供理解在编写模板代码时可能发生的错误类别的工具。
- en: We then showed how templates can work with non-type parameters, and how templates
    can be made easier to use by providing default template arguments, thanks to template
    argument deduction.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了模板如何与非类型参数一起工作，以及如何通过提供默认模板参数来简化模板的使用，这得益于模板参数推导。
- en: We then showed the students how to write more generic templates, thanks to the
    forwarding reference, `std::forward`, and the template parameter pack.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向学生们展示了如何利用前向引用、`std::forward`和模板参数包来编写更通用的模板。
- en: Finally, we concluded with some tools to make templates easier to read and more
    maintainable.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们总结了使模板更容易阅读和维护的一些工具。
- en: In the next chapter, we will cover standard library containers and algorithms.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍标准库容器和算法。
