- en: '*Chapter 8*: Creating Curves, Frames, and Tracks'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：创建曲线、帧和轨道'
- en: In the early 2000s, it was common for games to take an animation that was authored
    in a 3D content creation tool such as Blender or Maya, play back the animation,
    and sample the transform of every joint in the animation at set intervals. Once
    the animation was sampled, the game's runtime linearly interpolated between the
    sampled frames.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在21世纪初，游戏通常会采用在3D内容创建工具（如Blender或Maya）中制作的动画，播放动画，并在设置的间隔内对动画中每个关节的变换进行采样。一旦对动画进行了采样，游戏的运行时会在采样帧之间进行线性插值。
- en: 'While this works (and is doable with glTF files), it''s not the most accurate
    way to play back animations. It wastes memory by including frames that don''t
    actually need to exist. In a 3D content creation tool, animations are created
    using curves, such as the one shown in the following screenshot:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法可行（并且可以在glTF文件中实现），但这并不是播放动画的最准确方式。它通过包含实际上不需要存在的帧来浪费内存。在3D内容创建工具中，动画是使用曲线创建的，例如以下截图中显示的曲线：
- en: '![Figure 8.1: The Blender 3D curve editor](img/Figure_8.1_B16191.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1：Blender 3D曲线编辑器](img/Figure_8.1_B16191.jpg)'
- en: 'Figure 8.1: The Blender 3D curve editor'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：Blender 3D曲线编辑器
- en: 'Modern games and animation systems evaluate these curves directly. Evaluating
    the animation curves directly saves memory, but curves are a bit more expensive
    in terms of processing power. By the end of this chapter, you should be able to
    do the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现代游戏和动画系统直接评估这些曲线。直接评估动画曲线可以节省内存，但在处理能力方面曲线会更昂贵一些。在本章结束时，您应该能够做到以下几点：
- en: Understand cubic Bézier splines and how to evaluate them
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解立方Bézier样条以及如何评估它们
- en: Understand cubic Hermite splines and how to evaluate them
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解立方Hermite样条以及如何评估它们
- en: Understand common interpolation methods
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解常见的插值方法
- en: Be able to create cubic, linear, and constant keyframes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够创建立方、线性和恒定关键帧
- en: Understand how keyframes make up a cubic, linear, or constant track
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解关键帧如何组成立方、线性或恒定轨道
- en: Be able to evaluate cubic, linear, and constant tracks
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够评估立方、线性和恒定轨道
- en: Be able to combine three independent tracks into one transform track
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够将三个独立轨道合并为一个变换轨道
- en: Understanding cubic Bézier splines
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解立方Bézier样条
- en: 'To implement game animation, you need some understanding of curves. Let''s
    start with the basics—a cubic Bézier spline. A Bézier spline has two points to
    interpolate between and two control points that help generate a curve. This is
    what a cubic Bézier spline looks like:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现游戏动画，您需要对曲线有一定的了解。让我们从基础知识开始——立方Bézier样条。Bézier样条有两个要插值的点和两个控制点，帮助生成曲线。这就是立方Bézier样条的样子：
- en: '![Figure 8.2: A cubic Bézier spline](img/Figure_8.2_B16191.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2：立方Bézier样条](img/Figure_8.2_B16191.jpg)'
- en: 'Figure 8.2: A cubic Bézier spline'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：立方Bézier样条
- en: 'Given the two points and the two controls, how is the curve generated? Let''s
    explore interpolating the curve for a given time, **t**. Start by drawing a line
    from **P1** to **C1**, from **C1** to **C2**, and from **C2** to **P2**. Then,
    linearly interpolate along those lines with the value of **t**:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个点和两个控制点，如何生成曲线？让我们探索为给定时间**t**插值曲线。首先从**P1**到**C1**画一条线，从**C1**到**C2**，从**C2**到**P2**。然后，沿着这些线线性插值值**t**：
- en: '![Figure 8.3: Linearly interpolating between points and control points](img/Figure_8.3_B16191.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3：在点和控制点之间进行线性插值](img/Figure_8.3_B16191.jpg)'
- en: 'Figure 8.3: Linearly interpolating between points and control points'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：在点和控制点之间进行线性插值
- en: 'The interpolated points from **P1** to **C1** is **A**, from **C2** to **P2**
    is **B**, and from **C1** to **C2** is **C**. Next, you need to repeat this process,
    drawing lines and interpolating from **A** to **C** and from **C** to **B**. Let''s
    call these newly interpolated points E and F:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从**P1**到**C1**的插值点是**A**，从**C2**到**P2**是**B**，从**C1**到**C2**是**C**。接下来，您需要重复这个过程，画线并从**A**到**C**和从**C**到**B**进行插值。让我们称这些新插值点为E和F：
- en: '![Figure 8.4: Linearly interpolating the results of figure 8.3](img/Figure_8.4_B16191.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4：线性插值图8.3的结果](img/Figure_8.4_B16191.jpg)'
- en: 'Figure 8.4: Linearly interpolating the results of figure 8.3'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：线性插值图8.3的结果
- en: 'Repeat this one more time, drawing a line from **E** to **F** and interpolating
    along that line by **t** as well. Let''s call the resulting point **R**. This
    point, **R**, is somewhere on the Bézier spline. If you were to calculate all
    points from *t=0* to *t=1*, you could plot the curve:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 重复一次，从**E**到**F**画一条线，并且也按照**t**在该线上进行插值。让我们称得到的点为**R**。这个点**R**在Bézier样条上的某个位置。如果您计算从*t=0*到*t=1*的所有点，您可以绘制出曲线：
- en: '![Figure 8.5: Linearly interpolating the results of figure 8.4](img/Figure_8.5_B16191.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5：线性插值图8.4的结果](img/Figure_8.5_B16191.jpg)'
- en: 'Figure 8.5: Linearly interpolating the results of figure 8.4'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：线性插值图8.4的结果
- en: 'Let''s explore the code required to draw a Bézier spline. Bézier splines will
    not be used anywhere else in this book, so implementing the following code is
    not required to follow along with the rest of this book:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索绘制Bézier样条所需的代码。本书中不会在其他地方使用Bézier样条，因此不需要实现以下代码来跟随本书的其余部分：
- en: 'First, you need to define what a Bézier spline is. Create a new templated class
    that contains two points and two control points:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要定义什么是Bézier样条。创建一个包含两个点和两个控制点的新模板类：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, implement the `Interpolate` function. This function takes a Bézier spline
    reference and a value, `t`, to interpolate the spline. It''s assumed that `t`
    is greater than or equal to `0` and less than or equal to `1`:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，实现`Interpolate`函数。该函数接受一个Bézier样条引用和一个值`t`，用于插值样条。假设`t`大于或等于`0`且小于或等于`1`：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following code sample demonstrates how the Bezier class and the `Interpolate`
    function can be used to plot a Bézier spline:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例演示了如何使用Bezier类和`Interpolate`函数来绘制Bézier样条：
- en: 'First, you need to create the data that will be plotted:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要创建将要绘制的数据：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, draw the points and handles:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，绘制点和控制点：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, plot the spline:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，绘制样条线：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding sample code, you can see that you can implement the Bézier
    `Interpolate` function by using six linear interpolations. To understand how Bézier
    splines work, you need to expand the `lerp` functions to what they actually are.
    Linear interpolation, `lerp(a, b, t)`, expands to `(1-t) * a + t * b`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例代码中，您可以看到可以通过使用六次线性插值来实现Bézier`Interpolate`函数。要理解Bézier样条的工作原理，您需要将`lerp`函数扩展到实际情况。线性插值，`lerp(a,
    b, t)`，扩展为`(1-t) * a + t * b`：
- en: 'Rewrite the `Interpolate` function so that all the `lerp` calls are expanded:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`Interpolate`函数，以便展开所有的`lerp`调用：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Nothing has changed, but you no longer need to call the `lerp` function. This
    works for any data type, `T`, as long as `T operator*(const T& t, float f)` is
    defined. Let''s try to simplify this in a mathematical sense. Instead of using
    the `A`, `B`, `C`, `D`, `E`, and `R` variables, expand these equations to the
    following:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有改变，但您不再需要调用`lerp`函数。只要定义了`T operator*(const T& t, float f)`，这对于任何数据类型`T`都适用。让我们试着在数学上简化这个。不要使用`A`、`B`、`C`、`D`、`E`和`R`变量，将这些方程展开为以下形式：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is the equivalent of inlining all the `lerp` functions by hand. The resulting
    code is a little hard to read:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这相当于手动内联所有的`lerp`函数。结果代码有点难以阅读：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Why go through all this trouble? To start simplifying the math, let''s start
    by combining like terms:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么要费这么大劲？为了开始简化数学，让我们从合并类似项开始：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that''s starting to look like an equation! This simplified equation can
    be expressed in code as well:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在这开始看起来像一个方程了！这个简化的方程也可以用代码表示：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Take this simplification a bit further by isolating some of the terms:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过隔离一些项来进一步简化这个简化：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In code, this is expressed as follows:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码中，这表示为：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Simplify the function one more time:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次简化函数：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The code for this final simplification looks as follows:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终简化的代码如下所示：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you plot these final equations out with *t* ranging from `0` to `1`, you
    get the following graph:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将这些最终方程用*t*从`0`到`1`绘制出来，您将得到以下图形：
- en: '![Figure 8.6: The basis functions of a Bézier spline](img/Figure_8.6_B16191.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6：Bézier样条的基础函数](img/Figure_8.6_B16191.jpg)'
- en: 'Figure 8.6: The basis functions of a Bézier spline'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：Bézier样条的基础函数
- en: These are the point basis functions of the cubic Bézier spline. They express
    how the value of the spline changes over time. For example, the influence of P1
    drops over time; at *t=0*, the influence is full—it has a value of 1\. However,
    by the time *t=1*, the influence of P1 is gone—it has a value of 0.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是三次Bézier样条的点基础函数。它们表达了样条值随时间的变化。例如，P1的影响随时间减小；在*t=0*时，影响是完整的—它的值为1。然而，到了*t=1*，P1的影响消失了—它的值为0。
- en: In this section, you went through the exercise of simplifying the Bézier spline
    evaluation function to arrive at the basis function of the spline. With Bézier
    splines, it's easy to follow this logic since you can start with an easy-to-understand
    implementation that just uses six lerp functions. With other curves, there is
    no easy place to start.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您经历了简化Bézier样条评估函数的练习，以得到样条的基础函数。对于Bézier样条，很容易遵循这种逻辑，因为您可以从一个易于理解的实现开始，该实现只使用六个lerp函数。对于其他曲线，没有一个容易的起点。
- en: In the next section, we will explore another type of cubic spline—the cubic
    Hermite spline. Using the knowledge you learned in this section, you will be able
    to implement the Hermite evaluation function using only the basis function graph.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨另一种三次样条——三次Hermite样条。使用本节学到的知识，您将能够仅使用基础函数图实现Hermite评估函数。
- en: Understanding cubic Hermite splines
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解三次Hermite样条
- en: The most common spline type used in animation for games is a **cubic Hermite
    spline**. Unlike Bézier, a Hermite spline doesn't use points in space for its
    control; rather, it uses the tangents of points along the spline. You still have
    four values, as with a Bézier spline, but they are interpreted differently.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏动画中最常用的样条类型是**三次Hermite样条**。与Bézier不同，Hermite样条不使用空间中的点作为控制点；相反，它使用样条上的点的切线。您仍然有四个值，就像Bézier样条一样，但它们的解释方式不同。
- en: 'With the Hermite spline, you don''t have two points and two control points;
    instead, you have two points and two slopes. The slopes are also referred to as
    tangents—throughout the rest of this chapter, the slope and tangent terms will
    be used interchangeably. The point basis functions for Hermite splines look as
    follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Hermite样条，您不是有两个点和两个控制点；相反，您有两个点和两个斜率。这些斜率也被称为切线—在本章的其余部分，斜率和切线术语将互换使用。Hermite样条的点基础函数如下所示：
- en: '![Figure 8.7: The point basis functions of Hermite splines](img/Figure_8.7_B16191.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7：Hermite样条的点基础函数](img/Figure_8.7_B16191.jpg)'
- en: 'Figure 8.7: The point basis functions of Hermite splines'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：Hermite样条的点基础函数
- en: 'When given the point basis functions, you can implement the spline evaluation
    function similar to how the Bézier interpolation function was implemented:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当给定点基础函数时，您可以实现类似于实现Bézier插值函数的样条评估函数：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It's possible to switch between Bézier and Hermite splines, but that's beyond
    the scope of what you need to know for animation. Some 3D content creation applications,
    such as Maya, let animators create animations using a Hermite spline, while others,
    such as Blender 3D, use Bézier curves.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在Bézier和Hermite样条之间切换，但这超出了您需要了解的动画范围。一些3D内容创建应用程序，如Maya，允许动画师使用Hermite样条创建动画，而其他应用程序，如Blender
    3D，使用Bézier曲线。
- en: It's useful to understand how these functions work, regardless of which one
    drives your animation system. There are, of course, more curve types, but Bézier
    and Hermite are the most common ones.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这些函数的工作原理是有用的，无论哪种函数驱动您的动画系统。当然，还有更多的曲线类型，但Bézier和Hermite是最常见的。
- en: The glTF file format supports the constant, linear, and cubic interpolation
    types. You just learned how to do cubic interpolation, but you still need to implement
    both constant and linear interpolation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: glTF文件格式支持常数、线性和三次插值类型。您刚刚学会了如何进行三次插值，但仍需要实现常数和线性插值。
- en: Interpolation types
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插值类型
- en: When defining an animation curve, generally, it follows one of three interpolation
    methods—constant, linear, or cubic. Cubic curves can be expressed using any cubic
    equation, such as Bézier curves (which is what Blender uses) or Hermite splines
    (which is what Maya uses). This book uses Hermite splines to represent cubic curves.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在定义动画曲线时，遵循三种插值方法之一——常数、线性或三次。三次曲线可以使用任何三次方程来表示，例如Bézier曲线（Blender使用的方法）或Hermite样条线（Maya使用的方法）。本书使用Hermite样条线来表示三次曲线。
- en: 'A **constant curve** keeps its value the same until the next keyframe. Sometimes,
    this type of curve is called a step curve. Visually, a constant curve looks as
    follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**常数曲线**保持其值不变，直到下一个关键帧。有时，这种类型的曲线被称为阶跃曲线。在视觉上，常数曲线如下所示：'
- en: '![Figure 8.8: A constant curve](img/Figure_8.8_B16191.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图8.8：常数曲线](img/Figure_8.8_B16191.jpg)'
- en: 'Figure 8.8: A constant curve'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：常数曲线
- en: 'A **linear curve** interpolates between two frames in a linear fashion (that
    is, in a straight line). As you saw with the sampled curve approximation example
    earlier, if the samples of a linear track are close enough, it can start to approximate
    other types of curves as well. A linear curve looks as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性曲线**以线性方式在两个帧之间进行插值（即直线）。正如您之前在采样曲线近似示例中看到的那样，如果线性轨迹的样本足够接近，它也可以开始近似其他类型的曲线。线性曲线如下所示：'
- en: '![Figure 8.9: A linear curve](img/Figure_8.9_B16191.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图8.9：线性曲线](img/Figure_8.9_B16191.jpg)'
- en: 'Figure 8.9: A linear curve'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：线性曲线
- en: 'A **cubic curve** lets you define a curve in terms of values and tangents.
    The benefit of cubic curves is that you can express complex curves with little
    data. The downside is that interpolation becomes a bit more expensive. A cubic
    curve looks as follows (the tangents are the lines coming out of the keyframes):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**三次曲线**允许您根据值和切线定义曲线。三次曲线的好处是您可以用很少的数据表示复杂的曲线。缺点是插值变得有点昂贵。三次曲线如下所示（切线是从关键帧出来的线）：'
- en: '![Figure 8.10: A cubic curve](img/Figure_8.10_B16191.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图8.10：三次曲线](img/Figure_8.10_B16191.jpg)'
- en: 'Figure 8.10: A cubic curve'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10：三次曲线
- en: 'Interpolation types can be expressed as a simple `enum` class. Create a new
    file—`Interpolation.h`. Add header guards and add the following `enum` class declaration:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 插值类型可以表示为简单的`enum`类。创建一个新文件—`Interpolation.h`。添加头文件保护并添加以下`enum`类声明：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These are the three interpolation types that glTF supports as well. In the next
    section, you will start to implement animation tracks by creating a `Frame` structure
    to hold keyframe data.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是glTF支持的三种插值类型。在下一节中，您将开始通过创建`Frame`结构来存储关键帧数据来实现动画轨迹。
- en: Creating the Frame struct
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Frame结构
- en: What is a frame of data? That depends on the interpolation type. If the interpolation
    is constant (step) or linear, a frame is just a time and value. When the interpolation
    is cubic, you need to store the tangents as well.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 数据帧是什么？这取决于插值类型。如果插值是常数（阶跃）或线性的，则帧只是时间和值。当插值为三次时，您还需要存储切线。
- en: A Hermite curve is made by connecting Hermite splines. Each control point consists
    of a time, a value, an incoming tangent, and an outgoing tangent. The incoming
    tangent is used if the control point is evaluated with the point that comes before
    it. The outgoing tangent is used if the control point is evaluated with the point
    that comes after it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Hermite曲线是通过连接Hermite样条线制成的。每个控制点由时间、值、入射切线和出射切线组成。如果使用控制点与其前面的点进行评估，则使用入射切线。如果使用控制点与其后面的点进行评估，则使用出射切线。
- en: The time value stored in a frame is scalar, but what about the data and tangents?
    Should these values be scalar, a vector, or a quaternion? To make that decision,
    you have to think about how you might want to organize a collection of frames
    into a curve.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 帧中存储的时间值是标量的，但数据和切线呢？这些值应该是标量、矢量还是四元数？要做出这个决定，您必须考虑如何将一组帧组织成曲线。
- en: There are two strategies to choose from. You could create a scalar curve object,
    where the data and tangents are scalar values. Then, when you need a vector curve,
    you can combine several scalar curve objects into a vector curve object.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种选择策略。您可以创建一个标量曲线对象，其中数据和切线是标量值。然后，当您需要一个矢量曲线时，可以将几个标量曲线对象组合成一个矢量曲线对象。
- en: The advantage of having a scalar track and compositing higher-order tracks from
    it is that each component of a vector or quaternion curve can be interpolated
    differently. It can also save on memory since each component of the curve could
    have a different number of frames. The disadvantage is the additional effort of
    implementation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 具有标量轨道并从中合成高阶轨道的优势在于矢量或四元数曲线的每个分量可以以不同的方式进行插值。它还可以节省内存，因为曲线的每个分量可以具有不同数量的帧。缺点是额外的实现工作。
- en: The other strategy is to have specialized frame and curve types, such as a scalar
    frame, a vector frame, and a quaternion frame. Similarly, you could create separate
    classes to represent a scalar curve, a vector curve, and a quaternion curve.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种策略是使用专门的帧和曲线类型，例如标量帧、矢量帧和四元数帧。同样，您可以创建单独的类来表示标量曲线、矢量曲线和四元数曲线。
- en: The advantage of using specialized frames and curves is their ease of implementation.
    You can take advantage of using templates to avoid writing duplicate code. glTF
    files store animation tracks this way as well. The disadvantage is memory; every
    component of a curve is required to have the same number of keyframes.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用专门的帧和曲线的优势在于其易于实现。您可以利用使用模板来避免编写重复的代码。glTF文件也以这种方式存储动画轨迹。缺点是内存；曲线的每个分量都需要具有相同数量的关键帧。
- en: 'In this book, you will implement explicit frames and curves (tracks). The `Frame`
    class will contain a time, a value, and both in and out tangents. If the interpolation
    type doesn''t need tangents, you can simply ignore them. A frame can be an arbitrary
    size (such as scalar, vector 2, vector 3, quat, and so on). The time it contains
    will always be a scalar, but the value and tangent lengths can be anything:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，你将实现显式帧和曲线（轨迹）。`Frame`类将包含时间、值和入射和出射切线。如果插值类型不需要切线，你可以简单地忽略它们。帧可以是任意大小（如标量、二维向量、三维向量、四元数等）。它包含的时间始终是标量，但值和切线长度可以是任何值：
- en: 'Create a new file, `Frame.h`. Add the declaration of the `Frame` class to this
    new file. The `Frame` class needs arrays for the value and the in and out tangents,
    and a scalar for the time. Use a template to specify the size of each frame:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件`Frame.h`。将`Frame`类的声明添加到这个新文件中。`Frame`类需要值和入射和出射切线的数组，以及一个时间标量。使用模板来指定每个帧的大小：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create the `typedef` data types for the common frame types:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为常见的帧类型创建`typedef`数据类型：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `Frame` class you just implemented is used to store keyframes in an animation
    track. An animation track is a collection of keyframes. In the next section, you
    will learn how to implement a `Track` class.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚实现的`Frame`类用于存储动画轨迹中的关键帧。动画轨迹是关键帧的集合。在下一节中，你将学习如何实现`Track`类。
- en: Creating the Track class
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Track类
- en: A `Track` class is a collection of frames. Interpolating a track returns the
    data type of the track; the result is the value along whatever curve the track
    defines at a specific point in time. A track must have at least two frames to
    interpolate between.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Track`类是一组帧。对轨迹进行插值返回轨迹的数据类型；结果是轨迹在特定时间点上定义的曲线上的值。轨迹必须至少有两个帧进行插值。'
- en: As mentioned in the *Creating the Frame struct* section, by following the examples
    in this book, you will implement explicit frame and track types. There will be
    separate classes for scalar, vector, and quaternion tracks. These classes are
    templated to avoid having to write duplicate code. A `vec3` track, for example,
    contains the `Frame<3>` type frames.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如*创建Frame结构*部分所述，通过遵循本书中的示例，你将实现显式的帧和轨迹类型。将为标量、向量和四元数轨迹创建单独的类。这些类是模板的，以避免编写重复的代码。例如，`vec3`轨迹包含`Frame<3>`类型的帧。
- en: Because tracks have an explicit type, you can't make a keyframe in the *X* component
    of a `vec3` track without also adding a keyframe to the *Y* and *Z* components
    as well.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因为轨迹有一个明确的类型，所以你不能在`vec3`轨迹的*X*分量中创建关键帧，而不同时为*Y*和*Z*分量添加关键帧。
- en: 'This can eat up more memory if you have a component that doesn''t change. For
    example, notice how, in the following figure, the *Z* component has many frames,
    even though it''s a straight line and two should be enough. This isn''t a big
    trade-off; the additional memory that''s taken is insignificant:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会占用更多的内存，如果你有一个不变的组件。例如，注意在下图中，*Z*组件有许多帧，即使它是一条直线，两个应该足够了。这并不是一个很大的折衷；所占用的额外内存是微不足道的：
- en: '![Figure 8.11: The components of a vec3 track](img/Figure_8.11_B16191.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图8.11：vec3轨迹的组件](img/Figure_8.11_B16191.jpg)'
- en: 'Figure 8.11: The components of a vec3 track'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11：vec3轨迹的组件
- en: For skinned mesh rendering, animation tracks always animate joint transforms.
    However, animation tracks can be used to animate other values in a game as well,
    such as the intensity of a light or switching between two-dimensional sprites
    for a flipbook effect. In the next section, you will create a new header file
    and start declaring the actual `Track` class.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于蒙皮网格渲染，动画轨迹总是对关节变换进行动画。然而，动画轨迹也可以用于在游戏中动画其他值，比如光的强度或在二维精灵之间切换以产生翻书效果。在下一节中，你将创建一个新的头文件并开始声明实际的`Track`类。
- en: Declaring the Track class
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明Track类
- en: 'A track is a collection of frames. The `Frame` class is templated, so the `Track`
    class needs to be templated as well. The `Track` class takes two template parameters—the
    first is the type (which is intended to be `float`, `vec3`, `quat`, and so on)
    and the other is the number of components that the type contains:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 轨迹是一组帧。`Frame`类是模板的，所以`Track`类也需要是模板的。`Track`类需要两个模板参数——第一个是类型（预期是`float`、`vec3`、`quat`等），另一个是类型包含的组件数：
- en: 'The `Track` class only needs two members—a vector of frames and an interpolation
    type. Create a new file, `Track.h`, and add the declaration of the `Track` class
    to this file:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Track`类只需要两个成员——帧的向量和插值类型。创建一个新文件`Track.h`，并将`Track`类的声明添加到这个文件中：'
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `Track` class only needs a default constructor to initialize the `mInterpolation`
    variable. The generated copy constructor, assignment operator, and destructor
    are fine:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Track`类只需要一个默认构造函数来初始化`mInterpolation`变量。生成的复制构造函数、赋值运算符和析构函数都很好：'
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create getter and setter functions for the number of frames a track has, as
    well as its interpolation type and the start and end time:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为轨迹的帧数、插值类型以及起始和结束时间创建获取器和设置器函数：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `Track` class needs a way to sample the track when given a time. This `Sample`
    method should take a time value and whether the track is looping or not. Overload
    the `[] operator` to retrieve a reference to a frame:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Track`类需要一种在给定时间采样轨迹的方法。这个`Sample`方法应该接受一个时间值和轨迹是否循环的参数。重载`[]运算符`以检索帧的引用：'
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, you need to declare some helper functions. A track can be constant, linear,
    or cubic. There is only one `Sample` function that needs to handle all three of
    these cases. Rather than making a huge, hard-to-read function, create a helper
    function for each interpolation type:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你需要声明一些辅助函数。轨迹可以是常量、线性或立方体。只需要一个`Sample`函数来处理这三种情况。不要创建一个庞大、难以阅读的函数，为每种插值类型创建一个辅助函数：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add a helper function to evaluate the Hermite splines:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个辅助函数来评估Hermite样条：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add a function to retrieve the frame index for a given time. This is the last
    frame right before the requested time. Also, add a helper function that takes
    an input time that is outside the range of the track and adjusts it to be a valid
    time on the track:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个函数来检索给定时间的帧索引。这是请求的时间之前的最后一帧。另外，添加一个辅助函数，该函数接受轨道范围之外的输入时间，并将其调整为轨道上的有效时间：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You will need a way of casting an array of floats (the data inside a frame)
    to the templated type of the track. This function is specialized for each type
    of track:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要一种将浮点数组（帧内的数据）转换为轨道模板类型的方法。该函数针对每种类型的轨道进行了专门化：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As with the `Frame` class, add the `typedef` data types for the common `Track`
    types:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与`Frame`类一样，为常见的`Track`类型添加`typedef`数据类型：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The API of the `Track` class is small, which makes the class easy to work with.
    However, there is a lot of hidden complexity to the `Track` class; after all,
    this class is at the core of the animation system you are building. In the next
    section, you will start to implement the actual `Track` class.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`Track`类的API很小，这使得该类易于使用。但是，`Track`类存在许多隐藏的复杂性；毕竟，这个类是您正在构建的动画系统的核心。在下一节中，您将开始实现实际的`Track`类。'
- en: Implementing the Track class
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现Track类
- en: 'The `Track` class is templated, but it''s not meant to be used outside of the
    animation system. Add template definitions for the `float`, `vec3`, and `quat`
    tracks to `Track.cpp`. This makes the compiler generate the code for these templates
    in the CPP file:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`Track`类是模板化的，但不打算在动画系统之外使用。在`Track.cpp`中为`float`、`vec3`和`quat`轨道添加模板定义。这样做可以使编译器在CPP文件中生成这些模板的代码：'
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For character animation, the `vec3` and `quat` track types are all you need.
    If you need to add a new type of track, don't forget to add the template type
    to the `Track.cpp` file. In the following section, you will start to implement
    helper functions to load track data.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于角色动画，`vec3`和`quat`轨道类型就足够了。如果需要添加新类型的轨道，请不要忘记将模板类型添加到`Track.cpp`文件中。在接下来的部分中，您将开始实现加载轨道数据的辅助函数。
- en: Implementing helper functions
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现辅助函数
- en: The `Track` class is templated to avoid having to write duplicate code for all
    the track types. However, some functionality needs to be specific to the type
    of the `Track` class. Besides the `Cast` function, all type-specific functions
    reside in a new namespace—`TrackHelpers`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Track`类是模板化的，以避免为所有轨道类型编写重复的代码。但是，某些功能需要特定于`Track`类的类型。除了`Cast`函数之外，所有特定于类型的函数都驻留在一个新的命名空间`TrackHelpers`中。'
- en: 'These helper functions are not a part of the `Track` class; they rely on function
    overloading to make sure the right version of the helper function is called. One
    of the key responsibilities of these helper classes is to make sure quaternions
    are normalized and are in the right neighborhood. Because this code interpolates
    quaternions, neighborhooding is a concern:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些辅助函数不是`Track`类的一部分；它们依赖于函数重载，以确保调用正确版本的辅助函数。这些辅助类的关键职责之一是确保四元数被归一化并处于正确的邻域。因为这段代码插值四元数，所以邻域是一个关注点：
- en: 'For a track to be linearly interpolated, you need to create interpolation functions
    that work with each track type. Add the following helper functions to `Track.cpp`
    that provide the correct interpolation method for each of the data types that
    a track might contain. These functions belong in the `TrackHelpers` namespace:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使轨道进行线性插值，您需要为每种轨道类型创建插值函数。在`Track.cpp`中添加以下辅助函数，为轨道可能包含的每种数据类型提供正确的插值方法。这些函数属于`TrackHelpers`命名空间。
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When a Hermite spline is interpolated, if the input type was a quaternion,
    the result needs to be normalized. Rather than providing a quaternion specification
    of the Hermite function, you can create helper functions that only normalize quaternions:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当插值Hermite样条时，如果输入类型是四元数，则结果需要被归一化。您可以创建仅归一化四元数的辅助函数，而不是提供Hermite函数的四元数规范：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'There also needs to be a common `Neighborhood` operation that makes sure two
    quaternions are in the correct neighborhood. This function should do nothing for
    the other data types:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还需要一个常见的`Neighborhood`操作，以确保两个四元数处于正确的邻域。该函数对其他数据类型应该不做任何操作：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The reason these helper functions exist is to avoid having to make specialized
    versions of the interpolation functions. Instead, the generic interpolation functions
    call these helper methods and function overloading makes sure the correct function
    is called. This does mean that you need to add new helper functions if you add
    a new type of track. In the next section, you will start implementing some of
    the `Track` functions.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这些辅助函数存在的原因是为了避免制作插值函数的专门版本。相反，通用插值函数调用这些辅助方法，并且函数重载确保调用正确的函数。这意味着如果添加新类型的轨道，则需要添加新的辅助函数。在下一节中，您将开始实现一些`Track`函数。
- en: Implementing the Track functions
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现Track函数
- en: 'In this section, you will start to implement the member functions of the `Track`
    class. The `Track` class has several unimportant functions that either need to
    call helper functions or are simply getter and setter functions. Begin implementing
    the `Track` class with these functions first:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将开始实现`Track`类的成员函数。`Track`类有几个不重要的函数，要么需要调用辅助函数，要么只是获取器和设置器函数。首先使用这些函数开始实现`Track`类：
- en: 'The `Track` constructor needs to set the track''s interpolation type. The getter
    and setter functions for the start and end times of the track are simple getter
    functions:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Track`构造函数需要设置轨道的插值类型。轨道的开始和结束时间的获取器和设置器函数很简单：'
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `Sample` function needs to call `SampleConstant`, `SampleLinear`, or `SampleCubic`,
    depending on the track type. The `[]` `operator` returns a reference to the specified
    frame:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Sample`函数需要调用`SampleConstant`、`SampleLinear`或`SampleCubic`，具体取决于轨道类型。`[]`
    `operator`返回对指定帧的引用：'
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `Resize` and `Size` functions are simple getter and setters around the
    size of the frames vector:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Resize`和`Size`函数是围绕帧向量的大小的简单获取器和设置器：'
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The interpolation type of the track also has simple getter and setter functions:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 轨道的插值类型也有简单的获取器和设置器函数：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `Hermite` function implements the basic functions covered in the *Understanding
    cubic Hermite splines* section of this chapter. The second point might need to
    be negated by the `Neighborhood` helper function. Quaternions also need to be
    normalized. Both neighborhooding and normalization are carried out by helper functions:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Hermite`函数实现了本章*理解三次Hermite样条*部分涵盖的基本函数。第二点可能需要通过`Neighborhood`辅助函数取反。四元数也需要被归一化。邻域化和归一化都是由辅助函数执行的：'
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the following sections, you will implement some of the more difficult functions
    of the `Track` class, starting with the `FrameIndex` function.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，您将实现`Track`类的一些更难的函数，从`FrameIndex`函数开始。
- en: Implementing the FrameIndex function
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现`FrameIndex`函数
- en: 'The `FrameIndex` function takes time as an argument; it should return the frame
    immediately before that time (on the left). This behavior changes depending on
    whether the track is intended to be sampled looping or not. Follow these steps
    to implement the `FrameIndex` function:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`FrameIndex`函数以时间作为参数；它应该返回该时间之前的帧（在左侧）。这种行为取决于轨道是否打算循环采样。按照以下步骤实现`FrameIndex`函数：'
- en: 'If the track has one frame or less, it is invalid. If an invalid track is encountered,
    return `-1`:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果轨道只有一帧或更少，那么它是无效的。如果遇到无效的轨道，返回`-1`：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If the track is sampled as looping, the input time needs to be adjusted so
    that it falls between the start and end frames. This means you need to know the
    time at the first frame of the track, the time at the frame of the track, and
    the duration of the track:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果轨道被循环采样，输入时间需要调整，使其落在起始和结束帧之间。这意味着您需要知道轨道第一帧的时间、轨道帧的时间和轨道的持续时间：
- en: '[PRE37]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Since the track is looping, `time` needs to be adjusted so that it is within
    a valid range. To do this, make `time` relative to duration by subtracting the
    start time from it and modulo the result with duration. If `time` is negative,
    add the duration. Don''t forget to add the start time back into `time`:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于轨道循环，`time`需要调整，使其在有效范围内。为此，通过从起始时间中减去`time`并将结果与持续时间取模来使`time`相对于持续时间。如果`time`为负数，则加上持续时间。不要忘记将起始时间加回`time`中：
- en: '[PRE38]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If the track doesn''t loop, any `time` value that is less than the start frame
    should clamp to `0` and any `time` value that is greater than the second-to-last
    frame should clamp to the second-to-last frame''s index:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果轨道不循环，任何小于起始帧的`time`值应该被夹到`0`，任何大于倒数第二帧的`time`值应该被夹到倒数第二帧的索引：
- en: '[PRE39]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now that the time is in a valid range, loop through every frame. The frame
    that is closest to the time (but still less) is the frame whose index should be
    returned. This frame can be found by looping through the frames of the track backward
    and returning the first index whose time is less than the time that is looked
    up:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在时间在有效范围内，循环遍历每一帧。最接近时间的帧（但仍然较小）是应该返回的帧的索引。可以通过向后循环遍历轨道的帧并返回第一个时间小于查找时间的索引来找到这一帧：
- en: '[PRE40]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If a track does not loop and the time is greater than the last frame's time,
    the index of the second-to-last frame is used. Why the second-to-last frame and
    not the last frame? The `Sample` function always needs a current and next frame,
    and the next frame is found by adding `1` to the result of the `FrameIndex` function.
    When `time` equals the time of the last frame, the two frames that need to be
    interpolated are still the second-to-last frame and the last frame.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个轨道不循环并且时间大于最后一帧的时间，则使用倒数第二帧的索引。为什么使用倒数第二帧而不是最后一帧？`Sample`函数总是需要当前帧和下一帧，下一帧是通过将`FrameIndex`函数的结果加`1`来找到的。当`time`等于最后一帧的时间时，需要插值的两帧仍然是倒数第二帧和最后一帧。
- en: In the next section, you will implement the `AdjustTimeToFitTrack` function.
    This function is used to make sure any time that is sampled has a valid value.
    A valid value is any time between the start and end times of the track.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将实现`AdjustTimeToFitTrack`函数。这个函数用于确保任何采样的时间都有一个有效的值。有效的值是指在轨道的起始时间和结束时间之间的任何时间。
- en: Implementing the AdjustTimeToFitTrack function
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现`AdjustTimeToFitTrack`函数
- en: 'The next function to implement is `AdjustTimeToFitTrack`. When given a time,
    this function needs to adjust the time to be in the range of the start/end frames
    of the track. This is, of course, different depending on whether the track loops.
    Take the following steps to implement the `AdjustTimeToFitTrack` function:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现的下一个函数是`AdjustTimeToFitTrack`。给定一个时间，这个函数需要调整时间，使其落在轨道的起始/结束帧的范围内。当然，这取决于轨道是否循环。按照以下步骤实现`AdjustTimeToFitTrack`函数：
- en: 'If a track has less than one frame, the track is invalid. If an invalid track
    is used, return `0`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个轨道少于一帧，那么这个轨道是无效的。如果使用了无效的轨道，返回`0`：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Find the start time, end time, and duration of the track. The start time is
    the time of the first frame, the end time is the time of the last frame, and the
    duration is the difference between the two. If the track has a `0` duration, it
    is invalid—return `0`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到轨道的起始时间、结束时间和持续时间。起始时间是第一帧的时间，结束时间是最后一帧的时间，持续时间是两者之间的差异。如果轨道持续时间为`0`，则无效——返回`0`：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If the track loops, adjust the time by the duration of the track:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果轨道循环，通过轨道的持续时间调整时间：
- en: '[PRE43]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If the track does not loop, clamp the time to the first or last frame. Return
    the adjusted time:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果轨道不循环，将时间夹到第一帧或最后一帧。返回调整后的时间：
- en: '[PRE44]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `AdjustTimeToFitTrack` function is useful because it keeps the animation
    sampling time in the range. This function is intended to be called when the playback
    time of an animation changes. Consider the following example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`AdjustTimeToFitTrack`函数很有用，因为它保持了动画采样时间在范围内。这个函数旨在在动画播放时间改变时调用。考虑以下例子：'
- en: '[PRE45]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Any time the `Update` function is called in the example, the `mAnimTime` variable
    is incremented by `deltaTime` of the frame. However, because the incremented time
    is passed to `AdjustTimeToFitTrack` before it is assigned, it never has an invalid
    animation time value.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中每次调用`Update`函数时，`mAnimTime`变量都会增加`frame`的`deltaTime`。然而，由于增加的时间在分配之前传递给`AdjustTimeToFitTrack`，因此它永远不会有无效的动画时间值。
- en: In the following section, you will implement the `Cast` function of the `Track`
    class. The `Cast` function is used to take an array of floats and cast it to whatever
    the templated type of the `Track` class is.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，您将实现`Track`类的`Cast`函数。`Cast`函数用于接受一个浮点数组，并将其转换为`Track`类的模板类型。
- en: Implementing the Cast function
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现Cast函数
- en: 'The `Cast` function is specialized; an implementation needs to be provided
    for every type of track. The `Cast` function takes a floating-point array and
    returns whatever the templated type, `T`, is of the `Track` class. The supported
    types are `float`, `vec3`, and `quat`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cast`函数是专门的；需要为每种类型的轨迹提供一个实现。`Cast`函数接受一个浮点数组，并返回`Track`类的模板类型`T`。支持的类型有`float`、`vec3`和`quat`：'
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This `Cast` function is important because it can cast a `float` array stored
    in a `Frame` class into the data type that the `Frame` class represents. For example,
    `Frame<3>` is cast to `vec3`. In the following sections, you will use the `Cast`
    function to return the correct data type when sampling a `Track` class.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Cast`函数很重要，因为它可以将存储在`Frame`类中的`float`数组转换为`Frame`类表示的数据类型。例如，`Frame<3>`被转换为`vec3`。在接下来的部分中，您将使用`Cast`函数来返回采样`Track`类时的正确数据类型。
- en: Constant track sampling
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常量轨迹采样
- en: 'In this section, you will implement the first of three sampling functions for
    a `Track` class—the `FrameIndex` helper. Make sure the frame is valid, then cast
    the value of that frame to the correct data type and return it:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将为`Track`类实现三个采样函数中的第一个——`FrameIndex`辅助函数。确保帧是有效的，然后将该帧的值转换为正确的数据类型并返回：
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Constant sampling is often used for things such as visibility flags, where it
    makes sense for the value of a variable to change from one frame to the next without
    any real interpolation. In the following section, you will learn how to implement
    linear track sampling. Linear sampling is very common; most content creation applications
    offer a "sampled" export option that exports linearly interpolated tracks.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 常量采样通常用于诸如可见标志之类的东西，其中一个变量的值从一帧到下一帧的变化没有任何实际的插值是有意义的。在接下来的部分中，您将学习如何实现线性轨迹采样。线性采样非常常见；大多数内容创建应用程序提供了一个“采样”导出选项，可以导出线性插值的轨迹。
- en: Linear track sampling
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线性轨迹采样
- en: The second type of sampling, `FrameIndex` function, you should never be in a
    situation where the current frame is the last frame of the track and the next
    frame is invalid.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种采样类型，`FrameIndex`函数，你永远不应该处于当前帧是轨迹的最后一帧且下一帧无效的情况。
- en: Once you know the current frame, the next frame, and the delta time between
    them, you can interpolate. Call `AdjustTimeToFitTrack` to make sure the time is
    valid, subtract the time of the first frame from it, and divide the result by
    the frame delta. This results in the interpolation value, `t`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你知道了当前帧、下一帧以及它们之间的时间差，你就可以进行插值。调用`AdjustTimeToFitTrack`确保时间有效，从第一帧的时间中减去它，并将结果除以帧间隔。这将得到插值值`t`。
- en: 'Knowing the interpolation value, call the `TrackHelpers::Interpolate` function
    to do the interpolation:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 知道插值值后，调用`TrackHelpers::Interpolate`函数进行插值：
- en: '[PRE48]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Linear sampling is common as many 3D content creation applications provide an
    option to approximate animation curves by sampling them at set intervals. In the
    following section, you will learn how to carry out the cubic interpolation of
    curves. Cubic interpolation stores less data than linear interpolation, but is
    more expensive to calculate.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 线性采样通常用于许多3D内容创建应用程序，这些应用程序提供了一个选项，可以通过在固定间隔处对动画曲线进行采样来近似。在接下来的部分中，您将学习如何进行曲线的三次插值。三次插值存储的数据比线性插值少，但计算成本更高。
- en: Cubic track sampling
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 三次轨迹采样
- en: The final type of sampling, `Hermite` helper function to do its interpolation.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种采样类型，`Hermite`辅助函数进行插值。
- en: 'If you imagine `time` as a play-head on a track, it is on the right of the
    first point and the left of the second point. Therefore, you need the out slope
    of the first point (because the play-head is moving away from it) and the in slope
    of the second point (because the play-head is moving toward it). Both slopes need
    to be scaled by the frame delta:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你把`time`想象成轨道上的播放头，它在第一个点的右边和第二个点的左边。因此，你需要第一个点的外斜率（因为播放头正在远离它），以及第二个点的内斜率（因为播放头正在朝向它）。两个斜率都需要乘以帧间隔：
- en: '[PRE49]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Why do the slopes use `memcpy` instead of the `Cast` function? This is because
    the `Cast` function normalizes quaternions, which is bad because slopes are not
    meant to be quaternions. Using `memcpy` instead of `Cast` copies the values directly,
    avoiding normalization.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么斜率使用`memcpy`而不是`Cast`函数？这是因为`Cast`函数会对四元数进行归一化，这是不好的，因为斜率不应该是四元数。使用`memcpy`而不是`Cast`直接复制值，避免了归一化。
- en: In the next section, you will learn how to combine vector and quaternion tracks
    into a `TransformTrack`. The actual animation framework will work on the `TransformTrack`
    classes, which will not be templated.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将学习如何将矢量和四元数轨迹合并成一个`TransformTrack`。实际的动画框架将在`TransformTrack`类上工作，这些类将不是模板化的。
- en: Creating the TransformTrack class
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建TransformTrack类
- en: For any animated transform, you don't want to maintain separate vector and quaternion
    tracks; instead, you build a higher-level structure—the transform track. A transform
    track encapsulates three tracks—one for the position, one for the rotation, and
    one for scale. You can sample the transform track at any point and get a full
    transform back, even if the component tracks are of different durations or start
    at different times.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何动画变换，您不希望维护单独的向量和四元数轨道；相反，您构建一个更高级的结构——变换轨道。变换轨道封装了三个轨道——一个用于位置，一个用于旋转，一个用于缩放。您可以在任何点对变换轨道进行采样，并获得完整的变换，即使组件轨道的持续时间或开始时间不同。
- en: One thing to consider is how you want to store these transform tracks in relation
    to an animated model. The skeleton of a model contains several bones. You can
    either store a vector of transform tracks—one for each bone—or you can add bone
    ID as a member of the transform track and only store as many as are needed.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要考虑的一件事是如何将这些变换轨道与动画模型相关联。模型的骨架包含几个骨骼。您可以存储一个变换轨道的向量——每个骨骼一个——或者您可以将骨骼ID添加为变换轨道的成员，并且只存储所需数量的骨骼。
- en: This is important because a character can have a lot of bones, but not all animations
    will animate all of those bones. If you store one transform track for each bone,
    it wastes memory, but sampling an animation is faster. If you store only as many
    transform tracks as needed, sampling becomes a bit more expensive, but memory
    consumption goes down.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为一个角色可能有很多骨骼，但并非所有动画都会对所有这些骨骼进行动画。如果为每个骨骼存储一个变换轨道，会浪费内存，但对动画进行采样会更快。如果只存储所需数量的变换轨道，采样会变得更昂贵，但内存消耗会减少。
- en: Implementation choices tend to always end up being memory versus speed. On modern
    systems, the delta on either axis should be trivial. In this section, you will
    add a bone ID to the transform tracks and only store as many tracks as needed.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 实现选择往往最终成为内存与速度之间的权衡。在现代系统上，任一轴上的增量应该是微不足道的。在本节中，您将为变换轨道添加一个骨骼ID，并且只存储所需数量的轨道。
- en: Declaring the TransformTrack class
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明TransformTrack类
- en: The `TransformTrack` class will need to hold an integer that represents which
    bone (joint) the track will affect. It also needs actual tracks for the position,
    rotation, and scale. These four pieces of information should together be enough
    to animate a joint's position, rotation, and scale.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransformTrack`类将需要保存一个表示轨道将影响哪个骨骼（关节）的整数。它还需要实际的位置、旋转和缩放轨道。这四个信息应该足以对关节的位置、旋转和缩放进行动画。'
- en: As with the `Track` class, the `TransformTrack` class has getter and setter
    functions for the start and end times of the transform track. The start and end
    times of a transform track is dependent on its component tracks. Component tracks
    are the position, rotation, and scale tracks.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Track`类一样，`TransformTrack`类有获取和设置变换轨道的开始和结束时间的函数。变换轨道的开始和结束时间取决于其组件轨道。组件轨道是位置、旋转和缩放轨道。
- en: Out of the three tracks, the start time that is the lowest is used as the transform
    track's start time. The end time that is the largest of the three tracks is used
    as the transform track's end time.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在三个轨道中，最低的开始时间被用作变换轨道的开始时间。三个轨道中最大的结束时间被用作变换轨道的结束时间。
- en: Not all of the component tracks in a transform track need to be valid. For example,
    if only the position of a transform is animated, the rotation and scale component
    tracks can be left as invalid. A transform track is valid so long as at least
    one of its component tracks is valid.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 变换轨道中的不是所有组件轨道都需要有效。例如，如果只有变换的位置是动画的，那么旋转和缩放组件轨道可以保持无效。只要其组件轨道中至少有一个有效，变换轨道就是有效的。
- en: 'Because not all of the component tracks are guaranteed to be valid, the `Sample`
    function of the `TransformTrack` class needs to take a reference transform. Take
    the following steps to declare the `TransformTrack` class:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 因为不是所有组件轨道都保证有效，`TransformTrack`类的`Sample`函数需要获取一个引用变换。采取以下步骤声明`TransformTrack`类：
- en: 'Create a new file, `TransformTrack.h`, and start adding the `TransformTrack`
    definition to it by defining the member variables:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件`TransformTrack.h`，并开始通过定义成员变量来添加`TransformTrack`的定义：
- en: '[PRE50]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The public API is straightforward. You need the default constructor to assign
    a default value to the joint ID of the track. You also need getter functions for
    the ID, the component tracks, and the start/end times, as well as the duration
    and validity. Only the ID needs a setter function; the component getter functions
    return mutable references:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 公共API很简单。您需要默认构造函数来为轨道的关节ID分配默认值。您还需要获取ID、组件轨道、开始/结束时间、持续时间和有效性的函数，以及ID需要一个设置函数；组件获取函数返回可变引用：
- en: '[PRE51]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the next section, you will start implementing the functions of `TransfromTrack`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将开始实现`TransfromTrack`的函数。
- en: Implementing the TransformTrack class
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现TransformTrack类
- en: 'Follow these steps to implement the `TransformTrack` class:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现`TransformTrack`类：
- en: 'Create a new file, `TransformTrack.cpp`, to implement the `TransformTrack`
    class in. The constructor of the `TransformTrack` class is unimportant; assign
    a default value to the joint that the transform track represents. The getter and
    setter functions for the track ID are also trivial:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件`TransformTrack.cpp`，以实现`TransformTrack`类。`TransformTrack`类的构造函数并不重要；为变换轨道表示的关节分配一个默认值。轨道ID的获取和设置函数也很简单：
- en: '[PRE52]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, implement functions to access the different component tracks stored in
    the transform track. These functions need to return a reference so that you can
    mutate the returned tracks:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，实现函数来访问存储在变换轨道中的不同组件轨道。这些函数需要返回一个引用，以便您可以改变返回的轨道：
- en: '[PRE53]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `IsValid` helper function should only return `true` if at least one of
    the component tracks stored in the `TransformTrack` class is valid. For a track
    to be valid, it needs to have two or more frames:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IsValid`辅助函数只有在存储在`TransformTrack`类中的组件轨道中至少有一个有效时才应返回`true`。要使轨道有效，需要有两个或更多帧：'
- en: '[PRE54]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `GetStartTime` function should return the smallest start time of the three
    component tracks. If none of the components are valid (that is, they all have
    one or no frames), then `TransformTrack` isn''t valid. In this case, just return
    `0`:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetStartTime`函数应该返回三个组件轨道中最小的开始时间。如果没有一个组件是有效的（即它们都只有一个或没有帧），那么`TransformTrack`就无效。在这种情况下，只需返回`0`：'
- en: '[PRE55]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `GetEndTime` function is similar to the `GetStartTime` function. The only
    difference is that this function looks for the greatest track end time:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetEndTime`函数类似于`GetStartTime`函数。唯一的区别是这个函数寻找最大的轨道结束时间：'
- en: '[PRE56]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `Sample` function only samples one of its component tracks if that track
    has two or more frames. Since a `TransformTrack` class can animate only one component,
    such as the position, this function needs to take a reference transform as an
    argument. If one of the transform components isn''t animated by the transform
    track, the value of the reference transform is used:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Sample`函数只在其组件轨道有两个或更多帧时对其进行采样。由于`TransformTrack`类只能对一个组件进行动画，比如位置，因此这个函数需要将一个参考变换作为参数。如果变换轨道没有对其中一个变换组件进行动画，那么将使用参考变换的值：'
- en: '[PRE57]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Because not all animations contain the same tracks, it's important to reset
    the pose that you are sampling any time the animation that you are sampling switches.
    This ensures that the reference transform is always correct. To reset the pose,
    assign it to be the same as the rest pose.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 因为并非所有动画都包含相同的轨道，重置正在采样的姿势是很重要的。这可以确保参考变换始终是正确的。要重置姿势，将其分配为与休息姿势相同。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about the building blocks of animation, what is
    in one frame of data, how several frames can make a track, and how a few tracks
    can animate a transform. You explored the different interpolation methods for
    interpolating an animation track and made these methods work for scalar, vector,
    and quaternion tracks.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了动画的基本组件，一个数据帧中包含什么，几个帧如何组成一个轨道，以及几个轨道如何使一个变换发生动画。您探索了不同的插值方法，用于插值动画轨道，并使这些方法适用于标量、向量和四元数轨道。
- en: The classes you built in this chapter will be used as the building blocks for
    creating animation clips in the next chapter. In the next chapter, you will implement
    animation clips and poses. The animation clips will be made of the `TransformTrack`
    objects. These tracks are at the core of a modern animation system.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中构建的类将作为下一章中创建动画剪辑的基本组件。在下一章中，您将实现动画剪辑和姿势。动画剪辑将由`TransformTrack`对象组成。这些轨道是现代动画系统的核心。
- en: There are two samples in the `Chapter08` folder of the downloadable content
    for this book. `Sample00` contains all the code used up to this point in the book
    and `Sample01` creates several tracks and plots them all on screen. Visually plotting
    tracks is a good idea as it can help prevent debug problems early on.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的可下载内容的`Chapter08`文件夹中有两个示例。`Sample00`包含到目前为止在书中使用的所有代码，`Sample01`创建了几个轨道并将它们全部绘制在屏幕上。在视觉上绘制轨道是一个好主意，因为它可以帮助及早解决调试问题。
