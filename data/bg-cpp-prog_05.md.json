["```cpp\n    int mult(int, int); \n\n    int main() \n    { \n        cout << mult(6, 7) << endl; \n        return 0; \n    } \n\n    int mult(int lhs, int rhs) \n    { \n        return lhs * rhs; \n    }\n```", "```cpp\n    extern int mult(int, int);        // defined in another file\n```", "```cpp\n    static int mult(int, int);        // defined in this file\n```", "```cpp\n    inline auto mult(int lhs, int rhs) -> int \n    { \n        return lhs * rhs; \n    }\n```", "```cpp\n    int calculate(int param) throw(overflow_error) \n    { \n        // do something which potentially may overflow \n    }\n```", "```cpp\n    // C++11 style: \n    int increment(int param) noexcept \n    { \n        // check the parameter and handle overflow appropriately \n    }\n```", "```cpp\n    void f(const float&); \n    f(1.0);              // OK, temporary float created \n    double d = 2.0; \n    f(d);                // OK, temporary float created\n```", "```cpp\n    struct point { int x; int y; }; \n\n    void set_point(point pt); \n\n    int main() \n    { \n        point p; \n        p.x = 1; p.y = 1; \n        set_point(p); \n        set_point({ 1, 1 });  \n        return 0; \n    }\n```", "```cpp\n    void log_message(const string& msg, bool clear_screen = false) \n    { \n        if (clear_screen) clear_the_screen(); \n        cout << msg << endl; \n    }\n```", "```cpp\n    log_message(\"first message\", true); \n    log_message(\"second message\"); \n    bool user_decision = ask_user(); \n    log_message(\"third message\", user_decision);\n```", "```cpp\n    extern void log_message(const string& msg, bool clear_screen);\n```", "```cpp\n    extern void log_message(const string& msg, bool clear_screen); \n    extern void log_message(const string& msg); // conceptually\n```", "```cpp\n    #include <initializer_list> \n\n    int sum(initializer_list<int> values) \n    { \n        int sum = 0; \n        for (int i : values) sum += i; \n        return sum; \n    } \n\n    int main() \n    { \n        cout << sum({}) << endl;                       // 0 \n        cout << sum({-6, -5, -4, -3, -2, -1}) << endl; // -21 \n        cout << sum({10, 20, 30}) << endl;             // 60 \n        return 0; \n    }\n```", "```cpp\n    int sum(int first, ...) \n    { \n        int sum = 0;    \n        va_list args; \n        va_start(args, first); \n        int i = first; \n        while (i != -1) \n        { \n            sum += i; \n            i = va_arg(args, int); \n        } \n        va_end(args); \n        return sum; \n    }\n```", "```cpp\n    cout << sum(-1) << endl;                       // 0 \n    cout << sum(-6, -5, -4, -3, -2, -1) << endl;   // -20 !!! \n    cout << sum(10, 20, 30, -1) << endl;           // 60\n```", "```cpp\n    int sum(int count, ...) \n    { \n        int sum = 0; \n        va_list args; \n        va_start(args, count); \n        while(count--) \n        { \n            int i = va_arg(args, int); \n            sum += i; \n        } \n        va_end(args); \n        return sum; \n    }\n```", "```cpp\n    cout << sum(0) << endl;                         // 0 \n    cout << sum(6, -6, -5, -4, -3, -2, -1) << endl; // -21 \n    cout << sum(3, 10, 20, 30) << endl;             // 60\n```", "```cpp\n    cout << sum(3, 10., 20, 30) << endl;\n```", "```cpp\n    int printf(const char *format, ...);\n```", "```cpp\n    int factorial(int n) \n    { \n        if (n > 1) return n \u2217 factorial(n \u2212 1); \n        return 1; \n    }\n```", "```cpp\n    factorial(4) returns 4 * factorial(3) \n        factorial(3) returns 3 * factorial(2) \n            factorial(2) returns 2 * factorial(1) \n                factorial(1) returns 1\n```", "```cpp\n    void f(int i)    { /*does something*/ } \n    void f(double d) { /*does something*/ } \n\n    int main() \n    { \n        void f(double d); \n        f(1); \n        return 0; \n    }\n```", "```cpp\n    void f(int i);\n```", "```cpp\n    f(1); \n    f('c'); \n    f(1.0); // warning of conversion\n```", "```cpp\n    void f(double) = delete; \n\n    void g() \n    { \n        f(1);   // compiles \n        f(1.0); // C2280: attempting to reference a deleted function \n    }\n```", "```cpp\n    // don't allow any more than 100 items \n    bool get_items(int count, vector<int>& values) \n    { \n        if (count > 100) return false; \n        for (int i = 0; i < count; ++i) \n        { \n            values.push_back(i); \n        } \n        return true; \n    }\n```", "```cpp\n    vector<int> items {}; \n    get_items(10, items); \n    for(int i : items) cout << i << ' '; \n    cout << endl\n```", "```cpp\n    bool get_datum(/*out*/ int *pi);\n```", "```cpp\n    int value = 0; \n    if (get_datum(&value)) { cout << \"value is \" << value << endl; } \n    else                   { cout << \"cannot get the value\" << endl;}\n```", "```cpp\n    bool get_data(/*in/out*/ int *psize, /*out*/ int **pi);\n```", "```cpp\n    int size = 10; \n    int *buffer = nullptr; \n    if (get_data(&size, &buffer)) \n    { \n        for (int i = 0; i < size; ++i) \n        { \n            cout << buffer[i] << endl; \n        } \n        delete [] buffer; \n    }\n```", "```cpp\n    int read16(ifstream& stm) \n    { \n        if (stm.eof()) return -1;  \n\n        int flags = cout.flags(); \n        cout << hex; \n        string line; \n\n        // code that changes the line variable \n\n        cout.setf(flags); \n        return line.length(); \n    }\n```", "```cpp\n    // values over zero are error codes \n    int get_status() \n    { \n        int status = 0;  \n        // code that checks the state of data is valid \n        return status; \n    }\n```", "```cpp\n    if (get_status > 0) \n    { \n        cout << \"system state is invalid\" << endl; \n    }\n```", "```cpp\n    void *pv = get_status;\n```", "```cpp\n    int get_status()\n```", "```cpp\n    int (*fn)() = get_status;\n```", "```cpp\n    int error_value = fn();\n```", "```cpp\n    using pf1 = int(*)();\n    typedef int(*pf2)();\n```", "```cpp\n    typedef bool(*MyPtr)(MyType*, MyType*);\n```", "```cpp\n    using MyPtr = bool(*)(MyType*, MyType*);\n```", "```cpp\n    using two_ints = void (*)(int, int); \n\n    void do_something(int l, int r){/* some code */} \n\n    void caller() \n    { \n        two_ints fn = do_something; \n        fn(42, 99); \n    }\n```", "```cpp\n    using callback = void(*)(const string&); \n\n    void big_routine(int loop_count, const callback progress) \n    { \n        for (int i = 0; i < loop_count; ++i) \n        { \n            if (i % 100 == 0) \n            { \n                string msg(\"loop \"); \n                 msg += to_string(i); \n                 progress(msg); \n            } \n            // routine \n        } \n    }\n```", "```cpp\n    void monitor(const string& msg) \n    { \n        cout << msg << endl; \n    } \n\n    int main() \n    { \n        big_routine(1000, monitor); \n        return 0; \n    }\n```", "```cpp\n    int maximum(int lhs, int rhs) \n    { \n        return (lhs > rhs) ? lhs : rhs; \n    }\n```", "```cpp\n    unsigned int s1 = 0xffffffff, s2 = 0x7fffffff; \n    unsigned int result = maximum(s1, s2);\n```", "```cpp\n    int maximum(int lhs, int rhs) \n    { \n        return (lhs > rhs) ? lhs : rhs; \n    } \n\n    unsigned maximum(unsigned lhs, unsigned rhs) \n    { \n        return (lhs > rhs) ? lhs : rhs; \n    }\n```", "```cpp\n    int i = maximum(true, 100.99);\n```", "```cpp\n    T maximum(T lhs, T rhs) \n    { \n        return (lhs > rhs) ? lhs : rhs; \n    }\n```", "```cpp\n    template<typename T> \n    T maximum(T lhs, T rhs) \n    { \n        return (lhs > rhs) ? lhs : rhs; \n    }\n```", "```cpp\n    int i = maximum(1, 100);\n    double d = maximum(1.0, 100.0);\n    bool b = maximum(true, false);\n```", "```cpp\n    int i = maximum(true, 100.99);\n```", "```cpp\n    template<typename T, typename U> \n    T maximum(T lhs, U rhs) \n    { \n        return (lhs > rhs) ? lhs : rhs; \n    }\n```", "```cpp\n    cout << maximum(false, 100.99) << endl; // 1 \n    cout << maximum(100.99, false) << endl; // 100.99\n```", "```cpp\n    // call template<typename T> maximum(T,T); \n    int i = maximum<int>(false, 100.99);\n```", "```cpp\n    template<int size, typename T> \n    T* init(T t) \n    { \n        T* arr = new T[size]; \n        for (int i = 0; i < size; ++i) arr[i] = t; \n        return arr; \n    }\n```", "```cpp\n    int *i10 = init<10>(42); \n    for (int i = 0; i < 10; ++i) cout << i10[i] << ' '; \n    cout << endl; \n    delete [] i10;\n```", "```cpp\n    template<typename T, int N> void print_array(T (&arr)[N]) \n    { \n        for (int i = 0; i < N; ++i) \n        { \n            cout << arr[i] << endl; \n        } \n    }\n```", "```cpp\n    int squares[] = { 1, 4, 9, 16, 25 }; \n    print_array(squares);\n```", "```cpp\n    print_array<int,5>(squares);\n```", "```cpp\n    template<typename T> void print_array(T* arr, int size) \n    { \n        for (int i = 0; i < size; ++i) \n        { \n            cout << arr[i] << endl; \n        } \n    } \n\n    template<typename T, int N> inline void print_array(T (&arr)[N]) \n    { \n        print_array(arr, N); \n    }\n```", "```cpp\n    template <typename T> int number_of_bytes(T t) \n    { \n        return sizeof(T); \n    }\n```", "```cpp\n    template<> int number_of_bytes<const char *>(const char *str) \n    { \n        return strlen(str) + 1; \n    }\n```", "```cpp\n    template<typename T> \n    T maximum(T lhs, T rhs) \n    { \n        return (lhs > rhs) ? lhs : rhs; \n    }\n```", "```cpp\n    template<> bool maximum<bool>(bool lhs, bool rhs) = delete;\n```", "```cpp\n    template<typename T, typename... Arguments>  \n    void func(T t, Arguments... args);\n```", "```cpp\n    template<typename T> void print(T t) \n    { \n        cout << t << endl; \n    } \n\n    template<typename T, typename... Arguments>  \n    void print(T first, Arguments ... next) \n    { \n        print(first); \n        print(next...); \n    }\n```", "```cpp\n    print(1, 2.0, \"hello\", bool);\n```", "```cpp\n    template<typename... Arguments>  \n    void print(Arguments ... args) \n    { \n        int arr [sizeof...(args)] = { args... }; \n        for (auto i : arr) cout << i << endl; \n    }\n```", "```cpp\n    template<typename... Arguments>  \n    void print(Arguments ... args) \n    { \n        int dummy[sizeof...(args)] = { (print(args), 0)... }; \n    }\n```", "```cpp\n    ! & + - * ++ -- ~\n```", "```cpp\n    != == < <= > >= && ||\n    % %= + += - -= * *= / /= & &= | |= ^ ^= << <<= = >> =>>\n    -> ->* ,\n```", "```cpp\n    struct point \n    { \n        int x; \n        int y; \n    };\n```", "```cpp\n    bool operator==(const point& lhs, const point& rhs) \n    { \n        return (lhs.x == rhs.x) && (lhs.y == rhs.y); \n    } \n\n    bool operator!=(const point& lhs, const point& rhs) \n    { \n        return !(lhs == rhs); \n    }\n```", "```cpp\n    point p1{ 1,1 }; \n    point p2{ 1,1 }; \n    cout << boolalpha; \n    cout << (p1 == p2) << endl; // true \n    cout << (p1 != p2) << endl; // false\n```", "```cpp\n    cout << equals(p1,p2) << endl;     // true \n    cout << not_equals(p1,p2) << endl; // false\n```", "```cpp\n    struct point \n    { \n        int x; \n        int y; \n    }; \n\n    ostream& operator<<(ostream& os, const point& pt) \n    { \n        os << \"(\" << pt.x << \",\" << pt.y << \")\"; \n        return os; \n    }\n```", "```cpp\n    point pt{1, 1}; \n    cout << \"point object is \" << pt << endl;\n```", "```cpp\n    modulus<int> fn; \n    cout << fn(10, 2) << endl;\n```", "```cpp\n    cout << fn.operator()(10, 2) << endl;\n```", "```cpp\n    // #include <algorithm> \n    // #include <functional> \n\n    vector<int> v1 { 1, 2, 3, 4, 5 }; \n    vector<int> v2(v1.size()); \n    fill(v2.begin(), v2.end(), 2); \n    vector<int> result(v1.size()); \n\n    transform(v1.begin(), v1.end(), v2.begin(), \n        result.begin(), modulus<int>()); \n\n    for (int i : result) \n    { \n        cout << i << ' '; \n    } \n    cout << endl;\n```", "```cpp\n    result = v1 % v2;\n```", "```cpp\n    transform(v1.begin(), v1.end(),  \n       v2.begin(), result.begin(), modulus<int>());\n```", "```cpp\n    bool equals_zero(int a) \n    { \n        return (a == 0); \n    }\n```", "```cpp\n    int zeros = count_if( \n       result.begin(), result.end(), equals_zero);\n```", "```cpp\n    template<typename T, T value> \n    inline bool equals(T a) \n    { \n        return a == value; \n    }\n```", "```cpp\n    int zeros = count_if( \n       result.begin(), result.end(), equals<int, 0>);\n```", "```cpp\n    int zeros = count_if( \n       result.begin(), result.end(), bind2nd(equal_to<int>(), 0));\n```", "```cpp\n    auto less_than_10 = [](int a) {return a < 10; }; \n    bool b = less_than_10(4);\n```", "```cpp\n    int limit = 99; \n    auto less_than = [limit](int a) {return a < limit; };\n```", "```cpp\n    auto incr = [] { static int i; return ++i; }; \n    incr(); \n    incr(); \n    cout << incr() << endl; // 3\n```", "```cpp\n    auto swap = [](int& a, int& b) { int x = a; a = b; b = x; }; \n    int i = 10, j = 20; \n    cout << i << \" \" << j << endl; \n    swap(i, j); \n    cout << i << \" \" << j << endl;\n```", "```cpp\n    vector<int> v { 1, 2, 3, 4, 5 }; \n    int less_than_3 = count_if( \n       v.begin(), v.end(),  \n       [](int a) { return a < 3; }); \n    cout << \"There are \" << less_than_3 << \" items less than 3\" << endl;\n```", "```cpp\ndir /b /s /os /a-d folder\n```", "```cpp\n    #include <iostream> \n    #include <string> \n    using namespace std; \n\n    int main(int argc, char* argv[]) \n    { \n        if (argc < 2) return 1; \n        return 0; \n    }\n```", "```cpp\n    using namespace std; \n\n    #include <windows.h> struct file_size { unsigned int high; unsigned int low; };\n```", "```cpp\n    #include <string> \n    #include <vector>\n #include <tuple>\n```", "```cpp\n    using file_info = tuple<string, file_size>;\n```", "```cpp\n    void files_in_folder( \n       const char *folderPath, vector<file_info>& files) \n    { \n    }\n```", "```cpp\n    vector<file_info> files; \n    files_in_folder(argv[1], files);\n```", "```cpp\n    string folder(folderPath); \n    folder += \"*\"; \n    WIN32_FIND_DATAA findfiledata {}; \n    void* hFind = FindFirstFileA(folder.c_str(), &findfiledata); \n\n    if (hFind != INVALID_HANDLE_VALUE) \n    { \n       do \n       { \n       } while (FindNextFileA(hFind, &findfiledata)); \n       FindClose(hFind); \n    }\n```", "```cpp\n    string findItem(folderPath); \n    findItem += \"\"; \n    findItem += findfiledata.cFileName; \n    if ((findfiledata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0) \n    { \n        // this is a folder so recurse \n    } \n    else \n    { \n        // this is a file so store information \n    }\n```", "```cpp\n    file_size fs{}; \n    fs.high = findfiledata.nFileSizeHigh; \n    fs.low = findfiledata.nFileSizeLow; \n    files.push_back(make_tuple(findItem, fs));\n```", "```cpp\n    for (auto file : files) \n    { \n        cout << setw(16) << get<1>(file) << \" \"  \n            << get<0>(file) << endl; \n    }\n```", "```cpp\n    ostream& operator<<(ostream& os, const file_size fs) \n    { \n        int flags = os.flags(); \n        unsigned long long ll = fs.low + \n            ((unsigned long long)fs.high << 32); \n        os << hex << ll; \n        os.setf(flags); \n        return os; \n    }\n```", "```cpp\nfiles C:windows\n```", "```cpp\n    // this is a folder so recurse \n    string folder(findfiledata.cFileName); \n    // ignore . and .. directories \n    if (folder != \".\" && folder != \"..\") \n    { \n        files_in_folder(findItem.c_str(), files); \n    }\n```", "```cpp\n    files_in_folder(argv[1], files); \n\n    sort(files.begin(), files.end(), \n        [](const file_info& lhs, const file_info& rhs) { \n            return get<1>(rhs) > get<1>(lhs);    \n    } );\n```", "```cpp\n    bool operator>(const file_size& lhs, const file_size& rhs) \n    { \n        if (lhs.high > rhs.high) return true; \n        if (lhs.high == rhs.high) { \n            if (lhs.low > rhs.low) return true; \n        } \n        return false; \n    }\n```"]