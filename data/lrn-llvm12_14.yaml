- en: '*Chapter 11*: Debugging Using LLVM Tools'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：使用LLVM工具进行调试'
- en: LLVM comes with a set of tools that helps you to identify certain errors in
    your application. All of these tools make use of the LLVM and **Clang** libraries.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM带有一套工具，可帮助您识别应用程序中的某些错误。所有这些工具都使用LLVM和**Clang**库。
- en: In this chapter, you will learn how to instrument an application with **sanitizers**,
    how to use the most common sanitizer to identify a wide range of bugs, and how
    to implement fuzz testing for your application. This will help you to identify
    bugs that are usually not found with unit testing. You will also learn how to
    identify performance bottlenecks in your application, running the **static analyzer**
    to identify problems normally not found by the compiler, and creating your own
    Clang-based tool with which you can extend Clang with new functionality.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用**消毒剂**为应用程序安装仪器，如何使用最常见的消毒剂来识别各种错误，并如何为应用程序实现模糊测试。这将帮助您识别通常无法通过单元测试找到的错误。您还将学习如何识别应用程序中的性能瓶颈，运行**静态分析器**以识别通常无法通过编译器找到的问题，并创建自己的基于Clang的工具，以便您可以扩展Clang的新功能。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Instrumenting an application with sanitizers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用消毒剂为应用程序安装仪器
- en: Finding bugs with **libFuzzer**
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**libFuzzer**查找错误
- en: Performance profiling with **XRay**
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**XRay**进行性能分析
- en: Checking the source with the **Clang Static Analyzer**
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Clang静态分析器**检查源代码
- en: Creating your own Clang-based tool
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自己的基于Clang的工具
- en: By the end of the chapter, you will know how to use various LLVM and Clang tools
    to identify a large category of errors in an application. You will also acquire
    the knowledge to extend Clang with new functionality, for example, to enforce
    a naming convention or to add new source analysis.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将了解如何使用各种LLVM和Clang工具来识别应用程序中的大量错误类别。您还将获得扩展Clang的知识，例如强制执行命名约定或添加新的源分析功能。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To create the **flame graph** in the *Performance profiling with XRay* section,
    you need to install the scripts from [https://github.com/brendangregg/FlameGraph](https://github.com/brendangregg/FlameGraph).
    Some systems, such as **Fedora** and **FreeBSD**, provide a package for these
    scripts, which you can also use.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要在*使用XRay进行性能分析*部分创建**火焰图**，您需要从[https://github.com/brendangregg/FlameGraph](https://github.com/brendangregg/FlameGraph)安装脚本。一些系统，如**Fedora**和**FreeBSD**，提供了这些脚本的软件包，您也可以使用它们。
- en: To view the **Chrome visualization** in the same section, you need to have the
    **Chrome** browser installed. You can download the browser from [https://www.google.com/chrome/](https://www.google.com/chrome/),
    or use the package manager of your system to install the Chrome browser. The code
    files for the chapter are available at [https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter11](https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter11)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要在同一部分查看**Chrome可视化**，您需要安装**Chrome**浏览器。您可以从[https://www.google.com/chrome/](https://www.google.com/chrome/)下载浏览器，或者使用系统的软件包管理器安装Chrome浏览器。本章的代码文件可在[https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter11](https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter11)找到
- en: You can find the code in action videos at [https://bit.ly/3nllhED](https://bit.ly/3nllhED)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://bit.ly/3nllhED](https://bit.ly/3nllhED)找到代码的实际操作视频
- en: Instrumenting an application with sanitizers
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用消毒剂为应用程序安装仪器
- en: LLVM comes with a couple of `compiler-rt` project. Sanitizers can be enabled
    in Clang, which makes them very comfortable to use. In the following sections,
    we will have a look at the available sanitizers, namely, `address`, `memory`,
    and `thread`. We will first look at the `address` sanitizer.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM带有一些`compiler-rt`项目。消毒剂可以在Clang中启用，这使它们非常方便使用。在接下来的章节中，我们将看一下可用的消毒剂，即“地址”，“内存”和“线程”。我们将首先看一下“地址”消毒剂。
- en: Detecting memory access problems with the address sanitizer
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用地址消毒剂检测内存访问问题
- en: You use the `address` sanitizer to detect a couple of memory access bugs in
    an application. This includes common errors such as using dynamically allocated
    memory after freeing it, or writing to dynamically allocated memory outside the
    boundaries of the allocated memory.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用“地址”消毒剂来检测应用程序中的一些内存访问错误。这包括常见错误，如在释放动态分配的内存后继续使用它，或者在分配的内存边界之外写入动态分配的内存。
- en: When enabled, the `address` sanitizer replaces calls to the `malloc()` and `free()`
    functions with its own version, and instruments all memory access with a checking
    guard. Of course, this adds a lot of overhead to the application, and you will
    use the `address` sanitizer only during the testing phase of the application.
    If you are interested in the implementation details, then you can find the source
    of the pass in the `llvm/lib/Transforms/Instrumentation/AddressSanitzer.cpp` file
    and a description of the algorithm used at [https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm](https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 启用“地址”消毒剂后，它将使用自己的版本替换对`malloc()`和`free()`函数的调用，并使用检查保护仪器化所有内存访问。当然，这会给应用程序增加很多开销，您只会在应用程序的测试阶段使用“地址”消毒剂。如果您对实现细节感兴趣，可以在`llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp`文件中找到该传递的源代码，以及在[https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm](https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm)上找到的算法描述。
- en: 'Let''s run a short example to demonstrate the capabilities of the `address`
    sanitizer. The following example application, `outofbounds.c`, allocates `12`
    bytes of memory, but initializes `14` bytes:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行一个简短的示例来演示“地址”消毒剂的功能。以下示例应用程序“outofbounds.c”分配了`12`字节的内存，但初始化了`14`字节：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can compile and run this application without noticing any problems. This
    is typical for this kind of error. Even in larger applications, this kind of bug
    can go unnoticed for a long time. But, if you enable the `address` sanitizer with
    the `-fsanitize=address` option, then the application stops after detecting the
    error.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以编译并运行此应用程序，而不会注意到任何问题。这对于这种类型的错误是典型的。即使在更大的应用程序中，这种错误也可能长时间不被注意到。但是，如果您使用`-fsanitize=address`选项启用`address`检测器，那么应用程序在检测到错误后会停止。
- en: 'It is also useful to enable debug symbols with the `–g` option, because it
    helps to identify the location of the error in the source. The following code
    is an example of how to compile the source file with the `address` sanitizer and
    debug symbols enabled:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 启用`-g`选项的调试符号也很有用，因为它有助于确定源代码中错误的位置。以下代码是一个使用`address`检测器和启用调试符号编译源文件的示例：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, you get a lengthy error report when running the application:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当运行应用程序时，您会得到一个冗长的错误报告：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The report also contains detailed information about the memory content. The
    important information is the type of error – `address` sanitizer intercepts the
    execution of the application. It shows *line 6* in the `outofbounds.c` file, which
    is the line containing the call to `memset()` – indeed, the exact place where
    the buffer overflow happens.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 报告还包含有关内存内容的详细信息。重要信息是错误的类型-`address`检测器拦截应用程序的执行。它显示了`outofbounds.c`文件中的*第6行*，其中包含对`memset()`的调用-确实是发生缓冲区溢出的确切位置。
- en: 'If you replace the line containing `memset(p, 0, 14);` in the `outofbounds.c`
    file with the following code, then you introduce access to memory after the memory
    is freed. You''ll need to store the source in the `useafterfree.c` file:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将`outofbounds.c`文件中包含`memset(p, 0, 14);`的行替换为以下代码，则会在释放内存后访问内存。您需要将源代码保存在`useafterfree.c`文件中：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Again, if you compile and run it, the use of the pointer after the memory is
    free is detected:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果您编译并运行它，将检测到在释放内存后使用指针：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This time, the report points to *line 8*, which contains dereferencing of the
    `p` pointer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，报告指向包含对`p`指针的解引用的*第8行*。
- en: 'On `ASAN_OPTIONS` environment variable to the value `detect_leaks=1` before
    running the application, then you also get a report about memory leaks. On the
    command line, you do this as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行应用程序之前，将`ASAN_OPTIONS`环境变量设置为值`detect_leaks=1`，然后您还会收到有关内存泄漏的报告。在命令行上，您可以这样做：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `address` sanitizer is very useful, because it catches a category of bugs
    that are otherwise difficult to detect. The `memory` sanitizer does a similar
    task, and we'll look at it in the next section.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`address`检测器非常有用，因为它捕获了一类难以检测的错误。`memory`检测器执行类似的任务，我们将在下一节中看到。'
- en: Finding uninitialized memory access with the memory sanitizer
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`memory`检测器查找未初始化的内存访问
- en: Using uninitialized memory is another category of bugs that are hard to find.
    In **C** and **C++**, the general memory allocation routines do not initialize
    the memory buffer with a default value. The same is true for automatic variables
    on the stack.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用未初始化的内存是另一类难以发现的错误。在**C**和**C++**中，一般的内存分配例程不会使用默认值初始化内存缓冲区。对于堆栈上的自动变量也是如此。
- en: There are lots of opportunities for errors, and the `memory` sanitizer helps
    to find the bugs. If you are interested in the implementation details, you can
    find the source for the `memory` sanitizer pass in the `llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp`
    file. The comment at top of the file explains the ideas behind the implementation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多错误的机会，`memory`检测器有助于找到这些错误。如果您对实现细节感兴趣，可以在`llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp`文件中找到`memory`检测器传递的源代码。文件顶部的注释解释了实现背后的思想。
- en: 'Let''s run a small example and save the following source as the `memory.c`
    file. You should note that the `x` variable is not initialized, but is used as
    a `return` value:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行一个小例子，并将以下源代码保存为`memory.c`文件。您应该注意到`x`变量没有初始化，但被用作`return`值：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Without the sanitizer, the application will run just fine. However, you will
    get an error report if you use the `-fsanitize=memory` option:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有检测器，应用程序将正常运行。但是，如果使用`-fsanitize=memory`选项，则会收到错误报告：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Like the `address` sanitizer, the `memory` sanitizer stops the application at
    the first found error.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与`address`检测器一样，`memory`检测器会在发现第一个错误时停止应用程序。
- en: In the next section, we look at how we can use the `thread` sanitizer to detect
    data races in multi-threaded applications.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看如何使用`thread`检测器来检测多线程应用程序中的数据竞争。
- en: Pointing out data races with the thread sanitizer
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`thread`检测器指出数据竞争
- en: To leverage the power of modern CPUs, applications now use multiple threads.
    This is a powerful technique, but it also introduces new sources of errors. A
    very common problem in multi-threaded applications is that access to global data
    is not protected, for example, with a `thread` sanitizer can detect data races
    in `llvm/lib/Transforms/Instrumentation/ThreadSanitize.cpp` file.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用现代CPU的强大功能，应用程序现在使用多个线程。这是一种强大的技术，但也引入了新的错误来源。多线程应用程序中的一个非常常见的问题是对全局数据的访问没有受到保护，例如，`thread`检测器可以在`llvm/lib/Transforms/Instrumentation/ThreadSanitize.cpp`文件中检测到数据竞争。
- en: 'To demonstrate the functionality of the `thread` sanitizer, we will create
    a very simple producer/consumer-style application. The producer thread increments
    a global variable, while the consumer thread decrements the same variable. The
    access to the global variable is not protected, so this is clearly a data race.
    You''ll need to save the following source in the `thread.c` file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示`thread`检测器的功能，我们将创建一个非常简单的生产者/消费者风格的应用程序。生产者线程增加全局变量，而消费者线程减少相同的变量。对全局变量的访问没有受到保护，因此这显然是数据竞争。您需要将以下源代码保存在`thread.c`文件中：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: From the preceding code, the `data` variable is shared between two threads.
    Here, it is of the `int` type to make the example simple. Most often, a data structure
    such as the `std::vector` class or similar would be used. These two threads run
    the `producer()` and `consumer()` functions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，`data`变量在两个线程之间共享。在这里，它是`int`类型，以使示例简单化。通常情况下，会使用诸如`std::vector`类或类似的数据结构。这两个线程运行`producer()`和`consumer()`函数。
- en: The `producer()` function only increments the `data` variable, while the `consumer()`
    function decrements it. No access protection is implemented, so this constitutes
    a data race. The `main()` function starts both threads with the `pthread_create()`
    function, waits for the end of the threads with the `pthread_join()` function,
    and returns the current value of the `data` variable.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`producer()`函数只增加`data`变量，而`consumer()`函数减少它。未实现访问保护，因此这构成了数据竞争。`main()`函数使用`pthread_create()`函数启动两个线程，使用`pthread_join()`函数等待线程结束，并返回`data`变量的当前值。'
- en: If you compile and run this application, then you will note no error; that is,
    the return value is always 0\. An error, in this case, a return value not equal
    to 0, will show up if the number of loops performed is increased by a factor of
    100\. Then, you'll see other values showing up.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您编译并运行此应用程序，那么您将注意到没有错误；也就是说，返回值始终为0。在这种情况下，如果循环执行的次数增加了100倍，就会出现错误，即返回值不等于0。然后，您会看到其他值出现。
- en: 'You use the `thread` sanitizer to identify the data race. To compile with the
    `thread` sanitizer being enabled, you''ll need to pass the `-fsanitize=thread`
    option to Clang. Adding debug symbols with the `–g` option gives you line numbers
    in the report, which helps a lot. Note that you also need to link the `pthread`
    library:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`thread` sanitizer来识别数据竞争。要启用带有`thread` sanitizer的编译，您需要向Clang传递`-fsanitize=thread`选项。使用`-g`选项添加调试符号可以在报告中给出行号，这非常有帮助。请注意，您还需要链接`pthread`库：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The report points us to *lines 6* and *11* of the source file, where the global
    variable is accessed. It also shows that two threads, named *T1* and *T2*, accessed
    the variable, as well as the file and line number of the respective calls to the
    `pthread_create()` function.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 报告指出了源文件的*第6行*和*第11行*，在这里全局变量被访问。它还显示了两个名为*T1*和*T2*的线程访问了该变量，以及各自调用`pthread_create()`函数的文件和行号。
- en: In this section, we learned how to use three sanitizers to identify common problems
    in applications. The `address` sanitizer helps us to identify common memory access
    errors, such as out-of-bounds access or using memory after being freed. Using
    the `memory` sanitizer, we can find accesses to uninitialized memory, and the
    `thread` sanitizer helps us to identify data races.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用三种sanitizer来识别应用程序中的常见问题。`address` sanitizer帮助我们识别常见的内存访问错误，例如越界访问或在释放后使用内存。使用`memory`
    sanitizer，我们可以找到对未初始化内存的访问，而`thread` sanitizer则帮助我们识别数据竞争。
- en: In the next section, we try to trigger the sanitizers by running our application
    on random data, called **fuzz testing**.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将尝试通过在随机数据上运行我们的应用程序来触发sanitizers，称为**模糊测试**。
- en: Finding bugs with libFuzzer
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用libFuzzer查找错误
- en: To test your application, you'll need to write **unit tests**. This is a great
    way to make sure your software behaves correctly. However, due to the exponential
    number of possible inputs, you'll probably miss certain weird inputs, and a few
    bugs as well.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试您的应用程序，您需要编写**单元测试**。这是确保软件行为正确的好方法。但是，由于可能输入的数量呈指数增长，您可能会错过某些奇怪的输入，以及一些错误。
- en: '**Fuzz testing** can help here. The idea is to present your application with
    randomly generated data, or data based on valid input but with random changes.
    This is done over and over again, and so your application is tested with a large
    number of inputs. This is a very powerful testing approach. Literally hundreds
    of bugs in web browsers and other software have been found with fuzz testing.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**模糊测试**可以在这里帮助。其思想是向应用程序提供随机生成的数据，或者基于有效输入但带有随机更改的数据。这样一遍又一遍地进行，因此您的应用程序将被大量输入进行测试。这是一种非常强大的测试方法。几乎所有浏览器和其他软件中的数百个错误都是通过模糊测试发现的。'
- en: LLVM comes with its own fuzz testing library. Originally part of the LLVM core
    libraries, the `compiler-rt`. The library is designed to test small and fast functions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM自带其自己的模糊测试库。最初是LLVM核心库的一部分，名为`compiler-rt`。该库旨在测试小型和快速函数。
- en: 'Let''s run a small example. You''ll need to provide the `LLVMFuzzerTestOneInput()`
    function. This function is called by the `fuzzer.c` file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行一个小例子。您需要提供`LLVMFuzzerTestOneInput()`函数。该函数由`fuzzer.c`文件调用：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: From the preceding code, the `count()` function counts the number of digits
    in the memory pointed to by the `Data` variable. The size of the data is only
    checked to determine whether there are any bytes available. Inside the `while`
    loop, the size is not checked.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，`count()`函数计算`Data`变量指向的内存中的数字数量。仅检查数据的大小以确定是否有任何可用字节。在`while`循环内，未检查大小。
- en: Used with normal `0` byte. The `LLVMFuzzerTestOneInput()` function is the so-called
    `0`, which is currently the only allowed value.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正常的`0`字节。`LLVMFuzzerTestOneInput()`函数是所谓的`0`，目前是唯一允许的值。
- en: 'To compile the file with libFuzzer, you add the `-fsanitize=fuzzer` option.
    The recommendation is to also enable the `address` sanitizer and the generation
    of debug symbols. Use the following command to compile the file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用libFuzzer编译文件，您需要添加`-fsanitize=fuzzer`选项。建议还启用`address` sanitizer和生成调试符号。使用以下命令编译文件：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When you run the test, a lengthy report is emitted. The report contains more
    information than a stack trace, so let''s have a closer look at it:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试时，会生成一个冗长的报告。该报告包含的信息比堆栈跟踪更多，因此让我们仔细看一下：
- en: 'The first line tells you the seed that was used to initialize the random number
    generator. You can use the `–seed=` option to repeat this execution:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一行告诉您用于初始化随机数生成器的种子。您可以使用`–seed=`选项重复此执行：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'By default, libFuzzer limits inputs to at most 4,096 bytes. You can change
    the default by using the `–max_len=` option:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，libFuzzer将输入限制为最多4,096字节。您可以使用`–max_len=`选项更改默认值：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we run the test without providing sample input. The set of all sample
    inputs is called the corpus, and it is empty for this run:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们在不提供样本输入的情况下运行测试。所有样本输入的集合称为语料库，在此运行中为空：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Some information about the generated test data will follow. It shows you that
    `28` inputs were tried and `6` inputs, with a combined length of `19` bytes, were
    found, which together cover `6` coverage points or basic blocks:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随后将提供有关生成的测试数据的一些信息。它向您显示尝试了`28`个输入，找到了`6`个输入，总长度为`19`字节，这些输入一共覆盖了`6`个覆盖点或基本块：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After this, a buffer overflow was detected, and it follows the information
    from the `address` sanitizer. Lastly, the report tells you where the input causing
    the buffer overflow is saved:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，检测到缓冲区溢出，并且随后是来自`address`消毒剂的信息。最后，报告向您指出导致缓冲区溢出的输入的位置：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With the saved input, you can execute the test case with just the crashing
    input again:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有了保存的输入，您可以再次执行带有崩溃输入的测试用例：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is obviously a great help to identify the problem. Only, using random data
    is often not very helpful. If you try to fuzz test the `tinylang` lexer or parser,
    then pure random data leads to immediate rejection of the input, because no valid
    token can be found.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然对于识别问题非常有帮助。但是，使用随机数据通常并不是非常有用。如果尝试对`tinylang`词法分析器或解析器进行模糊测试，那么纯随机数据会导致立即拒绝输入，因为找不到有效的标记。
- en: In such cases, it is more useful to provide a small set of valid input, called
    the corpus. Then, the files of the corpus are randomly mutated and used as input.
    You can think of the input as mostly valid, with just a few bits flipped. This
    also works great with other input, which must have a certain format. For example,
    for a library processing **JPEG** and **PNG** files, you will provide some small
    **JPEG** and **PNG** files as the corpus.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，提供一小组有效输入（称为语料库）更有用。然后，语料库的文件将被随机变异并用作输入。您可以将输入视为大多数有效，只是有一些位被翻转。这也适用于其他必须具有特定格式的输入。例如，对于处理**JPEG**和**PNG**文件的库，您将提供一些小的**JPEG**和**PNG**文件作为语料库。
- en: 'You can save the corpus files in one or more directories and you can create
    a simple corpus for your fuzz test with the help of the `printf` command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将语料库文件保存在一个或多个目录中，并且可以使用`printf`命令为模糊测试创建一个简单的语料库：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When running the test, you will provide the directory on the command line:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行测试时，您将在命令行上提供目录：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The corpus is then used as the base for generating random input, as the report
    tells you:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，语料库被用作生成随机输入的基础，正如报告所告诉您的那样：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you are testing a function that works on tokens or other magic values, such
    as a programming language, then you can speed up the process by providing a dictionary
    with the tokens. For a programming language, the dictionary would contain all
    the keywords and special symbols used in the language. The dictionary definitions
    follow a simple key-value style. For example, to define the `if` keyword in the
    dictionary, you can add the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要测试的函数处理标记或其他魔术值，比如编程语言，那么可以通过提供包含标记的字典来加快该过程。对于编程语言，字典将包含语言中使用的所有关键字和特殊符号。字典定义遵循简单的键值样式。例如，要在字典中定义`if`关键字，可以添加以下内容：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: However, the key is optional and can be left out. You can then specify the dictionary
    file on the command line with the `–dict=` option. In the next section, we'll
    get to know the limitations and alternatives for the libFuzzer implementation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，密钥是可选的，可以省略。然后，您可以使用`–dict=`选项在命令行上指定字典文件。在下一节中，我们将了解libFuzzer实现的限制和替代方案。
- en: Limitations and alternatives
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制和替代方案
- en: 'The libFuzzer implementation is fast but poses a number of restrictions on
    the test target. They are as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: libFuzzer实现速度快，但对测试目标有一些限制。它们如下：
- en: The function under test must accept the input as an array in memory. Some library
    functions require a file path to the data instead, and they cannot be tested with
    libFuzzer.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试函数必须将输入作为内存中的数组接受。一些库函数需要数据的文件路径，因此无法使用libFuzzer进行测试。
- en: The `exit()` function should not be called.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不应调用`exit()`函数。
- en: The global state should not be altered.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不应更改全局状态。
- en: Hardware random number generators should not be used.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不应使用硬件随机数生成器。
- en: From the aforementioned restrictions, the first two restrictions are an implication
    of the implementation of libFuzzer as a library. The latter two restrictions are
    needed to avoid confusion in the evaluation algorithm. If one of these restrictions
    is not met, then two identical calls to the fuzz target can give different results.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述限制中，前两个限制是libFuzzer作为库的实现的含义。后两个限制是为了避免评估算法中的混淆。如果这些限制中的一个未满足，那么对模糊目标的两个相同调用可能会产生不同的结果。
- en: The best-known alternative tool for fuzz testing is **AFL**, found at [https://github.com/google/AFL](https://github.com/google/AFL).
    AFL needs an instrumented binary (an LLVM plugin for instrumentation is provided)
    and requires the application to take the input as the file path on the command
    line. AFL and libFuzzer can share the same corpus and the same dictionary files.
    Thus, it is possible to test an application with both tools. In cases where libFuzzer
    is not applicable, AFL may be a good alternative.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试的最佳替代工具是**AFL**，位于[https://github.com/google/AFL](https://github.com/google/AFL)。AFL需要一个被插装的二进制文件（提供了一个用于插装的LLVM插件），并要求应用程序在命令行上以文件路径形式接受输入。AFL和libFuzzer可以共享相同的语料库和相同的字典文件。因此，可以使用这两种工具测试应用程序。在libFuzzer不适用的情况下，AFL可能是一个很好的替代方案。
- en: There are many more ways of influencing the way libFuzzer works. You can read
    the reference page at [https://llvm.org/docs/LibFuzzer.html](https://llvm.org/docs/LibFuzzer.html)
    for more details.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他影响libFuzzer工作方式的方法。您可以阅读[https://llvm.org/docs/LibFuzzer.html](https://llvm.org/docs/LibFuzzer.html)上的参考页面以获取更多详细信息。
- en: In the next section, we look at a totally different problem an application can
    have; we try to identify performance bottlenecks.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看一个应用程序可能遇到的完全不同的问题；我们尝试识别性能瓶颈。
- en: Performance profiling with XRay
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用XRay进行性能分析
- en: If your application seems to run slow, then you might want to know where all
    the time is spent in the code. In this case, instrumenting the code with `llvm/lib/XRay/`
    directory. The runtime portion is part of `compiler-rt`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序似乎运行缓慢，那么你可能想知道代码中花费了多少时间。在这种情况下，使用`llvm/lib/XRay/`目录对代码进行仪器化。运行时部分是`compiler-rt`的一部分。
- en: 'In the following example source, real work is simulated by calling the `usleep()`
    function. The `func1()` function sleeps for 10 µs. The `func2()` function either
    calls `func1()` or sleeps for 100 µs, depending on whether the `n` parameter is
    odd or even. Inside the `main()` function, both functions are called inside a
    loop. This is already enough to get interesting information. You''ll need to save
    the following source code in the `xraydemo.c` file:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例源代码中，通过调用`usleep()`函数来模拟真实工作。`func1()`函数休眠10微秒。`func2()`函数根据`n`参数是奇数还是偶数，要么调用`func1()`，要么休眠100微秒。在`main()`函数内，这两个函数都在一个循环中被调用。这已经足够获取有趣的信息了。你需要将以下源代码保存在`xraydemo.c`文件中：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To enable the XRay instrumentation during compilation, you will need to specify
    the `-fxray-instrument` option. Functions with less than 200 instructions are
    not instrumented. This is an arbitrary threshold defined by the developers, and
    in our case, the functions would not be instrumented. The threshold can be specified
    with the `-fxray-instruction-threshold=` option. Alternatively, we can add a function
    attribute to control whether a function should be instrumented. For example, adding
    the following prototype would result in always instrumenting the function:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要在编译期间启用XRay仪器化，你需要指定`-fxray-instrument`选项。少于200条指令的函数不会被仪器化。这是开发人员定义的一个任意阈值，在我们的情况下，这些函数不会被仪器化。阈值可以通过`-fxray-instruction-threshold=`选项指定。另外，我们可以添加一个函数属性来控制是否应该对函数进行仪器化。例如，添加以下原型将导致始终对函数进行仪器化：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Likewise, by using the `xray_never_instrument` attribute, you can turn off instrumentation
    for a function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，通过使用`xray_never_instrument`属性，你可以关闭对函数的仪器化。
- en: 'We will now use the command-line option and compile the `xraydemo.c` file as
    follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用命令行选项并按以下方式编译`xraydemo.c`文件：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the resulting binary, instrumentation is turned off by default. If you run
    the binary, you will note no difference to a not-instrumented binary. The `XRAY_OPTIONS`
    environment variable is used to control the recording of runtime data. To enable
    data collection, you run the application as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成的二进制文件中，默认情况下关闭了仪器。如果你运行这个二进制文件，你会注意到与未经仪器化的二进制文件没有任何区别。`XRAY_OPTIONS`环境变量用于控制运行时数据的记录。要启用数据收集，你需要按照以下方式运行应用程序：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `xray_mode=xray-basic` option tells the runtime that we want to use basic
    mode. In this mode, all runtime data is collected, which can result in huge log
    files. When the `patch_premain=true` option is given, then functions that are
    run before the `main()` function are instrumented, too.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`xray_mode=xray-basic`选项告诉运行时我们要使用基本模式。在这种模式下，会收集所有运行时数据，这可能会导致巨大的日志文件。当给出`patch_premain=true`选项时，那么在`main()`函数之前运行的函数也会被仪器化。'
- en: After running this command, you see a new file in the directory, in which the
    collected data is stored. You need to use the `llvm-xray` tool to extract readable
    information from this file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个命令后，你会在目录中看到一个新文件，其中存储了收集到的数据。你需要使用`llvm-xray`工具从这个文件中提取可读的信息。
- en: 'The `llvm-xray` tool supports various subcommands. You use the `account` subcommand
    to extract some basic statistics. For example, to get the top 10 most called functions,
    you add the `-top=10` option to limit the output, and the `-sort=count` option
    to specify the function call count as the sort criteria. You can influence the
    sort order with the `-sortorder=` option. Run the following command to get the
    statistic:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`llvm-xray`工具支持各种子命令。你可以使用`account`子命令来提取一些基本统计信息。例如，要获取前10个最常调用的函数，你可以添加`-top=10`选项来限制输出，并使用`-sort=count`选项来指定函数调用计数作为排序标准。你可以使用`-sortorder=`选项来影响排序顺序。运行以下命令来获取统计信息：'
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can see that the `func1()` function is called most often, as well as the
    accumulated time spent in this function. The example only has three functions,
    so the `–top=` option has no visible effect here, but for real applications, it
    is very useful.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`func1()`函数被调用最频繁，以及在这个函数中累积的时间。这个示例只有三个函数，所以`-top=`选项在这里没有明显的效果，但对于真实的应用程序来说，它非常有用。
- en: 'From the collected data, it is possible to reconstruct all the stack frames
    that occurred during runtime. You use the `stack` subcommand to view the top 10
    stacks. The output shown here is reduced for brevity:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 从收集到的数据中，可以重构出运行时发生的所有堆栈帧。你可以使用`stack`子命令来查看前10个堆栈。这里显示的输出已经为了简洁起见进行了缩减：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: A `func2()` function is called by the `main()` function, and this is the stack
    frame with the largest accumulated time. The depth depends on how many functions
    are called, and the stack frames are usually large.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数调用了`func2()`函数，这是累积时间最长的堆栈帧。深度取决于调用了多少函数，堆栈帧通常很大。'
- en: This subcommand can also be used to create a `flamegraph.pl` script, you convert
    the data into a **Scalable Vector Graphics** (**SVG**) file, which you can view
    in your browser.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个子命令也可以用来创建一个`flamegraph.pl`脚本，将数据转换成**可伸缩矢量图形**（**SVG**）文件，你可以在浏览器中查看。
- en: 'With the following command, you instruct `llvm-xray` to output all stack frames
    with the `–all-stacks` option. Using the `–stack-format=flame` option, the output
    is in the format expected by the `flamegraph.pl` script. With the `–aggregation-type`
    option, you can choose whether stack frames are aggregated by total time or by
    the number of invocations. The output of `llvm-xray` is piped into the `flamegraph.pl`
    script, and the resulting output is saved in the `flame.svg` file:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令，您可以指示`llvm-xray`使用`-all-stacks`选项输出所有堆栈帧。使用`-stack-format=flame`选项，输出格式符合`flamegraph.pl`脚本的预期格式。使用`-aggregation-type`选项，您可以选择堆栈帧是按总时间还是按调用次数进行聚合。`llvm-xray`的输出被导入`flamegraph.pl`脚本，并将结果输出保存在`flame.svg`文件中：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Open the generated `flame.svg` file in your browser. The graphic looks as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开生成的`flame.svg`文件。图形如下所示：
- en: '![Figure 11.1 – Flame graph produced by llvm-xray'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.1 - 由llvm-xray生成的火焰图'
- en: '](img/Figure_11.1_B15647.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.1_B15647.jpg)'
- en: Figure 11.1 – Flame graph produced by llvm-xray
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 - 由llvm-xray生成的火焰图
- en: Flame graphs can be confusing at the first look, because the *x* axis does not
    have the usual meaning of elapsed time. Instead, the functions are simply sorted
    by name. The colors are chosen to have good contrast and have no other meaning.
    From the preceding graph, you can easily determine the call hierarchy and the
    time spent in a function.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 火焰图乍一看可能会令人困惑，因为*x*轴没有经过的时间的通常含义。相反，函数只是按名称排序。颜色选择是为了具有良好的对比度，并没有其他含义。从前面的图表中，您可以轻松确定调用层次结构和函数中所花费的时间。
- en: Information about a stack frame is displayed only after you move the mouse cursor
    over the rectangle representing the frame. With a mouse click on the frame, you
    can zoom into this stack frame. Flame graphs are of great help if you want to
    identify functions worth optimizing. To find out more about flame graphs, please
    visit the website of Brendan Gregg, the inventor of flame graphs, [http://www.brendangregg.com/flamegraphs.html](http://www.brendangregg.com/flamegraphs.html).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 关于堆栈帧的信息只有在将鼠标光标移动到表示该帧的矩形上方时才显示。单击帧后，您可以放大此堆栈帧。如果您想要识别值得优化的函数，火焰图非常有帮助。要了解更多关于火焰图的信息，请访问火焰图的发明者Brendan
    Gregg的网站[http://www.brendangregg.com/flamegraphs.html](http://www.brendangregg.com/flamegraphs.html)。
- en: 'You can use the `convert` subcommand to convert the data into `.yaml` format
    or into the format used by the `xray.evt` file, you run the following command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`convert`子命令将数据转换为`.yaml`格式或`xray.evt`文件使用的格式，运行以下命令：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you do not specify the `–symbolize` option, then no function names are shown
    in the resulting graph.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不指定`-symbolize`选项，则结果图中不会显示函数名称。
- en: 'Once that is done, open the Chrome browser and type `chrome:///tracing`. Then,
    click on the `xray.evt` file. You will see the following visualization of the
    data:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，打开Chrome浏览器，输入`chrome:///tracing`。然后，单击`xray.evt`文件。您将看到以下数据的可视化：
- en: '![Figure 11.2 – Chrome trace viewer visualization generated by llvm-xray'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.2 - 由llvm-xray生成的Chrome跟踪查看器可视化'
- en: '](img/Figure_11.2_B15647.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.2_B15647.jpg)'
- en: Figure 11.2 – Chrome trace viewer visualization generated by llvm-xray
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 - 由llvm-xray生成的Chrome跟踪查看器可视化
- en: In this view, the stack frames are sorted by the time the function call occurs.
    For further interpretation of the visualization, please read the tutorial at [https://www.chromium.org/developers/how-tos/trace-event-profiling-tool](https://www.chromium.org/developers/how-tos/trace-event-profiling-tool).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在此视图中，堆栈帧按函数调用发生的时间进行排序。要进一步解释可视化，请阅读[https://www.chromium.org/developers/how-tos/trace-event-profiling-tool](https://www.chromium.org/developers/how-tos/trace-event-profiling-tool)上的教程。
- en: Tip
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The `llvm-xray` tool has more functionality. You can read about it on the LLVM
    website at [https://llvm.org/docs/XRay.html](https://llvm.org/docs/XRay.html)
    and [https://llvm.org/docs/XRayExample.html](https://llvm.org/docs/XRayExample.html).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`llvm-xray`工具具有更多功能。您可以在LLVM网站上阅读有关它的信息[https://llvm.org/docs/XRay.html](https://llvm.org/docs/XRay.html)和[https://llvm.org/docs/XRayExample.html](https://llvm.org/docs/XRayExample.html)。'
- en: In this section, we learned how to instrument an application with XRay, how
    to collect runtime information, and how to visualize that data. We can use this
    knowledge to find performance bottlenecks in applications.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用XRay对应用程序进行工具化，如何收集运行时信息以及如何可视化这些数据。我们可以使用这些知识来找出应用程序中的性能瓶颈。
- en: Another approach to identifying errors in an application is to analyze the source
    code, which is done with the static analyzer.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 识别应用程序中的错误的另一种方法是分析源代码，这是由静态分析器完成的。
- en: Checking the source with the Clang Static Analyzer
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Clang静态分析器检查源代码
- en: The **Clang Static Analyzer** is a tool that performs additional checking on
    C, C++, and **Objective C** source code. The checks performed by the static analyzer
    are more thorough than the checks the compiler performs. They are also more costly
    in terms of time and required resources. The static analyzer has a set of checkers
    that check for certain bugs.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**Clang静态分析器**是一种在C、C++和**Objective C**源代码上执行额外检查的工具。静态分析器执行的检查比编译器执行的检查更彻底。它们在时间和所需资源方面也更昂贵。静态分析器具有一组检查器，用于检查特定的错误。'
- en: The tool performs a symbolic interpretation of the source code that looks at
    all the code paths through an application and derives constraints on the values
    used in the application from it. **Symbolic interpretation** is a common technique
    used in compilers, for example, to identify constant values. In the context of
    the static analyzer, the checkers are applied to the derived values.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 该工具对源代码进行符号解释，从中查看应用程序的所有代码路径，并从中推导出应用程序中使用的值的约束。**符号解释**是编译器中常用的技术，例如用于识别常量值。在静态分析器的上下文中，检查器适用于推导出的值。
- en: 'For example, if the divisor of a division is 0, then the static analyzer warns
    about it. We can check this with the following example stored in the `div.c` file:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果除法的除数为0，则静态分析器会发出警告。我们可以通过`div.c`文件中的以下示例进行检查：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The static analyzer will warn about a division by `0` in the example. However,
    when compiling, the file with the `clang -Wall -c div.c` command will show no
    warning.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，静态分析器将警告除以`0`。但是，在编译时，使用`clang -Wall -c div.c`命令编译的文件不会显示警告。
- en: 'There are two ways to invoke the static analyzer from the command line. The
    older tool is `scan-build` tool is the easier solution. You simply pass the `compile`
    command to the tool, and everything else is done automatically:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以从命令行调用静态分析器。较旧的工具是`scan-build`工具是更简单的解决方案。您只需将`compile`命令传递给工具，其他所有操作都会自动完成：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The output on the screen already tells you that a problem was found, that is,
    the checker with the name `core.DivideZero` was triggered. But that is not all.
    You will find a complete report in HTML in the mentioned subdirectory of the `/tmp`
    directory. You can use the `scan-view` command to view the report or open the
    `index.html` file found in the subdirectory in your browser.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上的输出已经告诉您发现了问题，即触发了名为`core.DivideZero`的检查器。但这还不是全部。您将在`/tmp`目录的提到的子目录中找到完整的HTML报告。您可以使用`scan-view`命令查看报告，或者在浏览器中打开子目录中找到的`index.html`文件。
- en: 'The first page of the report shows you a summary of the found bugs:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 报告的第一页显示了找到的错误的摘要：
- en: '![Figure 11.3 – Summary page'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.3 - 摘要页面'
- en: '](img/Figure_11.3_B15647.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.3_B15647.jpg)'
- en: Figure 11.3 – Summary page
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 - 摘要页面
- en: For each found error, the summary page shows the type of the error, the location
    in the source, and the path length after which the analyzer finds the error. A
    link to a detailed report for the error is provided.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个找到的错误，摘要页面显示了错误的类型、源代码中的位置以及分析器发现错误后的路径长度。提供了指向错误详细报告的链接。
- en: 'The following screenshot shows the detailed report for the error:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了错误的详细报告：
- en: '![Figure 11.4 – Detailed report'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.4 - 详细报告'
- en: '](img/Figure_11.4_B15647.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.4_B15647.jpg)'
- en: Figure 11.4 – Detailed report
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 - 详细报告
- en: With the detailed report, you are able to verify the error by following the
    numbered bubbles. In our simple example, it shows in three steps how passing `0`
    as a parameter value leads to a division by zero error.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过详细报告，您可以通过跟随编号的气泡来验证错误。在我们的简单示例中，它显示了通过将`0`作为参数值传递导致除以零错误的三个步骤。
- en: Verification through a human is indeed required. If the derived constraints
    are not precise enough for a certain checker, then false positives are possible,
    that is, an error is reported for perfectly fine code. Based on the report, you
    can identify false positives.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 确实需要通过人来验证。如果派生的约束对于某个检查器不够精确，则可能会出现误报，即对于完全正常的代码报告错误。根据报告，您可以识别出误报。
- en: You are not limited to the checkers that are provided with the tool. You can
    also add new checkers. The next section shows how to do this.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您不仅限于使用工具提供的检查器。您也可以添加新的检查器。下一节将介绍如何执行此操作。
- en: Adding a new checker to the Clang Static Analyzer
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向Clang静态分析器添加新的检查器
- en: To add a new checker to the Clang Static Analyzer, you create a new subclass
    of the `Checker` class. The static analyzer tries all possible paths through the
    code. The analyzer engine generates events at certain points, for example, before
    a function call or after a function call. Your class has to provide callbacks
    for these events if you need to handle them. The `Checker` class and the registrations
    for the events are provided in the `clang/include/clang/StaticAnalyzer/Core/Checker.h`
    header file.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要向Clang静态分析器添加新的检查器，您需要创建`Checker`类的新子类。静态分析器尝试通过代码的所有可能路径。分析引擎在某些点生成事件，例如，在函数调用之前或之后。如果需要处理这些事件，您的类必须为这些事件提供回调。`Checker`类和事件的注册在`clang/include/clang/StaticAnalyzer/Core/Checker.h`头文件中提供。
- en: Usually, a checker needs to track some symbols. But the checker can't manage
    the state, because it does not know which code path the analyzer engine currently
    tries. Therefore, the tracked state must be registered with the engine, and can
    only be changed using a `ProgramStateRef` instance.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，检查器需要跟踪一些符号。但是检查器无法管理状态，因为它不知道分析引擎当前尝试的代码路径。因此，跟踪的状态必须在引擎中注册，并且只能使用`ProgramStateRef`实例进行更改。
- en: Many libraries provide functions that must be used in pairs. For example, the
    C standard library provides the `malloc()` and `free()` functions. The memory
    allocated by the `malloc()` function must be freed exactly one time by the `free()`
    function. Not calling the `free()` function, or calling it several times, is a
    programming error. There are many more instances of this coding pattern, and the
    static analyzer provides checkers for some of them.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 许多库提供必须成对使用的函数。例如，C标准库提供了`malloc()`和`free()`函数。`malloc()`函数分配的内存必须由`free()`函数精确释放一次。不调用`free()`函数或多次调用它都是编程错误。这种编码模式还有许多其他实例，静态分析器为其中一些提供了检查器。
- en: The `iconv` library provides the `iconv_open()` and `iconv_close()` functions,
    which must be used in pairs. You implement a checker to check for this.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`iconv`库提供了`iconv_open()`和`iconv_close()`函数，这两个函数必须成对使用。您可以实现一个检查器来检查这一点。'
- en: To detect the errors, the checker needs to track the descriptor returned from
    the `iconv_open()` function. The analyzer engine returns a `SymbolRef` instance
    for the return value of the `iconv_open()` function. We associate this symbol
    with a state to reflect whether `iconv_close()` was called or not. For the state,
    we create the `IconvState` class, which encapsulates a `bool` value.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测错误，检查器需要跟踪从`iconv_open()`函数返回的描述符。分析引擎为`iconv_open()`函数的返回值返回一个`SymbolRef`实例。我们将此符号与状态关联起来，以反映是否调用了`iconv_close()`。对于状态，我们创建了`IconvState`类，它封装了一个`bool`值。
- en: 'The new `IconvChecker` class needs to handle four events:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`IconvChecker`类需要处理四个事件：
- en: '`PostCall`, which occurs after a function call. After the `iconv_open()` function
    is called, we retrieve the symbol for the return value and remember it as being
    in an open state.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PostCall`，在函数调用之后发生。在调用`iconv_open()`函数之后，我们检索返回值的符号，并记住它处于打开状态。'
- en: '`PreCall`, which occurs before a function call. Before the `iconv_close()`
    function is called, we check whether the symbol for the descriptor is in an open
    state. If not, then the `iconv_close()` function was already called for the descriptor,
    and we have detected a double call to the function.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PreCall`，在函数调用之前发生。在调用`iconv_close()`函数之前，我们检查描述符的符号是否处于打开状态。如果不是，则说明已经为描述符调用了`iconv_close()`函数，我们已经检测到对该函数的双重调用。'
- en: '`DeadSymbols`, which occurs when unused symbols are cleaned up. We check whether
    an unused symbol for a descriptor is still in an open state. If yes, then we have
    detected a missing call to `iconv_close()`, which is a resource leak.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeadSymbols`，当未使用的符号被清理时发生。我们检查未使用的符号是否仍处于打开状态。如果是，则我们已经检测到对`iconv_close()`的缺失调用，这是资源泄漏。'
- en: '`PointerEscape`, which is called when the symbols can no longer be tracked
    by the analyzer. In this case, we remove the symbol from the state, because we
    can no longer reason whether the descriptor was closed or not.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PointerEscape`，当符号不再能被分析器跟踪时调用。在这种情况下，我们从状态中移除符号，因为我们无法再推断描述符是否已关闭。'
- en: 'The new checker is implemented inside the Clang project. Let''s begin with
    adding the new checker to the collection of all checkers, which is the `clang/include/clang/StaticAnalyzer/Checkers/Checkers.td`
    file. Each checker is associated with packages. Our new checker is under development,
    and therefore it belongs in the `alpha` package. The iconv API is a POSIX-standardized
    API, so it also belongs in the `unix` package. Locate the `UnixAlpha` section
    in the `Checkers.td` file and add the following code to register the new `IconvChecker`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 新的检查器是在Clang项目内实现的。让我们从将新的检查器添加到所有检查器的集合开始，这是`clang/include/clang/StaticAnalyzer/Checkers/Checkers.td`文件。每个检查器都与软件包相关联。我们的新检查器正在开发中，因此它属于`alpha`软件包。iconv
    API是一个POSIX标准化的API，因此它也属于`unix`软件包。在`Checkers.td`文件中找到`UnixAlpha`部分，并添加以下代码以注册新的`IconvChecker`：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This adds the new checker to the collection of known **checkers**, sets help
    text for the command-line option, and states that there is no documentation for
    this checker.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这将新的检查器添加到已知**检查器**集合中，为命令行选项设置帮助文本，并声明此检查器没有文档。
- en: 'Next, we implement the checker in the `clang/lib/StaticAnalyzer/Checkers/IconvChecker.cpp`
    file:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在`clang/lib/StaticAnalyzer/Checkers/IconvChecker.cpp`文件中实现检查器：
- en: 'For the implementation, we need to include several header files. The `BuiltinCheckerRegistration.h`
    file is required to register the checker. The `Checker.h` file provides the declaration
    of the `Checker` class and the callbacks for the events. The `CallEvent.h` file
    declares the class used for call events, and the `CheckerContext.h` file is required
    for the declaration of the `CheckerContext` class, which is the central class
    providing access to the state of the analyzer:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于实现，我们需要包括几个头文件。`BuiltinCheckerRegistration.h`文件用于注册检查器。`Checker.h`文件提供了`Checker`类的声明和事件的回调。`CallEvent.h`文件声明了用于调用事件的类，`CheckerContext.h`文件用于声明`CheckerContext`类，它是提供对分析器状态访问的中心类：
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To avoid typing the namespace names, we use the `clang` and `ento` namespaces:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了避免输入命名空间名称，我们使用`clang`和`ento`命名空间：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We associate a state with each symbol representing an iconv descriptor. The
    state can be open or closed, and we use a `bool`-type variable, with the `true`
    value for an open state. The state value is encapsulated in the `IconvState` struct.
    This struct is used with a `FoldingSet` data structure, which is a hash set that
    filters duplicate entries. To be usable with this data structure implementation,
    the `Profile()` method is added here, which sets the unique bits of this struct.
    We put the struct into an anonymous namespace, to avoid pollution of the global
    namespace:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将状态与表示iconv描述符的每个符号关联起来。状态可以是打开或关闭的，我们使用一个`bool`类型的变量，对于打开状态为`true`。状态值封装在`IconvState`结构中。该结构与`FoldingSet`数据结构一起使用，后者是一个过滤重复条目的哈希集。为了使该数据结构实现可用，这里添加了`Profile()`方法，该方法设置了该结构的唯一位。我们将该结构放入匿名命名空间中，以避免全局命名空间的污染。
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `IconvState` struct represents the state of an iconv descriptor, which
    is represented by a symbol of the `SymbolRef` class. This is best done with a
    map, which has the symbol as the key and the state as the value. As explained
    earlier, the checker cannot hold the state. Instead, the state must be registered
    with the global program state, which is done with the `REGISTER_MAP_WITH_PROGRAMSTATE`
    macro. This macro introduces the `IconvStateMap` name, which we use later to access
    the map:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IconvState`结构表示iconv描述符的状态，由`SymbolRef`类的符号表示。这最好通过一个映射来完成，该映射将符号作为键，状态作为值。正如前面所解释的，检查器不能保存状态。相反，状态必须在全局程序状态中注册，这是通过`REGISTER_MAP_WITH_PROGRAMSTATE`宏完成的。此宏引入了`IconvStateMap`名称，我们稍后将使用它来访问映射：'
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We also implement the `IconvChecker` class in an anonymous namespace. The requested
    `PostCall`, `PreCall`, `DeadSymbols`, and `PointerEscape` events are template
    parameters to the `Checker` base class:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还在匿名命名空间中实现了`IconvChecker`类。请求的`PostCall`、`PreCall`、`DeadSymbols`和`PointerEscape`事件是`Checker`基类的模板参数：
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `IconvChecker` class only has fields of the `CallDescription` type, which
    are used to identify `iconv_open()`, `iconv()`, and `iconv_close()` function calls
    in the program:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IconvChecker`类只有`CallDescription`类型的字段，用于识别程序中的`iconv_open()`、`iconv()`和`iconv_close()`函数调用：'
- en: '[PRE38]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `report()` method generates an error report. The important parameters to
    the method are an array of symbols, the type of the bug, and a bug description.
    Inside the method, a bug report is created for each symbol, and the symbol is
    marked as the interesting one for the bug. If a source range is provided as a
    parameter, then this is also added to the report. Finally, the report is emitted:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`report()`方法生成错误报告。该方法的重要参数是符号数组、错误类型和错误描述。在方法内部，为每个符号创建一个错误报告，并将该符号标记为错误的有趣对象。如果提供了源范围作为参数，则也将其添加到报告中。最后，报告被发出：'
- en: '[PRE39]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The constructor of the `IconvChecker` class only initializes the `CallDescription`
    fields using the name of the function:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IconvChecker`类的构造函数只使用函数的名称初始化`CallDescription`字段：'
- en: '[PRE40]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `checkPostCall()` method is called after the analyzer has executed a function
    call. If the executed function is not a global C function and not named `iconv_open`,
    then there is nothing to do:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当分析器执行函数调用后，会调用`checkPostCall()`方法。如果执行的函数不是全局C函数，也不是名为`iconv_open`，那么就没有什么要做的：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Otherwise, we try to get the return value of the function as a symbol. To store
    the symbol with the open state in the global program state, we need to get a `ProgramStateRef`
    instance from the `CheckerContext` instance. The state is immutable, so adding
    the symbol to the state results in a new state. The analyzer engine is informed
    about the new state with a call to the `addTransition()` method:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们尝试将函数的返回值作为符号获取。为了将具有打开状态的符号存储在全局程序状态中，我们需要从`CheckerContext`实例中获取`ProgramStateRef`实例。状态是不可变的，所以将符号添加到状态中会导致新的状态。通过调用`addTransition()`方法，分析器引擎被告知新的状态：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Likewise, the `checkPreCall()` method is called before the analyzer executes
    a function. Only a global C function with the name `iconv_close` is of interest
    to us:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，当分析器执行函数之前，会调用`checkPreCall()`方法。我们只对名为`iconv_close`的全局C函数感兴趣：
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If the symbol for the first argument of the function, which is the iconv descriptor,
    is known, then we retrieve the state of the symbol from the program state:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果函数的第一个参数的符号，也就是iconv描述符，是已知的，那么我们从程序状态中检索符号的状态：
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If the state represents the closed state, then we have detected a double close
    error, and we generate a bug report for it. The call to `generateErrorNode()`
    can return a `nullptr` value if an error report was already generated for this
    path, so we have to check for this situation:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果状态表示关闭状态，那么我们已经检测到了双重关闭错误，并为此生成了一个错误报告。调用`generateErrorNode()`可能会返回`nullptr`值，如果已经为这条路径生成了错误报告，所以我们必须检查这种情况：
- en: '[PRE45]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Otherwise, we set the state for the symbol to closed:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们将符号的状态设置为关闭：
- en: '[PRE46]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `checkDeadSymbols()` method is called to clean up unused symbols. We loop
    over all symbols we track and ask the `SymbolReaper` instance whether the current
    symbol is dead:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`checkDeadSymbols()`方法来清理未使用的符号。我们遍历我们跟踪的所有符号，并询问`SymbolReaper`实例当前的符号是否已经失效：
- en: '[PRE47]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If the symbol is dead, then we need to check the state. If the state is still
    open, then this is a potential resource leak. There is one exception: `iconv_open()`
    returns `-1` in the case of an error. If the analyzer is in a code path handling
    this error, then it is wrong to assume a resource leak, because the function call
    failed. We try to get the value of the symbol from the `ConstraintManager` instance,
    and we do not consider the symbol as a resource leak if this value is `-1`. We
    add a leaked symbol to a `SmallVector` instance, for generating the error report
    later. Finally, we remove the dead symbol from the program state:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果符号已经失效，那么我们需要检查状态。如果状态仍然是打开的，那么这是一个潜在的资源泄漏。有一个例外：`iconv_open()`在错误的情况下返回`-1`。如果分析器在处理此错误的代码路径中，那么假设存在资源泄漏是错误的，因为函数调用失败了。我们尝试从`ConstraintManager`实例中获取符号的值，如果这个值是`-1`，我们就不认为这个符号是资源泄漏。我们将一个泄漏的符号添加到`SmallVector`实例中，以便稍后生成错误报告。最后，我们从程序状态中删除死亡的符号：
- en: '[PRE48]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'After the loop, we call the `generateNonFatalErrorNode()` method. This method
    transitions to the new program state, and returns an error node if there is not
    already an error node for this path. The `LeakedSyms` container holds the (possibly
    empty) list of leaked symbols, and we call the `report()` method to generate an
    error report:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环结束后，我们调用`generateNonFatalErrorNode()`方法。这个方法转换到新的程序状态，并且如果这条路径上还没有错误节点，就返回一个错误节点。`LeakedSyms`容器保存了泄漏符号的（可能为空的）列表，我们调用`report()`方法生成错误报告：
- en: '[PRE49]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `checkPointerEscape()` function is called when the analyzer detects a function
    call for which the parameters cannot be tracked. In such a case, we must assume
    that we do not know whether the iconv descriptor will be closed inside the function
    or not. The only exception is a call to the `iconv()` function, which does the
    conversion and is known to not call the `iconv_close()` function. This finishes
    the implementation of the `IconvChecker` class:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当分析器检测到参数无法被跟踪的函数调用时，会调用`checkPointerEscape()`函数。在这种情况下，我们必须假设我们不知道iconv描述符是否在函数内部关闭。唯一的例外是对`iconv()`函数的调用，它执行转换并且已知不会调用`iconv_close()`函数。这完成了`IconvChecker`类的实现：
- en: '[PRE50]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Lastly, the new checker needs to be registered at a `CheckerManager` instance.
    The `shouldRegisterIconvChecker()` method returns `true` to indicate that `IconvChecker`
    should be registered by default, and the `registerIconvChecker()` method performs
    the registration. Both methods are called via the code generated from the `Checkers.td`
    file:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，新的检查器需要在`CheckerManager`实例中注册。`shouldRegisterIconvChecker()`方法返回`true`，表示`IconvChecker`应该默认注册，`registerIconvChecker()`方法执行注册。这两个方法都是通过从`Checkers.td`文件生成的代码调用的。
- en: '[PRE51]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This finishes the implementation of the new checker. You just need to add the
    filename to the list of source filenames in the `clang/lib/StaticAnalyzer/Checkers/CmakeLists.txt`
    file:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了新检查器的实现。您只需要将文件名添加到`clang/lib/StaticAnalyzer/Checkers/CmakeLists.txt`文件中的源文件名列表中：
- en: '[PRE52]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To compile the new checker, you change to your build directory and run the
    `ninja` command:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译新的检查器，您需要切换到构建目录并运行`ninja`命令：
- en: '[PRE53]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You can test the new checker with the following source saved in the `conv.c`
    file, which has two calls to the `iconv_close()` function:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下保存在`conv.c`文件中的源代码来测试新的检查器，其中包含两个对`iconv_close()`函数的调用：
- en: '[PRE54]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You learned how to extend the Clang Static Analyzer with your own checker. You
    can use this knowledge to either create new general checkers and contribute them
    to the community, or you can create checkers specifically built for your needs,
    to raise the quality of your product.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你学会了如何用自己的检查器扩展Clang静态分析器。你可以利用这些知识来创建新的通用检查器并贡献给社区，或者你可以创建专门为你的需求构建的检查器，提高产品的质量。
- en: The static analyzer is built leveraging the Clang infrastructure, and the next
    section introduces you to how can build your own plugin extending Clang.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析器是建立在Clang基础设施之上的，下一节将介绍如何构建自己的插件来扩展Clang。
- en: Creating your own Clang-based tool
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你自己的基于Clang的工具
- en: The static analyzer is an impressive example of what you can do with the Clang
    infrastructure. It is also possible to extend Clang with plugins, so you are able
    to add your own functionality to Clang. The technique is very similar to adding
    a pass plugin to LLVM.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析器是Clang基础设施的一个令人印象深刻的例子。你也可以扩展Clang的功能，以便向Clang添加你自己的功能。这种技术与向LLVM添加一个pass插件非常相似。
- en: Let's explore the functionality with a simple plugin. The LLVM coding standard
    requires function names to begin with a lowercase letter. However, the coding
    standard has evolved over time, and there are many instances in which a function
    begins with an uppercase letter. A plugin that warns about a violation of the
    naming rule can help to fix the issue, so let's give it a try.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的插件来探索功能。LLVM编码标准要求函数名以小写字母开头。然而，编码标准随着时间的推移而发展，有许多情况下函数以大写字母开头。一个警告违反命名规则的插件可以帮助解决这个问题，所以让我们试一试。
- en: Because you want to run a user-defined action over the `PluginASTAction` class.
    If you write your own tool using the Clang libraries, then you define subclasses
    of the `ASTFrontendAction` class for your actions. The `PluginASTAction` class
    is a subclass of the `ASTFrontendAction` class, with the additional ability to
    parse command-line options.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你想在`PluginASTAction`类上运行一个用户定义的动作。如果你使用Clang库编写自己的工具，那么你为你的动作定义`ASTFrontendAction`类的子类。`PluginASTAction`类是`ASTFrontendAction`类的子类，还具有解析命令行选项的额外能力。
- en: 'The other class you need is a subclass of the `ASTConsumer` class. An AST consumer
    is a class using which you can run an action over an AST, regardless of the origin
    of the AST. Nothing more is needed for our first plugin. You can create the implementation
    in the `NamingPlugin.cpp` file as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要另一个`ASTConsumer`类的子类。AST消费者是一个类，你可以在AST上运行一个动作，而不管AST的来源是什么。我们的第一个插件不需要更多的东西。你可以在`NamingPlugin.cpp`文件中创建实现，如下所示：
- en: 'Begin by including the required header files. Besides the mentioned `ASTConsumer`
    class, you also need an instance of the compiler and the plugin registry:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先包括所需的头文件。除了提到的`ASTConsumer`类，你还需要一个编译器实例和插件注册表的实例：
- en: '[PRE55]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Use the `clang` namespace and put your implementation into an anonymous namespace
    to avoid name clashes:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`clang`命名空间，并将你的实现放入匿名命名空间中，以避免名称冲突：
- en: '[PRE56]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Next, define your subclass of the `ASTConsumer` class. Later, you will want
    to emit warnings if you detect a violation of the naming rule. To do so, you need
    a reference to a `DiagnosticsEngine` instance.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义你的`ASTConsumer`类的子类。稍后，如果检测到命名规则的违反，你将希望发出警告。为此，你需要一个对`DiagnosticsEngine`实例的引用。
- en: 'You''ll need to store a `CompilerInstance` instance in the class, then you
    can ask for a `DiagnosticsEngine` instance:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要在类中存储一个`CompilerInstance`实例，然后你可以要求一个`DiagnosticsEngine`实例：
- en: '[PRE57]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'An `ASTConsumer` instance has several entry methods. The `HandleTopLevelDecl()`
    method fits our purpose. The method is called for each declaration at the top
    level. This includes more than functions, for example, variables. So, you will
    use the LLVM RTTI `dyn_cast<>()` function to determine whether the declaration
    is a function declaration. The `HandleTopLevelDecl()` method has a declaration
    group as a parameter, which can contain more than a single declaration. This requires
    a loop over the declarations. The following code shows us the `HandleTopLevelDecl()`
    method:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ASTConsumer`实例有几个入口方法。`HandleTopLevelDecl()`方法符合我们的目的。该方法对顶层的每个声明都会被调用。这包括函数以外的内容，例如变量。因此，你将使用LLVM
    RTTI `dyn_cast<>()`函数来确定声明是否是函数声明。`HandleTopLevelDecl()`方法有一个声明组作为参数，它可以包含多个声明。这需要对声明进行循环。以下代码展示了`HandleTopLevelDecl()`方法：'
- en: '[PRE58]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'After having found a function declaration, you''ll need to retrieve the name
    of the function. You''ll also need to make sure that the name is not empty:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在找到函数声明后，你需要检索函数的名称。你还需要确保名称不为空：
- en: '[PRE59]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If the function name does not start with a lowercase letter, then you''ll have
    found a violation of the naming rule:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数名不以小写字母开头，那么你将发现一个违反命名规则的情况：
- en: '[PRE60]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'To emit a warning, you need a `DiagnosticsEngine` instance. Additionally, you
    need a message ID. Inside Clang, the message ID is defined as an enumeration.
    Because your plugin is not part of Clang, you need to create a custom ID, which
    you then use to emit the warning:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要发出警告，你需要一个`DiagnosticsEngine`实例。另外，你需要一个消息ID。在Clang内部，消息ID被定义为一个枚举。因为你的插件不是Clang的一部分，你需要创建一个自定义ID，然后用它来发出警告：
- en: '[PRE61]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Aside from closing all open braces, you need to return `true` from this function
    to indicate that processing can continue:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了关闭所有的大括号，你需要从这个函数中返回`true`来表示处理可以继续进行：
- en: '[PRE62]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Next, you need to create the `PluginASTAction` subclass, which implements the
    interface called by Clang:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你需要创建`PluginASTAction`子类，该子类实现了Clang调用的接口：
- en: '[PRE63]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The first method you must implement is the `CreateASTConsumer()` method, which
    returns an instance of your `NamingASTConsumer` class. This method is called by
    Clang, and the passed `CompilerInstance` instance gives you access to all the
    important classes of the compiler. The following code demonstrates this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须实现的第一个方法是`CreateASTConsumer()`方法，它返回你的`NamingASTConsumer`类的一个实例。这个方法是由Clang调用的，传递的`CompilerInstance`实例让你可以访问编译器的所有重要类。以下代码演示了这一点：
- en: '[PRE64]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'A plugin also has access to command-line options. Your plugin has no command-line
    parameters, and you will just return `true` to indicate success:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插件还可以访问命令行选项。您的插件没有命令行参数，只需返回`true`表示成功：
- en: '[PRE65]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The action type of a plugin describes when the action is invoked. The default
    value is `Cmdline`, which means that the plugin must be named on the command line
    in order to be invoked. You''ll need to override the method and change the value
    to `AddAfterMainAction`, which automatically runs the action:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插件的操作类型描述了何时调用操作。默认值是`Cmdline`，这意味着必须在命令行上命名插件才能调用。您需要覆盖该方法并将值更改为`AddAfterMainAction`，这将自动运行操作：
- en: '[PRE66]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The implementation of your `PluginNamingAction` class is finished; only the
    closing braces for the class and the anonymous namespace are missing. Add them
    to the code as follows:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的`PluginNamingAction`类的实现已经完成；只缺少类和匿名命名空间的闭合大括号。将它们添加到代码中如下：
- en: '[PRE67]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Lastly, you need to register the plugin. The first parameter is the name of
    the plugin, and the second parameter is the help text:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您需要注册插件。第一个参数是插件的名称，第二个参数是帮助文本：
- en: '[PRE68]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This finishes the implementation of the plugin. To compile the plugin, create
    a build description in the `CMakeLists.txt` file. The plugin lives outside the
    Clang source tree, so you need to set up a complete project. You can do so by
    following these steps:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了插件的实现。要编译插件，在`CMakeLists.txt`文件中创建一个构建描述。插件位于Clang源树之外，因此您需要设置一个完整的项目。您可以按照以下步骤进行：
- en: 'Begin with the definition of the required **CMake** version and the name of
    the project:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从定义所需的**CMake**版本和项目名称开始：
- en: '[PRE69]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Next, include the LLVM files. If CMake is not able to find the files automatically,
    then you have to set the `LLVM_DIR` variable to point to the LLVM directory containing
    the CMake files:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，包括LLVM文件。如果CMake无法自动找到文件，则必须将`LLVM_DIR`变量设置为指向包含CMake文件的LLVM目录：
- en: '[PRE70]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Append the LLVM directory with the CMake files to the search path, and include
    some required modules:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将包含一些必需模块的LLVM目录附加到搜索路径中：
- en: '[PRE71]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Then, load the CMake definitions for Clang. If CMake is not able to find the
    files automatically, then you have to set the `Clang_DIR` variable to point to
    the Clang directory containing the CMake files:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，加载Clang的CMake定义。如果CMake无法自动找到文件，则必须将`Clang_DIR`变量设置为指向包含CMake文件的Clang目录：
- en: '[PRE72]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Next, define where the headers files and the library files are located, and
    which definitions to use:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义头文件和库文件的位置，以及要使用的定义：
- en: '[PRE73]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The previous definitions set up the build environment. Insert the following
    command, defining the name of your plugin, the source file(s) of the plugin, and
    that it is a Clang plugin:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的定义设置了构建环境。插入以下命令，定义插件的名称、插件的源文件和它是一个Clang插件：
- en: '[PRE74]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'On **Windows**, the plugin support is different from the **Unix** platforms,
    and the required LLVM and Clang libraries must be linked in. The following code
    ensures this:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Windows**上，插件支持与**Unix**平台不同，必须链接所需的LLVM和Clang库。以下代码确保了这一点：
- en: '[PRE75]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Save both files in the `NamingPlugin` directory. Create a `build-naming-plugin`
    directory at the same level as the `NamingPlugin` directory, and build the plugin
    with the following commands:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这两个文件保存在`NamingPlugin`目录中。在与`NamingPlugin`目录相同级别创建一个`build-naming-plugin`目录，并使用以下命令构建插件：
- en: '[PRE76]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: These steps create the `NamingPlugin.so` shared library in the `build` directory.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤在`build`目录中创建了`NamingPlugin.so`共享库。
- en: 'To test the plugin, save the following source as the `naming.c` file. The `Func1`
    function name violates the naming rule, but not the `main` name:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试插件，请将以下源代码保存为`naming.c`文件。`Func1`函数名称违反了命名规则，但`main`名称没有违反：
- en: '[PRE77]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'To invoke the plugin, you need to specify the `–fplugin=` option:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用插件，您需要指定`-fplugin=`选项：
- en: '[PRE78]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This kind of invocation requires that you override the `getActionType()` method
    of the `PluginASTAction` class, and that you return a value different from the
    `Cmdline` default value.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这种调用方式要求您覆盖`PluginASTAction`类的`getActionType()`方法，并返回与`Cmdline`默认值不同的值。
- en: 'If you did not do this, for example, because you want to have more control
    over the invocation of the plugin action, then you can run the plugin from the
    compiler command line:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有这样做，例如，因为您希望更多地控制插件操作的调用，那么可以从编译器命令行运行插件：
- en: '[PRE79]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Congrats, you have built your first Clang plugin!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，您已经构建了您的第一个Clang插件！
- en: 'The disadvantage of this approach is that it has certain limitations. The `ASTConsumer`
    class has different entry methods, but they are all coarse-grained. This can be
    solved by using a `RecursiveASTVisitor` class. This class traverses all AST nodes,
    and you can override the `VisitXXX()` methods you are interested in. You can rewrite
    the plugin to use the visitor with the following steps:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是它有一定的限制。`ASTConsumer`类有不同的入口方法，但它们都是粗粒度的。这可以通过使用`RecursiveASTVisitor`类来解决。这个类遍历所有AST节点，您可以重写您感兴趣的`VisitXXX()`方法。您可以按照以下步骤重写插件以使用访问者：
- en: 'You need an additional `include` for the definition of the `RecursiveASTVisitor`
    class. Insert it as follows:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要为`RecursiveASTVisitor`类的定义添加额外的`include`。将其插入如下：
- en: '[PRE80]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Then, define the visitor as the first class in the anonymous namespace. You
    will only store a reference to the AST context, which will give you access to
    all the important methods for AST manipulation, including the `DiagnosticsEngine`
    instance required for emitting the warning:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在匿名命名空间中将访问者定义为第一个类。您只需存储对AST上下文的引用，这将使您能够访问所有重要的AST操作方法，包括发出警告所需的`DiagnosticsEngine`实例：
- en: '[PRE81]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'During traversal, the `VisitFunctionDecl()` method is called whenever a function
    declaration is discovered. Copy the body of the inner loop inside the `HandleTopLevelDecl()`
    function here:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在遍历期间，每当发现函数声明时，都会调用`VisitFunctionDecl()`方法。将内部循环的主体复制到`HandleTopLevelDecl()`函数中：
- en: '[PRE82]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This finishes the visitor implementation. In your `NamingASTConsumer` class,
    you will now only store a visitor instance:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这完成了访问者模式的实现。在你的`NamingASTConsumer`类中，你现在只需要存储一个访问者实例：
- en: '[PRE83]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'You will remove the `HandleTopLevelDecl()` method, because the functionality
    is now in the visitor class, so you''ll need to override the `HandleTranslationUnit()`
    method instead. This class is called once for each translation unit, and you will
    start the AST traversal here:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将删除`HandleTopLevelDecl()`方法，因为功能现在在访问者类中，所以你需要重写`HandleTranslationUnit()`方法。这个类对每个翻译单元调用一次，你将从这里开始AST遍历：
- en: '[PRE84]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This new implementation has exactly the same functionality. The advantage is
    that it is easier to extend. For example, if you want to examine variable declarations,
    then you implement the `VisitVarDecl()` method. Or if you want to work with a
    statement, then you implement the `VisitStmt()` method. Basically, you have a
    visitor method for each entity of the C, C++, and Objective C languages.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的实现具有完全相同的功能。优点是更容易扩展。例如，如果你想检查变量声明，那么你实现`VisitVarDecl()`方法。或者如果你想处理语句，那么你实现`VisitStmt()`方法。基本上，你对C、C++和Objective
    C语言的每个实体都有一个访问者方法。
- en: Having access to the AST allows you to build plugins that perform complex tasks.
    Enforcing naming conventions, as described in this section, is a useful addition
    to Clang. Another useful addition you could implement as a plugin is the calculation
    of a software metric such as **cyclomatic complexity**. You can also add or replace
    AST nodes, allowing you, for example, to add runtime instrumentation. Adding plugins
    allows you to extend Clang in the way you need it.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 访问AST允许你构建执行复杂任务的插件。强制命名约定，如本节所述，是Clang的一个有用补充。你可以实现的另一个有用的插件是计算软件度量，比如**圈复杂度**。你还可以添加或替换AST节点，允许你例如添加运行时仪表。添加插件允许你按照你的需要扩展Clang。
- en: Summary
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to apply various sanitizers. You detected pointer
    errors with the `address` sanitizer, uninitialized memory access with the `memory`
    sanitizer, and detected data races with the `thread` sanitizer. Application errors
    are often triggered by malformed input, and you implemented fuzz testing to test
    your application with random data.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何应用各种消毒剂。你使用`address`消毒剂检测指针错误，使用`memory`消毒剂检测未初始化的内存访问，并使用`thread`消毒剂检测数据竞争。应用程序错误通常是由格式不正确的输入触发的，你实现了模糊测试来使用随机数据测试你的应用程序。
- en: You instrumented your application with XRay to identify the performance bottlenecks,
    and you also learned about the various ways to visualize data. In this chapter,
    you also used the Clang Static Analyzer to find possible errors through interpretation
    of the source, and you learned how to build your own Clang plugin.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用XRay为你的应用程序添加了仪表，以识别性能瓶颈，并且你也学习了各种可视化数据的方法。在本章中，你还使用了Clang静态分析器通过对源代码的解释来查找可能的错误，并学习了如何构建自己的Clang插件。
- en: These skills will help you to raise the quality of the applications you build.
    It is certainly good to find runtime errors before your application users complain
    about them. Applying the knowledge gained in this chapter, you can not only find
    a wide range of common errors but also extend Clang with new functionality.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技能将帮助你提高构建应用程序的质量。在应用程序用户抱怨之前找到运行时错误肯定是件好事。应用本章中所学的知识，你不仅可以找到各种常见错误，还可以扩展Clang的新功能。
- en: In the next chapter, you will learn how to add a new backend to LLVM.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何向LLVM添加新的后端。
