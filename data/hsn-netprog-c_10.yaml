- en: Making Your Program Send Email
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使您的程序能够发送电子邮件
- en: In this chapter, we will consider the protocol responsible for delivering email
    on the internet. This protocol is called the **Simple Mail Transfer Protocol**
    (**SMTP**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将考虑负责在互联网上发送电子邮件的协议。这个协议被称为**简单邮件传输协议**（**SMTP**）。
- en: Following an exposition of the inner workings of email transfer, we will build
    a simple SMTP client capable of sending short emails.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在阐述电子邮件传输的内部工作原理之后，我们将构建一个简单的SMTP客户端，能够发送简短的电子邮件。
- en: 'The following topics are covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: How SMTP servers work
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SMTP服务器的工作原理
- en: Determining which mail server is responsible for a given domain
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定负责特定域的邮件服务器
- en: Using SMTP
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SMTP
- en: Email encoding
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子邮件编码
- en: Spam-blocking and email-sending pitfalls
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防垃圾邮件和发送电子邮件的陷阱
- en: SPF, DKIM, and DMARC
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SPF、DKIM和DMARC
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The example programs from this chapter can be compiled with any modern C compiler.
    We recommend MinGW on Windows and GCC on Linux and macOS. See [Appendix B](47da8507-709b-44a6-9399-b18ce6afd8c9.xhtml),
    *Setting Up Your C Compiler on Windows*, [Appendix C](221eebc0-0bb1-4661-a5aa-eafed9fcba7e.xhtml),
    *Setting Up Your C Compiler on Linux*, and [Appendix D](632db68e-0911-4238-a2be-bd1aa5296120.xhtml),
    *Setting Up Your C Compiler on macOS*, for compiler setup.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例程序可以用任何现代C编译器编译。我们推荐Windows上的MinGW和Linux及macOS上的GCC。有关编译器设置的详细信息，请参阅[附录B](47da8507-709b-44a6-9399-b18ce6afd8c9.xhtml)，*在Windows上设置您的C编译器*，[附录C](221eebc0-0bb1-4661-a5aa-eafed9fcba7e.xhtml)，*在Linux上设置您的C编译器*，以及[附录D](632db68e-0911-4238-a2be-bd1aa5296120.xhtml)，*在macOS上设置您的C编译器*。
- en: The code for this book can be found at [https://github.com/codeplea/Hands-On-Network-Programming-with-C](https://github.com/codeplea/Hands-On-Network-Programming-with-C).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本书代码可在[https://github.com/codeplea/Hands-On-Network-Programming-with-C](https://github.com/codeplea/Hands-On-Network-Programming-with-C)找到。
- en: 'From the command line, you can download the code for this chapter with the
    following command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行，您可以使用以下命令下载本章的代码：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each example program in this chapter runs on Windows, Linux, and macOS. When
    compiling on Windows, each example program requires linking with the Winsock library.
    This can be accomplished by passing the `-lws2_32` option to `gcc`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的每个示例程序都在Windows、Linux和macOS上运行。在Windows上编译时，每个示例程序都需要与Winsock库链接。这可以通过将`-lws2_32`选项传递给`gcc`来实现。
- en: We provide the exact commands needed to compile each example as they are introduced.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在介绍每个示例时提供编译每个示例所需的精确命令。
- en: All of the example programs in this chapter require the same header files and
    C macros that we developed in [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml),
    *Getting to Grips with Socket APIs*. For brevity, we put these statements in a
    separate header file, `chap08.h`, which we can include in each program. For a
    detailed explanation of these statements, please refer to [Chapter 2](https://cdp.packtpub.com/hands_on_network_programming_with_c/wp-admin/post.php?post=31&action=edit#post_25), *Getting
    to Grips with Socket APIs*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有示例程序都需要我们在[第2章](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml)，*掌握套接字API*中开发的相同头文件和C宏。为了简洁，我们将这些语句放在一个单独的头文件`chap08.h`中，我们可以在每个程序中包含它。有关这些语句的详细解释，请参阅[第2章](https://cdp.packtpub.com/hands_on_network_programming_with_c/wp-admin/post.php?post=31&action=edit#post_25)，*掌握套接字API*。
- en: 'The first part of `chap08.h` includes the needed networking headers for each
    platform. The code for this is as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`chap08.h`的第一部分包括每个平台所需的网络头文件。以下是相应的代码：'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We also define some macros to make writing portable code easier, and we''ll
    include the additional headers that our programs require:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一些宏，以便更容易编写可移植的代码，并且我们将包括我们的程序所需的附加头文件：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That concludes `chap08.h`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了`chap08.h`。
- en: Email servers
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电子邮件服务器
- en: SMTP is the protocol responsible for delivering emails between servers. It is
    a text-based protocol operating on TCP port `25`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: SMTP是负责在服务器之间传递电子邮件的协议。它是一个基于文本的协议，在TCP端口`25`上运行。
- en: Not all emails need to be delivered between systems. For example, imagine you
    have a Gmail account. If you compose and send an email to your friend who also
    has a Gmail account, then SMTP is not necessarily used. In this case, Gmail only
    needs to copy your email into their inbox (or do equivalent database updates).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有电子邮件都需要在系统之间传递。例如，假设您有一个Gmail账户。如果您给同样拥有Gmail账户的朋友发送电子邮件，那么SMTP不一定被使用。在这种情况下，Gmail只需要将您的电子邮件复制到他们的收件箱（或执行等效的数据库更新）。
- en: On the other hand, consider a case where you send an email to your friend's
    Yahoo! account. If the email is sent from your Gmail account, then it's clear
    that the Gmail and Yahoo! servers must communicate. In that case, your email is
    transmitted from the Gmail server to the Yahoo! server using SMTP.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，考虑一下你向你的朋友Yahoo!邮箱发送电子邮件的情况。如果你的电子邮件是从你的Gmail账户发送的，那么很清楚，Gmail和Yahoo!服务器必须进行通信。在这种情况下，你的电子邮件将通过SMTP从Gmail服务器传输到Yahoo!服务器。
- en: 'This connection is illustrated in the following diagram:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种连接关系在以下图中得到了说明：
- en: '![](img/cc2d0147-cd00-430a-889b-01c9c8ab33eb.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cc2d0147-cd00-430a-889b-01c9c8ab33eb.png)'
- en: Retrieving your email from your mail service provider is a different issue than
    delivering email between service providers. Webmail is very popular now for sending
    and receiving mail from your mail provider. Webmail providers allow mailbox access
    through a web browser. Web browsers communicate using HTTP (or HTTPS).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从你的邮件服务提供商检索电子邮件与在服务提供商之间发送电子邮件是不同的问题。现在，使用网页邮箱从你的邮件服务提供商发送和接收邮件非常流行。网页邮箱服务提供商允许通过网页浏览器访问邮箱。网页浏览器使用HTTP（或HTTPS）进行通信。
- en: 'Let''s consider the full path of an email from **Alice** to **Bob**. In this
    example, Alice has **Gmail** as her mail provider, and Bob has **Yahoo!** as his
    mail provider. Both Alice and Bob access their mailbox using a standard web browser.
    The path an email takes from Bob to Alice is illustrated by the following diagram:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一封从**爱丽丝**到**鲍勃**的电子邮件的完整路径。在这个例子中，爱丽丝使用**Gmail**作为她的邮件服务提供商，而鲍勃使用**Yahoo!**作为他的邮件服务提供商。爱丽丝和鲍勃都使用标准的网页浏览器来访问他们的邮箱。电子邮件从鲍勃到爱丽丝的路径在以下图中得到了说明：
- en: '![](img/fc5f08f6-9756-47cd-9963-4871398ede99.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc5f08f6-9756-47cd-9963-4871398ede99.png)'
- en: As you can see in the preceding diagram, **SMTP** is only used when delivering
    the mail between mail providers. This usage of SMTP is called **mail transmission**.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，**SMTP**仅在邮件服务提供商之间发送邮件时使用。这种SMTP的使用方式被称为**邮件传输**。
- en: 'In fact, the email in this example could take other paths. Let''s consider
    that Alice uses a desktop email client instead of webmail. Gmail still supports
    desktop email clients, and these clients offer many good features, even if they
    are falling out of fashion. A typical desktop client connects to a mail provider
    using either: **Internet Message Access Protocol** (**IMAP**) or **Post Office
    Protocol** (**POP**) and SMTP. In this case, SMTP is used by Alice to deliver
    her mail to her mail provider (Gmail). This usage of SMTP is called **mail submission**.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个例子中的电子邮件可以采取其他路径。让我们考虑一下，如果爱丽丝使用桌面电子邮件客户端而不是网页邮箱。尽管这些客户端正在过时，但Gmail仍然支持桌面电子邮件客户端，并且它们提供了许多优良的功能。一个典型的桌面客户端会通过**Internet
    Message Access Protocol**（**IMAP**）或**Post Office Protocol**（**POP**）以及SMTP连接到邮件服务提供商。在这种情况下，SMTP被爱丽丝用来将她的邮件发送到她的邮件服务提供商（Gmail）。这种SMTP的使用方式被称为**邮件提交**。
- en: 'The Gmail provider then uses SMTP again to deliver the email to the **Yahoo!**
    mail server. This is illustrated in the following diagram:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Gmail服务提供商随后再次使用SMTP将电子邮件发送到**Yahoo!**邮件服务器。以下图进行了说明：
- en: '![](img/f654b33e-4fdf-4fdc-afb2-6f523c1bb1e9.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f654b33e-4fdf-4fdc-afb2-6f523c1bb1e9.png)'
- en: In the preceding diagram, the Gmail server would be considered an **SMTP relay**.
    In general, an SMTP server should only relay mail for trusted users. If an SMTP
    server relayed all mail, it would become quickly overwhelmed by spammers.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前图中，Gmail服务器将被视为一个**SMTP中继**。一般来说，SMTP服务器应该只为可信用户中继邮件。如果SMTP服务器中继所有邮件，它很快就会被垃圾邮件发送者淹没。
- en: Many mail providers have a set of mail servers used to accept incoming mail
    and a separate set of mail servers used to accept outgoing mail from their users.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 许多邮件服务提供商有一组用于接收传入邮件的邮件服务器，以及一组用于接收用户发出的邮件的邮件服务器。
- en: It is important to understand that SMTP is used to send mail. SMTP is not used
    to retrieve mail from a server. IMAP and POP are the common protocols used by
    desktop mail programs to retrieve mail from a server.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解SMTP用于发送邮件。SMTP不用于从服务器检索邮件。IMAP和POP是桌面邮件程序从服务器检索邮件的常用协议。
- en: 'It is not necessary for Alice to send her mail through her provider''s SMTP
    server. Instead, she could send it directly to Bob''s mail provider as illustrated
    in the following diagram:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 爱丽丝不需要通过她的服务提供商的SMTP服务器发送她的邮件。相反，她可以直接将邮件发送到鲍勃的邮件服务提供商，以下图进行了说明：
- en: '![](img/5dd6d1fb-1504-416b-91d0-7f29d8d9da93.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5dd6d1fb-1504-416b-91d0-7f29d8d9da93.png)'
- en: In practice, one usually delegates the delivery responsibility to their mail
    provider. This has several advantages; namely, the mail provider can attempt a
    redelivery if the destination mail server isn't available. Other advantages are
    discussed later in this chapter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，人们通常将邮件投递责任委托给他们的邮件提供商。这有几个优点；即，如果目标邮件服务器不可用，邮件提供商可以尝试重新投递。其他优点将在本章后面讨论。
- en: The program we develop in this chapter is used to deliver mail directly to the
    recipient's email provider. It is not useful to deliver mail to a relay server
    because we are not going to implement authentication techniques. Generally, SMTP
    servers do not relay mail without authenticating that the sender has an account
    with them.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们开发的程序用于直接将邮件发送到收件人的电子邮件提供商。将邮件发送到中继服务器是没有用的，因为我们不打算实现身份验证技术。通常，SMTP服务器在没有验证发件人是否拥有他们账户的情况下不会中继邮件。
- en: The SMTP protocol we describe in this chapter is unsecured and not encrypted.
    This is convenient for explanation and learning purposes, but in the real world,
    you may want to secure your email transfer.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们描述的SMTP协议是不安全的且未加密的。这对于解释和学习来说很方便，但在现实世界中，你可能希望加密你的电子邮件传输。
- en: SMTP security
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SMTP安全
- en: We describe unsecured SMTP in this chapter. In real-world use, SMTP should be
    secured if both communicating servers support it. Not all do.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中描述了不安全的SMTP。在实际应用中，如果通信服务器都支持，SMTP应该被加密。并非所有服务器都支持。
- en: Securing SMTP is done by having SMTP connections start out as plaintext on port `25`.
    The SMTP client then issues a `STARTTLS` command to upgrade to a secure, encrypted
    connection. This secure connection works by merely running the SMTP commands through
    a TLS layer; therefore, everything we cover in this chapter is applicable to secure
    SMTP too. See [Chapter 9](47ba170d-42d9-4e38-b5d8-89503e005708.xhtml), *Loading **Secure
    Web Pages with HTTPS and OpenSSL,* for more information about TLS.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将SMTP连接从端口`25`开始作为明文，然后SMTP客户端发出`STARTTLS`命令以升级到安全、加密的连接来加密SMTP。这个安全连接通过仅通过TLS层运行SMTP命令来实现；因此，本章中涵盖的所有内容也适用于安全SMTP。有关TLS的更多信息，请参阅[第9章](47ba170d-42d9-4e38-b5d8-89503e005708.xhtml)，*使用HTTPS和OpenSSL加载**安全网页*。
- en: Mail transmission between servers is always done on port `25`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器之间的邮件传输总是在端口`25`上进行的。
- en: Many desktop email clients use TCP ports `465` or `587` for SMTP mail submission.
    **Internet Service Providers (ISPs)** prefer these alternative ports for mail
    submission, and it allows them to block port `25` altogether. This is generally
    justified as a spam prevention technique.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 许多桌面电子邮件客户端使用TCP端口`465`或`587`进行SMTP邮件提交。**互联网服务提供商（ISPs）**更喜欢这些替代端口进行邮件提交，这允许他们完全阻止端口`25`。这通常被合理化为一种反垃圾邮件技术。
- en: Next, let's see how to determine which mail server receives mail for a given
    email address.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何确定哪个邮件服务器接收特定电子邮件地址的邮件。
- en: Finding an email server
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找电子邮件服务器
- en: Consider the email address `bob@example.com`. In this case, `bob` identifies
    the user, while `example.com` identifies the domain name of the service provider.
    These parts are delineated by the `@` symbol.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑电子邮件地址`bob@example.com`。在这种情况下，`bob`标识用户，而`example.com`标识服务提供商的域名。这些部分由`@`符号分隔。
- en: One domain name can potentially use multiple mail servers. Likewise, one mail
    server can provide service for many domain names. For this reason, identifying
    the mail server or servers responsible for receiving mail for `bob@example.com` isn't
    as easy as connecting to `example.com`. Instead, the mail server must be identified
    by performing a DNS lookup for an MX record.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个域名可能使用多个邮件服务器。同样，一个邮件服务器可以为多个域名提供服务。因此，识别负责接收`bob@example.com`邮件的邮件服务器或服务器并不像连接到`example.com`那样简单。相反，必须通过执行MX记录的DNS查找来识别邮件服务器。
- en: DNS was covered in depth back in [Chapter 5](3d80e3b8-07d3-49f4-b60f-b006a17f7213.xhtml), *Hostname
    Resolution and DNS*. The program we developed in that chapter can be used to query
    MX records.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: DNS在[第5章](3d80e3b8-07d3-49f4-b60f-b006a17f7213.xhtml)中进行了深入探讨，*主机名解析和DNS*。我们本章开发的程序可以用来查询MX记录。
- en: Otherwise, most operating systems provide a command-line tool for DNS lookup.
    Windows provides `nslookup`, while Linux and macOS provide `dig`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，大多数操作系统都提供用于DNS查找的命令行工具。Windows提供`nslookup`，而Linux和macOS提供`dig`。
- en: 'On Windows, we can find the mail servers responsible for accepting mail `@gmail.com` using
    the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，我们可以使用以下命令找到负责接收`@gmail.com`邮件的服务器：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This lookup is shown in the following screenshot:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了此查找：
- en: '![](img/6f4e6420-bf5b-491a-9c56-2a09ec4f19d7.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6f4e6420-bf5b-491a-9c56-2a09ec4f19d7.png)'
- en: 'On Linux or macOS, an MX record lookup for a `@gmail.com` account is done with
    the following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux或macOS上，使用以下命令对`@gmail.com`账户进行MX记录查找：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The use of `dig` is shown in the following screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了`dig`的使用：
- en: '![](img/cc1f9572-2088-4dbf-87a6-cf0a0750a8c0.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cc1f9572-2088-4dbf-87a6-cf0a0750a8c0.png)'
- en: As you can see in the preceding two screenshots, Gmail uses five mail servers.
    When multiple MX records are found, mail should be delivered to the server having
    the lowest MX preference first. If mail delivery fails to that server, then an
    attempt should be made to deliver to the server having the next lowest preference,
    and so on. At the time of this writing, Gmail's primary mail server, having a
    preference of `5`, is `gmail-smtp-in.l.google.com`. That is the SMTP server you
    would connect to in order to send mail to an `@gmail.com` address.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如前两个屏幕截图所示，Gmail使用五个邮件服务器。当找到多个MX记录时，应首先将邮件发送到具有最低MX优先级的邮件服务器。如果邮件无法发送到该服务器，则应尝试发送到具有下一个最低优先级的邮件服务器，依此类推。在撰写本文时，Gmail的主要邮件服务器，优先级为`5`，是`gmail-smtp-in.l.google.com`。这是您连接以发送`@gmail.com`地址邮件的SMTP服务器。
- en: 'It is also possible for MX records to have the same preference. Yahoo! uses
    mail servers having the same preference. The following screenshot shows the MX
    records for `yahoo.com`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: MX记录也可能具有相同的优先级。雅虎使用具有相同优先级的邮件服务器。以下屏幕截图显示了`yahoo.com`的MX记录：
- en: '![](img/36cd8937-4fc7-4057-8168-7f2586deb7ce.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/36cd8937-4fc7-4057-8168-7f2586deb7ce.png)'
- en: In the preceding screenshot, we see that Yahoo! uses three mail servers. Each
    server has a preference of `1`. This means that mail can be delivered to any one
    of them with no special preference. If mail delivery fails to the first chosen
    server, then another server should be chosen at random to retry.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到雅虎使用三个邮件服务器。每个服务器都有一个优先级`1`。这意味着邮件可以发送到其中的任何一个，没有特别的优先顺序。如果邮件无法发送到第一个选择的邮件服务器，那么应该随机选择另一个服务器重试。
- en: Programmatically getting the MX record in a cross-platform manner can be difficult.
    Please see [Chapter 5](3d80e3b8-07d3-49f4-b60f-b006a17f7213.xhtml), *Hostname
    Resolution and DNS*, where this topic was covered in some depth. The SMTP client
    we develop in this present chapter assumes that the mail server is known in advance.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以跨平台方式编程获取MX记录可能很困难。请参阅[第5章](3d80e3b8-07d3-49f4-b60f-b006a17f7213.xhtml)，*主机名解析和DNS*，其中对这一主题进行了深入探讨。我们本章开发的SMTP客户端假设邮件服务器是事先已知的。
- en: Now that we know which server to connect to, let's consider the SMTP protocol
    itself in more detail.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了要连接的服务器，让我们更详细地考虑SMTP协议本身。
- en: SMTP dialog
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SMTP对话
- en: SMTP is a text-based TCP protocol that works on port `25`. SMTP works in a lock-step,
    one-at-a-time dialog, with the client sending commands and the server sending
    responses for each command.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: SMTP是一种基于文本的TCP协议，在端口`25`上工作。SMTP以锁步、逐个命令的方式工作，客户端发送命令，服务器对每个命令发送响应。
- en: 'In a typical session, the dialog goes as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型会话中，对话如下：
- en: The client first establishes a connection to the SMTP server.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端首先建立与SMTP服务器的连接。
- en: The server initiates with a greeting. This greeting indicates that the server
    is ready to receive commands.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器以问候开始。这个问候表明服务器已准备好接收命令。
- en: The client then issues its own greeting.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端随后发出自己的问候。
- en: The server responds.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器响应。
- en: The client sends a command indicating who the mail is from.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端发送一个命令，表明邮件的发送者是谁。
- en: The server responds to indicate that the sender is accepted.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器响应以表明发送者已被接受。
- en: The client issues another command, which specifies the mail's recipient.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端发出另一个命令，指定邮件的接收者。
- en: The server responds indicating the recipient is accepted.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器响应表明接收者已被接受。
- en: The client then issues a `DATA` command.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端随后发出一个`DATA`命令。
- en: The server responds asking the client to proceed.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器响应要求客户端继续。
- en: The client transfers the email.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端传输电子邮件。
- en: 'The protocol is very simple. In the following example SMTP session, `mail.example.net` is
    the client, and the server is `mail.example.com` (`C` and `S` indicate whether
    the client or server is sending, respectively):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 该协议非常简单。在以下SMTP会话示例中，`mail.example.net`是客户端，服务器是`mail.example.com`（`C`和`S`分别表示客户端或服务器是否发送）：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Everything the server sends is in reply to the client's commands, except for
    the first line. The first line is simply in response to the client connecting.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器发送的每一项内容都是对客户端命令的回应，除了第一行。第一行仅仅是响应客户端的连接。
- en: You may notice that each of the client's commands start with a four-letter word.
    Each one of the server's responses starts with a three-digit code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到客户端的每个命令都以四个字母的单词开头。每个服务器的响应都以三位数字代码开头。
- en: 'The common client commands we use are as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们常用的客户端命令如下：
- en: '`HELO` is used for the client to identify itself to the server.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HELO`用于客户端向服务器标识自己。'
- en: '`MAIL` is used to specify who is sending the mail.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MAIL`用于指定谁在发送邮件。'
- en: '`RCPT` is used to specify a recipient.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RCPT`用于指定一个收件人。'
- en: '`DATA` is used to initiate the transfer of the actual email. This email should
    include both headers and a body.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DATA`用于启动实际电子邮件的传输。这封电子邮件应包括头部和正文。'
- en: '`QUIT` is used to end the session.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QUIT`用于结束会话。'
- en: 'The server response codes used in a successful email transfer are the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功的电子邮件传输中使用的服务器响应代码如下：
- en: '`220`: The service is ready'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`220`: 服务就绪'
- en: '`250`: The requested command was accepted and completed successfully'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`250`: 请求的命令已被接受并成功完成'
- en: '`354`: Start sending the message'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`354`: 开始发送消息'
- en: '`221`: The connection is closing'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`221`: 连接正在关闭'
- en: Error codes vary between providers, but they are generally in the 500 range.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 错误代码因提供商而异，但通常在500范围内。
- en: 'SMTP servers can also send replies spanning multiple lines. In this case, the
    very last line begins with the response code followed by a space. All preceding
    lines begin with the response code followed by a dash. The following example illustrates
    a multiline response after attempting to deliver to a mailbox that does not exist:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: SMTP服务器也可以发送跨越多行的回复。在这种情况下，最后一行以响应代码后跟一个空格开始。所有前面的行都以响应代码后跟一个破折号开始。以下是一个尝试投递到不存在的邮箱后的多行响应示例：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that some servers validate that the recipient address is valid before replying
    to the `RCPT` command, but many servers only validate the recipient address after
    the client sends the email using the `DATA` command.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一些服务器在回复`RCPT`命令之前会验证收件人地址是否有效，但许多服务器仅在客户端使用`DATA`命令发送电子邮件后验证收件人地址。
- en: Although that explains the basics of the protocol used to send mail, we still
    must consider the format of the email itself. This is covered next.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这解释了发送邮件所使用的协议的基本原理，但我们仍然必须考虑电子邮件本身的格式。这将在下一部分介绍。
- en: The format of an email
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电子邮件的格式
- en: If we make an analogy to physical mail, the SMTP commands `MAIL FROM` and `RCPT
    TO` address the envelope. Those commands give the SMTP server information on how
    the mail is to be delivered. In this analogy, the `DATA` command would be the
    letter inside the envelope. As it's common to address a physical letter inside
    an envelope, it's also common to repeat the delivery information in the email,
    even though it was already sent to the SMTP server through the `MAIL` and `RCPT`
    commands.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将物理邮件进行类比，SMTP命令`MAIL FROM`和`RCPT TO`指向信封。这些命令向SMTP服务器提供了关于邮件如何投递的信息。在这个类比中，`DATA`命令将是信封内的信件。由于通常在信封内写上物理信件地址，所以在电子邮件中重复投递信息也很常见，即使这些信息已经通过`MAIL`和`RCPT`命令发送给了SMTP服务器。
- en: 'A simple email may look like the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的电子邮件可能看起来像以下这样：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The entire email is transmitted to an SMTP server following the `DATA` command.
    A single period on an otherwise blank line is transmitted to indicate the end
    of the email. If the email contains any line beginning with a period, the SMTP
    client should replace it with two consecutive periods. This prevents the client
    from indicating the email is over prematurely. The SMTP server knows that any
    line beginning with two periods should be replaced with a single period.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 整个电子邮件在`DATA`命令之后被发送到SMTP服务器。在一行空白中加一个点表示电子邮件的结束。如果电子邮件中任何行以点开头，SMTP客户端应将其替换为两个连续的点。这防止客户端过早地表示电子邮件结束。SMTP服务器知道以两个点开头的任何行应替换为单个点。
- en: The email itself can be divided into two parts—the header and the body. The
    two parts are delineated by the first blank line.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件本身可以分为两部分——头部和正文。这两部分由第一行空白分隔。
- en: The header part consists of various headers that indicate properties of the
    email. `From`, `To`, `Subject`, and `Date` are the most common headers.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 头部部分由各种头部组成，这些头部指示电子邮件的属性。`From`、`To`、`Subject`和`Date`是最常见的头部。
- en: The body part of the email is simply the message being sent.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件的正文部分就是发送的消息。
- en: With a basic understanding of the email format, we are now ready to begin writing
    a simple C program to send emails.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在对电子邮件格式有基本了解之后，我们现在可以开始编写一个简单的C程序来发送电子邮件。
- en: A simple SMTP client program
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的 SMTP 客户端程序
- en: 'With a basic understanding of both SMTP and the email format, we are ready
    to program a simple email client. Our client takes as inputs: the destination
    email server, the recipient''s address, the sender''s address, the email subject
    line, and the email body text.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在对 SMTP 和电子邮件格式有基本理解之后，我们就可以编写一个简单的电子邮件客户端程序了。我们的客户端接受以下输入：目标电子邮件服务器、收件人地址、发件人地址、电子邮件主题行和电子邮件正文文本。
- en: 'Our program begins by including the necessary headers with the following statements:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序首先通过以下语句包含必要的头文件：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We also define the following two constants to make buffer allocation and checking
    easier:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了以下两个常量，以便于缓冲区分配和检查：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Our program needs to prompt the user for input several times. This is required
    to get the email server's hostname, the recipient's address, and so on. C provides
    the `gets()` function for this purpose but `gets()` is deprecated in the latest
    C standard. Therefore, we implement our own function.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序需要多次提示用户输入。这是为了获取电子邮件服务器的域名、收件人地址等等。C 提供了 `gets()` 函数来完成这个目的，但 `gets()`
    在最新的 C 标准中已被弃用。因此，我们实现了自己的函数。
- en: 'The following function, `get_input()`, prompts for user input:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数 `get_input()` 用于提示用户输入：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `get_input()` function uses `fgets()` to read from `stdin`. The buffer passed
    to `get_input()` is assumed to be `MAXINPUT` bytes, which we defined at the top
    of the file.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_input()` 函数使用 `fgets()` 从 `stdin` 读取。传递给 `get_input()` 的缓冲区假定是 `MAXINPUT`
    字节，我们在文件顶部定义了这个值。'
- en: The `fgets()` function does not remove a newline character from the received
    input; therefore, we overwrite the last character inputted with a terminating
    null character.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`fgets()` 函数不会从接收到的输入中删除换行符；因此，我们将输入的最后一个字符覆盖为一个终止的空字符。'
- en: It is also very helpful to have a function that can send formatted strings directly
    over the network. We implement a function called `send_format()` for this purpose.
    It takes a socket, a formatting string, and the additional arguments to send.
    You can think of `send_format()` as being very similar to `printf()`. The difference
    is that `send_format()` delivers the formatted text over the network instead of
    printing to the screen.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一个函数可以直接通过网络发送格式化的字符串非常有帮助。我们为此实现了一个名为 `send_format()` 的函数。它接受一个套接字、一个格式化字符串以及要发送的附加参数。你可以把
    `send_format()` 看作是非常类似于 `printf()` 的。区别在于 `send_format()` 通过网络传递格式化的文本而不是打印到屏幕上。
- en: 'The code for `send_format()` is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`send_format()` 的代码如下：'
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code works by first reserving a buffer. `vsprintf()` is then used
    to format the text into that buffer. It is up to the caller to ensure that the
    formatted output doesn't exceed the reserved buffer space. We are assuming for
    this program that the user is trusted, but in a production program, you would
    want to add checks to prevent a buffer overflow here.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码首先预留一个缓冲区。然后使用 `vsprintf()` 将文本格式化到该缓冲区中。调用者需要确保格式化的输出不超过预留的缓冲区空间。我们假设在这个程序中用户是可信的，但在一个生产程序中，你想要添加检查以防止在这里发生缓冲区溢出。
- en: After the output text is formatted into `buffer`, it is sent using `send()`.
    We also print the sent text to the screen. A `C:` is printed preceding it to indicate
    that the text was sent by us, the client.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在将输出文本格式化为 `buffer` 后，我们使用 `send()` 发送它。我们还打印出发送的文本到屏幕上。在它前面打印一个 `C:` 来表示文本是由我们，即客户端发送的。
- en: One of the trickier parts of our SMTP client is parsing the SMTP server responses.
    This is important because the SMTP client must not issue a second command until
    a response is received for the first command. If the SMTP client sends a new command
    before the server is ready, then the server will likely terminate the connection.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 SMTP 客户端比较棘手的部分之一是解析 SMTP 服务器响应。这很重要，因为 SMTP 客户端必须在收到第一个命令的响应之前不发出第二个命令。如果
    SMTP 客户端在服务器准备好之前发送新的命令，那么服务器很可能会终止连接。
- en: Recall that each SMTP response starts with a three-digit code. We want to parse
    out this code to check for errors. Each SMTP response is usually followed by text
    that we ignore. SMTP responses are typically only one line long, but they can
    sometimes span multiple lines. In this case, each line up to the penultimate line
    contains a dash character, `-`, directly following the three-digit response code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，每个 SMTP 响应都以三位数字代码开始。我们想要解析出这个代码来检查错误。每个 SMTP 响应通常后面跟着我们忽略的文本。SMTP 响应通常是单行长，但有时可以跨越多行。在这种情况下，直到倒数第二行的每一行都包含一个破折号字符
    `-`，直接跟在三位响应代码后面。
- en: 'To illustrate how multiline responses work, consider the following two responses
    as equivalent:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明多行响应是如何工作的，考虑以下两个响应是等效的：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It is important that our program recognizes multiline responses; it must not
    mistakenly treat a single multiline response as separate responses.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 确保我们的程序识别多行响应很重要；它不能错误地将单个多行响应视为单独的响应。
- en: 'We implement a function called `parse_response()` for this purpose. It takes
    in a null-terminated response string and returns the parsed response code. If
    no code is found or the response isn''t complete, then `0` is returned instead.
    The code for this function is as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个目的，我们实现了一个名为`parse_response()`的函数。它接受一个以空字符终止的响应字符串，并返回解析后的响应代码。如果没有找到代码或响应不完整，则返回`0`。此函数的代码如下：
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `parse_response()` function begins by checking for a null terminator in
    the first three characters of the response. If a null is found there, then the
    function can return immediately because `response` isn't long enough to constitute
    a valid SMTP response.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`parse_response()`函数首先检查响应的前三个字符中是否有空终止符。如果在那里找到空字符，那么函数可以立即返回，因为`response`不足以构成有效的SMTP响应。'
- en: It then loops through the `response` input string. The loop goes until a null-terminating
    character is found three characters out. Each loop, `isdigit()` is used to see
    whether the current character and the next two characters are all digits. If so,
    the fourth character, `k[3]`, is checked. If `k[3]` is a dash, then the response
    continues onto the next line. However, if `k[3]` isn't a dash, then `k[0]` represents
    the beginning of the last line of the SMTP response. In this case, the code checks
    if the line ending has been received; `strstr()` is used for this purpose. It
    the line ending was received, the code uses `strtol()` to convert the response
    code to an integer.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它遍历`response`输入字符串。循环直到在三个字符外找到一个空终止字符。在每次循环中，使用`isdigit()`检查当前字符和下一个两个字符是否都是数字。如果是这样，则检查第四个字符`k[3]`。如果`k[3]`是一个破折号，则响应继续到下一行。然而，如果`k[3]`不是一个破折号，则`k[0]`代表SMTP响应的最后一行的开始。在这种情况下，代码检查是否已经接收到行结束；`strstr()`用于此目的。如果接收到行结束，则代码使用`strtol()`将响应代码转换为整数。
- en: If the code loops through `response()` without returning, then `0` is returned,
    and the client needs to wait for more input from the SMTP server.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码在遍历`response()`而没有返回时，则返回`0`，并且客户端需要等待从SMTP服务器接收更多输入。
- en: 'With `parse_response()` out of the way, it is useful to have a function that
    waits until a particular response code is received over the network. We implement
    a function called `wait_on_response()` for this purpose, which begins as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在`parse_response()`函数处理完毕后，有一个函数等待网络接收到特定的响应代码是有用的。为此，我们实现了一个名为`wait_on_response()`的函数，其开始如下：
- en: '[PRE14]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, a `response` buffer variable is reserved for storing
    the SMTP server's response. A pointer, `p`, is set to the beginning of this buffer; `p` will
    be incremented to point to the end of the received data, but it starts at `response`
    since no data has been received yet. An `end` pointer variable is set to the end
    of the buffer, which is useful to ensure we do not attempt to write past the buffer
    end.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，为存储SMTP服务器的响应预留了一个`response`缓冲区变量。一个指针`p`被设置为这个缓冲区的开始；`p`将被增加以指向接收到的数据的末尾，但因为它还没有收到数据，所以它从`response`开始。一个指向缓冲区末尾的`end`指针变量被设置，这对于确保我们不会尝试写入缓冲区末尾是有用的。
- en: Finally, we set `code = 0` to indicate that no response code has been received
    yet.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`code`设置为`0`以指示尚未接收到任何响应代码。
- en: 'The `wait_on_response()` function then continues with a loop as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`wait_on_response()`函数随后通过以下循环继续：'
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The beginning of the preceding loop uses `recv()` to receive data from the SMTP
    server. The received data is written at point `p` in the `response` array. We
    are careful to use `end` to make sure received data isn't written past the end
    of `response`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 上述循环的开始使用`recv()`从SMTP服务器接收数据。接收到的数据被写入`response`数组中的`p`点。我们小心地使用`end`确保接收到的数据不会写入`response`的末尾。
- en: After `recv()` returns, `p` is incremented to the end of the received data,
    and a null terminating character is set. A check for `p == end` ensures that we
    haven't written to the end of the response buffer.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在`recv()`返回后，`p`被增加以指向接收到的数据的末尾，并设置一个空终止字符。检查`p == end`确保我们没有写入响应缓冲区的末尾。
- en: Our function from earlier, `parse_response()`, is used to check whether a full
    SMTP response has been received. If so, then `code` is set to that response. If
    not, then `code` is equal to `0`, and the loop continues to receive additional
    data.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前定义的函数 `parse_response()` 用于检查是否已接收到完整的 SMTP 响应。如果是，则将 `code` 设置为该响应。如果不是，则
    `code` 等于 `0`，循环将继续接收更多的数据。
- en: 'After the loop terminates, the `wait_on_response()` function checks that the
    received SMTP response code is as expected. If so, the received data is printed
    to the screen, and the function returns. The code for this is as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 循环结束后，`wait_on_response()` 函数会检查接收到的 SMTP 响应代码是否符合预期。如果是，则将接收到的数据打印到屏幕上，并返回函数。以下是该代码：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That concludes the `wait_on_response()` function. This function proves very
    useful, and it is needed after every command sent to the SMTP server.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了 `wait_on_response()` 函数。这个函数非常有用，并且需要在向 SMTP 服务器发送的每个命令之后使用。
- en: We also define a function called `connect_to_host()`, which attempts to open
    a TCP connection to a given hostname and port number. This function is extremely
    similar to the code we've used in the previous chapters.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一个名为 `connect_to_host()` 的函数，该函数尝试打开到指定主机名和端口号的 TCP 连接。这个函数与我们在前几章中使用的代码非常相似。
- en: 'First `getaddrinfo()` is used to resolve the hostname and `getnameinfo()` is
    then used to print the server IP address. The following code achieves those two
    purposes:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用 `getaddrinfo()` 解析主机名，然后使用 `getnameinfo()` 打印服务器 IP 地址。以下代码实现了这两个目的：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A socket is then created with `socket()`, as shown in the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用 `socket()` 创建一个套接字，如下所示：
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once the socket has been created, `connect()` is used to establish the connection.
    The following code shows the use of `connect()` and the end of the `connect_to_host()`
    function:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了套接字，就使用 `connect()` 来建立连接。以下代码展示了 `connect()` 的使用和 `connect_to_host()`
    函数的结束：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Don't forget to call `freeaddrinfo()` to free the memory allocated for the server
    address, as shown by the preceding code.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记调用 `freeaddrinfo()` 来释放为服务器地址分配的内存，如前述代码所示。
- en: 'Finally, with those helper functions out of the way, we can begin on `main()`.
    The following code defines `main()` and initializes Winsock if required:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当那些辅助函数不再需要时，我们可以开始编写 `main()` 函数。以下代码定义了 `main()` 函数并在需要时初始化 Winsock：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: See [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml), *Getting to Grips
    with Socket APIs*, for more information about initializing Winsock and establishing
    connections.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 [第 2 章](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml)，*掌握 Socket API*，以获取有关初始化
    Winsock 和建立连接的更多信息。
- en: 'Our program can proceed by prompting the user for an SMTP hostname. This hostname
    is stored in `hostname`, and our `connect_to_host()` function is used to open
    a connection. The following code shows this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序可以通过提示用户输入 SMTP 主机名来继续执行。这个主机名存储在 `hostname` 中，我们的 `connect_to_host()`
    函数用于打开连接。以下代码展示了这一点：
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After the connection is established, our SMTP client must not issue any commands
    until the server responds with a `220` code. We use `wait_on_response()` to wait
    for this with the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 连接建立后，我们的 SMTP 客户端必须等待服务器响应 `220` 代码后才能发出任何命令。我们使用 `wait_on_response()` 函数通过以下代码来等待响应：
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once the server is ready to receive commands, we must issue the `HELO` command.
    The following code sends the `HELO` command and waits for a `250` response code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器准备好接收命令，我们必须发出 `HELO` 命令。以下代码发送 `HELO` 命令并等待 `250` 响应代码：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`HELO` should be followed by the SMTP client''s hostname; however, since we
    are probably running this client from a development machine, it''s likely we don''t
    have a hostname setup. For this reason, we simply send `HONPWC`, although any
    arbitrary string can be used. If you are running this client from a server, then
    you should change the `HONPWC` string to a domain that points to your server.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`HELO` 应该跟随着 SMTP 客户端的主机名；然而，由于我们可能是在开发机器上运行此客户端，所以我们可能没有设置主机名。因此，我们简单地发送 `HONPWC`，尽管可以使用任何任意的字符串。如果你是从服务器上运行此客户端，那么你应该将
    `HONPWC` 字符串更改为指向你的服务器的域名。'
- en: Also, note the line ending used in the preceding code. The line ending used
    by SMTP is a carriage return character followed by a line feed character. In C,
    this is represented by `"\r\n"`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意前述代码中使用的行结束符。SMTP 使用的行结束符是一个回车符后跟一个换行符。在 C 语言中，这表示为 `"\r\n"`。
- en: 'Our program then prompts the user for the sending and receiving addresses and
    issues the appropriate SMTP commands. This is done using `get_input()` to prompt
    the user, `send_format()` to issue the SMTP commands, and `wait_on_response()`
    to receive the SMTP server''s response:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们的程序会提示用户输入发送和接收地址，并发出相应的SMTP命令。这是通过`get_input()`来提示用户，`send_format()`来发出SMTP命令，以及`wait_on_response()`来接收SMTP服务器的响应来完成的：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After the sender and receiver are specified, the next step in the SMTP is to
    issue the `DATA` command. The `DATA` command instructs the server to listen for
    the actual email. It is issued by the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定了发送者和接收者之后，SMTP的下一步是发出`DATA`命令。`DATA`命令指示服务器监听实际电子邮件。它通过以下代码发出：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Our client program then prompts the user for an email subject line. After the
    subject line is specified, it can send the email headers: `From`, `To`, and `Subject`.
    The following code does this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户端程序接着会提示用户输入电子邮件的主题行。在指定主题行之后，它可以发送电子邮件头：`From`，`To`，和`Subject`。以下代码执行此操作：
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It is also useful to add a date header. Emails use a special format for dates.
    We can make use of the `strftime()` function to format the date properly. The
    following code formats the date into the proper email header:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 添加日期头也很有用。电子邮件使用特殊的日期格式。我们可以使用`strftime()`函数正确地格式化日期。以下代码将日期格式化为正确的电子邮件头：
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code, the `time()` function is used to get the current date
    and time, and `gmtime()` is used to convert it into a `timeinfo` struct. Then, `strftime()`
    is called to format the data and time into a temporary buffer, `date`. This formatted
    string is then transmitted to the SMTP server as an email header.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`time()`函数用于获取当前日期和时间，而`gmtime()`用于将其转换为`timeinfo`结构。然后，调用`strftime()`将日期和时间格式化到临时缓冲区`date`中。然后，将格式化后的字符串作为电子邮件头发送到SMTP服务器。
- en: 'After the email headers are sent, the email body is delineated by a blank line.
    The following code sends this blank line:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送电子邮件头之后，电子邮件正文由一个空行分隔。以下代码发送这个空行：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We can then prompt the user for the body of the email using `get_input()`. The
    body is transmitted one line at a time. When the user finishes their email, they
    should enter a single period on a line by itself. This indicates both to our client
    and the SMTP server that the email is finished.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`get_input()`提示用户输入电子邮件正文。正文逐行传输。当用户完成他们的电子邮件后，他们应该在单独的一行上输入一个句点。这既向我们的客户端也向SMTP服务器表明电子邮件已结束。
- en: 'The following code sends user input to the server until a single period is
    inputted:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将用户输入发送到服务器，直到输入单个句点为止：
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If the mail was accepted by the SMTP server, it sends a `250` response code.
    Our client then issues the `QUIT` command and checks for a `221` response code.
    The `221` response code indicates that the connection is terminating as shown
    in the following code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果邮件被SMTP服务器接受，它将发送`250`响应代码。然后，我们的客户端发出`QUIT`命令并检查`221`响应代码。`221`响应代码表示连接正在终止，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Our SMTP client concludes by closing the socket, cleaning up Winsock (if required),
    and exiting as shown here:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的SMTP客户端通过关闭套接字，清理Winsock（如果需要），并按以下方式退出：
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: That concludes `smtp_send.c`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了`smtp_send.c`。
- en: 'You can compile and run `smtp_send.c` on Windows with MinGW using the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下方式在Windows上使用MinGW编译和运行`smtp_send.c`：
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'On Linux or macOS, compiling and running `smtp_send.c` is done by the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux或macOS上，编译和运行`smtp_send.c`的方式如下：
- en: '[PRE33]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following screenshot shows the sending of a simple email using `smtp_send.c`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了使用`smtp_send.c`发送简单电子邮件的过程：
- en: '![](img/18ae9fc0-07ef-4066-afca-6be70e0c0e26.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/18ae9fc0-07ef-4066-afca-6be70e0c0e26.png)'
- en: 'If you''re doing a lot of testing, you may find it tedious to type in the email
    each time. In that case, you can automate it by putting your text in a file and
    using the `cat` utility to read it into `smtp_send`. For example, you may have
    the `email.txt` file as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在进行大量测试，你可能觉得每次都输入电子邮件地址很麻烦。在这种情况下，你可以通过将文本放入文件并使用`cat`实用程序将其读取到`smtp_send`中来自动化它。例如，你可能有一个如下所示的`email.txt`文件：
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'With the program input stored in `email.txt`, you can send an email using the
    following command:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用存储在`email.txt`中的程序输入，你可以使用以下命令发送电子邮件：
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Hopefully, you can send some test emails with `smtp_send`. There are, however,
    a few obstacles you may run into. Your ISP may block outgoing emails from your
    connection, and many email servers do not accept mail from residential IP address
    blocks. See the *Spam-blocking pitfalls* section later in the chapter for more
    information.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您可以使用`smtp_send`发送一些测试电子邮件。然而，您可能会遇到一些障碍。您的ISP可能会阻止从您的连接发送的出站电子邮件，并且许多电子邮件服务器不接受来自住宅IP地址块的邮件。请参阅本章后面的*垃圾邮件阻止陷阱*部分以获取更多信息。
- en: Although `smtp_send` is useful for sending simple text-based messages, you may
    be wondering how to add formatting to your email. Perhaps you want to send files
    as attachments. The next section addresses these issues.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`smtp_send`对于发送基于文本的消息很有用，但您可能想知道如何给电子邮件添加格式。也许您想发送作为附件的文件。下一节将解决这些问题。
- en: Enhanced emails
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强型电子邮件
- en: The emails we've been looking at so far have been only simple text. Modern email
    usage often demands fancier formatted emails.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止所查看的电子邮件只是简单的文本。现代电子邮件的使用往往需要更复杂的格式化电子邮件。
- en: We can control the content type of an email using the `Content-Type` header.
    This is very similar to the content type header used by HTTP, which we covered
    in [Chapter 7](f352830e-089c-4369-b7a2-18a896e1c5d5.xhtml), *Building a Simple
    Web Server*.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Content-Type`标题来控制电子邮件的内容类型。这与我们在[第7章](f352830e-089c-4369-b7a2-18a896e1c5d5.xhtml)中介绍的HTTP使用的`Content-Type`标题非常相似，即*构建一个简单的Web服务器*。
- en: 'If the content type header is missing, a content type of `text/plain` is assumed
    by default. Therefore, the `Content-Type` header in the following email is redundant:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果缺少内容类型标题，默认假设内容类型为`text/plain`。因此，以下电子邮件中的`Content-Type`标题是多余的：
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If you want formatting support in your email, which is common today, you should
    use a `text/html` content type. In the following email, HTML is used to add emphasis:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在电子邮件中添加格式支持，这在当今是很常见的，您应该使用`text/html`内容类型。在下面的电子邮件中，HTML被用来添加强调：
- en: '[PRE37]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Not all email clients support HTML emails. For this reason, it may be useful
    to encode your message as both plaintext and HTML. The following email uses this
    technique:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有电子邮件客户端都支持HTML电子邮件。因此，将您的消息编码为纯文本和HTML两种格式可能很有用。以下电子邮件使用了这种技术：
- en: '[PRE38]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The preceding email example uses two headers to indicate that it''s a multipart
    message. The first one, `MIME-Version: 1.0`, indicates which version of **Multipurpose
    Internet Mail Extensions** (**MIME**) we''re using. MIME is used for all emails
    that aren''t simply plaintext.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '上述电子邮件示例使用两个标题来指示它是一个多部分消息。第一个标题`MIME-Version: 1.0`指示我们正在使用哪个版本的**多用途互联网邮件扩展**（**MIME**）。MIME用于所有不是纯文本的电子邮件。'
- en: 'The second header, `Content-Type: multipart/alternative; boundary="SEPARATOR"`,
    specifies that we''re sending a multipart message. It also specifies a special
    boundary character sequence that delineates the parts of the email. In our example,
    `SEPARATOR` is used as the boundary. It is important that the boundary not appear
    in the email text or attachments. In practice, boundary specifiers are often long
    randomly generated strings.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '第二个标题`Content-Type: multipart/alternative; boundary="SEPARATOR"`指定了我们正在发送一个多部分消息。它还指定了一个特殊的边界字符序列，用于界定电子邮件的各个部分。在我们的例子中，`SEPARATOR`被用作边界。确保边界不会出现在电子邮件文本或附件中。在实践中，边界指定符通常是长随机生成的字符串。'
- en: Once the boundary has been set, each part of the email begins with `--SEPARATOR`
    on a line by itself. The email ends with `--SEPARATOR--`. Note that each part
    of the message gets its own header section, specific to only that part. These
    header sections are used to specify the content type for each part.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了边界，电子邮件的每一部分都以单独一行上的`--SEPARATOR`开始。电子邮件以`--SEPARATOR--`结束。请注意，消息的每一部分都有自己的标题部分，仅针对该部分。这些标题部分用于指定每一部分的内容类型。
- en: It is also often useful to attach files to email, which we will cover now.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件附加到电子邮件中也是非常有用的，我们现在就来介绍这一点。
- en: Email file attachments
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电子邮件文件附件
- en: 'If a multipart email is being sent, a part can be designated as an attachment
    using the `Content-Disposition` header. See the following example:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正在发送多部分电子邮件，可以使用`Content-Disposition`标题将部分指定为附件。请参阅以下示例：
- en: '[PRE39]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The preceding example includes a file called `my_file.txt`. SMTP is a purely
    text-based protocol; therefore, any attachments that may include binary data need
    to be encoded into a text format. Base64 encoding is commonly used for this purpose.
    In this example, the header, `Content-Transfer-Encoding: base64`, specifies that
    we are going to use Base64 encoding.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '上述示例中包含一个名为 `my_file.txt` 的文件。SMTP 是一个纯文本协议；因此，任何可能包含二进制数据的附件都需要编码成文本格式。Base64
    编码通常用于此目的。在这个例子中，头部 `Content-Transfer-Encoding: base64` 指定了我们将使用 Base64 编码。'
- en: The content of `my_file.txt` is `This is a simple text message`. That sentence
    encodes to Base64 as `VGhpcyBpcyBhIHNpbXBsZSB0ZXh0IG1lc3NhZ2Uu` as seen in the
    preceding code.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`my_file.txt` 的内容是 `This is a simple text message`。这句话编码成 Base64 为 `VGhpcyBpcyBhIHNpbXBsZSB0ZXh0IG1lc3NhZ2Uu`，如前述代码所示。'
- en: Spam-blocking pitfalls
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾邮件拦截陷阱
- en: It can be much harder to send emails today than it was in the past. Spam has
    become a major problem, and every provider is taking actions to curb it. Unfortunately,
    many of these actions can also make it much more difficult to send legitimate
    emails.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在发送电子邮件可能比过去要困难得多。垃圾邮件已经成为一个主要问题，每个服务提供商都在采取措施来遏制它。不幸的是，许多这些措施也可能使得发送合法电子邮件变得更加困难。
- en: Many residential ISPs don't allow outgoing connections on port `25`. If your
    residential provider blocks port `25`, then you won't be able to establish an
    SMTP connection. In this case, you may consider renting a virtual private server
    to run this chapter's code.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 许多住宅互联网服务提供商不允许在端口 `25` 上进行出站连接。如果你的住宅服务提供商阻止了端口 `25`，那么你将无法建立 SMTP 连接。在这种情况下，你可能需要考虑租用一个虚拟专用服务器来运行本章的代码。
- en: Even if your ISP does allow outgoing connections on port `25`, many SMTP servers
    won't accept mail from a residential IP address. Of the servers that do, many
    will send those emails straight into a spam folder.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你的 ISP 允许在端口 `25` 上进行出站连接，许多 SMTP 服务器也不会接受来自住宅 IP 地址的邮件。在这些接受邮件的服务器中，许多会将这些邮件直接发送到垃圾邮件文件夹。
- en: 'For example, if you attempt to deliver an email to Gmail, you may get a response
    similar to the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你尝试将电子邮件发送到 Gmail，你可能会收到以下类似的响应：
- en: '[PRE40]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Another spam-blocking measure that may trip you up is **Sender Policy Framework**
    (**SPF**). SPF works by listing which servers can send mail for a given domain.
    If a sending server isn't on the SPF list, then receiving SMTP servers reject
    their mail.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能会让你陷入困境的垃圾邮件拦截措施是 **发送者策略框架**（**SPF**）。SPF 通过列出哪些服务器可以为特定域发送邮件来工作。如果一个发送服务器不在
    SPF 列表中，那么接收 SMTP 服务器将拒绝它们的邮件。
- en: '**DomainKeys Identified Mail** (**DKIM**) is a measure to authenticate email
    using digital signatures. Many popular email providers are more likely to treat
    non-DKIM mail as spam. DKIM signing is very complicated and out of scope for this
    book.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**域密钥识别邮件**（**DKIM**）是一种使用数字签名验证电子邮件的措施。许多流行的电子邮件服务提供商更有可能将非 DKIM 邮件视为垃圾邮件。DKIM
    签名非常复杂，超出了本书的范围。'
- en: '**Domain-based Message Authentication*,* Reporting, and Conformance** (**DMARC**)
    is a technique used for domains to publish whether SPF and/or DKIM is required
    of mail originating from them, among other things.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于域的消息身份验证、报告和一致性**（**DMARC**）是一种技术，用于域发布是否需要 SPF 和/或 DKIM 来验证从它们发出的邮件，以及其他事项。'
- en: Most commercial email servers use SPF, DKIM, and DMARC. If you're sending email
    without these, your email will likely be treated as spam. If you're sending email
    in opposition to these, your email will either be rejected outright or labeled
    as spam.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数商业电子邮件服务器使用 SPF、DKIM 和 DMARC。如果你发送电子邮件没有这些，你的电子邮件很可能会被视为垃圾邮件。如果你发送的电子邮件违反了这些规定，你的电子邮件可能会被直接拒绝或被标记为垃圾邮件。
- en: Finally, many popular providers assign a reputation to sending domains and servers.
    This puts potential emails senders in a catch-22 situation. Email can't be delivered
    without building a reputation, but a reputation can't be built without successfully
    delivering lots of emails. As spam continues to be a major problem, we may soon
    come to a time where only big-name, trusted SMTP servers can operate with each
    other. Let's hope it doesn't come to that!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，许多流行的服务提供商会给发送域和服务器分配一个声誉。这使潜在的电子邮件发送者陷入了一个两难境地。没有建立声誉，电子邮件就无法投递，但没有成功发送大量电子邮件，声誉也无法建立。随着垃圾邮件继续成为一个主要问题，我们可能很快就会来到一个只有知名、可信的
    SMTP 服务器才能相互操作的时代。让我们希望这种情况不会发生！
- en: If your program needs to send email reliably, you should likely consider using
    an email service provider. One option is to allow an SMTP relay to do the final
    delivery. A potentially easier option is to use a mail sending service that operates
    an HTTP API.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的程序需要可靠地发送电子邮件，你可能会考虑使用电子邮件服务提供商。一个选项是允许SMTP中继进行最终投递。一个可能更容易的选项是使用一个运行HTTP
    API的邮件发送服务。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how email is delivered over the internet. SMTP,
    the protocol responsible for email delivery, was studied in some depth. We then
    constructed a simple program to send short emails using SMTP.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了电子邮件如何在互联网上投递。我们深入研究了负责电子邮件投递的协议SMTP。然后我们构建了一个简单的程序，使用SMTP发送简短的电子邮件。
- en: We looked at the email format too. We saw how MIME could be used to send multipart
    emails with file attachments.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了电子邮件格式。我们看到了如何使用MIME发送带有文件附件的多部分电子邮件。
- en: We also saw how sending emails over the modern internet is full of pitfalls.
    Many of these stems from attempts to block spam. Techniques used by providers,
    such as blocking residential IP addresses, SPF, DKIM, DMARC, and IP address reputation
    monitoring, may make it difficult for our simple program to deliver email reliably.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了在现代互联网上发送电子邮件充满了陷阱。其中许多源于阻止垃圾邮件的尝试。提供商使用的技巧，如封锁住宅IP地址、SPF、DKIM、DMARC和IP地址声誉监控，可能会使我们的简单程序难以可靠地投递邮件。
- en: In the next chapter, [Chapter 9](47ba170d-42d9-4e38-b5d8-89503e005708.xhtml), *Loading
    Secure Web Pages with HTTPS and OpenSSL*, we look at secure web connections using
    HTTPS.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，[第9章](47ba170d-42d9-4e38-b5d8-89503e005708.xhtml)，*使用HTTPS和OpenSSL加载安全网页*，我们将探讨使用HTTPS的加密网络连接。
- en: Questions
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Try these questions to test your knowledge from this chapter:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下问题来测试你对本章知识的掌握：
- en: What port does SMTP operate on?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SMTP运行在哪个端口上？
- en: How do you determine which SMTP server receives mail for a given domain?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何确定哪个SMTP服务器为特定域名接收邮件？
- en: How do you determine which SMTP server sends mail for a given provider?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何确定哪个SMTP服务器为特定提供商发送邮件？
- en: Why won't an SMTP server relay mail without authentication?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么SMTP服务器在没有身份验证的情况下不会中继邮件？
- en: How are binary files sent as email attachments when SMTP is a text-based protocol?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当SMTP是一个基于文本的协议时，如何将二进制文件作为电子邮件附件发送？
- en: The answers can be found in [Appendix A](bd8b8f52-52cb-4d34-b01b-e907564bfece.xhtml),
    *Answers to Questions*.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 答案可以在[附录A](bd8b8f52-52cb-4d34-b01b-e907564bfece.xhtml)，*问题解答*中找到。
- en: Further reading
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information about SMTP and email formats, please refer to the following
    links:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 关于SMTP和电子邮件格式的更多信息，请参阅以下链接：
- en: '**RFC 821**: *Simple Mail Transfer Protocol* ([https://tools.ietf.org/html/rfc821](https://tools.ietf.org/html/rfc821))'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RFC 821**: *简单邮件传输协议* ([https://tools.ietf.org/html/rfc821](https://tools.ietf.org/html/rfc821))'
- en: '**RFC 2822**: *Internet* *Message Format* ([https://tools.ietf.org/html/rfc2822](https://tools.ietf.org/html/rfc2822))'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RFC 2822**: *互联网* *消息格式* ([https://tools.ietf.org/html/rfc2822](https://tools.ietf.org/html/rfc2822))'
