["```cpp\nsysctl -a hw \n```", "```cpp\nhw.memsize: 17179869184\nhw.cachelinesize: 64\nhw.l1icachesize: 32768\nhw.l1dcachesize: 32768\nhw.l2cachesize: 262144\nhw.l3cachesize: 8388608 \n```", "```cpp\nconstexpr auto kL1CacheCapacity = 32768; // The L1 Data cache size \nconstexpr auto kSize = kL1CacheCapacity / sizeof(int); \nusing MatrixType = std::array<std::array<int, kSize>, kSize>; \nauto cache_thrashing(MatrixType& matrix) { \n  auto counter = 0;\n  for (auto i = 0; i < kSize; ++i) {\n    for (auto j = 0; j < kSize; ++j) {\n      matrix[i][j] = counter++;\n    }\n  }\n} \n```", "```cpp\nmatrix[j][i] = counter++; \n```", "```cpp\nPerson(Person&& other) {         // Will be copied \n   // ...\n} \nPerson(Person&& other) noexcept { // Will be moved \n   // ...\n} \n```", "```cpp\nstatic_assert(std::is_nothrow_move_constructible<Person>::value); \n```", "```cpp\npersons.emplace_back(\"John\", 65); \n```", "```cpp\nauto v = std::vector{-1, 5, 2, -3, 4, -5, 5};\nstd::erase(v, 5);                               // v: [-1,2,-3,4,-5]\nstd::erase_if(v, [](auto x) { return x < 0; }); // v: [2, 4] \n```", "```cpp\nauto a = std::array<int, 16>{};\nauto b = std::array<int, 1024>{}; \n```", "```cpp\nauto f(const std::array<int, 1024>& input) { \n  // ... \n} \n\nf(a);  // Does not compile, f requires an int array of size 1024 \n```", "```cpp\n// input looks like an array, but is in fact a pointer \nauto f(const int input[]) {  \n  // ... \n} \n\nint a[16]; \nint b[1024]; \nf(a); // Compiles, but unsafe \n```", "```cpp\nauto in = std::ifstream{\"file.txt\", std::ios::binary | std::ios::ate}; \nif (in.is_open()) { \n  auto size = in.tellg(); \n  auto content = std::string(size, '\\0'); \n  in.seekg(0); \n  in.read(&content[0], size); \n  // \"content\" now contains the entire file \n} \n```", "```cpp\nauto my_hash = [](const Person& person) {\n  return 47; // Bad, don't do this!\n}; \n```", "```cpp\nauto person_eq = [](const Person& lhs, const Person& rhs) {\n  return lhs.name() == rhs.name() && lhs.age() == rhs.age();\n}; \n```", "```cpp\n#include <boost/functional/hash.hpp>\nauto person_hash = [](const Person& person) { \n  auto seed = size_t{0};\n  boost::hash_combine(seed, person.name()); \n  boost::hash_combine(seed, person.age()); \n  return seed;\n}; \n```", "```cpp\nusing Set = std::unordered_set<Person, decltype(person_hash),                                decltype(person_eq)>; \nauto persons = Set{100, person_hash, person_eq}; \n```", "```cpp\nclass Document { \npublic:  \n  Document(std::string title) : title_{std::move(title)} {}\nprivate:  \n  std::string title_; \n  // ... \n}; \n```", "```cpp\nstruct Hit { \n  float rank_{}; \n  std::shared_ptr<Document> document_; \n}; \n```", "```cpp\ntemplate<typename It>\nauto sort_hits(It begin, It end, size_t m) -> std::vector<Hit> { \n```", "```cpp\n auto cmp = [](const Hit& a, const Hit& b) { \n    return a.rank_ > b.rank_; // Note, we are using greater than \n  };\n  auto queue = std::priority_queue<Hit, std::vector<Hit>,                                    decltype(cmp)>{cmp}; \n```", "```cpp\n for (auto it = begin; it != end; ++it) { \n    if (queue.size() < m) { \n      queue.push(*it); \n    } \n    else if (it->rank_ > queue.top().rank_) { \n      queue.pop(); \n      queue.push(*it); \n    } \n  } \n```", "```cpp\n auto result = std::vector<Hit>{}; \n  while (!queue.empty()) { \n    result.push_back(queue.top()); \n    queue.pop(); \n  } \n  std::reverse(result.begin(), result.end()); \n  return result; \n} // end of sort_hits() \n```", "```cpp\nauto some_func(const std::string& s) {\n  // process s ...\n}\nsome_func(\"A string literal\"); // Creates a std::string \n```", "```cpp\nauto some_func(std::string_view s) { // Pass by value\n  // process s ... \n}\nsome_func(\"A string literal\"); \n```", "```cpp\n// buffer looks like an array, but is in fact a pointer \nauto f1(float buffer[]) {\n  const auto n = std::size(buffer);   // Does not compile!\n  for (auto i = 0u; i < n; ++i) {     // Size is lost!\n    // ...\n  }\n} \n```", "```cpp\nauto f2(float buffer[], size_t n) {\n  for (auto i = 0u; i < n; ++i) {\n    // ...\n  }\n} \n```", "```cpp\nfloat a[256]; \nf2(a, 256);     \nf2(a, sizeof(a)/sizeof(a[0])); // A common tedious pattern\nf2(a, std::size(a)); \n```", "```cpp\nauto f3(std::span<float> buffer) {  // Pass by value\n  for (auto&& b : buffer) {         // Range-based for-loop\n    // ...\n  }\n}\nfloat a[256]; \nf3(a);          // OK! Array is passed as a span with size\nauto v = std::vector{1.f, 2.f, 3.f, 4.f};\nf3(v);          // OK! \n```", "```cpp\nauto bag = std::multiset<std::string>{}; // Our bag-of-words\n// Fill bag with words ... \n```", "```cpp\nauto word = std::string{\"bayes\"}; // Our word we want to find\nif (bag.count(word) > 0) {\n   // ...\n} \n```", "```cpp\nif (bag.find(word) != bag.end()) {\n  // ...\n} \n```", "```cpp\nif (bag.lower_bound(word) != bag.end()) { \n  // ...\n} \n```", "```cpp\nif (bag.contains(word)) { // Efficient and with clear intent \n  // ...\n} \n```", "```cpp\nstruct SmallObject { \n  std::array<char, 4> data_{}; \n  int score_{std::rand()}; \n};\n\nstruct BigObject { \n std::array<char, 256> data_{}; \n int score_{std::rand()}; \n}; \n```", "```cpp\nstd::cout << sizeof(SmallObject); // Possible output is 8 \nstd::cout << sizeof(BigObject);   // Possible output is 260 \n```", "```cpp\nauto small_objects = std::vector<SmallObject>(1'000'000); \nauto big_objects = std::vector<BigObject>(1'000'000); \n```", "```cpp\ntemplate <class T> \nauto sum_scores(const std::vector<T>& objects) {  \n  ScopedTimer t{\"sum_scores\"};    // See chapter 3 \n\n  auto sum = 0; \n  for (const auto& obj : objects) { \n    sum += obj.score_; \n  } \n  return sum; \n} \n```", "```cpp\nauto sum = 0; \nsum += sum_scores(small_objects); \nsum += sum_scores(big_objects); \n```", "```cpp\nstruct User { \n  std::string name_; \n  std::string username_; \n  std::string password_; \n  std::string security_question_; \n  std::string security_answer_; \n  short level_{}; \n  bool is_playing_{}; \n}; \n```", "```cpp\nauto num_users_at_level(const std::vector<User>& users, short level) { \n  ScopedTimer t{\"num_users_at_level (using 128 bytes User)\"}; \n\n  auto num_users = 0; \n  for (const auto& user : users)\n    if (user.level_ == level)\n      ++num_users; \n  return num_users; \n} \n```", "```cpp\nauto num_playing_users(const std::vector<User>& users) { \n  ScopedTimer t{\"num_playing_users (using 128 bytes User)\"}; \n\n  return std::count_if(users.begin(), users.end(), \n    [](const auto& user) { \n      return user.is_playing_; \n    }); \n} \n```", "```cpp\n11 ms num_users_at_level (using 128 bytes User)\n10 ms num_playing_users (using 128 bytes User) \n```", "```cpp\nstruct AuthInfo { \n  std::string username_; \n  std::string password_; \n  std::string security_question_; \n  std::string security_answer_; \n}; \n\nstruct User { \n  std::string name_; \n  std::unique_ptr<AuthInfo> auth_info_; \n  short level_{}; \n  bool is_playing_{}; \n}; \n```", "```cpp\n4 ms num_users_at_level with User\n3 ms num_playing_users with User \n```", "```cpp\nauto num_users_at_level(const std::vector<int>& users, short level) { \n  ScopedTimer t{\"num_users_at_level using int vector\"}; \n  return std::count(users.begin(), users.end(), level); \n} \n```", "```cpp\nauto num_playing_users(const std::vector<bool>& users) { \n  ScopedTimer t{\"num_playing_users using vector<bool>\"}; \n  return std::count(users.begin(), users.end(), true); \n} \n```", "```cpp\nauto users = std::vector<User>(1'000'000); \nauto levels = std::vector<short>(1'000'000); \nauto playing_users = std::vector<bool>(1'000'000); \n\n// Initialize data \n// ... \n\nauto num_at_level_5 = num_users_at_level(levels, 5);\nauto num_playing = num_playing_users(playing_users); \n```"]