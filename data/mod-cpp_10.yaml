- en: Exploring Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索函数
- en: 'The recipes included in this chapter are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含的示例如下：
- en: Defaulted and deleted functions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认和删除的函数
- en: Using lambdas with standard algorithms
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用lambda与标准算法
- en: Using generic lambdas
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用通用lambda
- en: Writing a recursive lambda
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写递归lambda
- en: Writing a function template with a variable number of arguments
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写具有可变数量参数的函数模板
- en: Using fold expressions to simplify variadic function templates
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用折叠表达式简化可变参数函数模板
- en: Implementing higher-order functions map and fold
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现高阶函数map和fold
- en: Composing functions into a higher-order function
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数组合成高阶函数
- en: Uniformly invoking anything callable
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统一调用任何可调用的东西
- en: Defaulted and deleted functions
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认和删除的函数
- en: In C++, classes have special members (constructors, destructors, and operators)
    that may be either implemented by default by the compiler or supplied by the developer.
    However, the rules for what can be default implemented are a bit complicated and
    can lead to problems. On the other hand, developers sometimes want to prevent
    objects from being copied, moved, or constructed in a particular way. That is
    possible by implementing different tricks using these special members. The C++11
    standard has simplified many of these by allowing functions to be deleted or defaulted
    in the manner we will see in the next section.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，类有特殊成员（构造函数、析构函数和运算符），可以由编译器默认实现，也可以由开发人员提供。然而，可以默认实现的规则有点复杂，可能会导致问题。另一方面，开发人员有时希望阻止对象以特定方式被复制、移动或构造。通过使用这些特殊成员实现不同的技巧是可能的。C++11标准通过允许函数被删除或默认实现简化了许多这样的问题，我们将在下一节中看到。
- en: Getting started
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: For this recipe, you need to know what special member functions are and what
    copyable and moveable means.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，你需要知道什么是特殊成员函数，以及可复制和可移动的含义。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Use the following syntax to specify how functions should be handled:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下语法指定如何处理函数：
- en: 'To default a function, use `=default` instead of the function body. Only special
    class member functions that have defaults can be defaulted:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要默认一个函数，使用`=default`而不是函数体。只有具有默认值的特殊类成员函数可以被默认：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To delete a function, use `=delete` instead of the function body. Any function,
    including non-member functions, can be deleted:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要删除一个函数，使用`=delete`而不是函数体。任何函数，包括非成员函数，都可以被删除：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Use defaulted and deleted functions to achieve various design goals, such as
    the following examples:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认和删除的函数来实现各种设计目标，例如以下示例：
- en: 'To implement a class that is not copyable, and implicitly not movable, declare
    the copy operations as deleted:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要实现一个不可复制且隐式不可移动的类，将复制操作声明为已删除：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To implement a class that is not copyable, but is movable, declare the copy
    operations as deleted and explicitly implement the move operations (and provide
    any additional constructors that are needed):'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要实现一个不可复制但可移动的类，将复制操作声明为已删除，并显式实现移动操作（并提供任何需要的其他构造函数）：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To ensure a function is called only with objects of a specific type, and perhaps
    prevent type promotion, provide deleted overloads for the function (the following
    example with free functions can also be applied to any class member functions):'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了确保一个函数只能被特定类型的对象调用，并可能防止类型提升，为函数提供已删除的重载（以下示例中的自由函数也可以应用于任何类成员函数）：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'A class has several special members that can be implemented, by default, by
    the compiler. These are the default constructor, copy constructor, move constructor,
    copy assignment, move assignment, and destructor. If you don''t implement them,
    then the compiler does it so that instances of a class can be created, moved,
    copied, and destructed. However, if you explicitly provide one or more of these
    special methods, then the compiler will not generate the others according to the
    following rules:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类有几个特殊成员，可以由编译器默认实现。这些是默认构造函数、复制构造函数、移动构造函数、复制赋值、移动赋值和析构函数。如果你不实现它们，那么编译器会这样做，以便可以创建、移动、复制和销毁类的实例。然而，如果你显式提供了其中一个或多个特殊方法，那么编译器将根据以下规则不生成其他方法：
- en: If a user-defined constructor exists, the default constructor is not generated
    by default.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在用户定义的构造函数，则默认构造函数不会被默认生成。
- en: If a user-defined virtual destructor exists, the default constructor is not
    generated by default.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在用户定义的虚拟析构函数，则默认构造函数不会被默认生成。
- en: If a user-defined move constructor or move assignment operator exists, then
    the copy constructor and copy assignment operator are not generated by default.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在用户定义的移动构造函数或移动赋值运算符，则默认不会生成复制构造函数和复制赋值运算符。
- en: If a user-defined copy constructor, move constructor, copy assignment operator,
    move assignment operator, or destructor exists, then the move constructor and
    move assignment operator are not generated by default.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在用户定义的复制构造函数、移动构造函数、复制赋值运算符、移动赋值运算符或析构函数，则默认不会生成移动构造函数和移动赋值运算符。
- en: If a user-defined copy constructor or destructor exists, then the copy assignment
    operator is generated by default.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在用户定义的复制构造函数或析构函数，则默认生成复制赋值运算符。
- en: If a user-defined copy assignment operator or destructor exists, then the copy
    constructor is generated by default.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在用户定义的复制赋值运算符或析构函数，则默认生成复制构造函数。
- en: Note that the last two rules in the preceding list are deprecated rules and
    may no longer be supported by your compiler.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面列表中的最后两条规则是被弃用的规则，可能不再被你的编译器支持。
- en: Sometimes, developers need to provide empty implementations of these special
    members or hide them in order to prevent the instances of the class from being constructed
    in a specific manner. A typical example is a class that is not supposed to be
    copyable. The classical pattern for this is to provide a default constructor and
    hide the copy constructor and copy assignment operators. While this works, the
    explicitly defined default constructor ensures the class is no longer considered
    trivial and, therefore, a POD type. The modern alternative to this is using a
    deleted function as shown in the preceding section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，开发人员需要提供这些特殊成员的空实现或隐藏它们，以防止以特定方式构造类的实例。一个典型的例子是一个不应该被复制的类。这种情况的经典模式是提供一个默认构造函数并隐藏复制构造函数和复制赋值运算符。虽然这样可以工作，但显式定义的默认构造函数确保了该类不再被视为平凡的，因此不再是POD类型。这种情况的现代替代方法是使用前面部分所示的删除函数。
- en: 'When the compiler encounters `=default` in the definition of a function, it
    will provide the default implementation. The rules for special member functions
    mentioned earlier still apply. Functions can be declared `=default` outside the
    body of a class if and only if they are inlined:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器在函数定义中遇到`=default`时，它将提供默认实现。之前提到的特殊成员函数的规则仍然适用。如果函数是内联的，函数可以在类的主体之外声明为`=default`：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When the compiler encounters the `=delete` in the definition of a function,
    it will prevent the calling of the function. However, the function is still considered
    during overload resolution, and only if the deleted function is the best match,
    the compiler generates an error. For example, by giving the previously defined
    overloads for the `run()` function, only calls with long integers are possible.
    Calls with arguments of any other type, including `int`, for which an automatic
    type promotion to `long` exists, will determine a deleted overload to be considered
    the best match and therefore the compiler will generate an error:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器在函数定义中遇到`=delete`时，它将阻止调用该函数。但是，在重载解析期间仍然会考虑该函数，只有在删除的函数是最佳匹配时，编译器才会生成错误。例如，通过为`run()`函数给出先前定义的重载，只有长整数的调用是可能的。对于任何其他类型的参数，包括`int`，其中存在自动类型提升为`long`的情况，将确定删除的重载被认为是最佳匹配，因此编译器将生成错误：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that previously declared functions cannot be deleted, as the `=delete`
    definition must be the first declaration in a translation unit:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，之前声明的函数不能被删除，因为`=delete`定义必须是翻译单元中的第一个声明：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The rule of thumb (also known as *The Rule of Five*) for class special member
    functions is that, if you explicitly define any copy constructor, move constructor,
    copy assignment operator, move assignment operator, or destructor, then you must
    either explicitly define or default all of them.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 经验法则（也称为*五大法则*）适用于类特殊成员函数，即，如果您明确定义了任何复制构造函数、移动构造函数、复制赋值运算符、移动赋值运算符或析构函数，则您必须明确定义或默认所有这些函数。
- en: Using lambdas with standard algorithms
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标准算法与lambda
- en: One of the most important modern features of C++ is lambda expressions, also
    referred to as lambda functions or simply lambdas. Lambda expressions enable us
    to define anonymous function objects that can capture variables in the scope and
    be invoked or passed as arguments to functions. Lambdas are useful for many purposes,
    and in this recipe, we will see how to use them with standard algorithms.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: C++最重要的现代特性之一是lambda表达式，也称为lambda函数或简单的lambda。Lambda表达式使我们能够定义可以捕获作用域中的变量并被调用或作为参数传递给函数的匿名函数对象。Lambda在许多方面都很有用，在这个配方中，我们将看到如何将它们与标准算法一起使用。
- en: Getting ready
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In this recipe, we discuss standard algorithms that take an argument that is
    a function or predicate applied to the elements it iterates through. You need
    to know what unary and binary functions are and what predicates and comparison
    functions are. You also need to be familiar with function objects because lambda
    expressions are syntactic sugar for function objects.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们讨论了接受作为其迭代的元素的函数或谓词参数的标准算法。您需要了解什么是一元和二元函数，以及什么是谓词和比较函数。您还需要熟悉函数对象，因为lambda表达式是函数对象的语法糖。
- en: How to do it...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'You should prefer to use lambda expressions to pass callbacks to standard algorithms
    instead of functions or function objects:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该更倾向于使用lambda表达式将回调传递给标准算法，而不是函数或函数对象：
- en: 'Define anonymous lambda expressions in the place of the call if you only need
    to use the lambda in a single place:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您只需要在一个地方使用lambda，则在调用的地方定义匿名lambda表达式：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Define a named lambda, that is, one assigned to a variable (usually with the
    `auto` specifier for the type), if you need to call the lambda in multiple places:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您需要在多个地方调用lambda，则定义一个命名lambda，即分配给变量的lambda（通常使用`auto`指定符为类型）：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Use generic lambda expressions if you need lambdas that only differ in their
    argument types (available since C++14):'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您需要在参数类型上有所不同的lambda，则使用通用lambda表达式（自C++14起可用）：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The non-generic lambda expression shown on the second bullet earlier takes
    a constant integer and returns `true` if it is greater than `0`, or `false` otherwise.
    The compiler defines an unnamed function object with the call operator having
    the signature of the lambda expression:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的第二个项目符号中显示的非通用lambda表达式接受一个常量整数，并在大于`0`时返回`true`，否则返回`false`。编译器定义了一个具有lambda表达式签名的无名函数对象的调用运算符：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The way the unnamed function object is defined by the compiler depends on the
    way we define the lambda expression that can capture variables, use the `mutable`
    specifier or exception specifications, or have a trailing return type. The `__lambda_name__`
    function object shown earlier is actually a simplification of what the compiler
    generates because it also defines a default copy and move constructor, a default
    destructor, and a deleted assignment operator.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器定义的未命名函数对象的方式取决于我们定义lambda表达式的方式，它可以捕获变量，使用`mutable`说明符或异常规范，或具有尾部返回类型。之前显示的`__lambda_name__`函数对象实际上是编译器生成的简化版本，因为它还定义了默认的复制和移动构造函数，默认的析构函数和已删除的赋值运算符。
- en: It must be well understood that the lambda expression is actually a class. In
    order to call it, the compiler needs to instantiate an object of the class. The
    object instantiated from a lambda expression is called a *lambda closure*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 必须充分理解，lambda表达式实际上是一个类。为了调用它，编译器需要实例化一个类的对象。从lambda表达式实例化的对象称为*lambda闭包*。
- en: 'In the next example, we want to count the number of elements in a range that
    are greater than or equal to 5 and less than or equal to 10\. The lambda expression,
    in this case, will look like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个例子中，我们想要计算范围内大于或等于5且小于或等于10的元素的数量。在这种情况下，lambda表达式将如下所示：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This lambda captures two variables, `start` and `end`, by copy (that is, value).
    The resulting unnamed function object created by the compiler looks very much
    like the one we defined earlier. With the default and deleted special members
    mentioned earlier, the class looks like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此lambda通过复制（即值）捕获两个变量`start`和`end`。编译器创建的结果未命名函数对象看起来非常像我们之前定义的那个。通过前面提到的默认和已删除的特殊成员，该类如下所示：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The lambda expression can capture variables by copy (or value) or by reference,
    and different combinations of the two are possible. However, it is not possible
    to capture a variable multiple times, and it is only possible to have `&` or `=`
    at the beginning of the capture list.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: lambda表达式可以通过复制（或值）或引用捕获变量，两者的不同组合是可能的。但是，不可能多次捕获变量，并且只能在捕获列表的开头使用`&`或`=`。
- en: A lambda can only capture variables from an enclosing function scope. It cannot
    capture variables with static storage duration (that is, variables declared in
    a namespace scope or with the `static` or `external` specifier).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: lambda只能捕获封闭函数范围内的变量。它不能捕获具有静态存储期限的变量（即在命名空间范围内声明或使用`static`或`external`说明符声明的变量）。
- en: The following table shows various combinations for lambda captures semantics.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了lambda捕获语义的各种组合。
- en: '| **Lambda** | **Description** |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: 描述
- en: '| `[](){}` | Does not capture anything |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: 不捕获任何东西
- en: '| `[&](){}` | Captures everything by reference |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: 通过引用捕获一切
- en: '| `[=](){}` | Captures everything by copy |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: 通过复制捕获一切
- en: '| `[&x](){}` | Capture only `x` by reference |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: 仅通过引用捕获`x`
- en: '| `[x](){}` | Capture only `x` by copy |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: 仅通过复制捕获`x`
- en: '| `[&x...](){}` | Capture pack extension `x` by reference |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: 通过引用捕获包扩展`x`
- en: '| `[x...](){}` | Capture pack extension `x` by copy |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: 通过复制捕获包扩展`x`
- en: '| `[&, x](){}` | Captures everything by reference except for `x` that is captured
    by copy |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: 通过引用捕获一切，除了通过复制捕获的`x`
- en: '| `[=, &x](){}` | Captures everything by copy except for `x` that is captured
    by reference |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: 通过复制捕获一切，除了通过引用捕获的`x`
- en: '| `[&, this](){}` | Captures everything by reference except for pointer `this`
    that is captured by copy (`this` is always captured by copy) |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: 通过引用捕获一切，除了指针`this`被复制捕获（`this`始终被复制捕获）
- en: '| `[x, x](){}` | Error, `x` is captured twice |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: 错误，`x`被捕获两次
- en: '| `[&, &x](){}` | Error, everything is captured by reference, cannot specify
    again to capture `x` by reference |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: 错误，一切都被引用捕获，不能再次指定通过引用捕获`x`
- en: '| `[=, =x](){}` | Error, everything is captured by copy, cannot specify again
    to capture `x` by copy |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: 错误，一切都被复制捕获，不能再次指定通过复制捕获`x`
- en: '| `[&this](){}` | Error, pointer `this` is always captured by copy |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: 错误，指针`this`始终被复制捕获
- en: '| `[&, =](){}` | Error, cannot capture everything both by copy and by reference
    |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: 错误，不能同时通过复制和引用捕获一切
- en: 'The general form of a lambda expression, as of C++17, looks like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 截至C++17，lambda表达式的一般形式如下：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: All parts shown in this syntax are actually optional except for the capture
    list, that can, however, be empty, and the body, that can also be empty. The parameter
    list can actually be omitted if no parameters are needed. The return type does
    not need to be specified, as the compiler can infer it from the type of the returned
    expression. The `mutable` specifier (that tells the compiler the lambda can actually
    modify variables captured by copy), the `constexpr` specifier (that tells the
    compiler to generate a `constexpr` call operator), and the exception specifiers
    and attributes are all optional.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此语法中显示的所有部分实际上都是可选的，除了捕获列表，但是可以为空，并且主体也可以为空。如果不需要参数，则可以省略参数列表。不需要指定返回类型，因为编译器可以从返回表达式的类型推断出来。`mutable`说明符（告诉编译器lambda实际上可以修改通过复制捕获的变量），`constexpr`说明符（告诉编译器生成`constexpr`调用运算符），异常说明符和属性都是可选的。
- en: The simplest possible lambda expression is `[]{}`, though it is often written
    as `[](){}`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的lambda表达式是`[]{}`，尽管通常写作`[](){}`。
- en: There's more...
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are cases where lambda expressions only differ in the type of their arguments.
    In this case, the lambdas can be written in a generic way, just like templates,
    but using the `auto` specifier for the type parameters (no template syntax is
    involved). This is addressed in the next recipe, mentioned in the *See also* section.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有时lambda表达式只在其参数的类型上有所不同。在这种情况下，lambda可以以通用的方式编写，就像模板一样，但是使用`auto`说明符作为类型参数（不涉及模板语法）。这在下一个配方中讨论，见*另请参阅*部分。
- en: See also
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Using generic lambdas*'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用通用lambda*'
- en: '*Writing a recursive lambda*'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写递归lambda*'
- en: Using generic lambdas
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用通用lambda：
- en: In the preceding recipe, we saw how to write lambda expressions and use them
    with standard algorithms. In C++, lambdas are basically syntactic sugar for unnamed
    function objects, which are classes that implement the call operator. However,
    just like any other function, this can be implemented generically with templates.
    C++14 takes advantage of this and introduces generic lambdas that do not need
    to specify actual types for their parameters and use the `auto` specifier instead.
    Though not referred with this name, generic lambdas are basically lambda templates.
    They are useful in cases where we want to use the same lambda but with different
    types of parameter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的文章中，我们看到了如何编写lambda表达式并将其与标准算法一起使用。在C++中，lambda基本上是未命名函数对象的语法糖，这些函数对象是实现调用运算符的类。然而，就像任何其他函数一样，这可以通过模板来实现。C++14利用了这一点，并引入了通用lambda，它们不需要为参数指定实际类型，而是使用`auto`关键字。虽然没有用这个名字，通用lambda基本上就是lambda模板。它们在我们想要使用相同lambda但参数类型不同的情况下非常有用。
- en: Getting started
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: It is recommended that you read the preceding recipe, *Using lambdas with standard
    algorithms*, before you continue with this one.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 建议在继续阅读本文之前，先阅读前一篇文章《使用lambda与标准算法》。
- en: How to do it...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤如下：
- en: 'Write generic lambdas:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 编写通用lambda：
- en: By using the `auto` specifier instead of actual types for lambda expression
    parameters.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`auto`关键字而不是实际类型来定义lambda表达式的参数。
- en: When you need to use multiple lambdas that only differ by their parameter types.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要使用多个lambda，它们之间只有参数类型不同。
- en: The following example shows a generic lambda used with the `std::accumulate()`
    algorithm first with a vector of integers and then with a vector of strings.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了一个通用lambda首先与整数向量一起使用`std::accumulate()`算法，然后与字符串向量一起使用。
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理：
- en: In the example from the previous section, we have defined a named lambda expression,
    that is, a lambda expression that has its closure assigned to a variable. This
    variable is then passed as an argument to the `std::accumulate()` function. This
    general algorithm takes the begin and the end iterators that define a range, an
    initial value to accumulate over, and a function that is supposed to accumulate
    each value in the range to the total. This function takes a first parameter representing
    the currently accumulated value and a second parameter representing the current
    value to accumulate to the total, and it returns the new accumulated value.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节的示例中，我们定义了一个命名的lambda表达式，也就是说，一个具有其闭包分配给变量的lambda表达式。然后将这个变量作为参数传递给`std::accumulate()`函数。这个通用算法接受定义范围的开始和结束迭代器，一个初始值进行累积，并一个函数，该函数应该将范围内的每个值累积到总和中。这个函数接受一个表示当前累积值的第一个参数和一个表示要累积到总和中的当前值的第二个参数，并返回新的累积值。
- en: Note that I did not use the term `add` because this can be used for other things
    than just adding. It can also be used for calculating a product, concatenating,
    or other operations that aggregate values together.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我没有使用术语`add`，因为它不仅仅用于加法。它也可以用于计算乘积、连接或其他将值聚合在一起的操作。
- en: 'The two calls to `std::accumulate()` in this example are almost the same, only
    the types of the arguments are different:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，两次调用`std::accumulate()`几乎相同，只是参数的类型不同：
- en: In the first call, we pass iterators to a range of integers (from a `vector<int>`),
    0 for the initial sum and a lambda that adds two integers and returns their sum.
    This produces a sum of all integers in the range; for this example, it is 22.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一个调用中，我们传递整数范围的迭代器（来自`vector<int>`），初始和为0，并传递一个将两个整数相加并返回它们的和的lambda。这将产生范围内所有整数的和；在这个例子中，结果是22。
- en: In the second call, we pass iterators to a range of strings (from a `vector<string>`),
    an empty string for the initial value, and a lambda that concatenates two strings
    by adding them together and returning the result. This produces a string that
    contains all the strings in the range put together one after an other; for this
    example, the result is *"hello world!"*.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二次调用中，我们传递字符串范围的迭代器（来自`vector<string>`），一个空字符串作为初始值，并传递一个将两个字符串连接在一起并返回结果的lambda。这将产生一个包含范围内所有字符串的字符串，这个例子中结果是"hello
    world!"。
- en: Though generic lambdas can be defined anonymously in the place where they are
    called, it does not really make sense because the very purpose of a generic lambda
    (that is basically, as mentioned earlier, a lambda expression template) is to
    be reused, as shown in the example from the *How to do it...* section.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通用lambda可以在调用它们的地方匿名定义，但这实际上没有意义，因为通用lambda（基本上就是前面提到的lambda表达式模板）的目的是被重用，就像在*操作步骤如下*部分的示例中所示的那样。
- en: 'When defining this lambda expression used with multiple calls to `std::accumulate()`,
    instead of specifying concrete types for the lambda parameters (such as `int`
    or `std::string`) we used the `auto` specifier and let the compiler deduce the
    type. When encountering a lambda expression that has the `auto` specifier for
    a parameter type, the compiler generates an unnamed function object that has a
    call operator template. For the generic lambda expression in this example, the
    function object would look like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义用于多次调用`std::accumulate()`的lambda表达式时，我们使用了`auto`关键字而不是具体类型来指定lambda参数（比如`int`或`std::string`），让编译器推断类型。当遇到lambda表达式的参数类型带有`auto`关键字时，编译器会生成一个没有名字的函数对象，该对象具有调用运算符模板。在这个例子中，通用lambda表达式的函数对象如下：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The call operator is a template with a type parameter for each parameter in
    the lambda that was specified with `auto`. The return type of the call operator
    is also `auto`, which means the compiler will deduce it from the type of the returned
    value. This operator template will be instantiated with the actual types the compiler
    will identify in the context where the generic lambda is used.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 调用运算符是一个模板，对于lambda中使用`auto`指定的每个参数，都有一个类型参数。调用运算符的返回类型也是`auto`，这意味着编译器将从返回值的类型中推断出它。这个操作符模板将使用编译器在使用通用lambda的上下文中识别的实际类型进行实例化。
- en: See also
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Using lambdas with standard algorithms*'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用标准算法与lambda*'
- en: '*Using auto whenever possible* recipe of [Chapter 8](6737b7e9-2260-4f5a-989b-ead3eb7d9dc1.xhtml),
    *Learning Modern Core Language Features*'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*尽可能使用auto* [第8章](6737b7e9-2260-4f5a-989b-ead3eb7d9dc1.xhtml) 的配方，*学习现代核心语言特性*'
- en: Writing a recursive lambda
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写递归lambda
- en: Lambdas are basically unnamed function objects, which means that it should be
    possible to call them recursively. Indeed, they can be called recursively; however,
    the mechanism for doing it is not obvious, as it requires assigning the lambda
    to a function wrapper and capturing the wrapper by reference. Though it can be
    argued that a recursive lambda does not really make sense and a function is probably
    a better design choice, in this recipe we will look at how to write a recursive
    lambda.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda基本上是无名函数对象，这意味着应该可以递归调用它们。事实上，它们可以被递归调用；但是，这样做的机制并不明显，因为它需要将lambda分配给函数包装器，并通过引用捕获包装器。虽然可以说递归lambda实际上并没有太多意义，函数可能是更好的设计选择，但在这个配方中，我们将看看如何编写递归lambda。
- en: Getting ready
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To demonstrate how to write a recursive lambda, we will consider the well-known
    example of the Fibonacci function. This is usually implemented recursively in
    C++, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何编写递归lambda，我们将考虑著名的斐波那契函数的例子。在C++中通常以递归方式实现如下：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How to do it...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In order to write a recursive lambda function, you must perform the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写递归lambda函数，您必须执行以下操作：
- en: Define the lambda in a function scope.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数范围内定义lambda。
- en: Assign the lambda to an `std::function` wrapper.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将lambda分配给`std::function`包装器。
- en: Capture the `std::function` object by reference in the lambda in order to call
    it recursively.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过引用在lambda中捕获`std::function`对象，以便递归调用它。
- en: 'The following are examples of recursive lambdas:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是递归lambda的示例：
- en: 'A recursive Fibonacci lambda expression in the scope of a function that is
    invoked from the scope where it is defined:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在从定义它的范围调用的函数范围内的递归斐波那契lambda表达式：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A recursive Fibonacci lambda expression returned by a function, that can be
    invoked from any scope:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过函数返回的递归斐波那契lambda表达式，可以从任何范围调用：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The first thing you need to consider when writing a recursive lambda is that
    a lambda expression is a function object and, in order to call it recursively
    from the lambda''s body, the lambda must capture its closure (that is, the instantiation
    of the lambda). In other words, the lambda must capture itself and this has several
    implications:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 编写递归lambda时需要考虑的第一件事是，lambda表达式是一个函数对象，为了从lambda的主体递归调用它，lambda必须捕获其闭包（即lambda的实例化）。换句话说，lambda必须捕获自身，这有几个含义：
- en: First of all, the lambda must have a name; an unnamed lambda cannot be captured
    in order to be called again.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，lambda必须有一个名称；无名lambda不能被捕获以便再次调用。
- en: Secondly, the lambda can only be defined in a function scope. The reason for
    this is that a lambda can only capture variables from a function scope; it cannot
    capture any variable that has a static storage duration. Objects defined in a
    namespace scope or with the static or external specifiers have static storage
    duration. If the lambda was defined in a namespace scope, its closure would have
    static storage duration and therefore the lambda would not capture it.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，lambda只能在函数范围内定义。原因是lambda只能捕获函数范围内的变量；它不能捕获任何具有静态存储期的变量。在命名空间范围内或使用static或external说明符定义的对象具有静态存储期。如果lambda在命名空间范围内定义，它的闭包将具有静态存储期，因此lambda将无法捕获它。
- en: The third implication is that the type of the lambda closure cannot remain unspecified,
    that is, be declared with the auto specifier. It is not possible for a variable
    declared with the auto type specifier to appear in its own initializer because
    the type of the variable is not known when the initializer is being processed.
    Therefore, you must specify the type of the lambda closure. The way we can do
    this is using the general purpose function wrapper `std::function`.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个含义是lambda闭包的类型不能保持未指定，也就是说，不能使用auto说明符声明它。因为在处理初始化程序时，变量的类型是未知的，所以无法使用auto类型说明符声明的变量出现在自己的初始化程序中。因此，您必须指定lambda闭包的类型。我们可以使用通用目的的函数包装器`std::function`来做到这一点。
- en: Last, but not least, the lambda closure must be captured by reference. If we
    capture by copy (or value), then a copy of the function wrapper is made, but the
    wrapper is uninitialized when the capturing is done. We end up with an object
    that we are not able to call. Even though the compiler will not complain about
    capturing by value, when the closure is invoked, an `std::bad_function_call` is
    thrown.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，lambda闭包必须通过引用捕获。如果我们通过复制（或值）捕获，那么将会创建函数包装器的副本，但是当捕获完成时，包装器将未初始化。我们最终得到一个无法调用的对象。尽管编译器不会抱怨通过值捕获，但当调用闭包时，会抛出`std::bad_function_call`。
- en: In the first example from the *How to do it...* section, the recursive lambda
    is defined inside another function called `sample()`. The signature and the body
    of the lambda expression are the same as those of the regular recursive function
    `fib()` defined in the introductory section. The lambda closure is assigned to
    a function wrapper called `lfib` that is then captured by reference by the lambda
    and called recursively from its body. Since the closure is captured by reference,
    it will be initialized at the time it has to be called from the lambda's body.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在*如何做...*部分的第一个示例中，递归lambda是在另一个名为`sample()`的函数内部定义的。lambda表达式的签名和主体与介绍部分中定义的常规递归函数`fib()`的相同。lambda闭包被分配给一个名为`lfib`的函数包装器，然后被lambda引用并从其主体递归调用。由于闭包被引用捕获，它将在必须从lambda的主体中调用时初始化。
- en: 'In the second example, we have defined a function that returns the closure
    of a lambda expression that, in turn, defines and invokes a recursive lambda with
    the argument it was, in turn, invoked with. This is a pattern that must be implemented
    when a recursive lambda needs to be returned from a function. This is necessary
    because the lambda closure must still be available at the time the recursive lambda
    is called. If it is destroyed before that, we are left with a dangling reference
    and calling it will cause the program to terminate abnormally. This erroneous
    situation is exemplified in the following sample:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，我们定义了一个函数，该函数返回一个lambda表达式的闭包，该闭包又定义并调用了一个递归lambda，并使用它被调用的参数。当需要从函数返回递归lambda时，必须实现这种模式。这是必要的，因为在递归lambda被调用时，lambda闭包仍然必须可用。如果在那之前它被销毁，我们将得到一个悬空引用，并且调用它将导致程序异常终止。这种错误的情况在以下示例中得到了说明：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The solution for this is to create two nested lambda expressions as shown in
    the *How to do it...* section. The `fib_create()` method returns a function wrapper
    that when invoked creates the recursive lambda that captures itself. This is slightly
    and subtly, yet fundamentally, different from the implementation shown in the
    preceding sample. The outer `f` lambda does not capture anything, especially by
    reference; therefore, we don't have the issue with dangling references. However,
    when invoked, it creates a closure of the nested lambda, the actual lambda we
    are interested in calling and returns the result of applying that recursive `lfib`
    lambda to its parameter.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是在*如何做...*部分中创建两个嵌套的lambda表达式。`fib_create()`方法返回一个函数包装器，当调用时创建捕获自身的递归lambda。这与前面示例中的实现略有不同，但基本上是不同的。外部的`f`
    lambda不捕获任何东西，特别是不捕获引用；因此，我们不会遇到悬空引用的问题。然而，当调用时，它创建了嵌套lambda的闭包，我们感兴趣的实际lambda，并返回将递归的`lfib`
    lambda应用于其参数的结果。
- en: Writing a function template with a variable number of arguments
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写具有可变数量参数的函数模板
- en: It is sometimes useful to write functions with a variable number of arguments
    or classes with a variable number of members. Typical examples include functions
    such as `printf` that take a format and a variable number of arguments, or classes
    such as `tuple`. Before C++11, the former was possible only with the use of variadic
    macros (that enable writing only type-unsafe functions) and the latter was not
    possible at all. C++11 introduced variadic templates, which are templates with
    a variable number of arguments that make it possible to write both type-safe function
    templates with a variable number of arguments and also class templates with a variable
    number of members. In this recipe, we will look at writing function templates.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有时编写具有可变数量参数的函数或具有可变数量成员的类是很有用的。典型的例子包括`printf`这样的函数，它接受格式和可变数量的参数，或者`tuple`这样的类。在C++11之前，前者只能通过使用可变宏（只能编写不安全类型的函数）实现，而后者根本不可能。C++11引入了可变模板，这是具有可变数量参数的模板，可以编写具有可变数量参数的类型安全函数模板，也可以编写具有可变数量成员的类模板。在本示例中，我们将看看如何编写函数模板。
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Functions with a variable number of arguments are called *variadic functions*.
    Function templates with a variable number of arguments are called *variadic function
    templates*. Knowledge of C++ variadic macros (`va_start`, `va_end`, `va_arg` and
    `va_copy`, `va_list`) is not necessary for learning how to write variadic function
    templates, but it represents a good starting point.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 具有可变数量参数的函数称为*可变函数*。具有可变数量参数的函数模板称为*可变函数模板*。学习如何编写可变函数模板并不需要了解C++可变宏（`va_start`、`va_end`、`va_arg`和`va_copy`、`va_list`），但它代表了一个很好的起点。
- en: We have already used variadic templates in our previous recipes, but this one
    will provide detailed explanations.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在之前的示例中使用了可变模板，但这个示例将提供详细的解释。
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In order to write variadic function templates, you must perform the following
    steps:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写可变函数模板，必须执行以下步骤：
- en: Define an overload with a fixed number of arguments to end compile-time recursion
    if the semantics of the variadic function template require it (refer to `[1]`
    in the following code).
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果可变函数模板的语义要求，可以定义一个带有固定数量参数的重载来结束编译时递归（参见以下代码中的`[1]`）。
- en: Define a template parameter pack to introduce a template parameter that can
    hold any number of arguments, including zero; these arguments can be either types,
    non-types, or templates (refer to `[2]`).
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个模板参数包，引入一个可以容纳任意数量参数的模板参数，包括零个；这些参数可以是类型、非类型或模板（参见`[2]`）。
- en: Define a function parameter pack to hold any number of function arguments, including
    zero; the size of the template parameter pack and the corresponding function parameter
    pack is the same and can be determined with the `sizeof...` operator (refer to
    `[3]`).
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数参数包，用于保存任意数量的函数参数，包括零个；模板参数包的大小和相应的函数参数包的大小相同，并且可以使用`sizeof...`运算符确定（参见`[3]`）。
- en: Expand the parameter pack in order to replace it with the actual arguments being
    supplied (refer to `[4]`).
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展参数包，以替换为提供的实际参数（参考`[4]`）。
- en: 'The following example that illustrates all the preceding points, is a variadic
    function template that adds a variable number of arguments using `operator+`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了所有前面的观点，是一个可变参数函数模板，它使用`operator+`来添加可变数量的参数：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: At a first look, the preceding implementation looks like recursion, because
    function `add()` calls itself, and in a way it is, but it is a compile-time recursion
    that does not incur any sort of runtime recursion and overhead. The compiler actually
    generates several functions with a different number of arguments, based on the
    variadic function template usage, so it is only function overloading that is involved
    and not any sort of recursion. However, implementation is done as if parameters
    would be processed in a recursive manner with an end condition.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，前面的实现看起来像是递归，因为函数`add()`调用了自身，从某种意义上来说确实是，但它是一种不会产生任何运行时递归和开销的编译时递归。编译器实际上会生成几个具有不同参数数量的函数，基于可变参数函数模板的使用，因此只涉及函数重载，而不涉及任何递归。然而，实现是按照参数会以递归方式处理并具有结束条件的方式进行的。
- en: 'In the preceding code we can identify the following key parts:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以识别出以下关键部分：
- en: '`Typename... Ts` is a template parameter pack that indicates a variable number
    of template type arguments.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Typename... Ts`是指示可变数量模板类型参数的模板参数包。'
- en: '`Ts... rest` is a function parameter pack that indicates a variable number
    of function arguments.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ts... rest`是指示可变数量函数参数的函数参数包。'
- en: '`Rest...` is an expansion of the function parameter pack.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rest...`是函数参数包的扩展。'
- en: The position of the ellipsis is not syntactically relevant. `typename... Ts`,
    `typename ... Ts`, and `typename ...Ts` are all equivalent.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 省略号的位置在语法上并不重要。`typename... Ts`，`typename ... Ts`和`typename ...Ts`都是等效的。
- en: In the `add(T head, Ts... rest)` parameter, `head` is the first element of the
    list of arguments, and `...rest` is a pack with the rest of the parameters in
    the list (this can be zero or more). In the body of the function, `rest...` is
    an expansion of the function parameter pack. This means the compiler replaces
    the parameter pack with its elements in their order. In the `add()` function,
    we basically add the first argument to the sum of the remaining arguments, which
    gives the impression of a recursive processing. This recursion ends when there
    is a single argument left, in which case the first `add()` overload (with a single
    argument) is called and returns the value of its argument.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在`add(T head, Ts... rest)`参数中，`head`是参数列表的第一个元素，`...rest`是列表中其余参数的包（可以是零个或多个）。在函数的主体中，`rest...`是函数参数包的扩展。这意味着编译器会用它们的顺序替换参数包中的元素。在`add()`函数中，我们基本上将第一个参数添加到其余参数的总和中，这给人一种递归处理的印象。当只剩下一个参数时，递归就会结束，在这种情况下，将调用第一个`add()`重载（带有单个参数）并返回其参数的值。
- en: 'This implementation of the function template `add()` enables us to write code,
    as shown here:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数模板`add()`的实现使我们能够编写如下代码：
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When the compiler encounters `add(1, 2, 3, 4, 5)`, it generates the following
    functions (`arg1`, `arg2`, and so on, are not the actual names the compiler generates)
    that show this is actually only calls to overloaded functions and not recursion:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器遇到`add(1, 2, 3, 4, 5)`时，它会生成以下函数（`arg1`，`arg2`等等，并不是编译器生成的实际名称），显示这实际上只是对重载函数的调用，而不是递归：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With GCC and Clang, you can use the `__PRETTY_FUNCTION__` macro to print the
    name and the signature of the function.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GCC和Clang，您可以使用`__PRETTY_FUNCTION__`宏来打印函数的名称和签名。
- en: 'By adding a `std::cout << __PRETTY_FUNCTION__ << std::endl` at the beginning
    of the two functions we wrote, we get the following when running the code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在我们编写的两个函数的开头添加`std::cout << __PRETTY_FUNCTION__ << std::endl`，在运行代码时我们得到以下结果：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Since this is a function template, it can be used with any type that supports
    `operator+`. The other example, `add("hello"s, " "s, "world"s, "!"s)`, produces
    the *"hello world!"* string. However, the `std::basic_string` type has different
    overloads for `operator+`, including one that can concatenate a string to a character,
    so we should be able to also write the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个函数模板，它可以与支持`operator+`的任何类型一起使用。另一个例子，`add("hello"s, " "s, "world"s, "!"s)`，产生了字符串`"hello
    world!"`。然而，`std::basic_string`类型有不同的`operator+`重载，包括一个可以将字符串连接到字符的重载，因此我们应该也能够编写以下内容：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'However, that will generate compiler errors as follows (note that I actually
    replaced `std::basic_string<char, std::char_traits<char>, std::allocator<char>
    >` with string *"hello world"* for simplicity):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这将生成如下的编译器错误（请注意，我实际上用字符串“hello world”替换了`std::basic_string<char, std::char_traits<char>,
    std::allocator<char> >`以简化）：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'What happens is that the compiler generates the code shown next where the return
    type is the same as the type of the first argument. However, the first argument
    is either a `std::string` or a `char` (again, `std::basic_string<char, std::char_traits<char>,
    std::allocator<char> >` was replaced with `string` for simplicity). In cases where
    `char` is the type of the first argument, the type of the return value `head+add(...)`
    that is an `std::string` does not match the function return type and does not
    have an implicit conversion to it:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的情况是，编译器生成了下面显示的代码，其中返回类型与第一个参数的类型相同。然而，第一个参数是`std::string`或`char`（再次，`std::basic_string<char,
    std::char_traits<char>, std::allocator<char> >`被替换为`string`以简化）。在第一个参数的类型为`char`的情况下，返回值的类型`head+add(...)`是`std::string`，它与函数返回类型不匹配，并且没有隐式转换为它：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can fix this by modifying the variadic function template to have `auto`
    for the return type instead of `T`. In this case, the return type is always inferred
    from the return expression, and in our example, it will be `std::string` in all
    cases:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过修改可变参数函数模板，将返回类型改为`auto`而不是`T`来解决这个问题。在这种情况下，返回类型总是从返回表达式中推断出来，在我们的例子中，它将始终是`std::string`。
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It should be further added that a parameter pack can appear in a brace-initialization
    and its size can be determined using the `sizeof...` operator. Also, variadic
    function templates do not necessarily imply compile-time recursion as we have
    shown in this recipe. All these are shown in the following example where we define
    a function that creates a tuple with an even number of members. We first use `sizeof...(a)`
    to make sure that we have an even number of arguments and assert by generating
    a compiler error otherwise. The `sizeof...` operator can be used with both template
    parameter packs and function parameter packs. `sizeof...(a)` and `sizeof...(T)`
    would produce the same value. Then, we create and return a tuple. The template
    parameter pack `T` is expanded (with `T...`) into the type arguments of the `std::tuple`
    class template, and the function parameter pack `a` is expanded (with `a...`)
    into the values for the tuple members using brace initialization:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 还应该进一步补充的是，参数包可以出现在大括号初始化中，并且可以使用`sizeof...`运算符确定其大小。此外，可变函数模板并不一定意味着编译时递归，正如我们在本配方中所示的那样。所有这些都在以下示例中展示，其中我们定义了一个创建具有偶数成员的元组的函数。我们首先使用`sizeof...(a)`来确保我们有偶数个参数，并通过生成编译器错误来断言否则。`sizeof...`运算符既可以用于模板参数包，也可以用于函数参数包。`sizeof...(a)`和`sizeof...(T)`将产生相同的值。然后，我们创建并返回一个元组。模板参数包`T`被展开（使用`T...`）为`std::tuple`类模板的类型参数，并且函数参数包`a`被展开（使用`a...`）为元组成员的值，使用大括号初始化：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: See also
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Using fold expressions to simplify variadic function templates*'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用折叠表达式简化可变函数模板*'
- en: '*Creating raw user-defined literals* recipe of [Chapter 9](9830e5b8-a9ca-41e8-b565-8800a82d9caa.xhtml),
    *Working with Numbers and*'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第9章](9830e5b8-a9ca-41e8-b565-8800a82d9caa.xhtml)的*创建原始用户定义字面量*配方中，*使用数字和*'
- en: '*Strings*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符串*'
- en: Using fold expressions to simplify variadic function templates
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用折叠表达式简化可变函数模板
- en: In this chapter, we are discussing folding several times; this is an operation
    that applies a binary function to a range of values to produce a single value.
    We have seen this when we discussed variadic function templates and will see it
    again with higher-order functions. It turns out there is a significant number
    of cases where the expansion of a parameter pack in variadic function templates
    is basically a folding operation. To simplify writing such variadic function templates
    C++17 introduced fold expressions that fold an expansion of a parameter pack over
    a binary operator. In this recipe, we will see how to use fold expressions to
    simplify writing variadic function templates.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们多次讨论了折叠；这是一种将二元函数应用于一系列值以产生单个值的操作。我们在讨论可变函数模板时已经看到了这一点，并且将在高阶函数中再次看到。事实证明，在编写可变函数模板中参数包的展开基本上是一种折叠操作的情况相当多。为了简化编写这样的可变函数模板，C++17引入了折叠表达式，它将参数包的展开折叠到二元运算符上。在本配方中，我们将看到如何使用折叠表达式来简化编写可变函数模板。
- en: Getting ready
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The examples in this recipe are based on the variadic function template `add()`
    that we wrote in the previous recipe, *Writing a function template with a variable
    number of arguments*. That implementation is a left-folding operation. For simplicity,
    we present the function again:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方中的示例基于我们在上一个配方*编写具有可变数量参数的函数模板*中编写的可变函数模板`add()`。该实现是一个左折叠操作。为简单起见，我们再次呈现该函数：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How to do it...
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To fold a parameter pack over a binary operator, use one of the following forms:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要在二元运算符上折叠参数包，请使用以下形式之一：
- en: 'Left folding with a unary form `(... op pack)`:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一元形式的左折叠`(... op pack)`：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Left folding with a binary form `(init op ... op pack)`:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二元形式的左折叠`(init op ... op pack)`：
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Right folding with a unary form `(pack op ...)`:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一元形式的右折叠`(pack op ...)`：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Right folding with a binary form `(pack op ... op init)`:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一元形式的右折叠`(pack op ... op init)`：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The parentheses shown above are part of the fold expression and cannot be omitted.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 上面显示的括号是折叠表达式的一部分，不能省略。
- en: How it works...
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When the compiler encounters a fold expression, it expands it in one of the
    following expressions:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器遇到折叠表达式时，它会将其扩展为以下表达式之一：
- en: '| **Expression** | **Expansion** |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** | **展开** |'
- en: '| `(... op pack)` | ((pack$1 op pack$2) op ...) op pack$n |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '`(... op pack)` | ((pack$1 op pack$2) op ...) op pack$n |'
- en: '| `(init op ... op pack)` | (((init op pack$1) op pack$2) op ...) op pack$n
    |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '`(init op ... op pack)` | (((init op pack$1) op pack$2) op ...) op pack$n |'
- en: '| `(pack op ...)` | pack$1 op (... op (pack$n-1 op pack$n)) |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '`(pack op ...)` | pack$1 op (... op (pack$n-1 op pack$n)) |'
- en: '| `(pack op ... op init)` | pack$1 op (... op (pack$n-1 op (pack$n op init)))
    |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '`(pack op ... op init)` | pack$1 op (... op (pack$n-1 op (pack$n op init)))
    |'
- en: When the binary form is used, the operator on both the left-hand and right-hand
    side of the ellipses must be the same, and the initialization value must not contain
    an unexpanded parameter pack.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用二元形式时，省略号的左右两侧的运算符必须相同，并且初始化值不能包含未展开的参数包。
- en: 'The following binary operators are supported with fold expressions:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下二元运算符支持折叠表达式：
- en: '| + | - | * | / | % | ^ | & | &#124; | = | < | > | << |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: 加 | 减 | 乘 | 除 | 取余 | 指数 | 与 | 或 | 等于 | 小于 | 大于 | 左移
- en: '| >> | += | -= | *= | /= | %= | ^= | &= | &#124;= | <<= | >>= | == |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| >> | += | -= | *= | /= | %= | ^= | &= | &#124;= | <<= | >>= | =='
- en: '| != | <= | >= | && | &#124;&#124; | , | .* | ->*. |  |  |  |  |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| != | <= | >= | && | &#124;&#124; | , | .* | ->*. |  |  |  |  |'
- en: 'When using the unary form, only operators such as `*`, `+`, `&`, `|`, `&&`,
    `||`, and `,` (comma) are allowed with an empty parameter pack. In this case,
    the value of the empty pack is as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用一元形式时，只允许使用诸如`*`，`+`，`&`，`|`，`&&`，`||`和`,`（逗号）等运算符与空参数包一起。在这种情况下，空包的值如下：
- en: '| `+` | `0` |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '`+` | `0`'
- en: '| `*` | `1` |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '`*` | `1`'
- en: '| `&` | `-1` |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '`&` | `-1`'
- en: '| `&#124;` | `0` |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '`&#124;` | `0`'
- en: '| `&&` | `true` |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '`&&` | `true`'
- en: '| `&#124;&#124;` | `false` |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '`&#124;&#124;` | `false`'
- en: '| `,` | `void()` |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `,` | `void()` |'
- en: 'Now that we have the function templates implemented earlier (let''s consider
    the left-folding version), we can write the following code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了之前的函数模板（让我们考虑左折叠版本），我们可以编写以下代码：
- en: '[PRE35]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Considering the  `add(1, 2, 3, 4, 5)` call, it would produce the following
    function:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到`add(1, 2, 3, 4, 5)`的调用，它将产生以下函数：
- en: '[PRE36]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Due to the aggressive ways modern compilers do optimizations, this function
    can be inlined and eventually end up with an expression such as `auto sum = 1
    + 2 + 3 + 4 + 5`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现代编译器进行优化的激进方式，这个函数可以被内联，最终得到一个表达式，如`auto sum = 1 + 2 + 3 + 4 + 5`。
- en: There's more...
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Fold expressions work with all overloads for the supported binary operators,
    but do not work with arbitrary binary functions. It is possible to implement a
    workaround for that by providing a wrapper type to hold a value and an overloaded
    operator for that wrapper type:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Fold表达式适用于所有支持的二元运算符的重载，但不适用于任意的二元函数。可以通过提供一个包装类型来实现对此的解决方法，以保存一个值和一个重载的运算符来实现：
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the preceding code, `wrapper` is a simple class template that holds a constant
    reference to a value of type `T`. An overloaded `operator<` is provided for this
    class template; this overload does not return a Boolean to indicate that the first
    argument is less than the second, but actually an instance of the `wrapper` class
    type to hold the minimum value of the two arguments. The variadic function template
    `min()` uses this overloaded `operator<` to fold the pack of arguments expanded
    to instances of the wrapper class template:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`wrapper`是一个简单的类模板，它保存了类型为`T`的值的常量引用。为这个类模板提供了重载的`operator<`；这个重载并不返回一个布尔值来指示第一个参数是否小于第二个参数，而是实际上返回`wrapper`类类型的一个实例，以保存这两个参数的最小值。可变函数模板`min()`使用这个重载的`operator<`来将展开为`wrapper`类模板实例的参数包进行折叠：
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: See also
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Implementing higher-order functions map and fold*'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现高阶函数map和fold*'
- en: Implementing higher-order functions map and fold
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现高阶函数map和fold
- en: Throughout the preceding recipes in this book, we have used the general purpose
    algorithms `std::transform()` and `std::accumulate()` in several examples, such
    as implementing string utilities to create uppercase or lowercase copies of a
    string or summing the values of a range. These are basically implementations of
    higher-order functions, `map` and `fold`. A higher-order function is a function
    that takes one or more other functions as arguments and applies them to a range
    (a list, vector, map, tree, and so on), producing either a new range or a value.
    In this recipe, we will see how to implement `map` and `fold` functions to work
    with C++ standard containers.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前面几个示例中，我们使用了通用算法`std::transform()`和`std::accumulate()`，例如实现字符串工具来创建字符串的大写或小写副本，或者对范围的值进行求和。这些基本上是高阶函数`map`和`fold`的实现。高阶函数是一个接受一个或多个其他函数作为参数并将它们应用于范围（列表、向量、映射、树等）的函数，产生一个新的范围或值。在这个示例中，我们将看到如何实现`map`和`fold`函数来处理C++标准容器。
- en: Getting ready
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: '*Map* is a higher-order function that applies a function to the elements of
    a range and returns a new range in the same order.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*Map*是一个高阶函数，它将一个函数应用于范围的元素，并按相同的顺序返回一个新的范围。'
- en: '*Fold* is a higher-order function that applies a combining function to the
    elements of the range producing a single result. Since the order of the processing
    can be important, there are usually two versions of this function--`foldleft`,
    that processes elements from left to right, and **`foldright`** that combines
    the elements from right to left.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*Fold*是一个高阶函数，它将一个组合函数应用于范围的元素，产生一个单一的结果。由于处理的顺序可能很重要，通常有两个版本的这个函数--`foldleft`，从左到右处理元素，和**`foldright`**，从右到左组合元素。'
- en: Most descriptions of the function map indicate that it is applied to a `list`,
    but this is a general term that can indicate different sequential types, such
    as list, vector, and array, and also dictionaries (that is, maps), queues, and
    so on. For this reason, I prefer to use the term range when describing these higher-order
    functions.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数对map函数的描述表明它适用于`list`，但这是一个通用术语，可以表示不同的顺序类型，如列表、向量和数组，还有字典（即映射）、队列等。因此，我更喜欢在描述这些高阶函数时使用术语范围。
- en: How to do it...
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To implement the `map` function you should:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现`map`函数，您应该：
- en: 'Use `std::transform` on containers that support iterating and assignment to
    the elements, such as `std::vector` or `std::list`:'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在支持迭代和对元素进行赋值的容器上使用`std::transform`，如`std::vector`或`std::list`：
- en: '[PRE39]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Use other means such as explicit iteration and insertion for containers that
    do not support assignment to the elements, such as `std::map`:'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于不支持对元素进行赋值的容器，如`std::map`，请使用显式迭代和插入等其他方法：
- en: '[PRE40]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To implement the `fold` function you should:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现`fold`函数，您应该：
- en: 'Use `std::accumulate()` on containers that support iterating:'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在支持迭代的容器上使用`std::accumulate()`：
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Use other means to explicitly process containers that do not support iterating,
    such as `std::queue`:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用其他方法显式处理不支持迭代的容器，如`std::queue`：
- en: '[PRE42]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: How it works...
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the preceding examples, we have implemented the map in a functional way,
    without side-effects. That means it preserves the original range and returns a
    new one. The arguments of the function are the function to apply and the range.
    In order to avoid confusion with the `std::map` container, we have called this
    function `mapf`. There are several overloads for `mapf` as shown earlier:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们以一种功能方式实现了map，没有副作用。这意味着它保留了原始范围并返回了一个新的范围。函数的参数是要应用的函数和范围。为了避免与`std::map`容器混淆，我们将这个函数称为`mapf`。有几个`mapf`的重载，如前面所示：
- en: The first overload is for containers that support iterating and assignment to
    its elements; this includes `std::vector`, `std::list`, and `std::array`, but
    also C-like arrays. The function takes an `rvalue` reference to a function and
    a range for which `std::begin()` and `std::end()` are defined. The range is passed
    by value so that modifying the local copy does not affect the original range.
    The range is transformed by applying the given function to each element using
    the standard algorithm `std::transform()`; the transformed range is then returned.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个重载适用于支持迭代和对其元素赋值的容器；这包括`std::vector`、`std::list`和`std::array`，还有类似C的数组。该函数接受一个对函数的`rvalue`引用和一个范围，其中`std::begin()`和`std::end()`被定义。范围通过值传递，这样修改本地副本不会影响原始范围。通过应用给定函数对每个元素使用标准算法`std::transform()`来转换范围；然后返回转换后的范围。
- en: The second overload is specialized for `std::map` that does not support direct
    assignment to its elements (`std::pair<T, U>`). Therefore, this overload creates
    a new map, then iterates through its elements using a range-based for loop, and
    inserts into the new map the result of applying the input function to each element
    of the original map.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个重载专门针对不支持直接赋值给其元素（`std::pair<T, U>`）的`std::map`。因此，这个重载创建一个新的映射，然后使用基于范围的for循环遍历其元素，并将应用输入函数的结果插入到新映射中。
- en: The third overload is specialized for `std::queue`, which is a container that
    does not support iterating. It can be argued that a queue is not a typical structure
    to map over, but for the sake of demonstrating different possible implementations,
    we are considering it. In order to iterate over the elements of a queue, the queue
    must be altered--you need to pop elements from the front until the list is empty.
    This is what the third overload does--it processes each element of the input queue
    (passed by value) and pushes the result of applying the given function to the
    front element of the remaining queue.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个重载专门针对`std::queue`，这是一个不支持迭代的容器。可以说队列不是一个典型的映射结构，但为了演示不同的可能实现，我们考虑它。为了遍历队列的元素，必须改变队列--需要从前面弹出元素，直到列表为空。这就是第三个重载所做的--它处理输入队列的每个元素（通过值传递），并将应用给定函数的结果推送到剩余队列的前端元素。
- en: 'Now that we have these overloads implemented, we can apply them to a lot of
    containers, as shown in the following examples (notice that the map and fold functions
    used here are implemented in a namespace called funclib in the code accompanying
    the book and therefore shown with the fully qualified name):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了这些重载，我们可以将它们应用到许多容器中，如下面的例子所示（请注意，这里使用的map和fold函数在附带书籍的代码中实现在名为funclib的命名空间中，因此显示为完全限定名称）：
- en: Retain absolute values from a vector. In this example, the vector contains both
    negative and positive values. After applying the mapping, the result is a new
    vector with only positive values.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留向量中的绝对值。在这个例子中，向量包含负值和正值。应用映射后，结果是一个只包含正值的新向量。
- en: '[PRE43]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Square the numerical values of a list. In this example, the list contains integral
    values. After applying the mapping, the result is a list containing the squares
    of the initial values.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对列表中的数值进行平方。在这个例子中，列表包含整数值。应用映射后，结果是一个包含初始值的平方的列表。
- en: '[PRE44]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Rounded amounts of floating point. For this example, we need to use `std::round()`;
    however, this has overloads for all floating point types, which makes it impossible
    for the compiler to pick the right one. As a result, we either have to write a
    lambda that takes an argument of a specific floating point type and returns the
    value of `std::round()` applied to that value or create a function object template
    that wraps `std::round()` and enables its call operator only for floating point
    types. This technique is used in the following example:'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点数的四舍五入金额。在这个例子中，我们需要使用`std::round()`；然而，这个函数对所有浮点类型都有重载，这使得编译器无法选择正确的重载。因此，我们要么编写一个接受特定浮点类型参数并返回应用于该值的`std::round()`值的lambda，要么创建一个函数对象模板，包装`std::round()`并仅对浮点类型启用其调用运算符。这种技术在下面的例子中使用：
- en: '[PRE45]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Uppercase the string keys of a map of words (where the key is the word and
    the value is the number of appearances in the text). Note that creating an uppercase
    copy of a string is itself a mapping operation. Therefore, in this example, we
    use `mapf` to apply `toupper()` to the elements of the string representing the
    key in order to produce an uppercase copy:'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将单词映射的地图键大写（其中键是单词，值是在文本中出现的次数）。请注意，创建字符串的大写副本本身就是一个映射操作。因此，在这个例子中，我们使用`mapf`将`toupper()`应用于表示键的字符串的元素，以产生一个大写副本。
- en: '[PRE46]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Normalize values from a queue of priorities--initially, the values are from
    1 to 100, but we want to normalize them into two values, 1=high and 2=normal.
    All initial priorities that have a value up to 30 become a high priority, the
    others get a normal priority:'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从优先级队列中规范化数值--最初，数值范围是1到100，但我们希望将它们规范化为两个值，1=高和2=正常。所有初始优先级的值最多为30的变为高优先级，其他的变为正常优先级：
- en: '[PRE47]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: To implement `fold`, we actually have to consider the two possible types of
    folding, that is, from left to right and from right to left. Therefore, we have
    provided two functions called `foldl` (for left folding) and `foldr` (for right
    folding). The implementations shown in the previous section are very similar--they
    both take a function, a range, and an initial value and call `std::algorithm()`
    to fold the values of the range into a single value. However, `foldl` uses direct
    iterators, whereas `foldr` uses reverse iterators to traverse and process the
    range. The second overload is a specialization for type `std::queue`, which does
    not have iterators.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现`fold`，我们实际上必须考虑两种可能的折叠类型，即从左到右和从右到左。因此，我们提供了两个名为`foldl`（用于左折叠）和`foldr`（用于右折叠）的函数。在前一节中显示的实现非常相似--它们都接受一个函数、一个范围和一个初始值，并调用`std::algorithm()`将范围的值折叠成一个值。然而，`foldl`使用直接迭代器，而`foldr`使用反向迭代器来遍历和处理范围。第二个重载是`std::queue`类型的特化，它没有迭代器。
- en: 'Based on these implementations for folding, we can do the following examples:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些折叠实现，我们可以进行以下示例：
- en: 'Adding the values of a vector of integers. In this case, both left and right
    folding will produce the same result. In the following examples, we pass either
    a lambda that takes a sum and a number and returns a new sum or the function object
    `std::plus<>` from the standard library that applies `operator+` to two operands
    of the same type (basically similar to the closure of the lambda):'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加整数向量的值。在这种情况下，左折叠和右折叠将产生相同的结果。在以下示例中，我们传递一个lambda，它接受一个和一个数字并返回一个新的和，或者从标准库中使用`std::plus<>`函数对象，它将`operator+`应用于相同类型的两个操作数（基本上类似于lambda的闭包）：
- en: '[PRE48]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Concatenating strings from a vector into a single string:'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将字符串从向量连接成一个字符串：
- en: '[PRE49]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Concatenating an array of characters into a string:'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将字符数组连接成一个字符串：
- en: '[PRE50]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Counting the number of words from a text based on their already computed appearances
    available in a `map<string, int>`:'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据`map<string, int>`中已计算出现次数的单词数量来计算文本中单词的数量：
- en: '[PRE51]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: There's more...
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'These functions can be pipelined, that is, they can call one function with
    the result of another. The following example maps a range of integers into a range
    of positive integers by applying the `std::abs()` function to its elements. The
    result is then mapped into another range of squares. These are then summed together
    by applying a left fold on the range:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数可以被串联，也就是说，它们可以用另一个函数调用另一个函数的结果。以下示例将整数范围映射为正整数范围，方法是将`std::abs()`函数应用于其元素。然后将结果映射到另一个平方范围。然后通过在范围上应用左折叠将它们相加：
- en: '[PRE52]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'As an exercise, we could implement the fold function as a variadic function
    template, in the manner seen in a previous recipe. The function that performs
    the actual folding is provided as an argument:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，我们可以按照前面配方中所见的方式，将fold函数实现为一个可变参数函数模板。执行实际折叠的函数作为参数提供：
- en: '[PRE53]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'When we compare this with the `add()` function template that we wrote in the
    recipe *Writing a function template with a variable number of arguments*, we can
    notice several differences:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将这与我们在配方*编写具有可变数量参数的函数模板*中编写的`add()`函数模板进行比较时，我们可以注意到几个不同之处：
- en: The first argument is a function, which is perfectly forwarded when calling
    `foldl` recursively.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是一个函数，在递归调用`foldl`时可以完全转发。
- en: The end case is a function that requires two arguments because the function
    we use for folding is a binary one (taking two arguments).
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结束情况是一个需要两个参数的函数，因为我们用于折叠的函数是一个二元函数（接受两个参数）。
- en: 'The return type of the two functions we wrote is declared as `auto` because
    it must match the return type of the supplied binary function `f` that is not
    known until we call `foldl`:'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们编写的两个函数的返回类型声明为`auto`，因为它必须匹配提供的二元函数`f`的返回类型，直到我们调用`foldl`为止，这是不知道的：
- en: '[PRE54]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: See also
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Creating a library of string helpers* recipe of [Chapter 9](9830e5b8-a9ca-41e8-b565-8800a82d9caa.xhtml),
    *Working with Numbers and Strings*'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建字符串助手库* 第9章的配方[9830e5b8-a9ca-41e8-b565-8800a82d9caa.xhtml]，*处理数字和字符串*'
- en: '*Writing a function template with a variable number of arguments*'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写具有可变数量参数的函数模板*'
- en: '*Composing functions into a higher-order function*'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将函数组合成高阶函数*'
- en: Composing functions into a higher-order function
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将函数组合成高阶函数
- en: In the previous recipe, we implemented two higher-order functions, map and fold,
    and saw various examples of using them. At the end of the recipe, we saw how they
    can be pipelined to produce a final value after several transformations of the
    original data. Pipelining is a form of composition, which means creating one new
    function from two or more given functions. In the mentioned example, we didn't
    actually compose functions; we only called a function with the result produced
    by another, but in this recipe, we will see how to actually compose functions
    together into a new function. For simplicity, we will only consider unary functions
    (functions that take only one argument).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个配方中，我们实现了两个高阶函数，map和fold，并看到了它们的各种使用示例。在配方的结尾，我们看到它们如何可以被串联起来，在对原始数据进行多次转换后产生最终值。管道是一种组合形式，意味着从两个或更多给定函数创建一个新函数。在上述示例中，我们实际上并没有组合函数；我们只是调用了一个函数，其结果由另一个函数产生，但在这个配方中，我们将看到如何将函数实际组合到一起成为一个新函数。为简单起见，我们只考虑一元函数（只接受一个参数的函数）。
- en: Getting ready
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before you go forward, it is recommended that you read the previous recipe,
    *Implementing higher-order functions map and fol*d. It is not mandatory for understanding
    this recipe, but we will refer to the map and fold functions implemented here.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '在继续之前，建议您阅读前一篇配方*实现高阶函数map和fol*d。这不是理解本配方的必要条件，但我们将引用这里实现的map和fold函数。 '
- en: How to do it...
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'To compose unary functions into a higher-order function, you should:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一元函数组合成高阶函数，您应该：
- en: 'For composing two functions, provide a function that takes two functions, `f` and
    `g`, as arguments and returns a new function (a lambda) that returns `f(g(x))`
    where `x` is the argument of the composed function:'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要组合两个函数，提供一个接受两个函数`f`和`g`作为参数并返回一个新函数（lambda）的函数，该函数返回`f(g(x))`，其中`x`是组合函数的参数：
- en: '[PRE55]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'For composing a variable number of functions, provide a variadic template overload
    of the function described previously:'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要组合可变数量的函数，提供先前描述的函数的可变模板重载：
- en: '[PRE56]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: How it works...
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Composing two unary functions into a new one is relatively trivial. Create a
    template function that we called `compose()` in the earlier examples, with two
    arguments--`f` and `g`--that represent functions, and return a function that takes
    one argument `x` and returns `f(g(x))`. It is important though that the type of
    the value returned by the `g` function is the same as the type of the argument
    of the `f` function. The returned value of the compose function is a closure,
    that is, an instantiation of a lambda.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个一元函数组合成一个新函数相对较简单。创建一个我们在之前的示例中称为`compose()`的模板函数，它有两个参数--`f`和`g`--代表函数，并返回一个接受一个参数`x`并返回`f(g(x))`的函数。但是重要的是，`g`函数返回的值的类型与`f`函数的参数的类型相同。`compose`函数的返回值是一个闭包，即一个lambda的实例。
- en: 'In practice, it is useful to be able to combine more than just two functions
    together. This can be achieved by writing a variadic template version of the `compose()`
    function. Variadic templates are explained in more detail in the *Writing a function
    template with a variable number of arguments* recipe. Variadic templates imply
    compile-time recursion by expanding the parameter pack. This implementation is
    very similar to the first version of `compose()`, except as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，能够组合不止两个函数是很有用的。这可以通过编写`compose()`函数的可变模板版本来实现。可变模板在*编写具有可变数量参数的函数模板*配方中有更详细的解释。可变模板意味着通过扩展参数包进行编译时递归。这个实现与`compose()`的第一个版本非常相似，只是如下：
- en: It takes a variable number of functions as arguments.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它接受可变数量的函数作为参数。
- en: The returned closure calls `compose()` recursively with the expanded parameter
    pack; recursion ends when only two functions are left, in which case, the previously
    implemented overload is called.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回的闭包使用扩展的参数包递归调用`compose()`；递归在只剩下两个函数时结束，在这种情况下，调用先前实现的重载。
- en: Even if the code looks like recursion is happening, this is not true recursion.
    It could be called compile-time recursion, but with every expansion, we get a
    call to another method with the same name but a different number of arguments,
    which does not represent recursion.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 即使代码看起来像是发生了递归，这并不是真正的递归。这可以称为编译时递归，但是随着每次扩展，我们会得到对另一个具有相同名称但不同数量参数的方法的调用，这并不代表递归。
- en: 'Now that we have these variadic template overloads implemented, we can rewrite
    the last example from the previous recipe, *Implementing higher-order functions
    map and fold*. Having an initial vector of integers, we map it to a new vector
    with only positive values by applying `std::abs()` on each element. The result
    is then mapped to a new vector by doubling the value of each element. Finally,
    the values in the resulting vector are folded together by adding them to the initial
    value 0:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了这些可变模板重载，我们可以重写上一个配方*实现高阶函数map和fold*中的最后一个示例。有一个初始整数向量，我们通过对每个元素应用`std::abs()`将其映射到只有正值的新向量。然后，将结果映射到一个新向量，方法是将每个元素的值加倍。最后，将结果向量中的值通过将它们添加到初始值0来折叠在一起：
- en: '[PRE57]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: There's more...
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Composition is usually represented by a dot (`.`) or asterisk (`*`), such as
    `f . g` or `f * g`. We can actually do something similar in C++ by overloading
    `operator*` (it would make little sense to try to overload operator dot). Similar
    to the `compose()` function, `operator*` should work with any number of arguments;
    therefore, we will have two overloads, just like in the case of `compose()`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 组合通常用点（`.`）或星号（`*`）表示，比如`f . g`或`f * g`。我们实际上可以在C++中做类似的事情，通过重载`operator*`（尝试重载操作符点没有多大意义）。与`compose()`函数类似，`operator*`应该适用于任意数量的参数；因此，我们将有两个重载，就像在`compose()`的情况下一样：
- en: The first overload takes two arguments and calls `compose()` to return a new
    function.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个重载接受两个参数并调用`compose()`返回一个新函数。
- en: 'The second overload is a variadic template function that again calls `operator*`
    by expanding the parameter pack:'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个重载是一个可变模板函数，再次通过扩展参数包调用`operator*`：
- en: '[PRE58]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We can now simplify the actual composition of functions by applying `operator*`
    instead of the more verbose call to compose:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过应用`operator*`来简化函数的实际组合，而不是更冗长地调用compose：
- en: '[PRE60]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: See also
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Writing a function template with a variable number of arguments*'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写具有可变数量参数的函数模板*'
- en: Uniformly invoking anything callable
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统一调用任何可调用对象
- en: Developers, and especially those who implement libraries, sometimes need to
    invoke a callable object in a uniform manner. This can be a function, a pointer
    to a function, a pointer to a member function, or a function object. Examples
    of such cases include `std::bind`, `std::function`, `std::mem_fn`, and `std::thread::thread`.
    C++17 defines a standard function called `std::invoke()` that can invoke any callable
    object with the provided arguments. This is not intended to replace direct calls
    to functions or function objects, but it is useful in template metaprogramming
    for implementing various library functions.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员，特别是那些实现库的人，有时需要以统一的方式调用可调用对象。这可以是一个函数，一个指向函数的指针，一个指向成员函数的指针，或者一个函数对象。这种情况的例子包括`std::bind`，`std::function`，`std::mem_fn`和`std::thread::thread`。C++17定义了一个名为`std::invoke()`的标准函数，可以使用提供的参数调用任何可调用对象。这并不意味着要取代对函数或函数对象的直接调用，但在模板元编程中实现各种库函数时非常有用。
- en: Getting ready
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: For this recipe, you should be familiar with how to define and use function
    pointers.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，您应该熟悉如何定义和使用函数指针。
- en: 'To exemplify how `std::invoke()` can be used in different contexts, we will
    use the following function and class:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明 `std::invoke()` 如何在不同的上下文中使用，我们将使用以下函数和类：
- en: '[PRE61]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: How to do it...
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The `std::invoke()` function is a variadic function template that takes the
    callable object as the first argument and a variable list of arguments that are
    passed to the call. `std::invoke()` can be used to call the following:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::invoke()` 函数是一个可变参数的函数模板，它将可调用对象作为第一个参数，并传递给调用的可变参数列表。`std::invoke()`
    可以用来调用以下内容：'
- en: 'Free functions:'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自由函数：
- en: '[PRE62]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Free functions through pointer to function:'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过函数指针调用自由函数：
- en: '[PRE63]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Member functions through pointer to member function:'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过成员函数指针调用成员函数：
- en: '[PRE64]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Data members:'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据成员：
- en: '[PRE65]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Function objects:'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数对象：
- en: '[PRE66]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Lambda expressions:'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda 表达式：
- en: '[PRE67]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In practice, `std:invoke()` should be used in template meta-programming for
    invoking a function with an arbitrary number of arguments. To exemplify such a
    case, we present a possible implementation for our `std::apply()` function, and
    also a part of the standard library as of C++17 that calls a function by unpacking
    the members of a tuple into the arguments of the function:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，`std::invoke()` 应该在模板元编程中被用来调用带有任意数量参数的函数。为了举例说明这样的情况，我们提供了我们的 `std::apply()`
    函数的可能实现，以及作为 C++17 标准库的一部分的一个调用函数的实现，通过将元组的成员解包成函数的参数：
- en: '[PRE68]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: How it works...
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Before we see how `std::invoke()` works, let''s have a short look at how different
    callable objects can be invoked. Given a function, obviously, the ubiquitous way
    of invoking it is directly passing it the necessary parameters. However, we can
    also invoke the function using function pointers. The trouble with function pointers
    is that defining the type of the pointer can be cumbersome. Using `auto` can simplify
    things (as shown in the following code), but in practice, you usually need to
    define the type of the pointer to function first and then define an object and
    initialize it with the correct function address. Here are several examples:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看到 `std::invoke()` 如何工作之前，让我们简要看一下不同可调用对象如何被调用。给定一个函数，显然，调用它的普遍方式是直接传递必要的参数给它。然而，我们也可以使用函数指针来调用函数。函数指针的问题在于定义指针的类型可能很麻烦。使用
    `auto` 可以简化事情（如下面的代码所示），但在实践中，通常需要先定义函数指针的类型，然后定义一个对象并用正确的函数地址进行初始化。以下是几个例子：
- en: '[PRE69]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Calling through a function pointer becomes more cumbersome when you need to
    invoke a class function through an object that is an instance of the class. The
    syntax for defining the pointer to a member function and invoking it is not simple:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要通过一个是类的实例的对象来调用类函数时，通过函数指针进行调用变得更加麻烦。定义成员函数的指针和调用它的语法并不简单：
- en: '[PRE70]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Regardless of how cumbersome this kind of call may look, the actual problem
    is writing library components (functions or classes) that are able to call any
    of these types of callable objects, in a uniform manner. This is what benefits
    in practice from a standard function, such as `std::invoke()`.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 无论这种调用看起来多么麻烦，实际问题是编写能够以统一方式调用任何这些类型的可调用对象的库组件（函数或类）。这就是实践中从标准函数（如 `std::invoke()`）中受益的地方。
- en: 'The implementation details of `std::invoke()` are complex, but the way it works
    can be explained in simple terms. Supposing the call has the form `invoke(f, arg1,
    arg2, ..., argN)`, then consider the following:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::invoke()` 的实现细节很复杂，但它的工作原理可以用简单的术语来解释。假设调用的形式是 `invoke(f, arg1, arg2,
    ..., argN)`，那么考虑以下情况：'
- en: 'If `f` is a pointer to a member function of a `T` class,  then the call is
    equivalent with either:'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `f` 是 `T` 类的成员函数的指针，那么调用等价于：
- en: '`(arg1.*f)(arg2, ..., argN)`, if `arg1` is an instance of `T`'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(arg1.*f)(arg2, ..., argN)`，如果 `arg1` 是 `T` 的一个实例'
- en: '`(arg1.get().*f)(arg2, ..., argN)`, if `arg1` is a specialization of `reference_wrapper`'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(arg1.get().*f)(arg2, ..., argN)`，如果 `arg1` 是 `reference_wrapper` 的一个特化'
- en: '`((*arg1).*f)(arg2, ..., argN)`, if it is otherwise'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`((*arg1).*f)(arg2, ..., argN)`，如果是其他情况'
- en: 'If `f` is a pointer to a data member of a `T` class and there is a single argument,
    in other words, the call has the form `invoke(f, arg1)`, then the call is equivalent
    to either:'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `f` 是 `T` 类的数据成员的指针，并且有一个参数，换句话说，调用的形式是 `invoke(f, arg1)`，那么调用等价于：
- en: '`arg1.*f` if `arg1` is an instance class `T`'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arg1.*f`，如果 `arg1` 是 `T` 类的一个实例'
- en: '`arg1.get().*f` if `arg1` is a specialization of `reference_wrapper`'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arg1.get().*f`，如果 `arg1` 是 `reference_wrapper` 的一个特化'
- en: '`(*arg1).*f`, if it is otherwise'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(*arg1).*f`，如果是其他情况'
- en: If `f` is a function object, then the call is equivalent to `f(arg1, arg2, ...,
    argN)`
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `f` 是一个函数对象，那么调用等价于 `f(arg1, arg2, ..., argN)`
- en: See also
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Writing a function template with a variable number of arguments*'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写一个带有可变数量参数的函数模板*'
