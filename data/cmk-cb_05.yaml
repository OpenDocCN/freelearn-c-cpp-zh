- en: Creating and Running Tests
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和运行测试
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Creating a simple unit test
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的单元测试
- en: Defining a unit test using the Catch2 library
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Catch2库定义单元测试
- en: Defining a unit test and linking against Google Test
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义单元测试并链接到Google Test
- en: Defining a unit test and linking against Boost test
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义单元测试并链接到Boost测试
- en: Using dynamic analysis to detect memory defects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动态分析检测内存缺陷
- en: Testing expected failures
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试预期失败
- en: Using timeouts for long tests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为长时间测试设置超时
- en: Running tests in parallel
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行运行测试
- en: Running a subset of tests
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行测试的子集
- en: Using test fixtures
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用测试夹具
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: Testing is a core component of the code development toolbox. Performing automated
    testing by using unit and integration tests not only helps the developer to detect
    functionality regressions early, but can also serve as a starting point for developers
    joining the project. It can help new developers to submit changes to the code
    project, with assurance that the expected functionality is preserved. For users
    of the code, automated tests can be essential when verifying that the installation
    preserves the functionality of the code. A nice byproduct of employing tests for
    units, modules, or libraries right from the start is that it can guide the programmer
    towards more modular and less complex code structures, using a pure, functional
    style, that minimizes and localizes global variables and the global state.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是代码开发工具箱的核心组成部分。通过使用单元和集成测试进行自动化测试，不仅可以帮助开发者在早期检测功能回归，还可以作为新加入项目的开发者的起点。它可以帮助新开发者提交代码变更，并确保预期的功能得以保留。对于代码的用户来说，自动化测试在验证安装是否保留了代码功能方面至关重要。从一开始就为单元、模块或库使用测试的一个好处是，它可以引导程序员编写更加模块化和不那么复杂的代码结构，采用纯粹的、函数式的风格，最小化并局部化全局变量和全局状态。
- en: 'In this chapter, we will demonstrate how to integrate testing into the CMake
    build structure, using popular testing libraries and frameworks, with the following
    goals in mind:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将演示如何将测试集成到CMake构建结构中，使用流行的测试库和框架，并牢记以下目标：
- en: Making it easy for users, developers, and continuous integration services to
    run the test set. When using Unix Makefiles, it should be as simple as typing
    `make test`.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让用户、开发者和持续集成服务轻松运行测试套件。在使用Unix Makefiles时，应该简单到只需输入`make test`。
- en: Running tests efficiently by minimizing the total test time, in order to maximize
    the probability that tests are run often-ideally, with each code change.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过最小化总测试时间来高效运行测试，以最大化测试经常运行的概率——理想情况下，每次代码更改后都进行测试。
- en: Creating a simple unit test
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的单元测试
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-01](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-01),
    and includes a C++ example. The recipe is valid with CMake version 3.5 (and higher),
    and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-01](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-01)找到，并包含一个C++示例。该示例适用于CMake版本3.5（及以上），并在GNU/Linux、macOS和Windows上进行了测试。
- en: In this recipe, we will introduce unit tests using CTest, the testing tool distributed
    as a part of CMake. In order to keep the focus on the CMake/CTest aspect and to
    minimize the cognitive load, we wish to keep the code that is to be tested as
    simple as possible. Our plan is to write and test code that can sum up integers,
    and nothing more. Just like in primary school, when we learned multiplication
    and division after learning how to add, at this point, our example code will only
    add and will only understand integers; it will not need to deal with floating
    point numbers. And, just as the young Carl Friedrich Gauss was tested by his teacher
    to sum all natural numbers from 1 to 100, we will ask our code to do the same-albeit
    without using the clever grouping trick employed by Gauss. To show that CMake
    does not impose any restrictions on the language to implement the actual tests,
    we will test our code using not only a C++ executable, but also using a Python
    script and a shell script. For simplicity, we will do this without using any testing
    libraries, but we will introduce C++ testing frameworks in later recipes in this
    chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将介绍使用CTest进行单元测试，CTest是作为CMake一部分分发的测试工具。为了保持对CMake/CTest方面的关注并最小化认知负荷，我们希望尽可能简化要测试的代码。我们的计划是编写并测试能够求和整数的代码，仅此而已。就像在小学时，我们在学会加法后学习乘法和除法一样，此时，我们的示例代码只会加法，并且只会理解整数；它不需要处理浮点数。而且，就像年轻的卡尔·弗里德里希·高斯被他的老师测试从1到100求和所有自然数一样，我们将要求我们的代码做同样的事情——尽管没有使用高斯所用的聪明分组技巧。为了展示CMake对实现实际测试的语言没有任何限制，我们将不仅使用C++可执行文件，还使用Python脚本和shell脚本来测试我们的代码。为了简单起见，我们将不使用任何测试库来完成这个任务，但我们将在本章后面的食谱中介绍C++测试框架。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Our code example consists of three files. The implementation source file, `sum_integers.cpp`,
    does the work of summing up over a vector of integers, and returns the sum:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码示例包含三个文件。实现源文件`sum_integers.cpp`负责对整数向量进行求和，并返回总和：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For this example, it does not matter whether this is the most elegant implementation
    of a sum over a vector. The interface is exported to our example library in `sum_integers.hpp`,
    as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，无论这是否是最优雅的向量求和实现方式都无关紧要。接口被导出到我们的示例库中的`sum_integers.hpp`，如下所示：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, the main function is defined in `main.cpp`, which collects the command-line
    arguments from `argv[]`, converts them into a vector of integers, calls the `sum_integers` function,
    and prints the result to the output:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`main.cpp`中定义了主函数，它从`argv[]`收集命令行参数，将它们转换成一个整数向量，调用`sum_integers`函数，并将结果打印到输出：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our goal is to test this code using a C++ executable (`test.cpp`), a Bash shell
    script (`test.sh`), and a Python script (`test.py`), to demonstrate that CMake
    does not really mind which programming or scripting language we prefer, as long
    as the implementation can return a zero or non-zero value that CMake can interpret
    as a success or failure, respectively.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是使用C++可执行文件（`test.cpp`）、Bash shell脚本（`test.sh`）和Python脚本（`test.py`）来测试这段代码，以证明CMake并不真正关心我们偏好哪种编程或脚本语言，只要实现能够返回零或非零值，CMake可以将其解释为成功或失败，分别。
- en: 'In the C++ example (`test.cpp`), we verify that 1 + 2 + 3 + 4 + 5 equals 15,
    by calling `sum_integers`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++示例（`test.cpp`）中，我们通过调用`sum_integers`验证1 + 2 + 3 + 4 + 5等于15：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The Bash shell script test example calls the executable, which is received
    as a positional argument:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Bash shell脚本测试示例调用可执行文件，该文件作为位置参数接收：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Also, the Python test script calls the executable (passed using the `--executable`
    command-line argument) directly, and allows it to be executed with the `--short` command-line
    argument:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Python测试脚本直接调用可执行文件（使用`--executable`命令行参数传递），并允许它使用`--short`命令行参数执行：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How to do it
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'We will now describe, step by step, how to set up testing for our project,
    as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将逐步描述如何为我们的项目设置测试，如下所示：
- en: 'For this example, we require C++11 support, a working Python interpreter, and
    the Bash shell:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个例子，我们需要C++11支持、一个可用的Python解释器以及Bash shell：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We then define the library, the dependencies of the main executable, and the
    testing executable:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义了库、主可执行文件的依赖项以及测试可执行文件：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, we turn on the testing functionality and define four tests. The last
    two tests call the same Python script; first without any command-line argument,
    and then with `--short`:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们开启测试功能并定义了四个测试。最后两个测试调用同一个Python脚本；首先是没有任何命令行参数，然后是使用`--short`：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We are now ready to configure and build the code. First, we test it manually:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备好配置和构建代码了。首先，我们手动测试它：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we can run the test set with `ctest`:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`ctest`运行测试集。
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You should also try to break the implementation, to verify whether the test
    set catches the change.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还应该尝试破坏实现，以验证测试集是否捕获了更改。
- en: How it works
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'The two key commands here are `enable_testing()`, which enables testing for
    this directory and all subfolders within it (in this case, the entire project,
    since we place it in the main `CMakeLists.txt`), and `add_test()`, which defines
    a new test and sets the test name and the command to run; an example is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的两个关键命令是`enable_testing()`，它为这个目录及其所有子文件夹（在本例中，整个项目，因为我们将其放在主`CMakeLists.txt`中）启用测试，以及`add_test()`，它定义一个新测试并设置测试名称和运行命令；例如：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding example, we employed a generator expression: `$<TARGET_FILE:cpp_test>`.
    Generator expressions are expressions that are evaluated at **build system generation
    time**. We will return to generator expressions in more detail in [Chapter 5](9612acc1-56f6-4158-a55f-9a9db3714759.xhtml),
    *Configure-time and Build-time Operations*, Recipe 9, *Fine-tuning configuration
    and compilation with generator expressions*. At this point, we can state that
    `$<TARGET_FILE:cpp_test>` will be replaced by the full path to the `cpp_test`
    executable target.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了一个生成器表达式：`$<TARGET_FILE:cpp_test>`。生成器表达式是在**构建系统生成时间**评估的表达式。我们将在[第5章](9612acc1-56f6-4158-a55f-9a9db3714759.xhtml)，*配置时间和构建时间操作*，第9个配方，*使用生成器表达式微调配置和编译*中更详细地返回生成器表达式。目前，我们可以声明`$<TARGET_FILE:cpp_test>`将被替换为`cpp_test`可执行目标的完整路径。
- en: Generator expressions are extremely convenient in the context of defining tests,
    because we do not have to explicitly hardcode the locations and names of the executables
    into the test definitions. It would be very tedious to achieve this in a portable
    way, since both the location of the executable and the executable suffix (for
    example, the `.exe` suffix on Windows) can vary between operating systems, build
    types, and generators. Using the generator expression, we do not have to explicitly
    know the location and name.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式在定义测试的上下文中非常方便，因为我们不必将可执行文件的位置和名称硬编码到测试定义中。以可移植的方式实现这一点将非常繁琐，因为可执行文件的位置和可执行文件后缀（例如，Windows上的`.exe`后缀）可能在操作系统、构建类型和生成器之间有所不同。使用生成器表达式，我们不必明确知道位置和名称。
- en: 'It is also possible to pass arguments to the test command to run; for example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以向测试命令传递参数以运行；例如：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, we run the tests sequentially (Recipe 8, *Running tests in
    parallel*, will show you how to shorten the total test time by executing tests
    in parallel), and the tests are executed in the same order that they are defined
    (Recipe 9, *Running a subset of tests*, will show you how to change the order
    or run a subset of tests). It is up to the programmer to define the actual test
    command, which can be programmed in any language supported by the operating system
    environment running the test set. The only thing that CTest cares about, in order
    to decide whether a test has passed or failed, is the return code of the test
    command. CTest follows the standard convention that a zero return code means success,
    and a non-zero return code means failure. Any script that can return zero or non-zero can
    be used to implement a test case.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们按顺序运行测试（第8个配方，*并行运行测试*，将向您展示如何通过并行执行测试来缩短总测试时间），并且测试按定义的顺序执行（第9个配方，*运行测试子集*，将向您展示如何更改顺序或运行测试子集）。程序员负责定义实际的测试命令，该命令可以用操作系统环境支持的任何语言编程。CTest唯一关心的是决定测试是否通过或失败的测试命令的返回代码。CTest遵循标准约定，即零返回代码表示成功，非零返回代码表示失败。任何可以返回零或非零的脚本都可以用来实现测试用例。
- en: 'Now that we know how to define and execute tests, it is also important that
    we know how to diagnose test failures. For this, we can introduce a bug into our
    code and let all of the tests fail:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道如何定义和执行测试，了解如何诊断测试失败也很重要。为此，我们可以向代码中引入一个错误，并让所有测试失败：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we then wish to learn more, we can inspect the file `Testing/Temporary/LastTestsFailed.log`.
    This file contains the full output of the test commands, and is the first place
    to look during a postmortem analysis. It is possible to obtain more verbose test
    output from CTest by using the following CLI switches:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望了解更多信息，可以检查文件`Testing/Temporary/LastTestsFailed.log`。该文件包含测试命令的完整输出，是进行事后分析时的第一个查看地点。通过使用以下CLI开关，可以从CTest获得更详细的测试输出：
- en: '`--output-on-failure`: Will print to the screen anything that the test program
    produces, in case the test fails.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--output-on-failure`：如果测试失败，将打印测试程序产生的任何内容到屏幕上。'
- en: '`-V`: Will enable verbose output from tests.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-V`：将启用测试的详细输出。'
- en: '`-VV`: Enables even more verbose output from tests.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-VV`：启用更详细的测试输出。'
- en: CTest offers a very handy shortcut to rerun only the tests that have previously
    failed; the CLI switch to use is `--rerun-failed`, and it proves extremely useful
    during debugging.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: CTest提供了一个非常方便的快捷方式，可以仅重新运行先前失败的测试；使用的CLI开关是`--rerun-failed`，这在调试过程中证明极其有用。
- en: There is more
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容。
- en: 'Consider the following definition:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下定义：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding definition can be re-expressed by explicitly specifying the `WORKING_DIRECTORY` in
    which the script will be run, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的定义可以通过显式指定脚本将在其中运行的`WORKING_DIRECTORY`来重新表达，如下所示：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We will also mention that test names can contain the `/` character, which may
    be useful when organizing related tests by name; for example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将提到，测试名称可以包含`/`字符，这在按名称组织相关测试时可能很有用；例如：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Sometimes, we need to set environment variables for a test script. This can
    be achieved with `set_tests_properties`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要为测试脚本设置环境变量。这可以通过`set_tests_properties`实现。
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This approach might not always be robust across different platforms, but CMake
    offers a way around this potential lack of robustness. The following snippet is
    equivalent to the one given above and invokes CMake, *via* `CMAKE_COMMAND`, to
    prepend environment variables before executing the actual Python test script:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可能并不总是跨不同平台都健壮，但CMake提供了一种绕过这种潜在健壮性不足的方法。以下代码片段等同于上述代码片段，并通过`CMAKE_COMMAND`预先添加环境变量，然后执行实际的Python测试脚本：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Once again, note the use of the generator expression `$<TARGET_FILE:account>`
    to pass the location of the library file without explicitly hardcoding paths.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，使用生成器表达式`$<TARGET_FILE:account>`来传递库文件的位置，而无需显式硬编码路径。
- en: 'We have executed the test set using the `ctest` command, but CMake will also
    create targets for the generator in question (`make test` for Unix Makefile generators,
    `ninja test` for the Ninja tool, or `RUN_TESTS` for Visual Studio). This means
    that there is yet another (almost) portable way to run the test step:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ctest`命令执行了测试集，但CMake还将为生成器创建目标（对于Unix Makefile生成器使用`make test`，对于Ninja工具使用`ninja
    test`，或对于Visual Studio使用`RUN_TESTS`）。这意味着还有另一种（几乎）便携的方式来运行测试步骤：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Unfortunately, this fails when using the Visual Studio generator where we have
    to use `RUN_TESTS` instead:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在使用Visual Studio生成器时这会失败，我们必须使用`RUN_TESTS`代替：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The command `ctest` offers a wealth of command-line arguments. Some of these
    will be explored in later recipes. For a full list, try `ctest --help`. The command
    `cmake --help-manual ctest` will output the full CTest manual to the screen.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`ctest`命令提供了丰富的命令行参数。其中一些将在后面的食谱中探讨。要获取完整列表，请尝试`ctest --help`。命令`cmake --help-manual
    ctest`将输出完整的CTest手册到屏幕上。'
- en: Defining a unit test using the Catch2 library
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Catch2库定义单元测试
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-02](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-02),
    and has a C++ example. The recipe is valid with CMake version 3.5 (and higher),
    and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-02](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-02)获取，并包含一个C++示例。该食谱适用于CMake版本3.5（及更高版本），并在GNU/Linux、macOS和Windows上进行了测试。
- en: In the previous recipe, we used an integer return code to signal success or
    failure in `test.cpp`. This is fine for simple tests, but typically, we would
    like to use a testing framework that offers an infrastructure to run more sophisticated
    tests with fixtures, comparisons with numerical tolerance, and better error reporting
    if a test fails. A modern and popular test library is Catch2 ([https://github.com/catchorg/Catch2](https://github.com/catchorg/Catch2)).
    One nice feature of this test framework is the fact that it can be included in
    your project as a single-header library, which makes compilation and updating
    the framework particularly easy. In this recipe, we will use CMake in combination
    with Catch2, to test the summation code introduced in the previous recipe.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个配方中，我们在`test.cpp`中使用整数返回码来表示成功或失败。这对于简单的测试来说是可以的，但通常我们希望使用一个提供基础设施的测试框架，以便运行更复杂的测试，包括固定装置、与数值容差的比较，以及如果测试失败时更好的错误报告。一个现代且流行的测试库是Catch2（[https://github.com/catchorg/Catch2](https://github.com/catchorg/Catch2)）。这个测试框架的一个很好的特点是它可以作为单个头文件库包含在你的项目中，这使得编译和更新框架特别容易。在本配方中，我们将使用CMake与Catch2结合，测试在前一个配方中介绍的求和代码。
- en: Getting ready
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We will keep the `main.cpp`, `sum_integers.cpp`, and `sum_integers.hpp` unchanged
    from the previous recipe, but will update the `test.cpp`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保持`main.cpp`、`sum_integers.cpp`和`sum_integers.hpp`与之前的配方不变，但将更新`test.cpp`：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We also need the `catch.hpp` header, which we can download from [https://github.com/catchorg/Catch2](https://github.com/catchorg/Catch2) (we
    have used version 2.0.1) and place in the root of our project, alongside `test.cpp`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要`catch.hpp`头文件，可以从[https://github.com/catchorg/Catch2](https://github.com/catchorg/Catch2)（我们使用了2.0.1版本）下载，并将其放置在项目根目录中，与`test.cpp`并列。
- en: How to do it
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做
- en: 'To use the Catch2 library, we will modify `CMakeLists.txt` from the previous
    recipe, to perform the following steps:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Catch2库，我们将修改前一个配方的`CMakeLists.txt`，执行以下步骤：
- en: 'We can keep most of `CMakeLists.txt` unchanged:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以保持`CMakeLists.txt`的大部分内容不变：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The only change, with respect to the previous recipe, is to remove all of the
    tests except for one, and rename it (to make clear what we have changed). Note
    that we pass the `--success` option to our unit tests executable. This is a Catch2
    option, and will produce output from tests, even upon success:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与前一个配方相比，唯一的改变是删除所有测试，只保留一个，并重命名它（以明确我们改变了什么）。请注意，我们向我们的单元测试可执行文件传递了`--success`选项。这是Catch2的一个选项，即使在成功时也会从测试中产生输出：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'That''s it! Let us configure, build, and test. The tests will be run using
    the `-VV` option in CTest, to get output from the unit tests executable:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这样！让我们配置、构建并测试。测试将使用CTest中的`-VV`选项运行，以从单元测试可执行文件获取输出：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can also try the `cpp_test` binary directly, and can see output directly
    from Catch2:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以直接尝试运行`cpp_test`二进制文件，并直接从Catch2看到输出：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Catch will generate an executable with a command-line interface. We invite
    you to  also try to execute the following command to explore the options offered
    by the unit testing framework:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Catch将生成一个具有命令行界面的可执行文件。我们邀请你也尝试执行以下命令，以探索单元测试框架提供的选项：
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'Since Catch2 is a single-header framework, no additional targets have to be
    defined and built. We only have to make sure that CMake can find `catch.hpp`,
    to build `test.cpp`. For convenience, we placed it in the same directory as `test.cpp`,
    but we could have chosen a different location and indicated that location by using
    `target_include_directories`. Yet another approach would be to wrap the header
    into an `INTERFACE` library. This can be done as illustrated in the Catch2 documentation
    (`https://github.com/catchorg/Catch2/blob/master/docs/build-systems.md#cmake`):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Catch2是一个单头文件框架，因此不需要定义和构建额外的目标。我们只需要确保CMake能够找到`catch.hpp`来构建`test.cpp`。为了方便，我们将其放置在与`test.cpp`相同的目录中，但我们也可以选择不同的位置，并使用`target_include_directories`指示该位置。另一种方法是将头文件包装成一个`INTERFACE`库。这可以按照Catch2文档中的说明进行（`https://github.com/catchorg/Catch2/blob/master/docs/build-systems.md#cmake`）：
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We would have then linked against the library as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们将按照以下方式链接库：
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We recall from the discussion in Recipe 3, *Building and linking static and
    shared libraries*, in [Chapter 1](037080e9-3b67-421a-b6ec-71b1e51dbe42.xhtml),
    *From a Simple Executable to Libraries* that `INTERFACE` libraries are pseudo-targets
    offered by CMake that are useful to specify usage requirements for targets outside
    our project.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从[第1章](037080e9-3b67-421a-b6ec-71b1e51dbe42.xhtml)，*从简单可执行文件到库*中的食谱3，*构建和链接静态和共享库*的讨论中回忆起，`INTERFACE`库是CMake提供的伪目标，对于指定项目外部的目标使用要求非常有用。
- en: There is more
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: This was a simple example, with a focus on CMake. Catch2 offers much more, of
    course. For a full documentation of the Catch2 framework, visit [https://github.com/catchorg/Catch2](https://github.com/catchorg/Catch2).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，重点在于CMake。当然，Catch2提供了更多功能。要获取Catch2框架的完整文档，请访问[https://github.com/catchorg/Catch2](https://github.com/catchorg/Catch2)。
- en: See also
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The Catch2 code repository contains a contributed CMake function to parse Catch
    tests and automatically create CMake tests, without explicitly typing `add_test()`
    functions; see [https://github.com/catchorg/Catch2/blob/master/contrib/ParseAndAddCatchTests.cmake](https://github.com/catchorg/Catch2/blob/master/contrib/ParseAndAddCatchTests.cmake).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Catch2代码仓库包含一个由贡献的CMake函数，用于解析Catch测试并自动创建CMake测试，而无需显式键入`add_test()`函数；请参阅[https://github.com/catchorg/Catch2/blob/master/contrib/ParseAndAddCatchTests.cmake](https://github.com/catchorg/Catch2/blob/master/contrib/ParseAndAddCatchTests.cmake)。
- en: Defining a unit test and linking against Google Test
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义单元测试并链接Google Test
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-03](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-03),
    and has a C++ example. The recipe is valid with CMake version 3.11 (and higher),
    and has been tested on GNU/Linux, macOS, and Windows. The code repository also
    contains an example compatible with CMake 3.5.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-03](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-03)找到，并包含一个C++示例。本食谱适用于CMake版本3.11（及更高版本），并在GNU/Linux、macOS和Windows上进行了测试。代码仓库还包含一个与CMake
    3.5兼容的示例。
- en: In this recipe, we will demonstrate how to implement unit testing using the
    Google Test framework, with the help of CMake. In contrast to the previous recipe,
    the Google Test framework is more than a header file; it is a library containing
    a couple of files that need to be built and linked against. We could place these
    alongside our code project, but to make the code project more lightweight, we
    will choose to download a well-defined version of the Google Test sources at configure
    time, and then build the framework and link against it. We will use the relatively
    new `FetchContent` module (available since CMake version 3.11). We will revisit `FetchContent`
    in [Chapter 8](2c4b0d92-f493-4e2c-9732-a1039be79580.xhtml), *The Superbuild Pattern*,
    where we will discuss how the module works under the hood, and where we will also
    illustrate how to emulate it by using `ExternalProject_Add`. This recipe is inspired
    by (and adapted from) the example at [https://cmake.org/cmake/help/v3.11/module/FetchContent.html](https://cmake.org/cmake/help/v3.11/module/FetchContent.html).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将演示如何使用CMake和Google Test框架实现单元测试。与之前的食谱不同，Google Test框架不仅仅是一个头文件；它是一个包含多个需要构建和链接的文件的库。我们可以将这些文件与我们的代码项目放在一起，但为了让代码项目更轻量级，我们将在配置时下载Google
    Test源代码的明确定义版本，然后构建框架并与之链接。我们将使用相对较新的`FetchContent`模块（自CMake版本3.11起可用）。我们将在[第8章](2c4b0d92-f493-4e2c-9732-a1039be79580.xhtml)，*超级构建模式*中重新讨论`FetchContent`，在那里我们将讨论模块在幕后是如何工作的，以及我们还将说明如何使用`ExternalProject_Add`来模拟它。本食谱的灵感来自（并改编自）[https://cmake.org/cmake/help/v3.11/module/FetchContent.html](https://cmake.org/cmake/help/v3.11/module/FetchContent.html)的示例。
- en: Getting ready
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will keep `main.cpp`, `sum_integers.cpp`, and `sum_integers.hpp` unchanged
    from the previous recipes, but will update the `test.cpp` source code, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保持`main.cpp`、`sum_integers.cpp`和`sum_integers.hpp`与之前的食谱不变，但将更新`test.cpp`源代码，如下所示：
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As indicated in the preceding code, we chose to explicitly place neither `gtest.h` nor
    other Google Test sources in our code project repository, but will download them
    at configure time by using the `FetchContent` module.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们选择不在我们的代码项目仓库中显式放置`gtest.h`或其他Google Test源文件，而是通过使用`FetchContent`模块在配置时下载它们。
- en: How to do it
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'The following steps describe how you can set up a `CMakeLists.txt` step by
    step, to compile the executable and its corresponding test using GTest:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤描述了如何逐步设置`CMakeLists.txt`，以使用GTest编译可执行文件及其相应的测试：
- en: 'The beginning of `CMakeLists.txt` is mostly unchanged, as compared to the previous
    two recipes, except that we require CMake 3.11 to have access to the `FetchContent`
    module:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CMakeLists.txt`的开头与前两个配方相比大部分未变，只是我们需要CMake 3.11以访问`FetchContent`模块：'
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We then introduce an if-clause, checking for `ENABLE_UNIT_TESTS`. By default,
    it is `ON`, but we want to have the possibility to turn it `OFF`, in case we do
    not have any network to download the Google Test sources:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们引入了一个if语句，检查`ENABLE_UNIT_TESTS`。默认情况下它是`ON`，但我们希望有可能将其关闭，以防我们没有网络下载Google
    Test源码：
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Inside of the if-clause, we first include the `FetchContent` module, declare
    a new content to fetch, and query its properties:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在if语句内部，我们首先包含`FetchContent`模块，声明一个新的要获取的内容，并查询其属性：
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If the content is not yet populated (fetched), we fetch and configure it. This
    will add a couple of targets that we can link against. In this example, we are
    interested in `gtest_main`. The example also contains some workarounds, for compilation
    using Visual Studio:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果内容尚未填充（获取），我们获取并配置它。这将添加一些我们可以链接的目标。在本例中，我们对`gtest_main`感兴趣。该示例还包含一些使用Visual
    Studio编译的解决方法：
- en: '[PRE34]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We then define the `cpp_test` executable target and specify its sources, using
    the `target_sources` command and its link libraries, using the `target_link_libraries`
    command:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义了`cpp_test`可执行目标，并使用`target_sources`命令指定其源文件，使用`target_link_libraries`命令指定其链接库：
- en: '[PRE35]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, we use the now familiar `enable_testing` and `add_test` commands to
    define the unit test:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用熟悉的`enable_testing`和`add_test`命令来定义单元测试：
- en: '[PRE36]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we are ready to configure, build, and test the project:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备好配置、构建和测试项目了：
- en: '[PRE37]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can also try to run `cpp_test` directly, as follows:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以尝试直接运行`cpp_test`，如下所示：
- en: '[PRE38]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: The `FetchContent` module enables populating content at configure time, *via*
    any method supported by the `ExternalProject` module, and has become a standard
    part of CMake in its 3.11 version. Whereas `ExternalProject_Add()` downloads at
    build time (as seen in [Chapter 8](2c4b0d92-f493-4e2c-9732-a1039be79580.xhtml), *The
    Superbuild Pattern*), the `FetchContent` module makes content available immediately,
    such that the main project and the fetched external project (in this case, the
    Google Test) can be processed when CMake is first invoked, and can be nested using `add_subdirectory`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`FetchContent`模块允许在配置时填充内容，*通过*任何`ExternalProject`模块支持的方法，并且已成为CMake 3.11版本的标准部分。而`ExternalProject_Add()`在构建时下载（如[第8章](2c4b0d92-f493-4e2c-9732-a1039be79580.xhtml)，*超级构建模式*所示），`FetchContent`模块使内容立即可用，以便主项目和获取的外部项目（在本例中为Google
    Test）可以在CMake首次调用时处理，并且可以使用`add_subdirectory`嵌套。'
- en: 'To fetch Google Test sources, we have first declared the external content:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取Google Test源码，我们首先声明了外部内容：
- en: '[PRE39]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this case, we fetched a Git repository with a specific tag (`release-1.8.0`),
    but we could also fetch an external project from a Subversion, Mercurial, or HTTP(S)
    source. For available options, consult the options of the corresponding `ExternalProject_Add`
    command at [https://cmake.org/cmake/help/v3.11/module/ExternalProject.html](https://cmake.org/cmake/help/v3.11/module/ExternalProject.html).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们获取了一个带有特定标签（`release-1.8.0`）的Git仓库，但我们也可以从Subversion、Mercurial或HTTP(S)源获取外部项目。有关可用选项，请参阅[https://cmake.org/cmake/help/v3.11/module/ExternalProject.html](https://cmake.org/cmake/help/v3.11/module/ExternalProject.html)上相应`ExternalProject_Add`命令的选项。
- en: We checked whether content population was already processed with the `FetchContent_GetProperties()`
    command, before calling `FetchContent_Populate()`; otherwise, `FetchContent_Populate()`
    would have thrown an error if it was called more than once.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在调用`FetchContent_Populate()`之前使用`FetchContent_GetProperties()`命令检查内容填充是否已经处理；否则，如果`FetchContent_Populate()`被调用多次，它会抛出一个错误。
- en: 'The command `FetchContent_Populate(googletest)` populates the sources and defines `googletest_SOURCE_DIR`
    and `googletest_BINARY_DIR`, which we can use to process the Google Test project
    (using `add_subdirectory()`, since it happens to be a CMake project, as well):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`FetchContent_Populate(googletest)`命令填充源码并定义`googletest_SOURCE_DIR`和`googletest_BINARY_DIR`，我们可以使用它们来处理Google
    Test项目（使用`add_subdirectory()`，因为它恰好也是一个CMake项目）：'
- en: '[PRE40]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The preceding defines the following targets: `gtest`, `gtest_main`, `gmock`,
    and `gmock_main`. In this recipe, we were only interested in the `gtest_main`
    target, as a library dependency for the unit test example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 上述定义了以下目标：`gtest`、`gtest_main`、`gmock`和`gmock_main`。在本示例中，我们只对`gtest_main`目标感兴趣，作为单元测试示例的库依赖项：
- en: '[PRE41]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When building our code, we can see how it correctly triggers the configure and
    build steps for Google Test. One day, we will wish to upgrade to a later Google
    Test release, and the only line that we will probably need to change is the one
    detailing the `GIT_TAG`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建我们的代码时，我们可以看到它如何正确地触发了Google Test的配置和构建步骤。有一天，我们可能希望升级到更新的Google Test版本，我们可能需要更改的唯一一行是详细说明`GIT_TAG`的那一行。
- en: There is more
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: We have scraped the surface of `FetchContent` and its build-time cousin, `ExternalProject_Add`,
    and we will revisit these commands in [Chapter 8](2c4b0d92-f493-4e2c-9732-a1039be79580.xhtml),
    *The Superbuild Pattern*. For a detailed discussion of the available options,
    please consult [https://cmake.org/cmake/help/v3.11/module/FetchContent.html](https://cmake.org/cmake/help/v3.11/module/FetchContent.html).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经初步了解了`FetchContent`及其构建时的表亲`ExternalProject_Add`，我们将在[第8章](2c4b0d92-f493-4e2c-9732-a1039be79580.xhtml)，*超级构建模式*中重新审视这些命令。对于可用选项的详细讨论，请参考[https://cmake.org/cmake/help/v3.11/module/FetchContent.html](https://cmake.org/cmake/help/v3.11/module/FetchContent.html)。
- en: In this recipe, we fetched the sources at configure time, but we could have
    also installed them on the system environment and used the `FindGTest` module
    to detect the library and header files ([https://cmake.org/cmake/help/v3.5/module/FindGTest.html](https://cmake.org/cmake/help/v3.5/module/FindGTest.html)).
    From version 3.9, CMake also offers a `GoogleTest` module ([https://cmake.org/cmake/help/v3.9/module/GoogleTest.html](https://cmake.org/cmake/help/v3.9/module/GoogleTest.html)),
    which provides a `gtest_add_tests` function. This function can be used to automatically
    add tests, by scanning the source code for Google Test macros.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们在配置时获取了源代码，但我们也可以在系统环境中安装它们，并使用`FindGTest`模块来检测库和头文件（[https://cmake.org/cmake/help/v3.5/module/FindGTest.html](https://cmake.org/cmake/help/v3.5/module/FindGTest.html)）。从版本3.9开始，CMake还提供了一个`GoogleTest`模块（[https://cmake.org/cmake/help/v3.9/module/GoogleTest.html](https://cmake.org/cmake/help/v3.9/module/GoogleTest.html)），该模块提供了一个`gtest_add_tests`函数。这个函数可以用来自动添加测试，通过扫描源代码中的Google
    Test宏。
- en: See also
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Obviously, Google Test has a myriad of features that are outside the scope of
    this recipe, as listed at [https://github.com/google/googletest](https://github.com/google/googletest).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，Google Test有许多超出本示例范围的功能，如[https://github.com/google/googletest](https://github.com/google/googletest)所列。
- en: Defining a unit test and linking against Boost test
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义单元测试并链接到Boost测试
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-04](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-04),
    and has a C++ example. The recipe is valid with CMake version 3.5 (and higher),
    and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-04](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-04)找到，并包含一个C++示例。本示例适用于CMake版本3.5（及以上），并在GNU/Linux、macOS和Windows上进行了测试。
- en: Boost test is another very popular unit testing framework in the C++ community,
    and in this example, we will demonstrate how to unit test our familiar summing
    example code using Boost test.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Boost测试是C++社区中另一个非常流行的单元测试框架，在本示例中，我们将演示如何使用Boost测试对我们的熟悉求和示例代码进行单元测试。
- en: Getting ready
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will keep the `main.cpp`, `sum_integers.cpp`, and `sum_integers.hpp` unchanged
    from the previous recipes, but we will update `test.cpp` as a minimal example
    of a unit test using the Boost test library:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保持`main.cpp`、`sum_integers.cpp`和`sum_integers.hpp`与之前的示例不变，但我们将更新`test.cpp`作为使用Boost测试库的单元测试的简单示例：
- en: '[PRE42]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: How to do it
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'These are the steps to follow to build our project using Boost test:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用Boost测试构建我们项目的步骤：
- en: 'We start out with the now familiar `CMakeLists.txt` structure:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从熟悉的`CMakeLists.txt`结构开始：
- en: '[PRE43]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We detect the Boost library and link `cpp_test` against it:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检测Boost库并链接`cpp_test`：
- en: '[PRE44]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, we define the unit test:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义单元测试：
- en: '[PRE45]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The following is everything we need to configure, build, and test the code:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是我们需要配置、构建和测试代码的所有内容：
- en: '[PRE46]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: We have used `find_package` to detect the `unit_test_framework` component of
    Boost (see [Chapter 3](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml), *Detecting
    External Libraries and Programs*, Recipe 8, *Detecting the Boost libraries*).
    We have insisted that this component is `REQUIRED`, and the configuration will
    stop if it cannot be found in the system environment. The `cpp_test` target needs
    to know where to find Boost header files, and needs to be linked against the corresponding
    libraries; these are both provided by the `IMPORTED` library target, `Boost::unit_test_framework`,
    set by a successful call to `find_package`. We recall from the discussion in Recipe
    3, *Building and linking static and shared libraries*, in [Chapter 1](037080e9-3b67-421a-b6ec-71b1e51dbe42.xhtml),
    *From a Simple Executable to Libraries* that `IMPORTED` libraries are pseudo-targets
    offered by CMake to represent pre-existing dependencies and their usage requirements.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`find_package`来检测Boost的`unit_test_framework`组件（请参阅[第3章](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml)，*检测外部库和程序*，第8节，*检测Boost库*）。我们坚持认为这个组件是`REQUIRED`，如果无法在系统环境中找到，配置将停止。`cpp_test`目标需要知道在哪里找到Boost头文件，并需要链接到相应的库；这两者都由`IMPORTED`库目标`Boost::unit_test_framework`提供，该目标由成功的`find_package`调用设置。我们从[第1章](037080e9-3b67-421a-b6ec-71b1e51dbe42.xhtml)，*从简单可执行文件到库*中的第3节，*构建和链接静态和共享库*的讨论中回忆起，`IMPORTED`库是CMake提供的伪目标，用于表示预先存在的依赖关系及其使用要求。
- en: There is more
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容
- en: 'In this recipe, we assumed that Boost was installed on the system. Alternatively,
    we could have fetched and built the Boost dependency at compile-time (see [Chapter
    8](2c4b0d92-f493-4e2c-9732-a1039be79580.xhtml), *The Superbuild Pattern*, Recipe
    2, *Managing dependencies with a superbuild: I. The Boost libraries*). However,
    Boost is not a lightweight dependency. In our example code, we used only the most
    basic infrastructure, but Boost offers a wealth of features and options, and we
    will refer the interested reader to [http://www.boost.org/doc/libs/1_65_1/libs/test/doc/html/index.html](http://www.boost.org/doc/libs/1_65_1/libs/test/doc/html/index.html).'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们假设Boost已安装在系统上。或者，我们可以在编译时获取并构建Boost依赖项（请参阅[第8章](2c4b0d92-f493-4e2c-9732-a1039be79580.xhtml)，*超级构建模式*，第2节，*使用超级构建管理依赖项：I.
    Boost库*）。然而，Boost不是一个轻量级依赖项。在我们的示例代码中，我们仅使用了最基本的基础设施，但Boost提供了丰富的功能和选项，我们将引导感兴趣的读者访问[http://www.boost.org/doc/libs/1_65_1/libs/test/doc/html/index.html](http://www.boost.org/doc/libs/1_65_1/libs/test/doc/html/index.html)。
- en: Using dynamic analysis to detect memory defects
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动态分析检测内存缺陷
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-05](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-05),
    and has a C++ example. The recipe is valid with CMake version 3.5 (and higher),
    and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-05](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-05)找到，并提供了一个C++示例。本节适用于CMake版本3.5（及更高版本），并在GNU/Linux、macOS和Windows上进行了测试。
- en: Memory defects, such as writing to or reading from memory beyond allocated bounds,
    or memory leaks (memory that is allocated, but never released), can create nasty
    bugs that are difficult to track down, and it is useful to detect them early.
    Valgrind ([http://valgrind.org](http://valgrind.org)) is a popular and versatile
    tool to detect memory defects and memory leaks, and in this recipe, we will use
    Valgrind to alert us about memory problems when running tests using CMake/CTest
    (see [Chapter 14](6ba7b67c-0921-45f5-b7e0-948627e165ec.xhtml), *Testing Dashboards*,
    for a discussion of the related `AddressSanitizer` and `ThreadSanitizer`).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 内存缺陷，例如越界写入或读取内存，或者内存泄漏（已分配但从未释放的内存），可能会产生难以追踪的讨厌错误，因此尽早检测它们是有用的。Valgrind（[http://valgrind.org](http://valgrind.org)）是一个流行且多功能的工具，用于检测内存缺陷和内存泄漏，在本节中，我们将使用Valgrind来提醒我们使用CMake/CTest运行测试时的内存问题（请参阅[第14章](6ba7b67c-0921-45f5-b7e0-948627e165ec.xhtml)，*测试仪表板*，以讨论相关的`AddressSanitizer`和`ThreadSanitizer`）。
- en: Getting ready
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'For this recipe, we require three files. The first is the implementation that
    we wish to test (we can call the file `leaky_implementation.cpp`):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，我们需要三个文件。第一个是我们希望测试的实现（我们可以将文件称为`leaky_implementation.cpp`）：
- en: '[PRE47]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We also need the corresponding header file (`leaky_implementation.hpp`):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要相应的头文件（`leaky_implementation.hpp`）：
- en: '[PRE48]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'And, we need the test file (`test.cpp`):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要测试文件（`test.cpp`）：
- en: '[PRE49]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We expect the test to pass, since the `return_code` is hardcoded to `0`. However,
    we also hope to detect a memory leak, since we forgot to de-allocate `my_array`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望测试通过，因为`return_code`被硬编码为`0`。然而，我们也希望检测到内存泄漏，因为我们忘记了释放`my_array`。
- en: How to do it
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'The following shows how to set up `CMakeLists.txt` to perform the dynamic analysis
    of the code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何设置`CMakeLists.txt`以执行代码的动态分析：
- en: 'We first define the minimum CMake version, project name, language, targets,
    and dependencies:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义了最低CMake版本、项目名称、语言、目标和依赖项：
- en: '[PRE50]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, we define not only the test, but also the `MEMORYCHECK_COMMAND`:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们不仅定义了测试，还定义了`MEMORYCHECK_COMMAND`：
- en: '[PRE52]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Running the test set reports that the test is passing, as follows:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试集报告测试通过，如下所示：
- en: '[PRE53]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, we wish to check for memory defects, and can observe that the memory leak
    is detected:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们希望检查内存缺陷，并可以观察到内存泄漏被检测到：
- en: '[PRE54]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As a final step, you should try to fix the memory leak and verify that `ctest
    -T memcheck` reports no errors.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一步，你应该尝试修复内存泄漏，并验证`ctest -T memcheck`报告没有错误。
- en: How it works
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: We used `find_program(MEMORYCHECK_COMMAND NAMES valgrind)` to find Valgrind
    and set `MEMORYCHECK_COMMAND` to its full path. We also needed to explicitly include
    the `CTest` module to enable the `memcheck` test action, which we can employ by
    using `ctest -T memcheck`. Also, observe that we were able to pass options to
    Valgrind using `set(MEMORYCHECK_COMMAND_OPTIONS "--trace-children=yes --leak-check=full")`.
    The memory checking step creates a log file, which can be used to inspect the
    memory defect in detail.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`find_program(MEMORYCHECK_COMMAND NAMES valgrind)`来查找Valgrind并将其完整路径设置为`MEMORYCHECK_COMMAND`。我们还需要显式包含`CTest`模块以启用`memcheck`测试动作，我们可以通过使用`ctest
    -T memcheck`来使用它。此外，请注意我们能够使用`set(MEMORYCHECK_COMMAND_OPTIONS "--trace-children=yes
    --leak-check=full")`将选项传递给Valgrind。内存检查步骤创建一个日志文件，可用于详细检查内存缺陷。
- en: Some tools, like code coverage and static analysis tools, can be set up similarly.
    The use of some of these tools is, however, more complicated, since specialized
    builds and toolchains are required. Sanitizers are one such example. For more
    information, see [https://github.com/arsenm/sanitizers-cmake](https://github.com/arsenm/sanitizers-cmake).
    Also, check out [Chapter 14](6ba7b67c-0921-45f5-b7e0-948627e165ec.xhtml), *Testing
    Dashboards*, for a discussion of the `AddressSanitizer` and `ThreadSanitizer`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一些工具，如代码覆盖率和静态分析工具，可以类似地设置。然而，使用其中一些工具更为复杂，因为需要专门的构建和工具链。Sanitizers就是一个例子。有关更多信息，请参阅[https://github.com/arsenm/sanitizers-cmake](https://github.com/arsenm/sanitizers-cmake)。此外，请查看[第14章](6ba7b67c-0921-45f5-b7e0-948627e165ec.xhtml)，*测试仪表板*，以讨论`AddressSanitizer`和`ThreadSanitizer`。
- en: There is more
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: This recipe can be used to report memory defects to a nightly testing dashboard,
    but we demonstrated here that this functionality can also be used independent
    of a testing dashboard. We will revisit discuss usage in conjunction with CDash
    in [Chapter 14](6ba7b67c-0921-45f5-b7e0-948627e165ec.xhtml), *Testing Dashboards*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱可用于向夜间测试仪表板报告内存缺陷，但我们在这里演示了此功能也可以独立于测试仪表板使用。我们将在[第14章](6ba7b67c-0921-45f5-b7e0-948627e165ec.xhtml)，*测试仪表板*中重新讨论与CDash结合使用的情况。
- en: See also
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For documentation on Valgrind and its features and options, see [http://valgrind.org](http://valgrind.org).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Valgrind及其功能和选项的文档，请参阅[http://valgrind.org](http://valgrind.org)。
- en: Testing expected failures
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试预期失败
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-06](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-06).
    The recipe is valid with CMake version 3.5 (and higher), and has been tested on
    GNU/Linux, macOS, and Windows.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-06](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-06)找到。该食谱适用于CMake版本3.5（及以上），并在GNU/Linux、macOS和Windows上进行了测试。
- en: Ideally, we want all of our tests to always pass on every platform. However,
    we may want to test whether an expected failure or exception will occur in a controlled
    setting, and in that case, we would define the expected failure as a successful
    outcome. We believe that typically, this is a task that should be given to the
    test framework (such as Catch2 or Google Test), which should check for the expected
    failure and report successes to CMake. But, there may be situations where you
    wish to define a non-zero return code from a test as success; in other words,
    you may want to invert the definitions of success and failure. In this recipe,
    we will demonstrate such a situation.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望我们的所有测试在每个平台上都能始终通过。然而，我们可能想要测试在受控环境中是否会发生预期的失败或异常，在这种情况下，我们将预期的失败定义为成功的结果。我们相信，通常这应该是测试框架（如Catch2或Google
    Test）的任务，它应该检查预期的失败并将成功报告给CMake。但是，可能会有情况，你希望将测试的非零返回代码定义为成功；换句话说，你可能想要反转成功和失败的定义。在本节中，我们将展示这样的情况。
- en: Getting ready
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The ingredient for this recipe will be a tiny Python script (`test.py`) that
    always returns `1`, which CMake interprets as a failure:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的成分将是一个微小的Python脚本（`test.py`），它总是返回`1`，CMake将其解释为失败：
- en: '[PRE55]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: How to do it
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Step by step, this is how to write `CMakeLists.txt` to accomplish our task:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步地，这是如何编写`CMakeLists.txt`来完成我们的任务：
- en: 'In this recipe, we will not require any language support from CMake, but we
    will need to locate a working Python interpreter:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本节中，我们不需要CMake提供任何语言支持，但我们需要找到一个可用的Python解释器：
- en: '[PRE56]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We then define the test and tell CMake that we expect it to fail:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义测试并告诉CMake我们期望它失败：
- en: '[PRE57]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Finally, we verify that it is reported as a successful test, as follows:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们验证它被报告为成功的测试，如下所示：
- en: '[PRE58]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: How it works
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: Using `set_tests_properties(example PROPERTIES WILL_FAIL true)`, we set the
    property `WILL_FAIL` to `true`, which inverts success/failure. However, this feature
    should not be used to temporarily fix broken tests.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`set_tests_properties(example PROPERTIES WILL_FAIL true)`，我们将属性`WILL_FAIL`设置为`true`，这会反转成功/失败的状态。然而，这个功能不应该用来临时修复损坏的测试。
- en: There is more
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: If you need more flexibility, you can use the test properties `PASS_REGULAR_EXPRESSION`
    and `FAIL_REGULAR_EXPRESSION` in combination with `set_tests_properties`. If these
    are set, the test output will be checked against a list of regular expressions
    given as arguments, and, if at least one of the regular expressions matches, the
    test either passes or fails, respectively. Many other properties can be set on
    tests. A full list of available properties can be found at [https://cmake.org/cmake/help/v3.5/manual/cmake-properties.7.html#properties-on-tests](https://cmake.org/cmake/help/v3.5/manual/cmake-properties.7.html#properties-on-tests).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更多的灵活性，你可以结合使用测试属性`PASS_REGULAR_EXPRESSION`和`FAIL_REGULAR_EXPRESSION`与`set_tests_properties`。如果设置了这些属性，测试输出将被检查与作为参数给出的正则表达式列表进行匹配，如果至少有一个正则表达式匹配，则测试分别通过或失败。还有许多其他属性可以设置在测试上。可以在[https://cmake.org/cmake/help/v3.5/manual/cmake-properties.7.html#properties-on-tests](https://cmake.org/cmake/help/v3.5/manual/cmake-properties.7.html#properties-on-tests)找到所有可用属性的完整列表。
- en: Using timeouts for long tests
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为长时间测试设置超时
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-07](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-07).
    The recipe is valid with CMake version 3.5 (and higher), and has been tested on
    GNU/Linux, macOS, and Windows.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-07](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-07)找到。本节适用于CMake版本3.5（及以上），并在GNU/Linux、macOS和Windows上进行了测试。
- en: Ideally, the test set should take only a short time, in order to motivate developers
    to run the test set often, and to make it possible (or easier) to test every commit
    (changeset). However, some tests might take longer or get stuck (for instance,
    due to a high file I/O load), and we may need to implement timeouts to terminate
    tests that go overtime, before they pile up and delay the entire test and deploy
    pipeline. In this recipe, we will demonstrate one way of implementing timeouts,
    which can be adjusted separately for each test.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，测试集应该只需要很短的时间，以激励开发者频繁运行测试集，并使得对每次提交（变更集）进行测试成为可能（或更容易）。然而，有些测试可能会耗时较长或卡住（例如，由于高文件I/O负载），我们可能需要实施超时机制来终止超时的测试，以免它们堆积起来延迟整个测试和部署流水线。在本节中，我们将展示一种实施超时的方法，可以为每个测试单独调整。
- en: Getting ready
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The ingredient for this recipe will be a tiny Python script (`test.py`) that
    always returns `0`. To keep it super simple and to maintain focus on the CMake
    aspect, the test script does nothing other than wait for two seconds; but, we
    can imagine that in real life, this test script would perform more meaningful
    work:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的成分将是一个微小的Python脚本（`test.py`），它总是返回`0`。为了保持超级简单并专注于CMake方面，测试脚本除了等待两秒钟之外不做任何事情；但是，我们可以想象在现实生活中，这个测试脚本会执行更有意义的工作：
- en: '[PRE59]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How to do it
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'We need to inform CTest that tests need to be terminated if they go into overtime,
    as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要通知CTest，如果测试超时，需要终止测试，如下所示：
- en: 'We define the project name, enable testing, and define the test:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义项目名称，启用测试，并定义测试：
- en: '[PRE60]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In addition, we specify a `TIMEOUT` for the test, and set it to 10 seconds:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们为测试指定了一个`TIMEOUT`，并将其设置为10秒：
- en: '[PRE61]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We know how to configure and build, and we expect the test to pass:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们知道如何配置和构建，我们期望测试通过：
- en: '[PRE62]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, to verify that the `TIMEOUT` works, we increase the sleep command in `test.py`
    to 11 seconds, and rerun the test:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了验证`TIMEOUT`是否有效，我们将`test.py`中的睡眠命令增加到11秒，并重新运行测试：
- en: '[PRE63]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: How it works
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: '`TIMEOUT` is a handy property that can be used to specify a timeout for individual
    tests, by using `set_tests_properties`. If the test goes past that time, for whatever
    reason (the test has stalled or the machine is too slow), the test is terminated
    and marked as failed.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`TIMEOUT`是一个方便的属性，可用于通过使用`set_tests_properties`为单个测试指定超时。如果测试超过该时间，无论出于何种原因（测试停滞或机器太慢），测试都会被终止并标记为失败。'
- en: Running tests in parallel
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行运行测试
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-08](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-08).
    The recipe is valid with CMake version 3.5 (and higher), and has been tested on
    GNU/Linux, macOS, and Windows.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-08](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-08)找到。该食谱适用于CMake版本3.5（及更高版本），并在GNU/Linux、macOS和Windows上进行了测试。
- en: Most modern computers have four or more CPU cores. One fantastic feature of
    CTest is its ability to run tests in parallel, if you have more than one core
    available. This can significantly reduce the total time to test, and reducing
    the total test time is what really counts, to motivate developers to test frequently.
    In this recipe, we will demonstrate this feature and discuss how you can optimize
    the definition of your tests for maximum performance.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代计算机都有四个或更多的CPU核心。CTest的一个很棒的功能是，如果你有多个核心可用，它可以并行运行测试。这可以显著减少总测试时间，减少总测试时间才是真正重要的，以激励开发者频繁测试。在这个食谱中，我们将演示这个功能，并讨论如何优化你的测试定义以获得最大性能。
- en: Getting ready
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Let us assume that our test set contains tests labeled *a, b, ..., j*, each
    with a specific time duration:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们的测试集包含标记为*a, b, ..., j*的测试，每个测试都有特定的持续时间：
- en: '| Tests | Duration (in time units) |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 测试 | 持续时间（以时间单位计） |'
- en: '| *a, b, c, d* | 0.5 |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| *a, b, c, d* | 0.5 |'
- en: '| *e, f, g* | 1.5 |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| *e, f, g* | 1.5 |'
- en: '| *h* | 2.5 |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| *h* | 2.5 |'
- en: '| *i* | 3.5 |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| *i* | 3.5 |'
- en: '| *j* | 4.5 |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| *j* | 4.5 |'
- en: 'The time units can be minutes, but to keep it simple and short, we will use
    seconds. For simplicity, we can represent test *a*, which consumes 0.5 time units,
    with a Python script:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 时间单位可以是分钟，但为了保持简单和短，我们将使用秒。为了简单起见，我们可以用一个Python脚本来表示消耗0.5时间单位的测试*a*：
- en: '[PRE64]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The other tests can be represented accordingly. We will place these scripts
    one directory below `CMakeLists.txt`, in a directory called `test`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 其他测试可以相应地表示。我们将把这些脚本放在`CMakeLists.txt`下面的一个目录中，目录名为`test`。
- en: How to do it
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'For this recipe, we need to declare a list of tests, as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们需要声明一个测试列表，如下所示：
- en: '`CMakeLists.txt` is very brief:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CMakeLists.txt`非常简短：'
- en: '[PRE65]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can configure the project and run the tests using `ctest`, which takes 17
    seconds in total:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`ctest`配置项目并运行测试，总共需要17秒：
- en: '[PRE66]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, if we happen to have four cores available, we can run the test set on
    four cores in less than five seconds:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们碰巧有四个核心可用，我们可以在不到五秒的时间内将测试集运行在四个核心上：
- en: '[PRE67]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: How it works
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'We can see that in the parallel case, tests *j, i, h*, and *e* started at the
    same time. The reduction in total test time when running in parallel can be significant.
    Looking at the output from `ctest --parallel 4`, we can see that the parallel
    test run started with the longest tests, and ran the shortest tests at the end.
    Starting with the longest tests is a very good strategy. It is like packing moving
    boxes: we start with larger items, and fill in the gaps with smaller items. Comparing
    the stacking of the *a-j* tests on four cores, when starting with the longest,
    looks as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在并行情况下，测试*j, i, h*和*e*同时开始。并行运行时总测试时间的减少可能是显著的。查看`ctest --parallel 4`的输出，我们可以看到并行测试运行从最长的测试开始，并在最后运行最短的测试。从最长的测试开始是一个非常好的策略。这就像打包搬家箱子：我们从较大的物品开始，然后用较小的物品填充空隙。比较在四个核心上从最长测试开始的*a-j*测试的堆叠，看起来如下：
- en: '[PRE68]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Running tests in the order in which they are defined looks as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 按照定义的顺序运行测试看起来如下：
- en: '[PRE69]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Running the tests in the order in which they are defined takes more time overall,
    since it leaves two cores idle for most of the time (here, cores 3 and 4). How
    did CMake know which tests would take the longest? CMake knew the time cost for
    each test because we ran the test sequentially first, and this recorded the cost
    data for each test in the file `Testing/Temporary/CTestCostData.txt`, which looks
    as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 按照定义的顺序运行测试总体上需要更多时间，因为它让两个核心大部分时间处于空闲状态（这里，核心3和4）。CMake是如何知道哪些测试需要最长的时间？CMake知道每个测试的时间成本，因为我们首先按顺序运行了测试，这记录了每个测试的成本数据在文件`Testing/Temporary/CTestCostData.txt`中，看起来如下：
- en: '[PRE70]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'If we had started with the parallel test right after configuring the project,
    it would run the tests in the order in which they were defined, and on four cores,
    the total test time would be noticeably longer. What does this mean for us? Does
    it mean that we should order tests according to decreasing time costs? This is
    an option, but it turns out that there is another way; we can indicate the time
    cost for each test by ourselves:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们刚配置完项目就立即开始并行测试，它将按照定义的顺序运行测试，并且在四个核心上，总测试时间会明显更长。这对我们意味着什么？这是否意味着我们应该根据递减的时间成本来排序测试？这是一个选项，但事实证明还有另一种方法；我们可以自行指示每个测试的时间成本：
- en: '[PRE71]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `COST` parameter can be either an estimate or extracted from `Testing/Temporary/CTestCostData.txt`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`COST`参数可以是估计值或从`Testing/Temporary/CTestCostData.txt`提取。'
- en: There is more
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容。
- en: Instead of using `ctest --parallel N`, you can also use the environment variable `CTEST_PARALLEL_LEVEL`,
    and set it to the desired level.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`ctest --parallel N`，你还可以使用环境变量`CTEST_PARALLEL_LEVEL`，并将其设置为所需的级别。
- en: Running a subset of tests
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行测试子集
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-09](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-09).
    The recipe is valid with CMake version 3.5 (and higher), and has been tested on
    GNU/Linux, macOS, and Windows.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-09](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-09)找到。本示例适用于CMake版本3.5（及以上），并在GNU/Linux、macOS和Windows上进行了测试。
- en: In the previous recipe, we learned how to run tests in parallel with the help
    of CMake, and we discussed that it is advantageous to start with the longest tests.
    While this strategy minimizes the total test time, during the code development
    of a particular feature, or during debugging, we may not wish to run the entire
    test set. We may prefer to start with the longest tests, especially while debugging
    functionality that is exercised by a short test. For debugging and code development,
    we need the ability to only run a selected subset of tests. In this recipe, we
    will present strategies to accomplish that.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们学习了如何借助CMake并行运行测试，并讨论了从最长的测试开始的优势。虽然这种策略可以最小化总测试时间，但在特定功能的代码开发或调试过程中，我们可能不希望运行整个测试集。我们可能更倾向于从最长的测试开始，特别是在调试由短测试执行的功能时。对于调试和代码开发，我们需要能够仅运行选定的测试子集。在本示例中，我们将介绍实现这一目标的策略。
- en: Getting ready
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this example, we assume that we have six tests in total; the first three
    tests are shorter, and have the names `feature-a`, `feature-b`, and `feature-c`.
    We also have three longer tests, with the names `feature-d`, `benchmark-a`, and
    `benchmark-b`. In this recipe, we can represent these tests with Python scripts,
    where we can adjust the sleep time:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们假设总共有六个测试；前三个测试较短，名称分别为`feature-a`、`feature-b`和`feature-c`。我们还有三个较长的测试，名称分别为`feature-d`、`benchmark-a`和`benchmark-b`。在本例中，我们可以使用Python脚本来表示这些测试，其中我们可以调整睡眠时间：
- en: '[PRE72]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: How to do it
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'The following is a detailed breakdown of the contents of our `CMakeLists.txt`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对我们的`CMakeLists.txt`内容的详细分解：
- en: 'We start out with a relatively compact `CMakeLists.txt`, which defines the
    six tests:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从一个相对紧凑的`CMakeLists.txt`开始，定义了六个测试：
- en: '[PRE73]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In addition, we give the shorter tests the label `"quick"` and the longer tests
    the label `"long"`:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们将较短的测试标记为`"quick"`，将较长的测试标记为`"long"`：
- en: '[PRE75]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We are now ready to run the test set, as follows:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在准备运行测试集，如下所示：
- en: '[PRE76]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: How it works
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: Each test now has a name and a label. In CMake, all tests are numbered, so they
    also carry a unique number. Having defined the test label, we can now either run
    the entire set or run tests by their names (using regular expressions), their
    labels, or their numbers.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每个测试都有一个名称和一个标签。在CMake中，所有测试都有编号，因此它们也具有唯一编号。定义了测试标签后，我们现在可以运行整个集合，也可以根据测试的名称（使用正则表达式）、标签或编号来运行测试。
- en: 'Running tests by their names (here, we run all tests with names matching `feature`)
    looks as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 通过名称运行测试（这里，我们运行所有名称匹配`feature`的测试）如下所示：
- en: '[PRE78]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Running tests by their labels (here, we run all `long` tests) produces:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 通过标签运行测试（这里，我们运行所有`long`测试）产生：
- en: '[PRE79]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Running tests by their numbers (here, we run tests 2 to 4) yields:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编号运行测试（这里，我们运行第2到第4个测试）得到：
- en: '[PRE80]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: There is more
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不仅如此
- en: Try using `**$ ctest --help**`, and you will see a wealth of options to choose
    from to customize your testing.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用`**$ ctest --help**`，您将看到大量可供选择的选项来定制您的测试。
- en: Using test fixtures
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用测试夹具
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-10](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-10).
    The recipe is valid with CMake version 3.5 (and higher), and has been tested on
    GNU/Linux, macOS, and Windows.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-10](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-10)找到。本例适用于CMake版本3.5（及以上），并在GNU/Linux、macOS和Windows上进行了测试。
- en: This recipe was inspired by the work of Craig Scott, and we recommend the reader
    to also consult the corresponding blog post for more background, at [https://crascit.com/2016/10/18/test-fixtures-with-cmake-ctest/](https://crascit.com/2016/10/18/test-fixtures-with-cmake-ctest/).
    The motivation for this recipe was to demonstrate how to employ test fixtures.
    These are useful for more sophisticated tests that require setup actions before
    the test is run, and cleanup actions after it has completed (such as creating
    an example database, setting up a connection, disconnecting, cleaning up the test
    database, and so on). We want to make sure that running a test that requires a
    setup or cleanup action automatically triggers these steps in a predictable and
    robust way, without introducing code repetition. These setup and cleanup steps
    can be delegated to the testing framework, such as Google Test or Catch2, but
    here, we demonstrate how to implement test fixtures at the CMake level.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 本例灵感来源于Craig Scott的工作，我们建议读者也参考相应的博客文章以获取更多背景信息，网址为[https://crascit.com/2016/10/18/test-fixtures-with-cmake-ctest/](https://crascit.com/2016/10/18/test-fixtures-with-cmake-ctest/)。本例的动机是展示如何使用测试夹具。对于需要测试前设置动作和测试后清理动作的更复杂的测试来说，这些夹具非常有用（例如创建示例数据库、设置连接、断开连接、清理测试数据库等）。我们希望确保运行需要设置或清理动作的测试时，这些步骤能以可预测和稳健的方式自动触发，而不会引入代码重复。这些设置和清理步骤可以委托给测试框架，如Google
    Test或Catch2，但在这里，我们展示了如何在CMake级别实现测试夹具。
- en: Getting ready
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will prepare four tiny Python scripts, and place them under the `test` directory: `setup.py`,
    `feature-a.py`, `feature-b.py`, and `cleanup.py`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将准备四个小型Python脚本，并将它们放置在`test`目录下：`setup.py`、`feature-a.py`、`feature-b.py`和`cleanup.py`。
- en: How to do it
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'We start with a familiar `CMakeLists.txt` structure, with some additional steps,
    as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从熟悉的`CMakeLists.txt`结构开始，并添加了一些额外的步骤，如下所示：
- en: 'We prepare the now familiar infrastructure:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们准备好了熟悉的基础设施：
- en: '[PRE81]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Then, we define the four test steps and bind them with a fixture:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义了四个测试步骤并将它们与一个固定装置绑定：
- en: '[PRE82]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Running the entire set brings no surprises, as shown in the following output:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行整个集合并不会带来任何惊喜，正如以下输出所示：
- en: '[PRE83]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'However, the interesting part is when we try to run the test `feature-a` alone.
    It correctly invokes both the `setup` step and the `cleanup` step:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，有趣的部分在于当我们尝试单独运行测试`feature-a`时。它正确地调用了`setup`步骤和`cleanup`步骤：
- en: '[PRE84]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: How it works
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: In this example, we defined a text fixture and called it `my-fixture`. We gave
    the setup test the `FIXTURES_SETUP` property and the cleanup test the `FIXTURES_CLEANUP`
    property, and, using `FIXTURES_REQUIRED`, we made sure that the tests `feature-a`
    and `feature-b` both required the setup and cleanup steps in order to be run.
    Binding these together ensures that we always enter and leave steps in a well-defined
    state.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们定义了一个文本固定装置并将其命名为`my-fixture`。我们为设置测试赋予了`FIXTURES_SETUP`属性，为清理测试赋予了`FIXTURES_CLEANUP`属性，并且使用`FIXTURES_REQUIRED`确保测试`feature-a`和`feature-b`都需要设置和清理步骤才能运行。将这些绑定在一起，确保我们始终以明确定义的状态进入和退出步骤。
- en: There is more
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容
- en: For more background and an excellent motivation for using this technique for
    fixtures see [https://crascit.com/2016/10/18/test-fixtures-with-cmake-ctest/](https://crascit.com/2016/10/18/test-fixtures-with-cmake-ctest/).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解更多背景信息以及使用此技术进行固定装置的出色动机，请参阅[https://crascit.com/2016/10/18/test-fixtures-with-cmake-ctest/](https://crascit.com/2016/10/18/test-fixtures-with-cmake-ctest/)。
