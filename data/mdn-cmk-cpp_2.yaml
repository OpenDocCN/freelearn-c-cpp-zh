- en: 1 First steps with CMake
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 使用CMake的第一步
- en: 'There is something magical about turning source code into a working application.
    Not only the effect itself: a working mechanism that we devised and brought to
    life, but the very process, the very act of exercising the idea into existence.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 将源代码转化为可工作的应用程序有一种神奇的感觉。不仅仅是效果本身：一个我们设计和赋予生命的工作机制，还有这个过程，将想法付诸实践的行为本身。
- en: 'As programmers we work in this loop: designing-coding-testing. We invent changes,
    we phrase them in a language that the compiler understands and we check if they
    work as intended. To create a proper, high-quality application from our source
    code we need to meticulously execute repetitive, error-prone tasks: invoking right
    commands, checking syntax, linking binary files, running tests, reporting issues
    and so on.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们在这个循环中工作：设计-编码-测试。我们构思变更，用编译器理解的语言表达它们，并检查它们是否按预期工作。为了从我们的源代码创建一个高质量的应用程序，我们需要仔细执行重复且容易出错的任务：调用正确的命令，检查语法，链接二进制文件，运行测试，报告问题等等。
- en: It takes effort to remember every step all the time. Instead, we want to stay
    focused on the actual coding, and delegate everything else to the automated tooling.
    Ideally - this process would be started with a single button, right after we changed
    our code. It would be smart, fast, extensible and work the same way across different
    operating systems and environments. It would be supported by multiple IDEs, but
    also by Continuous Integration pipelines which test our software after a change
    is submitted to a shared repository.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 始终记住每一步都需要努力。相反，我们希望专注于实际的编码工作，并将其他所有事情委托给自动化工具。理想情况下，这个过程会在我们修改代码后立即通过一个按钮启动。它应该是智能、快速、可扩展的，并且在不同的操作系统和环境中以相同的方式工作。它应该得到多个IDE的支持，也应该得到持续集成管道的支持，这些管道在代码提交到共享存储库后测试我们的软件。
- en: CMake is the answer to many such needs, but it requires a bit of work to configure
    and use correctly. This is not because CMake is unnecessarily complex, but because
    the subject that we're dealing with here is. Don't worry. We'll do with this whole
    learning process very methodically, and before you know it - you will become a
    building guru.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: CMake是满足许多此类需求的答案，但它需要一些工作来正确配置和使用。这不是因为CMake过于复杂，而是因为我们在这里处理的主题本身就很复杂。别担心，我们将非常系统地进行整个学习过程，很快你就会成为构建大师。
- en: I know you're eager to rush off, and start writing your own CMake projects,
    and I applaud your attitude. Since your projects will be primarily for users (yourself
    included), it's important that you understand that perspective as well.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你急于开始，开始编写你自己的CMake项目，我赞赏你的态度。既然你的项目将主要面向用户（包括你自己），那么理解那个视角也很重要。
- en: 'Let''s start with just that: becoming a CMake power user. We’ll go through
    a few basics: what is this tool, how it works in principle and how to install
    it. Then we''ll do a deep-dive on the command line and modes of operation. Finally,
    we''ll wrap up with purposes of different files in a project and we''ll touch
    on using CMake without one.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从成为CMake高级用户开始。我们将介绍一些基础知识：这个工具是什么，它在原理上是如何工作的，以及如何安装它。然后我们将深入探讨命令行和操作模式。最后，我们将总结项目中不同文件的用途，并简要介绍在没有项目的情况下使用CMake。
- en: 'In this chapter we’re going to cover the following main topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding the basics
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解基础知识
- en: Installing CMake on different platforms
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同平台上安装CMake
- en: Mastering the Command Line
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握命令行
- en: Navigating the Project Files
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览项目文件
- en: Discovering Scripts and Modules
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现脚本和模块
- en: Technical requirement
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Modern-CMake-for-Cpp](https://github.com/PacktPublishing/Modern-CMake-for-Cpp)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章中的代码文件，地址是[https://github.com/PacktPublishing/Modern-CMake-for-Cpp](https://github.com/PacktPublishing/Modern-CMake-for-Cpp)
- en: Understanding the basics
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解基础知识
- en: 'Compilation of C++ source code seems like a fairly straightforward process.
    When we take a small program like a classic `hello.cpp`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: C++源代码的编译过程看起来相当直接。当我们处理一个小程序，比如经典的`hello.cpp`时：
- en: chapter-01/01-hello/hello.cpp
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第1章/01-hello/hello.cpp
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'All we need to do to get an executable is to run a single command. We call
    the compiler with a file name as an argument:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得可执行文件，我们只需运行一个命令。我们使用文件名作为参数调用编译器：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Our code is correct so the compiler will silently produce an executable binary
    file that our machine can understand. We can run it by calling its name:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码是正确的，所以编译器会默默地生成一个可执行的二进制文件，我们的机器可以理解。我们可以通过调用它的名称来运行它：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: However, as our projects grow – we quickly understand that keeping everything
    in a single file is simply not possible. Clean code practices recommend that files
    should be kept small and in well-organized structures. Manual compilation of every
    file will be a tiresome and fragile process. There must be a better way.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着我们的项目增长，我们很快意识到将所有内容保存在一个文件中是根本不可能的。干净的代码实践建议文件应该保持小巧，并组织得井井有条。手动编译每个文件将是一个繁琐且脆弱的过程。一定有更好的方法。
- en: What is CMake?
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CMake是什么？
- en: 'Let’s say we automate building by writing a script that goes through our project
    tree and compiles everything. To avoid unnecessary compilation our script will
    detect if the source was modified since last time. Now we’d like a convenient
    way to manage arguments that are passed to the compiler for each file - preferably
    do that based on configurable criteria. Our script should also know how to link
    all the compiled files in a binary, or even better: build whole solutions that
    can be reused, and incorporated as modules in bigger projects.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们通过编写一个脚本来实现自动化构建，该脚本会遍历我们的项目树并编译所有内容。为了避免不必要的编译，我们的脚本会检测自上次以来源文件是否被修改过。现在我们希望有一个方便的方法来管理传递给每个文件编译器的参数——最好基于可配置的标准。我们的脚本还应该知道如何将所有编译过的文件链接成一个二进制文件，或者更好的是：构建整个解决方案，这些解决方案可以被重复使用，并作为模块整合到更大的项目中。
- en: 'The more features we will add – the more we will get to a full-fledged solution.
    Building software is a very versatile process and can span multiple different
    aspects:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的功能越多——我们就会得到一个功能齐全的解决方案。软件构建是一个非常多样化的过程，可以跨越多个不同的方面：
- en: Compiling executables and libraries
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译可执行文件和库
- en: Managing dependencies
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理依赖项
- en: Testing
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试
- en: Installing
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装
- en: Packaging
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包
- en: Producing documentation
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成文档
- en: Testing some more
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再测试一些
- en: It would take a really long time to come up with a truly modular and powerful
    C++ building application fit for every purpose. And it did. Bill Hoffman at Kitware
    implemented the first versions of CMake over 20 years ago. As you already guessed
    – it is very successful, has a lot of features and support from the community.
    Today CMake is being actively developed and has become the industry standard for
    C and C++ programmers.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 开发一个真正模块化且强大的适用于各种用途的C++构建应用程序需要很长时间。确实如此。Kitware的Bill Hoffman在20多年前实现了CMake的第一个版本。正如你已经猜到的——它非常成功，拥有许多功能和社区支持。今天，CMake正在积极开发中，并已成为C和C++程序员的行业标准。
- en: 'The problem of building code in an automated way is much older than CMake,
    so naturally there are plenty of options out there: Make, Autotools, SCons, Ninja,
    Premake and many others. But why does CMake have the upper hand?'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在自动化方式下构建代码的问题比CMake要古老得多，所以自然有很多选择：Make、Autotools、SCons、Ninja、Premake等等。但为什么CMake占据上风？
- en: 'A couple of things about CMake I find (granted, subjectively) really important:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 关于CMake，我发现（当然，主观上）一些真正重要的事情：
- en: It stays focused on supporting modern compilers and toolchains
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它专注于支持现代编译器和工具链
- en: CMake is truly cross-platform – it supports building for Windows, Linux, macOS
    and Cygwin
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake确实是跨平台的——它支持为Windows、Linux、macOS和Cygwin构建
- en: 'It generates project files for popular IDEs: Microsoft Visual Studio, Xcode,
    Eclipse CDT, and it is a project model for others like CLion'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为流行的IDE生成项目文件：Microsoft Visual Studio、Xcode、Eclipse CDT，并且它是其他IDE（如CLion）的项目模型
- en: CMake operates on just the right level of abstraction – it allows to group files
    in reusable targets and projects
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake在适当的抽象级别上运行——它允许将文件分组为可重用的目标和项目
- en: There are tons of projects that are built with CMake, and offer an easy way
    to include them in your project
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有大量的项目是使用CMake构建的，并提供了一种简单的方法将它们包含在你的项目中
- en: CMake sees testing, packaging and installing as an inherent part of the build
    process
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake将测试、打包和安装视为构建过程的固有部分
- en: Old, unused features get deprecated to keep CMake lean
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旧的、不常用的功能会被弃用，以保持CMake的精简
- en: 'CMake provides this unified, streamlined experience across the board: building
    in your IDE, from the command line and (what’s really important) on later stages
    as well. Your CI/CD pipeline can easily use the same exact CMake configuration
    and build projects using a single standard even if all above environments differ.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: CMake提供了这种统一的、简化的体验：在你的IDE中构建，从命令行构建，以及（真正重要的是）在后续阶段也是如此。你的CI/CD管道可以轻松地使用相同的CMake配置，并使用单一标准构建项目，即使上述所有环境都不同。
- en: How does it work?
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的？
- en: You might get an impression that CMake is a tool that reads source code on one
    end, and produces binaries on the other – while that’s true in principle, it’s
    not the full picture.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会得到这样的印象：CMake是一个从一端读取源代码，从另一端生成二进制文件的工具——虽然在原则上这是正确的，但这并不是全部情况。
- en: 'CMake can’t build anything on its own – it relies on other tools in the system
    to perform the actual compilation, linking and other tasks. Think of it as an
    orchestrator of your building process: it knows what steps need to be done, what
    is the end goal and how to find the right workers and materials for the job.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: CMake本身不能构建任何东西——它依赖于系统中的其他工具来执行实际的编译、链接和其他任务。将其视为构建过程的指挥者：它知道需要完成哪些步骤，最终目标是什么，以及如何找到合适的工人和材料来完成工作。
- en: 'This process has three stages:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程有三个阶段：
- en: Configuration
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置
- en: Generation
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成
- en: Building
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建
- en: Configuration stage
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置阶段
- en: This stage is about reading project details stored in a directory called **source
    tree**, and preparing an output directory **build tree** for generation stage.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段是关于阅读存储在名为**源树**的目录中的项目细节，并为生成阶段准备一个输出目录**构建树**。
- en: CMake starts by creating an empty build tree and collecting all the details
    about the environment it is working in - architecture, available compilers, linkers,
    archivers and checks if a simple test program can be compiled correctly.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: CMake首先创建一个空的构建树，并收集有关其工作环境的全部细节——架构、可用的编译器、链接器、归档器，并检查是否可以正确编译一个简单的测试程序。
- en: 'Next, the `CMakeLists.txt` project configuration file is parsed and executed
    (yes, CMake projects are configured with CMake''s own coding language). This file
    is the bare minimum of a CMake project (source files can be added later). It tells
    CMake about the project structure, targets and dependencies: libraries and other
    CMake packages. During this process CMake stores collected information in the
    build tree: system details, project configuration, logs, and temp files used for
    the next step. Specifically, a `CMakeCache.txt` file is created to store more
    stable variables (like paths to compilers and other tools), and save time during
    the next configuration.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，解析并执行`CMakeLists.txt`项目配置文件（是的，CMake项目使用CMake自己的编程语言进行配置）。这个文件是CMake项目的基础（稍后可以添加源文件）。它告诉CMake项目的结构、目标和依赖关系：库和其他CMake包。在此过程中，CMake在构建树中存储收集的信息：系统细节、项目配置、日志和用于下一步的临时文件。特别是，创建了一个`CMakeCache.txt`文件来存储更稳定的变量（如编译器和其他工具的路径），并在下一次配置时节省时间。
- en: Generation stage
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生成阶段
- en: After reading the project configuration CMake will **generate a buildsystem**
    for the exact environment it is working in. Buildsystems are nothing else but
    cut-to-size configuration files for other build tools (for example Makefiles for
    GNU Make or Ninja and IDE project files for Visual Studio). During this stage
    CMake can still apply some final touches to the build configuration by evaluating
    **generator expressions**.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读项目配置后，CMake将**为它工作的确切环境生成一个构建系统**。构建系统只不过是为其他构建工具定制的配置文件（例如，GNU Make的Makefile或Ninja和Visual
    Studio的IDE项目文件）。在这个阶段，CMake仍然可以通过评估**生成器表达式**来对构建配置进行一些最后的调整。
- en: '**Note**'
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意**'
- en: ''
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Generation stage is executed with configuration one (unless you specifically
    ask CMake not to, through cmake-gui). For that reason when we mention generation
    stage – we mean both.
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 生成阶段是在配置阶段之后执行的（除非你通过cmake-gui特别要求CMake不这样做）。因此，当我们提到生成阶段时，我们指的是两者。
- en: Building stage
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建阶段
- en: To produce the final artifacts specified in our project we have to run the appropriate
    **build tool**. It can be invoked directly, through IDE or with CMake command.
    These build tools will in turn execute steps to produce **targets** with compilers,
    linkers, static and dynamic analysis tools, test frameworks, reporting tools and
    everything else you can think of.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成我们项目中指定的最终制品，我们必须运行适当的**构建工具**。这可以通过直接调用、通过IDE或使用CMake命令来实现。这些构建工具将反过来执行步骤，使用编译器、链接器、静态和动态分析工具、测试框架、报告工具以及你能想到的其他一切来生成**目标**。
- en: The beauty of this solution lies in the ability to produce buildsystems on demand
    for every platform with a single configuration (the same project files).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案的美妙之处在于，它能够为每个平台按需生成构建系统，且只需单一配置（相同的项目文件）。
- en: '![Figure 1.1: CMake stages](img/file0.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1：CMake阶段](img/file0.png)'
- en: 'Figure 1.1: CMake stages'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**图1.1：CMake阶段**'
- en: 'Remember our `hello.cpp` application from the first section? CMake makes it
    really easy to build it. All we need is following `CMakeLists.txt` file next to
    our source and two simple commands: `cmake -B buildtree` and `cmake --build buildtree`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在第一节中的`hello.cpp`应用程序吗？CMake使得构建它变得非常容易。我们所需要的只是旁边的源代码和两个简单的命令：`cmake -B
    buildtree`和`cmake --build buildtree`
- en: 'chapter01/01-hello/CMakeLists.txt: Hello world in CMake language'
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: chapter01/01-hello/CMakeLists.txt：CMake语言中的Hello world
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is the output from dockerized Linux system (we''ll discuss Docker in the
    next section):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是来自Docker化Linux系统的输出（我们将在下一节讨论Docker）：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'All that''s left is to run it:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是运行它：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: I have generated a build system stored in the `buildtree` directory, then we
    executed the build stage and produced a final binary that I was able to run.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经生成了一个存储在`buildtree`目录中的构建系统，然后执行了构建阶段，并生成了一个最终的可执行二进制文件。
- en: 'Now, when you know how the end result looks like, I''m sure you''re full of
    questions: what are the prerequisites to this process? What do these commands
    mean? Why do we need two of them? How to write my own project files? Not to worry
    - these questions will be answered on the following pages.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您知道最终结果的样子时，我相信您一定有很多问题：这个过程的前提条件是什么？这些命令是什么意思？为什么我们需要两个？如何编写自己的项目文件？不用担心——这些问题将在接下来的页面上得到解答。
- en: '**Getting help**'
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**获取帮助**'
- en: ''
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This book will provide you with most important information relevant to the
    current version of CMake (as of today: 3.20). To provide you with best advice
    I explicitly avoided any deprecated and no longer recommended features. I highly
    recommend using at least version 3.15 which is considered as "the Modern CMake".
    If you need more information - you can find the latest, complete documentation
    online: [https://cmake.org/cmake/help/](https://cmake.org/cmake/help/).'
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本书将为您提供与当前版本CMake（截至今天：3.20）最相关的最重要信息。为了给您提供最佳建议，我特意避免了任何已弃用且不再推荐的功能。我强烈建议使用至少3.15版本，该版本被认为是“现代CMake”。如果您需要更多信息，可以在线找到最新的完整文档：[https://cmake.org/cmake/help/](https://cmake.org/cmake/help/)。
- en: Installing CMake on different platforms
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在不同平台上安装CMake
- en: 'CMake is a cross-platform, open-source software written in C++. That means
    you can of course compile it yourself, but most likely you don’t have to, as pre-compiled
    binaries are available for you to download from official webpage: [https://cmake.org/download/](https://cmake.org/download/)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: CMake是一个跨平台的开源软件，用C++编写。这意味着您当然可以自己编译它，但大多数情况下您不需要这样做，因为可以从官方网页下载预编译的二进制文件：[https://cmake.org/download/](https://cmake.org/download/)
- en: Unix-based systems provide packages ready to install straight from the command
    line.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Unix的系统提供了可以直接从命令行安装的软件包。
- en: '**Note**'
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意**'
- en: ''
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Remember that CMake doesn't come with compilers, so if your system doesn't have
    anything installed - you'll need to provide them on your own. Be sure to add a
    path to their executables to the `PATH` environment variable so CMake can find
    them.
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请记住，CMake不自带编译器，所以如果你的系统上没有任何安装，你需要自行提供。确保将它们可执行文件的路径添加到`PATH`环境变量中，以便CMake能够找到它们。
- en: ''
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To avoid solving tooling and dependency problems while learning from this book,
    I recommend choosing the first installation method - Docker.
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了避免在学习本书时解决工具和依赖问题，我建议选择第一种安装方法——Docker。
- en: Docker
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker
- en: Docker ([https://www.docker.com/](https://www.docker.com/)) is a cross-platform
    tool that provides OS-level virtualization, allowing applications to be shipped
    in complete packages called containers. These are self-sufficient bundles that
    contain all the libraries, dependencies and tools. Docker executes its containers
    in lightweight environments that are isolated one from another.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Docker（[https://www.docker.com/](https://www.docker.com/)）是一个跨平台的工具，提供操作系统级别的虚拟化，允许应用程序以称为容器的完整包形式进行交付。这些是自给自足的包，包含所有库、依赖项和工具。Docker在其轻量级环境中执行容器，这些环境彼此隔离。
- en: This concept makes it extremely convenient to share whole toolchains necessary
    for a given process, configured and ready to go. I can't stress enough how easy
    things become when you don't need to worry about miniscule environment differences.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念使得共享整个工具链变得极其方便，这些工具链是为特定过程配置好的，随时可以使用。我无法强调当你不必担心微小的环境差异时，事情变得多么容易。
- en: Docker platform has a public repository of container images [https://registry.hub.docker.com/](https://registry.hub.docker.com/),
    which provides millions of images ready to use.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Docker平台有一个公共的容器镜像仓库[https://registry.hub.docker.com/](https://registry.hub.docker.com/)，提供了数百万个随时可用的镜像。
- en: 'For your convenience I have published two docker repositories:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了您的方便，我已经发布了两个docker仓库：
- en: '`swidzinski/cmake:toolchain` - containing curated tools and dependencies necessary
    to build with CMake'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`swidzinski/cmake:toolchain` - 包含构建CMake所需精选工具和依赖项'
- en: '`swidzinski/cmake:examples` - containing above toolchain and all the projects
    and examples from this book'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`swidzinski/cmake:examples` - 包含上述工具链以及本书中的所有项目和示例'
- en: The first option is for readers who just want a clean slate image ready to build
    their own projects, and the second for hands-on practice with examples as we go
    through the chapters.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种选择是为那些只想获得一个干净的镜像，准备构建自己项目的读者准备的，而第二种选择是为那些希望通过实践示例来练习的读者准备的，我们将在章节中逐步介绍。
- en: 'Install docker following instructions from its documentation [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)and
    execute following commands in your terminal to download image and start the container:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 按照Docker文档中的说明安装Docker[https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)，并在终端中执行以下命令以下载镜像并启动容器：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: All examples will be available in `/home/root/chapter-<N>/<M>-<title>` directories.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 所有示例都将位于`/home/root/chapter-<N>/<M>-<title>`目录中。
- en: Windows
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows
- en: Installing in Windows is straightforward – download version for 32 or 64 bits.
    You can pick a portable zip or msi package for Windows Installer.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上安装很简单——下载适用于32位或64位的版本。您可以选择适用于Windows Installer的便携式zip或msi软件包。
- en: 'With zip package you will have to add CMake bin directory to `PATH` environment
    variable to be able to use it in any directory without such errors:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用zip软件包，您将不得不将CMake bin目录添加到`PATH`环境变量中，以便能够在任何目录中使用它，而不会出现此类错误：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you prefer convenience – use msi installer.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您偏好便利性——使用msi安装程序。
- en: '![Figure 1.2: Installation wizard can set up the PATH environment variable
    for you.](img/file1.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2：安装向导可以为您设置PATH环境变量。](img/file1.jpg)'
- en: 'Figure 1.2: Installation wizard can set up the PATH environment variable for
    you.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：安装向导可以为您设置PATH环境变量。
- en: As I have mentioned – this is an open-source software, so it is possible to
    build CMake yourself, however – you will first have to get a binary copy of CMake
    on your system. Why use other build tools if you have your own, right? This scenario
    is used by CMake contributors to generate new versions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的——这是一个开源软件，所以你可以自己构建CMake，但是——你首先必须在你的系统上获得一个二进制版本的CMake。如果你有自己的构建工具，为什么要使用其他的呢，对吧？这种情况是由CMake贡献者用来生成新版本的。
- en: 'On windows we also need a build tool that can finalize the build process started
    by CMake. Good common choice here is Visual Studio, available for free in Community
    version from Microsoft’s website: [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，我们还需要一个构建工具来完成CMake启动的构建过程。一个很好的通用选择是Visual Studio，可以从微软网站的免费社区版下载：[https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/)
- en: Linux
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux
- en: Getting CMake on Linux is exactly the same as getting any other popular package.
    Just use your package manager from the command line. Packages are usually kept
    up to date with fairly recent versions, but if you are after the latest version
    – download the installation script from the website.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上获取CMake与获取任何其他流行软件包完全相同。只需使用命令行上的软件包管理器即可。软件包通常会保持更新，版本相当新，但如果你需要最新版本，可以从网站下载安装脚本。
- en: Script for Linux x86_64
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 适用于Linux x86_64的脚本
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Script for Linux aarch64
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 适用于Linux aarch64的脚本
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Package for Debian / Ubuntu
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 适用于Debian / Ubuntu的软件包
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Package for Redhat
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 适用于Redhat的软件包
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: MacOS
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MacOS
- en: 'This platform is also strongly supported by CMake developers. Most popular
    choices of installation are through MacPorts:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个平台也得到了CMake开发者的强烈支持。最受欢迎的安装方式是通过MacPorts：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Alternatively – you can use Homebrew:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用Homebrew：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Building from source
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从源代码构建
- en: 'If everything else fails, or you’re on a special platform – download the source
    from official website and compile it yourself:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其他方法都失败了，或者你处于特殊平台，可以从官方网站下载源代码并自行编译：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Building from source is a bit slower and requires more steps, but this way
    you''re guaranteed to use the latest version of CMake. This is especially visible
    in comparison to packages available for Linux: the older version of the system,
    the less updates it gets.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从源代码构建会稍微慢一些，步骤也更多，但这样能确保你使用的是CMake的最新版本。这在与Linux上可用的软件包进行比较时尤为明显：系统版本越旧，获得的更新就越少。
- en: Now that we have our CMake readily installed - let's learn how to use it!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经安装好了CMake，现在让我们学习如何使用它！
- en: Mastering the Command Line
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 掌握命令行
- en: Most of this book will teach you how to prepare CMake projects for your users.
    In order to cater to their needs - we need to thoroughly understand how users
    interact with CMake in different scenarios. This will allow you to test your project
    files and make sure they're working correctly.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的大部分内容将教你如何为用户准备CMake项目。为了满足他们的需求，我们需要深入了解用户在不同情况下如何与CMake交互。这将使你能够测试项目文件并确保它们正常工作。
- en: 'CMake is a family of tools, and consists of five executables:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: CMake是一套工具，由五个可执行文件组成：
- en: '`cmake` – main executable that configures, generates and builds projects'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmake` – 配置、生成和构建项目的主可执行文件'
- en: '`ctest` – test driver program used to run and report test results'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ctest` – 用于运行和报告测试结果的测试驱动程序'
- en: '`cpack` – packaging program used to generate installers and source packages'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cpack` – 用于生成安装程序和源包的打包程序'
- en: '`cmake-gui` – graphical wrapper around cmake'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmake-gui` – 基于图形的cmake包装器'
- en: '`ccmake` – console-based gui wrapper around cmake'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ccmake` – 基于控制台的cmake图形界面包装器'
- en: CMake
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CMake
- en: 'This binary provides a few modes of operation (also called actions):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个二进制文件提供了几种操作模式（也称为动作）：
- en: Generating a Project Buildsystem
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成项目构建系统
- en: Building a Project
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建项目
- en: Installing a Project
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装项目
- en: Running a Script
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行脚本
- en: Running a Command-Line Tool
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行命令行工具
- en: Getting Help
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取帮助
- en: Generating a Project Buildsystem
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生成项目构建系统
- en: 'This is the first step required to build our project. Here are a few options
    how CMake build action can be executed:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构建我们项目的第一步。以下是执行CMake构建操作的几种方式：
- en: Syntax of the generation mode
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生成模式的语法
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We''ll discuss options in next sections - right now let''s focus on choosing
    the right form of command. Important feature of CMake are out-of-source builds,
    or producing artifacts in an indicated directory. In contrast to tools like GNU Make
    - this keeps source directory clean of any build-related files and avoids polluting
    our version control systems with unnecessary files or ignore directives. This
    is why it''s best to use the first form of generation mode, and specify directory
    of produced buildsystem with `-B` and path to source tree `-S` like so:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中讨论选项，现在让我们专注于选择正确的命令形式。CMake的一个重要特性是外部构建，即在指定的目录中生成构件。与GNU Make等工具不同，这保持了源目录的清洁，没有与构建相关的文件，并避免了在我们的版本控制系统中添加不必要的文件或忽略指令。这就是为什么最好使用第一种生成模式，并通过`-B`指定生成的构建系统目录和通过`-S`指定源树路径，如下所示：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Above will generate buildsystem in the `./build` directory (and create it if
    it’s missing) from source in `./project` directory.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 上述操作将在`./build`目录中生成构建系统（如果该目录不存在则创建它），源代码位于`./project`目录中。
- en: We can skip one of the arguments and `cmake` will "guess" that we intended to
    use current directory for it, but watch out – skipping both will get you in-source
    build, and that is messy.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以跳过其中一个参数，`cmake`会“猜测”我们打算使用当前目录，但要小心——跳过两个参数会导致内部构建，那会很混乱。
- en: '**Not recommended**'
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**不推荐**'
- en: ''
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Do not use second or third form of the command: `$ cmake <directory>` as it
    can produce messy in-source build (we’ll learn how to block that in *Chapter 3*).
    As hinted in the syntax snippet – the same command behaves differently if a previous
    build already exists in `<directory>`: it will use the cached path to sources
    and rebuild from there. Since we often invoke the same commands from terminal
    command history, we might get in trouble here: before using this form always check
    if your shell is currently working in the right directory.'
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不要使用第二种或第三种命令形式：`$ cmake <directory>`，因为它可能会产生混乱的内部构建（我们将在第3章学习如何阻止这种情况）。正如语法片段中所暗示的，如果`<directory>`中已经存在之前的构建，相同的命令会有不同的行为：它将使用缓存的源路径并从那里重新构建。由于我们经常从终端命令历史中调用相同的命令，我们可能会在这里遇到麻烦：在使用这种形式之前，请始终检查你的shell是否正在正确的目录中工作。
- en: Examples
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'Build in current directory, but take source from one directory up (`-S` is
    optional):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前目录中构建，但从上一级目录获取源代码（`-S`是可选的）：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Build in `./build` directory, and use source from current directory:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`./build`目录中构建，并使用当前目录的源代码：
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Options: Generators'
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 选项：生成器
- en: As shown in the synopsis - you can specify a few options during the generation
    step. Selecting and configuring a generator decides which build tool from our
    system will be used for building, how build files will look like and what will
    be the structure of the Build Tree.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如概要所示，在生成步骤期间可以指定几个选项。选择和配置生成器决定了将使用我们系统上的哪个构建工具进行构建，构建文件将是什么样子，以及构建树的结构将是什么。
- en: 'So, should you care? Luckily – the answer often is “no”. CMake does support
    multiple native build systems on many platforms, but unless you have few of them
    installed at the same time – CMake will correctly select it for you. This can
    be overridden by the `CMAKE_GENERATOR` environment variable, or by specifying
    the generator directly on command line like so:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你应该关心吗？幸运的是，答案通常是“不”。CMake确实支持许多平台上的多种本地构建系统，但除非你同时安装了几个，否则CMake会为你正确选择。这可以通过`CMAKE_GENERATOR`环境变量或通过在命令行上直接指定生成器来覆盖，如下所示：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Some generators (like Visual Studio) support more in-depth specification of
    a toolset (compiler), and platform (compiler or SDK). These also have respective
    environment variables which override default value: `CMAKE_GENERATOR_TOOLSET`
    and `CMAKE_GENERATOR_PLATFORM`. We specify them directly as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一些生成器（如Visual Studio）支持更深入的工具集（编译器）和平台（编译器或SDK）的规范。这些也有相应的环境变量，它们覆盖默认值：`CMAKE_GENERATOR_TOOLSET`和`CMAKE_GENERATOR_PLATFORM`。我们直接如下指定它们：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Windows users usually want to generate buildsystem for their favorite IDE, on
    Linux and macOS – it’s very common to use Unix Makefiles or Ninja generators.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Windows用户希望为其喜爱的IDE生成构建系统，而在Linux和macOS上，使用Unix Makefiles或Ninja生成器非常常见。
- en: 'To check which generators are available on your system use:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查系统上可用的生成器，请使用：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'At the end of help printout, you will see a full list like this one:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在帮助打印输出的末尾，你将看到一个完整的列表，如下所示：
- en: There are plenty of generators available on Windows 10
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在Windows 10上有许多可用的生成器
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Options: Cache'
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 选项：缓存
- en: CMake queries the system for all kinds of information during the configuration
    stage – this information is cached in `CMakeCache.txt` in the build tree directory.
    There are few options that allow more convenient management of that file.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: CMake在配置阶段查询系统以获取各种信息，这些信息被缓存在构建树目录中的`CMakeCache.txt`中。有几个选项允许更方便地管理该文件。
- en: 'First at our disposal is ability to **prepopulate cached information**:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以**预填充缓存信息**：
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can provide a path to CMake script which contains (only) a list of `set()`
    commands to specify variables that will be used to initialize an empty build tree.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提供一个CMake脚本的路径，该脚本包含（仅）一个`set()`命令列表，以指定将用于初始化空构建树的变量。
- en: '**Initialization and modification** of existing cache variables can be done
    in another way (when creating a file is bit much to only set a few of them). You
    can just set them in command line like so:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**初始化和修改**现有缓存变量的另一种方法（当创建文件只是为了设置其中几个时，这有点过分）。你可以在命令行上像这样设置它们：'
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `:<type>` section is optional (it is used by GUIs), use one of `BOOL`, `FILEPATH`,
    `PATH`, `STRING`, `INTERNAL`. If you omit the type – it will be set to the type
    of already existing variable, or `UNITIALIZED` otherwise.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`:<type>`部分是可选的（它被GUI使用），使用`BOOL`、`FILEPATH`、`PATH`、`STRING`、`INTERNAL`之一。如果你省略类型，它将被设置为现有变量的类型，否则为`UNITIALIZED`。'
- en: 'One particularly important variable contains the type of the build: debug,
    release and so on. Many CMake projects will read it on numerous occasions to decide
    things like verbosity of messages, presence of debugging information and level
    of optimization for built artifacts.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特别重要的变量包含构建的类型：调试、发布等。许多CMake项目会多次读取它，以决定消息的详细程度、调试信息的可用性以及构建产物的优化级别。
- en: 'For single-configuration generators (such as Makefile and Ninja) you''ll need
    to specify it during the configuration phase with `CMAKE_BUILD_TYPE` variable,
    and generate a separate build tree for every type of config: `Debug`, `Release`,
    `MinSizeRel`, or `RelWithDebInfo`.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单配置生成器（如Makefile和Ninja），你需要在配置阶段使用`CMAKE_BUILD_TYPE`变量指定它，并为每种配置类型生成一个单独的构建树：`Debug`、`Release`、`MinSizeRel`或`RelWithDebInfo`。
- en: 'Here''s an example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Multi-Configuration generators are configured during the build stage.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 多配置生成器在构建阶段配置。
- en: 'We can **list cache** variables with -L option:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用-L选项**列出缓存**变量：
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Such a list will contain cache variables that aren't marked as `ADVANCED`, we
    can change that by adding the `A` modifier. If we're interested in reading help
    for each variable we can add the `H` modifier.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的列表将包含未标记为`ADVANCED`的缓存变量，我们可以通过添加`A`修饰符来更改这一点。如果我们对阅读每个变量的帮助感兴趣，我们可以添加`H`修饰符。
- en: Surprisingly, custom variables added manually with the `-D` option won't be
    visible unless you specify one of supported types.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，使用`-D`选项手动添加的自定义变量将不可见，除非您指定一种受支持的类型。
- en: '**Removal** of one or more variables can be done with following option:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**删除**一个或多个变量可以使用以下选项完成：'
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The globbing expression supports wildcard `*` and any character `?` symbols.
    Be careful when using, as you may break things.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通配符表达式支持通配符`*`和任意字符`?`符号。使用时要小心，因为您可能会破坏某些内容。
- en: Both `-U` and `-D` options can be repeated multiple times.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 可以多次重复使用`-U`和`-D`选项。
- en: 'Options: Debugging & Tracing'
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 选项：调试和跟踪
- en: 'CMake can be run with multitude of options that allow it to peek into its bellows
    and check different settings. To **get general information** about variables,
    commands, macros and other settings run:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: CMake可以通过多种选项运行，使其能够深入其内部并检查不同的设置。要**获取一般信息**关于变量、命令、宏和其他设置，请运行：
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Optional file argument allows you to store the output in a file. Running it
    in the build tree directory will print extra information about cache variables
    and build messages from log files.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的文件参数允许您将输出存储在文件中。在构建树目录中运行它将打印有关缓存变量和来自日志文件的构建消息的额外信息。
- en: 'In our projects we’ll be using `message()` commands to report details of the
    build process. CMake **filters log output** of these based on current log-level
    (`STATUS` by default). Following line specifies what log level we’re interested
    in:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，我们将使用`message()`命令来报告构建过程的详细信息。CMake**根据当前日志级别（默认为`STATUS`）过滤这些日志输出**。以下行指定我们感兴趣的日志级别：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Where `level` can be any of: `ERROR`, `WARNING`, `NOTICE`, `STATUS`, `VERBOSE`,
    `DEBUG` and `TRACE`. You can specify this setting permanently in `CMAKE_MESSAGE_LOG_LEVEL`
    cache variable.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`level`可以是以下任意一个：`ERROR`、`WARNING`、`NOTICE`、`STATUS`、`VERBOSE`、`DEBUG`和`TRACE`。您可以在`CMAKE_MESSAGE_LOG_LEVEL`缓存变量中永久指定此设置。
- en: 'Another interesting option allows us to **display log context** with each `message()`
    call. To debug very complex projects use `CMAKE_MESSAGE_CONTEXT` variable as stack
    and push strings on it going into narrower context, and pop them on leaving. If
    we enable displaying log context as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣选项允许我们**显示日志上下文**，每个`message()`调用。为了调试非常复杂的项目，使用`CMAKE_MESSAGE_CONTEXT`变量作为堆栈，并在进入更窄的上下文时将其推入，并在离开时将其弹出。如果我们启用显示日志上下文，如下所示：
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then our messages will be decorated with current `CMAKE_MESSAGE_CONTEXT` like
    so:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的消息将装饰有当前的`CMAKE_MESSAGE_CONTEXT`，如下所示：
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We’ll talk more about logging in the next chapter.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章详细讨论日志记录。
- en: 'If everything else fails, and we need to use the big guns – there is always
    the **trace mode**. It will print every command with filename and exact line number
    it is called from alongside its arguments. Enable it like so:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其他所有方法都失败了，我们需要使用重型武器 - 总有**跟踪模式**。它将打印每个命令及其调用的文件名和确切行号以及其参数。启用它如下所示：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Options: Presets'
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 选项：预设
- en: As you can tell - there are many, many options that users can specify to generate
    a build tree from your project. Between build tree path, generators, cache and
    environmental variables - it's easy to get confused or miss something. Developers
    can simplify how users interact with their project, and provide a `CMakePresets.json`
    file that specifies some defaults. Check the *Navigating the Project Files* section
    in this chapter to learn more.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见 - 用户可以指定许多选项来从您的项目生成构建树。在构建树路径、生成器、缓存和环境变量之间 - 很容易感到困惑或遗漏某些内容。开发人员可以简化用户与项目交互的方式，并提供一个`CMakePresets.json`文件，指定一些默认值。请在本章的*浏览项目文件*部分了解更多信息。
- en: 'To list available presets, execute:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出可用的预设，请执行：
- en: '[PRE33]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can use one of the available presets like so.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像这样使用其中一个可用预设。
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: These values override system defaults and environment, but at the same time
    - can be overridden with any arguments that are explicitly passed in the command
    line.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值覆盖系统默认值和环境，但同时 - 可以用命令行中明确传递的任何参数覆盖。
- en: '![Figure 1.3: How presets override CmakeCache.txt and system environment variables](img/file2.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3：预设如何覆盖CmakeCache.txt和系统环境变量](img/file2.jpg)'
- en: 'Figure 1.3: How presets override CmakeCache.txt and system environment variables'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3：预设如何覆盖CmakeCache.txt和系统环境变量
- en: Building a Project
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建项目
- en: 'After generating our build tree we’re ready for the next stage: **running the
    builder tool**. CMake not only knows how to generate input files for many different
    builders, but can also run them for you with arguments specific for our project.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 生成我们的构建树后，我们准备好进入下一个阶段：**运行构建工具**。CMake不仅知道如何为许多不同的构建工具生成输入文件，还可以使用我们项目特定的参数为你运行它们。
- en: '**Not recommended**'
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**不推荐**'
- en: ''
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Many online sources recommend calling GNU Make directly after the generation
    stage: `make`. This is a default generator for Linux and MacOS, and it usually
    works. We however prefer the method described in this section, as it is generator-independent
    and is supported across all platforms. This way we don’t need to worry about the
    exact environment of every user of our application.'
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 许多在线资源建议在生成阶段之后直接调用GNU Make：`make`。这是Linux和MacOS的默认生成器，通常情况下它是有效的。然而，我们更倾向于本节描述的方法，因为它与生成器无关，并且支持所有平台。这样我们就不需要担心我们应用程序的每个用户的具体环境。
- en: Syntax of the build mode
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建模式的语法
- en: '[PRE35]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In majority of the cases it is enough to provide just bare minimum to get a
    successful build:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，只需提供最基本的信息就足以成功构建：
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: CMake needs to know where the build tree is which we generated. This is the
    same path we passed with `-B` argument in the generation step.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: CMake需要知道我们生成的构建树的位置。这与我们在生成步骤中使用`-B`参数传递的路径相同。
- en: 'By providing a few options CMake allows specifying key build parameters that
    work for every builder. If you need to provide special arguments to your chosen,
    native builder - pass them at the end of the command after `--` token:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供一些选项，CMake允许指定适用于每个构建工具的关键构建参数。如果你需要为所选的本地构建工具提供特殊参数，请在命令末尾的`--`标记之后传递它们：
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Options: Parallel builds'
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 选项：并行构建
- en: Many build tools will by default use multiple concurrent processes to leverage
    modern processors and compile your sources in parallel. Builders know the structure
    of project dependencies, so they can simultaneously process steps that have their
    dependencies met in order to save users' time.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 许多构建工具默认会使用多个并发进程来利用现代处理器，并并行编译你的源代码。构建工具了解项目依赖关系的结构，因此它们可以同时处理那些依赖关系已满足的步骤，以节省用户的时间。
- en: 'You may want to override that setting if you''re building on a powerful machine
    (or to force a single threaded build for debugging), just **specify the number
    of jobs** with either of these options:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在强大的机器上构建（或者为了调试而强制单线程构建），你可能想要覆盖该设置，只需**指定作业数量**，使用以下任一选项：
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The alternative is to set it with the `CMAKE_BUILD_PARALLEL_LEVEL` environment
    variable. As usual - we can always use the above option to override the variable.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用`CMAKE_BUILD_PARALLEL_LEVEL`环境变量来设置它。通常，我们可以使用上述选项来覆盖该变量。
- en: 'Options: Target'
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 选项：目标
- en: 'We''ll talk more about targets in the second part of the book. For now, let''s
    just say that every project is made up from one of more parts called targets.
    Usually - we''ll want to build all of them, but on occasion we might be interested
    in skipping some, or **explicitly building a target** that was deliberately excluded
    from normal builds. We can do so as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的第二部分更多地讨论目标。现在，我们只能说每个项目都是由一个或多个称为目标的部分组成的。通常，我们想要构建所有目标，但有时我们可能对跳过某些目标感兴趣，或者**明确构建一个故意从正常构建中排除的目标**。我们可以这样做：
- en: '[PRE39]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you see - we can specify multiple targets separated by colon.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们可以通过冒号指定多个目标。
- en: 'One of such targets that isn''t normally built is `clean`. It will remove all
    artifacts from the build directory. This is how you call it:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 一个通常不会被构建的目标是`clean`。它将删除构建目录中的所有工件。调用它的方法是：
- en: '[PRE40]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'CMake also offers a convenient alias if you''d like to **clean first and then
    do a normal build**:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: CMake还提供了一个方便的别名，如果你想要**先清理然后进行正常构建**：
- en: '[PRE41]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Options: Multi-Configuration Generators'
  id: totrans-239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 选项：多配置生成器
- en: We already know a bit about generators. They come in different shapes and sizes.
    Some of them offer more features than others, and one of such is the ability to
    build both `Debug` and `Release` build types in a single build tree.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对生成器有了一些了解。它们有不同的形式和大小。有些生成器提供的功能比其他生成器更多，其中之一就是能够在单个构建树中构建`Debug`和`Release`构建类型。
- en: Generators supporting this feature are Ninja Multi-Config, XCode and Visual
    Studio. Every other is a single-configuration generator, and requires a separate
    build tree for that purpose.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 支持此功能的生成器有Ninja Multi-Config、XCode和Visual Studio。其他所有生成器都是单配置生成器，需要为此目的单独的构建树。
- en: 'Select one of `Debug`, `Release`, `MinSizeRel`, or `RelWithDebInfo` and specify
    it like so:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 选择`Debug`、`Release`、`MinSizeRel`或`RelWithDebInfo`中的一个，并这样指定：
- en: '[PRE42]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Otherwise CMake will use `Debug` as default.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，CMake将使用`Debug`作为默认值。
- en: 'Options: Debugging'
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 选项：调试
- en: 'When things go bad - first things to check are the output messages. However
    - veteran developers know that printing all the details all the time is confusing,
    so they often hide them by default. When we need to peek under the hood, we can
    ask for much more detailed logs by telling CMake to be verbose:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现问题时，首先要检查的是输出消息。然而，经验丰富的开发者知道，始终打印所有细节会令人困惑，因此他们通常默认隐藏这些细节。当我们需要窥视引擎盖下时，我们可以要求更详细的日志，告诉CMake要详细：
- en: '[PRE43]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The same effect can be achieved by setting `CMAKE_VERBOSE_MAKEFILE` cached variable.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置`CMAKE_VERBOSE_MAKEFILE`缓存变量也可以达到同样的效果。
- en: Install a Project
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装一个项目
- en: When artifacts are built, users can install them in the system. This usually
    means copying files into correct directories, installing libraries, or running
    some custom installation logic from a CMake script.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建工件时，用户可以将它们安装到系统中。这通常意味着将文件复制到正确的目录，安装库，或从CMake脚本运行一些自定义安装逻辑。
- en: Syntax of the Installation mode
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装模式的语法
- en: '[PRE44]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As with other modes of operation - CMake requires path to generated build tree:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他操作模式一样，CMake需要生成构建树的路径：
- en: '[PRE45]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Options: Multi-Configuration Generators'
  id: totrans-255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 选项：多配置生成器
- en: 'Exactly like in the build stage we can specify which build type we want to
    use for our installation (more details in "Building a Project"). Available types
    are `Debug`, `Release`, `MinSizeRel`, or `RelWithDebInfo`. Signature is as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在构建阶段一样，我们可以指定我们希望为安装使用的构建类型（更多细节请参见“构建项目”）。可用类型为`Debug`、`Release`、`MinSizeRel`或`RelWithDebInfo`。签名如下：
- en: '[PRE46]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Options: Components'
  id: totrans-258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 选项：组件
- en: 'As a developer you may choose to split your project into components that can
    be installed independently. We''ll discuss the concept of components in detail
    in *Chapter 11*, for now let''s just assume they represent different parts of
    the solution. This might be something like: "application", "docs" and "extra tools".'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，您可能希望将项目拆分为可以独立安装的组件。我们将在*第11章*中详细讨论组件的概念，现在让我们假设它们代表了解决方案的不同部分。这可能是：“应用程序”、“文档”和“额外工具”。
- en: 'To install a single component use this option:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装单个组件，请使用此选项：
- en: '[PRE47]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Options: Permissions'
  id: totrans-262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 选项：权限
- en: 'If installation is done on Unix-like platform you can specify default permissions
    for installed directories with following option, using this format: `u=rwx,g=rx,o=rx`'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在类Unix平台上进行安装，可以使用以下选项指定安装目录的默认权限，使用此格式：`u=rwx,g=rx,o=rx`
- en: '[PRE48]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Options: Installation Directory'
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 选项：安装目录
- en: 'We can prepend the installation path specified in the project configuration
    with a prefix of our choice (for example when we have limited write access to
    some directories). Path `/usr/local` prefixed with `/home/user` becomes `/home/user/usr/local`.
    Signature for this option is:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在项目配置中指定的安装路径前加上我们选择的任何前缀（例如，当我们对某些目录的写入权限有限时）。路径`/usr/local`以前缀`/home/user`变为`/home/user/usr/local`。此选项的签名是：
- en: '[PRE49]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note that this won't work on Windows as paths on this platform usually start
    with the drive letter.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这在Windows上不起作用，因为该平台上的路径通常以驱动器字母开头。
- en: 'Options: Debugging'
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 选项：调试
- en: 'Similarly to the build stage - we can also choose to view detailed output of
    the installation stage. Use any of following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 与构建阶段类似，我们也可以选择查看安装阶段的详细输出。使用以下任何一种：
- en: '[PRE50]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Same effect can be achieved if the `VERBOSE` environment variable is set.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了`VERBOSE`环境变量，也可以达到同样的效果。
- en: Run a Script
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行脚本
- en: CMake projects are configured using CMake's custom language. It's cross-platform,
    quite powerful and it's already there. Why not make it available for other tasks?
    Sure enough - you can write standalone scripts (we'll get to that at the end of
    this chapter).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: CMake项目使用CMake的定制语言进行配置。它是跨平台的，非常强大，而且已经存在。为什么不将其用于其他任务呢？当然，您可以编写独立的脚本（我们将在本章末尾讨论这一点）。
- en: 'CMake can run these like so:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: CMake可以这样运行：
- en: Syntax of the Run a Script mode
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行脚本模式的语法
- en: '[PRE51]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Running such a script won''t run any configure or generate stages and won''t
    affect cache. There are two ways of passing values to this script:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这样的脚本不会运行任何配置或生成阶段，也不会影响缓存。有两种方法可以将值传递给此脚本：
- en: Through variables defined with `-D` option
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`-D`选项定义的变量
- en: Through arguments that can be passed after a `--` token.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过可以在`--`标记后传递的参数。
- en: CMake will create `CMAKE_ARGV<n>` variables for all arguments passed to the
    script (including the `--` token).
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: CMake将为传递给脚本的所有参数（包括`--`标记）创建`CMAKE_ARGV<n>`变量。
- en: Run a Command-Line Tool
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行命令行工具
- en: On a rare occasion we might need to run just a single command in a platform-independent
    way - perhaps copy a file or compute a checksum. Not all platforms were created
    equal, so not all commands are available in every system, or they have a different
    name.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在极少数情况下，我们可能需要以平台无关的方式运行单个命令，例如复制文件或计算校验和。并非所有平台都是平等创建的，因此并非所有命令在每个系统上都可用，或者它们具有不同的名称。
- en: 'CMake offers a mode to execute the most common ones in the same way across
    platforms:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: CMake提供了一种在跨平台上以相同方式执行最常见操作的模式：
- en: Syntax of the Run Command-Line Tool mode
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行命令行工具模式的语法
- en: '[PRE52]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'As the use of this mode is fairly limited we won''t cover them in-depth. If
    you''re interested in the details, I recommend calling `cmake -E` to list all
    available commands. Just to get a glimpse, CMake 3.20 supports these commands:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种模式的使用相当有限，我们不会深入讨论它们。如果您对细节感兴趣，我建议调用`cmake -E`来列出所有可用的命令。只是为了窥见一斑，CMake
    3.20支持以下命令：
- en: '`capabilities`, `cat`, `chdir`, `compare_files`, `copy`, `copy_directory`,
    `copy_if_different`, `echo`, `echo_append`, `env`, `environment`, `make_directory`,
    `md5sum`, `sha1sum`, `sha224sum`, `sha256sum`, `sha384sum`, `sha512sum`, `remove`,
    `remove_directory`, `rename`, `rm`, `server`, `sleep`, `tar`, `time`, `touch`,
    `touch_nocreate`, `create_symlink`, `create_hardlink`, `true`, `false`'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`capabilities`, `cat`, `chdir`, `compare_files`, `copy`, `copy_directory`,
    `copy_if_different`, `echo`, `echo_append`, `env`, `environment`, `make_directory`,
    `md5sum`, `sha1sum`, `sha224sum`, `sha256sum`, `sha384sum`, `sha512sum`, `remove`,
    `remove_directory`, `rename`, `rm`, `server`, `sleep`, `tar`, `time`, `touch`,
    `touch_nocreate`, `create_symlink`, `create_hardlink`, `true`, `false`'
- en: If a command you'd like to use is missing, or you need a more complex behavior,
    consider wrapping it in a script and running it in a `-P` mode.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要使用的命令缺失，或者您需要更复杂的行为，可以考虑将其包装在脚本中，并在`-P`模式下运行。
- en: Getting help
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取帮助
- en: It comes without a surprise that CMake offers extensive help accessible through
    its command-line.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 不出所料，CMake通过其命令行提供了广泛的可用帮助。
- en: Syntax of the Help mode
  id: totrans-292
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 帮助模式的语法
- en: '[PRE53]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: CTest
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CTest
- en: Automated testing is very important to produce and maintain high-quality code.
    That's why we devoted an entire *Chapter 8* to this subject, and we'll do a deep-dive
    into the usage of CTest there. It is one of the available command-line tools so
    let's briefly introduce it for now.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试对于生成和维护高质量代码非常重要。这就是为什么我们专门用*第8章*来讨论这个主题，并在那里深入探讨CTest的使用。它是可用的命令行工具之一，所以现在让我们简要介绍一下。
- en: 'CTest is about wrapping CMake in a higher layer of abstraction, where building
    becomes just one of the stepping stones in the process of developing our software.
    Other tasks that CMake can do for us are: updating, running all kinds of tests,
    reporting the state of the project to external dashboards, and running scripts
    written in CMake language.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: CTest是关于将CMake包装在更高层次的抽象中，其中构建只是我们软件开发过程中的一个步骤。CMake可以为我们执行的其他任务包括：更新、运行各种测试、向外部仪表板报告项目状态以及运行用CMake语言编写的脚本。
- en: Most importantly CTest standardizes **running tests and reporting** for solutions
    built with CMake. As a user - you don't need to know which testing framework the
    project is using or how to run it. CTest provides a convenient façade to list,
    filter, shuffle, retry and timebox test runs. It can also call CMake for you if
    build is needed.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，CTest标准化了使用CMake构建的解决方案的**运行测试和报告**。作为用户，您不需要知道项目使用的是哪种测试框架，或者如何运行它。CTest提供了一个方便的外观，用于列出、过滤、洗牌、重试和时间限制测试运行。如果需要构建，它还可以为您调用CMake。
- en: 'Simplest way to run tests for a built project is just calling `ctest` in the
    generated build tree:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为已构建的项目运行测试的最简单方法是在生成的构建树中调用`ctest`：
- en: '[PRE54]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: CPack
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CPack
- en: After we built and tested our amazing software, we are ready to share it with
    the world. In rare few cases - power users are completely fine with source code,
    and that's what they want. Vast majority of the world however is using pre-compiled
    binaries because of convenience, time saved and many other reasons.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建并测试了我们的精彩软件之后，我们准备与世界分享它。在极少数情况下，高级用户完全满意于源代码，这就是他们想要的。然而，世界上绝大多数人使用预编译的二进制文件，因为它们方便、节省时间以及许多其他原因。
- en: 'CMake doesn''t leave you stranded here - it comes with batteries included.
    CPack is built for the exact purpose of **creating packages for different platforms**:
    compressed archives, executable installers, wizards, NuGet packages, MacOs bundles,
    DMG packages, RPMs and many, many more.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 不会让你陷入困境 - 它自带了所有必要的组件。CPack 正是为此目的而构建的，用于 **为不同平台创建包**：压缩档案、可执行安装程序、向导、NuGet
    包、MacOS 捆绑包、DMG 包、RPM 等等。
- en: 'CPack works very much like CMake: it is configured with CMake language and
    has many package generators to pick from (don''t confuse them with CMake buildsystem
    generators). We''ll go through all the details in *Chapter 11*, as this is quite
    a hefty tool meant for last stages of CMake projects.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: CPack 的工作方式与 CMake 非常相似：它使用 CMake 语言进行配置，并且有许多包生成器可供选择（不要将它们与 CMake 构建系统生成器混淆）。我们将在
    *第 11 章* 中详细介绍，因为这是一个相当庞大的工具，用于 CMake 项目的最后阶段。
- en: CMake-GUI
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CMake-GUI
- en: CMake for Windows comes with a GUI version to configure the building process
    of previously prepared projects. For Unix-like platforms there is a version built
    with QT libraries. Ubuntu offers it in the `cmake-qt-gui` package.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: CMake for Windows 附带了一个 GUI 版本，用于配置先前准备好的项目的构建过程。对于 Unix-like 平台，有一个使用 QT 库构建的版本。Ubuntu
    在 `cmake-qt-gui` 包中提供了它。
- en: To access CMake-GUI run the `cmake-gui` executable.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问 CMake-GUI，请运行 `cmake-gui` 可执行文件。
- en: '![Figure 1.4: CMake GUI: configuring stage for a buildsystem using a generator
    for Visual Studio 2019](img/file3.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4：CMake GUI：使用 Visual Studio 2019 生成器的构建系统配置阶段](img/file3.jpg)'
- en: 'Figure 1.4: CMake GUI: configuring stage for a buildsystem using a generator
    for Visual Studio 2019'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4：CMake GUI：使用 Visual Studio 2019 生成器的构建系统配置阶段
- en: GUI application is really a convenience tool for users of your application,
    as the options there are rather limited. It can be helpful for those who aren’t
    familiar with the command line and would prefer a window-based interface.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: GUI 应用程序实际上是为你的应用程序用户提供的便利工具，因为那里的选项相当有限。对于不熟悉命令行并更喜欢基于窗口的界面的用户来说，它可能会有所帮助。
- en: '**Not Recommended**'
  id: totrans-310
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**不推荐**'
- en: ''
  id: totrans-311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I would definitely recommend GUI to end-users craving convenience, but as a
    programmer I avoid introducing any manual, blocking steps that would require clicking
    on forms every time I build my programs. This is especially important for build
    automation in continuous integration pipelines. These tools require headless applications,
    so build can be fully executed without users' interaction.
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我绝对推荐 GUI 给追求便利的终端用户，但作为程序员，我避免引入任何手动、阻塞的步骤，这些步骤每次构建程序时都需要点击表单。这对于持续集成管道中的构建自动化尤其重要。这些工具需要无头应用程序，因此可以在没有用户交互的情况下完全执行构建。
- en: CCMake
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CCMake
- en: The `ccmake` executable is the CMake `curses` interface for Unix-like platforms
    (it's unavailable for Windows). It's not available as part of the CMake package,
    so users have to install it separately.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`ccmake` 可执行文件是 CMake 在 Unix-like 平台上的 `curses` 接口（在 Windows 上不可用）。它不是 CMake
    包的一部分，因此用户必须单独安装它。'
- en: 'Command for Debian/Ubuntu systems:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 命令适用于 Debian/Ubuntu 系统：
- en: '[PRE55]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Project configuration settings may be specified interactively through this GUI.
    Brief instructions are provided at the bottom of the terminal when the program
    is running.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 项目配置设置可以通过这个 GUI 进行交互式指定。当程序运行时，终端底部会提供简短的说明。
- en: Syntax of CCMake command
  id: totrans-318
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 语法 CCMake 命令
- en: '[PRE56]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: CCMake uses the same set of options as `cmake`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: CCMake 使用与 `cmake` 相同的选项集。
- en: '![Figure 1.5: Configure stage in ccmake](img/file4.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.5：ccmake 中的配置阶段](img/file4.jpg)'
- en: 'Figure 1.5: Configure stage in ccmake'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5：ccmake 中的配置阶段
- en: Like with graphical GUI - this mode is fairly limited and intended to be used
    by less experienced users. If you're using a Unix machine - I recommend you take
    a quick look and move on even quicker.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 与图形化 GUI 一样，这种模式相当有限，旨在供经验较少的用户使用。如果你使用的是 Unix 机器，我建议你快速浏览一下，然后更快地继续前进。
- en: Navigating the project files
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览项目文件
- en: CMake uses quite a few files to manage its projects. Let's get a general idea
    what each file does before tinkering with their contents. It's not only a good
    practice, but changes in random files can get easily lost. You see, even though
    a file contains CMake Language commands - it's not certain that it's meant for
    developers to edit. Some files are generated to be used by subsequent tools and
    any work done there can get written over at some stage. Other files are meant
    for advanced users, to adjust your project to their individual needs. Finally,
    there are some temporary files that provide valuable information in specific contexts.
    This section will also tell you which of them should be in the ignore file of
    your version control system.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: CMake使用相当多的文件来管理其项目。在我们开始修改这些文件的内容之前，让我们对每个文件的作用有一个大致的了解。这不仅是一种良好的实践，而且随机文件中的更改很容易丢失。您知道，即使文件包含CMake语言命令
    - 也不能确定它是为开发人员编辑的。有些文件是生成的，供后续工具使用，在那里所做的工作可能会在某个阶段被覆盖。其他文件是为高级用户准备的，以调整您的项目以满足他们的个人需求。最后，有一些临时文件在特定上下文中提供有价值的信息。本节还将告诉您哪些文件应该在版本控制系统的忽略文件中。
- en: Source Tree
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 源代码树
- en: This is the directory where your project will live (also called **project root**).
    It contains all C++ sources and CMake project files.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您的项目将存在的目录（也称为**项目根目录**）。它包含所有C++源文件和CMake项目文件。
- en: 'Here are the key takeaways:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关键要点：
- en: It is required to provide a `CMakeLists.txt` configuration file in its top directory
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要在顶层目录中提供一个`CMakeLists.txt`配置文件
- en: It should be managed with a Version Control System (or VCS) like git.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该使用版本控制系统（或VCS）如git来管理它。
- en: You can provide a path to this directory with `-S` argument to the `cmake` command.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过`cmake`命令的`-S`参数提供此目录的路径。
- en: Avoid hardcoding any absolute paths to it - your users may store it elsewhere.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免硬编码任何绝对路径到它 - 您的用户可能将其存储在其他地方。
- en: Build Tree
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建树
- en: 'CMake uses this directory to store everything that gets generated during the
    build: artifacts of the project, transient configuration, cache, build logs, and
    anything that your native build tool will create. Other names for this directory
    are: **build root** and **binary tree**.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: CMake使用此目录来存储在构建过程中生成的所有内容：项目产物、临时配置、缓存、构建日志以及您的本地构建工具将创建的任何内容。此目录的其他名称包括：**构建根目录**和**二进制树**。
- en: 'Key takeaways:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 关键要点：
- en: 'Your binary files will be created here: executables and libraries, but also
    object files and archives used for final linking.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的二进制文件将在此处创建：可执行文件和库，以及用于最终链接的对象文件和存档。
- en: Don't add this directory to your VCS - it's specific to your system. If you
    decide to put it inside the source tree - make sure to add it to the VCS ignore
    file.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要将此目录添加到您的VCS中 - 它是特定于您的系统的。如果您决定将其放在源代码树中 - 请确保将其添加到VCS忽略文件中。
- en: CMake recommends **out-of-source builds**, or builds that produce artifacts
    in a directory that is separate from all source files. This way we can avoid polluting
    our project's source tree with temporary, system-specific files (or **in-source-builds**).
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake推荐**源码外构建**，即在所有源文件之外的目录中生成构建产物的构建方式。这样我们可以避免在我们的项目源代码树中污染临时、系统特定的文件（或**源码内构建**）。
- en: 'It is specified with `-B`, or as a last argument to the `cmake` command if
    you have provided path to source: `cmake -S ../project ./`'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`-B`参数指定，或者在提供源代码路径的情况下作为`cmake`命令的最后一个参数：`cmake -S ../project ./`
- en: '`It''s recommended that projects provide an installation step to put the final
    artifacts in a correct place in the system, so all temporary files used for building
    can be removed.`'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`建议项目提供一个安装步骤，将最终产物放置在系统中的正确位置，以便可以删除用于构建的所有临时文件。`'
- en: Listfiles
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列出文件
- en: Files which contain CMake language are called Listfiles and can be included
    one in another by calling `include()` and `find_package()`, or indirectly with
    `add_subdirectory()`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 包含CMake语言的文件称为Listfiles，可以通过调用`include()`和`find_package()`，或间接使用`add_subdirectory()`来相互包含。
- en: CMake doesn't enforce consistent naming for these, but they usually have a `.cmake`
    extension.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake并不强制这些名称的一致性，但它们通常具有`.cmake`扩展名。
- en: Very important naming exception is a file called `CMakeLists.txt`, which is
    the first file to be executed in the configuration step, and is required at the
    top of the source tree.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非常重要的命名例外是一个名为`CMakeLists.txt`的文件，这是在配置步骤中首先执行的文件，并且需要在源代码树的顶部。
- en: 'As CMake walks the source tree and includes different listfiles, following
    variables are set: `CMAKE_CURRENT_LIST_DIR`, `CMAKE_CURRENT_LIST_FILE`, `CMAKE_PARENT_LIST_FILE`,
    `CMAKE_CURRENT_LIST_LINE`'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake遍历源树并包含不同的列表文件时，会设置以下变量：`CMAKE_CURRENT_LIST_DIR`，`CMAKE_CURRENT_LIST_FILE`，`CMAKE_PARENT_LIST_FILE`，`CMAKE_CURRENT_LIST_LINE`
- en: CMakeLists.txt
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CMakeLists.txt
- en: 'CMake projects are configured with `CMakeLists.txt` listfiles. You are required
    to provide at least one in the root of the source tree. Such top-level file is
    first to be executed by CMake configure step and should contain at least two commands:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: CMake项目使用`CMakeLists.txt`列表文件进行配置。您需要在源树的根目录中至少提供一个。这种顶级文件是CMake配置步骤中第一个被执行的文件，并且应至少包含两个命令：
- en: '`cmake_minimum_required(VERSION <x.xx>)` which sets an expected version of
    CMake (and implicitly tells CMake what policies to apply with regards to legacy
    behaviors).'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmake_minimum_required(VERSION <x.xx>)` 设置预期的CMake版本（并隐式告诉CMake应用哪些策略来处理遗留行为）。'
- en: '`project(<name> <OPTIONS>)` to name the project (available later in `PROJECT_NAME`
    variable), and specify options to configure it (we''ll talk this more in the next
    chapter).'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`project(<name> <OPTIONS>)` 用于命名项目（稍后在`PROJECT_NAME`变量中可用），并指定配置它的选项（我们将在下一章中更多地讨论这一点）。'
- en: 'As your software grows - you might want to partition it into smaller units
    that can be configured and reasoned about separately. CMake supports that with
    the notion of subdirectories, and their own `CMakeLists.txt` files. Your project
    structure might look similar to this example:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您的软件增长，您可能希望将其划分为可以单独配置和推理的小单元。CMake通过子目录的概念支持这一点，以及它们自己的`CMakeLists.txt`文件。您的项目结构可能与此示例类似：
- en: '[PRE57]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'A very simple `CMakeLists.txt` can then be used to bring it all together:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以使用一个非常简单的`CMakeLists.txt`将所有内容整合在一起：
- en: CMakeLists.txt
  id: totrans-353
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CMakeLists.txt
- en: '[PRE58]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Main aspects of the project are covered in the top-level file: managing dependencies,
    stating requirements, environment detection and whatnot. In this file we''ll also
    have an `add_subdirectory(api)` command to include another `CMakeListst.txt` from
    the `api` directory to perform steps specific to API part of our application.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的主要方面在顶级文件中涵盖：管理依赖项、声明要求、环境检测等。在此文件中，我们还将有一个`add_subdirectory(api)`命令，以包含来自`api`目录的另一个`CMakeListst.txt`，以执行我们应用程序API部分的具体步骤。
- en: CMakeCache.txt
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CMakeCache.txt
- en: 'CACHE variables will be generated from `listfiles` and stored in `CMakeCache.txt`
    when the configure stage is run for the first time. This file resides in root
    of the build tree, and has a fairly simple format:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存变量将从`listfiles`生成，并在首次运行配置阶段时存储在`CMakeCache.txt`中。此文件位于构建树的根目录中，并且具有相当简单的格式：
- en: '[PRE59]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As you can see from comments in the heading - this format is pretty self-explanatory.
    Cache entries in the `EXTERNAL` section are meant for users to modify while the
    `INTERNAL` section is managed by CMake and it's not recommended to change them
    manually.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 从标题中的注释可以看出 - 这种格式相当直观。`EXTERNAL`部分中的缓存条目旨在供用户修改，而`INTERNAL`部分由CMake管理，不建议手动更改它们。
- en: 'Key takeaways:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 关键要点：
- en: 'You can manage this file manually, by calling `cmake` (see *Options: Cache*
    in *Mastering the Command Line* section), or through `ccmake`/`cmake-gui`.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以手动管理此文件，通过调用`cmake`（参见*掌握命令行*部分中的*选项：缓存*），或通过`ccmake`/`cmake-gui`。
- en: You can reset the project to default configuration by deleting this file - it
    will be regenerated from listfiles.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过删除此文件，您可以将项目重置为默认配置 - 它将从列表文件中重新生成。
- en: Cache variables can be read and written from the listfiles. Sometimes variable
    reference evaluation is a bit complicated - more on that in the next chapter.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存变量可以从列表文件中读取和写入。有时变量引用评估有点复杂 - 关于这一点将在下一章中详细介绍。
- en: Package Config-files
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置文件包
- en: Big part of the CMake ecosystem are external packages that projects can depend
    on. They allow developers to use libraries and tools in a seamless, cross-platform
    way. Packages which support CMake should provide a configuration file, so CMake
    knows how to use them.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: CMake生态系统的大部分是项目可以依赖的外部包。它们允许开发人员以无缝、跨平台的方式使用库和工具。支持CMake的包应提供配置文件，以便CMake知道如何使用它们。
- en: 'We''ll be learning to write those files in *Chapter 11*. Meanwhile here''s
    a few interesting details:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*第11章*中学习编写这些文件。同时，这里有一些有趣的细节：
- en: Config-files contain information on how to use the library binaries, headers
    and helper tools. Sometimes they expose CMake macros to use in your project.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文件包含有关如何使用库二进制文件、头文件和辅助工具的信息。有时它们会公开CMake宏供您在项目中使用。
- en: Use `find_package()` command to include packages.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`find_package()`命令来包含包。
- en: CMake files describing packages are named `<PackageName>-config.cmake` and `<PackageName>Config.cmake`.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake描述包的文件被命名为`<PackageName>-config.cmake`和`<PackageName>Config.cmake`。
- en: When using packages, you can specify which version of the package you need.
    CMake will check that in the associated `<Config>Version.cmake` file.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用包时，可以指定所需的包版本。CMake将在关联的`<Config>Version.cmake`文件中检查这一点。
- en: Config-files are provided by package vendors supporting the CMake ecosystem.
    If a vendor doesn't provide such a config file, it can be replaced with a Find-module.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文件由支持CMake生态系统的包供应商提供。如果供应商没有提供这样的配置文件，可以用Find模块替换。
- en: CMake provides a package registry to store packages system-wide and per user.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake提供了一个包注册表，用于存储系统范围和每个用户的包。
- en: cmake_install.cmake, CTestTestfile.cmake, CPackConfig.cmake
  id: totrans-373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: cmake_install.cmake, CTestTestfile.cmake, CPackConfig.cmake
- en: These files are generated in the build tree by `cmake` executable in the generation
    step. As such - they shouldn't be edited manually. CMake uses them as a configuration
    for `cmake` install action, CTest and CPack. If you're doing an in-source build
    (not recommended), it's probably a good idea to add them to VCS ignore file.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件是在生成步骤中由`cmake`可执行文件在构建树中生成的。因此，不应手动编辑它们。CMake使用它们作为`cmake`安装操作、CTest和CPack的配置。如果你正在进行源内构建（不推荐），那么可能是个好主意将它们添加到VCS忽略文件中。
- en: CMakePresets.json, CMakeUserPresets.json
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CMakePresets.json, CMakeUserPresets.json
- en: Configuration of the projects can become quite a busy task when we require to
    be specific about things like cache variables, chosen generators, path of build
    tree and so on. Especially when we have more than one way of building our project.
    This is where the presets come in.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要对缓存变量、选定的生成器、构建树路径等事项进行具体配置时，项目的配置可能会变得相当繁琐。尤其是在我们有多种构建项目的方式时。这时预设就派上用场了。
- en: Users can choose presets through GUI or use the command line to `--list-presets`
    and select a preset for buildsystem with `--preset=<preset>` option. You'll find
    more details in the *Mastering the Command Line* section of this chapter.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过图形界面选择预设，或者使用命令行来`--list-presets`并使用`--preset=<preset>`选项为构建系统选择一个预设。你会在本章的*精通命令行*部分找到更多详细信息。
- en: 'Presets are stored in the same JSON format in two files:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 预设以相同的JSON格式存储在两个文件中：
- en: '`CMakePresets.json` meant for project authors to provide official presets'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMakePresets.json`旨在供项目作者提供官方预设'
- en: '`CMakeUserPresets.json` dedicated for users who want to customize project configuration
    to their liking (add it to your VCS ignore file)'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMakeUserPresets.json`专为那些希望根据自己的喜好定制项目配置的用户而设（将其添加到你的VCS忽略文件中）'
- en: Presets are project files, so their explanation belongs here. But they are not
    required in projects and they only become useful when we have completed the initial
    setup, so feel free to skip to the next section and return here later if needed.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 预设是项目文件，因此它们的解释属于这里。但它们在项目中不是必需的，只有在完成初始设置后它们才变得有用，所以如果需要，可以自由跳到下一部分，稍后再回到这里。
- en: chapter-01/02-presets/CMakePresets.json
  id: totrans-382
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: chapter-01/02-presets/CMakePresets.json
- en: '[PRE60]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`CmakePresets.json` specifies following root fields:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`CmakePresets.json`指定了以下根字段：'
- en: '`version` - required, always `1`'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version` - 必需，始终为`1`'
- en: '`cmakeMinimumRequired` - optional, specifies CMake version, object with three
    fields: `major`, `minor`, `patch`'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmakeMinimumRequired` - 可选，指定CMake版本，具有三个字段的对象：`major`, `minor`, `patch`'
- en: '`vendor` - optional map of vendor-specific options external tools like IDEs,
    keyed with vendor domain and slash separated path. CMake virtually ignores this
    field.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vendor` - 可选映射，包含供应商特定选项的外部工具，如IDE，键值为供应商域名和斜杠分隔的路径。CMake实际上忽略了这个字段。'
- en: '`configurePresets` - optional array of available presets.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configurePresets` - 可选数组，包含可用的预设。'
- en: 'Let''s add two presets to our `configurePresets` array:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向我们的`configurePresets`数组添加两个预设：
- en: 'chapter-01/02-presets/CMakePresets.json : my-preset'
  id: totrans-390
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 'chapter-01/02-presets/CMakePresets.json : my-preset'
- en: '[PRE61]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This file supports tree-like structure, where children presets inherit properties
    from multiple parent presets. This means we can create a copy of above preset,
    and override only the fields we need. Here''s what a child-preset might look like:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件支持树状结构，其中子预设从多个父预设继承属性。这意味着我们可以创建上述预设的副本，并且只覆盖我们需要的字段。下面是一个子预设可能的样子：
- en: 'chapter-01/02-presets/CMakePresets.json : my-preset-multi'
  id: totrans-393
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 'chapter-01/02-presets/CMakePresets.json : my-preset-multi'
- en: '[PRE62]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '**Note**'
  id: totrans-395
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意**'
- en: ''
  id: totrans-396
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: CMake documentation labels only few fields as explicitly required. However,
    there are some other fields labeled as optional which must be provided either
    in the preset, or inherited from its parent.
  id: totrans-397
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: CMake 文档仅将少数字段标记为明确必需。然而，还有一些其他标记为可选的字段，这些字段必须在预设中提供，或者从其父级继承。
- en: 'Presets are defined as maps with following fields:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 预设定义为具有以下字段的地图：
- en: '`name` - **required** string identifying the preset. It has to be machine-friendly
    and unique across both files.'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name` - **必需**字符串，用于标识预设。它必须是机器友好的，并且在两个文件中都是唯一的。'
- en: '`hidden` - optional boolean hiding preset from GUI and command-line list. Such
    a preset can be a parent of another and doesn''t need to provide anything but
    its name.'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hidden` - 可选的布尔值，用于从 GUI 和命令行列表中隐藏预设。这样的预设可以是另一个预设的父级，并且不需要提供除其名称之外的任何内容。'
- en: '`displayName` - optional string with human-friendly name'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`displayName` - 可选的人类友好名称字符串'
- en: '`description` - optional string describing the preset'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description` - 可选字符串，用于描述预设'
- en: '`inherits` - optional string or array of preset names to inherit from. Values
    from earlier presets will be preferred in case of conflicts, and every preset
    is free to override any inherited field. Also - `CMakeUserPresets.json` can inherit
    from project presets but not the other way around.'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inherits` - 可选字符串或预设名称数组，用于继承自其他预设。在发生冲突时，将优先使用较早预设的值，并且每个预设都可以自由覆盖任何继承的字段。此外，`CMakeUserPresets.json`
    可以继承项目预设，但不能反向继承。'
- en: '`vendor` - optional map of vendor-specific values, follows the same convention
    as root-level `vendor` field.'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vendor` - 可选的供应商特定值映射，遵循与根级别 `vendor` 字段相同的约定。'
- en: '`generator` - **required or inherited** string specifying generator to use
    for the preset.'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generator` - **必需或继承**字符串，指定用于预设的生成器。'
- en: '`architecture`, `toolset` - optional fields configuring generators that support
    these. Each field can simply be a string or an object with `value` and `strategy`
    fields, where `strategy` is either `set` or `external`. Strategy configured to
    `set` will set the value and produce error if generator doesn''t support this
    field. Configuring `external` means that the field value is set for an external
    IDE and CMake should ignore it.'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`architecture`、`toolset` - 可选字段，用于配置支持这些字段的生成器。每个字段可以简单地是一个字符串或一个具有 `value`
    和 `strategy` 字段的对象，其中 `strategy` 可以是 `set` 或 `external`。配置为 `set` 的策略将设置值，并在生成器不支持该字段时产生错误。配置为
    `external` 意味着该字段值是为外部 IDE 设置的，CMake 应该忽略它。'
- en: '`binaryDir` - **required or inherited** string providing path to the build
    tree directory (absolute or relative to the source tree). Supports macro expansion.'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binaryDir` - **必需或继承**字符串，提供构建树目录的路径（绝对路径或相对于源树的路径）。支持宏扩展。'
- en: '`cacheVariables` - optional map of cache variables, where keys denote variable
    names. Accepted values are: `null`, `"TRUE"`, `"FALSE"`, a string-value or an
    object with optional `type` and required `value` fields. `value` can be a string
    value, `"TRUE"` or `"FALSE"`.'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cacheVariables` - 可选的缓存变量映射，其中键表示变量名称。接受的值为：`null`、`"TRUE"`、`"FALSE"`、字符串值或具有可选
    `type` 和必需 `value` 字段的对象。`value` 可以是字符串值、`"TRUE"` 或 `"FALSE"`。'
- en: Cache variables are inherited with union operation unless value is specified
    as `null` - then it remains unset. String-values support macro expansion.
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 缓存变量继承采用联合操作，除非值被指定为 `null` - 在这种情况下，它保持未设置状态。字符串值支持宏扩展。
- en: '`environment` - optional map of environment variables, where keys denote variable
    names. Accepted values are: `null` or a string-value.'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`environment` - 可选的环境变量映射，其中键表示变量名称。接受的值为：`null` 或字符串值。'
- en: Environment variables are inherited with union operation unless value is specified
    as `null` - then it remains unset. String-values support macro expansion, and
    variables may reference each other in any order, as long as there is no cyclic
    reference.
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 环境变量继承采用联合操作，除非值被指定为 `null` - 在这种情况下，它保持未设置状态。字符串值支持宏扩展，并且变量可以以任何顺序引用彼此，只要不存在循环引用。
- en: 'Following macros are recognized and evaluated:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 以下宏被识别并进行评估：
- en: '`${sourceDir}` - path to the source tree'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${sourceDir}` - 源树的路径'
- en: '`${sourceParentDir}` - path to the source tree''s parent directory'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${sourceParentDir}` - 源树父目录的路径'
- en: '`${sourceDirName}` - the last filename component of `${sourceDir}` i.e., for
    `/home/rafal/project` it would be `project`'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${sourceDirName}` - `${sourceDir}` 的最后一个文件名组件，例如，对于 `/home/rafal/project`，它将是
    `project`'
- en: '`${presetName}` - value of preset''s name field'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${presetName}` - 预设名称字段的值'
- en: '`${generator}` - value of preset''s generator field'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${generator}` - 预设的生成器字段值'
- en: '`${dollar}` - a literal dollar sign ($)'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${dollar}` - 字面美元符号（$）'
- en: '`$env{<variable-name>}` - environment variable macro. It will return the value
    of variable from the preset if defined, otherwise - the value from the parent
    environment. Remember that variable names in presets are case-sensitive (unlike
    in Windows environment).'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$env{<variable-name>}` - 环境变量宏。如果定义了预设，它将返回变量的值，否则 - 从父环境返回值。请记住，预设中的变量名是区分大小写的（与Windows环境不同）。'
- en: '`$penv{<variable-name>}` - just like `$env`, but always returns values from
    the parent environment. This allows to resolve issues with circular-references
    that are not allowed in the environment variables of the preset.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$penv{<variable-name>}` - 与$env类似，但总是从父环境返回值。这允许解决预设环境变量中不允许的循环引用问题。'
- en: '`$vendor{<macro-name>}` - Allows for vendors to insert their own macros.'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$vendor{<macro-name>}` - 允许供应商插入自己的宏。'
- en: Ignoring files in Git
  id: totrans-422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 忽略Git中的文件
- en: 'There are many Version Control Systems, one of the most popular out there is
    Git. Whenever we start a new project it is good to make sure that we only check
    in to the repository files that need to be there. Project hygiene is easier to
    maintain if we just add some generated, user and temporary files to the `.gitignore`
    file. This way - git knows to automatically skip them when building new commits.
    Here''s the file I use in my projects:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多版本控制系统，其中最流行的是Git。每当我们开始一个新项目时，最好确保我们只将需要的文件检入到仓库中。如果我们只是将一些生成的、用户和临时文件添加到`.gitignore`文件中，项目卫生更容易维护。这样
    - git在构建新提交时会自动跳过它们。以下是我在项目中使用的文件：
- en: chapter-01/01-hello/.gitignore
  id: totrans-424
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: chapter-01/01-hello/.gitignore
- en: '[PRE63]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Using above file in your projects will allow for more flexibility for you, other
    contributors and users.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中使用上述文件将为您、其他贡献者和用户提供更大的灵活性。
- en: Unknown territory of project files is now charted. With this map you'll soon
    be able to write your own listfiles, configure cache, presets and more. Before
    sail on the open seas of project writing - let's see what other kinds of self-contained
    units you can create with CMake.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 项目文件的未知领域现已绘制出来。有了这张地图，您很快就能编写自己的listfiles、配置缓存、预设等。在启航于项目编写的广阔海洋之前 - 让我们看看还可以用CMake创建哪些其他类型的自包含单元。
- en: Discovering Scripts and Modules
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发现脚本和模块
- en: 'Work with CMake is primarily focused on projects that get built, production
    of artifacts that get consumed by other systems: CI/CD pipelines, test platforms
    and deployed to machines or artifact repositories. There are however two other
    concepts that CMake enables you to create with its language: scripts and modules.
    Let''s take a closer look.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: CMake的工作主要集中在构建项目上，生产出的工件被其他系统消耗：CI/CD管道、测试平台和部署到机器或工件存储库。然而，CMake还启用了另外两个概念，您可以用其语言创建：脚本和模块。让我们更仔细地看看。
- en: Scripts
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 脚本
- en: To configure project building CMake offers a platform-agnostic programming language.
    It comes with many useful commands. You can use this tool to write scripts that
    come with your project or are completely independent.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置项目构建，CMake提供了一个与平台无关的编程语言。它带有许多有用的命令。您可以使用这个工具编写随项目一起提供的脚本或完全独立的脚本。
- en: 'Think of it as a consistent way to do cross-platform work: instead of using
    bash scripts on Linux and batch or powershell scripts on Windows - you can have
    one version. Sure, you could bring in external tools like python, perl or ruby
    scripts, but this is yet another dependency and increased complexity for your
    C/C++ projects. Yes, sometimes this will be the only thing that can get the job
    done, but more often than not we can get away with something much simpler.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 将其视为跨平台工作的统一方式：不必在Linux上使用bash脚本，在Windows上使用批处理或powershell脚本 - 您可以有一个版本。当然，您可以引入外部工具，如python、perl或ruby脚本，但这又是另一个依赖项，增加了C/C++项目的复杂性。是的，有时这是唯一能完成工作的方法，但大多数情况下，我们可以用更简单的方法来解决问题。
- en: 'We already know from the *Mastering the Command Line* section that we can execute
    scripts with `-P` option: `cmake -P script.cmake`, but what are the actual requirements
    for the script file provided? Not that many: script can be as complex as you like
    or an empty file, it is however recommended to call `cmake_minimum_required()`
    command at the beginning of the script to give CMake hint which policies it should
    apply to commands with legacy behavior.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从“掌握命令行”部分知道，我们可以使用`-P`选项执行脚本：`cmake -P script.cmake`，但是提供给脚本文件的实际要求是什么？并不多：脚本可以像您喜欢的那样复杂或是一个空文件，但是建议在脚本的开头调用`cmake_minimum_required()`命令，以给CMake提示它应该对具有遗留行为的命令应用哪些策略。
- en: chapter-01/03-script/script.cmake
  id: totrans-434
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: chapter-01/03-script/script.cmake
- en: '[PRE64]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'When running scripts CMake won''t execute any of the usual stages (configuration,
    generation), and it won''t use cache. Since there is no concept of source/build
    tree in scripts - variables that usually hold references to these paths will contain
    current working directory instead: `CMAKE_BINARY_DIR`, `CMAKE_SOURCE_DIR`, `CMAKE_CURRENT_BINARY_DIR`
    and `CMAKE_CURRENT_SOURCE_DIR`.'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行脚本时，CMake不会执行任何常规阶段（配置、生成），也不会使用缓存。由于脚本中没有源/构建树的概念，通常持有这些路径引用的变量将包含当前工作目录：`CMAKE_BINARY_DIR`、`CMAKE_SOURCE_DIR`、`CMAKE_CURRENT_BINARY_DIR`和`CMAKE_CURRENT_SOURCE_DIR`。
- en: Happy scripting.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 愉快的脚本编写。
- en: Utility Modules
  id: totrans-438
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实用模块
- en: CMake projects can use external modules to enhance their functionality. Modules
    are written in CMake language and contain macro definitions, variables and commands
    which perform all kinds of functions. They range from quite complex scripts (`CPack`
    and `CTest` also provide their modules!) to fairly simple ones, like `AddFileDependencies`
    or `TestBigEndian`.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: CMake项目可以使用外部模块来增强其功能。模块是用CMake语言编写的，包含宏定义、变量和执行各种功能的命令。它们从相当复杂的脚本（`CPack`和`CTest`也提供它们的模块！）到相当简单的脚本，如`AddFileDependencies`或`TestBigEndian`。
- en: 'CMake distribution comes packed with almost 90 different utility modules. If
    that''s not enough - you can download more from the Internet by browsing curated
    lists like this one: [https://github.com/onqtam/awesome-cmake](https://github.com/onqtam/awesome-cmake)
    or write a module from scratch.'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: CMake发行版附带了近90个不同的实用模块。如果这还不够，你可以通过浏览这样的精选列表从互联网上下载更多：[https://github.com/onqtam/awesome-cmake](https://github.com/onqtam/awesome-cmake)，或者从头开始编写一个模块。
- en: 'To use a utility module we need to call an `include(<MODULE>)` command. Here''s
    a simple project showing that in action:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用实用模块，我们需要调用一个`include(<MODULE>)`命令。这里有一个简单的项目示例展示了这一操作：
- en: chapter-01/04-module/CMakeLists.txt
  id: totrans-442
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: chapter-01/04-module/CMakeLists.txt
- en: '[PRE65]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We''ll learn what modules are available as they become relevant to the subject
    at hand. If you''re curious - a full list of bundled modules can be found here:
    [https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html](https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html).'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习哪些模块可用，因为它们与当前主题相关。如果你好奇，可以在这里找到捆绑模块的完整列表：[https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html](https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html)。
- en: Find-Modules
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找模块
- en: In the section about *Package Config-files* I have mentioned that CMake has
    a mechanism to find files belonging to external dependencies which don't support
    CMake and don't provide a CMake config file (or didn't). That's what the find-modules
    are for. CMake provides over 150 modules locating different packages in the system.
    As was the case with utility modules - there's plenty more find-modules available
    online and an option to write your own as a last resort.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于*包配置文件*的部分中，我提到了CMake有一个机制来查找属于不支持CMake且不提供CMake配置文件（或没有）的外部依赖的文件。这就是查找模块的作用。CMake提供了超过150个模块，用于在系统中定位不同的包。与实用模块一样，网上有更多的查找模块可用，并且作为最后的手段，你可以编写自己的查找模块。
- en: You can use them by calling `find_package()` command and providing the name
    of the package in question. Such a find-module will then play a little game of
    hide-and-seek and check all known locations of the software it is looking for.
    Then it defines variables (specified that module's manual) which allow building
    against that dependency.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用`find_package()`命令并提供相关包的名称来使用它们。这样的查找模块将进行一场小小的捉迷藏游戏，检查软件所在的所有已知位置。然后，它定义变量（在模块手册中指定），允许构建针对该依赖项。
- en: 'For example, the `FindCURL` module is searching for a popular *Client URL*
    library and defines following variables: `CURL_FOUND`, `CURL_INCLUDE_DIRS`, `CURL_LIBRARIES`,
    `CURL_VERSION_STRING`.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`FindCURL`模块正在搜索流行的*客户端URL*库，并定义以下变量：`CURL_FOUND`、`CURL_INCLUDE_DIRS`、`CURL_LIBRARIES`、`CURL_VERSION_STRING`。
- en: '*Chapter 7* covers find-modules in depth.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '*第7章*深入介绍了查找模块。'
- en: Summary
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'Now you understand what CMake is and how it works: what are the key components
    of CMake tool family, and how to install them on a variety of systems. Like a
    true power user, you know all the ways of running CMake through the command line:
    buildsystem generation, building a project, installing, running scripts, command
    line tools and printing help. You are aware of CTest, CPack and GUI applications.
    This will help you create projects with the right perspective: for users and other
    developers. You also learned what makes up a project: directories, listfiles,
    configs, presets and helper files and what to ignore in your VCS. Finally - you
    took a sneak-peak at other non-project files: standalone scripts and modules.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了CMake是什么以及它是如何工作的：CMake工具家族的关键组件是什么，以及如何在各种系统上安装它们。作为一个真正的资深用户，你了解通过命令行运行CMake的所有方式：生成构建系统、构建项目、安装、运行脚本、命令行工具和打印帮助。你知道CTest、CPack和GUI应用程序。这将帮助你以正确的视角创建项目：为用户和其他开发者。你还学习了构成项目的要素：目录、listfiles、配置、预设和辅助文件，以及在你的VCS中应该忽略什么。最后，你偷偷瞥见了其他非项目文件：独立脚本和模块。
- en: Next up is a deep dive into CMake's programming language. It will allow you
    to write your own listfiles and open the door to your first scripts, projects
    and modules.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是对CMake编程语言的深入探讨。它将允许你编写自己的listfiles，并为你打开编写第一个脚本、项目和模块的大门。
- en: Further Reading
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information you can refer to the following links:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 如需更多信息，您可以参考以下链接：
- en: 'Official CMake webpage with the documentation: [https://cmake.org/](https://cmake.org/)'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方CMake网页及其文档：[https://cmake.org/](https://cmake.org/)
- en: 'Single-Configuration generators: [https://cgold.readthedocs.io/en/latest/glossary/single-config.html](https://cgold.readthedocs.io/en/latest/glossary/single-config.html)'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单配置生成器：[https://cgold.readthedocs.io/en/latest/glossary/single-config.html](https://cgold.readthedocs.io/en/latest/glossary/single-config.html)
- en: 'Separation of stages in CMake GUI: [https://stackoverflow.com/questions/39401003/why-there-are-two-buttons-in-gui-configure-and-generate-when-cli-does-all-in-one](https://stackoverflow.com/questions/39401003/why-there-are-two-buttons-in-gui-configure-and-generate-when-cli-does-all-in-one)'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake GUI中阶段的分离：[https://stackoverflow.com/questions/39401003/why-there-are-two-buttons-in-gui-configure-and-generate-when-cli-does-all-in-one](https://stackoverflow.com/questions/39401003/why-there-are-two-buttons-in-gui-configure-and-generate-when-cli-does-all-in-one)
