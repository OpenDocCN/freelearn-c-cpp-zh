- en: Appendix
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录
- en: About
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于
- en: This section is included to assist the students to perform the activities in
    the book. It includes detailed steps that are to be performed by the students
    to achieve the objectives of the activities.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包括帮助学生完成书中活动的内容。它包括学生需要执行的详细步骤，以实现活动的目标。
- en: 'Chapter 1: Lists, Stacks, and Queues'
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1章：列表、栈和队列
- en: 'Activity 1: Implementing a Song Playlist'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动1：实现歌曲播放列表
- en: 'In this activity, we will implement a tweaked version of a doubly linked list
    which can be used to store a song playlist and supports the necessary functions.
    Follow these steps to complete the activity:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将实现一个稍加改进的双向链表的版本，它可以用来存储歌曲播放列表，并支持必要的功能。按照以下步骤完成这个活动：
- en: 'Let''s first include the header and write the node structure with the required
    data members:'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先包括头文件，并编写具有所需数据成员的节点结构：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let''s write a basic constructor and size function:'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个基本的构造函数和size函数：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We'll discuss why we need a dummy node between the first and the last node later
    on, in the case of iterating using iterators.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，在使用迭代器进行迭代时，我们将讨论为什么需要在第一个节点和最后一个节点之间有一个虚拟节点。
- en: 'Now, let''s write the `insert` and `erase` functions. Both will take one value
    to be inserted or deleted:'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写`insert`和`erase`函数。两者都将接受一个要插入或删除的值：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let''s write a basic structure for the required iterator and add members
    to access the actual data:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为所需的迭代器编写一个基本结构，并添加成员来访问实际数据：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let''s implement the core functions of an iterator – pre- and post-increments:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们实现迭代器的核心函数——前增量和后增量：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s add the decrement-related operations to make it bidirectional:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加与递减相关的操作，使其双向：
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s implement equality-related operators for the iterator, which are essential
    for range-based loops:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为迭代器实现与相等相关的运算符，这对于基于范围的循环是必不可少的：
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let''s write the `begin` and `end` functions with their `const` versions
    as well:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写`begin`和`end`函数，以及它们的`const`版本：
- en: '[PRE7]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s write a copy constructor, initializer list constructor, and destructor:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写一个复制构造函数、初始化列表构造函数和析构函数：
- en: '[PRE8]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let''s add a class for the music player''s playlist for our actual application.
    Instead of storing the songs, we''ll just go ahead and store integers indicating
    the ID of the song for ease of understanding:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为音乐播放器的播放列表添加一个类，用于我们实际的应用程序。我们将直接存储表示歌曲ID的整数，而不是存储歌曲：
- en: '[PRE9]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s now implement functions to add and delete songs:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们实现添加和删除歌曲的函数：
- en: '[PRE10]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s implement functions to print all the songs:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们实现打印所有歌曲的函数：
- en: '[PRE11]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s write a `main` function to use the playlist of our music player:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写一个`main`函数来使用我们音乐播放器的播放列表：
- en: '[PRE12]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Upon executing this, you should get output like this:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行此操作后，您应该得到如下输出：
- en: '[PRE13]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Activity 2: Simulating a Card Game'
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动2：模拟一场纸牌游戏
- en: 'In this activity, we will simulate a card game and implement an efficient data
    structure to store the information about each player''s cards. Follow these steps
    to complete the activity:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将模拟一场纸牌游戏，并实现一个高效的数据结构来存储每个玩家的卡牌信息。按照以下步骤完成这个活动：
- en: 'First, let''s include the necessary headers:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们包括必要的头文件：
- en: '[PRE14]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, let''s create a class to store the cards and a utility method to print
    them properly:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个类来存储卡牌，并编写一个实用方法来正确打印它们：
- en: '[PRE15]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we can create a deck of cards and shuffle the deck to randomly distribute
    the cards to each of the four players. We''ll write this logic inside a `game`
    class and call the functions later on in the `main` function:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一副牌，并洗牌以将牌随机分发给四名玩家。我们将在一个`game`类中编写这个逻辑，并在`main`函数中稍后调用这些函数：
- en: '[PRE16]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s write the core logic to play one round. To avoid duplicating the code,
    we will write a utility function that will compare two players'' hands and remove
    both cards if required:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写核心逻辑来进行一轮游戏。为了避免重复代码，我们将编写一个实用函数，用于比较两个玩家的手牌，并在需要时移除两张卡：
- en: '[PRE17]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let''s write the main logic to find out who''s the winner. We''ll call
    the preceding function in a loop until one of the players can get rid of all their
    cards. To make the code more readable, we will write another utility function
    to check whether the game has been completed:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写主要逻辑来找出谁是赢家。我们将在循环中调用前面的函数，直到其中一个玩家能够摆脱所有的卡牌。为了使代码更易读，我们将编写另一个实用函数来检查游戏是否已经完成：
- en: '[PRE18]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To find out who''s the winner, let''s write a utility function before starting
    the `main` function:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了找出谁是赢家，让我们在开始`main`函数之前编写一个实用函数：
- en: '[PRE19]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, let''s write the `main` function to execute the game:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们编写`main`函数来执行游戏：
- en: '[PRE20]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'One of the possible outputs could be as follows:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可能的输出之一如下：
- en: '[PRE21]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The winner could be any player from 1 to 4\. Since the game is based on randomness
    seeded by the time during execution, any of the players can win. Running the code
    multiple times may yield a different output every time.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 赢家可能是1到4号玩家中的任何一个。由于游戏是基于执行期间的时间种子随机性的，任何玩家都有可能获胜。多次运行代码可能会产生不同的输出。
- en: 'Activity 3: Simulating a Queue for a Shared Printer in an Office'
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动3：模拟办公室共享打印机的队列
- en: 'In this activity, we shall implement a queue for handling print requests to
    a shared printer in an office. Follow these steps to complete the activity:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将实现一个队列，用于处理办公室中共享打印机的打印请求。按照以下步骤完成这个活动：
- en: 'Let''s include the required headers:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们包括所需的头文件：
- en: '[PRE22]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s implement a `Job` class:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们实现一个`Job`类：
- en: '[PRE23]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, let''s implement the `Printer` class. We''ll use `std::queue` to have
    a first come, first served policy for `jobs`. We''ll keep the class templated
    based on the maximum number of jobs it can store in memory:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们实现`Printer`类。我们将使用`std::queue`来实现先到先服务的`jobs`策略。我们将基于内存中可以存储的最大作业数来模板化类：
- en: '[PRE24]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let''s implement another major functionality – printing jobs:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们实现另一个重要功能——打印作业：
- en: '[PRE25]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, let''s use these classes to simulate the scenario:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用这些类来模拟这种情景：
- en: '[PRE26]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here is the output of the preceding code:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是前述代码的输出：
- en: '[PRE27]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Chapter 2: Trees, Heaps, and Graphs'
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2章：树、堆和图
- en: 'Activity 4: Create a Data Structure for a Filesystem'
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动4：为文件系统创建数据结构
- en: 'In this activity, we will create a data structure using N-ary tree for a file
    system. Follow these steps to complete the activity:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将使用N叉树创建一个文件系统的数据结构。按照以下步骤完成这个活动：
- en: 'First, let''s include the required headers:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们包括所需的头文件：
- en: '[PRE28]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, let''s write a node to store the data of a directory/file:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个节点来存储目录/文件的数据：
- en: '[PRE29]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, let''s wrap this node in a tree structure for a good interface, and also
    add a static member so that we can store the current directory:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将这个节点包装在一个树结构中，以获得良好的接口，并添加一个静态成员，以便我们可以存储当前目录：
- en: '[PRE30]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, let''s add a constructor so that we can create a tree with a root directory:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个构造函数，以便我们可以创建一个带有根目录的树：
- en: '[PRE31]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, let''s add a function to find the directory/file:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个函数来查找目录/文件：
- en: '[PRE32]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, let''s add a function to add a directory:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个函数来添加一个目录：
- en: '[PRE33]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, let''s add a function to change the current directory. This will be very
    simple since we already have a function to find the path:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个函数来更改当前目录。这将非常简单，因为我们已经有一个函数来查找路径：
- en: '[PRE34]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, let''s add a function to print a directory or a file. For a file, we''ll
    just print the name of the file. For a directory, we''ll print all of its children''s
    names, just like the `ls` command in Linux:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个函数来打印目录或文件。对于文件，我们只会打印文件的名称。对于目录，我们将打印所有子目录的名称，就像Linux中的“ls”命令一样：
- en: '[PRE35]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s write a main function so that we can use the aforementioned functions:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写一个主函数，以便我们可以使用上述函数：
- en: '[PRE36]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '[PRE37]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Activity 5: K-Way Merge Using Heaps'
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动5：使用堆进行K路合并
- en: 'In this activity, we will merge multiple sorted arrays into a single sorted
    array. These steps will help you complete the activity:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将把多个排序的数组合并成一个排序的数组。以下步骤将帮助您完成这个活动：
- en: 'Start with the required headers:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从所需的头文件开始：
- en: '[PRE38]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, implement the main algorithm for merging. It will take a vector of a vector
    of `int` as input and will contain the vector of all the sorted vectors. Then,
    it will return the merged vector of `int`. First, let''s build the heap node:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实现合并的主要算法。它将以一个int向量的向量作为输入，并包含所有排序向量的向量。然后，它将返回合并的int向量。首先，让我们构建堆节点：
- en: '[PRE39]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As we can see, the heap node will contain three things – data, the position
    of the list in the input, and the position of the data item inside that list.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，堆节点将包含三个东西——数据、输入列表中的位置和该列表中数据项的位置。
- en: 'Let''s build the heap. The idea is to have a min heap with the smallest element
    from all the lists. So, when we pop from the heap, we are guaranteed to get the
    smallest element. After removing that element, we need to insert the next element
    from the same list, if it''s available:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们构建堆。想法是创建一个最小堆，其中包含所有列表中的最小元素。因此，当我们从堆中弹出时，我们保证得到最小的元素。删除该元素后，如果可用，我们需要插入相同列表中的下一个元素：
- en: '[PRE40]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, we''ll build the resultant vector. We''ll simply remove the elements from
    the heap until it is empty and replace it with the next element from the same
    list it belongs to, if available:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将构建结果向量。我们将简单地从堆中删除元素，直到它为空，并用相同列表中的下一个元素（如果可用）替换它：
- en: '[PRE41]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let''s write a `main` function so that we can use the preceding function:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写一个“main”函数，以便我们可以使用前面的函数：
- en: '[PRE42]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You should see the following output:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '[PRE43]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Chapter 3: Hash Tables and Bloom Filters'
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3章：哈希表和布隆过滤器
- en: 'Activity 6: Mapping Long URLs to Short URLs'
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动6：将长URL映射到短URL
- en: 'In this activity, we will create a program to map shorter URLs to corresponding
    longer URLs. Follow these steps to complete the activity:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将创建一个程序，将较短的URL映射到相应的较长URL。按照以下步骤完成这个活动：
- en: 'Let''s include the required headers:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们包括所需的头文件：
- en: '[PRE44]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s write a struct called `URLService` that will provide the interface for
    the required services:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写一个名为“URLService”的结构，它将提供所需服务的接口：
- en: '[PRE45]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As we can see, we've created a map from the small URL to the original URL. This
    is because we use the small URL for the lookup. We want to convert it into the
    original URL. As we saw earlier, a map can do fast lookups based on a key. So,
    we have kept the smaller URL as the key of the map and the original URL as the
    value of the map. We have created aliases to avoid confusion regarding which string
    we are talking about.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们已经创建了一个从小URL到原始URL的映射。这是因为我们使用小URL进行查找。我们希望将其转换为原始URL。正如我们之前看到的，映射可以根据键进行快速查找。因此，我们将较小的URL保留为映射的键，将原始URL保留为映射的值。我们已经创建了别名，以避免混淆，不清楚我们在谈论哪个字符串。
- en: 'Let''s add a `lookup` function:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个“查找”函数：
- en: '[PRE46]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, let''s write a function to register the smaller URL for the given actual
    URL:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个函数，为给定的实际URL注册较小的URL：
- en: '[PRE47]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `registerURL` function returns if there is already an existing entry in
    the data. If so, it will not touch the entry. Otherwise, it will register the
    entry and return `true` to indicate that.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: “registerURL”函数返回数据中是否已经存在条目。如果是，它将不会触及该条目。否则，它将注册该条目并返回“true”以指示注册成功。
- en: 'Now, let''s write a function to delete the entry:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个删除条目的函数：
- en: '[PRE48]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As we can see, we are using the `lookup` function instead of rewriting the find
    logic again. This function is much more readable now.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们使用了“查找”函数，而不是重新编写查找逻辑。现在这个函数更易读了。
- en: 'Now, let''s write a function to print all the mappings for logging:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个函数来打印所有映射以进行日志记录：
- en: '[PRE49]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, write the `main` function so that we can use this service:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编写“main”函数，以便我们可以使用这个服务：
- en: '[PRE50]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Let''s look at the output of the preceding code:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看前面代码的输出：
- en: '[PRE51]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As we can see, we are getting both the valid URLs at the end, and not the one
    we deregistered successfully.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，最后得到的是两个有效的URL，而不是我们成功注销的URL。
- en: 'Activity 7: Email Address Validator'
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动7：电子邮件地址验证器
- en: 'In this activity, we will create a validator to check if an email address requested
    by a user is already taken. Complete the activity using these steps:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将创建一个验证器来检查用户请求的电子邮件地址是否已经被使用。按照以下步骤完成活动：
- en: 'Let''s include the required headers:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们包括所需的头文件：
- en: '[PRE52]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s add a class for the Bloom filter:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为Bloom过滤器添加一个类：
- en: '[PRE53]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let''s add a constructor for this:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为此添加一个构造函数：
- en: '[PRE54]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Since we're going to use each byte in the hash value buffer as a different hash
    function value, and the size of the hash value buffer is 16 bytes (128 bits),
    we can't have more hash functions than that. Since each hash value is just 1 byte,
    its possible values are `0` to `255`. So, the size of the Bloom filter can't exceed
    `255`. Hence, we're throwing an error in the constructor itself.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用哈希值缓冲区中的每个字节作为不同的哈希函数值，并且哈希值缓冲区的大小为16字节（128位），我们不能有比这更多的哈希函数。由于每个哈希值只是1个字节，它的可能值是`0`到`255`。因此，Bloom过滤器的大小不能超过`255`。因此，我们在构造函数中抛出错误。
- en: 'Now, let''s write a hash function. It simply uses the MD5 function to calculate
    the hash:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个哈希函数。它简单地使用MD5函数来计算哈希：
- en: '[PRE55]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let''s add the function so that we can insert an email:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个函数，以便我们可以插入一个电子邮件：
- en: '[PRE56]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As we can see, we are iterating from the the bytes `0` to `nHashes` in the hash
    value buffer and setting each bit to `1`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们正在从哈希值缓冲区中的字节`0`迭代到`nHashes`，并将每个位设置为`1`。
- en: 'Similarly, let''s add a function to find an email address:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样地，让我们添加一个查找电子邮件地址的函数：
- en: '[PRE57]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let''s add the `main` function:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加`main`函数：
- en: '[PRE58]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The following is one of the possible outputs of the preceding code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的可能输出之一：
- en: '[PRE59]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This is one of the possible outputs because MD5 is a randomized algorithm. If
    we choose the number of functions and the size of the Bloom filter in a thoughtful
    way, we should get really good accuracy with the MD5 algorithm.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可能的输出之一，因为MD5是一个随机算法。如果我们以周到的方式选择函数的数量和Bloom过滤器的大小，我们应该能够通过MD5算法获得非常好的准确性。
- en: 'Chapter 4: Divide and Conquer'
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4章：分而治之
- en: 'Activity 8: Vaccinations'
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动8：疫苗接种
- en: 'In this activity, we will store and lookup the vaccination status of students
    to determine if they need to be vaccinated. These steps should help you complete
    the activity:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将存储和查找学生的疫苗接种状态，以确定他们是否需要接种疫苗。这些步骤应该帮助您完成这个活动：
- en: 'Begin by including the following headers:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先包括以下头文件：
- en: '[PRE60]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Define the `Student` class as follows:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式定义`Student`类：
- en: '[PRE61]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The following function lets us generate a student from random data:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下函数让我们从随机数据生成一个学生：
- en: '[PRE62]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The following code is used to run and test the output of our implementation:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码用于运行和测试我们实现的输出：
- en: '[PRE63]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The following function implements our logic for whether a vaccination is needed:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下函数实现了我们是否需要接种疫苗的逻辑：
- en: '[PRE64]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Finally, the driver code is implemented as follows:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，驱动代码的实现如下：
- en: '[PRE65]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Since we are randomizing values in *step 3*, your output may vary from the expected
    output shown for this activity.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在*步骤3*中随机化值，因此您的输出可能与此活动所示的预期输出不同。
- en: 'Activity 9: Partial Sorting'
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动9：部分排序
- en: 'The partial quicksort is only a slight modification of the original quicksort
    algorithm that was demonstrated in *Exercise 20*, *Quicksort*. Compared to that
    exercise, only *step 4* is different. The following is a reference implementation:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 部分快速排序只是原始快速排序算法的轻微修改，该算法在*练习20*，*快速排序*中有所展示。与该练习相比，只有*步骤4*不同。以下是一个参考实现：
- en: 'Add the following header files:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下头文件：
- en: '[PRE66]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Next, we shall implement the partition operation, as follows:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将按照以下方式实现分区操作：
- en: '[PRE67]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Since the desired output also needs an implementation of the quicksort algorithm,
    we''ll implement one as follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于期望的输出还需要快速排序算法的实现，我们将按以下方式实现一个：
- en: '[PRE68]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Implement the partial quicksort function as follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式实现部分快速排序函数：
- en: '[PRE69]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The following helper functions can be then used to print the contents of a
    vector and to generate a random vector:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的辅助函数可以用来打印向量的内容和生成一个随机向量：
- en: '[PRE70]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The following function implements the testing logic for our sorting functions:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下函数实现了我们排序函数的测试逻辑：
- en: '[PRE71]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Finally, add the driver code, as follows:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，按照以下方式添加驱动代码：
- en: '[PRE72]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Activity 10: Implementing WordCount in MapReduce'
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动10：在MapReduce中实现WordCount
- en: 'In this activity, we will implement the MapReduce model to solve the WordCount
    problem. The following is the solution to this activity:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将实现MapReduce模型来解决WordCount问题。以下是这个活动的解决方案：
- en: 'Implement the map task as follows:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式实现映射任务：
- en: '[PRE73]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The preceding map function is applied separately to each file in the input directory.
    The contents of the input file are accepted as the `*` character in `value`. The
    inner loop then iterates over the contents of the file, extracting different words
    and emitting *< key, value >* pairs, where *key* is a word and *value* is set
    to *1*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的映射函数分别应用于输入目录中的每个文件。输入文件的内容被接受为`*`字符中的`value`。然后内部循环遍历文件的内容，提取不同的单词并发出*<
    key, value >*对，其中*key*是一个单词，*value*设置为*1*。
- en: 'Implement the reduce task as follows:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式实现减少任务：
- en: '[PRE74]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The reduce operation can then be applied to all < key, value > pairs that are
    emitted by the map function. Since the value was set to `1` in the previous step,
    we can now use `std::accumulate()` to get the total number of times a key appears
    among the input pairs of the reduce operation.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以将减少操作应用于映射函数发出的所有< key, value >对。由于在上一步中值被设置为`1`，我们现在可以使用`std::accumulate()`来获得减少操作的输入对中键出现的总次数。
- en: 'Chapter 5: Greedy Algorithms'
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5章：贪婪算法
- en: 'Activity 11: The Interval Scheduling Problem'
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动11：区间调度问题
- en: 'In this activity, we will find the optimal scheduling of tasks to maximize
    the number of tasks that can be completed. Follow these steps to complete the
    activity:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将找到任务的最佳调度，以最大化可以完成的任务数量。按照以下步骤完成这个活动：
- en: 'Add the required header files and define the `Task` struct as follows:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加所需的头文件并按以下方式定义`Task`结构：
- en: '[PRE75]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The following function can be used to generate a list of *N* tasks with random
    data:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下函数可用于生成具有随机数据的*N*个任务列表：
- en: '[PRE76]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Implement the scheduling algorithm as follows:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现调度算法如下：
- en: '[PRE77]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The following utility functions are used to print the list of tasks, test our
    implementation, and include the driver code for the program:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下实用函数用于打印任务列表，测试我们的实现，并包括程序的驱动代码：
- en: '[PRE78]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Activity 12: The Welsh-Powell Algorithm'
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动12：Welsh-Powell算法
- en: 'We will implement the Welsh-Powell algorithm on the graph in this activity.
    A reference implementation is given here:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个活动中实现Welsh-Powell算法。这里提供了一个参考实现：
- en: 'Add the required header files and declare the graph that will be implemented
    later:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加所需的头文件并声明稍后将实现的图：
- en: '[PRE79]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Implement the struct, representing edges like so:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现表示边的结构如下：
- en: '[PRE80]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The following function allows us to serialize and print graphs by overloading
    the `<<` operator for the graph datatype:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下函数允许我们通过重载图数据类型的`<<`运算符来序列化和打印图：
- en: '[PRE81]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Implement the graph with the edge list representation, as shown here:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现边缘列表表示的图，如下所示：
- en: '[PRE82]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Initialize the set of colors that we will use in our implementation of the
    Welsh-Powell algorithm. Let this number of colors be `6`, as implemented in the
    following `unordered_map`:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化我们将在Welsh-Powell算法实现中使用的颜色集。让颜色数为`6`，如下`unordered_map`中实现的那样：
- en: '[PRE83]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Implement the Welsh-Powell graph coloring algorithm like so:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现Welsh-Powell图着色算法如下：
- en: '[PRE84]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The following function outputs the vector of colors:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下函数输出颜色向量：
- en: '[PRE85]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Finally, the following driver code creates the required graph, runs the vertex
    coloring algorithm, and outputs the results:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，以下驱动代码创建所需的图，运行顶点着色算法，并输出结果：
- en: '[PRE86]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Chapter 6: Graph Algorithms I'
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6章：图算法I
- en: 'Activity 13: Finding out Whether a Graph is Bipartite Using DFS'
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动13：使用DFS找出图是否为二分图
- en: 'In this activity, we will check whether a graph is bipartite using depth-first
    search traversal. Follow these steps to complete the activity:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将使用深度优先搜索遍历来检查图是否是二分图。按照以下步骤完成活动：
- en: 'Add the required header files and declare the graph to be used:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加所需的头文件并声明要使用的图：
- en: '[PRE87]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Write the following struct to define an edge in our graph:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下结构以定义图中的边：
- en: '[PRE88]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Use the following function to overload the `<<` operator for the graph so that
    it can be written to standard output:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下函数重载图的`<<`运算符，以便将其写入标准输出：
- en: '[PRE89]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Implement the edge list graph as follows:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示实现边缘列表图：
- en: '[PRE90]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Create the graph shown in *figure 6.17*, as shown here:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建*图6.17*中显示的图，如下所示：
- en: '[PRE91]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now, we need a function so that we can implement our algorithm and check whether
    the graph is bipartite. Write the function like so:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要一个函数，以便我们可以实现我们的算法并检查图是否是二分图。编写以下函数：
- en: '[PRE92]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Use the following functions to implement the test and driver code that tests
    our implementation of the bipartite checking algorithm:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下函数来实现测试和驱动代码，测试我们对二分图检查算法的实现：
- en: '[PRE93]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Run the program. You should see the following output:![Figure 6.34: Output
    of Activity 13'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。您应该看到以下输出：![图6.34：活动13的输出
- en: '](img/C14498_06_34.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_06_34.jpg)'
- en: 'Figure 6.34: Output of Activity 13'
  id: totrans-240
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.34：活动13的输出
- en: 'Activity 14: Shortest Path in New York'
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动14：纽约的最短路径
- en: 'In this activity, we will use the graph of various locations in New York City
    and find the shortest distance between the two given vertices. Follow these steps
    to complete the activity:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将使用纽约市各个地点的图，并找到两个给定顶点之间的最短距离。按照以下步骤完成活动：
- en: 'Add the required header files and declare the graph, as shown here:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加所需的头文件并声明图，如下所示：
- en: '[PRE94]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Implement the weighted edge that will be used in the graph:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现将在图中使用的加权边：
- en: '[PRE95]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Overload the `<<` operator for the `Graph` class so that it can be output to
    the C++ streams:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重载`Graph`类的`<<`运算符，以便将其输出到C++流中：
- en: '[PRE96]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Implement an edge list graph, as shown here:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现边缘列表图，如下所示：
- en: '[PRE97]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Write the following function so that you can parse the graph file and prepare
    the graph:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下函数，以便您可以解析图文件并准备图：
- en: '[PRE98]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Now, we need a struct that implements a `Label` struct that will be assigned
    to each vertex as Dijkstra''s algorithm runs. Implement it as follows:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要一个实现`Label`结构的结构，该结构将分配给Dijkstra算法运行时的每个顶点。实现如下：
- en: '[PRE99]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Dijkstra''s algorithm can be implemented as follows:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Dijkstra算法可以实现如下：
- en: '[PRE100]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Finally, implement the test and driver code, as shown here:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，实现测试和驱动代码，如下所示：
- en: '[PRE101]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Run the program. Your output should look as follows:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。您的输出应如下所示：
- en: '![Figure 6.35: Output of Activity 14'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.35：活动14的输出'
- en: '](img/C14498_06_35.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_06_35.jpg)'
- en: 'Figure 6.35: Output of Activity 14'
  id: totrans-262
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.35：活动14的输出
- en: 'Chapter 7: Graph Algorithms II'
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章：图算法II
- en: 'Activity 15: Greedy Robot'
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动15：贪婪机器人
- en: 'We can solve this activity using the exact algorithm from *Exercise 33*, *Implementing
    the Bellman-Ford Algorithm (Part II)*. The potential pitfalls here are related
    to correctly interpreting the required task and representing the graph within
    the context of the problem you are actually trying to solve. Let''s get started:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用*练习33*中的确切算法来解决这个活动，*实现贝尔曼-福特算法（第二部分）*。这里潜在的陷阱与正确解释所需任务和在实际尝试解决的问题的上下文中表示图有关。让我们开始吧：
- en: 'The first step will be identical to the exercise. We will include the same
    headers and define an `Edge` struct and an `UNKNOWN` constant:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步将与练习相同。我们将包括相同的头文件并定义一个`Edge`结构和一个`UNKNOWN`常量：
- en: '[PRE102]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'In `main()`, we will declare an integer, `N`, which determines the height/width
    of the grid. We will then iterate from 0 to N * N - 1 in a `for` loop and read
    the adjacency data given in the input:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`中，我们将声明一个整数`N`，它确定网格的高度/宽度。然后我们将在`for`循环中从0到N * N - 1进行迭代，并读取输入中给定的邻接数据：
- en: '[PRE103]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Now, we must face the first potential problem – accurately representing the
    adjacencies. Typically, we would be inclined to think of a grid in two dimensions,
    and while it would certainly be possible to solve the problem this way, it would
    not be the optimal approach for this particular problem. To reinterpret the grid
    and adjacencies in one dimension, we must simply observe the following relationships
    between the one-dimensional index, `i`, and the corresponding two-dimensional
    grid coordinates:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须面对第一个潜在的问题——准确表示邻接关系。通常，我们会倾向于将二维网格表示为一个网格，虽然这种方式当然可以解决问题，但对于这个特定的问题来说并不是最佳的方法。为了重新解释一维中的网格和邻接关系，我们只需观察一维索引`i`与相应的二维网格坐标之间的关系：
- en: '[PRE104]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'We can handle these relationships by iterating through the characters of `directions`
    and containing the logic within a `switch` statement:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过迭代`directions`的字符并在`switch`语句中包含逻辑来处理这些关系：
- en: '[PRE105]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'This leads to the second problematic aspect of this activity; that is, the
    interpretation of the `power` values. These, of course, will be the values that
    define the edge weights between adjacent cells, but within the context of this
    problem, the inputs can be rather misleading. According to the problem''s description,
    we want to find the path that reaches the end with the maximum amount of energy
    compared to the baseline. A careless reading of the problem statement may lead
    us to conclude that the `power` values correspond exactly to the edge weights,
    but this would actually produce the opposite of what we intend to achieve. "Maximizing
    energy" can be viewed as the equivalent to "minimizing energy loss," and since
    the negative values actually represent the energy expenditure for each cell and
    the positive values represent energy gained, we must reverse the sign of each
    `power` value:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这导致了这个活动的第二个问题方面；即`power`值的解释。当然，这些值将是定义相邻单元格之间边权重的值，但在这个问题的背景下，输入可能会相当误导。根据问题的描述，我们希望找到达到最大能量的路径与基线相比。对问题陈述的粗心阅读可能会导致我们得出`power`值确切对应边权重的结论，但这实际上会产生与我们意图相反的结果。"最大化能量"可以被视为等同于"最小化能量损失"，由于负值实际上代表每个单元格的能量消耗，正值代表获得的能量，我们必须颠倒每个`power`值的符号：
- en: '[PRE106]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Now, we can implement `BellmanFord()`. This time, our function will take `N`
    and `edges` as arguments and return an integer equal to the maximum relative energy.
    To simplify our code, we will pass `N` as the total number of cells in the grid
    (that is, `N * N`):'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以实现`BellmanFord()`。这次，我们的函数将以`N`和`edges`作为参数，并返回一个等于最大相对能量的整数。为了简化我们的代码，我们将`N`作为网格中单元格的总数传递（即`N
    * N`）：
- en: '[PRE107]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'As per the standard implementation, we will also perform a check for negative
    cycles to handle the condition related to the robot''s greedy energy consumption.
    In the case that a negative cycle is found, we will return `UNKNOWN`:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据标准实现，我们还将检查负循环以处理与机器人贪婪能量消耗相关的条件。如果找到负循环，我们将返回`UNKNOWN`：
- en: '[PRE108]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Now, we can perform a call to `BellmanFord()` in `main()` and handle the output
    accordingly:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在`main()`中调用`BellmanFord()`并相应地处理输出：
- en: '[PRE109]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Activity 16: Randomized Graph Statistics'
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动16：随机图形统计
- en: 'In this activity, we will generate randomized graphs for interview tests as
    described in the activity brief. Follow these steps to complete the activity:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将按照活动简介中描述的方式生成随机图形进行面试测试。按照以下步骤完成活动：
- en: 'Begin by including the following headers, as well as defining the `UNKNOWN`
    constant and the `Edge` struct:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先包括以下标头，并定义`UNKNOWN`常量和`Edge`结构：
- en: '[PRE110]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Our first task is to handle the generation of each graph. For this activity,
    we will encapsulate our graph data within a struct:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的第一个任务是处理每个图的生成。对于这个活动，我们将在一个结构体中封装我们的图形数据：
- en: '[PRE111]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'To make sure that the generated edges and the resulting graph are valid, we
    will create an adjacency matrix and check it during every attempt to create another
    edge. If an edge between the same two nodes already exists, we will begin another
    iteration. To make sure that every node has at least one incoming or outgoing
    edge, we will also set the diagonal cells in the matrix to true for each node
    that is part of an edge. If any of the diagonal cells are false after `E` edges
    are created, the graph will be invalid. We can indicate a graph as invalid by
    setting `V` to `-1`:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保生成的边和生成的图是有效的，我们将创建一个邻接矩阵，并在每次尝试创建另一个边时进行检查。如果两个节点之间已经存在一条边，我们将开始另一个迭代。为了确保每个节点至少有一个入边或出边，我们还将为矩阵中的对角线单元格设置每个节点的值为true。如果在创建`E`条边后，任何对角线单元格为false，则图将无效。我们可以通过将`V`设置为`-1`来表示图无效：
- en: '[PRE112]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Let''s also define an enum called `RESULT` with the corresponding values for
    each type of graph we need to consider:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们还定义一个名为`RESULT`的枚举，其中包含我们需要考虑的每种图形的相应值：
- en: '[PRE113]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'In `main()`, we will receive the input, as well as declare the counters for
    each type of graph. We will then loop through the given number of iterations,
    create a new graph, and call a `TestGraph()` function that takes a `Graph` object
    as input and returns `RESULT`. Depending on the value that''s returned, we will
    increment each counter accordingly:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`中，我们将接收输入，并声明每种图形的计数器。然后，我们将循环给定的迭代次数，创建一个新图形，并调用一个以`Graph`对象为输入并返回`RESULT`的`TestGraph()`函数。根据返回的值，我们将相应地递增每个计数器：
- en: '[PRE114]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '`TestGraph()` will first check whether the value of `V` for each graph is equal
    to `-1` and return `INVALID` if so. Otherwise, it will perform Johnson''s algorithm
    to retrieve the shortest distances. The first step will be to retrieve the reweighting
    array using the Bellman-Ford algorithm:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TestGraph()`首先会检查每个图的`V`值是否等于`-1`，如果是，则返回`INVALID`。否则，它将执行Johnson算法来检索最短距离。第一步是使用Bellman-Ford算法检索重新加权数组：'
- en: '[PRE115]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The implementation of Bellman-Ford that''s used in this solution corresponds
    exactly to the one from the exercise, except that it receives a single `Graph`
    structure as an argument:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个解决方案中使用的Bellman-Ford的实现与练习中的实现完全相同，只是它接收一个`Graph`结构作为参数：
- en: '[PRE116]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'As we did in the exercise, we will check whether the vector that''s returned
    by `BellmanFord()` is empty. If so, we return `VALID` (the graph is valid but
    uninteresting). Otherwise, we will follow through with the rest of Johnson''s
    algorithm by reweighting the edges and performing a call to Dijkstra''s algorithm
    for each vertex:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与练习中一样，我们将检查`BellmanFord()`返回的向量是否为空。如果是，我们返回`VALID`（图是有效的但无趣的）。否则，我们将通过重新加权边缘并为每个顶点执行Dijkstra算法来跟随约翰逊算法的其余部分：
- en: '[PRE117]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'For this solution, let''s use a more efficient form of Dijkstra''s algorithm,
    which uses a min-priority queue to determine traversal order. To do this, each
    value that''s added to the queue must consist of two values: the node''s index
    and its distance value. We will do this using `std::pair<int, int>`, which has
    been redefined here as `State`. When pushing elements to the queue, the first
    value must correspond to the distance since this is going to be the first value
    that''s considered by the priority queue''s internal ordering logic. All of this
    can be handled by `std::priority_queue`, but we will need to provide three template
    parameters corresponding to the data type, container, and comparison predicate,
    respectively:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个解决方案，让我们使用更高效的Dijkstra算法形式，它使用最小优先队列来确定遍历顺序。为了做到这一点，添加到队列中的每个值必须由两个值组成：节点的索引和其距离值。我们将使用`std::pair<int,
    int>`来实现这一点，这里已经重新定义为`State`。当将元素推送到队列时，第一个值必须对应于距离，因为这将是优先队列内部排序逻辑考虑的第一个值。所有这些都可以由`std::priority_queue`处理，但我们需要提供三个模板参数，分别对应于数据类型、容器和比较谓词：
- en: '[PRE118]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Now, we will calculate the averages in `TestGraph()` for each set of paths.
    We do this by iterating through the array returned by `Dijkstra()` and keeping
    a sum of distances for which the index is not equal to the starting node''s index.
    The corresponding value is not equal to `UNKNOWN`. Every time a valid distance
    is found, a counter is also incremented so that we can get the final average by
    dividing the sum by the count. Each one of these averages is then added to the
    total result, which is divided by the total number of vertices in the graph. Remember
    that we must reweight the distances again to get the correct values:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将计算`TestGraph()`中每组路径的平均值。我们通过迭代`Dijkstra()`返回的数组，并保持距离的总和，其中索引不等于起始节点的索引。相应的值不等于`UNKNOWN`。每次找到有效距离时，计数器也会递增，以便我们可以通过将总和除以计数来获得最终平均值。然后将这些平均值中的每一个添加到总结果中，然后将其除以图中顶点的总数。记住，我们必须重新加权距离，以获得正确的值：
- en: '[PRE119]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The last step is to calculate the ratio between the result and the maximum
    weight in the graph. If the value is less than `0.5`, we return `INTERESTING`;
    otherwise, we return `VALID`:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是计算结果与图中最大权重之间的比率。如果值小于`0.5`，我们返回`INTERESTING`；否则，我们返回`VALID`。
- en: '[PRE120]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'We can now return to `main()` and print the output. The first line will be
    equal to the value of `invalid`. The second line will be equal to `interesting
    / valid`, multiplied by `100`, so that it will be displayed as a percentage. Depending
    on how you do this, you may have to cast your variables as floating points to
    prevent the value from being rounded to an integer. When printing the output,
    you can easily make sure it is rounded to two decimal places by using `cout <<
    fixed << setprecision(2)`:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以返回`main()`并打印输出。第一行将等于`invalid`的值。第二行将等于`interesting / valid`，乘以`100`，以便显示为百分比。根据您的操作方式，您可能需要将变量转换为浮点数，以防止值被四舍五入为整数。在打印输出时，您可以通过使用`cout
    << fixed << setprecision(2)`轻松确保它四舍五入到两位小数：
- en: '[PRE121]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Activity 17: Maze-Teleportation Game'
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动17：迷宫传送游戏
- en: The entire activity conforms fairly closely to the standard implementations
    of the algorithms we've discussed in this chapter, but with a few slight modifications.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 整个活动与本章讨论的算法的标准实现非常接近，但有一些细微的修改。
- en: 'The terms that were used in the problem description, that is, *maze*, *rooms*,
    *teleporters*, and *points* could, of course, just as easily have been called
    *graph*, *vertices*, *edges*, and *edge weights*. The condition in which a player
    is able to infinitely reduce their score can be redefined as a *negative weight
    cycle*. Follow these steps to complete the activity:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在问题描述中使用的术语，即*maze*、*rooms*、*teleporters*和*points*，当然也可以被称为*graph*、*vertices*、*edges*和*edge
    weights*。玩家能够无限减少他们的分数的条件可以被重新定义为*负权重循环*。按照以下步骤完成活动：
- en: 'Let''s begin by including the necessary headers and setting up the variables
    and input for the activity:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先包括必要的头文件，并设置变量和输入以进行活动：
- en: '[PRE122]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'We will receive input in the same form as our original Bellman-Ford implementation,
    but we will also build an adjacency list for our graph (represented here as a
    vector of integer vectors, `adj`):'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将以与我们原始的Bellman-Ford实现相同的形式接收输入，但我们还将为我们的图构建一个邻接表（在这里表示为整数向量的向量，`adj`）：
- en: '[PRE123]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'The first portion of the problem can be solved by using Bellman-Ford in an
    identical fashion to what was outlined in *Exercise 32*, *Implementing the Bellman-Ford
    Algorithm (Part I)*. However, instead of printing all the values in the distance
    array, we will set its return type to `int` and include a few extra lines of code
    so that it returns only the shortest distance from the source vertex (or `UNKNOWN`
    if a negative cycle is detected):'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 问题的第一部分可以通过使用Bellman-Ford以与*练习32*中概述的完全相同的方式来解决。但是，我们将其返回类型设置为`int`，并包括一些额外的代码行，以便它仅返回从源顶点到最短距离（或如果检测到负循环，则返回`UNKNOWN`）：
- en: '[PRE124]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'We can now call this function in `main()` and populate a results vector for
    output. If `BellmanFord()` happens to return `UNKNOWN`, we output `INVALID MAZE`
    and terminate the program (as per the first condition). If a certain starting
    node has no outgoing edges, we can skip the call to `BellmanFord` entirely and
    simply append `UNKNOWN` to the vector. If we make it through every vertex, we
    can output the values in the results (or `DEAD END` if the value is `UNKNOWN`):'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以在`main()`中调用这个函数，并为输出填充一个结果向量。如果`BellmanFord()`返回`UNKNOWN`，我们输出`INVALID
    MAZE`并终止程序（根据第一个条件）。如果某个起始节点没有出边，我们可以完全跳过对`BellmanFord`的调用，并简单地将`UNKNOWN`附加到向量中。如果我们通过了每个顶点，我们可以输出结果中的值（或者如果值是`UNKNOWN`，则输出`DEAD
    END`）：
- en: '[PRE125]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Now, we''ve come to the final condition – finding rooms in which players can
    get "stuck." Considering this case in terms of graph connectivity, we can redefine
    it as follows: find the strongly connected components that have no outgoing edges
    to other components. There are many simple ways to do this once all the strongly
    connected components have been acquired, but let''s try to maximize our program''s
    efficiency and add the necessary logic directly into our existing Kosaraju implementation.'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们来到了最后一个条件——找到玩家可能会“卡住”的房间。从图的连通性角度考虑这种情况，我们可以重新定义它如下：找到没有出边通往其他组件的强连通分量。一旦获得了所有强连通分量，就有许多简单的方法来做到这一点，但让我们尝试最大化我们程序的效率，并直接将必要的逻辑添加到我们现有的Kosaraju实现中。
- en: 'To accomplish this, we will declare two new vectors: one of type `bool`, named
    `isStuck` and another of type `int`, named `inComponent`. `inComponent` will store
    the index of the component each node belongs to, while `isStuck` will tell us
    whether or not the component with index `i` is cut off from the rest of the graph.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将声明两个新向量：一个名为`isStuck`的`bool`类型，另一个名为`inComponent`的`int`类型。`inComponent`将存储每个节点所属的组件的索引，而`isStuck`将告诉我们组件索引`i`的组件是否与图的其余部分隔离。
- en: 'For the sake of simplicity, let''s declare the new variables globally:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，让我们在全局声明新变量：
- en: '[PRE126]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Here, we can really begin to appreciate the benefits of encapsulation and object-oriented
    implementations of graph structures. Having to pass such a large amount of data
    between our functions is not only difficult to keep track of mentally, but it
    greatly complicates any kind of modifications we may want to make in the future
    (to say nothing about the headache-inducing appearance of a function call such
    as `GetComponent(node, adj, visited, component, isStuck, inComponent, componentIndex)`.
    For the sake of example and readability, we opt to declare this data globally,
    but this sort of approach is highly recommended against within the context of
    an actual full-scale application.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们真的可以开始欣赏封装和面向对象的图结构实现的好处。在我们的函数之间传递如此大量的数据不仅在心理上难以跟踪，而且大大复杂化了我们可能希望在将来进行的任何修改（更不用说像`GetComponent(node,
    adj, visited, component, isStuck, inComponent, componentIndex)`这样的函数调用看起来令人头疼）。出于示例和可读性的考虑，我们选择在全局声明这些数据，但在实际的大型应用程序环境中，强烈建议不要采用这种方法。
- en: 'Within our `Kosaraju` function, we initialize the new data as follows:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`Kosaraju`函数中，我们初始化新数据如下：
- en: '[PRE127]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Now, we will begin our `while` loop, incrementing `componentIndex` by following
    each DFS traversal that''s performed on the stack:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将开始我们的`while`循环，通过在栈上执行每次DFS遍历来递增`componentIndex`：
- en: '[PRE128]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Now, we can write the logic in `GetComponent()`, which will handle this case.
    We will begin by setting the value of each node''s index in `inComponent` to `componentIndex`.
    Now, as we iterate through each node''s neighbors, we will include another condition
    that occurs when the nodes have already been visited:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在`GetComponent()`中编写处理这种情况的逻辑。我们将从将每个节点的索引值设置为`componentIndex`开始。现在，当我们遍历每个节点的邻居时，我们将包括另一个条件，即当节点已经被访问时发生：
- en: '[PRE129]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Essentially, we are checking to see whether each previously visited neighbor's
    component matches the current node's component. If their respective component
    IDs are different, we can conclude that the neighbor's component has a path that
    extends to other parts of the graph.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们正在检查每个先前访问的邻居的组件是否与当前节点的组件匹配。如果它们各自的组件ID不同，我们可以得出结论，即邻居的组件具有延伸到图的其他部分的路径。
- en: You may be wondering why, in a directed graph, the existence of an edge from
    the current node indicates that the neighboring node has an outgoing path outside
    of its own component. The reason this logic seems 'backward' is because it is.
    Remember that we are traversing the transform of the original graph, so the directions
    between adjacencies are all reversed!
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么在有向图中，当前节点存在一条边意味着相邻节点具有通往其自身组件之外的出边。这种逻辑之所以看起来“反向”，是因为它确实如此。请记住，我们正在遍历原始图的转置，因此邻接之间的方向都是相反的！
- en: 'Upon finishing the DFS traversals, we can now return the `components` vector
    and print the results:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成DFS遍历后，我们现在可以返回`components`向量并打印结果：
- en: '[PRE130]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Chapter 8: Dynamic Programming I'
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8章：动态规划I
- en: 'Activity 18: Travel Itinerary'
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动18：旅行行程
- en: 'Let''s begin by considering the base case and recurrence relation for this
    problem. Unlike some of the other examples we have discussed in this chapter,
    this particular problem has just one base case – the point at which the destination
    has been reached. The intermediate states are also quite simple: given a location
    at index `i` that has a distance limit of `x`, we can travel to any location between
    indices `i + 1` and `i + x` (inclusive). For example, let''s consider the following
    two cities:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先考虑这个问题的基本情况和递归关系。与本章讨论过的其他一些例子不同，这个特定的问题只有一个基本情况——到达目的地的点。中间状态也很简单：给定一个具有距离限制`x`的索引`i`的位置，我们可以前往索引`i
    + 1`和`i + x`（包括）之间的任何位置。例如，让我们考虑以下两个城市：
- en: 'City 1: `distance[1] = 2`'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 城市1：`distance[1] = 2`
- en: 'City 2: `distance[2] = 1`'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 城市2：`distance[2] = 1`
- en: Let's say we wanted to calculate the number of ways to reach the city at index
    `3`. Because we can reach *city 3* from both *city 1* and *city 2*, the number
    of ways to reach *city 3* is equivalent to the sum of the number of ways to reach
    city 1 and the number of ways to reach *city 2*. This recurrence is quite similar
    to the Fibonacci series, except that the number of previous states from which
    the current state's substructure is formed is variable according to the values
    of `distance`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要计算到达索引为`3`的城市的方式数量。因为我们可以从*城市1*和*城市2*到达*城市3*，所以到达*城市3*的方式数量等于到达城市1的方式数量和到达*城市2*的方式数量的总和。这种递归与斐波那契数列非常相似，只是当前状态的子结构形成的前一个状态的数量根据`distance`的值是可变的。
- en: 'So, let''s say we have the following four cities:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，假设我们有以下四个城市：
- en: '[PRE131]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'From this, we want to calculate the number of ways to travel to city 5\. To
    do this, we can formulate the substructure as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们想计算到达城市5的方式数量。为此，我们可以将子结构公式化如下：
- en: '[PRE132]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'We can now invert this logic to find the cities *from* which we can travel
    through to reach a given location:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以反转这种逻辑，找到我们可以通过旅行到达给定位置的城市：
- en: '[PRE133]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Taking this a step further, we can now devise an outline of the state logic:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 更进一步，我们现在可以设计状态逻辑的大纲：
- en: '[PRE134]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Thus, we can define the recurrence as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将递归定义如下：
- en: 'Base case:'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本情况：
- en: '*F(1) = 1* (We have reached the destination)'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '*F(1) = 1*（我们已经到达目的地）'
- en: 'Recurrence:'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归：
- en: '![Figure 8.22: Formula for defining recurrence](img/C14498_08_22.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![图8.22：定义递归的公式](img/C14498_08_22.jpg)'
- en: 'Figure 8.22: Formula for defining recurrence'
  id: totrans-353
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.22：定义递归的公式
- en: 'In other words, the number of ways to reach a given location is equal to the
    sum of the number of ways to reach each location that connects to it. Using this
    logic, a recursive function for solving this problem might look like this:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，到达给定位置的方式数量等于到达连接到它的每个位置的方式数量的总和。使用这种逻辑，解决这个问题的递归函数可能看起来像这样：
- en: '[PRE135]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Now that we have a functional definition of the problem's states, let's begin
    implementing it in code.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了问题状态的功能性定义，让我们开始在代码中实现它。
- en: 'For this problem, we will include the following headers and the `std` namespace:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个问题，我们将包括以下头文件和`std`命名空间：
- en: '[PRE136]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Because the outputs of this problem require the computation of numbers that
    exceed 32 bits, we will use `long long int` for the result. To avoid having to
    write this repeatedly, we will use a `typedef` statement to abbreviate it:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为这个问题的输出需要计算超过32位的数字，我们将使用`long long int`作为结果。为了避免重复编写这个，我们将使用`typedef`语句来缩写它：
- en: '[PRE137]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Finally, we will define the modulus value for outputting the results:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将定义输出结果的模数值：
- en: '[PRE138]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Handling the input and output in this problem can be implemented very simply:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中处理输入和输出可以非常简单地实现：
- en: '[PRE139]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'We will now define a function called `TravelItinerary()` that takes `n` and
    `distance` as arguments and returns a long integer:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将定义一个名为`TravelItinerary()`的函数，它以`n`和`distance`作为参数，并返回一个长整数：
- en: '[PRE140]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Now, we must convert the recursive algorithm we presented earlier into a bottom-up
    approach. In pseudocode, this might appear as follows:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须将我们之前提出的递归算法转换为自底向上的方法。在伪代码中，这可能如下所示：
- en: '[PRE141]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'To code this in C++, we will first declare a one-dimensional DP table of size
    `n + 1` and initialize all of its elements to `0`. Then, we will set its first
    element to `1` to represent the base case:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在C++中编写这个代码，我们将首先声明一个大小为`n + 1`的一维DP表，并将其所有元素初始化为`0`。然后，我们将将其第一个元素设置为`1`，以表示基本情况：
- en: '[PRE142]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'To implement the recurrence we described previously, we will first reverse
    the distance array so that we are essentially beginning our calculations from
    the destination index. There are several reasons for this, but the primary reason
    is so that our algorithm processes the current state by combining the results
    of earlier states, as opposed to calculating future states from the results of
    the current state. Though the logic described in the pseudocode will produce the
    correct result, it is generally preferable to formulate bottom-up logic in terms
    of how the solutions of the previous states form the result of the immediate state:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了实现我们之前描述的递归，我们将首先反转距离数组，这样我们基本上是从目的地索引开始计算。这样做有几个原因，但主要原因是我们的算法处理当前状态，通过组合先前状态的结果，而不是根据当前状态的结果计算未来状态。虽然伪代码中描述的逻辑会产生正确的结果，但通常更倾向于以底向上的逻辑来表述前一个状态的解如何形成立即状态的结果：
- en: '[PRE143]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: This is certainly a viable solution to the problem that will be completely satisfactory
    in the vast majority of cases. However, since dynamic programming is first and
    foremost an optimization technique, we should still ask ourselves if a better
    approach exists.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然是问题的一个可行解决方案，在绝大多数情况下都会完全令人满意。然而，由于动态规划首先是一种优化技术，我们仍然应该问自己是否存在更好的方法。
- en: '`n` and the maximum `distance` value increase, even the preceding algorithm
    will eventually prove to be rather inefficient. If `n = 10000000` and the distance
    values can vary between 1 and 10000, then the inner `for` loop would have to perform
    nearly 100000000000 iterations in the worst case. Thankfully, there is a very
    simple technique that will allow us to completely remove the inner loop, which
    means we will have to perform exactly `n` iterations for any input.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`n`和最大`distance`值增加，即使先前的算法最终也会变得相当低效。如果`n = 10000000`，距离值可以在1到10000之间变化，那么内部`for`循环在最坏的情况下将不得不执行近100000000000次迭代。幸运的是，有一种非常简单的技术可以完全消除内部循环，这意味着我们对任何输入都只需要执行`n`次迭代。'
- en: 'To handle this reduction, we will create a `prefix sum array`, which will allow
    us to calculate the range sums we previously handled by the inner loop in constant
    time. If you are unfamiliar with this technique, the basic concept is as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这种缩减，我们将创建一个`前缀和数组`，这将允许我们以常数时间计算我们之前通过内循环处理的范围和。如果您对这种技术不熟悉，基本概念如下：
- en: Create an array called `sums` that has a length equal to the total number of
    values to sum plus one, with all the elements initialized to `0`.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`sums`的数组，其长度等于要求和的值的总数加一，所有元素都初始化为`0`。
- en: For each index `i` from `0` to `n`, use `sum[i + 1] = sum[i] + distance[i]`.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个从`0`到`n`的索引`i`，使用`sum[i + 1] = sum[i] + distance[i]`。
- en: After the sums have been calculated, the sum of all elements in any range `[L,
    R]` will be equal to `sum[R+1] – sum[L]`.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在计算出和之后，任何范围`[L，R]`内所有元素的和将等于`sum[R+1] – sum[L]`。
- en: 'Take a look at the following example:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 看下面的例子：
- en: '[PRE144]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'We can implement this approach in our function as follows:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在我们的函数中实现这种方法如下：
- en: '[PRE145]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Now, there is still one more problem that you are likely to encounter, and
    that is that the result returned by the preceding function will be negative. This
    is due to the fact that the modulo operations are causing higher-indexed values
    in `sums` to be less than lower-indexed values, which leads to a negative result
    when subtracting. This sort of issue can be very common in problems requiring
    frequent modulo operations on very large numbers, but can be easily fixed by modifying
    the return statement slightly:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可能会遇到另一个问题，那就是前面函数返回的结果可能是负数。这是因为模运算导致`sums`中的高索引值小于低索引值，这导致减法结果为负数。在需要频繁对非常大的数字进行模运算的问题中，这种问题可能非常常见，但可以通过稍微修改返回语句来轻松解决：
- en: '[PRE146]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: With these slight modifications, we now have an elegant and efficient solution
    to the problem that can handle massive input arrays in a fraction of a second!
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些轻微的修改，我们现在有了一个优雅而高效的解决方案，可以在几秒钟内处理大量输入数组！
- en: 'Activity 19: Finding the Longest Common Subsequence by Using Memoization'
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动19：使用记忆化找到最长公共子序列
- en: 'As we did with the subset sum problem, we will include each new approach within
    the same code file so that we can compare their relative performance. To that
    end, let''s define our `GetTime()` function in the same way as before:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与子集和问题一样，我们将在同一个代码文件中包含每种新方法，以便比较它们的相对性能。为此，让我们以与之前相同的方式定义我们的`GetTime()`函数：
- en: '[PRE147]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Now, let''s define our new function, `LCS_Memoization()`, which will take the
    same arguments as `LCS_BruteForce()`, except that `subsequence` will instead be
    replaced by a reference to a two-dimensional integer vector, `memo`:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义我们的新函数`LCS_Memoization()`，它将接受与`LCS_BruteForce()`相同的参数，只是`subsequence`将被替换为对二维整数向量`memo`的引用：
- en: '[PRE148]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Our code for this function will also be quite similar to `LCS_BruteForce()`,
    except we will invert the logic by recursively traversing the prefixes of the
    two strings (beginning with the complete strings) and storing the results in our
    `memo` table at each step:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的这个函数的代码也将与`LCS_BruteForce()`非常相似，只是我们将通过递归遍历两个字符串的前缀（从完整字符串开始）并在每一步将结果存储在我们的`memo`表中来颠倒逻辑：
- en: '[PRE149]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Now, let''s redefine our `main()` function to perform both approaches and display
    the time taken by each:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们重新定义我们的`main()`函数，执行两种方法并显示每种方法所花费的时间：
- en: '[PRE150]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Now, let''s try performing our two algorithms on two new strings, `ABCABDBEFBA`
    and `ABCBEFBEAB`. Your program''s output should be similar to the following:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试在两个新字符串“ABCABDBEFBA”和“ABCBEFBEAB”上执行我们的两种算法。你的程序输出应该类似于以下内容：
- en: '[PRE151]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Of course, the time taken by the brute-force approach is going to be affected
    by the additional step of printing out the subsequences. By running our code again
    after setting the `DEBUG` constant to `0`, the output is now as follows:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，蛮力方法所花费的时间将受到打印子序列的额外步骤的影响。将`DEBUG`常量设置为`0`后再次运行我们的代码，输出现在如下所示：
- en: '[PRE152]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Now, let''s try pushing the limits of our algorithm using two much larger strings,
    `ABZCYDABAZADAEA` and `YABAZADBBEAAECYACAZ`. You should get an output something
    like this:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试推动我们的算法极限，使用两个更大的字符串“ABZCYDABAZADAEA”和“YABAZADBBEAAECYACAZ”。你应该得到类似于以下的输出：
- en: '[PRE153]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Note
  id: totrans-401
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The actual values for the time taken will vary depending on your system. Please
    note the difference in the values.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的时间值将根据您的系统而有所不同。请注意数值上的差异。
- en: As we can clearly see, the gains in performance provided by memoization are
    quite significant!
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可以清楚地看到的那样，记忆化提供的性能增益非常显著！
- en: 'Activity 20: Finding the Longest Common Subsequence Using Tabulation'
  id: totrans-404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动20：使用制表法找到最长公共子序列
- en: As we did previously, we will add a new function, `LCS_Tabulation()`, to the
    same code file that contains our brute-force and memoized solutions.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，我们将在包含蛮力和记忆化解决方案的同一代码文件中添加一个新函数`LCS_Tabulation()`。
- en: 'Our `LCS_Tabulation()` function receives two arguments— strings `A` and `B`
    — and returns a string:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`LCS_Tabulation()`函数接收两个参数——字符串`A`和`B`——并返回一个字符串：
- en: '[PRE154]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Our first step is to define our DP table, which we will represent as a two-dimensional
    vector of integers, with the first dimension''s size equal to one greater than
    the size of string `A`, and the second dimension''s size equal to one greater
    than the size of string `B`:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的第一步是定义DP表，我们将其表示为一个整数的二维向量，第一维的大小等于字符串`A`的大小加一，第二维的大小等于字符串`B`的大小加一：
- en: '[PRE155]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Like the subset sum problem, all of our algorithm''s logic can be contained
    within two nested loops, with the first one iterating from `0` to the size of
    `A`, and the second iterating from `0` to the size of `B`:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与子集和问题一样，我们算法的所有逻辑都可以包含在两个嵌套循环中，第一个循环从`0`到`A`的大小，第二个循环从`0`到`B`的大小：
- en: '[PRE156]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Unlike the subset sum problem, our base case will not be handled prior to the
    execution of the loops, but rather at the beginning of each loop. This is because
    our base case will occur any time the prefix of `A` or `B` is empty (that is,
    `i = 0` or `j = 0`). This is represented in our code as follows:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与子集和问题不同，我们的基本情况不会在循环执行之前处理，而是在每个循环开始时处理。这是因为我们的基本情况将在任何时候发生，即`A`或`B`的前缀为空（即`i
    = 0`或`j = 0`）。在我们的代码中表示如下：
- en: '[PRE157]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Now, we must handle the case where the characters at the end of *A*''s prefix
    and *B*''s prefix are equal. Remember that the LCS value for this state is always
    equal to `1`, plus the LCS value of the state where both prefixes are one character
    smaller than they are currently. This can be represented as follows:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须处理*A*前缀和*B*前缀末尾的字符相等的情况。请记住，这种状态的LCS值总是等于`1`，加上两个前缀比它们当前小一个字符的状态的LCS值。这可以表示如下：
- en: '[PRE158]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'For the final case, the end characters are *not* equal. For this state, we
    know that the LCS is equal to the maximum of the LCS of *A*''s previous prefix
    and *B*''s current prefix, and the LCS of B''s previous prefix and A''s current
    prefix. In terms of our table''s structure, this is equivalent to saying that
    the LCS is equal to the maximum of the value contained in the same column and
    previous row of the table, and the value contained in the same row and previous
    column:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于最后一种情况，结束字符*不*相等。对于这种状态，我们知道LCS等于*A*的前缀的LCS和*B*的当前前缀的最大值，以及B的前缀的LCS和A的当前前缀的最大值。就我们表的结构而言，这相当于说LCS等于表中相同列和前一行的值的最大值，以及表中相同行和前一列的值：
- en: '[PRE159]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'When we are done, the length of the longest common subsequence will be contained
    in `DP[A.size()][B.size()]` – the value of the LCS when the prefixes of both `A`
    and `B` are equal to the entire strings. Therefore, our complete DP logic is written
    as follows:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们完成时，最长公共子序列的长度将包含在`DP[A.size()][B.size()]`中 —— 当`A`和`B`的前缀等于整个字符串时的LCS的值。因此，我们完整的DP逻辑写成如下：
- en: '[PRE160]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'At this point, we have discussed several ways to find the length of the longest
    common subsequence, but what if we also want to output its actual characters?
    Of course, our brute-force solution does this, but very inefficiently; however,
    using the results contained in the preceding DP table, we can use backtracking
    to reconstruct the LCS quite easily. Let''s highlight the path we would need to
    follow in the table to accomplish this:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了几种找到最长公共子序列长度的方法，但如果我们还想输出其实际字符呢？当然，我们的蛮力解决方案可以做到这一点，但效率非常低；然而，使用前面DP表中包含的结果，我们可以使用回溯来相当容易地重建LCS。让我们突出显示我们需要在表中遵循的路径：
- en: '![Figure 8.23: Activity 20 DP table'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.23：活动20 DP表'
- en: '](img/C14498_08_23.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_08_23.jpg)'
- en: 'Figure 8.23: Activity 20 DP table'
  id: totrans-423
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.23：活动20 DP表
- en: By collecting the characters associated with each column in the path where the
    value increases, we get the LCS `ABCBEFBA`.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 通过收集与路径中值增加相关的每列的字符，我们得到LCS `ABCBEFBA`。
- en: 'Let''s define a function called `ReconstructLCS()` that takes `A`, `B`, `i`,
    `j`, and `DP` as arguments. Our backtracking logic can be defined as follows:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义一个名为`ReconstructLCS()`的函数，它接受`A`、`B`、`i`、`j`和`DP`作为参数。我们的回溯逻辑可以定义如下：
- en: '[PRE161]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'In C++, this can be coded as follows:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，这可以编码如下：
- en: '[PRE162]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Now, we can return the result of `ReconstructLCS()` in the final line of `LCS_Tabulation()`:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在`LCS_Tabulation()`的最后一行返回`ReconstructLCS()`的结果：
- en: '[PRE163]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Our code in `main()` should now be modified to accommodate the addition of
    `LCS_Tabulation()`:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`main()`中的代码现在应该被修改以适应`LCS_Tabulation()`的添加：
- en: '[PRE164]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Using the strings `ABCABDBEFBA` and `ABCBEFBEAB`, your program''s output should
    be similar to this:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用字符串`ABCABDBEFBA`和`ABCBEFBEAB`，您程序的输出应该类似于这样：
- en: '[PRE165]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Note
  id: totrans-435
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The actual values for the time taken will vary depending on your system. Please
    note the difference in the values.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的时间值将根据您的系统而异。请注意值的差异。
- en: Now, we have looked at another detailed example of how the same logic can be
    applied to the same problem using different techniques and the corresponding effect
    this has on the execution time of the algorithm.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经看了另一个详细的例子，说明了相同的逻辑如何可以应用于同一个问题，使用不同的技术以及这对算法的执行时间产生的相应影响。
- en: 'Activity 21: Melodic Permutations'
  id: totrans-438
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动21：旋律排列
- en: 'The first question to ask ourselves is: what constitutes a single state in
    this problem?'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要问自己的第一个问题是：在这个问题中，什么构成一个单一状态？
- en: 'Base case --> Empty set:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 基本情况 --> 空集：
- en: Consider each note in the melody.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑旋律中的每个音符。
- en: For each subset of notes that was previously encountered, either append the
    current note or do nothing.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于先前遇到的每个音符子集，要么附加当前音符，要么不做任何操作。
- en: If the subset matches the target, add it to the solutions.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果子集与目标匹配，则将其添加到解决方案中。
- en: 'Given that our options are to either append a note to a previous subset or
    leave it as-is, we could restate the logic as follows:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们的选择是要么将一个音符附加到先前的子集，要么保持不变，我们可以将逻辑重新表述如下：
- en: For a given note in the melody, the count of subsets of size | n | containing
    the note is equal to the total count of all subsets of size | n - 1 | that did
    not contain the note.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 对于旋律中的给定音符，包含该音符的大小为| n |的子集的计数等于不包含该音符的大小为| n - 1 |的所有子集的总计数。
- en: 'So, each state can be expressed in two dimensions:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个状态可以用两个维度表示：
- en: '**Dimension 1**: The length of the melody considered so far.'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**维度1**：到目前为止考虑的旋律的长度。'
- en: '`[length - 1]` of the melody to it or doing nothing.'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[length - 1]`的旋律，或者什么都不做。'
- en: 'In pseudocode, the logic could be expressed as follows:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在伪代码中，逻辑可以表达如下：
- en: '[PRE166]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: So, the primary question now is, how can we represent these states?
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在的主要问题是，我们如何表示这些状态？
- en: 'Remember that for an *n*-element collection, there are a total of *2**n* subsets
    comprising it — for example, a set of 4 elements can be divided into a total of
    *2**4* (or 16) subsets:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，对于一个*n*元素的集合，它包含的子集总数为*2**n* —— 例如，一个包含4个元素的集合可以被划分为*2**4*（或16）个子集：
- en: '[PRE167]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'If we iterate from *0* to *(2**4* *- 1)* inclusive in binary, we get the following
    numbers:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在二进制中从*0*迭代到*(2**4* *- 1)*，我们得到以下数字：
- en: '[PRE168]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: As we can see, the digits of each binary number from *0* to *2**n* correspond
    exactly to the indices of one possible subset of n elements. Since there are 12
    notes in the scale, this means there is a total of *2**12* (or 4,096) possible
    subsets of notes. By mapping each note in the scale to a power of 2, we can use
    bitwise arithmetic to represent the subsets encountered across each state.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，从*0*到*2**n*的每个二进制数的数字恰好对应于n个元素的一个可能子集的索引。由于音阶中有12个音符，这意味着一共有*2**12*（或4,096）个可能的音符子集。通过将音阶中的每个音符映射到2的幂，我们可以使用位运算来表示在每个状态下遇到的子集。
- en: 'The following are the steps to solve this activity:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是解决此活动的步骤：
- en: 'Moving on to the code, we should begin by including the following headers:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续编码，我们应该从包括以下标题开始：
- en: '[PRE169]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Let''s start by handling the input in our `main()` function:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从在我们的`main()`函数中处理输入开始：
- en: '[PRE170]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Now, let''s write a function called `ConvertNotes()`,that receives a vector
    of note strings as input and returns a vector of their corresponding integer values.
    Each of the 12 total notes in the scale will need to be mapped to a particular
    bit (beginning with `A`), with enharmonically equivalent notes assigned to identical
    values. We will use `std::map` to handle the conversions:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个名为`ConvertNotes()`的函数，它接收一个音符字符串向量作为输入，并返回它们对应的整数值向量。音阶中的12个音符中的每一个都需要映射到特定的位（从`A`开始），与增值等价音符分配给相同的值。我们将使用`std::map`来处理转换：
- en: '[PRE171]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Now, we will define a function called `CountMelodicPermutations()` that takes
    two integer vectors, `melody` and `set`, as arguments and returns an integer:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将定义一个名为`CountMelodicPermutations()`的函数，它以两个整数向量`melody`和`set`作为参数，并返回一个整数：
- en: '[PRE172]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Our first step is to define our target subset. We will do this using the bitwise
    or operator:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的第一步是定义我们的目标子集。我们将使用按位或运算符来实现这一点：
- en: '[PRE173]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'As an example, if our target set is `{ C, F#, A }`, the mapping would look
    like this:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，如果我们的目标集是`{C, F#, A}`，映射将如下所示：
- en: '[PRE174]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'We will now define a two-dimensional DP table, with the first dimension initialized
    to `melodyLength + 1`, and the second dimension initialized to one greater than
    the maximum subset value (that is, `111111111111 = 2``12` `- 1`, so the second
    dimension will contain *2**12*, or 4,096, elements):'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将定义一个二维DP表，第一维初始化为`melodyLength + 1`，第二维初始化为最大子集值的一个更大的值（即`111111111111
    = 2``12` `- 1`，因此第二维将包含*2**12*，或4,096个元素）：
- en: '[PRE175]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'Our DP formula can be defined as follows:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的DP公式可以定义如下：
- en: '[PRE176]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Here, `i` ranges from `1` to the length of the melody. We can write the preceding
    logic in C++ like this:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`i`的范围是从旋律的长度为`1`到。我们可以用C++来写前面的逻辑：
- en: '[PRE177]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Now, we can finish our `main()` function by calling `CountMelodicPermutations`
    and outputting the result:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过调用`CountMelodicPermutations`并输出结果来完成我们的`main()`函数：
- en: '[PRE178]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Chapter 9: Dynamic Programming II'
  id: totrans-478
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章：动态规划II
- en: 'Activity 22: Maximizing Profit'
  id: totrans-479
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动22：最大化利润
- en: 'In this activity, we will optimize our inventory for sale to maximize our profits.
    Follow these steps to complete the activity:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将优化我们的库存以最大化利润。按照以下步骤完成活动：
- en: 'Let''s begin by including the following headers:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先包括以下标题：
- en: '[PRE179]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'First, we will define a structure, `Product`, that encapsulates the data associated
    with each item:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将定义一个结构`Product`，它封装了与每个项目相关的数据：
- en: '[PRE180]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'Next, we will handle the input in the `main()` function and populate an array
    of the `Product` type:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在`main()`函数中处理输入，并填充一个`Product`类型的数组：
- en: '[PRE181]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'As with any DP algorithm, we must now define the states and base cases. We
    know that the subset of items that form the final result must match the following
    criteria:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与任何DP算法一样，我们现在必须定义状态和基本情况。我们知道形成最终结果的项目子集必须符合以下标准：
- en: –  The sum of the `cost` of all the products in the subset must not exceed `budget`.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '- 子集中所有产品的`cost`之和不能超过`budget`。'
- en: –  The sum of the `quantity` of all the products in the subset must not exceed
    `capacity`.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '- 子集中所有产品的`quantity`之和不能超过`capacity`。'
- en: –  The sum of the `value` of all the products in the subset must be maximized.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '- 子集中所有产品的`value`之和必须最大化。'
- en: 'Given these criteria, we can see that each state can be defined by the following
    parameters:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这些标准，我们可以看到每个状态可以由以下参数定义：
- en: –  The current item being considered
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '- 正在考虑的当前项目'
- en: –  The number of units previously purchased
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '- 先前购买的单位数'
- en: –  The total cost of the purchased items
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '- 购买项目的总成本'
- en: –  The total profit gained after selling the products at retail value
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '- 以零售价出售产品后获得的总利润'
- en: 'We can also conclude that a search will terminate when:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以得出结论，搜索将在以下情况下终止：
- en: –  All the items have been considered
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '- 所有项目都已考虑过'
- en: –  The total cost exceeds the budget
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '- 总成本超出预算'
- en: –  The total number of units exceeds the capacity
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '- 总单位数超过容量'
- en: 'Like the traditional 0-1 knapsack problem, we will consider each item from
    `0` to `N-1` linearly. For each item at index `i`, our states can transition in
    one of two ways: by either including the current item or leaving it. Writing the
    recursive logic in pseudocode may look like this:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的0-1背包问题一样，我们将线性地考虑从`0`到`N-1`的每个项目。对于索引为`i`的每个项目，我们的状态可以以两种方式之一转换：包括当前项目或留下它。用伪代码编写递归逻辑可能是这样的：
- en: '[PRE182]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'As shown in the preceding code, the recurrence relation is defined according
    to the values of `i`, `count`, `cost`, and `total`. Converting this logic from
    top down to bottom up can be done like so:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，递归关系根据`i`、`count`、`cost`和`total`的值来定义。将这种逻辑从自顶向下转换为自底向上可以这样做：
- en: '[PRE183]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: In other words, each state is described according to the current index, total
    cost, and total count. For each pair of valid `cost` and `count` values, the current
    result for an item at index `i` will be equal either to the maximum subset sum
    that was found for the same values of `cost` and `count` at index `i – 1` (that
    is, `DP[i – 1][cost][count]`) or the sum of the current item's `value` with the
    maximum sum at index `i – 1` with `cost` and `count` equal to what they would
    have been prior to including the item (that is, `DP[i - 1][cost – price][count
    – quantity] + value`).
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，每个状态都根据当前索引、总成本和总计数来描述。对于每对有效的`cost`和`count`值，对于相同的`cost`和`count`值在索引`i
    – 1`处找到的最大子集和（即`DP[i – 1][cost][count]`），当前项目在索引`i`处的当前结果将等于当前项目的`value`与在索引`i
    – 1`处的最大和的`cost`和`count`值相等的和（即`DP[i - 1][cost – price][count – quantity] + value`）。
- en: 'We can code the preceding logic as follows:'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将前面的逻辑编码如下：
- en: '[PRE184]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: As you can see, the implementation is equivalent to the 0-1 knapsack solution
    with an additional dimension.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，该实现等同于具有额外维度的0-1背包解决方案。
- en: 'Activity 23: Residential Roads'
  id: totrans-508
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动23：住宅道路
- en: 'This activity has quite a few potential pitfalls if you do not approach it
    with some forethought. The most difficult aspect of it is the fact that it requires
    a number of distinct steps, and a careless mistake at any point can cause the
    entire program to fail. Therefore, it is recommended to approach the implementation
    step by step. The primary steps that are required are as follows:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不事先考虑，这个活动可能会有一些潜在的陷阱。它最困难的一点是，它需要许多不同的步骤，而在任何时候的疏忽错误都可能导致整个程序失败。因此，建议逐步实现。所需的主要步骤如下：
- en: Handling the input
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理输入
- en: Building the graph (finding adjacencies and weight values)
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建图（找到邻接和权值）
- en: Finding the shortest distances between graph nodes
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找图节点之间的最短距离
- en: Reconstructing the edges in the shortest paths
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重建最短路径中的边
- en: Redrawing the input grid
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重绘输入网格
- en: Since this is considerably lengthier than the other activities in this chapter,
    let's attack each of these steps individually.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这比本章中的其他活动要长得多，让我们分别处理这些步骤。
- en: '**Step 0: Preliminary Setup**'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤0：初步设置**'
- en: 'Before we write any code related to input, we should decide how we want to
    represent our data in advance. The input we will receive is as follows:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写与输入相关的任何代码之前，我们应该提前决定如何表示我们的数据。我们将收到的输入如下：
- en: Two integers, `H` and `W`, representing the height and width of the grid.
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个整数`H`和`W`，表示网格的高度和宽度。
- en: An integer, `N`, representing the number of houses contained on the property.
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整数`N`，表示属性上包含的房屋数量。
- en: '`H` strings of width `W` representing the map of the property. We can store
    this data as an `H`-element vector of strings.'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`H`个宽度为`W`的字符串，表示属性的地图。我们可以将这些数据存储为一个包含字符串的`H`元素向量。'
- en: '`H` rows of `W` integers representing the ruggedness of the terrain. We can
    store these values in an integer matrix.'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`H`行`W`个整数，表示地形的崎岖程度。我们可以将这些值存储在一个整数矩阵中。'
- en: '`N` lines containing two integers, `x` and `y`, representing the coordinates
    of each house. For this, we can create a simple structure called `Point` containing
    two integers, `x` and `y`.'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`N`行，包含两个整数`x`和`y`，表示每个房屋的坐标。为此，我们可以创建一个简单的结构称为`Point`，包含两个整数`x`和`y`。'
- en: 'Now, let''s look at the implementation:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看实现：
- en: 'Include the required headers and define some global constants and variables
    that we will need later in this problem. We will declare most of our data globally
    for the sake of convenience, but it is worth reiterating the point that this is
    generally considered bad practice within the context of a full-scale application:'
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括所需的头文件，并定义一些全局常量和变量，我们将在问题后面需要。出于方便起见，我们将大部分数据声明为全局数据，但值得重申的是，在全面应用的情况下，这通常被认为是不良实践：
- en: '[PRE185]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '**Step 1: Handling the Input**'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤1：处理输入**'
- en: 'Since there is a fair amount of input required for this problem, let''s contain
    it all in its own function, `Input()`, which will return void:'
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这个问题需要相当多的输入，让我们将它们都包含在自己的函数`Input()`中，该函数将返回`void`：
- en: '[PRE186]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '**Step 2: Building the Graph**'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤2：构建图**'
- en: 'The problem description states the following:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 问题描述如下：
- en: A road can be built between two houses if and only if there is a direct horizontal,
    vertical, or diagonal path between them.
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有在它们之间存在直接的水平、垂直或对角路径时，才能在两个房屋之间修建道路。
- en: Roads may not be built across bodies of water, mountains, forests, and so on.
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 道路不能修建在水域、山脉、森林等地方。
- en: The cost of building a road between two houses is equal to the sum of ruggedness
    values on the path between them.
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两个房屋之间修建道路的成本等于它们之间路径上的崎岖值之和。
- en: 'To test the first condition, we simply need to compare the coordinates of two
    points and determine whether any of the following three conditions are true:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试第一个条件，我们只需要比较两点的坐标，并确定以下三个条件中是否有任何一个为真：
- en: '`A.x = B.x` (there is a horizontal line between them)'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A.x = B.x`（它们之间有一条水平线）'
- en: '`A.y = B.y` (there is a vertical line between them)'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A.y = B.y`（它们之间有一条垂直线）'
- en: '`| A.x – B.x | = | A.y – B.y |` (there is a diagonal line between them)'
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`| A.x – B.x | = | A.y – B.y |`（它们之间有一条对角线）'
- en: Now, let's get back to our code.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的代码。
- en: 'To do this, let''s write a function `DirectLine()`, that takes two points,
    `a` and `b`, as arguments and returns a Boolean:'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此，让我们编写一个名为`DirectLine()`的函数，它以两个点`a`和`b`作为参数，并返回一个布尔值：
- en: '[PRE187]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'To handle the second and third cases, we can simply perform a linear traversal
    from point `a` to point `b` in the grid. As we consider each point in the grid,
    we can accumulate the sum of values contained in the terrain matrix. As we do
    this, we can simultaneously check the character in `grid[a.y][a.x]`, terminating
    it as soon as we encounter a character that is not equal to `EMPTY_SPACE` (that
    is, ''`.`''). If at the end of the traversal point `a` is equal to point `b`,
    we will store the sum we acquired in the `cost` matrix; otherwise, we have determined
    that there is no adjacency between `a` and `b`, in which case we return `UNKNOWN`.
    We can do this using the `GetCost()` function, which takes two integers, `start`
    and `end`, as arguments. These represent the indices of `a` and `b`, respectively,
    and return an integer:'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了处理第二和第三种情况，我们可以简单地在网格中从点`a`到点`b`执行线性遍历。当我们考虑网格中的每个点时，我们可以累积包含在地形矩阵中的值的总和。在这样做的同时，我们可以同时检查`grid[a.y][a.x]`中的字符，并在我们遇到一个不等于`EMPTY_SPACE`（即'`.`'）的字符时终止它。如果在遍历结束时点`a`等于点`b`，我们将在`cost`矩阵中存储我们获得的总和；否则，我们已经确定`a`和`b`之间没有邻接关系，在这种情况下，我们返回`UNKNOWN`。我们可以使用`GetCost()`函数来做到这一点，它接受两个整数`start`和`end`作为参数。这些代表`a`和`b`的索引，分别返回一个整数：
- en: '[PRE188]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'The final line requires that we define `operator !=` in our `Point` struct:'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一行要求我们在`Point`结构中定义`operator !=`：
- en: '[PRE189]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'Now, let''s create the following `GetAdjacencies()` function:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建以下`GetAdjacencies()`函数：
- en: '[PRE190]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '**Step 3: Finding the Shortest Distances between Nodes**'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤3：查找节点之间的最短距离**'
- en: 'The problem states that two houses should be connected by a road that is on
    the path that minimizes the cost of reaching the exit point. For this implementation,
    we will use the Floyd-Warshall algorithm. Let''s get back to our code:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 问题说明两个房屋应该由一条道路连接，该道路位于最小化到达出口点的成本路径上。对于这个实现，我们将使用Floyd-Warshall算法。让我们回到我们的代码：
- en: 'Let''s define a function, `GetShortestPaths()`, that will handle both the implementation
    of Floyd-Warshall as well as the path''s reconstruction. To handle the latter
    case, we will maintain a *N x N* integer matrix called `next` that will store
    the index of the next point on the shortest path from nodes `a` and `b`. Initially,
    its values will be set to the existing edges in the graph:'
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义一个名为`GetShortestPaths()`的函数，它将处理Floyd-Warshall的实现以及路径的重建。为了处理后一种情况，我们将维护一个名为`next`的*N
    x N*整数矩阵，它将存储从节点`a`和`b`到最短路径上下一个点的索引。最初，它的值将设置为图中现有边的值：
- en: '[PRE191]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'We will then perform the standard implementation of Floyd-Warshall, with one
    additional line in the innermost loop setting `next[start][end]` to `next[start][mid]`
    every time we find a shorter distance between `start` and `end`:'
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将执行Floyd-Warshall的标准实现，在最内层循环中的一个额外行将`next[start][end]`设置为`next[start][mid]`，每当我们发现`start`和`end`之间的距离更短时：
- en: '[PRE192]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '`next` matrix, we can easily reconstruct the points on each path in a similar
    way to the reconstruction approaches for the LCS or 0-1 Knapsack problems. For
    this purpose, we will define another function, `GetPath()`, that has three parameters—two
    integers, `start` and `end`, and a reference to the `next` matrix — and returns
    an integer vector containing the node indices of the path:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '`next`矩阵，我们可以轻松地以与LCS或0-1背包问题的重建方法类似的方式重建每条路径上的点。为此，我们将定义另一个名为`GetPath()`的函数，它具有三个参数——两个整数`start`和`end`，以及对`next`矩阵的引用，并返回一个整数向量，其中包含路径的节点索引：'
- en: '[PRE193]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'Returning to `GetShortestPaths()`, we will now add a loop underneath our implementation
    of Floyd-Warshall that calls `GetPath()` and then draws lines in the grid corresponding
    to each pair of points in the path:'
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`GetShortestPaths()`，我们现在将在Floyd-Warshall的实现下面添加一个循环，调用`GetPath()`，然后在网格中为路径中的每一对点绘制线条：
- en: '[PRE194]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '**Step 5: Redrawing the Grid**'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤5：重绘网格**'
- en: 'Now, we must draw the roads in the grid. We will do this in another function,
    `DrawPath()`, which has the `start` and `end` parameters:'
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须在网格中绘制道路。我们将在另一个名为`DrawPath()`的函数中执行此操作，该函数具有`start`和`end`参数：
- en: '[PRE195]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'We will need to choose the correct character corresponding to the orientation
    of each road. To do this, we will define a function, `GetDirection()`, that returns
    an integer corresponding to an index in the `roads` string we defined at the beginning
    ("`-|/\`"):'
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要选择与每条道路方向相对应的正确字符。为此，我们将定义一个名为`GetDirection()`的函数，它返回一个整数，对应于我们在开始时定义的`roads`字符串中的索引（"`-|/\`"）：
- en: '[PRE196]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'We can now perform a linear traversal from `a` to `b`, setting each cell in
    the grid to `mark` if its value is `EMPTY_SPACE`. Otherwise, we must check to
    see whether the character in the cell is a road character of a different orientation,
    in which case we set it to `+`:'
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以从`a`到`b`进行线性遍历，如果其值为`EMPTY_SPACE`，则将网格中的每个单元格设置为`mark`。否则，我们必须检查单元格中的字符是否是不同方向的道路字符，如果是，则将其设置为`+`：
- en: '[PRE197]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'All that is left is to call our functions in `main()` and print the output:'
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，唯一剩下的就是在`main()`中调用我们的函数并打印输出：
- en: '[PRE198]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
