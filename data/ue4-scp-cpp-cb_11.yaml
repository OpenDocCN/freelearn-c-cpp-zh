- en: Chapter 11. Custom Materials and Shaders
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章 自定义材质和着色器
- en: 'Material definition and creation tools in UE4 are fantastic, not to mention
    its real-time rendering performance. When you see your first glittering gold shader,
    you will be amazed at UE4''s Material shading capabilities, which are possible
    with a bit of math. We will show you how to use these tools through the following
    recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: UE4中的材质定义和创建工具非常出色，更不用说其实时渲染性能了。当您看到您的第一个闪闪发光的金色着色器时，您会对UE4的材质着色能力感到惊讶，这是通过一些数学计算实现的。我们将通过以下教程向您展示如何使用这些工具：
- en: Modifying color using a basic Material
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基本材质修改颜色
- en: Modifying position using a Material
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用材质修改位置
- en: Shader code via Custom node
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过自定义节点的着色器代码
- en: The Material function
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材质函数
- en: Shader parameters and Material instances
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 着色器参数和材质实例
- en: Glimmer
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闪烁
- en: Leaves and Wind
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 叶子和风
- en: Reflectance dependent on the viewing angle
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与观察角度有关的反射
- en: Randomness – Perlin noise
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机性-柏林噪声
- en: Shading a Landscape
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给景观着色
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In computer graphics, a **shader** is used to color something. Traditionally,
    shaders were so called since they defined the shade that an object got based on
    its original color and light source position.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机图形学中，**着色器**用于给某物上色。传统上，着色器之所以被称为着色器，是因为它们根据原始颜色和光源位置定义了物体的阴影。
- en: Nowadays, shaders aren't really thought of as providing shading to an object
    as much as a textured, final color.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，着色器不再被认为是为对象提供阴影，而是提供纹理和最终颜色。
- en: '![Introduction](img/00261.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![介绍](img/00261.jpeg)'
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Shaders are about determining the final color of an object given the light source,
    geometric positions, and initial colors (including textures, and more expensively,
    material properties).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器是关于确定物体的最终颜色的，给定光源、几何位置和初始颜色（包括纹理，以及更昂贵的材质属性）。
- en: 'There are two flavors of shader: vertex shaders and pixel shaders.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器有两种类型：顶点着色器和像素着色器。
- en: '**Vertex shaders**: Color at the vertex (point in the mesh), and smoothly shade
    from one 3-space point to another 3-space point.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶点着色器**：顶点（网格中的点）的颜色，并且从一个三维点平滑着色到另一个三维点。'
- en: '**Pixel shaders**: Color at the pixel (point on the screen). The 3-space physical
    location of a pixel (aka fragment) is calculated using some simple math.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**像素着色器**：像素（屏幕上的点）的颜色。使用一些简单的数学计算来计算像素（也称为片段）的三维物理位置。'
- en: In UE4, we just call a shader a Material. Materials abstract the vertex and
    fragment processing pipelines into block-programmable functions, so you don't
    have to think about the GPU or code to get the graphical output you desire. You
    simply think in terms of blocks and pictures. You can construct Materials and
    build GPU shading functionality without ever writing a line of **High Level Shading
    Language** (**HLSL**), **OpenGL Shading Language** (**GLSL**), or Cg (C for graphics)
    code!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在UE4中，我们将着色器称为材质。材质将顶点和片段处理管线抽象为可编程块函数，因此您无需考虑GPU或编码即可获得所需的图形输出。您只需以块和图片的形式思考。您可以构建材质并构建GPU着色功能，而无需编写一行**高级着色语言**（**HLSL**）、**OpenGL着色语言**（**GLSL**）或Cg（用于图形）代码！
- en: Tip
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You will commonly hear of three major GPU programming languages: HLSL, GLSL,
    and Cg. GLSL is OpenGL''s GPU programming language, while HLSL is Microsoft''s
    offering. After battling it out for popularity through the 90s and the first decade
    of the twenty-first century, Cg was born in an attempt to unify all GPU programming
    under it. Cg is still popular, but GLSL and HLSL also remain in popular use.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您通常会听到三种主要的GPU编程语言：HLSL、GLSL和Cg。GLSL是OpenGL的GPU编程语言，而HLSL是微软的产品。在90年代和21世纪的第一个十年中，Cg诞生了，试图将所有GPU编程统一起来。Cg仍然很受欢迎，但GLSL和HLSL也仍然广泛使用。
- en: Modifying color using a basic Material
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基本材质修改颜色
- en: The primary usage of Materials is to make surfaces appear in the color you want
    them. In your scene, you will have light sources and surfaces. Surfaces are coated
    in materials that reflect and refract the light, which you then see using the
    camera's eye. The basic thing to do with a material is to modify the color of
    a surface.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 材质的主要用途是使表面呈现您想要的颜色。在您的场景中，您将拥有光源和表面。表面上涂有反射和折射光线的材质，您可以通过相机的眼睛看到。材质的基本操作是修改表面的颜色。
- en: Tip
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Do not ignore the importance of tuning your light sources to make materials
    look as you wish them to look!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忽视调整光源以使材质看起来符合您的期望的重要性！
- en: Getting used to the Material Editor takes some practice, but once you get used
    to it, you can do amazing things with it. In this recipe, we'll just use some
    of the very basic functionality to construct a wooden textured material.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉材质编辑器需要一些练习，但一旦您熟悉了它，您可以用它做出令人惊叹的事情。在本教程中，我们将只使用一些非常基本的功能来构建一个木质纹理材质。
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Texture versus Material: Keep in mind that there is a big difference between
    the terms texture and material. A texture is just an image file (such as a photograph
    of some `wood.png`); a material, on the other hand, is a combination of textures,
    colors, and mathematical formulae for describing how a surface appears under light.
    Materials will account for surface properties, such as color absorption, reflectance,
    and shininess, while a texture is just a group of colored pixels (or texels, as
    the GPU calls them).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理与材质的区别：请记住，纹理和材质这两个术语之间有很大的区别。纹理只是一个图像文件（例如一张名为`wood.png`的照片）；而材质则是一组纹理、颜色和数学公式的组合，用于描述表面在光线下的外观。材质将考虑表面的属性，如颜色吸收、反射和光泽度，而纹理只是一组有色像素（或者GPU称之为纹素）。
- en: Shaders are programmed just like normal C++ code, only far more restricted.
    There are several parameter types you can choose from. Most of them will be floats
    or packages of floats arranged in a vector format (`float`, `float2`, `float3`,
    `float4`). For things such as positions and colors, you'll use `float3` or `float4`;
    for things such as texture coordinates, you'll use `float2`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器的编程方式与普通的C++代码相同，只是限制更多。有几种参数类型可供选择。其中大多数将是浮点数或以向量格式排列的浮点数包（`float`，`float2`，`float3`，`float4`）。对于位置和颜色等内容，您将使用`float3`或`float4`；对于纹理坐标等内容，您将使用`float2`。
- en: Getting ready
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need a clean UE4 project into which you want to place your new material.
    Install the **GameTexture Materials** pack from the UE4 Marketplace (Epic Games
    Launcher Application) in your UE4 project. It contains some required textures
    that we'll need for this recipe. You also need a piece of simple geometry to show
    the results of your shader.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个干净的UE4项目，将其中放置您的新材质。在UE4项目中安装来自UE4市场（Epic Games Launcher应用程序）的**GameTexture
    Materials**包。它包含我们在本教程中需要的一些必需纹理。您还需要一个简单的几何体来显示着色器的结果。
- en: How to do it...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: To create a basic material, right-click in the **Content Browser,** and create
    a **Material** (available from the top four Basic Asset elements).![How to do
    it...](img/00262.jpeg)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个基本材质，在**内容浏览器**中右键单击，并创建一个**材质**（在前四个基本资产元素中可用）。![如何操作...](img/00262.jpeg)
- en: Name your material (for example, `GoldenMaterial`), then double-click on it
    to edit it.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的材质命名（例如`GoldenMaterial`），然后双击它进行编辑。
- en: Welcome to the Material Editor:![How to do it...](img/00263.jpeg)
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 欢迎来到材质编辑器：![如何操作...](img/00263.jpeg)
- en: You can tell it is the Material Editor because of the presence of the Material
    output node on the right. To the left is a 3D rendered sphere demonstrating what
    your material looks like. Materials start out as a kind of coal-ish black semi-shiny
    material. We can adjust all the material parameters, believe it or not, to make
    anything from a material that emits light like the Sun, to water, or to the texture
    of a unit's armor. Let us begin by adjusting the output colors of the material
    to create a gold-colored metallic material.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过右侧的材质输出节点来判断它是材质编辑器。左侧是一个3D渲染的球体，展示了您的材质的外观。材质最初是一种类似煤炭的黑色半光泽材质。我们可以调整所有材质参数，从像太阳一样发光的材质，到水，或者到单位装甲的纹理。让我们从调整材质的输出颜色开始，创建一个金色的金属材质。
- en: Change the **Base Color** to yellow by right-clicking on any blank spot in the
    Material Editor window and choosing a **Constant3Vector** (which represents an
    RGB color). Adjust the color by double-clicking on the node and dragging around
    the value of the color swatches. Connect the output of the Constant3Vector to
    **Base Color,** and wait for the 3D picture on the left to reload with your new
    material's appearance. Connect the output of the Constant3Vector to the **Base
    Color** to give the material a yellow appearance as shown in the following screenshot:![How
    to do it...](img/00264.jpeg)
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键单击材质编辑器窗口中的任何空白处，并选择**Constant3Vector**（表示RGB颜色）将**基础颜色**更改为黄色。通过双击节点并拖动颜色样本的值来调整颜色。将Constant3Vector的输出连接到**基础颜色**，等待左侧的3D图片重新加载以显示您的新材质外观。将Constant3Vector的输出连接到**基础颜色**，使材质呈现黄色，如下图所示：![如何操作...](img/00264.jpeg)
- en: Select a metallicness level for all channels by attaching a constant value to
    the **Metallic** input, and setting it to 1\. 1 is very metallic, and 0 is not
    metallic at all (and so will look plasticy, like the material shown in the next
    screenshot).![How to do it...](img/00265.jpeg)
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将一个常量值附加到**金属**输入并将其设置为1，为所有通道选择一个金属度级别。1表示非常金属，0表示完全不金属（因此看起来像下一个截图中显示的材质一样塑料）。![如何操作...](img/00265.jpeg)
- en: Choose a **Specular** value for the material, again between 0 and 1\. **Specular**
    materials are shiny, while non-specular ones are not.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为材质选择一个**高光**值，同样在0到1之间。**高光**材质是有光泽的，而非高光材质则没有。
- en: Choose a **Roughness** value for the material. **Roughness** refers to how spread
    out the specular highlight is. If **Roughness** is high (near 1.0), then the surface
    is clay-like, with almost specular highlight. The specular highlight appears fat
    and wide near the values 0.7 or 0.8\. When roughness is near 0, then the specular
    highlight is very sharp and thin (extremely shiny/mirror-like surface).
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为材质选择一个**粗糙度**值。**粗糙度**指的是镜面高光的扩散程度。如果**粗糙度**很高（接近1.0），则表面类似于黏土，几乎没有镜面高光。镜面高光在0.7或0.8附近的值附近呈现出较宽的形状。当粗糙度接近0时，镜面高光非常锐利而细小（极其光亮/镜面般的表面）。
- en: '![How to do it...](img/00266.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/00266.jpeg)'
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The material on the left has roughness = 0, and the material on the right has
    roughness = 1.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的材质的粗糙度为0，右侧的材质的粗糙度为1。
- en: Apply your material to an object in your scene by clicking and dragging the
    material onto the model mesh that you want the material to apply to. Alternatively,
    select a model mesh component, and the new material that you have created by name
    in the **Details** panel.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击并拖动材质到您想要应用材质的模型网格上，将材质应用于场景中的对象。或者，通过名称在**详细信息**面板中选择一个模型网格组件和您创建的新材质。
- en: Finally, create a light in the scene to examine your material's response properties
    further. Without a light, every material appears black (unless its an emissive
    material). Add a light via **Modes** | **Lights**.![How to do it...](img/00267.jpeg)
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在场景中创建一个光源以进一步检查材质的响应属性。没有光源，每个材质都会显示为黑色（除非它是自发光材质）。通过**模式** | **灯光**添加一个光源。![如何操作...](img/00267.jpeg)
- en: Modifying position using a Material
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用材质修改位置
- en: A less common thing to do is to use a Material to modify an object's position.
    This is commonly done in things such as water shaders. We do it using the **World
    Position Offset** node inside the Material's output.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 不常见的是使用材质来修改对象的位置。这通常在水着色器等方面使用。我们使用材质输出中的**世界位置偏移**节点来实现这一点。
- en: '![Modifying position using a Material](img/00268.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![使用材质修改位置](img/00268.jpeg)'
- en: We can modulate the output position of a vertex using some GPU math. This lightens
    the load of rendering realistic water on the CPU by a significant amount.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一些GPU数学来调制顶点的输出位置。这样做可以显著减轻CPU渲染逼真水体的负担。
- en: Getting ready
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a piece of geometry in your world. Construct a new shader called `Bob`,
    which we'll edit to produce a simple bobbing motion for objects rendered with
    the material.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的世界中创建一个几何体。构建一个名为`Bob`的新着色器，我们将编辑它以产生一个简单的上下浮动的运动效果，用于渲染使用该材质的对象。
- en: How to do it...
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: In your new Material (named `Bob`), right-click and add **Texcoord** and **Time
    Input** nodes.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的新材质（名为`Bob`）中，右键单击并添加**Texcoord**和**Time Input**节点。
- en: Cascade the sum of the **Texcoord** (for spatial) and **Time Input** nodes through
    a `sin()` function call to create some wavy displacement. Multiply the output
    of the `sin()` function, and pass as Z-inputs to **World Displacement**.![How
    to do it...](img/00269.jpeg)
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过对`sin()`函数调用级联**Texcoord**（用于空间）和**Time Input**节点的总和，创建一些波浪位移。将`sin()`函数的输出乘以并作为Z输入传递给**World
    Displacement**。![操作步骤...](img/00269.jpeg)
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Part of the simple water shader given in the code of `Chapter11` that produces
    the displacement.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 给出在`Chapter11`代码中的简单水体着色器的一部分，它产生位移。
- en: Select **PN Triangles** under **Tessellation** | **D3D11Tessellation Mode**,
    and set **Tessellation Multiplier** in the material to 1.0.![How to do it...](img/00270.jpeg)
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Tessellation** | **D3D11Tessellation Mode**下选择**PN Triangles**，并将材质中的**Tessellation
    Multiplier**设置为1.0。![操作步骤...](img/00270.jpeg)
- en: Tip
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Normally, specularity and translucency cannot be combined in UE4 shaders. However,
    the Surface Perpixel (experimental, limited features) Lighting Mode does allow
    you to enable both. In addition to selecting this lighting mode, you must remember
    to ensure to press [PRE0]
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，UE4着色器中无法同时使用高光和半透明效果。然而，表面每像素（实验性，功能有限）光照模式允许你同时启用两者。除了选择这种光照模式外，你还必须记住确保按下[PRE0]
- en: return float3( x*x, y*y, z*z );
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: return float3( x*x, y*y, z*z );
- en: '```'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '![How to do it...](img/00272.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](img/00272.jpeg)'
- en: Tip
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: What this does is construct a 3-float vector, and return the square of *X* in
    the `x` value, the square of *Y* in the `y` value, and the square of *Z* in the
    `z` value.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的作用是构建一个3个浮点数的向量，并将*X*的平方返回到`x`值中，将*Y*的平方返回到`y`值中，将*Z*的平方返回到`z`值中。
- en: To return different values for *X*, *Y*, *Z* components of a vector type, we
    had to return a call to a `float3` or `float4` constructor. If you're not returning
    a vector type, you can just use a `return` statement (without calling a `float`
    constructor).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了返回向量类型的*X*、*Y*、*Z*分量的不同值，我们必须返回对`float3`或`float4`构造函数的调用。如果你不返回向量类型，你可以只使用一个`return`语句（不调用`float`构造函数）。
- en: How it works…
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: A custom node is really just a bit of HLSL code. Any valid HLSL code can be
    used in the code text field. A vertex or pixel shader program has several standard
    inputs in it. These standard inputs have been defined for a very long time, and
    they are the parameters you can use to change the way your geometry renders.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义节点实际上只是一段HLSL代码。任何有效的HLSL代码都可以在代码文本字段中使用。顶点或像素着色器程序中有几个标准输入。这些标准输入已经定义了很长时间，它们是你可以用来改变几何体渲染方式的参数。
- en: '![How it works…](img/00273.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/00273.jpeg)'
- en: HLSL and Cg have a concept called semantics, which attaches a kind of concrete
    typing to a float. This is done so that the external program calling the shader
    knows where to put which input when calling your vertex or pixel shading program.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: HLSL和Cg有一个称为语义的概念，它将一种具体的类型与一个浮点数关联起来。这样做是为了外部调用着色器的程序在调用顶点或像素着色程序时知道在哪里放置哪个输入。
- en: In the following Cg function signature, in addition to being a `float` variable,
    `inPosition` is semantically a `POSITION` typed variable `inTexcoord` a `TEXCOORD`
    typed variable, and `inColor` a `COLOR` typed variable. Inside the shader, you
    can use the variables for anything you want, the semantics are simply for routing
    the correct input to the correct variable (to make sure that the color comes in
    on the `COLOR` typed variable—otherwise, we'd have to do something like track
    the order in which the parameters are specified or something!)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的Cg函数签名中，除了是一个`float`变量之外，`inPosition`在语义上是一个`POSITION`类型的变量，`inTexcoord`是一个`TEXCOORD`类型的变量，`inColor`是一个`COLOR`类型的变量。在着色器内部，你可以将这些变量用于任何你想要的目的，语义只是为了将正确的输入路由到正确的变量（以确保颜色通过`COLOR`类型的变量输入，否则我们将不得不跟踪参数的指定顺序或其他操作！）
- en: The output parameters of the function specify how the output of the shader is
    to be interpreted. Interpretation is only for the recipient of the output data
    of your program (the next step in the rendering pipeline). Inside your shader
    program you know you are just writing out a bunch of floats to the shader pipeline.
    There's nothing that forbids you from mixing different types of semantics inside
    the shader. A `COLOR` semantic variable can be multiplied by a `POSITION` semantic
    input, and sent out as a `TEXCOORD` semantic output if you so desired.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的输出参数指定了如何解释着色器的输出。解释仅适用于程序的输出数据的接收者（渲染管线中的下一步）。在着色器程序内部，你知道你只是将一堆浮点数写入着色器管线。没有什么禁止你在着色器内部混合不同类型的语义。一个`COLOR`语义变量可以乘以一个`POSITION`语义输入，并作为`TEXCOORD`语义输出发送出去，如果你愿意的话。
- en: The Material function
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 材质函数
- en: 'As always, **modularity** is one of the best practices in programming. Material
    shaders are no exception: it is far better if your shader blocks are modular,
    and can be boxed out and identified as named functions. This way, not only are
    your shader blocks clearer, but they can also be reused in multiple Material shaders,
    or even exported to your local UE4 library for future use in other projects.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，**模块化**是编程中的最佳实践之一。材质着色器也不例外：如果你的着色器块是模块化的，并且可以被封装并标识为命名函数，那将更好。这样，不仅你的着色器块更清晰，而且它们还可以在多个材质着色器中重复使用，甚至可以导出到本地UE4库中以供将来在其他项目中使用。
- en: Getting ready
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: A reusable or repeatable block of shader functionality can be factored out of
    your custom material shader program. In this example, we'll write a simple function
    series—`Square`, `Square2`, `Square3`, and `Square4`—that squares input values.
    Get ready to perform the work in this recipe by opening a UE4 project and navigating
    to the **Content Browser**.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将可重用的着色器功能块从自定义材质着色器程序中分离出来。在本示例中，我们将编写一个简单的函数系列——`Square`、`Square2`、`Square3`和`Square4`——来对输入值进行平方。通过打开UE4项目并导航到**内容浏览器**，准备好在本教程中执行工作。
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Right-click in the **Content Browser,** and select **Materials & Textures**
    | **Material Function**.![How to do it...](img/00274.jpeg)
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**内容浏览器**中右键单击，然后选择**Materials & Textures** | **Material Function**。![如何操作...](img/00274.jpeg)
- en: Name your **Material Function** `Square`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的**材质函数**命名为`Square`。
- en: Double-click on **Material Function**.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**材质函数**。
- en: As soon as you open **Material Function**, deselect the **Output Result** node
    by left-clicking anywhere in the blank canvas space of the Material Editor. Take
    a look at the **Details** panel, and note that the Function's exposure to the
    UE4 library is optionally available:![How to do it...](img/00275.jpeg)
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦打开**材质函数**，通过在材质编辑器的空白画布空间中的任何位置左键单击，取消选择**输出结果**节点。查看**详细信息**面板，并注意函数对UE4库的暴露是可选的：![如何操作...](img/00275.jpeg)
- en: The **Expose to Library** checkbox appears in the **Details** panel when no
    nodes are selected in the **Material Function** Editor screen.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当在**材质函数**编辑器屏幕中没有选择节点时，**详细信息**面板中会出现**暴露到库**复选框。
- en: Right-click anywhere in the blank space in the **Material Function** editor,
    and select **Input**. Name your input. Notice how **Input** nodes are only available
    in the **Material Functions** editor, not in the normal Material editing view.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**材质函数**编辑器的空白处右键单击，然后选择**输入**。为您的输入命名。请注意，**输入**节点仅在**材质函数**编辑器中可用，而不在普通的材质编辑视图中可用。
- en: 'From any regular Material, invoke your function by doing one of the following:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从任何常规材质中，通过以下方式之一调用您的函数：
- en: Right-click in the blank space, and select `MaterialFunction`, then select your
    `MaterialFunction` from the drop-down menu.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在空白处右键单击，然后选择`MaterialFunction`，然后从下拉菜单中选择您的`MaterialFunction`。
- en: Right-click and type the name of your **Material Function** (this requires you
    to have exposed your **Material Function** previously).
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击并输入您的**材质函数**的名称（这要求您先前已经暴露了您的**材质函数**）。
- en: If you don't want to expose your **Material Function** to the UE4 library, then
    you have to use a `MaterialFunction` block to call your custom function.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您不想将您的**材质函数**暴露给UE4库，则必须使用`MaterialFunction`块来调用您的自定义函数。
- en: Right-click anywhere in the **Material Function** editor, and select **Output**.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**材质函数**编辑器的任何位置右键单击，然后选择**输出**。
- en: How it works…
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '**Material Function**s are some of the most useful blocks you can create. With
    them, you can modularize your shader code to be much more neat, compact, and reusable.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**材质函数**是您可以创建的最有用的块之一。通过使用它们，您可以将着色器代码模块化，使其更整洁、紧凑和可重用。'
- en: There's more…
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Migrating your functionality to the shader library is a good idea. You can make
    your custom function appear in the function library by choosing **Expose to Library**
    in the root of the shader (provided you have nothing selected in the Material
    Editor window).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将功能迁移到着色器库是一个好主意。通过在着色器的根部选择**暴露到库**，您可以使自定义函数出现在函数库中（前提是在材质编辑器窗口中没有选择任何内容）。
- en: When developing a **Material Function**, sometimes, it's helpful to change the
    Material Preview node to a node other than the output node. Preview a specific
    node's output by right-clicking the output jack for any node and selecting **Start
    Previewing Node**.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发**材质函数**时，有时将材质预览节点更改为输出节点以外的节点会很有帮助。通过右键单击任何节点的输出插孔并选择**开始预览节点**来预览特定节点的输出。
- en: '![There''s more…](img/00276.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/00276.jpeg)'
- en: The window in the top-left corner of the Material Editor will now show the output
    of the node you are previewing. In addition, the text **Previewing** will be added
    to the node you are previewing (if it's not the final output node). Ensure that
    **Live Preview** is enabled in the menu bar at the top of the Material Editor.
    Typically, you would want the final output to be previewed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 材质编辑器左上角的窗口现在将显示您正在预览的节点的输出。此外，如果您正在预览的节点不是最终输出节点，则会在您正在预览的节点上添加文本**正在预览**。确保在材质编辑器顶部的菜单栏中启用了**实时预览**。通常，您希望预览最终输出。
- en: Shader parameters and Material instances
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色器参数和材质实例
- en: A parameter to a shader is going to be a variable input to that shader. You
    can configure scalars or vectors to be used as input parameters to your shader.
    Some materials within UE4 come preprogrammed with material parameters exposed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器的参数将成为该着色器的变量输入。您可以配置标量或矢量作为您的着色器的输入参数。UE4中的某些材质预先编程了暴露的材质参数。
- en: Getting ready
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order to set up a parameter to a shader, you first need a shader with something
    that you want to modify with a variable. A good thing to modify with a variable
    is the suit color of a character. We can expose the color of the suit as a shader
    parameter that we multiply suit color by.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置着色器的参数，您首先需要一个带有您想要使用变量修改的内容的着色器。一个好的用变量修改的东西是角色的服装颜色。我们可以将服装的颜色作为着色器参数暴露出来，然后将其与服装颜色相乘。
- en: How to do it...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Construct a new Material.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个新的材质。
- en: Within the Material, create a `VectorParameter`. Give the parameter a name,
    such as `Color`. Give it a default value, such as blue or black.![How to do it...](img/00277.jpeg)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在材质中创建一个`VectorParameter`。给参数一个名称，例如`Color`。给它一个默认值，例如蓝色或黑色。![如何操作...](img/00277.jpeg)
- en: Close the Material.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭材质。
- en: In **Content Browser**, right-click on the Material with the parameter in it,
    and select **Create Material Instance**.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**内容浏览器**中，右键单击具有参数的材质，并选择**创建材质实例**。
- en: Double-click on your Material instance. Check the box beside your `VectorParameter`
    name, and voila! Your `VectorParameter` is customizable without further affecting
    the base functionality of the Material.![How to do it...](img/00278.jpeg)
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击您的材质实例。勾选您的“VectorParameter”名称旁边的复选框，完成！您的“VectorParameter”可以自定义，而不会进一步影响材质的基本功能。![如何操作...](img/00278.jpeg)
- en: Further, if you change the base functionality of the Material, the Material
    instance will inherit those changes without needing any further configurations.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，如果您更改了材质的基本功能，材质实例将继承这些更改，而无需进行任何进一步的配置。
- en: How it works…
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Material Parameters allow you to edit the value of variables sent to a Material
    without editing the Material itself. In addition, you can also change a Material
    instance's values from C++ code quite easily. This is useful for things such as
    team colors, and the like.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 材质参数允许您编辑发送到材质的变量的值，而无需编辑材质本身。此外，您还可以轻松地从C++代码更改材质实例的值。这对于诸如团队颜色之类的事物非常有用。
- en: Glimmer
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闪烁
- en: Some shader functionality is easily accessible using the standard nodes inside
    the UE4 Material Editor. You can come up with some neat speckled effects, such
    as the glittering gold shader we show you how to construct in the following recipe.
    The purpose of this recipe is to familiarize you with the Material Editor's base
    functions so that you can learn to construct your own material shaders.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在UE4材质编辑器中使用标准节点，可以轻松访问一些着色器功能。您可以构建一些漂亮的斑点效果，例如我们在下一个示例中展示的闪闪发光的金色着色器。这个示例的目的是让您熟悉材质编辑器的基本功能，以便您可以学会构建自己的材质着色器。
- en: Getting ready
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create an asset (such as a treasure chest) that you want to glow, or open the
    the source code package of `Chapter11` to find the `treasureChest.fbx` model.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个您想要发光的资产（例如一个宝箱），或者打开`Chapter11`的源代码包以找到`treasureChest.fbx`模型。
- en: What we'll do is move a plane across the object of a certain thickness *W*.
    When the plane passes over the geometry, the emissive color channel is activated,
    and a glimmer effect is created across the treasure.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的是在物体上移动一个厚度为*W*的平面。当平面经过几何体时，发射颜色通道被激活，从而在宝藏上创建出闪烁效果。
- en: We expose several parameters to control the glimmer, including **Speed**, **Period**
    (time between glimmers), **Width**, **Gain**, **PlaneDirection**, and finally,
    **Color**.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们公开了几个参数来控制闪烁，包括**速度**，**周期**（闪烁之间的时间），**宽度**，**增益**，**平面方向**，最后是**颜色**。
- en: How to do it...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a new Material by right-clicking in the **Content Browser,** and selecting
    **Material**.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在**内容浏览器**中右键单击并选择**材质**来创建一个新的材质。
- en: Add input parameters to scale time as shown in the following image, pulling
    in a `Time` input, and making it periodic by calling `Fmod` with the period of
    time:![How to do it...](img/00279.jpeg)
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下图像所示添加输入参数，引入一个`Time`输入，并通过使用时间周期调用`Fmod`使其成为周期性的：![如何操作...](img/00279.jpeg)
- en: '`Fmod` with period will make time follow a sawtooth pattern. The value of time
    read will not increase past the **Period**, because we will keep kicking it down
    to 0 using the `fmod` operation.'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用周期的`Fmod`将使时间遵循锯齿形模式。读取的时间值不会超过**周期**，因为我们将使用`fmod`操作将其保持为0。
- en: Provide the `OnPlane` function in a separate file. The `OnPlane` function uses
    the Plane Equation *Ax + By + Cz + D = 0* to determine if an input point is on
    a plane or not. Pass the `LocalPosition` coordinates into the `OnPlane` function
    to determine if, in the given frame, this section should be highlighted with emissive
    glow in the geometry or not.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个单独的文件中提供`OnPlane`函数。`OnPlane`函数使用平面方程*Ax + By + Cz + D = 0*来确定输入点是否在平面上。将`LocalPosition`坐标传递到`OnPlane`函数中，以确定在给定帧中，是否应该在几何体中用发光突出显示此部分。
- en: How it works…
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: An imaginary plane of light passes through the geometry at the speed specified
    by speed, once every **Period** seconds. The plane starts at the corner of a bounding
    box, in the direction specified by **PlaneDirection**. The plane always starts
    at the corner of the box where it will pass through the entire volume when the
    plane is shifted forward with time.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一个想象中的光平面以指定的速度通过几何体。光平面每隔**周期**秒从一个边界框的角落开始，沿着**平面方向**指定的方向移动。当平面随时间向前移动时，它总是从盒子的角落开始，当平面通过整个体积时，它将通过整个体积。
- en: Leaves and Wind
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树叶和风
- en: In this recipe, we'll write a simple particle shader demonstrating how to create
    leaves in wind. We can do so using a **Particle Emitter** combined with a Material
    Shader that "shades" our leaves to give them the appearance of blowing in the
    wind.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将编写一个简单的粒子着色器，演示如何在风中创建树叶。我们可以使用一个**粒子发射器**结合一个材质着色器来实现这一点，通过"着色"我们的树叶，使它们看起来像在风中飘动。
- en: '![Leaves and Wind](img/00280.jpeg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![树叶和风](img/00280.jpeg)'
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To begin, you'll need a leaf texture as well as a scene in which to place the
    falling leaves. In the `Chapter11` code package, you'll find a scene called `LeavesAndTree`
    that contains a deciduous tree that you can use.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要一个树叶纹理以及一个放置落叶的场景。在`Chapter11`代码包中，您会找到一个名为`LeavesAndTree`的场景，其中包含一个落叶树，您可以使用它。
- en: How to do it...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a new particle emitter by right-clicking in the **Content Browser,**
    and choosing **Particle System**.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在**内容浏览器**中右键单击并选择**粒子系统**来创建一个新的粒子发射器。
- en: Construct a new Material shader by right-clicking in the **Content Browser**
    and choosing **Material**. Your leaf material should contain a texture of a leaf
    in the `BaseColor` component. We'll edit the **World Position** of the leaf in
    a later step to represent a jitter in motion represented by the wind.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在**内容浏览器**中右键单击并选择**材质**来构建一个新的材质着色器。您的叶子材质应该包含一个叶子的纹理在`BaseColor`组件中。我们将在后面的步骤中编辑叶子的**世界位置**，以表示由风引起的运动中的抖动。
- en: 'Add a couple of parameters to modify the Leaves particle emitter:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些参数来修改树叶粒子发射器：
- en: '**Spawn** should have a nice high rate of about 100.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**生成**应该有一个很高的速率，大约为100。'
- en: '**Initial Location** can be distributed in a cube of 100 units per side.'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**初始位置**可以在每边100个单位的立方体中分布。'
- en: '**Lifetime** can be 4-5 seconds.'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**生命周期**可以是4-5秒。'
- en: '**Initial Velocity** should be something like ranging from (-50,-50,-100) to
    (25,25,-10).'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**初始速度**应该是从(-50,-50,-100)到(25,25,-10)之间的某个值。'
- en: '**Initial Color** can be a distribution vector with values at green, yellow,
    and red.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**初始颜色**可以是一个分布向量，其值为绿色、黄色和红色。'
- en: '**Acceleration** can be (0,0,-20).'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**加速度**可以是(0,0,-20)。'
- en: '**Initial Rotation Rate** can be 0.25 (max).'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**初始旋转速率**可以是0.25（最大值）。'
- en: An **Orbit** parameter can be added with distribution (0,0,0) to (0,10,10).
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以添加一个带有分布（0,0,0）到（0,10,10）的**轨道**参数。
- en: '**Wind**: Create a **Material Parameter Collection** (**MPC**) by right-clicking
    anywhere in the blank space in **Content Browser** and selecting **New Material
    Parameter Collection**.'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**风**：通过在**内容浏览器**的空白处右键单击，然后选择**新建材质参数集合**，创建一个**材质参数集合**（**MPC**）。'
- en: Double-click to edit your new Material Parameter Collection, and enter a new
    parameter `TheWind`. Give it initial values of `(1, 1, 1)`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击编辑您的新材质参数集合，并输入一个新的参数`TheWind`。给它初始值`(1, 1, 1)`。
- en: In your level Blueprint (**Blueprints** | **Level Blueprint**), create a client-side
    variable called `TheWind`. We will send this variable down to the GPU in each
    frame after we change it locally at the CPU. Initialize the `TheWind` variable
    to `(1, 1, 1)` in event `BeginPlay`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的关卡蓝图（**蓝图** | **关卡蓝图**）中，创建一个名为`TheWind`的客户端变量。在事件`BeginPlay`中将`TheWind`变量初始化为`(1,
    1, 1)`，然后在每帧将此变量发送到GPU。
- en: In the Event `Tick`, modify the wind to your liking. In my version of the wind,
    I have multiplied the wind in each frame by a random vector with values between
    [-1,1] in three dimensions. This gives the wind a nice jittery look per-frame.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件“Tick”中，根据自己的喜好修改风力。在我的版本中，我将每帧的风力乘以一个三维随机向量，其值在[-1,1]之间。这样可以使风力每帧都有一个不错的颤动效果。
- en: Send the wind variable update down to the GPU by choosing a **Set Vector Parameter
    Value** node immediately after you modify the wind vector. The **Set Vector Parameter
    Value** must reference a variable inside a Material Parameter Collection, so reference
    `TheWind` variable inside the Material Parameter Collection that we created in
    *STEP 4*.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在修改风向量后立即选择一个**设置矢量参数值**节点，将风变量更新发送到GPU。**设置矢量参数值**必须引用材质参数集合内的变量，因此引用在*步骤4*中创建的材质参数集合内的`TheWind`变量。
- en: Modify `WorldPositionOffset` by some multiple of `TheWind` each frame. Since
    `TheWind` variable varies slowly, the modification presented in each frame will
    be a slight variation of the modification presented in the last frame, producing
    a smooth leaf motion.![How to do it...](img/00281.jpeg)
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过每帧修改`WorldPositionOffset`的`TheWind`的某个倍数。由于`TheWind`变量变化缓慢，每帧呈现的修改将是上一帧呈现的修改的轻微变化，从而产生平滑的叶子运动。![如何操作...](img/00281.jpeg)
- en: How it works…
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The leaves fall at more or less a constant rate with additional light gravity,
    but they are pulled around by a constantly varying wind vector inside the shader.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 叶子以大致恒定的速率下落，但受到着色器内部不断变化的风向量的牵引。
- en: Reflectance dependent on the viewing angle
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反射率取决于观察角度
- en: The tendency of the reflectance of a material to depend on the viewing angle
    is called the **Fresnel** effect. A material may be more specular from a grazing
    angle than from a head-on angle.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 材质的反射率依赖于观察角度的倾向被称为**Fresnel**效应。材质在接近水平角度时可能比在正对角度时更具镜面反射性。
- en: '![Reflectance dependent on the viewing angle](img/00282.jpeg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![反射率取决于观察角度](img/00282.jpeg)'
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Fresnel effect has magnitude at a grazing angle. This water material seen
    in the preceding screenshot has high specularity and opacity at a grazing angle
    due to use of the Fresnel effect.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Fresnel效果在接近水平角度时具有较大的幅度。由于使用了Fresnel效果，前面截图中的水材质在接近水平角度时具有较高的镜面反射和不透明度。
- en: UE4 has a specially built-in capability to account for this. We'll construct
    a water shader that has view-angle dependence for translucency to give an example
    of how to use the Fresnel effect realistically.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: UE4具有专门的内置功能来处理这个问题。我们将构建一个水材质，其中透明度具有视角依赖性，以便实际演示如何使用Fresnel效果。
- en: Getting ready
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need a new shader to which you want to add the Fresnel effect. Preferably,
    select a material that you want to look a bit different depending on the viewing
    angle.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个要添加Fresnel效果的新材质。最好选择一个在观察角度不同的情况下看起来有些不同的材质。
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Inside your material, drive a channel (either Opacity, Specularity, or a diffuse
    color) by the output of a Fresnel node.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在材质内部，通过Fresnel节点的输出来驱动一个通道（不透明度、镜面反射或漫反射颜色）。
- en: 'The Fresnel node''s parameters Exponent and Base Reflect Fraction can be adjusted
    as follows:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Fresnel节点的参数指数和基础反射分数可以调整如下：
- en: '**Exponent**: Describes how Fresnel the material is. Higher values here exaggerate
    the Fresnel effect.'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**指数**：描述材质的Fresnel程度。较高的值会夸大Fresnel效果。'
- en: '**Base Reflect Fraction**: Lower numbers exaggerate the Fresnel Effect. For
    a value of 1.0, the Fresnel effect will not manifest.'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**基础反射分数**：较低的数值会夸大Fresnel效果。对于值为1.0，Fresnel效果不会显现。'
- en: How it works…
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There is a fair bit of math behind implementing the Fresnel effect, but using
    it to drive a component in a material is fairly easy, and can help you come up
    with some very beautiful looking materials.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 实现Fresnel效果背后有很多数学知识，但在材质中使用它来驱动组件相对较简单，并且可以帮助您创建一些非常漂亮的材质。
- en: Randomness – Perlin noise
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随机性 - 柏林噪声
- en: Some shaders benefit from the ability to use random values. Each Material has
    a few nodes that can help add randomness to a shader. Randomness from a **Perlin**
    noise texture can be used to generate interesting-looking materials such as marbled
    materials. The noise can also be used to drive bump maps, height maps, and displacement
    fields for some neat effects.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一些着色器可以从使用随机值中受益。每个材质都有一些节点可以帮助给着色器添加随机性。可以使用**Perlin**噪声纹理的随机性来生成看起来有趣的材质，比如大理石材质。这种噪声还可以用于驱动凹凸贴图、高度贴图和位移场，产生一些炫酷的效果。
- en: Getting ready
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Choose a material to which you'd like to add some randomness. Open the Material
    in the Material Editor, and follow the steps.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个你想要添加一些随机性的材质。在材质编辑器中打开该材质，并按照以下步骤进行操作。
- en: How to do it...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Insert a **Noise** node into your Material Editor window.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个**Noise**节点插入到你的材质编辑器窗口中。
- en: Normalize the coordinates of the object you're adding the noise to. You can
    use math such as the following to do so:![How to do it...](img/00283.jpeg)
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对你要添加噪声的对象的坐标进行归一化。你可以使用以下数学公式来实现：![如何操作...](img/00283.jpeg)
- en: Subtract the minimum from each processed vertex in the system to take the object
    to sit at the origin.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从系统中的每个处理过的顶点中减去最小值，使对象位于原点。
- en: Divide the vertex by the size of the object to put the object in a unit box.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将顶点除以对象的大小，将对象放入一个单位盒子中。
- en: Multiply the vertex value by 2 to expand the unit box from 1x1 to 2x2.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将顶点值乘以2，将单位盒子从1x1扩展到2x2。
- en: Subtract 1 from the vertex values to move the unit to being centered in the
    origin with values from *[-1,-1,-1]* to *[+1,+1,+1]*.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将顶点值减去1，将单位移动到以原点为中心，值从*[-1,-1,-1]*到*[+1,+1,+1]*。
- en: Select a value from which to draw noise. Keep in mind that noise works extremely
    well with input values between ![How to do it...](img/00284.jpeg). Outside of
    this range, Perlin's noise starts to appear snowy when zoomed out (because there
    will be too much variation in the output values over your input *x*).
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个值来绘制噪声。请记住，噪声在输入值在![如何操作...](img/00284.jpeg)之间时效果非常好。在这个范围之外，Perlin噪声在缩小时会出现雪花状的外观（因为输出值在输入*x*上的变化太大）。
- en: How it works…
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Perlin's noise can help you produce some beautiful marbly textures and patterns.
    Besides using it in graphics, you can also use Perlin noise to drive motion and
    other phenomena in a natural looking way.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Perlin噪声可以帮助你产生一些美丽的大理石纹理和图案。除了在图形中使用它，你还可以使用Perlin噪声以一种自然的方式驱动运动和其他现象。
- en: Shading a Landscape
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给景观着色
- en: Landscape shaders are relatively easy to construct. They allow you to specify
    multi-texturing for a very large custom piece of geometry called a Landscape.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 构建景观着色器相对较容易。它们允许你为一个非常大的自定义几何体（称为景观）指定多重纹理。
- en: Getting ready
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Landscape objects are fantastic for use as a ground plane for your game world
    level. You can construct multiple landscapes in the same level using the Landscape
    tab. Access the Landscape palette in the **Modes** panel by clicking on the picture
    of a mountain, as shown in the following screenshot:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 景观对象非常适合用作游戏世界级别的地面平面。你可以使用景观选项卡在同一级别中构建多个景观。通过点击**模式**面板中的山的图片，访问**景观**调色板，如下图所示：
- en: '![Getting ready](img/00285.jpeg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/00285.jpeg)'
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Construct a new Landscape object by clicking on **Modes** | Landscape. Under
    the **New Landscape** heading, select the **Create New** radio button. You will
    see a green wireframe overlay proposing the new landscape. You can adjust its
    size using the **Section Size** and **Sections Per Component** settings.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**模式** | **景观**来构建一个新的景观对象。在**新景观**标题下，选择**创建新的**单选按钮。你将看到一个绿色的线框覆盖层，提供了新的景观。你可以使用**区块大小**和**每个组件的区块数**设置来调整其大小。
- en: Tip
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The landscape will tile the textures we select for it **Section Size** * **Sections
    Per Component** * **Number of Components** times when we finally texture. You
    can keep note of this number if you want to make the landscape texture tile fewer
    times—simply divide the UV coordinates fed to the textures by the number computed
    in the preceding line.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们最终进行纹理贴图时，景观将以**区块大小** * **每个组件的区块数** * **组件的数量**的倍数平铺所选的纹理。如果你想让景观纹理平铺次数更少，可以记下这个数字，然后将馈送给纹理的UV坐标除以前一行计算出的数字。
- en: Do not click on anything else in this dialog yet, as we still have to construct
    our Landscape Material. This is outlined in the following steps.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 暂时不要点击对话框中的其他任何内容，因为我们还需要构建我们的景观材质。这在以下步骤中进行了概述。
- en: Navigate to **Content Browser** and create a new Material for use by your landscape.
    Call it `LandscapeMaterial`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**内容浏览器**，为你的景观创建一个新的材质。将其命名为`LandscapeMaterial`。
- en: Edit your `LandscapeMaterial` by double-clicking on it. Right-click anywhere
    in the blank space and select a `LandscapeCoordinate` node to feed the UV coordinates
    through the textures that we're about to apply.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过双击编辑你的`LandscapeMaterial`。在空白处右键单击，选择一个`LandscapeCoordinate`节点，将UV坐标传递到我们即将应用的纹理中。
- en: To reduce the tiling on the Landscape, you'll need to divide the output of the
    `LandscapeCoordinate` node by the total size of the landscape (**Section Size**
    * **Sections Per Component** * **Number of Components**) (as described in a tip
    in *Step 1*)
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了减少景观上的平铺效果，你需要将`LandscapeCoordinate`节点的输出除以景观的总大小（**区块大小** * **每个组件的区块数**
    * **组件的数量**）（如*步骤1*中的提示所述）。
- en: Add a `LandscapeLayerBlend` node to the canvas. Lead the output of the node
    to the **Base Color** layer.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在画布上添加一个`LandscapeLayerBlend`节点。将节点的输出导向**基本颜色**图层。
- en: 'Click on the `LandscapeLayerBlend` node, and add a few Layers to the element
    in the **Details** tab. This will allow you to blend between the textures using
    **Texture Painting**. Name each, and select the method for blending from among
    the following options:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`LandscapeLayerBlend`节点，在**详细信息**选项卡中为元素添加几个图层。这将允许你使用**纹理绘制**来在纹理之间进行混合。为每个图层命名，并从以下选项中选择混合方法：
- en: By painted weight (LB Weight Blend).
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过绘制权重（LB权重混合）。
- en: By alpha value inside the texture (LB Alpha Blend).
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过纹理内的alpha值（LB Alpha混合）。
- en: By height (LB Height Blend).
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按高度（LB高度混合）。
- en: Set other parameters for each `LandscapeLayer` you're adding as you desire.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要设置每个添加的`LandscapeLayer`的其他参数。
- en: Feed in the textures, one for each layer of Landscape blend.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个景观混合层提供纹理。
- en: Reduce the specularity of the landscape to 0 by adding a constant 0 input to
    the Specular input.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将恒定的0输入添加到镜面输入中，将景观的高光减少到0。
- en: Save and close your material.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭您的材质。
- en: Go to the **Modes** | Landscape tab now, and select your newly created `LandscapeMaterial`
    in the drop-down menu.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转到**模式** | 景观选项卡，并在下拉菜单中选择您新创建的`LandscapeMaterial`。
- en: Under the **Layers** section, click on the **+** icon beside each of the Landscape
    layers that are available. Create and save a Target Layer object for each Landscape
    layer that you have.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**图层**部分，点击每个可用的景观图层旁边的**+**图标。为每个景观图层创建并保存一个目标图层对象。
- en: Finally, scroll down the Landscape tab, and click on the **Create** button.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，向下滚动到景观选项卡，点击**创建**按钮。
- en: Click on the Paint tab, select a brush size and a texture to paint with, and
    begin texture painting your landscape.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击绘画选项卡，选择画笔大小和纹理，开始绘制景观纹理。
- en: How it works…
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Landscape materials can be blended either by height, or by manual artistry,
    as shown in this recipe.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 景观材质可以通过高度或手工艺进行混合，如本教程所示。
