["```cpp\nauto aVector = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\nauto all_of_parallel = [&aVector](){\n    return all_of(execution::par, aVector.begin(), aVector.end(),  \n        [](auto value){return value > 5;});\n};\n```", "```cpp\nauto measureExecutionTimeForF = [](auto f){\n    auto t1 = high_resolution_clock::now();\n    f();\n    auto t2 = high_resolution_clock::now();\n    chrono::nanoseconds duration = t2 - t1;\n    return duration;\n};\n```", "```cpp\n// At the time when I created this file, only MSVC had implementation  \n    for execution policies.\n// Since you're seeing this in the future, you can enable the parallel \n    execution code by uncommenting the following line \n//#define PARALLEL_ENABLED\n```", "```cpp\nTEST_CASE(\"all_of with sequential execution policy\"){\n    auto aVector = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n    auto all_of_sequential = [&aVector](){\n        return all_of(execution::seq, aVector.begin(), aVector.end(), \n            [](auto value){return value > 5;});\n    };\n\n    auto sequentialDuration = \n        measureExecutionTimeForF(all_of_sequential);\n        cout << \"Execution time for sequential policy:\" << \n            sequentialDuration.count() << \" ns\" << endl;\n\n    auto all_of_parallel = [&aVector](){\n        return all_of(execution::par, aVector.begin(), aVector.end(), \n            [](auto value){return value > 5;});\n    };\n\n    auto parallelDuration = measureExecutionTimeForF(all_of_parallel);\n    cout << \"Execution time for parallel policy:\" <<   \n        parallelDuration.count() << \" ns\" << endl;\n}\n```", "```cpp\nfunction<long long(int, int)> power = [](auto base, auto exponent){\n    return pow(base, exponent);\n};\n```", "```cpp\ntuple<int, int> parameters\n```", "```cpp\n    map<tuple<int, int>, long long> cache;\n```", "```cpp\n    function<long long(int, int)> memoizedPower = [&cache](int base, \n        int exponent){\n            tuple<int, int> parameters(base, exponent);\n            auto valueIterator = cache.find(parameters);\n\n```", "```cpp\n        if(valueIterator == cache.end()){\n            result = pow(base, exponent);\n            cache[parameters] = result;\n        } else{\n            result = valueIterator -> second;\n        }\n        return result; \n```", "```cpp\n    CHECK_EQ(power(1, 1), memoizedPower(1, 1));\n    CHECK_EQ(power(3, 19), memoizedPower(3, 19));\n    CHECK_EQ(power(2, 25), memoizedPower(2, 25));\n```", "```cpp\n    function<long long(int, int)> power = [](int base, int exponent){\n        return pow(base, exponent);\n    };\n\n    map<tuple<int, int>, long long> cache;\n\n    function<long long(int, int)> memoizedPower = [&cache](int base, \n        int exponent){\n            tuple<int, int> parameters(base, exponent);\n            auto valueIterator = cache.find(parameters);\n            long long result;\n            if(valueIterator == cache.end()){\n result = pow(base, exponent);\n            cache[parameters] = result;\n        } else{\n            result = valueIterator -> second;\n        }\n        return result; \n    };\n```", "```cpp\n    function<long long(int, int)> memoizedPower = [&cache, &power](int \n        base, int exponent){\n            tuple<int, int> parameters(base, exponent);\n            auto valueIterator = cache.find(parameters);\n            long long result;\n            if(valueIterator == cache.end()){\n result = power(base, exponent);\n            cache[parameters] = result;\n        } else{\n            result = valueIterator -> second;\n        }\n        return result; \n    };\n```", "```cpp\n    auto memoize = [&cache](int base, int exponent, auto \n        functionToMemoize){\n            tuple<int, int> parameters(base, exponent);\n            auto valueIterator = cache.find(parameters);\n            long long result;\n            if(valueIterator == cache.end()){\n            result = functionToMemoize(base, exponent);\n            cache[parameters] = result;\n        } else{\n            result = valueIterator -> second;\n        }\n        return result; \n    };\n\n    CHECK_EQ(power(1, 1), memoize(1, 1, power));\n    CHECK_EQ(power(3, 19), memoize(3, 19, power));\n    CHECK_EQ(power(2, 25), memoize(2, 25, power));\n```", "```cpp\n    auto memoize = [](auto functionToMemoize){\n        map<tuple<int, int>, long long> cache;\n return [&](int base, int exponent) {\n            tuple<int, int> parameters(base, exponent);\n            auto valueIterator = cache.find(parameters);\n            long long result;\n            if(valueIterator == cache.end()){\n                result = functionToMemoize(base, exponent);\n                cache[parameters] = result;\n            } else{\n                result = valueIterator -> second;\n            }\n            return result; \n            };\n    };\n    auto memoizedPower = memoize(power);\n```", "```cpp\n    auto memoize = [](auto functionToMemoize){\n        map<tuple<int, int>, long long> cache;\n return [=](int base, int exponent) mutable {\n            tuple<int, int> parameters(base, exponent);\n            auto valueIterator = cache.find(parameters);\n            long long result;\n            if(valueIterator == cache.end()){\n                result = functionToMemoize(base, exponent);\n                cache[parameters] = result;\n            } else{\n                result = valueIterator -> second;\n            }\n            return result; \n            };\n    };\n```", "```cpp\ntemplate<typename ReturnType, typename FirstArgType, typename \n    SecondArgType>\nauto memoizeTwoParams = [](function<ReturnType(FirstArgType, SecondArgType)> functionToMemoize){\n    map<tuple<FirstArgType, SecondArgType>, ReturnType> cache;\n    return [=](FirstArgType firstArg, SecondArgType secondArg) mutable {\n        tuple<FirstArgType, SecondArgType> parameters(firstArg, \n    secondArg);\n        auto valueIterator = cache.find(parameters);\n        ReturnType result;\n        if(valueIterator == cache.end()){\n            result = functionToMemoize(firstArg, secondArg);\n            cache[parameters] = result;\n        } else{\n            result = valueIterator -> second;\n        }\n        return result; \n    };\n};\n```", "```cpp\ntemplate<typename ReturnType, typename... Args>\nfunction<ReturnType(Args...)> memoize(function<ReturnType(Args...)> f){\n    map<tuple<Args...>, ReturnType> cache;\n    return ([=](Args... args) mutable  {\n            tuple<Args...> theArguments(args...);\n            auto cached = cache.find(theArguments);\n            if(cached != cache.end()) return cached -> second;\n            auto result = f(args...);\n            cache[theArguments] = result;\n            return result;\n    });\n};\n```", "```cpp\nfunction<long long(int, int)> power = [&](auto base, auto exponent) \n{\n    return (exponent == 0) ? 1 : base * power(base, exponent - 1);\n};\n```", "```cpp\nTEST_CASE(\"Pow vs memoized pow\"){\n    function<int(int, int)> power = [](auto first, auto second){\n        return pow(first, second);\n    };\n\n    cout << \"Computing pow\" << endl;\n    printDuration(\"First call no memoization: \",  [&](){ return \n        power(5, 24);});\n    printDuration(\"Second call no memoization: \", [&](){return power(3, \n        1024);});\n    printDuration(\"Third call no memoization: \", [&](){return power(9, \n        176);});\n    printDuration(\"Fourth call no memoization (same as first call): \", \n        [&](){return power(5, 24);});\n\n    auto powerWithMemoization = memoize(power);\n    printDuration(\"First call with memoization: \",  [&](){ return \n        powerWithMemoization(5, 24);});\n    printDuration(\"Second call with memoization: \", [&](){return \n        powerWithMemoization(3, 1024);});\n    printDuration(\"Third call with memoization: \", [&](){return \n        powerWithMemoization(9, 176);});\n    printDuration(\"Fourth call with memoization (same as first call): \n        \", [&](){return powerWithMemoization(5, 24);});\n    cout << \"DONE computing pow\" << endl;\n\n    CHECK_EQ(power(5, 24),  powerWithMemoization(5, 24));\n    CHECK_EQ(power(3, 1024),  powerWithMemoization(3, 1024));\n    CHECK_EQ(power(9, 176),  powerWithMemoization(9, 176));\n}\n```", "```cpp\nComputing pow\nFirst call no memoization: 26421 ns\nSecond call no memoization: 5207 ns\nThird call no memoization: 2058 ns\nFourth call no memoization (same as first call): 179 ns\nFirst call with memoization: 2380 ns\nSecond call with memoization: 2207 ns\nThird call with memoization: 1539 ns\nFourth call with memoization (same as first call): 936 ns\nDONE computing pow\n\n```", "```cpp\nFirst call: 26421 ns > 2380 ns\nSecond call: 5207 ns > 2207 ns\nThird call: 2058 ns > 1539 ns\nFourth call: 179 ns < 936 ns\n```", "```cpp\n    map<tuple<int, int>, long long> cache;\n    function<long long(int, int)> powerWithMemoization = [&](auto base, \n        auto exponent) -> long long{\n            if(exponent == 0) return 1;\n            long long value;\n\n            tuple<int, int> parameters(base, exponent);\n            auto valueIterator = cache.find(parameters);\n            if(valueIterator == cache.end()){\n            value = base * powerWithMemoization(base, exponent - 1);\n            cache[parameters] = value;\n            } else {\n            value = valueIterator->second;\n        };\n        return value;\n    };\n```", "```cpp\nComputing pow\nFirst call no memoization: 1761 ns\nSecond call no memoization: 106994 ns\nThird call no memoization: 8718 ns\nFourth call no memoization (same as first call): 1395 ns\nFirst call with recursive memoization: 30921 ns\nSecond call with recursive memoization: 2427337 ns\nThird call with recursive memoization: 482062 ns\nFourth call with recursive memoization (same as first call): 1721 ns\nDONE computing pow\n```", "```cpp\nFirst call: 1761 ns < 30921 ns\nSecond call: 106994 ns < 2427337 ns\nThird call: 8718 ns < 482062 ns\nFourth call: 1395 ns < 1721 ns\n```", "```cpp\nTEST_CASE(\"Factorial difference vs memoized\"){\n    function<int(int)> fact = [&fact](int n){\n        if(n == 0) return 1;\n        return n * fact(n-1);\n    };\n\n    function<int(int, int)> factorialDifference = [&fact](auto first, \n        auto second){\n            return fact(second) - fact(first);\n    };\n    cout << \"Computing factorial difference\" << endl;\n    printDuration(\"First call no memoization: \",  [&](){ return \n        factorialDifference(5, 24);});\n    printDuration(\"Second call no memoization: \", [&](){return \n        factorialDifference(3, 1024);});\n    printDuration(\"Third call no memoization: \", [&](){return \n        factorialDifference(9, 176);});\n    printDuration(\"Fourth call no memoization (same as first call): \", \n        [&](){return factorialDifference(5, 24);});\n\n    auto factWithMemoization = memoize(fact);\n    function<int(int, int)> factorialMemoizedDifference = \n        [&factWithMemoization](auto first, auto second){\n        return factWithMemoization(second) - \n            factWithMemoization(first);\n    };\n    printDuration(\"First call with memoized factorial: \",  [&](){ \n        return factorialMemoizedDifference(5, 24);});\n    printDuration(\"Second call with memoized factorial: \", [&](){return \n        factorialMemoizedDifference(3, 1024);});\n    printDuration(\"Third call with memoized factorial: \", [&](){return \n        factorialMemoizedDifference(9, 176);});\n    printDuration(\"Fourth call with memoized factorial (same as first \n        call): \", [&](){return factorialMemoizedDifference(5, 24);});\n\n    auto factorialDifferenceWithMemoization = \n        memoize(factorialDifference);\n    printDuration(\"First call with memoization: \",  [&](){ return \n        factorialDifferenceWithMemoization(5, 24);});\n    printDuration(\"Second call with memoization: \", [&](){return \n        factorialDifferenceWithMemoization(3, 1024);});\n    printDuration(\"Third call with memoization: \", [&](){return \n        factorialDifferenceWithMemoization(9, 176);});\n    printDuration(\"Fourth call with memoization (same as first call): \n        \", [&](){return factorialDifferenceWithMemoization(5, 24);});\n\n    cout << \"DONE computing factorial difference\" << endl;\n\n    CHECK_EQ(factorialDifference(5, 24),  \n        factorialMemoizedDifference(5, 24));\n    CHECK_EQ(factorialDifference(3, 1024),  \n        factorialMemoizedDifference(3, 1024));\n    CHECK_EQ(factorialDifference(9, 176),        \n        factorialMemoizedDifference(9, 176));\n\n    CHECK_EQ(factorialDifference(5, 24),  \n        factorialDifferenceWithMemoization(5, 24));\n    CHECK_EQ(factorialDifference(3, 1024),  \n        factorialDifferenceWithMemoization(3, 1024));\n    CHECK_EQ(factorialDifference(9, 176),  \n        factorialDifferenceWithMemoization(9, 176));\n}\n```", "```cpp\nComputing factorial difference\nFirst call no memoization: 1727 ns\nSecond call no memoization: 79908 ns\nThird call no memoization: 8037 ns\nFourth call no memoization (same as first call): 1539 ns\nFirst call with memoized factorial: 4672 ns\nSecond call with memoized factorial: 41183 ns\nThird call with memoized factrorial: 10029 ns\nFourth call with memoized factorial (same as first call): 1105 ns\n```", "```cpp\nFirst call: 1727 ns < 4672 ns\nSecond call: 79908 ns > 41183 ns\nThird call: 8037 ns < 10029 ns\nFourth call: 1539 ns > 1105 ns\n```", "```cpp\nFirst call no memoization: 1727 ns\nSecond call no memoization: 79908 ns\nThird call no memoization: 8037 ns\nFourth call no memoization (same as first call): 1539 ns\nFirst call with memoization: 2363 ns\nSecond call with memoization: 39700 ns\nThird call with memoization: 8678 ns\nFourth call with memoization (same as first call): 704 ns\n```", "```cpp\nFirst call: 1727 ns < 2363 ns\nSecond call: 79908 ns > 39700 ns\nThird call: 8037 ns < 8678 ns\nFourth call: 1539 ns > 704 ns\n```", "```cpp\n    map<int, int> cache;\n    function<int(int)> recursiveMemoizedFactorial = \n        [&recursiveMemoizedFactorial, &cache](int n) mutable{\n        auto value = cache.find(n); \n        if(value != cache.end()) return value->second;\n        int result;\n\n        if(n == 0) \n            result = 1;\n        else \n            result = n * recursiveMemoizedFactorial(n-1);\n\n        cache[n] = result;\n        return result;\n    };\n```", "```cpp\n    function<int(int, int)> factorialMemoizedDifference =  \n        [&recursiveMemoizedFactorial](auto first, auto second){\n                return recursiveMemoizedFactorial(second) -  \n                    recursiveMemoizedFactorial(first);\n    };\n```", "```cpp\nComputing factorial difference\nFirst call no memoization: 1367 ns\nSecond call no memoization: 58045 ns\nThird call no memoization: 16167 ns\nFourth call no memoization (same as first call): 1334 ns\nFirst call with recursive memoized factorial: 16281 ns\nSecond call with recursive memoized factorial: 890056 ns\nThird call with recursive memoized factorial: 939 ns\nFourth call with recursive memoized factorial (same as first call): 798 ns \n```", "```cpp\nFirst call: 1,367 ns < 16,281 ns\nSecond call: 58,045 ns < 890,056 ns Third call: 16,167 ns > 939 ns Fourth call: 1,334 ns > 798 ns\n```", "```cpp\n    function<int(int)> fact = [&fact](int n){\n        if(n == 0) return 1;\n        return n * fact(n-1);\n    };\n```", "```cpp\nStack content fact(1024)\n1024 * fact(1023)\n1023 * fact(1022)\n...\n1 * fact(0)\nfact(0) = 1 => unwind the stack\n```", "```cpp\n    function<int(int)> fact = [&fact](int n){\n        if(n == 0) return 1;\n        return n * (n-1) * (n-1-1) * (n-1-1-1) * ... * fact(0);\n    };\n```", "```cpp\nTEST_CASE(\"Factorial\"){\n    function<int(int)> fact = [&fact](int n){\n        if(n == 0) return 1;\n        return n * fact(n-1);\n    };\n\n    printDuration(\"Duration for 0!: \", [&](){return fact(0);});\n    printDuration(\"Duration for 1!: \", [&](){return fact(1);});\n    printDuration(\"Duration for 10!: \", [&](){return fact(10);});\n    printDuration(\"Duration for 100!: \", [&](){return fact(100);});\n    printDuration(\"Duration for 1024!: \", [&](){return fact(1024);});\n}\n```", "```cpp\nDuration for 0!: 210 ns\nDuration for 1!: 152 ns\nDuration for 10!: 463 ns\nDuration for 100!: 10946 ns\nDuration for 1024!: 82683 ns\n```", "```cpp\nDuration for 0!: 209 ns\nDuration for 1!: 152 ns\nDuration for 10!: 464 ns\nDuration for 100!: 6455 ns\nDuration for 1024!: 75602 ns\n```", "```cpp\nDuration for 0!: 210 ns > 209 ns\nDuration for 1!: 152 ns  = 152 ns\nDuration for 10!: 463 ns < 464 ns\nDuration for 100!: 10946 ns > 6455 ns\nDuration for 1024!: 82683 ns > 75602 ns\n```", "```cpp\nDuration for 0!: 128 ns\nDuration for 1!: 96 ns\nDuration for 10!: 96 ns\nDuration for 100!: 405 ns\nDuration for 1024!: 17249 ns\n```", "```cpp\nDuration for 0!: 209 ns > 128 ns\nDuration for 1!: 152 ns > 96 ns\nDuration for 10!: 464 ns > 96 ns\nDuration for 100!: 6455 ns > 405 ns\nDuration for 1024!: 75602 ns > 17249 ns\n```", "```cpp\n    function<int(int)> fact = [&fact](int n){\n        return (n == 0) ? 1 : (n * fact(n-1));\n    };\n```", "```cpp\nDuration for 0!: 633 ns\nDuration for 1!: 561 ns\nDuration for 10!: 1441 ns\nDuration for 100!: 20407 ns\nDuration for 1024!: 215600 ns\n```", "```cpp\nDuration for 0!: 277 ns\nDuration for 1!: 214 ns\nDuration for 10!: 578 ns\nDuration for 100!: 9573 ns\nDuration for 1024!: 81182 ns\n```", "```cpp\nDuration for 0!: 633 ns > 277 ns\nDuration for 1!: 561 ns > 214 ns\nDuration for 10!: 1441 ns > 578 ns\nDuration for 100!: 20407 ns > 9573 ns\nDuration for 1024!: 75602 ns > 17249 ns\n```", "```cpp\n    function<int(int)> f2;\n    function<int(int)> f1 = [&f2](int n){\n        return (n == 0) ? 1 : (n * f2(n-1));\n    };\n\n    f2 = [&f1](int n){\n        return (n == 0) ? 2 : (f1(n) + f1(n-1));\n    };\n```", "```cpp\n    printDuration(\"Duration for f1(0): \", [&](){return f1(0);});\n    printDuration(\"Duration for f1(1): \", [&](){return f1(1);});\n    printDuration(\"Duration for f1(2): \", [&](){return f1(2);});\n    printDuration(\"Duration for f1(3): \", [&](){return f1(3);});\n    printDuration(\"Duration for f1(4): \", [&](){return f1(4);});\n    printDuration(\"Duration for f1(5): \", [&](){return f1(5);});\n    printDuration(\"Duration for f1(6): \", [&](){return f1(6);});\n    printDuration(\"Duration for f1(7): \", [&](){return f1(7);});\n    printDuration(\"Duration for f1(8): \", [&](){return f1(8);});\n```", "```cpp\nDuration for f1(0): 838 ns\nDuration for f1(1): 825 ns\nDuration for f1(2): 1218 ns\nDuration for f1(3): 1515 ns\nDuration for f1(4): 2477 ns\nDuration for f1(5): 3919 ns\nDuration for f1(6): 5809 ns\nDuration for f1(7): 9354 ns\nDuration for f1(8): 14884 ns\n```", "```cpp\nDuration for f1(0): 206 ns\nDuration for f1(1): 327 ns\nDuration for f1(2): 467 ns\nDuration for f1(3): 642 ns\nDuration for f1(4): 760 ns\nDuration for f1(5): 1155 ns\nDuration for f1(6): 2023 ns\nDuration for f1(7): 3849 ns\nDuration for f1(8): 4986 ns\n```", "```cpp\nf1(0): 838 ns > 206 ns\nf1(1): 825 ns > 327 ns\nf1(2): 1218 ns > 467 ns\nf1(3): 1515 ns > 642 ns\nf1(4): 2477 ns > 760 ns\nf1(5): 3919 ns > 1155 ns\nf1(6): 5809 ns > 2023 ns\nf1(7): 9354 ns > 3849 ns\nf1(8): 14884 ns > 4986 ns\n```", "```cpp\n    promise<string> secretMessagePromise;\n```", "```cpp\n    future<string> secretMessageFuture = \n        secretMessagePromise.get_future();\n    thread isPrimeThread(printSecretMessage, ref(secretMessageFuture));\n```", "```cpp\n    secretMessagePromise.set_value(\"It's a secret\");\n    isPrimeThread.join();\n```", "```cpp\nauto printSecretMessage = [](future<string>& secretMessageFuture) {\n    string secretMessage = secretMessageFuture.get();\n    cout << \"The secret message: \" << secretMessage << '\\n';\n};\n```", "```cpp\nauto is_prime = [](int x) {\n    auto xIsDivisibleBy = bind(isDivisibleBy, x, _1);\n    return none_of_collection(\n            rangeFrom2To(x - 1), \n            xIsDivisibleBy\n        );\n};\n```", "```cpp\nauto rangeFromTo = [](const int start, const int end){\n    vector<int> aVector(end);\n    iota(aVector.begin(), aVector.end(), start);\n    return aVector;\n};\n```", "```cpp\nauto rangeFrom2To = bind(rangeFromTo, 2, _1);\n```", "```cpp\nauto isDivisibleBy = [](auto value, auto factor){\n    return value % factor == 0;\n};\n```", "```cpp\n    future<bool> futureIsPrime(async(is_prime, 2597));\n```", "```cpp\nTEST_CASE(\"Future with async\"){\n    future<bool> futureIsPrime(async(is_prime, 7757));\n    cout << \"doing stuff ...\" << endl;\n bool result = futureIsPrime.get();\n\n    CHECK(result);\n}\n```", "```cpp\nTEST_CASE(\"more futures\"){\n    future<bool> future1(async(is_prime, 2));\n    future<bool> future2(async(is_prime, 27));\n    future<bool> future3(async(is_prime, 1977));\n    future<bool> future4(async(is_prime, 7757));\n\n    CHECK(future1.get());\n    CHECK(!future2.get());\n    CHECK(!future3.get());\n    CHECK(future4.get());\n}\n```", "```cpp\n    vector<int> values{2, 27, 1977, 7757};\n    vector<bool> expectedResults{true, false, false, true};\n```", "```cpp\n    vector<future<bool>> futures;\n    for(auto value : values){\n        futures.push_back(async(is_prime, value));\n    }\n```", "```cpp\n    vector<bool> results;\n    for(auto& future : futures){\n        results.push_back(future.get());\n    }\n```", "```cpp\nTEST_CASE(\"more futures with loops\"){\n    vector<int> values{2, 27, 1977, 7757};\n    vector<bool> expectedResults{true, false, false, true};\n\n    vector<future<bool>> futures;\n    for(auto value : values){\n        futures.push_back(async(is_prime, value));\n    }\n\n    vector<bool> results;\n    for(auto& future : futures){\n        results.push_back(future.get());\n    }\n\n    CHECK_EQ(results, expectedResults);\n}\n```", "```cpp\n    auto makeFuture = [](auto value){\n        return async(is_prime, value);\n    };\n```", "```cpp\n    vector<future<bool>> futures = transformAll<vector<future<bool>>>\n       (values, makeFuture);\n```", "```cpp\n    vector<bool> results(values.size());\n    transform(futures.begin(), futures.end(), results.begin(), []\n        (future<bool>& future){ return future.get();});\n```", "```cpp\nTEST_CASE(\"more futures functional\"){\n    vector<int> values{2, 27, 1977, 7757};\n\n    auto makeFuture = [](auto value){\n        return async(is_prime, value);\n    };\n\n    vector<future<bool>> futures = transformAll<vector<future<bool>>>\n        (values, makeFuture);\n    vector<bool> results(values.size());\n    transform(futures.begin(), futures.end(), results.begin(), []\n        (future<bool>& future){ return future.get();});\n\n    vector<bool> expectedResults{true, false, false, true};\n\n    CHECK_EQ(results, expectedResults);\n}\n```", "```cpp\nauto printIsPrime = [](int value){\n    cout << value << (is_prime(value) ? \" is prime\" : \" is not prime\")  \n    << endl;\n};\n```", "```cpp\nint main(){\n    int number;\n\n    while(true){\n        cin >> number;\n        async(printIsPrime, number);\n    }\n}\n```", "```cpp\n23423\n23423 is not prime\n453576\n453576 is not prime\n53\n53 is prime\n2537\n2537 is not prime\n364544366\n5347\n54\n534532\n436\n364544366 is not prime\n5347 is prime\n54 is not prime\n534532 is not prime\n436 is not prime\n```", "```cpp\ntemplate<typename DestinationType>\nauto transformAll = [](const auto source, auto lambda){\n    DestinationType result;\n    transform(source.begin(), source.end(), back_inserter(result), \n        lambda);\n    return result;\n};\n\nTEST_CASE(\"Memory\"){\n    vector<long long> manyNumbers(size);\n    fill_n(manyNumbers.begin(), size, 1000L);\n\n    auto result = transformAll<vector<long long>>(manyNumbers, \n        increment);\n\n    CHECK_EQ(result[0], 1001);\n}\n```", "```cpp\nconst long size_1GB_64Bits = 125000000;\nTEST_CASE(\"Memory\"){\n    auto size = size_1GB_64Bits;\n    vector<long long> manyNumbers(size);\n    fill_n(manyNumbers.begin(), size, 1000L);\n\n    auto result = transformAll<vector<long long>>(manyNumbers, \n        increment);\n\n    CHECK_EQ(result[0], 1001);\n}\n```", "```cpp\nmemoryConsumptionNoMoveIterator: .outputFolder \n    g++ -DNO_MOVE_ITERATOR -std=c++17 memoryOptimization.cpp -Wall -\n        Wextra -Werror -o out/memoryOptimization\n    ./runWithMemoryConsumptionMonitoring memoryNoMoveIterator.log\n```", "```cpp\ntemplate<typename DestinationType>\nauto transformAll = [](const auto& source, auto lambda){\n    DestinationType result;\n    result.resize(source.size());\n    transform(source.begin(), source.end(), result.begin(), lambda);\n    return result;\n};\n```", "```cpp\nTEST_CASE(\"Memory\"){\n    auto size = size_1GB_64Bits;\n    vector<long long> manyNumbers(size);\n    fill_n(manyNumbers.begin(), size, 1000L);\n\n    for(auto iter = manyNumbers.begin(); iter != manyNumbers.end(); \n        ++iter){\n            ++(*iter);\n    };\n\n    CHECK_EQ(manyNumbers[0], 1001);\n}\n```", "```cpp\nauto increment = [](const auto value){\n    return value + 1;\n};\n\nauto transformAllInPlace = [](auto& source, auto lambda){\n    transform(source.begin(), source.end(), source.begin(), lambda);\n};\n\nTEST_CASE(\"Memory\"){\n    auto size = size_1GB_64Bits;\n    vector<long long> manyNumbers(size);\n    fill_n(manyNumbers.begin(), size, 1000L);\n\n    transformAllInPlace(manyNumbers, increment);\n\n    CHECK_EQ(manyNumbers[0], 1001);\n}\n```", "```cpp\ntemplate<typename SourceType>\nauto transformAllInPlace = [](auto& source, auto lambda) -> SourceType&& {\n    transform(source.begin(), source.end(), source.begin(), lambda);\n    return move(source);\n};\n```", "```cpp\nTEST_CASE(\"Memory\"){\n    auto size = size_1GB_64Bits;\n    vector<long long> manyNumbers(size);\n    fill_n(manyNumbers.begin(), size, 1000L);\n\n    auto result = transformAllInPlace<vector<long long>>(manyNumbers, \n        increment);\n\n    CHECK_EQ(result[0], 1001);\n}\n```", "```cpp\ntemplate<typename DestinationType>\nauto transformAllWithMoveIterator = [](auto& source, auto lambda){\n    DestinationType result(source.size());\n    transform(make_move_iterator(source.begin()), \n        make_move_iterator(source.end()), result.begin(), lambda);\n    source.clear();\n    return result;\n};\n```", "```cpp\nTEST_CASE(\"Memory\"){\n    auto size = size_1GB_64Bits;\n    vector<long long> manyNumbers(size);\n    fill_n(manyNumbers.begin(), size, 1000L);\n\n    auto result = transformAllWithMoveIterator<vector<long long>>\n        (manyNumbers, increment);\n\n    CHECK_EQ(result[0], 1001);\n}\n```", "```cpp\nTEST_CASE(\"Check immutable vector\"){\n    const auto empty = immer::vector<int>{};\n    const auto withOneElement = empty.push_back(42);\n\n    CHECK_EQ(0, empty.size());\n    CHECK_EQ(1, withOneElement.size());\n    CHECK_EQ(42, withOneElement[0]);\n}\n```"]