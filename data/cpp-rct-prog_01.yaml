- en: Reactive Programming Model – Overview and History
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式编程模型-概述和历史
- en: 'The X Windows system, Microsoft Windows, and IBM OS/2 Presentation Manager
    made GUI programming popular on the PC platform. This was a major shift from the
    character mode user interface and batch process style programming models that
    existed before them. Responding to events became a major concern for software
    developers worldwide and platform vendors resorted to the creation of low-level
    C-based APIs that relied on function pointers and callbacks to enable programmers
    to handle the events. The programming models were mostly based on the co-operative
    multithreaded model, and with the advent of better microprocessors, most platforms
    began to support pre-emptive multithreading. Handling events (and other asynchronous
    tasks) became more complex and responding to events in the traditional way became
    less scalable. Even though excellent C++-based GUI toolkits made their appearance,
    event handling was done mostly using message IDs, function pointer based dispatches,
    and other low-level techniques. A prominent compiler vendor even tried adding
    language extensions to the C++ language to enable better Windows programming.
    Handling events, asynchrony, and associated issues require a fresh look at the
    problem. Luckily, the Modern C++ standard has support for Functional Programming,
    language-level concurrency (with a memory model), and better memory management
    techniques to enable programmers to work with asynchronous data streams (by treating
    events as streams). This is achieved using a programming model called reactive
    programming. To put things in perspective, this chapter will outline the following
    topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: X Windows系统、Microsoft Windows和IBM OS/2 Presentation Manager使得GUI编程在PC平台上变得流行。这是从字符模式用户界面和批处理式编程模型到他们之前存在的重大转变。对事件的响应成为全球软件开发人员的主要关注点，平台供应商转而创建了基于低级C的API，依赖于函数指针和回调来使程序员能够处理事件。编程模型大多基于合作式多线程模型，并随着更好的微处理器的出现，大多数平台开始支持抢占式多线程。处理事件（和其他异步任务）变得更加复杂，以传统方式响应事件变得不太可扩展。尽管出现了出色的基于C++的GUI工具包，事件处理大多是使用消息ID、函数指针分发和其他低级技术来完成的。甚至一家知名的编译器供应商尝试添加C++语言的语言扩展来实现更好的Windows编程。处理事件、异步性和相关问题需要重新审视问题。幸运的是，现代C++标准支持函数式编程、语言级并发（带有内存模型）和更好的内存管理技术，使程序员能够处理异步数据流（将事件视为流）的编程模型称为反应式编程。为了让事情更清晰，本章将概述以下主题：
- en: Event-driven programming model and how it has been implemented in various platforms.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件驱动编程模型及其在各种平台上的实现。
- en: What is reactive programming?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是反应式编程？
- en: Different models of reactive programming.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式编程的不同模型。
- en: Some simple programs to make conceptual understanding better.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些简单的程序以更好地理解概念。
- en: The philosophy of our book.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们书的理念。
- en: Event-driven programming model
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件驱动编程模型
- en: Event-driven programming is a programming model where flow control is determined
    by events. Examples of events are mouse clicks, key presses, gestures, sensor
    data, messages from other programs, and so on. An event-driven application has
    the mechanism to detect events on a near real-time basis, and respond or react
    to them by invoking the appropriate event handling procedure. Since the bulk of
    the earlier event processing programs were written using C/C++, they resorted
    to low-level techniques such as callbacks (using function pointers) to write those
    event handlers. Later systems such as Visual Basic, Delphi, and other rapid application
    development tools did add native support for event-driven programming. To make
    matters more clear, we will take a tour of the event handling mechanism of the
    various platforms. This will help readers appreciate the issues that reactive
    programming models are solving (from a GUI programming context).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动编程是一种编程模型，其中流程控制由事件决定。事件的例子包括鼠标点击、按键、手势、传感器数据、来自其他程序的消息等等。事件驱动应用程序具有在几乎实时基础上检测事件并通过调用适当的事件处理过程来响应或反应的机制。由于早期的事件处理程序大多使用C/C++编写，它们采用低级技术，如回调（使用函数指针）来编写这些事件处理程序。后来的系统，如Visual
    Basic、Delphi和其他快速应用程序开发工具确实增加了对事件驱动编程的本地支持。为了更清楚地阐明问题，我们将介绍各种平台的事件处理机制。这将帮助读者理解反应式编程模型解决的问题（从GUI编程的角度）。
- en: Reactive programming treats data as streams and events in windowing systems
    can be treated as streams to be processed in a uniform manner. The Reactive programming
    model provides support for gathering events from different sources as streams,
    filtering streams, the transformation of streams, performing actions on streams,
    and so on. The programming model handles asynchrony, scheduling details as part
    of the framework. This chapter is mostly based on the key data structures of the
    Reactive programming model and how we can implement basic Reactive programs. In
    an industrial-strength reactive program, the code written will be asynchronous
    and the examples from this chapter are synchronous. We give the necessary background
    information and language constructs in the following chapters before out of order
    execution and schedules are discussed. These implementations are here for elucidation
    and can be treated as learning examples.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式编程将数据视为流和窗口系统中的事件可以被视为流以便以统一的方式进行处理。反应式编程模型支持从不同来源收集事件作为流，过滤流，转换流，对流执行操作等。编程模型处理异步性，调度细节作为框架的一部分。本章主要基于反应式编程模型的关键数据结构以及我们如何实现基本的反应式程序。在工业强度的反应式程序中，编写的代码将是异步的，而本章的示例是同步的。在讨论乱序执行和调度之前，我们在接下来的章节中提供必要的背景信息和语言构造。这些实现是为了阐明问题，并可以作为学习示例。
- en: Event-driven programming on X Windows
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: X Windows上的事件驱动编程
- en: 'The X Windows programming model is a cross-platform API, is mostly supported
    on POSIX systems, and has even been ported to Microsoft Windows. In fact, X is
    a network windowing protocol, which required a Window manager to manage the Windows
    stack. The screen contents are managed by the X server and the client library
    will pull the contents and display them on the local machine. In desktop environments,
    the server runs locally on the same machine. The following program will help the
    reader understand the gist of the XLib programming model and how events are handled
    in the platform:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: X Windows编程模型是一个跨平台API，在POSIX系统上得到了广泛支持，甚至已经移植到了Microsoft Windows。事实上，X是一个网络窗口协议，需要一个窗口管理器来管理窗口堆栈。屏幕内容由X服务器管理，客户端库将内容拉取并在本地机器上显示。在桌面环境中，服务器在同一台机器上本地运行。以下程序将帮助读者了解XLib编程模型的要点以及平台上如何处理事件：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code snippet includes the proper header files that a programmer
    is supposed to include to get the function prototypes provided by the XLib C library.
    There are some data structures that a programmer should be aware of while writing
    XLib programs from scratch. Nowadays, people use libraries such as Qt, WxWidgets,
    Gtk+, Fox toolkit, and so on to write commercial-quality X Programs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段包括了程序员应该包含的正确的头文件，以获取XLib C库提供的函数原型。在从头开始编写XLib程序时，程序员应该了解一些数据结构。如今，人们使用诸如Qt、WxWidgets、Gtk+、Fox
    toolkit等库来编写商业质量的X程序。
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code snippet initializes the server and creates a window to certain
    specifications. Traditionally, most X Windows programs run under a window manager
    that manages the cascading windows. We selected the messages that are of interest
    to us by invoking the `XSelectInput` API call before displaying the window:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段初始化了服务器并根据特定规格创建了一个窗口。传统上，大多数X Windows程序在管理级窗口下运行。我们通过在显示窗口之前调用`XSelectInput`
    API来选择我们感兴趣的消息：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, the program goes to an infinite loop while polling for any events, and
    the appropriate Xlib API will be used to draw a string on the Window. In Windowing
    parlance, it is called a **message** loop. The retrieval of events will be done
    by the `XNextEvent` API call:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，程序进入一个无限循环，同时轮询任何事件，并使用适当的Xlib API在窗口上绘制字符串。在窗口术语中，这被称为**消息**循环。事件的检索将通过`XNextEvent`
    API调用来完成：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once we are out of the infinite message loop, the connection to the server will
    be closed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们退出无限消息循环，与服务器的连接将被关闭。
- en: Event-driven programming on Microsoft Windows
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微软Windows上的事件驱动编程
- en: 'Microsoft Corporation created a GUI programming model, which can be considered
    as the most successful windowing system in the world. The third edition of the
    Windows software was a runaway success (in 1990) and Microsoft followed this with
    the Windows NT and Windows 95/98/ME series. Let us look at the event-driven programming
    model of Microsoft Windows (consult Microsoft documentation for a detailed look
    at how this programming model works). The following program will help us understand
    the gist of what is involved in writing Windows Programming using C/C++:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 微软公司创建了一个GUI编程模型，可以被认为是世界上最成功的窗口系统。Windows软件的第三版（1990年）取得了巨大成功，随后微软推出了Windows
    NT和Windows 95/98/ME系列。让我们来看看微软Windows的事件驱动编程模型（请参阅微软文档，详细了解这个编程模型的工作原理）。以下程序将帮助我们了解使用C/C++编写Windows编程所涉及的要点：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code snippet initializes a structure by the name of `WNDCLASS`
    (or `WNDCLASSEX` for modern systems) with a necessary template for a Window. The
    most important field in the structure is `lpfnWndProc`, which is the address of
    the function that responds to the event inside an instance of this Window:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段初始化了一个名为`WNDCLASS`（或现代系统上的`WNDCLASSEX`）的结构，并提供了一个窗口的必要模板。结构中最重要的字段是`lpfnWndProc`，它是响应此窗口实例中事件的函数的地址：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will invoke the `CreateWindow` (or `CreateWindowEx` on modern systems) API
    call to create a window based on the class name provided in the `WNDCLASS.lpszClassname`
    parameter:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调用`CreateWindow`（或现代系统上的`CreateWindowEx`）API调用，根据`WNDCLASS.lpszClassname`参数中提供的类名创建一个窗口：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding code snippet gets into an infinite loop where messages will be
    retrieved from the message queue until we get a `WM_QUIT` message. The `WM_QUIT`
    message takes us out of the infinite loop. The Messages will sometimes be translated
    before calling the `DispatchMessage` API call. `DispatchMessage` invokes the Window
    callback procedure (`lpfnWndProc`):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段进入了一个无限循环，消息将从消息队列中检索，直到我们收到一个`WM_QUIT`消息。`WM_QUIT`消息将使我们退出无限循环。有时在调用`DispatchMessage`
    API之前会对消息进行翻译。`DispatchMessage`调用窗口回调过程（`lpfnWndProc`）：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code snippet is a minimalist `callback` function. You can consult
    Microsoft documentation to learn about Windows API programming and how events
    are handled in those programs
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段是一个最简化的`callback`函数。您可以查阅微软文档，了解Windows API编程以及这些程序中如何处理事件
- en: Event-driven programming under Qt
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt下的事件驱动编程
- en: 'The Qt Framework is an industrial-strength, cross-platform, and multi-platform
    GUI toolkit that runs on Windows, GNU Linux, macOS X, and other Mac systems. The
    toolkit has been compiled into embedded systems and mobile devices. The C++ Programming
    model has leveraged something called **Meta Object Compiler** (**MOC**), which
    will peruse the source code for directives (a bunch of macros and language extensions
    embedded in the source code) and generate appropriate additional source code to
    generate event handlers. So, before the C++ compiler gets the source code, the
    MOC pass has to run to generate legal ANSI C++ by removing those extra linguistic
    constructs specific to the Qt system. Consult the Qt documentation to learn more
    about this. The following simple Qt program will demonstrate the key aspects of
    Qt programming and its event processing system:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Qt框架是一个工业级、跨平台和多平台的GUI工具包，可在Windows、GNU Linux、macOS X和其他Mac系统上运行。该工具包已经编译到嵌入式系统和移动设备中。C++编程模型利用了称为**元对象编译器**（**MOC**）的东西，它将浏览指令的源代码（源代码中嵌入的一堆宏和语言扩展）并生成适当的附加源代码以生成事件处理程序。因此，在C++编译器获取源代码之前，必须运行MOC
    pass以通过删除那些特定于Qt系统的额外语言构造生成合法的ANSI C++。请参阅Qt文档以了解更多信息。以下简单的Qt程序将演示Qt编程及其事件处理系统的关键方面：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The macro `Q_OBJECT` is a directive to the MOC to generate an `Event Dispatch`
    table. When we connect the event source to an event sink, an entry will be given
    to the `Event Dispatch` table. The generated code will be compiled along with
    the C++ code to produce an executable:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 宏`Q_OBJECT`是指示MOC生成`事件分发`表的指令。当我们将事件源连接到事件接收器时，将向`事件分发`表中添加一个条目。生成的代码将与C++代码一起编译以生成可执行文件：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The language extension *public slots* will be stripped away by the MOC (after
    doing the job of source code generation) to a form compatible with the ANSI C/C++
    compiler:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 语言扩展*public slots*将被MOC剥离（在完成源代码生成的工作后）以与ANSI C/C++编译器兼容的形式：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding code snippet initializes the Qt application object and displays
    the main window. For all practical purposes, Qt is the most prominent application
    development framework for the C++ language and it also has got a good binding
    to the Python Programming language.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段初始化了Qt应用程序对象并显示了主窗口。在实际应用中，Qt是C++语言最重要的应用程序开发框架，它还与Python编程语言有很好的绑定。
- en: Event-driven programming under MFC
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MFC下的事件驱动编程
- en: 'The Microsoft Foundation class library is still a popular library with which
    to write Microsoft Windows-based desktop programs. It does have some support for
    web programming if we mix **ActiveX Template Library** (**ATL**) along with it.
    Being a C++ library, MFC uses a mechanism called Message Mapping to handle events.
    A sample event handling table given as macros is part of every MFC program:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft Foundation类库仍然是编写基于Microsoft Windows的桌面程序的流行库。如果我们将**ActiveX模板库**（**ATL**）与之混合使用，它确实对Web编程提供了一些支持。作为一个C++库，MFC使用一种称为消息映射的机制来处理事件。每个MFC程序都有一些给定的宏作为样本事件处理表：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding message map will respond to `OnCreate`, `OnPaint`, and `Ontimer`
    standard Windows API messages. Deep down these message maps are arrays on to which
    we will use `message id` as an index for dispatching the events. On closer examination,
    it is not much different from the standard Windows API messaging model.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的消息映射将响应`OnCreate`、`OnPaint`和`Ontimer`标准Windows API消息。深入了解这些消息映射，它们实际上就是数组，我们将使用`消息ID`作为索引来分派事件。仔细检查后，它与标准的Windows
    API消息模型并没有太大的不同。
- en: The code listing is not given here because we have globally a GUI implementation
    of one of the key interfaces for the Reactive Programming model using MFC. The
    implementation is based on the MFC library and the reader can go through the annotated
    listing to gain an understanding of non-trivial event processing in MFC.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有给出代码清单，因为我们全局上使用了MFC来实现响应式编程模型的一个关键接口的GUI。该实现基于MFC库，读者可以通过注释清单来理解MFC中的非平凡事件处理。
- en: Other event-driven programming models
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他基于事件驱动的编程模型
- en: Distributed object processing frameworks such as COM+ and CORBA do have their
    own event processing framework. The COM+ event model is based on the notion of
    Connection Points (modeled by `IConnectionPointContainer`/`IConnectionPoint` interfaces)
    and CORBA does have its own event service model. The CORBA standard provides both
    pull-based and push-based event notifications. COM+ and CORBA are beyond the scope
    of this book and the reader is expected to consult the respective documentation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如COM+和CORBA之类的分布式对象处理框架确实有自己的事件处理框架。COM+事件模型基于连接点的概念（由`IConnectionPointContainer`/`IConnectionPoint`接口建模），而CORBA确实有自己的事件服务模型。CORBA标准提供了基于拉取和推送的事件通知。COM+和CORBA超出了本书的范围，读者应该查阅各自的文档。
- en: Limitations of classical event processing models
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 经典事件处理模型的限制
- en: The whole purpose of making a tour of the event processing supported by various
    platforms was to put things into the proper perspective. The event response logic
    in these platforms is mostly coupled with the platform where the code is written.
    With the advent of multi-core programming, writing low-level multi-threaded code
    is difficult and declarative task-based programming models are available with
    the C++ programming language. But the event sources are mostly outside the C++
    standard! The C++ language does not have a standard GUI programming library, an
    interface standard to access external devices, and so on. What is the way out?
    Luckily, events and data from external sources can be aggregated into streams
    (or sequences) and by using functional programming constructs such as Lambda functions
    can be processed very efficiently. The added bonus is that if we resort to some
    kind of restrictions regarding the mutability of variables and streams, concurrency,
    and parallelism are built into the stream processing model.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 进行事件处理的整个目的是为了正确地看待事物。这些平台中的事件响应逻辑大多与编写代码的平台耦合在一起。随着多核编程的出现，编写低级多线程代码变得困难，而使用C++编程语言可以使用声明式任务模型。但是，事件源大多在C++标准之外！C++语言没有标准的GUI编程库，也没有访问外部设备的接口标准等。有什么办法？幸运的是，外部数据和事件可以聚合成流（或序列），并且通过使用Lambda函数等函数式编程构造可以被高效地处理。额外的好处是，如果我们对变量和流的可变性以及并发性方面进行一些限制，那么并发性和并行性就内置到流处理模型中了。
- en: Reactive programming model
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程模型
- en: Simply put, reactive programming is nothing but programming with asynchronous
    data streams. By applying various operations on stream, we can achieve different
    computational goals. The primary task in a reactive program is to convert data
    into streams, regardless of what the source of the data is. While writing modern
    graphical user interface applications, we process mouse move-and-click events.
    Currently, most systems get a callback and process these events as and when they
    happen. Most of the time, the handler does a series of filtering operations before
    it invokes the action methods associated with the event calls. In this particular
    context, reactive programming helps us in aggregating the mouse move-and-click
    events into a collection and sets a filter on them before notifying the handler
    logic. In this way, the application/handler logic does not get executed unnecessarily.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，响应式编程就是使用异步数据流进行编程。通过对流应用各种操作，我们可以实现不同的计算目标。响应式程序的主要任务是将数据转换为流，而不管数据的来源是什么。在编写现代图形用户界面应用程序时，我们处理鼠标移动和点击事件。目前，大多数系统都会得到回调，并在事件发生时处理这些事件。大部分时间，处理程序在调用与事件调用相关的动作方法之前会进行一系列的过滤操作。在这种特定的上下文中，响应式编程帮助我们将鼠标移动和点击事件聚合到一个集合中，并在通知处理程序逻辑之前对它们进行过滤。这样，应用程序/处理程序逻辑就不会被不必要地执行。
- en: The stream-processing model is well known, and it is very easy to encode by
    application developers. Pretty much anything can be converted into a stream. Such
    candidates include messages, logs, properties, Twitter feeds, blog posts, RSS
    feeds, and so on. Functional programming techniques are really good at processing
    streams. A language such as Modern C++, with excellent support for Object/Functional
    programming, is a natural choice for writing reactive programs. The basic idea
    behind reactive programming is that there are certain datatypes that represent
    a value over time. These datatypes (or rather data sequences) are represented
    as Observable sequences in this programming paradigm. Computations that involve
    these changing (time-dependent) values will, in turn, themselves have values that
    change over time, and will need to asynchronously receive notifications (as and
    when the dependent data changes).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 流处理模型是众所周知的，并且非常容易由应用程序开发人员编码。几乎任何东西都可以转换成流。这些候选对象包括消息、日志、属性、Twitter动态、博客文章、RSS动态等。函数式编程技术非常擅长处理流。像现代C++这样对面向对象/函数式编程提供了出色支持的语言，是编写响应式程序的自然选择。响应式编程的基本思想是，有一些数据类型代表随时间变化的值。在这种编程范式中，这些数据类型（或者说数据序列）被表示为可观察序列。涉及这些变化（依赖时间）的值的计算本身也会随时间变化，并且需要异步地接收通知（在依赖数据发生变化时）。
- en: Functional reactive programming
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式响应式编程
- en: Almost all modern programming languages support functional programming constructs.
    Functional programming constructs such as Transform, Apply, Filter, Fold, and
    so on are good for processing streams. Programming asynchronous data streams using
    functional programming constructs are generally called functional reactive programming
    (for all practical purposes). The definition given here is an operational one.
    Consult the work done by Conal Elliott and Paul Hudak as part of the Haskell community
    to understand the strict definition. Mixing Reactive Programming with FP is gaining
    traction among developers these days. The Emergence of libraries such as Rx.Net, RxJava,
    RxJs, and RxCpp and so on is a testimony to this.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有现代编程语言都支持函数式编程构造。函数式编程构造，如转换、应用、过滤、折叠等，非常适合处理流。使用函数式编程构造来编程异步数据流通常被称为函数式响应式编程（在实际目的上）。这里给出的定义是一个操作性的定义。请参考Conal
    Elliott和Paul Hudak在Haskell社区所做的工作，以了解严格的定义。将响应式编程与函数式编程混合在一起在开发人员中越来越受欢迎。Rx.Net、RxJava、RxJs、RxCpp等库的出现证明了这一点。
- en: Even though reactive programming is the core subject of this book, in this chapter
    we will be sticking to an OOP approach. This is necessitated because of the fact
    that we need to introduce some standard interfaces (emulated in C++ using virtual
    functions) necessary for doing Reactive programming. Later on, after learning
    about FP constructs supported by C++ , readers can do some mental model mapping
    from OOP to FP constructs. We will also keep away from concurrency stuff to focus
    on software interfaces in this chapter. [Chapters 2](e1c95513-a3a7-40f2-ac25-9f95cbd9a2e6.xhtml),
    *A Tour of the Modern C++ and Its Key Idioms*, [Chapter 3](16bbadb9-c545-44b1-8edb-82ab82a83394.xhtml),
    *Language-Level Concurrency and Parallelism in C++*, and [Chapter 4](80c4a483-89c7-45fc-a83f-736a1817126e.xhtml),
    *Asynchronous and Lock-Free Programming in C++*, will give the necessary background
    to understand reactive programming using FP constructs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管响应式编程是本书的核心主题，但在本章中，我们将坚持面向对象的方法。这是因为我们需要引入一些标准接口（在C++中使用虚函数模拟）来进行响应式编程。之后，在学习C++支持的FP构造之后，读者可以将OOP构造进行一些心智模型映射到FP构造。在本章中，我们还将远离并发内容，专注于软件接口。[第2章](e1c95513-a3a7-40f2-ac25-9f95cbd9a2e6.xhtml)，*现代C++及其关键习语之旅*，[第3章](16bbadb9-c545-44b1-8edb-82ab82a83394.xhtml)，*C++中的语言级并发和并行性*，以及[第4章](80c4a483-89c7-45fc-a83f-736a1817126e.xhtml)，*C++中的异步和无锁编程*，将为理解使用FP构造进行响应式编程提供必要的背景。
- en: The key interfaces of a reactive program
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式程序的关键接口
- en: 'To help you understand what is really happening inside a reactive program,
    we will write some toy programs to put things in proper context. From a software
    design point of view, if you keep concurrency/parallelism aside to focus on software
    interfaces, a reactive Program should have:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您理解响应式程序内部实际发生的事情，我们将编写一些玩具程序，以便将事情放在适当的背景下。从软件设计的角度来看，如果将并发/并行性放在一边，专注于软件接口，响应式程序应该具有：
- en: An event source that implements `IObservable<T>`
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`IObservable<T>`的事件源
- en: An event sink that implements `IObserver<T>`
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`IObserver<T>`的事件接收器
- en: A mechanism to add subscribers to an event source
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个向事件源添加订阅者的机制
- en: When data appears at the source, subscribers will be notified
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当数据出现在源头时，订阅者将收到通知
- en: In this particular chapter, we have written code using classic C++ constructs.
    This is because we have not yet introduced Modern C++ constructs. We have also
    used raw pointers, something which we can mostly avoid while writing Modern C++
    code. The code in this chapter is written to conform to the ReactiveX documentation
    in general. In C++, we do not use inheritance-based techniques like we do in Java
    or C#.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了经典的C++构造编写了代码。这是因为我们还没有介绍现代C++构造。我们还使用了原始指针，这在编写现代C++代码时可以大多避免。本章中的代码是一般遵循ReactiveX文档编写的。在C++中，我们不像在Java或C#中那样使用基于继承的技术。
- en: 'To kickstart, let us define Observer, Observable, and a `CustomException` class:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，让我们定义Observer、Observable和`CustomException`类：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `CustomException` class is just a placeholder to make the interface complete.
    Since we have decided that we will only use classic C++ in this chapter, we are
    not deviating from the `std::exception` class:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomException`类只是一个占位符，以使接口完整。由于我们决定在本章中只使用经典的C++，我们不会偏离`std::exception`类：'
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `Enumerable` interface is used by the data source from which we can enumerate
    data and `IEnuerator<T>` will be used for iteration by the client.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enumerable`接口由数据源使用，我们可以枚举数据，并且客户端将使用`IEnuerator<T>`进行迭代。'
- en: 'The purpose of defining interfaces for Iterator (`IEnuerable<T>`/`IEnumerator<T>`)
    is to make the reader understand that they are very closely related to the `Observer<T>`/`Observable<T>`
    pattern. We will define `Observer<T>`/`Observable<T>` as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 定义迭代器接口（`IEnuerable<T>`/`IEnumerator<T>`）的目的是让读者理解它们与`Observer<T>`/`Observable<T>`模式非常密切相关。我们将定义`Observer<T>`/`Observable<T>`如下：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`IObserver<T>` is the interface that the data sink will use to receive notifications
    from the data source. The data source will implement the `IObservable<T>` interface.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`IObserver<T>`是数据接收器将用于从数据源接收通知的接口。数据源将实现`IObservable<T>`接口。'
- en: We have defined the `IObserver<T>` interface and it has got three methods. They
    are `OnNext` (when the item is notified to the Observer), `OnCompleted` (when
    there is no more data), and `OnError` (when an exception is encountered). `Observable<T>`
    is implemented by the event source and event sinks can insert objects that implement `IObserver<T>`
    to receive notifications.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了`IObserver<T>`接口，并且它有三种方法。它们是`OnNext`（当项目通知给观察者时），`OnCompleted`（当没有更多数据时），和`OnError`（当遇到异常时）。`Observable<T>`由事件源实现，事件接收器可以插入实现`IObserver<T>`以接收通知的对象。
- en: Pull-versus push-based reactive programming
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拉取与推送式响应式编程
- en: Reactive programs can be classified as **push-based** and **pull-based**. The
    pull-based system waits for a demand to push the data streams to the requestor
    (or subscriber in our case). This is the classic case where the data source is
    actively polled for more information. This employs the iterator pattern, and `IEnumerable
    <T>`/`IEnumerator <T>` interfaces are specifically designed for such scenarios
    that are synchronous in nature (the application can block while pulling data).
    On the other hand, a push-based system aggregates events and pushes through a
    signal network to achieve the computation. In this case, unlike the pull-based
    system, data and related updates are handed to the subscriber from the source
    (Observable sequences in this case). This asynchronous nature is achieved by not
    blocking the subscriber, but rather making it react to the changes. As you can
    see, employing this push pattern is more beneficial in rich UI environments where
    you wouldn't want to block the main UI thread while waiting for some events. This
    becomes ideal, thus making reactive programs responsive.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式程序可以被分类为**基于推送**和**基于拉取**。基于拉取的系统等待需求，将数据流推送给请求者（或我们的订阅者）。这是经典情况，其中数据源被主动轮询以获取更多信息。这使用了迭代器模式，而`IEnumerable
    <T>`/`IEnumerator <T>`接口专门设计用于这种同步性质的场景（应用程序在拉取数据时可能会阻塞）。另一方面，基于推送的系统聚合事件并通过信号网络推送以实现计算。在这种情况下，与基于拉取的系统不同，数据和相关更新是从源头（在这种情况下是Observable序列）传递给订阅者。这种异步性质是通过不阻塞订阅者，而是使其对变化做出反应来实现的。正如您所看到的，采用这种推送模式在丰富的UI环境中更有益，因为您不希望在等待某些事件时阻塞主UI线程。这变得理想，从而使响应式程序具有响应性。
- en: The IEnumerable/IObservable duality
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IEnumerable/IObservable对偶性
- en: 'If you take a closer look, there is only a subtle difference between these
    two patterns. `IEnumerable<T>` can be considered the pull-based equivalent of
    the push-based `IObservable<T>`. In fact, they are duals. When two entities exchange
    information, one entity''s pull corresponds to another entity pushing the information.
    This duality is illustrated in the following diagram:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细观察，这两种模式之间只有微妙的差异。`IEnumerable<T>`可以被认为是基于拉取的等价于基于推送的`IObservable<T>`。实际上，它们是对偶的。当两个实体交换信息时，一个实体的拉取对应于另一个实体推送信息。这种对偶性在下图中有所说明：
- en: '![](img/a4538551-7bd5-4fcc-8a04-e2b682f92a84.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a4538551-7bd5-4fcc-8a04-e2b682f92a84.png)'
- en: 'Let''s understand this duality by looking at this sample code, a number sequence
    generator:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看这个示例代码，一个数字序列生成器，来理解这种对偶性：
- en: We have striven to use classic C++ constructs to write programs for this particular
    chapter as there are chapters on Modern C++ language features, language level
    concurrency, lock-free programming, and related topics for implementing Reactive
    constructs in Modern C++.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们努力使用经典的C++构造来编写本章的程序，因为还有关于现代C++语言特性、语言级并发、无锁编程以及实现现代C++中的响应式构造的相关主题。
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding class takes an array of integers as a parameter and we can enumerate
    over the elements as we have implemented the `IEnumerable<T>` interface. The `Enumeration`
    logic is implemented by the nested class, which implements the `IEnumerator<T>`
    interface:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类以整数数组作为参数，并且我们可以枚举元素，因为我们已经实现了`IEnumerable<T>`接口。`Enumeration`逻辑由嵌套类实现，该嵌套类实现了`IEnumerator<T>`接口：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The main program instantiates an implementation of the `ConcreteEnuerable` class
    and walks through each element.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 主程序实例化了`ConcreteEnuerable`类的一个实现，并遍历每个元素。
- en: 'We will write an even number sequence generator to demonstrate how these data
    types work together in converting a pull-based program to a push program. The
    robustness aspect is given low priority to keep the listing terse:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个偶数序列生成器，以演示这些数据类型如何在将基于拉取的程序转换为推送程序时一起工作。鲁棒性方面给予了较低的优先级，以保持清单的简洁性：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding program takes an array of integers, filters out of the odd numbers,
    and notifies `Observer<T>` if an even integer is encountered. In this particular
    case, the data source is pushing data to `observer`. The implementation of `Observer<T>`
    is given as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序接受一个整数数组，过滤掉奇数，并在遇到偶数时通知`Observer<T>`。在这种情况下，数据源将数据推送给`observer`。`Observer<T>`的实现如下所示：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `SimpleObserver` class implements the `IObserver<T>` interface and it has
    the capability to receive notifications and react to them:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleObserver`类实现了`IObserver<T>`接口，并具有接收通知并对其做出反应的能力：'
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: From the preceding example, you see how one can naturally subscribe for even
    numbers from an Observable sequence of natural numbers. The system will automatically
    `push` (`publish`) the values to the `observer` (`subscriber`) when an even number
    is detected. The code gives explicit implementations for key interfaces so that
    one can understand, or speculate what really happens under the hood.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中，您可以看到如何自然地订阅自然数的Observable序列中的偶数。当检测到偶数时，系统将自动向观察者（订阅者）“推送”（发布）值。代码为关键接口提供了明确的实现，以便人们可以理解或推测在幕后到底发生了什么。
- en: Converting events to IObservable<T>
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将事件转换为IObservable<T>
- en: 'We have now understood how one can convert an `IEnumerable<T>`-based pull program
    to an `IObservable<T>`/`IObserver<T>`-based push program. In real life, the event
    source is not as simple as we found in the number stream example given earlier.
    Let us see how we can convert a `MouseMove` event into a stream with a small MFC
    program:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经理解了如何将基于`IEnumerable<T>`的拉取程序转换为基于`IObservable<T>`/`IObserver<T>`的推送程序。在现实生活中，事件源并不像我们之前给出的数字流示例中那么简单。让我们看看如何将`MouseMove`事件转换为一个小型MFC程序中的流：
- en: 'We have chosen MFC for this particular implementation because we have a chapter
    dedicated to Qt-based reactive programming. In that chapter, we will be implementing
    Reactive programs in idiomatic asynchronous push-based streams. In this MFC program,
    we simply do a filtering operation to see whether the mouse is moving in a bounding
    rectangle and, if so, notify the `observer`. We are using synchronous dispatch
    here. This example is synchronous too:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择了MFC来实现这个特定的实现，因为我们有一章专门讲解基于Qt的响应式编程。在那一章中，我们将以成语异步推送流的方式实现响应式程序。在这个MFC程序中，我们只是进行了一个过滤操作，以查看鼠标是否在一个边界矩形内移动，如果是，则通知`observer`。我们在这里使用同步分发。这个示例也是同步的：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding part of the code defines a `Frame` class that derives from the
    `MFC` library the `CFrameWnd` class and also implements the `IObservable<T>` interface
    to force the programmer to implement the `Subscribe` method. A vector of `IObserver<T>`
    will store the list of `observers` or `Subscribers`. For this example, we will
    have only one `observer`. There is no restriction on the number of `observer` in
    the code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的前面部分定义了一个`Frame`类，它从`MFC`库的`CFrameWnd`类派生，并实现了`IObservable<T>`接口，以强制程序员实现`Subscribe`方法。一个`IObserver<T>`的向量将存储`observers`或`Subscribers`的列表。在本例中，我们只有一个`observer`。代码中没有对`observer`的数量进行限制：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `Subscribe` method just stores the reference to the `observer` onto a vector
    and returns `true`: when the mouse is moved, we get notification from the `MFC`
    library and if it is in a rectangular area, `observer` will be notified (the notification
    code is as follows):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subscribe`方法只是将`observer`的引用存储到一个向量中并返回`true`：当鼠标移动时，我们从`MFC`库中获得通知，如果它在一个矩形区域内，`observer`将会被通知（通知代码如下）：'
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `FireEvent` method walks through the `observer`''s and calls the `OnNext`
    method of the `observer`. It also calls the `OnCompleted` method of each instance
    of Observer''s: The Rx dispatching mechanism follows certain rules while calling
    the `observer` methods. If `OnComplete` method is called, no more `OnNext` will
    be called on the same `observer`. Similarly, if `OnError` is called, no further
    messages will be dispatched to the `observer`. If we need to follow the conventions
    stipulated by the Rx model here, the listing will get complicated. The purpose
    of the code given here is to show how the Rx programming model works in a schematic
    manner.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`FireEvent`方法遍历`observer`并调用`observer`的`OnNext`方法。它还调用每个Observer的`OnCompleted`方法：Rx调度机制在调用`observer`方法时遇到一些规则。如果调用了`OnComplete`方法，同一个`observer`将不再调用`OnNext`。同样，如果调用了`OnError`，将不会再向`observer`分发消息。如果我们需要遵循Rx模型规定的约定，代码将变得复杂。这里给出的代码目的是以一种概要的方式展示Rx编程模型的工作原理。'
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `SetCurrentPoint` method is invoked by `observer` to set the current point
    where the text has to be drawn. The `Invalidate` method is invoked to trigger
    a `WM_PAINT` message and the `MFC` subsystem will route it to `OnPaint` (as it
    is wired in the `Message` maps):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetCurrentPoint`方法由`observer`调用以设置文本绘制的当前点。调用`Invalidate`方法触发`WM_PAINT`消息，`MFC`子系统将其路由到`OnPaint`（因为它在`Message`映射中被连接）：'
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `OnPaint` method is invoked by the `MFC` framework when the `Invalidate`
    call is made. The method draws the `literal` string, `Hello Reactive C++`, on
    the screen:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`Invalidate`时，`OnPaint`方法由`MFC`框架调用。该方法在屏幕上绘制`literal`字符串`Hello Reactive
    C++`：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `Transform` method computes the bound of the client area of the `Frame`
    and converts `Cartesian` coordinates to devise coordinates. This computation can
    be better done through world coordinate transformations:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`Transform`方法计算`Frame`的客户区域的边界，并将`Cartesian`坐标转换为设备坐标。这种计算可以通过世界坐标变换更好地完成：'
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `OnMouseMove` method checks whether the mouse position is within a rectangle
    centered inside the screen and fires the notification to the `observer`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnMouseMove`方法检查鼠标位置是否在屏幕内的一个矩形区域内，并向`observer`发出通知：'
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding class `WindowHandler` implements the `IObserver<T>` interface
    and handles the event notified by `CMouseFrame`, which implements the `IObservable<CPoint>`
    interface. In this canned example, we set the current point by invoking the `SetCurrentPoint`
    method to draw the string at the mouse position:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`WindowHandler`类实现了`IObserver<T>`接口，并处理了由`CMouseFrame`通知的事件，后者实现了`IObservable<CPoint>`接口。在这个示例中，我们通过调用`SetCurrentPoint`方法来设置当前点，以便在鼠标位置绘制字符串：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The philosophy of our book
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的书的哲学
- en: The purpose of this chapter is to introduce readers to the key interfaces of
    the reactive programming mode they are—`IObservable<T>` and `IObserver<T>.` They
    are in fact the duals of the `IEnumerable<T>` and `IEnumerator<T>` interface.
    We learned how to model those interfaces in classic C++ (well, mostly) and had
    toy implementations of all of them. Finally, we implemented a GUI program that
    captures mouse movements and notifies a list of Observers. These toy implementations
    are to get our feet wet with the ideas and ideals of the Reactive programming
    model. Our implementations can be considered as implementing of OOP-based reactive
    programming.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是向读者介绍响应式编程模式的关键接口，它们是`IObservable<T>`和`IObserver<T>`。实际上，它们是`IEnumerable<T>`和`IEnumerator<T>`接口的对偶。我们学习了如何在经典C++中对这些接口进行建模（大部分），并对它们进行了玩具实现。最后，我们实现了一个捕获鼠标移动并通知一系列观察者的GUI程序。这些玩具实现是为了让我们初步了解响应式编程模式的思想和理想。我们的实现可以被视为基于面向对象的响应式编程的实现。
- en: 'To be proficient in C++ reactive programming, a programmer has to be comfortable
    with the following topics:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要精通C++响应式编程，程序员必须熟悉以下主题：
- en: Advanced linguistic constructs provided by Modern C++
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代C++提供的高级语言构造
- en: Functional programming constructs provided by Modern C++
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代C++提供的函数式编程构造
- en: Asynchronous programming (RxCpp handles it for you!) model
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步编程（RxCpp为您处理！）模型
- en: Event stream processing
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件流处理
- en: Knowledge of industrial-strength libraries such as RxCpp
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对RxCpp等工业级库的了解
- en: Applications of RxCpp in GUI and web programming
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxCpp在GUI和Web编程中的应用
- en: Advanced reactive programming constructs
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级响应式编程构造
- en: Handling errors and exceptions
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理错误和异常
- en: This chapter was mostly about key idioms and why we require a robust model for
    handling asynchronous data. The next three chapters will cover language features
    of Modern C++, handling concurrency/parallelism with C++ standard constructs,
    and lock-free programming (made possible by memory model guarantees). The preceding
    topics will give the user a firm foundation from which to master functional reactive
    programming.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要讨论了关键的习语以及为什么我们需要一个强大的模型来处理异步数据。接下来的三章将涵盖现代C++的语言特性，使用C++标准构造处理并发/并行性，以及无锁编程（由内存模型保证实现）。前面的主题将为用户提供坚实的基础，以便掌握函数式响应式编程。
- en: In [Chapter 5](c73fa9f3-6f2b-47f6-946d-155446d3225f.xhtml), *Introduction to
    Observables*, we will once again return to the topic of Observables and implement
    interfaces in a functional manner to reiterate some of the concepts. In [Chapter
    6](9f5e24eb-c2fd-4cfe-b812-c961e350fd9a.xhtml), *Introduction to Event Stream
    Programming Using C++*, we will move towards the advanced event stream processing
    topics with the help of two industrial-strength libraries that use the **Domain
    Specific Embedded Language** (**DSEL**) approach towards event stream processing.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章]《可观察对象简介》中，我们将再次回到可观察对象的主题，并以函数式的方式实现接口，重申一些概念。在[第6章]《使用C++进行事件流编程简介》中，我们将借助两个工业级库，使用**领域特定嵌入式语言**（DSEL）方法处理高级事件流处理主题。
- en: By now, the stage will be set for the user to be exposed to the industrial-strength
    RxCpp library and its nuances to write professional-quality Modern C++ programs.
    In Chapter 7, *Introduction to Data Flow Computation and the RxCpp Library* and
    Chapter 8, *RxCpp – the Key Elements*, we will cover this wonderful library. The
    following chapters will cover Reactive GUI programming using the Qt library and
    advanced operators in RxCpp.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，用户将有机会接触工业级RxCpp库及其细微之处，以编写专业质量的现代C++程序。在第7章《数据流计算和RxCpp库简介》和第8章《RxCpp
    - 关键要素》中，我们将介绍这个出色的库。接下来的章节将涵盖使用Qt库进行响应式GUI编程以及RxCpp中的高级操作符。
- en: The last three chapters cover advanced topics of Reactive design patterns, micro-services
    in C++, and handling errors/exceptions. By the end of the book, the reader who
    started with classic C++ will have covered a lot of ground, not only in writing
    Reactive programs but in the C++ language itself. Because of the nature of the
    topic, we will cover most of the features of C++ 17 (at the time of writing).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三章涵盖了响应式设计模式、C++中的微服务以及错误/异常处理的高级主题。在本书结束时，从经典C++开始的读者将不仅在编写响应式程序方面取得了很大进展，而且在C++语言本身方面也有了很大进步。由于主题的性质，我们将涵盖C++
    17的大部分特性（在撰写时）。
- en: Summary
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about some key data structures of the Rx programming
    model. We implemented toy versions of them to familiarize us with the conceptual
    nuances underpinning them. We started with how GUI events were handled by Windows
    API, XLib API, MFC, and Qt. We briefly touched upon how events are handled in
    COM+/CORBA as well. Then, a quick overview of Reactive programming was given.
    After introducing some interfaces, we implemented them from scratch. Finally,
    a GUI version of these interfaces on top of MFC was implemented for the sake of
    completeness. We also dealt with the key philosophical aspects of the book.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了Rx编程模型的一些关键数据结构。我们实现了它们的玩具版本，以熟悉支撑它们的概念细微差别。我们从Windows API、XLib API、MFC和Qt处理GUI事件开始。我们还简要介绍了在COM+/CORBA中如何处理事件。然后，我们快速概述了响应式编程。在介绍了一些接口后，我们从头开始实现了它们。最后，为了完整起见，我们在MFC上实现了这些接口的GUI版本。我们还处理了本书的一些关键哲学方面。
- en: In the next chapter, we will make a whirlwind tour of the key features of Modern
    C++ (C++ Versions 11/14/17) by emphasizing on move semantics, Lambdas, type inference,
    range-based loops, pipe-able operators, smart pointers, and so on. This is essential
    for writing even basic code for Reactive Programming.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将快速浏览现代C++（C++版本11/14/17）的关键特性，重点介绍移动语义、Lambda、类型推断、基于范围的循环、可管道的操作符、智能指针等。这对于编写响应式编程的基本代码至关重要。
