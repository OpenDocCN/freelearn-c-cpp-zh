- en: Persistence
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久性
- en: 'In [Chapter 5](d1169ccb-4e46-49f4-b41b-2aaf896337ad.xhtml), *Data*, we created
    a framework for capturing and holding data in memory.  However, this is only half
    of the story, as without persisting the data to some external destination, it
    will be lost as soon as we close the application. In this chapter, we will build
    on our earlier work and save our data to disk in a SQLite database so that it
    can live on beyond the lifetime of the application. Once saved, we will also build
    methods for finding, editing, and deleting our data. To get all these operations
    for free in our various data models, we will extend our data entities so that
    they can load and save to our database automatically, without us having to write
    boilerplate code in each class. We will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](d1169ccb-4e46-49f4-b41b-2aaf896337ad.xhtml)中，*Data*，我们创建了一个在内存中捕获和保存数据的框架。然而，这只是故事的一半，因为如果不将数据持久化到某个外部目的地，那么一旦关闭应用程序，数据就会丢失。在本章中，我们将在之前的工作基础上，将数据保存到SQLite数据库中，以便它可以在应用程序的生命周期之外存在。保存后，我们还将构建用于查找、编辑和删除数据的方法。为了在各种数据模型中免费获得所有这些操作，我们将扩展我们的数据实体，以便它们可以自动加载和保存到我们的数据库，而无需我们在每个类中编写样板代码。我们将涵盖以下主题：
- en: SQLite
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite
- en: Primary keys
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主键
- en: Creating clients
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建客户端
- en: Finding clients
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找客户端
- en: Editing clients
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑客户端
- en: Deleting clients
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除客户端
- en: SQLite
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQLite
- en: General purpose database technology has fragmented in the recent years with
    the explosion of NoSQL and Graph databases. However, SQL databases are still fighting
    fit and absolutely an appropriate choice in a lot of applications. Qt comes with
    built-in support for several SQL database driver types, and can be extended with
    custom drivers. MySQL and PostgreSQL are very popular open source SQL database
    engines and are both supported by default, but are intended for use on servers
    and require administration, which makes them a bit unnecessarily complicated for
    our purposes. Instead, we will use the much more lightweight SQLite, which is
    commonly used as a client-side database and is very popular in mobile applications
    due to its small footprint.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，通用数据库技术已经分化，NoSQL和图形数据库的爆炸使得SQL数据库仍然非常适用，并且在许多应用程序中仍然是一个合适的选择。Qt内置支持多种SQL数据库驱动程序类型，并且可以通过自定义驱动程序进行扩展。MySQL和PostgreSQL是非常流行的开源SQL数据库引擎，并且默认情况下都受到支持，但是它们是用于服务器的，并且需要管理，这使得它们对我们的目的来说有点不必要地复杂。相反，我们将使用更轻量级的SQLite，它通常用作客户端数据库，并且由于其小的占用空间，在移动应用程序中非常受欢迎。
- en: According to the official website at [https://www.sqlite.org](https://www.sqlite.org/),
    "SQLite is a self-contained, high-reliability, embedded, full-featured, public-domain,
    SQL database engine. SQLite is the most used database engine in the world". Paired
    with Qt's SQL related classes, it's a snap to create a database and store your
    data.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 根据官方网站[https://www.sqlite.org](https://www.sqlite.org/)，“SQLite是一个独立的、高可靠性的、嵌入式的、功能齐全的、公共领域的SQL数据库引擎。SQLite是世界上使用最多的数据库引擎”。配合Qt的SQL相关类，创建数据库并存储数据非常容易。
- en: 'The first thing we need to do is add the SQL module to our library project
    to get access to all of Qt’s SQL goodness. In `cm-lib.pro`, add the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是将SQL模块添加到我们的库项目中，以便访问Qt的所有SQL功能。在`cm-lib.pro`中添加以下内容：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we’ll take onboard what we discussed in the previous chapter and implement
    our database-related functionality behind an interface. Create a new `i-database-controller.h`
    header file in `cm-lib/source/controllers`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将接受前一章讨论的内容，并在接口后面实现与数据库相关的功能。在`cm-lib/source/controllers`中创建一个新的`i-database-controller.h`头文件：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we are implementing the four basic functions of (**Create**, **Read**,
    **Update**, and **Delete**) **CRUD**, which are relevant to persistent storage
    in general, not just SQL databases. We supplement these functions with an additional
    `find()` method that we will use to find an array of matching clients based on
    supplied search text.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在实现(**创建**、**读取**、**更新**和**删除**) **CRUD**的四个基本功能，这些功能与持久存储一般相关，而不仅仅是SQL数据库。我们还通过一个额外的`find()`方法来补充这些功能，我们将使用它来查找基于提供的搜索文本的匹配客户端数组。
- en: Now, let’s create a concrete implementation of the interface. Create a new `DatabaseController`
    class in `cm-lib/source/controllers`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个接口的具体实现。在`cm-lib/source/controllers`中创建一个新的`DatabaseController`类。
- en: '`database-controller.h`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`database-controller.h`：'
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let''s walk through each of the key implementation details in `database-controller.cpp`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐步了解`database-controller.cpp`中的每个关键实现细节：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Starting with the private implementation, we’ve broken the initialization into
    two operations: `initialise()` instantiates a connection to a SQLite database
    with a file named `cm.sqlite`, and this operation will first create the database
    file for us if it doesn’t already exist. The file will be created in the same
    folder as the application executable, `createTables()`, then creates any tables
    that we need which don’t already exist in the database. Initially, we only need
    a single table named client, but this can be easily extended later. We delegate
    the actual work of creating the named table to the `createJsonTable()` method
    so that we can reuse it for multiple tables.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从私有实现开始，我们将初始化分为两个操作：`initialise()`实例化一个连接到名为`cm.sqlite`的SQLite数据库的操作，如果数据库文件不存在，此操作将首先为我们创建数据库文件。文件将在与应用程序可执行文件相同的文件夹中创建，`createTables()`然后创建我们需要的任何表，这些表在数据库中不存在。最初，我们只需要一个名为client的单个表，但稍后可以轻松扩展。我们将实际创建命名表的工作委托给`createJsonTable()`方法，以便我们可以在多个表中重用它。
- en: 'A conventional normalized relational database approach would be to persist
    each of our data models in their own table, with fields that match the properties
    of the class. Recall the model diagram back in [Chapter 5](d1169ccb-4e46-49f4-b41b-2aaf896337ad.xhtml),
    *Data*, which is as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的规范化关系数据库方法是将我们的每个数据模型持久化到自己的表中，字段与类的属性匹配。回想一下[第5章](d1169ccb-4e46-49f4-b41b-2aaf896337ad.xhtml)中的模型图，如下所示：
- en: '![](img/f194d8cd-8f52-4936-bebc-64a2f23f37a9.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f194d8cd-8f52-4936-bebc-64a2f23f37a9.png)'
- en: We could create a Client table with the "reference" and "name" fields, a contact
    table with the "type", "address", and other fields. However, we will instead leverage
    the JSON serialization code we’ve already implemented and implement a pseudo document-style
    database. We will utilize a single client table that will store a unique ID for
    the client along with the whole client object hierarchy serialized to JSON.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个带有“reference”和“name”字段的客户端表，一个带有“type”、“address”和其他字段的联系人表。然而，我们将利用我们已经实现的JSON序列化代码，并实现一个伪文档式数据库。我们将利用一个单一的客户端表，该表将存储客户端的唯一ID以及整个客户端对象层次结构序列化为JSON。
- en: 'Finally, we''ve also added a `sqliteVersion()` utility method to identify which
    version of SQLite the database is using:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还添加了一个`sqliteVersion()`实用方法来识别数据库使用的SQLite版本：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The CRUD operations are all based around the `QSqlQuery` class and prepared
    `sqlStatements`. In all cases, we first perform some perfunctory checks on the
    parameters to ensure that we’re not trying to do something silly. We then concatenate
    the table name into a SQL string, representing parameters with the `:myParameter`
    syntax. After preparing the statement, parameters are subsequently substituted
    in using the `bindValue()` method on the query object.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: CRUD操作都是基于`QSqlQuery`类和准备的`sqlStatements`。在所有情况下，我们首先对参数进行一些例行检查，以确保我们不会做一些愚蠢的事情。然后，我们将表名连接到一个SQL字符串中，用`:myParameter`语法表示参数。在准备好语句之后，随后使用查询对象的`bindValue()`方法替换参数。
- en: 'When creating, deleting, or updating rows, we simply return a `true`/`false`
    success indicator on query execution. Assuming that the query prepares and executes
    without error, we check that the number of rows affected by the operation is greater
    than `0`. The read operation returns a JSON object parsed from the JSON text stored
    in the matching record. If no record is found or if the JSON cannot be parsed,
    then we return a default JSON object:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建、删除或更新行时，我们只需在查询执行时返回一个`true`/`false`的成功指示器。假设查询准备和执行没有错误，我们检查操作受影响的行数是否大于`0`。读取操作返回从匹配记录中存储的JSON文本解析出的JSON对象。如果找不到记录或无法解析JSON，则返回默认的JSON对象：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Finally, the `find()` method does essentially the same thing as the CRUD operations
    but compiles an array of JSON objects as there may be more than one match. Note
    that we use the `like` keyword in the SQL statement, combined with the `%` wildcard
    character, to find any JSON that contains the search text. We also convert both
    sides of the comparison to lowercase to make the search effectively case-insensitive.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`find()`方法本质上与CRUD操作相同，但编译一个JSON对象数组，因为可能有多个匹配项。请注意，我们在SQL语句中使用`like`关键字，结合`%`通配符字符，以查找包含搜索文本的任何JSON。我们还将比较的两侧转换为小写，以使搜索有效地不区分大小写。
- en: Primary keys
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主键
- en: Integral to most of these operations is an ID parameter used as the primary
    key in our table. To support the persistence of our entities using this new database
    controller, we need to add a property to our `Entity` class that uniquely identifies
    an instance of that entity.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数这些操作中，使用ID参数作为我们表中的主键至关重要。为了支持使用这个新的数据库控制器持久化我们的实体，我们需要向我们的`Entity`类添加一个属性，用于唯一标识该实体的一个实例。
- en: 'In `entity.cpp`, add a member variable to `Entity::Implementation`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在`entity.cpp`中，向`Entity::Implementation`添加一个成员变量：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, initialize it in the constructor:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在构造函数中初始化它：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When we instantiate a new `Entity`, we need to generate a new unique ID, and
    we use the QUuid class to this for us with the `createUuid()` method. A **Universally
    Unique Identifier** (**UUID**)is essentially a randomly generated number that
    we then convert to a string in the “{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}" format, where
    "x" is a hex digit. You will need to `#include <QUuid>`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实例化一个新的`Entity`时，我们需要生成一个新的唯一ID，并使用`createUuid()`方法使用QUuid类为我们生成。**通用唯一标识符**（**UUID**）本质上是一个随机生成的数字，然后我们将其转换为字符串格式“{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}”，其中“x”是一个十六进制数字。您需要`#include
    <QUuid>`。
- en: 'Next, provide a public accessor method for it:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为其提供一个公共访问器方法：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The challenge now is that if we are creating an `Entity` that already has an
    ID (for example, loading a client from the database), we need some mechanism for
    overwriting the generated ID value with the known value. We’ll do this in the
    `update()` method:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的挑战是，如果我们正在创建一个已经具有ID的`Entity`（例如，从数据库加载客户端），我们需要一些机制来用已知值覆盖生成的ID值。我们将在`update()`方法中执行此操作：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Similarly, when we serialize the object to JSON, we need to include the ID
    too:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当我们将对象序列化为JSON时，我们也需要包含ID：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Great! This gives us automatically generated unique IDs for all of our data
    models, which we can use as the primary key in our database table. However, a
    common usecase with database tables is that there is actually an existing field
    that is a great candidate for use as a primary key, for example, a National Insurance
    or Social Security number, an account reference, or site ID. Let’s add a mechanism
    for specifying a data decorator to use as the ID that will override the default
    UUID, if set.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！这为我们所有的数据模型自动生成了唯一的ID，我们可以将其用作数据库表中的主键。然而，数据库表的一个常见用例是实际上存在一个非常适合用作主键的现有字段，例如国民保险号码、社会安全号码、帐户参考或站点ID。如果设置了，让我们添加一个指定要用作ID的数据装饰器的机制，以覆盖默认的UUID。
- en: 'In our `Entity` class, add a new private member in `Implementation`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Entity`类中，在`Implementation`中添加一个新的私有成员：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You will need to `#include` the `StringDecorator` header. Add a protected mutator
    method to set it:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要`#include` `StringDecorator`头文件。添加一个受保护的修改器方法来设置它：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can then tweak our `id()` method to return us the primary key value if appropriate,
    otherwise default to the generated UUID value:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以调整我们的`id()`方法，以便在适当的情况下返回主键值，否则默认返回生成的UUID值：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, in the `client.cpp` constructor, after we have instantiated all the data
    decorators, we can specify that we want to use the reference field as our primary
    key:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`client.cpp`构造函数中，在我们实例化所有数据装饰器之后，我们可以指定我们要使用引用字段作为我们的主键：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let’s add a couple of tests to verify this behavior. We’ll verify that if a
    reference value is set, the `id()` method returns that value, otherwise it returns
    a generated UUID loosely of the “{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}" format.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一些测试来验证这种行为。我们将验证如果设置了引用值，`id()`方法将返回该值，否则将返回一个松散地符合“{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}”格式的生成的UUID。
- en: 'In `client-tests.h` of the `cm-tests` project, add two new tests in the private
    slots scope:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cm-tests`项目的`client-tests.h`中，在私有槽范围中添加两个新测试：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, implement the tests in `client-tests.cpp`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`client-tests.cpp`中实现测试：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that the checks are effectively performed twice in the first test just
    to demonstrate a couple of different approaches you can take. First, we check
    using individual character matches (‘{‘, ‘-’, and ‘}’), which is quite long-winded
    but easy for other developers to read and understand. Then, we perform the check
    again using Qt’s regular expression helper class. This is much shorter but more
    difficult to parse for normal humans who don’t speak regular expression syntax.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在第一个测试中，检查实际上进行了两次，只是为了演示您可以采取的几种不同方法。首先，我们使用单个字符匹配（'{'，'-'和'}'）进行检查，这相当冗长，但其他开发人员很容易阅读和理解。然后，我们再次使用Qt的正则表达式辅助类进行检查。这要短得多，但对于不懂正则表达式语法的普通人来说更难解析。
- en: Build and run the tests, and they should validate the changes we have just implemented.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行测试，它们应该验证我们刚刚实施的更改。
- en: Creating clients
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建客户端
- en: Let’s put our new infrastructure to use and wire up the `CreateClientView`.
    If you remember, we present a save command that when clicked on, calls `onCreateClientSaveExecuted()`
    on `CommandController`. In order to be able to perform anything useful, `CommandController`
    needs visibility of the client instance to be serialized and saved, and an implementation
    of the `IDatabaseController` interface to perform the create operation for us.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用我们的新基础设施，并连接`CreateClientView`。如果您记得，我们提供了一个保存命令，当单击时，会调用`CommandController`上的`onCreateClientSaveExecuted()`。为了能够执行任何有用的操作，`CommandController`需要能够序列化和保存客户端实例，并且需要一个`IDatabaseController`接口的实现来为我们执行创建操作。
- en: 'Inject them into the constructor in `command-controller.h`, including any necessary
    headers:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们注入到`command-controller.h`中的构造函数中，包括任何必要的头文件：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As we’ve seen a few times now, add the member variables to `Implementation`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们现在已经看到了几次，将成员变量添加到`Implementation`中：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Pass them through the `CommandController` constructor to the Implementation
    constructor:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们通过`CommandController`构造函数传递到Implementation构造函数：
- en: '[PRE19]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we can update the `onCreateClientSaveExecuted()` method to create our new
    client:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以更新`onCreateClientSaveExecuted()`方法来创建我们的新客户端：
- en: '[PRE21]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Our client instance provides us with all the information we need to be able
    to save it to the database, and the database controller performs the database
    interactions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户端实例为我们提供了保存到数据库所需的所有信息，数据库控制器执行数据库交互。
- en: Our `CommandController` is now ready, but we’re not actually injecting the database
    controller or new client in yet, so head over to `master-controller.cpp` and add
    an instance of a `DatabaseController` as we did with `CommandController` and `NavigationController`.
    Add a private member, accessor method, and `Q_PROPERTY`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`CommandController`现在已经准备就绪，但我们实际上还没有注入数据库控制器或新客户端，因此转到`master-controller.cpp`，并像我们在`CommandController`和`NavigationController`中一样添加一个`DatabaseController`实例。添加一个私有成员，访问器方法和`Q_PROPERTY`。
- en: 'In the `Implementation` constructor, we need to ensure that we initialize the
    new client and `DatabaseController` before we initialize the `CommandController`,
    and then pass the pointers through:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Implementation`构造函数中，我们需要确保在初始化`CommandController`之前初始化新的客户端和`DatabaseController`，然后通过指针传递：
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Build and run `cm-ui`, and you should see messages in the Application Output
    from the newly instantiated `DatabaseController`, telling you that it has created
    the database and table:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和运行`cm-ui`，您应该在应用程序输出中看到新实例化的`DatabaseController`的消息，告诉您它已经创建了数据库和表：
- en: '[PRE23]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Take a look at the output folder where your binaries are, and you will see a
    new `cm.sqlite` file.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 查看您的二进制文件所在的输出文件夹，您将看到一个新的`cm.sqlite`文件。
- en: 'If you navigate to Create Client View, enter a name, and click on the Save
    button, you will see further output, confirming that the new client has been saved
    successfully:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您导航到创建客户端视图，输入名称，然后单击保存按钮，您将看到进一步的输出，确认新客户端已成功保存：
- en: '[PRE24]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let’s take a look inside our database and see what work has been done for us.
    There are several SQLite browsing applications and web browser plugins available,
    but the one I tend to use is found at [http://sqlitebrowser.org/](http://sqlitebrowser.org/).
    Download and install this, or any other client of your choice for your operating
    system, and open the `cm.sqlite` file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的数据库内部，并查看为我们完成了哪些工作。有几个SQLite浏览应用程序和Web浏览器插件可用，但我倾向于使用的是[http://sqlitebrowser.org/](http://sqlitebrowser.org/)上找到的一个。下载并安装这个，或者您选择的任何其他客户端适用于您的操作系统，并打开`cm.sqlite`文件：
- en: '![](img/035414d6-2999-4408-b674-f05e382fe65d.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/035414d6-2999-4408-b674-f05e382fe65d.png)'
- en: 'You will see that we have a client table, just as we asked for, with two fields: id
    and json. Browse Data for the client table, and you will see our newly created
    record with the name property we entered on the UI:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到我们有一个客户端表，就像我们要求的那样，有两个字段：id和json。浏览客户端表的数据，您将看到我们新创建的记录，其中包含我们在UI上输入的名称属性：
- en: '![](img/63acbb6f-08c5-42b8-8189-e2cc4d95bb86.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/63acbb6f-08c5-42b8-8189-e2cc4d95bb86.png)'
- en: Fantastic, we have created our first client in the database. Note that the `DatabaseController`
    initialization methods are idempotent, so you can launch the application again
    and the existing database will not be affected. Similarly, if you manually delete
    the `cm.sqlite` file, then launching the application will create a new version
    for you (without the old data), which is a simple way of deleting test data.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，我们已经在数据库中创建了我们的第一个客户端。请注意，`DatabaseController`初始化方法是幂等的，因此您可以再次启动应用程序，现有的数据库不会受到影响。同样，如果您手动删除`cm.sqlite`文件，然后启动应用程序将为您创建一个新版本（不包括旧数据），这是一种简单的删除测试数据的方法。
- en: 'Let’s make a quick tweak to add the `reference` property of the client. In
    `CreateClientView`, duplicate the `StringEditorSingleLine` component bound to
    `ui_name`, and bind the new control to `ui_reference`. Build, run, and create
    a new client:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速调整一下，添加客户的`reference`属性。在`CreateClientView`中，复制绑定到`ui_name`的`StringEditorSingleLine`组件，并将新控件绑定到`ui_reference`。构建、运行，并创建一个新的客户：
- en: '![](img/2c9bf851-c9e6-4512-9e50-8cffc2b6c766.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2c9bf851-c9e6-4512-9e50-8cffc2b6c766.png)'
- en: 'Our new client happily uses the specified client reference as the unique primary
    key:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新客户愉快地使用指定的客户引用作为唯一的主键：
- en: '![](img/fcbd34f0-f483-49be-beed-c0b2fb8dda95.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fcbd34f0-f483-49be-beed-c0b2fb8dda95.png)'
- en: Panels
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面板
- en: 'Now, let''s flesh out our `CreateClientView` a little so that we can actually
    save some meaningful data rather than just a bunch of empty strings. We still
    have lots of fields to add in, so we''ll break things up a little, and also visually
    separate the data from the different models, by encapsulating them in discreet
    panels with descriptive titles and a drop shadow to give our UI a bit of pizzazz:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们稍微完善一下我们的`CreateClientView`，这样我们就可以保存一些有意义的数据，而不仅仅是一堆空字符串。我们还有很多字段要添加，所以我们会稍微分开一些东西，并且通过将它们封装在具有描述性标题和下拉阴影的离散面板中，从视觉上将数据与不同的模型分开，为我们的UI增添一些活力：
- en: '![](img/d1af194c-0617-4db3-ac07-4fb20013f77c.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1af194c-0617-4db3-ac07-4fb20013f77c.png)'
- en: 'We’ll begin by creating a generic panel component. Create a new QML file in
    `cm-ui/components` named `Panel.qml`. Update `components.qrc` and `qmldir`, as
    we have done for all the other components:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个通用的面板组件。在`cm-ui/components`中创建一个名为`Panel.qml`的新的QML文件。更新`components.qrc`和`qmldir`，就像我们为所有其他组件所做的那样：
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is an extremely dynamic component. Unlike our other components, where we
    pass in a string or maybe even a custom class, here we are passing in the entire
    contents of the panel. We achieve this using a `Loader` component, which loads
    a QML subtree on demand. We alias the `sourceComponent` property so that calling
    elements can inject their desired content at runtime.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常动态的组件。与我们的其他组件不同，我们在这里传递整个面板的内容，而不是传递一个字符串或者甚至是一个自定义类。我们使用`Loader`组件来实现这一点，它可以根据需要加载QML子树。我们别名`sourceComponent`属性，以便调用元素可以在运行时注入他们想要的内容。
- en: Due to the dynamic nature of the content, we can’t set the component to be a
    fixed size, so we leverage the `implicitWidth` and `implicitHeight` properties
    to tell parent elements how large the component wants to be based on the size
    of the title bar plus the size of the dynamic content.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于内容的动态性，我们无法设置组件的固定大小，因此我们利用`implicitWidth`和`implicitHeight`属性告诉父元素组件希望的大小，基于标题栏的大小加上动态内容的大小。
- en: To render the shadow, we draw a simple `Rectangle`, ensuring that it is rendered
    first by placing it near the top of the file. We then use the `x` and `y` properties
    to offset it from the rest of the elements, moving it slightly across and down.
    The remaining `Rectangle` elements for the header strip and panel background are
    then drawn over the top of the shadow.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了渲染阴影，我们绘制一个简单的`Rectangle`，确保它首先被渲染，通过将它放在文件的顶部附近。然后我们使用`x`和`y`属性来使其与其他元素偏移，稍微向下和向下移动。然后，用于标题条和面板背景的其余`Rectangle`元素被绘制在阴影的顶部。
- en: 'To support the styling here, we need to add a collection of new `Style` properties:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这里的样式，我们需要添加一系列新的`Style`属性：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Next, let’s add a component for address editing so that we can reuse it for
    both the supply and billing addresses. Create a new QML file in `cm-ui/components`
    named `AddressEditor.qml`. Update `components.qrc` and `qmldir` as earlier.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加一个地址编辑组件，这样我们就可以在供应地址和账单地址上重用它。在`cm-ui/components`中创建一个名为`AddressEditor.qml`的新的QML文件。像之前一样更新`components.qrc`和`qmldir`。
- en: 'We’ll use our new `Panel` component as the root element and add an `Address`
    property, so that we can pass in an arbitrary data model to bind to:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们的新的`Panel`组件作为根元素，并添加一个`Address`属性，这样我们就可以传递一个任意的数据模型进行绑定：
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, you can see the flexibility of our new `Panel` component in action, thanks
    to the embedded `Loader` element. We can pass in whatever QML content we want,
    and it will be presented in the panel.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们新的`Panel`组件的灵活性，这要归功于嵌入的`Loader`元素。我们可以传递任何我们想要的QML内容，并且它将显示在面板中。
- en: 'Finally, we can update our `CreateClientView` to add our new refactored address
    components. We’ll also move the client controls onto their own panel:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以更新我们的`CreateClientView`，添加我们新重构的地址组件。我们还将客户控件移动到它们自己的面板上：
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Before we build and run, we just need to tweak the background color of our
    `StringEditorSingleLine` `textLabel` so that it matches the panels they are now
    displayed on:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建和运行之前，我们只需要调整`StringEditorSingleLine`的`textLabel`的背景颜色，以使其与它们现在显示在的面板匹配：
- en: '[PRE30]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![](img/b6e32497-89df-4bf3-ba33-42af47bc0b7b.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b6e32497-89df-4bf3-ba33-42af47bc0b7b.png)'
- en: Go ahead and create a new client and check the database. You should now see
    the supply and billing address details successfully saved. We’ve now got the C
    in our CRUD operational, so let’s move on to the ‘R’.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 继续创建一个新的客户并检查数据库。现在你应该看到供应和账单地址的详细信息已经成功保存。我们现在已经让我们的CRUD操作起作用了，所以让我们继续进行‘R’。
- en: Finding clients
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找客户
- en: We've just successfully saved our first clients to the database, so let's now
    look at how we can find and view that data. We’ll encapsulate our searching functionality
    in a dedicated class in `cm-lib`, so go ahead and create a new class named `ClientSearch`
    in `cm-lib/source/models`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚成功地将我们的第一个客户保存到数据库中，现在让我们看看如何找到并查看这些数据。我们将在`cm-lib`中的一个专用类中封装我们的搜索功能，所以继续在`cm-lib/source/models`中创建一个名为`ClientSearch`的新类。
- en: '`client-search.h`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`client-search.h`:'
- en: '[PRE31]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`client-search.cpp`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`client-search.cpp`:'
- en: '[PRE32]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We need to capture some text from the user, search the database using that text,
    and display the results as a list of matching clients. We accommodate the text
    using a `StringDecorator`, implement a `search()` method to perform the search
    for us, and finally, add an `EntitityCollection<Client>` to store the results.
    One additional point of interest here is that we need to signal to the UI when
    the search results have changed so that it knows that it needs to rebind the list.
    To do this, we notify using the signal `searchResultsChanged()`, and we connect
    this signal directly to the `collectionChanged()` signal built into `EntityCollection`.
    Now, whenever the list that is hidden away in `EntityCollection` is updated, the
    UI will be automatically notified of the change and will redraw itself as needed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从用户那里捕获一些文本，使用该文本搜索数据库，并将结果显示为匹配客户的列表。我们使用“StringDecorator”来容纳文本，实现一个“search()”方法来执行搜索，最后，添加一个“EntitityCollection<Client>”来存储结果。这里还有一个额外的要点是，我们需要向UI发出信号，告诉它搜索结果已经改变，这样它就知道需要重新绑定列表。为此，我们使用“searchResultsChanged()”信号进行通知，并将此信号直接连接到“EntityCollection”中内置的“collectionChanged()”信号。现在，每当隐藏在“EntityCollection”中的列表更新时，UI将自动收到更改通知，并根据需要重新绘制自己。
- en: Next, add an instance of `ClientSearch` to `MasterController`, just as we did
    for the new client model. Add a private member variable of the `ClientSearch*` type
    named `clientSearch`, and initialize it in the `Implementation` constructor. Remember
    to pass the `databaseController` dependency to the constructor. Now that we are
    passing more and more dependencies, we need to be careful about the initialization
    order. `ClientSearch` has a dependency on `DatabaseController`, and when we come
    to implement our search commands in `CommandController`, that will have a dependency
    on `ClientSearch`. So ensure that you initialize `DatabaseController` before `ClientSearch`
    and that `CommandController` comes after both of them. To finish off the changes
    to `MasterController`, add a `clientSearch()` accessor method and a `Q_PROPERTY`
    named `ui_clientSearch`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在“MasterController”中添加一个“ClientSearch”的实例，就像我们为新的客户模型所做的那样。添加一个名为“clientSearch”的私有成员变量，类型为“ClientSearch*”，并在“Implementation”构造函数中对其进行初始化。记得将“databaseController”依赖项传递给构造函数。现在我们正在传递越来越多的依赖项，我们需要小心初始化顺序。“ClientSearch”依赖于“DatabaseController”，当我们来实现在“CommandController”中的搜索命令时，它将依赖于“ClientSearch”。因此，请确保在初始化“ClientSearch”之前初始化“DatabaseController”，并且“CommandController”在它们两者之后初始化。完成对“MasterController”的更改后，添加一个“clientSearch()”访问器方法和一个名为“ui_clientSearch”的“Q_PROPERTY”。
- en: 'As usual, we need to register the new class in the QML subsystem before we
    can use it in the UI. In `main.cpp`, `#include <models/client-search.h>` and register
    the new type:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，在我们可以在UI中使用它之前，我们需要在QML子系统中注册新的类。在“main.cpp”中，`#include <models/client-search.h>`并注册新类型：
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'With all that in place, we can wire up our `FindClientView`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这一切，我们可以连接我们的“FindClientView”：
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We access the `ClientSearch` instance via `MasterController` and create a shortcut
    to it with a property. We also utilize our new `Panel` component again, which
    gives us a nice consistent look and feel across views with very little work:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过“MasterController”访问“ClientSearch”实例，并使用属性创建一个快捷方式。我们还再次利用我们的新“Panel”组件，这样可以在视图之间提供一个漂亮一致的外观和感觉，而工作量很小：
- en: '![](img/ff6f1c18-de37-4492-952d-1c01d8775251.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff6f1c18-de37-4492-952d-1c01d8775251.png)'
- en: 'The next step is to add a command button for us to be able to instigate a search.
    We do this back over in `CommandController`. Before we get into the commands,
    we have an additional dependency on the `ClientSearch` instance, so add a parameter
    to the constructor:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加一个命令按钮，以便我们能够发起搜索。我们在“CommandController”中完成这个操作。在我们开始命令之前，我们对“ClientSearch”实例有一个额外的依赖，所以在构造函数中添加一个参数：
- en: '[PRE35]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Pass the parameter through to the `Implementation` class and store it in a
    private member variable, just as we did with `newClient`. Hop back to `MasterController`
    briefly and add the `clientSearch` instance into the `CommandController` initialization:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 像我们对“newClient”所做的那样，通过参数传递到“Implementation”类，并将其存储在一个私有成员变量中。暂时回到“MasterController”，并将“clientSearch”实例添加到“CommandController”的初始化中：
- en: '[PRE36]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Next, in `CommandController`, duplicate and rename the private member variable,
    accessor, and `Q_PROPERTY` that we added for the create client view so that you
    end up with a `ui_findClientViewContextCommands` property for the UI to use.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在“CommandController”中，复制并重命名我们为创建客户视图添加的私有成员变量、访问器和“Q_PROPERTY”，这样你就会得到一个“ui_findClientViewContextCommands”属性供UI使用。
- en: 'Create an additional public slot, `onFindClientSearchExecuted()`, which will
    be called when we hit the search button:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个额外的公共槽，“onFindClientSearchExecuted()”，当我们点击搜索按钮时将被调用：
- en: '[PRE37]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now we have an empty command list for our find view and a delegate to be called
    when we click on the button; all we need to do now is add a search button to the
    `Implementation` constructor:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为我们的查找视图有一个空的命令列表，并且有一个在点击按钮时要调用的委托；我们现在需要做的就是在“Implementation”构造函数中添加一个搜索按钮：
- en: '[PRE38]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'That’s it for the command plumbing; we can now easily add a command bar to
    `FindClientView`. Insert the following as the last element within the root item:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 命令管道就到这里了；现在我们可以很容易地向“FindClientView”添加一个命令栏。将以下内容插入到根项目的最后一个元素中：
- en: '[PRE39]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '![](img/1c44bc94-195d-43b8-b7c0-4129fb1fc62e.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1c44bc94-195d-43b8-b7c0-4129fb1fc62e.png)'
- en: 'Enter some search text and click on the button, and you will see in the Application
    Output console that everything triggers as expected:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一些搜索文本并点击按钮，你会看到在应用程序输出控制台中一切都按预期触发了：
- en: '[PRE40]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Great, now what we need to do is take the search text, query the SQLite database
    for a list of results, and display those results on screen. Fortunately, we’ve
    already done the groundwork for querying the database, so we can easily implement
    that:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，现在我们需要做的是获取搜索文本，查询SQLite数据库以获取结果列表，并在屏幕上显示这些结果。幸运的是，我们已经为查询数据库做好了准备，所以我们可以很容易地实现这一点：
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'There is a bit more work to do on the UI side to display the results. We need
    to bind to the `ui_searchResults` property and dynamically display some sort of
    QML subtree for each of the clients in the list. We will use a new QML component,
    `ListView`, to do the heavy lifting for us. Let’s start simple to demonstrate
    the principle and then build out from there. In `FindClientView`, immediately
    after the Panel element, add the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在UI方面还有更多工作要做来显示结果。我们需要绑定到`ui_searchResults`属性，并动态显示列表中每个客户端的某种QML子树。我们将使用一个新的QML组件`ListView`来为我们完成繁重的工作。让我们从简单开始，以演示原理，然后逐步构建。在`FindClientView`中，立即在Panel元素之后添加以下内容：
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The two key properties of a `ListView` are as listed:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView`的两个关键属性如下：'
- en: The `model`, which is the list of items that you want to display
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`model`，即你想要显示的项目列表'
- en: The `delegate`, which is how you want to visually represent each item
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理，即你想要如何在视觉上表示每个项目
- en: In our case, we bind the model to our `ui_searchResults` and represent each
    item with a simple `Text` element displaying the client reference number. Of particular
    importance here is the `modelData` property, which is magically injected into
    the delegate for us and exposes the underlying item (which is a client object,
    in this case).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们将模型绑定到我们的`ui_searchResults`，并用一个简单的`Text`元素表示每个项目，显示客户参考编号。这里特别重要的是`modelData`属性，它被神奇地注入到代理中，为我们暴露了底层项目（在这种情况下是一个客户对象）。
- en: 'Build, run, and perform a search for a piece of text you know exists in the
    JSON for one of the test clients you have created so far, and you will see that
    the reference number is displayed for each of the results. If you get more than
    one result and they lay out incorrectly, don’t worry, as we will replace the delegate
    anyway:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 构建，运行，并对你迄今为止创建的一个测试客户端的JSON中存在的文本进行搜索，你会发现每个结果都显示了参考编号。如果你得到了多个结果并且它们排列不正确，不要担心，因为我们无论如何都会替换代理：
- en: '![](img/a63d1111-ec63-4786-a8bc-0614cd56606f.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a63d1111-ec63-4786-a8bc-0614cd56606f.png)'
- en: 'To keep things neat and tidy, we’ll write a new custom component to use as
    the delegate. Create `SearchResultDelegate` in `cm-ui/components`, and update
    `components.qrc` and `qmldir` as usual:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持整洁，我们将编写一个新的自定义组件用作代理。在`cm-ui/components`中创建`SearchResultDelegate`，并像往常一样更新`components.qrc`和`qmldir`：
- en: '[PRE43]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: There isn’t really anything new here, we’ve just combined techniques covered
    in other components. Note that the `MouseArea` element will trigger a method on
    `masterController` that we haven’t implemented yet, so don’t worry if you run
    this and get an error when you click on one of the clients.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里并没有什么新东西，我们只是结合了其他组件中涵盖的技术。请注意，`MouseArea`元素将触发`masterController`上我们尚未实现的方法，所以如果你点击其中一个客户端时出现错误，不要担心。
- en: 'Replace the old `Text` delegate in `FindClientView` with our new component
    using the `modelData` property to set the `client`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在`FindClientView`中用我们的新组件替换旧的`Text`代理，使用`modelData`属性来设置`client`：
- en: '[PRE44]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '![](img/763dcfa3-7b48-4081-a618-625ed04edda2.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/763dcfa3-7b48-4081-a618-625ed04edda2.png)'
- en: 'Now, let’s implement the `selectClient()` method on `MasterController`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`MasterController`上实现`selectClient()`方法：
- en: We can just emit the `goEditClientView()` signal directly from the `SearchResultDelegate`
    and bypass `MasterController` entirely. This is a perfectly valid approach and
    is indeed simpler; however, I prefer to route all the interactions through the
    business logic layer, even if all the business logic does is to emit the navigation
    signal. This means that if you need to add any further logic later on, everything
    is already wired up and you don’t need to change any of the plumbing. It’s also
    much easier to debug C++ than QML.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接从`SearchResultDelegate`发出`goEditClientView()`信号，并完全绕过`MasterController`。这是一个完全有效的方法，而且确实更简单；然而，我更喜欢通过业务逻辑层路由所有交互，即使所有业务逻辑只是发出导航信号。这意味着如果以后需要添加任何进一步的逻辑，一切都已经连接好，你不需要更改任何管道。而且，调试C++比QML要容易得多。
- en: 'In `master-controller.h`, we need to add our new method as a public slot as
    it will be called directly from the UI, which won’t have visibility of a regular
    public method:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`master-controller.h`中，我们需要将我们的新方法添加为公共槽，因为它将直接从UI中调用，而UI无法看到常规的公共方法：
- en: '[PRE45]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Provide the implementation in `master-controller.cpp`, simply calling the relevant
    signal on the navigation coordinator and passing through the client:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在`master-controller.cpp`中提供实现，简单地调用导航协调器上的相关信号，并传递客户端：
- en: '[PRE46]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: With the searching and selection in place, we can now turn our attention to
    editing clients.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索和选择已经就位，现在我们可以转向编辑客户端。
- en: Editing clients
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑客户端
- en: With an existing client now located and loaded from the database, we need a
    mechanism to be able to view and edit the data. Let’s prepare by first creating
    the context commands we will use in the edit view. Repeat the steps we took for
    the Find Client View and in `CommandController`, add a new list of commands named
    `editClientViewContextCommands`, along with an accessor method and `Q_PROPERTY`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经从数据库中找到并加载了现有的客户端，我们需要一种机制来查看和编辑数据。首先，让我们创建在编辑视图中将使用的上下文命令。重复我们为查找客户端视图所采取的步骤，在`CommandController`中添加一个名为`editClientViewContextCommands`的新命令列表，以及一个访问方法和`Q_PROPERTY`。
- en: 'Create a new slot to be called when the user saves their changes on the edit
    view:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的槽，当用户在编辑视图上保存他们的更改时调用：
- en: '[PRE47]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Add a new save command to the list that calls the slot when executed:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用时向列表添加一个新的保存命令，调用槽：
- en: '[PRE48]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We now have a list of commands we can present to the Edit Client View; however,
    a challenge that we now need to overcome is that when we execute this command,
    the `CommandController` has no idea which client instance it needs to work with.
    We can’t pass in the selected client as a dependency to the constructor like we
    do with the new client, because we have no idea which client the user will select.
    One option would be to move the list of edit commands out of the `CommandController`
    and into the client model. Then, each client instance can present its own commands
    to the UI. However, this means that command functionality is fractured, and we
    lose the nice encapsulation that the command controller gives us. It also bloats
    the **client** model with functionality it shouldn’t care about. Instead, we will
    add the currently selected client as a member within `CommandController` and set
    it whenever the user navigates to the `editClientView`. In `CommandController::Implementation`,
    add the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个可以呈现给编辑客户端视图的命令列表；然而，我们现在需要克服的一个挑战是，当我们执行这个命令时，`CommandController` 不知道它需要处理哪个客户端实例。我们不能像处理新客户端那样将选定的客户端作为依赖项传递给构造函数，因为我们不知道用户会选择哪个客户端。一个选择是将编辑命令列表从`CommandController`移出，并放入客户端模型中。然后，每个客户端实例可以向UI呈现自己的命令。然而，这意味着命令功能被分割，我们失去了命令控制器给我们的封装性。它还使**客户端**模型膨胀了不应该关心的功能。相反，我们将当前选定的客户端作为`CommandController`的成员添加到其中，并在用户导航到`editClientView`时设置它。在`CommandController::Implementation`中添加以下内容：
- en: '[PRE49]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Add a new public slot:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个新的公共槽：
- en: '[PRE50]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now that we have the selected client available, we can go ahead and complete
    the implementation of the save slot. Again, we’ve already done the hard work in
    the `DatabaseController` and client classes, so this method is really straightforward:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了选定的客户端，我们可以继续完成保存槽的实现。同样，我们已经在`DatabaseController`和客户端类中完成了繁重的工作，所以这个方法非常简单：
- en: '[PRE51]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'From the UI point of view, editing an existing client will essentially be the
    same as creating a new client. So much so, in fact, that we can even probably
    use the same view and just pass in a different client object in each case. However,
    we’ll keep the two functions separate and just copy and tweak the QML we’ve already
    written for creating a client. Update `EditClientView`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 从UI的角度来看，编辑现有客户端基本上与创建新客户端是一样的。实际上，我们甚至可能可以使用相同的视图，只是在每种情况下传入不同的客户端对象。然而，我们将保持这两个功能分开，并只是复制和调整我们已经为创建客户端编写的QML。更新`EditClientView`：
- en: '[PRE52]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We change the client property to match the `selectedClient` property `MasterView`
    sets in the `Connections` element. We use the `Component.onCompleted` slot to
    call through to `CommandController` and set the currently selected client. Finally,
    we update `CommandBar` to reference the new context command list we just added.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将客户端属性更改为`MasterView`在`Connections`元素中设置的`selectedClient`属性。我们使用`Component.onCompleted`槽调用`CommandController`并设置当前选定的客户端。最后，我们更新`CommandBar`以引用我们刚刚添加的新上下文命令列表。
- en: Build and run, and you should now be able to make changes to a selected client
    and use the Save button to update the database.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行，现在您应该能够对选定的客户端进行更改，并使用保存按钮更新数据库。
- en: Deleting clients
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除客户端
- en: 'The final part of our CRUD operations is deleting an existing client. Let’s
    trigger this via a new button on `EditClientView`. We’ll begin by adding the slot
    that will be called when the button is pressed to `CommandController`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们CRUD操作的最后一部分是删除现有客户端。让我们通过`EditClientView`上的一个新按钮触发这个操作。我们将首先向`CommandController`添加在按下按钮时将被调用的槽：
- en: '[PRE53]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This follows the same pattern as the other slots, except this time we also clear
    the `selectedClient` property as although the client instance still exists in
    application memory, it has been semantically deleted by the user. We also refresh
    the search so that the deleted client is removed from the search results. As this
    method stands, we’ve performed the correct database interaction but the user will
    be left on `editClientView` for a client that they have just asked to be deleted.
    What we want is for the user to be navigated back to the dashboard. In order to
    do this, we need to add `NavigationController` as an additional dependency to
    our `CommandController` class. Replicate what we did for the `DatabaseController`
    dependency so that we can inject it into the constructor. Remember to update `MasterController`
    and pass in the navigation controller instance.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这遵循了其他槽的相同模式，只是这一次我们还清除了`selectedClient`属性，因为虽然客户端实例仍然存在于应用程序内存中，但它已经被用户语义化地删除了。我们还刷新搜索，以便从搜索结果中删除已删除的客户端。就目前而言，我们已经执行了正确的数据库交互，但用户将被留在刚刚要求删除的客户端的`editClientView`上。我们希望用户被导航回仪表板。为了做到这一点，我们需要将`NavigationController`作为`CommandController`类的附加依赖项添加进去。复制我们为`DatabaseController`依赖项所做的操作，以便我们可以将其注入到构造函数中。记得更新`MasterController`并传入导航控制器实例。
- en: 'With an instance of a database controller available, we can then send the user
    to the Dashboard View:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 有了数据库控制器的实例，我们可以将用户发送到仪表板视图：
- en: '[PRE54]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now that we have the navigation controller available, we can also improve the
    experience when creating new clients. Rather than leaving the user on the new
    client view, let’s perform a search for the newly created client ID and navigate
    them to the results. They can then easily select the new client if they wish to
    view or edit:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了导航控制器，我们还可以改进创建新客户端时的体验。让用户不再停留在新客户端视图上，而是执行对新创建的客户端ID的搜索并将他们导航到结果。然后他们可以轻松地选择新客户端，如果他们希望查看或编辑：
- en: '[PRE55]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'With the deletion slot complete, we can now add a new delete command to the
    `editClientContextCommands` list in `CommandController`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 删除槽完成后，我们现在可以在`CommandController`的`editClientContextCommands`列表中添加一个新的删除命令：
- en: '[PRE56]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We are now presented with the option to delete an existing client:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以选择删除现有的客户端了：
- en: '![](img/a16062b1-ad68-44bf-ad11-094b3cc3c6b7.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a16062b1-ad68-44bf-ad11-094b3cc3c6b7.png)'
- en: 'If you delete a client, you will see that the row is removed from the database
    and the user is successfully navigated back to the dashboard. However, you will
    also see that the Application Output window is full of QML warnings along the
    lines of `qrc:/views/EditClientView:62: TypeError: Cannot read property ''ui_billingAddress''
    of null`.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '如果删除客户端，您将看到该行已从数据库中删除，并且用户成功导航回仪表板。但是，您还会看到应用程序输出窗口中充满了类似`qrc:/views/EditClientView:62:
    TypeError: Cannot read property ''ui_billingAddress'' of null`的QML警告。'
- en: 'The reason for this is that the edit view is bound to a client instance that
    is part of the search results. When we refresh the search, we delete the old search
    results, which means that the edit view is now bound to `nullptr` and can no longer
    access the data. This continues to happen even if you navigate to the dashboard
    before refreshing the search, because of the asynchronous nature of the signals/slots
    used to perform the navigation. One way of fixing these warnings is to add null
    checks on all the bindings in the view and bind to local temporary objects if
    the main object is null. Consider the following example:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是编辑视图绑定到搜索结果的客户端实例。当我们刷新搜索时，我们会删除旧的搜索结果，这意味着编辑视图现在绑定到`nullptr`，无法再访问数据。即使在刷新搜索之前导航到仪表板，也会发生这种情况，因为执行导航的信号/槽的异步性质。修复这些警告的一种方法是在视图中对所有绑定添加空检查，并在主对象为空时绑定到本地临时对象。考虑以下示例：
- en: '[PRE57]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'So, if `selectedClient` is not null, bind to the `ui_reference` property of
    that, otherwise bind to `temporaryObject`. You can even add a level of indirection
    to the root Client property and substitute the entire client object:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果`selectedClient`不为空，则绑定到该对象的`ui_reference`属性，否则绑定到`temporaryObject`。甚至可以在根客户端属性上添加一层间接，并替换整个客户端对象：
- en: '[PRE58]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Here, `selectedClient` will be set by the parent as normal; `localTemporaryClient`
    will not be set, so a default instance will be created locally. `clientToBindTo`
    will then pick the appropriate object to use and all the child controls can bind
    to that. As these bindings are dynamic, if `selectedClient` was deleted after
    loading the view (as in our case), then `clientToBindTo` will automatically switch
    over.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`selectedClient`将像往常一样由父级设置；`localTemporaryClient`将不会被设置，因此将在本地创建一个默认实例。然后，`clientToBindTo`将选择适当的对象使用，并且所有子控件都可以绑定到该对象。由于这些绑定是动态的，如果在加载视图后删除了`selectedClient`（就像我们的情况一样），那么`clientToBindTo`将自动切换。
- en: As this is just a demonstration project, it is safe for us to ignore the warnings,
    so we will take no action here to keep things simple.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这只是一个演示项目，我们可以安全地忽略警告，因此我们在这里不会采取任何行动，以保持简单。
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we added database persistence for our client models. We made
    it generic and flexible so that we can easily persist other model hierarchies
    by simply adding a new table to our `DatabaseController` class. We covered all
    the core CRUD operations, including a free text search capability that matches
    against the entire JSON object.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为客户端模型添加了数据库持久性。我们使其通用和灵活，以便我们可以通过简单地向`DatabaseController`类添加新表来轻松持久化其他模型层次结构。我们涵盖了所有核心CRUD操作，包括针对整个JSON对象进行匹配的自由文本搜索功能。
- en: In [Chapter 8](d04b2aa4-cbbe-4826-b27f-5f00ea4cfb07.xhtml), *Web Requests*,
    we will continue the theme of reaching outside of our application for data and
    look at another extremely common Line of Business application requirement making
    HTTP requests to web services.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](d04b2aa4-cbbe-4826-b27f-5f00ea4cfb07.xhtml)中，*Web请求*，我们将继续探讨超出我们应用程序范围的数据，并查看另一个极其常见的业务应用程序需求，即向Web服务发出HTTP请求。
