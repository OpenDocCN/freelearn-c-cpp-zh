- en: Optimizing Your Code for Performance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为性能优化您的代码
- en: Optimizing your code for performance ensures your code is getting the most out
    of what C++ can offer. Unlike other high-level languages, C++ is capable of providing
    high-level syntactical freedom without sacrificing performance, although admittedly
    at the expense of a higher learning curve.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 优化代码以提高性能可以确保您的代码充分利用了C++所能提供的功能。与其他高级语言不同，C++能够提供高级的语法自由，而不会牺牲性能，尽管诚然会增加学习曲线的成本。
- en: This chapter is important because it will demonstrate more advanced methods
    for optimizing your code, including how to benchmark your software at the unit
    level, how to examine the resulting assembly code your compiler produces for potential
    optimizations, how to reduce the number of memory resources your application is
    using, and why compiler hints such as `noexcept` are important. After reading
    this chapter, you will have the skills to write more efficient C++.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章很重要，因为它将演示更高级的优化代码方法，包括如何在单元级别对软件进行基准测试，如何检查编译器为潜在优化而生成的结果汇编代码，如何减少应用程序使用的内存资源数量，以及为什么编译器提示（如`noexcept`）很重要。阅读完本章后，您将具备编写更高效C++代码的技能。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Benchmarking your code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对代码进行基准测试
- en: Looking at assembly code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看汇编代码
- en: Reducing the number of memory allocations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少内存分配的数量
- en: Declaring noexcept
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明noexcept
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To compile and run the examples in this chapter, you must have administrative
    access to a computer running Ubuntu 18.04 with a functional internet connection.
    Prior to running these examples, you must install the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和运行本章中的示例，您必须具有管理访问权限，可以访问运行Ubuntu 18.04的计算机，并具有功能正常的互联网连接。在运行这些示例之前，您必须安装以下内容：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If this is installed on any operating system other than Ubuntu 18.04, then GCC
    7.4 or higher and CMake 3.6 or higher will be required.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是安装在Ubuntu 18.04以外的任何操作系统上，则需要GCC 7.4或更高版本和CMake 3.6或更高版本。
- en: Benchmarking your code
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对代码进行基准测试
- en: In this recipe, you will learn how to benchmark and optimize your source code.
    Optimizing source code will result in more efficient C++, which increases battery
    life, improves performance, and so on. This recipe is important as the process
    of optimizing source code starts with determining which resource you plan to optimize,
    which could include speed, memory, and even power. Without benchmarking tools,
    it is extremely difficult to compare different approaches to the same problem.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，您将学习如何对源代码进行基准测试和优化。优化源代码将导致更高效的C++，从而增加电池寿命，提高性能等。这个配方很重要，因为优化源代码的过程始于确定您计划优化的资源，这可能包括速度、内存甚至功耗。没有基准测试工具，要比较解决同一个问题的不同方法是非常困难的。
- en: 'There are countless benchmarking tools (anything that measures a single property
    of your program) available to C++ programmers, including C++ APIs such as Boost,
    Folly, and Abseil, and CPU-specific tools such as Intel''s vTune. There are also
    several profiling tools (anything the helps you understand the behavior of your
    program) such as valgrind and gprof. In this recipe, we will focus on two of these:
    Hayai and Valgrind. Hayai provides a simple example of a micro-benchmarking, while
    Valgrind provides an example of a more complete, though more complicated, dynamic
    analysis/profiling tool.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于C++程序员来说，有无数的基准测试工具（任何测量程序的单个属性的工具），包括Boost、Folly和Abseil等C++ API，以及诸如Intel的vTune之类的特定于CPU的工具。还有一些性能分析工具（任何帮助您了解程序行为的工具），如valgrind和gprof。在本配方中，我们将重点关注其中的两个：Hayai和Valgrind。Hayai提供了一个微基准测试的简单示例，而Valgrind提供了一个更完整、但更复杂的动态分析/性能分析工具的示例。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements have
    been met, including installing Ubuntu 18.04 or higher and running the following
    in a Terminal window:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保已满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once you've done this, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有适当的工具来编译和执行本配方中的示例。完成此操作后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'Perform the following steps to complete this recipe:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成这个配方：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端中运行以下命令以下载源代码：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To compile the source code, run the following command:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the source code has been compiled, you can execute each example in this
    recipe by running the following commands:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦源代码被编译，您可以通过运行以下命令来执行本配方中的每个示例：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本配方中所教授的课程的关系。
- en: How it works...
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'The most common optimization that''s applied to C++ is the speed of execution.
    To optimize C++ for speed, we must start by developing different approaches to
    the same problem and then benchmark each solution to determine which solution
    executes the fastest. Benchmarking tools such as Hayai, a C++ based benchmarking
    library on GitHub, aid in making this determination. To explain this, let''s look
    at a simple example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 应用于C++的最常见优化是执行速度。为了优化C++的速度，我们必须首先开发不同的方法来解决同一个问题，然后对每个解决方案进行基准测试，以确定哪个解决方案执行速度最快。基准测试工具，如GitHub上的基于C++的基准测试库Hayai，有助于做出这一决定。为了解释这一点，让我们看一个简单的例子：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we execute the preceding code, we get the following output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行上述代码时，我们会得到以下输出：
- en: '![](img/4b7883ec-9592-4fde-bb6f-bcc9465077c4.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4b7883ec-9592-4fde-bb6f-bcc9465077c4.jpg)'
- en: In the preceding example, we use the Hayai library to benchmark the performance
    difference between adding a string to a vector using `push_back()` versus `emplace_back()`.
    The difference between `push_back()` and `emplace_back()` is that `push_back()`
    creates the object and then copies or moves it into the vector, while `emplace_back()`
    creates the object in the vector itself without the need for the temporary object
    and subsequent copy/move. That is to say, if you use `push_back()`, an object
    must be constructed and then either copied or moved into the vector. If you use
    `emplace_back()`, the object is simply constructed. As expected, `emplace_back()`
    outperforms `push_back()`, which is why tools such as Clang-Tidy recommend the
    use of `emplace_back()` over `push_back()` whenever possible.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用Hayai库来基准测试使用`push_back()`和`emplace_back()`向向量添加字符串之间的性能差异。`push_back()`和`emplace_back()`之间的区别在于，`push_back()`创建对象，然后将其复制或移动到向量中，而`emplace_back()`在向量中创建对象本身，而无需临时对象和随后的复制/移动。也就是说，如果使用`push_back()`，必须构造对象，然后将其复制或移动到向量中。如果使用`emplace_back()`，则只需构造对象。如预期的那样，`emplace_back()`优于`push_back()`，这就是为什么诸如Clang-Tidy之类的工具建议尽可能使用`emplace_back()`而不是`push_back()`。
- en: Benchmark libraries such as Hayai are simple to use and extremely effective
    at aiding the programmer with optimizing source code and are capable of not only
    benchmarking speed but also resource usage as well. The problem with these libraries
    is they are better leveraged at the *unit* level and not at the *integration* and
    *system* level; that is, to test an entire executable, these libraries are not
    well suited to aid the programmer as they do not scale well as the size of the
    test increases. To analyze an entire executable and not a single function, tools
    such as Valgrind exist, which help you profile which functions need the most attention
    with respect to optimizations. From there, a benchmarking tool can be used to
    analyze the functions that need the most attention.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 基准库，如Hayai，使用简单，对帮助程序员优化源代码非常有效，并且不仅能够对速度进行基准测试，还能够对资源使用进行基准测试。这些库的问题在于它们更适合在*单元*级别而不是*集成*和*系统*级别进行利用；也就是说，要测试整个可执行文件，这些库不适合帮助程序员，因为随着测试规模的增加，它们的扩展性不佳。为了分析整个可执行文件而不是单个函数，存在诸如Valgrind之类的工具，它可以帮助您分析哪些函数在优化方面需要最多的关注。然后，可以使用基准测试工具来分析需要最多关注的函数。
- en: 'Valgrind is a dynamic analysis tool that''s capable of detecting memory leaks
    and tracing the execution of a program. To see this in action, let''s look at
    the following example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind是一种动态分析工具，能够检测内存泄漏并跟踪程序的执行。为了看到这一点，让我们看下面的示例：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding example, we increment a global variable (marked volatile to
    ensure the compiler does not optimize away the variable) from a function named
    `foo()` and then execute this function `100,000` times. To analyze this example,
    run the following (which uses `callgrind` to output how many times each function
    is called in your program):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们从名为`foo()`的函数中递增一个全局变量（标记为volatile以确保编译器不会优化掉该变量），然后执行这个函数`100,000`次。要分析这个示例，请运行以下命令（使用`callgrind`输出程序中每个函数被调用的次数）：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This results in the following output:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下输出：
- en: '![](img/f6aac4e5-2af5-426e-a176-9da59a0a379b.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6aac4e5-2af5-426e-a176-9da59a0a379b.png)'
- en: 'As we can see, the `foo()` function is listed near the top of the preceding output
    (with the dynamic linker''s `_dl_lookup_symbol_x()` function called the most,
    which is used to link the program prior to execution). It should be noted that
    the program lists (on the left-hand side) the total number of instructions for
    the `foo()` function as `800,000`. This is due to the `foo()` function being `8`
    assembly instructions long and being executed `100,000` times. For example, let''s
    look at the assembly of the `foo()` function using `objdump` (a tool capable of
    outputting the compiled assembly of an executable), as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`foo()`函数在前面的输出中位于最前面（动态链接器的`_dl_lookup_symbol_x()`函数被调用最多，用于在执行之前链接程序）。值得注意的是，程序列表（在左侧）中`foo()`函数的指令总数为`800,000`。这是因为`foo()`函数有`8`条汇编指令，并且被执行了`100,000`次。例如，让我们使用`objdump`（一种能够输出可执行文件编译汇编的工具）来查看`foo()`函数的汇编，如下所示：
- en: '![](img/f3a341c8-cf01-4265-9e74-e2496c465733.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3a341c8-cf01-4265-9e74-e2496c465733.png)'
- en: 'Using Valgrind, it is possible to profile an executable to determine which
    functions take the longest to execute. For example, let''s look at `ls`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Valgrind，可以对可执行文件进行分析，以确定哪些函数执行时间最长。例如，让我们看看`ls`：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This results in the following output:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下输出：
- en: '![](img/050bd8f5-9adc-4825-b4db-fc8970010080.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/050bd8f5-9adc-4825-b4db-fc8970010080.png)'
- en: As we can see, the `strcmp` function is called a lot. This information can be
    combined with benchmarking APIs at the *unit* level to determine whether a faster
    version of `strcmp` can be written (for example, using handwritten assembly and
    special CPU instructions). Using tools such as Hayai and Valgrind, it is possible
    to isolate which functions in your program are consuming the most CPU, memory,
    and even power, and rewrite them to provide better performance while focusing
    your efforts on the optimizations that will provide the best return of investment.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`strcmp`函数被频繁调用。这些信息可以与*单元*级别的基准测试API相结合，以确定是否可以编写更快的`strcmp`版本（例如，使用手写汇编和特殊的CPU指令）。使用诸如Hayai和Valgrind之类的工具，可以分离出程序中消耗最多CPU、内存甚至电源的函数，并重写它们以提供更好的性能，同时将精力集中在将提供最佳投资回报的优化上。
- en: Looking at assembly code
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看汇编代码
- en: 'In this recipe, we will take a look at the resulting assembly from two different
    optimizations: loop unrolling and pass-by-reference parameters. This recipe is
    important because it will teach you how to dive deeper into how the compiler converts
    C++ into executable code. This information will shed light on why C++ specifications
    such as the C++ Core Guidelines make the recommendations it does with respect
    to optimizations and performance. This is often critical when you''re attempting
    to write better C++ code, especially when you want to optimize it.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将从两种不同的优化中查看生成的汇编：循环展开和传引用参数。这个教程很重要，因为它将教会你如何深入了解编译器是如何将C++转换为可执行代码的。这些信息将揭示为什么C++规范（如C++核心指南）对于优化和性能做出了推荐。当你试图编写更好的C++代码时，尤其是当你想要优化它时，这通常是至关重要的。
- en: Getting ready
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements have
    been met, including installing Ubuntu 18.04 or higher and running the following
    in a Terminal window:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保已满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once you've done this, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有正确的工具来编译和执行本教程中的示例。完成这些操作后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps to complete this recipe:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成本教程：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端中，运行以下命令来下载源代码：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To compile the source code, run the following command:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once the source code has been compiled, you can execute each example in this
    recipe by running the following commands:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦源代码被编译，您可以通过运行以下命令来执行本教程中的每个示例：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些例子，并解释每个例子程序的作用以及它与本教程中所教授的课程的关系。
- en: How it works...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'One of the best ways to learn how to optimize your C++ code is to learn how
    to analyze the resulting assembly code that the compiler generates after compilation.
    In this recipe, we will learn how this analysis is done by looking at two different
    examples: loop unrolling and pass-by-reference parameters.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何优化C++代码的最佳方法之一是学习如何分析编译器在编译后生成的汇编代码。在本教程中，我们将学习如何通过查看两个不同的例子来进行这种分析：循环展开和传引用参数。
- en: 'Before we look at these examples, let''s look at a simple example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看这些例子之前，让我们先看一个简单的例子：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding example, we have nothing more than a `main()` function. We
    haven''t included any C or C++ libraries and the `main()` function itself is empty.
    If we compile this example, we will see that the resulting binary is still pretty
    large:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们只有一个`main()`函数。我们没有包含任何C或C++库，`main()`函数本身是空的。如果我们编译这个例子，我们会发现生成的二进制文件仍然非常大：
- en: '![](img/99ace8d4-1e3a-45be-a24f-c318040b45eb.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99ace8d4-1e3a-45be-a24f-c318040b45eb.png)'
- en: 'In this case, the example is `22kb` in size. To show the resulting assembly
    that the compiler generated for this code, we can do the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这个例子的大小是`22kb`。为了显示编译器为这段代码生成的汇编代码，我们可以这样做：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The resulting output of the preceding command should be surprising as there
    is a lot of code for an application that does absolutely nothing.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出结果应该令人惊讶，因为对于一个完全没有任何功能的应用程序来说，代码量很大。
- en: 'To get a better feel for how much code there really is, we can refine the output
    by using `grep`, a tool that lets us filter text from any command. Let''s look
    at all of the functions in the code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解有多少代码，我们可以通过使用`grep`来细化输出，这是一个让我们从任何命令中过滤文本的工具。让我们看看代码中的所有函数：
- en: '![](img/d17573c5-b2e5-4905-a7a5-29b065898a0d.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d17573c5-b2e5-4905-a7a5-29b065898a0d.png)'
- en: 'As we can see, there are several functions the compiler automatically adds
    to the code for you. This includes the `_init()`, `_fini()`, and `_start()` functions.
    We can also look at a specific function, such as our main function, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，编译器会自动为您添加几个函数。这包括`_init()`、`_fini()`和`_start()`函数。我们还可以查看特定的函数，比如我们的主函数，如下所示：
- en: '![](img/1b25fad2-bea6-4f4c-a87b-adb0e85f399d.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b25fad2-bea6-4f4c-a87b-adb0e85f399d.png)'
- en: In the preceding example, we search the output of `objdump` for `main>:` and
    `RETQ`. All the function names end with `>:` and the last instruction (typically)
    for each function is `RETQ` on an Intel 64-bit system.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们搜索`objdump`的输出，查找`main>:`和`RETQ`。所有函数名都以`>:`结尾，而每个函数的最后一条指令（通常）是在Intel
    64位系统上的`RETQ`。
- en: 'The following is the resulting assembly:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是生成的汇编：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First, it stores the current stack frame pointer (`rbp`) to the stack and loads
    the stack frame pointer with the current address of the stack (`rsp`) for the
    `main()` function.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它将当前的堆栈帧指针（`rbp`）存储到堆栈中，并将堆栈帧指针加载到`main()`函数的堆栈的当前地址（`rsp`）。
- en: 'This can be seen in every function and is called the function''s prolog. The
    only code that `main()` executes is `return 0`, which was added to the code automatically
    by the compiler:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在每个函数中看到，并称为函数的前言。`main()`执行的唯一代码是`return 0`，这是编译器自动添加的代码：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, the last assembly in this function contains the function''s epilog,
    which restores the stack frame pointer and returns:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个函数中的最后一个汇编包含了函数的结尾，它恢复了堆栈帧指针并返回：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now that we have a better understanding of how to get and read the resulting
    assembly for compiled C++, let''s look at an example of loop unrolling, which
    is the process of replacing a loop of instructions with its equivalent version
    of the instructions without a loop. To do this, ensure that the examples are compiled
    in release mode (that is, with compiler optimizations enabled) by configuring
    them using the following command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对如何获取和阅读编译后的C++程序的汇编结果有了更好的理解，让我们来看一个循环展开的例子，循环展开是用其等效的指令版本替换循环指令的过程。为了做到这一点，确保示例是在发布模式下编译的（也就是启用了编译器优化），通过以下命令进行配置：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To understand loop unrolling, let''s look at the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解循环展开，让我们看一下以下代码：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When the compiler encounters a loop, the resulting assembly it generates contains
    the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器遇到循环时，生成的汇编代码包含以下代码：
- en: '![](img/4414aa74-9275-444b-bf7a-a8a150a4a426.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4414aa74-9275-444b-bf7a-a8a150a4a426.png)'
- en: 'Let''s break this down:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first two instructions belong to the `for (auto i = 0U;` portion of the
    code. In this case, the `i` variable is stored in the `EAX` register and is set
    to `0` using the `XOR` instruction (the `XOR` instruction is faster on Intel for
    setting a register to 0 than a `MOV` instruction). The `NOPW` instruction can
    be safely ignored.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 前两条指令属于代码的`for (auto i = 0U;`部分。在这种情况下，`i`变量存储在`EAX`寄存器中，并使用`XOR`指令将其设置为`0`（在Intel上，`XOR`指令比`MOV`指令更快地将寄存器设置为0）。`NOPW`指令可以安全地忽略。
- en: 'The next couple of instructions are interleaved, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几条指令是交错的，如下所示：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'These instructions represent the `i++;` and `data[i] = 42;` code. The first
    instruction stores the current value of the `i` variable and then increments it
    by one before storing `42` into the memory address indexed by `i`. Conveniently,
    this resulting assembly demonstrates a possible opportunity for optimization as
    the compiler could have achieved the same functionality using the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令代表了`i++;`和`data[i] = 42;`的代码。第一条指令存储了`i`变量的当前值，然后将其加一，然后再将`42`存储到由`i`索引的内存地址中。方便的是，这个汇编结果展示了一个优化的可能机会，因为编译器可以使用以下方式实现相同的功能：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding code stores the value `42` before executing `i++`, thus removing
    the need for the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码在执行`i++`之前存储了值`42`，因此不再需要以下内容：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A number of methods exist to realize this potential optimization, including
    using a different compiler or handwriting the assembly. The next set of instructions
    execute the `i < 1000;` portion of our `for` loop:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 存在多种方法来实现这种潜在的优化，包括使用不同的编译器或手写汇编。下一组指令执行我们`for`循环的`i < 1000;`部分：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `CMP` instruction checks to see if the `i` variable is `1000` and, if not,
    uses the `JNE` instruction to jump to the top of the function to continue the
    loop. Otherwise, the remaining code executes:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMP`指令检查`i`变量是否为`1000`，如果不是，则使用`JNE`指令跳转到函数顶部继续循环。否则，剩下的代码执行：'
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To see how loop unrolling works, let''s change the number of iterations the
    loop takes from `1000` to `4`, as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解循环展开的工作原理，让我们将循环的迭代次数从`1000`改为`4`，如下所示：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As we can see, the code is identical except for the number of iterations the
    loop takes. The resulting assembly is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，除了循环迭代次数之外，代码是相同的。汇编结果如下：
- en: '![](img/4414aa74-9275-444b-bf7a-a8a150a4a426.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4414aa74-9275-444b-bf7a-a8a150a4a426.png)'
- en: 'As we can see, the `CMP` and `JNE` instructions are missing. Now, the following
    code is compiled (*but there''s more!*):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`CMP`和`JNE`指令都不见了。现在，以下代码被编译了（但还有更多！）：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The compiled code is converted into the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后的代码转换为以下代码：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`return 0;` shows up in the assembly in-between the assignments. This is allowed
    because the return value of the function is independent of the assignment (since
    the assignment instructions never touch `RAX`), which provides the CPU with an
    additional optimization (as it can execute `return 0;` in parallel, though this
    is a topic that is out of the scope of this book). It should be noted that loop
    unrolling doesn''t require a small number of loop iterations to be used. Some
    compilers will partially unroll a loop to achieve optimizations (for example,
    executing the loop in groups of `4` instead of `1` at a time).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`return 0;`出现在赋值之间的汇编中。这是允许的，因为函数的返回值与赋值无关（因为赋值指令从不触及`RAX`），这为CPU提供了额外的优化（因为它可以并行执行`return
    0;`，尽管这是本书范围之外的话题）。值得注意的是，循环展开并不要求使用少量的循环迭代。一些编译器会部分展开循环以实现优化（例如，以`4`个为一组而不是一次执行`1`次循环）。'
- en: 'Our last example will look at pass-by-reference instead of pass-by-value. To
    start, recompile the code in debug mode:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一个例子将研究按引用传递而不是按值传递。首先，在调试模式下重新编译代码：
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s look at the following example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下例子：
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this example, we''ve created a large structure and passed it by-value to
    a function named `foo()` in our main function. The resulting assembly for the
    main function is as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个大型结构体，并按值传递给了我们主函数中名为`foo()`的函数。主函数的汇编结果如下：
- en: '![](img/45b46604-3410-4880-b1de-7ed7b6ecbd4b.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/45b46604-3410-4880-b1de-7ed7b6ecbd4b.png)'
- en: 'The important instructions from the preceding example are as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例中的重要指令如下：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding instructions copy the large structure to the stack and then call
    our `foo()` function. The copy occurs because the structure is passed by value,
    which means the compiler must perform a copy. As a side note, if you would like
    to see the output in a readable format and not a mangled format, add a `C` to
    the options, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的指令将大型结构体复制到堆栈上，然后调用我们的`foo()`函数。复制是因为结构体是按值传递的，这意味着编译器必须执行复制。顺便说一句，如果您想以可读的格式而不是混淆的格式看到输出，可以在选项中添加`C`，如下所示：
- en: '![](img/1e602d6c-13f7-4a30-9494-09b95deb705c.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e602d6c-13f7-4a30-9494-09b95deb705c.png)'
- en: 'Finally, let''s pass-by-reference to see the resulting improvement:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们按引用传递来看看结果的改善：
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As we can see, we pass the structure by-reference instead of by-value. The
    resulting assembly is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们通过引用传递结构而不是按值传递。生成的汇编代码如下：
- en: '![](img/60ea97a9-3744-48ce-bc91-000a09a842b0.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60ea97a9-3744-48ce-bc91-000a09a842b0.png)'
- en: Here, there is far less code, resulting in a faster executable. As we have learned,
    examining what the compiler produces can be effective if we wish to understand
    what the compiler is producing as this provides more information about potential
    changes you can make to write more efficient C++ code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，代码要少得多，导致可执行文件更快。正如我们所学到的，如果我们希望了解编译器生成了什么，检查编译器生成的内容是有效的，因为这提供了有关您可以进行的潜在更改的更多信息，以编写更有效的C++代码。
- en: Reducing the number of memory allocations
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少内存分配的数量
- en: Hidden memory allocations are produced by C++ all the time when an application
    runs. This recipe will teach you how to determine when memory is allocated by
    C++ and how to remove these allocations when possible. Understanding how to remove
    memory allocations is important because functions such as `new()`, `delete()`,
    `malloc()`, and `free()` are not only slow, but the memory they provide is also
    finite. Removing unneeded allocations not only improves the overall performance
    of your application, but it also helps to reduce its overall memory requirements.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: C++在应用程序运行时会一直产生隐藏的内存分配。本教程将教你如何确定C++何时分配内存以及如何在可能的情况下删除这些分配。了解如何删除内存分配很重要，因为`new()`、`delete()`、`malloc()`和`free()`等函数不仅速度慢，而且它们提供的内存也是有限的。删除不需要的分配不仅可以提高应用程序的整体性能，还有助于减少其整体内存需求。
- en: Getting ready
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements have
    been met, including installing Ubuntu 18.04 or higher and running the following
    in a Terminal window:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保已满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once you've done this, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有适当的工具来编译和执行本教程中的示例。完成后，打开一个新的终端。我们将使用此终端来下载、编译和运行示例。
- en: How to do it...
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps to complete this recipe:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成本教程：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端运行以下命令以下载源代码：
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To compile the source code, run the following command:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once the source code has been compiled, you can execute each example in this
    recipe by running the following commands:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译完成后，您可以通过运行以下命令来执行本教程中的每个示例：
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个步骤地介绍每个示例，并解释每个示例程序的作用以及它与本教程中所教授的课程的关系。
- en: How it works...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we will learn how to monitor how much memory an application
    is consuming, as well as the different ways that C++ can allocate memory behind
    the scenes. To start, let''s look at a simple application that does nothing:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何监视应用程序消耗的内存量，以及C++在幕后分配内存的不同方式。首先，让我们看一个什么都不做的简单应用程序：
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As we can see, this application does nothing. To see how much memory the application
    has used, we will use Valgrind, a dynamic analysis tool, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这个应用程序什么也没做。要查看应用程序使用了多少内存，我们将使用动态分析工具Valgrind，如下所示：
- en: '![](img/4b394af7-4501-4c48-bfd4-20e1f216d0de.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4b394af7-4501-4c48-bfd4-20e1f216d0de.png)'
- en: 'As shown in the preceding example, our application has allocated heap memory
    (that is, memory allocated using `new()`/`delete()` or `malloc()`/`free()`). To
    determine where this allocation occurred, let''s use Valgrind again, but this
    time, we will enable a tool called **Massif**, which will trace where the memory
    allocation came from:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，我们的应用程序已经分配了堆内存（即使用`new()`/`delete()`或`malloc()`/`free()`分配的内存）。要确定此分配发生的位置，让我们再次使用Valgrind，但这次我们将启用一个名为**Massif**的工具，它将跟踪内存分配的来源：
- en: '![](img/def07c68-3679-40b0-ae34-b2b5ebb1757c.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/def07c68-3679-40b0-ae34-b2b5ebb1757c.png)'
- en: 'To see the output of the preceding example, we must output a file that was
    created for us automatically:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看上述示例的输出，我们必须输出一个为我们自动创建的文件：
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This results in us retrieving the following output:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致我们检索到以下输出：
- en: '![](img/2434cd14-83e9-4761-b2d4-a3f3616eb879.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2434cd14-83e9-4761-b2d4-a3f3616eb879.png)'
- en: 'As we can see, the dynamic linker''s `init()` function is performing the allocation,
    which is `72,704` bytes in size. To further demonstrate how to use Valgrind, let''s
    take a look at this simple example, where we perform our own allocation:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，动态链接器的`init()`函数正在执行分配，大小为`72,704`字节。为了进一步演示如何使用Valgrind，让我们看一个简单的例子，其中我们执行自己的分配：
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To see the memory allocation of the preceding source, we need to run Valgrind
    again:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看上述源代码的内存分配，我们需要再次运行Valgrind：
- en: '![](img/5ca77107-fafd-479a-8c84-a660ea785dd3.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ca77107-fafd-479a-8c84-a660ea785dd3.png)'
- en: 'As we can see, we have allocated `72,708` bytes. Since we know that the application
    will allocate `72,704` bytes for us automatically, we can see that Valgrind has
    successfully detected the `4` bytes we allocated (the size of an integer on Intel
    64-bit systems running Linux). To see where this allocation occurred, let''s use
    Massif again:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们已经分配了`72,708`字节。由于我们知道应用程序将自动为我们分配`72,704`字节，我们可以看到Valgrind成功检测到我们分配的`4`字节（在运行Linux的Intel
    64位系统上是整数的大小）。要查看此分配发生的位置，让我们再次使用Massif：
- en: '![](img/d1b7826e-721d-44ad-8c3a-dbc55d4cc5e1.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1b7826e-721d-44ad-8c3a-dbc55d4cc5e1.png)'
- en: 'As we can see, we''ve added the `--threshold=0.1` to the command-line options
    as this tells Valgrind that any allocation that makes up `.1%` of the allocations
    should be logged. Let''s `cat` the results (the `cat` program simply echoes the
    contents of a file to the console):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们在命令行选项中添加了`--threshold=0.1`，这告诉Valgrind任何占`.1%`分配的分配都应该被记录。让我们`cat`一下结果（`cat`程序只是将文件的内容回显到控制台）：
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'By doing this, we get the following output:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们得到以下输出：
- en: '![](img/8e0189c6-c5a1-44bb-a848-4d752d4bee3a.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e0189c6-c5a1-44bb-a848-4d752d4bee3a.png)'
- en: As we can see, Valgrind has detected the memory allocations from the `init()`
    function, as well as from our `main()` function.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，Valgrind检测到了`init()`函数和我们的`main()`函数的内存分配。
- en: 'Now that we know how to analyze the memory allocations our application makes,
    let''s look at some different C++ APIs to see what types of memory allocations
    they make behind the scenes. To start, let''s look at an `std::vector`, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何分析应用程序所做的内存分配，让我们看一些不同的C++ API，看看它们在幕后做了什么类型的内存分配。首先，让我们看一个`std::vector`，如下所示：
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here, we''ve created a global vector of integers and then added `10,000` integers
    to the vector. Using Valgrind, we get the following output:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个整数的全局向量，然后向向量添加了`10,000`个整数。使用Valgrind，我们得到以下输出：
- en: '![](img/01e29595-e5db-4190-8321-93c0973e49cb.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01e29595-e5db-4190-8321-93c0973e49cb.png)'
- en: Here, we can see 16 allocations, with a total of `203,772` bytes. We know that
    the application will allocate `72,704` bytes for us, so we must remove this from
    our total, leaving us with `131,068` bytes of memory. We also know that we allocated
    `10,000` integers, which is `40,000` bytes in total. So, the question is, where
    did the other `91,068` bytes come from?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到有`16`次分配，总共`203,772`字节。我们知道应用程序将为我们分配`72,704`字节，所以我们必须从总数中去掉这部分，留下`131,068`字节的内存。我们还知道我们分配了`10,000`个整数，总共`40,000`字节。所以，问题是，其他`91,068`字节来自哪里？
- en: The answer is in how `std::vector` works under the hood. `std::vector` must
    ensure a continuous view of memory at all times, which means that when an insertion
    occurs and the `std::vector` is out of space, it must allocate a new, larger buffer
    and then copy the contents of the old buffer into the new buffer. The problem
    is that `std::vector` doesn't know what the total size of the buffer will be when
    all of the insertions are complete, so when the first insertion is performed,
    it creates a small buffer to ensure memory is not wasted and then proceeds to
    increase the size of the `std::vector` in small increments as the vector grows,
    resulting in several memory allocations and memory copies.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 答案在于`std::vector`在幕后的工作方式。`std::vector`必须始终确保内存的连续视图，这意味着当插入发生并且`std::vector`空间不足时，它必须分配一个新的更大的缓冲区，然后将旧缓冲区的内容复制到新缓冲区。问题在于`std::vector`不知道在所有插入完成时缓冲区的总大小，因此当执行第一次插入时，它创建一个小缓冲区以确保不浪费内存，然后以小增量增加`std::vector`的大小，导致多次内存分配和内存复制。
- en: 'To prevent such allocation from happening, C++ provides the `reserve()` function,
    which provides the user of a `std::vector` to estimate how much memory the user
    thinks they will need. For example, consider the following code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止发生这种分配，C++提供了`reserve()`函数，该函数允许`std::vector`的用户估计他们认为他们将需要多少内存。例如，考虑以下代码：
- en: '[PRE42]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The code in the preceding example is the same as it is in the previous example,
    with the difference being that we added a call to the `reserve()` function, which
    tells the `std::vector` how large we think the vector will be. Valgrind''s output
    is as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，代码与之前的例子相同，唯一的区别是我们添加了对`reserve()`函数的调用，该函数告诉`std::vector`我们认为向量将有多大。Valgrind的输出如下：
- en: '![](img/726ac6f0-8701-40ea-b53e-310902914389.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/726ac6f0-8701-40ea-b53e-310902914389.png)'
- en: As we can see, the application allocated `112,704` bytes. If we remove our `72,704`
    bytes that the application creates by default, we are left with `40,000` bytes,
    which is the exact size we expected (since we are adding `10,000` integers to
    the vector, with each integer being `4` bytes in size).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，应用程序分配了`112,704`字节。如果我们去掉应用程序默认创建的`72,704`字节，我们剩下`40,000`字节，这正是我们预期的大小（因为我们向向量添加了`10,000`个整数，每个整数的大小为`4`字节）。
- en: 'Data structures are not the only type of C++ Standard Library API that performs
    hidden allocations. Let''s look at an `std::any`, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构不是C++标准库API的唯一一种执行隐藏分配的类型。让我们看一个`std::any`，如下所示：
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In this example, we created an `std::any` and assigned it an integer and an
    `std::string`. Let''s look at the output of Valgrind:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个`std::any`，并将其分配给一个整数和一个`std::string`。让我们看一下Valgrind的输出：
- en: '![](img/56140dbb-bf2e-4670-82e2-15eb7134ce6d.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/56140dbb-bf2e-4670-82e2-15eb7134ce6d.png)'
- en: 'As we can see, `3` allocations occurred. The first allocation occurs by default,
    while the second allocation is produced by the `std::string`. The last allocation
    is produced by the `std::any`. This occurs because `std::any` has to adjust its
    internal storage to account for any new random data type that it sees. In other
    words, to handle a *generic* data type, C++ has to perform an allocation. This
    is made worse if we keep changing the data type. For example, consider the following
    code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，发生了`3`次分配。第一次分配是默认发生的，而第二次分配是由`std::string`产生的。最后一次分配是由`std::any`产生的。这是因为`std::any`必须调整其内部存储以适应它看到的任何新的随机数据类型。换句话说，为了处理*通用*数据类型，C++必须执行分配。如果我们不断改变数据类型，情况会变得更糟。例如，考虑以下代码：
- en: '[PRE44]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The preceding code is identical to the previous example, with the only difference
    being that we swap between data types. Valgrind produces the following output:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码与之前的例子相同，唯一的区别是我们在不同的数据类型之间进行了交换。Valgrind产生了以下输出：
- en: '![](img/1df2f995-397d-4929-adfd-d6847ce57abf.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1df2f995-397d-4929-adfd-d6847ce57abf.png)'
- en: 'As we can see, `9` allocations occurred instead of `3`. To solve this problem,
    we need to use an `std::variant` instead of `std::any`, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，发生了`9`次分配，而不是`3`次。为了解决这个问题，我们需要使用`std::variant`而不是`std::any`，如下所示：
- en: '[PRE45]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The difference between `std::any` and `std::variant` is that `std::variant`
    requires that the user states which types the variant must support, removing the
    need for dynamic memory allocation on assignment. Valgrind''s output is as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::any`和`std::variant`之间的区别在于，`std::variant`要求用户声明变体必须支持的类型，从而在赋值时消除了动态内存分配的需要。Valgrind的输出如下：'
- en: '![](img/2a8432c6-3aa6-4f3e-9f2d-d83c733ea3d2.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2a8432c6-3aa6-4f3e-9f2d-d83c733ea3d2.png)'
- en: Now, we only have `2` allocations, as expected (the default allocation and the
    allocation from `std::string`). As shown in this recipe, libraries, including
    the C++ Standard Library, can hide memory allocations, potentially slowing down
    your code and using more memory resources than you intended. Tools such as Valgrind
    can be used to identify these types of problems, allowing you to create more efficient
    C++ code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只有`2`个分配，正如预期的那样（默认分配和从`std::string`分配）。正如本教程所示，包括C++标准库在内的库可以隐藏内存分配，可能会减慢代码速度并使用比预期更多的内存资源。诸如Valgrind之类的工具可以用于识别这些类型的问题，从而使您能够创建更高效的C++代码。
- en: Declaring noexcept
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明noexcept
- en: C++11 introduced the `noexcept` keyword, which, besides simplifying how exceptions
    were used in general, also included a better implementation of C++ exceptions
    that removed some of their performance hits. However, this doesn't mean that exceptions
    do not include *overhead* (that is, performance penalties). In this recipe, we
    will explore how exceptions add overhead to an application and how the `noexcept`
    keyword can help reduce these penalties (depending on the compiler).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: C++11引入了`noexcept`关键字，除了简化异常的一般使用方式外，还包括了更好的C++异常实现，去除了一些性能损耗。但是，这并不意味着异常不包括*开销*（即性能惩罚）。在本教程中，我们将探讨异常如何给应用程序增加开销，以及`noexcept`关键字如何帮助减少这些惩罚（取决于编译器）。
- en: This recipe is important because it will demonstrate that if a function doesn't
    throw an exception, then it should be marked as such to prevent the additional
    overhead regarding the total size of the application, resulting in an application
    that loads faster.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程很重要，因为它将演示如果一个函数不会抛出异常，那么应该标记为`noexcept`，以防止额外的开销影响应用程序的总大小，从而导致应用程序加载更快。
- en: Getting ready
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements have
    been met, including installing Ubuntu 18.04 or higher and running the following
    in a Terminal window:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保已满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE46]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once you've done this, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有适当的工具来编译和执行本教程中的示例。完成后，打开一个新的终端。我们将使用此终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Perform the following steps to complete this recipe:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成本教程：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的终端中，运行以下命令以下载源代码：
- en: '[PRE47]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To compile the source code, run the following command:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE48]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Once the source code has been compiled, you can execute each example in this
    recipe by running the following commands:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译完成后，可以通过运行以下命令来执行本教程中的每个示例：
- en: '[PRE49]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本教程所教授的课程的关系。
- en: How it works...
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'In this recipe, we will learn why it is so important to mark a function as
    `noexcept` if it shouldn''t throw an exception. This is because it removes the
    added overhead to the application for exception support, which can improve execution
    time, application size, and even load time (this depends on the compiler, which
    Standard Library you are using, and so on). To show this, let''s create a simple
    example:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习为什么将函数标记为`noexcept`非常重要，如果它不应该抛出异常。这是因为它去除了对异常支持的额外开销，可以改善执行时间、应用程序大小，甚至加载时间（这取决于编译器、使用的标准库等）。为了证明这一点，让我们创建一个简单的示例：
- en: '[PRE50]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The first thing we need to do is create a class that sets a `private` member
    variable when it is destructed, as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建一个类，在销毁时设置一个`private`成员变量，如下所示：
- en: '[PRE51]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, we can create two functions. The first function throws an exception, while
    the second function is our main function. This function creates an instance of
    our class and calls the `foo()` function inside a `try`/`catch` block. In other
    words, at no time will the `main()` function throw an exception. If we look at
    the assembly for the main function, we''ll see the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建两个函数。第一个函数抛出一个异常，而第二个函数是我们的主函数。这个函数创建了我们类的一个实例，并在`try`/`catch`块中调用`foo()`函数。换句话说，`main()`函数在任何时候都不会抛出异常。如果我们查看主函数的汇编代码，我们会看到以下内容：
- en: '![](img/e8b37484-b6b5-4a42-a49c-ace342254030.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8b37484-b6b5-4a42-a49c-ace342254030.png)'
- en: 'As we can see, our main function makes a call to `_Unwind_Resume`, which is
    used by the exception unwinder. This extra logic is due to the fact that C++ has
    to add additional exception logic to the end of the function. To remove this extra
    logic, tell the compiler that the `main()` function isn''t thrown:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们的主函数调用了`_Unwind_Resume`，这是异常解开器使用的。这额外的逻辑是因为C++必须在函数末尾添加额外的异常逻辑。为了去除这额外的逻辑，告诉编译器`main()`函数不会抛出异常：
- en: '[PRE52]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Adding `noexcept` tells the compiler that an exception cannot be thrown. As
    a result, the function no longer contains the extra logic for handling an exception,
    as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`noexcept`告诉编译器不能抛出异常。结果，该函数不再包含处理异常的额外逻辑，如下所示：
- en: '![](img/b17102a6-7e31-4c82-8751-308a935b23f2.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b17102a6-7e31-4c82-8751-308a935b23f2.png)'
- en: As we can see, the unwind function is no longer present. It should be noted
    that there are calls to catch functions, which are due to the `try`/`catch` block
    and not the overhead of an exception.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，取消函数不再存在。值得注意的是，存在对catch函数的调用，这是由于`try`/`catch`块而不是异常的开销。
