- en: '*Chapter 11*: Gearing Up with Support Utilities'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：使用支持实用工具准备就绪'
- en: In the previous chapter, we learned the basics of **Low-Level Virtual Machine**
    (**LLVM**) **intermediate representation** (**IR**)—the target-independent intermediate
    representations in LLVM—and how to inspect and manipulate this with C++ **application
    programming interfaces** (**APIs**). These are the core techniques for doing program
    analysis and transformation in LLVM. In addition to those skill sets, LLVM also
    provides many support utilities to improve compiler developers' productivity when
    working with LLVM IR. We are going to cover those topics in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了**低级虚拟机**（**LLVM**）**中间表示**（**IR**）的基础知识——LLVM 中的目标无关中间表示，以及如何使用
    C++ **应用程序编程接口**（**API**）来检查和操作它。这些是进行程序分析和转换在 LLVM 中的核心技术。除了这些技能集之外，LLVM 还提供了许多支持实用工具，以提高编译器开发者在处理
    LLVM IR 时的生产力。我们将在本章中涵盖这些主题。
- en: 'A compiler is a complex piece of software. It not only needs to handle thousands
    of different cases— including input programs with different shapes and a wide
    variety of target architectures—but the **correctness** of a compiler is also
    an important topic: namely, the compiled code needs to have the same behavior
    as the original one. LLVM, a large-scale compiler framework (and probably one
    of the biggest), is not an exception.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器是一块复杂的软件。它不仅需要处理数千种不同的案例——包括不同形状的输入程序和广泛的目标架构——而且编译器的**正确性**也是一个重要的话题：也就是说，编译后的代码需要与原始代码具有相同的行为。LLVM，一个大规模的编译器框架（可能是最大的之一），也不例外。
- en: To tackle these complexities, LLVM has provided a crate of gadgets to improve
    the development experience. In this chapter, we are going to show you how to gear
    up to use those tools. The utilities covered here can assist you in diagnosing
    problems that occur from the LLVM code you are developing. This includes more
    efficient debugging, error handling, and profiling abilities; for instance, one
    of the tools can collect statistical numbers on key components—such as the number
    of basic blocks being processed by a specific Pass—and automatically generate
    a summary report. Another example is LLVM's own error-handling framework, which
    prevents as many unhandled errors (a common programming mistake) as possible.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这些复杂性，LLVM 提供了一系列的实用工具来改善开发体验。在本章中，我们将向您展示如何准备使用这些工具。这里涵盖的实用工具可以帮助您诊断您正在开发的
    LLVM 代码中出现的问题。这包括更高效的调试、错误处理和性能分析能力；例如，其中一个工具可以收集关键组件（如特定 Pass 处理的基本块数量）的统计数据，并自动生成总结报告。另一个例子是
    LLVM 自身的错误处理框架，它可以尽可能防止未处理的错误（一种常见的编程错误）。
- en: 'Here is a list of the topics we are going to cover in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Printing diagnostic messages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印诊断信息
- en: Collecting statistics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集统计数据
- en: Adding time measurements
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加时间测量
- en: Error-handling utilities in LLVM
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLVM 中的错误处理实用工具
- en: Learning about the `Expected` and `ErrorOr` classes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 `Expected` 和 `ErrorOr` 类
- en: With the help of these utilities, you will have a better time debugging and
    diagnosing the LLVM code, letting you focus on the core logic you want to implement
    with LLVM.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些实用工具的帮助，您将能够更好地调试和诊断 LLVM 代码，让您能够专注于使用 LLVM 实现的核心逻辑。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this section, we are also going to use LLVM Pass as the platform to show
    different API usages. Therefore, please make sure you have built the `opt` command-line
    tool, as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们还将使用 LLVM Pass 作为平台来展示不同的 API 使用方法。因此，请确保您已经构建了`opt`命令行工具，如下所示：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that some of the content in this chapter only works with a **debug build**
    version of LLVM. Please check the first chapter, [*Chapter 1*](B14590_01_Final_JC_ePub.xhtml#_idTextAnchor014),
    *Saving Resources When Building LLVM,* for a recap on how to build LLVM in debug
    mode.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本章中的一些内容仅适用于 LLVM 的**调试构建**版本。请查阅第一章节，[*第1章*](B14590_01_Final_JC_ePub.xhtml#_idTextAnchor014)，*构建
    LLVM 时的资源节约*，以回顾如何在调试模式下构建 LLVM。
- en: You can also go back to [*Chapter 9*](B14590_09_Final_JC_ePub.xhtml#_idTextAnchor127),
    *Working with PassManager and AnalysisManager,* if you are not sure how to create
    a new LLVM Pass.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定如何创建新的 LLVM Pass，也可以回到[*第9章*](B14590_09_Final_JC_ePub.xhtml#_idTextAnchor127)，*使用
    PassManager 和 AnalysisManager 工作时*。
- en: 'The sample code for this chapter can be found here:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可以在以下位置找到：
- en: '[https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter11](https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter11)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter11](https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter11)'
- en: Printing diagnostic messages
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印诊断消息
- en: 'In software development, there are many ways to diagnose a bug—for instance,
    using a debugger, inserting a sanitizer into your program (to catch invalid memory
    access, for example), or simply using one of the simplest yet most effective ways:
    adding *print statements*. While the last option doesn''t sound really smart,
    it is actually pretty useful in many cases where other options cannot unleash
    their full potential (for example, release mode binaries with poor debug information
    quality or multithread programs).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，有许多方法可以诊断错误——例如，使用调试器，将清理器插入到你的程序中（例如，捕获无效的内存访问），或者简单地使用最简单但最有效的方法之一：添加
    *打印语句*。虽然最后一个选项听起来并不十分聪明，但实际上在许多情况下非常有用，在其他选项无法发挥全部潜力的情况下（例如，调试信息质量较差的发布模式二进制文件或多线程程序）。
- en: 'LLVM provides a small utility that not only helps you to print out debug messages
    but also *filters* which messages to show. Let''s say we have an LLVM Pass, `SimpleMulOpt`,
    which replaces multiplication by power-of-two constants with left-shifting operations
    (which is what we did in the last section of the previous chapter, *Processing
    LLVM IR*). Here is part of its `run` method:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 提供了一个小工具，它不仅可以帮助你打印调试信息，还可以*过滤*要显示的消息。假设我们有一个 LLVM Pass，名为 `SimpleMulOpt`，它将乘以
    2 的幂的常数替换为左移操作（这正是我们在上一章的最后一节中做的，*处理 LLVM IR*）。以下是它的 `run` 方法的一部分：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code iterates through all instructions in the given function before
    looking for instructions that represent arithmetic multiplication. If there are
    any, the Pass will then work with the `LHS` and `RHS` operands (which appear in
    the rest of the code—these are not shown here).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码在寻找表示算术乘法的指令之前，会遍历给定函数中的所有指令。如果存在这样的指令，Pass 将会与 `LHS` 和 `RHS` 操作数（这些操作数出现在代码的其余部分中——这里没有展示）一起工作。
- en: 'Let''s assume that we want to print out the operand variables during our development.
    The most naïve way will be by using our old friend `errs()`, which streams arbitrary
    messages to `stderr`, as shown in the following code snippet:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在开发过程中打印出操作数变量。最简单的方法就是使用我们老朋友 `errs()`，它将任意消息流到 `stderr`，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `printAsOperand` used in the preceding code snippet prints the textual representation
    of a `Value` to the given stream (`errs()`, in this case).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码片段中使用的 `printAsOperand` 将 `Value` 的文本表示打印到给定的流中（在这个例子中是 `errs()`）。
- en: 'Everything looks normal, except the fact that these messages will be printed
    out anyway even in a production environment, which is not what we want. Either
    we need to remove these codes before we ship our products, adding some macro guard
    around these codes (for example, `#ifndef NDEBUG`), or we can use the debug utility
    provided by LLVM. Here is an example of this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些消息即使在生产环境中也会被打印出来之外，一切看起来都很正常，这不是我们想要的。我们可以在发布产品之前删除这些代码，在这些代码周围添加一些宏保护（例如，`#ifndef
    NDEBUG`），或者我们可以使用 LLVM 提供的调试工具。以下是一个例子：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code is basically doing the following three things:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码基本上做了以下三件事：
- en: Replacing any usage of `errs()` with `dbgs()`. These two streams are basically
    doing the same thing, but the latter one will add a nice banner (`Debug Log Output`)
    to the output message.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `errs()` 的任何使用替换为 `dbgs()`。这两个流基本上做的是同一件事，但后者会在输出消息中添加一个漂亮的横幅（`Debug Log Output`）。
- en: Wrapping all lines related to debug printing with the `LLVM_DEBUG(…)` macro
    function. The use of this macro ensures that the enclosing line is only compiled
    in development mode. It also encodes the debug message category, which we will
    introduce shortly.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `LLVM_DEBUG(…)` 宏函数将所有与调试打印相关的行包装起来。使用此宏确保包含的行仅在开发模式下编译。它还编码了调试消息类别，我们将在稍后介绍。
- en: Before using any `LLVM_DEBUG(…)` macro functions, please make sure you define
    `DEBUG_TYPE` to the desired debug category string (`simple-mul-opt`, in this case).
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用任何 `LLVM_DEBUG(…)` 宏函数之前，请确保将 `DEBUG_TYPE` 定义为所需的调试类别字符串（在这个例子中是 `simple-mul-opt`）。
- en: 'In addition to the aforementioned code modification, we also need to use an
    additional command-line flag, `-debug`, with `opt` to print those debug messages.
    Here is an example of this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述代码修改之外，我们还需要使用额外的命令行标志`-debug`与`opt`一起打印这些调试信息。以下是一个示例：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: But then, you'll find the output to be pretty noisy. There are tons of debug
    messages from *other* LLVM Passes. In this case, we're only interested in the
    messages from our Pass.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 但然后，你会发现输出相当嘈杂。有来自*其他* LLVM Pass的大量调试信息。在这种情况下，我们只对来自我们Pass的消息感兴趣。
- en: 'To filter out unrelated messages, we can use the `-debug-only` command-line
    flag. Here is an example of this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了过滤掉无关的消息，我们可以使用`-debug-only`命令行标志。以下是一个示例：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The value after `-debug-only` is the `DEBUG_TYPE` value we defined in the previous
    code snippet. In other words, we can use `DEBUG_TYPE` defined by each Pass to
    filter the desired debug messages. We can also select *multiple* debug categories
    to print. For instance, check out the following command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`-debug-only`后面的值是我们之前代码片段中定义的`DEBUG_TYPE`值。换句话说，我们可以使用每个Pass定义的`DEBUG_TYPE`来过滤所需的调试信息。我们还可以选择*多个*调试类别来打印。例如，查看以下命令：'
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This command not only prints debug messages from our `SimpleMulOpt` Pass, but
    also those coming from the `SROA` Pass—an LLVM Pass included in the `O3` optimization
    pipeline.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令不仅打印来自我们的`SimpleMulOpt` Pass的调试信息，还打印来自`SROA` Pass的调试信息——这是包含在`O3`优化管道中的LLVM
    Pass。
- en: 'In addition to defining a single debug category (`DEBUG_TYPE`) for an LLVM
    Pass, you are in fact free to use as many categories as you like inside a Pass.
    This is useful, for instance, when you want to use separate debug categories for
    different parts of a Pass. For example, we can use separate categories for each
    of the operands in our `SimpleMulOpt` Pass. Here is how we can do this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为LLVM Pass定义单个调试类别（`DEBUG_TYPE`）之外，实际上你可以在Pass内部使用尽可能多的类别。这在例如你想为Pass的不同部分使用不同的调试类别时很有用。例如，我们可以在我们的`SimpleMulOpt`
    Pass的每个操作数上使用不同的类别。以下是我们可以这样做的方法：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`DEBUG_WITH_TYPE` is a special version of `LLVM_DEBUG`. It executes code at
    the second argument, with the first argument as the debug category, which can
    be different from the currently defined `DEBUG_TYPE` value. In the preceding code
    snippet, in addition to printing `Found a multiplication instruction` using the
    original `simple-mul-opt` category, we are using `simple-mul-opt-lhs` to print
    messages related to the `simple-mul-opt-rhs` to print messages for the other operand.
    With this feature, we can have a finer granularity to select debug message categories
    via the `opt` command.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`DEBUG_WITH_TYPE`是`LLVM_DEBUG`的一个特殊版本。它使用第二个参数执行代码，第一个参数作为调试类别，可以不同于当前定义的`DEBUG_TYPE`值。在前面的代码片段中，除了使用原始的`simple-mul-opt`类别打印`Found
    a multiplication instruction`之外，我们还使用`simple-mul-opt-lhs`来打印与`simple-mul-opt-rhs`相关的消息，以打印其他操作数的消息。有了这个特性，我们可以通过`opt`命令更精细地选择调试信息类别。'
- en: You have now learned how to use the utility provided by LLVM to print out debug
    messages in the development environment only, and how to filter them if needed.
    In the next section, we are going to learn how to collect key statistics while
    running an LLVM Pass.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经学会了如何使用LLVM提供的工具在开发环境中打印调试信息，以及如何在需要时过滤它们。在下一节中，我们将学习如何在运行LLVM Pass时收集关键统计数据。
- en: Collecting statistics
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集统计数据
- en: As mentioned in the previous section, a compiler is a complex piece of software.
    Collecting **statistical numbers**—for example, the number of basic blocks processed
    by a specific optimization—is one of the easiest and most efficient ways to get
    a quick portrait on the runtime behaviors of a compiler.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文所述，编译器是一块复杂的软件。收集**统计数字**——例如，特定优化处理的基本块数量——是快速了解编译器运行时行为的最简单和最有效的方法之一。
- en: 'There are several ways to collect statistics in LLVM. In this section, we are
    going to learn three of the most common and useful options for doing this, and
    these methods are outlined here:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在LLVM中有几种收集统计数据的方法。在本节中，我们将学习三种最常见和有用的选项，这些方法在此概述：
- en: Using the `Statistic` class
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Statistic`类
- en: Using an optimization remark
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用优化注释
- en: Adding time measurements
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加时间测量
- en: The first option is a general utility that collects statistics via simple counters;
    the second option is specifically designed to profile *compiler optimizations*;
    and the last option is used for collecting timing information in the compiler.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项是一个通用工具，通过简单的计数器收集统计信息；第二个选项专门设计用于分析*编译器优化*；最后一个选项用于在编译器中收集时间信息。
- en: Let's start with the first one.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个选项开始。
- en: Using the Statistic class
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Statistic 类
- en: 'In this section, we are going to demonstrate new features by amending them
    to the `SimpleMulOpt` LLVM Pass from the previous section. First, let''s assume
    that we don''t only want to print out the operand `Value` from multiplication
    instructions but that we also want to *count* how many multiplication instructions
    have been processed by our Pass. First, let''s try to implement this feature using
    the `LLVM_DEBUG` infrastructure we just learned about, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过将新功能添加到上一节中的 `SimpleMulOpt` LLVM Pass 来展示新功能。首先，让我们假设我们不仅想要打印出乘法指令的运算符
    `Value`，而且还想*计数*我们的 Pass 处理了多少条乘法指令。首先，让我们尝试使用我们刚刚学到的 `LLVM_DEBUG` 基础设施来实现这个功能，如下所示：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This approach seems pretty straightforward. But it comes with a drawback—the
    statistical numbers we are interested in are mixed with other debug messages.
    We need to take additional actions to parse or filter the value we want because
    although you might argue that these problems could be tackled by using a separate
    `DEBUG_TYPE` tag for each counter variable, when the number of counter variables
    increases, you might find yourself creating lots of redundant code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法看起来相当直接。但它的缺点是我们感兴趣的统计数字与其他调试信息混合在一起。我们需要采取额外的措施来解析或过滤我们想要的值，因为尽管你可以争辩说这些问题可以通过为每个计数器变量使用单独的
    `DEBUG_TYPE` 标签来解决，但当计数器变量的数量增加时，你可能会发现自己创建了大量的冗余代码。
- en: 'One elegant solution is to use the `Statistic` class (and related utilities)
    provided by LLVM. Here is a version rewritten using this solution:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一个优雅的解决方案是使用 LLVM 提供的 `Statistic` 类（和相关工具）。以下是使用此解决方案重写的版本：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code snippet shows the usage of `Statistic`, calling the `STATISTIC`
    macro function to create a `Statistic` type variable (with a textual description)
    and simply using it like a normal integer counter variable.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段显示了 `Statistic` 的用法，通过调用 `STATISTIC` 宏函数创建一个 `Statistic` 类型变量（带有文本描述）并像正常整数计数器变量一样使用它。
- en: 'This solution only needs to modify a few lines in the original code, plus it
    collects all counter values and prints them in a table view at the end of the
    optimization. For example, if you run the `SimpleMulOpt` Pass using the `-stats`
    flag with `opt`, you will get the following output:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案只需要修改原始代码中的几行，并且它收集所有计数器值，并在优化的最后以表格视图的形式打印出来。例如，如果你使用带有 `-stats` 标志的
    `opt` 运行 `SimpleMulOpt` Pass，你会得到以下输出：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`87` is the number of multiplication instructions processed in `SimpleMulOpt`.
    Of course, you are free to add as many `Statistic` counters as you want in order
    to collect different statistics. If you run more than one Pass in the pipeline,
    all of the statistical numbers will be presented in the same table. For instance,
    if we add another `Statistic` counter into `SimpleMulOpt` to collect a number
    of `none-power-of-two constant operands` from the multiplication instructions
    and run the Pass with **Scalar Replacement of Aggregates** (**SROA**), we can
    get an output similar to the one shown next:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`87` 是在 `SimpleMulOpt` 中处理的乘法指令的数量。当然，你可以自由地添加尽可能多的 `Statistic` 计数器来收集不同的统计信息。如果你在管道中运行多个
    Pass，所有统计数字都会在同一张表中展示。例如，如果我们向 `SimpleMulOpt` 中添加另一个 `Statistic` 计数器来收集乘法指令中的
    `none-power-of-two constant operands` 的数量，并使用 **聚合替换标量**（**SROA**）运行 Pass，我们可以得到类似于下面所示的输出：'
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The second column in the preceding code snippet is the name of the origin Pass,
    which is designated by the `DEBUG_TYPE` value defined prior to any calls to `STATISTIC`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的第二列是原始 Pass 的名称，该名称由在调用 `STATISTIC` 之前定义的 `DEBUG_TYPE` 值指定。
- en: 'Alternatively, you can output the result in `-stats-json` flag to `opt`. For
    example, look at the following code snippet:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以将结果输出到 `-stats-json` 标志的 `opt` 中。例如，看看下面的代码片段：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this JSON format, instead of printing statistic values with a textual description,
    the field name of a statistic entry has this format: `"<Pass name>.<Statistic
    variable name>"` (the Pass name here is also the value of `DEBUG_TYPE`). Furthermore,
    you can print statistic results (either in default or JSON format) into a file
    using the `-info-output-file=<file name>` command-line option. The following code
    snippet shows an example of this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种 JSON 格式下，我们不是用文本描述来打印统计值，而是使用统计条目字段的名称，其格式为：`"<Pass name>.<Statistic variable
    name>"`（这里的 Pass name 同时也是 `DEBUG_TYPE` 的值）。此外，您可以使用 `-info-output-file=<文件名>`
    命令行选项将统计结果（无论是默认格式还是 JSON 格式）打印到文件中。以下代码片段展示了这一示例：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You have now learned how to collect simple statistic values using the `Statistic`
    class. In the next section, we are going to learn a statistic collecting method
    that is unique to compiler optimization.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经学会了如何使用 `Statistic` 类收集简单的统计值。在下一节中，我们将学习一种独特的编译器优化统计收集方法。
- en: Using an optimization remark
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用优化注释
- en: 'A typical compiler optimization usually consists of two stages: *searching*
    for the desired patterns from the input code, followed by *modifying* the code.
    Take our `SimpleMulOpt` Pass as an example: the first stage is to look for multiplication
    instructions (`BinaryOperator` with the `Instruction::Mul` `IRBuilder::CreateShl(…)`
    and replace all old usages of multiplication instructions with these.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的编译器优化通常包括两个阶段：*搜索*从输入代码中寻找所需的模式，然后是*修改*代码。以我们的 `SimpleMulOpt` Pass 为例：第一阶段是寻找乘法指令（`BinaryOperator`
    与 `Instruction::Mul` 和 `IRBuilder::CreateShl(…)`），并将所有旧的乘法指令用法替换为这些。
- en: There are many cases, however, where the optimization algorithm simply "bails
    out" during the first stage due to *infeasible* input code. For example, in `SimpleMulOpt`,
    we are looking for a multiplication instruction, but if the incoming instruction
    is not `BinaryOperator`, the Pass will not proceed to the second stage (and continue
    on to the next instruction). Sometimes, we want to know the *reason* behind this
    bailout, which can help us to improve the optimization algorithm or diagnose incorrect/suboptimal
    compiler optimization. LLVM provides a nice utility called an **optimization remarks**
    to collect and report this kind of bailout (or any kind of information) occurring
    in optimization Passes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在许多情况下，优化算法在第一阶段由于*不可行*的输入代码而简单地“退出”。例如，在 `SimpleMulOpt` 中，我们正在寻找乘法指令，但如果传入的指令不是
    `BinaryOperator`，Pass 将不会进入第二阶段（并继续到下一个指令）。有时，我们想知道这种退出的*原因*，这有助于我们改进优化算法或诊断不正确/次优的编译器优化。LLVM
    提供了一个很好的工具，称为**优化注释**，用于收集和报告在优化 Pass 中发生的这种退出（或任何其他信息）。
- en: 'For example, let''s assume we have the following input code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有以下输入代码：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Theoretically, we can use **loop-invariant code motion** (**LICM**) to optimize
    this code into an equivalent code base such as this one:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，我们可以使用 **循环不变代码移动**（**LICM**）来优化这段代码到一个等效的代码库，如下所示：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can do this as the fifth array element, `a[5]`, never changed its value inside
    the loop. However, if we run LLVM's LICM Pass over the original code, it fails
    to perform the expected optimization.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个作为第五个数组元素 `a[5]`，在循环内部从未改变其值。然而，如果我们运行 LLVM 的 LICM Pass 对原始代码进行优化，它将无法执行预期的优化。
- en: 'To diagnose this problem, we can invoke the `opt` command with an additional
    option: `--pass-remarks-output=<filename>`. The filename will be a **YAML Ain''t
    Markup Language** (**YAML**) file in which optimization remarks print out the
    possible reasons why LICM failed to optimize. Here is an example of this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了诊断这个问题，我们可以使用带有附加选项的 `opt` 命令：`--pass-remarks-output=<filename>`。该文件名将是一个
    **YAML Ain't Markup Language**（**YAML**）文件，其中优化注释将打印出 LICM 未能优化的可能原因。以下是一个示例：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `cat` command in the preceding output shows one of the optimization remark
    entries in `licm_remarks.yaml`. This entry tells us that there was a *missed*
    optimization that happened in the LICM Pass when it was processing the `foo` function.
    It also tells us the reason: LICM was not sure if a particular memory address
    was invalidated by the loop. Though this message doesn''t provide fine-grained
    details, we can still infer that the problematic memory address concerning LICM
    was probably `a[5]`. LICM was not sure if the `a[i] += 2` statement modified the
    content of `a[5]`.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出中的`cat`命令显示了`licm_remarks.yaml`中的优化注释条目之一。这个条目告诉我们，在处理`foo`函数时，LICM Pass中发生了一个*遗漏*的优化。它还告诉我们原因：LICM不确定特定的内存地址是否被循环无效化。虽然这个消息没有提供详细的细节，但我们仍然可以推断出，与LICM相关的有问题内存地址可能是`a[5]`。LICM不确定`a[i]
    += 2`语句是否修改了`a[5]`的内容。
- en: With this knowledge, compiler developers can get hands-on in improving LICM—for
    example, teaching LICM to recognize induction variables (that is, the `i` variable
    in this loop) with a step value greater than 1 (in this case, it was 3, since
    `i += 3`).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 借助这些知识，编译器开发者可以亲自动手改进LICM——例如，教LICM识别步长值大于1的归纳变量（即，这个循环中的`i`变量，在这个例子中是3，因为`i
    += 3`）。
- en: 'To generate optimization remarks such as the one shown in the preceding output,
    compiler developers need to integrate a specific utility API into their optimization
    Pass. To show you how to do that in your own Pass, we are going to reuse our `SimpleMulOpt`
    Pass as the sample. Here is part of the code that performs the first stage—*searching
    for multiplications* with power-of-two constant operands—in `SimpleMulOpt`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成如前输出中所示的那种优化注释，编译器开发者需要将特定的实用API集成到他们的优化Pass中。为了向您展示如何在您的Pass中实现这一点，我们将重用我们的`SimpleMulOpt`
    Pass作为示例。以下是`SimpleMulOpt`中执行第一阶段——*搜索具有2的幂次常量操作数的乘法*——的部分代码：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding code checks if the operand is constant before making sure it's
    also a power-of-two operand. If either of these checks fails, the algorithm will
    bail out by continuing on to the next instruction in the function.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码在确保操作数是2的幂次操作数之前，会检查操作数是否为常量。如果这两个检查中的任何一个失败，算法将通过继续执行函数中的下一个指令来退出。
- en: 'We intentionally inserted a small flaw into this code to make it less powerful,
    and we are going to show you how to find that problem by using an optimization
    remark. Here are the steps to do this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意在这个代码中插入了一个小缺陷，使其功能减弱，我们将通过使用优化注释向您展示如何找到这个问题。以下是执行此操作的步骤：
- en: 'First, we need to have an `OptimizationRemarkEmitter` instance, which can help
    you to emit remark messages. This can be obtained from its parent analyzer, `OptimizationRemarkEmitterAnalysis`.
    Here is how we include it at the beginning of the `SimpleMulOpt::run` method:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要有一个`OptimizationRemarkEmitter`实例，它可以帮助您发出注释消息。这可以通过其父分析器`OptimizationRemarkEmitterAnalysis`获得。以下是如何在`SimpleMulOpt::run`方法开始时包含它的方法：
- en: '[PRE18]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we are going to use this `OptimizationRemarkEmitter` instance to emit
    an optimization remark if the multiplication instruction lacks a constant operand,
    as follows:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将使用这个`OptimizationRemarkEmitter`实例来发出一个优化注释，如果乘法指令缺少常量操作数，如下所示：
- en: '[PRE19]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `OptimizationRemarkMissed` class (note that it is not declared in `OptimizationRemarkEmitter.h`
    but in the `DiagnosticInfo.h` header file) represents the remark of a missed `I`
    does not have any constant operand. The constructor of `OptimizationRemarkMissed`
    takes three arguments: the name of the Pass, the name of the missed optimization
    opportunity, and the enclosing IR unit (in this case, we use the enclosing `Function`).
    In addition to constructing a `OptimizationRemarkMissed` object, we also concatenate
    several objects via the stream operator (`<<`) at the tail. These objects will
    eventually be put under the `Args` section of each optimization remark entry in
    the YAML file we saw previously.'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OptimizationRemarkMissed`类（请注意，它没有在`OptimizationRemarkEmitter.h`中声明，而是在`DiagnosticInfo.h`头文件中）表示一个遗漏的`I`没有任何常量操作数的注释。`OptimizationRemarkMissed`的构造函数接受三个参数：Pass的名称、遗漏的优化机会的名称以及封装的IR单元（在这种情况下，我们使用封装的`Function`）。除了构建`OptimizationRemarkMissed`对象外，我们还通过流操作符（`<<`）在末尾连接几个对象。这些对象最终将被放入我们之前看到的YAML文件中每个优化注释条目的`Args`部分。'
- en: In addition to using `OptimizationRemarkMissed` to notify you of missed optimization
    opportunities, you can also use other classes derived from `DiagnosticInfoOptimizationBase`
    to present different kinds of information—for example, use `OptimizationRemark`
    to find out which optimization has been *successfully* applied, and use `OptimizationRemarkAnalysis`
    to keep a log of analysis data/facts.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了使用`OptimizationRemarkMissed`来通知您错过优化机会外，您还可以使用从`DiagnosticInfoOptimizationBase`派生的其他类来呈现不同类型的信息——例如，使用`OptimizationRemark`来找出哪些优化已被*成功*应用，并使用`OptimizationRemarkAnalysis`来记录分析数据/事实。
- en: 'Among objects concatenated by the stream operator, `ore::NV(…)` seems to be
    a special case. Recall that in the optimization remark YAML file, each line under
    the `Args` section was a key-value pair (for example, `String: failed to move
    load with….`, where `String` was the key). The `ore::NV` object allows you to
    customize the key-value pair. In this case, we are using `Inst` as the key and
    `SS.str()` as the value. This feature provides more flexibility to parse the optimization
    remark YAML file—for instance, if you want to write a little tool to visualize
    the optimization remarks, custom `Args` keys can give you an easier time (during
    the parsing stage) by distinguishing critical data from other strings.'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在流操作符连接的对象中，`ore::NV(…)`似乎是一个特殊情况。回想一下，在优化备注YAML文件中，`Args`部分下的每一行都是一个键值对（例如，`String:
    failed to move load with….`，其中`String`是键）。`ore::NV`对象允许您自定义键值对。在这种情况下，我们使用`Inst`作为键，`SS.str()`作为值。此功能为解析优化备注YAML文件提供了更多灵活性——例如，如果您想编写一个小工具来可视化优化备注，自定义`Args`键可以在解析阶段更容易地区分关键数据和其他字符串。'
- en: 'Now that you have inserted the code to emit the optimization remark, it''s
    time to test it. This time, we are going to use the following `IR` function as
    the input code:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您已经插入了生成优化备注的代码，是时候对其进行测试了。这次，我们将使用以下`IR`函数作为输入代码：
- en: '[PRE20]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can rebuild the `SimpleMulOpt` Pass and run it using a command such as
    this:'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以重新构建`SimpleMulOpt` Pass，并使用如下命令运行它：
- en: '[PRE21]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: …
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: …
- en: if (BinOp->getOpcode() == Instruction::Mul) {
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (BinOp->getOpcode() == Instruction::Mul) {
- en: auto *LHS = BinOp->getOperand(0),
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: auto *LHS = BinOp->getOperand(0),
- en: '*RHS = BinOp->getOperand(1);'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*RHS = BinOp->getOperand(1);'
- en: // Has no constant operand
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 没有常数操作数
- en: if (!isa<ConstantInt>(RHS) && !isa<ConstantInt>(LHS)) {
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (!isa<ConstantInt>(RHS) && !isa<ConstantInt>(LHS)) {
- en: ORE.emit([&]() {
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ORE.emit([&]() {
- en: return …
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return …
- en: '});'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '});'
- en: continue;
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: continue;
- en: '}'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: …
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: …
- en: '}'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: …
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: …
- en: '[PRE22]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: So far, we have only studied the generated optimization remark YAML file. Though
    it has provided valuable diagnostic information, it would be great if we could
    have more fine-grained and intuitive location information to know where exactly
    these remarks happened. Luckily, Clang and LLVM have provided a way to achieve
    that.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只研究了生成的优化备注YAML文件。虽然它提供了有价值的诊断信息，但如果我们能获得更多细粒度和直观的位置信息，以了解这些备注的确切发生位置，那就太好了。幸运的是，Clang和LLVM提供了一种实现这一目标的方法。
- en: 'With the help of Clang, we can actually generate optimization remarks with
    **source location** (that is, line and column numbers in the original source file)
    attached. Furthermore, LLVM provides you with a small utility that can associate
    an optimization remark with its corresponding source location and visualize the
    result on a web page. Here''s how to do this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clang的帮助下，我们实际上可以生成带有**源位置**（即原始源文件中的行和列号）的优化备注。此外，LLVM为您提供了一个小型实用工具，可以将优化备注与其对应源位置关联，并在网页上可视化结果。以下是这样做的方法：
- en: 'Let''s reuse the following code as the input:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们重用以下代码作为输入：
- en: '[PRE23]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'First, let''s generate optimization remarks using this `clang` command:'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，让我们使用以下`clang`命令生成优化备注：
- en: '[PRE24]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After `licm.remark.yaml` is generated, let''s use a utility called `opt-viewer.py`
    to visualize the remarks. The `opt-viewer.py` script is not installed in the typical
    location by default—instead of putting it in `<install path>/bin` (for example
    `/usr/bin`), it is installed in `<install path>/share/opt-viewer` (`/usr/share/opt-viewer`).
    We are going to invoke this script with the following command-line options:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生成`licm.remark.yaml`之后，让我们使用一个名为`opt-viewer.py`的工具来可视化备注。`opt-viewer.py`脚本默认不是安装在典型位置——它不是放在`<install
    path>/bin`（例如`/usr/bin`）中，而是安装在`<install path>/share/opt-viewer`（`/usr/share/opt-viewer`）。我们将使用以下命令行选项调用此脚本：
- en: '[PRE25]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: (Note that `opt-viewer.py` depends on several Python packages such as `pyyaml`
    and `pygments`. Please install them before you use `opt-viewer.py`.)
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （请注意，`opt-viewer.py`依赖于几个Python包，如`pyyaml`和`pygments`。请在使用`opt-viewer.py`之前安装它们。）
- en: There will be a HTML file—`index.html`—generated inside the `licm_remark` folder.
    Before you open the web page, please copy the original source code—`opt_remark_licm.c`—into
    that folder as well. After that, you will be able to see a web page like this:![Figure
    11.1 – Web page of optimization remarks combined with the source file
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`licm_remark`文件夹内将生成一个HTML文件——`index.html`。在您打开网页之前，请将原始源代码——`opt_remark_licm.c`——也复制到该文件夹中。之后，您将能够看到如下网页：![图11.1
    – 优化注释与源文件结合的网页
- en: '](img/B14590_Figure_11.1.jpg)'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B14590_Figure_11.1.jpg)'
- en: Figure 11.1 – Web page of optimization remarks combined with the source file
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 优化注释与源文件结合的网页
- en: 'We are particularly interested in two of these columns: `Missed`, `Passed`,
    or `Analyzed` rendered in red, green, and white, respectively—attached on a given
    line shown at the **Source Location** column.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们特别关注其中的两列：分别以红色、绿色和白色渲染的`Missed`、`Passed`或`Analyzed`——分别附加在“源位置”列中显示的给定行上。
- en: 'If we click on a link in the **Source Location** column, this will navigate
    you to a page that looks like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击“源位置”列中的链接，这将带您到一个看起来像这样的页面：
- en: '![Figure 11.2 – Details of an optimization remark'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.2 – 优化注释的详细信息'
- en: '](img/B14590_Figure_11.2.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14590_Figure_11.2.jpg)'
- en: Figure 11.2 – Details of an optimization remark
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – 优化注释的详细信息
- en: This page gives you a nice view of optimization remark details, interleaved
    with the originating source code line. For example, on *line 3*, `loop-vectorize`
    Pass said it couldn't vectorize this loop because its cost model didn't think
    it was beneficial to do so.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面为您提供了一个优化注释细节的清晰视图，与原始源代码行交织在一起。例如，在*第3行*，`loop-vectorize` Pass表示它无法向量化这个循环，因为它的成本模型认为这样做没有好处。
- en: You have now learned how to use optimization remarks to gain insights into the
    optimization Pass, which is especially useful when you're debugging a missing
    optimization opportunity or fixing a mis-compilation bug.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经学会了如何使用优化注释来深入了解优化Pass，这在调试缺失的优化机会或修复误编译错误时特别有用。
- en: In the next section, we are going to learn some useful skills to profile the
    execution time of LLVM.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习一些有用的技能来分析LLVM的执行时间。
- en: Adding time measurements
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加时间测量
- en: LLVM is an enormous software, with hundreds of components working closely together.
    Its ever-increasing running time is slowly becoming an issue. This affects many
    use cases that are sensitive to compilation time—for example, the **Just-in-Time**
    (**JIT**) compiler. To diagnose this problem in a systematic way, LLVM provides
    some useful utilities for **profiling** the execution time.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM是一个庞大的软件，有成百上千的组件紧密协作。其不断增长的运行时间正逐渐成为一个问题。这影响了众多对编译时间敏感的使用场景——例如，**即时编译器**（**JIT**）。为了系统地诊断这个问题，LLVM提供了一些有用的工具来**分析**执行时间。
- en: 'Time profiling has always been an important topic in software development.
    With the running time collected from individual software components, we can spot
    performance bottlenecks more easily. In this section, we are going to learn about
    two tools provided by LLVM: the `Timer` class and the `TimeTraceScope` class.
    Let''s start with the `Timer` class first.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 时间分析一直是软件开发中的重要主题。通过从单个软件组件收集运行时间，我们可以更容易地发现性能瓶颈。在本节中，我们将学习LLVM提供的两个工具：`Timer`类和`TimeTraceScope`类。让我们首先从`Timer`类开始。
- en: Using the Timer class
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Timer类
- en: 'The `Timer` class, as suggested by its name, can measure the execution time
    of a code region. Here is an example of this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`Timer`类可以测量代码区域的执行时间。以下是一个例子：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding snippet, `Timer` instance `T` measures the time spent in the
    region, enclosed by the `startTimer` and `stopTimer` method calls.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`Timer`实例`T`通过`startTimer`和`stopTimer`方法调用测量的区域时间。
- en: 'Now that we have collected the timing data, let''s try to print it out. Here
    is an example of this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经收集了时间数据，让我们尝试将其打印出来。以下是一个例子：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the previous code snippet, a `TimeRecord` instance encapsulates the data
    collected by the `Timer` class. We can then use `TimeRecord::print` to print it
    to a stream—in this case, the `errs()` stream. In addition, we assigned another
    `TimeRecord` instance—via the first argument of `print`—as the *total* time interval
    we want to compare it against. Let''s look at the output of this code, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，一个`TimeRecord`实例封装了`Timer`类收集的数据。然后我们可以使用`TimeRecord::print`将其打印到一个流中——在这种情况下，是`errs()`流。此外，我们还通过`print`的第一个参数分配了另一个`TimeRecord`实例——作为我们想要比较的*总*时间间隔。让我们看看此代码的输出，如下所示：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding output, the first row shows the `TimeRecord` instance collected
    from our previous `Timer` instance, whereas the second row shows the total time—the
    first argument of `TimeRecord::print`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，第一行显示了从我们之前的`Timer`实例收集的`TimeRecord`实例，而第二行显示了总时间——`TimeRecord::print`的第一个参数。
- en: 'We now know how to print the timing data collected by a single `Timer` instance,
    but what about multiple timers? LLVM provides another support utility for the
    `Timer` class: the `TimerGroup` class. Here''s an example usage of the `TimerGroup`
    class:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何打印单个`Timer`实例收集的时间数据，但多个计时器怎么办？LLVM为`Timer`类提供了另一个支持工具：`TimerGroup`类。以下是一个`TimerGroup`类的使用示例：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the preceding code snippet, we declare a `TimerGroup` instance, `TG`, and
    use it as the third constructor argument for each `Timer` instance we create.
    Finally, we print them using `TimerGroup::print`. Here is the output of this code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们声明了一个`TimerGroup`实例，`TG`，并将其用作我们创建的每个`Timer`实例的第三个构造函数参数。最后，我们使用`TimerGroup::print`来打印它们。以下是此代码的输出：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Each row in the output (except the last one) is the `TimeRecord` instance for
    each `Timer` instance in this group.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中的每一行（除了最后一行）都是该组中每个`Timer`实例的`TimeRecord`实例。
- en: 'So far, we have been using `Timer::startTimer` and `Timer::stopTimer` to toggle
    the timer. To make measuring the time interval within a code block—namely, the
    region enclosed with curly brackets `{}`—easier without manually calling those
    two methods, LLVM provides another utility that automatically starts the timer
    upon entering a code block and turns it off when exiting. Let''s see how to use
    the `TimeRegion` class with the following sample code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用`Timer::startTimer`和`Timer::stopTimer`来切换计时器。为了在不需要手动调用这两个方法的情况下，更容易地测量代码块内的时间间隔——即花括号`{}`包围的区域——LLVM提供了一个自动在进入代码块时启动计时器并在退出时关闭计时器的工具。让我们看看如何使用`TimeRegion`类，以下是一个示例代码：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see in the preceding snippet, instead of calling `startTimer`/`stopTimer`,
    we put the to-be-measured code into a separate code block and use a `TimeRegion`
    variable to automatically toggle the timer. This code will print out the same
    content as the previous example. With the help of `TimeRegion`, we can have a
    more concise syntax and avoid any mistakes where we *forget* to turn off the timer.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，我们不是调用`startTimer`/`stopTimer`，而是将待测代码放入一个单独的代码块中，并使用`TimeRegion`变量自动切换计时器。此代码将打印出与上一个示例相同的内容。借助`TimeRegion`，我们可以拥有更简洁的语法，并避免任何由于*忘记*关闭计时器而犯的错误。
- en: You have now learned how to use `Timer` and its supporting utilities to measure
    the execution time of a certain code region. In the next section, we are going
    to learn a more advanced form of time measurement that captures the hierarchical
    structure of the program.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经学会了如何使用`Timer`及其支持工具来测量特定代码区域的执行时间。在下一节中，我们将学习一种更高级的时间测量形式，它可以捕获程序的层次结构。
- en: Collecting the time trace
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 收集时间跟踪
- en: In the previous section, we learned how to use `Timer` to collect the execution
    time of a small range of code regions. Although that gave us a portrait of the
    compiler's runtime performance, we sometimes need a more *structural* timing profile
    in order to fully understand any systematic issues.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何使用`Timer`来收集一小段代码区域的执行时间。尽管这给了我们编译器运行时性能的轮廓，但我们有时需要更*结构化*的时间统计信息，以便完全理解任何系统性问题。
- en: '`TimeTraceScope` is a class provided by LLVM to perform global-scope time profiling.
    Its usage is pretty simple: similar to `TimeRegion`, which we saw in the previous
    section, a `TimeTraceScope` instance automatically turns the time profiler on
    and off upon entering and exiting a code block. Here is an example of this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`TimeTraceScope`是LLVM提供的一个用于执行全局范围时间分析的类。它的用法很简单：类似于我们在上一节中看到的`TimeRegion`，`TimeTraceScope`实例在进入和退出代码块时会自动打开和关闭时间分析器。以下是一个示例：'
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the preceding code snippet, we create two `TimeTraceScope` instances: `OuterTimeScope`
    and `InnerTimeScope`. These try to profile the execution time of the whole region
    and the time spent on function `foo`, respectively.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了两个 `TimeTraceScope` 实例：`OuterTimeScope` 和 `InnerTimeScope`。这些尝试分析整个区域的执行时间和函数
    `foo` 上的时间。
- en: Normally, if we use `Timer` rather than `TimeTraceScope`, it can only give us
    the aggregate duration collected from each timer. However, in this case, we are
    more interested in how different parts of the code allocate themselves on the
    *timeline*. For example, does the `foo` function always spend the same amount
    of time ion every loop iteration? If that's not the case, which iterations spend
    more time than others?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果我们使用 `Timer` 而不是 `TimeTraceScope`，它只能给我们每个计时器收集的聚合持续时间。然而，在这种情况下，我们更感兴趣的是代码的不同部分如何在
    *时间线* 上分配自己。例如，`foo` 函数是否在每次循环迭代中花费相同的时间？如果不是这样，哪些迭代花费的时间比其他迭代多？
- en: 'To see the result, we need to add additional command-line options to the `opt`
    command when running the Pass (assuming you use `TimeTraceScope` within a Pass).
    Here is an example of this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看结果，我们需要在运行 Pass 时向 `opt` 命令添加额外的命令行选项（假设您在 Pass 中使用 `TimeTraceScope`）。以下是一个例子：
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The additional `-time-trace` flag is asking `opt` to export all the traces collected
    by `TimeTraceScope` to the file designated by the `-time-trace-file` option.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的 `-time-trace` 标志是要求 `opt` 将 `TimeTraceScope` 收集的所有跟踪导出到由 `-time-trace-file`
    选项指定的文件中。
- en: 'After running this command, you will get a new file, `my_trace.json`. The content
    of this file is basically non-human-readable, but guess what? You can visualize
    it using the **Chrome** web browser. Here are the steps to do this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，您将得到一个新的文件，`my_trace.json`。该文件的内容基本上是不可读的，但你知道吗？您可以使用 **Chrome** 网络浏览器来可视化它。以下是操作的步骤：
- en: Open your Chrome web browser and type in `chrome://tracing` in the **Uniform
    Resource Locator** (**URL**) bar. You will see an interface that looks like this:![Figure
    11.3 – The trace visualizer in Chrome
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的 Chrome 网络浏览器，并在 **统一资源定位符** (**URL**) 栏中输入 `chrome://tracing`。您将看到一个类似这样的界面：![图
    11.3 – Chrome 中的跟踪可视化器
- en: '](img/B14590_Figure_11.3.jpg)'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14590_Figure_11.3.jpg)'
- en: Figure 11.3 – The trace visualizer in Chrome
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 11.3 – Chrome 中的跟踪可视化器
- en: Click on the `my_trace.json` file. You will see a page like this:![Figure 11.4
    – The view after opening my_trace.json
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `my_trace.json` 文件。您将看到一个类似这样的页面：![图 11.4 – 打开 my_trace.json 后的视图
- en: '](img/B14590_Figure_11.4.jpg)'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14590_Figure_11.4.jpg)'
- en: Figure 11.4 – The view after opening my_trace.json
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 11.4 – 打开 my_trace.json 后的视图
- en: Each color block represents a time interval collected by a `TimeTraceScope`
    instance.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个颜色块代表一个由 `TimeTraceScope` 实例收集的时间间隔。
- en: 'Let''s take a closer look: please press the number key *3* to switch to zoom
    mode. After that, you should be able to zoom in or out by clicking and dragging
    the mouse up or down. In the meantime, you can use the arrow keys to scroll the
    timeline left or right. Here is part of the timeline after we zoom in:![Figure
    11.5 – Part of the trace timeline'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看：请按数字键 *3* 切换到缩放模式。之后，您应该可以通过点击并上下拖动鼠标来放大或缩小。同时，您可以使用箭头键左右滚动时间线。以下是缩放后的时间线的一部分：![图
    11.5 – 跟踪时间线的一部分
- en: '](img/B14590_Figure_11.5.jpg)'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14590_Figure_11.5.jpg)'
- en: Figure 11.5 – Part of the trace timeline
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 11.5 – 跟踪时间线的一部分
- en: As we can see from *Figure 11.5*, there are several layers stacking together.
    This layout reflects how different `TimeTraceScope` instances are organized in
    `opt` (and in our Pass). For example, our `TimeTraceScope` instance entitled `TheOuterScope`
    is stacked above multiple `TheInnerScope` blocks. Each of the `TheInnerScope`
    blocks represents the time spent on the `foo` function in each loop iteration
    we saw earlier.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如我们从 *图 11.5* 中所见，有多个层叠在一起。这种布局反映了不同的 `TimeTraceScope` 实例在 `opt`（以及在我们的 Pass
    中）是如何组织的。例如，我们的 `TimeTraceScope` 实例名为 `TheOuterScope` 是堆叠在多个 `TheInnerScope` 块之上的。每个
    `TheInnerScope` 块代表我们在之前看到的每个循环迭代中 `foo` 函数所花费的时间。
- en: 'We can further inspect the properties of a block by clicking on it. For example,
    if we click one of the `TheInnerScope` blocks, its timing properties will be shown
    in the lower half of the screen. Here is an example of this:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过点击来进一步检查一个块的性质。例如，如果我们点击一个 `TheInnerScope` 块，其时间属性将显示在屏幕的下半部分。以下是一个例子：
- en: '![Figure 11.6 – Details of a time interval block'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.6 – 时间间隔块的详细信息'
- en: '](img/B14590_Figure_11.6.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14590_Figure_11.6.jpg)'
- en: Figure 11.6 – Details of a time interval block
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 – 时间间隔块的详细信息
- en: This gives us information such as the time interval and the starting time in
    this timeline.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了诸如时间间隔和此时间线中的起始时间等信息。
- en: With this visualization, we can combine timing information with the structure
    of the compiler, which will help us to find out performance bottlenecks more rapidly.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种可视化，我们可以将时间信息与编译器的结构相结合，这将帮助我们更快地找出性能瓶颈。
- en: 'In addition to `opt`, `clang` can also generate the same trace JSON file. Please
    consider adding a `-ftime-trace` flag. Here is an example of this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`opt`之外，`clang`还可以生成相同的跟踪JSON文件。请考虑添加`-ftime-trace`标志。以下是一个示例：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This will generate a JSON trace file with the same name as the input file. In
    this case, it will be `foo.json`. You can use the skills we just learned to visualize
    it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个与输入文件同名的JSON跟踪文件。在这种情况下，它将是`foo.json`。您可以使用我们刚刚学到的技能来可视化它。
- en: In this section, we have learned some useful skills to collect statistics from
    LLVM. The `Statistic` class can be used as an integer counter to record the number
    of events occurring in the optimization. Optimization remarks, on the other hand,
    can give us insights into some of the decision-making process inside the optimization
    Pass, making it easier for compiler developers to diagnose missing optimization
    opportunities. With `Timer` and `TimeTraceScope`, developers can monitor LLVM's
    execution time in a more manageable way and handle compilation-speed regressions
    with confidence. These techniques can improve an LLVM developer's productivity
    when creating new inventions or fixing a challenging problem.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了一些有用的技能来收集LLVM的统计数据。`Statistic`类可以用作整数计数器来记录优化中发生的事件数量。另一方面，优化注释可以让我们深入了解优化Pass内部的一些决策过程，这使得编译器开发者更容易诊断遗漏的优化机会。通过`Timer`和`TimeTraceScope`，开发者可以以更可控的方式监控LLVM的执行时间，并自信地处理编译速度回归。这些技术可以提高LLVM开发者创建新发明或解决难题时的生产力。
- en: In the next section of this chapter, we are going to learn how to write error-handling
    code in an efficient way, using utilities provided by LLVM.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的下一节中，我们将学习如何使用LLVM提供的工具以高效的方式编写错误处理代码。
- en: Error-handling utilities in LLVM
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LLVM的错误处理工具
- en: Error handling has always been a widely discussed topic in software development.
    It can be as simple as returning an error code—such as in many of the Linux APIs
    (for example, the `open` function)—or using an advanced mechanism such as throwing
    an exception, which has been widely adopted by many modern programming languages
    such as Java and C++.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理一直是软件开发中广泛讨论的话题。它可以像返回一个错误代码那样简单——例如，在许多Linux API中（例如，`open`函数）——或者使用像抛出异常这样的高级机制，这种机制已被许多现代编程语言（如Java和C++）广泛采用。
- en: Although C++ has built-in support for exception handling, LLVM does *not* adopt
    it in its code base at all. The rationale behind this decision is that despite
    its convenience and expressive syntax, exception handling in C++ comes at a high
    cost in terms of performance. Simply speaking, exception handling makes the original
    code more complicated and hinders a compiler's ability to optimize it. Furthermore,
    during runtime, the program usually needs to spend more time recovering from an
    exception. Therefore, LLVM disables exception handling by default in its code
    base and falls back to other ways of error handling—for example, carrying an error
    with the return value or using the utilities we are going to learn about in this
    section.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管C++具有内置的异常处理支持，但LLVM在其代码库中**并不**采用它。这一决策背后的理由是，尽管它方便且语法表达能力强，但C++中的异常处理在性能方面代价高昂。简单来说，异常处理使原始代码更加复杂，并阻碍了编译器优化它的能力。此外，在运行时，程序通常需要花费更多时间从异常中恢复。因此，LLVM默认禁用了其代码库中的异常处理，并回退到其他错误处理方式——例如，通过返回值携带错误或使用本节将要学习的工具。
- en: In the first half of this section, we are going to talk about the `Error` class,
    which—as the name suggests—represents an error. This is unlike conventional error
    representations—when using an integer as the error code, for instance, you cannot
    *ignore* the generated `Error` instances without handling it. We will explain
    this shortly.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的上半部分，我们将讨论`Error`类，正如其名称所暗示的那样，它表示一个错误。这与传统的错误表示不同——例如，当使用整数作为错误代码时，如果不处理它，就无法*忽略*生成的`Error`实例。我们很快就会解释这一点。
- en: 'In addition to the `Error` class, developers found that in LLVM''s code base
    a common pattern was shared by much of the error-handling code: an API may return
    a result *or* an error, but not both (at the same time). For instance, when we
    call a file-reading API, we are expecting to get the content of that file (the
    result) or an error when something goes wrong (for example, there is no such file).
    In the second part of this section, we are going to learn two utility classes
    that implement this pattern.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Error`类之外，开发者发现LLVM代码库中的错误处理代码存在一个共同的模式：一个API可能返回一个结果*或*一个错误，但不能同时返回两者。例如，当我们调用一个文件读取API时，我们期望得到该文件的内容（结果）或者当出现错误时（例如，没有这样的文件）返回一个错误。在本节的第二部分，我们将学习两个实现此模式的实用类。
- en: Let's start with an introduction to the `Error` class first.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从`Error`类的介绍开始。
- en: Introducing the Error class
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍`Error`类
- en: 'The concept represented by the `Error` class is pretty simple: it''s an error
    with supplementary descriptions such as an error message or error code. It is
    designed to be passed by a value (as a function argument) or returned from a function.
    Developers are free to create their custom `Error` instance, too. For example,
    if we want to create a `FileNotFoundError` instance to tell users that a certain
    file does not exist, we can write the following code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`Error`类所表示的概念相当简单：它是一个带有补充描述的错误，如错误消息或错误代码。它被设计为可以通过值（作为函数参数）或从函数返回。开发者也可以自由地创建他们自己的自定义`Error`实例。例如，如果我们想创建一个`FileNotFoundError`实例来告诉用户某个文件不存在，我们可以编写以下代码：'
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'There are several requirements for implementing a custom `Error` instance.
    These are listed next:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 实现自定义`Error`实例有几个要求。以下列出了这些要求：
- en: Derive from the `ErrorInfo<T>` class, where `T` is your custom class.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`ErrorInfo<T>`类派生，其中`T`是您的自定义类。
- en: Declare a unique `ID` variable. In this case, we use a static class member variable.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个唯一的`ID`变量。在这种情况下，我们使用一个静态类成员变量。
- en: Implement the `convertToErrorCode` method. This method designates a `std::error_code`
    instance for this `Error` instance. `std::error_code` is the error type used in
    the C++ standard library (since C++11). Please refer to the C++ reference documentation
    for available (predefined) `std::error_code` instances.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个`convertToErrorCode`方法。此方法为这个`Error`实例指定一个`std::error_code`实例。`std::error_code`是C++标准库中使用的错误类型（自C++11起）。请参阅C++参考文档以获取可用的（预定义的）`std::error_code`实例。
- en: Implement the `log` method to print out error messages.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个`log`方法来打印错误信息。
- en: 'To create an `Error` instance, we can leverage a `make_error` utility function.
    Here is an example usage of this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个`Error`实例，我们可以利用一个`make_error`实用函数。以下是一个示例用法：
- en: '[PRE36]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `make_error` function takes an error class—in this case, our `FileNotFoundError`
    class—as the template argument and function arguments (in this case, `foo.txt`),
    if there are any. These will then be passed to its constructor.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_error`函数接受一个错误类作为模板参数和函数参数（在这种情况下，`foo.txt`），如果有任何参数。然后这些参数将被传递给其构造函数。'
- en: 'If you try to run the preceding code (in debug build) without doing anything
    to the `NoSuchFileErr` variable, the program will simply crash and show an error
    message such as this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试在没有对`NoSuchFileErr`变量进行任何操作的情况下运行前面的代码（在调试构建中），程序将简单地崩溃并显示如下错误信息：
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It turns out that every `Error` instance is required to be **checked** and **handled**
    before the end of its lifetime (that is, when its destructor method is called).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，每个`Error`实例在其生命周期结束之前（即其析构方法被调用时）都必须**检查**和**处理**。
- en: 'Let me first explain what *checking an* `Error` *instance* means. In addition
    to representing a real error, the `Error` class can also represent a *success*
    state—that is, no error. To give you a more concrete idea of this, many of the
    LLVM APIs have the following error-handling structure:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我先解释一下什么是*检查一个*`Error`*实例*。除了表示一个真实错误之外，`Error`类还可以表示一个*成功*状态——即没有错误。为了给您一个更具体的概念，许多LLVM
    API都有以下错误处理结构：
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In other words, they return an `ErrorSuccess` instance in the case of success
    or an `ErrorInfo` instance otherwise. When the program returns from `readFile`,
    we need to *check* if the returned `Error` instance represents a success result
    or not by treating it as a Boolean variable, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，它们在成功的情况下返回一个`ErrorSuccess`实例，否则返回一个`ErrorInfo`实例。当程序从`readFile`返回时，我们需要通过将其视为布尔变量来检查返回的`Error`实例是否表示成功结果，如下所示：
- en: '[PRE39]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that you *always* need to check an `Error` instance even if you are 100%
    sure that it is in a `Success` state, otherwise the program will still abort.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使你100%确信它处于`Success`状态，你也需要检查`Error`实例，否则程序仍然会中断。
- en: 'The preceding code snippet provides a good segue into the topic of handling
    `Error` instances. If an `Error` instance represents a real error, we need to
    use a special API to handle it: `handleErrors`. Here''s how to use it:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段很好地引出了处理`Error`实例的话题。如果一个`Error`实例代表一个真正的错误，我们需要使用一个特殊的API来处理它：`handleErrors`。下面是如何使用它的示例：
- en: '[PRE40]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `handleErrors` function takes ownership of the `Error` instance (by `std::move(E)`)
    and uses the provided lambda function to handle the error. You might notice that
    `handleErrors` returns another `Error` instance, which represents the *unhandled*
    error. What does that mean?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleErrors`函数通过`std::move(E)`接管`Error`实例，并使用提供的lambda函数来处理错误。你可能注意到`handleErrors`返回另一个`Error`实例，它代表*未处理的*错误。这意味着什么？'
- en: 'In the previous example of the `readFile` function, the returned `Error` instance
    can represent either a `Success` state or a `FileNotFoundError` state. We can
    slightly modify the function to return a `FileEmptyError` instance when the opened
    file is empty, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在`readFile`函数的先前的例子中，返回的`Error`实例可以代表`Success`状态或`FileNotFoundError`状态。我们可以稍微修改这个函数，以便在打开的文件为空时返回`FileEmptyError`实例，如下所示：
- en: '[PRE41]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, the `Error` instance returned from `readFile` can either be a `Success`
    state, a `FileNotFoundError` instance, *or* a `FileEmptyError` instance. However,
    the `handleErrors` code we wrote previously only handled the case of `FileNotFoundError`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从`readFile`返回的`Error`实例可以是`Success`状态，`FileNotFoundError`实例，*或者* `FileEmptyError`实例。然而，我们之前编写的`handleErrors`代码只处理了`FileNotFoundError`的情况。
- en: 'Therefore, we need to use the following code to handle the case of `FileEmptyError`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要使用以下代码来处理`FileEmptyError`的情况：
- en: '[PRE42]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Be aware that you always need to take ownership of an `Error` instance when
    using `handleErrors`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在使用`handleErrors`时，你始终需要接管`Error`实例的所有权。
- en: 'Alternatively, you can *coalesce* two `handleErrors` function calls into one
    by using multiple lambda function arguments for each of the error types, as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以通过为每种错误类型使用多个lambda函数参数，将两个`handleErrors`函数调用合并为一个，如下所示：
- en: '[PRE43]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In other words, the `handleErrors` function is acting like a switch-case statement
    for an `Error` instance. It is effectively working like the following pseudocode:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`handleErrors`函数就像一个`Error`实例的switch-case语句。它实际上工作如下面的伪代码所示：
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, you might be wondering: *Since* `handleErrors` *will always return an*
    `Error` *representing the unhandled error, and I can''t just ignore the returned
    instance, otherwise the program will abort, how should we end this "chain of error
    handling"?* There are two ways to do that, so let''s have a look at each, as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能想知道：*由于* `handleErrors` *总是返回一个*代表*未处理的*错误的`Error`，我不能简单地忽略返回的实例，否则程序将中断，我们应该如何结束这个“错误处理链”呢？*
    有两种方法可以做到这一点，让我们看看每种方法，如下所示：
- en: 'If you are 100% sure that you have handled all possible error types—which means
    that the unhandled `Error` variable is in a `Success` state—you can call the `cantFail`
    function to make an assertion, as illustrated in the following code snippet:'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你100%确信你已经处理了所有可能的错误类型——这意味着未处理的`Error`变量处于`Success`状态——你可以调用`cantFail`函数来进行断言，如下面的代码片段所示：
- en: '[PRE45]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'A more elegant solution would be to use the `handleAllErrors` function, as
    follows:'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个更优雅的解决方案是使用`handleAllErrors`函数，如下所示：
- en: '[PRE46]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You have now learned how to use the `Error` class and how to properly handle
    errors. Though the design of `Error` seems a little annoying at first glance (that
    is, we need to handle *all* possible error types or the execution will just abort
    halfway), these restrictions can decrease the number of mistakes made by programmers
    and create a more **robust** program.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经学会了如何使用`Error`类以及如何正确处理错误。尽管`Error`的设计一开始看起来有点令人烦恼（也就是说，我们需要处理*所有*可能错误类型，否则执行将半途而废），但这些限制可以减少程序员犯的错误数量，并创建一个更**健壮**的程序。
- en: Next, we are going to introduce two other utility classes that can further improve
    the error-handling expressions in LLVM.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍另外两个可以进一步改进LLVM中错误处理表达式的实用类。
- en: Learning about the Expected and ErrorOr classes
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Expected和ErrorOr类
- en: As we briefly mentioned in the introduction of this section, in LLVM's code
    base it's pretty common to see a coding pattern where an API wants to return a
    result or an error if something goes wrong. LLVM tries to make this pattern more
    accessible by creating utilities that *multiplex* results and errors in a single
    object—they are the `Expected` and `ErrorOr` classes. Let's begin with the first
    one.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本节引言中简要提到的，在 LLVM 的代码库中，看到 API 想要返回结果或错误（如果出现错误）的编码模式相当常见。LLVM 通过创建将结果和错误*多路复用*到单个对象中的实用工具来尝试使这种模式更容易访问——它们是
    `Expected` 和 `ErrorOr` 类。让我们从第一个开始。
- en: The Expected class
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Expected 类
- en: 'The `Expected` class carries either a `Success` result or an error—for instance,
    the JSON library in LLVM uses it to represent the outcome of parsing an incoming
    string, as shown next:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`Expected` 类携带一个 `Success` 结果或一个错误——例如，LLVM 中的 JSON 库使用它来表示解析传入字符串的结果，如下所示：'
- en: '[PRE47]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The preceding `JsonOrErr` class has a type of `Expected<json::Value>`. This
    means that this `Expected` variable either carries a `json::Value`-type `Success`
    result or an error, represented by the `Error` class we just learned about in
    the previous section.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `JsonOrErr` 类具有 `Expected<json::Value>` 类型。这意味着这个 `Expected` 变量要么携带一个 `json::Value`
    类型的 `Success` 结果，要么是一个错误，由我们在上一节中刚刚学习到的 `Error` 类表示。
- en: Just as with the `Error` class, every `Expected` instance needs to be *checked*.
    If it represents an error, that `Error` instance needs to be *handled* as well.
    To check the status of an `Expected` instance, we can also cast it to a Boolean
    type. However, unlike with `Error`, if an `Expected` instance contains a `Success`
    result, it will be `true` after being casted into a Boolean.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 正如与 `Error` 类一样，每个 `Expected` 实例都需要被*检查*。如果它表示一个错误，那么这个 `Error` 实例也需要被*处理*。为了检查
    `Expected` 实例的状态，我们也可以将其转换为布尔类型。然而，与 `Error` 不同，如果 `Expected` 实例包含一个 `Success`
    结果，在转换为布尔类型后它将是 `true`。
- en: If the `Expected` instance represents a `Success` result, you can fetch the
    result using either the `*` operator (as shown in the preceding code snippet),
    the `->` operator, or the `get` method. Otherwise, you can retrieve the error
    by calling the `takeError` method before handling the `Error` instance, using
    the skills we learned in the previous section.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `Expected` 实例表示一个 `Success` 结果，你可以使用 `*` 操作符（如前述代码片段所示）、`->` 操作符或 `get` 方法来获取结果。否则，在处理
    `Error` 实例之前，你可以通过调用 `takeError` 方法来检索错误，使用我们在上一节中学到的技能。
- en: 'Optionally, if you are sure that an `Expected` instance is in an `Error` state,
    you can check the underlying error type by calling the `errorIsA` method without
    retrieving the underlying `Error` instance first. For example, the following code
    checks if an error is a `FileNotFoundError` instance, which we created in the
    previous section:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，如果你确定一个 `Expected` 实例处于 `Error` 状态，你可以通过调用 `errorIsA` 方法来检查底层错误类型，而无需首先检索底层的
    `Error` 实例。例如，以下代码检查一个错误是否是 `FileNotFoundError` 实例，这是我们上一节中创建的：
- en: '[PRE48]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'These are tips for consuming an `Expected` variable. To create an `Expected`
    instance, the most common way is to leverage the *implicit* type conversion to
    `Expected`. Here is an example of this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是消费 `Expected` 变量的技巧。要创建一个 `Expected` 实例，最常见的方式是利用到 `Expected` 的*隐式*类型转换。以下是一个例子：
- en: '[PRE49]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The preceding code shows that in cases where something goes wrong, we can simply
    return an `Error` instance, which will be implicitly converted into an `Expected`
    instance representing that error. Similarly, if everything goes pretty smoothly,
    the `Success` result—in this case, the `std::string` type variable, `Content`—will
    also be implicitly converted into an `Expected` instance with a `Success` state.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码显示，在出现错误的情况下，我们可以简单地返回一个 `Error` 实例，它将被隐式转换为表示该错误的 `Expected` 实例。同样地，如果一切进行得相当顺利，`Success`
    结果——在这个例子中，是 `std::string` 类型的变量 `Content`——也将被隐式转换为具有 `Success` 状态的 `Expected`
    实例。
- en: 'You have now learned how to use the `Expected` class. The last part of this
    section will show you how to use one of its sibling classes: `ErrorOr`.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经学会了如何使用 `Expected` 类。本节的最后一部分将向你展示如何使用其兄弟类之一：`ErrorOr`。
- en: The ErrorOr class
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ErrorOr 类
- en: 'The `ErrorOr` class uses a model that is nearly identical to the `Expected`
    class—it is either a `Success` result or an error. Unlike the `Expected` class,
    `ErrorOr` uses `std::error_code` to represent the error. Here is an example of
    using the `MemoryBuffer` API to read a file—`foo.txt`— and storing its content
    into a `MemoryBuffer` object:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`ErrorOr`类使用与`Expected`类几乎相同的模型——它要么是`Success`结果，要么是错误。与`Expected`类不同，`ErrorOr`使用`std::error_code`来表示错误。以下是一个使用`MemoryBuffer`
    API读取文件——`foo.txt`——并将其内容存储到`MemoryBuffer`对象中的示例：'
- en: '[PRE50]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The previous code snippet shows a similar structure, with the sample code for
    `Expected` we saw previously: the `std::unique_ptr<MemoryBuffer>` instance is
    the type of success result here. We can also retrieve it using the `*` operator
    after checking the state of `ErrOrBuffer`.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段显示了类似的结构，其中包含了之前看到的`Expected`的示例代码：这里的`std::unique_ptr<MemoryBuffer>`实例是成功结果的类型。我们也可以在检查`ErrOrBuffer`的状态后使用`*`运算符来检索它。
- en: The only difference here is that if `ErrOrBuffer` is in an `Error` state, the
    error is represented by a `std::error_code` instance rather than `Error`. Developers
    are not *obliged* to handle a `std::error_code` instance—in other words, they
    can just ignore that error, which might increase the chances of other developers
    making mistakes in the code. Nevertheless, using the `ErrorOr` class can give
    you better *interoperability* with C++ standard library APIs, as many of them
    use `std::error_code` to represent errors. For details about how to use `std::error_code`,
    please refer to the C++ reference documentation.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的唯一区别是，如果`ErrOrBuffer`处于`Error`状态，错误将由一个`std::error_code`实例表示，而不是`Error`。开发者不是*必须*处理`std::error_code`实例——换句话说，他们可以忽略该错误，这可能会增加其他开发者犯错的几率。尽管如此，使用`ErrorOr`类可以为您提供更好的与C++标准库API的*互操作性*，因为其中许多使用`std::error_code`来表示错误。有关如何使用`std::error_code`的详细信息，请参阅C++参考文档。
- en: 'Finally, to create an `ErrorOr` instance, we are using the same trick we used
    on the `Expected` class—leveraging implicit conversion, as shown in the following
    code snippet:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了创建一个`ErrorOr`实例，我们使用了与`Expected`类相同的技巧——利用隐式转换，如下面的代码片段所示：
- en: '[PRE51]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `std::errc::no_such_file_or_directory` object is one of the predefined `std::error_code`
    objects from the `system_error` header file.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::errc::no_such_file_or_directory`对象是来自`system_error`头文件中预定义的`std::error_code`对象之一。'
- en: In this section, we learned how to use some error-handling utilities provided
    by LLVM—the important `Error` class that imposes strict rules on unhandled errors,
    and the `Expected` and `ErrorOr` classes that provide you with a handy way of
    multiplexing the program result and error state in a single object. These tools
    can help you to write expressive yet robust error-handling code when developing
    with LLVM.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用LLVM提供的某些错误处理实用工具——重要的`Error`类，它对未处理的错误施加严格规则，以及`Expected`和`ErrorOr`类，它们为您提供了在单个对象中多路复用程序结果和错误状态的手边工具。这些工具可以帮助您在LLVM开发中编写表达性强且健壮的错误处理代码。
- en: Summary
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned lots of useful utilities that can improve our productivity
    when developing with LLVM. Some of them—such as optimization remarks or timers—are
    useful for diagnosing problems raised by LLVM, while others—the `Error` class,
    for instance—help you to build more robust code that scales well with the complexity
    of your own compiler.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了大量的实用工具，这些工具可以提高我们使用LLVM进行开发时的生产力。其中一些——例如优化注释或计时器——有助于诊断LLVM提出的问题，而其他一些——例如`Error`类——则帮助您构建更健壮的代码，这些代码可以很好地适应您自己的编译器的复杂性。
- en: In the final chapter of this book, we are going to learn about **profile-guided
    optimization** (**PGO**) and sanitizer development, which are advanced topics
    that you can't miss.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一章中，我们将学习关于**基于配置文件优化**（**PGO**）和**sanitizer**开发的内容，这些都是您不容错过的先进主题。
