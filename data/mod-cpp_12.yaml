- en: Math Problems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数学问题
- en: Problems
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Here are the problem-solving sections for this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章的问题解决部分。
- en: 1\. Sum of naturals divisible by 3 and 5
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. 可被3和5整除的自然数之和
- en: Write a program that calculates and prints the sum of all the natural numbers
    divisible by either 3 or 5, up to a given limit entered by the user.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个计算和打印所有自然数的程序，这些自然数可被3或5整除，直到用户输入的给定限制为止。
- en: 2\. Greatest common divisor
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. 最大公约数
- en: Write a program that, given two positive integers, will calculate and print
    the greatest common divisor of the two.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，给定两个正整数，将计算并打印两者的最大公约数。
- en: 3\. Least common multiple
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. 最小公倍数
- en: Write a program that will, given two or more positive integers, calculate and
    print the least common multiple of them all.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，给定两个或多个正整数，计算并打印它们的最小公倍数。
- en: 4\. Largest prime smaller than given number
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 给定数字以下的最大质数
- en: Write a program that computes and prints the largest prime number that is smaller
    than a number provided by the user, which must be a positive integer.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，计算并打印小于用户提供的数字的最大质数，该数字必须是正整数。
- en: 5\. Sexy prime pairs
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 性感素数
- en: Write a program that prints all the sexy prime pairs up to a limit entered by
    the user.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，打印用户输入限制范围内的所有性感素数对。
- en: 6\. Abundant numbers
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 过剩数
- en: Write a program that prints all abundant numbers and their abundance, up to
    a number entered by the user.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，打印所有过剩数及其过剩值，直到用户输入的数字为止。
- en: 7\. Amicable numbers
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7. 亲和数
- en: Write a program that prints the list of all pairs of amicable numbers smaller
    than 1,000,000.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，打印小于1,000,000的所有亲和数对的列表。
- en: 8\. Armstrong numbers
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8. 阿姆斯特朗数
- en: Write a program that prints all Armstrong numbers with three digits.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，打印所有三位数的阿姆斯特朗数。
- en: 9\. Prime factors of a number
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9. 数的质因数
- en: Write a program that prints the prime factors of a number entered by the user.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，打印用户输入数字的质因数。
- en: 10\. Gray code
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10. 格雷码
- en: Write a program that displays the normal binary representations, Gray code representations,
    and decoded Gray code values for all 5-bit numbers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，显示所有5位数的普通二进制表示、格雷码表示和解码的格雷码值。
- en: 11\. Converting numerical values to Roman
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11. 将数值转换为罗马数字
- en: Write a program that, given a number entered by the user, prints its Roman numeral
    equivalent.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，给定用户输入的数字，打印其罗马数字等价物。
- en: 12\. Largest Collatz sequence
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12. 最大Collatz序列
- en: Write a program that determines and prints which number up to 1 million produces
    the longest Collatz sequence and what its length is.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，确定并打印出哪个数字最多产生最长的Collatz序列，以及它的长度是多少。
- en: 13\. Computing the value of Pi
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13. 计算Pi的值
- en: Write a program that computes the value of Pi with a precision of two decimal
    digits.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个计算Pi值的程序，精确到小数点后两位。
- en: 14\. Validating ISBNs
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14. 验证ISBN
- en: Write a program that validates that 10-digit values entered by the user, as
    a string, represent valid ISBN-10 numbers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，验证用户输入的10位值（作为字符串）是否表示有效的ISBN-10号码。
- en: Solutions
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: Here are the solutions for the above problem-solving sections.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以上是上述问题解决部分的解决方案。
- en: 1\. Sum of naturals divisible by 3 and 5
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. 可被3和5整除的自然数之和
- en: 'The solution to this problem is to iterate through all numbers from 3 (1 and
    2 are not divisible by 3 so it does not make sense to test them) up to the limit
    entered by the user. Use the modulo operation to check that the rest of the division
    of a number by 3 and 5 is 0\. However, the trick to being able to sum up to a
    larger limit is to use `long long` and not `int` or `long` for the sum, which
    would result in an overflow before summing up to 100,000:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此问题的方法是迭代从3（1和2不能被3整除，因此没有测试它们的意义）到用户输入的限制的所有数字。使用模运算来检查一个数字除以3和5的余数是否为0。然而，能够加到更大限制的技巧是使用`long
    long`而不是`int`或`long`进行求和，否则在加到100,000之前会发生溢出：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 2\. Greatest common divisor
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. 最大公约数
- en: 'The greatest common divisor (*gcd* in short) of two or more non-zero integers,
    also known as the greatest common factor (*gcf*), highest common factor (*hcf*),
    greatest common measure (*gcm*), or highest common divisor, is the greatest positive
    integer that divides all of them. There are several ways the gcd could be computed;
    an efficient method is Euclid''s algorithm. For two integers, the algorithm is:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 两个或多个非零整数的最大公约数（*gcd*简称），也称为最大公因数（*gcf*）、最大公因数（*hcf*）、最大公度量（*gcm*）或最大公约数，是能够整除它们所有的最大正整数。可以计算gcd的几种方法；一种有效的方法是欧几里得算法。对于两个整数，该算法是：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This can be very simply implemented in C++ using a recursive function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在C++中使用递归函数非常简单地实现：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A non-recursive implementation of Euclid''s algorithm should look like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 欧几里得算法的非递归实现应该如下所示：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In C++17 there is a `constexpr` function called `gcd()` in the header `<numeric>` that
    computes the greatest common divisor of two numbers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17中，头文件`<numeric>`中有一个名为`gcd()`的`constexpr`函数，用于计算两个数字的最大公约数。
- en: 3\. Least common multiple
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. 最小公倍数
- en: 'The **least common multiple** (**lcm**) of two or more non-zero integers, also
    known as the lowest common multiple, or smallest common multiple, is the smallest
    positive integer that is divisible by all of them. A possible way to compute the
    least common multiple is by reducing the problem to computing the greatest common
    divisor. The following formula is used in this case:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 两个或多个非零整数的**最小公倍数**（**lcm**），也称为最小公倍数，或最小公倍数，是可以被它们所有整除的最小正整数。计算最小公倍数的一种可能方法是将问题简化为计算最大公约数。在这种情况下使用以下公式：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A function to compute the least common multiple may look like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 计算最小公倍数的函数可能如下所示：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To compute the *lcm* for more than two integers, you could use the `std::accumulate` algorithm
    from the header `<numeric>`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算多于两个整数的*lcm*，可以使用头文件`<numeric>`中的`std::accumulate`算法：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In C++17 there is a `constexpr` function called `lcm()` in the header `<numeric>` that
    computes the least common multiple of two numbers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17中，有一个名为`lcm()`的`constexpr`函数，位于头文件`<numeric>`中，用于计算两个数的最小公倍数。
- en: 4\. Largest prime smaller than given number
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 给定数字的最大质数
- en: 'A prime number is a number that has only two divisors, 1 and the number itself.
    To find the largest prime smaller than a given number you should first write a
    function that determines if a number is prime and then call this function, starting
    from the given number, towards 1 until the first prime is encountered. There are
    various algorithms for determining if a number is prime. Common implementations
    for determining the primality appear as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 质数是只有两个因子1和本身的数。要找到小于给定数字的最大质数，你应该首先编写一个确定一个数是否为质数的函数，然后调用这个函数，从给定数字开始，向1递减直到遇到第一个质数。有各种算法可以确定一个数是否为质数。确定质数性的常见实现如下：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This function can be used as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以这样使用：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 5\. Sexy prime pairs
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 性质质数对
- en: Sexy prime numbers are prime numbers that differ from each other by six (for
    example 5 and 11, or 13 and 19). There are also *twin primes*, which differ by
    two, and *cousin primes*, which differ by four.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 性质质数是相差六的质数（例如5和11，或13和19）。还有*孪生质数*，相差两，和*表兄质数*，相差四。
- en: 'In the previous challenge, we implemented a function that determines whether
    an integer is a prime number. We will reuse that function for this exercise. What
    you have to do is check that if a number `n` is prime, the number `n+6` is also
    prime, and in this case print the pair to the console:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个挑战中，我们实现了一个确定整数是否为质数的函数。我们将重用该函数进行此练习。你需要做的是检查一个数字`n`是否为质数，数字`n+6`也是质数，并在这种情况下将这对数字打印到控制台上：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You could take it as a further exercise to compute and displays the sexy prime
    triples, quadruplets, and quintuplets.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将其作为进一步的练习来计算和显示性质质数的三元组、四元组和五元组。
- en: 6\. Abundant numbers
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 丰富数
- en: An abundant number, also known as an excessive number, is a number for which
    the sum of its proper divisors is greater than the number itself. The proper divisors
    of a number are the positive prime factors of the number, other than the number
    itself. The amount by which the sum of proper divisors exceeds the number itself
    is called abundance. For instance, the number 12 has the proper divisors 1, 2,
    3, 4, and 6\. Their sum is 16, which makes 12 an abundant number. Its abundance
    is 4 (that is, 16 - 12).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 丰富数，也被称为过剩数，是一个其真因子之和大于该数本身的数。一个数的真因子是除了该数本身以外的正的质因子。真因子之和超过该数本身的数量被称为过剩。例如，数字12有真因子1、2、3、4和6。它们的和是16，这使得12成为一个丰富数。它的过剩是4（即16-12）。
- en: 'To determine the sum of proper divisors, we try all numbers from 2 to the square
    root of the number (all prime factors are less than or equal to this value). If
    the current number, let’s call it `i`, divides the number, then `i` and `num/i` are
    both divisors. However, if they are equal (for example, if `i = 3`, and `n = 9`,
    then `i` divides 9, but `n/i = 3`), we add only `i` because proper divisors must
    only be added once. Otherwise, we add both `i` and `num/i` and continue:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定真因子的和，我们尝试从2到该数的平方根的所有数字（所有质因子都小于或等于这个值）。如果当前数字，我们称之为`i`，能够整除该数，那么`i`和`num/i`都是因子。然而，如果它们相等（例如，如果`i=3`，而`n=9`，那么`i`能整除9，但`n/i=3`），我们只添加`i`，因为真因子只能被添加一次。否则，我们添加`i`和`num/i`并继续：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Printing abundant numbers is as simple as iterating up to the specified limit,
    computing the sum of proper divisors and comparing it to the number:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 打印丰富数就像迭代到指定的限制，计算真因子的和并将其与数字进行比较一样简单：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 7\. Amicable numbers
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7. 亲和数
- en: Two numbers are said to be amicable if the sum of the proper divisors of one
    number is equal to that of the other number. The proper divisors of a number are
    the positive prime factors of the number other than the number itself. Amicable
    numbers should not be confused with *friendly numbers*. For instance, the number
    220 has the proper divisors 1, 2, 4, 5, 10, 11, 20, 22, 44, 55, and 110, whose
    sum is 284\. The proper divisors of 284 are 1, 2, 4, 71, and 142; their sum is
    220\. Therefore, the numbers 220 and 284 are said to be amicable.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个数的真因子之和等于另一个数的真因子之和，那么这两个数被称为亲和数。一个数的真因子是除了该数本身以外的正的质因子。亲和数不应该与*友好数*混淆。例如，数字220的真因子是1、2、4、5、10、11、20、22、44、55和110，它们的和是284。284的真因子是1、2、4、71和142；它们的和是220。因此，数字220和284被称为亲和数。
- en: 'The solution to this problem is to iterate through all the numbers up to the
    given limit. For each number, compute the sum of its proper divisors. Let’s call
    this `sum1`. Repeat the process and compute the sum of the proper divisors of `sum1`.
    If the result is equal to the original number, then the number and `sum1` are
    amicable numbers:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是遍历所有小于给定限制的数字。对于每个数字，计算其真因子的和。我们称这个和为`sum1`。重复这个过程并计算`sum1`的真因子的和。如果结果等于原始数字，那么数字和`sum1`是亲和数：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the above sample, `sum_proper_divisors()` is the function seen in the solution
    to the abundant numbers problem.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，`sum_proper_divisors()`是在丰富数问题的解决方案中看到的函数。
- en: The above function prints pairs of numbers twice, such as 220,284 and 284,220\.
    Modify this implementation to only print each pair a single time.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数会两次打印数字对，比如220,284和284,220。修改这个实现，只打印每对一次。
- en: 8\. Armstrong numbers
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8. 阿姆斯特朗数
- en: An Armstrong number (named so after Michael F. Armstrong), also called a narcissistic
    number, a pluperfect digital invariant, or a plus perfect number, is a number
    that is equal to the sum of its own digits when they are raised to the power of
    the number of digits. As an example, the smallest Armstrong number is 153, which
    is equal to ![](img/8a736b24-c3af-4da2-a9da-12789af4ee9e.png).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 阿姆斯特朗数（以迈克尔·F·阿姆斯特朗命名），也称为自恋数，完美的数字不变量或完美的数字，是一个等于其自身的数字，当它们被提升到数字的幂时。例如，最小的阿姆斯特朗数是153，它等于![](img/8a736b24-c3af-4da2-a9da-12789af4ee9e.png)。
- en: 'To determine if a number with three digits is a narcissistic number, you must
    first determine its digits in order to sum their powers. However, this involves
    division and modulo operations, which are expensive. A much faster way to compute
    it is to rely on the fact that a number is a sum of digits multiplied by 10 at
    the power of their zero-based position. In other words, for numbers up to 1,000,
    we have `a*10^2 + b*10^2 + c`. Since you are only supposed to determine numbers
    with three digits, that means `a` would start from 1\. This would be faster than
    other approaches because multiplications are faster to compute than divisions
    and modulo operations. An implementation of such a function would look like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定一个三位数是否是一个自恋数，您必须首先确定它的数字，以便对它们的幂求和。然而，这涉及到除法和取模运算，这些都是昂贵的。计算它的一个更快的方法是依赖于这样一个事实，即一个数字是数字的和，乘以10的零基位置的幂。换句话说，对于最多1,000的数字，我们有`a*10^2
    + b*10^2 + c`。因为你只需要确定三位数，这意味着`a`将从1开始。这比其他方法更快，因为乘法比除法和取模运算更快。这样一个函数的实现看起来像这样：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You could take it as a further exercise to write a function that determines
    the narcissistic numbers up to a limit, regardless their number of digits. Such
    a function would be slower because you first have to determine the sequence of
    digits of the number, store them in a container, and then sum together the digits
    raised to the appropriate power (the number of the digits).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将其作为进一步的练习，编写一个确定自恋数的函数，直到达到限制，而不管它们的位数如何。这样一个函数会更慢，因为你首先必须确定数字的数字序列，将它们存储在一个容器中，然后将数字加到适当的幂（数字的数量）。
- en: 9\. Prime factors of a number
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9. 数字的质因数
- en: 'The prime factors of a positive integer are the prime numbers that divide that
    integer exactly. For instance, the prime factors of 8 are 2 x 2 x 2, and the prime
    factors of 42 are 2 x 3 x 7\. To determine the prime factors you should use the
    following algorithm:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正整数的质因数是能够完全整除该整数的质数。例如，8的质因数是2 x 2 x 2，42的质因数是2 x 3 x 7。要确定质因数，您应该使用以下算法：
- en: While `n` is divisible by 2, 2 is a prime factor and must be added to the list,
    while `n` becomes the result of `n/2`. After completing this step, `n` is an odd
    number.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`n`可以被2整除时，2是一个质因数，必须添加到列表中，而`n`变为`n/2`的结果。完成此步骤后，`n`是一个奇数。
- en: Iterate from 3 to the square root of `n`. While the current number, let’s call
    it `i`, divides `n`, `i` is a prime factor and must be added to the list, while `n` becomes
    the result of `n/i`. When `i` no longer divides `n`, increment `i` by 2 (to get
    the next odd number).
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从3迭代到`n`的平方根。当当前数字，我们称之为`i`，除以`n`时，`i`是一个质因数，必须添加到列表中，而`n`变为`n/i`的结果。当`i`不再除以`n`时，将`i`增加2（以获得下一个奇数）。
- en: When `n` is a prime number greater than 2, the steps above will not result in `n` becoming
    1\. Therefore, if at the end of step 2 `n` is still greater than 2, then `n` is
    a prime factor.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`n`是大于2的质数时，上述步骤将不会导致`n`变为1。因此，如果在第2步结束时`n`仍大于2，则`n`是一个质因数。
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As a further exercise, determine the largest prime factor for the number 600,851,475,143.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 作为进一步的练习，确定数字600,851,475,143的最大质因数。
- en: 10. Gray code
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10. 格雷码
- en: 'Gray code, also known as reflected binary code or simply reflected binary,
    is a form of binary encoding where two consecutive numbers differ by only one
    bit. To perform a binary reflected Gray code encoding, we need to use the following
    formula:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 格雷码，也称为反射二进制码或简单反射二进制，是一种二进制编码形式，其中两个连续的数字只相差一个位。要执行二进制反射格雷码编码，我们需要使用以下公式：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is equivalent to the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于以下内容：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For decoding a binary reflected Gray code, the following formula should be
    used:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要解码二进制反射格雷码，应使用以下公式：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'These can be written in C++ as follows, for 32-bit unsigned integers:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以用C++编写如下，对于32位无符号整数：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To print the all 5-bit integers, their binary representation, the encoded Gray
    code representation, and the decoded value, we could use the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印所有5位整数，它们的二进制表示，编码的格雷码表示和解码的值，我们可以使用以下代码：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 11\. Converting numerical values to Roman
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11. 将数值转换为罗马数字
- en: 'Roman numerals, as they are known today, use seven symbols: I = 1, V = 5, X
    = 10, L = 50, C = 100, D = 500, and M = 1000\. The system uses additions and subtractions
    in composing the numerical symbols. The symbols from 1 to 10 are I, II, III, IV,
    V, VI, VII, VIII, IX, and X. Romans did not have a symbol for zero and used to
    write *nulla* to represent it. In this system, the largest symbols are on the
    left, and the least significant are on the right. As an example, the Roman numeral
    for 1994 is MCMXCIV. If you are not familiar with the rules for Roman numerals,
    you should read more on the web.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 罗马数字，如今所知，使用七个符号：I = 1，V = 5，X = 10，L = 50，C = 100，D = 500，M = 1000。该系统使用加法和减法来组成数字符号。从1到10的符号是I，II，III，IV，V，VI，VII，VIII，IX和X。罗马人没有零的符号，而是用*nulla*来表示。在这个系统中，最大的符号在左边，最不重要的在右边。例如，1994年的罗马数字是MCMXCIV。如果您不熟悉罗马数字的规则，您应该在网上阅读更多。
- en: 'To determine the Roman numeral of a number, use the following algorithm:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定一个数字的罗马数字，使用以下算法：
- en: Check every Roman base symbol from the highest (M) to the lowest (I)
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从最高（M）到最低（I）检查每个罗马基本符号
- en: If the current value is greater than the value of the symbol, then concatenate
    the symbol to the Roman numeral and subtract its value from the current one
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果当前值大于符号的值，则将符号连接到罗马数字并从当前值中减去其值
- en: Repeat until the current value reaches zero
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复直到当前值达到零
- en: 'For example, consider 42: the first Roman base symbol smaller than 42 is XL,
    which is 40\. We concatenate it to the numeral, resulting in XL, and subtract
    from the current number, resulting in 2\. The first Roman base symbol smaller
    than 2 is I, which is 1\. We add that to the numeral, resulting in XLI, and subtract
    1 from the number, resulting in 1\. We add one more I to the numeral, which becomes
    XLII, and subtract again 1 from the number, reaching 0 and therefore stopping:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑42：小于42的第一个罗马基本符号是XL，它是40。我们将它连接到罗马数字上，得到XL，并从当前数字中减去，得到2。小于2的第一个罗马基本符号是I，它是1。我们将它添加到罗马数字上，得到XLI，并从数字中减去1，得到1。我们再添加一个I到罗马数字中，它变成了XLII，并再次从数字中减去1，达到0，因此停止：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This function can be used as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以按照以下方式使用：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 12\. Largest Collatz sequence
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12. 最大的Collatz序列
- en: 'The Collatz conjecture, also known as the Ulam conjecture, Kakutani''s problem,
    the Thwaites conjecture, Hasse''s algorithm, or the Syracuse problem, is an unproven
    conjecture that states that a sequence defined as explained in the following always
    reaches 1\. The series is defined as follows: start with any positive integer `n` and
    obtain each new term from the previous one: if the previous term is even, the
    next term is half the previous term, or else it is 3 times the previous term plus
    1.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Collatz猜想，也称为乌拉姆猜想、角谷谜题、斯韦茨猜想、哈斯算法或锡拉丘兹问题，是一个未经证实的猜想，它指出如下所述的序列总是达到1。该系列定义如下：从任何正整数`n`开始，并从前一个整数获得每个新项：如果前一个项是偶数，则下一个项是前一个项的一半，否则是前一个项的3倍加1。
- en: 'The problem you are to solve is to generate the Collatz sequence for all positive
    integers up to one million, determine which of them is the longest, and print
    its length and the starting number that produced it. Although we could apply brute
    force to generate the sequence for each number and count the number of terms until
    reaching 1, a faster solution would be to save the length of all the sequences
    that have already been generated. When the current term of a sequence that started
    from a value `n` becomes smaller than `n`, then it is a number whose sequence
    has already been determined, so we could simply fetch its cached length and add
    it to the current length to determine the length of the sequence started from `n`.
    This approach, however, introduces a limit to the Collatz sequences that could
    be computed, because at some point the cache will exceed the amount of memory
    the system can allocate:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你要解决的问题是生成所有小于一百万的正整数的Collatz序列，确定其中最长的序列，并打印其长度和产生它的起始数字。虽然我们可以应用蛮力法为每个数字生成序列并计算达到1之前的项数，但更快的解决方案是保存已经生成的所有序列的长度。当从值`n`开始的序列的当前项变小于`n`时，那么它是一个其序列已经被确定的数字，因此我们可以简单地获取其缓存长度并将其添加到当前长度以确定从`n`开始的序列的长度。然而，这种方法引入了对Collatz序列的计算的限制，因为在某个时候，缓存将超过系统可以分配的内存量：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 13\. Computing the value of Pi
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13. 计算Pi的值
- en: A suitable solution for approximately determining the value of Pi is using a
    Monte Carlo simulation. This is a method that uses random samples of inputs to
    explore the behavior of complex processes or systems. The method is used in a
    large variety of applications and domains, including physics, engineering, computing,
    finance, business, and others.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 用蒙特卡洛模拟大致确定Pi的值是一个合适的解决方案。这是一种使用输入的随机样本来探索复杂过程或系统行为的方法。该方法在许多应用和领域中使用，包括物理学、工程学、计算机、金融、商业等。
- en: 'To do this we will rely on the following idea: the area of a circle with diameter `d` is `PI
    * d^2 / 4`. The area of a square that has the length of its sides equal to `d` is `d^2`.
    If we divide the two we get `PI/4`. If we put the circle inside the square and
    generate random numbers uniformly distributed within the square, then the count
    of numbers in the circle should be directly proportional to the circle area, and
    the count of numbers inside the square should be directly proportional to the
    square’s area. That means that dividing the total number of hits in the square
    and circle should give `PI/4`. The more points generated, the more accurate the
    result shall be.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将依赖以下想法：直径为`d`的圆的面积是`PI * d^2 / 4`。边长等于`d`的正方形的面积是`d^2`。如果我们将两者相除，我们得到`PI/4`。如果我们将圆放在正方形内并在正方形内生成均匀分布的随机数，那么圆内的数字计数应该与圆的面积成正比，正方形内的数字计数应该与正方形的面积成正比。这意味着将正方形和圆中的总命中数相除应该得到`PI/4`。生成的点越多，结果就越准确。
- en: 'For generating pseudo-random numbers we will use a Mersenne twister and a uniform
    statistical distribution:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成伪随机数，我们将使用Mersenne twister和均匀统计分布：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 14\. Validating ISBNs
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14. 验证ISBN
- en: The **International Standard Book Number** (**ISBN**) is a unique numeric identifier
    for books. Currently, a 13-digit format is used. However, for this problem, you
    are to validate the former format that used 10 digits. The last of the 10 digits
    is a checksum. This digit is chosen so that the sum of all the ten digits, each
    multiplied by its (integer) weight, descending from 10 to 1, is a multiple of
    11.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**国际标准书号**（**ISBN**）是书籍的唯一数字标识符。目前使用的是13位格式。然而，对于这个问题，你需要验证使用10位数字的旧格式。10位数字中的最后一位是一个校验和。选择这一位数字是为了使所有十个数字的和，每个数字乘以它的（整数）权重，从10到1递减，是11的倍数。'
- en: 'The `validate_isbn_10` function, shown as follows, takes an ISBN as a string,
    and returns `true` if the length of the string is 10, all ten elements are digits,
    and the sum of all digits multiplied by their weight (or position) is a multiple
    of 11:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`validate_isbn_10`函数如下所示，接受一个ISBN作为字符串，并在字符串长度为10、所有十个元素都是数字，并且所有数字乘以它们的权重（或位置）的和是11的倍数时返回`true`：'
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can take it as a further exercise to improve this function to also correctly
    validate ISBN-10 numbers that include hyphens, such as `3-16-148410-0`. Also,
    you can write a function that validates ISBN-13 numbers.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把这看作是进一步练习，以改进这个函数，使其能够正确验证包括连字符的ISBN-10号码，比如`3-16-148410-0`。另外，你也可以编写一个验证ISBN-13号码的函数。
