- en: 16\. Multiplayer Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16\. 多人游戏基础知识
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will be introduced to some important multiplayer concepts
    in order to add multiplayer support to your game using Unreal Engine 4's network
    framework.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解一些重要的多人游戏概念，以便使用虚幻引擎4的网络框架为您的游戏添加多人游戏支持。
- en: By the end of this chapter, you'll know basic multiplayer concepts such as the
    server-client architecture, connections, and actor ownership, along with roles
    and variable replication. You'll be able to implement these concepts to create
    a multiplayer game of your own. You'll also be able to make a 2D Blend Space,
    which allows you to blend between animations laid out in a 2D grid. Finally, you'll
    learn how to use `Transform (Modify) Bone` nodes to control Skeletal Mesh bones
    at runtime.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将了解基本的多人游戏概念，如服务器-客户端架构、连接和角色所有权，以及角色和变量复制。您将能够实现这些概念，创建自己的多人游戏。您还将能够制作2D混合空间，这允许您在2D网格中的动画之间进行混合。最后，您将学习如何使用`Transform
    (Modify) Bone`节点在运行时控制骨骼网格骨骼。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we completed the `SuperSideScroller` game and used
    1D Blend Spaces, animation blueprints, and animation montages. In this chapter,
    we're going to build on that knowledge and learn how to add multiplayer functionality
    to a game using Unreal Engine.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们完成了`SuperSideScroller`游戏，并使用了1D混合空间、动画蓝图和动画蒙太奇。在本章中，我们将在此基础上构建，并学习如何使用虚幻引擎为游戏添加多人游戏功能。
- en: 'Multiplayer games have grown quite a lot in the last decade. Games such as
    Fortnite, PUBG, League of Legends, Rocket League, Overwatch, and CS: GO have gained
    a lot of popularity in the gaming community and have had great success. Nowadays,
    almost all games need to have some kind of multiplayer experience in order to
    be more relevant and successful.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 多人游戏在过去十年里发展迅速。像Fortnite、PUBG、英雄联盟、火箭联盟、守望先锋和CS:GO等游戏在游戏社区中获得了很大的流行，并取得了巨大的成功。如今，几乎所有的游戏都需要具有某种多人游戏体验，以使其更具相关性和成功。
- en: The reason for that is it adds a new layer of possibilities on top of the existing
    gameplay, such as being able to play with friends in cooperative mode (*also known
    as co-op mode*) or against people from all around the world, which greatly increases
    the longevity and value of a game.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的原因是它在现有的游戏玩法之上增加了新的可能性，比如能够在合作模式（*也称为合作模式*）中与朋友一起玩，或者与来自世界各地的人对战，这大大增加了游戏的长期性和价值。
- en: In the next topic, we will be discussing the basics of multiplayer.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个主题中，我们将讨论多人游戏的基础知识。
- en: Multiplayer Basics
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多人游戏基础知识
- en: You may have heard the term multiplayer a lot while gaming, but what does it
    mean for game developers? Multiplayer, in reality, is just a set of instructions
    sent through the network (*internet or local area network*) between the server
    and its connected clients in order to give players the illusion of a shared world.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，你可能经常听到多人游戏这个术语，但对于游戏开发者来说，它意味着什么呢？实际上，多人游戏只是通过网络（*互联网或局域网*）在服务器和其连接的客户端之间发送的一组指令，以给玩家产生共享世界的错觉。
- en: For this to work, the server needs to be able to talk to clients, but also the
    other way around (client to server). This is because clients are typically the
    ones that affect the game world, so they need a way to be able to inform the server
    of their intentions while playing the game.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其工作，服务器需要能够与客户端进行通信，但客户端也需要与服务器进行通信（客户端到服务器）。这是因为客户端通常是影响游戏世界的一方，因此他们需要一种方式来告知服务器他们在玩游戏时的意图。
- en: 'An example of this back and forth communication between the server and a client
    is when a player tries to fire a weapon during a game. Have a look at the following
    figure, which shows a client-server interaction:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这种服务器和客户端之间的来回通信的一个例子是当玩家在游戏中尝试开火时。看一下下面的图，它展示了客户端和服务器的交互：
- en: '![Figure 16.1: Client-server interaction when a player wants to fire'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.1：玩家想要开火时的客户端-服务器交互'
- en: a weapon in a multiplayer game](img/B16183_16_01.jpg)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 多人游戏中的武器](img/B16183_16_01.jpg)
- en: 'Figure 16.1: Client-server interaction when a player wants to fire a weapon
    in a multiplayer game'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1：多人游戏中玩家想要开火时的客户端-服务器交互
- en: 'Let''s examine what was shown in *Figure 16.1*:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看*图16.1*中显示的内容：
- en: The player holds the *left mouse button* down and the client of that player
    tells the server that it wants to fire a weapon.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家按住*鼠标左键*，并且该玩家的客户端告诉服务器它想要开火。
- en: 'The server validates whether the player can fire the weapon by checking the following:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器通过检查以下内容来验证玩家是否可以开火：
- en: If the player is alive
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家还活着
- en: If the player has a weapon equipped
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家装备了武器
- en: If the player has enough ammo
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家有足够的弹药
- en: 'If all of the validations are valid, then the server will do the following:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果所有验证都有效，则服务器将执行以下操作：
- en: Run the logic to deduct ammo
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行逻辑以扣除弹药
- en: Spawn the projectile actor on the server, which is automatically sent to all
    of the clients
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器上生成抛射物角色，自动发送到所有客户端
- en: Play the fire animation on the character instance in all of the clients to ensure
    certain synchronicity between all of them, which helps to sell the idea that it's
    the same world, even though it's not
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有客户端的角色实例上播放开火动画，以确保它们之间的某种同步性，这有助于传达它们是同一个世界的想法，尽管实际上并非如此
- en: 'If any of the validations fail, then the server tells the specific client what
    to do:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果任何验证失败，服务器会告诉特定的客户端该做什么：
- en: Player is dead – don't do anything
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家已经死亡-不做任何事情
- en: Player doesn't have a weapon equipped – don't do anything
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家没有装备武器-不做任何事情
- en: Player doesn't have enough ammo – play an empty click sound
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家没有足够的弹药-播放空击声音
- en: Remember, if you want your game to support multiplayer, then it's highly recommended
    that you do that as soon as possible in your development cycle. If you try to
    run a single-player project with multiplayer enabled, you'll notice that some
    functionalities might *just work*, but probably most of them won't be working
    properly or as expected.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果您希望游戏支持多人游戏，则强烈建议您在开发周期的尽早阶段就这样做。如果您尝试运行启用了多人游戏的单人项目，您会注意到一些功能可能*正常工作*，但可能大多数功能都无法正常工作或达到预期效果。
- en: The reason for that is when you execute the game in single-player, the code
    runs locally and instantly, but when you add multiplayer into the equation, you
    are adding external factors such as an authoritative server that talks to clients
    on a network with latency, as you saw in *Figure 16.1*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为当您在单人游戏中执行游戏时，代码在本地立即运行，但是当您将多人游戏加入到方程式中时，您正在添加外部因素，例如与具有延迟的网络上的客户端进行通信的权威服务器，就像您在*图16.1*中看到的那样。
- en: 'In order to get everything working properly, you need to break apart the existing
    code into the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使一切正常运行，您需要将现有代码分解为以下部分：
- en: Code that only runs on the server
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅在服务器上运行的代码
- en: Code that only runs on the client
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅在客户端上运行的代码
- en: Code that runs on both, which can take a lot of time depending on the complexity
    of your single-player game
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两者上运行的代码，这可能需要很长时间，具体取决于您的单人游戏的复杂性
- en: In order to add multiplayer support to games, Unreal Engine 4 comes with a very
    powerful and bandwidth-efficient network framework already built in, using an
    authoritative server-client architecture.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为游戏添加多人游戏支持，虚幻引擎4已经内置了一个非常强大和带宽高效的网络框架，使用权威服务器-客户端架构。
- en: 'Here is a diagram of how it works:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是其工作原理的图表：
- en: '![Figure 16.2: Server-client architecture in Unreal Engine 4'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.2：虚幻引擎4中的服务器-客户端架构'
- en: '](img/B16183_16_02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_16_02.jpg)'
- en: 'Figure 16.2: Server-client architecture in Unreal Engine 4'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2：虚幻引擎4中的服务器-客户端架构
- en: In *Figure 16.2*, you can see how the server-client architecture works in Unreal
    Engine 4\. Each player controls a client that communicates with the server using
    a **two-way connection**. The server runs a specific level with a game mode (*which
    only exists in the server*) and controls the flow of information so that the clients
    can see and interact with each other in the game world.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图16.2*中，您可以看到服务器-客户端架构在虚幻引擎4中是如何工作的。每个玩家控制一个客户端，使用**双向连接**与服务器通信。服务器在特定级别上运行游戏模式（*仅存在于服务器中*）并控制信息流，以便客户端可以在游戏世界中看到并相互交互。
- en: Note
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Multiplayer can be a very advanced topic, so these next few chapters will serve
    as an introduction to help you understand the essentials, but it will not be an
    in-depth look. For that reason, some concepts might be omitted for simplicity's
    sake.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 多人游戏可能是一个非常复杂的话题，因此接下来的几章将作为介绍，帮助您了解基本知识，但不会深入研究。因此，出于简单起见，一些概念可能被省略。
- en: In the next section, we will be looking at servers.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看服务器。
- en: Servers
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器
- en: The server is the most critical part of the architecture since it's responsible
    for handling most of the work and making important decisions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器是架构中最关键的部分，因为它负责处理大部分工作并做出重要决策。
- en: 'Here is an overview of the main responsibilities of a server:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是服务器的主要责任概述：
- en: '**Creating and managing the shared world instance**: The server runs its own
    instance of the game in a specific level and game mode (*this will be covered
    in the chapters ahead*) and that will serve as the shared world between all of
    the connected clients. The level being used can be changed at any point in time
    and, if applicable, the server can bring along all of the connected clients with
    it automatically.'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建和管理共享世界实例**：服务器在特定级别和游戏模式中运行其自己的游戏实例（*这将在接下来的章节中介绍*），这将成为所有连接的客户端之间的共享世界。使用的级别可以随时更改，并且如果适用，服务器可以自动带上所有连接的客户端。'
- en: '`PostLogin` function in the game mode is called. From that point on, the client
    will enter the game and is part of the shared world where the player will be able
    to see and interact with other clients. If a client disconnects at any point in
    time, then all of the other clients will be notified and the `Logout` function
    in the game mode will be called.'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 游戏模式中的`PostLogin`函数被调用。从那时起，客户端将进入游戏，并成为共享世界的一部分，玩家将能够看到并与其他客户端进行交互。如果客户端在任何时候断开连接，那么所有其他客户端都将收到通知，并且游戏模式中的`Logout`函数将被调用。
- en: '**Spawning the actors that all of the clients need to know about**: If you
    want to spawn an actor that exists in all of the clients, then you need to do
    that on the server. The reason for this is the server has the authority and is
    the only one that can tell each client to create its own instance of that actor.'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**生成所有客户端需要了解的角色**：如果要生成所有客户端中存在的角色，则需要在服务器上执行此操作。原因是服务器具有权限，并且是唯一可以告诉每个客户端创建其自己的该角色实例的人。'
- en: This is the most common way of spawning actors in multiplayer, since most actors
    need to exist in all of the clients. An example of this would be with a power-up,
    which is something that all clients can see and interact with.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在多人游戏中生成角色的最常见方式，因为大多数角色需要存在于所有客户端中。一个例子是能量增强，所有客户端都可以看到并与之交互。
- en: '**Running critical gameplay logic**: In order to make sure that the game is
    fair to all of the clients, the critical gameplay logic needs to be executed only
    on the server. If clients were responsible for handling the deduction of health,
    it would be very exploitable, because a player could use a tool to change in memory
    the current value of health to 100% all the time, so the player would never die
    in the game.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运行关键的游戏逻辑**：为了确保游戏对所有客户端都是公平的，关键的游戏逻辑需要仅在服务器上执行。如果客户端负责处理健康扣除，那将是非常容易被利用的，因为玩家可以使用工具在内存中更改健康当前值为100%，所以玩家在游戏中永远不会死亡。'
- en: '**Handling variable replication**: If you have a replicated variable (*covered
    in this chapter*), then its value should only be changed on the server. This will
    ensure that all of the clients will have the value updated automatically. You
    can still change the value on the client, but it will always be replaced with
    the latest value from the server, in order to prevent cheating and to make sure
    all of the clients are in sync.'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理变量复制**：如果您有一个复制的变量（*在本章中介绍*），那么它的值应该只在服务器上更改。这将确保所有客户端的值会自动更新。您仍然可以在客户端上更改值，但它将始终被服务器的最新值替换，以防止作弊并确保所有客户端同步。'
- en: '**Handling RPCs from the client**: The server needs to process the remote procedure
    calls (*Chapter 17*, *Remote Procedure Calls*) sent from the clients.'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理来自客户端的RPC**：服务器需要处理来自客户端发送的远程过程调用（*第17章*，*远程过程调用*）。'
- en: Now that you know what a server does, we can talk about the two different ways
    of creating a server in Unreal Engine 4.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道服务器的功能，我们可以讨论在虚幻引擎4中创建服务器的两种不同方式。
- en: Dedicated Server
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 专用服务器
- en: The dedicated server only runs the server logic, so you won't see the typical
    window with the game running where you control a character as a local player.
    Additionally, if you run the dedicated server with the `-log` command prompt,
    you'll have a console window that logs relevant information about what is happening
    on the server, such as if a client has connected or disconnected, and so on. You,
    as a developer, can also log your own information by using the `UE_LOG` macro.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 专用服务器仅运行服务器逻辑，因此您不会看到典型的游戏运行窗口，您可以在其中控制本地玩家角色。此外，如果使用`-log`命令提示符运行专用服务器，您将看到一个控制台窗口，记录有关服务器上发生的事件的相关信息，例如客户端是否已连接或断开连接等。作为开发人员，您还可以使用`UE_LOG`宏记录自己的信息。
- en: Using dedicated servers is a very common way of creating servers for multiplayer
    games, and since it's more lightweight than a listen server (*covered in the next
    section*), you could just host it on a server stack and leave it running.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用专用服务器是创建多人游戏服务器的一种非常常见的方式，因为它比监听服务器更轻量级，您可以将其托管在服务器堆栈上并让其保持运行。
- en: 'To start a dedicated server in Unreal Engine 4, you can use the following command arguments:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要在虚幻引擎4中启动专用服务器，可以使用以下命令参数：
- en: 'Run the following command to start a dedicated server inside an editor through
    a shortcut or Command Prompt:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过快捷方式或命令提示符在编辑器中启动专用服务器，请运行以下命令：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here''s an example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A packaged project requires a special build of the project built specifically
    to serve as a dedicated server.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包项目需要专门构建的项目的特殊构建，用作专用服务器。
- en: Note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find out more about setting up a packaged dedicated server by visiting
    [https://allarsblog.com/2015/11/06/support-dedicated-servers/](https://allarsblog.com/2015/11/06/support-dedicated-servers/)
    and [https://www.ue4community.wiki/Dedicated_Server_Guide_(Windows)](https://www.ue4community.wiki/Dedicated_Server_Guide_(Windows)).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问[https://allarsblog.com/2015/11/06/support-dedicated-servers/](https://allarsblog.com/2015/11/06/support-dedicated-servers/)和[https://www.ue4community.wiki/Dedicated_Server_Guide_(Windows)](https://www.ue4community.wiki/Dedicated_Server_Guide_(Windows))了解有关设置打包专用服务器的更多信息。
- en: The Listen Server
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监听服务器
- en: The listen server acts as a server and client at the same time, so you'll also
    have a window where you can play the game as a client with this server type. It
    also has the advantage of being the quickest way of getting a server running,
    but it's not as lightweight as a dedicated server, so the number of clients that
    can be connected at the same time will be limited.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 监听服务器同时充当服务器和客户端，因此您还将拥有一个窗口，可以以此服务器类型的客户端玩游戏。它还具有是最快启动服务器的优势，但它不像专用服务器那样轻量级，因此可以连接的客户端数量将受到限制。
- en: 'To start a listen server, you can use the following command arguments:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动监听服务器，可以使用以下命令参数：
- en: 'Run the following command to start a dedicated server inside an editor through
    a shortcut or Command Prompt:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过快捷方式或命令提示符在编辑器中启动专用服务器，请运行以下命令：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here''s an example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A packaged project (development builds only) requires a special build of the
    project built specifically to serve as a dedicated server:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包项目（仅限开发构建）需要专门构建的项目的特殊构建，用作专用服务器：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here''s an example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the next section, we will discuss clients.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论客户端。
- en: Clients
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端
- en: The client is the simplest part of the architecture because most of the actors
    will have the authority on the server, so in those cases, the work will be done
    on the server and the client will just obey its orders.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端是架构中最简单的部分，因为大多数参与者将在服务器上拥有权限，所以在这些情况下，工作将在服务器上完成，客户端只需服从其命令。
- en: 'Here is an overview of the main responsibilities of a client:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是客户端的主要职责概述：
- en: '**Enforcing variable replication from the server**: The server typically has
    authority over all of the actors that the client knows, so when the value of a
    replicated variable is changed on the server, the client needs to enforce that
    value as well.'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从服务器强制执行变量复制**：服务器通常对客户端知道的所有参与者具有权限，因此当复制变量的值在服务器上更改时，客户端需要强制执行该值。'
- en: '**Handling RPCs from the server**: The client needs to process the remote procedure
    calls (covered in *Chapter 17*, *Remote Procedure Calls*) sent from the server.'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理来自服务器的RPC**：客户端需要处理来自服务器发送的远程过程调用（在*第17章*，*远程过程调用*中介绍）。'
- en: '**Predicting movement when simulating**: When a client is simulating an actor
    (*covered later in this chapter*) it needs to locally predict where it''s going
    to be based on the actor''s velocity.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模拟时预测移动**：当客户端模拟参与者（*本章后面介绍*）时，它需要根据参与者的速度本地预测其位置。'
- en: '**Spawning the actors that only a client needs to know about**: If you want
    to spawn an actor that only exists on a client, then you need to do that on that
    specific client.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**生成只有客户端需要知道的参与者**：如果要生成只存在于客户端的参与者，则需要在特定客户端上执行该操作。'
- en: This is the least common way of spawning actors since there are few instances
    when you want an actor to only exist on a client. An example of this is the placement
    preview actor you see in multiplayer survival games, where the player controls
    a semi-transparent version of a wall that other players can't see until it's actually
    placed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是生成角色的最不常见的方法，因为很少有情况下您希望一个角色只存在于一个客户端。一个例子是多人生存游戏中的放置预览角色，玩家控制一个半透明版本的墙，其他玩家直到实际放置之前都看不到。
- en: 'A client can join a server in different ways. Here is a list of the most common methods:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以以不同的方式加入服务器。以下是最常见的方法列表：
- en: 'Using the Unreal Engine 4 console (by default is the *`* key) to open it and
    type:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用虚幻引擎4控制台（默认为*`*键）打开它并输入：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For instance:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Using the `Execute Console Command` Blueprint node. An example is as follows:![Figure
    16.3: Joining a server with an example IP with the Execute Console Command node'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Execute Console Command`蓝图节点。一个例子如下：![图16.3：使用Execute Console Command节点加入具有示例IP的服务器
- en: '](img/B16183_16_03.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_16_03.jpg)'
- en: 'Figure 16.3: Joining a server with an example IP with the Execute Console Command
    node'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3：使用Execute Console Command节点加入具有示例IP的服务器
- en: 'Using the `ConsoleCommand` function in `APlayerController` as follows:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`APlayerController`中的`ConsoleCommand`函数如下：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here''s an example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Using the editor executable through a shortcut or Command Prompt:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过快捷方式或命令提示符使用编辑器可执行文件：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here''s an example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '`C:\Program Files\Epic Games\UE_4.24\Engine\Binaries\Win64\UE4Editor.exe D:\TestProject\TestProject.uproject
    194.56.23.4 -game`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`C:\Program Files\Epic Games\UE_4.24\Engine\Binaries\Win64\UE4Editor.exe D:\TestProject\TestProject.uproject
    194.56.23.4 -game`'
- en: 'Using a packaged development build through a shortcut or Command Prompt:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过快捷方式或命令提示符使用打包的开发版本：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here''s an example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '`D:\Packaged\TestProject\TestProject.exe 194.56.23.4`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`D:\Packaged\TestProject\TestProject.exe 194.56.23.4`'
- en: In the following exercise, we will test the Third Person template that comes
    with Unreal Engine 4 in multiplayer.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将在多人游戏中测试虚幻引擎4附带的第三人称模板。
- en: 'Exercise 16.01: Testing the Third Person Template in Multiplayer'
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习16.01：在多人游戏中测试第三人称模板
- en: In this exercise, we're going to create a Third Person template project and
    play it in multiplayer.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个第三人称模板项目，并在多人游戏中进行游玩。
- en: The following steps will help you complete the exercise.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成练习。
- en: Create a new `Third Person` template project using `Blueprints` called `TestMultiplayer`
    and save it to a location of your choosing.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用蓝图创建一个名为`TestMultiplayer`的新`Third Person`模板项目，并将其保存到您选择的位置。
- en: 'Once the project has been created, it should open the editor. We''ll now test
    the project in multiplayer to see how it behaves:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 项目创建后，应该打开编辑器。现在我们将在多人游戏中测试项目的行为：
- en: In the editor, to the right of the `Play` button, you have an option with an
    arrow pointing down. Click on it and you should see a list of options. Under the
    `Multiplayer Options` section, you can configure how many clients you want to
    use and whether or not you want a dedicated server.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，`播放`按钮右侧有一个带有向下箭头的选项。单击它，您应该看到一个选项列表。在`多人游戏选项`部分下，您可以配置要使用多少个客户端以及是否需要专用服务器。
- en: Leave `Run Dedicated Server` unchecked, change `Number of Players` to `3`, and
    click on `New Editor Window (PIE)`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消`运行专用服务器`的选中，将`玩家数量`更改为`3`，然后单击`新编辑器窗口（PIE）`。
- en: 'You should see three windows on top of each other representing the three clients:![Figure
    16.4: Launching three client windows with a listen server'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到三个窗口相互堆叠，代表三个客户端：![图16.4：启动三个带有监听服务器的客户端窗口
- en: '](img/B16183_16_04.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_16_04.jpg)'
- en: 'Figure 16.4: Launching three client windows with a listen server'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.4：启动三个带有监听服务器的客户端窗口
- en: As you can see, this is a bit cluttered, so let's change the size of the windows.
    Press *Esc* on your keyboard to stop playing.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这有点凌乱，所以让我们改变窗口的大小。在键盘上按*Esc*停止播放。
- en: Click once again on the downward-pointing arrow next to the `Play` button and
    pick the last option, `Advanced Settings`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次单击`播放`按钮旁边的向下箭头，并选择最后一个选项`高级设置`。
- en: Search for the `Game Viewport Settings` section. Change `New Viewport Resolution`
    to `640x480` and close the `Editor Preferences` tab.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索`游戏视口设置`部分。将`新视口分辨率`更改为`640x480`，然后关闭`编辑器首选项`选项卡。
- en: 'Play the game again and you should see the following:![Figure 16.5: Launching
    three client windows using a 640x480 resolution with a listen server'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次播放游戏，您应该看到以下内容：![图16.5：使用640x480分辨率启动三个客户端窗口与监听服务器
- en: '](img/B16183_16_05.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_16_05.jpg)'
- en: 'Figure 16.5: Launching three client windows using a 640x480 resolution with
    a listen server'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.5：使用640x480分辨率启动三个客户端窗口与监听服务器
- en: Once you start playing, you'll notice that the title bars of the windows say
    `Server`, `Client 1`, and `Client 2`. Since you can control a character in the
    `Server` window, that means we're running a `Server + Client 0` instead of just
    `Server` to avoid confusion.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开始游戏，您会注意到窗口的标题栏显示`服务器`，`客户端1`和`客户端2`。由于您可以在`服务器`窗口中控制一个角色，这意味着我们正在运行`服务器+客户端0`而不仅仅是`服务器`，以避免混淆。
- en: By completing this exercise, you now have a setup where you'll have one server
    and three clients running (`Client 0`, `Client 1`, and `Client 2`).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，您现在有了一个设置，其中您将有一个服务器和三个客户端运行（`客户端0`，`客户端1`和`客户端2`）。
- en: Note
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When you have multiple windows running at the same time, you'll notice that
    you can only have input focus on one window at a time. To shift the focus to another
    window, just press *Shift* + *F1* to lose the current input focus and then just
    click on the new window you want to focus on.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当您同时运行多个窗口时，您会注意到一次只能在一个窗口上进行输入焦点。要将焦点转移到另一个窗口，只需按下*Shift* + *F1*以失去当前的输入焦点，然后单击要关注的新窗口。
- en: If you play the game in one of the windows, you'll notice that you can move
    around and jump and the other clients will also be able to view that.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在其中一个窗口中玩游戏，您会注意到您可以四处移动和跳跃，其他客户端也能看到。
- en: The reason why everything works is that the character movement component, which
    comes with the character class, replicates the location, rotation, and falling
    state (used to show whether you are jumping or not) for you automatically. If
    you want to add a custom behavior such as an attack animation, you can't just
    tell the client to play an animation locally when a key is pressed, because that
    will not work on the other clients. That's why you need the server, to serve as
    an intermediary and tell all the clients to play the animation when one client
    presses the key.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一切正常运行的原因是角色移动组件自动复制位置、旋转和下落状态（用于显示您是否在跳跃）给您。如果要添加自定义行为，如攻击动画，您不能只是告诉客户端在按键时本地播放动画，因为这在其他客户端上不起作用。这就是为什么需要服务器，作为中介，告诉所有客户端在一个客户端按下按键时播放动画。
- en: The Packaged Version
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包版本
- en: Once you've finished the project, it's good practice to package it (*as covered
    in the previous chapters*) so that we have a pure standalone version that doesn't
    use Unreal Engine editor, which will run faster and is more lightweight.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 项目完成后，最好将其打包（*如前几章所述*），这样我们就会得到一个纯粹的独立版本，不需要使用虚幻引擎编辑器，运行速度更快，更轻量。
- en: 'The following steps will help you create the packaged version of *Exercise
    16.01*, *Testing the Third Person Template in Multiplayer file*:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您创建*Exercise 16.01*，*在多人游戏文件中测试第三人称模板*的打包版本：
- en: Go to `File` -> `Package Project` -> `Windows` -> `Windows (64-bit)`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`文件` -> `打包项目` -> `Windows` -> `Windows（64位）`。
- en: Pick a folder to place the packaged build and wait for it to finish.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个文件夹放置打包版本，并等待完成。
- en: Go to the selected folder and open the `WindowsNoEditor` folder inside it.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到所选文件夹，并打开其中的`WindowsNoEditor`文件夹。
- en: '*Right-click* on `TestMultiplayer.exe` and pick `Create Shortcut`.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击*`TestMultiplayer.exe`，选择“创建快捷方式”。'
- en: Rename the new shortcut `Run Server`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的快捷方式重命名为`运行服务器`。
- en: '*Right-click* on it and pick `Properties`.'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击*它，选择“属性”。'
- en: 'On the Target, append `ThirdPersonExampleMap?Listen -server`, which creates
    a listen server using `ThirdPersonExampleMap`. You should end up with this:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目标上附加`ThirdPersonExampleMap?Listen -server`，这将使用`ThirdPersonExampleMap`创建一个监听服务器。您应该得到这个：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Click `OK` and run the shortcut.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”并运行快捷方式。
- en: You should get a Windows Firewall prompt, so allow it.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该会收到Windows防火墙提示，所以允许它。
- en: Leave the server running and go back to the folder and create another shortcut
    from `TestMultiplayer.exe`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持服务器运行，并返回文件夹，从`TestMultiplayer.exe`创建另一个快捷方式。
- en: Rename it `Run Client`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其重命名为`运行客户端`。
- en: '*Right-click* on it and pick `Properties`.'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击*它，选择“属性”。'
- en: On the Target, append `127.0.0.1`, which is the IP of your local server. You
    should end up with `"<Path>\WindowsNoEditor\TestMultiplayer.exe" 127.0.0.1`.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目标上附加`127.0.0.1`，这是您本地服务器的IP。您应该得到`"<Path>\WindowsNoEditor\TestMultiplayer.exe"
    127.0.0.1`。
- en: Click `OK` and run the shortcut.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”并运行快捷方式。
- en: You are now connected to the listen server, so you can see each other's characters.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经连接到监听服务器，所以你可以看到彼此的角色。
- en: Every time you click on the `Run Client` shortcut, you'll add a new client to
    the server, so you can have a few clients running on the same machine.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次单击“运行客户端”快捷方式，您都会向服务器添加一个新的客户端，因此您可以在同一台机器上运行几个客户端。
- en: In the next section, we will be looking at connections and ownership.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将看看连接和所有权。
- en: Connections and Ownership
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接和所有权
- en: When using multiplayer in Unreal Engine, an important concept to understand
    is that of a connection. When a client joins a server, it will get a new **Player
    Controller** with a connection associated with it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用虚幻引擎进行多人游戏时，一个重要的概念是连接。当客户端加入服务器时，它将获得一个新的**玩家控制器**，并与之关联一个连接。
- en: If an actor doesn't have a valid connection with the server, then the actor
    won't be able to do replication operations such as variable replication (*covered
    later in this chapter*) or call RPCs (covered in *Chapter 17,* *Remote Procedure
    Calls*).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个角色与服务器没有有效的连接，那么该角色将无法进行复制操作，如变量复制（*本章后面介绍*）或调用RPC（在*第17章*，*远程过程调用*中介绍）。
- en: If the Player Controller is the only actor that holds a connection, then does
    that mean that it's the only place you can do replication operations? No, and
    that's where the `GetNetConnection` function, defined in `AActor`, comes into
    play.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家控制器是唯一持有连接的角色，那么这是否意味着它是唯一可以进行复制操作的地方？不是，这就是`GetNetConnection`函数发挥作用的地方，该函数在`AActor`中定义。
- en: When doing replication operations (such as variable replication or call RPCs)
    on an actor, the Unreal framework will get the actor's connection by calling the
    `GetNetConnection()` function on it. If the connection is valid, then the replication
    operation will be processed, if it's not, nothing will happen. The most common
    implementations of `GetNetConnection()` are from `APawn` and `AActor`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在对角色进行复制操作（如变量复制或调用RPC）时，虚幻框架将通过调用`GetNetConnection()`函数来获取角色的连接。如果连接有效，则复制操作将被处理，如果无效，则不会发生任何事情。`GetNetConnection()`的最常见实现来自`APawn`和`AActor`。
- en: 'Let''s take a look at how the `APawn` class implements the `GetNetConnection()`
    function, which is typically used for characters:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`APawn`类如何实现`GetNetConnection()`函数，这通常用于角色：
- en: '[PRE13]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding implementation, which is part of the Unreal Engine 4 source code,
    will first check whether the pawn has a valid controller. If the controller is
    valid, then it will use its connection. If the controller is not valid, then it
    will use the parent implementation of the `GetNetConnection()` function, which
    is on `AActor`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的实现是虚幻引擎4源代码的一部分，它首先检查pawn是否有有效的控制器。如果控制器有效，则使用其连接。如果控制器无效，则使用`GetNetConnection()`函数的父实现，即`AActor`上的实现：
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding implementation, which is also part of the Unreal Engine 4 source
    code, will check whether the actor has a valid owner. If it does, it will use
    the owner's connection; if it doesn't, it will return an invalid connection. So
    what is this `Owner` variable? Every actor has a variable called `Owner` (where
    you can set its value by calling the `SetOwner` function) that shows which actor
    *owns* it, so you can think of it as the parent actor.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的实现也是虚幻引擎4源代码的一部分，它将检查角色是否有有效的所有者。如果有，它将使用所有者的连接；如果没有，它将返回一个无效的连接。那么这个`Owner`变量是什么？每个角色都有一个名为`Owner`的变量（可以通过调用`SetOwner`函数来设置其值），显示哪个角色*拥有*它，因此你可以将其视为父角色。
- en: Using the owner's connection in this implementation of `GetNetConnection()`
    will work like a hierarchy. If, while going up the hierarchy of owners, it finds
    an owner that is a Player Controller or is being controlled by one, then it will
    have a valid connection and will be able to process replication operations. Have
    a look at the following example.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`GetNetConnection()`的实现中使用所有者的连接将像一个层次结构一样工作。如果在所有者的层次结构中找到一个是玩家控制器或者被玩家控制器控制的所有者，那么它将有一个有效的连接，并且能够处理复制操作。看下面的例子。
- en: Note
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In a listen server, the connection for the character controlled by its client
    will always be invalid, because that client is already a part of the server and
    therefore doesn't need a connection.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在监听服务器中，由其客户端控制的角色的连接将始终无效，因为该客户端已经是服务器的一部分，因此不需要连接。
- en: Imagine a weapon actor was placed in the world and it's just sitting there.
    In that situation, the weapon won't have an owner, so if the weapon tries to do
    any replication operations, such as variable replication or calling RPCs, nothing
    will happen.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个武器角色被放置在世界中，它就在那里。在这种情况下，武器将没有所有者，因此如果武器尝试执行任何复制操作，如变量复制或调用RPC，将不会发生任何事情。
- en: However, if a client picks up the weapon and calls `SetOwner` on the server
    with the value of the character, then the weapon will now have a valid connection.
    The reason for this is because the weapon is an actor, so in order to get its
    connection, it will use the `AActor` implementation of `GetNetConnection()`, which
    returns the connection of its owner. Since the owner is the client's character,
    it will use the implementation of `GetNetConnection()` of `APawn`. The character
    has a valid Player Controller, so that is the connection returned by the function.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果客户端拾取武器并在服务器上调用`SetOwner`并将值设置为角色，那么武器现在将有一个有效的连接。原因是武器是一个角色，因此为了获取其连接，它将使用`AActor`的`GetNetConnection()`实现，该实现返回其所有者的连接。由于所有者是客户端的角色，它将使用`APawn`的`GetNetConnection()`的实现。角色有一个有效的玩家控制器，因此这是函数返回的连接。
- en: 'Here is a diagram to help you understand this logic:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个图表来帮助你理解这个逻辑：
- en: '![Figure 16.6: Connections and ownership example of a weapon actor'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.6：武器角色的连接和所有权示例'
- en: '](img/B16183_16_06.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_16_06.jpg)'
- en: 'Figure 16.6: Connections and ownership example of a weapon actor'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6：武器角色的连接和所有权示例
- en: 'Let''s understand the elements of an invalid owner:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解无效所有者的元素：
- en: '`AWeapon` doesn''t override the `GetNetConnection` function, so to get the
    weapon''s connection, it will call the first implementation found, which is `AActor::GetNetConnection`.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AWeapon`没有覆盖`GetNetConnection`函数，因此要获取武器的连接，它将调用找到的第一个实现，即`AActor::GetNetConnection`。'
- en: The implementation of `AActor::GetNetConnection` calls `GetNetConnection` on
    its owner. Since there is no owner, the connection is invalid.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AActor::GetNetConnection`的实现调用其所有者的`GetNetConnection`。由于没有所有者，连接是无效的。'
- en: 'A valid owner will consist of the following elements:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的所有者将包括以下元素：
- en: '`AWeapon` doesn''t override the `GetNetConnection` function, so to get its
    connection, it will call the first implementation found, which is `AActor::GetNetConnection`.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AWeapon`没有覆盖`GetNetConnection`函数，因此要获取其连接，它将调用找到的第一个实现，即`AActor::GetNetConnection`。'
- en: The implementation of `AActor::GetNetConnection` calls `GetNetConnection` on
    its owner. Since the owner is the character that picked up the weapon, it will
    call `GetNetConnection` on it.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AActor::GetNetConnection`的实现调用其所有者的`GetNetConnection`。由于所有者是拾取武器的角色，它将在其上调用`GetNetConnection`。'
- en: '`ACharacter` doesn''t override the `GetNetConnection` function, so to get its
    connection, it will call the first implementation found, which is `APawn::GetNetConnection`.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACharacter`没有覆盖`GetNetConnection`函数，因此要获取其连接，它将调用找到的第一个实现，即`APawn::GetNetConnection`。'
- en: The implementation of `APawn::GetNetConnection` uses the connection from the
    owning player controller. Since the owning player controller is valid, then it
    will use that connection for the weapon.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APawn::GetNetConnection`的实现使用拥有的玩家控制器的连接。由于拥有的玩家控制器是有效的，因此它将使用该连接来处理武器。'
- en: Note
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In order for `SetOwner` to work as intended, it needs to be executed on the
    authority which, in most cases, means the server. If you only execute `SetOwner`
    on the client, it still won't be able to execute replication operations.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`SetOwner`按预期工作，它需要在大多数情况下在服务器上执行，这意味着需要在权限上执行。如果你只在客户端执行`SetOwner`，它仍然无法执行复制操作。
- en: Roles
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色
- en: When you spawn an actor on the server, there will be a version of the actor
    created on the server and one on each client. Since there are different versions
    of the same actor on different instances of the game (`Server`, `Client 1`, `Client
    2`, and so on), it is important to know which version of the actor is which. This
    will allow us to know what logic can be executed in each of these instances.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在服务器上生成一个角色时，将在服务器上创建一个角色的版本，并在每个客户端上创建一个版本。由于在游戏的不同实例（`服务器`，`客户端1`，`客户端2`等）上有相同角色的不同版本，因此知道哪个版本的角色是哪个是很重要的。这将使我们知道可以在这些实例中执行什么逻辑。
- en: 'To help with this situation, every actor has the following two variables:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助解决这种情况，每个角色都有以下两个变量：
- en: '`GetLocalRole()` function.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetLocalRole()`函数。'
- en: '`GetRemoteRole()` function.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetRemoteRole()`函数。'
- en: 'The return type of the `GetLocalRole()` and `GetRemoteRole()` functions is
    `ENetRole`, which is an enumeration that can have the following possible values:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetLocalRole()`和`GetRemoteRole()`函数的返回类型是`ENetRole`，它是一个枚举，可以具有以下可能的值：'
- en: '`ROLE_None`: The actor doesn''t have a role because it''s not being replicated.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ROLE_None`：该角色没有角色，因为它没有被复制。'
- en: '`ROLE_SimulatedProxy`: The current game instance doesn''t have authority over
    the actor and it''s not controlling it through a Player Controller. That means
    that its movement will be simulated/predicted by using the last value of the actor''s
    velocity.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ROLE_SimulatedProxy`：当前游戏实例对该角色没有权限，并且也没有通过玩家控制器来控制它。这意味着它的移动将通过使用角色速度的最后一个值来进行模拟/预测。'
- en: '`ROLE_AutonomousProxy`: The current game instance doesn''t have authority over
    the actor, but it''s being controlled by a Player Controller. That means that
    we can send to the server more accurate movement information, based on the player''s
    inputs, instead of just using the last value of the actor''s velocity.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ROLE_AutonomousProxy`：当前游戏实例对该角色没有权限，但它由玩家控制。这意味着我们可以根据玩家的输入向服务器发送更准确的移动信息，而不仅仅使用角色速度的最后一个值。'
- en: '`ROLE_Authority`: The current game instance has complete authority over the
    actor. That means that if the actor is on the server, the changes made to the
    replicated variables of the actor will be treated as the value that every client
    needs to have enforced through variable replication.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ROLE_Authority`：当前游戏实例对该角色具有完全权限。这意味着如果该角色在服务器上，对该角色的复制变量所做的更改将被视为每个客户端需要通过变量复制强制执行的值。'
- en: 'Let''s have a look at the following example code snippet:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下示例代码片段：
- en: '[PRE15]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code snippet will store the values of the local role and remote
    role to `MyLocalRole` and `MyRemoteRole` respectively. After that, it will print
    different messages on the screen depending on whether that version of the actor
    is the authority or whether it's being controlled by a player on its client.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段将将本地角色和远程角色的值分别存储到`MyLocalRole`和`MyRemoteRole`中。之后，它将根据该角色的版本是权限还是在其客户端上由玩家控制而在屏幕上打印不同的消息。
- en: Note
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to understand that if an actor has a local role of `ROLE_Authority`,
    it doesn't mean that it's on the server; it means that it's on the game instance
    that originally spawned the actor and therefore has authority over it.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，如果一个角色具有`ROLE_Authority`的本地角色，这并不意味着它在服务器上；这意味着它在最初生成角色的游戏实例上，并因此对其具有权限。
- en: If a client spawns an actor, even though the server and the other clients won't
    know about it, its local role will still be `ROLE_Authority`. Most of the actors
    in a multiplayer game will be spawned by the server; that's why it's easy to misunderstand
    that the authority is always referring to the server.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端生成一个角色，即使服务器和其他客户端不知道它，它的本地角色仍将是`ROLE_Authority`。大多数多人游戏中的角色都将由服务器生成；这就是为什么很容易误解权限总是指服务器。
- en: 'Here is a table to help you understand the roles that an actor will have in
    different scenarios:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个表格，帮助您理解角色在不同情况下将具有的角色：
- en: '![Figure 16.7: Roles that an actor can have in different scenarios'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.7：角色在不同场景中可以拥有的角色'
- en: '](img/B16183_16_07.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_16_07.jpg)'
- en: 'Figure 16.7: Roles that an actor can have in different scenarios'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.7：角色在不同场景中可以拥有的角色
- en: In the preceding table, you can see the roles that an actor will have in different scenarios.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在上表中，您可以看到角色在不同情况下将具有的角色。
- en: 'Let''s analyze each scenario and explain why the actor has that role:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析每种情况，并解释为什么角色具有该角色：
- en: '**Actor Spawned on the Server**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**在服务器上生成的角色**'
- en: The actor spawns on the server, so the server's version of that actor will have
    the local role of `ROLE_Authority` and the remote role of `ROLE_SimulatedProxy`,
    which is the local role of the client's version of the actor. For the client's
    version of that actor, its local role will be `ROLE_SimulatedProxy` and the remote
    role will be `ROLE_Authority`, which is the local role of the server's actor version.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 该角色在服务器上生成，因此服务器版本的该角色将具有`ROLE_Authority`的本地角色和`ROLE_SimulatedProxy`的远程角色，这是客户端版本的该角色的本地角色。对于该角色的客户端版本，其本地角色将是`ROLE_SimulatedProxy`，远程角色将是`ROLE_Authority`，这是服务器角色版本的本地角色。
- en: '**Actor Spawned on the Client**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**在客户端上生成的角色**'
- en: The actor was spawned on the client, so the client's version of that actor will
    have the local role of `ROLE_Authority` and the remote role of `ROLE_SimulatedProxy`.
    Since the actor wasn't spawned on the server, then it will only exist on the client
    that spawned it, so there won't be versions of this actor on the server and the
    other clients.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 角色在客户端上生成，因此该角色的客户端版本将具有`ROLE_Authority`的本地角色和`ROLE_SimulatedProxy`的远程角色。由于该角色未在服务器上生成，因此它只会存在于生成它的客户端上，因此在服务器和其他客户端上不会有该角色的版本。
- en: '**Player-Owned Pawn Spawned on the Server**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**在服务器上生成的玩家拥有的角色**'
- en: The pawn was spawned on the server, so the server's version of that pawn will
    have the local role of `ROLE_Authority` and the remote role of `ROLE_AutonomousProxy`,
    which is the local role of the client's version of the pawn. For the client's
    version of that pawn, its local role will be `ROLE_AutonomousProxy`, because it's
    being controlled by `PlayerController`, and the remote role `ROLE_Authority`,
    which is the local role of the server's pawn version.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 该角色在服务器上生成，因此服务器版本的该角色将具有`ROLE_Authority`的本地角色和`ROLE_AutonomousProxy`的远程角色，这是客户端版本的该角色的本地角色。对于该角色的客户端版本，其本地角色将是`ROLE_AutonomousProxy`，因为它由`PlayerController`控制，并且远程角色将是`ROLE_Authority`，这是服务器角色版本的本地角色。
- en: '**Player-Owned Pawn Spawned on the Client**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**在客户端上生成的玩家拥有的角色**'
- en: The pawn was spawned on the client, so the client's version of that pawn will
    have the local role of `ROLE_Authority` and the remote role of `ROLE_SimulatedProxy`.
    Since the pawn wasn't spawned on the server, then it will only exist on the client
    that spawned it, so there won't be versions of this pawn on the server and the
    other clients.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 该pawn在客户端上生成，因此该pawn的客户端版本将具有`ROLE_Authority`的本地角色和`ROLE_SimulatedProxy`的远程角色。由于pawn没有在服务器上生成，因此它只会存在于生成它的客户端上，因此在服务器和其他客户端上不会有这个pawn的版本。
- en: 'Exercise 16.02: Implementing Ownership and Roles'
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习16.02：实现所有权和角色
- en: In this exercise, we're going to create a C++ project that uses the Third Person
    template as a base.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个使用Third Person模板作为基础的C++项目。
- en: 'Create a new actor called `OwnershipTestActor` that has a static mesh component
    as the root component, and on every tick, it''ll do the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`OwnershipTestActor`的新actor，它具有静态网格组件作为根组件，并且在每次tick时，它将执行以下操作：
- en: On the authority, it will check which character is closest to it within a certain
    radius (configured by the `EditAnywhere` variable called `OwnershipRadius`) and
    will set that character as its owner. When no character is within the radius,
    then the owner will be `nullptr`.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在权限方面，它将检查在一定半径内（由名为`OwnershipRadius`的`EditAnywhere`变量配置）哪个角色离它最近，并将该角色设置为其所有者。当半径内没有角色时，所有者将为`nullptr`。
- en: Display its local role, remote role, owner, and connection.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示其本地角色、远程角色、所有者和连接。
- en: Edit `OwnershipRolesCharacter` and override the `Tick` function so that it displays
    its local role, remote role, owner, and connection.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑`OwnershipRolesCharacter`并覆盖`Tick`函数，以便显示其本地角色、远程角色、所有者和连接。
- en: Create a new header file called `OwnershipRoles.h` that contains the `ROLE_TO_String`
    macro, which converts `ENetRole` into an `Fstring` variable.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`OwnershipRoles.h`的新头文件，其中包含`ROLE_TO_String`宏，将`ENetRole`转换为`Fstring`变量。
- en: 'The following steps will help you complete the exercise:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成练习：
- en: Create a new `Third Person` template project using `C++` called `OwnershipRoles`
    and save it to a location of your choosing.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`C++`创建一个名为`OwnershipRoles`的新`Third Person`模板项目，并将其保存到您选择的位置。
- en: Once the project has been created, it should open the editor as well as the
    Visual Studio solution.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目创建完成后，应该打开编辑器以及Visual Studio解决方案。
- en: Using the editor, create a new C++ class called `OwnershipTestActor` that derives
    from `Actor`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用编辑器，创建一个名为`OwnershipTestActor`的新C++类，该类派生自`Actor`。
- en: Once it finishes compiling, Visual Studio should pop up with the newly created
    `.h` and `.cpp` files.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译完成后，Visual Studio应该弹出新创建的`.h`和`.cpp`文件。
- en: Close the editor and go back to Visual Studio.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭编辑器，返回Visual Studio。
- en: 'In Visual Studio, open the `OwnershipRoles.h` file and add the following macro:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，打开`OwnershipRoles.h`文件并添加以下宏：
- en: '[PRE16]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This macro will convert the `ENetRole` enumeration that we get from the `GetLocalRole()`
    function and `GetRemoteRole()` into an `FString`. The way it works is by finding
    the `ENetRole` enumeration type through Unreal Engine's reflection system and
    from that, it converts the `Value` parameter into an `FString` variable so it
    can be printed on the screen.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏将把我们从`GetLocalRole()`函数和`GetRemoteRole()`获得的`ENetRole`枚举转换为`FString`。它的工作方式是通过在虚幻引擎的反射系统中找到`ENetRole`枚举类型，并从中将`Value`参数转换为`FString`变量，以便在屏幕上打印出来。
- en: Now, open the `OwnershipTestActor.h` file.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`OwnershipTestActor.h`文件。
- en: 'Declare the protected variables for the static mesh component and the ownership
    radius as shown in the following code snippet:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据以下代码片段中所示，声明静态网格组件和所有权半径的受保护变量：
- en: '[PRE17]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code snippet, we declare the static mesh component and the
    `OwnershipRadius` variable, which allows you to configure the radius of the ownership.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们声明了静态网格组件和`OwnershipRadius`变量，它允许您配置所有权的半径。
- en: Next, delete the declaration of `BeginPlay` and move the constructor and the
    `Tick` function declarations to the protected area.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，删除`BeginPlay`的声明，并将构造函数和`Tick`函数的声明移到受保护的区域。
- en: 'Now, open the `OwnershipTestActor.cpp` file and add the required header files
    as mentioned in the following code snippet:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`OwnershipTestActor.cpp`文件，并根据以下代码片段中提到的添加所需的头文件：
- en: '[PRE18]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code snippet, we include `DrawDebugHelpers.h` because we'll
    call the `DrawDebugSphere` and `DrawDebugString` functions. We include `OwnershipRoles.h`,
    `OwnershipRolesCharacter.h` and `StaticMeshComponent.h` so that the `.cpp` file
    knows about those classes. We finally include `GameplayStatics.h` because we'll
    call the `GetAllActorsOfClass` function.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们包括了`DrawDebugHelpers.h`，因为我们将调用`DrawDebugSphere`和`DrawDebugString`函数。我们包括`OwnershipRoles.h`，`OwnershipRolesCharacter.h`和`StaticMeshComponent.h`，以便`.cpp`文件知道这些类。最后，我们包括`GameplayStatics.h`，因为我们将调用`GetAllActorsOfClass`函数。
- en: 'In the constructor definition, create the static mesh component and set it
    as the root component:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数定义中，创建静态网格组件并将其设置为根组件：
- en: '[PRE19]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Still in the constructor, set `bReplicates` to `true` to tell Unreal Engine
    that this actor replicates and should also exist in all of the clients:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，将`bReplicates`设置为`true`，告诉虚幻引擎该actor会复制，并且也应该存在于所有客户端中：
- en: '[PRE20]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Delete the `BeginPlay` function definition.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`BeginPlay`函数定义。
- en: 'In the `Tick` function, draw a debug sphere to help visualize the ownership
    radius, as shown in the following code snippet:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Tick`函数中，绘制一个调试球来帮助可视化所有权半径，如下面的代码片段所示：
- en: '[PRE21]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Still in the `Tick` function, create the authority specific logic that will
    get the closest `AOwnershipRolesCharacter` within the ownership radius, and if
    it''s different from the current one, then set it as the owner:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在`Tick`函数中，创建特定于权限的逻辑，该逻辑将获取所有权半径内最接近的`AOwnershipRolesCharacter`，如果与当前角色不同，则将其设置为所有者：
- en: '[PRE22]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Still in the `Tick` function, convert the values for the local/remote roles
    (using the `ROLE_TO_STRING` macro we created earlier), the current owner, and
    the connection to the strings:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在`Tick`函数中，将本地/远程角色的值（使用我们之前创建的`ROLE_TO_STRING`宏），当前所有者和连接转换为字符串：
- en: '[PRE23]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To finalize the `Tick` function, use `DrawDebugString` to display onscreen
    the strings we converted in the previous step:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`DrawDebugString`在屏幕上显示我们在上一步中转换的字符串：
- en: '[PRE24]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Instead of constantly using `GetLocalRole() == ROLE_Authority` to check whether
    the actor has authority, you can use the `HasAuthority()` helper function, defined
    in `AActor`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 不要不断使用`GetLocalRole() == ROLE_Authority`来检查角色是否具有权限，可以使用`AActor`中定义的`HasAuthority()`辅助函数。
- en: 'Next, open `OwnershipRolesCharacter.h` and declare the `Tick` function as protected:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开`OwnershipRolesCharacter.h`并将`Tick`函数声明为受保护的：
- en: '[PRE25]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, open `OwnershipRolesCharacter.cpp` and include the header files as shown
    in the following code snippet:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`OwnershipRolesCharacter.cpp`并按照以下代码片段中所示包含头文件：
- en: '[PRE26]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Implement the `Tick` function:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Tick`函数：
- en: '[PRE27]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Convert the values for the local/remote roles (using the `ROLE_TO_STRING` macro
    we created earlier), the current owner, and the connection to strings:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将本地/远程角色的值（使用我们之前创建的`ROLE_TO_STRING`宏），当前所有者和连接转换为字符串：
- en: '[PRE28]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Use `DrawDebugString` to display onscreen the strings we converted in the previous
    step:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`DrawDebugString`在屏幕上显示我们在上一步中转换的字符串：
- en: '[PRE29]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Finally, we can test the project.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以测试项目。
- en: Run the code and wait for the editor to fully load.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并等待编辑器完全加载。
- en: Create a new Blueprint called `OwnershipTestActor_BP` in the `Content` folder
    that derives from `OwnershipTestActor`. Set `Mesh` to use a cube mesh, and drop
    an instance of it in the world.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content`文件夹中创建一个名为`OwnershipTestActor_BP`的新蓝图，它派生自`OwnershipTestActor`。将`Mesh`设置为使用立方体网格，并在世界中放置一个实例。
- en: Go to `Multiplayer Options` and set the number of clients to `2`.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`多人游戏选项`并将客户端数量设置为`2`。
- en: Set the window size to `800x600`.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将窗口大小设置为`800x600`。
- en: Play using `New Editor Window (PIE)`.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`New Editor Window (PIE)`进行游戏。
- en: 'You should get the following output:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 16.8: Expected result on the server and Client 1 window'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.8：服务器和Client 1窗口上的预期结果'
- en: '](img/B16183_16_08.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_16_08.jpg)'
- en: 'Figure 16.8: Expected result on the server and Client 1 window'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.8：服务器和Client 1窗口上的预期结果
- en: By completing this exercise, you'll have a better understanding of how connections
    and ownership works. These are important concepts to know as everything related
    to replication is dependent on them.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你将更好地理解连接和所有权是如何工作的。这些是重要的概念，因为与复制相关的一切都依赖于它们。
- en: Next time you see that an actor is not doing replication operations, you'll
    know that you need to check first whether it has a **valid connection** and an
    **owner**.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 下次当你看到一个角色没有进行复制操作时，你会知道需要首先检查它是否有**有效的连接**和**所有者**。
- en: Now, let's analyze the displayed values in the server and client windows.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们分析服务器和客户端窗口中显示的值。
- en: The Server Window
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器窗口
- en: 'Have a look at the following output screenshot of the `Server` window from
    the previous exercise:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下上一个练习中`Server`窗口的以下输出截图：
- en: '![Figure 16.9: The Server window'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.9：服务器窗口'
- en: '](img/B16183_16_09.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_16_09.jpg)'
- en: 'Figure 16.9: The Server window'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.9：服务器窗口
- en: Note
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The text that says `Server Character`, `Client 1 Character`, and `Ownership
    Test Actor` is not part of the original screenshot and was added to help you understand
    which character and actor is which.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 显示`Server Character`，`Client 1 Character`和`Ownership Test Actor`的文本不是原始截图的一部分，是为了帮助你理解哪个角色和角色是哪个而添加的。
- en: In the preceding screenshot, you can see `Server Character`, `Client 1 Character`,
    and the `Ownership Test` cube actor.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，你可以看到`Server Character`，`Client 1 Character`和`Ownership Test`立方体角色。
- en: Let's first analyze the values for `Server Character`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 首先分析`Server Character`的值。
- en: Server Character
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器角色
- en: 'This is the character that the listen server is controlling. The values associated
    with this character are as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这是监听服务器正在控制的角色。与这个角色相关的值如下：
- en: '`LocalRole = ROLE_Authority`: because this character was spawned on the server,
    which is the current game instance.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalRole = ROLE_Authority`：因为这个角色是在服务器上生成的，这是当前的游戏实例。'
- en: '`RemoteRole = ROLE_SimulatedProxy`: because this character was spawned on the
    server, so the other clients should only simulate it.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoteRole = ROLE_SimulatedProxy`：因为这个角色是在服务器上生成的，所以其他客户端只能模拟它。'
- en: '`Owner = PlayerController_0`: because this character is being controlled by
    the client of the listen server, which uses the first `PlayerController` instance
    called `PlayerController_0`.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Owner = PlayerController_0`：因为这个角色由监听服务器的客户端控制，使用了名为`PlayerController_0`的第一个`PlayerController`实例。'
- en: '`Connection = Invalid Connection`: because we''re the client of the listen
    server, so there is no need for a connection.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Connection = Invalid Connection`：因为我们是监听服务器的客户端，所以不需要连接。'
- en: Next, we are going to be looking at `Client 1 Character` in the same window.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在同一个窗口中查看`Client 1 Character`。
- en: Client 1 Character
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Client 1 Character
- en: 'This is the character that `Client 1` is controlling. The values associated
    with this character are as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Client 1`正在控制的角色。与这个角色相关的值如下：
- en: '`LocalRole = ROLE_Authority`: because this character was spawned on the server,
    which is the current game instance.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalRole = ROLE_Authority`：因为这个角色是在服务器上生成的，这是当前的游戏实例。'
- en: '`RemoteRole = ROLE_AutonomousProxy`: because this character was spawned on
    the server, but it''s being controlled by another client.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoteRole = ROLE_AutonomousProxy`：因为这个角色是在服务器上生成的，但是由另一个客户端控制。'
- en: '`Owner = PlayerController_1`: because this character is being controlled by
    another client, which uses the second `PlayerController` instance called `PlayerController_1`.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Owner = PlayerController_1`：因为这个角色是由另一个客户端控制的，使用了名为`PlayerController_1`的第二个`PlayerController`实例。'
- en: '`Connection = Valid Connection`: because this character is being controlled
    by another client, so a connection to the server is required.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Connection = Valid Connection`：因为这个角色由另一个客户端控制，所以需要与服务器建立连接。'
- en: Next, we are going to be looking at the `OwnershipTest` actor in the same window.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在同一个窗口中查看`OwnershipTest`角色。
- en: The OwnershipTest Actor
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OwnershipTest Actor
- en: 'This is the cube actor that will set its owner to the closest character within
    a certain ownership radius. The values associated with this actor are as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将其所有者设置为一定所有权半径内最近的角色的立方体演员。与该演员相关的值如下：
- en: '`LocalRole = ROLE_Authority`: because this actor was placed in the level and
    spawned on the server, which is the current game instance.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalRole = ROLE_Authority`：因为这个演员被放置在级别中，并在服务器上生成，这是当前游戏实例。'
- en: '`RemoteRole = ROLE_SimulatedProxy`: because this actor was spawned in the server,
    but it''s not being controlled by any client.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoteRole = ROLE_SimulatedProxy`：因为这个演员是在服务器中生成的，但没有被任何客户端控制。'
- en: '`Owner` and `Connection` will have their values based on the closest character.
    If there isn''t a character inside the ownership radius, then they will have the
    values of `No Owner` and `Invalid Connection`.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Owner`和`Connection`的值将基于最近的角色。如果在所有权半径内没有角色，则它们将具有`无所有者`和`无效连接`的值。'
- en: 'Now, let''s have a look at the `Client 1` window:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下`Client 1`窗口：
- en: '![Figure 16.10: The Client 1 window'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.10：客户端1窗口'
- en: '](img/B16183_16_10.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_16_10.jpg)'
- en: 'Figure 16.10: The Client 1 window'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.10：客户端1窗口
- en: The Client 1 Window
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端1窗口
- en: The values for the `Client 1` window will be exactly the same as the `Server`
    window, except the values of `LocalRole` and `RemoteRole` will be reversed because
    they are always relative to the game instance that you are in.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`Client 1`窗口的值将与`Server`窗口的值完全相同，只是`LocalRole`和`RemoteRole`的值将被颠倒，因为它们始终相对于您所在的游戏实例。'
- en: Another exception is that the server character has no owner and the other connected
    clients won't have a valid connection. The reason for that is clients don't store
    player controllers and connections of other clients, only the server does, but
    this will be covered in more depth in *Chapter 18*, *Gameplay Framework Classes
    in Multiplayer*.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例外是服务器角色没有所有者，其他连接的客户端将没有有效连接。原因是客户端不存储其他客户端的玩家控制器和连接，只有服务器才会存储，但这将在*第18章*中更深入地介绍*多人游戏中的游戏框架类*。
- en: In the next section, we will be looking at variable replication.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看一下变量复制。
- en: Variable Replication
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量复制
- en: One of the ways the server can keep the clients synchronized is by using variable
    replication. The way it works is that every specific number of times per second
    (defined per actor in the `AActor::NetUpdateFrequency` variable, which is also
    exposed to blueprints) the variable replication system in the server will check
    whether there are any replicated variables (*explained in the next section*) in
    the client that needs to be updated with the latest value.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可以使客户端保持同步的一种方式是使用变量复制。其工作方式是，每秒特定次数（在`AActor::NetUpdateFrequency`变量中为每个演员定义，也暴露给蓝图）服务器中的变量复制系统将检查是否有任何需要使用最新值更新的客户端中的复制变量（*在下一节中解释*）。
- en: If the variable meets all of the replication conditions, then the server will
    send an update to the client and enforce the new value.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果变量满足所有复制条件，那么服务器将向客户端发送更新并强制执行新值。
- en: For example, if you have a replicated `Health` variable and the client on its
    end uses a hacking tool to set the value of the variable from `10` to `100`, then
    the replication system will enforce the real value from the server and change
    it back to `10`, which nullifies the hack.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您有一个复制的`Health`变量，并且客户端使用黑客工具将变量的值从`10`设置为`100`，那么复制系统将强制从服务器获取真实值并将其更改回`10`，从而使黑客无效。
- en: 'Variables are only sent to the client to be updated if:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在以下情况下才会将变量发送到客户端进行更新：
- en: The variable is set to replicate.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量被设置为复制。
- en: The value was changed on the server.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值已在服务器上更改。
- en: The value on the client is different than on the server.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端上的值与服务器上的值不同。
- en: The actor has replication enabled.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演员已启用复制。
- en: The actor is relevant and meets all of the replication conditions.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演员是相关的，并满足所有复制条件。
- en: One important thing to take into consideration is that the logic that determines
    whether a variable should be replicated or not is only executed `AActor::NetUpdateFrequency`
    times a second. In other words, the server doesn't send an update request to a
    client immediately after you change the value of a variable on the server. It
    will only send that request when the variable replication system executes, which
    is `AActor::NetUpdateFrequency` times a second, and it has determined that the
    values from the client are different than the values from the server.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的一个重要事项是，确定变量是否应该复制的逻辑仅在每秒执行`AActor::NetUpdateFrequency`次。换句话说，服务器在更改服务器上的变量值后不会立即向客户端发送更新请求。只有在变量复制系统执行时（每秒`AActor::NetUpdateFrequency`次），并且确定客户端的值与服务器的值不同时，才会发送该请求。
- en: An example would be if you had an integer replicate a variable called `Test`
    that has a default value of `5`. If you call a function on the server that sets
    `Test` to `3` and in the next line changes it to `8`, then only the latter change
    would send an update request to the clients. The reason for this is these two
    changes were made in between the `NetUpdateFrequency` interval, so when the variable
    replication system executes, the current value is `8`, and as that is different
    to the value of the clients (which is still `5`), it will update them. If instead
    of setting it to `8`, you set it back to `5`, then no changes would be sent to
    the clients.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您有一个整数复制一个名为`Test`的变量，其默认值为`5`。如果您在服务器上调用一个将`Test`设置为`3`的函数，并在下一行将其更改为`8`，那么只有后者的更改会发送更新请求到客户端。原因是这两个更改是在`NetUpdateFrequency`间隔之间进行的，因此当变量复制系统执行时，当前值为`8`，因为它与客户端的值不同（仍为`5`），它将更新它们。如果您将其设置回`5`，则不会向客户端发送任何更改。
- en: Replicated Variables
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制变量
- en: In Unreal Engine, any variable that can use the `UPROPERTY` macro can be set
    to replicate, and you can use two specifiers to do that.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎中，任何可以使用`UPROPERTY`宏的变量都可以设置为复制，并且可以使用两个限定词来执行此操作。
- en: '**Replicated**'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '**复制**'
- en: If you just want to say that a variable is replicated, then you use the `Replicated` specifier.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想说一个变量被复制，那么你使用`Replicated`修饰符。
- en: 'Have a look at the following example:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 看下面的例子：
- en: '[PRE30]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding code snippet, we declare a float variable called `Health`,
    as we normally do. The difference is that we've added `UPROPERTY(Replicated)`
    to tell Unreal Engine that the `Health` variable will be replicated.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们声明了一个名为`Health`的浮点变量，就像我们通常做的那样。不同之处在于，我们添加了`UPROPERTY(Replicated)`，告诉虚幻引擎`Health`变量将被复制。
- en: '**RepNotify**'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '**RepNotify**'
- en: 'If you want to say that a variable is replicated and calls a function every
    time it''s updated, then you use the `ReplicatedUsing=<Function Name>` specifier.
    Have a look at the following example:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想说一个变量被复制并且每次更新时都调用一个函数，那么你使用`ReplicatedUsing=<Function Name>`修饰符。看下面的例子：
- en: '[PRE31]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding code snippet, we declare a float variable called `Health`.
    The difference is that we've added `UPROPERTY(ReplicatedUsing=OnRep_Health)` to
    tell Unreal Engine that this variable will be replicated and every time it's updated
    it will call the `OnRep_Health` function, which, in this specific case, will call
    a function to update `HUD`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们声明了一个名为`Health`的浮点变量。不同之处在于，我们添加了`UPROPERTY(ReplicatedUsing=OnRep_Health)`，告诉虚幻引擎这个变量将被复制，并且每次更新时都会调用`OnRep_Health`函数，在这种特定情况下，它将调用一个函数来更新`HUD`。
- en: Typically, the naming scheme for the callback function is `OnRepNotify_<Variable
    Name>` or `OnRep_<Variable Name>`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，回调函数的命名方案是`OnRepNotify_<Variable Name>`或`OnRep_<Variable Name>`。
- en: Note
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The function used in the `ReplicatingUsing` specifier needs to be marked as
    `UFUNCTION()`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ReplicatingUsing`修饰符中使用的函数需要标记为`UFUNCTION()`。
- en: '**GetLifetimeReplicatedProps**'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '**GetLifetimeReplicatedProps**'
- en: Besides marking the variable as replicated, you'll also need to implement the
    `GetLifetimeReplicatedProps` function in the actor's `cpp` file. One thing to
    take into consideration is that this function is declared internally once you
    have at least one replicated variable, so you shouldn't declare it in the actor's
    header file. The purpose of this function is for you to tell how each replicated
    variable should replicate. You do this by using the `DOREPLIFETIME` macro and
    its variants on every variable that you want to replicate.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将变量标记为复制外，您还需要在角色的`cpp`文件中实现`GetLifetimeReplicatedProps`函数。需要考虑的一件事是，一旦您至少有一个复制的变量，此函数将在内部声明，因此您不应该在角色的头文件中声明它。这个函数的目的是告诉您每个复制的变量应该如何复制。您可以通过在您想要复制的每个变量上使用`DOREPLIFETIME`宏及其变体来实现这一点。
- en: '**DOREPLIFETIME**'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '**DOREPLIFETIME**'
- en: This macro tells the replication system that the replicated variable (entered
    as an argument) will replicate to all clients without a replication condition.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏告诉复制系统，复制的变量（作为参数输入）将在没有复制条件的情况下复制到所有客户端。
- en: 'Here''s its syntax:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是它的语法：
- en: '[PRE32]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Have a look at the following example:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 看下面的例子：
- en: '[PRE33]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code snippet, we use the `DOREPLIFETIME` macro to tell the
    replication system that the `Health` variable in the `AVariableReplicationActor`
    class will replicate without an extra condition.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们使用`DOREPLIFETIME`宏告诉复制系统，`AVariableReplicationActor`类中的`Health`变量将在没有额外条件的情况下复制。
- en: '**DOREPLIFETIME_CONDITION**'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**DOREPLIFETIME_CONDITION**'
- en: This macro tells the replication system that the replicated variable (entered
    as an argument) will replicate only to the clients that meet the condition (entered
    as an argument).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏告诉复制系统，复制的变量（作为参数输入）只会根据满足的条件（作为参数输入）复制给客户端。
- en: 'Here''s the syntax:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是语法：
- en: '[PRE34]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The condition parameter can be one of the following values:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 条件参数可以是以下值之一：
- en: '`COND_InitialOnly`: The variable will only replicate once, with the initial replication.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COND_InitialOnly`：变量只会复制一次，进行初始复制。'
- en: '`COND_OwnerOnly`: The variable will only replicate to the owner of the actor.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COND_OwnerOnly`：变量只会复制给角色的所有者。'
- en: '`COND_SkipOwner`: The variable won''t replicate to the owner of the actor.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COND_SkipOwner`：变量不会复制给角色的所有者。'
- en: '`COND_SimulatedOnly`: The variable will only replicate to actors that are simulating.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COND_SimulatedOnly`：变量只会复制到正在模拟的角色。'
- en: '`COND_AutonomousOnly`: The variable will only replicate to actors that are autonomous.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COND_AutonomousOnly`：变量只会复制给自主角色。'
- en: '`COND_SimulatedOrPhysics`: The variable will only replicate to actors that
    are simulating or to actors with `bRepPhysics` set to true.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COND_SimulatedOrPhysics`：变量只会复制到正在模拟的角色或`bRepPhysics`设置为true的角色。'
- en: '`COND_InitialOrOwner`: The variable will only replicate once, with the initial
    replication or to the owner of the actor.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COND_InitialOrOwner`：变量只会进行初始复制，或者只会复制给角色的所有者。'
- en: '`COND_Custom`: The variable will only replicate if its `SetCustomIsActiveOverride`
    Boolean condition (used in the `AActor::PreReplication` function) is true.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COND_Custom`：变量只有在其`SetCustomIsActiveOverride`布尔条件（在`AActor::PreReplication`函数中使用）为true时才会复制。'
- en: 'Have a look at the following example:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 看下面的例子：
- en: '[PRE35]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding code snippet, we use the `DOREPLIFETIME_CONDITION` macro to
    tell the replication system that the `Health` variable in the `AVariableReplicationActor`
    class will replicate only for the owner of this actor.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们使用`DOREPLIFETIME_CONDITION`宏告诉复制系统，`AVariableReplicationActor`类中的`Health`变量只会为该角色的所有者复制。
- en: Note
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are more `DOREPLIFETIME` macros available, but they won''t be covered
    in this book. To see all of the variants, please check the `UnrealNetwork.h` file
    from the Unreal Engine 4 source code. See the instructions at: [https://docs.unrealengine.com/en-US/GettingStarted/DownloadingUnrealEngine/index.html](https://docs.unrealengine.com/en-US/GettingStarted/DownloadingUnrealEngine/index.html).'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多的`DOREPLIFETIME`宏可用，但本书不会涵盖它们。要查看所有变体，请检查虚幻引擎4源代码中的`UnrealNetwork.h`文件。请参阅以下说明：[https://docs.unrealengine.com/en-US/GettingStarted/DownloadingUnrealEngine/index.html](https://docs.unrealengine.com/en-US/GettingStarted/DownloadingUnrealEngine/index.html)。
- en: 'Exercise 16.03: Replicating Variables Using Replicated, RepNotify, DOREPLIFETIME,
    and DOREPLIFETIME_CONDITION'
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习16.03：使用Replicated、RepNotify、DOREPLIFETIME和DOREPLIFETIME_CONDITION复制变量
- en: 'In this exercise, we''re going to create a C++ project that uses the Third
    Person template as a base and add two variables to the character that replicate
    in the following way:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个C++项目，该项目以第三人称模板为基础，并向角色添加两个以以下方式复制的变量：
- en: Variable `A` is a float that will use the `Replicated UPROPERTY` specifier and
    the `DOREPLIFETIME` macro.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量“A”是一个浮点数，将使用“Replicated UPROPERTY”说明符和“DOREPLIFETIME”宏。
- en: Variable `B` is an integer that will use the `ReplicatedUsing UPROPERTY` specifier
    and the `DOREPLIFETIME_CONDITION` macro.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量“B”是一个整数，将使用“ReplicatedUsing UPROPERTY”说明符和“DOREPLIFETIME_CONDITION”宏。
- en: 'The following steps will help you complete the exercise:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成练习：
- en: Create a new `Third Person` template project using `C++` called `VariableReplication`
    and save it to a location of your choosing.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用C++创建一个名为“VariableReplication”的“Third Person”模板项目，并将其保存到您选择的位置。
- en: Once the project has been created, it should open the editor as well as the
    Visual Studio solution.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目创建后，应打开编辑器以及Visual Studio解决方案。
- en: Close the editor and go back to Visual Studio.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭编辑器，返回Visual Studio。
- en: Open the `VariableReplicationCharacter.h` file.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“VariableReplicationCharacter.h”文件。
- en: 'Next, include the `UnrealNetwork.h` header file before the `VariableReplicationCharacter.generated.h`,
    which has the definition of the `DOREPLIFETIME` macros that we''re going to use:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在“VariableReplicationCharacter.generated.h”之前包含“UnrealNetwork.h”头文件，其中包含我们将使用的“DOREPLIFETIME”宏的定义：
- en: '[PRE36]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Declare the protected variables `A` and `B` as `UPROPERTY` using their respective
    replication specifiers:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用各自的复制说明符将受保护的变量“A”和“B”声明为“UPROPERTY”：
- en: '[PRE37]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Declare the `Tick` function as protected:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“Tick”函数声明为受保护：
- en: '[PRE38]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Since we''ve declared variable `B` as `ReplicatedUsing = OnRepNotify_B`, then
    we also need to declare the protected `OnRepNotify_B` callback function as `UFUNCTION`:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将变量“B”声明为“ReplicatedUsing = OnRepNotify_B”，因此我们还需要将受保护的“OnRepNotify_B”回调函数声明为“UFUNCTION”：
- en: '[PRE39]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, open the `VariableReplicationCharacter.cpp` file and include the headers
    `Engine.h`, so we can use the `AddOnScreenDebugMessage` function, and `DrawDebugHelpers.h`,
    so we can use the `DrawDebugString` function:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开“VariableReplicationCharacter.cpp”文件，并包括“Engine.h”头文件，这样我们就可以使用“AddOnScreenDebugMessage”函数，以及“DrawDebugHelpers.h”头文件，这样我们就可以使用“DrawDebugString”函数：
- en: '[PRE40]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Implement the `GetLifetimeReplicatedProps` function:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现“GetLifetimeReplicatedProps”函数：
- en: '[PRE41]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Set that as the `A` variable, which will replicate without any extra conditions:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其设置为“A”变量，它将在没有任何额外条件的情况下复制：
- en: '[PRE42]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Set that as the `B` variable, which will only replicate to the owner of this
    actor:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其设置为“B”变量，这将仅复制到此角色的所有者：
- en: '[PRE43]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Implement the `Tick` function:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现“Tick”函数：
- en: '[PRE44]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, run the authority-specific logic that adds `1` to `A` and `B`:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，运行特定权限的逻辑，将“1”添加到“A”和“B”：
- en: '[PRE45]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Since this character will be spawned on the server, then only the server will
    execute this logic.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此角色将在服务器上生成，因此只有服务器将执行此逻辑。
- en: 'Display the values of `A` and `B` on the location of the character:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在角色的位置上显示“A”和“B”的值：
- en: '[PRE46]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Implement the `RepNotify` function for variable `B`, which displays on the
    screen a message saying that the `B` variable was changed to a new value:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现变量“B”的“RepNotify”函数，该函数在屏幕上显示一条消息，说明“B”变量已更改为新值：
- en: '[PRE47]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, you can test the project:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以测试项目：
- en: Run the code and wait for the editor to fully load.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，等待编辑器完全加载。
- en: Go to `Multiplayer Options` and set the number of clients to `2`.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到“多人游戏选项”，并将客户端数量设置为“2”。
- en: Set the window size to `800x600`.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将窗口大小设置为“800x600”。
- en: Play using `New Editor Window (PIE)`.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“新编辑器窗口（PIE）”进行游戏。
- en: Once you complete this exercise, you will be able to play on each client and
    you'll notice that the characters are displaying their respective values for `A`
    and `B`.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此练习后，您将能够在每个客户端上进行游戏，并且您会注意到角色显示其各自的“A”和“B”的值。
- en: Now, let's analyze the values displayed in the `Server` and `Client 1` windows.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们分析“服务器”和“客户端1”窗口中显示的值。
- en: The Server Window
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器窗口
- en: 'In the `Server` window, you have the values for `Server Character`, which is
    the character controlled by the server, and in the background, you have values
    for `Client 1 Character`:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在“服务器”窗口中，您可以看到“服务器角色”的值，这是由服务器控制的角色，在后台，您可以看到“客户端1角色”的值：
- en: '![Figure 16.11: The Server window'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.11：服务器窗口'
- en: '](img/B16183_16_11.jpg)'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_16_11.jpg)'
- en: 'Figure 16.11: The Server window'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.11：服务器窗口
- en: 'The outputs that can be observed are as follows:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 可以观察到的输出如下：
- en: '`Server` `Character` – `A = 674.00 B = 574`'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “服务器”“角色” - “A = 674.00 B = 574”
- en: '`Client 1` `Character` – `A = 670.00 B = 570`'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “客户端1”“角色” - “A = 670.00 B = 570”
- en: At this specific point in time, `Server` `Character` has a value of `674` for
    `A` and `574` for `B`. The reason why `A` and `B` have different values is because
    `A` starts at `100` and `B` starts at `0`, which is the correct value after `574`
    ticks of `A++` and `B++`.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定时间点，“服务器”“角色”的“A”值为“674”，“B”值为“574”。之所以“A”和“B”有不同的值，是因为“A”从“100”开始，“B”从“0”开始，这是“574”次“A++”和“B++”后的正确值。
- en: As for why the `Client 1` `Character` doesn't have the same values as the Server
    Character, that is because `Client 1` was created slightly after the server, so
    in this case, the count will be off by `4` ticks of `A++` and `B++`.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 至于为什么“客户端1”“角色”的值与服务器角色不同，那是因为“客户端1”稍后创建，所以在这种情况下，“A++”和“B++”的计数将偏移4个滴答声。
- en: Next, we will be looking at the `Client 1` window.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看“客户端1”窗口。
- en: The Client 1 Window
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端1窗口
- en: 'In the `Client 1` window, you have the values for `Client 1 Character`, which
    is the character controlled by `Client 1`, and in the background, you have values
    for `Server Character`:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在“客户端1”窗口中，您可以看到“客户端1角色”的值，这是由“客户端1”控制的角色，在后台，您可以看到“服务器角色”的值：
- en: '![Figure 16.12: The Client 1 window'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.12：客户端1窗口'
- en: '](img/B16183_16_12.jpg)'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_16_12.jpg)'
- en: 'Figure 16.12: The Client 1 window'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.12：客户端1窗口
- en: 'The outputs that can be observed are as follows:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 可以观察到的输出如下：
- en: '`Server` `Character` – `A = 674.00 B = 0`'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Server` `Character` – `A = 674.00 B = 0`'
- en: '`Client 1` `Character` – `A = 670.00 B = 570`'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Client 1` `Character` – `A = 670.00 B = 570`'
- en: '`Client 1 Character` has the correct values from the server, so the variable
    replication is working as intended. If you look at `Server Character`, `A` is
    `674`, which is correct, but `B` is `0`. The reason for that is `A` is using `DOREPLIFETIME`,
    which doesn''t add any additional replication conditions, so it will replicate
    the variable and keep the client up to date every time the variable is changed
    on the server.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`Client 1 Character`从服务器那里得到了正确的值，因此变量复制正常工作。如果您查看`Server Character`，`A`是`674`，这是正确的，但`B`是`0`。原因是`A`使用了`DOREPLIFETIME`，它不会添加任何额外的复制条件，因此它将复制变量并在服务器上的变量更改时每次使客户端保持最新状态。'
- en: The variable `B`, on the other hand, uses `DOREPLIFETIME_CONDITION` with `COND_OwnerOnly`,
    and since `Client 1` is not the client that owns `Server Character` (*the client
    of the listen server is*), then the value is not replicated and remains unchanged
    from the default value of `0`.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，变量`B`使用`DOREPLIFETIME_CONDITION`和`COND_OwnerOnly`，由于`Client 1`不是拥有`Server
    Character`的客户端（*监听服务器的客户端是*），因此该值不会被复制，并且保持不变为`0`的默认值。
- en: If you go back to the code and change the replication condition of `B` to use
    `COND_SimulatedOnly` instead of `COND_OwnerOnly`, you'll notice that the results
    will be reversed in `Client 1 window`. The value of `B` will be replicated for
    `Server Character`, but it won't replicate for its own character.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您返回代码并将`B`的复制条件更改为使用`COND_SimulatedOnly`而不是`COND_OwnerOnly`，您会注意到结果将在`Client
    1`窗口中被颠倒。`B`的值将被复制到`Server Character`，但不会复制到自己的角色。
- en: Note
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The reason why the `RepNotify` message is showing in the `Server` window instead
    of the client window is that, when playing in the editor, both windows share the
    same process, and therefore printing text on the screen won't be accurate. To
    get the correct behavior, you'll need to run the packaged version of the game.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`RepNotify`消息显示在`Server`窗口而不是客户端窗口的原因是，当在编辑器中播放时，两个窗口共享同一个进程，因此在屏幕上打印文本不准确。要获得正确的行为，您需要运行游戏的打包版本。'
- en: 2D Blend Spaces
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2D混合空间
- en: In *Chapter 2*, *Working with Unreal Engine*, we created a 1D Blend Space to
    blend between the movement states (*idle, walk, and run*) of a character based
    on the value of the Speed axis. For that specific example, it worked pretty well
    because you only needed one axis, but if we wanted the character to also be able
    to strafe, then we couldn't really do that.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第2章*，*使用虚幻引擎*中，我们创建了一个1D混合空间，根据`Speed`轴的值来混合角色的移动状态（*空闲、行走和奔跑*）。对于这个特定的示例，它工作得相当好，因为您只需要一个轴，但是如果我们希望角色也能够斜行，那么我们实际上无法做到。
- en: To explore that case, Unreal Engine allows you to create 2D Blend Spaces. The
    concepts are almost exactly the same; the only difference is that you have an
    extra axis for animations, so you can blend between them not only horizontally,
    but also vertically.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索这种情况，虚幻引擎允许您创建2D混合空间。概念几乎完全相同；唯一的区别是您有一个额外的轴用于动画，因此您不仅可以在水平方向上混合它们，还可以在垂直方向上混合它们。
- en: 'Exercise 16.04: Creating a Movement 2D Blend Space'
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习16.04：创建移动2D混合空间
- en: In this exercise, we're going to create a Blend Space that uses two axes instead
    of one. The vertical axis will be `Speed`, which will be between `0` and `800`.
    The horizontal axis will be `Direction`, which represents the relative angle (`-180
    to 180`) between the velocity and the rotation/forward vector of the pawn.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个使用两个轴而不是一个轴的混合空间。垂直轴将是`Speed`，取值范围为`0`到`800`。水平轴将是`Direction`，表示角色速度和旋转/前向矢量之间的相对角度（`-180到180`）。
- en: 'The following figure will help you calculate the direction in this exercise:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图将帮助您计算本练习中的方向：
- en: '![Figure 16.13: Direction values based on the angle between the forward'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.13：基于前向矢量之间角度的方向值'
- en: vector and the velocity
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 矢量和速度
- en: '](img/B16183_16_13.jpg)'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_16_13.jpg)'
- en: 'Figure 16.13: Direction values based on the angle between the forward vector
    and the velocity'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.13：基于前向矢量和速度之间角度的方向值
- en: In the preceding figure, you can see how the direction will be calculated. The
    forward vector represents the direction that the character is currently facing,
    and the numbers represent the angle that the forward vector would make with the
    velocity vector if it was pointing in that direction. If the character was looking
    in a certain direction and you pressed a key to move the character to the right,
    then the velocity vector would be perpendicular to the forward vector. That would
    mean that the angle would be 90º, so that would be our direction.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，您可以看到方向是如何计算的。前向矢量表示角色当前面对的方向，数字表示如果前向矢量指向该方向，则前向矢量将与速度矢量形成的角度。如果角色朝向某个方向，然后按键移动角色向右，那么速度矢量将与前向矢量垂直。这意味着角度将是90º，这将是我们的方向。
- en: If we set up our 2D Blend Space with that logic in mind, we can use the correct
    animation based on the character's movement angle.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们根据这个逻辑设置我们的2D混合空间，我们可以根据角色的移动角度使用正确的动画。
- en: 'The following steps will help you complete the exercise:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成练习：
- en: Create a new `Third Person` template project using `Blueprints` called `Blendspace2D`
    and save it to a location of your choosing.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Blueprints`创建一个名为`Blendspace2D`的新`Third Person`模板项目，并将其保存到您选择的位置。
- en: Once the project has been created, it should open the editor.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目创建后，应该打开编辑器。
- en: Next, you will be importing the movement animations. In the editor, go to the
    `Content\Mannequin\Animations` folder.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您将导入移动动画。在编辑器中，转到`Content\Mannequin\Animations`文件夹。
- en: Click on the `Import` button.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`导入`按钮。
- en: Go to the `Chapter16\Exercise16.04\Assets` folder, select all of the `fbx` files,
    and hit the `Open` button.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入`Chapter16\Exercise16.04\Assets`文件夹，选择所有`fbx`文件，然后点击`打开`按钮。
- en: In the import dialog, make sure you pick the character's skeleton and hit the
    `Import All` button.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导入对话框中，确保选择角色的骨架并点击`Import All`按钮。
- en: Save all of the new files in the `Assets` folder.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存所有新文件到`Assets`文件夹中。
- en: Click on the `Add New` button and pick `Animation -> Blend Space`.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`Add New`按钮并选择`Animation -> Blend Space`。
- en: Next, select the character's skeleton.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择角色的骨架。
- en: Rename the Blend Space `BS_Movement` and open it.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重命名混合空间为`BS_Movement`并打开它。
- en: 'Create the horizontal `Direction` axis `(-180 to 180)` and the vertical `Speed`
    axis `(0 to 800)` as shown in the following figure:![Figure 16.14: 2D Blend Space
    Axis Settings'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建水平`Direction`轴（-180至180）和垂直`Speed`轴（0至800），如下图所示：![图16.14：2D混合空间轴设置
- en: '](img/B16183_16_14.jpg)'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_16_14.jpg)'
- en: 'Figure 16.14: 2D Blend Space Axis Settings'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.14：2D混合空间轴设置
- en: Drag the `Idle_Rifle_Ironsights` animation onto the `5` grid entries where `Speed`
    is `0`.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Idle_Rifle_Ironsights`动画拖到`Speed`为`0`的5个网格条目上。
- en: Drag the `Walk_Fwd_Rifle_Ironsights` animation where `Speed` is `800` and `Direction`
    is `0`.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Walk_Fwd_Rifle_Ironsights`动画拖到`Speed`为`800`，`Direction`为`0`的位置。
- en: Drag the `Walk_Lt_Rifle_Ironsights` animation where `Speed` is `800` and `Direction`
    is `-90`.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Walk_Lt_Rifle_Ironsights`动画拖到`Speed`为`800`，`Direction`为`-90`的位置。
- en: Drag the `Walk_Rt_Rifle_Ironsights` animation where `Speed` is `800` and `Direction`
    is `90`.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Walk_Rt_Rifle_Ironsights`动画拖到`Speed`为`800`，`Direction`为`90`的位置。
- en: You should end up with a Blend Space that can be previewed by holding *Shift*
    and moving the mouse.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该最终得到一个可以通过按住*Shift*并移动鼠标来预览的混合空间。
- en: Now, on the `Asset Details` panel, set the `Target Weight Interpolation Speed
    Per Sec` variable to `5` to make the interpolation smoother.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`Asset Details`面板上，将`Target Weight Interpolation Speed Per Sec`变量设置为`5`，以使插值更加平滑。
- en: Save and close the Blend Space.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭混合空间。
- en: Now, update the animation Blueprint to use the new Blend Space.
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更新动画蓝图以使用新的混合空间。
- en: Go to `Content\Mannequin\Animations` and open the file that comes along with
    the Third Person template – `ThirdPerson_AnimBP`.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`Content\Mannequin\Animations`并打开随Third Person模板一起提供的文件–`ThirdPerson_AnimBP`。
- en: Next, go to the event graph and create a new float variable called `Direction`.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到事件图并创建一个名为`Direction`的新浮点变量。
- en: 'Set the value of `Direction` with the result of the `Calculate Direction` function,
    which calculates the angle (-180º to 180º) between the pawn''s `velocity` and
    `rotation`:![Figure 16.15: Calculating the Speed and Direction to use on the 2D
    Blend Space'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Calculate Direction`函数的结果设置`Direction`的值，该函数计算角度（-180º至180º）在角色的`速度`和`旋转`之间：![图16.15：计算用于2D混合空间的速度和方向
- en: '](img/B16183_16_15.jpg)'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_16_15.jpg)'
- en: 'Figure 16.15: Calculating the Speed and Direction to use on the 2D Blend Space'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.15：计算用于2D混合空间的速度和方向
- en: Note
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/3pAbbAl](https://packt.live/3pAbbAl).'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接找到前面的截图的全分辨率版本以便更好地查看：[https://packt.live/3pAbbAl](https://packt.live/3pAbbAl)。
- en: 'In `AnimGraph`, go to the `Idle/Run` state where the old 1D Blend Space is
    being used, as shown in the following screenshot:![Figure 16.16: Idle/run state
    in the AnimGraph'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AnimGraph`中，转到正在使用旧的1D混合空间的`Idle/Run`状态，如下截图所示：![图16.16：AnimGraph中的空闲/奔跑状态
- en: '](img/B16183_16_16.jpg)'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_16_16.jpg)'
- en: 'Figure 16.16: Idle/run state in the AnimGraph'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.16：AnimGraph中的空闲/奔跑状态
- en: 'Replace that Blend Space with `BS_Movement` and use the `Direction` variable
    like so:![Figure 16.17: 1D Blend Space has been replaced by the new 2D Blend Space'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`BS_Movement`替换该混合空间，并像这样使用`Direction`变量：![图16.17：1D混合空间已被新的2D混合空间替换
- en: '](img/B16183_16_17.jpg)'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_16_17.jpg)'
- en: 'Figure 16.17: 1D Blend Space has been replaced by the new 2D Blend Space'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.17：1D混合空间已被新的2D混合空间替换
- en: Save and close the animation Blueprint. Now you need to update the character.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭动画蓝图。现在您需要更新角色。
- en: Go to the `Content\ThirdPersonBP\Blueprints` folder and open `ThirdPersonCharacter`.
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`Content\ThirdPersonBP\Blueprints`文件夹并打开`ThirdPersonCharacter`。
- en: On the `Details` panel for the character, set `Use Controller Rotation Yaw`
    to `true`, which will make the character's `Yaw` rotation always face the control
    rotation's Yaw.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在角色的`Details`面板上，将`Use Controller Rotation Yaw`设置为`true`，这将使角色的`Yaw`旋转始终面向控制旋转的Yaw。
- en: Go to the character movement component and set `Max Walk Speed` to `800`.
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到角色移动组件并将`Max Walk Speed`设置为`800`。
- en: Set `Orient Rotation to Movement` to `false`, which will prevent the character
    from rotating toward the direction of the movement.
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Orient Rotation to Movement`设置为`false`，这将防止角色朝向移动方向旋转。
- en: Save and close the character Blueprint.
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭角色蓝图。
- en: 'If you play the game now with two clients and move the character, it will walk
    forward and backward, but it will also strafe, as shown in the following screenshot:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在使用两个客户端玩游戏并移动角色，它将向前和向后走，但也会侧移，如下面的截图所示：
- en: '![Figure 16.18: Expected output on the server and Client 1 windows'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.18：服务器和客户端1窗口上的预期输出'
- en: '](img/B16183_16_18.jpg)'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_16_18.jpg)'
- en: 'Figure 16.18: Expected output on the server and Client 1 windows'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.18：服务器和客户端1窗口上的预期输出
- en: By completing this exercise, you will have improved your understanding of how
    to create 2D Blend Spaces, how they work, and the advantages they provide compared
    to just using the regular 1D Blend Space.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，您将提高对如何创建2D混合空间、它们的工作原理以及它们相对于仅使用常规1D混合空间的优势的理解。
- en: In the next section, we will be looking at transforming a character's bone so
    that we can rotate the torso of the player up and down based on the camera's Pitch.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看一下如何转换角色的骨骼，以便根据摄像机的俯仰旋转玩家的躯干上下。
- en: Transform (Modify) Bone
  id: totrans-485
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换（修改）骨骼
- en: Before we move on, there is a very useful node that you can use in the AnimGraph
    called the `Transform (Modify) Bone` node, which allows you to translate, rotate,
    and scale a bone of a skeleton at *runtime*.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，有一个非常有用的节点，您可以在AnimGraph中使用，称为`Transform (Modify) Bone`节点，它允许您在*运行时*转换骨骼的平移、旋转和缩放。
- en: You can add it in the `AnimGraph` by *right-clicking* on an empty space, typing
    `transform modify`, and picking the node from the list. If you click on the `Transform
    (Modify) Bone` node, you'll have quite a few options on the `Details` panel.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过*右键单击*空白处，在`AnimGraph`中添加它，输入`transform modify`，然后从列表中选择节点。如果单击`Transform
    (Modify) Bone`节点，您将在`Details`面板上有相当多的选项。
- en: Here's an explanation of what each option does.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是每个选项的解释。
- en: The `Bone to Modify` option will tell the node what bone is going to be transformed.
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bone to Modify`选项将告诉节点将要变换的骨骼是哪个。'
- en: 'After that option, you have three sections representing each transform operation
    (`Translation`, `Rotation`, and `Scale`). In each section, you can do the following:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在该选项之后，您有三个部分，分别代表每个变换操作（`Translation`，`Rotation`和`Scale`）。在每个部分中，您可以执行以下操作：
- en: '`Translation, Rotation, Scale`: This option will tell the node how much of
    that specific transform operation you want to apply. The final result will depend
    on the mode (*covered in the next section*) you have selected.'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Translation，Rotation，Scale`：此选项将告诉节点您要应用多少特定变换操作。最终结果将取决于您选择的模式（*在下一节中介绍*）。'
- en: 'There are two ways you can set this value:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以设置此值：
- en: Setting a constant value such as (`X=0.0,Y=0.0,Z=0.0`)
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置一个常量值，比如（`X=0.0,Y=0.0,Z=0.0`）
- en: 'Using a variable, so it can be changed at runtime. To enable this, you need
    to take the following steps (this example is for `Rotation`, but the same concepts
    apply for `Translation` and `Scale`):'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个变量，这样它可以在运行时更改。为了实现这一点，您需要采取以下步骤（此示例是为了`Rotation`，但相同的概念也适用于`Translation`和`Scale`）：
- en: 'Click the checkbox next to the constant value and make sure it is checked.
    Once you do that, the text boxes for the constant value will disappear.![Figure
    16.19: Check the checkbox'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击常量值旁边的复选框，并确保它被选中。一旦您这样做了，常量值的文本框将消失。![图16.19：勾选复选框
- en: '](img/B16183_16_19.jpg)'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_16_19.jpg)'
- en: 'Figure 16.19: Check the checkbox'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.19：勾选复选框
- en: '`Transform (Modify) Bone` will add an input so you can plug in your variable:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '`Transform (Modify) Bone`将添加一个输入，这样您就可以插入您的变量：'
- en: '![Figure 16.20: Variable used as an input on the Transform (Modify) Bone node'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.20：变量用作变换（修改）骨骼节点的输入'
- en: '](img/B16183_16_20.jpg)'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_16_20.jpg)'
- en: 'Figure 16.20: Variable used as an input on the Transform (Modify) Bone node'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.20：变量用作变换（修改）骨骼节点的输入
- en: '**Setting the mode**'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置模式**'
- en: 'This will tell the node what to do with the value. You can pick from one of
    these three options:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉节点如何处理该值。您可以从以下三个选项中选择一个：
- en: '`Ignore`: Don''t do anything with the supplied value.'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ignore`：不对提供的值进行任何操作。'
- en: '`Add to Existing`: Grab the current value of the bone and add the supplied
    value to it.'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Add to Existing`：获取骨骼的当前值，并将提供的值添加到其中。'
- en: '`Replace Existing`: Replace the current value of the bone with the supplied value.'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Replace Existing`：用提供的值替换骨骼的当前值。'
- en: '**Setting the space**'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置空间**'
- en: 'This will define the space the node should apply the transform to. You can
    pick from one of these four options:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 这将定义节点应该应用变换的空间。您可以从以下四个选项中选择一个：
- en: '`World Space`: The transform will happen in the world space.'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`World Space`：变换将发生在世界空间中。'
- en: '`Component Space`: The transform will happen in the skeletal mesh component
    space.'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Component Space`：变换将发生在骨骼网格组件空间中。'
- en: '`Parent Bone Space`: The transform will happen in the parent bone''s space
    of the selected bone.'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Parent Bone Space`：变换将发生在所选骨骼的父骨骼空间中。'
- en: '`Bone Space`: The transform will happen in the space of the selected bone.'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bone Space`：变换将发生在所选骨骼的空间中。'
- en: 'Last but not least, you have the `Alpha`, which is a value that allows you
    to control the amount of transform that you want to apply. As an example, if you
    have the `Alpha` value as a float, then you''ll have the following behavior with
    different values:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是`Alpha`，它是一个值，允许您控制要应用的变换量。例如，如果`Alpha`值为浮点数，则不同值将产生以下行为：
- en: If `Alpha` is 0.0, then no transform will be applied.
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`Alpha`为0.0，则不会应用任何变换。
- en: If `Alpha` is 0.5, then it will only apply half of the transform.
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`Alpha`为0.5，则只会应用一半的变换。
- en: If `Alpha` is 1.0, then it will apply the entire transform.
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`Alpha`为1.0，则会应用整个变换。
- en: In the next exercise, we will use the `Transform (Modify) Bone` node to enable
    the character from *Exercise 16.04*, *Creating a Movement 2D Blend Space*, to
    look up and down based on the camera's rotation.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将使用`Transform (Modify) Bone`节点来使角色能够根据摄像机的旋转从*练习16.04*，*创建一个2D混合运动空间*中上下观察。
- en: 'Exercise 16.05: Creating a Character That Looks up and down'
  id: totrans-518
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习16.05：创建一个能够上下观察的角色
- en: In this exercise, we're going to duplicate the project from *Exercise 16.04*,
    *Creating a Movement 2D Blend Space*, and enable the character to look up and
    down based on the camera's rotation. To achieve this, we're going to use the `Transform
    (Modify) Bone` node to rotate the `spine_03` bone in the component space based
    on the Pitch of the camera.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将复制*练习16.04*中的项目，*创建一个2D混合运动空间*，并使角色能够根据摄像机的旋转上下观察。为了实现这一点，我们将使用`Transform
    (Modify) Bone`节点来根据摄像机的俯仰在组件空间中旋转`spine_03`骨骼。
- en: 'The following steps will help you complete the exercise:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成练习：
- en: First, you need to duplicate and rename the project from *Exercise 16.04*, *Creating
    a Movement 2D Blend Space*.
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要复制并重命名*练习16.04*中的项目，*创建一个2D混合运动空间*。
- en: Copy the `Blendspace2D` project folder from *Exercise 16.04*, *Creating a Movement
    2D Blend Space*, paste it in a new folder, and rename it `TransformModifyBone`.
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从*练习16.04*中复制`Blendspace2D`项目文件夹，*创建一个2D混合运动空间*，粘贴到一个新文件夹中，并将其重命名为`TransformModifyBone`。
- en: Open the new project folder, rename the `Blendspace2D.uproject` file `TransformModifyBone.uproject`,
    and open it.
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新的项目文件夹，将`Blendspace2D.uproject`文件重命名为`TransformModifyBone.uproject`，然后打开它。
- en: Next, you will be updating the animation Blueprint.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将更新动画蓝图。
- en: Go to `Content\Mannequin\Animations` and open `ThirdPerson_AnimBP`.
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`Content\Mannequin\Animations`，并打开`ThirdPerson_AnimBP`。
- en: 'Go to the `Event Graph`, create a float variable called `Pitch`, and set it
    with the Pitch of the subtraction (or delta) between the pawn''s rotation and
    the base aim rotation, as shown in the following figure:![Figure 16.21: Calculating
    the Pitch'
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到“事件图”，创建一个名为“俯仰”的浮点变量，并将其设置为pawn旋转和基本瞄准旋转之间的减法（或delta）的俯仰，如下图所示：![图16.21：计算俯仰
- en: '](img/B16183_16_21.jpg)'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_16_21.jpg)'
- en: 'Figure 16.21: Calculating the Pitch'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.21：计算俯仰
- en: As an alternative to using the `Break Rotator` node, you can *right-click* on
    `Return Value` and pick `Split Struct Pin`.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用“分解旋转器”节点的替代方法，您可以*右键单击*“返回值”，然后选择“拆分结构引脚”。
- en: Note
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `Break Rotator` node allows you to separate a `Rotator` variable into three
    float variables that represent the `Pitch`, `Yaw`, and `Roll`. This is useful
    when you want to access the value of each individual component or if you only
    want to work with one or two components, and not with the whole rotation.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: “分解旋转器”节点允许您将“旋转器”变量分解为代表“俯仰”、“偏航”和“翻滚”的三个浮点变量。当您想要访问每个单独组件的值或者只想使用一个或两个组件而不是整个旋转时，这将非常有用。
- en: Take into consideration that the `Split Struct Pin` option will only appear
    if `Return` `Value` is not connected to anything. Once you do the split, it will
    create three separate wires for `Roll`, `Pitch`, and `Yaw`, just like a break
    but without the extra node.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，“拆分结构引脚”选项只会在“返回值”未连接到任何东西时出现。一旦您进行拆分，它将创建三根分开的电线，分别代表“翻滚”、“俯仰”和“偏航”，就像一个分解但没有额外的节点。
- en: 'You should end up with the following:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下结果：
- en: '![Figure 16.22: Calculating the Pitch to look up using the Split Struct Pin
    option'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.22：使用拆分结构引脚选项计算俯仰'
- en: '](img/B16183_16_22.jpg)'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_16_22.jpg)'
- en: 'Figure 16.22: Calculating the Pitch to look up using the Split Struct Pin option'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.22：使用拆分结构引脚选项计算俯仰
- en: 'This logic uses the rotation of the pawn and subtracts it from the camera''s
    rotation to get the difference in `Pitch`, as shown in the following figure:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 这个逻辑使用了pawn的旋转并将其减去摄像机的旋转，以获得“俯仰”的差异，如下图所示：
- en: '![Figure 16.23: How to calculate the Delta Pitch'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.23：如何计算Delta Pitch'
- en: '](img/B16183_16_23.jpg)'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_16_23.jpg)'
- en: 'Figure 16.23: How to calculate the Delta Pitch'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.23：如何计算Delta Pitch
- en: 'Next, go to `AnimGraph` and add a `Transform (Modify) Bone` node with the following
    settings:![Figure 16.24: Settings for the Transform (Modify) Bone node'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到“AnimGraph”并添加一个带有以下设置的“变换（修改）骨骼”节点：![图16.24：变换（修改）骨骼节点的设置
- en: '](img/B16183_16_24.jpg)'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_16_24.jpg)'
- en: 'Figure 16.24: Settings for the Transform (Modify) Bone node'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.24：变换（修改）骨骼节点的设置
- en: In the preceding screenshot, we've set `Bone to Modify` to `spine_03` because
    that is the bone that we want to rotate. We've also set `Rotation Mode` to `Add
    to Existing` because we want to keep the original rotation from the animation
    and add an offset to it. The rest of the options need to have their default value.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们将“要修改的骨骼”设置为“spine_03”，因为这是我们想要旋转的骨骼。我们还将“旋转模式”设置为“添加到现有”，因为我们希望保留动画中的原始旋转并添加偏移量。其余选项需要保持默认值。
- en: 'Connect the `Transform (Modify) Bone` node to the `State Machine` and the `Output
    Pose`, as shown in the following screenshot:![Figure 16.25: Transform (Modify)
    Bone connected to the Output Pose'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“变换（修改）骨骼”节点连接到“状态机”和“输出姿势”，如下截图所示：![图16.25：变换（修改）骨骼连接到输出姿势
- en: '](img/B16183_16_25.jpg)'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_16_25.jpg)'
- en: 'Figure 16.25: Transform (Modify) Bone connected to the Output Pose'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.25：变换（修改）骨骼连接到输出姿势
- en: In the preceding figure, you see the full `AnimGraph`, which will allow the
    character to look up and down by rotating the `spine_03` bone based on the camera
    Pitch. The `State Machine` will be the starting point, and from there, it will
    need to be converted into component space in order to be able to use the `Transform
    (Modify) Bone` node, which will connect to the `Output Pose` node after being
    converted back to local space.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，您可以看到完整的“AnimGraph”，它将允许角色通过旋转“spine_03”骨骼来上下查看，基于摄像机的俯仰。 “状态机”将是起点，从那里，它将需要转换为组件空间，以便能够使用“变换（修改）骨骼”节点，然后连接到“输出姿势”节点，再转换回本地空间。
- en: Note
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The reason why we connect `Pitch` variable to the `Roll` is that the bone in
    the skeleton is internally rotated that way. You can use the `Split Struct Pin`
    on input parameters as well, so you don't have to add a `Make Rotator` node.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将“俯仰”变量连接到“翻滚”的原因是骨骼在骨架内部是以这种方式旋转的。您也可以在输入参数上使用“拆分结构引脚”，这样您就不必添加“制作旋转器”节点。
- en: 'If you test the project with two clients and move the mouse *up* and *down*
    on one of the characters, you''ll notice that it will Pitch up and down, as shown
    in the following screenshot:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用两个客户端测试项目，并在其中一个角色上*向上*和*向下*移动鼠标，您会注意到它会上下俯仰，如下截图所示：
- en: '![Figure 16.26: Character mesh pitching up and down, based on the camera rotation'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.26：根据摄像机旋转使角色网格上下俯仰'
- en: '](img/B16183_16_26.jpg)'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_16_26.jpg)'
- en: 'Figure 16.26: Character mesh pitching up and down, based on the camera rotation'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.26：根据摄像机旋转使角色网格上下俯仰
- en: By completing this final exercise, you'll have an understanding of how to modify
    bones at runtime by using the `Transform (Modify) Bone` node in an animation blueprint.
    This node can be used in various scenarios, so it might prove really useful for
    you.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个最终练习，您将了解如何在动画蓝图中使用“变换（修改）骨骼”节点在运行时修改骨骼。这个节点可以在各种场景中使用，所以对您可能非常有用。
- en: In the next activity, you're going to put everything you've learned to the test
    by creating the character we're going to use for our multiplayer FPS project.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个活动中，您将通过创建我们将在多人FPS项目中使用的角色来将您学到的一切付诸实践。
- en: 'Activity 16.01: Creating a Character for the Multiplayer FPS Project'
  id: totrans-557
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动16.01：为多人FPS项目创建角色
- en: 'In this activity, you''ll create the character for the multiplayer FPS project
    that we''re going to build in the next few chapters. The character will have a
    few different mechanics, but for this activity, you just need to create a character
    that walks, jumps, looks up/down, and has two replicated stats: health and armor.'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 在此活动中，您将为我们在接下来的几章中构建的多人FPS项目创建角色。 角色将具有一些不同的机制，但是对于此活动，您只需要创建一个可以行走，跳跃，上下查看并具有两个复制的统计数据：生命值和护甲的角色。
- en: 'The following steps will help you complete the activity:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此活动：
- en: Create a `Blank C++` project called `MultiplayerFPS` without the starter content.
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`MultiplayerFPS`的`Blank C++`项目，不包含起始内容。
- en: Import the skeletal mesh and the animations from the `Activity16.01\Assets folder`
    and place them in the `Content\Player\Mesh` and `Content\Player\Animations` folders
    respectively.
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Activity16.01\Assets`文件夹导入骨骼网格和动画，并将它们分别放置在`Content\Player\Mesh`和`Content\Player\Animations`文件夹中。
- en: 'Import the following sounds from the `Activity16.01\Assets` folder to `Content\Player\Sounds`:'
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Activity16.01\Assets`文件夹导入以下声音到`Content\Player\Sounds`：
- en: '`Jump.wav`: Play this sound on the `Jump_From_Stand_Ironsights` animation with
    a `Play Sound` anim notify.'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Jump.wav`：在`Jump_From_Stand_Ironsights`动画上使用`Play Sound`动画通知播放此声音。'
- en: '`Footstep.wav`: Play this sound every time a foot is on the floor in every
    walk animation by using the `Play Sound` anim notify.'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Footstep.wav`：通过使用`Play Sound`动画通知，在每次行走动画中脚踩在地板上时播放此声音。'
- en: '`Spawn.wav`: Use this on the `SpawnSound` variable in the character.'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Spawn.wav`：在角色的`SpawnSound`变量上使用此音频。'
- en: Set up the skeletal mesh by retargeting its bones and creating a socket called
    `Camera` that is a child of the head bone and has a Relative Location of (`X=7.88,
    Y=4.73, Z=-10.00`).
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过重新定位其骨骼并创建一个名为`Camera`的插座来设置骨骼网格，该插座是头骨的子级，并具有相对位置（*X=7.88, Y=4.73, Z=-10.00*）。
- en: Create a 2D Blend Space in `Content\Player\Animations` called `BS_Movement`
    that uses the imported movement animations and a `Target Weight Interpolation
    Speed Per Sec` of `5`.
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content\Player\Animations`中创建一个名为`BS_Movement`的2D混合空间，该空间使用导入的移动动画和`Target
    Weight Interpolation Speed Per Sec`为`5`。
- en: 'Create the input mappings in the `Project Settings`, using the knowledge acquired
    in *Chapter 4*, *Player Input*:'
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Project Settings`中创建输入映射，使用*第4章*中获得的知识，*Player Input*：
- en: Jump (action mapping) – *Spacebar*
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳跃（动作映射）- *空格键*
- en: Move Forward (axis mapping) – *W* (scale `1.0`) and *S* (scale `-1.0`)
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向前移动（轴映射）- *W*（比例`1.0`）和*S*（比例`-1.0`）
- en: Move Right (axis mapping) – *A* (scale `-1.0`) and *D* (scale `1.0`)
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向右移动（轴映射）- *A*（比例`-1.0`）和*D*（比例`1.0`）
- en: Turn (axis mapping) – Mouse *X* (scale `1.0`)
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转向（轴映射）- 鼠标*X*（比例`1.0`）
- en: Look Up (axis mapping) – Mouse *Y* (scale `-1.0`)
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向上查看（轴映射）- 鼠标*Y*（比例`-1.0`）
- en: 'Create a C++ class called `FPSCharacter` that does the following:'
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`FPSCharacter`的C++类，执行以下操作：
- en: Derives from the `Character` class.
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 派生自`Character`类。
- en: Has a camera component attached to the skeletal mesh on the `Camera` socket
    and has `pawn control rotation` set to `true`.
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Camera`插座上附加到骨骼网格上的摄像头组件，并将`pawn control rotation`设置为`true`。
- en: Has variables for `health` and `armor` that only replicate to the owner.
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有仅复制到所有者的`health`和`armor`变量。
- en: Has variables for the maximum `health` and `armor`, as well as the percentage
    of how much damage the armor absorbs.
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有最大`health`和`armor`的变量，以及护甲吸收多少伤害的百分比。
- en: Has a constructor that initializes the camera, disables ticking, and sets `Max
    Walk Speed` to `800` and `Jump Z Velocity` to `600`.
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有初始化摄像头，禁用打勾，并将`Max Walk Speed`设置为`800`和`Jump Z Velocity`设置为`600`的构造函数。
- en: On `BeginPlay`, plays the spawning sound and initializes the `health` with `max
    health` if it has authority.
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`BeginPlay`中，播放生成声音并在具有权限时初始化`health`为`max health`。
- en: Creates and binds the functions to handle the input actions and axis.
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建并绑定处理输入动作和轴的功能。
- en: Has functions to add/remove/set health. It also ensures the situation where
    the character is dead.
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有添加/删除/设置生命值的功能。 还确保角色死亡的情况。
- en: 'Has functions to add/set/absorb armor. The armor absorption reduces the armor
    based on the `ArmorAbsorption` variable and changes the damage value based on
    the formula:'
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有添加/设置/吸收护甲的功能。护甲吸收根据`ArmorAbsorption`变量减少护甲，并根据以下公式更改伤害值：
- en: '*Damage = (Damage * (1 - ArmorAbsorption)) - FMath::Min(RemainingArmor, 0);*'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '*Damage = (Damage * (1 - ArmorAbsorption)) - FMath::Min(RemainingArmor, 0);*'
- en: 'Create an animation Blueprint in `Content\Player\Animations` called `ABP_Player`
    that has a `State Machine` with the following states:'
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content\Player\Animations`中创建名为`ABP_Player`的动画蓝图，其中包含以下状态的`State Machine`：
- en: '`Idle/Run`: Uses `BS_Movement` with the `Speed` and `Direction` variables'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Idle/Run`：使用具有`Speed`和`Direction`变量的`BS_Movement`'
- en: '`Jump`: Plays the jump animation and transitions from the `Idle/Run` states
    when the `Is Jumping` variable is `true`'
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Jump`：当`Is Jumping`变量为`true`时，播放跳跃动画并从`Idle/Run`状态转换'
- en: It also uses `Transform (Modify) Bone` to make the character Pitch up and down
    based on the camera's Pitch.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 它还使用`Transform (Modify) Bone`根据相机的Pitch使角色上下俯仰。
- en: 'Create a `UMG` widget in `Content\UI` called `UI_HUD` that displays the `Health`
    and `Armor` of the character in the format `Health: 100` and `Armor: 100`, using
    the knowledge acquired in *Chapter 15*, *Collectibles, Power-ups, and Pickups*.'
  id: totrans-589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在`Content\UI`中创建一个名为`UI_HUD`的`UMG`小部件，以`Health: 100`和`Armor: 100`的格式显示角色的`Health`和`Armor`，使用*第15章*中获得的知识，*Collectibles,
    Power-ups, and Pickups*。'
- en: 'Create a Blueprint in `Content\Player` called `BP_Player` that derives from
    `FPSCharacter` and set up the mesh component to have the following values:'
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content\Player`中创建一个名为`BP_Player`的蓝图，该蓝图派生自`FPSCharacter`，并设置网格组件具有以下值：
- en: Use the `SK_Mannequin` skeletal mesh
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`SK_Mannequin`骨骼网格
- en: Use the `ABP_Player` animation Blueprint
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ABP_Player`动画蓝图
- en: Set `Location` to be equal to (*X=0.0, Y=0.0, Z=-88.0*)
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`Location`设置为(*X=0.0, Y=0.0, Z=-88.0*)
- en: Set `Rotation` to be equal to (*X=0.0, Y=0.0, Z=-90.0*)
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`Rotation`设置为(*X=0.0, Y=0.0, Z=-90.0*)
- en: Also, on the `Begin Play` event, it needs to create a widget instance of `UI_HUD`
    and add it to the viewport.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在`Begin Play`事件中，需要创建`UI_HUD`的小部件实例并将其添加到视口中。
- en: Create a Blueprint in `Content\Blueprints` called `BP_GameMode` that derives
    from `MultiplayerFPSGameModeBase`, which will use `BP_Player` as the `DefaultPawn`
    class.
  id: totrans-596
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content\Blueprints`中创建一个名为`BP_GameMode`的蓝图，它派生自`MultiplayerFPSGameModeBase`，并将`BP_Player`作为`DefaultPawn`类使用。
- en: Create a test map in `Content\Maps` called `DM-Test` and set it as the default
    map in `Project Settings`.
  id: totrans-597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content\Maps`中创建一个名为`DM-Test`的测试地图，并将其设置为`Project Settings`中的默认地图。
- en: 'Expected output:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出：
- en: The result should be a project where each client will have a first-person character
    that can move, jump, and look around. These actions will also be replicated, so
    each client will be able to see what the other client's character is doing.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该是一个项目，每个客户端都有一个第一人称角色，可以移动、跳跃和四处张望。这些动作也将被复制，因此每个客户端都能看到其他客户端角色正在做什么。
- en: Each client will also have a HUD that displays the health and the armor value.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 每个客户端还将拥有一个显示健康和护甲值的HUD。
- en: '![Figure 16.27: Expected output'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.27：预期输出'
- en: '](img/B16183_16_27.jpg)'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_16_27.jpg)'
- en: 'Figure 16.27: Expected output'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.27：预期输出
- en: Note
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在以下链接找到：[https://packt.live/338jEBx](https://packt.live/338jEBx)。
- en: The end result should be two characters that can see each other moving, jumping,
    and looking around. Each client also displays its character's health and armor
    value.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果应该是两个角色可以看到彼此移动、跳跃和四处张望。每个客户端还会显示其角色的健康和护甲值。
- en: By completing this activity, you should have a good idea of how the server-client
    architecture, variable replication, roles, 2D Blend Spaces, and the `Transform
    (Modify) Bone` node work.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成此活动，您应该对服务器-客户端架构、变量复制、角色、2D混合空间和“变换（修改）骨骼”节点的工作原理有一个很好的了解。
- en: Summary
  id: totrans-608
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned about some critical multiplayer concepts, such
    as how the server-client architecture works, the responsibilities of the server
    and the client, how the listen server is quicker to set up than the dedicated
    server but not as lightweight, ownership and connections, roles, and variable
    replication.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了一些关键的多人游戏概念，比如服务器-客户端架构的工作原理，服务器和客户端的责任，监听服务器设置比专用服务器快但不够轻量级，所有权和连接，角色和变量复制。
- en: We've also learned some useful techniques for animation, such as how to use
    2D Blend Spaces, which allow you to have a two-axis grid to blend between animations,
    and the Transform (Modify) Bone node, which has the ability to modify the bones
    of a skeletal mesh at runtime. To finish off the chapter, we created a first-person
    multiplayer project where you have characters that can walk, look, and jump around,
    which will be the foundation of the multiplayer first-person shooter project that
    we will be working on for the next few chapters.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了一些有用的动画技巧，比如如何使用2D混合空间，这允许您在两轴网格之间混合动画，以及变换（修改）骨骼节点，它具有在运行时修改骨骼的能力。最后，我们创建了一个第一人称多人游戏项目，其中您可以让角色行走、观看和跳跃，这将是我们在接下来的几章中将要开发的多人第一人称射击项目的基础。
- en: In the next chapter, we'll learn how to use RPCs, which allow clients and servers
    to execute functions on each other. We'll also cover how to use enumerations in
    the editor and how to use bi-directional circular array indexing, which allows
    you to cycle forward and backward through an array and loop back when it's outside
    the limits.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用RPCs，这允许客户端和服务器在彼此上执行函数。我们还将介绍如何在编辑器中使用枚举以及如何使用双向循环数组索引，这允许您在数组中向前和向后循环，并在超出限制时循环回来。
