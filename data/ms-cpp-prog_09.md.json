["```cpp\n#include <iostream>\n#include <vector>\n#include <iterator>\n#include <algorithm>\nusing namespace std; //Use this judiciously - this is applicable throughout the book\n\nclass MyInteger {\n      private:\n           int number;\n\n      public:\n           MyInteger( int value ) {\n                this->number = value;\n           }\n\n           MyInteger(const MyInteger & rhsObject ) {\n                this->number = rhsObject.number;\n           }\n\n           MyInteger& operator = (const MyInteger & rhsObject ) {\n\n                if ( this != &rhsObject )\n                     this->number = rhsObject.number;\n\n                return *this;\n           }\n\n           bool operator < (const MyInteger &rhsObject) {\n                return this->number > rhsObject.number;\n           }\n\n           bool operator > (const MyInteger &rhsObject) {\n                return this->number > rhsObject.number;\n           }\n\n           friend ostream & operator << ( ostream &output, const MyInteger &object );\n};\n\nostream & operator << (ostream &o, const MyInteger& object) {\n    o << object.number;\n}\n\nint main ( ) {\n\n    vector<MyInteger> v = { 10, 100, 40, 20, 80, 70, 50, 30, 60, 90 };\n\n    cout << \"\\nVectors entries before sorting are ...\" << endl;\n    copy ( v.begin(), v.end() , ostream_iterator<MyInteger>( cout, \"\\t\" ) );\n    cout << endl;\n\n    sort ( v.begin(), v.end() );\n\n    cout << \"\\nVectors entries after sorting are ...\" << endl;\n    copy ( v.begin(), v.end() , ostream_iterator<MyInteger>( cout, \"\\t\" ) );\n    cout << endl;\n\n    return 0;\n}\n```", "```cpp\nVectors entries before sorting are ...\n10 100 40 20 80 70 50 30 60 90\n\nVectors entries after sorting are ...\n100 90 80 70 60 50 40 30 20 10\n```", "```cpp\nVectors entries before sorting are ...\n10 100 40 20 80 70 50 30 60 90\n\nVectors entries after sorting are ...\n10 20 30 40 50 60 70 80 90 100\n```", "```cpp\ng++ main.cpp -std=c++17 -g\n```", "```cpp\ngdb ./a.out\n```", "```cpp\njegan@ubuntu:~/MasteringC++Programming/Debugging/Ex1$ g++ main.cpp -g\njegan@ubuntu:~/MasteringC++Programming/Debugging/Ex1$ ls\na.out main.cpp\njegan@ubuntu:~/MasteringC++Programming/Debugging/Ex1$ gdb ./a.out\n\nGNU gdb (Ubuntu 7.12.50.20170314-0ubuntu1.1) 7.12.50.20170314-git\nCopyright (C) 2017 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law. Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n<http://www.gnu.org/software/gdb/documentation/>.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from ./a.out...done.\n(gdb) b main\nBreakpoint 1 at 0xba4: file main.cpp, line 46.\n(gdb) l\n32 \n33 bool operator > (const MyInteger &rhsObject) {\n34 return this->number < rhsObject.number;\n35 }\n36 \n37 friend ostream& operator << ( ostream &output, const MyInteger &object );\n38 \n39 };\n40 \n41 ostream& operator << (ostream &o, const MyInteger& object) {\n(gdb)\n```", "```cpp\n(gdb) run\nStarting program: /home/jegan/MasteringC++Programming/Debugging/Ex1/a.out \n\nBreakpoint 1, main () at main.cpp:46\n46 int main ( ) {\n(gdb) \n```", "```cpp\n(gdb) run\nStarting program: /home/jegan/MasteringC++Programming/Debugging/Ex1/a.out \n\nBreakpoint 1, main () at main.cpp:46\n46 int main ( ) {\n(gdb) next\n48   vector<MyInteger> v = { 10, 100, 40, 20, 80, 70, 50, 30, 60, 90 };\n(gdb) next\n50   cout << \"\\nVectors entries before sorting are ...\" << endl;\n(gdb) n\nVectors entries before sorting are ...51   copy ( v.begin(), v.end() , ostream_iterator<MyInteger>( cout, \"\\t\" ) );\n(gdb) n\n52   cout << endl;\n(gdb) n\n10 100 40 20 80 70 50 30 60 90 \n54   sort ( v.begin(), v.end() );\n(gdb) \n```", "```cpp\nBreakpoint 1 at 0xba4: file main.cpp, line 46.Breakpoint 1 at 0xba4: file main.cpp, line 46.(gdb) run\nStarting program: /home/jegan/Downloads/MasteringC++Programming/Debugging/Ex1/a.out \nBreakpoint 1, main () at main.cpp:46\n46 int main ( ) {\n(gdb) l\n41 ostream& operator << (ostream &o, const MyInteger& object) {\n42    o << object.number;\n43 }\n44 \n45 \n46 \nint main ( ) {\n47 \n48   vector<MyInteger> v = { 10, 100, 40, 20, 80, 70, 50, 30, 60, 90 };\n49    \n50   cout << \"\\nVectors entries before sorting are ...\" << endl;\n(gdb) n\n48   vector<MyInteger> v = { 10, 100, 40, 20, 80, 70, 50, 30, 60, 90 };\n(gdb) n\n50   cout << \"\\nVectors entries before sorting are ...\" << endl;\n(gdb) n\nVectors entries before sorting are ...\n51   copy ( v.begin(), v.end() , ostream_iterator<MyInteger>( cout, \"\\t\" ) );\n(gdb) break 29\nBreakpoint 2 at 0x555555554f88: file main.cpp, line 29.\n(gdb) break 33\nBreakpoint 3 at 0x555555554b80: file main.cpp, line 33.\n(gdb) \n```", "```cpp\n(gdb) break 29\nBreakpoint 2 at 0x555555554f88: file main.cpp, line 29.\n(gdb) break 33\nBreakpoint 3 at 0x555555554b80: file main.cpp, line 33.\n(gdb) continue Continuing.\nBreakpoint 2, MyInteger::operator< (this=0x55555576bc24, rhsObject=...) at main.cpp:30 30 return this->number > rhsObject.number; (gdb) \n```", "```cpp\n(gdb) break 29\nBreakpoint 2 at 0x400ec6: file main.cpp, line 29.\n(gdb) break 33\nBreakpoint 3 at 0x400af6: file main.cpp, line 33.\n(gdb) continue\nContinuing.\nBreakpoint 2, MyInteger::operator< (this=0x617c24, rhsObject=...) at main.cpp:30\n30 return this->number > rhsObject.number;\n(gdb) print this->number $1 = 100 (gdb) print rhsObject.number $2 = 10 (gdb) \n```", "```cpp\nbool operator < ( const MyInteger &rhsObject ) {\n        return this->number > rhsObject.number;\n}\n\nbool operator > ( const MyInteger &rhsObject ) {\n        return this->number < rhsObject.number;\n}\n```", "```cpp\nbool operator < ( const MyInteger &rhsObject ) {\n        return this->number < rhsObject.number;\n}\n\nbool operator > ( const MyInteger &rhsObject ) {\n        return this->number > rhsObject.number;\n}\n```", "```cpp\ng++ main.cpp -std=c++17 -g\n\n./a.out\n```", "```cpp\nVectors entries before sorting are ...\n10   100   40   20   80   70   50   30   60   90\n\nVectors entries after sorting are ...\n10   20   30   40   50   60   70   80   90   100\n```", "```cpp\n#include <iostream>\nusing namespace std;\n\nint main ( ) {\n    int a[10];\n\n    a[10] = 100;\n    cout << a[10] << endl;\n\n    return 0;\n}\n```", "```cpp\ng++ arrayboundsoverrun.cpp -g -std=c++17 \n\njegan@ubuntu  ~/MasteringC++/Debugging  valgrind --track-origins=yes --read-var-info=yes ./a.out\n==28576== Memcheck, a memory error detector\n==28576== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.\n==28576== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info\n==28576== Command: ./a.out\n==28576== \n100\n*** stack smashing detected ***: ./a.out terminated\n==28576== \n==28576== Process terminating with default action of signal 6 (SIGABRT)\n==28576== at 0x51F1428: raise (raise.c:54)\n==28576== by 0x51F3029: abort (abort.c:89)\n==28576== by 0x52337E9: __libc_message (libc_fatal.c:175)\n==28576== by 0x52D511B: __fortify_fail (fortify_fail.c:37)\n==28576== by 0x52D50BF: __stack_chk_fail (stack_chk_fail.c:28)\n==28576== by 0x4008D8: main (arrayboundsoverrun.cpp:11)\n==28576== \n==28576== HEAP SUMMARY:\n==28576== in use at exit: 72,704 bytes in 1 blocks\n==28576== total heap usage: 2 allocs, 1 frees, 73,728 bytes allocated\n==28576== \n==28576== LEAK SUMMARY:\n==28576== definitely lost: 0 bytes in 0 blocks\n==28576== indirectly lost: 0 bytes in 0 blocks\n==28576== possibly lost: 0 bytes in 0 blocks\n==28576== still reachable: 72,704 bytes in 1 blocks\n==28576== suppressed: 0 bytes in 0 blocks\n==28576== Rerun with --leak-check=full to see details of leaked memory\n==28576== \n==28576== For counts of detected and suppressed errors, rerun with: -v\n==28576== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\n[1] 28576 abort (core dumped) valgrind --track-origins=yes --read-var-info=yes ./a.out\n```", "```cpp\n#include <iostream>\nusing namespace std;\n\nint main( ) {\n\n    int *ptr = new int();\n\n    *ptr = 100;\n\n    cout << \"\\nValue stored at pointer location is \" << *ptr << endl;\n\n    delete ptr;\n\n    *ptr = 200;\n    return 0;\n}\n```", "```cpp\n==118316== Memcheck, a memory error detector\n==118316== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.\n==118316== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info\n==118316== Command: ./a.out\n==118316== \n\nValue stored at pointer location is 100\n==118316== Invalid write of size 4\n==118316== at 0x400989: main (illegalaccess_to_released_memory.cpp:14)\n==118316== Address 0x5ab6c80 is 0 bytes inside a block of size 4 free'd\n==118316== at 0x4C2F24B: operator delete(void*) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==118316== by 0x400984: main (illegalaccess_to_released_memory.cpp:12)\n==118316== Block was alloc'd at\n==118316== at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==118316== by 0x400938: main (illegalaccess_to_released_memory.cpp:6)\n==118316== \n==118316== \n==118316== HEAP SUMMARY:\n==118316== in use at exit: 72,704 bytes in 1 blocks\n==118316== total heap usage: 3 allocs, 2 frees, 73,732 bytes allocated\n==118316== \n==118316== LEAK SUMMARY:\n==118316== definitely lost: 0 bytes in 0 blocks\n==118316== indirectly lost: 0 bytes in 0 blocks\n==118316== possibly lost: 0 bytes in 0 blocks\n==118316== still reachable: 72,704 bytes in 1 blocks\n==118316== suppressed: 0 bytes in 0 blocks\n==118316== Rerun with --leak-check=full to see details of leaked memory\n==118316== \n==118316== For counts of detected and suppressed errors, rerun with: -v\n==118316== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)\n```", "```cpp\n#include <iostream>\nusing namespace std;\n\nclass MyClass {\n    private:\n       int x;\n    public:\n      MyClass( );\n  void print( );\n}; \n\nMyClass::MyClass() {\n    cout << \"\\nMyClass constructor ...\" << endl;\n}\n\nvoid MyClass::print( ) {\n     cout << \"\\nValue of x is \" << x << endl;\n}\n\nint main ( ) {\n\n    MyClass obj;\n    obj.print();\n    return 0;\n\n}\n```", "```cpp\ng++ main.cpp -g\n\nvalgrind ./a.out --track-origins=yes\n\n==51504== Memcheck, a memory error detector\n==51504== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.\n==51504== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info\n==51504== Command: ./a.out --track-origins=yes\n==51504== \n\nMyClass constructor ...\n\n==51504== Conditional jump or move depends on uninitialised value(s)\n==51504== at 0x4F3CCAE: std::ostreambuf_iterator<char, std::char_traits<char> > std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::_M_insert_int<long>(std::ostreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, char, long) const (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21)\n==51504== by 0x4F3CEDC: std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::do_put(std::ostreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, char, long) const (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21)\n==51504== by 0x4F493F9: std::ostream& std::ostream::_M_insert<long>(long) (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21)\n==51504== by 0x40095D: MyClass::print() (uninitialized.cpp:19)\n==51504== by 0x4009A1: main (uninitialized.cpp:26)\n==51504== \n==51504== Use of uninitialised value of size 8\n==51504== at 0x4F3BB13: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21)\n==51504== by 0x4F3CCD9: std::ostreambuf_iterator<char, std::char_traits<char> > std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::_M_insert_int<long>(std::ostreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, char, long) const (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21)\n==51504== by 0x4F3CEDC: std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::do_put(std::ostreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, char, long) const (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21)\n==51504== by 0x4F493F9: std::ostream& std::ostream::_M_insert<long>(long) (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21)\n==51504== by 0x40095D: MyClass::print() (uninitialized.cpp:19)\n==51504== by 0x4009A1: main (uninitialized.cpp:26)\n==51504== \n==51504== Conditional jump or move depends on uninitialised value(s)\n==51504== at 0x4F3BB1F: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21)\n==51504== by 0x4F3CCD9: std::ostreambuf_iterator<char, std::char_traits<char> > std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::_M_insert_int<long>(std::ostreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, char, long) const (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21)\n==51504== by 0x4F3CEDC: std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::do_put(std::ostreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, char, long) const (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21)\n==51504== by 0x4F493F9: std::ostream& std::ostream::_M_insert<long>(long) (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21)\n==51504== by 0x40095D: MyClass::print() (uninitialized.cpp:19)\n==51504== by 0x4009A1: main (uninitialized.cpp:26)\n==51504== \n==51504== Conditional jump or move depends on uninitialised value(s)\n==51504== at 0x4F3CD0C: std::ostreambuf_iterator<char, std::char_traits<char> > std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::_M_insert_int<long>(std::ostreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, char, long) const (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21)\n==51504== by 0x4F3CEDC: std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::do_put(std::ostreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, char, long) const (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21)\n==51504== by 0x4F493F9: std::ostream& std::ostream::_M_insert<long>(long) (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21)\n==51504== by 0x40095D: MyClass::print() (uninitialized.cpp:19)\n==51504== by 0x4009A1: main (uninitialized.cpp:26)\n==51504== \nValue of x is -16778960\n==51504== \n==51504== HEAP SUMMARY:\n==51504== in use at exit: 72,704 bytes in 1 blocks\n==51504== total heap usage: 2 allocs, 1 frees, 73,728 bytes allocated\n==51504== \n==51504== LEAK SUMMARY:\n==51504== definitely lost: 0 bytes in 0 blocks\n==51504== indirectly lost: 0 bytes in 0 blocks\n==51504== possibly lost: 0 bytes in 0 blocks\n==51504== still reachable: 72,704 bytes in 1 blocks\n==51504== suppressed: 0 bytes in 0 blocks\n==51504== Rerun with --leak-check=full to see details of leaked memory\n==51504== \n==51504== For counts of detected and suppressed errors, rerun with: -v\n==51504== Use --track-origins=yes to see where uninitialised values come from\n==51504== ERROR SUMMARY: 18 errors from 4 contexts (suppressed: 0 from 0)\n\n```", "```cpp\n==51504== by 0x40095D: MyClass::print() (uninitialized.cpp:19)\n==51504== by 0x4009A1: main (uninitialized.cpp:26)\n\n 18 void MyClass::print() {\n 19 cout << \"\\nValue of x is \" << x << endl;\n 20 } \n```", "```cpp\nvalgrind application_debugged.exe --tool=memcheck\n```", "```cpp\n#include <iostream>\nusing namespace std;\n\nstruct Node {\n  int data;\n  Node *next;\n};\n\nclass List {\nprivate:\n  Node *pNewNode;\n  Node *pHead;\n  Node *pTail;\n  int __size;\n  void createNewNode( int );\npublic:\n  List();\n  ~List();\n  int size();\n  void append ( int data );\n  void print( );\n};\n```", "```cpp\n#include \"list.h\"\n\nList::List( ) {\n  pNewNode = NULL;\n  pHead = NULL;\n  pTail = NULL;\n  __size = 0;\n}\n\nList::~List() {}\n\nvoid List::createNewNode( int data ) {\n  pNewNode = new Node();\n  pNewNode->next = NULL;\n  pNewNode->data = data;\n}\n\nvoid List::append( int data ) {\n  createNewNode( data );\n  if ( pHead == NULL ) {\n    pHead = pNewNode;\n    pTail = pNewNode;\n    __size = 1;\n  }\n  else {\n    Node *pCurrentNode = pHead;\n    while ( pCurrentNode != NULL ) {\n      if ( pCurrentNode->next == NULL ) break;\n      pCurrentNode = pCurrentNode->next;\n    }\n\n    pCurrentNode->next = pNewNode;\n    ++__size;\n  }\n}\n\nvoid List::print( ) {\n  cout << \"\\nList entries are ...\" << endl;\n  Node *pCurrentNode = pHead;\n  while ( pCurrentNode != NULL ) {\n    cout << pCurrentNode->data << \"\\t\";\n    pCurrentNode = pCurrentNode->next;\n  }\n  cout << endl;\n}\n```", "```cpp\n#include \"list.h\"\n\nint main ( ) {\n  List l;\n\n  for (int count = 0; count < 5; ++count )\n    l.append ( (count+1) * 10 );\n  l.print();\n\n  return 0;\n}\n```", "```cpp\ng++ main.cpp list.cpp -std=c++17 -g\n\nvalgrind ./a.out --leak-check=full \n\n==99789== Memcheck, a memory error detector\n==99789== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.\n==99789== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info\n==99789== Command: ./a.out --leak-check=full\n==99789== \n\nList constructor invoked ...\n\nList entries are ...\n10 20 30 40 50 \n==99789== \n==99789== HEAP SUMMARY:\n==99789== in use at exit: 72,784 bytes in 6 blocks\n==99789== total heap usage: 7 allocs, 1 frees, 73,808 bytes allocated\n==99789== \n==99789== LEAK SUMMARY:\n==99789== definitely lost: 16 bytes in 1 blocks\n==99789== indirectly lost: 64 bytes in 4 blocks\n==99789== possibly lost: 0 bytes in 0 blocks\n==99789== still reachable: 72,704 bytes in 1 blocks\n==99789== suppressed: 0 bytes in 0 blocks\n==99789== Rerun with --leak-check=full to see details of leaked memory\n==99789== \n==99789== For counts of detected and suppressed errors, rerun with: -v\n==99789== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\n\n```", "```cpp\nList::~List( ) {\n\n        cout << \"\\nList destructor invoked ...\" << endl;\n        Node *pTemp = NULL;\n\n        while ( pHead != NULL ) {\n\n                pTemp = pHead;\n                pHead = pHead->next;\n\n                delete pTemp;\n        }\n\n        pNewNode = pHead = pTail = pTemp = NULL;\n        __size = 0;\n\n}\n```", "```cpp\ng++ main.cpp list.cpp -std=c++17 -g\n\nvalgrind ./a.out --leak-check=full\n\n==44813== Memcheck, a memory error detector\n==44813== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.\n==44813== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info\n==44813== Command: ./a.out --leak-check=full\n==44813== \n\nList constructor invoked ...\n\nList entries are ...\n10 20 30 40 50 \nMemory utilised by the list is 80\n\nList destructor invoked ...\n==44813== \n==44813== HEAP SUMMARY:\n==44813== in use at exit: 72,704 bytes in 1 blocks\n==44813== total heap usage: 7 allocs, 6 frees, 73,808 bytes allocated\n==44813== \n==44813== LEAK SUMMARY:\n==44813== definitely lost: 0 bytes in 0 blocks\n==44813== indirectly lost: 0 bytes in 0 blocks\n==44813== possibly lost: 0 bytes in 0 blocks\n==44813== still reachable: 72,704 bytes in 1 blocks\n==44813== suppressed: 0 bytes in 0 blocks\n==44813== Rerun with --leak-check=full to see details of leaked memory\n==44813== \n==44813== For counts of detected and suppressed errors, rerun with: -v\n==44813== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\n\n```", "```cpp\n#include <iostream>\nusing namespace std;\n\nint main ( ) {\n\n    return 0;\n\n} \n```", "```cpp\ng++ simple.cpp -std=c++17 -g\n\nvalgrind ./a.out --leak-check=full\n\n==62474== Memcheck, a memory error detector\n==62474== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.\n==62474== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info\n==62474== Command: ./a.out --leak-check=full\n==62474== \n==62474== \n==62474== HEAP SUMMARY:\n==62474== in use at exit: 72,704 bytes in 1 blocks\n==62474== total heap usage: 1 allocs, 0 frees, 72,704 bytes allocated\n==62474== \n==62474== LEAK SUMMARY:\n==62474== definitely lost: 0 bytes in 0 blocks\n==62474== indirectly lost: 0 bytes in 0 blocks\n==62474== possibly lost: 0 bytes in 0 blocks\n==62474== still reachable: 72,704 bytes in 1 blocks\n==62474== suppressed: 0 bytes in 0 blocks\n==62474== Rerun with --leak-check=full to see details of leaked memory\n==62474== \n==62474== For counts of detected and suppressed errors, rerun with: -v\n==62474== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\n\n```", "```cpp\n#include <stdlib.h>\n\nint main ( ) {\n\n        int *ptr = new int();\n\n        free (ptr); // The correct approach is delete ptr\n\n        char *c = (char*)malloc ( sizeof(char) );\n\n        delete c; // The correct approach is free ( c )\n\n        return 0;\n}\n```", "```cpp\ng++ mismatchingnewandfree.cpp -g\n\nvalgrind ./a.out \n==76087== Memcheck, a memory error detector\n==76087== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.\n==76087== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info\n==76087== Command: ./a.out\n==76087== \n==76087== Mismatched free() / delete / delete []\n==76087== at 0x4C2EDEB: free (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==76087== by 0x4006FD: main (mismatchingnewandfree.cpp:7)\n==76087== Address 0x5ab6c80 is 0 bytes inside a block of size 4 alloc'd\n==76087== at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==76087== by 0x4006E7: main (mismatchingnewandfree.cpp:5)\n==76087== \n==76087== Mismatched free() / delete / delete []\n==76087== at 0x4C2F24B: operator delete(void*) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==76087== by 0x400717: main (mismatchingnewandfree.cpp:11)\n==76087== Address 0x5ab6cd0 is 0 bytes inside a block of size 1 alloc'd\n==76087== at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==76087== by 0x400707: main (mismatchingnewandfree.cpp:9)\n==76087== \n==76087== \n==76087== HEAP SUMMARY:\n==76087== in use at exit: 72,704 bytes in 1 blocks\n==76087== total heap usage: 3 allocs, 2 frees, 72,709 bytes allocated\n==76087== \n==76087== LEAK SUMMARY:\n==76087== definitely lost: 0 bytes in 0 blocks\n==76087== indirectly lost: 0 bytes in 0 blocks\n==76087== possibly lost: 0 bytes in 0 blocks\n==76087== still reachable: 72,704 bytes in 1 blocks\n==76087== suppressed: 0 bytes in 0 blocks\n==76087== Rerun with --leak-check=full to see details of leaked memory\n==76087== \n==76087== For counts of detected and suppressed errors, rerun with: -v\n==76087== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)\n```"]