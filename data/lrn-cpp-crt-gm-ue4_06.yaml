- en: Chapter 6. Objects, Classes, and Inheritance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章：对象、类和继承
- en: In the previous chapter, we discussed functions as a way to bundle up a bunch
    of lines of related code. We talked about how functions abstracted away implementation
    details and how the `sqrt()` function does not require you to understand how it
    works internally to use it to find roots. This was a good thing, primarily because
    it saved the programmer time and effort, while making the actual work of finding
    square roots easier. This principle of *abstraction* will come up again here when
    we discuss objects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了函数作为一种将相关代码行捆绑在一起的方式。我们讨论了函数如何抽象实现细节，以及 `sqrt()` 函数不需要你了解其内部工作原理即可使用它来找到根。这是一件好事，主要是因为它节省了程序员的精力和时间，同时使寻找平方根的实际工作变得更容易。当我们讨论对象时，这个
    *抽象* 原理将再次出现。
- en: In a nutshell, objects tie together methods and their related data into a single
    structure. This structure is called a *class*. The main idea of using objects
    is to create a code representation for every thing inside your game. Every object
    represented in the code will have data and associated functions that operate on
    that data. So you'd have an *object* to represent your player instance and related
    functions that make the player `jump()`, `shoot()`, and `pickupItem()` functions.
    You'd also have an object to represent every monster instance and related functions
    such as `growl()`, `attack()`, and possibly `follow()`.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，对象将方法和相关数据绑定到一个单一的结构中。这个结构被称为 *类*。使用对象的主要思想是为游戏中的每个事物创建一个代码表示。代码中表示的每个对象都将有数据和相关的函数来操作这些数据。因此，你会有一个
    *对象* 来表示玩家实例以及相关的函数，如 `jump()`、`shoot()` 和 `pickupItem()`。你也会有一个对象来表示每个怪物实例以及相关的函数，如
    `growl()`、`attack()` 和可能还有 `follow()`。
- en: Objects are types of variables, though, and objects will stay in memory as long
    as you keep them there. You create an object instance once when the thing in your
    game it represents is created, and you destroy the object instance when the thing
    in your game it represents dies.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对象是变量的一种类型，并且只要你在那里保持它们，对象就会留在内存中。当你创建代表游戏中的事物的对象实例时，你将创建一个对象实例，当你代表游戏中的事物死亡时，你将销毁对象实例。
- en: Objects can be used to represent in-game things, but they can also be used to
    represent any other type of thing. For example, you can store an image as an object.
    The data fields will be the image's width of the image, its height, and the collection
    of pixels inside it. C++ strings are also objects.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对象可以用来表示游戏中的事物，但它们也可以用来表示任何其他类型的事物。例如，你可以将一个图像存储为对象。数据字段将包括图像的宽度、高度以及其中的像素集合。C++
    字符串也是对象。
- en: Tip
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: This chapter contains a lot of keywords that might be difficult to grasp at
    first, including `virtual` and `abstract`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含许多可能一开始难以理解的关键词，包括 `virtual` 和 `abstract`。
- en: Don't let the more difficult sections of this chapter bog you down. I included
    descriptions of many advanced concepts for completeness. However, bear in mind
    that you don't need to completely understand everything in this chapter to write
    working C++ code in UE4\. It helps to understand it, but if something doesn't
    make sense, don't get stuck. Give it a read and then move on. Probably what will
    happen is you will not get it at first, but remember a reference to the concept
    in question when you're coding. Then, when you open this book up again, "voilà!"
    It will make sense.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 不要让本章更难的部分让你感到困惑。我为了完整性而包括了众多高级概念的描述。然而，请记住，你不需要完全理解本章中的所有内容就能在 UE4 中编写有效的 C++
    代码。理解它是有帮助的，但如果某些内容让你感到困惑，不要陷入困境。阅读它，然后继续前进。可能的情况是，你一开始可能不会理解，但记住在编码时对相关概念的参考。然后，当你再次打开这本书时，“哇！”它就会变得有意义。
- en: struct objects
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体对象
- en: 'An object in C++ is basically any variable type that is made up of a conglomerate
    of simpler types. The most basic object in C++ is `struct`. We use the `struct`
    keyword to glue together a bunch of smaller variables into one big variable. If
    you recall, we did introduce `struct` briefly in [Chapter 2](part0022_split_000.html#KVCC2-dd4a3f777fc247568443d5ffb917736d
    "Chapter 2. Variables and Memory"), *Variables and Memory*. Let''s revise that
    simple example:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，对象基本上是由更简单的类型组成的复合类型。C++ 中最基本的对象是 `struct`。我们使用 `struct` 关键字将许多较小的变量粘合在一起形成一个大的变量。如果你还记得，我们在
    [第二章](part0022_split_000.html#KVCC2-dd4a3f777fc247568443d5ffb917736d "第二章。变量和内存")
    中简要介绍了 `struct`，*变量和内存*。让我们回顾一下这个简单的例子：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is the structure definition for what makes a `Player` object. The player
    has a `string` for his `name` and an integer for his `hp` value.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Player`对象的结构定义。玩家有一个`string`类型的`name`和一个表示`hp`值的整数。
- en: 'If you''ll recall from [Chapter 2](part0022_split_000.html#KVCC2-dd4a3f777fc247568443d5ffb917736d
    "Chapter 2. Variables and Memory"), *Variables and Memory*, the way we make an
    instance of the `Player` object is like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得[第2章](part0022_split_000.html#KVCC2-dd4a3f777fc247568443d5ffb917736d "第2章。变量和内存")中的内容，即*变量和内存*，我们创建`Player`对象实例的方式是这样的：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'From here, we can access the fields of the `me` object like so:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以这样访问`me`对象的字段：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Member functions
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成员函数
- en: Now, here's the exciting part. We can attach member functions to the `struct`
    definition simply by writing these functions inside the `struct Player` definition.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里是激动人心的部分。我们可以通过在`struct Player`定义内部编写这些函数来将成员函数附加到`struct`定义上。
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A member function is just a C++ function that is declared inside a `struct`
    or `class` definition. Isn't that a great idea?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 成员函数就是一个在`struct`或`class`定义内部声明的C++函数。这不是一个好主意吗？
- en: There is a bit of a funny idea here, so I'll just come out and say it. The variables
    of `struct Player` are accessible to all the functions inside `struct Player`.
    Inside each of the member functions of `struct Player`, we can actually access
    the `name` and `hp` variables as if they were local to the function. In other
    words, the `name` and `hp` variables of `struct Player` are shared between all
    the member functions of `struct Player`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有点奇怪的想法，所以我就直接说出来吧。`struct Player`的变量对所有`struct Player`内部的函数都是可访问的。在`struct
    Player`的每个成员函数内部，我们实际上可以像访问局部变量一样访问`name`和`hp`变量。换句话说，`struct Player`的`name`和`hp`变量在`struct
    Player`的所有成员函数之间是共享的。
- en: The this keyword
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`this`关键字'
- en: 'In some C++ code (in later chapters), you will see more references to the `this`
    keyword. The `this` keyword is a pointer that refers to the current object. Inside
    the `Player::damage()` function, for example, we can write our reference to `this`
    explicitly:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些C++代码（在后面的章节中），你会看到更多对`this`关键字的引用。`this`关键字是一个指向当前对象的指针。例如，在`Player::damage()`函数内部，我们可以明确写出对`this`的引用：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `this` keyword only makes sense inside a member function. We could explicitly
    include use of keyword `this` inside member functions, but without writing `this`,
    it is implied that we are talking about the `hp` of the current object.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`关键字仅在成员函数内部有意义。我们可以在成员函数中明确包含`this`关键字的用法，但如果没有写`this`，则默认我们谈论的是当前对象的`hp`。'
- en: Strings are objects?
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串是对象吗？
- en: Yes! Every time you've used a string variable in the past, you were using an
    object. Let's try out some of the member functions of the `string` class.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！每次你使用字符串变量时，你都是在使用一个对象。让我们尝试一下`string`类的成员函数。
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What we've done here is use the `append()` member function to add on two extra
    characters to the end of the string (`!!`). Member functions always apply to the
    object that calls the member function (the object to the left of the dot).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是使用`append()`成员函数在字符串的末尾添加两个额外的字符（`!!`）。成员函数始终应用于调用成员函数的对象（点左侧的对象）。
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To see the listing of members and member functions available on an object, type
    the object's variable name in Visual Studio, then a dot (`.`), then press *Ctrl*
    and spacebar. A member listing will pop up.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看对象上可用的成员和成员函数列表，请在Visual Studio中输入对象的变量名，然后输入一个点（`.`），然后按*Ctrl*和空格键。成员列表将弹出。
- en: '![Strings are objects?](img/00060.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![字符串是对象吗？](img/00060.jpeg)'
- en: Pressing *Ctrl* and spacebar will make the member listing appear
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*Ctrl*和空格键将显示成员列表。
- en: Invoking a member function
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用成员函数
- en: 'Member functions can be invoked with the following syntax:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 成员函数可以使用以下语法调用：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The object invoking the member function is on the left of the dot. The member
    function to call is on the right of the dot. A member function invocation is always
    followed by round brackets `()`, even when no arguments are passed to the brackets.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 调用成员函数的对象位于点的左侧。要调用的成员函数位于点的右侧。成员函数调用始终后跟圆括号`()`，即使没有传递参数给括号。
- en: 'So, in the part of the program where the monster attacks, we can reduce the
    player''s `hp` value like so:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在程序中怪物攻击的部分，我们可以这样减少玩家的`hp`值：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Which isn''t that more readable than the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是比以下内容更易读吗？
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When member functions and objects are used effectively, your code will read
    more like prose or poetry than a bunch of operator symbols slammed together.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当成员函数和对象被有效使用时，你的代码将读起来更像散文或诗歌，而不是一堆操作符的组合。
- en: Besides beauty and readability, what is the point of writing member functions?
    Outside the `Player` object, we can now do more with a single line of code than
    just reduce the `hp` member by `15`. We can also do other things as we're reducing
    the player's `hp`, such as take into account the player's armor, check whether
    the player is invulnerable, or have other effects occur when the player is damaged.
    What happens when the player is damaged should be abstracted away by the `damage()`
    function.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了美观和可读性之外，编写成员函数的目的是什么？现在，在`Player`对象外部，我们只用一行代码就可以做更多的事情，而不仅仅是减少`hp`成员`15`。我们还可以在减少玩家的`hp`时做其他事情，比如考虑玩家的护甲，检查玩家是否无敌，或者当玩家受伤时产生其他效果。当玩家受伤时应该由`damage()`函数来抽象处理。
- en: 'Now think if the player had an armor class. Let''s add a field to `struct Player`
    for armor class:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想想如果玩家有一个护甲等级。让我们给`struct Player`添加一个护甲等级字段：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We''d need to reduce the damage received by the player by the armor class of
    the player. So we''d type a formula now to reduce `hp`. We can do it the non-object-oriented
    way by accessing the data fields of the `player` object directly:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要通过玩家的护甲等级来减少玩家收到的伤害。所以现在我们可以输入一个公式来减少`hp`。我们可以通过直接访问`player`对象的数据字段来实现非面向对象的方式：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Otherwise, we can do it the object-oriented way by writing a member function
    that changes the data members of the `player` object as needed. Inside the `Player`
    object, we can write a member function `damage()`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们可以通过编写一个成员函数来改变`player`对象的数据成员，以实现面向对象的方式。在`Player`对象内部，我们可以编写一个成员函数`damage()`：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Exercises
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: 'There is a subtle bug in the player''s `damage` function in the preceding code.
    Can you find and fix it? Hint: What happens if the damage dealt is less than `armorClass`
    of the player?'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的代码中，玩家的`damage`函数中有一个微小的错误。你能找到并修复它吗？提示：如果造成的伤害小于玩家的`armorClass`，会发生什么？
- en: Having only a number for armor class doesn't give enough information about the
    armor! What is the armor's name? What does it look like? Devise a `struct` function
    for the Player's armor with fields for name, armor class, and durability rating.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有一个护甲等级的数字并不能提供足够的关于护甲的信息！护甲的名字是什么？它看起来像什么？为玩家的护甲设计一个`struct`函数，包含名称、护甲等级和耐久性评分字段。
- en: Solutions
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: The solution is in the `struct` player code listed in the next section, *Privates
    and encapsulation*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案在下一节中列出的`struct`玩家代码中，*私有和封装*。
- en: 'How about using the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码如何？
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'An instance of `Armor` will then be placed inside `struct Player`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct Player`中将会放置一个`Armor`实例：'
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This means the player has an armor. Keep this in mind—we'll explore `has-a`
    versus `is-a` relationships later.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着玩家有护甲。请记住这一点——我们将在以后探讨`has-a`与`is-a`关系。
- en: Privates and encapsulation
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 私有和封装
- en: So now we've defined a couple of member functions, whose purpose it is to modify
    and maintain the data members of our `Player` object, but some people have come
    up with an argument.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在已经定义了一些成员函数，其目的是修改和维护我们的`Player`对象的数据成员，但有些人提出了一个论点。
- en: 'The argument is as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 论点如下：
- en: An object's data members should only ever be accessed only through its member
    functions, never directly.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个对象的数据成员应该只通过其成员函数访问，永远不要直接访问。
- en: 'This means that you should never access an object''s data members from outside
    the object directly, in other words, modify the player''s `hp` directly:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你不应该直接从对象外部访问对象的数据成员，换句话说，直接修改玩家的`hp`：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This should be forbidden, and users of the class should be forced to use the
    proper member functions instead to change the values of data members:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该被禁止，并且应该强制类用户使用适当的成员函数来更改数据成员的值：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This principle is called *encapsulation*. Encapsulation is the concept that
    every object should be interacted via its member functions only. Encapsulation
    says that raw data members should never be accessed directly.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则被称为*封装*。封装的概念是每个对象都应该只通过其成员函数进行交互。封装表示原始数据成员不应直接访问。
- en: 'The reasons behind encapsulation are:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 封装背后的原因如下：
- en: '**To make the class self contained**: The primary idea behind encapsulation
    is that objects work best when they are programmed such that they manage and maintain
    their own internal state variables without a need for code outside the class to
    examine that class'' private data. When objects are coded this way, it makes the
    object much easier to work with, that is, easier to read and maintain. To make
    the player object jump, you should just have to call `player.jump()`; let the
    player object manage state changes to its `y-height` position (making the player
    jump!). When an object''s internal members are not exposed, interacting with that
    object is much easier and more efficient. Interact only with an object''s public
    member functions; let the object manage its internal state (we will explain the
    keywords `private` and `public` in a moment).'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为了使类自包含**：封装背后的主要思想是，当对象以这种方式编程时，它们工作得最好，即它们可以管理和维护自己的内部状态变量，而无需类外部的代码检查该类的私有数据。当对象以这种方式编码时，会使对象更容易处理，也就是说，更容易阅读和维护。要使玩家对象跳跃，你只需调用`player.jump()`；让玩家对象管理其`y-height`位置的状态变化（使玩家跳跃！）当对象的内部成员没有暴露时，与该对象的交互会更加容易和高效。仅与对象的公共成员函数交互；让对象管理其内部状态（我们将在稍后解释`private`和`public`关键字）。 '
- en: '**To avoid breaking code**: When code outside of a class interacts with that
    class'' public member functions only (the class'' public interface), then an object''s
    internal state management is free to change, without breaking any of the calling
    code. This way, if an object''s internal data members change for any reason, all
    code using the object still remains valid as long as the member functions remain
    the same.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为了避免破坏代码**：当类外部的代码仅与该类的公共成员函数交互（类的公共接口）时，对象的内部状态管理可以自由更改，而不会破坏任何调用代码。这样，如果对象的内部数据成员因任何原因而更改，只要成员函数保持不变，所有使用该对象的代码仍然有效。'
- en: So how can we prevent the programmer from doing the wrong thing and accessing
    data members directly? C++ introduces the concept of *access modifiers* to prevent
    access of an object's internal data.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何防止程序员犯错误并直接访问数据成员呢？C++引入了*访问修饰符*的概念，以防止访问对象的内部数据。
- en: Here is how we'd use access modifiers to forbid access to certain sections of
    `struct Player` from outside of `struct Player`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何使用访问修饰符来禁止从`struct Player`外部访问`struct Player`的某些部分。
- en: 'The first thing you''d do is decide which sections of the `struct` definition
    you want to be accessible outside of the class. These section will be labelled
    `public`. All other regions that will not be accessible outside of `struct` will
    be labelled `private`, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先需要决定你希望从类外部访问的`struct`定义的哪些部分。这些部分将被标记为`public`。所有其他将不会从`struct`外部访问的区域将被标记为`private`，如下所示：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Some people like it public
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有些人喜欢将其设置为`public`
- en: Some people do unabashedly use `public` data members and do not encapsulate
    their objects. This is a matter of preference, though considered as bad object-oriented
    programming practice.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人会毫不犹豫地使用`public`数据成员，并且不封装他们的对象。尽管这被视为不良的面向对象编程实践，但这仍然是一个个人喜好问题。
- en: However, classes in UE4 do use `public` members sometimes. It's a judgment call;
    whether a data member should be `public` or `private` is really up to the programmer.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，UE4中的类有时确实会使用`public`成员。这是一个判断问题；数据成员应该是`public`还是`private`完全取决于程序员。
- en: With experience, you will find that sometimes you get into a situation that
    requires quite a bit of refactoring when you make a data member `public` that
    should have been `private`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 随着经验的积累，你会发现，当你将应该为`private`的数据成员设置为`public`时，有时你会陷入需要大量重构的情况。
- en: class versus struct
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类与结构体
- en: 'You might have seen a different way of declaring an object, using the `class`
    keyword, instead of `struct`, as shown in the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经看到了另一种声明对象的方法，使用`class`关键字而不是`struct`，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `class` and `struct` keywords in C++ are almost identical. There is only
    one difference between `class` and `struct`, and it is that the data members inside
    a `struct` keyword will be declared `public` by default, while in a `class` keyword
    the data members inside the class will be declared `private` by default. (This
    is why I introduced objects using `struct`; I didn't want to put `public` inexplicably
    as the first line of `class`.)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 'C++中的`class`和`struct`关键字几乎相同。`class`和`struct`之间只有一个区别，那就是在`struct`关键字内部的数据成员默认会被声明为`public`，而在`class`关键字中，类内部的数据成员默认会被声明为`private`。（这就是为什么我使用`struct`来引入对象；我不想在`class`的第一行无解释地放置`public`。） '
- en: In general, `struct` is preferred for simple types that don't use encapsulation,
    don't have many member functions, and must be backward compatible with C. Classes
    are used almost everywhere else.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于简单类型，不使用封装，没有很多成员函数，并且必须与C语言向后兼容的情况，我们更倾向于使用`struct`。类几乎在其他所有地方都被使用。
- en: From now on, let's use the `class` keyword instead of `struct`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，让我们使用`class`关键字而不是`struct`。
- en: Getters and setters
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取器和设置器
- en: You might have noticed that once we slap `private` onto the `Player` class definition,
    we can no longer read or write the name of the player from outside the `Player`
    class.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，一旦我们将`private`添加到`Player`类定义中，我们就不能再从`Player`类外部读取或写入玩家的名称。
- en: 'If we try and read the name with the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用以下代码读取名称：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Or write to the name, as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 或者按照以下方式写入名称：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Using the `struct Player` definition with `private` members, we will get the
    following error:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有`private`成员的`struct Player`定义，我们将得到以下错误：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is just what we asked for when we labeled the `name` field `private`. We
    made it completely inaccessible outside the `Player` class.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们当我们将`name`字段标记为`private`时所期望的。我们使其在`Player`类外部完全不可访问。
- en: Getters
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取器
- en: 'A getter (also known as an accessor function) is used to pass back copies of
    internal data members to the caller. To read the player''s name, we''d deck out
    the `Player` class with a member function specifically to retrieve a copy of that
    `private` data member:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 获取器（也称为访问器函数）用于将内部数据成员的副本传递给调用者。为了读取玩家的名称，我们需要在`Player`类中添加一个特定的成员函数来检索该`private`数据成员的副本：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'So now it is possible to read the player''s name information. We can do this
    by using the following code statement:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在可以读取玩家的名称信息。我们可以通过以下代码语句来实现：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Getters are used to retrieve `private` members that would otherwise be inaccessible
    to you from outside the class.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 获取器用于检索那些从类外部无法访问的`private`成员。
- en: Tip
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Real world tip–Keyword const**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**实际技巧–const关键字**'
- en: 'Inside a class, you can add the `const` keyword to a member function declaration.
    What the `const` keyword does is promises to the compiler that the internal state
    of the object will not change as a result of running this function. Attaching
    the `const` keyword will look something like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在类内部，你可以在成员函数声明中添加`const`关键字。`const`关键字的作用是向编译器承诺，运行此函数后对象的内部状态不会改变。添加`const`关键字的样子如下：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: No assignments to data members can happen inside a member function that is marked
    `const`. As the internal state of the object is guaranteed not to change as a
    result of running a `const` function, the compiler can make some optimizations
    around function calls to `const` member functions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在标记为`const`的成员函数内部不能对数据成员进行赋值。由于对象的内部状态在运行`const`函数后保证不会改变，编译器可以在函数调用`const`成员函数时进行一些优化。
- en: Setters
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置器
- en: 'A setter (also known as a modifier function or mutator function) is a member
    function whose sole purpose is to change the value of an internal variable inside
    the class, as shown in the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 设置器（也称为修改器函数或突变函数）是一个成员函数，其唯一目的是更改类内部内部变量的值，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: So we can still change the `private` function of a `class` from outside the
    `class` function, but only if we do so through a setter function.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们仍然可以通过设置器函数从类外部更改`class`的`private`函数，但只能通过这种方式。
- en: But what's the point of get/set operations?
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 但获取/设置操作的意义何在？
- en: So the first question that crosses a newbie programmer's mind when he first
    encounters get/set operations on `private` members is, isn't get/set self-defeating?
    I mean, what's the point in hiding access to data members when we're just going
    to expose that same data again in another way? It's like saying, "You can't have
    any chocolates because they are private, unless you say please `getMeTheChocolate()`.
    Then, you can have the chocolates."
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，当新手程序员第一次遇到对 `private` 成员进行获取/设置操作时，他们首先想到的问题是不是获取/设置自我矛盾？我的意思是，当我们打算以另一种方式再次暴露相同的数据时，隐藏对数据成员的访问有什么意义？这就像说，“你不能有任何巧克力，因为它们是私有的，除非你说请
    `getMeTheChocolate()`。然后，你就可以有巧克力了。”
- en: 'Some expert programmers even shorten the get/set functions to one liners, like
    this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一些经验丰富的程序员甚至将获取/设置函数缩短为一行，如下所示：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let's answer the question. Doesn't a get/set pair break encapsulation by exposing
    the data completely?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来回答这个问题。一个获取/设置对不是通过完全暴露数据来破坏封装性吗？
- en: The answer is twofold. First, get member functions typically only return a copy
    of the data member being accessed. This means that the original data member's
    value remains protected and is not modifiable through a `get()` operation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 答案有两个方面。首先，获取成员函数通常只返回被访问的数据成员的副本。这意味着原始数据成员的值仍然受到保护，并且不能通过 `get()` 操作进行修改。
- en: '`Set()` (mutator method) operations are a little bit counterintuitive though.
    If the setter is a `passthru` operation, such as `void setName( string newName
    ) { name=newName; }`, then having the setter might seem pointless. What is the
    advantage of using a mutator method instead of overwriting the variable directly?'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set()`（变更器方法）操作有点反直觉。如果设置器是一个 `passthru` 操作，例如 `void setName( string newName
    ) { name=newName; }`，那么拥有设置器可能看起来没有意义。使用变更器方法而不是直接覆盖变量有什么优势？'
- en: 'The argument for using mutator methods is to write additional code before the
    assignment of a variable to guard the variable from taking on incorrect values.
    Say, for example, we have a setter for the `hp` data member, which will look like
    this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用变更器方法的论点是，在变量赋值之前编写额外的代码来保护变量免受错误值的侵害。比如说，我们有一个 `hp` 数据成员的设置器，它看起来可能像这样：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The mutator method is supposed to prevent the internal `hp` data member from
    taking on negative values. You might consider mutator methods a bit retroactive.
    Should the responsibility lie with the calling code to check the value it is setting
    before calling `setHp( -2 )`, and not let that only get caught in the mutator
    method? Can't you use a `public` member variable and put the responsibility for
    making sure the variable doesn't take on invalid values in the calling code, instead
    of in the setter? You can.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 变更器方法旨在防止内部 `hp` 数据成员取负值。你可能认为变更器方法有点事后诸葛亮。责任应该由调用代码在调用 `setHp( -2 )` 之前检查它设置的值，而不是只在变更器方法中捕获这个问题吗？你不能使用一个
    `public` 成员变量，并将确保变量不取无效值的责任放在调用代码中，而不是在设置器中吗？你可以。
- en: However, this is the core of the reason behind using mutator methods. The idea
    behind mutator methods is so that the calling code can pass any value it wants
    to the `setHp` function (for example, `setHp( -2 )`), without having to worry
    whether the value it is passing to the function is valid or not. The `setHp` function
    then takes the responsibility of ensuring that the value is valid for the `hp`
    variable.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这正是使用变更器方法的核心原因。变更器方法背后的想法是，调用代码可以将任何它想要的值传递给 `setHp` 函数（例如，`setHp( -2 )`），而不必担心它传递给函数的值是否有效。然后
    `setHp` 函数负责确保该值对 `hp` 变量有效。
- en: Some programmers consider direct mutator functions such as `getHp()`/`setHp()`
    a code smell. A code smell is in general a bad programming practice that people
    don't overtly take notice of, except for a niggling feeling that something is
    being done suboptimally. They argue that higher-level member functions can be
    written instead of mutators. For example, instead of a `setHp()` member function,
    we should have `public` member functions such as `heal()` and `damage()` instead.
    An article on this topic is available at [http://c2.com/cgi/wiki?AccessorsAreEvil](http://c2.com/cgi/wiki?AccessorsAreEvil).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员认为直接变更函数，如 `getHp()`/`setHp()`，是一种代码恶臭。一般来说，代码恶臭是一种不良的编程实践，人们并没有明显注意到，除了有一种感觉，觉得某些事情做得不够优化。他们认为可以编写高级成员函数来代替变更器。例如，我们不应该有
    `setHp()` 成员函数，而应该有 `public` 成员函数，如 `heal()` 和 `damage()`。关于这个话题的文章可在 [http://c2.com/cgi/wiki?AccessorsAreEvil](http://c2.com/cgi/wiki?AccessorsAreEvil)
    查阅。
- en: Constructors and destructors
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数和析构函数
- en: 'The constructor in your C++ code is a simple little function that runs once
    when the C++ object is first created. The destructor runs once when the C++ object
    is destroyed. Say we have the following program:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的C++代码中，构造函数是一个简单的函数，当C++对象首次创建时运行一次。析构函数在C++对象被销毁时运行一次。比如说我们有以下程序：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'So here we have created a `Player` object. The output of this code will be
    as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在这里创建了一个`Player`对象。这段代码的输出将如下所示：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The first thing that happens during object construction is that the constructor
    actually runs. This prints the line `Player object constructed`. Following this,
    the line with the player''s name gets printed: `Player named ''Diplo''`. Why is
    the player named *Diplo*? Because that is the name assigned in the `Player()`
    constructor.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对象构造过程中发生的第一件事是构造函数实际上运行了。这会打印出`Player object constructed`这一行。随后，会打印出带有玩家名字的行：`Player
    named 'Diplo'`。为什么玩家名字叫*Diplo*？因为这是在`Player()`构造函数中分配的名字。
- en: Finally, at the end of the program, the player destructor gets called, and we
    see `Player object destroyed`. The player object gets destroyed when it goes out
    of scope at the end of `main()` (at `}` of `main`).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在程序结束时，调用玩家析构函数，我们看到`Player object destroyed`。当玩家对象在`main()`函数的末尾（在`main`的`}`处）超出作用域时，玩家对象被销毁。
- en: 'So what are constructors and destructors good for? Exactly what they appear
    to be for: setting up and tearing down of an object. The constructor can be used
    for initialization of data fields and the destructor to call delete on any dynamically
    allocated resources (we haven''t covered dynamically allocated resources yet,
    so don''t worry about this last point yet).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，构造函数和析构函数有什么好处？它们看起来就是用来：设置和销毁对象。构造函数可以用来初始化数据字段，析构函数可以用来删除任何动态分配的资源（我们还没有涉及动态分配的资源，所以现在不用担心这个最后一点）。
- en: Class inheritance
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类继承
- en: You use inheritance when you want to create a new, more functional class of
    code, based on some existing class of code. Inheritance is a tricky topic to cover.
    Let's start with the concept of a *derived class* (or subclass).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想基于某个现有的代码类创建一个新的、功能更强大的代码类时，你会使用继承。继承是一个复杂的话题。让我们从*派生类*（或子类）的概念开始。
- en: Derived classes
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 派生类
- en: 'The most natural way to consider inheritance is by analogy with the animal
    kingdom. The classification of living things is shown in the following screenshot:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑继承最自然的方式是通过类比动物王国。以下截图显示了生物的分类：
- en: '![Derived classes](img/00061.jpeg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![派生类](img/00061.jpeg)'
- en: What this diagram means is that **Dog**, **Cat**, **Horse** **,** and **Human**
    are all **Mammals**. What that means is that dog, cat, horse, and human all share
    some common characteristics, such as having common organs (brain with neocortex,
    lungs, liver, and uterus in females), while being completely different in other
    regard. How each walks is different. How each talks is also different.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表示的意思是**狗**、**猫**、**马**、**人**都是**哺乳动物**。这意味着狗、猫、马和人都有一些共同的特征，例如有共同的器官（大脑有新皮层、肺、肝脏和女性的子宫），但在其他方面完全不同。它们走路的方式不同。它们说话的方式也不同。
- en: What does that mean if you were coding creatures? You would only have to program
    the common functionality once. Then, you would implement the code for the different
    parts specifically for each of the dog, cat, horse and human classes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在编写生物的代码，你只需要编写一次共同的功能。然后，你会为狗、猫、马和人这些类分别实现不同部分的代码。
- en: 'A concrete example of the preceding figure is as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示的一个具体例子如下：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: All of `Dog`, `Cat`, and `Human` inherit from `class Mammal`. This means that
    dog, cat, and human are mammals, and many more.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的`Dog`、`Cat`和`Human`都从`class Mammal`继承。这意味着狗、猫和人是哺乳动物，还有更多。
- en: Syntax of inheritance
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继承的语法
- en: 'The syntax of inheritance is quite simple. Let''s take the `Human` class definition
    as an example. The following screenshot is a typical inheritance statement:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 继承的语法相当简单。让我们以`Human`类定义为例。以下截图是一个典型的继承语句：
- en: '![Syntax of inheritance](img/00062.jpeg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![继承的语法](img/00062.jpeg)'
- en: The class on the left of the colon (**:**) is the new, derived class, and the
    class on the right of the colon is the base class.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号（**:**）左边的类是新派生类，冒号右边的类是基类。
- en: What does inheritance do?
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继承有什么作用？
- en: The point of inheritance is for the derived class to take on all the characteristics
    (data members, member functions) of the base class, and then to extend it with
    even more functionality. For instance, all mammals have a `breathe()` function.
    By inheriting from the `Mammal` class, the `Dog`, `Cat`, and `Human` classes all
    automatically gain the ability to `breathe()`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 继承的目的是让派生类承担基类的所有特性（数据成员、成员函数），然后在此基础上扩展更多的功能。例如，所有哺乳动物都有一个`breathe()`函数。通过从`Mammal`类继承，`Dog`、`Cat`和`Human`类都自动获得了`breathe()`的能力。
- en: Inheritance reduces replication of code since we don't have to re-implement
    common functionalities (such as `.breathe()`) for `Dog`, `Cat`, and `Human`. Instead,
    each of these derived classes enjoys the reuse of the `breathe()` function defined
    in `class Mammal`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 继承减少了代码的重复，因为我们不需要为`Dog`、`Cat`和`Human`重新实现常见功能（如`.breathe()`）。相反，这些派生类都享受了在`class
    Mammal`中定义的`breathe()`函数的重用。
- en: However, only the `Human` class has the `attack()`member function. This would
    mean that, in our code, only the `Human` class attacks. The `cat.attack()` function
    will introduce a compiler error, unless you write a member function `attack()`
    inside `class Cat` (or in `class Mammal`).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，只有`Human`类有`attack()`成员函数。这意味着在我们的代码中，只有`Human`类会攻击。除非你在`class Cat`（或`class
    Mammal`）内部编写一个成员函数`attack()`，否则`cat.attack()`函数将引入编译器错误。
- en: is-a relationship
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: is-a关系
- en: Inheritance is often said to be an `is-a` relationship. When a `Human` class
    inherits from `Mammal` class, then we say that human *is-a* mammal.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 继承通常被说成是`is-a`关系。当一个`Human`类从`Mammal`类继承时，我们说人类*是*哺乳动物。
- en: '![is-a relationship](img/00063.jpeg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![is-a关系](img/00063.jpeg)'
- en: The Human inherits all the traits a Mammal has
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 人类继承了哺乳动物的所有特征
- en: 'For example, a `Human` object contains a `Mammal` function inside it, as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个`Human`对象在其内部包含一个`Mammal`函数，如下所示：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this example, we would say the human *has-a* `Mammal` on it somewhere (which
    would make sense if the human were pregnant, or somehow carrying a mammal).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以说人类*有一个*`Mammal`在其某个地方（如果人类怀孕或以某种方式携带哺乳动物，这将是合理的）。
- en: '![is-a relationship](img/00064.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![is-a关系](img/00064.jpeg)'
- en: This Human class instance has some kind of mammal attached in it
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个人类类实例中附有一种哺乳动物
- en: Remember that we previously gave `Player` an `Armor` object inside it. It wouldn't
    make sense for the `Player` object to inherit from the `Armor` class, because
    it wouldn't make sense to say *the Player is-an Armor*. When deciding whether
    one class inherits from another or not in code design (for example, the Human
    class inherits from the Mammal class), you must always be able to comfortably
    say something like the Human class *is-a* Mammal. If the *is-a* statement sounds
    wrong, then it is likely that inheritance is the wrong relationship for that pair
    of objects.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们之前在`Player`内部给了它一个`Armor`对象。对于`Player`对象来说，从`Armor`类继承是没有意义的，因为这说不通*玩家是装甲*。在代码设计中决定一个类是否从另一个类继承时（例如，Human类从Mammal类继承），你必须始终能够舒适地说出类似于Human类*是*Mammal的话。如果*是*这个陈述听起来不对，那么很可能是继承对于这对对象的关系是错误的。
- en: In the preceding example, we're introducing a few new C++ keywords here. The
    first is `protected`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们在这里引入了一些新的C++关键字。第一个是`protected`。
- en: protected variables
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: protected变量
- en: A `protected` member variable is different from a `public` or `private` variable.
    All three classes of variables are accessible inside the class in which they are
    defined. The difference between them is in regard to accessibility outside the
    class. A `public` variable is accessible anywhere inside the class and outside
    the class. A `private` variable is accessible inside the class but not outside
    the class. A `protected` variable is accessible inside the class, and inside of
    derived subclasses, but is not accessible outside the class. So, the `hp` and
    `speed` members of `class Mammal` will be accessible in the derived classes Dog,
    Cat, Horse, and Human, but not outside of these classes (in `main()` for instance).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`protected`成员变量与一个`public`或`private`变量不同。所有这三个类别的变量都可以在定义它们的类内部访问。它们之间的区别在于对类外部的可访问性。一个`public`变量可以在类内部和类外部访问。一个`private`变量可以在类内部访问，但不能在类外部访问。一个`protected`变量可以在类内部和派生子类内部访问，但不能在类外部访问。因此，`class
    Mammal`中的`hp`和`speed`成员将在派生类Dog、Cat、Horse和Human中可访问，但不在这些类外部（例如在`main()`中）。
- en: Virtual functions
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚函数
- en: A virtual function is a member function whose implementation can be overridden
    in a derived class. In this example, the `talk()` member function (defined in
    `class Mammal`) is marked `virtual`. This means that the derived classes might
    or might not choose to implement their own version of what the `talk()` member
    function means.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 虚函数是一个成员函数，其实现可以在派生类中重写。在这个例子中，`talk()` 成员函数（在 `class Mammal` 中定义）被标记为 `virtual`。这意味着派生类可能会也可能不会选择实现自己的
    `talk()` 函数版本。
- en: Purely virtual functions (and abstract classes)
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯虚函数（以及抽象类）
- en: 'A purely virtual function is one whose implementation you are required to override
    in the derived class. The `walk()` function in `class Mammal` is purely virtual;
    it was declared like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 纯虚函数是要求在派生类中重写的函数。`class Mammal` 中的 `walk()` 函数是纯虚的；它被声明如下：
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `= 0` part at the end of the preceding code is what makes the function purely
    `virtual`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码末尾的 `= 0` 部分使得函数成为纯虚函数。
- en: The `walk()` function in `class Mammal` is purely `virtual` and this makes the
    Mammal class abstract. An abstract class in C++ is any class that has at least
    one purely virtual function.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`class Mammal` 中的 `walk()` 函数是纯虚函数，这使得 `Mammal` 类成为抽象类。在 C++ 中，抽象类是至少有一个纯虚函数的任何类。'
- en: 'If a class contains a purely virtual function and is abstract, then that class
    cannot be instantiated directly. That is, you cannot create a `Mammal` object
    now, on account of the purely virtual function `walk()`. If you tried to do the
    following code, you would get an error:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类包含一个纯虚函数并且是抽象的，那么这个类不能直接实例化。也就是说，你现在不能创建一个 `Mammal` 对象，因为 `walk()` 是一个纯虚函数。如果你尝试执行以下代码，你会得到一个错误：
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you try to create a `Mammal` object, you will get the following error:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试创建一个 `Mammal` 对象，你会得到以下错误：
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can, however, create instances of derivatives of `class Mammal`, as long
    as the derived classes have all of the purely virtual member functions implemented.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以创建 `class Mammal` 的派生类的实例，只要这些派生类实现了所有的纯虚成员函数。
- en: Multiple inheritance
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多重继承
- en: Not everything multiple is as good as it sounds. Multiple inheritance is when
    a derived class inherits from more than one base class. Usually, this works without
    a hitch if the multiple base classes we are inheriting from are completely unrelated.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有听起来很好的多重继承都是如此。多重继承是指一个派生类从多个基类继承。通常，如果我们继承的多个基类完全无关，这个过程会顺利无误。
- en: For example, we can have a class `Window` that inherits from the `SoundManager`
    and `GraphicsManager` base classes. If `SoundManager` provides a member function
    `playSound()` and `GraphicsManager` provides a member function `drawSprite()`,
    then the `Window` class will be able to use those additional capabilities without
    a hitch.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以有一个 `Window` 类，它从 `SoundManager` 和 `GraphicsManager` 基类继承。如果 `SoundManager`
    提供一个成员函数 `playSound()`，而 `GraphicsManager` 提供一个成员函数 `drawSprite()`，那么 `Window`
    类将能够无障碍地使用这些额外的功能。
- en: '![Multiple inheritance](img/00065.jpeg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![多重继承](img/00065.jpeg)'
- en: Game Window inheriting from Sound Man and Graphics Man means Game Window will
    have both sets of capabilities
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏窗口从声音管理和图形管理器继承意味着游戏窗口将拥有这两组功能
- en: However, multiple inheritance can have negative consequences. Say we want to
    create a class `Mule` that derives from both the `Donkey` and `Horse` classes.
    The `Donkey` and `Horse` classes, however, both inherit from the base class `Mammal`.
    We instantly have an issue! If we were to call `mule.talk()`, but `mule` does
    not override the `talk()` function, which member function should be invoked, that
    of `Horse` or `Donkey`? It's ambiguous.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，多重继承可能会有负面影响。比如说，我们想要创建一个从 `Donkey` 和 `Horse` 类派生的 `Mule` 类。然而，`Donkey` 和
    `Horse` 类都从基类 `Mammal` 继承。我们立刻遇到了问题！如果我们调用 `mule.talk()`，但 `mule` 没有重写 `talk()`
    函数，应该调用哪个成员函数，`Horse` 的还是 `Donkey` 的？这是模糊的。
- en: private inheritance
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 私有继承
- en: 'A less talked about feature of C++ is `private` inheritance. Whenever a class
    inherits from another class publicly, it is known to all code whose parent class
    it belongs to. For example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: C++中较少讨论的特性是 `私有` 继承。每当一个类以公有方式从另一个类继承时，它对其所属的父类中的所有代码都是已知的。例如：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This means that all code will know that `Cat` is an object of `Mammal`, and
    it will be possible to point to a `Cat*` instance using a base class `Mammal*`
    pointer. For example, the following code will be valid:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着所有代码都将知道 `Cat` 是 `Mammal` 的一个对象，并且可以使用基类 `Mammal*` 指针指向 `Cat*` 实例。例如，以下代码将是有效的：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The preceding code is fine if `Cat` inherits from `Mammal` publicly. Private
    inheritance is where code outside the `Cat` class is not allowed to know the parent
    class:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Cat`从`Mammal`公开继承，前面的代码是好的。私有继承是外部`Cat`类不允许知道父类的地方：
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, externally calling code will not "know" that the `Cat` class derives from
    the `Mammal` class. Casting a `Cat` instance to the `Mammal` base class is not
    allowed by the compiler when inheritance is `private`. Use `private` inheritance
    when you need to hide the fact that a certain class derives from a certain parent
    class.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，外部调用代码不会“知道”`Cat`类是从`Mammal`类派生的。当继承为`private`时，编译器不允许将`Cat`实例强制转换为`Mammal`基类。当你需要隐藏某个类从某个父类派生的事实时，请使用`private`继承。
- en: However, private inheritance is rarely used in practice. Most classes just use
    `public` inheritance. If you want to know more about private inheritance, see
    [http://stackoverflow.com/questions/406081/why-should-i-avoid-multiple-inheritance-in-c](http://stackoverflow.com/questions/406081/why-should-i-avoid-multiple-inheritance-in-c).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实际应用中，私有继承很少使用。大多数类只是使用 `public` 继承。如果你想了解更多关于私有继承的信息，请参阅[http://stackoverflow.com/questions/406081/why-should-i-avoid-multiple-inheritance-in-c](http://stackoverflow.com/questions/406081/why-should-i-avoid-multiple-inheritance-in-c)。
- en: Putting your classes into headers
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将你的类放入头文件中
- en: So far, our classes have just been pasted before `main()`. If you continue to
    program that way, your code will all be in one file and appear as one big disorganized
    mess.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的类只是粘贴在 `main()` 之前。如果你继续这样编程，你的代码将全部在一个文件中，看起来像一大团混乱。
- en: Therefore, it is a good programming practice to organize your classes into separate
    files. This makes editing each class's code individually much easier when there
    are multiple classes inside the project.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将你的类组织到单独的文件中是一种良好的编程实践。当项目中有多个类时，这使得单独编辑每个类的代码变得容易得多。
- en: 'Take `class Mammal` and its derived classes from earlier. We will properly
    organize that example into separate files. Let''s do it in steps:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的 `class Mammal` 和其派生类开始。我们将把这个例子适当地组织到单独的文件中。让我们分步骤来做：
- en: Create a new file in your C++ project called `Mammal.h`. Cut and paste the entire
    `Mammal` class into that file. Notice that since the `Mammal` class included the
    use of `cout`, we write a `#include <iostream>` statement in that file as well.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 C++ 项目中创建一个名为 `Mammal.h` 的新文件。将整个 `Mammal` 类复制并粘贴到该文件中。注意，由于 `Mammal` 类使用了
    `cout`，我们也在该文件中写了一个 `#include <iostream>` 语句。
- en: Write a " `#include` `Mammal.h`" statement at the top of your `Source.cpp` file.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `Source.cpp` 文件顶部写一个 " `#include` `Mammal.h`" 语句。
- en: 'An example of what this looks like is shown in the following screenshot:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示，这是它的一个示例：
- en: '![Putting your classes into headers](img/00066.jpeg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![将你的类放入头文件中](img/00066.jpeg)'
- en: What's happening here when the code is compiled is that the entire `Mammal`
    class is copied and pasted (#include) into the `Source.cpp` file, which contains
    the `main()` function, and the rest of the classes are derived from `Mammal`.
    Since `#include` is a copy and paste function, the code will function exactly
    the same as it did before; the only difference is that it will be much better
    organized and easier to look at. Compile and run your code at this step to make
    sure it still works.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码编译时，这里发生的情况是将整个 `Mammal` 类复制并粘贴（`#include`）到包含 `main()` 函数的 `Source.cpp`
    文件中，其余的类都从 `Mammal` 派生。由于 `#include` 是一个复制粘贴函数，代码将完全按照之前的方式运行；唯一的区别是它将组织得更好，更容易查看。在这一步编译和运行你的代码，以确保它仍然可以工作。
- en: Tip
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Check that your code compiles and runs often, especially when refactoring. When
    you don't know the rules, you're bound to make a lot of mistakes. This is why
    you should do your refactoring only in small steps. Refactoring is the name for
    the activity we are doing now—we are reorganizing the source to make better sense
    to other readers of our codebase. Refactoring usually does not involve rewriting
    too much of it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的代码经常编译和运行，尤其是在重构时。当你不知道规则时，你肯定会犯很多错误。这就是为什么你应该只在小步骤中重构。重构是我们现在正在进行的活动的名称——我们正在重新组织源代码，使其对我们代码库的其他读者来说更有意义。重构通常不涉及太多重写。
- en: The next thing you need to do is isolate the Dog, Cat, and Human classes into
    their own files. To do so, create the `Dog.h`, `Cat.h`, and `Human.h` files and
    add them to your project.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步你需要做的是将 Dog、Cat 和 Human 类隔离到它们自己的文件中。为此，创建 `Dog.h`、`Cat.h` 和 `Human.h` 文件并将它们添加到你的项目中。
- en: 'Let''s start with the Dog class, as shown in the following screenshot:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 Dog 类开始，如下截图所示：
- en: '![Putting your classes into headers](img/00067.jpeg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![将你的类放入标题](img/00067.jpeg)'
- en: 'If you use exactly this setup and try to compile and run your project, you
    will see the **''Mammal'' : ''class'' type redefinition** error, as shown in the
    following screenshot:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你使用这个设置并尝试编译和运行你的项目，你将看到如下所示的 **''Mammal'' : ''class'' 类型重新定义** 错误，如下面的截图所示：'
- en: '![Putting your classes into headers](img/00068.jpeg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![将你的类放入标题](img/00068.jpeg)'
- en: What this error means is that `Mammal.h` has been included twice in your project,
    once in `Source.cpp` and then again in `Dog.h`. This means effectively two versions
    of the Mammal class got added to the compiling code, and C++ is unsure which version
    to use.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误意味着 `Mammal.h` 在你的项目中已被包含两次，一次在 `Source.cpp` 中，然后又在 `Dog.h` 中。这意味着实际上有两个版本的
    `Mammal` 类被添加到编译代码中，C++ 不确定使用哪个版本。
- en: 'There are a few ways to fix this issue, but the easiest (and the one that Unreal
    Engine uses) is the `#pragma once` macro, as shown in the following screenshot:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以解决这个问题，但最简单（也是虚幻引擎使用的方法）是使用 `#pragma once` 宏，如下面的截图所示：
- en: '![Putting your classes into headers](img/00069.jpeg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![将你的类放入标题](img/00069.jpeg)'
- en: We write `#pragma once` at the top of each header file. This way, the second
    time `Mammal.h` is included, the compiler doesn't copy and paste its contents
    again, since it already has been included before, and its content is actually
    already in the compiling group of files.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在每个头文件顶部写上 `#pragma once`。这样，当第二次包含 `Mammal.h` 时，编译器不会再次复制粘贴其内容，因为它之前已经包含过了，其内容实际上已经在编译文件组中。
- en: Do the same thing for `Cat.h` and `Human.h`, then `include` them both into your
    `Source.cpp` file where your `main()` function resides.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `Cat.h` 和 `Human.h` 也做同样的事情，然后将它们都包含到你的 `Source.cpp` 文件中，你的 `main()` 函数就在那里。
- en: '![Putting your classes into headers](img/00070.jpeg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![将你的类放入标题](img/00070.jpeg)'
- en: Diagram with all classes included
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 包含所有类的图
- en: Now that we've included all classes into your project, the code should compile
    and run.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将所有类包含到你的项目中，代码应该可以编译并运行。
- en: .h and .cpp
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .h 和 .cpp
- en: The next level of organization is to leave the class declarations in the header
    files (`.h`) and put the actual function implementation bodies inside some new
    `.cpp` files. Also, leave existing members inside the `class Mammal` declaration.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个组织级别是将类声明留在头文件（`.h`）中，并将实际函数实现体放入一些新的 `.cpp` 文件中。同时，将现有成员留在 `class Mammal`
    声明中。
- en: 'For each class, perform the following operations:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个类，执行以下操作：
- en: 'Delete all function bodies (code between `{` and `}`) and replace them with
    just a semicolon. For the `Mammal` class, this would look as follows:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除所有函数体（`{` 和 `}` 之间的代码）并替换为仅有一个分号。对于 `Mammal` 类，它看起来如下所示：
- en: '[PRE37]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create a new `.cpp` file called `Mammal.cpp`. Then simply put the member function
    bodies inside this file:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Mammal.cpp` 的新 `.cpp` 文件。然后只需将成员函数体放入此文件中：
- en: '[PRE38]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: It is important to note the use of the class name and scope resolution operator
    (double colon) when declaring the member function bodies. We prefix all member
    functions belonging to the `Mammal` class with `Mammal::`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意在声明成员函数体时使用类名和作用域解析运算符（双冒号）。我们用 `Mammal::` 前缀所有属于 `Mammal` 类的成员函数。
- en: Notice how the purely virtual function does not have a body; it's not supposed
    to! Purely virtual functions are simply declared (and initialized to 0) in the
    base class, but implemented later in derived classes.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，纯虚函数没有函数体；它不应该有！纯虚函数只是在基类中声明（并初始化为 0），然后在派生类中实现。
- en: Exercise
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Complete the separation of the different creature classes above into class header
    (`.h`) and class definition files (`.cpp`)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述不同的生物类完全分离成类头文件 (.h) 和类定义文件 (.cpp)
- en: Summary
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You learned about objects in C++; they are pieces of code that tie data members
    and member functions together into a bundle of code called `class` or `struct`.
    Object-oriented programming means that your code will be filled with things instead
    of just `int`, `float`, and `char` variables. You will have a variable that represents
    `Barrel`, another variable that represents `Player`, and so on, that is, a variable
    to represent every entity in your game. You will be able to reuse code by using
    inheritance; if you had to code implementations of `Cat` and `Dog`, you can code
    a common functionality in the base class `Mammal`. We also discussed encapsulation
    and how it is easier and more efficient to program objects such that they maintain
    their own internal state.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 C++ 中学习了关于对象的知识；它们是将数据成员和成员函数结合在一起形成代码包的代码片段，称为 `class` 或 `struct`。面向对象编程意味着你的代码将充满各种事物，而不仅仅是
    `int`、`float` 和 `char` 变量。你将有一个代表 `Barrel` 的变量，另一个代表 `Player` 的变量，等等，也就是说，一个代表你游戏中每个实体的变量。你将通过使用继承来重用代码；如果你不得不编写
    `Cat` 和 `Dog` 的实现，你可以在基类 `Mammal` 中编写共同的功能。我们还讨论了封装以及如何编程对象以便它们保持自己的内部状态，这样做既容易又高效。
