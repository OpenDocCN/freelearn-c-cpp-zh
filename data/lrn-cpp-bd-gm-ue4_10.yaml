- en: Inventory System and Pickup Items
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库存系统和拾取物品
- en: We want our player to be able to pick up items from the game world. In this
    chapter, we will code and design a backpack for our player to store items. We
    will display what the player is carrying in the pack when the user presses the
    *I* key.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望玩家能够从游戏世界中拾取物品。在本章中，我们将为玩家编写和设计一个背包来存放物品。当用户按下*I*键时，我们将显示玩家携带的物品。
- en: As a data representation, we can use the `TMap<FString, int>` items covered
    in the previous chapter to store our items. When the player picks up an item,
    we add it to the map. If the item is already in the map, we just increase its
    value by the quantity of the new items picked up.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为数据表示，我们可以使用上一章中介绍的`TMap<FString, int>`来存储我们的物品。当玩家拾取物品时，我们将其添加到地图中。如果物品已经在地图中，我们只需增加其值，即新拾取的物品的数量。
- en: 'We will be covering the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Declaring the backpack
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明背包
- en: The PickupItem base class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PickupItem基类
- en: Drawing the player inventory
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制玩家库存
- en: Declaring the backpack
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明背包
- en: 'We can represent the player''s backpack as a simple `TMap<FString, int>` item. To
    allow our player to gather items from the world, open the `Avatar.h` file and add
    the following `TMap` declaration:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将玩家的背包表示为一个简单的`TMap<FString, int>`项目。为了让我们的玩家从世界中收集物品，打开`Avatar.h`文件并添加以下`TMap`声明：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Forward declaration
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前向声明
- en: Before the `AAvatar` class, notice that we have a `class APickupItem` forward
    declaration. Forward declarations are needed in a code file when a class is mentioned
    (such as the `APickupItem::Pickup( APickupItem *item );` function prototype),
    but there is no code in the file actually using an object of that type inside
    the file. Since the `Avatar.h` header file does not contain executable code that
    uses an object of the type `APickupItem`, a forward declaration is what we need.
    While it may seem easier to include a .h file. sometimes it's better to avoid
    that, or you may get circular dependencies (two classes that each try including
    the other one can cause problems).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AAvatar`类之前，请注意我们有一个`class APickupItem`的前向声明。在代码文件中需要前向声明的情况是当提到一个类（例如`APickupItem::Pickup(
    APickupItem *item );`函数原型）时，但文件中实际上没有使用该类型的对象的代码。由于`Avatar.h`头文件不包含使用`APickupItem`类型对象的可执行代码，我们需要前向声明。虽然包含一个.h文件可能更容易，但有时最好避免这样做，否则可能会出现循环依赖（两个类互相包含可能会导致问题）。
- en: The absence of a forward declaration will give a compiler error, since the compiler
    won't have heard of `class APickupItem` before compiling the code in `class AAvatar`.
    The compiler error will come at the declaration of the `APickupItem::Pickup( APickupItem
    *item );` function prototype declaration.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少前向声明将导致编译错误，因为编译器在编译`class AAvatar`中的代码之前不知道`class APickupItem`。编译器错误将出现在`APickupItem::Pickup(
    APickupItem *item );`函数原型声明处。
- en: 'We declared two `TMap` objects inside the `AAvatar` class. This is how the
    objects will look, as shown in the following table:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`AAvatar`类中声明了两个`TMap`对象。如下表所示：
- en: '| `FString` (name) | `int` (quantity) | `UTexture2D*` (im) |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `FString`（名称）| `int`（数量）| `UTexture2D*`（im）|'
- en: '| `GoldenEgg` | `2` | ![](img/c3918bbc-1d30-4f56-aea2-4df86976f902.png) |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `GoldenEgg` | `2` | ![](img/c3918bbc-1d30-4f56-aea2-4df86976f902.png) |'
- en: '| `MetalDonut` | `1` | ![](img/9b920363-321a-41c9-a215-8f472aad5bc9.png) |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `MetalDonut` | `1` | ![](img/9b920363-321a-41c9-a215-8f472aad5bc9.png) |'
- en: '| `Cow` | `2` | ![](img/771da95a-5e07-4846-94f1-346279693904.png) |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `Cow` | `2` | ![](img/771da95a-5e07-4846-94f1-346279693904.png) |'
- en: In the `TMap` backpack, we store the `FString` variable of the item that the
    player is holding. In the `Icons` map, we store a single reference to the image
    of the item the player is holding.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TMap`背包中，我们存储玩家持有的物品的`FString`变量。在`图标`映射中，我们存储玩家持有物品的图像的单个引用。
- en: 'At render time, we can use the two maps working together to look up both the
    quantity of an item that the player has (in his `Backpack` mapping), and the texture
    asset reference of that item (in the `Icons` map). The following screenshot shows
    how the rendering of the HUD will look:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染时，我们可以使用两个地图一起工作，查找玩家拥有的物品数量（在他的`背包`映射中），以及该物品的纹理资产引用（在`图标`映射中）。以下屏幕截图显示了HUD的渲染效果：
- en: '![](img/ead175d8-8699-48a9-88de-6c8fa1c2086b.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ead175d8-8699-48a9-88de-6c8fa1c2086b.png)'
- en: Note that we can also use an array of `struct` with an `FString` variable and
    `UTexture2D*` in it instead of using two maps.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还可以使用一个包含`FString`变量和`UTexture2D*`的`struct`数组，而不是使用两个地图。
- en: 'For example, we can keep `TArray<Item> Backpack;` with a `struct` variable,
    as shown in the following code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用`TArray<Item> Backpack;`和一个`struct`变量，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Then, as we pick up items, they will be added to the linear array. However,
    counting the number of each item we have in the backpack will require constant
    re-evaluation by iterating through the array of items each time we want to see
    the count. For example, to see how many hairbrushes you have, you will need to
    make a pass through the whole array. This is not as efficient as using a map.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们拾取物品时，它们将被添加到线性数组中。然而，计算我们在背包中每种物品的数量将需要通过遍历整个数组来进行不断的重新评估。例如，要查看您有多少个发夹，您需要遍历整个数组。这不如使用地图高效。
- en: Importing assets
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入资产
- en: You might have noticed the Cow asset in the preceding screenshot, which is not
    a part of the standard set of assets that UE4 provides in a new project. In order
    to use the Cow asset, you need to import the cow from the Content Examples project.
    There is a standard importing procedure that UE4 uses.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到前面屏幕截图中的Cow资产，这不是UE4在新项目中提供的标准资产集的一部分。为了使用Cow资产，您需要从内容示例项目中导入cow。UE4使用标准的导入过程。
- en: In the following screenshot, I have outlined the procedure for importing the
    Cow asset. Other assets will be imported from other projects in UE4 using the
    same method.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，我已经概述了导入Cow资产的过程。其他资产将使用相同的方法从UE4中的其他项目导入。
- en: 'Perform the following steps to import the Cow asset:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤导入Cow资产：
- en: 'Download and open UE4''s Content Examples project. Find it under Learn in the
    Epic Game Launcher, shown as follows:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并打开UE4的Content Examples项目。在Epic Game Launcher的Learn下找到它，如下所示：
- en: '![](img/d6b3e574-9bbc-455d-a1aa-44ad05f4822e.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6b3e574-9bbc-455d-a1aa-44ad05f4822e.png)'
- en: After you have downloaded Content Examples, open it and click on
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载Content Examples后，打开它并单击
- en: 'Create Project:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 创建项目：
- en: '![](img/d191f3be-af11-46e1-b608-8255fd89edc7.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d191f3be-af11-46e1-b608-8255fd89edc7.png)'
- en: Next, name the folder in which you will put your `ContentExamples` and click
    on Create.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，命名您将放置`ContentExamples`的文件夹，然后单击创建。
- en: 'Open your `ContentExamples` project from the library. Browse the assets available
    in the project until you find one that you like. Searching for `SM_` will help
    since all static meshes usually begin with `SM_` by convention:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从库中打开您的`ContentExamples`项目。浏览项目中可用的资产，直到找到您喜欢的资产。按照惯例，搜索`SM_`将有所帮助，因为所有静态网格通常以`SM_`开头：
- en: '![](img/c401500f-fb64-4339-ad53-cb369c27eed2.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c401500f-fb64-4339-ad53-cb369c27eed2.png)'
- en: Assets available in the project
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 项目中可用的资产
- en: 'When you find an asset that you like, import it into your project by right-clicking
    on the asset and then clicking on Asset Actions > Migrate...:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您找到喜欢的资产时，通过右键单击资产，然后单击Asset Actions > Migrate...将其导入到您的项目中：
- en: '![](img/aaf26cd5-cdb2-4f0c-9784-bd815f8f43c4.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aaf26cd5-cdb2-4f0c-9784-bd815f8f43c4.png)'
- en: 'Click on OK in the Asset Report dialog:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Asset Report对话框中单击确定：
- en: '![](img/335e3f20-4f45-4d42-b3b0-2f87a74e648b.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/335e3f20-4f45-4d42-b3b0-2f87a74e648b.png)'
- en: 'Select the Content folder from your project that you want to add the SM_Toy_Cow
    file to. We will add it to `/Documents/Unreal Projects/GoldenEgg/Content`, as
    shown in the following screenshot:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您要将SM_Toy_Cow文件添加到的项目的Content文件夹中选择。我们将把它添加到`/Documents/Unreal Projects/GoldenEgg/Content`，如下面的截图所示：
- en: '![](img/be9114fd-5243-4752-b5a0-eaa04fed5e27.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be9114fd-5243-4752-b5a0-eaa04fed5e27.png)'
- en: 'If the import was completed successfully, you will see the following message:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果导入成功完成，您将看到以下消息：
- en: '![](img/fd127d7a-4618-45e8-9a57-66f9bca8328e.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fd127d7a-4618-45e8-9a57-66f9bca8328e.png)'
- en: 'Once you import your asset, you will see it show up in your asset browser inside
    your project:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您导入资产，您将在项目内的资产浏览器中看到它显示出来：
- en: '![](img/2eea6f29-6e2e-4ef0-a5a5-7fc312a12e4e.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2eea6f29-6e2e-4ef0-a5a5-7fc312a12e4e.png)'
- en: You can then use the asset inside your project normally.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您可以在项目中正常使用该资产。
- en: Attaching an action mapping to a key
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将动作映射附加到键
- en: 'We need to attach a key to activate the display of the player''s inventory.
    Inside the UE4 editor, follow these steps:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要附加一个键来激活玩家库存的显示。在UE4编辑器中，按照以下步骤操作：
- en: Add an Action Mappings + called `Inventory`
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Inventory`的Action Mappings+
- en: 'Assign it to the keyboard key *I*, as shown:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其分配给键盘键*I*，如下所示：
- en: '![](img/6b70bffd-3536-4c2b-b521-1103b6ba0183.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b70bffd-3536-4c2b-b521-1103b6ba0183.png)'
- en: 'Next, in the `Avatar.h` file, add a member function to be run when the player''s
    inventory needs to be displayed:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`Avatar.h`文件中，添加一个成员函数，以在需要显示玩家库存时运行：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the `Avatar.cpp` file, implement the `ToggleInventory()` function, as shown
    in the following code:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Avatar.cpp`文件中，实现`ToggleInventory()`函数，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, connect the `"Inventory"` action to `AAvatar::ToggleInventory()` in `SetupPlayerInputComponent()`:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`SetupPlayerInputComponent()`中将`"Inventory"`动作连接到`AAvatar::ToggleInventory()`：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The PickupItem base class
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拾取物品基类
- en: We need to define how a pickup item looks in code. Each pickup item will be
    derived from a common base class. Let's construct the base class for a `PickupItem`
    class now.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在代码中定义拾取物品的外观。每个拾取物品将从一个共同的基类派生。现在让我们构造一个`PickupItem`类的基类。
- en: 'The `PickupItem` base class should inherit from the `AActor` class. Similar
    to how we created multiple NPC blueprints from the base NPC class, we can create
    multiple `PickupItem` blueprints from a single `PickupItem` base class, as shown
    in the following screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`PickupItem`基类应该继承自`AActor`类。类似于我们如何从基础NPC类创建多个NPC蓝图，我们可以从单个`PickupItem`基类创建多个`PickupItem`蓝图，如下面的截图所示：'
- en: '![](img/01cb7674-3e98-4a88-b927-5a8a3b556723.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01cb7674-3e98-4a88-b927-5a8a3b556723.png)'
- en: The text in this screenshot is not important. this image gives you an idea of
    how to create multiple `PickupItem` blueprints from a single `PickupItem` base
    class
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此截图中的文本不重要。此图让您了解如何从单个`PickupItem`基类创建多个`PickupItem`蓝图
- en: Once you have created the `PickupItem` class, open its code in Visual Studio.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`PickupItem`类后，打开其代码在Visual Studio中。
- en: 'The `APickupItem` class will need quite a few members, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`APickupItem`类将需要相当多的成员，如下所示：'
- en: An `FString` variable for the name of the item being picked up
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于被拾取物品名称的`FString`变量
- en: An `int32` variable for the quantity of the item being picked up
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于被拾取物品数量的`int32`变量
- en: A `USphereComponent` variable for the sphere that you will collide with for
    the item to be picked up
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于碰撞的球体的`USphereComponent`变量，以便拾取物品
- en: A `UStaticMeshComponent` variable to hold the actual `Mesh`
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于保存实际`Mesh`的`UStaticMeshComponent`变量
- en: A `UTexture2D` variable for the icon that represents the item
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于表示物品的图标的`UTexture2D`变量
- en: A pointer for the HUD (which we will initialize later)
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个HUD的指针（稍后我们将初始化）
- en: 'This is how the code in `PickupItem.h` looks:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`PickupItem.h`中的代码如下：'
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The point of all these `UPROPERTY()` declarations is to make `APickupItem`
    completely configurable by blueprints. For example, the items in the Pickup category
    will be displayed as follows in the blueprints editor:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些`UPROPERTY()`声明的目的是使`APickupItem`完全可由蓝图配置。例如，Pickup类别中的项目将在蓝图编辑器中显示如下：
- en: '![](img/d5a2836e-5c31-47f8-8303-68ad756e0f6d.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5a2836e-5c31-47f8-8303-68ad756e0f6d.png)'
- en: 'In the `PickupItem.cpp` file, we complete the constructor for the `APickupItem`
    class, as shown in the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PickupItem.cpp`文件中，完成`APickupItem`类的构造函数，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the first two lines, we perform an initialization of `Name` and `Quantity`
    to values that should stand out to the game designer as being uninitialized. We
    used block capitals so that the designer can clearly see that the variable has
    never been initialized before.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两行中，我们对`Name`和`Quantity`进行了初始化，使其值在游戏设计师看来是未初始化的。我们使用大写字母，以便设计师可以清楚地看到该变量以前从未被初始化过。
- en: We then initialize the `ProxSphere` and `Mesh` components using `ObjectInitializer.CreateDefaultSubobject`.
    The freshly initialized objects might have some of their default values initialized,
    but `Mesh` will start out empty. You will have to load the actual mesh later,
    inside blueprints.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`ObjectInitializer.CreateDefaultSubobject`初始化`ProxSphere`和`Mesh`组件。新初始化的对象可能已经初始化了一些默认值，但`Mesh`将为空。您将不得不稍后在蓝图中加载实际的网格。
- en: For the mesh, we set it to simulate realistic physics so that pickup items will
    bounce and roll around if they are dropped or moved. Pay special attention to
    the line `ProxSphere->AttachToComponent(Mesh, FAttachmentTransformRules::KeepWorldTransform);`.
    This line tells you to make sure the pickup item's `ProxSphere` component is attached
    to the `Mesh` root component. This means that when the mesh moves in the level,
    `ProxSphere` follows. If you forget this step (or if you did it the other way
    around), then `ProxSphere` will not follow the mesh when it bounces.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网格，我们将其设置为模拟真实物理，以便如果放下或移动，捡起物品会弹跳和滚动。特别注意`ProxSphere->AttachToComponent(Mesh,
    FAttachmentTransformRules::KeepWorldTransform);`这一行。这行告诉您确保捡起物品的`ProxSphere`组件附加到`Mesh`根组件。这意味着当网格在级别中移动时，`ProxSphere`会跟随移动。如果忘记了这一步（或者反过来做了），那么`ProxSphere`在弹跳时将不会跟随网格。
- en: The root component
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根组件
- en: 'In the preceding code, we assigned `RootComponent` of `APickupItem` to the
    `Mesh` object. The `RootComponent` member is a part of the `AActor` base class,
    so every `AActor` and its derivatives have a root component. The root component
    is basically meant to be the core of the object, and also defines how you collide
    with the object. The `RootComponent` object is defined in the `Actor.h` file,
    as shown in the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们将`APickupItem`的`RootComponent`分配给了`Mesh`对象。`RootComponent`成员是`AActor`基类的一部分，因此每个`AActor`及其派生类都有一个根组件。根组件基本上是对象的核心，并且还定义了您与对象的碰撞方式。`RootComponent`对象在`Actor.h`文件中定义，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'So, the UE4 creators intended `RootComponent` to always be a reference to the
    collision primitive. Sometimes the collision primitive can be capsule shaped—other
    times it can be spherical or even box-shaped, or it can be arbitrarily shaped,
    as in our case, with the mesh. It''s rare that a character should have a box-shaped
    root component, however, because the corners of the box can get caught on walls.
    Round shapes are usually preferred. The `RootComponent` property shows up in the
    blueprints, where you can see and manipulate it:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，UE4的创建者打算`RootComponent`始终是对碰撞原语的引用。有时，碰撞原语可以是胶囊形状，其他时候可以是球形甚至是盒形，或者可以是任意形状，就像我们的情况一样，具有网格。然而，角落的盒子可能会被卡在墙上，因此很少有角色应该有盒状的根组件。通常更喜欢圆形。`RootComponent`属性显示在蓝图中，您可以在那里查看和操作它：
- en: '![](img/3283ccec-e589-4b8e-a8b9-140c368d86d8.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3283ccec-e589-4b8e-a8b9-140c368d86d8.png)'
- en: You can edit the ProxSphere root component from its blueprints once you create
    a blueprint based on the PickupItem class
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 创建基于PickupItem类的蓝图后，可以从其蓝图中编辑ProxSphere根组件
- en: 'Finally, the `Prox_Implementation` function gets implemented, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Prox_Implementation`函数得到实现，如下所示：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Also, make sure you add the following at the top of the file:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请确保在文件顶部添加以下内容：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A couple of tips here that are pretty important: first, we have to access a
    couple of *globals* to get the objects we need. There are three main objects we''ll
    be accessing through these functions that manipulate the HUD:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些非常重要的提示：首先，我们必须访问一些*全局*对象来获取我们需要的对象。通过这些函数，我们将访问三个主要对象，这些对象操作HUD：
- en: The controller (`APlayerController`)
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器 (`APlayerController`)
- en: The HUD (`AMyHUD`)
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HUD (`AMyHUD`)
- en: The player himself (`AAvatar`)
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家本身（`AAvatar`）
- en: There is only one of each of these three types of objects in the game instance.
    UE4 has made finding them easy.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏实例中只有这三种类型的对象中的一个。UE4使得找到它们变得很容易。
- en: 'Also, for this to compile you also need to add another constructor to the `Message`
    struct in `MyHud.h`. You need one that lets you pass in the image like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了编译这个，您还需要在`MyHud.h`中的`Message`结构中添加另一个构造函数。您需要一个可以让您像这样传递图像的构造函数：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To compile, you will also need to add another variable to the struct, `UTexture2D*
    tex;`. You also need to implement the Pickup function in Avatar.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译，您还需要向结构体添加另一个变量`UTexture2D* tex;`。您还需要在Avatar中实现Pickup函数。
- en: Getting the avatar
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取avatar
- en: 'The `player` class object can be found at any time from any place in the code
    by simply calling the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`player`类对象可以通过简单调用以下代码从代码的任何地方找到：'
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We then pass the player the item by calling the `AAvatar::Pickup()` function
    defined earlier.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们通过调用之前定义的`AAvatar::Pickup()`函数将物品传递给玩家。
- en: Because the `PlayerPawn` object is really an `AAvatar` instance, we cast the
    result to the `AAvatar` class, using the `Cast<AAvatar>` command. The `UGameplayStatics`
    family of functions are accessible anywhere in your code as they are global functions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因为PlayerPawn对象实际上是一个AAvatar实例，所以我们将结果转换为AAvatar类，使用Cast<AAvatar>命令。UGameplayStatics函数族可以在代码的任何地方访问，因为它们是全局函数。
- en: Getting the player controller
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取玩家控制器
- en: 'Retrieving the player controller can be done from a global function as well:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 检索玩家控制器也可以通过全局函数完成：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `GetWorld()` function is actually defined in the `UObject` base class. Since
    all UE4 objects derive from `UObject`, any object in the game actually has access
    to the `world` object.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetWorld()`函数实际上是在`UObject`基类中定义的。由于所有UE4对象都派生自`UObject`，因此游戏中的任何对象实际上都可以访问`world`对象。'
- en: Getting the HUD
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取HUD
- en: 'Although this organization might seem strange at first, the HUD is actually
    attached to the player''s controller. You can retrieve the HUD as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种组织可能一开始看起来很奇怪，但HUD实际上是附加到玩家的控制器上的。您可以按如下方式检索HUD：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We cast the HUD object since we previously set the HUD to be an `AMyHUD` instance
    in blueprints. Since we will be using the HUD often, we can actually store a permanent
    pointer to the HUD inside our `APickupItem` class. We will discuss this point
    later.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对HUD对象进行转换，因为我们之前在蓝图中将HUD设置为`AMyHUD`实例。由于我们将经常使用HUD，我们实际上可以在`APickupItem`类内部存储一个永久指针指向HUD。我们稍后会讨论这一点。
- en: 'Next, we implement `AAvatar::Pickup`, which adds an object of the type `APickupItem`
    to the Avatar''s backpack:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实现`AAvatar::Pickup`，它将一个`APickupItem`类型的对象添加到Avatar的背包中：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Also, make sure you add `#include "PickupItem.h"` at the top of the file.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 还要确保在文件顶部添加`#include "PickupItem.h"`。
- en: In the preceding code, we check whether the pickup item that the player just
    got is already in his pack. If it is, we increase its quantity. If it is not in
    his pack, we add it to both his pack and the `Icons` mapping.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们检查玩家刚刚获得的捡起物品是否已经在他的背包中。如果是，我们增加它的数量。如果不在他的背包中，我们将其添加到他的背包和`Icons`映射中。
- en: 'To add the pickup items to the pack, use the following line of code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要将捡起物品添加到背包中，请使用以下代码行：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`APickupItem::Prox_Implementation` is the way this member function will get
    called.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`APickupItem::Prox_Implementation`是调用该成员函数的方式。'
- en: Now, we need to display the contents of our backpack in the HUD when the player
    presses *I*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当玩家按下*I*键时，我们需要在HUD中显示背包的内容。
- en: Drawing the player inventory
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制玩家库存
- en: An inventory screen in a game such as *Diablo* features a pop-up window, with
    the icons of the items you've picked up in the past arranged in a grid. We can
    achieve this type of behavior in UE4.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 像*暗黑破坏神*这样的游戏中的库存屏幕会显示一个弹出窗口，其中过去捡起的物品的图标排列在一个网格中。我们可以在UE4中实现这种行为。
- en: 'There are a number of approaches to drawing a UI in UE4\. The most basic way
    is to simply use `HUD::DrawTexture()` calls. Another way is to use Slate. Another
    way still is to use the newest UE4 UI functionality: **Unreal Motion Graphics**
    (**UMG**) Designer.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在UE4中绘制UI有许多方法。最基本的方法是简单地使用`HUD::DrawTexture()`调用。另一种方法是使用Slate。还有一种方法是使用最新的UE4
    UI功能：**虚幻运动图形**（**UMG**）设计师。
- en: Slate uses a declarative syntax to lay out UI elements in C++. Slate is best
    suited for menus and the like. UMG has been around since UE 4.5 and uses a heavily
    blueprint-based workflow. Since our focus here is on exercises that use C++ code,
    we will stick to a `HUD::DrawTexture()` implementation, but we will go over UMG
    in a later chapter. This means that we will have to manage all the data that deals
    with the inventory in our code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Slate使用声明性语法在C++中布局UI元素。Slate最适合菜单等。UMG自UE 4.5以来一直存在，并使用基于蓝图的工作流程。由于我们这里的重点是使用C++代码的练习，我们将坚持使用`HUD::DrawTexture()`实现，但我们将在后面的章节中介绍UMG。这意味着我们将不得不在我们的代码中管理所有与库存有关的数据。
- en: Using HUD::DrawTexture()
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HUD::DrawTexture()
- en: '`HUD::DrawTexture()` is what we will use to draw the inventory to the screen
    at this point.   We will achieve this in two steps:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`HUD::DrawTexture()`是我们将在此时用来将库存绘制到屏幕上的方法。我们将分两步实现这一点：'
- en: We push the contents of our inventory to the HUD when the user presses the *I*
    key.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户按下*I*键时，我们将库存的内容推送到HUD。
- en: Then, we render the icons into the HUD in a grid-like fashion.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们以网格方式将图标渲染到HUD中。
- en: To keep all the information about how a widget can be rendered, we declare a
    simple structure to keep the information concerning what icon it uses, its current
    position, and current size.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保存有关小部件如何渲染的所有信息，我们声明了一个简单的结构来保存有关它使用的图标、当前位置和当前大小的信息。
- en: 'This is how the `Icon` and `Widget` structures look:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Icon`和`Widget`结构的样子：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can add these structure declarations to the top of `MyHUD.h`, or you can
    add them to a separate file and include that file everywhere those structures
    are used.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将这些结构声明添加到`MyHUD.h`的顶部，或者您可以将它们添加到一个单独的文件中，并在使用这些结构的任何地方包含该文件。
- en: Notice the four member functions on the `Widget` structure to get to the `left()`,
    `right()`, `top()`, and `bottom()` functions of the widget. We will use these
    later to determine whether a click point is inside the box.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`Widget`结构上的四个成员函数，以获取小部件的`left()`、`right()`、`top()`和`bottom()`函数。我们稍后将使用这些函数来确定点击点是否在框内。
- en: 'Next, we declare the function that will render the widgets out on the screen
    in the `AMyHUD` class. First, in `MyHud.h`, add an array to hold widgets and a
    vector to hold the screen dimensions:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在`AMyHUD`类中声明将小部件渲染到屏幕上的函数。首先，在`MyHud.h`中，添加一个数组来保存小部件，以及一个向量来保存屏幕尺寸：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Also, add the line `void DrawWidgets();`. Then, add this to `MyHud.cpp`:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要添加一行`void DrawWidgets();`。然后，将其添加到`MyHud.cpp`中：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A call to the `DrawWidgets()` function should be added to the `DrawHUD()` function,
    and you might want to move the current message handling code into a separate `DrawMessages`
    function so you can then get this (or just leave the original code there):'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该在`DrawHUD()`函数中添加对`DrawWidgets()`函数的调用，并且您可能希望将当前的消息处理代码移动到一个单独的`DrawMessages`函数中，以便您可以随后获取这一点（或者只是保留原始代码）：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we will fill the `ToggleInventory()` function. This is the function that
    runs when the user presses *I*:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将填充`ToggleInventory()`函数。这是用户按下*I*键时运行的函数：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For the preceding code to compile, we need to add two functions to `AMyHUD`:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使前面的代码编译，我们需要向`AMyHUD`添加两个函数：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Make sure you add the following to the `.h` file as well:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，确保在`.h`文件中添加以下内容：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We keep using the `Boolean` variable in `inventoryShowing` to tell us whether
    the inventory is currently displayed or not. When the inventory is shown, we also
    show the mouse so that the user knows what he''s clicking on. Also, when the inventory
    is displayed, the free motion of the player is disabled. The easiest way to disable
    a player''s free motion is by simply returning from the movement functions before
    actually moving. The following code is an example:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继续使用`inventoryShowing`中的`Boolean`变量，以告诉我们库存当前是否显示。当显示库存时，我们还显示鼠标，以便用户知道他点击的是什么。此外，当显示库存时，玩家的自由运动被禁用。禁用玩家的自由运动的最简单方法是在实际移动之前从移动函数中返回。以下代码是一个示例：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Exercise
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Add `if( inventoryShowing ) { return; }` to each of the movement functions so
    when inventory is showing it will block all movement.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个移动函数中添加`if( inventoryShowing ) { return; }`，这样当库存显示时，它将阻止所有移动。
- en: Detecting inventory item clicks
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测库存项目点击
- en: We can detect whether someone is clicking on one of our inventory items by doing
    a simple test to see if the point is inside the `rect` (rectangle) of an object.
    This test is done by checking the point of the click against the contents of the
    `rect` containing the area you want to test.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过简单的测试来检测是否有人点击了我们的库存项目，以查看点是否在对象的`rect`（矩形）内。通过检查点击点与包含要测试区域的`rect`的内容，可以进行此测试。
- en: 'To check against the `rect`, add the following member function to `struct Widget`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要针对`rect`进行检查，向`struct Widget`添加以下成员函数：
- en: '[PRE24]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The test against the `rect` is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 针对`rect`的测试如下：
- en: '![](img/d31e3ea5-d9e9-4708-b3a0-6e15ee9f845c.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d31e3ea5-d9e9-4708-b3a0-6e15ee9f845c.png)'
- en: 'So, it is a hit if `p.X` is all of:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果`p.X`全部是命中：
- en: Right of `left() (p.X > left())`
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`left() (p.X > left())`的右侧'
- en: Left of `right() (p.X < right())`
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`right() (p.X < right())`的左侧'
- en: Below `top() (p.Y > top())`
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`top() (p.Y > top())`的下方
- en: Above `bottom() (p.Y < bottom())`
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`bottom() (p.Y < bottom())`的上方
- en: Remember that in UE4 (and UI rendering in general), the *y* axis is inverted.
    In other words, y goes down in UE4\. This means that `top()` is less than `bottom()`,
    since the origin (the `(0, 0)` point) is at the top-left corner of the screen.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在UE4（以及通常的UI渲染中），*y*轴是反转的。换句话说，在UE4中，y向下。这意味着`top()`小于`bottom()`，因为原点（`(0,
    0)`点）位于屏幕的左上角。
- en: Dragging elements
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拖动元素
- en: 'We can drag elements easily:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松拖动元素：
- en: 'The first step to enable dragging is to respond to the left mouse button click.
    First, we''ll write the function to execute when the left mouse button is clicked.
    In the `Avatar.h` file, add the following prototype to the class declaration:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用拖动的第一步是响应左鼠标按钮点击。首先，我们将编写在单击左鼠标按钮时执行的函数。在`Avatar.h`文件中，向类声明添加以下原型：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the `Avatar.cpp` file, we can add a function to execute on a mouse click
    and pass the click request to the HUD, as follows:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Avatar.cpp`文件中，我们可以添加一个函数来执行鼠标点击，并将点击请求传递给HUD，如下所示：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, in `AAvatar::SetupPlayerInputComponent`, we have to attach our responder:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`AAvatar::SetupPlayerInputComponent`中，我们必须附加我们的响应者：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following screenshot shows how you set up the binding:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了如何设置绑定：
- en: '![](img/4fcda832-ff9a-491d-9c16-031a2ca91188.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4fcda832-ff9a-491d-9c16-031a2ca91188.png)'
- en: 'Add a member to the `AMyHUD` class, plus two new function definitions:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`AMyHUD`类添加一个成员，以及两个新的函数定义：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, in `AMyHUD::MouseClicked()`, we start searching for the `Widget` hit:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`AMyHUD::MouseClicked()`中，我们开始搜索命中的`Widget`：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the `AMyHUD::MouseClicked` function, we loop through all the widgets that
    are on the screen and check for a hit with the current mouse position. You can
    get the current mouse position from the controller at any time by simply looking
    up `PController->GetMousePosition()`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在`AMyHUD::MouseClicked`函数中，我们循环遍历屏幕上的所有小部件，并检查当前鼠标位置是否命中。您可以随时通过简单查找`PController->GetMousePosition()`来获取控制器的当前鼠标位置。 '
- en: Each widget is checked against the current mouse position, and the widget that
    got hit by the mouse click will be moved once the mouse is dragged. Once we have
    determined which widget got hit, we can stop checking, so we have a `return` value
    from the `MouseClicked()` function.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个小部件都与当前鼠标位置进行检查，鼠标点击命中的小部件将在鼠标拖动时移动。一旦确定了命中的小部件，我们就可以停止检查，所以我们从`MouseClicked()`函数中得到一个`return`值。
- en: 'Hitting the widget is not enough, though. We need to drag the widget that got
    hit when the mouse moves. For this, we need to implement a `MouseMoved()` function
    in `AMyHUD`:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，仅仅命中小部件是不够的。当鼠标移动时，我们需要拖动被命中的小部件。为此，我们需要在`AMyHUD`中实现`MouseMoved()`函数：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The drag function looks at the difference in the mouse position between the
    last frame and this frame, and moves the selected widget by that amount. A `static`
    variable (global with local scope) is used to remember the `lastMouse` position
    between the calls for the `MouseMoved()` function.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 拖动函数查看鼠标位置在上一帧和本帧之间的差异，并移动所选小部件相应的距离。一个`static`变量（局部范围内的全局变量）用于在`MouseMoved()`函数调用之间记住`lastMouse`位置。
- en: 'How can we link the mouse''s motion to running the `MouseMoved()` function
    in `AMyHUD`? If you remember, we have already connected the mouse motion in the
    `Avatar` class. The two functions that we used were these:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将鼠标的移动链接到在`AMyHUD`中运行`MouseMoved()`函数？如果您记得，我们已经在`Avatar`类中连接了鼠标移动。我们使用的两个函数是这些：
- en: '`AAvatar::Pitch()` (the y axis)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AAvatar::Pitch()`（y轴）'
- en: '`AAvatar::Yaw()` (the x axis)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AAvatar::Yaw()`（x轴）'
- en: 'Extending these functions will enable you to pass mouse inputs to the HUD.
    I will show you the `Yaw` function now, and you can extrapolate how `Pitch` will
    work from there:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展这些函数将使您能够将鼠标输入传递给HUD。我现在将向您展示`Yaw`函数，您可以从中推断出`Pitch`将如何工作：
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `AAvatar::Yaw()` function first checks whether the inventory is showing
    or not. If it is showing, inputs are routed straight to the HUD, without affecting
    `Avatar`. If the HUD is not showing, inputs just go to `Avatar`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`AAvatar::Yaw()`函数首先检查库存是否显示。如果显示，输入将直接路由到HUD，而不影响`Avatar`。如果HUD没有显示，输入将直接传递给`Avatar`。'
- en: Make sure you added `#include "MyHUD.h"` to the top of the file for this to
    work.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你在文件顶部添加了`#include "MyHUD.h"`，这样才能正常工作。
- en: Exercises
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Complete the `AAvatar::Pitch()` function (y axis) to route inputs to the HUD
    instead of to `Avatar`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成`AAvatar::Pitch()`函数（y轴）以将输入路由到HUD而不是`Avatar`。
- en: Take the NPC characters from [Chapter 8](2f46e9ad-37ad-433a-bf6b-ba297c65565d.xhtml),
    *Actors and Pawns*, and give the player an item (such as `GoldenEgg`) when he
    goes near them.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[第8章](2f46e9ad-37ad-433a-bf6b-ba297c65565d.xhtml)中的NPC角色，*角色和棋子*中获取，并在玩家靠近它们时给予玩家一个物品（比如`GoldenEgg`）。
- en: Putting things together
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 把事情放在一起
- en: Now that you have all this code, you'll want to put this together and see it
    working. Use the Meshes you copied over to create new blueprints by right-clicking
    the `PickupItem` class in the Class Viewer and select Create Blueprint Class as
    we did previously. Set the values (including the Mesh) and then drag objects into
    the game. When you walk into them, you will get a message that it was picked up.
    At that point, you can hit *I* to view your inventory.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了所有这些代码，你会想把它们放在一起并看到它们运行。使用你复制过来的Meshes创建新的蓝图，方法是在类查看器中右键单击`PickupItem`类并选择创建蓝图类，就像我们之前做的那样。设置值（包括Mesh），然后将对象拖入游戏中。当你走进它们时，你会收到一个被拾取的消息。此时，你可以按*I*键查看你的库存。
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered how to set up multiple pickup items for the player
    to see displayed in the level and also pick up. We also displayed them on screen
    and added functionality to drag the widgets. In [Chapter 11](1bee5b28-fd5d-4d05-8347-f8b2886cf011.xhtml), *Monsters*,
    we will introduce Monsters and how to make them follow and attack the player.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何为玩家设置多个拾取物品，以便在关卡中显示并拾取。我们还在屏幕上显示了它们，并添加了拖动小部件的功能。在[第11章](1bee5b28-fd5d-4d05-8347-f8b2886cf011.xhtml)中，*怪物*，我们将介绍怪物以及如何让它们跟随并攻击玩家。
