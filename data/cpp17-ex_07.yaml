- en: The Games
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏
- en: In [Chapter 6](f20d7a19-156f-43e8-92a5-46b9068128fc.xhtml), *Enhancing the QT
    Graphical Applications*, we developed an analog clock, a drawing program, and
    an editor with the Qt graphical library. In this chapter, we continue by developing
    the Othello and Noughts and Crosses games with the Qt library. You will find a
    description of these games after this introduction. We start in this chapter with
    basic versions, where two players play against each other. In [Chapter 8](ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml),
    *The Computer Plays*, we improve the games so that the computer plays against
    the human.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 6 章](f20d7a19-156f-43e8-92a5-46b9068128fc.xhtml)，“增强 QT 图形应用”中，我们使用 Qt
    图形库开发了一个模拟时钟、一个绘图程序和一个编辑器。在本章中，我们继续开发 Othello 和井字棋游戏，使用 Qt 库。您将在本介绍之后找到这些游戏的描述。我们从这个章节的基本版本开始，其中两名玩家相互对战。在第
    8 章 [计算机游戏](ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml)中，我们将游戏改进为计算机与人类对战。
- en: 'Topics we will cover in this chapter include:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的主题包括：
- en: Introduction to game theory. We develop a game grid where the players take turns
    to add their marks to the game grid.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 博弈论简介。我们开发了一个游戏网格，玩家轮流将他们的标记添加到游戏网格中。
- en: We announce the winner. In Othello, after each move, we calculate how many of
    the opponent's marks can be changed. When every position of the game grid has
    been occupied, we declare the winner or a draw.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们宣布获胜者。在国际象棋中，每走一步棋后，我们计算有多少个对手的标记可以被改变。当游戏网格的每个位置都被占据后，我们宣布获胜者或平局。
- en: In Noughts and Crosses, we count the number of marks in a row. If there are
    five marks in a row, we declare the winner.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在井字棋中，我们计算一行中的标记数量。如果一行中有五个标记，我们宣布获胜者。
- en: We continue to use C++ features such as classes, fields, and methods. We also
    continue to use Qt features such as windows and widgets.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们继续使用 C++ 特性，如类、字段和方法。我们还继续使用 Qt 特性，如窗口和小部件。
- en: Othello
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 国际象棋
- en: In Othello, the game grid is empty at the beginning of the game. During the
    game, two players take turns adding marks, colored in black and white, to the
    game grid. Each time a player adds a mark, we look at the other marks and see
    if the new mark causes any of the opponent’s marks to be enclosed. In that case,
    we swap the color of the opponent’s enclosed marks.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在国际象棋中，游戏网格在游戏开始时是空的。在游戏过程中，两名玩家轮流将黑白标记添加到游戏网格中。每次玩家添加标记时，我们查看其他标记，看看新的标记是否会导致对手的任何标记被包围。如果是这样，我们就交换对手被包围标记的颜色。
- en: For instance, if the black player adds a black mark in a position where the
    three marks to the left are white and the fourth mark is black, the three white
    marks are being enclosed by the two black marks, and they are swapped to black
    marks. When every position on the game grid has been occupied by white and black
    marks, we count the marks and the player with the most marks is the winner. If
    there is an equal number of black and white marks, it is a draw.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果黑子在三个白标记的左侧添加一个黑标记，第四个标记是黑，那么这三个白标记被两个黑标记包围，它们被交换成黑标记。当游戏网格上的每个位置都被黑白标记占据后，我们计算标记数量，标记数量最多的玩家获胜。如果黑白标记数量相等，则为平局。
- en: 'Here''s what our game should look like:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们游戏应该看起来像的：
- en: '![](img/c7a9a4b5-274d-46fc-8bde-d9d10a94b08f.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![游戏](img/c7a9a4b5-274d-46fc-8bde-d9d10a94b08f.png)'
- en: The game widget
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏小部件
- en: First of all, we need a game grid. The `GameWidget` class is common to all the
    applications of this chapter and of [Chapter 8](ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml), *The
    Computer Plays*. In [Chapter 5](411aae8c-9215-4315-8a2e-882bf028834c.xhtml), *Qt
    Graphical Applications* and [Chapter 6](f20d7a19-156f-43e8-92a5-46b9068128fc.xhtml), *Enhancing
    the QT Graphical Applications*, we developed the `DocumentWidget` class, since
    we worked with document-based applications. In this chapter and [Chapter 8](ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml), *The
    Computer Plays,* we instead develop the `GameWidget` class.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个游戏网格。`GameWidget` 类是本章以及 [第 8 章](ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml)，“计算机游戏”中所有应用的通用类。在第
    5 章 [Qt 图形应用](411aae8c-9215-4315-8a2e-882bf028834c.xhtml)和第 6 章 [增强 QT 图形应用](f20d7a19-156f-43e8-92a5-46b9068128fc.xhtml)中，由于我们处理的是基于文档的应用，我们开发了
    `DocumentWidget` 类。在本章和 [第 8 章](ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml)，“计算机游戏”中，我们则开发了
    `GameWidget` 类。
- en: The `DocumentWidget` class of the two previous chapters and the `GameWidget` class
    of this chapter and the next chapter have both similarities and differences. They
    are both subclasses of the Qt class `QWidget`, and they are both intended to be
    embedded in a window. However, while `DocumentWidget` was intended to hold a document,
    `GameWidget` is intended to hold a game grid. It draws the grid and catches mouse
    clicks in the positions of the grid. `GameWidget` is an abstract class that lets
    it its subclass define methods that are called when the user clicks the mouse
    or when a mark in one of the positions of the game grid needs to be repainted.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章的`DocumentWidget`类和本章以及下一章的`GameWidget`类既有相似之处也有不同之处。它们都是Qt类`QWidget`的子类，并且都旨在嵌入到窗口中。然而，`DocumentWidget`旨在包含文档，而`GameWidget`旨在包含游戏网格。它绘制网格并捕获网格位置的鼠标点击。`GameWidget`是一个抽象类，允许其子类定义当用户点击鼠标或游戏网格中某个位置的标记需要重绘时调用的方法。
- en: However, we reuse the `MainWindow` class from the previous chapters to hold
    the main window of the application, with its menu bar.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们重用了上一章的`MainWindow`类来包含应用程序的主窗口及其菜单栏。
- en: '**GameWidget.h**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**GameWidget.h**'
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The constructor initializes the number of rows and columns of the game grid:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数初始化游戏网格的行数和列数：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `clearGrid` method sets every position in the game grid to zero, which
    is assumed to represent an empty position. Therefore, every class that inherits
    `GameWidget` shall let the value zero represent an empty position:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`clearGrid`方法将游戏网格中的每个位置都设置为零，这被假定为表示一个空位置。因此，继承`GameWidget`的每个类都应该让零值代表一个空位置：'
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `resizeEvent` method is called when the user changes the size of the window.
    Since the number of rows and columns is constant, the width and height of each
    position is changed in accordance with the new size of the window:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户改变窗口大小时会调用`resizeEvent`方法。由于行数和列数是固定的，每个位置的宽度和高度会根据窗口的新大小进行改变：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `mousePressEvent` is called when the user presses one of the mouse buttons,
    `paintEvent` is called when the window needs to be repainted, and `closeEvent`
    is called when the user clicks on the close box at the top-right corner of the
    window:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下鼠标按钮时调用`mousePressEvent`，当窗口需要重绘时调用`paintEvent`，当用户点击窗口右上角的关闭框时调用`closeEvent`：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `mouseMark` and `drawMark` methods are pure virtual methods intended to
    be overridden by subclasses; `mouseMark` is called when the user clicks at a position
    in the grid, and `drawMark` is called when a position needs to be repainted. They
    are pure virtual methods, whereas `GameWidget` is abstract, which means that it
    is only possible to use `GameWidget` as a base class. The subclasses of `GameWidget`
    must override the methods to become non-abstract:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`mouseMark`和`drawMark`方法是纯虚方法，旨在被子类覆盖；当用户在网格中的某个位置点击时调用`mouseMark`，当需要重绘某个位置时调用`drawMark`。它们是纯虚方法，而`GameWidget`是抽象的，这意味着只能将其用作基类。`GameWidget`的子类必须覆盖这些方法以使其非抽象：'
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `isQuitOk` method displays a message box that asks the user if they really
    want to quit the game:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`isQuitOk`方法显示一个消息框，询问用户是否真的想要退出游戏：'
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `isQuitEnabled` method is called before the `Game` menu becomes visible.
    The `Quit` item is enabled when a game is in progress:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Game`菜单可见之前调用`isQuitEnabled`方法。当游戏正在进行时，`Quit`项被启用：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `onQuit` and `onExit` methods are called when the user selects the Quit
    or Exit menu items:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择退出或退出菜单项时调用`onQuit`和`onExit`方法：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `isGameInProgress` and `setGameInProgress` methods return and set the value
    of the `m_gameInProgress` field:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`isGameInProgress`和`setGameInProgress`方法返回和设置`m_gameInProgress`字段的值：'
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `get` and `set` methods get and set a value at a position in the game grid.
    The value is an integer; remember that an empty position is assumed to hold the
    value zero:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`和`set`方法用于在游戏网格中的某个位置获取和设置一个值。该值是一个整数；记住，一个空位置被假定为包含值零：'
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `m_gameInProgress` field is true as long as a game is in progress. The
    `m_rows` and `m_columns` fields hold the number of rows and columns of the game
    grid; `m_rowHeight` and `m_columnWidth` hold the height and width in pixels of
    each position in the game grid. Finally, `m_gameGrid` is a pointer to a buffer
    holding the values of the positions of the game grid:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_gameInProgress` 字段在游戏进行中时为真。`m_rows` 和 `m_columns` 字段分别存储游戏网格的行数和列数；`m_rowHeight`
    和 `m_columnWidth` 分别存储游戏网格中每个位置的高度和宽度（以像素为单位）。最后，`m_gameGrid` 是一个指向缓冲区的指针，该缓冲区包含游戏网格中位置值：'
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `GameWidget.cpp` file holds the definitions of the methods of the `GameWidget` class,
    the mouse event methods, and the menu methods, as well as the drawings and settings
    of the marks.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameWidget.cpp` 文件包含 `GameWidget` 类的方法定义、鼠标事件方法、菜单方法，以及标记的绘制和设置。'
- en: '**GameWidget.cpp**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**GameWidget.cpp**'
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The constructor initializes the number of rows and columns of the grid, dynamically
    allocates its memory, and calls `clearGrid` to clear the grid:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数初始化网格的行数和列数，动态分配其内存，并调用 `clearGrid` 以清除网格：
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `get` method returns the value at the position indicated by the row and
    column and `set` sets the value. The buffer holding the values is organized in
    rows. That is, the first part of the buffer holds the first row, and then the
    second row, and so on:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`get` 方法返回由行和列指示的位置的值，而 `set` 设置该值。包含值的缓冲区按行组织。也就是说，缓冲区的第一部分包含第一行，然后是第二行，依此类推：'
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `clearGrid` method sets every position to zero, since zero is assumed to
    represent an empty position:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`clearGrid` 方法将每个位置设置为零，因为零假设表示一个空位置：'
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `Quit` menu item is enabled as long as a game is in progress:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 只要游戏在进行中，`Quit` 菜单项就处于启用状态：
- en: '[PRE16]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If a game is in progress when the user selects to quit the game, a message
    box with a confirmation question is displayed:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在游戏进行中选择退出游戏，则显示一个带有确认问题的消息框：
- en: '[PRE17]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If the user presses the `Yes` button, `true` is returned:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户按下 `Yes` 按钮，则返回 `true`：
- en: '[PRE18]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `onQuit` method is called when the user selects the Quit menu item. If the
    call to `isQuitOk` returns true, `m_gameInProgress` is set to false and update
    is called, which eventually forces a repaint of the window where the game grid
    is cleared.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择退出菜单项时，会调用 `onQuit` 方法。如果 `isQuitOk` 的调用返回 `true`，则将 `m_gameInProgress`
    设置为 `false` 并调用更新，这最终强制重新绘制游戏网格所在的窗口，并清除网格。
- en: '[PRE19]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `onExit` method is called when the user selects the Exit menu item. If
    the call to `isQuitOk` returns true, the application is exited. This is shown
    in the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择退出菜单项时，会调用 `onExit` 方法。如果 `isQuitOk` 的调用返回 `true`，则应用程序退出。这在上面的代码中显示：
- en: '[PRE20]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `resizeEvent` method is called when the user resizes the window. The row
    height and column width are recalculated since the number of rows and columns
    is constant regardless of the size of the window. We divide the height and width
    of the window by the number of rows and columns plus two, since we add extra rows
    and columns as margins. Consider the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户调整窗口大小时，会调用 `resizeEvent` 方法。由于行数和列数是固定的，无论窗口大小如何，都会重新计算行高和列宽。我们将窗口的高度和宽度除以行数和列数加二，因为我们添加了额外的行和列作为边距。考虑以下代码：
- en: '[PRE21]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `mousePressEvent` method is called when the user clicks on the window:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击窗口时，会调用 `mousePressEvent` 方法：
- en: '[PRE22]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The column width and row height are subtracted from the mouse point, since
    the game grid is enclosed by margins:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于游戏网格被边距包围，因此从鼠标点中减去列宽和行高：
- en: '[PRE23]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If the mouse point is located inside one of the game grid positions, and that
    position is empty (zero), the pure virtual method `mouseMark` is called, which
    takes care of the actual action of the mouse click. In the next section, black
    and white marks are added to the game grid, and in the Noughts and Crosses application
    later on. Noughts and crosses are added to the game grid:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果鼠标点位于游戏网格中的一个位置内，并且该位置为空（零），则调用纯虚方法 `mouseMark`，该方法负责处理鼠标点击的实际操作。在下一节中，将在游戏网格中添加黑白标记，并在稍后的井字棋应用中添加。井字棋被添加到游戏网格中：
- en: '[PRE24]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If the rows and columns clicked are located in the game grid (rather than in
    the margins outside the game grid) and the position is empty (zero), we call the `mouseMark`, which
    is a pure virtual method, with the row and column:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果点击的行和列位于游戏网格内（而不是游戏网格外的边距中）并且位置为空（零），我们调用 `mouseMark`，这是一个纯虚方法，并带有行和列：
- en: '[PRE25]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `paintEvent` method is called when the window needs to be repainted. If
    a game is in progress (`m_gameInProgress` is true), the rows and columns are written,
    and then for each position in the game grid, the pure virtual method `drawMark`
    is called, which takes care of the actual painting of each position:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当窗口需要重绘时，会调用 `paintEvent` 方法。如果游戏正在进行中（`m_gameInProgress` 为 true），则写入行和列，然后对游戏网格中的每个位置调用纯虚方法
    `drawMark`，该方法负责实际绘制每个位置：
- en: '[PRE26]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'First, we iterate through the rows and for each row, we write a letter from
    `A` to `Z`. There are 26 letters of the alphabet, and we assume there are no more
    than 26 rows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们遍历行，并为每一行写入一个从 `A` 到 `Z` 的字母。字母表中有 26 个字母，我们假设没有超过 26 行：
- en: '[PRE27]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then we iterate through the columns, and for each column, we write its number:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们遍历列，并为每一列写入其编号：
- en: '[PRE28]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: A pure virtual method is a method that is not intended to be defined in the
    class, only in its subclasses. A class holding at least one pure virtual method
    becomes abstract, which means that it is not possible to create objects of the
    class. The class can only be used as a base class in a class hierarchy. A class
    that inherits an abstract class must define each pure virtual method of the base
    class, or become abstract itself.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 纯虚方法是那些不打算在类中定义，而只在其子类中定义的方法。包含至少一个纯虚方法的类成为抽象类，这意味着无法创建该类的对象。该类只能作为类层次结构中的基类使用。继承自抽象类的类必须定义基类中的每个纯虚方法，或者自身也成为抽象类。
- en: 'Finally, we iterate through the game grid, and for each position, we call the
    pure virtual method `drawMark` with the rectangle of the position and its current
    mark:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们遍历游戏网格，并对每个位置调用纯虚方法 `drawMark`，该方法使用位置的矩形及其当前标记：
- en: '[PRE29]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `closeEvent` method is called when the user clicks on the close box at
    the top-right corner of the window. If the call to `isQuitOk` returns true, the
    window is closed, and the application is exited:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击窗口右上角的关闭按钮时，会调用 `closeEvent` 方法。如果 `isQuitOk` 的调用返回 true，则窗口关闭，应用程序退出：
- en: '[PRE30]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The OthelloWindow class
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OthelloWindow 类
- en: The `Othello` class is a subclass of `MainWindow` from [Chapter 6](f20d7a19-156f-43e8-92a5-46b9068128fc.xhtml),
    *Enhancing the QT Graphical Applications*. It adds menus to the window and sets
    the `OthelloWidget` class here, which is a subclass of `GameWidget`, to its central
    widget.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Othello` 类是来自 [第 6 章](f20d7a19-156f-43e8-92a5-46b9068128fc.xhtml)，*增强 QT 图形应用程序*
    的 `MainWindow` 子类。它向窗口添加菜单，并将 `OthelloWidget` 类（它是 `GameWidget` 的子类）设置为中央小部件。'
- en: '**OthelloWindow.h**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**OthelloWindow.h**'
- en: '[PRE31]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `m_othelloWidgetPtr` field holds a pointer to the widget located in the
    center of the window. It points at an object of the `OthelloWidget` class. This
    is shown in the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_othelloWidgetPtr` 字段持有指向窗口中心小部件的指针。它指向 `OthelloWidget` 类的对象。以下代码展示了这一点：'
- en: '[PRE32]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `OthelloWindow.cpp` file defines the methods of the `OthelloWIndow` class.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`OthelloWindow.cpp` 文件定义了 `OthelloWindow` 类的方法。'
- en: '**OthelloWindow.cpp**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**OthelloWindow.cpp**'
- en: '[PRE33]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The constructor sets the title of the window to `Othello` and the size to *1000*
    x *500* pixels:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数将窗口标题设置为 `Othello` 并将大小设置为 *1000* x *500* 像素：
- en: '[PRE34]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'An `OthelloWidget` object is dynamically created and placed at the center of
    the window:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 动态创建 `OthelloWidget` 对象并将其放置在窗口中心：
- en: '[PRE35]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We add the menu `Game` to the menu bar and connect the `onMenuShow` method
    to the menu, which causes it to be called before the menu becomes visible:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将菜单 `Game` 添加到菜单栏，并将 `onMenuShow` 方法连接到菜单，这样在菜单可见之前就会调用它：
- en: '[PRE36]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The user can choose the black or white color to make the first move. The `isBlackStartsEnabled`
    and `isWhiteStartsEnabled` methods are called before the items become visible.
    The items become disabled when a game is in progress:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以选择黑色或白色来开始第一步。在项目可见之前会调用 `isBlackStartsEnabled` 和 `isWhiteStartsEnabled`
    方法。当游戏进行时，项目会变为不可用：
- en: '[PRE37]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When a game is in progress, the user can quit the game. The item becomes disabled
    when no game is in progress:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏进行时，用户可以退出游戏。如果没有游戏进行，项目会变为不可用：
- en: '[PRE38]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The user can exit the application at any time:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以随时退出应用程序：
- en: '[PRE39]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The destructor deallocates the `Othello` widget in the center of the window:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数释放窗口中心 `Othello` 小部件的资源：
- en: '[PRE40]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The OthelloWidget class
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OthelloWidget 类
- en: '`OthelloWidget` is a subclass of the `GameWidget` class we defined at the beginning
    of this chapter. It becomes a non-abstract class by overriding `mouseMark` and
    `drawMark`, which are called when the user clicks at a position in the game grid
    and when a position needs to be repainted.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`OthelloWidget`是我们在本章开头定义的`GameWidget`类的子类。通过重写`mouseMark`和`drawMark`，它成为一个非抽象类，这两个方法分别在用户点击游戏网格中的位置和需要重绘位置时被调用。'
- en: '**OthelloWidget.h**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**OthelloWidget.h**'
- en: '[PRE41]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'A mark in Othello can be black or white. We use the `Mark` enumeration to store
    values on the game grid. The `Empty` item holds a value of zero, which is assumed
    to be `GameWidget` to represent an empty position:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在奥赛罗游戏中，标记可以是黑色或白色。我们使用`Mark`枚举来存储游戏网格上的值。`Empty`项持有零值，它被假定为`GameWidget`以表示空位：
- en: '[PRE42]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `isBlackStartsEnabled` and `isWhiteStartsEnabled` listeners are called
    before the `BlackStarts` and `WhiteStarts` menu items become visible in order
    to enable them. Note that the listeners and methods must be marked as public slots
    for the menu framework to allow them as listeners:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BlackStarts`和`WhiteStarts`菜单项可见之前，会调用`isBlackStartsEnabled`和`isWhiteStartsEnabled`监听器以启用它们。请注意，监听器和方法必须被标记为公共槽，以便菜单框架允许它们作为监听器：
- en: '[PRE43]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `onBlackStarts` and `onWhiteStarts` methods are called when the `BlackStarts`
    and `WhiteStarts` menu items are selected by the user:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择`BlackStarts`和`WhiteStarts`菜单项时，会调用`onBlackStarts`和`onWhiteStarts`方法：
- en: '[PRE44]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `checkWinner` method checks if every position on the game grid has been
    occupied by a black or white mark. If it has, the marks are counted, and the winner
    is announced unless it is a draw:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果游戏网格上的每个位置都被黑白标记占据，`checkWinner`方法会检查。如果是这样，就会计算标记，并宣布获胜者，除非是平局：
- en: '[PRE45]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `turn` method is called when one of the players has made a move. It calculates
    the positions to be turned as a result of the move:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当一位玩家移动时，会调用`turn`方法。它计算移动结果导致的翻转位置：
- en: '[PRE46]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `calculateMark` method calculates the set of marks to be turned if the
    player places the mark in the position given by the row and column:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculateMark`方法计算如果玩家在由行和列给出的位置放置标记，则要翻转的标记集合：'
- en: '[PRE47]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `m_nextMark` field is alternatively given the values `Black` and `White`
    of the preceding `Mark` enumeration, depending on which player is about to do
    the next move.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_nextMark`字段交替地赋予前一个`Mark`枚举的`Black`和`White`值，这取决于哪个玩家即将进行下一步移动。'
- en: 'It is initialized by `onBlackStarts` or `onWhiteStarts`, as shown in the previous
    code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 它由`onBlackStarts`或`onWhiteStarts`初始化，如前述代码所示：
- en: '[PRE48]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `OthelloWidget` class holds the functionality of the game. It allows the
    player to add black and white marks to the game grid, turn marks, and announce
    the winner.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`OthelloWidget`类包含游戏的功能。它允许玩家将黑白标记添加到游戏网格，翻转标记，并宣布获胜者。'
- en: '**OthelloWidget.cpp**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**OthelloWidget.cpp**'
- en: '[PRE49]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `BlackStarts` and `WhiteStarts` menu items are enabled when there is not
    already a game in progress:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有正在进行的游戏时，`BlackStarts`和`WhiteStarts`菜单项被启用：
- en: '[PRE50]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `onBlackStarts` and `onWhiteStarts` methods set a new game in progress,
    set the mark to make the first move (black or white), clear the grid, and update
    the window to paint an empty game grid:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`onBlackStarts`和`onWhiteStarts`方法设置一个新游戏开始，设置第一个移动的标记（黑色或白色），清除网格，并更新窗口以绘制一个空的游戏网格：'
- en: '[PRE51]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `onMouseMark` is called when the player clicks an empty position on the
    game grid. We set the position with the next mark, turn every mark that is affected
    by the move, and update the window to reflect the change:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家在游戏网格上点击一个空位时，会调用`onMouseMark`。我们使用下一个标记设置位置，翻转所有受移动影响的标记，并更新窗口以反映变化：
- en: '[PRE52]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We check if the move has caused the game grid to become full and switch the
    next mark:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查移动是否使游戏网格变得满载，并切换下一个标记：
- en: '[PRE53]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `drawMark` method is called when a position in the game grid needs to be
    repainted. We draw a black or white ellipse with black borders if the position
    is not empty. If the position is empty, we do nothing. Note that the framework
    clears the window before the call to repaint:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏网格中的某个位置需要重绘时，会调用`drawMark`方法。如果位置不为空，我们用黑色边框绘制一个黑色或白色的椭圆。如果位置为空，我们不做任何操作。请注意，框架在调用重绘之前清除窗口：
- en: '[PRE54]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `checkWinner` method counts the number of positions that are occupied by
    black and white marks or are empty:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkWinner`方法计算被黑白标记占据或为空的格子的数量：'
- en: '[PRE56]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If there are no empty positions left, the game is over, and we announce the
    winner, unless it is a draw. The winner is the player with the most marks in their
    color:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有剩余的空位置，游戏结束，我们宣布获胜者，除非是平局。获胜者是拥有最多标记的玩家：
- en: '[PRE57]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `turn` method calls `calculateMark` to obtain the set of positions where
    the mark shall be turned. Then each position in the set is set to the mark in
    question.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`turn` 方法调用 `calculateMark` 来获取标记应翻转的位置集合。然后，将集合中的每个位置都设置为相应的标记。'
- en: 'In this application, `turn` is the only method that calls `calculateMark`.
    However, in [Chapter 8](ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml), *The Computer
    Plays*, `calculateMark` will also be called to calculate the move of the computer
    player. Therefore, the functionality of `turn` and `calculateMark` are divided
    into two methods:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，`turn` 是唯一调用 `calculateMark` 的方法。然而，在[第8章](ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml)，《计算机对战》中，`calculateMark`
    也会被调用以计算计算机玩家的移动。因此，`turn` 和 `calculateMark` 的功能被分为两个方法：
- en: '[PRE58]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `calculateMark` method counts the number of marks that will be turned for
    each position on the game grid, in all eight directions:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculateMark` 方法计算游戏网格上每个位置将翻转的标记数量，包括八个方向：'
- en: '[PRE59]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Each integer pair in `directionArray` refers to a direction in accordance with
    the compass rising:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`directionArray` 中的每个整数对都根据罗盘上升的方向指代一个方向：'
- en: '[PRE60]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The size of an array can be decided by dividing its total size (in bytes) by
    the size of its first value:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的大小可以通过将其总大小（以字节为单位）除以第一个值的大小来确定：
- en: '[PRE61]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We iterate through the directions and, for each direction, keep moving as long
    as we find the mark of the opponent:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历方向，并且对于每个方向，只要我们找到对手的标记就继续移动：
- en: '[PRE62]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `row` and `column` fields hold the current row and column as long as we
    iterate in that direction:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`row` 和 `column` 字段在迭代该方向时保持当前行和列：'
- en: '[PRE63]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We gather the marks we find during the iteration in `directionSet`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在迭代过程中找到的标记收集到 `directionSet` 中：
- en: '[PRE64]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'If we reach one of the borders of the game grid, or if we find an empty position,
    we break the iteration:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们到达游戏网格的边界之一，或者如果我们找到一个空位置，我们就会中断迭代：
- en: '[PRE65]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'If we find the player''s mark, we add the direction set to the total set and
    break the iteration:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们找到玩家的标记，我们将方向集合添加到总集合中，并中断迭代：
- en: '[PRE66]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If we do not find the player''s mark or an empty position, we have found the
    opponent''s mark, and we add its position to the direction set:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有找到玩家的标记或空位置，我们就找到了对手的标记，并将其位置添加到方向集合中：
- en: '[PRE67]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The main function
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主函数
- en: The `main` function works in the same way as in the previous Qt applications.
    It creates an application, shows the Othello window, and executes the applications.
    The execution continues until the `exit` method is called, which it is when the
    user closes the window or selects the Exit menu item.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 函数与之前 Qt 应用程序中的方式相同。它创建一个应用程序，显示 Othello 窗口，并执行应用程序。执行将继续，直到调用 `exit`
    方法，这通常发生在用户关闭窗口或选择退出菜单项时。'
- en: '**Main.cpp**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**Main.cpp**'
- en: '[PRE68]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Noughts and crosses
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 井字棋
- en: The Noughts and Crosses application sets up a game grid and allows two players
    to play each other. In Noughts and Crosses, two players take turns adding noughts
    and crosses to a game grid. The player that first manages to place five marks
    in a row wins the game. The marks can be placed horizontally, vertically, or diagonally.
    While each player tries to place five of their own marks in a row, they must also
    try to prevent the opponent from placing five marks in a row.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Noughts and Crosses 应用程序设置了一个游戏网格，并允许两名玩家相互对战。在井字棋游戏中，两名玩家轮流在游戏网格上添加圆圈和叉号。首先成功将五个标记连成一线的玩家赢得游戏。标记可以水平、垂直或对角放置。虽然每个玩家都试图将五个自己的标记连成一线，但他们也必须尝试阻止对手将五个标记连成一线。
- en: In [Chapter 8](ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml), *The Computer Plays*,
    the computer plays against the human.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml)，《计算机对战》中，计算机与人类玩家对战。
- en: The NaCWindow class
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NaCWindow 类
- en: We reuse the `GameWidget` from the game widget section. The `NaCWindow` class
    is similar to `OthelloWindow`. It adds the `Nought Begins` and `Cross Begins`
    menu items to the window's menu bar.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重用了游戏部件部分的 `GameWidget`。`NaCWindow` 类与 `OthelloWindow` 类类似。它将 `Nought Begins`
    和 `Cross Begins` 菜单项添加到窗口的菜单栏中。
- en: '**NaCWindow.h**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**NaCWindow.h**'
- en: '[PRE69]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The `NaCWindow.cpp` file holds the definitions of the methods of the `NacWindow` class.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`NaCWindow.cpp` 文件包含 `NacWindow` 类的方法定义。'
- en: '**NaCWindow.cpp**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**NaCWindow.cpp**'
- en: '[PRE70]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The NaCWidget class
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NaCWidget 类
- en: The `NaCWidget` class handles the functionality of Noughts and Crosses. It allows
    two players to play each other. In [Chapter 8](ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml),
    *The Computer Plays*, we will write a game where the computer plays the human.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`NaCWidget` 类处理井字棋的功能。它允许两个玩家相互对战。在[第8章](ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml)，*计算机对战*中，我们将编写一个计算机对战人类的游戏：'
- en: '**NaCWidget.h**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**NaCWidget.h**'
- en: '[PRE71]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Similar to the Othello application, a position in the game grid can hold one
    of three values:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与奥赛罗应用类似，游戏网格中的位置可以持有三个值之一：
- en: '`Empty` (which is zero)'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Empty`（即零）'
- en: '`Nought`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Nought`'
- en: '`Cross`'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cross`'
- en: 'The `Mark` enumeration corresponds to the `Empty`, `Nought`, and `Cross` values:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mark` 枚举对应于 `Empty`、`Nought` 和 `Cross` 值：'
- en: '[PRE72]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `NaCWidget.cpp` file holds the definitions of the methods of the `NaCWidget` class.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`NaCWidget.cpp` 文件包含 `NaCWidget` 类的方法定义：'
- en: '**NaCWidget.cpp**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**NaCWidget.cpp**'
- en: '[PRE73]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The `isNoughtStartsEnabled` and `isCrossStartsEnabled` methods are called before
    the `Game` menu becomes visible. The `Noughts Begins` and `Cross Begins` menu
    items are enabled if there is no game in progress:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Game` 菜单可见之前，会调用 `isNoughtStartsEnabled` 和 `isCrossStartsEnabled` 方法。如果没有正在进行的游戏，则启用
    `Noughts Begins` 和 `Cross Begins` 菜单项：
- en: '[PRE74]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The `onNoughtBegins` and `onCrossBegins` methods are called when the user selects
    the `Nought Begins` and `Cross Begins` menu items. They set the game in progress,
    set the first mark to make the first move (`m_nextMark`), and force a repainting
    of the game grid by calling `update`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择 `Nought Begins` 和 `Cross Begins` 菜单项时，会调用 `onNoughtBegins` 和 `onCrossBegins`
    方法。它们设置正在进行的游戏，设置第一个标记以进行第一次移动（`m_nextMark`），并通过调用 `update` 强制重绘游戏网格：
- en: '[PRE75]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The `mouseMark` method is called when the players click a position in the game
    grid. We set the next mark at the position, check if one of the players has won
    the game, swap the next move, and repaint the window by calling `update`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家在游戏网格中点击一个位置时，会调用 `mouseMark` 方法。我们在该位置设置下一个标记，检查是否有玩家赢得了游戏，交换下一个移动，并通过调用
    `update` 来重绘窗口：
- en: '[PRE76]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `drawMark` method is called when a position in the game grid needs to be
    repainted:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏网格中的位置需要重绘时，会调用 `drawMark` 方法：
- en: '[PRE77]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We set the pen color to black, and in the case of a nought, we draw an ellipse,
    as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将笔的颜色设置为黑色，在井的情况下，我们画一个椭圆，如下所示：
- en: '[PRE78]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'In the case of a cross, we draw two lines between the top-left and bottom-right
    corners and between the top-right and bottom-left corners:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在十字的情况下，我们在左上角和右下角以及右上角和左下角之间画两条线：
- en: '[PRE79]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'In the case of an empty position, we do nothing. Remember that the framework
    clears the window before the repainting:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在空位的情况下，我们不做任何操作。请记住，框架在重绘之前会清除窗口：
- en: '[PRE80]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'When a player has made a move, we check if the move has led to victory. We
    call `countMarks` in four directions to `checkWinner` and see if the move has
    caused five marks in a row:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家移动时，我们检查该移动是否导致了胜利。我们调用 `countMarks` 在四个方向上到 `checkWinner`，看看移动是否导致了五个标记连成一线：
- en: '[PRE81]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'For the north and south directions, the code would be:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于北和南方向，代码如下：
- en: '[PRE82]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'For the west and east directions, the code would be:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对于西和东方向，代码如下：
- en: '[PRE83]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'For the northwest and southeast directions, the code would be:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于西北和东南方向，代码如下：
- en: '[PRE84]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'For southeast and northwest, it would be:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于东南和西北方向，代码如下：
- en: '[PRE85]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'If the move has caused five marks in a row, we display a message box with the
    winner (black or white). In Noughts and Crosses, there can be no draw:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果移动导致一行有五个标记，我们将显示一个包含获胜者（黑色或白色）的消息框。在井字棋中，不可能平局：
- en: '[PRE86]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The game grid is cleared, and is thereby ready for another game:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏网格被清除，因此准备好进行另一场比赛：
- en: '[PRE87]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The `countMarks` method counts the number of marks in a row. We `countMarks`
    the number of marks in both directions. For instance, if both `rowStep` and `columnStep`
    are minus one, we decrease the current row and column by one for each iteration.
    That means that we call `countMarks` in the northeast direction in the first iteration.
    In the second iteration, we call `countMarks` in the opposite direction, that
    is, in the southwest direction:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`countMarks` 方法计算一行中的标记数量。我们在两个方向上计算标记的数量。例如，如果 `rowStep` 和 `columnStep` 都是减一，那么我们每次迭代都减少当前行和列。这意味着我们在第一次迭代中在东北方向调用
    `countMarks`。在第二次迭代中，我们在相反的方向调用 `countMarks`，即西南方向：'
- en: '[PRE88]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'We keep counting until we encounter one of the game grid borders, or we find
    a mark that is not the mark we are counting, that is, the mark of the opposite
    player or an empty mark:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续计数，直到遇到游戏网格的边界，或者我们找到的不是我们正在计数的标记，即对手的标记或空标记：
- en: '[PRE89]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'In the second iteration, we subtract the row and column steps instead of adding
    them. In this way, we call `countMarks` in the opposite direction. We also initialize
    the current rows and columns by adding the steps in order, so we do not `countMarks`
    the middle mark twice:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次迭代中，我们减去行和列的步长而不是增加它们。这样，我们以相反的方向调用`countMarks`。我们还通过顺序添加步长来初始化当前行和列，这样我们就不会对中间的标记进行两次`countMarks`：
- en: '[PRE90]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The main function
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主函数
- en: The `main` function creates the application, shows the window, and executes
    the application until the user closes the window or selects the Exit menu item.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数创建应用程序，显示窗口，并在用户关闭窗口或选择退出菜单项之前执行应用程序。'
- en: '**Main.cpp**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**Main.cpp**'
- en: '[PRE91]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The output for the preceding code is as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/d0111dd0-efe7-4911-8851-1bfa61a04170.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d0111dd0-efe7-4911-8851-1bfa61a04170.png)'
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we developed the two games, Othello and Noughts and Crosses.
    We were introduced to game theory, and we developed a game grid where the players
    take turns to add their marks. In Othello, we developed methods to count the number
    of marks to change for each move, and in Noughts and Crosses, we developed methods
    to recognize if one of the players had managed to place five marks in a row—if
    they had, we declared them the winner.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开发了两个游戏，黑白棋和井字棋。我们介绍了博弈论，并开发了一个游戏网格，玩家轮流在其上添加标记。在黑白棋中，我们开发了计算每步需要更改的标记数量的方法，在井字棋中，我们开发了识别玩家是否成功在一行中放置了五个标记的方法——如果他们做到了，我们宣布他们为胜者。
- en: In [Chapter 8](ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml), *The Computer Plays*,
    we will develop more advanced versions of these games, where the computer plays
    against a human.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml)，《计算机游戏》，我们将开发这些游戏的更高级版本，其中计算机与人类玩家对战。
