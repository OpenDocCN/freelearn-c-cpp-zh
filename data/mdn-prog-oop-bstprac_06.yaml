- en: '*Chapter 4*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第四章*'
- en: Tools That Support Software Development
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持软件开发的工具
- en: Introduction
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引言
- en: Yes, there are loads of different tools. Yes, everybody has their favorite.
    No, there's no reason to look down on people who use different tools than yours.
    Yes, people who like `vi` are weird. In this chapter, I'm not going to recommend
    specific tools, but maybe certain classes of tools and ways I've found of working
    with them that help me.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，有大量的不同工具。是的，每个人都有他们偏爱的工具。不，没有理由看不起使用与你不同工具的人。是的，喜欢`vi`的人很奇怪。在这一章中，我不会推荐特定的工具，但可能会介绍某些工具类别以及我找到的一些使用方法，这些方法对我有所帮助。
- en: If you're new to programming – perhaps you've just taken a few classes or worked
    through some books – this chapter should tell you something about what programmers
    do beyond typing `public static void` into text editors. If you're more experienced,
    you may still find the odd useful nugget here.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始学习编程——也许你只是上过几节课或者读过几本书——这一章应该会告诉你程序员除了在文本编辑器中输入`public static void`之外还做些什么。如果你更有经验，你也许还能在这里找到一些有用的信息。
- en: Version Control/Source Code Management
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本控制/源代码管理
- en: I imagine many readers are currently thinking that the battle over version control
    must surely be over by now, and that all developers are using some system. This
    is, unfortunately, demonstrably untrue. Let me start with an anecdote. It's 2004,
    and I've just started working as a systems manager in a university computing lab.
    My job is partly to maintain the computers in the lab, partly to teach programming
    and numerical computing to physics undergraduates, and partly to write software
    that will assist in said teaching. As part of this work, I started using version
    control, both for my source code and for some of the configuration files in `/etc`
    on the servers. A more experienced colleague saw me doing this and told me that
    I was just generating work for myself; that this wasn't necessary for the small
    things I was maintaining.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我想象许多读者现在可能认为关于版本控制的争论肯定已经结束了，所有开发者都在使用某种系统。遗憾的是，这显然是不真实的。让我从一个轶事开始。那是2004年，我刚刚开始在一家大学计算机实验室担任系统管理员。我的工作部分是维护实验室的电脑，部分是教授物理本科生编程和数值计算，部分是编写辅助教学的软件。作为这项工作的一部分，我开始使用版本控制，既用于我的源代码，也用于服务器上`/etc`目录中的一些配置文件。一位经验更丰富的同事看到我在这样做，告诉我我只是在给自己找麻烦；说这些小事情没有必要进行版本控制。
- en: Move on now to 2010, and I'm working in a big scientific facility in the UK.
    Using software and a *lot* of computers, we've got something that used to take
    an entire PhD to finish down to somewhere between 1 and 8 hours. I'm on the software
    team and, yes, we're using version control to track changes to the software and
    to understand what version is released. Well, kind of, anyway. The "core" of the
    files/source code is in version control, but one of its main features is to provide
    a scripting environment and DSL in which scientists at the "lab benches," if you
    will, can write up scripts that automate their experiments. These scripts are
    not (necessarily) version controlled. Worse, the source code is deployed to experimental
    stations so someone who discovers a bug *in the core* can fix it locally without
    the change being tracked in version control.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在转到2010年，我在英国的一个大型科学设施工作。使用软件和大量的电脑，我们将原本需要整个博士研究生才能完成的工作缩短到了1到8小时之间。我是软件团队的一员，是的，我们使用版本控制来跟踪软件的变更以及了解哪个版本被发布。好吧，至少在某种程度上是这样的。文件/源代码的核心部分在版本控制中，但它的一个主要功能是提供一个脚本环境和领域特定语言（DSL），让“实验室台面”上的科学家可以编写自动化实验的脚本。这些脚本（不一定）在版本控制中。更糟糕的是，源代码被部署到实验站，如果有人发现核心中的错误，可以本地修复它，而无需在版本控制中跟踪更改。
- en: So, a group does an experiment at this facility, and produces some interesting
    results. You try to replicate this later, and you get different results. It could
    be software-related, right? All you need to do is to use the same software as
    the original group used… Unfortunately, you can't. It's vanished.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个团队在这个设施进行了一次实验，并产生了一些有趣的结果。你后来尝试复制这个实验，却得到了不同的结果。这可能是软件相关的问题，对吧？你所需要做的只是使用与原始团队相同的软件……不幸的是，你做不到。它已经消失了。
- en: That's an example of how scientists failing to use the tools from software development
    could be compromising their science. There's a lot of snake oil in the software
    field, both from people wanting you to use their tools/methodologies because you'll
    pay them for it, and from people who have decided that "their" way of working
    is correct and that any other way is incorrect. You need to be able to cut through
    all of that nonsense to find out how particular tools and techniques impact the
    actual work you're trying to do. Philosophy of science currently places a high
    value on reproducibility and auditing. Version control supports that, so it would
    be beneficial for programmers working in science to use version control. But they
    aren't; not consistently, anyway.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是科学家未能使用软件开发工具可能会损害他们科学的一个例子。软件领域有很多“蛇油”，既有想要你使用他们的工具/方法论的人，因为他们会为此向你收费，也有决定“他们的”工作方式是正确的，而任何其他方式都是错误的人。你需要能够穿越所有这些废话，找出特定工具和技术如何影响你试图做的实际工作。科学哲学目前高度重视可重复性和审计。版本控制支持这一点，因此对于在科学领域工作的程序员使用版本控制是有益的。但他们并没有；至少不是始终如一。
- en: In its simplest guise - the one that I was using in 2004 - version control is
    a big undo stack. Only, unlike a series of undo and redo commands, you can leave
    messages explaining who made each change and why. Even if you're working on your
    own, this is a great facility to have – if you try something that gets confusing
    or doesn't work out, you can easily roll back to a working version and take things
    from there.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的形式——我在2004年使用的那种形式——版本控制是一个大的撤销栈。只是，与一系列撤销和重做命令不同，你可以留下消息解释每个变更是由谁做出的以及为什么。即使你是在独自工作，这也是一个非常好的功能——如果你尝试的事情变得混乱或者没有成功，你可以轻松地回滚到一个可工作的版本，并从那里继续。
- en: 'Once you''re more familiar with the capabilities of a version control system,
    it can become a powerful tool for configuration management. Work on different
    features and bugfixes for the same product can proceed in parallel, with work
    being integrated when it''s ready into one or more releases of the product. Discussing
    this workflow in detail is more than I''m willing to cover here: I recommend the
    **Pragmatic Programmer** books on version control such as **Pragmatic Version
    Control Using Git**—[http://pragprog.com/book/tsgit/pragmatic-version-control-using-git](http://pragprog.com/book/tsgit/pragmatic-version-control-using-git)
    by Travis Swicegood.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你更熟悉版本控制系统的功能，它就可以成为配置管理的强大工具。对同一产品的不同功能和错误修复工作可以并行进行，当工作准备好时，可以集成到产品的一个或多个版本中。详细讨论这个工作流程超出了我在这里愿意涵盖的范围：我推荐Travis
    Swicegood的关于版本控制的**实用程序员**书籍，例如**使用Git进行实用版本控制**——[http://pragprog.com/book/tsgit/pragmatic-version-control-using-git](http://pragprog.com/book/tsgit/pragmatic-version-control-using-git)。
- en: On Version Control and Collaboration
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于版本控制和协作
- en: Version control is *no* more of a collaboration tool than other document management
    systems, such as SharePoint. Integrating (or merging) related work by different
    people is hard and requires knowledge of the meaning of the code and how changes
    interact. Version control systems don't have that knowledge, and as a result cannot
    simplify this merging process in any but the most trivial cases. It *does* let
    you defer the problem until you want to face it, but that's about it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制并不比其他文档管理系统，如 SharePoint，更是一种协作工具。整合（或合并）不同人之间的相关工作很困难，需要了解代码的含义以及变更如何交互。版本控制系统没有这种知识，因此除了最简单的情况外，无法简化合并过程。它确实让你可以推迟问题直到你想要面对它，但仅此而已。
- en: Some tools - for example, **GitHub** — [http://www.github.com](http://www.github.com)
    – provide social features around a core version control system. However, the problems
    of knowing what to integrate from whom, and when, and resolving conflicts all
    still exist. The social features give you somewhere to talk about those problems.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一些工具——例如，**GitHub** —— [http://www.github.com](http://www.github.com) – 在核心版本控制系统周围提供社交功能。然而，知道从谁那里整合什么，何时整合，以及解决冲突的问题仍然存在。社交功能为你提供了一个讨论这些问题的场所。
- en: Distributed Version Control
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分布式版本控制
- en: I've used a good few version control systems over the years, from simple tools
    that work with the local filesystem to hugely expensive commercial products. My
    favored way of working now is with a `darcs`, they all work in much the same way).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些年来，我使用过许多版本控制系统，从与本地文件系统工作的简单工具到极其昂贵的商业产品。我现在最喜欢的工作方式是使用`darcs`，它们都以非常相似的方式工作）。
- en: With a DVCS, it's very easy to get a local project into version control, so
    even toy projects and prototypes can be versioned. A feature that makes them great
    for this, over earlier systems that version local files, such as **RCS** (**Reaction
    Control System)** and **SCCS** (**Source Code Control System**), is that the whole
    repository (that is, all of the files that comprise the versioned project) is
    treated atomically. In other words, the repository can be at one version or another,
    but never in an in-between state where some files are at an earlier revision than
    others.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分布式版本控制系统（DVCS），将本地项目纳入版本控制非常简单，因此即使是玩具项目和原型也可以进行版本控制。这使得它们比早期的系统（如**RCS**（反应控制系统）和**SCCS**（源代码控制系统））更适合版本控制本地文件，因为这些系统将整个仓库（即构成版本化项目的所有文件）视为原子单元。换句话说，仓库可以处于一个版本或另一个版本，但永远不会处于一个中间状态，其中某些文件比其他文件的版本更早。
- en: Earlier systems, like RCS, do not impose this restriction. With RCS, every file
    is versioned independently so each can be checked out on a different version.
    While this is more flexible, it does introduce certain problems. For example,
    consider the files in the following figure. One of the files contains a function
    that's used in code in the other file. You need to make a change to the function's
    signature, to add a new parameter. This means changing all three files.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的系统，如RCS，没有这种限制。在RCS中，每个文件都是独立版本化的，因此每个文件都可以在不同的版本上检出。虽然这更灵活，但也引入了某些问题。例如，考虑以下图中的文件。其中一个文件包含一个在其他文件中使用的函数。您需要更改函数的签名，以添加一个新参数。这意味着需要更改所有三个文件。
- en: '![Figure 4.1: A dependency that crosses multiple files](img/B15099_04_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1：跨越多个文件的依赖关系](img/B15099_04_01.jpg)'
- en: 'Figure 4.1: A dependency that crosses multiple files'
  id: totrans-20
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.1：跨越多个文件的依赖关系
- en: In an atomic version control system, the files can either both be checked out
    at the revision with one parameter or both be checked out at the revision with
    two parameters. A per-file versioning system will allow any combination of versions
    to be checked out, despite the fact that half of the possible combinations do
    not make sense.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在原子版本控制系统中，文件可以同时使用一个参数检出特定版本的文件，或者同时使用两个参数检出特定版本的文件。一个按文件版本化的系统将允许检出任何版本的组合，尽管其中一半的组合没有意义。
- en: Once you've got a project that's locally versioned in a DVCS repository, sharing
    it with others is simple and can be done in numerous ways. If you want to back
    up or share the repository on a hosted service like **BitBucket**—[http://www.bitbucket.org](http://www.bitbucket.org),
    you set that up as a remote repository and push your content. A collaborator can
    then clone the repository from the remote version and start working on the code.
    If they're on the same network as you, then you can just share the folder containing
    the repository without setting up a remote service.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在DVCS仓库中本地版本化了项目，与他人共享就变得简单，可以通过多种方式完成。如果您想在像**BitBucket**这样的托管服务上备份或共享仓库——[http://www.bitbucket.org](http://www.bitbucket.org)，您将其设置为远程仓库并推送内容。然后，合作者可以从远程版本克隆仓库并开始工作。如果他们与您在同一网络中，那么您只需共享包含仓库的文件夹，而无需设置远程服务。
- en: Personal Experience
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 个人经验
- en: In some situations, a combination of these approaches is required. The DVCS
    tools that I've used all support that. On one recent project, everything was hosted
    on a remote service but there were hundreds of megabytes of assets stored in the
    repository. It made sense for the computers in the office to not only clone the
    remote repository, but also to peer with each other to reduce the time and bandwidth
    used when the assets changed. The situation looked like the following figure.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，需要这些方法的组合。我使用的所有DVCS工具都支持这一点。在一个最近的项目中，所有内容都托管在远程服务上，但仓库中存储了数百兆字节的资产。对于办公室的计算机来说，不仅克隆远程仓库，而且相互对等以减少资产更改时的时间和带宽使用是有意义的。这种情况看起来如下图所示。
- en: '![Figure 4.2: A DVCS configuration can break out of the “star” topology required
    by centralized systems](img/B15099_04_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2：分布式版本控制系统的配置可以摆脱集中式系统所需的“星形”拓扑结构](img/B15099_04_02.jpg)'
- en: 'Figure 4.2: A DVCS configuration can break out of the "star" topology required
    by centralized systems'
  id: totrans-26
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.2：分布式版本控制系统的配置可以摆脱集中式系统所需的“星形”拓扑结构
- en: Doing this with a centralized version control system would've been possible,
    but ugly. One of the developers would've needed to fully synchronize their working
    copy with the server, then fully copy the repository and its metadata to all of
    the other developer systems. This is less efficient than just copying the differences
    between the repositories. Some centralized version control systems wouldn't even
    support that way of working, because they track which files they think you have
    checked out on the server.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用集中式版本控制系统来做这件事是可能的，但会很丑陋。其中一个开发者需要完全同步他们的工作副本与服务器，然后将整个仓库及其元数据完全复制到所有其他开发者的系统上。这比仅仅复制仓库之间的差异要低效。一些集中式版本控制系统甚至不支持这种方式，因为它们跟踪他们认为你在服务器上签出的文件。
- en: Another benefit brought by DVCS – as much due to improved algorithms as their
    distributed nature – is the ease with which you can create and destroy branches.
    When I mainly worked with centralized version control (primarily Subversion and
    Perforce), branches were created for particular tasks, such as new releases, and
    the teams I worked on invented workflows for deciding when code migrated from
    one branch to another.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: DVCS带来的另一个好处——部分归功于改进的算法，也归功于其分布式特性——是创建和销毁分支的便捷性。当我主要使用集中式版本控制（主要是Subversion和Perforce）时，分支是为特定任务创建的，比如新版本发布，而我所在的团队发明了工作流程来决定何时将代码从一条分支迁移到另一条分支。
- en: With DVCSes, I often create a branch every hour or so. If I want to start some
    new work, I create a branch in my local version of the repository. After a while,
    I'm either done, and the branch gets merged and deleted; convinced that the idea
    was wrong - in which case, it's just deleted; or I want someone else to have a
    look, and I push that branch without merging it. All of this was possible with
    centralized VCS, though much slower – and you needed network access to even create
    the branch.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在DVCS中，我经常每小时创建一个分支。如果我想开始一些新的工作，我会在本地仓库版本中创建一个分支。过了一段时间，我可能完成了，分支被合并并删除；或者我确信这个想法是错误的——在这种情况下，它只是被删除；或者我想让别人看看，我就不合并这个分支而将其推送到远程。所有这些在集中式VCS中都是可能的，尽管速度慢得多——而且你需要网络访问才能创建分支。
- en: Continuous Integration and Deployment
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续集成与持续部署
- en: Having just discussed version control, it's time to announce which VCS mistake
    I see more often than any other - the mistake that's made by everyone (myself
    included), regardless of their experience or expertise. And the winner is…
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在刚刚讨论了版本控制之后，是时候宣布我看到的比其他任何错误都更频繁的VCS错误了——这个错误是每个人（包括我自己）都会犯的，无论他们的经验或专业知识如何。获胜者是…
- en: '*Adding new files to a project but forgetting to add them to the repository.*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*在项目中添加新文件，但忘记将其添加到仓库中。*'
- en: I don't do this *very* often - maybe less than once per month. But whenever
    I do, when the other developers on the team synchronize their repositories, we're
    left in a situation where everything works for me, but they can't build.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不经常这样做——可能每月不到一次。但每次我这样做，当团队中的其他开发者同步他们的仓库时，我们就会陷入一种情况：对我而言一切正常，但他们无法构建。
- en: If we're lucky, the error will report that the file wasn't found, and we can
    quickly resolve the problem. If not, there'll be some other error about a missing
    symbol or something that will take time to track down before discovering the root
    cause.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们很幸运，错误报告将指出文件未找到，我们可以快速解决问题。如果不这样，可能会有一些其他错误，比如缺失符号或其他需要花费时间追踪的问题，在发现根本原因之前。
- en: If only we had some form of robot that would see every check-in, grab the source
    code, and try to build the product. If it couldn't do that, it'd be great if it
    came over and complained to the person who made the change that broke the build.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一种形式的机器人，它会看到每一次的提交，获取源代码，并尝试构建产品。如果它做不到，如果它出现并抱怨导致构建失败的人，那就太好了。
- en: It turns out that we've been living in the future for quite a while now, and
    that robot already exists. It goes by the name of **Continuous Integration**,
    or CI.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，我们已经生活在未来一段时间了，那个机器人已经存在了。它被称为**持续集成**，或CI。
- en: Why Use CI?
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么使用持续集成？
- en: Finding those missing files isn't the only thing CI is good for. If you have
    automated tests (see the *Chapter 5, Coding Practices*), a CI system can run the
    tests on every change and report any problems. My team's CI server is configured
    to run the analysis tool (discussed in this chapter) and consider a build failed
    if that tool discovers any problems. Some projects automatically generate API
    documentation and publish it to a web server.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 找到那些缺失的文件并不是 CI 好处的唯一之处。如果你有自动化测试（见*第 5 章，编码实践*），CI 系统可以在每次更改时运行测试，并报告任何问题。我团队的
    CI 服务器配置为运行分析工具（本章讨论），如果该工具发现任何问题，则认为构建失败。一些项目会自动生成 API 文档并将其发布到 web 服务器上。
- en: 'It can even make the build available for people to install once it''s passed
    all of the tests. This is related to the idea of **Continuous Deployment**: if
    a version of the software seems good enough to use (that is, it doesn''t fail
    any test you put it through), then start using it. You may still find problems
    that weren''t exposed by the automated tests, but you''ll do so earlier than if
    you didn''t deploy right away.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦通过了所有测试，甚至可以让构建对人们安装可用。这与**持续部署**的概念相关：如果软件的某个版本看起来足够好可以使用（也就是说，它没有失败你给它做的任何测试），那么就开始使用它。你仍然可能会发现自动化测试没有暴露的问题，但你会比没有立即部署时更早地发现这些问题。
- en: A final benefit to CI - one that's quite subtle but very useful – is that it
    forces you to set your project up so that it can be checked out of version control
    and built automatically. This means that even when a human programmer is working
    with the project, it's easy for them to get set up with the source and start being
    productive. That person could be you, when you get a new laptop. It could be a
    contractor or a new employee joining the team. Either way, if there's a single
    step to fetch the project and build it, then they'll be up to speed quickly, rather
    than asking you how to fetch some library or configure some plugin.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: CI 的一个最终好处——虽然相当微妙但非常有用——是它迫使你设置你的项目，以便可以从版本控制中检出并自动构建。这意味着即使当人类程序员在处理项目时，他们也很容易设置源代码并开始变得高效。那个人可能是你，当你得到一台新笔记本电脑时。也可能是承包商或加入团队的新的员工。无论如何，如果只有一个步骤可以获取项目并构建它，那么他们可以快速上手，而不是询问你如何获取某个库或配置某个插件。
- en: CI On Real Teams
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CI 在真实团队中的应用
- en: Some teams I've worked on have been so heavily invested in using CI that they've
    employed someone to maintain the CI infrastructure (it's not a full-time occupation,
    so they usually look after other supporting tools and consult on their use). In
    other teams, it's been up to the developers to keep it running.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我参与过的某些团队对使用 CI 投入了极大的热情，以至于他们雇佣了专人维护 CI 基础设施（这不是一份全职工作，所以他们通常还会负责其他支持工具的维护并对其使用提供咨询）。在其他团队中，维护
    CI 的责任则落在了开发者身上。
- en: The difficulty in that second case is in knowing when to look after the CI versus
    doing project work. As an example, in the month before this section was written,
    I had to migrate my team's CI system onto different hardware. Despite trying to
    ensure that the configuration of the system didn't change between the two environments,
    the tests in one of the projects would no longer run.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，困难在于知道何时照顾 CI 而不是做项目工作。例如，在本节编写前的一个月，我不得不将我团队的 CI 系统迁移到不同的硬件上。尽管我试图确保系统配置在两个环境之间没有变化，但其中一个项目中的测试将不再运行。
- en: The thing is, the tests worked fine in the IDEs on all of the developer machines.
    Is it really important to take more time away from adding value to the products
    our clients are paying for to handhold some confused robot?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，测试在所有开发者的 IDE 上都运行得很好。我们真的需要花费更多的时间从增加客户支付的产品价值中抽离出来，去手把手地指导一些困惑的机器人吗？
- en: I consider running without CI to be proceeding at risk these days. Yes, I *could*
    avoid all problems without it. Yes, it's *possible* that nothing will go wrong.
    But why take the chance? Why not spend that little extra to ensure I discover
    problems as early as possible? It's spending a little now to potentially save
    a lot in the future. I therefore try to find the time to maintain the CI service
    when it's necessary.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为现在不使用 CI 进行开发是有风险的。是的，没有它，我*可以*避免所有问题。是的，*可能*不会出任何问题。但为什么要冒险呢？为什么不花一点额外的时间来确保我尽早发现问题呢？这是现在花一点时间，以备将来可能节省很多。因此，我试图在必要时找到时间维护
    CI 服务。
- en: Build Management
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建管理
- en: I wrote in the previous section that a benefit of adopting CI is that it forces
    you to simplify the building of your project (by which I mean compiling sources,
    translating assets, creating packages, and anything else that takes the inputs
    created by the project team and converts them into a product that will be used
    by customers). Indeed, to use CI you will have to condense the build down until
    an automated process can complete it given any revision of your source code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我提到采用 CI 的好处之一是它迫使你简化项目的构建（我的意思是编译源代码、转换资源、创建包以及任何其他将项目团队创建的输入转换为将被客户使用的产品的操作）。确实，为了使用
    CI，你必须将构建过程压缩到自动化流程可以在任何源代码修订后完成它的程度。
- en: 'There''s no need to write a script or an other program to do this work, because
    plenty of build management tools already exist. At a high level, they all do the
    same thing: they take a collection of input files, a collection of output files,
    and some information about the transformations needed to get from one to the other.
    How they do that, of course, varies from product to product.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要编写脚本或其他程序来完成这项工作，因为已经存在大量的构建管理工具。从高层次来看，它们都做同样的事情：它们接受一组输入文件、一组输出文件，以及一些关于如何从一组到另一组进行转换的信息。当然，它们如何做到这一点因产品而异。
- en: Convention or Configuration
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 习惯或配置
- en: Some build systems, like `make` and `ant`, need the developer to tell them nearly
    everything about a project before they can do anything. As an example, while `make`
    has an implicit rule for converting C source files into object files, it won't
    actually execute that rule until you tell it that you need the object file for
    something.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一些构建系统，如 `make` 和 `ant`，需要在它们能够做任何事情之前，让开发者几乎告诉它们关于项目的所有信息。例如，虽然 `make` 有一个将
    C 源文件转换为目标文件的隐式规则，但它实际上不会执行该规则，直到你告诉它你需要目标文件用于某个目的。
- en: Conversely, other tools (including Maven) make certain assumptions about a project.
    Maven assumes that every `.java` file in a folder called `src/main/java` must
    be compiled into a class that will be part of the product.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，其他工具（包括 Maven）对项目有一些假设。Maven 假设名为 `src/main/java` 的文件夹中的每个 `.java` 文件都必须编译成一个将成为产品一部分的类。
- en: The configuration approach has the advantage that it's discoverable even to
    someone who knows little about the system. Someone armed with a collection of
    source files, `grep`, and a little patience could work out from a `Makefile` or
    `Xcode` project which files were built as which targets, and how. Because there's
    a full (or near full) specification of how everything's built, you can find what
    you need to change to make it act differently, too.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 配置方法的优点是，即使对系统了解不多的人也能发现它。有人手持一组源文件、`grep` 和一点耐心，可以从 `Makefile` 或 `Xcode` 项目中找出哪些文件被构建成了哪些目标，以及如何构建。因为有一个完整的（或几乎是完整的）关于如何构建一切的规范，你可以找到需要更改的内容，以便使其行为不同。
- en: The downside to that discoverability is that you *have* to specify all that
    stuff. You can't just tell Xcode that any `.m` file in a folder called `Classes`
    should be passed to the Objective-C compiler; you have to give it a big list of
    all of them. Add a new file, and you must change the list.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种可发现性的缺点是，你必须指定所有这些内容。你不能只是告诉 Xcode，名为 `Classes` 的文件夹中的任何 `.m` 文件都应该传递给 Objective-C
    编译器；你必须给它一个包含所有这些文件的庞大列表。添加一个新文件，你必须更改这个列表。
- en: With a convention-based build system, this situation is exactly reversed. If
    you follow the conventions, everything's automatic. However, if you don't *know*
    the conventions, they can be hard to discover. I once had a situation on a *Rails*
    project where the folder that static resources (such as images) were saved in
    changed between two releases. On launching the app, none of my images were being
    used and it wasn't clear why. Of course, for someone who *does* know the conventions,
    there's no learning curve associated with transferring between different projects.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于习惯的构建系统中，这种状况正好相反。如果你遵循习惯，一切都会自动完成。然而，如果你不知道这些习惯，它们可能很难发现。我曾经在一个 *Rails*
    项目中遇到过这样的情况，静态资源（如图像）保存的文件夹在两个版本之间发生了变化。在启动应用程序时，我的所有图像都没有被使用，而且不清楚原因。当然，对于知道这些习惯的人来说，在不同项目之间转移时没有学习曲线。
- en: On balance, I'd prefer a convention-led approach, provided the conventions are
    well-documented somewhere so it's easy to find out what's going on and how to
    override it if you need to. The benefit of reduced effort and increased consistency,
    for me, outweighs the occasional surprise that's encountered.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，我更喜欢一种由惯例引导的方法，前提是这些惯例在某处有很好的文档记录，这样就可以轻松地了解发生了什么，以及当你需要时如何覆盖它。对我来说，减少努力和增加一致性的好处超过了偶尔遇到的惊喜。
- en: Build Systems That Generate Other Build Systems
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成其他构建系统的构建系统
- en: Some build procedures get so complicated that they spawn another build system
    that configures the build environment for the target system before building. An
    archetypal example is GNU Autotools, – which actually has a three-level build
    system. Typically, developers will run `autoconf`, a tool that examines a project
    to find out what questions the subsequent step should ask and generates a script
    called `configure`. The user downloads the source package and runs `configure`,
    which inspects the compilation environment and uses a collection of macros to
    create a Makefile. The Makefile can then compile the source code to (finally!)
    create the product.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一些构建过程变得如此复杂，以至于它们产生了另一个构建系统，在构建之前为目标系统配置构建环境。一个典型的例子是GNU Autotools，——它实际上有一个三级构建系统。通常，开发者会运行`autoconf`，这是一个检查项目以确定后续步骤应该提出什么问题的工具，并生成一个名为`configure`的脚本。用户下载源代码包并运行`configure`，它会检查编译环境并使用一系列宏来创建一个Makefile。然后Makefile可以编译源代码（最终！）创建产品。
- en: As argued by *Poul-Henning Kamp*—[http://queue.acm.org/detail.cfm?id=2349257](http://queue.acm.org/detail.cfm?id=2349257)),
    this is a bad architecture that adds layers of cruft to work around code that
    has not been written to be portable to the environments it will be used in. Software
    written to be built with tools like these is hard to read, because you must read
    multiple languages just to understand how one line of code works.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如*Poul-Henning Kamp*所论证——[http://queue.acm.org/detail.cfm?id=2349257](http://queue.acm.org/detail.cfm?id=2349257))，这是一个糟糕的架构，它增加了不必要的层来处理那些没有编写成可移植到将使用其环境的代码。用这些工具编写的软件难以阅读，因为你必须阅读多种语言才能理解一行代码是如何工作的。
- en: Consider a bug reported in a particular C function in your project. You open
    that function to find two different implementations, chosen by a `#ifdef/#else/#endif`
    preprocessor block. You search for the macro used by that block and find it in
    `config.h`, so you must read the `configure` script to find out how it's set.
    To discover whether *that* test is doing the right thing, you need to look at
    the `configure.ac` file to find out how the test is generated.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑你在项目中报告的一个特定C函数中的缺陷。你打开该函数，发现有两个不同的实现，由一个`#ifdef/#else/#endif`预处理器块选择。你搜索该块使用的宏，并在`config.h`中找到它，因此你必须阅读`configure`脚本以了解它是如何设置的。为了发现*那个*测试是否做得正确，你需要查看`configure.ac`文件以了解测试是如何生成的。
- en: About the only justification for using such a convoluted process is that it's
    thought of as conventional and expected by your target users, but even then, I'd
    question whether that expectation is driven by a technical need or by **Stockholm
    syndrome** — [http://en.wikipedia.org/wiki/Stockholm_syndrome](http://en.wikipedia.org/wiki/Stockholm_syndrome).
    If your product doesn't need to be portable, then there's no need to add all that
    complexity – and even if it does, there may be better ways to solve the problem
    that'll work for your product. One obvious approach is to target a portable platform
    such as Mono or Python.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种复杂过程的唯一理由可能是它被认为是一种传统，并且你的目标用户期望这样做，但即使如此，我也会质疑这种期望是由技术需求还是由**斯德哥尔摩综合症**——[http://en.wikipedia.org/wiki/Stockholm_syndrome](http://en.wikipedia.org/wiki/Stockholm_syndrome)驱动的。如果你的产品不需要可移植性，那么就没有必要增加所有这些复杂性——即使它确实需要，也可能有更好的方法来解决你的产品的问题。一个明显的方法是针对可移植平台，如Mono或Python。
- en: Bug and work tracking
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺陷和工作跟踪
- en: For most of their history, computers have excelled at doing things one at a
    time. Even a single client or customer can parallelize much better than that and
    will think of (and make) multiple requests while you're still working on one thing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在它们的大部分历史中，计算机擅长一次只做一件事。即使是一个单独的客户或用户也能比这更好地并行处理，在你还在处理一件事的时候，他们可能会想出（并制作）多个请求。
- en: It's really useful to write all of these requests down, and keep track of where
    you and your colleagues are on each of them so that you don't all try to solve
    the same problem, and can let the client know which of them you've fixed. Bug
    trackers (sometimes more generally called issue trackers or work trackers) are
    designed to solve that problem.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些请求都写下来并跟踪你和你的同事在每个请求上的进度，这样你们就不会都试图解决相同的问题，并且可以通知客户哪些问题已经修复。bug跟踪器（有时更通称为问题跟踪器或工作跟踪器）旨在解决这个问题。
- en: What Goes in And When?
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 何时以及什么内容进入？
- en: 'I''ve worked on projects where the bug tracker gets populated with all of the
    project''s feature requests at the beginning (this discussion overlaps slightly
    with the treatment of software project management patterns, in *Chapter 13, Teamwork*).
    This introduces a couple of problems. One is that the **Big List** needs a lot
    of grooming and editing to stay relevant as features are added and removed, split
    between multiple developers, or found to be dependent on other work. The second
    is psychological: for a long time, members of the project team will be looking
    at a soul-destroying list of things that still haven''t been done, like Sisyphus
    standing with his rock looking up from the base of the hill. The project will
    seem like a death march from the beginning.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我参与过一些项目，其中bug跟踪器在项目开始时就被所有项目功能请求填满（这个讨论与第13章“团队合作”中软件项目管理模式的处理略有重叠）。这引入了一些问题。一个是**大列表**需要大量的梳理和编辑，以保持相关性，因为功能被添加和删除，分散在多个开发者之间，或者被发现依赖于其他工作。第二个是心理上的：在很长的一段时间里，项目团队成员将看到令人沮丧的尚未完成的事项列表，就像西西弗斯站在山脚下仰望他的石头一样。项目从一开始就会像死亡行军一样。
- en: My preference is to attack the work tracker with an iterative approach. When
    it's decided what will go into the next build, add those tasks to the work tracker.
    As they're done, mark them as closed. The only things that stay in the tracker
    from one iteration to the next are those things that don't get completed in the
    build when they were scheduled to. Now, the big list of items in the tracker is
    always the big list of what we've already completed, not the big list of things
    still remaining. This is something akin to the Kanban system, where a team will
    have a fixed "capacity" of pending work. As they pull work from the pending bucket
    to start working on it, they can request that the bucket get topped up—but never
    past its capacity.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我的偏好是采用迭代方法来攻击工作跟踪器。当决定下一个构建将包含哪些内容时，将这些任务添加到工作跟踪器中。完成它们后，标记为已关闭。唯一从一次迭代保留到下一次迭代的东西是那些在计划中未能完成的任务。现在，跟踪器中的大列表始终是我们已经完成的大列表，而不是仍然剩下的大列表。这与看板系统类似，团队将有一个固定的“容量”的待办工作。当他们从待办桶中提取工作开始工作时，他们可以要求桶得到补充——但永远不要超过其容量。
- en: My approach to reporting bugs is different. Unless it's something trivial in
    the code I'm working on now, so that I can fix the problem in under a couple of
    minutes and move on, I'll always report it straight away. This means I won't forget
    about the problem; the fix is implicitly planned for the next iteration, following
    the **Joel Test** rule of fixing bugs before adding new code, and we can see how
    many bugs are being discovered in each build of the product. (Now that I reflect
    on the Joel Test, I realize that this chapter covers a lot of points that are
    included in the test. Perhaps you should just measure your team's performance
    with respect to the Joel test's 12 points and fix any that you answer "no" to—[http://www.joelonsoftware.com/articles/fog0000000043.html](http://www.joelonsoftware.com/articles/fog0000000043.html).).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我报告bug的方法不同。除非是我在现在工作的代码中的小事，这样我可以在几分钟内解决问题并继续前进，否则我总会立即报告。这意味着我不会忘记问题；修复是隐式地计划在下一个迭代中进行的，遵循**乔尔测试**规则，即在添加新代码之前修复bug，我们可以看到每个产品构建中发现了多少bug。（现在回想起来，我意识到这一章涵盖了测试中包含的许多要点。也许你应该只测量你团队相对于乔尔测试的12个点的表现，并修复你回答“否”的任何问题——[http://www.joelonsoftware.com/articles/fog0000000043.html](http://www.joelonsoftware.com/articles/fog0000000043.html)）。
- en: How Precisely to Track?
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何精确跟踪？
- en: So, you managed to fix that bug in 2 hours. But, was it *actually* 2 hours,
    or was it 125 minutes? Did you spend those 2 hours solely fixing the bug, or did
    you answer that email about the engineers-versus-sales whist drive during that
    time?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你设法在2小时内修复了那个bug。但是，它实际上是2小时吗，还是125分钟？你花了那2小时仅仅修复bug，还是在这段时间内还回答了关于工程师与销售之间的口哨赛跑的邮件？
- en: Being able to compare estimated time versus actual time can be useful. I'm not
    sure that "velocity" – the ratio between the estimated time and the actual time
    spent on tasks – is particularly helpful, because in my experience estimates are
    not consistently wrong by a constant factor. It's knowing *what* work you're bad
    at estimating that's helpful. Do you fail to appreciate the risks involved in
    adding new features, or do you tend to assume all bug fixes are trivially simple?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 能够比较估计时间与实际时间可能是有用的。我不确定“速度”——估计时间与实际花费在任务上的时间的比率——特别有帮助，因为在我的经验中，估计并不总是以一个常数因子错误。知道你**什么**工作估计得不好是有帮助的。你是否没有意识到添加新功能的风险，或者你是否倾向于认为所有错误修复都是微不足道的简单？
- en: So, precise measurements are not particularly helpful, which is useful to know,
    because the accuracy probably doesn't exist to back up that precision. I usually
    just look at my watch when I start work and when I end work, and round to the
    nearest quarter or half hour. That means my time records include all those interruptions
    and little tasks I did while fixing the bug – which is fine because they slowed
    me down and that needs recording.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，精确的测量并不特别有帮助，了解这一点是有用的，因为准确性可能并不存在来支持这种精确度。我通常只在开始工作和结束工作的时候看我的手表，并四舍五入到最近的十五分钟或半小时。这意味着我的时间记录包括了我在修复错误时所做的所有那些中断和小的任务——这是可以接受的，因为它们减慢了我的速度，这需要记录。
- en: 'Estimates aren''t even that accurate. The game I play with my team goes like
    this: every developer on the team (and no one else) independently writes down
    an estimate of how long the tasks we''re planning will take. They''re allowed
    to pick one of these: 1 hour, 2 hours, 4 hours, 8 hours, or don''t know. If we
    think a task will take longer than 8 hours, we break it down and estimate smaller
    chunks of the task.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 估计甚至并不那么准确。我和我的团队玩的游戏是这样的：团队中的每个开发者（只有开发者）独立写下我们计划的任务预计需要多长时间。他们可以从中选择以下之一：1小时、2小时、4小时、8小时，或者不知道。如果我们认为一个任务将需要超过8小时，我们会将其分解并估计更小的任务部分。
- en: For each task, everyone presents their estimates. If they're roughly the same,
    then we just pick the highest number and go with that. If there's a spread of
    opinion – maybe one developer thinks something will take an hour when someone
    else thinks it'll take a day – we'll discuss that. Probably, one (or more) of
    the team is relying on tacit knowledge that needs to be brought into the open.
    It's usually possible to resolve such differences quickly and move on to the next
    thing.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个任务，每个人都提出他们的估计。如果他们的估计大致相同，那么我们就选择最大的数字并继续。如果有意见分歧——也许一个开发者认为某件事需要一个小时，而另一个人认为需要一天——我们会讨论这个问题。很可能，团队中的一个人（或更多人）依赖于需要公开的隐性知识。通常，可以快速解决这些差异并继续下一件事。
- en: Integrated Development Environment
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成开发环境
- en: Well, really, I suppose your environment doesn't need to be fully integrated.
    For a long time, my toolset was a combination of Project Builder, Interface Builder,
    WebObjects Builder, EOModeler, and Edit. It *does* need to make you more efficient
    than the simple "text editor and `make`" combo of yore.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，实际上，我想你的环境并不需要完全集成。长期以来，我的工具集是项目构建器、界面构建器、WebObjects构建器、EOModeler和编辑器的组合。它确实需要比简单的“文本编辑器和`make`”组合更高效。
- en: What's the big problem? Why so harsh on the text editor? Any time you have to
    stop making software to deal with your tools, there's a chance you'll lose concentration,
    forget what you were doing, and have to spend a few minutes reacquainting yourself
    with the problem. Losing a couple of minutes doesn't sound like too big a deal,
    but if you're doing it a couple of times an hour every working day, it quickly
    adds up to a frustrating drop in productivity.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 什么大问题？为什么对文本编辑器这么苛刻？每次你必须停止制作软件来处理你的工具时，你都有可能失去注意力，忘记你在做什么，然后需要花几分钟重新熟悉问题。失去几分钟听起来并不像什么大问题，但如果你每天工作的时候每小时都这样做几次，它很快就会变成一个令人沮丧的生产力下降。
- en: You're going to be using your IDE for most of your working day, *every* working
    day, for the next few years. You should invest heavily in it. That means spending
    a bit of money on a good one that's better than the free alternatives. It means
    training yourself in the tricks and shortcuts so you can do them without thinking,
    saving the occasional second and (more importantly) keeping you focused on the
    work. It can even mean writing plugins, if your environment supports them, so
    you can do more without context-switching.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几年里，你将大部分工作时间都在使用你的 IDE，*每一天*都在使用。你应该在它上面进行大量投资。这意味着为一个好的 IDE 花一些钱，它比免费的替代品更好。这意味着训练自己掌握技巧和快捷方式，这样你就可以不用思考就能完成它们，节省偶尔的几秒钟，更重要的是，保持你专注于工作。如果你的环境支持，甚至可能意味着编写插件，这样你就可以在不切换上下文的情况下做更多的事情。
- en: In some plugin-rich environments, you could go a whole day without ever leaving
    the IDE. For example, Eclipse now includes the **Mylyn** ([http://eclipse.org/mylyn/start/](http://eclipse.org/mylyn/start/))
    task-focused plugin, so you can interact with your bug tracker inside the IDE.
    It'll also let you focus your views on only those files related to the task you're
    currently working on.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些插件丰富的环境中，你可能会整天都待在集成开发环境（IDE）里，从未离开过。例如，Eclipse 现在包括了**Mylyn** ([http://eclipse.org/mylyn/start/](http://eclipse.org/mylyn/start/))这样一个以任务为中心的插件，因此你可以在
    IDE 内部与你的缺陷跟踪器进行交互。它还会让你只关注与你当前正在工作的任务相关的文件。
- en: Not only do you need to go deep on your chosen IDE, you need to go broad on
    alternatives. A future version of your favorite tool might change things so much
    that you'd be more efficient switching to a different app. Or you might start
    working on a project where your preferred IDE isn't available; for example, you
    can't (easily) write a Mono app in Xcode, or an Eclipse RCP application in Visual
    Studio.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅需要深入掌握你选择的 IDE，还需要广泛了解替代方案。你最喜欢的工具的未来版本可能会带来很大的变化，以至于你切换到不同的应用程序会更加高效。或者，你可能会开始在一个你首选的
    IDE 不可用的项目中工作；例如，你无法（轻易地）在 Xcode 中编写 Mono 应用程序，或者在 Visual Studio 中编写 Eclipse RCP
    应用程序。
- en: 'This restriction of development environments to particular platforms, whether
    done for technological or business reasons, is unfortunate. This is where the
    "just use a text editor" crowd has a point: you can learn `emacs` just once and
    whatever language you end up programming in, you don''t need to learn how to use
    the editor again just to write code. As you''re going to spend your whole working
    life in one of these environments, every change to features you already know how
    to use represents horrendous inefficiency.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这种将开发环境限制在特定平台上的限制，无论出于技术还是商业原因，都是不幸的。这正是“只需使用一个文本编辑器”的人群有道理的地方：你可以一次性学习 `emacs`，无论你最终使用哪种编程语言，你都不需要再次学习如何使用编辑器来编写代码。既然你将在这些环境中度过你整个职业生涯，那么你对已知功能的任何更改都代表着巨大的低效。
- en: Notice that all of the aforementioned IDEs follow the same common pattern. When
    people have the "which IDE is best?" argument, what they're actually discussing
    is "which slightly souped-up monospace text editor with a **build** button do
    you like using?" Eclipse, Xcode, IntelliJ, Visual Studio… All of these tools riff
    on the same design—letting you see the source code and change the source code.
    As secondary effects, you can also do things like build the source code, run the
    built product, and debug it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，上述所有 IDE 都遵循相同的通用模式。当人们争论“哪个 IDE 是最好的？”时，他们实际上讨论的是“你更喜欢使用哪个带有**构建**按钮的略微增强的等宽字体文本编辑器？”Eclipse、Xcode、IntelliJ、Visual
    Studio……所有这些工具都基于相同的设计——让你能够查看源代码并更改源代码。作为次要效果，你还可以执行诸如构建源代码、运行构建的产品以及调试它等操作。
- en: The most successful IDE in the world, I would contend (and then wave my hands
    unconvincingly when anyone asks for data), is one that's not designed like that
    at all. It's the one that is used by more non-software specialists than any of
    those already mentioned. The one that doesn't require you to practice being an
    IDE user for years before you get any good. The one that business analysts, office
    assistants, accountants, and project managers alike all turn to when they need
    their computer to run through some custom algorithm. The most successful IDE in
    the world is Excel.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为世界上最成功的 IDE 是一个根本不是那样设计的 IDE。它是那些比已经提到的任何 IDE 都被更多非软件专业人士使用的 IDE。它是那些不需要你练习多年才能成为一个优秀的
    IDE 用户之前就能获得好处的 IDE。它是当商业分析师、办公室助手、会计和项目经理需要他们的电脑运行一些自定义算法时都会转向的 IDE。世界上最成功的 IDE
    是 Excel。
- en: In a spreadsheet, it's the inputs and results that are front-and-center in the
    presentation, not the intermediate stuff that gets you from one to the other.
    You can test your "code" by typing in a different input and watching the results
    change in front of you. You can see intermediate results, not by breaking and
    stepping through, or putting in a log statement then switching to the log view,
    but by breaking the algorithm up into smaller steps (or functions or procedures,
    if you want to call them that). You can then visualize how these intermediate
    results change right alongside the inputs and outputs. That's quicker feedback
    than even REPLs can offer.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在电子表格中，最显眼的是输入和结果，而不是那些将你从一个带到另一个的中间过程。你可以通过输入不同的输入并观察结果在你面前变化来测试你的“代码”。你可以看到中间结果，不是通过中断和逐步执行，或者放入日志语句然后切换到日志视图，而是通过将算法分解成更小的步骤（或者如果你愿意可以称之为函数或过程）。然后你可以可视化这些中间结果是如何随着输入和输出的变化而变化的。这比REPLs提供的反馈更快。
- en: Many spreadsheet users naturally adopt a "test-first" approach; they create
    inputs for which they know what the results should be and make successively better
    attempts to build a formula that achieves those results. And, of course, interesting
    visualizations such as graphs are available (though the quality does vary between
    products). Drawing a graph in Xcode is… challenging. Indeed, you can't do it at
    all, but you can get Xcode to create an application that can itself generate a
    graph. The results are a significant distance away from the tools.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 许多电子表格用户自然采用“测试优先”的方法；他们为已知结果应该是什么的输入创建输入，并逐步尝试构建一个能够实现这些结果的公式。当然，还有有趣的可视化，如图表等（尽管产品的质量各不相同）。在Xcode中绘制图表是……具有挑战性的。确实，你根本无法做到这一点，但你可以让Xcode创建一个可以自己生成图表的应用程序。结果与工具相去甚远。
- en: Static Analysis
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态分析
- en: In the *Chapter 5, Coding Practices*, there's a section on *Code Reviews*. Knowing
    that reviewers will find and fixate upon the simplest problems they can find,
    wouldn't it be great to remove all the trivial problems so that they're forced
    to look for something more substantial?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在**第5章，编码实践**中，有一个关于**代码审查**的部分。考虑到审阅者会找到并专注于他们能找到的最简单的问题，如果能够消除所有这些琐碎的问题，迫使他们寻找更实质性的问题，那岂不是很好？
- en: This is what static analysis does. It finds problems in code that can be automatically
    discovered without running the product, but that are either off-topic for compiler
    warnings or take too long to discover for the compiler to be an appropriate tool
    to search for them.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是静态分析所做的事情。它可以在不运行产品的情况下自动发现代码中的问题，但这些问题的离题性质使得编译器警告不适用，或者发现这些问题的速度太慢，以至于编译器不适合作为搜索它们的工具。
- en: 'What are off-topic problems? Typically, those that require knowledge of the
    semantics of the functions or methods you''re using – knowledge that''s beyond
    the scope of the compiler. For example, consider a C++ `destroyObject<T>(T t)`
    function that *deletes* its parameter. Calling that function twice with the same
    argument would be an error – but the compiler doesn''t know that if it''s just
    inspecting the function signature. Others are a matter of style. For example,
    Apple''s C APIs have a naming convention related to their memory management rules:
    a function name contains `Create` when the caller owns the returned object or
    `Get` when the `callee` does. It''s not a mistake to use C language to mix those
    up, so the compiler won''t tell you about it, but an analyzer can.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是离题问题？通常，那些需要了解你使用的函数或方法的语义的问题——这种知识超出了编译器的范围。例如，考虑一个C++的`destroyObject<T>(T
    t)`函数，它会**删除**其参数。用相同的参数调用该函数两次将是一个错误——但是编译器并不知道这一点，如果它只是检查函数签名的话。其他问题则是关于风格的。例如，苹果的C语言API有一个与其内存管理规则相关的命名约定：当调用者拥有返回的对象时，函数名包含`Create`；当`callee`拥有时，包含`Get`。使用C语言混合这些名称并不是错误，所以编译器不会告诉你，但分析器可以。
- en: There is basically no reason to avoid using a static analyzer (if your reason
    is that there isn't one for your language/framework/whatever yet, you might have
    chosen a language/framework/whatever that isn't ready yet. There's a section about
    that in *Chapter 12, Business*). It'll discover easily fixable bugs for you and
    quickly train you into not making those mistakes in the first place.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上没有理由避免使用静态分析器（如果你的理由是还没有为你使用的语言/框架/等等提供静态分析器，你可能选择了一个尚未准备好的语言/框架/等等。关于这一点，在第12章“商业”中有一个部分）。它将为你发现容易修复的错误，并迅速训练你从一开始就不犯这些错误。
- en: Code Generation
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码生成
- en: There are, in many applications, plenty of features that are trivial to implement
    but must be done over and over. Perhaps it's taking an array of model objects
    and preparing a list view, creating classes from database schemata, or creating
    a list of compile-time constants from a text file.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多应用中，有很多功能实现起来很简单，但必须反复执行。也许是将模型对象的数组转换为列表视图，从数据库模式创建类，或者从文本文件创建编译时常量列表。
- en: These situations can usually be automated by generating code. The idea is to
    express the problem in a succinct representation, then translate that into something
    that can be incorporated into your program. This is pretty much what a compiler
    does; though many programming languages are far from succinct, they're still much
    less unwieldy than the machine's native instruction code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些情况通常可以通过生成代码来自动化。想法是将问题表达在一个简洁的表示中，然后将其翻译成可以集成到你的程序中的东西。这正是编译器所做的事情；尽管许多编程语言远非简洁，但它们仍然比机器的本地指令代码要容易操作得多。
- en: Writing Your Own Generator Shouldn't Be A First Resort
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写自己的生成器不应是首选方案
- en: Just as a code generator makes it easier to create a product, it makes it harder
    to debug. For a concrete example, consider the `autotools` build system discussed
    earlier in this chapter. Imagine that a developer is looking into a reported problem
    in which one of the tests fails (a problem that I had to deal with today). The
    log file tells them what the C program was that encapsulated the test, but the
    developer cannot just modify that program. They must discover where the `configure`
    script is generating that program, and what it's trying to achieve by doing so.
    They must then find out where in `configure.ac` that section of the shell script
    is generated and work out a change to the `m4` macros that will result in the
    desired change to the C program, two steps later.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如代码生成器使创建产品变得更容易一样，它也使得调试变得更困难。以本章前面讨论的`autotools`构建系统为例。想象一下，一个开发者正在调查一个报告的问题，其中一个测试失败了（今天我不得不处理的问题）。日志文件告诉他们哪个C程序封装了测试，但开发者不能直接修改那个程序。他们必须发现`configure`脚本在哪里生成那个程序，以及它是通过什么方式尝试达到这个目的的。然后他们必须找出在`configure.ac`中那个shell脚本的部分是如何生成的，并找出对`m4`宏的修改，以便在两步之后实现C程序的期望变化。
- en: In short, if your target environment offers facilities to solve your problem
    natively, such a solution will require less reverse engineering when diagnosing
    later problems. It's only if such a solution is overly expensive or error-prone
    that code generation is a reasonable alternative.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，如果你的目标环境提供了原生解决你问题的工具，那么在诊断后续问题时，这种解决方案将需要更少的逆向工程。只有当这种解决方案过于昂贵或容易出错时，代码生成才是一个合理的替代方案。
- en: Many of the cases given at the beginning of this section were data-driven, like
    the situation deriving class descriptions from a database schema for some **Object-Relational
    Mapping** (**ORM**) system. This is a case where some programming languages give
    you the ability to solve this problem without generating code in their language.
    If you can resolve messages sent to an object at runtime, then you can tell that
    object which table its object is in and it can decide whether any message corresponds
    to a column in that table. If you can add classes and methods at runtime, then
    you can generate all of the ORM classes when the app connects to the database.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 本节开头给出的许多案例都是数据驱动的，例如从数据库模式推导出某些**对象关系映射（ORM**）系统的类描述的情况。这是一个某些编程语言允许你解决此问题而不在它们的语言中生成代码的情况。如果你可以在运行时解析发送给对象的短信，那么你可以告诉该对象其对象所在的表，并且它可以决定任何消息是否对应于该表中的列。如果你可以在运行时添加类和方法，那么你可以在应用程序连接到数据库时生成所有的ORM类。
- en: The existence and applicability of such features depends very much on the environment
    you're targeting but look for and consider them before diving into writing a generator.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这种功能的存在和适用性在很大程度上取决于你针对的环境，但在开始编写生成器之前，寻找并考虑这些功能。
- en: When the Generator Won't Be Used by A Programmer
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当生成器不会被程序员使用时
- en: If the target "customer" for this facility isn't going to be another developer,
    then a generator can often be a better choice than a full-featured programming
    language, despite the increase in implementation complexity.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个设施的目标“客户”不是另一个开发者，那么尽管实现复杂度增加，生成器通常比功能齐全的编程语言是一个更好的选择。
- en: A solution that's often explored in this context is a **Domain-Specific Language**
    (**DSL**), a very limited programming language that exposes grammar and features
    much closer to the problem that the customer understands than to computer science
    concepts. Many projects that I've been involved with have used DSLs, because they
    offer a nice trade-off between letting the customer modify the system as they
    see fit and avoiding complex configuration mechanisms.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个背景下，经常探索的解决方案是**领域特定语言（DSL**），这是一种非常有限的编程语言，它暴露的语法和功能与客户理解的问题比计算机科学概念更接近。我参与过的许多项目都使用了DSL，因为它们在让客户根据需要修改系统与避免复杂的配置机制之间提供了一个很好的权衡。
- en: Case study
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 案例研究
- en: The "customer" using the application doesn't need to be the end user of the
    finished product. On one project I worked on, I created a DSL to give to the client
    so that they could define achievements used in the project's gamification feature.
    A parser app told them about any inconsistencies in their definitions, such as
    missing or duplicate properties, and also generated a collection of objects that
    would implement the rules for those achievements in the app. It could also generate
    a script that connected to the app store to tell it what the achievements were.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该应用程序的“客户”不一定是最终产品的终端用户。在我参与的一个项目中，我创建了一个领域特定语言（DSL）供客户使用，以便他们能够定义项目中用于游戏化功能的成绩。一个解析应用程序会告诉他们定义中的任何不一致性，例如缺失或重复的属性，并且还生成了一组对象，这些对象将在应用程序中实现这些成绩的规则。它还可以生成一个脚本，连接到应用商店，告诉它这些成绩是什么。
