- en: 7\. Everybody Falls, It's How You Get Back Up – Testing and Debugging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7. 每个人都会跌倒，重要的是你如何重新站起来——测试和调试
- en: Learning Objectives
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将能够：
- en: Describe different types of assertions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述不同类型的断言
- en: Implement compile-time and runtime assertions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施编译时和运行时断言
- en: Implement exception handling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施异常处理
- en: Describe and implement unit testing and mock testing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述并实施单元测试和模拟测试
- en: Debug C++ code using breakpoints and watchpoints
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用断点和监视点调试C++代码
- en: Inspect data variables and C++ objects in the debugger
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调试器中检查数据变量和C++对象
- en: In this chapter, you'll learn how to add assertions appropriately, add unit
    test cases so that code behaves as per the requirements, and learn about debugging
    techniques so that you can find bugs in the code and trace the root cause of them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何适当地添加断言，添加单元测试用例以使代码按照要求运行，并学习调试技术，以便您可以找到代码中的错误并追踪其根本原因。
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: During the **Software Development Life Cycle** (**SDLC**), once the requirement
    gathering phase is complete, then generally comes the Design and Architecture
    phase, wherein the high-level flow of the project is defined and broken down into
    smaller components of modules. When there are many team members in a project,
    it is necessary that each team member is clearly assigned a specific part of the
    module and that they are aware of their requirements. This way, they can independently
    write their part of the code in an isolated environment and make sure it works
    fine. Once their part of the work is complete, they can integrate their module
    with the other developer's modules and make sure the overall project is executing
    as per the requirements.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在**软件开发生命周期**（**SDLC**）中，一旦需求收集阶段完成，通常会进入设计和架构阶段，在这个阶段，项目的高级流程被定义并分解成模块的较小组件。当项目中有许多团队成员时，每个团队成员清楚地被分配了模块的特定部分，并且他们了解自己的要求是必要的。这样，他们可以在隔离的环境中独立编写他们的代码部分，并确保它能正常运行。一旦他们的工作部分完成，他们可以将他们的模块与其他开发人员的模块集成，并确保整个项目按照要求执行。
- en: This concept can be applied to small projects too, where the developer is completely
    working on a requirement, breaking it down into smaller components, developing
    components in an isolated environment, making sure it executes as per the plan,
    integrating all the small modules to complete the project, and finally testing
    it to ensure that the overall project is working fine.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念也可以应用于小型项目，其中开发人员完全致力于一个需求，将其分解为较小的组件，在隔离的环境中开发组件，确保它按计划执行，集成所有小模块以完成项目，并最终测试以确保整个项目正常运行。
- en: There is a good amount of testing required when the whole project is integrated
    and executed. There may be a separate team (known as `IP address` as a `string`,
    then the developer needs to ensure it is in the format `XXX.XXX.XXX.XXX`, where
    `X` is a digit from `0`-`9`. The length of the string must be of limited size.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 整合整个项目并执行时需要大量的测试。可能会有一个单独的团队（称为`IP地址`作为`字符串`，然后开发人员需要确保它的格式为`XXX.XXX.XXX.XXX`，其中`X`是`0`-`9`之间的数字。字符串的长度必须是有限的。
- en: 'Here, the developer can create a test program that executes their part of the
    code: parsing the file, extracting the `IP address` as a string, and testing if
    it is in the correct format. Similarly, if the configuration has other parameters
    to be parsed and they need to be in a specific format such as `userid` / `password`,
    file location for the log or mount point, and so on, then all these will be part
    of the unit testing for that module. In this chapter, we''ll explain techniques
    such as `assertions`, `safety nesting` (`exception handling`), `unit testing`,
    `mocking`, `breakpoints`, `watchpoints`, and `data visualization` to pinpoint
    the source of errors and limit their growth. In the next section, we''ll explore
    the assertion technique.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，开发人员可以创建一个测试程序来执行他们的代码部分：解析文件，提取`IP地址`作为字符串，并测试它是否处于正确的格式。同样，如果配置有其他需要解析的参数，并且它们需要以特定格式出现，比如`userid`/`password`，日志文件的位置或挂载点等，那么所有这些都将成为该模块的单元测试的一部分。在本章中，我们将解释诸如`断言`、`安全嵌套`（`异常处理`）、`单元测试`、`模拟`、`断点`、`监视点`和`数据可视化`等技术，以确定错误的来源并限制其增长。在下一节中，我们将探讨断言技术。
- en: Assertions
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 断言
- en: Using testing condition for the aforementioned scenario will help the project
    develop in a better way as the flaws will be caught at a base level rather than
    at the later QA level. There may be scenarios wherein even after writing the unit
    test cases and successful execution of the code, issues may be found sch as the
    application crashing, the program exiting unexpectedly, or the behavior is not
    as expected. To overcome such scenarios, generally, a developer uses a debug mode
    binary to recreate the problem. `Asserts` are used to ensure that the conditions
    are checked, otherwise the program's execution is terminated.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述情景使用测试条件将有助于项目更好地发展，因为缺陷将在基本层面被捕捉到，而不是在后期的QA阶段。可能会出现这样的情况，即使编写了单元测试用例并成功执行了代码，也可能会发现问题，比如应用程序崩溃、程序意外退出或行为不如预期。为了克服这种情况，通常开发人员使用调试模式二进制文件来重新创建问题。`断言`用于确保条件被检查，否则程序的执行将被终止。
- en: This way, the problem can be traced fast. Also, in `Debug Mode`, the developer
    can traverse the actual execution of the program line by line and check if the
    flow of code is as expected or if the variables are set as expected and accessed
    correctly. Sometimes, accessing pointer variables causes unexpected behaviors
    if they are not pointing to a valid memory location.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，问题可以被迅速追踪。此外，在`调试模式`中，开发人员可以逐行遍历程序的实际执行，并检查代码流程是否如预期那样，或者变量是否设置如预期那样并且是否被正确访问。有时，访问指针变量会导致意外行为，如果它们没有指向有效的内存位置。
- en: When writing code, we can check if the necessary condition is satisfied. If
    not, then the programmer may not want to execute the code further. This can be
    easily done using an assertion. An `assertion` is a macro where the specific condition
    is checked and if it doesn't meet the criteria, abort is called (program execution
    is stopped) and an error message is printed as a `standard error`. This is generally
    a **runtime assertion**. There can also be an assertion done at compile time.
    We will talk about this later. In the next section, we'll solve an exercise wherein
    we'll be writing and testing our first assertion.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时，我们可以检查是否满足必要条件。如果不满足，程序员可能不希望继续执行代码。这可以很容易地通过断言来实现。断言是一个宏，用于检查特定条件，如果不满足条件，则调用abort（停止程序执行）并打印错误消息作为标准错误。这通常是**运行时断言**。还可以在编译时进行断言。我们将在后面讨论这一点。在下一节中，我们将解决一个练习，其中我们将编写和测试我们的第一个断言。
- en: 'Exercise 1: Writing and Testing Our First Assertion'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习1：编写和测试我们的第一个断言
- en: 'In this exercise, we''ll write a function to parse an `IP address` and check
    if it''s valid. As part of our requirements, the `IP address` will be passed as
    a string literal in the `XXX.XXX.XXX.XXX` format. In this format, `X` represents
    a digit from `0`-`9`. So, as part of testing to check whether the `string` being
    parsed is correct or not, we need to ensure that the `string` is `not null` and
    has a `length` that''s less than `16`. Follow these steps to implement this exercise:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一个函数来解析IP地址并检查它是否有效。作为我们的要求的一部分，IP地址将作为字符串文字以“XXX.XXX.XXX.XXX”的格式传递。在这种格式中，“X”代表从“0”到“9”的数字。因此，作为测试的一部分，我们需要确保解析的字符串不为空，并且长度小于16。按照以下步骤来实现这个练习：
- en: Create a new file named **AssertSample.cpp**.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**AssertSample.cpp**的新文件。
- en: 'Open the file and write the following code to include the header files:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件并写入以下代码以包括头文件：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, `#include<cassert>` shows that we need to include the
    `cassert` file where assert is defined.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，“#include<cassert>”显示我们需要包括定义assert的cassert文件。
- en: 'Create a function named `checkValidIp()` that will take the `IP address` as
    input and return a `true` value if the `IP address` meets our requirements. Write
    the following code to define the function:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为checkValidIp（）的函数，它将以IP地址作为输入，并在IP地址满足我们的要求时返回true值。编写以下代码来定义该函数：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, `assert(ip != NULL)` shows that the assert macro is used to check condition
    if the "`ip`" variable that was passed is not `NULL`. If it's `NULL`, then it
    will abort with an error message. Also, `assert(strlen(ip) < 16)` shows that the
    assert is used to check if "`ip`" is `16` character or less. If not, then it aborts
    with `error message`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，“assert（ip！= NULL）”显示assert宏用于检查传递的“ip”变量是否不为“NULL”。如果是“NULL”，那么它将中止并显示错误消息。另外，“assert（strlen（ip）<16）”显示assert用于检查“ip”是否为16个字符或更少。如果不是，则中止并显示错误消息。
- en: 'Now, create a `main` function that passes a different string literal to our
    `checkValidIp()` function and makes sure it can be tested appropriately. Write
    the following code for the `main` function:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个main函数，向我们的checkValidIp（）函数传递一个不同的字符串文字，并确保可以适当地进行测试。编写以下代码以实现main函数：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, we've deliberately passed `NULL` to the `ip` variable
    to make sure `assert` is called.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们故意将NULL传递给ip变量，以确保调用assert。
- en: 'Open the `Command Prompt` and go to the location where the `g++` compiler by
    typing the following command:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令提示符并转到g++编译器的位置，方法是键入以下命令：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With this command, the `a.out` binary file is generated.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令生成a.out二进制文件。
- en: 'Run the `a.out` binary file by typing the following command in the compiler:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在编译器中键入以下命令来运行a.out二进制文件：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You will see the following output:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '![Figure 7.1: Running the Assertion binary on the Command Prompt](img/C14583_07_01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1：在命令提示符上运行断言二进制文件](img/C14583_07_01.jpg)'
- en: 'Figure 7.1: Running the Assertion binary on the Command Prompt'
  id: totrans-38
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.1：在命令提示符上运行断言二进制文件
- en: In the preceding screenshot, you can see three pieces of code circled in red.
    The first highlighted portion shows the compilation of the **.cpp** file. The
    second highlighted portion shows the **a.out** binary that that was generated
    by the preceding compilation. The third highlighted part shows assertion throwing
    an error for the **NULL** value being passed. It indicates the line number and
    function name where the assertion is called.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的屏幕截图中，您可以看到用红色圈出的三段代码。第一个高亮部分显示了.cpp文件的编译。第二个高亮部分显示了前面编译生成的a.out二进制文件。第三个高亮部分显示了对传递的NULL值抛出错误的断言。它指示了断言被调用的行号和函数名。
- en: 'Now, inside the `main` function, we will pass `ip` with a length greater than
    `16` and check if the `assert` is called here too. Write the following code to
    implement this:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在main函数中，我们将传递长度大于16的ip，并检查这里是否也调用了assert。编写以下代码来实现这一点：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Again, open the compiler, compile the `ip` length that was passed is greater
    than `16`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 再次打开编译器，编译传递的ip长度大于16。
- en: 'Now, to satisfy the `assert` condition so that the binary runs fine, we need
    to update the value of `ip` inside the `main` function. Write the following code
    to do this:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了满足assert条件，使二进制文件正常运行，我们需要在main函数中更新ip的值。编写以下代码来实现这一点：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Again, open the compiler, compile the `assert` here, we haven't added any extra
    functionality to our `checkValidIP()` function. However, we'll use the same example
    in the *Exception Handling* and *Unit Testing* sections wherein we'll add more
    functionality to our function.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 再次打开编译器，在这里编译assert，我们没有向checkValidIP（）函数添加任何额外的功能。但是，在*异常处理*和*单元测试*部分中，我们将使用相同的示例添加更多功能到我们的函数中。
- en: 'If we don''t want the executable to abort due to assert in production or the
    release environment, remove the `assert` macro call from the code. First, we''ll
    update the value of `ip` whose length is greater than `16`. Add the following
    code to the file:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们不希望可执行文件因为生产或发布环境中的断言而中止，就从代码中删除`assert`宏调用。首先，我们将更新`ip`的值，其长度大于`16`。将以下代码添加到文件中：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, during compilation, pass the `-DNDEBUG` macro. This will make sure that
    the assert is not called in the binary. Write the following command to compile
    our `.cpp` file in the Terminal:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在编译时，传递`-DNDEBUG`宏。这将确保断言在二进制文件中不被调用。在终端中写入以下命令来编译我们的`.cpp`文件：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After this, when we execute the binary file, the following output is generated:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这之后，当我们执行二进制文件时，会生成以下输出：
- en: '![](img/C14583_07_04.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14583_07_04.jpg)'
- en: 'Figure 7.4: Running the Assertion binary on the Command Prompt'
  id: totrans-52
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.4：在命令提示符上运行断言二进制文件
- en: In the preceding screenshot, since `assert` is not called, it will show the
    string length as **17** and the **true** value as the IP address will be validated.
    In this exercise, we saw that the assertion was called when the binary was executed.
    We can also have an assertion during the compilation of the code. This was introduced
    in C++ 11\. It is called a **static assertion** and we'll explore it in the next
    section.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述截图中，由于未调用`assert`，它将显示字符串长度为**17**，并且**true**值为IP地址将被验证。在这个练习中，我们看到了在执行二进制文件时调用了断言。我们也可以在代码编译时进行断言。这是在C++
    11中引入的。它被称为**静态断言**，我们将在下一节中探讨它。
- en: Static Assertions
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态断言
- en: Sometimes, we can do condition checks at compilation time to avoid any future
    errors. For example, in a project, we may use a third-party library that has some
    data structure declared in it. This structure information, such as its `size`
    and `member variables`, are known to us from its header file. Using this information,
    we can allocate or deallocate memory correctly, as well as work on its member
    variable. This structure property may change in a third-party library with a different
    version. However, if our project code is still using the structure of the earlier
    version, then it will create a problem when we use it. We may get an error at
    a later stage when running the binary. We can catch this error at compile time
    itself using `static assertion`. We can make a comparison of static data such
    as the version number of libraries, thus making sure our code will not have to
    face any problems. In the next section, we'll solve an exercise based on this.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可以在编译时进行条件检查，以避免任何未来的错误。例如，在一个项目中，我们可能会使用一个第三方库，其中声明了一些数据结构。我们可以使用这些信息来正确分配或释放内存，并处理其成员变量。这个结构属性可能会在第三方库的不同版本中发生变化。然而，如果我们的项目代码仍然使用早期版本的结构，那么在使用它时就会出现问题。我们可能会在运行二进制文件时的后期阶段遇到错误。我们可以使用`static
    assertion`在编译时捕获这个错误。我们可以对静态数据进行比较，比如库的版本号，从而确保我们的代码不会遇到任何问题。在下一节中，我们将解决一个基于此的练习。
- en: 'Exercise 2: Testing Static Assertions'
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习2：测试静态断言
- en: 'In this exercise, we''ll be comparing the version numbers of two header files
    by doing a `static assertion`. If the `version number` is less than `1`, then
    the static assert error will be thrown. Perform the following steps to implement
    this exercise:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将通过进行`静态断言`来比较两个头文件的版本号。如果`版本号`小于`1`，那么静态断言错误将被抛出。执行以下步骤来实现这个练习：
- en: Create a header file named `name`, `age`, and `address`. It also has the version
    number `1`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`name`、`age`和`address`的头文件。它还有版本号`1`。
- en: 'Create another header file named `struct person` is defined and consists of
    the following attributes: `name`, `age`, `address`, and `Mobile_No`. It also has
    the `version number 2`. Now, `version 1` is the old version and `version 2` is
    the new one. The following is a screenshot of the two header files side by side:![Figure
    7.5: Library file with a different version](img/C14583_07_05.jpg)'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`struct person`的头文件，其中包含以下属性：`name`、`age`、`address`和`Mobile_No`。它还有`版本号2`。现在，`版本1`是旧版本，`版本2`是新版本。以下是两个头文件并排的截图：![图7.5：具有不同版本的库文件](img/C14583_07_05.jpg)
- en: 'Figure 7.5: Library file with a different version'
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.5：具有不同版本的库文件
- en: Create a file named `doSanityCheck()` that performs a version check for the
    library. It is done using static assertion and it is performed at compile time.
    The second line of the code shows that the `doSanityCheck()` function, the `static_assert()`
    function checks if this version of the library is greater than 1\.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`doSanityCheck()`的文件，用于对库进行版本检查。它使用静态断言，并在编译时执行。代码的第二行显示了`doSanityCheck()`函数，`static_assert()`函数检查此库的版本是否大于1。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: If your project needs a struct of person defined in `version 2` or higher of
    the library to execute it correctly, we need files that match `version 2`, that
    is, `PERSON_LIB_VERSION` should be set to `2` at least. If a developer gets `version
    1` of the library and tries to create a binary for the project, it may create
    a problem in execution. To avoid this scenario, in the main code of the project,
    we do a sanity check for the project before it builds and executes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的项目需要在`版本2`或更高版本的库中定义的`person`结构才能正确执行，我们需要匹配`版本2`的文件，即`PERSON_LIB_VERSION`至少应设置为`2`。如果开发人员获得了库的`版本1`并尝试为项目创建二进制文件，可能会在执行时出现问题。为了避免这种情况，在项目的主代码中，在构建和执行之前对项目进行健全性检查。
- en: To include `version 1` of the library in our `version 1`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在我们的`版本1`中包含库的`版本1`。
- en: Compile our `static_assert` error that was thrown since the version of the library
    is not matching.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译我们的`static_assert`错误，因为库的版本不匹配。
- en: 'Now, to compile the program correctly, remove the soft link of `ProgramLibrary`
    and create a new one pointing to `version2` and compile it again. This time, it
    will compile fine. Type the following commands into the terminal to remove a soft
    link:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了正确编译程序，删除`ProgramLibrary`的软链接，并创建一个指向`version2`的新链接，然后再次编译。这次，它将编译成功。在终端中输入以下命令以删除软链接：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following is a screenshot of the same:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是相同的屏幕截图：
- en: '![Figure 7.7: Static assertion compilation file](img/C14583_07_07.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图7.7：静态断言编译文件](img/C14583_07_07.jpg)'
- en: 'Figure 7.7: Static assertion compilation file'
  id: totrans-70
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.7：静态断言编译文件
- en: As you can see, a region marked in red shows that the correct version of `PersonLibrary`
    is used and compilation goes ahead with no problem. After the compilation, a binary
    file called "**a.exe**" is created. In this exercise, we performed static assertion
    by comparing the version numbers of two header files. In the next section, we'll
    explore the concept of exception handling.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，红色标记的区域显示使用了正确版本的`PersonLibrary`，编译进行顺利。编译后，将创建一个名为“**a.exe**”的二进制文件。在这个练习中，我们通过比较两个头文件的版本号执行了静态断言。在下一节中，我们将探讨异常处理的概念。
- en: Understanding Exception Handling
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解异常处理
- en: As we saw earlier in the debug mode binary, we can use runtime assert to abort
    the program when a certain condition is not satisfied. But in a release mode binary
    or production environment, when the client is using this product, it will not
    be a good idea to abort the program abruptly. It would be better to handle such
    error conditions and proceed with the next part of the execution of the binary.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前在调试模式二进制中看到的，我们可以使用运行时断言来中止程序，当某个条件不满足时。但是在发布模式二进制或生产环境中，当客户使用此产品时，突然中止程序并不是一个好主意。最好处理这样的错误条件，并继续执行二进制的下一部分。
- en: 'The worst case occurs when the binary needs to exit. It''ll do so gracefully
    by adding the correct log messages and cleaning all the allocated memory for this
    process. For such a scenario, exception handling is used. Here, when an error
    condition is hit, execution is transferred to a special block of code. The exception
    consists of three sections, which are as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最坏的情况发生在二进制需要退出时。它会通过添加正确的日志消息和清理为该进程分配的所有内存来优雅地退出。对于这种情况，使用异常处理。在这里，当发生错误条件时，执行会转移到一个特殊的代码块。异常包括三个部分，如下所示：
- en: '**try block**: Here, we check if the criteria match the necessary condition.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**try块**：在这里，我们检查条件是否符合必要的条件。'
- en: '**throw block**: It throws an exception if the criteria do not match.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**throw块**：如果条件不符合，它会抛出异常。'
- en: '**catch block**: It catches the exception and performs the necessary execution
    for that error condition.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**catch块**：它捕获异常并对该错误条件执行必要的执行。'
- en: In the next section, we'll solve an exercise wherein we'll perform exception
    handling on our code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将解决一个练习，在其中我们将对我们的代码执行异常处理。
- en: 'Exercise 3: Performing Exception Handling'
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习3：执行异常处理
- en: 'In this exercise, we''ll be performing exception handling on our **AssertSample.cpp**
    code. We''ll replace the assert condition with our exception. Perform the following
    steps to implement this exercise:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将在我们的**AssertSample.cpp**代码上执行异常处理。我们将用我们的异常替换断言条件。执行以下步骤来实现这个练习：
- en: Create a file named `ExceptionSample.cpp`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ExceptionSample.cpp`的文件。
- en: 'Add the following codes to add header files:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码以添加头文件：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create a `checkValidIp()` function wherein we have a try-catch block. If the
    condition present in the try block is not satisfied, an exception will be thrown
    and the message in the catch block will be printed. Add the following code to
    accomplish this:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`checkValidIp()`函数，在其中有一个try-catch块。如果try块中的条件不满足，将抛出异常，并打印catch块中的消息。添加以下代码来完成这个操作：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, you can see the try block where the condition is checked.
    Inside the try block, if `ip` is `NULL`, then it will throw an exception of the
    (`const char *`) type. In the next condition, if `ip` is `greater than 15`, then
    it will throw an exception with the int parameter type. This throw is caught by
    a correct catch with matching parameters (`int` or `const char *`). Both exceptions
    return `false` with some error message. Alternatively, in the `catch` block, you
    can perform extra steps if any cleaning is needed or use the default values for
    variables that were used for comparison in the exception.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，您可以看到try块，其中检查条件。在try块内，如果`ip`是`NULL`，那么它将抛出(`const char *`)类型的异常。在下一个条件中，如果`ip`大于15，则它将抛出带有int参数类型的异常。这个抛出被正确的catch捕获，匹配参数（`int`或`const
    char *`）。两个异常都返回带有一些错误消息的`false`。或者，在`catch`块中，如果需要进行任何清理或使用在异常中用于比较的变量的默认值，可以执行额外的步骤。
- en: Note
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: There is a default exception; for example, if there's a nested function that
    throws an error with a different parameter, it can be caught as a higher-level
    function with a parameter such as catch(…). Again, in the generic catch, you can
    create a default behavior for exception handling.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个默认的异常；例如，如果有一个嵌套函数抛出一个带有不同参数的错误，它可以作为具有参数的更高级函数捕获（…）。同样，在通用catch中，您可以为异常处理创建默认行为。
- en: 'Create the `main()` function and write the following code inside it:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main()`函数，并在其中写入以下代码：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Open the terminal, compile our file, and run the binary. You will see the following
    output:![Figure 7.8: Example execute code with exception handling](img/C14583_07_08.jpg)'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，编译我们的文件，并运行二进制文件。您将看到以下输出：![图7.8：带有异常处理的示例执行代码](img/C14583_07_08.jpg)
- en: 'Figure 7.8: Example execute code with exception handling'
  id: totrans-92
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.8：带有异常处理的示例执行代码
- en: The preceding example throws an exception for `ip` being `NULL` and exits gracefully.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例对`ip`为`NULL`抛出异常并优雅退出。
- en: 'Now, modify the value of `ip` in the `main` function by providing more than
    `15` characters. Write the following code to do this:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`main`函数中修改`ip`的值，提供超过15个字符。编写以下代码来执行此操作：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Open the terminal, compile our file, and run the binary. You will see the following
    output:![Figure 7.9: Another example of exception handling](img/C14583_07_09.jpg)'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，编译我们的文件，然后运行二进制文件。您将看到以下输出：![图7.9：异常处理的另一个例子](img/C14583_07_09.jpg)
- en: 'Figure 7.9: Another example of exception handling'
  id: totrans-97
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.9：异常处理的另一个例子
- en: It throws an error with a `length mismatch` for the `ip string`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 它为“ip字符串”的“长度不匹配”抛出错误。
- en: 'Again, modify the value of `ip` in the `main` function by providing less than
    `15` characters. Write the following code to do this:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次修改“main”函数中“ip”的值，提供少于“15”个字符。编写以下代码来实现这一点：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Open the terminal, compile our file, and run the binary. You will see the following
    output:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，编译我们的文件，然后运行二进制文件。您将看到以下输出：
- en: '![Figure 7.10: The binary runs fine without throwing an exception](img/C14583_07_10.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图7.10：二进制文件正常运行，没有抛出异常](img/C14583_07_10.jpg)'
- en: 'Figure 7.10: The binary runs fine without throwing an exception'
  id: totrans-103
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.10：二进制文件正常运行，没有抛出异常
- en: As you can see from the preceding screenshot, the binary file executes properly
    without any exceptions. Now that you've understood how to handle exceptions, in
    the next section, we'll explore the concepts of `unit testing` and `mock testing`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，二进制文件正常执行，没有抛出任何异常。现在您已经了解了如何处理异常，在下一节中，我们将探讨“单元测试”和“模拟测试”的概念。
- en: Unit Testing and Mock Testing
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试和模拟测试
- en: When a developer starts writing code, they need to ensure it is tested correctly
    at the unit level. It may happen that the boundary conditions are missed, and
    the code may break when it runs on the client's site. To avoid this situation,
    generally, it is a good idea to do `unit testing` for the code. `Unit testing`
    is testing that's performed at the unit level or the base level of the code where
    a developer can test their code in an isolated environment, assuming the required
    setup has been fulfilled to run a feature of the code. Generally, it is good practice
    to break down modules into small functions and test each function separately.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发人员开始编写代码时，他们需要确保在单元级别正确测试代码。可能会出现边界条件被忽略的情况，当代码在客户端站点运行时可能会出现故障。为了避免这种情况，通常最好对代码进行“单元测试”。“单元测试”是在代码的单元级别或基本级别进行的测试，在这里开发人员可以在隔离的环境中测试他们的代码，假设已经满足了运行代码功能所需的设置。通常，将模块分解为小函数并分别测试每个函数是一个很好的实践。
- en: For example, suppose part of the functionality is to read the configuration
    file and get the environment set up with the parameters from the configuration
    file. We can create a dedicated function to write this functionality. So, to test
    this function, we can create a set of unit test cases that will check various
    combinations that may fail or behave incorrectly. Once these test cases have been
    identified, the developer can write code to cover the functionality and make sure
    it passes all the unit test cases. This is good practice as part of development
    where you keep on adding test cases first and add code accordingly, and then run
    all the test cases for that function and make sure they behave appropriately.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设功能的一部分是读取配置文件并使用配置文件中的参数设置环境。我们可以创建一个专门的函数来编写这个功能。因此，为了测试这个功能，我们可以创建一组单元测试用例，检查可能失败或行为不正确的各种组合。一旦确定了这些测试用例，开发人员可以编写代码来覆盖功能，并确保它通过所有单元测试用例。这是开发的一个良好实践，您首先不断添加测试用例，然后相应地添加代码，然后运行该函数的所有测试用例，并确保它们的行为是适当的。
- en: There are a good number of tools available for writing and integrating unit
    test cases for a project. A few of them are `Google Test framework`. It is freely
    available and can be integrated with the project. It uses the **xUnit test framework**
    and has a collection of asserts that can be used to test the condition for test
    cases. In the next section, we'll solve an exercise wherein we'll be creating
    our first unit test case.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多可用于编写和集成项目的单元测试用例的工具。其中一些是“Google测试框架”。它是免费提供的，并且可以与项目集成。它使用**xUnit测试框架**，并具有一系列断言，可用于测试用例的条件。在下一节中，我们将解决一个练习，其中我们将创建我们的第一个单元测试用例。
- en: 'Exercise 4: Creating Our First Unit Test Case'
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习4：创建我们的第一个单元测试用例
- en: 'In this exercise, we''ll work on the same scenario we discussed in the previous
    section wherein the developer is tasked with writing a function to parse the `configuration
    file`. Different valid parameters are passed in the configuration file, for example,
    `product executable name`, `version number`, `database connectivity information`,
    `IP address` to connect to the server, and so on. Assume that the developer will
    break down all this functionality of parsing the file and setting and testing
    the parameters for individual properties in a separate function. In our case,
    we assume that the developer is writing functionality where they have parsed the
    `IP address` as a `string` and wants to deduce if the `string` is the valid `IP
    address`. For now, the criteria to match the `IP address` to be valid needs to
    satisfy the following conditions:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将处理与上一节讨论过的相同场景，即开发人员被要求编写一个函数来解析“配置文件”。配置文件中传递了不同的有效参数，例如“产品可执行文件名”、“版本号”、“数据库连接信息”、“连接到服务器的IP地址”等。假设开发人员将分解解析文件的所有功能，并在单独的函数中设置和测试各个属性的参数。在我们的情况下，我们假设开发人员正在编写功能，他们已经将“IP地址”解析为“字符串”，并希望推断出该“字符串”是否是有效的“IP地址”。目前，使“IP地址”有效的标准需要满足以下条件：
- en: The `string` should not be null.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “字符串”不应为空。
- en: The `string` should contain no more than `16` characters
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “字符串”不应包含超过“16”个字符
- en: The `string` should be in the `XXX.XXX.XXX.XXX` format, where `X` must be a
    digit from `0`-`9`.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “字符串”应该是“XXX.XXX.XXX.XXX”的格式，其中“X”必须是“0”-“9”的数字。
- en: 'Perform the following steps to implement this exercise:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来实现这个练习：
- en: Create the `checkValidIp()` to check if the `IP address` is valid. Again, just
    to understand the `Google unit test`, we will write minimal code to understand
    the feature.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`checkValidIp()`来检查`IP地址`是否有效。再次，为了理解`Google单元测试`，我们将编写最少的代码来理解这个功能。
- en: 'Create a `ip` is `not NULL` and that the length is less than `16`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`ip`不为空，并且长度小于`16`：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code, if both conditions fail, the function returns `false`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，如果两个条件都失败，函数将返回`false`。
- en: 'Call the `checkValidIp()` function to create a new file named `checkValidIP()`
    function. Add the following code inside it:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`checkValidIp()`函数来创建一个名为`checkValidIP()`函数的新文件。在其中添加以下代码：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To create test code, we''ll create our first `checkValidIp` function. Write
    the following code inside it:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建测试代码，我们将创建我们的第一个`checkValidIp`函数。在其中写入以下代码：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the second line of the preceding code, we''re including the `TEST` function,
    which takes two parameters: the first is the `testsuite` name and the second is
    the `testcase` name. For our case, we have created `TestSuite` `CheckIp`. In the
    `TEST` block, you will see that we have the `Google test` define an `assert` called
    `ASSERT_FALSE` that will check if the condition is `false`. If it''s not, it will
    fail the test case and show the same in the results.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面代码的第二行，我们包含了`TEST`函数，它接受两个参数：第一个是`testsuite`名称，第二个是`testcase`名称。对于我们的情况，我们创建了`TestSuite`
    `CheckIp`。在`TEST`块中，您将看到我们有`Google测试`定义了一个名为`ASSERT_FALSE`的`assert`，它将检查条件是否为`false`。如果不是，它将使测试用例失败，并在结果中显示相同的内容。
- en: Note
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Generally, for a `Google test` case and test suite, you can group them in a
    common namespace and call the `RUN_ALL_TESTS` macro, which runs all the test cases
    attached to test binary. For each test case, it calls the `SetUp` function to
    initialize (like constructor in class), then it calls the actual test case, and
    finally, it calls the `TearDown` function (like destructor in class). It is not
    necessary to write the `SetUp` and `TearDown` functions unless you have to initialize
    something for the test cases.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于`Google测试`用例和测试套件，您可以将它们分组在一个公共命名空间中，并调用`RUN_ALL_TESTS`宏，该宏运行附加到测试二进制文件的所有测试用例。对于每个测试用例，它调用`SetUp`函数来初始化（类中的构造函数），然后调用实际的测试用例，最后调用`TearDown`函数（类中的析构函数）。除非您必须为测试用例初始化某些内容，否则不需要编写`SetUp`和`TearDown`函数。
- en: 'Now, to run the test cases, we will create the main `RUN_ALL_TESTS` macro.
    Alternatively, we can create an executable by linking the `Google Test library`
    that invokes `RUN_ALL_TESTS`. For our case, we will do the latter. Open the terminal
    and run the following command to create a test run binary:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要运行测试用例，我们将创建主`RUN_ALL_TESTS`宏。或者，我们可以创建一个可执行文件，链接`Google Test库`，并调用`RUN_ALL_TESTS`。对于我们的情况，我们将选择后者。打开终端并运行以下命令以创建一个测试运行二进制文件：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This will include the object file of `CheckValidIp` function is defined in it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这将包括`CheckValidIp`函数的对象文件在其中定义。
- en: 'Now, type the following command to add the necessary libraries that will be
    linked for creating a binary:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，输入以下命令以添加必要的库，这些库将被链接以创建一个二进制文件：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, run the binary with the following command:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下命令运行二进制文件：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This shows two test cases that were passed for the `CheckIp` `testsuite`. The
    first test case, `CheckIp.testNull`, is called and it passes. The second testcase,
    `CheckIp.BadLength`, is called and it passes too. This result is visible in the
    following screenshot:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了通过`CheckIp` `testsuite`的两个测试用例。第一个测试用例`CheckIp.testNull`被调用并通过了。第二个测试用例`CheckIp.BadLength`也被调用并通过了。这个结果在以下截图中可见：
- en: '![Figure 7.11: Compiling and executing test cases](img/C14583_07_11.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图7.11：编译和执行测试用例](img/C14583_07_11.jpg)'
- en: 'Figure 7.11: Compiling and executing test cases'
  id: totrans-135
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.11：编译和执行测试用例
- en: Note
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: In `Google Test`, we can also use other asserts, but for our test cases, we
    are fine with `ASSERT_FALSE` since we are only checking the false condition for
    the IP address that we pass.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Google测试`中，我们也可以使用其他断言，但对于我们的测试用例，我们满意于`ASSERT_FALSE`，因为我们只检查我们传递的IP地址的假条件。
- en: Now, we will add more test cases to make our code robust. This is generally
    good practice for writing code. First, create the test cases and make sure the
    code runs fine for new test cases and old test cases along with the correct functionality
    of the code. To add more test cases, add the following code to the `IP` starts
    with ".". The fourth case should fail if the `IP` ends with ".". The fifth case
    should fail if `IP` has space in-between. The sixth case should fail if the `IP`
    contains any non-digit characters. The seventh case should fail if `IP` has a
    token value less than `0` and greater than `255`. The last case should fail if
    `IP` has wrong token counts.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将添加更多的测试用例来使我们的代码更加健壮。这通常是编写代码的良好实践。首先，创建测试用例，并确保代码对新测试用例和旧测试用例以及代码的正确功能都能正常运行。要添加更多的测试用例，将以下代码添加到`IP`以"."开头。如果`IP`以"."结尾，则第四个案例应该失败。如果`IP`之间有空格，则第五个案例应该失败。如果`IP`包含任何非数字字符，则第六个案例应该失败。如果`IP`的令牌值小于`0`且大于`255`，则第七个案例应该失败。如果`IP`的令牌计数错误，则最后一个案例应该失败。
- en: 'Now, add the following code inside the `CheckValidIp()` function of the **CheckIp.cpp**
    file. This code is required to handle new test cases:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在**CheckIp.cpp**文件的`CheckValidIp()`函数中添加以下代码。这段代码是处理新测试用例所必需的：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Open the terminal and write the following command to run the binary file:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并输入以下命令以运行二进制文件：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'All the test cases have been executed, as shown in the following screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试用例都已执行，如下截图所示：
- en: '![Figure 7.12: Output of test cases run](img/C14583_07_12.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图7.12：测试用例运行的输出](img/C14583_07_12.jpg)'
- en: 'Figure 7.12: Output of test cases run'
  id: totrans-145
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.12：测试用例运行的输出
- en: The preceding screenshot shows that there are `10` test cases in the `CheckIp`
    test suite and that all the test cases ran fine. In the next section, we'll learn
    about unit testing using mock objects.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了`CheckIp`测试套件中有`10`个测试用例，并且所有测试用例都运行正常。在下一节中，我们将学习使用模拟对象进行单元测试。
- en: Unit Testing Using Mock Objects
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用模拟对象进行单元测试
- en: When a developer works on unit testing, there may be scenarios wherein certain
    interfaces are called after concrete actions have taken place. For example, as
    we discussed in the preceding scenarios, let's assume that the project is designed
    in such a way that, before its execution, it takes all the configuration information
    from the database. It queries the database to get specific parameters, for example,
    the web server's `IP address`, `user`, and `password`. It then tries to connect
    to a web server (maybe there is another module that handles network-related tasks)
    or starts acting on the items that are needed for an actual project. Previously,
    we worked on testing the validity of the IP address. Now, we'll go a step further.
    Let's assume that the IP address is fetched from the database and that we have
    a utility class that handles connecting to `DB` and querying `IP addresses`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发人员进行单元测试时，可能会出现在具体操作发生后调用某些接口的情况。例如，正如我们在前面的情景中讨论的，假设项目设计成在执行之前从数据库中获取所有配置信息。它查询数据库以获取特定参数，例如Web服务器的`IP地址`，`用户`和`密码`。然后尝试连接到Web服务器（也许有另一个模块处理与网络相关的任务）或开始对实际项目所需的项目进行操作。之前，我们测试了IP地址的有效性。现在，我们将更进一步。假设IP地址是从数据库中获取的，并且我们有一个实用类来处理连接到`DB`和查询`IP地址`。
- en: Now, to test the IP address' validity, we need to assume the database connectivity
    has been set up. This means that the application can query the database correctly
    and get the results of the query, one of which is an `IP address`. Only then can
    we test the IP address' validity. Now, in order to perform such testing, we must
    assume that all the necessary activities have been completed and that we've got
    an `IP address` to test. Here comes the mock object, which behaves like the real
    object. It provides the facility for unit testing so that the application is under
    the impression that the IP address has already been fetched from the database,
    but in reality, we have imitated it. To create a mock object, we need to inherit
    it from the class that it needs to imitate. In the next section, we'll walk through
    an exercise to get a better understanding of the mock object.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了测试IP地址的有效性，我们需要假设数据库连接已经设置好。这意味着应用程序可以正确地查询数据库并获取查询结果，其中之一是`IP地址`。只有这样，我们才能测试IP地址的有效性。现在，为了进行这样的测试，我们必须假设所有必要的活动都已经完成，并且我们已经得到了一个`IP地址`来测试。这就是模拟对象的作用，它就像真实对象一样。它提供了单元测试的功能，以便应用程序认为IP地址已经从数据库中获取，但实际上我们是模拟的。要创建一个模拟对象，我们需要从它需要模拟的类中继承。在下一节中，我们将进行一个练习，以更好地理解模拟对象。
- en: 'Exercise 5: Creating Mock Objects'
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习5：创建模拟对象
- en: 'In this exercise, we''ll create mock objects by assuming that all the interfaces
    are working as expected. Using these objects, we''ll test a few functionalities
    such as validating the `IP address`, checking DB connectivity, and checking whether
    the `username` and `password` are in correct format. Once all the tests have passed,
    we''ll confirm the application and make it ready for `QA`. Perform the following
    steps to implement this exercise:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将通过假设所有接口都按预期工作来创建模拟对象。使用这些对象，我们将测试一些功能，比如验证`IP地址`，检查数据库连接性，以及检查`用户名`和`密码`是否格式正确。一旦所有测试都通过了，我们将确认应用程序，并准备好进行`QA`。执行以下步骤来实现这个练习：
- en: 'Create a header file named **Misc.h** and include the necessary libraries:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**Misc.h**的头文件，并包含必要的库：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a class named `ConnectDatabase` that will connect to the database and
    return the result of the query. Within the class, declare the `Dbname`, user,
    and passwd variables. Also, declare a constructor and two virtual functions. Out
    of these two virtual functions, the first one must be a destructor, and the second
    one must be the `getResult()` function, which returns the query result from the
    database. Add the following code to implement this:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ConnectDatabase`的类，它将连接到数据库并返回查询结果。在类内部，声明`Dbname`，user和passwd变量。还声明一个构造函数和两个虚函数。在这两个虚函数中，第一个必须是析构函数，第二个必须是`getResult()`函数，它从数据库返回查询结果。添加以下代码来实现这一点：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create another class named `WebServerConnect`. Declare three `string` variables
    inside the `class`, namely `Webserver`, `uname`, and `passwd`. Create constructor
    and two virtual functions. Out of these two virtual functions, the first one must
    be a destructor, and the second one must be the `getRequest()` function. Add the
    following code to implement this:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`WebServerConnect`的类。在`class`内部声明三个`string`变量，分别是`Webserver`，`uname`和`passwd`。创建构造函数和两个虚函数。在这两个虚函数中，第一个必须是析构函数，第二个必须是`getRequest()`函数。添加以下代码来实现这一点：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '`Virtual functions` are required since we are going to create a `Mock class`
    from the preceding class and call these functions.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将从前面的类创建一个`模拟类`并调用这些函数，所以需要`虚函数`。
- en: 'Create a class named `App`. Create the constructors, and destructors and call
    all the functions. Add the following code to implement this:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`App`的类。创建构造函数和析构函数并调用所有函数。添加以下代码来实现这一点：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code, the app will first query the database and get the `IP
    address`. It then connects to the web server with the necessary information and
    query it to get the required information.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，应用程序将首先查询数据库并获取`IP地址`。然后，它使用必要的信息连接到Web服务器并查询以获取所需的信息。
- en: Create a class named `gmock` header file, which is needed to create a mock class.
    Also, the `MockDB` class is inherited from the `ConnectDatabase` class. The `MOCK_METHOD1(getResult,
    string(string));` line states that we are going to mock the `getResult` interface.
    So, during unit testing, we can call the `getResult` function directly with the
    desired result without creating the `ConnectDatabase` class and running a real
    query to the database. One important point that needs to be noted here is that
    the function we need to mock must be defined with the `MOCK_METHOD[N] macro`,
    where N is the number of parameters the interface will take. In our case, the
    `getResult` interface takes one parameter. Thus, it is mocked with the `MOCK_METHOD1`
    macro.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`gmock`的类头文件，这是创建模拟类所需的。此外，`MockDB`类是从`ConnectDatabase`类继承的。`MOCK_METHOD1(getResult,
    string(string));`这一行表示我们将模拟`getResult`接口。因此，在单元测试期间，我们可以直接调用`getResult`函数，并传递所需的结果，而无需创建`ConnectDatabase`类并运行实际的数据库查询。需要注意的一个重要点是，我们需要模拟的函数必须使用`MOCK_METHOD[N]`宏进行定义，其中N是接口将接受的参数数量。在我们的情况下，`getResult`接口接受一个参数。因此，它使用`MOCK_METHOD1`宏进行模拟。
- en: Create a file named `getResult()` and `getRequest()` functions, where the DB
    query and `WebServer` query return a default string. Here, the `App::run()` function
    assumes that both DB connectivity and web server connectivity has been executed
    and now it can execute web queries at regular intervals. At the end of each query,
    it will return the "`Webserver returned success`" string by default.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`getResult()`和`getRequest()`的函数，其中DB查询和`WebServer`查询返回默认字符串。在这里，`App::run()`函数假设DB连接和web服务器连接已经执行，现在它可以定期执行web查询。在每次查询结束时，它将默认返回"`Webserver
    returned success`"字符串。
- en: Now, create a file named `dbname`, `dbuser`, and `dbpasswd`. Then, we query
    to the database to get the IP address and other config parameters. We've commented
    the `app.checkValidIp(ip)` line as we're assuming that the IP address that we've
    fetched from the DB needs to be validated. Also, this function needs to be unit
    tested. Using the `connectWeb()` function, we can connect to the web server by
    passing dummy parameters such as `webname`, `user`, and `passwd`. Finally, we
    call the `run()` function, which will run in iteration, thereby querying the web
    server and giving the default output.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为`dbname`、`dbuser`和`dbpasswd`的文件。然后，我们查询数据库以获取IP地址和其他配置参数。我们已经注释掉了`app.checkValidIp(ip)`这一行，因为我们假设从数据库中获取的IP地址需要进行验证。此外，这个函数需要进行单元测试。使用`connectWeb()`函数，我们可以通过传递虚拟参数如`webname`、`user`和`passwd`来连接到web服务器。最后，我们调用`run()`函数，它将迭代运行，从而查询web服务器并给出默认输出。
- en: 'Save all the files and open the terminal. In order to get the basic functionality
    required to execute the project, we''ll build the binary file and execute it to
    see the result. Run the following command in the terminal:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存所有文件并打开终端。为了获得执行项目所需的基本功能，我们将构建二进制文件并执行它以查看结果。在终端中运行以下命令：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding code will create binary file called `RunApp` in the current folder.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将在当前文件夹中创建一个名为`RunApp`的二进制文件。
- en: 'Now, write the following command to run the executable:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编写以下命令来运行可执行文件：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The preceding command generates the following output in the Terminal:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令在终端中生成以下输出：
- en: '![Figure 7.13: Running the app](img/C14583_07_13.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图7.13：运行应用程序](img/C14583_07_13.jpg)'
- en: 'Figure 7.13: Running the app'
  id: totrans-173
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.13：运行应用程序
- en: As you can see in the preceding screenshot, the binary displays the output "`Webserver
    returned success`" in a timely fashion. So far, our application is running fine
    as it is assuming that all the interfaces are working as expected. But we still
    have to test a few functionalities such as validating the `IP address`, `DB connectivity`,
    checking whether the `username` and `password` are in the correct format if any,
    and more before making it ready for `QA`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，二进制文件及时显示输出"`Webserver returned success`"。到目前为止，我们的应用程序正常运行，因为它假设所有接口都按预期工作。但在将其准备好供QA测试之前，我们仍需测试一些功能，如验证`IP地址`、`DB连接性`、检查`用户名`和`密码`是否符合正确格式等。
- en: 'Using the same infrastructure, start unit testing each functionality. For our
    exercise, we''ll assume that the `DB connectivity` has already been done and has
    been queried to get the `IP address`. After that, we can start unit testing the
    validity of the `IP address`. So, in our test case, the Database class needs to
    be mocked and the `getDBResult` function must return the `IP address`. This `IP
    address` will be passed to the `checkValidIP` function later, wherein we''ll test
    it. To implement this, create a class named `checkValidIP` function:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的基础设施，开始对每个功能进行单元测试。在我们的练习中，我们假设`DB连接`已经完成，并已查询以获取`IP地址`。之后，我们可以开始单元测试`IP地址`的有效性。因此，在我们的测试用例中，需要模拟数据库类，并且`getDBResult`函数必须返回`IP地址`。稍后，这个`IP地址`将传递给`checkValidIP`函数进行测试。为了实现这一点，创建一个名为`checkValidIP`的类：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we have used the testing and `testing::Return` namespaces to call mock
    class interfaces and return the user-defined values that are meant for test cases.
    Within the `TEST_F` function, we used the `EXPECT_CALL` function, wherein we pass
    the instance of a mock object as the first parameter and pass the `getResult()`
    function as the second parameter. The `WillOnce(Return(""))` line states that
    the interface needs to be called once and will return "" and an empty string.
    This is the value that needs to be passed to the `checkValidIP` function to test
    for the empty string. This is checked with the `ASSERT_FALSE` macro. Similarly,
    other test cases can be created using the mocked object of DB and passing the
    IP address to the `checkValidIP` function. To create various test cases, the `TestApp`
    class is inherited from the `testing::Test` class, which contains the App instance
    and Mocked object of Database. Within the `TestApp` class, we have defined two
    functions, namely `SetUp()` and `TearDown()`. Inside the `SetUp()` function, we
    created a `MockDB` instance and tagged it to the testApp instance. Since nothing
    needs to be done for the `TearDown()` function, we've kept it empty. Its destructor
    is called in the destructor of the `App` class. Also, we passed two parameters
    inside the `TEST_F` function. The first parameter is the Test class while the
    second parameter is the test case's name.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了测试和`testing::Return`命名空间来调用模拟类接口，并返回用于测试用例的用户定义的值。在`TEST_F`函数中，我们使用了`EXPECT_CALL`函数，其中我们将模拟对象的实例作为第一个参数传递，并将`getResult()`函数作为第二个参数传递。`WillOnce(Return(""))`行表示需要调用接口一次，并将返回""和一个空字符串。这是需要传递给`checkValidIP`函数以测试空字符串的值。这通过`ASSERT_FALSE`宏进行检查。类似地，可以使用DB的模拟对象创建其他测试用例，并将IP地址传递给`checkValidIP`函数。为了创建各种测试用例，`TestApp`类从`testing::Test`类继承，其中包含App实例和Database的模拟对象。在`TestApp`类中，我们定义了两个函数，即`SetUp()`和`TearDown()`。在`SetUp()`函数中，我们创建了一个`MockDB`实例并将其标记为testApp实例。由于`TearDown()`函数不需要执行任何操作，我们将其保持为空。它的析构函数在`App`类的析构函数中被调用。此外，我们在`TEST_F`函数中传递了两个参数。第一个参数是测试类，而第二个参数是测试用例的名称。
- en: 'Save all the files and open the terminal. Run the following command:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存所有文件并打开终端。运行以下命令：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the preceding command, we have also linked the `gmock library`. Now, type
    the following command to run the test cases:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，我们还链接了`gmock库`。现在，输入以下命令来运行测试用例：
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding command generates the following output:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令生成了以下输出：
- en: '![Figure 7.14: Running the Gmock test](img/C14583_07_14.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图7.14：运行Gmock测试](img/C14583_07_14.jpg)'
- en: 'Figure 7.14: Running the Gmock test'
  id: totrans-184
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.14：运行Gmock测试
- en: From the preceding command, we can see that all the test cases executed and
    passed successfully. In the next section, we'll discuss `breakpoints`, `watchpoints`,
    and `data visualization`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的命令中，我们可以看到所有的测试用例都执行并成功通过了。在下一节中，我们将讨论`断点`、`观察点`和`数据可视化`。
- en: Breakpoints, Watchpoints, and Data Visualization
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 断点、观察点和数据可视化
- en: In the previous section, we discussed that unit testing needs to be done before
    a developer checks code into the repository branch and can be seen by other team
    members so that they can integrate it with other modules. Although unit testing
    is done well and the developer checks the code in, there may be a chance that
    whenever the code is integrated and the QA team starts testing, they may find
    a bug in the code. Generally, in such a scenario, an error may be thrown in a
    module that was caused due to changes in the other module. It may become difficult
    for the team to crack down on the real reason for such issues. In such cases,
    **debugging** comes into the picture. It tells us exactly how the code is behaving,
    and the developer can get granular information of the code's execution. A developer
    can see what parameters the function is getting and what value it is returning.
    It can tell exactly what value is assigned to a variable or a pointer or what
    the content in memory is. This becomes very helpful for the developer to identify
    in which part of the code the issue is. In the next section, we'll implement a
    stack and perform a few operations on it.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们讨论了在开发人员将代码检入存储库分支之前需要进行单元测试，并且其他团队成员可以看到它，以便他们可以将其与其他模块集成。虽然单元测试做得很好，开发人员检查了代码，但在集成代码并且QA团队开始测试时，可能会发现代码中存在错误的机会。通常，在这种情况下，可能会在由于其他模块的更改而导致的模块中抛出错误。团队可能会很难找出这些问题的真正原因。在这种情况下，**调试**就出现了。它告诉我们代码的行为如何，开发人员可以获得代码执行的细粒度信息。开发人员可以看到函数正在接收的参数以及它返回的值。它可以准确地告诉一个变量或指针分配了什么值，或者内存中的内容是什么。这对于开发人员来说非常有帮助，可以确定代码的哪一部分存在问题。在下一节中，我们将实现一个堆栈并对其执行一些操作。
- en: Working with the Stack Data Structure
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与堆栈数据结构一起工作
- en: 'Consider a scenario wherein a developer has been asked to develop his/her own
    stack structure that can take in any parameter. Here, the requirement is that
    the stack structure must follow the **Last In First Out** (**LIFO**) principle,
    where elements are placed on top of each other and when they''re removed from
    the stack, the last element should be removed first. It should have the following
    functions:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一个场景，其中开发人员被要求开发自己的堆栈结构，可以接受任何参数。在这里，要求是堆栈结构必须遵循**后进先出**（**LIFO**）原则，其中元素被放置在彼此之上，当它们从堆栈中移除时，最后一个元素应该首先被移除。它应该具有以下功能：
- en: '**push()** to place a new element on top of the stack'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**push()**将新元素放置在堆栈顶部'
- en: '**top()** to display the top element of the stack, if any'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**top()**显示堆栈的顶部元素（如果有）'
- en: '**pop()** to remove the last inserted element from the stack'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pop()**从堆栈中移除最后插入的元素'
- en: '**is_empty()** to check if the stack is empty'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**is_empty()**检查堆栈是否为空'
- en: '**size()** to display the number of elements present in the stack'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**size()**显示堆栈中存在的元素数量'
- en: '**clean()** to empty the stack if it has any elements in it'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**clean()**清空堆栈（如果有任何元素）'
- en: 'The following lines of code show how to include the necessary libraries within
    the **Stack.h** header file:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行显示了如何在**Stack.h**头文件中包含必要的库：
- en: '[PRE32]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As we already know, the stack consists of various operations. To define each
    of these functions, we''ll write the following code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经知道的，栈由各种操作组成。为了定义这些函数中的每一个，我们将编写以下代码：
- en: '[PRE33]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: So far, we've seen how to implement a stack using a `Single Linked List`. Every
    time `push` is called in Stack, a new element of a given value will be created
    and attached to the beginning of the stack. We call this a head member variable
    and is where the head will point to the next element in the stack and so on. When
    `pop` is called, the head will be removed from the stack and will point to the
    next element of the stack.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何使用`单链表`实现栈。每次在Stack中调用`push`时，都会创建一个给定值的新元素，并将其附加到栈的开头。我们称之为头成员变量，它是头部将指向栈中的下一个元素等等。当调用`pop`时，头部将从栈中移除，并指向栈的下一个元素。
- en: 'Let''s write the implementation of the previously created Stack in the `22`,
    `426`, and `57`. When the `displayStackStats()` function is called, it should
    state the size of the stack to be `3`. Then, we pop out `57` from the stack and
    the top element must display `426`. We''ll do the same operation for the stack
    of `char`. Here is the complete implementation of the stack:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`22`、`426`和`57`中编写先前创建的Stack的实现。当调用`displayStackStats()`函数时，它应该声明栈的大小为`3`。然后，我们从栈中弹出`57`，顶部元素必须显示`426`。我们将对char栈执行相同的操作。以下是栈的完整实现：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When we compile the `-g` option is being used). Thus, you can debug the binary
    if needed:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编译时（使用了`-g`选项）。因此，如果需要，您可以调试二进制文件：
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We''ll write the following command to execute the binary:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将写以下命令来执行二进制文件：
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The preceding command generates the following output:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令生成了以下输出：
- en: '![Figure 7.15: Main function using the Stack class](img/C14583_07_15.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图7.15：使用Stack类的主函数](img/C14583_07_15.jpg)'
- en: 'Figure 7.15: Main function using the Stack class'
  id: totrans-209
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.15：使用Stack类的主函数
- en: 'In the preceding output, the red ink in the second call to the statistics function
    shows the correct information of showing three elements in a stack of int. However,
    the red ink calls to the top of the int stack show random or garbage values. If
    the program is run again, it will show some other random numbers and not the expected
    values of `57` and `426`. Similarly, for the stack of char, the section highlighted
    in the red ink, that is, top of `char`, shows a garbage value instead of the expected
    value, that is, "l". Later, the execution shows the error of double free or corruption,
    which means free was called to the same memory location again. Finally, the executable
    gave core dump. The program didn''t execute as expected and it may not be clear
    from the display where the actual error lies. To debug `Main`, we''ll write the
    following command:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，统计函数的第二次调用中的红色墨水显示了在int栈中显示三个元素的正确信息。然而，int栈顶部的红色墨水调用显示了随机或垃圾值。如果程序再次运行，它将显示一些其他随机数字，而不是预期的值`57`和`426`。同样，对于char栈，红色墨水突出显示的部分，即`char`的顶部，显示了垃圾值，而不是预期的值，即"l"。后来，执行显示了双重释放或损坏的错误，这意味着再次调用了相同的内存位置。最后，可执行文件产生了核心转储。程序没有按预期执行，从显示中可能不清楚实际错误所在。为了调试`Main`，我们将编写以下命令：
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The preceding command generates the following output:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令生成了以下输出：
- en: '![Figure 7.16: Debugger display – I](img/C14583_07_16.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图7.16：调试器显示 – I](img/C14583_07_16.jpg)'
- en: 'Figure 7.16: Debugger display – I'
  id: totrans-214
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.16：调试器显示 – I
- en: 'In the preceding screenshot, the marks highlighted in blue show how the debugger
    is used and what it displays. The first mark shows the debugger being called using
    the `gdb` command. After entering the `gdb` command, the user goes to the command
    mode of the debugger. Here is some brief information about the commands being
    used in the command mode:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，蓝色突出显示的标记显示了调试器的使用方式以及它显示的内容。第一个标记显示了使用`gdb`命令调用调试器。输入`gdb`命令后，用户进入调试器的命令模式。以下是命令模式中使用的命令的简要信息：
- en: '**b main**: This tells the debugger to break at the main function call.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**b main**：这告诉调试器在主函数调用时中断。'
- en: '**r**: It is the short form that''s used to run the executable. It can be run
    by passing parameters too.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**r**：这是用于运行可执行文件的简写。也可以通过传递参数来运行。'
- en: '**n**: It is a short form for the next command, which tells us to execute the
    next statement.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**n**：这是下一个命令的简写，告诉我们执行下一个语句。'
- en: '`si` variable when it is called in the code and its value is changed. The debugger
    will display the content of the code where this variable is being used.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`si`变量在代码中被调用时，其值会发生变化。调试器将显示使用此变量的代码的内容。'
- en: '`step in`" command.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`step in`"命令。'
- en: The next statement that will be executed is `si.push(22)`. Since `si` has been
    updated, the watchpoint invokes and displays the old value of `si` and a new value
    of `si` wherein it shows that the old value of `si` was head with NULL and `sz`
    was 0\. After `si.push`, the head is updated with the new value and its execution
    comes to line 75 of the `Stack.h` file, which is where the `sz` variable is incremented.
    If the *Enter* key is pressed again, it will execute it.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 将执行的下一个语句是`si.push(22)`。由于`si`已经更新，观察点调用并显示了`si`的旧值和一个新值，其中显示了`si`的旧值是带有NULL的头部和`sz`为0。在`si.push`之后，头部将更新为新值，并且其执行到了`Stack.h`文件的第75行，这是`sz`变量增加的地方。如果再次按下*Enter*键，它将执行。
- en: 'Note that the execution has automatically moved from the main function to the
    `Stack::push` function. The following is a screenshot of the continued commands
    on the debugger:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，执行已自动从主函数移动到`Stack::push`函数。以下是调试器上继续命令的屏幕截图：
- en: '![](img/C14583_07_17.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14583_07_17.jpg)'
- en: 'Figure 7.17: Debugger display – II'
  id: totrans-224
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.17：调试器显示 – II
- en: 'The next command shows that `sz` has been updated with a new value of `1`.
    After pressing *Enter*, the execution of code moves back from `Stack::push` on
    the `line 76` back to the main function at line 8\. This is highlighted in the
    following screenshot. It shows that the execution stopped at the `si.push(426)`
    call. Once we step in, `Stack::push` will be called. The execution moves to `line
    71` of the `Stack.h` program, as shown in the red ink. Once execution comes to
    `line 74`, as shown in the red ink, the watch is called which displays that `si`
    was updated with the new value. You can see that after the completion of the `Stack::push`
    function, the flow went back to the Main code. The following is a screenshot of
    the steps that were executed in the debugger:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个命令显示`sz`已更新为新值`1`。按*Enter*后，代码的执行从`Stack::push`的`第76行`返回到主函数的`第8行`。这在下面的屏幕截图中有所突出。它显示执行停在`si.push(426)`的调用处。一旦我们进入，`Stack::push`将被调用。执行移动到`Stack.h`程序的`第71行`，如红色墨水所示。一旦执行到达`第74行`，如红色墨水所示，watch被调用，显示`si`已更新为新值。您可以看到在`Stack::push`函数完成后，流程回到了主代码。以下是调试器中执行的步骤的屏幕截图：
- en: '![](img/C14583_07_18.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14583_07_18.jpg)'
- en: 'Figure 7.18: Debugger display – III'
  id: totrans-227
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.18：调试器显示-III
- en: After pressing *Enter*, you will see that `displayStackStats` is called at `line
    11`. In the `line 12`. However, the display shows the value as `0` instead of
    the expected value of `57`. This is an error that we are still unable to figure
    out – why was the value changed? However, it is clear that the value may have
    changed somewhere in the preceding calls to the main function. So, this may not
    make us interested in continuing with the debugging ahead of us. However, we need
    to proceed and debug from the beginning again.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 按*Enter*后，您会看到`displayStackStats`在`第11行`被调用。然而，在`第12行`，显示的值是`0`，而不是预期的值`57`。这是一个错误，我们仍然无法弄清楚-为什么值会改变？但是，很明显，值可能在前面对主函数的调用中的某个地方发生了变化。因此，这可能不会让我们对继续进行调试感兴趣。但是，我们需要继续并从头开始调试。
- en: 'The following screenshot shows the commands that will be used to debug the
    code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了将用于调试代码的命令：
- en: '![](img/C14583_07_19.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14583_07_19.jpg)'
- en: 'Figure 7.19: Debugger display – IV'
  id: totrans-231
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.19：调试器显示-IV
- en: To rerun the program from the start, we must press *r*, and for confirmation
    and continuation, we need to press *y*, which means we rerun the program from
    the start. It will ask for confirmation; press *y* to continue. All of these commands
    are highlighted in blue in the preceding screenshot. During execution at line
    7, we need to run the '`display *si.head`' command, which will continuously display
    the contents of the `si.head` memory location after every statement that's executed.
    As shown in the red ink, after `22` is pushed onto the stack, the head is updated
    with the correct values. Similarly, for values `426` and `57`, when inserted into
    the stack using push, the call to head is updated correctly.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要从头重新运行程序，我们必须按*r*，然后按*y*进行确认和继续，这意味着我们从头重新运行程序。它会要求确认；按*y*继续。在前面的屏幕截图中，所有这些命令都用蓝色标出。在第7行执行时，我们需要运行'`display
    *si.head`'命令，它将在执行每条语句后持续显示`si.head`内存位置的内容。如红色墨水所示，在将`22`推入堆栈后，head会更新为正确的值。类似地，对于值`426`和`57`，在使用push将其插入堆栈时，对head的调用也会正确更新。
- en: Later, when `displayStackStats` is called, it shows the correct `size` of `3`.
    But when the top command is called, there is the wrong value shown in the head.
    This is highlighted in red ink. Now, the code for the top command doesn't alter
    the value of head, so it is clear that an error occurred in the previous statement
    of execution, that is, at `displayStackStats`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，当调用`displayStackStats`时，它显示了正确的`size`为`3`。但是当调用top命令时，head显示了错误的值。这在红色墨水中有所突出。现在，top命令的代码不会改变head的值，因此很明显错误发生在前一条执行语句中，也就是在`displayStackStats`处。
- en: 'So, we have narrowed down the code where there may be an issue. We can run
    the debugger to point `displayStackStats` and move inside `displayStackStats`
    to find the reasons that caused the values to be altered inside the Stack. The
    following is a screenshot of the same wherein the user needs to start the debugger
    from the beginning:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经缩小了可能存在问题的代码范围。我们可以运行调试器指向`displayStackStats`并移动到`displayStackStats`内部，以找出导致堆栈内部值发生变化的原因。以下是同一屏幕截图，用户需要从头开始启动调试器：
- en: '![Figure 7.20: Debugger display – IV](img/C14583_07_20.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图7.20：调试器显示-IV](img/C14583_07_20.jpg)'
- en: 'Figure 7.20: Debugger display – IV'
  id: totrans-236
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.20：调试器显示-IV
- en: After restarting the debugger from the beginning and coming to the execution
    point at line 11 where `displayStackStats` is called, we need to step in. The
    flow is to go to the start of the `displayStackStats` function. Also, we need
    to execute the next statement. Since the initial checks in the function are clear,
    they don't alter the value of the head and we can press *Enter* to execute the
    next steps. When we suspect that the next steps can alter the value of the variable
    that we're looking for, we need to step in. This is done in the preceding snapshot,
    highlighted in red. The latter execution comes to `line 97`, that is, the last
    line for the `displayStackStats` function.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动调试器并到达调用`displayStackStats`的第11行执行点后，我们需要进入。流程是进入`displayStackStats`函数的开头。此外，我们需要执行下一条语句。由于函数中的初始检查是清晰的，它们不会改变head的值，我们可以按*Enter*执行下一步。当我们怀疑下一步可能会改变我们正在寻找的变量的值时，我们需要进入。这是在前面的快照中完成的，用红色标出。后面的执行到达`第97行`，也就是`displayStackStats`函数的最后一行。
- en: 'After typing in *s*, the execution moves to the destructor stack and calls
    the clean function at line 81\. This clean command deletes the `tmp` variable,
    which has the same value as that of the head. The function empties the stack,
    which was not expected to run. It was only the `displayStackStats` function that
    was supposed to be called and executed to finally return to the main function.
    But the destructor may be called due to the local variable in the function that
    goes out of scope after the function is completed. Here, the local variable was
    the variable that was declared as a parameter to the `displayStackStats` function
    at `line 92`. So, a local copy of the `si` variable from the main function was
    created when the `displayStackStats` function was called. This variable called
    the destructor of Stack when it went out of scope. Now, the pointers from the
    `si` variable have been copied to the temporary variable and deleted the pointer
    at the end by mistake. This was not intended by the developer. Thus, at the end
    of the execution of the code, a double free error was stated. The `si` variable
    must call the Stack destructor when it goes out of scope as it will try to free
    the same memory again. To resolve this issue, it is clear that the `displayStackStats`
    function must be called with the passing parameter as a reference. For that, we
    must update the code of the `displayStackStats` function in the `Stack.h` file:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入*s*后，执行移动到析构堆栈并在第81行调用清理函数。此清理命令删除了与头部相同值的`tmp`变量。该函数清空了堆栈，这是不希望发生的。只有`displayStackStats`函数应该被调用和执行，最终返回到主函数。但是，由于局部变量超出范围，析构函数可能会被调用。在这里，局部变量是在`line
    92`处作为`displayStackStats`函数的参数声明的变量。因此，当调用`displayStackStats`函数时，会创建来自主函数的`si`变量的局部副本。当`displayStackStats`函数被调用时，该变量调用了Stack的析构函数。现在，`si`变量的指针已被复制到临时变量，并且错误地在最后删除了指针。这不是开发人员的意图。因此，在代码执行结束时，会报告双重释放错误。`si`变量在超出范围时必须调用Stack析构函数，因为它将尝试再次释放相同的内存。为了解决这个问题，很明显`displayStackStats`函数必须以传递参数作为引用的方式进行调用。为此，我们必须更新`Stack.h`文件中`displayStackStats`函数的代码：
- en: '[PRE38]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, when we save and compile the **Main.cpp** file, the binary will be generated:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们保存并编译**Main.cpp**文件时，将生成二进制文件：
- en: '[PRE39]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The preceding command generates the following output in the Terminal:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令在终端中生成以下输出：
- en: '![Figure 7.21: Debugger display – IV](img/C14583_07_21.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图7.21：调试器显示 - IV](img/C14583_07_21.jpg)'
- en: 'Figure 7.21: Debugger display – IV'
  id: totrans-244
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.21：调试器显示 - IV
- en: From the preceding screenshot, we can see that the expected values of `57` and
    `426` are shown at the top of the stack. The `displayStackStats` function also
    displays the correct information for int and the char Stack. Finally, we located
    the error using the debugger and fixed it. In the next section, we'll solve an
    activity wherein we'll be developing functions for parsing files and writing test
    cases to check the accuracy of the functions.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的屏幕截图中，我们可以看到`57`和`426`的预期值显示在堆栈顶部。`displayStackStats`函数还显示了int和char堆栈的正确信息。最后，我们使用调试器找到了错误并进行了修复。在下一节中，我们将解决一个活动，我们将开发用于解析文件并编写测试用例以检查函数准确性的函数。
- en: 'Activity 1: Checking the Accuracy of the Functions Using Test Cases and Understanding
    Test-Driven Development (TDD)'
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动1：使用测试用例检查函数的准确性并了解测试驱动开发（TDD）
- en: In this activity, we'll be developing functions so that we can parse files and
    then write test cases to check the correctness of the functions we've developed.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将开发函数，以便我们可以解析文件，然后编写测试用例来检查我们开发的函数的正确性。
- en: An IT team in a big retail organization wants to keep track of product sales
    by storing Product details and Customer details in its database as part of its
    reconciliation. On a periodic basis, the sales department will provide this data
    to the IT team in a simple text format. As the developer, you need to ensure that
    the basic sanity checking of data is done and that all the records are parsed
    correctly before the company stores records in the database. The sales department
    will provide two text files that hold Customer information and Currency information
    for all the sales transactions. You need to write parsing functions to process
    these files. The two files are `Currency` and `ConversionRatio`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一个大型零售组织的IT团队希望通过在其数据库中存储产品详情和客户详情来跟踪产品销售作为其对账的一部分。定期，销售部门将以简单的文本格式向IT团队提供这些数据。作为开发人员，您需要确保在公司将记录存储在数据库之前，对数据进行基本的合理性检查，并正确解析所有记录。销售部门将提供两个包含客户信息和货币信息的文本文件。您需要编写解析函数来处理这些文件。这两个文件是`Currency`和`ConversionRatio`。
- en: All the necessary information for the environment's setup for this project is
    kept in the Configuration file. This will also hold filenames, along with other
    parameters (such as `DB`, `RESTAPI`, and so on) and variable values in a file
    called `recordFile` and similarly for the Currency file, the variable name is
    `currencyFile`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目环境设置的所有必要信息都保存在配置文件中。这也将保存文件名，以及其他参数（如`DB`，`RESTAPI`等）和文件`recordFile`中的变量值，以及货币文件，变量名为`currencyFile`。
- en: 'The following are the test conditions we''ll be writing to check the accuracy
    of the function that''s used to parse the **CurrencyConversion.txt** file:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将编写的测试条件，以检查用于解析**CurrencyConversion.txt**文件的函数的准确性：
- en: The first line should be the header line and its first field should contain
    the "`Currency`" string.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行应该是标题行，其第一个字段应包含"`Currency`"字符串。
- en: 'The `Currency` field should be made up of three characters. For example: "`USD`",
    "`GBP`" is valid.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Currency`字段应由三个字符组成。例如："`USD`"，"`GBP`"是有效的。'
- en: The `ConversionRatio` field should be made of floating-point numbers. For example,
    `1.2`, `0.06` is valid.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConversionRatio`字段应由浮点数组成。例如，`1.2`，`0.06`是有效的。'
- en: There should be exactly two fields for each line.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每行应该恰好有两个字段。
- en: The delimiter that's used for the record is "|".
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于记录的分隔符是"|"。
- en: 'The following are test conditions we''ll be writing to check the accuracy of
    the function that''s used to parse the **RecordFile.txt** file:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将编写的测试条件，用于检查用于解析**RecordFile.txt**文件的函数的准确性：
- en: The first line should contain the header line and its first field should contain
    the "`Customer Id`" string.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行应包含标题行，其第一个字段应包含"`Customer Id`"字符串。
- en: The `Customer Id`, `Order Id`, `Product Id`, and `Quantity` should all be integer
    values. For example, `12312`, `4531134` is valid.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Customer Id`，`Order Id`，`Product Id`和`Quantity`应该都是整数值。例如，`12312`，`4531134`是有效的。'
- en: '`TotalPrice (Regional Currency)` and `TotalPrice (USD)` should be floating-point
    values. For example, `2433.34`, `3434.11` is valid.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TotalPrice (Regional Currency)`和`TotalPrice (USD)`应该是浮点值。例如，`2433.34`，`3434.11`是有效的。'
- en: The `RegionalCurrency` field should have its value present in the `std::map`.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RegionalCurrency`字段的值应该存在于`std::map`中。'
- en: There should be exactly nine fields in each line, as defined in the `HEADER`
    information of the file.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每行应该有九个字段，如文件的`HEADER`信息中定义的那样。
- en: The delimiter for the record is "|".
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录的分隔符是"|"。
- en: 'Follow these steps to implement this activity:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤执行此活动：
- en: Parse the **parse.conf** configuration file, which includes the environment
    variables for the project to run.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析**parse.conf**配置文件，其中包括项目运行的环境变量。
- en: Set the `recordFile` and `currencyFile` variables correctly from Step 1.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从步骤1正确设置`recordFile`和`currencyFile`变量。
- en: Using these variables we retrieved from the Config file, parse the Currency
    file with all conditions met. If the condition is not met, return the appropriate
    error message.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用从配置文件中检索的这些变量，解析满足所有条件的货币文件。如果条件不满足，返回适当的错误消息。
- en: Parse the Record file with all the conditions we've met. If not, then return
    an error message.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析满足的所有条件的记录文件。如果不满足条件，则返回错误消息。
- en: Create a header file named `CommonHeader.h` and declare all the utility functions,
    that is, `isAllNumbers()`, `isDigit()`, `parseLine()`, `checkFile()`, `parseConfig()`,
    `parseCurrencyParameters()`, `fillCurrencyMap()`, `parseRecordFile()`, `checkRecord()`,
    `displayCurrencyMap()`, and `displayRecords()`.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`CommonHeader.h`的头文件，并声明所有实用函数，即`isAllNumbers()`，`isDigit()`，`parseLine()`，`checkFile()`，`parseConfig()`，`parseCurrencyParameters()`，`fillCurrencyMap()`，`parseRecordFile()`，`checkRecord()`，`displayCurrencyMap()`和`displayRecords()`。
- en: Create a file named `Util.cpp` and define all the utility functions.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Util.cpp`的文件，并定义所有实用函数。
- en: Create a file named `ParseFiles.cpp` and call the `parseConfig()`, `fillCurrencyMap()`,
    and `parseRecordFile()` function.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ParseFiles.cpp`的文件，并调用`parseConfig()`，`fillCurrencyMap()`和`parseRecordFile()`函数。
- en: Compile and execute the `Util.cpp` and `ParseFiles.cpp` files.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并执行`Util.cpp`和`ParseFiles.cpp`文件。
- en: Create a file named `ParseFileTestCases.cpp` and write test cases for the functions,
    that is, `trim()`, `isAllNumbers()`, `isDigit()`, `parseCurrencyParameters()`,
    `checkFile()`, `parseConfig()`, `fillCurrencyMap()`, and `parseRecordFile()`.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ParseFileTestCases.cpp`的文件，并为函数编写测试用例，即`trim()`，`isAllNumbers()`，`isDigit()`，`parseCurrencyParameters()`，`checkFile()`，`parseConfig()`，`fillCurrencyMap()`和`parseRecordFile()`。
- en: Compile and execute the `Util.cpp` and `ParseFileTestCases.cpp` files.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并执行`Util.cpp`和`ParseFileTestCases.cpp`文件。
- en: 'The following is the flow diagram for parsing different files and displaying
    information:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是解析不同文件并显示信息的流程图：
- en: '![](img/C14583_07_22.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14583_07_22.jpg)'
- en: 'Figure 7.22: Flow diagram'
  id: totrans-276
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.22：流程图
- en: From above flowchart we have rough idea of executing the flow. To have a clear
    understanding before writing the code, let's look at the finer details. It'll
    help define test cases for each execution block.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的流程图中，我们大致了解了执行流程。在编写代码之前，让我们看看更细节的内容，以便清楚地理解。这将有助于为每个执行块定义测试用例。
- en: 'For parsing Config File block, we can break down steps into the following:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 对于解析配置文件块，我们可以将步骤分解如下：
- en: Check if config file exists and has read permission.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查配置文件是否存在并具有读取权限。
- en: Check if it has appropriate header.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查是否有适当的标题。
- en: Parse whole file line by line.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逐行解析整个文件。
- en: For each line, parse fields with '=' as delimiter.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每一行，使用'='作为分隔符解析字段。
- en: If there are 2 fields from above step , process to see if it is `Currency file`
    or `Record file` variables and store appropriately.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果从上一步中有2个字段，则处理以查看它是`Currency file`还是`Record file`变量，并适当存储。
- en: If there are no 2 fields from step 4 go to next line.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果从步骤4中没有2个字段，则转到下一行。
- en: After completely parsing file, check if both variables from above step are not
    empty.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完全解析文件后，检查上述步骤中的两个变量是否不为空。
- en: If empty, return with error.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果为空，则返回错误。
- en: 'For parsing `Currency File` block, we can break down steps into the following:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 对于解析`Currency File`块，我们可以将步骤分解如下：
- en: Read variable for `CurrencyFile` and see if the file exists and has read permission.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取`CurrencyFile`的变量，看看文件是否存在并且具有读取权限。
- en: Check if it has appropriate header.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查是否有适当的标题。
- en: Parse whole file line by line, with '|' as delimiter.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逐行解析整个文件，使用'|'作为分隔符。
- en: If there are exactly 2 fields found for each line, consider first as `Currency
    field` and second as `conversion field`.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果每行找到确切的2个字段，将第一个视为`Currency field`，第二个视为`conversion field`。
- en: If there are no 2 fields found from step 3, return with appropriate error message.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果从步骤3中没有找到2个字段，则返回适当的错误消息。
- en: From step 4, do all checks for `Currency field` (it should be of 3 characters)
    and `Conversion Field` ( should be digit).
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从步骤4开始，对`Currency field`（应为3个字符）和`Conversion Field`（应为数字）进行所有检查。
- en: If passed from step 6, store the `currency`/`conversion` value as pair on map
    with key as `Currency` and value as digit.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果从步骤6通过，将`currency`/`conversion`值存储为具有`Currency`作为键和数字作为值的映射对。
- en: If not passed from step 6, return error stating for that `currency`.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果未从步骤6通过，返回说明`currency`的错误。
- en: After complete parsing of the `Currency` file, there will be map created that
    will have conversion values for all the currencies.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析完整的`Currency`文件后，将创建一个映射，其中将为所有货币的转换值。
- en: 'For parsing `Record File` block, we can break down steps into the following:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 对于解析`Record File`块，我们可以将步骤分解为以下步骤：
- en: Read variable for `RecordFile` and see if the file exists and has read permission.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取`RecordFile`的变量，并查看文件是否存在并具有读取权限。
- en: Check if it has appropriate header.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查是否有适当的头部
- en: Parse whole file line by line, with '|' as delimiter.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逐行解析整个文件，以'|'作为分隔符。
- en: If there no 9 fields found from above step return with appropriate error message.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果从上述步骤中找不到9个字段，请返回适当的错误消息。
- en: If there are 9 fields found, do corresponding checks for all fields listed in
    start of activity.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到9个字段，请对活动开始时列出的所有字段进行相应的检查。
- en: If step 5 does not pass, return with appropriate error message.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果步骤5未通过，请返回适当的错误消息。
- en: If step 5 is passed, store the record in vector of records.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果步骤5通过，请将记录存储在记录的向量中。
- en: After completely parsing Record file, all the records will be stored in vector
    of records.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在完全解析记录文件后，所有记录将存储在记录的向量中。
- en: 'While creating flow for parsing all the three files, we see few steps repeating
    for all 3 files such as:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建解析所有三个文件的流程时，我们看到所有3个文件都重复了一些步骤，例如：
- en: Checking if file exists and is readable
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 检查文件是否存在且可读
- en: Checking if file has a correct header information
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 检查文件是否具有正确的头部信息
- en: Parsing the records with delimiter
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分隔符解析记录
- en: Checking if field is `Digit` is common in `Currency` and `Record file`
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 检查字段是否为`Digit`在`Currency`和`Record file`中是常见的
- en: Checking if field is `Numeric` is common in `Currency` and `Record file`
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 检查字段是否为`Numeric`在`Currency`和`Record file`中是常见的
- en: The above points will help in refactoring the code. Also, there will be one
    common function for parsing the fields with delimiter, that is `trim function`.
    So, when we parse records with delimiter we can get value with space or tab at
    begin or end and that may not be needed , so we need to trim it once when parse
    the record.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 上述要点将有助于重构代码。此外，将有一个用于使用分隔符解析字段的常见函数，即`trim`函数。因此，当我们使用分隔符解析记录时，我们可能会得到带有空格或制表符的值，这可能是不需要的，因此我们需要在解析记录时修剪它一次。
- en: Now we know we have above steps that are common we can write individual function
    for them. To start with TDD, we first understand requirement for function and
    start writing unit test cases first to test these functionalities. Then we write
    function such that it will pass the unit test cases. If few test cases fail we
    iterate the steps of updating function and executing test cases, until all of
    them pass.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们有上述常见的步骤，我们可以为它们编写单独的函数。为了开始TDD，我们首先了解函数的要求，并首先编写单元测试用例来测试这些功能。然后我们编写函数，使其通过单元测试用例。如果有几个测试用例失败，我们迭代更新函数并执行测试用例的步骤，直到它们全部通过。
- en: For our example, above we can write `trim` function,
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们可以编写`trim`函数，
- en: Now we know in trim function we need to remove first and last extra spaces/tab.
    For example, if string contains " AA " , the trim should return "AA" remove all
    the spaces.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道在修剪函数中，我们需要删除第一个和最后一个额外的空格/制表符。例如，如果字符串包含"AA"，则修剪应返回"AA"删除所有空格。
- en: The trim function can return new string with expected value or it can update
    the same string which was passed to it.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 修剪函数可以返回具有预期值的新字符串，也可以更新传递给它的相同字符串。
- en: 'So now we can write signature of the trim function : `string trim ( string
    &) ;`'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在我们可以编写修剪函数的签名：`string trim(string&);`
- en: 'We can write the following test cases for it:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为此编写以下测试用例：
- en: With only extra characters (" ") , returns empty string ().
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅有额外字符(" ")，返回空字符串()。
- en: With only empty characters in beginning(" AA") return string with end characters
    ("AA")
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅以开头的空字符("AA")返回带有结束字符("AA")的字符串
- en: With only empty characters at end("AA ") , should return string with begin characters("AA")
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅以结尾的空字符("AA ")，应返回带有开始字符("AA")的字符串
- en: With characters in middle (" AA ") return string with characters ("AA")
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在中间有字符("AA")，返回带有字符("AA")的字符串
- en: With empty space in middle ("AA BB") , return the same string ("AA BB")
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在中间有空格("AA BB")，返回相同的字符串("AA BB")
- en: All steps 3,4,5 with single character. Should return string with single character.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有步骤3,4,5都是单个字符。应返回具有单个字符的字符串。
- en: To create test cases , please check file `trim` function are written in test
    suite `trim`. Now write `trim` function with signature shown above in file. Execute
    test cases of `trim` function and check if it passes. It doesn't change the function
    appropriately and test it again. Repeat till all test cases pass.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建测试用例，请检查文件`trim`函数是否在测试套件`trim`中编写。现在在文件中编写具有上述签名的`trim`函数。执行`trim`函数的测试用例并检查是否通过。如果没有适当更改函数并再次测试。重复直到所有测试用例通过。
- en: Now we are confident to use `trim` function in the project. Repeat similar steps
    for the rest of the common functions (`isDigit`, `isNumeric`, `parseHeader` and
    so on). Please refer the **Util.cpp** file and **ParseFiletestCases.cpp** for
    the same and test all the common functions.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有信心在项目中使用`trim`函数。对于其余的常见函数（`isDigit`，`isNumeric`，`parseHeader`等），请参考**Util.cpp**文件和**ParseFiletestCases.cpp**，并测试所有常见函数。
- en: After completing common functions, we can write parse each file function separately.
    Main thing to understand and learn here is how to break down module to small functions.
    Find small repetitive tasks and create small functions for each so it is refactored.
    Understand the detail functionality of these small functions and create appropriate
    unit test cases.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 完成常见功能后，我们可以分别编写解析每个文件的函数。要理解和学习的主要内容是如何将模块分解为小函数。找到小的重复任务，并为每个创建小函数，以便进行重构。了解这些小函数的详细功能，并创建适当的单元测试用例。
- en: Complete single function and thoroughly test it, if it fails, then update the
    function till it passes all test cases. Similarly, complete other functions. Then
    write and execute test cases for bigger functions, that should be relatively easy
    since we are calling small functions tested above in these bigger functions.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 完整测试单个函数，如果失败，则更新函数直到通过所有测试用例。类似地，完成其他函数。然后编写并执行更大函数的测试用例，这应该相对容易，因为我们在这些更大函数中调用了上面测试过的小函数。
- en: 'After implementing the preceding steps, we''ll get the following output:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施了上述步骤之后，我们将得到以下输出：
- en: '![Figure 7.23: All tests running properly](img/C14583_07_23.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![图7.23：所有测试都正常运行](img/C14583_07_23.jpg)'
- en: 'Figure 7.23: All tests running properly'
  id: totrans-331
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.23：所有测试都正常运行
- en: 'Below is the screenshot of the next steps:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是下一步的屏幕截图：
- en: '![Figure 7.24: All tests running properly](img/C14583_07_24.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![图7.24：所有测试都正常运行](img/C14583_07_24.jpg)'
- en: 'Figure 7.24: All tests running properly'
  id: totrans-334
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.24：所有测试都正常运行
- en: Note
  id: totrans-335
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 706.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在第706页找到。
- en: Summary
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at various ways in which errors that are thrown by
    executables can be grabbed at compile time and runtime using asserts. We also
    learned about static assertion. We understood how exceptions are generated and
    how to handle them in the code. We also saw how unit testing can act as a savior
    to developers as they'll be able to identify any issues in the code at the beginning.
    We utilized mock objects for the classes that needed to be used in the test cases.
    We then learned about the debugger, breakpoints, watchpoints, and visualizing
    the data. We were able to locate the issues in the code using the debugger and
    fix them. We also solved an activity wherein we wrote the necessary test cases
    to check the accuracy of the functions that were used for parsing the files.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了各种通过可执行文件抛出的错误可以在编译时和运行时使用断言来捕获的方法。我们还学习了静态断言。我们了解了异常是如何生成的，以及如何在代码中处理它们。我们还看到单元测试如何可以成为开发人员的救星，因为他们可以在开始时识别代码中的任何问题。我们为需要在测试用例中使用的类使用了模拟对象。然后我们学习了调试器、断点、观察点和数据可视化。我们能够使用调试器找到代码中的问题并修复它们。我们还解决了一个活动，其中我们编写了必要的测试用例来检查用于解析文件的函数的准确性。
- en: In the next chapter, we'll learn how to optimize our code. We'll review how
    the processors execute the code and access the memory. We'll also learn how to
    determine the excess time that will be taken by the software to execute. Finally,
    we'll learn about memory alignment and cache access.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何优化我们的代码。我们将回顾处理器如何执行代码并访问内存。我们还将学习如何确定软件执行所需的额外时间。最后，我们将学习内存对齐和缓存访问。
