- en: Keyboard Input
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 键盘输入
- en: Now that we have sprites and animations, and can move these sprites around our
    canvas, we will need to add some interaction into our game. There are a few ways
    we can get keyboard input for our game. One way is through JavaScript, making
    calls to different functions in our WebAssembly module based on that input. The
    first section of our code will do just that. We will add some functions inside
    the WebAssembly module for us to wrap in JavaScript wrappers. We will also set
    up some JavaScript keyboard event handlers that we will use to make calls into
    our WebAssembly module whenever the keyboard events are triggered.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了精灵和动画，可以在画布上移动这些精灵，我们需要在游戏中添加一些交互。有几种方法可以获取游戏的键盘输入。一种方法是通过JavaScript，根据输入调用WebAssembly模块中的不同函数。我们代码的第一部分将做到这一点。我们将在WebAssembly模块中添加一些函数，供我们在JavaScript包装器中使用。我们还将设置一些JavaScript键盘事件处理程序，这些处理程序将在触发键盘事件时调用我们的WebAssembly模块。
- en: The other way we can get input into our WebAssembly module is to allow SDL to
    do all the heavy lifting for us. That involves adding C code into our WebAssembly
    module that captures the `SDL_KEYDOWN` and `SDL_KEYUP` events. The module will
    then look at the event keycode to determine what key triggered the event. There
    are costs and benefits to writing our code using either method. Generally speaking,
    having SDL managing our keyboard input costs us some of the flexibility of writing
    our keyboard input manager inside the JavaScript, while, at the same time, we
    gain the benefit of more straightforward code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以让SDL来为我们处理所有繁重的工作，从而将输入传递到我们的WebAssembly模块中。这涉及将C代码添加到我们的WebAssembly模块中，以捕获`SDL_KEYDOWN`和`SDL_KEYUP`事件。然后，模块将查看事件的键码，以确定触发事件的键。使用任一方法编写我们的代码都有成本和收益。一般来说，让SDL管理我们的键盘输入会使我们失去在JavaScript中编写键盘输入管理器的灵活性，同时，我们也会获得更加直接的代码的好处。
- en: 'You will need to include several images in your build to make this project
    work. Make sure you include the `/Chapter05/sprites/` folder from the project''s
    GitHub. If you haven''t yet downloaded the GitHub project, you can get it online
    at: [https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在构建中包含几个图像，以使该项目正常工作。确保您从项目的GitHub中包含`/Chapter05/sprites/`文件夹。如果您还没有下载GitHub项目，可以在以下网址在线获取：[https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly)。
- en: 'In this chapter, we will do the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将执行以下操作：
- en: Learn how to use JavaScript keyboard events to make calls into our WebAssembly
    module
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用JavaScript键盘事件调用我们的WebAssembly模块
- en: Learn how to use SDL events to manage keyboard input from inside our WebAssembly
    module
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用SDL事件来管理WebAssembly模块内的键盘输入
- en: Demonstrate what we have learned by using keyboard input to move a spaceship
    sprite around the canvas
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用键盘输入来移动画布上的飞船精灵来演示我们所学到的内容
- en: JavaScript keyboard input
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript键盘输入
- en: The first thing we will do is learn how to listen for JavaScript keyboard events
    and make calls into our WebAssembly module based on those events. We will be reusing
    a lot of the code we wrote for [Chapter 2](0c9c09be-1e03-4074-9718-7bc3bf9e70e2.xhtml),
    *HTML5 and WebAssembly*, so the first thing we should do is grab that code from
    the `Chapter02` folder and copy it into our new `Chapter05` folder. Copy the `new_shell.html`
    file from inside the `Chapter02` directory to the `Chapter05` directory, then
    rename that file `jskey_shell.html`. Next, copy `shell.c` from the `Chapter02`
    directory to the `Chapter05` directory and rename that file `jskey.c`. Finally,
    copy the `shell.css` file from the `Chapter02` directory into the `Chapter05`
    directory, but do not rename it. These three files will give us a starting point
    for writing the JavaScript keyboard input code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先学习如何监听JavaScript键盘事件，并根据这些事件调用我们的WebAssembly模块。我们将重用我们为[第2章](0c9c09be-1e03-4074-9718-7bc3bf9e70e2.xhtml)编写的大部分代码，*HTML5和WebAssembly*，所以我们应该首先从`Chapter02`文件夹中获取该代码，并将其复制到我们的新`Chapter05`文件夹中。将`Chapter02`目录中的`new_shell.html`文件复制到`Chapter05`目录，然后将该文件重命名为`jskey_shell.html`。接下来，将`Chapter02`目录中的`shell.c`复制到`Chapter05`目录，并将该文件重命名为`jskey.c`。最后，将`Chapter02`目录中的`shell.css`文件复制到`Chapter05`目录，但不要重命名。这三个文件将为我们编写JavaScript键盘输入代码提供一个起点。
- en: 'First, let''s take a look at the `jskey.c` file that we have just created from
    `shell.c`. We can get rid of most of the code inside this file right at the beginning.
    Delete all of the code after the end of the `main` function. That means you will
    be deleting all of the following code:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看一下我们刚刚从`shell.c`创建的`jskey.c`文件。我们可以在文件的开头就把大部分代码删除掉。删除`main`函数结束后的所有代码。这意味着你将删除以下所有代码：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we will modify the `main` function. We no longer want to use `EM_ASM`
    inside our `main` function to call our JavaScript wrapper initialization function,
    so delete the following two lines of code from the `main` function:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将修改`main`函数。我们不再希望在`main`函数内部使用`EM_ASM`来调用我们的JavaScript包装器初始化函数，因此从`main`函数中删除以下两行代码：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The only thing left in our `main` function is a single `printf` statement.
    We will change that line to let us know that the `main` function has run. You
    can change this code to say anything you like, or remove the `printf` statement
    entirely. The following code shows what we have for the `main` function:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main`函数中，唯一剩下的是一个`printf`语句。我们将更改该行以让我们知道`main`函数已运行。您可以更改此代码以说任何您喜欢的内容，或者完全删除`printf`语句。以下代码显示了我们`main`函数的内容：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that we have modified the `main` function, and removed all of the functions
    we no longer need, let''s put in some functions called when a JavaScript `keyboard`
    event is triggered. We will add a function for a `keypress` event when the user
    presses one of the arrow keys on the keyboard. The following code will be called
    by those `keypress` events:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经修改了`main`函数，并删除了我们不再需要的所有函数，让我们添加一些在触发JavaScript`keyboard`事件时调用的函数。当用户在键盘上按下箭头键时，我们将添加一个`keypress`事件的函数。以下代码将被这些`keypress`事件调用：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We would also like to know when the user releases a key. So,to do this, we
    will add four `release` functions into the C module, as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想知道用户何时释放按键。因此，我们将在C模块中添加四个`release`函数，如下所示：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that we have our new C file, we can change our shell file. Open up `jskey_shell.html`.
    We do not need to change anything in the `head` tag, but inside the `body`, we
    will want to remove a lot of the HTML elements that we will no longer be using.
    Go ahead and delete all of the elements except the `textarea` element. We want
    to keep our `textarea` element around so that we can see the output of the `printf`
    statements inside our module. We need to delete the following HTML from the `jskey_shell.html`
    before our `textarea` element:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了新的C文件，我们可以改变我们的shell文件。打开`jskey_shell.html`。我们不需要改变`head`标签中的任何内容，但在`body`内部，我们将删除许多我们将不再使用的HTML元素。继续删除除`textarea`元素之外的所有元素。我们希望保留`textarea`元素，以便我们可以看到模块内的`printf`语句的输出。我们需要在`jskey_shell.html`中删除以下HTML，然后再删除`textarea`元素之后的`div`及其内容：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, after the `textarea` element, we need to delete the following `div` and
    its contents:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`textarea`元素之后，我们需要删除以下`div`及其内容：
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After that, we have the `script` tag that contains all of our JavaScript code.
    We will need to add some global variables into that `script` tag. First, let''s
    add some Boolean variables that will tell us if the player is pressing any of
    our arrow keys. Initialize all of these values to `false`, as per the following
    example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们有包含所有JavaScript代码的`script`标签。我们需要在该`script`标签中添加一些全局变量。首先，让我们添加一些布尔变量，告诉我们玩家是否按下了我们的任何箭头键。将所有这些值初始化为`false`，如下例所示：
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Following our `key_press` flags, we will have all of the `wrapper` variables
    that will be used to hold the `wrapper` functions that call functions within our
    WebAssembly module. We will initialize all of these wrappers to `null`. Later,
    we will only call these functions if they are not `null`. The following code shows
    our wrappers:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`key_press`标志之后，我们将有所有将用于保存调用我们WebAssembly模块内函数的`wrapper`函数的`wrapper`变量。我们将所有这些包装器初始化为`null`。稍后，我们只会在这些函数不为`null`时调用这些函数。以下代码显示了我们的包装器：
- en: '[PRE8]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that we have defined all of our global variables, we need to add functions
    triggered on the `key_press` and `key_release` events. The first of these functions
    is `keyPress`. The code we have for this function is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了所有的全局变量，我们需要添加在`key_press`和`key_release`事件上触发的函数。其中之一是`keyPress`函数。我们为这个函数编写的代码如下：
- en: '[PRE9]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The first line of this function is `event.preventDefault();`. This line prevents
    the web browser from doing what it would normally do when the user presses the
    key in question. For instance, if you are playing a game, and you press the down
    arrow key to have your spaceship move down, you would not want the web page also
    to scroll down. Placing this `preventDefault` call at the beginning of the `keyPress`
    function will disable the default behavior for all key presses. In other projects,
    this may not be what you want. If you only wanted to disable the default behavior
    when pressing the down arrow key, you would place that call inside of the `if`
    block that manages the down arrow key press. The following block of code checks
    to see if the event is a repeat event:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的第一行是`event.preventDefault();`。这一行阻止了网页浏览器在用户按下相应键时通常会做的事情。例如，如果你正在玩游戏，并按下下箭头键使你的飞船向下移动，你不希望网页也滚动向下。在`keyPress`函数的开头放置这个`preventDefault`调用将禁用所有按键的默认行为。在其他项目中，这可能不是你想要的。如果你只想在按下下箭头键时禁用默认行为，你会将该调用放在管理下箭头键按下的`if`块内。以下代码块检查事件是否为重复事件：
- en: '[PRE10]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That would be true if you held down one of the keys. For example, if you held
    down the up arrow key, you would initially get one up arrow key press event, but,
    after a delay, you would start getting a repeat event for the up arrow key. You
    may have noticed that behavior inside a word processor if you have ever held down
    a single key, like the *F* key for instance. You would start with a single f that
    appears inside your word processor, but, after a second or so you would start
    to get ffffffffffffff, and you would continue to see f repeated into your word
    processor for as long as you held down the *F* key. Generally speaking, this behavior
    may be helpful when you are using a word processor, but is detrimental when you
    are playing a game. The preceding `if` block causes us to exit the function when
    we are receiving repeat key events.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按住其中一个键是正确的。例如，如果你按住上箭头键，你最初会得到一个上箭头键按下事件，但是，经过一段时间后，你会开始得到一个重复的上箭头键事件。你可能已经注意到，如果你曾经按住一个单一的键，比如*F*键，你会在你的文字处理器中看到一个f，但是，一秒左右后你会开始看到fffffffffffff，你会继续看到f重复进入你的文字处理器，只要你按住*F*键。一般来说，这种行为在使用文字处理器时可能是有帮助的，但在玩游戏时是有害的。前面的`if`块使我们在接收到重复按键事件时退出函数。
- en: 'The next several `if` blocks in our function check the various JavaScript keycodes
    and make calls to our WebAssembly module based on those keycodes. Let''s take
    a quick look at what happens when the player presses the up arrow key, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们函数中的接下来的几个`if`块检查各种JavaScript键码，并根据这些键码调用我们的WebAssembly模块。让我们快速看一下当玩家按下上箭头键时会发生什么：
- en: '[PRE11]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `if` statement is checking the event''s keycode against the value `38`,
    which is the keycode value for the up arrow. You can find a list of HTML5 keycodes
    at: [https://www.embed.com/typescript-games/html-keycodes.html](https://www.embed.com/typescript-games/html-keycodes.html).
    If the triggering event was an up arrow key press, we set the `up_key_press` variable
    to `true`. If our `up_press_wrapper` is initialized, we call it, which in turn
    will call the `press_up` function inside our WebAssembly module. After the `if`
    block that checks against the up arrow keycode, we will need more `if` blocks
    to check against the other arrow keys, as shown in the following example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句正在检查事件的键码是否等于值`38`，这是上箭头的键码值。您可以在[https://www.embed.com/typescript-games/html-keycodes.html](https://www.embed.com/typescript-games/html-keycodes.html)找到HTML5键码的列表。如果触发事件是上箭头键按下，我们将`up_key_press`变量设置为`true`。如果我们的`up_press_wrapper`已初始化，我们将调用它，它将调用WebAssembly模块内的`press_up`函数。在检查上箭头键码的`if`块之后，我们将需要更多的`if`块来检查其他箭头键，如下例所示：'
- en: '[PRE12]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After the `keyUp` function, we need to create a very similar function: `keyRelease`.
    This function is pretty much the same as `keyUp`, except it will be calling the
    key release functions in the WebAssembly module. The following code shows what
    the `keyRelease()` function looks like:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在`keyUp`函数之后，我们需要创建一个非常相似的函数：`keyRelease`。这个函数与`keyUp`几乎相同，只是它将调用WebAssembly模块中的按键释放函数。以下代码显示了`keyRelease()`函数的样子：
- en: '[PRE13]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After we have defined these functions, we need to make them event listeners
    with the following two lines of JavaScript code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了这些函数之后，我们需要使用以下两行JavaScript代码将它们作为事件监听器：
- en: '[PRE14]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The next thing we need to do is modify our `InitWrappers` function to wrap
    the functions we created earlier. We do this using the `Module.cwrap` function.
    The new version of our `InitWrappers` function is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要修改我们的`InitWrappers`函数来包装我们之前创建的函数。我们使用`Module.cwrap`函数来实现这一点。我们的`InitWrappers`函数的新版本如下：
- en: '[PRE15]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We have two functions that are no longer needed that we can remove. These are
    the `runbefore` and `runafter` functions. These functions were used in our shell
    in chapter 2, *HTML5 and WebAssembly,* to demonstrate the `preRun` and `postRun`
    module functionality. All they do is log a line out to the console, so please
    remove the following code from the `jskey_shell.html` file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个不再需要的函数可以删除。这些是`runbefore`和`runafter`函数。这些函数在第2章的shell中使用，用来演示`preRun`和`postRun`模块功能。它们只是在控制台中记录一行，所以请从`jskey_shell.html`文件中删除以下代码：
- en: '[PRE16]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now that we have deleted these lines, we can remove the call to these functions
    from our module''s `preRun` and `postRun` arrays. Because we had earlier removed
    the call to `EM_ASM( InitWrappers() );` inside our WebAssembly module''s `main`
    function, we will need to run `InitWrappers` from the module''s `postRun` array.
    The following code shows what the beginning of the `Module` object definition
    looks like after these changes:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经删除了这些行，我们可以从模块的`preRun`和`postRun`数组中删除对这些函数的调用。因为我们之前已经从WebAssembly模块的`main`函数中删除了对`EM_ASM(
    InitWrappers() );`的调用，所以我们需要从模块的`postRun`数组中运行`InitWrappers`。以下代码显示了这些更改后`Module`对象定义的开头是什么样子的：
- en: '[PRE17]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we should build and test our new JavaScript keyboard handler. Run the following
    `emcc` command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该构建和测试我们的新JavaScript键盘处理程序。运行以下`emcc`命令：
- en: '[PRE18]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You will notice that we have used the `-s EXPORT_FUNCTIONS` flag to export all
    of our key press and key release functions. Because we are not using the default
    shell, we have used the `--shell-file jskey_shell.html` flag. The `-s NO_EXIT_RUNTIME=1`
    flag prevents the browser from exiting the WebAssembly module if there is no emscripten
    main loop. We also exported `cwrap` and `ccall` with `-s EXTRA_EXPORTED_RUNTIME_METHODS="['cwrap',
    'ccall']"`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们使用了`-s EXPORT_FUNCTIONS`标志来导出所有的按键按下和按键释放函数。因为我们没有使用默认的shell，我们使用了`--shell-file
    jskey_shell.html`标志。`-s NO_EXIT_RUNTIME=1`标志防止浏览器在没有emscripten主循环时退出WebAssembly模块。我们还使用`-s
    EXTRA_EXPORTED_RUNTIME_METHODS="['cwrap', 'ccall']"`导出了`cwrap`和`ccall`。
- en: 'The following is a screenshot of the app:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是应用程序的屏幕截图：
- en: '![](img/e34de0b2-9525-4a1b-9cad-5e851c5e1368.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e34de0b2-9525-4a1b-9cad-5e851c5e1368.png)'
- en: 'Figure 5.1: Screenshot of jskey.html'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：jskey.html的屏幕截图
- en: It is important to remember that the app must be run from a web server, or using
    `emrun`. If you do not run the app from a web server, or use `emrun`, you will
    receive a variety of errors when the JavaScript glue code attempts to download
    the WASM and data files. You should also know that IIS requires additional configuration
    in order to set the proper MIME types for the `.wasm` and `.data` file extensions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，应用程序必须从Web服务器运行，或者使用`emrun`。如果您不从Web服务器运行应用程序，或者使用`emrun`，当JavaScript粘合代码尝试下载WASM和数据文件时，您将收到各种错误。您还应该知道，IIS需要额外的配置才能为`.wasm`和`.data`文件扩展名设置正确的MIME类型。
- en: In the next section, we will be using the SDL event handler and the default
    WebAssembly shell to capture and process keyboard events.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用SDL事件处理程序和默认的WebAssembly shell来捕获和处理键盘事件。
- en: Adding SDL keyboard input to WebAssembly
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向WebAssembly添加SDL键盘输入
- en: SDL allows us to poll for keyboard input. Whenever the user presses a key, a
    call to `SDL_PollEvent( &event )` will return us an `SDK_KEYDOWN SDL_Event`. When
    a key is released, it will return an `SDK_KEYUP` event. We can look into the values
    in such a case to figure out which key has been pressed or released. We can use
    this information to set flags in our game to let us know when to move our spaceship,
    and in what direction. Later, we can add code that detects a space bar press that
    will fire our ship's weapons.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: SDL允许我们轮询键盘输入。每当用户按下键时，调用`SDL_PollEvent( &event )`将返回一个`SDK_KEYDOWN SDL_Event`。当释放键时，它将返回一个`SDK_KEYUP`事件。在这种情况下，我们可以查看这些值，以确定哪个键被按下或释放。我们可以使用这些信息来设置游戏中的标志，以便在何时移动我们的飞船以及移动的方向。稍后，我们可以添加检测空格键按下的代码，以发射飞船的武器。
- en: For now, we are going to go back to using the default Emscripten shell. For
    the rest of this section, we will be able to do everything from within the WebAssembly
    C code. I will walk you through creating a new `keyboard.c` file from scratch,
    which will handle keyboard events and print to the `textarea` in our default shell.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将回到使用默认的Emscripten shell。在本节的其余部分，我们将能够在WebAssembly C代码中完成所有操作。我将带你创建一个新的`keyboard.c`文件，从头开始处理键盘事件并在默认shell中打印到`textarea`。
- en: 'Start by creating a new `keyboard.c` file, and add the following `#include`
    directives at the top of the file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个新的`keyboard.c`文件，并在文件顶部添加以下`#include`指令：
- en: '[PRE19]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After that, we need to add our global `SDL` objects. The first two, `SDL_Window`
    and `SDL_Renderer`, should look familiar by now. The third one, `SDL_Event`, is
    new. We will be populating this event object using a call to `SDL_PollEvent` later
    in our code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要添加我们的全局`SDL`对象。前两个，`SDL_Window`和`SDL_Renderer`，现在应该看起来很熟悉。第三个，`SDL_Event`，是新的。我们将使用`SDL_PollEvent`在代码后期填充这个事件对象：
- en: '[PRE20]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Like the JavaScript version of this code, we will be using global variables
    to keep track of which arrow keys we are currently pressing. These will all be
    Boolean variables, as shown in the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 和这段代码的JavaScript版本一样，我们将使用全局变量来跟踪我们当前按下的箭头键。这些都将是布尔变量，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The first function we are going to define is `input_loop`, but before we can
    define that function, we need to declare two functions that `input_loop` will
    be calling, as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要定义的第一个函数是`input_loop`，但在我们定义该函数之前，我们需要声明`input_loop`将调用的两个函数，如下所示：
- en: '[PRE22]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will allow us to define the `input_loop` function before actually defining
    what happens when `input_loop` calls those functions. The `input_loop` function
    will call `SDL_PollEvent` to get an event object. We can then look at the type
    of event, and, if it is an `SDL_KEYDOWN` or `SDL_KEYUP` event, we can call the
    appropriate function to handle those events, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们在实际定义`input_loop`调用这些函数之前定义`input_loop`函数。`input_loop`函数将调用`SDL_PollEvent`来获取一个事件对象。然后我们可以查看事件的类型，如果是`SDL_KEYDOWN`或`SDL_KEYUP`事件，我们可以调用适当的函数来处理这些事件，如下所示：
- en: '[PRE23]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The first of these functions that we will define will be the `key_press()`
    function. Inside this function, we will look at the keyboard event in a switch
    and compare the value to the different arrow key SDLK events. If the key had been
    previously up, it prints out a message that lets us know the key the user pressed.
    Then we should set the `keypress` flag to `true`. The following example shows
    the `key_press()` function in its entirety:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义的第一个函数是`key_press()`函数。在这个函数内部，我们将在switch中查看键盘事件，并将值与不同的箭头键SDLK事件进行比较。如果键之前是弹起状态，它会打印出一个消息，让我们知道用户按下了哪个键。然后我们应该将`keypress`标志设置为`true`。下面的示例展示了`key_press()`函数的全部内容：
- en: '[PRE24]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first line inside the `key_press` function is a switch statement, `switch(event.key.keysym.sym)`.
    These are structures within structures. Inside the `input_loop` function, we called
    `SDL_PollEvent`, passing a reference to an `SDL_Event` structure. This structure
    contains event data for any possible event that may be returned to us, as well
    as a type that tells us what kind of event this is. If the type is `SDL_KEYDOWN`
    or `SDL_KEYUP`, that means the internal `key` structure, which is a structure
    of type `SDL_KeyboardEvent`, is populated. If you would like to see the full definition
    of the `SDL_Event` structure, you can find it on the SDL website, at: [https://wiki.libsdl.org/SDL_Event](https://wiki.libsdl.org/SDL_Event).
    Looking at the key variable inside of `SDL_Event`, you will notice it is a structure
    of type `SDL_KeyboardEvent`. This structure has a lot of data in it that we will
    not be using yet. It includes information such as timestamp, whether this key
    is a repeat press, or whether this key is being pressed or released; but what
    we are looking at in our switch is they `keysym` variable, which is a structure
    of type `SDL_Keysym`. For more information on the `SDL_KeyboardEvent`, you can
    find its definition on the SDL website, at: [https://wiki.libsdl.org/SDL_KeyboardEvent](https://wiki.libsdl.org/SDL_KeyboardEvent).
    The `keysym` variable in the `SDL_KeyboardEvent` structure is where you will find
    the `SDL_Keycode` in the `sym` variable. This keycode is what we must look at
    to determine which key the player pressed. That is why we have the switch statement
    built around `switch( event.key.keysym.sym )`. A link to all of the possible values
    for the SDL keycodes is available at: [https://wiki.libsdl.org/SDL_Keycode](https://wiki.libsdl.org/SDL_Keycode).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`key_press`函数内的第一行是一个switch语句，`switch(event.key.keysym.sym)`。这些都是结构中的结构。在`input_loop`函数内，我们调用了`SDL_PollEvent`，传递了一个`SDL_Event`结构的引用。这个结构包含了可能返回给我们的任何事件的事件数据，以及一个告诉我们这是什么类型事件的类型。如果类型是`SDL_KEYDOWN`或`SDL_KEYUP`，那意味着内部的`key`结构，它是一个`SDL_KeyboardEvent`类型的结构，被填充了。如果你想看`SDL_Event`结构的完整定义，你可以在SDL网站上找到它：[https://wiki.libsdl.org/SDL_Event](https://wiki.libsdl.org/SDL_Event)。在`SDL_Event`内部的key变量，你会注意到它是一个`SDL_KeyboardEvent`类型的结构。这个结构里有很多我们暂时不会用到的数据。它包括时间戳、这个键是否是重复按下的，或者这个键是被按下还是被释放；但是我们在switch语句中关注的是`keysym`变量，它是一个`SDL_Keysym`类型的结构。关于`SDL_KeyboardEvent`的更多信息，你可以在SDL网站上找到它的定义：[https://wiki.libsdl.org/SDL_KeyboardEvent](https://wiki.libsdl.org/SDL_KeyboardEvent)。`SDL_KeyboardEvent`结构中的`keysym`变量是你会在`sym`变量中找到`SDL_Keycode`的地方。这个键码是我们必须查看的，以确定玩家按下了哪个键。这就是为什么我们在`switch(
    event.key.keysym.sym )`周围构建了switch语句。SDL键码的所有可能值的链接可以在这里找到：[https://wiki.libsdl.org/SDL_Keycode](https://wiki.libsdl.org/SDL_Keycode)。'
- en: 'All of the case statements inside our switch look pretty similar: if a given
    SDLK keycode is pressed, we check to see if that key was pressed in the previous
    cycle, and we only print out the value if it has not. Then we set the `keypress`
    flag to `true`. The following example shows the code where we detect the press
    of the left arrow key:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在switch语句中的所有case语句看起来非常相似：如果按下给定的SDLK键码，我们会检查上一个周期是否按下了该键，并且仅在其未按下时打印出该值。然后我们将`keypress`标志设置为`true`。以下示例显示了我们检测左箭头键按下的代码：
- en: '[PRE25]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Our application calls the `key_release` function when the event type is `SDL_KEYUP`
    . That is very similar to the `key_down` function. The primary difference is that
    it is looking to see if the user pressed the key, and only prints out a message
    when the state changes to unpressed. The following example shows that function
    in its entirety:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件类型为`SDL_KEYUP`时，我们的应用程序调用`key_release`函数。这与`key_down`函数非常相似。主要区别在于它是在查看用户是否按下按键，并且仅在状态变为未按下时打印消息。以下示例展示了该函数的全部内容：
- en: '[PRE26]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Our last function is a new version of the `main` function, called when our
    `Module` is loaded. We still need to use `emscripten_set_main_loop` to prevent
    our code from tying up the JavaScript engine. We have created an `input_loop`
    which we defined earlier. It uses SDL to poll for keyboard events. But, before
    that, we still need to do our SDL initialization. We are using the Emscripten
    default shell, so the call to `SDL_CreateWindowAndRenderer` will set the width
    and height of our `canvas` element. We will not be rendering to the `canvas` element
    inside our `input_loop`, but we still want to have it initialized here because,
    in the next section, we will be adapting this code to render a spaceship image
    to the canvas and to move it around with key presses. The following code shows
    what the new version of our `main` function will look like:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一个函数是`main`函数的新版本，在加载我们的`Module`时调用。我们仍然需要使用`emscripten_set_main_loop`来防止我们的代码占用JavaScript引擎。我们创建了一个我们之前定义的`input_loop`。它使用SDL来轮询键盘事件。但是，在此之前，我们仍然需要进行SDL初始化。我们使用Emscripten默认shell，因此调用`SDL_CreateWindowAndRenderer`将设置我们的`canvas`元素的宽度和高度。我们不会在`input_loop`中渲染`canvas`元素，但是我们仍希望在此处进行初始化，因为在下一节中，我们将调整此代码以将太空船图像渲染到画布上，并使用按键移动它。以下代码显示了我们的`main`函数的新版本将是什么样子：
- en: '[PRE27]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now that we have all the code inside our `keyboard.c` file, we can compile
    our `keyboard.c` file with the following `emcc` command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将所有代码放入了`keyboard.c`文件中，我们可以使用以下`emcc`命令编译我们的`keyboard.c`文件：
- en: '[PRE28]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When you run `keyboard.html` in the browser, you will notice that pressing the
    arrow keys results in a message printed to the Emscripten default shell's textarea.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在浏览器中运行`keyboard.html`时，您会注意到按下箭头键会导致消息打印到Emscripten默认shell的文本区域。
- en: 'Consider the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下屏幕截图：
- en: '![](img/41a1b5c7-89b9-4b88-ae20-16283cad1c8e.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41a1b5c7-89b9-4b88-ae20-16283cad1c8e.png)'
- en: 'Figure 5.2: Screenshot of keyboard.html'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：keyboard.html的屏幕截图
- en: In the next section, we will learn how to use this keyboard input to move a
    sprite around our canvas.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将学习如何使用键盘输入来移动精灵在画布上移动。
- en: Using keyboard input to move a sprite
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用键盘输入移动精灵
- en: 'Now that we know how to get keyboard input and use it in our WebAssembly module,
    let''s figure out how we can take that keyboard input and use it to move our spaceship
    sprite around the HTML canvas. Let''s begin by copying `sprite_move.c` from the
    `Chapter04` directory into the `Chapter05` directory. That will give us a good
    starting point. Now we can start modifying the code. We will need to add a single
    `#include` to the beginning of our `.c` file. Because we need Boolean variables,
    we must add `#include <stdbool.h>`. The new start of our `.c` file will now look
    as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何获取键盘输入并在我们的WebAssembly模块中使用它，让我们想想如何将键盘输入用于在HTML画布上移动我们的太空船精灵。让我们从`Chapter04`目录中复制`sprite_move.c`到`Chapter05`目录中。这将给我们一个很好的起点。现在我们可以开始修改代码。我们需要在我们的`.c`文件开头添加一个`#include`。因为我们需要布尔变量，所以我们必须添加`#include
    <stdbool.h>`。现在我们的`.c`文件的新开头将如下所示：
- en: '[PRE29]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After that, all the `#define` directives will remain unchanged from what they
    were in the `sprite_move.c` file, as can be seen in the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，所有的`#define`指令将保持与`sprite_move.c`文件中的内容相同，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `sprite_move.c` file had several global variables that we will continue
    to use in `keyboard_move.c`. Do not remove any of these variables; we will only
    be adding to them:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`sprite_move.c`文件中有几个全局变量，我们将继续在`keyboard_move.c`中使用。不要删除这些变量中的任何一个；我们只会添加到它们中：'
- en: '[PRE31]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now we need to bring in some variables from the `keyboard.c` file that we used
    in the previous section. We need the `SDL_Event` global variable so that we have
    something to pass into our call to `SDL_PollEvent`, and we need our Boolean key
    press flags, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要从`keyboard.c`文件中引入一些变量，这些变量在上一节中使用过。我们需要`SDL_Event`全局变量，以便我们有东西传递给我们对`SDL_PollEvent`的调用，并且我们需要我们的布尔键按下标志，如下所示：
- en: '[PRE32]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We then have the function declarations, which allow us to define the `key_press`
    and `key_release` functions after we have defined our `input_loop` function, as
    shown in the following example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是函数声明，允许我们在定义`input_loop`函数之后定义`key_press`和`key_release`函数，如下例所示：
- en: '[PRE33]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we will bring in the `input_loop` function from our `keyboard.c` file.
    This is the function that we use to call `SDL_PollEvent`, and, based on the event
    type returned, either calls `key_press` or `key_release`. This function remains
    unchanged from the version we had in `keyboard.c`, as can be seen in the following
    example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将从我们的`keyboard.c`文件中引入`input_loop`函数。这是我们用来调用`SDL_PollEvent`的函数，并根据返回的事件类型调用`key_press`或`key_release`。这个函数与我们在`keyboard.c`中的版本保持不变，如下例所示：
- en: '[PRE34]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `key_press` and `key_release` functions follow the `input_loop` function
    and remain unchanged from the `keyboard.c` version. The primary purpose of these
    functions is to set the keypress flags. The `printf` statements are now unnecessary,
    but we will leave them there. This is not a good thing for performance because
    continuing to add lines to our `textarea` with every key press and release will
    eventually slow our game down, but, at this point, I feel it is better to leave
    these statements in for demonstration purposes:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`key_press`和`key_release`函数跟随`input_loop`函数，并且与`keyboard.c`版本保持不变。这些函数的主要目的是设置按键标志。`printf`语句现在是不必要的，但我们将它们留在那里。这对性能来说并不是一件好事，因为继续在我们的`textarea`中添加每次按键按下和释放的行最终会减慢我们的游戏速度，但是，此时，我觉得最好还是为了演示目的将这些语句留在那里：'
- en: '[PRE35]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The next function in the `keyboard_move.c` file will be `show_animation`. This
    function will need to be changed significantly from the version that appears in
    `sprite_move.c`, to allow the player to control the spaceship and move it around
    the canvas. The following example shows you the new function in its entirety before
    we go through it a piece at a time:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`keyboard_move.c`文件中的下一个函数将是`show_animation`。这个函数需要与`sprite_move.c`中的版本有显著的改变，以便玩家可以控制飞船并在画布上移动它。在我们逐步讲解之前，以下示例展示了新函数的全部内容：'
- en: '[PRE36]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We added the very first line in `show_animation` to this new version of the
    function. The call to `input_loop` is used to set the key press flags every frame.
    After the call to `input_loop`, there is a chunk of the code that we have not
    changed from the `sprite_move.c` file, as shown in the following example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`show_animation`中的第一行添加到这个函数的新版本中。调用`input_loop`用于在每帧设置按键按下标志。在调用`input_loop`之后，有一大块代码，我们没有从`sprite_move.c`文件中更改，如下例所示：
- en: '[PRE37]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This code calls `SDL_GetTicks()` to get the current time, and then subtracts
    the current time from the last time the current frame changed, to get the number
    of milliseconds it has been since we last had a frame change. If the number of
    milliseconds since the last frame change is greater than the number of milliseconds
    that we want to stay on any given frame, we need to advance the current frame.
    Once we have figured out whether or not we have advanced the current frame, we
    need to make sure that the current frame is not more than our frame count. If
    it is, we need to reset it to `0`. After that, we need to clear out our renderer
    and set the texture we are using to the texture in our animation array that corresponds
    with the current frame.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码调用`SDL_GetTicks()`来获取当前时间，然后从上一次当前帧更改的时间中减去当前时间，以获取自上次帧更改以来的毫秒数。如果自上次帧更改以来的毫秒数大于我们希望停留在任何给定帧上的毫秒数，我们需要推进当前帧。一旦我们弄清楚了是否推进了当前帧，我们需要确保当前帧不超过我们的帧数。如果超过了，我们需要将其重置为`0`。之后，我们需要清除我们的渲染器，并将我们使用的纹理设置为与当前帧对应的动画数组中的纹理。
- en: 'In `sprite_move.c`, we moved the `y` coordinates of our spaceship up one pixel
    per frame with the following few lines of code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在`sprite_move.c`中，我们使用以下几行代码将飞船的`y`坐标每帧向上移动一个像素：
- en: '[PRE38]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the new keyboard app, we only want to change our `y` coordinate when the
    player presses the up arrow key. To do this, we must enclose the code that changes
    the `y` coordinate in an `if` block that checks the `up_key_press` flag. Here
    is the new version of that code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的键盘应用程序中，我们只希望在玩家按下上箭头键时改变我们的`y`坐标。为此，我们必须将改变`y`坐标的代码放在一个检查`up_key_press`标志的`if`块中。以下是该代码的新版本：
- en: '[PRE39]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We also need to add code that moves the spaceship when the player presses the
    other arrow keys. The following code moves the spaceship down, left or right based
    on what keys the player is currently pressing:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加代码，当玩家按下其他箭头键时移动飞船。根据玩家当前按下的键，以下代码将使飞船向下、向左或向右移动：
- en: '[PRE40]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, we have to render the texture and present it, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须渲染纹理并呈现它，如下所示：
- en: '[PRE41]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `main` function will not change from the version inside `sprite_move.c`
    because none of the initialization has changed. The following code shows the `main`
    function as it appears in `keyboard_move.c`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数不会从`sprite_move.c`中的版本改变，因为初始化没有改变。以下代码显示了`keyboard_move.c`中的`main`函数：'
- en: '[PRE42]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As I said earlier, this code is a combination of the last application we wrote
    in [Chapter 4](f14c80d0-2d87-45b1-96ab-a3305ad35c50.xhtml), *Sprite Animations
    in WebAssembly with SDL*, and the code we wrote in the section *Adding SDL keyboard
    input to WebAssembly* where we were taking input from the keyboard and logging
    our keys with the `printf` statement. We kept our `input_loop` function and added
    a call to it from the beginning of our `show_animation` function. Inside `show_animation`,
    we no longer move the ship one pixel up every frame, but only move the ship up
    if we are pressing the up arrow key. Likewise, we move the ship left when the
    user presses the left arrow key, right when the right arrow key is pressed and
    down when the user presses the down arrow key.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前所说，这段代码是我们在[第4章](f14c80d0-2d87-45b1-96ab-a3305ad35c50.xhtml)中编写的最后一个应用程序的结合，*使用SDL在WebAssembly中进行精灵动画*，以及我们在*将SDL键盘输入添加到WebAssembly*部分编写的代码，我们在那里从键盘接收输入并使用`printf`语句记录我们的按键。我们保留了`input_loop`函数，并在`show_animation`函数的开头添加了对它的调用。在`show_animation`内部，我们不再在每一帧移动飞船一像素，而是只有在按下上箭头键时才移动飞船。同样，当用户按下左箭头键时，我们向左移动飞船，当按下右箭头键时，我们向右移动飞船，当用户按下下箭头键时，我们向下移动飞船。
- en: 'Now that we have our new `keyboard_move.c` file, let''s compile it and try
    out our new moving spaceship. Run the following `emcc` command to compile the
    code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了新的`keyboard_move.c`文件，让我们编译它并尝试一下我们的新移动飞船。运行以下`emcc`命令来编译代码：
- en: '[PRE43]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We need to add the `--preload-file sprites` flag to indicate that we want a
    virtual file system with the sprites folder included. We also need to add the
    `-s USE_SDL=2` and `-s USE_SDL_IMAGE=2 -s SDL2_IMAGE_FORMATS=["png"]` flags to
    allow us to load `.png` files from the virtual file system. Once you have compiled
    `keyboard_move.html`, load it into a browser and use the arrow keys to move the
    spaceship around the canvas. See the following screenshot:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加`--preload-file sprites`标志，以指示我们希望在虚拟文件系统中包含sprites文件夹。我们还需要添加`-s USE_SDL=2`和`-s
    USE_SDL_IMAGE=2 -s SDL2_IMAGE_FORMATS=["png"]`标志，以允许我们从虚拟文件系统加载`.png`文件。一旦你编译了`keyboard_move.html`，将其加载到浏览器中，并使用箭头键在画布上移动飞船。请参阅以下截图：
- en: '![](img/cb33d02f-3e01-4378-a984-a4a408df6e4b.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb33d02f-3e01-4378-a984-a4a408df6e4b.png)'
- en: 'Figure 5.3: Screenshot of keyboard_move.html'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：keyboard_move.html的键盘移动截图
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to get keyboard input for use with WebAssembly.
    There are two primary methods. We could either take in keyboard input on the JavaScript
    side and communicate with WebAssembly through a wrapper made with `Module.cwrap`,
    or by calling WebAssembly functions directly with `Module.ccall`. The other way
    to accept keyboard input in WebAssembly is by using SDL keyboard input events.
    When we use this method, we can use the default Emscripten shell. This second
    method, using SDL events, will be our preferred method throughout the rest of
    this book.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何获取用于WebAssembly的键盘输入。有两种主要方法。我们可以在JavaScript端接收键盘输入，并通过使用`Module.cwrap`制作的包装器与WebAssembly进行通信，或者直接通过`Module.ccall`调用WebAssembly函数。在WebAssembly中接受键盘输入的另一种方法是使用SDL键盘输入事件。当我们使用这种方法时，我们可以使用默认的Emscripten
    shell。使用SDL事件的这种第二种方法将是本书其余部分中我们首选的方法。
- en: In the next chapter, we will learn more about the game loop and how we will
    use it in our game, as well as games in general.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更多地了解游戏循环以及我们将如何在我们的游戏中使用它，以及一般的游戏。
