["```cpp\n#ifndef _H_QUAT_\n#define _H_QUAT_\n#include \"vec3.h\"\n#include \"mat4.h\"\nstruct quat {\n\u00a0\u00a0 union {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 struct {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 float x;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 float y;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 float z;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 float w;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 };\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 struct {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 vec3 vector;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 float scalar;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 };\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 float v[4];\n\u00a0\u00a0 };\n\u00a0\u00a0 inline quat() :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 x(0), y(0), z(0), w(1) { }\n\u00a0\u00a0 inline quat(float _x, float _y, float _z, float _w)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 : x(_x), y(_y), z(_z), w(_w) {}\n};\n#endif\n```", "```cpp\n#include \"quat.h\"\n#include <cmath>\nquat angleAxis(float angle, const vec3& axis) {\n\u00a0\u00a0\u00a0\u00a0vec3 norm = normalized(axis);\n\u00a0\u00a0\u00a0\u00a0float s = sinf(angle * 0.5f);\n\u00a0\u00a0\u00a0\u00a0return quat(norm.x * s,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0norm.y * s,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0norm.z * s,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cosf(angle * 0.5f)\n\u00a0\u00a0\u00a0\u00a0);\n}\n```", "```cpp\n    quat fromTo(const vec3& from, const vec3& to) {\n    \u00a0\u00a0 vec3 f = normalized(from);\n    \u00a0\u00a0 vec3 t = normalized(to);\n    \u00a0\u00a0 if (f == t) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return quat();\n    \u00a0\u00a0 }\n    ```", "```cpp\n    \u00a0\u00a0 else if (f == t * -1.0f) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vec3 ortho = vec3(1, 0, 0);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (fabsf(f.y) <fabsf(f.x)) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 ortho = vec3(0, 1, 0);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (fabsf(f.z)<fabs(f.y) && fabs(f.z)<fabsf(f.x)){\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 ortho = vec3(0, 0, 1);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vec3 axis = normalized(cross(f, ortho));\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return quat(axis.x, axis.y, axis.z, 0);\n    \u00a0\u00a0 }\n    ```", "```cpp\n    \u00a0\u00a0 vec3 half = normalized(f + t); \n    \u00a0\u00a0 vec3 axis = cross(f, half);\n    \u00a0\u00a0 return quat(axis.x, axis.y, axis.z, dot(f, half));\n    }\n    ```", "```cpp\nvec3 getAxis(const quat& quat) {\n\u00a0\u00a0\u00a0\u00a0return normalized(vec3(quat.x, quat.y, quat.z));\n}\nfloat getAngle(const quat& quat) {\n\u00a0\u00a0\u00a0\u00a0return 2.0f * acosf(quat.w);\n}\n```", "```cpp\nquat operator+(const quat& a, const quat& b) {\n\u00a0\u00a0\u00a0\u00a0return quat(a.x+b.x, a.y+b.y, a.z+b.z, a.w+b.w);\n}\nquat operator-(const quat& a, const quat& b) {\n\u00a0\u00a0\u00a0\u00a0return quat(a.x-b.x, a.y-b.y, a.z-b.z, a.w-b.w);\n}\nquat operator*(const quat& a, float b) {\n\u00a0\u00a0\u00a0\u00a0return quat(a.x * b, a.y * b, a.z * b, a.w * b);\n}\nquat operator-(const quat& q) {\n\u00a0\u00a0\u00a0\u00a0return quat(-q.x, -q.y, -q.z, -q.w);\n}\n```", "```cpp\n    bool operator==(const quat& left, const quat& right) {\n    \u00a0\u00a0\u00a0\u00a0return (fabsf(left.x - right.x) <= QUAT_EPSILON &&\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0fabsf(left.y - right.y) <= QUAT_EPSILON &&\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0fabsf(left.z - right.z) <= QUAT_EPSILON &&\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0fabsf(left.w - right.w) <= QUAT_EPSILON);\n    }\n    bool operator!=(const quat& a, const quat& b) {\n    \u00a0\u00a0\u00a0\u00a0return !(a == b);\n    }\n    ```", "```cpp\n    bool sameOrientation(const quat&l, const quat&r) {\n    \u00a0\u00a0\u00a0\u00a0return (fabsf(l.x - r.x) <= QUAT_EPSILON\u00a0\u00a0&&\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0fabsf(l.y - r.y) <= QUAT_EPSILON\u00a0\u00a0&&\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0fabsf(l.z - r.z) <= QUAT_EPSILON\u00a0\u00a0&&\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0fabsf(l.w - r.w) <= QUAT_EPSILON) ||\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 (fabsf(l.x + r.x) <= QUAT_EPSILON\u00a0\u00a0&&\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0fabsf(l.y + r.y) <= QUAT_EPSILON\u00a0\u00a0&&\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0fabsf(l.z + r.z) <= QUAT_EPSILON\u00a0\u00a0&&\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0fabsf(l.w + r.w) <= QUAT_EPSILON);\n    }\n    ```", "```cpp\nfloat dot(const quat& a, const quat& b) {\n\u00a0\u00a0\u00a0\u00a0return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;\n}\n```", "```cpp\n    float lenSq(const quat& q) {\n    \u00a0\u00a0return q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;\n    }\n    ```", "```cpp\n    float len(const quat& q) {\n    \u00a0\u00a0float lenSq = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w;\n    \u00a0\u00a0if (lenSq< QUAT_EPSILON) {\n    \u00a0\u00a0\u00a0\u00a0 return 0.0f;\n    \u00a0\u00a0}\n    \u00a0\u00a0return sqrtf(lenSq);\n    }\n    ```", "```cpp\n    void normalize(quat& q) {\n    \u00a0\u00a0 float lenSq = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w;\n    \u00a0\u00a0 if (lenSq < QUAT_EPSILON) { \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return; \n    \u00a0\u00a0 }\n    \u00a0\u00a0 float i_len = 1.0f / sqrtf(lenSq);\n    \u00a0\u00a0 q.x *= i_len;\n    \u00a0\u00a0 q.y *= i_len;\n    \u00a0\u00a0 q.z *= i_len;\n    \u00a0\u00a0 q.w *= i_len;\n    }\n    ```", "```cpp\n    quat normalized(const quat& q) {\n    \u00a0\u00a0 float lenSq = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w;\n    \u00a0\u00a0 if (lenSq < QUAT_EPSILON) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return quat();\n    \u00a0\u00a0 }\n    \u00a0\u00a0 float il = 1.0f / sqrtf(lenSq); // il: inverse length\n    \u00a0\u00a0 return quat(q.x * il, q.y * il, q.z * il,q.w * il);\n    }\n    ```", "```cpp\n    quat conjugate(const quat& q) {\n    \u00a0\u00a0\u00a0\u00a0return quat(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-q.x,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-q.y,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-q.z,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 q.w\n    \u00a0\u00a0\u00a0\u00a0);\n    }\n    ```", "```cpp\n    quat inverse(const quat& q) {\n    \u00a0\u00a0 float lenSq = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w;\n    \u00a0\u00a0 if (lenSq < QUAT_EPSILON) { \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return quat(); \n    \u00a0\u00a0 }\n    \u00a0\u00a0 float recip = 1.0f / lenSq;\n    \u00a0\u00a0 return quat(-q.x * recip,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 -q.y * recip,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 -q.z * recip,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q.w * recip\n    \u00a0\u00a0 );\n    }\n    ```", "```cpp\nquat operator*(const quat& Q1, const quat& Q2) {\n\u00a0\u00a0 return quat( \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Q2.x*Q1.w + Q2.y*Q1.z - Q2.z*Q1.y + Q2.w*Q1.x,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-Q2.x*Q1.z + Q2.y*Q1.w + Q2.z*Q1.x + Q2.w*Q1.y,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Q2.x*Q1.y - Q2.y*Q1.x + Q2.z*Q1.w + Q2.w*Q1.z,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-Q2.x*Q1.x - Q2.y*Q1.y - Q2.z*Q1.z + Q2.w*Q1.w\n\u00a0\u00a0 );\n}\n```", "```cpp\nquat operator*(const quat& Q1, const quat& Q2) {\n\u00a0\u00a0quat result;\n\u00a0\u00a0result.scalar = Q2.scalar * Q1.scalar -\n\u00a0\u00a0dot(Q2.vector, Q1.vector);\n\u00a0\u00a0result.vector = (Q1.vector * Q2.scalar) +\n\u00a0\u00a0(Q2.vector * Q1.scalar)+cross(Q2.vector, Q1.vector);\n\u00a0\u00a0return result;\n}\n```", "```cpp\nvec3 operator*(const quat& q, const vec3& v) {\n\u00a0\u00a0\u00a0\u00a0return q.vector * 2.0f * dot(q.vector, v) +\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0v * (q.scalar * q.scalar - dot(q.vector, q.vector)) +\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cross(q.vector, v) * 2.0f * q.scalar;\n}\n```", "```cpp\nquat SampleFunction(const quat& a, const quat& b) {\n\u00a0\u00a0\u00a0\u00a0if (dot(a, b) < 0.0f) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0b = -b;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return slerp(a, b, 0.5f);\n}\n```", "```cpp\nquat mix(const quat& from, const quat& to, float t) {\n\u00a0\u00a0\u00a0\u00a0return from * (1.0f - t) + to * t;\n}\n```", "```cpp\nquat nlerp(const quat& from, const quat& to, float t) {\n\u00a0\u00a0\u00a0\u00a0return normalized(from + (to - from) * t);\n}\n```", "```cpp\nquat operator^(const quat& q, float f) {\n\u00a0\u00a0\u00a0\u00a0float angle = 2.0f * acosf(q.scalar);\n\u00a0\u00a0\u00a0\u00a0vec3 axis = normalized(q.vector);\n\u00a0\u00a0\u00a0\u00a0float halfCos = cosf(f * angle * 0.5f);\n\u00a0\u00a0\u00a0\u00a0float halfSin = sinf(f * angle * 0.5f);\n\u00a0\u00a0\u00a0\u00a0return quat(axis.x * halfSin,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0axis.y * halfSin,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0axis.z * halfSin,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0halfCos\n\u00a0\u00a0\u00a0\u00a0);\n}\n```", "```cpp\nquat slerp(const quat& start, const quat& end, float t) {\n\u00a0\u00a0\u00a0\u00a0if (fabsf(dot(start, end)) > 1.0f - QUAT_EPSILON) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return nlerp(start, end, t);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0quat delta = inverse(start) * end;\n\u00a0\u00a0\u00a0\u00a0return normalized((delta ^ t) * start);\n}\n```", "```cpp\nquat lookRotation(const vec3& direction, const vec3& up) {\n\u00a0\u00a0\u00a0\u00a0// Find orthonormal basis vectors\n\u00a0\u00a0\u00a0\u00a0vec3 f = normalized(direction); // Object Forward\n\u00a0\u00a0\u00a0\u00a0vec3 u = normalized(up); // Desired Up\n\u00a0\u00a0\u00a0\u00a0vec3 r = cross(u, f); // Object Right\n\u00a0\u00a0\u00a0\u00a0u = cross(f, r); // Object Up\n\u00a0\u00a0\u00a0\u00a0// From world forward to object forward\n\u00a0\u00a0\u00a0\u00a0quat worldToObject = fromTo(vec3(0, 0, 1), f); \n\u00a0\u00a0\u00a0\u00a0// what direction is the new object up?\n\u00a0\u00a0\u00a0\u00a0vec3 objectUp = worldToObject * vec3(0, 1, 0);\n\u00a0\u00a0\u00a0\u00a0// From object up to desired up\n\u00a0\u00a0\u00a0\u00a0quat u2u = fromTo(objectUp, u);\n\u00a0\u00a0\u00a0\u00a0// Rotate to forward direction first\n\u00a0\u00a0\u00a0\u00a0// then twist to correct up\n\u00a0\u00a0\u00a0\u00a0quat result = worldToObject * u2u; \n\u00a0\u00a0\u00a0\u00a0// Don't forget to normalize the result\n\u00a0\u00a0\u00a0\u00a0return normalized(result);\n}\n```", "```cpp\n    mat4 quatToMat4(const quat& q) {\n    \u00a0\u00a0\u00a0\u00a0vec3 r = q * vec3(1, 0, 0);\n    \u00a0\u00a0\u00a0\u00a0vec3 u = q * vec3(0, 1, 0);\n    \u00a0\u00a0\u00a0\u00a0vec3 f = q * vec3(0, 0, 1);\n    \u00a0\u00a0\u00a0\u00a0return mat4(r.x, r.y, r.z, 0,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u.x, u.y, u.z, 0,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0f.x, f.y, f.z, 0,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0, 0\u00a0\u00a0, 0\u00a0\u00a0, 1\n    \u00a0\u00a0\u00a0\u00a0);\n    }\n    ```", "```cpp\n    quat mat4ToQuat(const mat4& m) {\n    \u00a0\u00a0\u00a0\u00a0vec3 up = normalized(vec3(m.up.x, m.up.y, m.up.z));\n    \u00a0\u00a0\u00a0\u00a0vec3 forward = normalized(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 vec3(m.forward.x, m.forward.y, m.forward.z));\n    \u00a0\u00a0\u00a0\u00a0vec3 right = cross(up, forward);\n    \u00a0\u00a0\u00a0\u00a0up = cross(forward, right);\n    \u00a0\u00a0\u00a0\u00a0return lookRotation(forward, up);\n    }\n    ```"]