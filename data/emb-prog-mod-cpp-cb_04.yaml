- en: Handling Interrupts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理中断
- en: One of the primary tasks of embedded applications is communicating with external
    hardware peripherals. Sending data to peripherals using the output port is easy
    to understand. When it comes to reading, though, things become more complicated.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式应用程序的主要任务之一是与外部硬件外设通信。使用输出端口向外设发送数据很容易理解。但是，当涉及到读取时，情况变得更加复杂。
- en: Embedded developers have to know when data is available to be read. Since the
    peripheral is external to the processor, this can happen at any moment in time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式开发人员必须知道何时可以读取数据。由于外围设备外部于处理器，这可能发生在任何时刻。
- en: 'In this chapter, we will learn about what interrupts are and how to work with
    them. While using an 8-bit microcontroller, 8051, as a target platform, we will
    learn about the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习什么是中断以及如何处理中断。在以8051为目标平台的8位微控制器上，我们将学习以下主题：
- en: How to implement a basic interrupt handling
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现基本中断处理
- en: How to generate a signal on the output pin of the **M****icrocontroller Unit** (**MCU**)
    using interrupts from the timer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用定时器中断从MCU的输出引脚生成信号
- en: How to use interrupts to count events on the external pins of the MCU
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用中断来计算MCU外部引脚上的事件
- en: How to use interrupts to communicate over the serial channel
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用中断在串行通道上进行通信
- en: 'We will learn about these topics by completing the following recipes:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成以下示例，我们将学习这些主题：
- en: Implementing an interrupt service routine
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现中断服务例程
- en: Generating a 5 kHz square signal using 8-bit auto-reload mode
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用8位自动重装模式生成5 kHz方波信号
- en: Using Timer 1 as an event counter to count a 1 Hz pulse
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用定时器1作为事件计数器来计算1 Hz脉冲
- en: Receiving and transmitting data serially
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 串行接收和发送数据
- en: Understanding the core concepts of how to handle interrupts will help you implement
    responsive and power-efficient embedded applications.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何处理中断的核心概念将帮助您实现响应灵敏且节能的嵌入式应用程序。
- en: Before we do this, however, we'll acquire some background knowledge of a few
    concepts.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在此之前，我们将获取一些背景知识。
- en: Data polling
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据轮询
- en: The first approach to waiting for data from an external source is called **polling**.
    An application periodically queries the input port of an external device to check
    if it has new data. It is easy to implement but has significant downsides.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从外部源等待数据的第一种方法称为**轮询**。应用程序周期性地查询外部设备的输入端口，以检查是否有新数据。这种方法易于实现，但有显著的缺点。
- en: First, it wastes processor resources. Most poll calls report that data is not
    available yet and we need keep waiting. Since these calls do not lead to some
    data processing, it is waste of computing resources. Moreover, the polling interval
    should be short enough that it responds to an external event quickly. Developers
    should look for a compromise between the efficient utilization of processor power
    and reaction time.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它浪费处理器资源。大多数轮询调用报告数据尚不可用，我们需要继续等待。由于这些调用不会导致某些数据处理，这是对计算资源的浪费。此外，轮询间隔应该足够短，以便快速响应外部事件。开发人员应该在处理器功率的有效利用和响应时间之间寻求折衷。
- en: Secondly, it makes the logic of the program convoluted. If the program should
    poll for events, for example, every 5 milliseconds, none of its subroutines should
    take longer than 5 milliseconds. As a result, developers artificially split the
    code into smaller chunks and organize complex switching between them to allow
    polling.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，它使程序的逻辑变得复杂。如果程序应该每5毫秒轮询一次事件，例如，那么它的任何子程序都不应该超过5毫秒。结果，开发人员人为地将代码分成更小的块，并组织它们之间的复杂切换，以允许轮询。
- en: Interrupt service routines
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中断服务例程
- en: Interrupts are an alternative to polling. Once an external device has new data,
    it triggers an event in a processor called an **interrupt**. As its name suggests,
    it interrupts the normal workflow of executing instructions. The processor saves
    its current state and starts executing instructions from a different address until
    it encounters the return from an interrupt instruction. Then, it reads the saved
    state to continue executing the instruction stream from the moment it was interrupted.
    This alternative sequence of instructions is called an **Interrupt Service Routine** (**ISR**).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 中断是轮询的一种替代方法。一旦外部设备有新数据，它会在处理器中触发一个称为**中断**的事件。顾名思义，它会中断正常的执行指令流程。处理器保存其当前状态，并开始从不同的地址执行指令，直到遇到从中断返回的指令。然后，它读取保存的状态以继续执行从中断时刻开始的指令流。这种替代的指令序列称为**中断服务例程**（**ISR**）。
- en: 'Each processor defines its own set of instructions and conventions to work
    with interrupts; however, all of them use the same general approach while dealing
    with interrupts:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每个处理器都定义了自己的一组指令和约定来处理中断；然而，在处理中断时，它们都使用相同的一般方法：
- en: Interrupts are identified by numbers, starting with 0\. The numbers are mapped
    to the hardware **interrupt request lines** (**IRQ**) that physically correspond
    to specific processor pins.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中断由数字标识，从0开始。这些数字映射到硬件**中断请求线**（**IRQ**），这些线物理上对应于特定的处理器引脚。
- en: When an IRQ line is activated, the processor uses its number as an offset in
    the interrupt vector array to locate the address of the interrupt service routine.
    The interrupt vector array is stored in memory on a fixed address.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当IRQ线被激活时，处理器使用其编号作为中断向量数组中的偏移量，以定位中断服务例程的地址。中断向量数组存储在内存中的固定地址上。
- en: Developers can define or redefine ISRs by updating the entries in the interrupt
    vector arrays.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员可以通过更新中断向量数组中的条目来定义或重新定义ISR。
- en: A processor can be programmed to enable or disable interrupts, either for specific
    IRQ lines or all interrupts at once. When interrupts are disabled, the processor
    does not invoke the corresponding ISRs, although the status of the IRQ lines can
    be read.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理器可以被编程以启用或禁用中断，无论是针对特定的IRQ线还是一次性禁用所有中断。当中断被禁用时，处理器不会调用相应的ISR，尽管可以读取IRQ线的状态。
- en: IRQ lines can be programmed to trigger interrupts, depending on the signal on
    the physical pin. This can be at the low level of the signal, the high level of
    the signal, or the edge (which is a transition from low to high or high to low).
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IRQ线可以编程触发中断，取决于物理引脚上的信号。这可以是信号的低电平、高电平，或者边沿（即从低到高或从高到低的过渡）。
- en: General considerations for ISRs
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ISR的一般考虑
- en: This approach does not waste processor resources for polling and provides a
    very short reaction time since interrupt processing is performed at the hardware
    level. However, developers should be aware of its specifics to avoid critical
    or hard-to-detect issues in the future.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法不会浪费处理器资源进行轮询，并且由于中断处理是在硬件级别执行的，因此提供了非常短的反应时间。然而，开发人员应该注意其具体情况，以避免未来出现关键或难以检测的问题。
- en: First of all, dealing with multiple interrupts at the same time, or responding
    to the same interrupt while still handling the previous interrupt, is hard to
    implement. That is why ISRs are executed with interrupts disabled. This prevents
    the ISR from being interrupted with another interrupt, but it also means that
    the reaction time for the pending interrupt can be longer. Worse, this can lead
    to data or events being lost if interrupts are not re-enabled quickly.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，同时处理多个中断，或者在处理前一个中断的同时响应相同的中断，是很难实现的。这就是为什么ISR在中断被禁用时执行。这可以防止ISR被另一个中断打断，但也意味着待处理中断的反应时间可能会更长。更糟糕的是，如果中断不及时重新启用，这可能会导致数据或事件丢失。
- en: To avoid such situations, all ISRs are written to be short. They only do a minimal
    amount of work to read or acknowledge data from a device. Complex data analysis
    and processing are performed outside of the ISR.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，所有ISR都被编写为简短的。它们只做最少量的工作，以从设备中读取或确认数据。复杂的数据分析和处理是在ISR之外进行的。
- en: 8051 microcontroller interrupts
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8051微控制器中断
- en: 'The 8051 microcontroller supports six interrupt sources – reset, two hardware
    interrupts, two timer interrupts, and a serial communication interrupt:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 8051微控制器支持六个中断源-复位、两个硬件中断、两个定时器中断和一个串行通信中断：
- en: '| **Interrupt number** | **Description** | **Offset in bytes** |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| **中断号** | **描述** | **字节偏移** |'
- en: '|  | Reset | 0 |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| | 复位 | 0 |'
- en: '| 0 | External interrupt INT0 | 3 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 外部中断INT0 | 3 |'
- en: '| 1 | Timer 0 (TF0) | 11 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 定时器0（TF0） | 11 |'
- en: '| 2 | External interrupt INT1 | 19 |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 外部中断INT1 | 19 |'
- en: '| 3 | Timer 1 (TF1) | 27 |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 定时器1（TF1） | 27 |'
- en: '| 4 | Serial  | 36 |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 串行 | 36 |'
- en: The interrupt vector array is located at address 0; each entry except reset
    is 8 bytes in size. Though a minimal ISR can fit into 8 bytes, normally, the entries
    contain code that redirects execution to the actual ISR located elsewhere.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 中断向量数组位于地址0处；除了复位之外，每个条目的大小为8字节。虽然最小的ISR可以适应8字节，但通常，条目包含将执行重定向到实际ISR的代码，该ISR位于其他地方。
- en: The reset entry is special. It is activated by the reset signal and immediately
    jumps to the address where the main program is located.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 复位入口是特殊的。它由复位信号激活，并立即跳转到主程序所在的地址。
- en: '8051 defines a special register called **Interrupt Enable** (**EA**), which
    is used to enable and disable interrupts. Its 8-bits are allocated in the following
    way:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 8051定义了一个称为**中断使能**（**EA**）的特殊寄存器，用于启用和禁用中断。它的8位分配如下：
- en: '| **Bit ** | **Name** | **Meaning** |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| **位** | **名称** | **含义** |'
- en: '| 0 | EX0 | External Interrupt 0 |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 0 | EX0 | 外部中断0 |'
- en: '| 1 | ET0 | Timer 0 Interrupt |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 1 | ET0 | 定时器0中断 |'
- en: '| 2 | EX1 | External Interrupt 1 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 2 | EX1 | 外部中断1 |'
- en: '| 3 | ET1 | Timer 1 Interrupt |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 3 | ET1 | 定时器1中断 |'
- en: '| 4 | ES | Serial Port Interrupt |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 4 | ES | 串口中断 |'
- en: '| 5 | - | Not used |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 5 | - | 未使用 |'
- en: '| 6 | - | Not used |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 6 | - | 未使用 |'
- en: '| 7 | EA | Global Interrupt Control |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 7 | EA | 全局中断控制 |'
- en: Setting these bits to 1 enables corresponding interrupts, to 0 disables them.
    The EA bit enables or disables all interrupts.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些位设置为1会启用相应的中断，设置为0会禁用它们。EA位启用或禁用所有中断。
- en: Implementing an interrupt service routine
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现中断服务例程
- en: In this recipe, we will learn how to define an interrupt service routine for
    the 8051 microcontroller.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何为8051微控制器定义中断服务例程。
- en: How to do it...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to complete this recipe:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个配方：
- en: Switch to the build system we set up in [Chapter 2](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml), *Setting
    Up the Environment*.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到我们在[第2章](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml)中设置的构建系统，*设置环境*。
- en: 'Make sure that the 8051 emulator is installed:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保安装了8051仿真器：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Launch `mcu8051ide` and create a new project called `Test`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动`mcu8051ide`并创建一个名为`Test`的新项目。
- en: 'Create a new file called `test.c` and put the following code snippet into it.
    This increments an internal `counter` for each timer interrupt:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`test.c`的新文件，并将以下代码片段放入其中。这会为每个定时器中断增加一个内部`counter`：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Select Tools | Compile to build the code. The messages window will display
    the following output:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择工具|编译来构建代码。消息窗口将显示以下输出：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Select the Simulator | Start/Shutdown menu entry to activate a simulator.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择模拟器|启动/关闭菜单项以激活模拟器。
- en: Select Simulator | Animate to run the program in slow mode.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择模拟器|动画以慢速模式运行程序。
- en: Switch to the C variables panel and scroll down until it shows Counter variable.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到C变量面板，并向下滚动，直到显示Counter变量。
- en: 'Observe how it increases over time:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察它随时间的增长：
- en: '![](img/6bfb07eb-bdc2-4be0-a095-90ce3bda6141.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6bfb07eb-bdc2-4be0-a095-90ce3bda6141.png)'
- en: As you can see, the Value field for the `Counter` variable is now 74.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Counter`变量的值字段现在是74。
- en: How it works...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: For our sample applications, we are going to use an emulator for the 8051 microcontroller.
    Several of them are available; however, we will be using MCU8051IDE since it's
    readily available in the Ubuntu repository.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例应用程序，我们将使用8051微控制器的仿真器。有几种可用；但是，我们将使用MCU8051IDE，因为它在Ubuntu存储库中已经准备好了。
- en: 'We install it as a regular Ubuntu package, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其安装为常规的Ubuntu软件包，如下所示：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is a GUI IDE and requires an X Window system to run. If you use Linux or
    Windows as your working environment, consider installing and running it directly
    from [https://sourceforge.net/projects/mcu8051ide/files/](https://sourceforge.net/projects/mcu8051ide/files/).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个GUI IDE，需要X Window系统才能运行。如果您使用Linux或Windows作为工作环境，请考虑直接从[https://sourceforge.net/projects/mcu8051ide/files/](https://sourceforge.net/projects/mcu8051ide/files/)安装和运行它。
- en: The simple program we created defines a global variable called `Counter`, as
    shown here*:*
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的简单程序定义了一个名为`Counter`的全局变量，如下所示*：*
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is defined as `volatile`, indicating that it can be changed externally
    and that a compiler shouldn't try to optimize the code to eliminate it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这被定义为`volatile`，表示它可以在外部更改，并且编译器不应尝试优化代码以消除它。
- en: Next, we define a simple function called `timer0_ISR`*:*
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个名为`timer0_ISR`的简单函数*：*
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It doesn't accept any parameters and doesn't return any values. The only thing
    it does is increment the `Counter` variable. It is declared with an important
    attribute called `__interrupt(1)` to let the compiler know that it is an interrupt
    handler and that it serves the interrupt number 1\. The compiler generates code
    that updates the corresponding entry of the interrupt vector array automatically.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 它不接受任何参数，也不返回任何值。它唯一的作用是增加`Counter`变量。它声明了一个重要的属性，称为`__interrupt(1)`，以让编译器知道它是一个中断处理程序，并且它服务于中断号1。编译器会自动生成代码，自动更新中断向量数组的相应条目。
- en: 'After defining the ISR itself, we configure the parameters of the timer:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义ISR本身之后，我们配置定时器的参数：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we turn on Timer 0, as shown here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们打开定时器0，如下所示：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following command enables interrupts from Timer 0:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令启用定时器0的中断：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following code enables all interrupts:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码启用所有中断：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'At this point, our ISR is being periodically activated by the timer''s interrupt.
    We run an endless loop that does nothing since all the work is done within ISR:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们的ISR被定时器的中断周期性地激活。我们运行一个无限循环，因为所有的工作都是在ISR内完成的：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When we run the preceding code in the simulator, we will see that the actual
    value of the `counter` variable changes over time, indicating that our ISR is
    being activated by the timer.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在模拟器中运行上述代码时，我们会看到`counter`变量的实际值随时间变化，表明我们的ISR被定时器激活。
- en: Generating a 5 kHz square signal using 8-bit auto-reload mode
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用8位自动重装模式生成5 kHz方波信号
- en: In the preceding recipe, we learned how to create a simple ISR that only does
    a counter increment. Let's make the interrupt routine do something more useful.
    In this recipe, we will learn how to program the 8051 microcontroller so that
    it generates a signal with a given frequency.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们学习了如何创建一个简单的ISR，只进行计数器增量。让我们让中断例程做一些更有用的事情。在这个示例中，我们将学习如何编程8051微控制器，以便它生成具有给定频率的信号。
- en: The 8051 microcontroller has two timers – Timer 0 and Timer 1 – both of which
    are configured using two special function registers: **Timer Mode** (**TMOD**)
    and **Timer Control** (**TCON**). The timer's values are stored in the TH0 and
    TL0 timer registers for Timer 0 and the TH1 and TL1 timer registers for Timer
    1.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 8051微控制器有两个定时器 - 定时器0和定时器1 - 都使用两个特殊功能寄存器：**定时器模式**（**TMOD**）和**定时器控制**（**TCON**）进行配置。定时器的值存储在TH0和TL0定时器寄存器中，用于定时器0，以及TH1和TL1定时器寄存器用于定时器1。
- en: 'The TMOD and TCON bits have special meanings. The bits of the TMOD registers
    are defined as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: TMOD和TCON位具有特殊含义。TMOD寄存器的位定义如下：
- en: '| **Bit** | **Timer** | **Name** | **Purpose** |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| **位** | **定时器** | **名称** | **目的** |'
- en: '| 0 | 0 | M0 | Timer mode selector – lower bit. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | M0 | 定时器模式选择器 - 低位。|'
- en: '| 1 | 0 | M1 | Timer mode selector – upper bit. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | M1 | 定时器模式选择器 - 高位。|'
- en: '| 2 | 0 | CT | Counter (1) or Timer (0) mode. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 0 | CT | 计数器（1）或定时器（0）模式。|'
- en: '| 3 | 0 | GATE | Enable Timer 1, but only if the external interrupt of INT0
    is high. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 0 | GATE | 使能定时器1，但仅当INT0的外部中断为高时。|'
- en: '| 4 | 1 | M0 | Timer mode selector – lower bit. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 1 | M0 | 定时器模式选择器 - 低位。|'
- en: '| 5 | 1 | M1 | Timer mode selector – upper bit. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 1 | M1 | 定时器模式选择器 - 高位。|'
- en: '| 6 | 1 | CT | Counter (1) or Timer (0) mode. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 1 | CT | 计数器（1）或定时器（0）模式。|'
- en: '| 7 | 1 | GATE | Enable Timer 1, but only if the external interrupt of INT1
    is high. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 1 | GATE | 使能定时器1，但仅当INT1的外部中断为高时。|'
- en: The lower 4 bits are assigned to Timer 0, while the upper 4 bits are assigned
    to Timer 1.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 低4位分配给定时器0，而高4位分配给定时器1。
- en: 'The M0 and M1 bits allow us to configure the timers in one of four modes:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: M0和M1位允许我们以四种模式之一配置定时器：
- en: '| **Mode** | **M0** | **M1** | **Description** |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| **模式** | **M0** | **M1** | **描述** |'
- en: '| 0 | 0 | 0 | 13-bit mode. TL0 or TL1 registers contain lower 5 bits, TH0 or
    TH1 registers contain upper 8 bits of the corresponding timer value. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 13位模式。TL0或TL1寄存器包含对应定时器值的低5位，TH0或TH1寄存器包含对应定时器值的高8位。|'
- en: '| 1 | 0 | 1 | 16-bit mode. TL0 or TL1 registers contain lower 8-bits, TH0 or
    TH1 registers contain upper 8 bits of the corresponding timer value. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 16位模式。TL0或TL1寄存器包含对应定时器值的低8位，TH0或TH1寄存器包含对应定时器值的高8位。|'
- en: '| 2 | 1 | 0 | 8 bits mode with auto-reload. TL0 or TL1 contains the corresponding
    timer value, while TH0 or TL1 contains the reload value. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1 | 0 | 8位模式自动重装。TL0或TL1包含对应的定时器值，而TH0或TL1包含重装值。|'
- en: '| 3 | 1 | 1 | Special 8 bits mode for Timer 0 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 1 | 1 | 定时器0的特殊8位模式|'
- en: 'The **Timer** **Control** (**TCON**) registers the control''s timer interrupts.
    Its bits are defined as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**定时器控制**（**TCON**）寄存器控制定时器中断。其位定义如下：'
- en: '| **Bit** | **Name** | **Purpose** |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| **位** | **名称** | **目的** |'
- en: '| 0 | IT0 | External interrupt 0 control bit. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 0 | IT0 | 外部中断0控制位。|'
- en: '| 1 | IE0 | External interrupt 0 edge flag. Set to 1 when high-to-low edge
    signal received at INT0. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 1 | IE0 | 外部中断0边沿标志。当INT0接收到高至低边沿信号时设置为1。|'
- en: '| 2 | IT1 | External interrupt 1 control bit. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 2 | IT1 | 外部中断1控制位。|'
- en: '| 3 | IE1 | External interrupt 1 edge flag. Set to 1 when high-to-low edge
    signal received at INT1. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 3 | IE1 | 外部中断1边沿标志。当INT1接收到高至低边沿信号时设置为1。|'
- en: '| 4 | TR0 | Run Control for Timer 0\. Set to 1 to start, 0 to halt the timer.
    |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 4 | TR0 | 定时器0的运行控制。设置为1以启动，设置为0以停止定时器。|'
- en: '| 5 | TF0 | Timer 0 overflow. Set to 1 when the timer reaches its maximal value.
    |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 5 | TF0 | 定时器0溢出。当定时器达到其最大值时设置为1。|'
- en: '| 6 | TR1 | Run Control for Timer 1\. Set to 1 to start, 0 to halt the timer.
    |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 6 | TR1 | 定时器1的运行控制。设置为1以启动，设置为0以停止定时器。|'
- en: '| 7 | TF1 | Timer 1 overflow. Set to 1 when the timer reaches its maximal value.
    |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 7 | TF1 | 定时器1溢出。当定时器达到其最大值时设置为1。|'
- en: We are going to use the specific mode of 8051 timers called auto-reload. In
    this mode, the TL0 (TL1 for Timer 1) register contains the timer value, while
    TH0 (TH1 for Timer 1) contains a reload value. Once TL0 reaches the maximum value
    of 255, it generates the overflow interrupt and is automatically reset to the
    reload value.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用称为自动重载的8051定时器的特定模式。在这种模式下，TL0（定时器1的TL1）寄存器包含计时器值，而TH0（定时器1的TH1）包含重载值。一旦TL0达到255的最大值，它就会生成溢出中断，并自动重置为重载值。
- en: How to do it...
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to complete this recipe:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此操作：
- en: Launch *mce8051ide* and create a new project called `Test`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动*mce8051ide*并创建一个名为`Test`的新项目。
- en: 'Create a new file called `generator.c` and put the following code snippet into
    it. This will generate a 5 kHz signal on the `P0_0` pin of the MCU:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`generator.c`的新文件，并将以下代码片段放入其中。这将在MCU的`P0_0`引脚上生成5 kHz信号：
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Select Tools | Compile to build the code.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择工具|编译以构建代码。
- en: Select the Simulator | Start/Shutdown menu entry to activate a simulator.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择模拟器|启动/关闭菜单项以激活模拟器。
- en: Select Simulator | Animate to run the program in slow mode.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择模拟器|动画以以慢速模式运行程序。
- en: How it works...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The following code defines an ISR for Timer 0:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码定义了定时器0的ISR：
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: On every timer interrupt, we flip the 0 bit of P0's input-output register. This
    will efficiently generate the square wave signal on a P0 output pin.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次定时器中断时，我们翻转P0的输入输出寄存器的0位。这将有效地在P0输出引脚上生成方波信号。
- en: Now, we need to figure out how to program the timer to generate interrupts with
    the given frequency. To generate the 5 kHz signal, we need to flip the bit with
    the 10 kHz frequency since each wave consists of one high and one low phase.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要弄清楚如何编程定时器以生成给定频率的中断。要生成5 kHz信号，我们需要以10 kHz频率翻转位，因为每个波包括一个高相位和一个低相位。
- en: The 8051 MCU uses an external oscillator as a clock source. The timer unit divides
    the external frequency by 12\. For the 11.0592 MHz oscillator, which is commonly
    used as a time source for 8051, the timer is activated every 1/11059200*12 = 1.085
    milliseconds.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 8051 MCU使用外部振荡器作为时钟源。定时器单元将外部频率除以12。对于常用作8051时间源的11.0592 MHz振荡器，定时器每1/11059200*12
    = 1.085毫秒激活一次。
- en: Our timer ISR should be activated with 10 kHz frequency, or every 100 milliseconds,
    or after every 100/1.085 = 92 timer ticks.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的定时器ISR应以10 kHz频率激活，或者每100毫秒激活一次，或者在每100/1.085 = 92个定时器滴答后激活一次。
- en: 'We programmed Timer 0 to run in mode two, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定时器0编程为以第二种模式运行，如下所示：
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this mode, we store the reset value of the timer in the TH0 register. The
    ISR is activated by the timer overflow, which happens after the timer counter
    reaches the maximum value. Mode two is an 8-bit mode, meaning the maximum value
    is 255\. To activate the ISR every 92 ticks, the auto-reload value should be 255-92
    = 163, or `0xa3` in hexadecimal representation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种模式下，我们将定时器的复位值存储在TH0寄存器中。ISR由定时器溢出激活，这发生在定时器计数器达到最大值之后。第二种模式是8位模式，意味着最大值是255。要使ISR每92个时钟周期激活一次，自动重载值应为255-92
    = 163，或者用十六进制表示为`0xa3`。
- en: 'We store the auto-reload value along with the initial timer value in the timer
    registers:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将自动重载值与初始定时器值一起存储在定时器寄存器中：
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Timer 0 is activated, as shown here:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 定时器0被激活，如下所示：
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we enable timer interrupts:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们启用定时器中断：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, all the interrupts are activated:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，所有中断都被激活：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'From now on, our ISR is invoked every 100 microseconds, as shown in the following
    code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们的ISR每100微秒被调用一次，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This flips the `0` bit of the `P0` register, resulting in the 5 kHz square signal
    being produced on the corresponding output pin.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这会翻转`P0`寄存器的`0`位，从而在相应的输出引脚上产生5 kHz方波信号。
- en: Using Timer 1 as an event counter to count a 1 Hz pulse
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用定时器1作为事件计数器来计算1 Hz脉冲
- en: 8051 timers have dual functionality. When they are activated by the clock oscillator,
    they act as timers. However, they can also be activated by the signal pulse on
    the external pins, that is, P3.4 (Timer 0) and P3.5 (Timer 1), acting as counters.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 8051定时器具有双重功能。当它们被时钟振荡器激活时，它们充当定时器。然而，它们也可以被外部引脚上的信号脉冲激活，即P3.4（定时器0）和P3.5（定时器1），充当计数器。
- en: In this recipe, we will learn how to program Timer 1 so that it counts the activations
    of the P3.5 pin of the 8051 processor.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何编程定时器1，以便它计算8051处理器的P3.5引脚的激活次数。
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to complete this recipe:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此操作：
- en: Open mcu8051ide.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开mcu8051ide。
- en: Create a new project called `Counters`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Counters`的新项目。
- en: 'Create a new file called `generator.c` and put the following code snippet into
    it. This increments a counter variable each time a timer interrupt is triggered:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`generator.c`的新文件，并将以下代码片段放入其中。这将在每次定时器中断触发时递增一个计数器变量：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Select Tools | Compile to build the code.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择工具|编译以构建代码。
- en: Open the Virtual HW menu and select the Simple Key... entry. A new window will
    open.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Virtual HW菜单，并选择Simple Key...条目。将打开一个新窗口。
- en: 'In the Simple Keypad window, assign PORT 3 and BIT 5 to the first key. Then,
    click the ON or OFF button to activate it:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Simple Keypad窗口中，将端口3和位5分配给第一个键。然后，单击ON或OFF按钮以激活它：
- en: '![](img/5c45f07b-20cb-4009-93d0-312fa4abe748.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c45f07b-20cb-4009-93d0-312fa4abe748.png)'
- en: Select the Simulator | Start/Shutdown menu entry to activate the simulator.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择模拟器|启动/关闭菜单项以激活模拟器。
- en: Select Simulator | Animate to run the program in the animation mode that displays
    all changes to the special registers in the debugger window.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择模拟器|动画以以动画模式运行程序，该模式在调试器窗口中显示对特殊寄存器的所有更改。
- en: Switch to the Simple Keypad window and click the first key.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到简单键盘窗口并单击第一个键。
- en: How it works...
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In this recipe, we utilize the capability of 8051 timers so that they act as
    counters. We define an interrupt service routine in exactly the same way as we
    do for ordinary timers. Since we use Timer 1 as a counter, we use interrupt line
    number `3`, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们利用8051定时器的能力，使其作为计数器。我们以与普通定时器完全相同的方式定义中断服务例程。由于我们将定时器1用作计数器，我们使用中断线号`3`，如下所示：
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The body of the interrupt routine is simple. We only increment the `counter`
    variable.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 中断例程的主体很简单。我们只递增`counter`变量。
- en: 'Now, let''s ensure the ISR is activated by the external source rather than
    the clock oscillator. To do so, we configure Timer 1 by setting the C/T bit of
    the `TMOD` special function register to one:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们确保ISR是由外部源而不是时钟振荡器激活的。为此，我们通过将`TMOD`特殊功能寄存器的C/T位设置为1来配置定时器1：
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The same line configures Timer 1 to run in Mode 2 – 8-bit mode with auto-reload.
    Since our goal is to make the interrupt routine invoked on every external pin
    activation, we set the auto-reload and initial values to the maximum value of
    `254`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的行配置定时器1以在Mode 2下运行- 8位模式与自动重载。由于我们的目标是使中断例程在每次外部引脚激活时被调用，我们将自动重载和初始值设置为最大值`254`：
- en: '[PRE22]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we enable Timer 1:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们启用定时器1：
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, all the interrupts from Timer 1 are activated, as shown here:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，激活所有来自定时器1的中断，如下所示：
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After that, we can enter the endless loop that does nothing since all the work
    is done in the Interrupt Service Routine:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以进入一个什么也不做的无限循环，因为所有的工作都是在中断服务例程中完成的：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: At this point, we can run the code in the emulator. However, we need to configure
    the external source of events. For this purpose, we utilize one of the virtual
    external hardware components supported by MCU8051IDE – the virtual keypad.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以在模拟器中运行代码。但是，我们需要配置外部事件的来源。为此，我们利用MCU8051IDE支持的虚拟外部硬件组件之一-虚拟键盘。
- en: We configure one of its keys to activate pin P3.5 of 8051\. This pin is used
    as a source for Timer 1 when it is used in counting mode.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们配置其中一个键来激活8051的引脚P3.5。当它在计数模式下使用时，该引脚被用作定时器1的源。
- en: Now, we run the code. Pressing the virtual key activates the counter. Once the
    timer value overflows, our ISR is triggered, incrementing the `counter` variable.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们运行代码。按下虚拟键会激活计数器。一旦计时器值溢出，我们的ISR就会被触发，递增`counter`变量。
- en: There's more...
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this recipe, we used Timer 1 as a counter. The same can be applied to Counter
    0\. In this case, pin P3.4 should be used as an external source.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们使用定时器1作为计数器。同样的方法也可以应用于计数器0。在这种情况下，引脚P3.4应该被用作外部源。
- en: Receiving and transmitting data serially
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 串行接收和发送数据
- en: 8051 microcontrollers come with a built-in **Universal Asynchronous Receiver
    Transmitter** (**UART**) port for serial data exchange.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 8051微控制器配备了内置的**通用异步收发器**（**UART**）端口，用于串行数据交换。
- en: 'The serial port is controlled by a **Special Function Register** (**SFR**)
    called **Serial Control** (**SCON**). Its bits are defined as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 串行端口由名为**串行控制**（**SCON**）的**特殊功能寄存器**（**SFR**）控制。其位定义如下：
- en: '| **Bit** | **Name** | **Purpose** |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| **位** | **名称** | **目的** |'
- en: '| 0 | **RI** (short for **Receive** **Interrupt**) | Set by UART when a byte
    is received completely |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 0 | **RI**（**接收** **中断**的缩写）| 当一个字节完全接收时由UART设置 |'
- en: '| 1 | **TI** (short for **Transmit** **Interrupt**) | Set by UART when a byte
    is transmitted completely |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **TI**（**传输** **中断**的缩写）| 当一个字节完全传输时由UART设置 |'
- en: '| 2 | **RB8** (short for **Receive** **Bit** **8**) | Stores the ninth bit
    of the received data in 9-bit mode. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **RB8**（**接收** **位** **8**的缩写）| 在9位模式下存储接收数据的第九位。|'
- en: '| 3 | **TB8** (short for **Transmit Bit 8**) | Stores the ninth bit of data
    to be transmitted in 9-bit mode (see below) |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **TB8**（**传输位8**的缩写）| 在9位模式下存储要传输的数据的第九位（见下文）|'
- en: '| 4 | **REN** (short for **Receiver Enabled**) | Enables (1) or disables (0)
    the receive operation |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 4 | **REN**（**接收使能**的缩写）| 启用（1）或禁用（0）接收操作 |'
- en: '| 5 | **SM2** (Enable Multiprocessor) | Enables (1) or disables (0) multiprocessor
    communication for 9-bit mode |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 5 | **SM2**（启用多处理器）| 为9位模式启用（1）或禁用（0）多处理器通信 |'
- en: '| 6 | **SM1** (Serial Mode, high bit) | Defines the serial communication mode
    |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 6 | **SM1**（串行模式，高位）| 定义串行通信模式 |'
- en: '| 7 | **SM0** (Serial Mode, low bit) | Defines the serial communication mode
    |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 7 | **SM0**（串行模式，低位）| 定义串行通信模式 |'
- en: '8051 UART supports four m of serial communication modes, all of which are defined
    by the SM1 and SM0 bits:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 8051 UART支持四种串行通信模式，所有这些模式都由SM1和SM0位定义：
- en: '| **Mode** | **SM0** | **SM1** | **Description** |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| **模式** | **SM0** | **SM1** | **描述** |'
- en: '| 0 | 0 | 0 | Shift-register, fixed baud rate |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 移位寄存器，固定波特率 |'
- en: '| 1 | 0 | 1 | 8-bit UART, baud rate set with Timer 1 |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 8位UART，波特率由定时器1设置 |'
- en: '| 2 | 1 | 0 | 9-bit UART, fixed baud rate  |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1 | 0 | 9位UART，固定波特率 |'
- en: '| 3 | 1 | 1 | 9-bit UART, baud rate set with Timer 1 |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 1 | 1 | 9位UART，波特率由定时器1设置 |'
- en: In this recipe, we will learn how to use interrupts to implement a simple data
    exchange over a serial port using the 8-bit UART mode with a programmable baud
    rate (mode 1).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们将学习如何使用中断来实现使用可编程波特率的8位UART模式进行简单数据交换。
- en: How to do it...
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to complete this recipe:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此过程：
- en: Open mcu8051ide and create a new project.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开mcu8051ide并创建一个新项目。
- en: 'Create a new file called `serial.c` and copy the following code snippet into
    it. This code copies the bytes that were received over the serial link to the
    `P0` output register. This is associated with the general-purpose input/output
    pins on the MCU:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`serial.c`的新文件，并将以下代码片段复制到其中。这段代码将接收到的字节复制到`P0`输出寄存器中。这与MCU上的通用输入/输出引脚相关联：
- en: '[PRE26]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Select Tools | Compile to build the code.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择工具 | 编译以构建代码。
- en: Select the Simulator | Start/Shutdown menu entry to activate the simulator.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择模拟器 | 启动/关闭菜单项以激活模拟器。
- en: How it works...
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'We define an ISR for interrupt line `4`, which is triggered for serial port
    events:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为中断线`4`定义了一个ISR，用于串行端口事件触发：
- en: '[PRE27]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The interrupt routine is invoked as soon as a full byte is received and stored
    in the **Serial buffer register** (**SBUF**). Our implementation of ISR just copies
    the received byte to the input/output port, that is, `P0` :'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦接收到一个完整的字节并存储在**串行缓冲寄存器**（**SBUF**）中，中断例程就会被调用。我们的中断服务程序的实现只是将接收到的字节复制到输入/输出端口，即`P0`：
- en: '[PRE28]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Then, it resets the RI flag to enable the interrupt for the upcoming byte.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它重置RI标志以启用即将到来的字节的中断。
- en: 'To make the interrupts work as expected, we configure both the serial port
    and the timer. First, the serial port is configured, as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使中断按预期工作，我们需要配置串行端口和定时器。首先，配置串行端口如下：
- en: '[PRE29]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: According to the preceding table, this means only the SM1 and REN bits of the **Serial
    Control Register** (**SCON**) are set to 1, resulting in the selection of communication
    mode 1\. This is an 8-bit UARS with a baud rate defined via Timer 1\. Then, it
    enables the receiver.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上表，这意味着**串行控制寄存器**（**SCON**）的SM1和REN位仅设置为1，从而选择通信模式1。这是一个由定时器1定义波特率的8位UARS。然后，它启用接收器。
- en: 'Since the baud rate is defined by Timer 1, the next step is to configure the
    timer, as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 由于波特率由定时器1定义，下一步是配置定时器，如下所示：
- en: '[PRE30]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding code configures Timer 1 to use mode 2, which is the 8-bit auto-reload
    mode.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码配置定时器1使用模式2，即8位自动重载模式。
- en: Loading 0xFD into the TH1 register sets the baud rate to 9600 bps. Then, we
    enable Timer 1, serial interrupts, and all interrupts.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 将0xFD加载到TH1寄存器中，将波特率设置为9600 bps。然后，我们启用定时器1、串行中断和所有中断。
- en: There's more...
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Data transmission can be implemented in a similar way. If you write data to
    the SBUF special register, the 8051 UART will start transmission. Once completed,
    a serial interrupt will be invoked and the TI flag will be set to 1.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 数据传输可以以类似的方式实现。如果您向SBUF特殊寄存器写入数据，8051 UART将开始传输。完成后，将调用串行中断并将TI标志设置为1。
