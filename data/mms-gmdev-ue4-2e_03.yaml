- en: Blueprint Review and When to Use BP Scripting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝图审查及何时使用BP脚本
- en: Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'Welcome to our next chapter. This will be our first departure from focusing
    on C++ code, but not the last. Unreal has many systems with great capabilities
    that exist in a form you can access from the editor without writing any code.
    The most flexible and most closely related to actually writing code will be explored
    here, delving into UE4''s blueprint system and its capabilities and limitations.
    Up until now, most of our work has been implementing things in C++ and minimally
    showing how these are interacted with as blueprint objects in the editor. Blueprint
    is capable of much more, including making whole games.  In this chapter we''ll
    cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到我们的下一章。这将是我们第一次从专注于C++代码的焦点中跳出来，但不是最后一次。Unreal拥有许多具有强大功能且无需编写代码即可从编辑器访问的系统。最灵活且与实际编写代码最紧密相关的是在这里探索的，深入探讨UE4的蓝图系统和其功能与局限性。到目前为止，我们的大部分工作都是用C++实现事物，并尽可能展示这些是如何作为编辑器中的蓝图对象进行交互的。蓝图的功能远不止于此，包括制作整个游戏。在本章中，我们将涵盖：
- en: Blueprint review/overview
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝图审查/概述
- en: Blueprint-only games, pros and cons
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅使用蓝图的游戏，优缺点
- en: Scritping an object with blueprint (elevator)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用蓝图编写对象（电梯）
- en: Blueprint tips & tricks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝图技巧与窍门
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Like last time, the work in this chapter will be done by utilizing what was
    finished in [Chapter 2](5cc3645d-8420-4178-9897-2c71100caeac.xhtml), *Inventory
    and Weapons for the Player*. This, however, is not strictly required and the contents
    here should be implementable with the [Chapter 1](dfc11944-e8b6-45b1-8997-5f1a59d0f8ac.xhtml), *Making
    a C++ Project for a First-Person Shooter*, project or even a new UE4 template.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如同上次，本章的工作将通过利用[第2章](5cc3645d-8420-4178-9897-2c71100caeac.xhtml)，*玩家的库存和武器*中完成的内容来完成。然而，这并不是严格必要的，这里的内容应该可以使用[第1章](dfc11944-e8b6-45b1-8997-5f1a59d0f8ac.xhtml)，*为第一人称射击游戏创建C++项目*的项目或甚至是一个新的UE4模板来实现。
- en: 'As usual, the GitHub branch for this chapter is here:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，本章的GitHub分支如下：
- en: '[https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-3](https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-3)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-3](https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-3)'
- en: 'Engine version used: 4.19.0.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的引擎版本：4.19.0。
- en: Blueprint review and Blueprint-only games
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝图审查和仅使用蓝图的游戏
- en: 'It''s fair to ask: just what exactly is "blueprint?" There are really two main
    areas to be concerned with. The first we have already touched on previously and
    used: integrating C++ classes with the UE4 editor. Classes used in the editor
    are typically derived from `UObject` at some level, and this allows for them to
    utilize things such as the `UPROPERTY` and `UFUNCTION` macros that then allow
    these to be accessed by blueprint instances of those classes, such as `StealthCharacter`.
    With a few exceptions of some basic geometry and other essential game objects,
    almost everything placed directly in a level by yourself or designers or artists
    will be an instance of a blueprint class, such as our character in the level now.
    The other area to be aware of that every project should evaluate for its needs
    is the **blueprint visual scripting** (**BVS**) system. Almost all gameplay concepts
    you can think of doing in C++ are possible in blueprint scripting. It also has
    an integrated debugger you can use with breakpoints during runtime. Here, we will
    delve into these concepts a bit more deeply and look at some of the advantages
    and limitations for scripting.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 合理地提出问题：究竟什么是“蓝图”？实际上有两个主要领域需要关注。第一个我们在之前已经涉及并使用过：将C++类与UE4编辑器集成。在编辑器中使用的类通常在某个级别上派生自`UObject`，这使得它们可以利用诸如`UPROPERTY`和`UFUNCTION`宏等特性，从而允许这些类通过蓝图实例访问，例如`StealthCharacter`。除了少数基本几何形状和其他基本游戏对象外，几乎所有直接放置在关卡中的内容，无论是你自己、设计师还是艺术家，都将是一个蓝图类的实例，例如现在关卡中的我们的角色。另一个需要关注的是每个项目都应该根据其需求评估的领域是**蓝图可视化脚本**（**BVS**）系统。几乎所有你能在C++中想到的游戏玩法概念在蓝图脚本中都是可能的。它还集成了你可以在运行时使用断点调试的调试器。在这里，我们将更深入地探讨这些概念，并查看脚本的优势和局限性。
- en: Blueprint overview
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝图概述
- en: 'As we have shown multiple times in our previous chapters, the advantages of
    exposing variables that will be iterated upon or made unique in many instances
    of the same class type is fairly obvious: these variables can be modified while
    running the editor by content creators with no programming knowledge whatsoever.
    System designers in particular depend on having the right variables exposed so
    they can tune and build variants of systems quickly and test them equally quickly.
    Doing this almost entirely from C++ as the FPS template begins means that changing
    those values at best requires compiling and doing a hot-reload of the game while
    in the editor, and at worst, shutting down the editor, building, and restarting
    it. Much like scripting in blueprint, discussed in the next paragraph, much of
    blueprint''s exposure and utilization in your game comes down, once again, to
    your team''s and project''s needs. If the design of a class for your game is almost
    certain to never change or change very minimally over the course of the project,
    and you have plenty of C++ programmers as resources, maybe it makes sense to get
    things done in a very direct way like the FPS template''s character started for
    us. However, if you have designers (system-level or otherwise) who are anxious
    to get started building a variety of game objects and are constantly changing
    them, adding new variations, and testing these quickly in levels, the more blueprint
    flexibility you can give them, the better!  As noted previously, at the most basic
    level, blueprint classes are excellent data containers: even if designers or artists
    are never going to use them, programmers directly benefit from having access to
    view and often modify as much data as possible in classes while staying in the
    editor. The iteration time is instantaneous, and you can always check your values
    without switching context from the editor to Visual Studio or other windows. Of
    course, there are sensitive, critical values that you may not want anyone arbitrarily
    modifying from blueprint, but with `UPROPERTY` flags such as `BlueprintReadOnly`,
    you can easily give people the availability to view what is currently set for
    a property without letting someone accidentally modify it and save a bad value.
    Hopefully the point is made well enough here that other than making sure you keep
    inexperienced people from changing critical data, there is almost no downside
    to exposing any interesting variables of a class that can be viewed in the editor
    as `UPROPERTY` types.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前几章中多次展示的那样，在许多相同类类型的实例中公开将要迭代的变量或使变量独特化的优势相当明显：这些变量可以在编辑器运行时被没有任何编程知识的创作者修改。特别是系统设计师依赖于公开正确的变量，以便他们可以快速调整和构建系统的变体，并同样快速地进行测试。这意味着从C++作为FPS模板开始，几乎完全这样做，改变这些值在最好的情况下需要编译并在编辑器中执行热重载游戏，在最坏的情况下则需要关闭编辑器、构建并重新启动它。这与下一段讨论的蓝图脚本类似，蓝图在游戏中的许多公开和利用最终都取决于你团队和项目的需求。如果你的游戏类的设计几乎肯定在整个项目过程中不会改变或只会发生非常小的变化，并且你有足够的C++程序员作为资源，那么以像FPS模板中为我们启动的角色那样非常直接的方式完成任务可能是有意义的。然而，如果你有设计师（系统级或其他）急于开始构建各种游戏对象，并且不断更改它们，添加新的变体，并在关卡中快速测试这些对象，那么你能给予他们的蓝图灵活性越多，就越好！如前所述，在最基本层面上，蓝图类是优秀的数据容器：即使设计师或艺术家永远不会使用它们，程序员也能直接受益于在编辑器中访问并经常修改尽可能多的数据，同时保持编辑器中的上下文。迭代时间是瞬间的，你总是可以检查你的值，而无需从编辑器切换到Visual
    Studio或其他窗口。当然，有一些敏感的、关键的价值你可能不希望任何人随意从蓝图中进行修改，但使用`UPROPERTY`标志，如`BlueprintReadOnly`，你可以轻松地让人们查看当前设置的属性，同时防止某人意外修改它并保存一个不良的值。希望这里已经充分说明了这一点，即除了确保你让没有经验的人不要更改关键数据之外，公开任何可以在编辑器中以`UPROPERTY`类型查看的有趣变量几乎没有任何缺点。
- en: Now, on to visual scripting. This is so far wholly untouched in our prject,
    but that is about to change with a fully utilized example in the next section
    (*Blueprint scripting and performance*). For those new to using blueprint scripting,
    as it's possible also to make entire games while never using it at all, don't
    worry, there will be lots of screenshots and direct work in it in that section.
    For now, though, we will simply discuss from a high level the capabilities and
    drawbacks of using scripting. First, what are some major things that you can do
    in blueprint scripting?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向视觉脚本。到目前为止，在我们的项目中这部分内容完全未被触及，但在下一节（*蓝图脚本和性能*）中，我们将通过一个充分利用的示例来改变这一状况。对于那些刚开始使用蓝图脚本的人来说，即使完全不使用它，也可以制作整个游戏，所以请不要担心，在那一节中会有很多截图和直接的工作内容。不过，现在，我们只是从高层次上讨论使用脚本的能力和缺点。首先，在蓝图脚本中你能做哪些主要的事情呢？
- en: 'Game logic: Including `for`/`while` loops, using local and class variables
    of most types, and access to huge numbers of functions in existing UE4 classes.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏逻辑：包括`for`/`while`循环、使用大多数类型的局部和类变量，以及访问现有UE4类中的大量函数。
- en: 'Game mechanics: Interaction between objects in the world, collision responses,
    movement, and even pathfinding.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏机制：世界中对象之间的交互、碰撞响应、移动，甚至路径查找。
- en: 'Access shareable Blueprint Function Libraries: These are groups of stateless/static
    utility functions you can write in both C++ or blueprint scripting, and share
    with different teams or projects.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问可共享的蓝图函数库：这些是你可以用C++或蓝图脚本编写的无状态/静态实用函数组，你可以与不同的团队或项目共享。
- en: Easily integrate with UI in the UMG editor, often crucial for UI/UX designers'
    workflow.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以轻松地与UMG编辑器中的UI集成，这对于UI/UX设计师的工作流程通常至关重要。
- en: 'No rebuilding any executable or code, and easy referencing of one object to
    another: as will be discussed in the section immediately following this one, you
    can (and people do) make whole games just using scripting for logic.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需重新构建任何可执行文件或代码，并且可以轻松地将一个对象引用到另一个对象：正如将在紧接着本节之后的章节中讨论的，你可以（并且人们确实这样做）仅使用脚本进行逻辑来制作整个游戏。
- en: 'Sounds great, right!? Well, before you think there''s a very big *but* coming,
    let''s be clear: blueprint scripting *is* quite great, and powerful. Here is a
    quick list of some drawbacks to be aware of, but comparing those to the capabilities
    blueprint scripting gives out of the box to teams who invest in getting familiar
    and comfortable with it, well, the drawbacks are overall very minor:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很棒，对吧！？好吧，在你认为接下来会有一个非常大的*但是*出现之前，让我们先明确一点：蓝图脚本*确实*很棒，而且功能强大。以下是一些需要注意的缺点列表，但与那些投入时间和精力去熟悉和适应它的团队相比，这些缺点总体上非常小：
- en: 'Performance costs can be significant: It''s generally possible to minimize
    these, but profiling them and determining problem areas is harder and requires
    a different skillset than profiling C++ code for issues.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能成本可能相当显著：通常可以最小化这些成本，但分析它们并确定问题区域更困难，并且需要与分析C++代码以解决问题不同的技能集。
- en: 'Loss of access to certain data types: C++ is only dependent on your platform
    compiler settings, but blueprints must be usable and accessible across all platforms
    UE4 supports (32 and 64 bit, mobile, web, and so on).'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法访问某些数据类型：C++只依赖于你的平台编译器设置，但蓝图必须能够在UE4支持的所有平台上（32位和64位、移动、网页等）使用和访问。
- en: 'Debugging can be... buggy: Often, the context of how you got to a breakpoint
    is missing, or certain variables won''t be available when you hover over them.
    It''s great to have the debugger, but when it doesn''t work, you''re on your own.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试可能会...出现错误：通常，你到达断点的上下文信息可能缺失，或者当你悬停在变量上时，某些变量可能不可用。调试器很棒，但当它不起作用时，你就得自己解决了。
- en: 'Anyone can modify or add things to blueprints: *anyone!*This means your team
    needs to have very well-defined roles for who can modify what types of things,
    to prevent someone without expertise introducing bugs that are hard to find.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何人都可以修改或向蓝图添加内容：*任何人*！这意味着你的团队需要对谁可以修改哪些类型的内容有非常明确的角色定义，以防止没有专业知识的人引入难以找到的错误。
- en: 'Switching back and forth between C++ code and blueprint scripting can be distracting:
    Often, to get the whole picture of what''s going on, you need data from both,
    and switching contexts can slow down development.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C++代码和蓝图脚本之间来回切换可能会分散注意力：通常，为了全面了解正在发生的事情，你需要从两者中获取数据，而切换上下文可能会减慢开发速度。
- en: 'First, a brief discussion of a few of these points and how to mitigate them.
    For performance profiling, the editor has a very good tool built into it that
    if you''re not already familiar with, take some time and see what it can do. This
    is the Profiler in the Session Frontend window, which can be accessed from the
    Window toolbar under Development Tools:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，简要讨论一些这些点以及如何减轻它们。对于性能分析，编辑器内置了一个非常好的工具，如果你还不熟悉，花点时间看看它能做什么。这是会话前端窗口中的Profiler，可以通过开发工具下的窗口工具栏访问：
- en: '![](img/b51d360a-c291-4c51-88fc-ee4a44c9cebd.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b51d360a-c291-4c51-88fc-ee4a44c9cebd.png)'
- en: If a team is disciplined about tracking performance from the start, it is usually
    a bit easier to track down what has changed and caused a problem. But again, keep
    in mind, something as simple as changing a value of one variable might be detrimental
    to performance, and if you use compiled blueprints, there may be no way to easily
    search for that change in version tracking history. Two strategies to mitigate
    this are to integrate source control to the editor, and "nativize" blueprints.
    If you have a supported source control package (this book's project is using Git),
    you can enable source control integration by right-clicking any blueprint asset
    in the editor, and at the bottom of the popup is the option to connect to source
    control.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个团队从一开始就注重跟踪性能，那么通常更容易追踪到发生了什么变化并导致了问题。但再次提醒，即使是改变一个变量的值也可能对性能产生不利影响，如果你使用了编译蓝图，可能没有简单的方法在版本跟踪历史中搜索这个变化。两种缓解这种状况的策略是将源代码控制集成到编辑器中，以及“本地化”蓝图。如果你有一个受支持的源代码控制包（这本书的项目使用Git），你可以在编辑器中通过右键单击任何蓝图资产来启用源代码控制集成，在弹出窗口的底部有连接到源代码控制选项。
- en: 'Once it''s set up, you can right-click on any blueprint asset again, such as
    the FirstPersonCharacter, and different. versions of it:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置好，你再次可以右键单击任何蓝图资产，例如FirstPersonCharacter及其不同版本：
- en: '![](img/50c96fb5-a61e-4085-8987-388f6e7f3947.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/50c96fb5-a61e-4085-8987-388f6e7f3947.png)'
- en: Finding data changes can be difficult at times (look closely and you'll see
    where Can Crouch was changed in the preceding screenshot), but when it works right,
    showing script changes as visual graphs side by side can be incredibly helpful
    in tracking down where a new change may have caused a problem.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有时寻找数据变化可能很困难（仔细看看，你会在上一张截图的Can Crouch处看到变化），但当它正确工作时，将脚本变化以视觉图表的形式并排显示，在追踪新变化可能引起的问题的地方非常有帮助。
- en: A tutorial on setting this up for Git can be found in the *Further reading*
    section of this chapter. Nativizing blueprints can be enabled under Project Settings | Packaging
    | Blueprints.  This turns all blueprint classes in the editor into intermediate
    C++ classes, and packages them to your project. You may have a few reasons to
    do this. It's something to experiment with if your project is having trouble understanding
    why some blueprints are not working as expected, but we won't spend further time
    on this option here.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的“进一步阅读”部分可以找到关于为Git设置此功能的教程。在项目设置 | 打包 | 蓝图下可以启用蓝图本地化。这会将编辑器中的所有蓝图类转换为中间C++类，并将它们打包到你的项目中。你可能有一些这样做的原因。如果你的项目在理解为什么某些蓝图没有按预期工作时有困难，这是一个可以实验的选项，但在这里我们不会进一步讨论这个选项。
- en: 'Lastly, regarding the loss of data types, it''s entirely possible with Blueprint
    Function Libraries. You can use native (compiler) types for your platform and
    return results in types that blueprint can then use. For example, if you had some
    UI using the existing UE4 `FDateTime` values and want the difference between them
    in seconds, this is not doable in blueprint directly because the values of those
    date-time `structs` is natively in `int64` format. So you could easily make a
    function such as this, which takes the two dates from blueprint, does the math
    natively (`ToUnixTimestamp` returns an `int64`) and then returns the result as
    an `int32`, which blueprint can then access (and thus the UI can display):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，关于数据类型丢失的问题，使用蓝图函数库是完全可能的。你可以使用平台的本地（编译器）类型，并以蓝图可以使用的数据类型返回结果。例如，如果你有一些使用现有UE4
    `FDateTime`值的UI，并想要它们之间的秒数差，在蓝图直接中这是不可行的，因为这些日期时间`structs`的值是本地`int64`格式。因此，你可以轻松地创建一个这样的函数，它从蓝图接收两个日期，本地进行数学运算（`ToUnixTimestamp`返回`int64`），然后以`int32`返回结果，蓝图可以访问（因此UI可以显示）：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And then the simple C++ implementation:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是简单的C++实现：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So, in the C++, we use a type that isn't allowed to be used directly in a blueprint,
    but this works across all modern C++ compilers. Of course, if the dates are very
    far apart, you could lose some data in this calculation/truncation, but so long
    as it can be assumed that there is no case where dates would be near that level
    of separation, it is an easy solution to an `int64` calculation that can now be
    accessed from anywhere in blueprints.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在C++中，我们使用一种不允许在蓝图直接使用的类型，但这一点在所有现代C++编译器中都适用。当然，如果日期相差非常远，在这个计算/截断过程中可能会丢失一些数据，但只要可以假设没有日期会接近这种分离程度的情况，这便是一个简单的解决方案，用于现在可以从蓝图中的任何位置访问的`int64`计算。
- en: Right before the list of drawbacks mentioned previously, it was stated that
    these issues overall are very minor, but keep in mind that this was in the context
    of the power blueprint gives you. For example, you can set up a multiplayer game
    session, have other players search for and connect to it, and begin playing a
    match together, all from just a few existing blueprint nodes UE4 provides to you.
    This is incredibly powerful and could take a programmer who's unfamiliar with
    that workflow days or even weeks to get correct using `FAsyncTask` tasks and `OnlineSubsystem`
    calls, all triggered from the right events in the `GameMode`, or the like. So
    is this the way to go 100%, and let's forget this whole C++ business for your
    project?  That's what we'll finally discuss next.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前提到的缺点列表之前，提到这些问题总体来说非常小，但请记住，这是在考虑蓝图赋予你的能力的情况下说的。例如，你可以设置一个多人游戏会话，让其他玩家搜索并连接到它，然后开始一起玩游戏，所有这些都可以通过仅使用UE4为你提供的几个现有蓝图节点来完成。这非常强大，对于一个不熟悉该工作流程的程序员来说，可能需要几天甚至几周的时间才能正确使用`FAsyncTask`任务和`OnlineSubsystem`调用，所有这些都是从`GameMode`或类似事件的正确触发中开始的。那么，这是100%正确的做法吗？我们是否应该忘记整个C++业务，只为你的项目使用这种方法？这就是我们接下来要讨论的。
- en: Blueprint-only games – is this right for you?
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅蓝图的游戏——这适合你吗？
- en: We have established that blueprints are required at some level for any game,
    and blueprint scripting is a very powerful tool that can save a ton of time when
    implementing systems or reusable pieces that would otherwise be written with dozens,
    hundreds, or potentially many thousands of lines of C++ code. We have now also
    discussed the risks and drawbacks to using blueprint scripting, but now keep in
    mind that in a project that is blueprint only, you are stuck with these choices.
    As soon as you hit a problem that seemingly can't be solved and have to add as
    much as one new C++ class to your project, well, you might as well have started
    with a basic C++ project from day one in hindsight, and that is a very common
    outcome. Teams that are very experienced with blueprint scripting and its limitations
    when starting a project can navigate these things in their design up-front. If
    you're unsure whether you can do all of what needs to be done for your game's
    design at the start of your project, make it C++ and then you can use as much
    from blueprint and C++ as your team's bandwidth and developers prefer, but converting
    a very large blueprint-only project to C++ will be a great deal more work later
    in a project's workflow.  Adding C++ builds may be very disruptive and distracting
    to a team used to never having to do them if you are farther along in development,
    so again, when in doubt, just start with C++ capabilities in your flow and balance
    your workload between the two systems in whichever way is optimal. A team with
    very little C++ code that changes or is added over time will find their workflow
    then to mostly be the same quick iterations as a blueprint-only project anyway,
    but have all the infrastructure available and workflow established to add C++
    as needed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定，任何游戏在某种程度上都需要蓝图，而蓝图脚本是一种非常强大的工具，在实现系统或可重用的组件时，它可以节省大量时间，否则这些组件可能需要用成百上千行C++代码编写。我们现在也已经讨论了使用蓝图脚本的风险和缺点，但请记住，在一个仅使用蓝图的项目中，你必须接受这些选择。一旦遇到看似无法解决的问题，不得不向项目中添加多达一个新C++类，那么，从后视镜来看，你或许从一开始就应该从基本的C++项目开始，这是一个非常常见的结局。那些非常熟悉蓝图脚本及其局限性并在项目开始时就能在设计阶段就规避这些问题的团队可以提前规划好这些问题。如果你不确定在项目开始时是否能够完成游戏设计所需的所有工作，那么就使用C++，然后你可以根据团队带宽和开发者的偏好，尽可能多地使用蓝图和C++。但是，将一个非常大的仅使用蓝图的项目转换为C++将在项目后期的工作流程中需要更多的工作。如果你在开发过程中更深入，添加C++构建可能会对习惯于从未需要执行这些任务的团队造成很大的干扰和分心，所以，如果你不确定，就只从你的流程中开始使用C++功能，并在两种系统之间以最优的方式平衡你的工作量。一个在一段时间内几乎没有任何C++代码更改或添加的团队会发现，他们的工作流程与仅使用蓝图的项目一样，主要是快速迭代，但同时也拥有所有基础设施和工作流程，以便在需要时添加C++。
- en: 'iOS developers! There is a huge reason for you to consider staying blueprint-only
    for a long time, if not for a whole project, depending on its scope: UE4 can package,
    run, and test on iOS device builds from a Windows PC, *if *they are blueprint
    only. This can be a huge advantage to proving out an iOS concept quickly, or to
    massively reduce build times when iterating quickly on gameplay ideas. You will
    still eventually need at least a Mac that can run a version of Xcode, and an Apple
    Developer License, to ultimately submit to Apple, but blueprint-only is a great
    way to quickly prove what your game can do on an iPhone or iPad.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: iOS开发者！如果你考虑长期（甚至整个项目）仅使用蓝图，有一个很大的原因：UE4可以从Windows PC打包、运行和测试iOS设备构建，前提是它们仅使用蓝图。这可以快速证明iOS概念，或者在快速迭代游戏玩法想法时大幅减少构建时间。你最终仍然需要至少一台可以运行Xcode版本的Mac，以及一个Apple开发者许可证，才能最终提交给苹果，但仅使用蓝图是一个快速证明你的游戏在iPhone或iPad上能做什么的好方法。
- en: 'As a rule of thumb, there are generally two types of teams that will want to
    go blueprint-only:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，通常有两种类型的团队会希望仅使用蓝图：
- en: Those with no one available to handle difficult C++ development, problems, or
    set up the workflow
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有人可以处理困难的C++开发、问题或设置工作流程
- en: Those with a very simple design, or a very experienced set of blueprint-developers
    who know its limits
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于设计非常简单，或者有一组非常经验丰富的蓝图开发者，他们知道其局限性
- en: Often indie-teams fall into a bit of each of these, and again, there is nothing
    wrong with prototyping a game quickly in blueprint only and if you find you must
    switch later, it can be done. For those with some experience on a few different
    teams, though, always weigh the preceding topics and decide wisely before starting,
    if at all possible.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 常常独立游戏团队会陷入这些问题的其中一些，再次强调，快速在蓝图下原型化一个游戏并没有什么错误，如果你发现你以后必须切换，这也是可以做到的。对于那些在几个不同团队中有些经验的人来说，始终要权衡前面提到的话题，并在尽可能的情况下明智地决定开始。
- en: Going *back* to a blueprint-only game after some (even not so significant/major)
    C++ work has been done can be a very difficult to downright-impractical process.
    It's also another good rule of thumb to just accept once you open the C++ box,
    do not have any expectation you will shut it again.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行了一些（甚至不是那么重要/重大的）C++工作之后，再回到仅使用蓝图的游戏可能会非常困难，甚至可以说是完全不切实际的过程。这也是一个很好的经验法则：一旦你打开了C++的盒子，就不要有任何期望你会再次关闭它。
- en: Blueprint scripting and performance
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝图脚本和性能
- en: 'So you may be thinking at this point: we sure have talked a lot about the benefits
    and drawbacks of blueprint scripting and blueprint-only problems, but we still
    haven''t just sat down and *made* any to see how it goes and how we can profile
    its performance. Let''s do so now, and get a real-world game system built that
    we can investigate with: in this case, a game''s classic moving platform.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我相信你一定可以想象到：我们确实谈了很多关于蓝图脚本的好处和坏处，以及仅使用蓝图的问题，但我们还没有坐下来实际制作一些东西来看看它如何运作，以及我们如何可以分析其性能。现在让我们这样做，并构建一个真实的游戏系统，我们可以用它来调查：在这种情况下，是一个游戏中的经典移动平台。
- en: Blueprint scripting example – moving platform and elevator
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝图脚本示例 - 移动平台和电梯
- en: 'As I''m sure you can imagine after all of this talk, this class, and the work
    implementing its gameplay, will be done almost exclusively in the editor (there
    are ways you can always hook C++ to blueprint, which will be discussed near the
    end). So, start off by opening the editor and going in the content browser tab
    to our Content | FirstPersonCPP | Blueprints and right-click, like we have done
    before, to make a new class:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如同你想象的那样，在所有这些讨论之后，这个类以及实现其游戏玩法的工作几乎完全在编辑器中完成（你始终有方法可以将C++连接到蓝图，这将在结尾附近讨论）。所以，首先打开编辑器，进入内容浏览器标签，转到我们的内容
    | FirstPersonCPP | Blueprints，然后右键单击，就像我们之前做的那样，创建一个新的类：
- en: '![](img/b345a7ac-f962-4d3b-9fcc-8511c2313585.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b345a7ac-f962-4d3b-9fcc-8511c2313585.png)'
- en: 'Click Actor as the parent class for the blueprint, and name it MovingPlatform.
    Now, we have a completely bare-bones actor we could place in our world, but it
    doesn''t even have any geometry, of course. Let''s quickly fix this. Panning around
    the level, you''ll see two gray rectangular boxes (not the white boxes, but those
    actually work fine too): click one and then right-click on it and select Browse
    to Asset (*Ctrl* + *B*) (note, you can also find this when editing most assets
    from the menu bar under Asset), and you should be in Content | Geometry | Meshes
    now with 1M_Cube selected. So, now that we know how to find this simple piece
    of geometry, let''s go back to our MovingPlatform and double-click it. You may
    notice, since we made this as a blueprint class from the start, you get the full
    blueprint editor automatically, and not the minimal interface it normally starts
    with for native classes that don''t use scripting, as we often had before. For
    our platform object, we now need to add a component. Note that you could just
    add a simple cube or plane as a static mesh component. It is great that these
    things are available, again, especially for quick prototyping. Just to get used
    to the workflow, however, which is more typical of professional games, we will
    use the static mesh cube we were just looking at. So, type to filter or just scroll
    for Static Mesh in the components drop-down and add one. Now notice in the hierarchy
    how this is added under the default scene component (named DefaultSceneRoot).
    Once we have an actor component in our case, that can *be* the root component
    of our actor object here, the default is really just a placeholder. So, rename
    the mesh component to Platform and drag it on top of the scene component to replace
    it.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 将蓝图作为父类，命名为MovingPlatform。现在，我们有一个可以放置在我们世界中的完全裸骨演员，但当然它没有任何几何形状。让我们快速解决这个问题。在水平面上四处查看，你会看到两个灰色矩形框（不是白色框，但那些也可以正常工作）：点击一个，然后右键点击它并选择浏览资源
    (*Ctrl* + *B*) （注意，你还可以在编辑大多数资源时在菜单栏下的资源中找到这个选项），现在你应该在内容 | 几何 | 网格下，并且1M_Cube被选中。所以，既然我们已经知道了如何找到这个简单的几何形状，让我们回到我们的MovingPlatform并双击它。你可能注意到，因为我们从一开始就将其作为蓝图类创建，你将自动获得完整的蓝图编辑器，而不是通常用于不使用脚本的本地类的那种最小界面，就像我们以前经常做的那样。对于我们的平台对象，我们现在需要添加一个组件。请注意，你只需添加一个简单的立方体或平面作为静态网格组件。这些功能可用真是太好了，再次强调，特别是对于快速原型设计。但是，为了熟悉工作流程，这是更典型的专业游戏的工作流程，我们将使用我们刚才查看的静态网格立方体。所以，在组件下拉菜单中输入以过滤或滚动以找到静态网格，并添加一个。现在注意在层次结构中，这个组件是如何添加到默认场景组件（命名为DefaultSceneRoot）下的。一旦在我们的案例中有一个演员组件，它可以是我们的演员对象的根组件，默认设置实际上只是一个占位符。所以，将网格组件重命名为Platform并将其拖到场景组件的顶部以替换它。
- en: 'Now we''ll do two more quick moves to get this platform looking right, click
    the mesh component and on the right in its properties, under Static Mesh | Static
    Mesh, select 1M_Cube, which we found earlier, and click the unlock icon to the
    right of Transsform | Scale and things should be coming together:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将进行两个快速操作来使这个平台看起来正确，点击网格组件，在其属性中的右侧，在静态网格 | 静态网格下选择1M_Cube，这是我们之前找到的，然后点击变换
    | 缩放右侧的解锁图标，事情应该就会开始整合：
- en: '![](img/51b4acd1-05eb-48ea-8d0b-5cfc5c3e2ea3.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/51b4acd1-05eb-48ea-8d0b-5cfc5c3e2ea3.png)'
- en: We can now drag these into our scene, but of course, it won't do anything other
    than block our player, as the step-height is too high for its collision to handle.
    You will also notice it need to compile and save, good steps any time you are
    making progress on a blueprint, though if its scripting is not ready to successfully
    compile, obviously hold off until it is. You can save and use blueprints with
    broken scripting, but their warning messages can be very distracting and allow
    people to not notice other broken blueprint issues that may be critical.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将这些拖入我们的场景，但当然，除了阻挡我们的玩家之外，它不会做任何事情，因为步高太高，无法处理碰撞。你也会注意到它需要编译和保存，每当你在一个蓝图上取得进展时，这都是一个好的步骤，尽管如果它的脚本还没有准备好成功编译，显然要等到它准备好了。你可以保存并使用带有损坏脚本的蓝图，但它们的警告信息可能会非常分散注意力，并让人们注意不到其他可能至关重要的损坏蓝图问题。
- en: Before we can really use and script this platform, however, we need to add one
    more component. Unreal keeps blocking (hit) and overlap (touch) collisions separate,
    and in this case we need a bit of both. So, click Add Component, and this time
    we simply will add a cube from its list. Notice it should be parented to Platform and
    because of this, its size is the same since the scale from Platform propagates
    to our new cube. Now, raise it up a few centimeters by either dragging in the
    viewport along the Z axis or typing in a value in its transform until you can
    see it is above but is still basically touching our original platform (I found
    a Z value of 50 worked for 5 cm since our Z scale is 0.1). Now, scroll down until
    you see the Collision flyout and make sure Generate Overlap Events is checked.
    Click in the drop-down for preset to OverlapOnlyPawn, and down in the Rendering
    flyout, uncheck Visible as we don't want to see this piece because it is only
    there to detect our character walking on it. In the Platform component's collision
    events, you can leave this as BlockAllDynamic, and note that generating overlap
    events is irrelevant as hit events supersede overlap, so you will receive events
    when projectiles or the player hit the platform, but we would never get the overlap
    events we need with these filters.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们真正使用和脚本化这个平台之前，我们还需要添加一个组件。虚幻引擎将（碰撞）和（接触）碰撞分开处理，在这种情况下，我们需要两者都有一点。因此，点击添加组件，这次我们只需从列表中选择一个立方体。注意它应该成为平台的父级，因此由于平台的比例传播到我们新的立方体，其大小是相同的。现在，通过在视图中沿Z轴拖动或在其变换中输入一个值将其抬起几厘米，直到你可以看到它已经在上方，但仍然基本上接触到我们的原始平台（我发现Z值为50适用于5厘米，因为我们的Z比例是0.1）。现在，向下滚动直到你看到碰撞展开，并确保已选中生成重叠事件。在预设下拉菜单中点击，选择重叠OnlyPawn，在渲染展开中，取消选中可见，因为我们不希望看到这个部件，因为它只是为了检测我们的角色是否在它上面行走。在平台组件的碰撞事件中，你可以将其保留为BlockAllDynamic，并注意生成重叠事件是不相关的，因为碰撞事件优先于重叠，所以当项目或玩家撞击平台时，你会收到事件，但我们永远不会通过这些过滤器收到所需的重叠事件。
- en: '![](img/962489d1-4b3c-4d6f-bdfd-0b232062fce8.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/962489d1-4b3c-4d6f-bdfd-0b232062fce8.png)'
- en: This is how everything should look right before clicking the Visible box at
    the bottom of this screenshot.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是点击此截图底部可见框之前一切应该看起来的样子。
- en: 'And finally, to some blueprint scripting! Click over to the Event Graph tab
    and you''ll see the existing events are grayed out with notes about how to enable
    them. In our case, we want the overlap box. Click and drag from the blue Other
    Actor pin (from here on, we''ll just call this a *pull* from the pin), and you
    will see a list of many things we can add that are context-sorted (so long as
    the checkbox remains checked) to things that take an actor as input, the way that
    pin from the event is supplying it as an output. Filter for `GetClass`, and you
    see it has been added now. For those familiar with blueprint scripting, just check
    out the following screenshot for the progress. Here are the steps (after adding
    `GetClass`) to have that in place:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，进行一些蓝图脚本编写！点击到事件图标签页，你会看到现有的事件被灰色显示，并带有有关如何启用它们的说明。在我们的情况下，我们想要重叠框。点击并从蓝色其他演员引脚（从现在起，我们只称之为从引脚拉出），你会看到一个我们可以添加的许多东西的列表，这些列表是按上下文排序的（只要复选框保持选中状态），并且可以接受演员作为输入，就像事件中的引脚那样作为输出。过滤`GetClass`，你会看到它已经被添加了。对于熟悉蓝图脚本的人来说，只需查看以下截图以了解进度。以下是添加`GetClass`后的步骤：
- en: Pull the return value for Get Class, and find Is Child Of in the list. These
    should now be wired. In the Is Child Of box, in its dropdown, select our MasteringCharacter
    class as the type so only our player gives a true result here.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拉取`Get Class`的返回值，并在列表中找到`Is Child Of`。现在它们应该已经连接。在`Is Child Of`框中，在其下拉菜单中选择我们的`MasteringCharacter`类作为类型，这样只有我们的玩家在这里给出真实的结果。
- en: Pull the red result pin from is child of and filter or find Branch, then wire
    this from the white triangle output pin of the actor begin overlap event, and
    in to the input white pin of the Branch.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从子组件中拉出红色结果引脚，然后过滤或查找分支，然后从演员开始重叠事件的白色三角形输出引脚中连接到分支的输入白色引脚。
- en: Pull the white output (which points right) pin from the branch's True result
    and filter and add a MoveComponentTo block.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从分支的真实结果中拉出白色输出（指向右侧）引脚，并添加一个移动组件到块。
- en: Pull left from the MoveComponentTo block's blue component pin and type to filter
    for GetPlatform (a reference to our root component).
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`MoveComponentTo`块的蓝色组件引脚向左拉，并输入以过滤`GetPlatform`（对我们根组件的引用）。
- en: Pull left from the TargetRelativeLocation yellow pin and type + or otherwise
    filter/scroll for vector + vector in the list.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从目标相对位置黄色图钉向左拉，并输入+或以其他方式在列表中过滤/滚动以找到向量+向量。
- en: Pull from its top left pin and type/filter for GetActorLocation, and you can
    leave the input pin on that node as self (that's what we want).
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从其左上角图钉拉出，并输入/过滤以获取 GetActorLocation，你可以将输入图钉留在该节点上为self（这是我们想要的）。
- en: Set the bottom vector's destination to what you want. In my test case, a Z value
    of 300 puts us up even with these other large gray blocks around the map.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将底部向量的目的地设置为所需的值。在我的测试案例中，Z值为300使我们与地图周围的其他大型灰色方块齐平。
- en: 'The TargetRelativeLocation variable seems a bit poorly named, as what it wants
    for a proper motion is a world location. And lastly, on that MoveToLocation node,
    set the time to whatever you like: 4 seconds as here is a little slow and boring,
    but great for demonstrating that this all works:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: TargetRelativeLocation 变量似乎命名得不太好，因为它想要的适当运动是一个世界位置。最后，在 MoveToLocation 节点上，将时间设置为任何你喜欢的值：这里设置为4秒，因为有点慢且无聊，但非常适合演示这一切都能正常工作：
- en: '![](img/e147bd98-1250-4ba5-ac1b-2233b7c687b6.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e147bd98-1250-4ba5-ac1b-2233b7c687b6.png)'
- en: Don't forget to compile and save.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记编译并保存。
- en: Note that running the game in play-in-editor mode will always try to compile
    any edited blueprints before running (and give errors to the output log if there
    are any), but it will *not* save those assets!  You still have to do this with
    a save-all or Ctrl + S on your blueprints and level editing windows! If you shut
    down your editor directly via Visual Studio, you won't even get prompted to save
    any unsaved levels or assets, so it's usually best when working in editor to close
    via its window 's X button.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在编辑器模式下运行游戏将始终尝试在运行之前编译任何已编辑的蓝图（如果有错误，将在输出日志中给出错误），但它不会保存这些资产！你仍然需要在蓝图和级别编辑窗口中使用“全部保存”或Ctrl
    + S来保存！如果你直接通过Visual Studio关闭你的编辑器，甚至不会提示你保存任何未保存的级别或资产，所以当在编辑器中工作时，通常最好通过其窗口的X按钮关闭。
- en: 'Now all that''s left to show this off is to drag one of our Moving it into
    the world on the floor somewhere, and walk over and step on it. Off you go in
    the air! Note that if you step on it again by hopping off and on, it takes you
    up further. We''ll make this thing a bit better shortly, but right now, this is
    a good checkpoint for the GitHub version of the project. Here you can see where
    it is placed in the book''s project''s map (again, by dragging the MovingPlatform
    blueprint icon into the main level window itself):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在要展示这个功能，只需将我们的移动平台拖到地板上的某个位置，然后走过去踩上它。你就可以飞起来了！注意，如果你再次跳上跳下地踩它，它会带你飞得更高。我们很快会把这个东西做得更好，但现在，这是GitHub版本项目的良好检查点。在这里，你可以看到它在书籍项目地图中的位置（再次，通过将移动平台蓝图图标拖入主级别窗口本身）：
- en: '![](img/2591cbb9-b7a8-46f6-a226-a3a8f469c185.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2591cbb9-b7a8-46f6-a226-a3a8f469c185.png)'
- en: 'There are many, many more options that we could do with something like this
    now. It''s possible to add all kinds of logic, including other components, allowing
    this platform to do pathfinding navigation, or adding a spline to the world that
    in the level blueprint for the platform uses (from the main editor window, click
    Blueprints | Open Editor Blueprint to access individual blueprints that can reference
    each other in the level). There is a massive amount of very valuable work that
    can be done in these areas. For now, we will make the platform head back to its
    start point when the player steps off, and the same when it reaches the top of
    its movement:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以用类似的东西做很多很多其他的事情。可以添加各种逻辑，包括其他组件，使这个平台能够进行路径寻找导航，或者向世界中添加一个平台在级别蓝图中使用（从主编辑窗口，点击蓝图
    | 打开编辑蓝图以访问可以相互引用的级别中的各个蓝图）。在这些领域可以完成大量非常有价值的工作。现在，我们将使平台在玩家离开时返回其起点，同样，当它到达运动的顶部时也是如此：
- en: '![](img/e3ea792d-aecf-4d1e-92b4-1f5c03cb02a5.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3ea792d-aecf-4d1e-92b4-1f5c03cb02a5.png)'
- en: 'Note that this uses a couple of blueprint variables added to the class, too,
    a short reference to which is added in the *Further reading* section. The short
    version is under the My Blueprint tab on the left. There is Add New, and under
    that is Variable. Once you add one, you can change the type and default value.
    Here, we added one we renamed under My Blueprint | Variables as StartPosition,
    and on the right under details, set its type to vector, and also add GoingHome
    as a boolean. You can always then access these types, like C++ exposed variables
    too, in get/set blocks in blueprint scripting windows. Note, though, that unless
    you make a specific accessor (and here is an example that is *not* used, but you
    could implement) these variables cannot be accessed in C++:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这使用了添加到类中的几个蓝图变量，其中简短参考在*进一步阅读*部分中添加。简而言之，在左侧的My Blueprint标签页下。有添加新内容，在其下是变量。一旦添加一个，你就可以更改类型和默认值。在这里，我们在My
    Blueprint | 变量下添加了一个重命名为StartPosition的变量，在右侧的详细信息下，将其类型设置为vector，并添加GoingHome作为布尔值。你总是可以在蓝图脚本窗口中的get/set块中访问这些类型，就像C++公开的变量一样。注意，除非你创建一个特定的访问器（这里有一个示例，它*不是*使用，但你可以实现），否则这些变量不能在C++中访问：
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Making this a blueprint-implementable event that means for a hybrid C++/blueprint
    class you could add this as an event type function in blueprint and then simply
    have it return StartPosition. This way, a variable that is only defined in blueprint
    could be accessed by C++. Similarly, to make native functions in C++ that can
    do work as we have before, be sure to keep in mind BlueprintCallable as a `UFUNCTION` keyword,
    as these can be accessed *by* blueprint any time you are in or using an instance
    of the class that implements it.  Spoiler alert: we will be doing this quite a
    bit in the next chapter, [Chapter 4](eadb37a8-4ecb-4fc9-b391-e65671c99fc0.xhtml), *U.I.
    Necessities: Menus, HUD, and Load/Save*, similar to this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 将其制作为一个蓝图可实现的事件，这意味着对于混合C++/蓝图类，你可以在蓝图中将此作为事件类型函数添加，然后简单地让它返回StartPosition。这样，仅定义在蓝图中的变量就可以被C++访问。同样，为了使C++中的本地函数能够像我们之前那样执行工作，请务必记住将BlueprintCallable作为`UFUNCTION`关键字，因为它们可以在任何你处于或使用实现它的类的实例时被蓝图访问。预告：在下一章中，我们将做很多这样的事情，[第4章](eadb37a8-4ecb-4fc9-b391-e65671c99fc0.xhtml)，*U.I.
    必需品：菜单、HUD和加载/保存*，类似于以下内容：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These functions do work in C++, but can be directly called by blueprint. Note
    also that these calls from C++ to blueprint and vice versa have a fairly significant
    call-stack overhead. On previous hardware this was a major performance issue,
    but to save you time here and now, on most platforms these days, the overhead
    really is minimal. Keep this in mind that if you switch between the two frequently,
    but there is no longer the same level of stress that was caused in UE3's similar
    systems.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数在C++中可以工作，但可以直接由蓝图调用。注意，从C++到蓝图以及相反方向的调用有一个相当大的调用栈开销。在之前的硬件上，这是一个主要性能问题，但为了节省你的时间，在大多数平台上，这些开销现在实际上是非常小的。记住，如果你经常在这两者之间切换，但不再有UE3类似系统中引起的那种同样水平的工作压力。
- en: 'OK, so these asides about how to call back and forth from C++ to blueprint
    notwithstanding, let''s get back to our quick logic to get this elevator in a
    finished state. As you can see, there are several steps, and once again for brevity,
    let''s just add them here in an ordered list:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以关于如何从C++到蓝图以及相反方向调用的这些旁白就到这里，让我们回到我们的快速逻辑，以使这个电梯达到完成状态。正如你所看到的，有几个步骤，为了简洁起见，我们在这里按顺序列出它们：
- en: First, we need our two new variables, so as noted earlier, in the My Blueprint
    tab, click add new twice and pick variable from the list for each.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要两个新变量，所以如前所述，在My Blueprint标签页中，点击两次添加新内容，然后从列表中选择变量。
- en: For the first one, rename it GoingHome, and its type can remain as-is, as a
    boolean.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第一个，将其重命名为GoingHome，其类型可以保持不变，作为一个布尔值。
- en: For the second, also as noted, name it StartPosition and give it the type of
    a vector.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第二个，也如前所述，命名为StartPosition，并给它一个vector的类型。
- en: Now, pull from the event for BeginPlay in the scripting window and filter to
    Set Start Position.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从脚本窗口中的BeginPlay事件中拉取，并过滤到设置起始位置。
- en: Pull left from its vector and pick GetActorLocation like we did earlier, again
    leaving self as the object. Now, when we begin playing, this platform will mark
    its initial location and save it in a blueprint-only variable we just made.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从其矢量向左拉，就像我们之前做的那样，再次将self作为对象。现在，当我们开始播放时，这个平台将标记其初始位置，并将其保存在我们刚刚创建的蓝图变量中。
- en: Now pull from our existing MoveComponentTo node and filter to Set Going Home,
    and check its box to true.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从我们现有的 MoveComponentTo 节点拉取并筛选到 Set Going Home，并勾选它的框为 true。
- en: Pull from that node, and make a new MoveComponentTo node similar to how we did
    before. Use Platform again as the input component, but as the TargetRelativeLocation,
    drag from it and filter to GetStartPosition.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从那个节点拉取，并创建一个新的 MoveComponentTo 节点，类似于我们之前所做的那样。再次使用 Platform 作为输入组件，但作为 TargetRelativeLocation，从它那里拖动并筛选到
    GetStartPosition。
- en: Pull from the new MoveComponentTo node's output and filter to SetGoingHome,
    making sure this time the node is unchecked so it's set to false.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的 MoveComponentTo 节点的输出拉取并筛选到 SetGoingHome，确保这次节点未被勾选，因此设置为 false。
- en: 'We need a new event: right-click anywhere and filter to ActorEndOverlap.'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个新的事件：在任意位置右键点击并筛选到 ActorEndOverlap。
- en: Drag from its output and add another branch. Pull that branch's condition and
    do the same logic we did before, pulling the end-overlap's OtherActor to a `GetClass`
    node, then that return to a ClassIsChildOf MasteringCharacter, or just copy and
    paste those nodes with a multi or shift/control select from the begin-overlap
    and save yourself some trouble.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从它的输出拖动并添加另一个分支。拉取那个分支的条件并执行我们之前所做的相同逻辑，从重叠结束的 OtherActor 拉取到 `GetClass` 节点，然后从那里返回到
    ClassIsChildOf MasteringCharacter，或者只需复制并粘贴这些节点，使用多选或 shift/control 选择从 begin-overlap
    开始，这样就可以节省一些麻烦。
- en: When that branch is true (this means our player's character is no longer on
    the platform), pull from the true, filter to SetGoingHome, and check its box.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当那个分支为真时（这意味着我们的玩家角色不再在平台上），从真分支拉取，筛选到 SetGoingHome，并勾选它的框。
- en: Pull from that to a branch, pull from its condition to and filter to GetGoingHome.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从那里拉取到一个分支，从它的条件拉取并筛选到 GetGoingHome。
- en: Pull from the branch's true and add the same set of logic as before with MoveComponentTo
    (to StartPosition, clearing GoingHome to false after completion).
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从分支的真值拉取，并添加与之前相同的逻辑集，使用 MoveComponentTo（到 StartPosition，在完成后清除 GoingHome 为
    false）。
- en: What you should have now should match both the preceding screenshot and the
    final check-in for GitHub in the `chapter 3` branch. This elevator pad should
    now reliably get you up to the next floor, but also return to its start once it
    arrives there or is abandoned. Ideally there should probably be a timer when reaching
    the top before it auto-returns, and there's no reason most games could not generally
    just rely on the end-overlap path to reset the platform. Again, this is just showing
    a hint of what blueprint can do for you and is a great starting point for further
    experimentation!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该有的内容应该与前面的截图以及 GitHub 上 `chapter 3` 分支的最终提交相匹配。这个电梯垫现在应该能够可靠地将你带到下一层，但到达那里或被遗弃后也会返回到起点。理想情况下，在自动返回之前，到达顶部之前可能应该有一个计时器，而且大多数游戏没有理由不能一般性地仅依赖重叠结束路径来重置平台。再次强调，这只是为了展示蓝图能为你做什么的一个提示，并且是一个很好的进一步实验的起点！
- en: Blueprint tips, tricks, and performance hits
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝图技巧、窍门和性能影响
- en: 'The last real question with blueprints is how to see where your performance
    problems may arise and what can make life easier. As has already been noted, you
    can use the built-in UE4 profiling tools. This is always a good place to start.
    Also listed at the end of this section in additional reading is a Stack Overflow
    discussion of profiling tools. I highly recommend VTune from Intel, and if you
    have a hardware device that''s compatible, the NVIDIA Visual Profiler is also
    an excellent tool. However, note that these items will show you in C++ classes
    what the hot-spots are. When you see K2 classes (or for older types, classes with
    *Kismet* in the name) from C++, you can be assured those are things spending time
    in blueprint doing work, but other things such as pathfinding, physics, or collisions
    may be less obvious. You may then have to work backwards to find what these mean
    in blueprint. A faster but cruder way to test performance with blueprints is simply
    to unhook (make pieces of blueprint not be called) and compare previous profiling
    with current profiling (or even just look at your frames per second!). There may
    be obvious areas of blueprint that are causing you performance pain, and fixing
    them or changing them will mitigate the problem. Keep especially in mind, though,
    like in the example of what''s possible: pathfinding, or modifying the NavMesh,
    is entirely possible from blueprint objects. If our elevator platform modifies
    the NavMesh (this is a fairly simple setting, but beyond the scope of this chapter),
    it can be a significant performance hit as it moves! Know your tools and use what
    works best, but always have an eye on performance. Every game has to run smoothly
    on your target platforms to be a success.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 关于蓝图，最后一个真正的问题是如何看到你的性能问题可能出现在哪里，以及什么可以使生活变得更轻松。正如已经提到的，你可以使用内置的UE4性能分析工具。这是一个很好的开始地方。在本节的末尾，还列出了额外的阅读材料，包括关于性能分析工具的Stack
    Overflow讨论。我强烈推荐Intel的VTune，如果你有一个兼容的硬件设备，NVIDIA Visual Profiler也是一个出色的工具。然而，请注意，这些工具会显示在C++类中哪些是热点。当你从C++中看到K2类（或者对于旧类型，名字中带有*Kismet*的类）时，你可以确信这些是在蓝图中进行工作并花费时间的，但其他事情，如路径查找、物理或碰撞可能不那么明显。你可能需要逆向工作来找到这些在蓝图中的含义。使用蓝图测试性能的一个更快但更粗糙的方法是简单地断开连接（使蓝图的部分不被调用）并比较之前的性能分析结果与当前的性能分析结果（或者甚至只是看看你的每秒帧数！）。可能有一些明显的蓝图区域正在导致你的性能问题，修复它们或更改它们将减轻问题。不过，特别要注意的是，就像在可能性的例子中：路径查找或修改NavMesh完全是可以通过蓝图对象实现的。如果我们电梯平台修改了NavMesh（这是一个相当简单的设置，但超出了本章的范围），那么在移动时可能会对性能产生重大影响！了解你的工具并使用最适合的工具，但始终关注性能。每个游戏都必须在目标平台上流畅运行才能成功。
- en: 'One last rule of thumb for this chapter: if you *can* do it in blueprint, *do* it
    in blueprint first. Prove a mechanic works and is fun there in short order. Get
    players joining and starting multiplayer games together with blueprint nodes and
    not huge amounts of new C++ code. Use what is there, and find when it finally
    hits the limits of your requirements before you write your own C++ versions. Blueprint
    can''t do everything, but it can do a huge amount of things quite well, with very
    minimal effort for those who know it.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一条经验法则：如果你可以用蓝图实现，**首先**用蓝图来实现。快速证明一个机制是可行的并且很有趣。让玩家通过蓝图节点一起加入并开始多人游戏，而不是编写大量的新C++代码。利用现有的资源，在你编写自己的C++版本之前，找到它最终达到你要求极限的时刻。蓝图不能做所有事情，但它可以非常高效地完成大量事情，对于那些了解它的人来说，几乎不需要付出太多努力。
- en: Summary
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we''ve learned to do some blueprint scripting, seen some examples
    thereof, and some of the limitations and performance problems that it brings.
    It''s vastly powerful and easy to learn compared to writing C++ code, but using
    it late in a complex project it can be a big headache. Know your team, know your
    options, and know your limitations: these are the keys to making the right decisions
    when it comes to blueprint and your project. Additionally, this blueprint knowledge
    will be invaluable when doing even basic UI work as we will in the next chapter.
    UMG (the editing interface primarily used by UE4) is heavily ingrained in blueprint
    work, and blueprint has a relatively easy time integrating from the game back
    into that UI. These are, like most things in UE4, not specifically required to
    have to work together, but now that there is a solid foundation and understanding
    of the strengths of blueprint, the benefits reaped in getting UI working quickly
    and to desired specifications will be easy to see!'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了如何进行蓝图脚本编写，看到了一些示例，以及它带来的某些局限性和性能问题。与编写C++代码相比，它非常强大且易于学习，但在复杂项目的后期使用它可能会带来很大的麻烦。了解你的团队，了解你的选择，了解你的局限性：这些是在涉及蓝图和你的项目时做出正确决策的关键。此外，这种蓝图知识在进行甚至基本的UI工作（如下一章所述）时也将非常有价值！UMG（UE4主要使用的编辑界面）在蓝图工作中根深蒂固，蓝图从游戏集成回UI相对容易。这些，就像UE4中的大多数事情一样，并不是必须一起工作才能实现，但现在有了坚实的基础和对蓝图优势的理解，快速实现UI并达到期望规格的好处将很容易看到！
- en: Questions
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What two systems from UE3 did blueprint grow from, giving in the K2_ prefix
    for most of its C++ classes?
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 蓝图是从UE3中的哪两个系统发展而来的，为什么大多数C++类都使用K2_前缀？
- en: What is a huge advantage of having source control integration in the editor?
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中拥有源代码控制集成有什么巨大优势？
- en: Why are `UFUNCTIONS` and `UPROPERTIES` so valuable?
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么`UFUNCTIONS`和`UPROPERTIES`如此有价值？
- en: What is a good estimate of the time it would take to add session joining via
    C++?
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加通过C++进行会话加入的大致需要多长时间？
- en: What are some tools to use to profile the performance of work done in blueprint?
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用哪些工具来分析在蓝图中所做工作的性能？
- en: What are some drawbacks to building gameplay in blueprint and not C++?
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在蓝图而不是C++中构建游戏玩法有哪些缺点？
- en: Why is blueprint at some level absolutely required for any UE4 project?
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在某些层面上，蓝图对于任何UE4项目都是绝对必需的？
- en: What do you also need to do if you let running the PIE game compile your blueprints?
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你让运行PIE游戏编译蓝图，你还需要做些什么？
- en: Further reading
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Git integration in UE4 editor:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: UE4编辑器中的Git集成：
- en: '[https://wiki.unrealengine.com/Git_source_control_(Tutorial)](https://wiki.unrealengine.com/Git_source_control_(Tutorial))'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://wiki.unrealengine.com/Git_source_control_(Tutorial)](https://wiki.unrealengine.com/Git_source_control_(Tutorial))'
- en: 'Quick overview of blueprint online session nodes. Be sure to read the link
    about online subsystems if you''re unfamiliar with them:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝图在线会话节点的快速概述。如果你不熟悉它们，请务必阅读有关在线子系统的链接：
- en: '[https://docs.unrealengine.com/en-us/Engine/Blueprints/UserGuide/OnlineNodes](https://docs.unrealengine.com/en-us/Engine/Blueprints/UserGuide/OnlineNodes)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.unrealengine.com/en-us/Engine/Blueprints/UserGuide/OnlineNodes](https://docs.unrealengine.com/en-us/Engine/Blueprints/UserGuide/OnlineNodes)'
- en: 'Blueprint variables overview:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝图变量概述：
- en: '[https://docs.unrealengine.com/en-us/Engine/Blueprints/UserGuide/Variables](https://docs.unrealengine.com/en-us/Engine/Blueprints/UserGuide/Variables)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.unrealengine.com/en-us/Engine/Blueprints/UserGuide/Variables](https://docs.unrealengine.com/en-us/Engine/Blueprints/UserGuide/Variables)'
- en: 'C++ profiling tools:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: C++性能分析工具：
- en: '[https://stackoverflow.com/questions/67554/whats-the-best-free-c-profiler-for-windows](https://stackoverflow.com/questions/67554/whats-the-best-free-c-profiler-for-windows)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://stackoverflow.com/questions/67554/whats-the-best-free-c-profiler-for-windows](https://stackoverflow.com/questions/67554/whats-the-best-free-c-profiler-for-windows)'
