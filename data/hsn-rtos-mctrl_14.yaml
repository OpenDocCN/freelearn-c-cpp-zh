- en: Drivers and ISRs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 驱动程序和中断服务例程（ISRs）
- en: Interacting with the peripherals of a **microcontroller unit** (**MCU**) is
    extremely important in many applications. In this chapter, we'll discuss several
    different ways of implementing peripheral drivers. Up to this point, we've been
    using blinking LEDs as a means of interacting with our development board. This
    is about to change. As we seek to gain a deeper understanding of peripheral drivers,
    we'll start to focus on different ways of implementing a driver for a common communication
    peripheral—the **u****niversal asynchronous receiver/transmitter** (**UART**).
    As we transfer data from one UART to another, we'll uncover the important role
    that peripheral and **direct memory access** (**DMA**) hardware plays when creating
    efficient driver implementations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 与**微控制器单元**（**MCU**）的外设交互在许多应用中非常重要。在本章中，我们将讨论几种不同的实现外设驱动程序的方法。到目前为止，我们一直使用闪烁的
    LED 作为与我们的开发板交互的手段。这即将改变。随着我们寻求对外设驱动程序有更深入的了解，我们将开始关注实现通用通信外设——**通用异步收发传输器**（**UART**）驱动程序的不同方式。当我们从一个
    UART 向另一个 UART 传输数据时，我们将揭示外设和**直接内存访问**（**DMA**）硬件在创建高效驱动程序实现时的重要作用。
- en: We'll start by exploring a UART peripheral by implementing an extremely simple
    polled receive-only driver inside a task. After taking a look at the performance
    of that driver, we'll take a close look at **interrupt service routines** (**ISRs**)
    and the different ways they can interact with the RTOS kernel. The driver will
    be re-implemented using interrupts. After that, we'll add in support for a DMA-based
    driver. Finally, we'll explore a few different approaches to how the drivers can
    interact with the rest of the system and take a look at a newer FreeRTOS feature—stream
    buffers. Throughout this chapter, we'll keep a close eye on overall system performance
    using SystemView. By the end, you should have a solid understanding of the trade-offs
    to be made when writing drivers that can take advantage of RTOS features to aid
    usability.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过在任务中实现一个极其简单的轮询只接收驱动程序来探索 UART 外设。在查看该驱动程序的性能后，我们将仔细研究**中断服务例程**（**ISRs**）以及它们与
    RTOS 内核交互的不同方式。驱动程序将使用中断重新实现。之后，我们将添加对基于 DMA 的驱动程序的支持。最后，我们将探讨几种不同的方法，了解驱动程序如何与系统其他部分交互，并查看
    FreeRTOS 的新功能——流缓冲区。在本章中，我们将使用 SystemView 密切关注整体系统性能。到本章结束时，你应该对编写可以利用 RTOS 功能来提高可用性的驱动程序时需要做出的权衡有一个稳固的理解。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introducing the UART
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 UART
- en: Creating a polled UART driver
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建轮询 UART 驱动程序
- en: Differentiating between tasks and ISRs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区分任务和中断服务例程
- en: Creating ISR-based drivers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基于中断服务例程的驱动程序
- en: Creating DMA-based drivers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基于 DMA 的驱动程序
- en: FreeRTOS stream buffers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FreeRTOS 流缓冲区
- en: Choosing a driver model
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择驱动程序模型
- en: Using third-party libraries (STM HAL)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用第三方库（STM HAL）
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete the exercises in this chapter, you will require the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章的练习，你需要以下内容：
- en: A Nucleo F767 dev board
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nucleo F767 开发板
- en: Jumper wires—20 to 22 AWG (~0.65 mm) solid core wire
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳线——20 到 22 AWG（约 0.65 毫米）实心线
- en: A Micro-USB cable
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Micro-USB 线缆
- en: STM32CubeIDE and source code (instructions in the *Setting up Our IDE* section
    in [Chapter 5](84a945dc-ff6c-4ec8-8b9c-84842db68a85.xhtml), *Selecting an IDE*)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STM32CubeIDE 和源代码（在[第 5 章](84a945dc-ff6c-4ec8-8b9c-84842db68a85.xhtml)的*设置我们的
    IDE*部分中的说明，*选择 IDE*）
- en: SEGGER J-Link, Ozone, and SystemView (instructions in [Chapter 6](699daa80-06ae-4acc-8b93-a81af2eb774b.xhtml),
    *Debugging Tools for Real-Time Systems*)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SEGGER J-Link、Ozone 和 SystemView（在[第 6 章](699daa80-06ae-4acc-8b93-a81af2eb774b.xhtml)的*实时系统调试工具*部分中的说明）
- en: All source code used in this chapter is available at [https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_10](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_10).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有源代码均可在[https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_10](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_10)找到。
- en: Introducing the UART
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 UART
- en: 'As we briefly covered in [Chapter 4](c52d7cdb-b6cb-41e8-8d75-72494bc9d4d3.xhtml), *Selecting
    the Right MCU*, the acronym **UART** stands for **Universal Asynchronous Receiver/Transmitter**. UART
    hardware takes bytes of data and transmits them over a wire by modulating the
    voltage of a signal line at a predetermined rate:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第 4 章](c52d7cdb-b6cb-41e8-8d75-72494bc9d4d3.xhtml)中简要介绍的，*选择合适的 MCU*，缩写
    **UART** 代表 **通用异步收发器/发送器**。UART 硬件通过在预定速率下调制信号线的电压来传输数据字节：
- en: '![](img/fc5fb57b-0534-4d40-b752-ae02f2483362.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fc5fb57b-0534-4d40-b752-ae02f2483362.png)'
- en: The **asynchronous** nature of a UART means no additional clock line is needed
    to monitor individual bit transitions. Instead, the hardware is set up to transition
    each bit at a specific frequency (baud rate). The UART hardware also adds some
    extra framing to the beginning and end of each packet it transmits. Start and
    stop bits signal the beginning and end of a packet. These bits (along with an
    optional parity bit) are used by the hardware to help guarantee the validity of
    packets (which are typically 8 bits long).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: UART 的 **异步** 特性意味着不需要额外的时钟线来监控单个位转换。相反，硬件被设置为以特定频率（波特率）转换每个位。UART 硬件还在每个传输的数据包的开始和结束处添加一些额外的帧。起始位和停止位表示数据包的开始和结束。这些位（以及可选的奇偶校验位）由硬件用于帮助保证数据包的有效性（通常长度为
    8 位）。
- en: A more general form of UART hardware is the **USART** **universal synchronous/asynchronous
    receiver transmitter** (**USART**). USARTs are capable of transferring data either
    synchronously (with the addition of a clock signal) or asynchronously (without
    a clock signal).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: UART 硬件的更通用形式是 **USART**（通用同步/异步接收发送器）。USARTs 能够以同步（添加时钟信号）或异步（不添加时钟信号）的方式传输数据。
- en: UARTs are often used to communicate between different chips and systems. They
    form the foundation of many different communication solutions, such as RS232,
    RS422, RS485, Modbus, and so on. UARTs can also be used for multi-processor communication
    and to communicate with different chips in the same system—for example, WiFi and
    Bluetooth transceivers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: UARTs 常常用于不同芯片和系统之间的通信。它们构成了许多不同通信解决方案的基础，例如 RS232、RS422、RS485、Modbus 等。UARTs
    也可以用于多处理器通信以及与同一系统中的不同芯片通信——例如，WiFi 和蓝牙收发器。
- en: 'In this chapter, we''ll be developing a few iterations of a UART driver. In
    order to be able to observe system behavior, we''ll be tying two UARTs on the
    Nucleo development board together, as in the following diagram. The two connections
    in the diagram will tie the transmit signal from UART4 to the receive signal of
    USART2\. Likewise, they''ll tie USART2 Tx to UART4 Rx. This will allow bidirectional
    communication between the UARTs. The connections should be made with pre-terminated
    **jumper wires** or 20-22 AWG (~0.65 mm) solid core wires:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开发几个 UART 驱动程序的迭代版本。为了能够观察系统行为，我们将把 Nucleo 开发板上的两个 UART 连接起来，如下面的图所示。图中的两个连接将把
    UART4 的发送信号连接到 USART2 的接收信号。同样，它们将 USART2 的 Tx 连接到 UART4 的 Rx。这将允许 UARTs 之间的双向通信。连接应使用预接线的
    **跳线** 或 20-22 AWG (~0.65 mm) 实心线：
- en: '![](img/1b44a7da-7e56-4f6a-8bd2-ed54043bb1fb.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1b44a7da-7e56-4f6a-8bd2-ed54043bb1fb.png)'
- en: Now that the connections are made, let's take a closer look at what else needs
    to happen before we can consider transferring data between peripherals on this
    chip.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在连接已经完成，让我们更详细地看看在我们可以考虑在这个芯片上的外设之间传输数据之前还需要发生什么。
- en: Setting up the UART
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 UART
- en: 'As we can see from the following simplified block diagram, there are a few
    components involved when setting up a UART for communication. The UART needs to
    be properly configured to transmit at the correct baud rate, parity settings,
    flow control, and stop bits. Other hardware that interacts with the UART will
    also need to be configured properly:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下简化框图所示，设置 UART 进行通信时涉及一些组件。UART 需要正确配置以在正确的波特率、奇偶校验设置、流量控制和停止位下传输。与 UART
    交互的其他硬件也需要正确配置：
- en: '![](img/316246b5-dc2a-4957-abd5-c2795961bf83.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/316246b5-dc2a-4957-abd5-c2795961bf83.png)'
- en: 'Here''s a list of steps that will need to be taken to get UART4 set up. Although
    we''re using UART4 as an example, the same steps will apply to most other peripherals
    that attach to pins of the MCU:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一份需要执行的步骤列表，以设置 UART4。虽然我们以 UART4 为例，但相同的步骤将适用于大多数其他连接到 MCU 引脚的外设：
- en: 'Configure the GPIO lines. Since each GPIO pin on the MCU can be shared with
    many different peripherals, they must be configured to connect to the desired
    peripheral (in this case, the UART). In this example, we''ll cover the steps to
    connect PC10 and PC11 to UART4 signals:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置GPIO线。由于MCU上的每个GPIO引脚都可以与许多不同的外设共享，因此它们必须配置为连接到所需的外设（在这种情况下，是UART）。在这个例子中，我们将介绍将PC10和PC11连接到UART4信号的过程：
- en: 'You can read more about the pinout of the STM32F7xx series MCUs in *Section
    3, Pinouts and Pin Description*, of STM''s STM32F767xx datasheet *DoCID 029041*. Datasheets
    will typically contain information specific to exact models of MCUs, while reference
    manuals will contain general information about an entire family of MCUs. The following
    excerpt is of a table is from the datasheet and shows alternate function pin mappings:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在STM的STM32F767xx数据手册*第3节，引脚配置和引脚描述*中了解更多关于STM32F7xx系列MCU引脚的信息*DoCID 029041*。数据手册通常包含特定MCU型号的信息，而参考手册将包含整个MCU系列的一般信息。以下摘录来自数据表中的一个表格，显示了交替功能引脚映射：
- en: '![](img/cbd883b1-430b-4c99-84bd-5e5203a066a5.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cbd883b1-430b-4c99-84bd-5e5203a066a5.png)'
- en: Reference the desired port and bit. (In this case, we'll be setting up port
    `C` bit `11` to map to the `UART4_Rx` function).
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引用所需的端口和位。（在这种情况下，我们将设置端口`C`位`11`以映射到`UART4_Rx`功能）。
- en: Find the desired alternate function for the pin (`UART4_Rx`).
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到所需的引脚交替功能（`UART4_Rx`）。
- en: Find the alternate function number (`AF8`) to use when configuring the GPIO
    registers.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到配置GPIO寄存器时使用的交替功能号（`AF8`）。
- en: Set up the appropriate GPIO registers to correctly configure the hardware and
    map the desired UART peripheral to the physical pins.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置适当的GPIO寄存器以正确配置硬件并将所需的UART外设映射到物理引脚。
- en: 'An STM-supplied `HAL` function is used here for simplicity. The appropriate
    GPIO registers will by written when `HAL_GPIO_Init` is called.  All we need to
    do is fill in a `GPIO_InitTypeDef` struct and pass a reference to `HAL_GPIO_Init`;
    in the following code, the `10` GPIO pin and the `11` GPIO pin on port `C` are
    both initialized to alternative push/pull functions. They are also mapped to `UART4`
    by setting the alternate function member to `AF8`—as determined in step 4:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，这里使用了STM提供的`HAL`函数。当调用`HAL_GPIO_Init`时，将写入适当的GPIO寄存器。我们只需要填写一个`GPIO_InitTypeDef`结构体，并传递`HAL_GPIO_Init`的引用；在下面的代码中，端口`C`上的`10`GPIO引脚和`11`GPIO引脚都被初始化为交替推挽功能。它们还通过将交替功能成员设置为`AF8`（在第4步中确定）映射到`UART4`：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Enable the necessary peripheral clocks. Since each peripheral clock is turned
    off by default (for power saving), the UART''s peripheral clock must be turned
    on by writing to the **reset and clock control** (**RCC**) register. The following
    line is also from `HAL`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用必要的外设时钟。由于每个外设时钟默认关闭（为了节能），必须通过写入**复位和时钟控制**（**RCC**）寄存器来打开UART的外设时钟。以下行也来自`HAL`：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Configure the interrupts (if using them) by configuring settings in the **nested
    vector interrupt controller** (**NVIC**)—details will be included in the examples
    where appropriate.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过配置**嵌套向量中断控制器**（**NVIC**）中的设置（如果使用它们）来配置中断——适当的情况下，将在示例中包含详细信息。
- en: Configure the DMA (if using it)—details will be included in the examples where
    appropriate.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置DMA（如果使用它）——适当的情况下，将在示例中包含详细信息。
- en: Configure the peripheral with the necessary settings, such as baud rate, parity,
    flow control, and so on.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置外设所需的设置，例如波特率、奇偶校验、流量控制等。
- en: 'The following code is an excerpt from the `STM_UartInit` function in `BSP/UartQuickDirtyInit.c.`,
    where **`Baudrate`**and **`STM_UART_PERIPH`** are input parameters of `STM_UartInit`,
    which makes it very easy to configure multiple UART peripherals with similar settings,
    without repeating all of the following code every time:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是从`BSP/UartQuickDirtyInit.c`中的`STM_UartInit`函数的摘录，其中**`Baudrate`**和**`STM_UART_PERIPH`**是`STM_UartInit`的输入参数，这使得配置具有类似设置的多个UART外设变得非常容易，无需每次都重复以下代码：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Depending on the desired transmit method (such as polled, interrupt-driven,
    or DMA), some additional setting up will be required; this setting up is typically
    performed immediately before beginning a transfer.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据所需的传输方法（例如轮询、中断驱动或DMA），可能需要一些额外的设置；这种设置通常在开始传输之前立即执行。
- en: Let's see how all of this plays out by creating a simple driver to read data
    coming into USART2.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个简单的驱动程序来读取进入USART2的数据，看看这一切是如何发挥作用的。
- en: Creating a polled UART driver
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建轮询UART驱动程序
- en: When writing low-level drivers, it's a must to read through the datasheet in
    order to understand how the peripheral works. Even if you're not writing a low-level
    driver from scratch, it is always a good idea to gain some familiarity with the
    hardware you'll be working with. The more familiarity you have, the easier it
    will be to diagnose unexpected behavior, as well as to create efficient solutions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写低级驱动程序时，必须阅读数据手册以了解外设的工作方式。即使你不是从头开始编写低级驱动程序，了解你将要工作的硬件也是一个好主意。你对硬件的了解越多，诊断意外行为以及创建高效解决方案就越容易。
- en: You can read more about the UART peripheral we're working with in *Chapter 34*
    of the*STM **RM0410 STM32F76xxx* reference manual (*USART*).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*STM32F76xxx*参考手册（*USART*）的第34章中了解更多关于我们正在工作的UART外设的信息。
- en: Our first **driver** will take an extremely simple approach to getting data
    from the UART and into a queue that can be easily monitored and consumed by any
    task in the system. By monitoring the **receive not empty** ( `RXNE`) bit of the
    UART peripheral's **interrupt status register** (`ISR`), the driver can determine
    when a new byte is ready to be transferred from the **receive data register**
    (`RDR`) of the UART into the queue. To make this as easy as possible, the `while`
    loop is placed in a task (`polledUartReceive`), which will let other higher-priority
    tasks run.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个**驱动程序**将采取极其简单的方法从UART获取数据并将其放入一个可以轻松监控和由系统中的任何任务消费的队列中。通过监控UART外设的**接收未空**（`RXNE`）位和**中断状态寄存器**（`ISR`），驱动程序可以确定何时一个新字节准备好从UART的**接收数据寄存器**（`RDR`）传输到队列中。为了使这个过程尽可能简单，`while`循环被放置在一个任务（`polledUartReceive`）中，这将允许其他更高优先级的任务运行。
- en: 'The following is an excerpt from `Chapter_10/Src/mainUartPolled.c`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从`Chapter_10/Src/mainUartPolled.c`摘录的内容：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There is another simple task in this example as well; it monitors the queue
    and prints out whatever has been received:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中还有一个简单的任务；它监控队列并打印出接收到的任何内容：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that our driver is ready, let's see how it performs.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了驱动程序，让我们看看它的性能如何。
- en: Analyzing the performance
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析性能
- en: 'The preceding code (`uartPolled`)can be programmed onto the MCU and we can
    take a look at the performance using SEGGER SystemView:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码（`uartPolled`）可以编程到MCU中，我们可以使用SEGGER SystemView查看性能：
- en: '![](img/8f262810-3376-400f-9f34-745d331f11ca.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f262810-3376-400f-9f34-745d331f11ca.png)'
- en: 'After looking at the execution using SystemView, we quickly realize that—although
    easy to program—this driver is *horrifically inefficient*:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用SystemView查看执行后，我们很快意识到——尽管易于编程，但这个驱动程序的效率极其低下：
- en: SystemView reports that this driver is utilizing *over 96%* of the CPU's resources.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SystemView报告称，此驱动程序正在使用超过96%的CPU资源。
- en: The queue is being called at 960 Hz (which makes perfect sense given the initial
    baud rate of 9,600 baud).
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 队列在960 Hz的频率下被调用（考虑到初始波特率为9,600波特，这是完全合理的）。
- en: We can see that, while easy to implement, this solution comes with significant
    performance penalties—all while servicing a fairly slow peripheral. Drivers that
    service peripherals by polling have trade-offs.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，虽然易于实现，但这个解决方案带来了显著的性能损失——而这一切都是在服务一个相当慢的外设。通过轮询服务外设的驱动程序有权衡之处。
- en: Pros and cons of a polled driver
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮询驱动程序的优缺点
- en: 'Here are some of the advantages of using a polled driver:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用轮询驱动程序的一些优点如下：
- en: It is easy to program.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它很容易编程。
- en: Any task has immediate access to data in the queue.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何任务都可以立即访问队列中的数据。
- en: 'At the same time, there are many issues with this approach:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，这种方法也存在许多问题：
- en: It must be one of the highest priority tasks in the system.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须是系统中优先级最高的任务之一。
- en: There is a high chance of data loss when not executing at high priority.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不在高优先级下执行，数据丢失的可能性很高。
- en: It is extremely wasteful of CPU cycles.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这对CPU周期来说极其浪费。
- en: In this example, we're only transferring data at 9,600 baud. Granted, most of
    the time was spent spinning on the `RXNE` bit, but transferring every byte as
    it is received in a queue is also fairly expensive (when compared to pushing bytes
    into a simple array-based buffer). To put this into perspective, USART2 on STM32F767
    running at 216 MHz has a maximum baud rate of 27 Mbaud, which would mean we would
    need to add each character to the shared queue nearly 3 million times a second
    (it is currently adding < 1,000 characters per second). Transferring this much
    data through a queue quickly isn't feasible on this hardware since queue additions
    take 7 µS each (even if the CPU was doing nothing else, we'd be capable of transferring
    less than 143,000 characters per second into the queue).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只以9,600波特率传输数据。诚然，大部分时间都花在了`RXNE`位上，但将每个字节作为接收到的队列中的数据传输也是相当昂贵的（与将字节推入简单的基于数组的缓冲区相比）。为了更直观地说明这一点，STM32F767上的USART2在216
    MHz的频率下运行，其最大波特率为27 Mbaud，这意味着我们几乎需要每秒将每个字符添加到共享队列中近300万次（目前每秒添加不到1,000个字符）。由于队列添加需要7
    µS（即使CPU不做其他任何事情，我们每秒也最多能将143,000个字符传输到队列中），因此在这种硬件上通过队列快速传输这么多数据是不可行的。
- en: More importantly, there are few opportunities to speed up this polled approach,
    since we may receive a new character once every millisecond. If any other task
    was executing for more than 2 ms, the peripheral could potentially be overrun
    (a new byte is received and overwrites the buffer before the previous byte is
    read). Because of these limitations, there are very specific circumstances where
    polled drivers are most useful.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，由于我们可能每毫秒只接收一个新字符，因此几乎没有机会加快这种轮询方法。如果任何其他任务执行时间超过2 ms，外围设备可能会被溢出（新字节在读取前被接收并覆盖缓冲区）。由于这些限制，轮询驱动程序在非常特定的环境中最有用。
- en: Usage of polled drivers
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮询驱动程序的使用
- en: 'There are a few circumstances where polled drivers are especially helpful:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，轮询驱动程序特别有用：
- en: '**System verification**: This is perfectly acceptable when performing initial
    system verification, but at that stage of development, it is debatable whether
    an RTOS should be used at all. If the application happens to be truly single purpose,
    there is nothing else to be done while waiting for data to be transferred, and
    there are no power considerations, this would also be an acceptable approach.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统验证**：在进行初始系统验证时，这是完全可以接受的，但在那个开发阶段，是否应该使用实时操作系统（RTOS）还有待商榷。如果应用程序确实是单一用途的，在等待数据传输的过程中没有其他事情可做，并且没有考虑电源问题，这也是一种可接受的方法。'
- en: '**Special cases**: Occasionally, there may be times when a very special-purpose
    piece of code is needed for a limited scope. For example, a peripheral may need
    to be serviced with an extremely low amount of latency. In other cases, the event
    being polled for could happen extremely quickly. When events are happening in
    the order of nanoseconds or microseconds ns or µs (instead of ms, as in the previous
    example), it often makes more sense to simply poll for the event, rather than
    create a more elaborate synchronization scheme. In event-driven systems, adding
    in blocking calls must be carefully considered and clearly documented.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特殊情况**：偶尔，可能需要为有限的范围编写非常特殊用途的代码。例如，外围设备可能需要以极低的延迟进行服务。在其他情况下，轮询的事件可能发生得非常快。当事件以纳秒或微秒（ns或µs）的顺序发生（而不是像上一个例子中的毫秒ms），简单地轮询事件通常比创建更复杂的同步方案更有意义。在事件驱动系统中，添加阻塞调用必须仔细考虑并明确记录。'
- en: Conversely, if a given event is happening very infrequently and there are no
    specific timing constraints, a polled approach may also be perfectly acceptable.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果某个事件发生得非常频繁，并且没有特定的时序限制，轮询方法也可能完全可行。
- en: 'While the driver in this example focused on the receiving side, where poll-based
    drivers are rarely acceptable, it is more common to find them used to transmit
    data. This is because space between the characters is generally acceptable since
    it doesn''t result in loss the of data. This allows the driver to be run at a
    lower priority so that other tasks in the system have a chance to run. There are
    a few cases where there is a reasonable argument for using a polled transmit driver
    that blocks while the transmission is taking place:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个示例中的驱动程序专注于接收端，在基于轮询的驱动程序很少被接受的情况下，但它们更常用于传输数据。这是因为字符之间的空间通常是可接受的，因为它不会导致数据丢失。这允许驱动程序以较低的优先级运行，以便系统中的其他任务有机会运行。在某些情况下，使用轮询传输驱动程序是有合理理由的，该驱动程序在传输过程中会阻塞：
- en: The code using the driver must block until the transmission is complete.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用驱动程序的代码必须在传输完成之前阻塞。
- en: The transfer is a short amount of data.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传输是一小部分数据。
- en: The data rate is reasonably high (so the transfer takes a relatively small amount
    of time).
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据速率相当高（因此传输所需时间相对较短）。
- en: If all of these conditions are met, it *may* make sense to simply use a polled
    approach, rather than a more elaborate interrupt- or DMA-driven approach, which
    will require the use of callbacks and, potentially, task synchronization mechanisms.
    However, depending on how you choose to structure your drivers, it is also possible
    to have the convenience of blocking calls but without the inefficiency of a polled
    transfer wasting CPU cycles. To take advantage of any of the non-polled approaches,
    we'll need to develop another skill—programming ISRs.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有这些条件都满足，那么简单地使用轮询方法而不是更复杂的基于中断或 DMA 的方法可能是有意义的，后者将需要使用回调和可能的任务同步机制。然而，根据您选择如何构建您的驱动程序，也可能同时拥有阻塞调用的便利性，但又不至于有轮询传输浪费
    CPU 周期的低效性。为了利用任何非轮询方法，我们需要开发另一项技能——编程 ISRs。
- en: Differentiating between tasks and ISRs
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区分任务和 ISRs
- en: Before we jump into coding a peripheral driver that utilizes interrupts, let's
    take a quick look at how interrupts compare to FreeRTOS tasks.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写利用中断的外设驱动程序之前，让我们快速看一下中断与 FreeRTOS 任务相比如何。
- en: 'There are many similarities between tasks and ISRs:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 任务和 ISRs 之间有许多相似之处：
- en: Both provide a way of achieving **parallel** code execution.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们都提供了一种实现 **并行** 代码执行的方法。
- en: Both only run when required.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们都只在需要时运行。
- en: Both can be written with C/C++ (ISRs generally no longer need to be written
    in assembly code).
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两种情况都可以用 C/C++ 编写（ISRs 通常不再需要用汇编代码编写）。
- en: 'But there are also many differences between tasks and ISRs:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 但任务和 ISRs 之间也有很多不同之处：
- en: '**ISRs are brought into context by hardware; tasks gain context by the RTOS
    kernel**: Tasks are always brought into context by the FreeRTOS kernel. Interrupts,
    on the other hand, are generated by hardware in the MCU. There are usually a few
    different ways of configuring the generation (and masking) of interrupts.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ISRs 由硬件引入上下文；任务通过 RTOS 内核获得上下文**：任务总是由 FreeRTOS 内核引入上下文。另一方面，中断是由 MCU 中的硬件生成的。通常有几种不同的方式来配置中断的生成（和屏蔽）。'
- en: '**ISRs must exit as quickly as possible; tasks are more forgiving**: FreeRTOS
    tasks are often set up to run in a similar way to an infinite `while` loop—they
    will be synchronized with the system using primitives (such as queues and semaphores)
    and switched into context according to their priority. At the complete opposite
    end of the spectrum are ISRs, which should generally be coded so that they exit
    quickly. This *quick exit* ensures that the system can respond to other ISRs,
    which keeps everything responsive and ensures no interrupts are missed because
    a single routine was hogging the CPU.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ISRs 必须尽可能快地退出；任务则更加宽容**：FreeRTOS 任务通常被设置为以类似无限 `while` 循环的方式运行——它们将使用原语（如队列和信号量）与系统同步，并根据它们的优先级切换上下文。在光谱的另一端是
    ISRs，它们应该通常被编码为快速退出。这种 *快速退出* 确保系统可以响应其他 ISRs，从而保持系统的响应性，并确保不会因为单个例程占用 CPU 而错过任何中断。'
- en: '**ISR functions do not take input parameters; tasks can**: Unlike tasks, ISRs
    can never have input parameters. Since an interrupt is triggered because of a
    hardware state, the most important job of the ISR is to read the hardware state
    (through memory-mapped registers) and take the appropriate action(s). For example,
    an interrupt can be generated when a UART receives a byte of data. In this case,
    the ISR would read a status register, read (and store) the byte received in a
    static variable, and clear the interrupt.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ISR函数不接受输入参数；任务可以**：与任务不同，ISR永远不会接受输入参数。由于中断是由硬件状态触发的，ISR最重要的任务是读取硬件状态（通过内存映射寄存器）并采取适当的行动。例如，当UART接收一个字节的数据时，可以生成中断。在这种情况下，ISR将读取状态寄存器，读取（并存储）接收到的字节到一个静态变量中，并清除中断。'
- en: Most (but not all) peripherals on STM32 hardware will automatically clear interrupt
    flags when certain registers are read. Regardless of how the interrupt is cleared,
    it is important to ensure the interrupt is no longer pending—otherwise, the interrupt
    will fire continuously and you will always be executing the associated ISR!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数（但并非全部）STM32硬件上的外设，在读取某些寄存器时将自动清除中断标志。无论中断是如何被清除的，确保中断不再挂起是很重要的——否则，中断将连续触发，你将始终在执行相关的中断服务例程（ISR）！
- en: '**ISRs may only access a limited ISR-specific subset of the FreeRTOS API**: FreeRTOS
    is written in a way that provides flexibility while balancing convenience, safety,
    and performance. Accessing data structures such as queues from a task is extremely
    flexible (for example, tasks making API calls to a queue can easily block for
    any period of time). There is an additional set of functions that are available
    to ISRs for operating on queues, but these functions have a limited subset of
    functionality (such as not being able to block—the call always immediately returns).
    This provides a level of safety since the programmer can''t shoot themself in
    the foot by calling a function that blocks from inside an ISR. Calling a non-ISR
    API function from inside an ISR will cause FreeRTOS to trigger `configASSERT`.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ISR只能访问FreeRTOS API的有限ISR特定子集**：FreeRTOS是以一种提供灵活性同时平衡便利性、安全性和性能的方式编写的。从任务中访问数据结构，如队列，非常灵活（例如，向队列发出API调用的任务可以轻松地阻塞任何时间段）。ISR有一组额外的函数可用于在队列上操作，但这些函数的功能有限（例如，不能阻塞——调用总是立即返回）。这提供了一定程度的安全性，因为程序员不能在ISR内部调用一个会阻塞的函数。在ISR内部调用非ISR
    API函数将导致FreeRTOS触发`configASSERT`。'
- en: '**ISRs may operate completely independently of all RTOS code**: There are many
    cases where an ISR operates on such a low level that it doesn''t *need* access
    to any of the FreeRTOS API at all. In this case, the ISR simply executes as it
    normally would without an RTOS present. The kernel never gets involved (and no
    tasks will interrupt execution).  This makes it very convenient for creating flexible
    solutions that blend high-performing ISRs (operating completely *underneath* the
    RTOS) with extremely convenient tasks.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ISR可以完全独立于所有RTOS代码运行**：有许多情况下，ISR在如此低级别上运行，它甚至不需要访问任何FreeRTOS API。在这种情况下，ISR将像通常没有RTOS存在时那样执行。内核永远不会介入（并且没有任务会中断执行）。这使得创建灵活的解决方案变得非常方便，这些解决方案将高性能ISR（完全在RTOS之下运行）与极其方便的任务相结合。'
- en: '**All ISRs share the same system stack; each task has a dedicated stack**:
    Each task receives a private stack, but all of the ISRs share the same system
    stack. This is noteworthy only because, when writing ISRs, you''ll need to ensure
    you reserve enough stack space to allow them to run (possibly simultaneously)
    if they are nested.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**所有ISR共享相同的系统堆栈；每个任务都有一个专用的堆栈**：每个任务都接收一个私有堆栈，但所有ISR共享相同的系统堆栈。这值得注意，因为当你编写ISR时，你需要确保为它们保留足够的堆栈空间，以便它们可以运行（可能同时运行），如果它们是嵌套的。'
- en: Now that we've covered the differences between tasks and ISRs, let's take a
    look at how they can be used together to create very powerful event-driven code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了任务和ISR之间的区别，让我们看看它们如何结合使用来创建非常强大的事件驱动代码。
- en: Using the FreeRTOS API from interrupts
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从中断中使用FreeRTOS API
- en: 'Most of the FreeRTOS primitives covered so far have ISR-safe versions of their
    APIs. For example, `xQueueSend()` has an equivalent ISR-safe version, `xQueueSendFromISR()`.
    There are a few differences between the ISR-safe version and the standard call:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，大多数FreeRTOS原语都有它们API的中断安全版本。例如，`xQueueSend()`有一个等效的中断安全版本，`xQueueSendFromISR()`。ISR安全版本和标准调用之间有一些差异：
- en: The `FromISR` variants won't block. For example, if `xQueueSendFromISR` encounters
    a full queue, it will immediately return.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FromISR` 变体不会阻塞。例如，如果 `xQueueSendFromISR` 遇到满队列，它将立即返回。'
- en: The `FromISR` variants require an extra parameter, `BaseType_t *pxHigherPriorityTaskWoken`,
    which will indicate whether or not a higher-priority task needs to be switched
    into context immediately following the interrupt.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FromISR` 变体需要额外的参数，`BaseType_t *pxHigherPriorityTaskWoken`，这将指示是否需要在中断之后立即将更高优先级的任务切换到上下文中。'
- en: Only interrupts that have a *logically* lower priority than what is defined
    by `configMAX_API_CALL_INTERRUPT_PRIORITY` in `FreeRTOSConfig.h` are permitted
    to call FreeRTOS API functions (see the following diagram for an example).
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有优先级低于 `FreeRTOSConfig.h` 中定义的 `configMAX_API_CALL_INTERRUPT_PRIORITY` 的中断才能调用
    FreeRTOS API 函数（以下图示为例）。
- en: 'The following is an overview of how the `FreeRTOSConfig.h` and `main_XXX.c`
    files configure interrupts for the examples in this book. Some noteworthy items
    are as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对 `FreeRTOSConfig.h` 和 `main_XXX.c` 文件如何配置本书中示例中断的概述。以下是一些值得注意的项目：
- en: '`main_XXX.c` makes a call to `NVIC_SetPriorityGrouping(0)` after all STM HAL
    initialization is performed (`HAL` sets priority grouping upon initialization).
    This allows all 4 bits of the **nested interrupt vector controller** (**NVIC**)
    to be used for priorities and results in 16 priority levels.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main_XXX.c` 在执行所有 STM HAL 初始化后调用 `NVIC_SetPriorityGrouping(0)`（`HAL` 在初始化时设置优先级分组）。这允许使用所有
    4 位来设置优先级，从而产生 16 个优先级级别。'
- en: '`FreeRTOSConfig.h` is used to set up the relationship between FreeRTOS API
    calls and NVIC priorities. The Cortex-M7 defines `255` as being the lowest priority
    level and `0` as being the highest. Since the STM32F7 only implements 4 bits,
    these 4 bits will be shifted into the 4 MSB bits; the lower 4 bits won''t affect
    operation (see the following diagram):'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FreeRTOSConfig.h` 用于设置 FreeRTOS API 调用与 NVIC 优先级之间的关系。Cortex-M7 将 `255` 定义为最低优先级，而
    `0` 为最高优先级。由于 STM32F7 只实现了 4 位，这 4 位将被移位到 4 个最高有效位；较低的 4 位不会影响操作（见以下图示）：'
- en: '`configKERNEL_INTERRUPT_PRIORITY` defines the lowest priority interrupt in
    our system (and the ISR priority of the FreeRTOS tasks, since the scheduler is
    called within a SysTick interrupt). Because 4 bits yields a possible range of
    `0` (highest priority) to `15` (lowest priority), the lowest NVIC priority used
    will be `15`. When setting `configKERNEL_INTERRUPT_PRIORITY`, `15` needs to be
    shifted left into the 8 bit representation (used directly in the CortexM registers)
    as `(15 << 4) | 0x0F = 0xFF` or `255`.  Since the lowest 4 bits are don''t cares,
    `0xF0` (decimal 240) is also acceptable.'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configKERNEL_INTERRUPT_PRIORITY` 定义了我们系统中最低优先级的中断（以及 FreeRTOS 任务的 ISR 优先级，因为调度器是在
    SysTick 中断内被调用的）。由于 4 位可以产生从 `0`（最高优先级）到 `15`（最低优先级）的可能范围，因此使用的最低 NVIC 优先级将是 `15`。在设置
    `configKERNEL_INTERRUPT_PRIORITY` 时，`15` 需要左移到 8 位表示（直接用于 CortexM 寄存器）中，即 `(15
    << 4) | 0x0F = 0xFF` 或 `255`。由于最低 4 位是无关紧要的，`0xF0`（十进制 240）也是可接受的。'
- en: '`configMAX_SYSCALL_INTERRUPT_PRIORITY` defines the (logically) highest priority
    interrupt that is allowed to make calls to the FreeRTOS API. This is set to `5`
    in our examples. Shifting left to fill out the 8 bits gives us a value of `0x50`
    or `0x5F` (decimal 80 or 95, respectively):'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configMAX_SYSCALL_INTERRUPT_PRIORITY` 定义了允许调用 FreeRTOS API 的（逻辑上）最高优先级中断。在我们的示例中，这被设置为
    `5`。左移以填充 8 位给出值为 `0x50` 或 `0x5F`（十进制 80 或 95）：'
- en: '![](img/c94abcbe-e57f-476c-b15f-15272efe8f64.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c94abcbe-e57f-476c-b15f-15272efe8f64.png)'
- en: As we can see in the preceding diagram, there are some cases where ISRs can
    be set up to execute at a priority above anything the RTOS might be doing. When
    configured as `0` to `4` NVIC priorities, ISRs are identical to traditional "bare-metal"
    ISRs.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，有些情况下中断服务例程（ISR）可以配置为以高于 RTOS 可能执行的所有操作的优先级执行。当配置为 `0` 到 `4` NVIC 优先级时，ISR
    与传统的“裸机”ISR 相同。
- en: It is *very* important to ensure that the interrupt priority is properly configured *before*
    enabling the interrupt by calling `NVIC_SetPriority` with a priority of <= 5\.
    If an interrupt with a priority that is logically higher than `configMAX_SYSCALL_INTERRUPT_PRIORITY` calls
    a FreeRTOS API function, you'll be greeted with a `configASSERT` failure (see
    [Chapter 17](50d2b6c3-9a4e-45c3-9bfc-1c7f58de0b98.xhtml), *Troubleshooting Tips
    and Next Steps*, for more details on `configASSERT`).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过调用`NVIC_SetPriority`（优先级为<= 5）启用中断之前，确保正确配置中断优先级是非常重要的。如果一个优先级逻辑上高于`configMAX_SYSCALL_INTERRUPT_PRIORITY`的中断调用FreeRTOS
    API函数，你将遇到`configASSERT`失败（有关`configASSERT`的更多详细信息，请参阅[第17章](50d2b6c3-9a4e-45c3-9bfc-1c7f58de0b98.xhtml)，*故障排除提示和下一步操作*）。
- en: Now that we have an understanding of the differences between tasks and ISRs,
    as well as some of the ground rules for using FreeRTOS API functions from within
    ISRs, let's take another look at the polled driver to see how it can be implemented
    more efficiently.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了任务和中断服务例程（ISR）之间的区别，以及在使用FreeRTOS API函数时的一些基本规则，让我们再次审视轮询驱动程序，看看它如何能更有效地实现。
- en: Creating ISR-based drivers
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基于ISR的驱动程序
- en: In the first iteration of the UART driver, a task polled the UART peripheral
    registers to determine when a new byte had been received. The constant polling
    is what caused the task to consume > 95% of CPU cycles. The most meaningful work
    done by this task-based driver was transferring bytes of data out of the UART
    peripheral and into the queue.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在UART驱动程序的第一迭代中，一个任务轮询UART外设寄存器以确定是否已接收到新的字节。这种持续的轮询导致任务消耗了> 95%的CPU周期。基于任务的驱动程序所做的最有意义的工作是将数据字节从UART外设传输到队列中。
- en: In this iteration of the driver, instead of using a task to continuously poll
    the UART registers, we'll set up the `UART2` peripheral and NVIC to provide an
    interrupt when a new byte is received.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个驱动程序的这一迭代中，我们不会使用任务来持续轮询UART寄存器，而是设置`UART2`外设和NVIC，以便在接收到新字节时提供中断。
- en: Queue-based driver
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于队列的驱动程序
- en: First, let's look at how to more efficiently implement the polled driver (previously
    implemented by polling the UART registers within a task). In this implementation,
    instead of using a task to repeatedly poll the UART registers, a function will
    be used to set up the peripheral to use interrupts and initiate the transfer.
    A complete set of ISR function prototypes can be found in the startup file (for
    the STM32F767 used in our examples, this file is `Chapter_10/startup_stm32f767xx.s`).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何更有效地实现轮询驱动程序（之前是通过在任务中轮询UART寄存器来实现的）。在这个实现中，我们不会使用任务来重复轮询UART寄存器，而是使用一个函数来设置外设使用中断并启动传输。完整的ISR函数原型可以在启动文件中找到（对于我们在示例中使用的STM32F767，此文件是`Chapter_10/startup_stm32f767xx.s`）。
- en: Each `*_IRQHandler` instance in `startup_stm32f767xx.s` is used to map the function
    name to an address in the interrupt vector table. On ARM Cortex-M0+, -M3, -M4,
    and -M7 devices, this vector table can be relocated by an offset at runtime. See
    *Further reading* for some links to more information on these concepts.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在`startup_stm32f767xx.s`中的每个`*_IRQHandler`实例都用于将函数名映射到中断向量表中的一个地址。在ARM Cortex-M0+、-M3、-M4和-M7设备上，这个向量表可以在运行时通过偏移量重新定位。有关这些概念更多信息的链接，请参阅*进一步阅读*。
- en: 'This example has four primary components:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例有四个主要组件：
- en: '`uartPrintOutTask`: This function initializes USART2 and associated hardware,
    starts a reception, and then prints anything placed in the `uart2_BytesReceived`
    queue.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uartPrintOutTask`：此函数初始化USART2和相关硬件，启动接收，然后打印放入`uart2_BytesReceived`队列中的任何内容。'
- en: '`startReceiveInt`: Sets up an interrupt-based reception for USART2.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startReceiveInt`：为USART2设置基于中断的接收。'
- en: '`USART2_IRQHandler`: An ISR is issued when an interrupt occurs for the USART2
    peripheral.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USART2_IRQHandler`：当USART2外设发生中断时发出ISR。'
- en: '`startUart4Traffic`: Starts a continuous stream of data transmitted from UART4
    to be received by USART2 (provided the jumpers are correctly set).'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startUart4Traffic`：启动从UART4发送的连续数据流，由USART2接收（前提是跳线设置正确）。'
- en: Let's take a look at each component in detail. All excerpts in this section
    are from `Chapter_10/Src/mainUartInterruptQueue.c`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看每个组件。本节中的所有摘录均来自`Chapter_10/Src/mainUartInterruptQueue.c`。
- en: uartPrintOutTask
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: uartPrintOutTask
- en: 'The only task in this example is `uartPrintOutTask`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中唯一的任务是`uartPrintOutTask`：
- en: '[PRE5]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`uartPrintOutTask` does the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`uartPrintOutTask`执行以下操作：'
- en: Performs all peripheral hardware initialization by calling `STM_UartInit`
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用`STM_UartInit`执行所有外设硬件初始化。
- en: Starts an interrupt-based reception by calling `startReceiveInt`
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用 `startReceiveInt` 开始基于中断的接收。
- en: '*Consumes* and prints each character as it is added to the `uart2_BytesReceived` queue
    by calling `xQueueReceive`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*消费* 并打印每个字符，当它通过调用 `xQueueReceive` 添加到 `uart2_BytesReceived` 队列时。'
- en: startReceiveInt
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`startReceiveInt`'
- en: 'The `startReceiveInt` function starts an interrupt-driven reception:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`startReceiveInt` 函数启动了一个基于中断的接收：'
- en: '[PRE6]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`startReceiveInt` sets up everything required to receive data on USART2:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`startReceiveInt` 设置了接收 USART2 数据所需的所有内容：'
- en: '`rxInProgress` is a flag used by the ISR to indicate a reception is in progress.
    The ISR (`USART2_IRQHandler()`) will not attempt to write to the queue until `rxInProgress`
    is true.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rxInProgress` 是一个由中断服务例程 (ISR) 使用的标志，用于指示接收正在进行。ISR (`USART2_IRQHandler()`)
    不会尝试向队列写入，直到 `rxInProgress` 为真。'
- en: USART2 is configured to generate `receive` and `error` interrupts and is then
    enabled.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: USART2 被配置为生成 `接收` 和 `错误` 中断，然后被启用。
- en: The `NVIC_SetPriority` function (defined by CMSIS in `Drivers/CMSIS/Include/corex_cm7.h`)
    is used to set the interrupt priority. Since this interrupt will call a FreeRTOS
    API function, this priority must be set at or *below* thelogical priority defined
    by  `configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY` in `FreeRTOSConfig.h`. On ARM
    CortexM processors, smaller numbers signify a higher logical priority—in this
    example, `#define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY 5`, so assigning
    a priority of `6` to `USART2_IRQn` will be adequate for allowing the ISR to make
    calls to the ISR-safe function (`xQueueSendFromISR`) provided by FreeRTOS.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NVIC_SetPriority` 函数（由 CMSIS 在 `Drivers/CMSIS/Include/corex_cm7.h` 中定义）用于设置中断优先级。由于此中断将调用
    FreeRTOS API 函数，因此此优先级必须设置在 `FreeRTOSConfig.h` 中定义的 `configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY`
    的或以下。在 ARM CortexM 处理器上，较小的数字表示较高的逻辑优先级——在本例中，`#define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY
    5`，因此将优先级 `6` 分配给 `USART2_IRQn` 将足够允许 ISR 调用 FreeRTOS 提供的 ISR 安全函数 (`xQueueSendFromISR`)。'
- en: Finally, the interrupt requests generated by USART2 will be enabled by making
    a call to `NVIC_EnableIRQ`.   If `NVIC_EnableIRQ` is not called, USART2 will still
    generate requests, but the interrupt controller (the "IC" in NVIC) will not *vector* the
    program counter to the ISR (`USART2_IRQHandler` will never be called).
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，通过调用 `NVIC_EnableIRQ` 启用 USART2 生成的中断请求。如果未调用 `NVIC_EnableIRQ`，USART2 仍然会生成请求，但中断控制器（NVIC
    中的“IC”）不会将程序计数器向量到 ISR（`USART2_IRQHandler` 将永远不会被调用）。
- en: In this example, as with nearly all the code in this chapter, we're writing
    directly to the hardware peripheral registers and not using considerable amounts
    of abstraction. This is done to keep the focus on how the RTOS interacts with
    the MCU. If code reuse is one of your goals, you'll need to provide some level
    of abstraction above raw registers (or STM HAL code, if you're using it). Some
    guidelines on this can be found in [Chapter 12](8e78a49a-1bcd-4cfe-a88f-fb86a821c9c7.xhtml),
    *Tips on Creating Well-Abstracted Architecture*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，与本章中几乎所有代码一样，我们直接写入硬件外设寄存器，而不是使用大量的抽象。这样做是为了保持关注 RTOS 如何与 MCU 交互。如果你将代码重用作为目标之一，你需要提供一定程度的抽象层（或者如果你使用
    STM HAL 代码，则需要提供抽象层）。有关这方面的指南可以在 [第 12 章](8e78a49a-1bcd-4cfe-a88f-fb86a821c9c7.xhtml)，*创建良好抽象架构的技巧*
    中找到。
- en: USART2_IRQHandler
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`USART2_IRQHandler`'
- en: 'Here is the code for `USART2_IRQHandler`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `USART2_IRQHandler` 的代码：
- en: '[PRE7]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s take a closer look at each component of the ISR:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看 ISR 的每个组成部分：
- en: The USART registers are directly read to determine whether or not the receive
    not empty (`RXNE`) is set. If it is, the contents of the receive data register
    (`RDR`) are stored to a temporary variable (`tempVal`)—this read clears the interrupt
    flag. If a receive is in progress, `tempVal` is sent to the queue.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过直接读取 USART 寄存器来确定接收是否为空 (`RXNE`) 是否被设置。如果是，接收数据寄存器 (`RDR`) 的内容将被存储到一个临时变量
    (`tempVal`) 中——这次读取会清除中断标志。如果接收正在进行，`tempVal` 将被发送到队列中。
- en: Calls to `SEGGER_SYSVIEW_RecordEnterISR` and `SEGGER_SYSVIEW_RecordExitISR`
    are made upon entry and exit, which gives SEGGER SystemView the visibility to
    display the interrupt with all of the other tasks in the system.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进入和退出时调用 `SEGGER_SYSVIEW_RecordEnterISR` 和 `SEGGER_SYSVIEW_RecordExitISR`，这使
    SEGGER SystemView 能够看到中断，并在系统中显示与其他任务一起的所有任务。
- en: The `xHigherPriorityTaskWoken` variable is initialized to false. This variable
    is passed to the `xQueueSendFromISR` function and is used to determine whether
    a high-priority task (higher than the one currently in the non-ISR context) is
    blocking because it is waiting on an empty queue. In this case, `xHigherPriorityTaskWoken` will
    be set to true, indicating a higher-priority task should be woken immediately
    after the ISR exits. When the call to `portYIELD_FROM_ISR` is made, if `xHigherPriorityTaskWoken` is
    true, the scheduler will immediately switch to the higher-priority task.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xHigherPriorityTaskWoken`变量初始化为false。这个变量传递给`xQueueSendFromISR`函数，用于确定一个高优先级任务（高于当前的非ISR上下文中的任务）是否因为正在等待一个空队列而阻塞。在这种情况下，`xHigherPriorityTaskWoken`将被设置为true，表示在ISR退出后应立即唤醒一个高优先级任务。当调用`portYIELD_FROM_ISR`时，如果`xHigherPriorityTaskWoken`为true，调度器将立即切换到高优先级任务。'
- en: Now that the ISR has been written, we'll need to make sure it will actually
    be called by the hardware at the appropriate time.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在ISR已经编写好了，我们需要确保它实际上会在适当的时间被硬件调用。
- en: Tips for linking ISRs
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接ISR的技巧
- en: 'When writing ISRs from scratch (as we''ve done in the previous example), one
    area that can prove to be a source of unexpected trouble is ensuring your ISR
    is properly linked in (and executed). That is, even if you''ve properly set up
    the peripheral to generate interrupts, your new ISR might never be called because
    it isn''t named properly (instead, the default implementation, defined in a startup
    file, will likely be called). Here are some tips to make sure that shiny new ISR
    can be found and properly linked in with the rest of the application:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当从头开始编写中断服务例程（ISR）（就像我们在上一个示例中所做的那样）时，可能会成为意外麻烦来源的一个区域是确保你的ISR被正确链接（并执行）。也就是说，即使你已经正确设置了外设以生成中断，你的新ISR可能永远不会被调用，因为它没有被正确命名（相反，默认实现，定义在启动文件中，可能会被调用）。以下是一些确保这个闪亮的新ISR可以被找到并与应用程序的其他部分正确链接的技巧：
- en: STM32 `*_IRQHandler` function names *usually* contain the *exact* peripheral
    name from the datasheet as a sub-string. For example, USART2 maps to `USART2_IRQHandler` (notice
    the "S") and UART4 maps to `UART4_IRQHandler` (no "S" in the peripheral or function
    name).
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STM32的`*_IRQHandler`函数名称*通常*包含数据表中的*确切*外设名称作为子字符串。例如，USART2映射到`USART2_IRQHandler`（注意"S"），而UART4映射到`UART4_IRQHandler`（外设或函数名称中没有"S"）。
- en: When writing a new implementation for an ISR, it is a good idea to copy and
    paste the exact `_IQRHandler` name from the startup file. This reduces the chance
    of typos, which can cause debug headaches!
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当为ISR编写新实现时，复制并粘贴启动文件中的确切`_IQRHandler`名称是一个好主意。这减少了打字错误的可能性，这可能会引起调试困难！
- en: STM start-up files implement default handlers for every interrupt as an infinite
    loop. If you notice your application becoming unresponsive, it is possible you've
    enabled an interrupt and your `*_IRQHandler` definition isn't being linked in
    properly.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STM启动文件为每个中断实现默认处理程序作为一个无限循环。如果你注意到你的应用程序变得无响应，可能是因为你已启用了一个中断，而你的`*_IRQHandler`定义没有被正确链接。
- en: If you happen to be implementing `*_IRQHandler` inside a C++ file, be sure to
    use `extern "C"` to prevent *name mangling*. For example, the USART2 definition
    would be written as `extern "C" void USART2_IRQHandler( void)`. This also means
    the ISR definition must *not* be inside a class.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你碰巧在一个C++文件中实现`*_IRQHandler`，请确保使用`extern "C"`以防止*名称修饰*。例如，USART2的定义将写成`extern
    "C" void USART2_IRQHandler(void)`。这也意味着ISR定义必须*不在*类内部。
- en: When implementing ISRs, take your time and be sure to get the details (such
    as the *exact* name) right. Don't rush into attempting to debug the rest of your
    application without first ensuring the ISR is called when expected. Using breakpoints
    inside the ISR is an excellent way of doing this.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现ISR时，请花时间并确保细节（如确切的名称）正确无误。在确保ISR在预期时被调用之前，不要急于尝试调试应用程序的其他部分。在ISR中使用断点是完成这一点的绝佳方式。
- en: startUart4Traffic
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: startUart4Traffic
- en: The final component that needs to be explored in this example is how data will
    be sent to UART2\. These examples are meant to simulate external data being received
    by USART2.  To achieve this without additional hardware, we wired together UART4
    Tx and USART2 RX pins earlier in the chapter. The call to `startUart4Traffic()` is
    a `TimerHandler` prototype. A oneshot timer is started and set to fire 5 seconds
    after the application starts.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中需要探索的最后一个组件是如何将数据发送到UART2。这些示例旨在模拟外部数据被USART2接收。为了在不添加额外硬件的情况下实现这一点，我们在本章早期将UART4的Tx和USART2的RX引脚连接在一起。对`startUart4Traffic()`的调用是一个`TimerHandler`原型。一个单次定时器被启动并设置为在应用程序启动后5秒触发。
- en: The function that does all of the heavy lifting is `SetupUart4ExternalSim()`.
    It sets up a continuous circular DMA transfer (which executes without CPU intervention)
    that transmits the string `data from uart4` repeatedly. A full example using DMA
    will be covered later in this chapter – for now, it is sufficient to realize that
    data is being sent to USART2 without involvement from the CPU.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 执行所有繁重工作的函数是`SetupUart4ExternalSim()`。它设置了一个连续的循环DMA传输（无需CPU干预）来重复传输字符串`data
    from uart4`。本章稍后将详细介绍使用DMA的完整示例——目前，我们只需要意识到数据正在发送到USART2，而不涉及CPU。
- en: '`startUart4Traffic()` creates a *continuous* stream of bytes that will be transmitted
    out of UART4 Tx and into UART2 Rx (with no flow control). Depending on the selected
    baud rate and the amount of time it takes for the receiving code to execute, we
    can expect that, eventually, a byte will be missed on the receiving side during
    some examples. Keep this in mind when running examples on your own. See the *Choosing
    a driver model* section for more details on selecting the appropriate driver type
    for your application.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`startUart4Traffic()`创建了一个*连续*的字节流，这些字节将从UART4的Tx引脚传输到UART2的Rx引脚（没有流量控制）。根据所选的波特率和接收代码执行所需的时间，我们预计在某些示例中，接收端最终会丢失一个字节。在运行自己的示例时请记住这一点。有关选择适当驱动程序类型更详细的信息，请参阅*选择驱动程序模型*部分。'
- en: Performance analysis
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能分析
- en: 'Now, let''s take a look at the performance of this implementation by compiling
    `mainUartInterruptQueue`, loading it onto the MCU, and using SystemView to analyze
    the actual execution:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过编译`mainUartInterruptQueue`，将其加载到MCU上，并使用SystemView分析实际执行来查看此实现的性能：
- en: '![](img/1db4a7e2-4ed1-4022-864f-efba7ed13ab6.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1db4a7e2-4ed1-4022-864f-efba7ed13ab6.png)'
- en: 'This time around, things look considerably better.  Here are some noteworthy
    items from the preceding screenshot:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，情况看起来好得多。以下是前一个屏幕截图中的几个值得注意的项目：
- en: The ISR responsible for dealing with the incoming data on USART2 Rx is only
    consuming around 1.6% of the CPU (much better than the 96% we saw when we were
    using a polled approach).
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 负责处理USART2 Rx接收到的数据的ISR仅消耗大约1.6%的CPU（比我们使用轮询方法时看到的96%要好得多）。
- en: We are still receiving 960 bytes per second—the same as before.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们仍然以每秒960字节的速度接收数据——与之前相同。
- en: The small tick mark shown here is the exact point in time when `tempVal` is
    added to `uart2_BytesReceived` by the call to the `xQueueSendFromISR` FreeRTOS
    API function.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里显示的小刻度是`tempVal`通过调用FreeRTOS API函数`xQueueSendFromISR`添加到`uart2_BytesReceived`的确切时间点。
- en: We can see the effect of `portYIELD_FROM_ISR` here. The light-blue portion of
    the `uartPrint` task indicates that the task is ready to run. This happens because
    the `uartPrint` task is ready to run since there is an item in the queue. The
    call to `portYIELD_FROM_ISR` forces the scheduler to immediately evaluate which
    task should be brought into context. The green portion (starting at ~21 uS) is
    SystemView's way of signifying that the task is in a **running** state.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在这里看到`portYIELD_FROM_ISR`的效果。`uartPrint`任务中的浅蓝色部分表示任务准备就绪。这是因为`uartPrint`任务由于队列中有项目而准备就绪。对`portYIELD_FROM_ISR`的调用迫使调度器立即评估哪个任务应该被带入上下文。绿色部分（从大约21
    uS开始）是SystemView表示任务处于**运行**状态的方式。
- en: After the `uartPrint` task begins running, it removes the next character from
    the queue and prints it using `SEGGER_SYSVIEW_PrintfHost`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`uartPrint`任务开始运行后，它从队列中移除下一个字符，并使用`SEGGER_SYSVIEW_PrintfHost`打印它。
- en: By switching from a poll-based driver to an interrupt-based driver, we've significantly
    reduced the CPU load. Additionally, systems that use an interrupt-based driver
    can run other tasks while still receiving data through USART2\. This driver also
    uses a queue-based approach, which provides a very convenient ring buffer, allowing
    characters to be continuously received and added to the queue, then read whenever
    it is convenient for higher-level tasks.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从基于轮询的驱动程序切换到基于中断的驱动程序，我们显著降低了 CPU 的负载。此外，使用基于中断的驱动程序的系统可以在通过 USART2 接收数据的同时运行其他任务。此驱动程序还使用基于队列的方法，提供了一个非常方便的环形缓冲区，允许字符连续接收并添加到队列中，然后在高层任务方便时读取。
- en: Next, we'll work through an example of a similar driver that doesn't use a queue
    at all.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过一个类似但不使用队列的驱动程序的例子来进行分析。
- en: A buffer-based driver
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于缓冲区的驱动程序
- en: Sometimes, the exact size of a transfer is known in advance. In this case, a
    pre-existing buffer can be passed to the driver and used in place of a queue.
    Let's take a look at an example of a buffer-based driver, where the exact number
    of bytes is known in advance. The hardware setup for this example is identical
    to the previous examples—we'll concentrate on receiving data through USART2.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，传输的确切大小可以提前知道。在这种情况下，可以传递一个现有的缓冲区给驱动程序，并用它来代替队列。让我们看看一个基于缓冲区的驱动程序的例子，其中确切的字节数是提前知道的。这个例子中的硬件设置与前面的例子相同——我们将专注于通过
    USART2 接收数据。
- en: Instead of using a queue, `uartPrintOutTask` will supply its own buffer to the `startReceiveInt`
    function. Data received by USART2 will be placed directly in the local buffer
    until the desired number of bytes have been added, then a semaphore will be given
    by the ISR to provide notification of the completion. The entire message will
    be printed as a single string, rather than 1 byte at a time, as it is received
    (which was done in the last example).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用队列不同，`uartPrintOutTask` 将为其 `startReceiveInt` 函数提供自己的缓冲区。通过 USART2 接收到的数据将直接放置在本地缓冲区中，直到添加了所需数量的字节，然后中断服务例程（ISR）将通过信号量提供完成通知。整个信息将作为一个字符串打印出来，而不是像接收时那样逐字节打印（这在上一个例子中已经这样做过）。
- en: 'Just like the previous example, there are four main components. However, their
    responsibilities vary slightly:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 就像前面的例子一样，有四个主要组件。然而，它们的责任略有不同：
- en: '`startReceiveInt`: Sets up an interrupt-based reception for USART2 and configures
    the necessary variables used by the ISR for the transfer.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startReceiveInt`：为 USART2 设置基于中断的接收并配置用于传输的中断服务例程所需的相关变量。'
- en: '`uartPrintOutTask`: This function initializes USART2 and associated hardware,
    starts a reception, and waits for completion (with a deadline of 100 ms). The
    complete message is either printed or a timeout occurs and an error is printed.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uartPrintOutTask`：此函数初始化 USART2 及相关硬件，启动接收，并等待完成（截止时间为 100 毫秒）。完整的信息要么被打印出来，要么发生超时并打印错误。'
- en: '`USART2_IRQHandler`: An ISR is issued when an interrupt occurs for the USART2
    peripheral.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USART2_IRQHandler`：当 USART2 外设发生中断时发出中断服务例程（ISR）。'
- en: '`startUart4Traffic`: Starts a continuous stream of data transmitted from UART4
    to be received by USART2 (provided the jumpers are correctly set).'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startUart4Traffic`：启动从 UART4 发送并由 USART2 接收的连续数据流（前提是跳线设置正确）。'
- en: Let's take a look at each component in detail. All excerpts in this section
    are from `Chapter_10/Src/mainUartInterruptBuffer.c`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细查看每个组件。本节中所有摘录均来自 `Chapter_10/Src/mainUartInterruptBuffer.c`。
- en: startReceiveInt
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: startReceiveInt
- en: 'The `startReceiveInt` function is very similar to the one used for the queue-based
    driver:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`startReceiveInt` 函数与用于基于队列的驱动程序的函数非常相似：'
- en: '[PRE8]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here are the notable differences in this setup:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在此设置中，以下是一些显著的不同点：
- en: This variant takes in a pointer to a buffer (`Buffer`), as well as the desired
    length of the transfer (`Len`). A couple of global variables, `rxBuff` and `rxLen` (which
    will be used by the ISR), are initialized using these parameters.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此变体接受一个指向缓冲区（`Buffer`）的指针以及所需的传输长度（`Len`）。使用这些参数初始化了几个全局变量 `rxBuff` 和 `rxLen`（这些将由中断服务例程使用）。
- en: '`rxInProgress` is used to determine whether a reception is already in progress
    (returning `-1`  if it is).'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rxInProgress` 用于确定接收是否已经在进行中（如果是，则返回 `-1`）。'
- en: An iterator (`rxItr`) that is used to index into the buffer is initialized to
    `0`.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于索引缓冲区的迭代器（`rxItr`）初始化为 `0`。
- en: All of the remaining functionality of `startReceiveInt` is identical to the
    example covered in the *Queue-based driver* section earlier in the chapter.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`startReceiveInt` 函数的所有剩余功能与本章前面 *基于队列的驱动* 部分中介绍的示例完全相同。'
- en: uartPrintOutTask
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: uartPrintOutTask
- en: 'The `uartPrintOutTask` function that is responsible for printing out data received
    by USART2 is a bit more complex in this example. This example is also capable
    of comparing the received data against an expected length, as well as some rudimentary
    error detection:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 负责打印USART2接收到的数据的`uartPrintOutTask`函数在这个例子中稍微复杂一些。此示例还可以比较接收到的数据与预期长度，以及一些基本的错误检测：
- en: 'The buffer and length variables are initialized and the UART peripheral is
    set up:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缓冲区和长度变量被初始化，UART外设被设置：
- en: '[PRE9]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Then, the body of the `while` loop starts a reception by calling `startReceiveInt`
    and then waits for the `rxDone` semaphore for up to 100 RTOS ticks for the transfer
    to complete.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，`while`循环的主体通过调用`startReceiveInt`开始接收，并等待`rxDone`信号量，最多等待100个RTOS tick以完成传输。
- en: If the transfer completes in time, the total number of bytes received is compared
    against `expectedLen`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果传输及时完成，接收到的总字节数将与`expectedLen`进行比较：
- en: 'If the correct number of bytes are present, the content of `rxData` is printed.
    Otherwise, a message providing an explanation of the discrepancy is printed:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在正确的字节数量，`rxData`的内容将被打印。否则，将打印一条消息，解释差异的原因：
- en: '[PRE10]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The remainder of the `while` loop and function simply prints `timeout` if the
    semaphore is not taken within 100 ticks.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环的其余部分和函数简单地打印`timeout`，如果信号量在100个tick内没有被获取。'
- en: USART2_IRQHandler
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: USART2_IRQHandler
- en: 'This ISR is also slightly more involved since it is required to keep track
    of the position in a queue:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于需要跟踪队列中的位置，这个ISR也稍微复杂一些：
- en: 'Private globals are used by `USART2_IRQHandler` because they need to be accessible
    by both the ISR and used by both `USART2_IRQHandler`  and `startReceiveInt`:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`USART2_IRQHandler`使用私有全局变量，因为它们需要被ISR访问，并且由`USART2_IRQHandler`和`startReceiveInt`使用：'
- en: '[PRE11]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The same paradigm for storing `xHigherPriorityTaskWoken` and SEGGER SystemView
    tracing is used in this ISR, just like in the last example:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个ISR中，存储`xHigherPriorityTaskWoken`和SEGGER SystemView跟踪的范式与上一个例子相同：
- en: '[PRE12]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, errors are checked by reading the overrun (`ORE`), noise error (`NE`),
    framing error (`FE`), and parity error (`PE`) bits in the interrupt state register
    (`USART2->ISR`).
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过读取中断状态寄存器（`USART2->ISR`）中的溢出（`ORE`）、噪声错误（`NE`）、帧错误（`FE`）和奇偶校验错误（`PE`）位来检查错误。
- en: 'If an error is present, it is cleared by a write to the interrupt clear register
    (`USART2->ICR`) and the `rxDone` semaphore is given. It is the responsibility
    of the caller code to check the number of bits in the buffer by looking at the
    `rxItr` variable (shown in the next code block) to ensure the correct number of
    bits were successfully received:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在错误，它将通过写入中断清除寄存器（`USART2->ICR`）和释放`rxDone`信号量来清除。调用者代码的责任是通过查看`rxItr`变量（如下一代码块所示）来检查缓冲区中的位数，以确保成功接收了正确的位数：
- en: '[PRE13]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next, the ISR checks whether a new byte has been received (by reading the `RXNE`
    bit of `USART2->ISR`). If a new byte is available, it is pushed into the `rxBuff`
    buffer and the `rxItr` iterator is incremented.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，ISR检查是否接收到了新的字节（通过读取`USART2->ISR`中的`RXNE`位）。如果有一个新的字节可用，它将被推入`rxBuff`缓冲区，并且`rxItr`迭代器递增。
- en: 'After the desired number of bytes have been added to the buffer, the `rxDone`
    semaphore is given to notify `uartPrintOutTask`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在缓冲区中添加了所需数量的字节后，释放`rxDone`信号量以通知`uartPrintOutTask`：
- en: '[PRE14]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Don't forget to put a breakpoint in the ISR to make sure it is being called.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在ISR中设置断点，以确保它被调用。
- en: startUart4Traffic
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: startUart4Traffic
- en: Identical to the previous example, this function sets up a DMA transfer to push
    data out of the UART4 Tx pin into the USART2 Rx pin.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个例子相同，这个函数设置DMA传输，将数据从UART4的Tx引脚推送到USART2的Rx引脚。
- en: Performance analysis
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能分析
- en: 'Now, let''s take a look at the performance of this driver implementation. There
    are several aspects to consider. Unless a transfer is complete, the ISR will normally
    only transfer a byte into `rxBuff`. In this case, the interrupt is fairly short,
    taking less than 3 us to complete:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个驱动程序实现的表现。有几个方面需要考虑。除非传输完成，否则ISR通常只会将一个字节传输到`rxBuff`。在这种情况下，中断非常短，完成时间不到3微秒：
- en: '![](img/5ba829c9-7e44-4a49-94c4-9c0caabc9a6f.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ba829c9-7e44-4a49-94c4-9c0caabc9a6f.png)'
- en: 'After all 16 bytes have been received, the ISR execution gets a bit more interesting
    and looks a bit more similar to the previous example:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在接收所有16个字节之后，ISR的执行变得更有趣，看起来与上一个例子有些相似：
- en: '![](img/0ff7273f-d44e-4b1b-b4a1-f67eb8937997.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ff7273f-d44e-4b1b-b4a1-f67eb8937997.png)'
- en: 'Here are some noteworthy points from the preceding screenshot:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是从前面的屏幕截图中的几个值得注意的点：
- en: After all the bytes have been placed into `rxBuff`, the `rxDone` semaphore is
    given from the ISR using `xSemaphoreGiveFromISR`.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有字节都放入`rxBuff`之后，ISR使用`xSemaphoreGiveFromISR`从ISR中释放`rxDone`信号量。
- en: The task is unblocked after the interrupt is executed by taking the available
    semaphore (`xSemaphoreTake(rxDone,100)`).
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在中断执行后，通过获取可用的信号量（`xSemaphoreTake(rxDone,100)`）来解除任务阻塞。
- en: The exact contents of `rxBuff` are printed. Note that each line contains the
    entire string, rather than individual characters. This is because this implementation
    collects an entire buffer's worth of data before using a semaphore to indicate
    completion.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出`rxBuff`的确切内容。请注意，每一行都包含整个字符串，而不是单个字符。这是因为这个实现收集了一个完整的缓冲区数据，然后使用信号量来指示完成。
- en: 'Finally, let''s have a look at the complete tally of CPU usage:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看一下CPU使用的完整统计：
- en: '![](img/13db11e2-8cf2-4deb-849d-d83e05492654.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/13db11e2-8cf2-4deb-849d-d83e05492654.png)'
- en: 'Here are some noteworthy items from the preceding screenshot:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是从前面的屏幕截图中的几个值得注意的项目：
- en: The ISR for this implementation is using 0.34% of the CPU (instead of 1.56%
    when each character was pushed to a queue from inside the ISR).
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个实现，ISR使用了CPU的0.34%（而不是在ISR内部将每个字符推入队列时的1.56%）。
- en: The FreeRTOS scheduler is using only using 0.06% of the CPU instead of 0.94%
    (each time items are added to queues, the scheduler runs to determine whether
    or not tasks should be unblocked because of the addition).
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FreeRTOS调度器现在只使用CPU的0.06%，而不是0.94%（每次向队列添加项目时，调度器都会运行以确定是否应该解除任务阻塞）。
- en: The frequency of the USART2 ISR remains at 960 Hz, exactly the same as the previous
    examples, but now the frequency of the `print` task has been reduced to only 60
    Hz, since the `uartPrint` task that only runs after 16 bytes has been transferred
    into `rxBuff`.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: USART2 ISR的频率保持在960 Hz，与之前的例子完全相同，但现在`print`任务的频率已经降低到只有60 Hz，因为只有当16个字节被传输到`rxBuff`后，`uartPrint`任务才会运行。
- en: As we can see, this ISR implementation of the driver uses even fewer CPU cycles
    than the queue-based approach. Depending on the use case, it can be an attractive
    alternative. These types of drivers are commonly found in non-RTOS-based systems,
    where callback functions will be used instead of semaphores. This approach is
    flexible enough to be used with or without an RTOS by placing a semaphore in the
    callback. While slightly more complex, this is one of the most flexible approaches
    for code bases that see a large amount of reuse in different applications.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这个驱动程序的ISR实现比基于队列的方法使用的CPU周期更少。根据使用情况，它可能是一个有吸引力的替代方案。这类驱动程序通常在非RTOS（实时操作系统）系统中找到，其中回调函数将用于代替信号量。这种方法足够灵活，可以通过在回调中放置一个信号量来与或没有RTOS一起使用。虽然稍微复杂一些，但这对于代码库来说，是看到大量不同应用中重用的一种最灵活的方法。
- en: 'To summarize, the two variants of drivers implemented with an ISR so far have
    been the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，到目前为止，使用ISR实现的两种驱动程序变体如下：
- en: '**A queue-based driver**: Delivers incoming data to tasks by pushing received
    data into a queue one character at a time.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于队列的驱动程序**：通过逐个字符将接收到的数据推入队列，将传入的数据传递给任务。'
- en: '**A buffer-based driver**: Delivers incoming data to a single buffer that is
    pre-allocated by the calling function.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于缓冲区的驱动程序**：将传入的数据传递给由调用函数预先分配的单个缓冲区。'
- en: On the surface, it may seem silly to have two different implementations that
    both take incoming data from a peripheral and present it to the higher layers
    of code. It is important to realize these two different variants of a driver for
    the same hardware vary both in their implementation, efficiency, and ultimately,
    the interface provided to higher-level code. They may both be moving bytes from
    the UART peripheral, but they provide higher-level code with drastically different
    programming models.  These different programming models are each suited to solving
    different types of problems.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，似乎很荒谬，有两个不同的实现，它们都从外围设备接收传入的数据并将其呈现给代码的更高层。重要的是要认识到，对于同一硬件的这两种不同的驱动程序变体，在实现、效率和最终提供给更高层代码的接口方面都存在差异。它们可能都在从UART外围设备移动字节，但它们为更高层代码提供了截然不同的编程模型。这些不同的编程模型各自适合解决不同类型的问题。
- en: Next, we'll look at how another piece of hardware inside the MCU can be used
    to lighten the burden on the CPU when moving large amounts of data.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何使用MCU内部的另一块硬件来减轻在移动大量数据时CPU的负担。
- en: Creating DMA-based drivers
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基于DMA的驱动程序
- en: We saw that, compared to a polled approach, the interrupt-based driver is considerably
    better in terms of CPU utilization. But what about applications with a high data
    rate that require millions of transfers per second? The next step in improved
    efficiency can be obtained by having the CPU involved as little as possible by
    pushing most of the work for transferring data around onto specialized peripheral
    hardware within the MCU.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，与轮询方法相比，基于中断的驱动程序在CPU利用率方面有相当大的改进。但对于需要每秒数百万次传输的高数据率应用程序呢？通过尽可能少地让CPU参与，将大部分数据传输工作推到MCU内的专用外设硬件上，可以进一步提高效率的下一步。
- en: A short introduction to DMAwas covered in [Chapter 2](84f04852-827d-4e79-99d7-6c954ba3e93c.xhtml),
    *Understanding RTOS Tasks*, in case you need a refresher before diving into this
    example.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](84f04852-827d-4e79-99d7-6c954ba3e93c.xhtml) *理解RTOS任务* 中简要介绍了DMA，以防在深入研究此示例之前需要复习。
- en: In this example, we'll work through creating a driver using the same buffer-based
    interface as the interrupt-based driver. The only difference will be the use of
    DMA hardware to transfer bytes out of the peripheral's read data register (`RDR`)
    and into our buffer. Since we already have a good handle on configuring the USART2
    peripheral from our other drivers, the first order of business for this variant
    is to figure out how to get data from `USART2->RDR` to the DMA controller and
    then into memory.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将通过创建一个使用与基于中断的驱动程序相同的基于缓冲区的接口的驱动程序来操作。唯一的区别将是使用DMA硬件将字节从外设的读取数据寄存器（`RDR`）传输到我们的缓冲区。由于我们已经很好地掌握了从其他驱动程序配置USART2外设，因此这个变体的首要任务是找出如何将数据从`USART2->RDR`传输到DMA控制器，然后进入内存。
- en: Configuring DMA peripherals
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置DMA外设
- en: 'STM32F767 has two DMA controllers. Each controller has 10 channels and 8 streams
    to map DMA requests from one location in the MCU to another. On the STM32F767
    hardware, streams can do the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: STM32F767有两个DMA控制器。每个控制器有10个通道和8个流，用于将DMA请求从MCU的一个位置映射到另一个位置。在STM32F767硬件上，流可以执行以下操作：
- en: Can be thought of as a way to *flow* data from one address to another
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将其视为从地址到地址的*流动*数据的方式
- en: Can transfer data from peripherals to RAM or RAM to peripherals
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在从外设到RAM或从RAM到外设之间传输数据
- en: Can transfer data from RAM to RAM
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在RAM之间传输数据
- en: Can only transfer data between two points at any given moment in time
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只能在任何给定时刻在两点之间传输数据
- en: 'Each stream has up to 10 channels for mapping a peripheral register into a
    given stream. In order to configure the DMA controller to handle requests from
    the USART2 `receive`, we''ll reference table 27 from the *STM32F7xx **RM0410* reference
    manual:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 每个流最多有10个通道，用于将外设寄存器映射到给定的流。为了配置DMA控制器以处理USART2的接收请求，我们将参考*STM32F7xx RM0410*参考手册中的表27：
- en: '![](img/a36bd6b0-a7a7-423d-aa0b-30625a0871e0.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a36bd6b0-a7a7-423d-aa0b-30625a0871e0.png)'
- en: In this table, we can see that DMA1 Channel 4, Stream 5 is the appropriate setup
    to use to handle requests from `USART2_RX`. If we were also interested in handling
    requests for the transmit side, Channel 4, Stream 6 would also need to be set
    up.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表中，我们可以看到DMA1通道4，流5是处理`USART2_RX`请求的适当设置。如果我们还对处理发送端的请求感兴趣，通道4，流6也需要设置。
- en: 'Now that we know the channel and stream numbers, we can add some initialization
    code to set up the DMA1 and USART2 peripherals:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了通道和流号，我们可以添加一些初始化代码来设置DMA1和USART2外设：
- en: '`DMA1_Stream5` will be used to transfer data from the `receive` data register
    of USART2 directly into a buffer in RAM.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DMA1_Stream5` 将用于将USART2的接收数据寄存器中的数据直接传输到RAM中的缓冲区。'
- en: '`USART2` will not have interrupts enabled (they are not needed since DMA will
    perform all transfers from the peripheral register to RAM).'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USART2` 不会启用中断（因为DMA将执行所有从外设寄存器到RAM的传输）。'
- en: '`DMA1_Stream5` will be set up to trigger an interrupt after the entire buffer
    has been filled.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DMA1_Stream5` 将配置为在缓冲区完全填满后触发中断。'
- en: 'The next few snippets are from the `setupUSART2DMA` function in `Chapter_10/src/mainUartDMABuff.c`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的几个片段来自`Chapter_10/src/mainUartDMABuff.c`中的`setupUSART2DMA`函数：
- en: 'First, the clock to the DMA peripheral is enabled, interrupt priorities are
    set up, and the interrupts are enabled in the NVIC:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，启用DMA外设的时钟，设置中断优先级，并在NVIC中启用中断：
- en: '[PRE15]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, the DMA stream is configured by filling out a `DMA_HandleTypeDef` struct
    (`usart2DmaRx`) and using `HAL_DMA_Init()`:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过填写一个 `DMA_HandleTypeDef` 结构（`usart2DmaRx`）并使用 `HAL_DMA_Init()` 来配置DMA流：
- en: '[PRE16]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`HAL` initialization provides some sanity checking on the values passed to
    it. Here''s a highlight of the most immediately relevant portions:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`HAL` 初始化对其传递的值提供一些合理性检查。以下是最直接相关的部分：'
- en: '`DMA1_Stream5` is set as the instance. All calls that use the `usart2DmaRx`
    struct will reference stream `5`.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `DMA1_Stream5` 设置为实例。所有使用 `usart2DmaRx` 结构体的调用都将引用流 `5`。
- en: Channel `4` is attached to stream `5`.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道 `4` 连接到流 `5`。
- en: Memory incrementing is enabled. The DMA hardware will automatically increment
    the memory address after a transfer, filling the buffer.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用内存递增。DMA 硬件将在传输后自动递增内存地址，填充缓冲区。
- en: The peripheral address is not incremented after each transfer—the address of
    the USART2 receive data register (`RDR`) doesn't ever change.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次传输后不递增外设地址——USART2 接收数据寄存器 (`RDR`) 的地址永远不会改变。
- en: The `transfer complete` interrupt is enabled for `DMA1_Stream5`.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `DMA1_Stream5` 启用 `传输完成` 中断。
- en: USART2 is set up for `DMA receive mode`. It is necessary to set this bit in
    the USART peripheral configuration to signal that the peripheral's receive register
    will be mapped to the DMA controller.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: USART2 已设置为 `DMA 接收模式`。在 USART 外设配置中设置此位是必要的，以表示外设的接收寄存器将被映射到 DMA 控制器。
- en: Additional details about how this struct is used can be found by looking at
    the `DMA_HandleTypeDef` struct definition in `stm32f7xx_hal_dma.h` (line 168)
    and `HAL_DMA_Init()` in `stm32f7xx_hal_dma.c` (line 172). Cross-reference the
    registers used by the HAL code with section 8 (page 245) in the *STM32F76xxx RM0410*
    reference manual. This same technique is often most productive for understanding *exactly*
    what the `HAL` code is doing with individual function parameters and struct members.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何使用此结构体的更多详细信息，可以通过查看 `stm32f7xx_hal_dma.h` 中的 `DMA_HandleTypeDef` 结构体定义（第
    168 行）和 `stm32f7xx_hal_dma.c` 中的 `HAL_DMA_Init()`（第 172 行）来找到。将 HAL 代码使用的寄存器与
    *STM32F76xxx RM0410* 参考手册的第 8 节（第 245 页）进行交叉引用。这种相同的技术通常对于理解 `HAL` 代码如何使用单个函数参数和结构体成员是非常有效的。
- en: Now that the initial DMA configuration is done, we can explore a few different
    interrupt implementations using DMA instead of interrupts.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在初始 DMA 配置已完成，我们可以探索一些不同的中断实现，使用 DMA 而不是中断。
- en: A buffer-based driver with DMA
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于缓冲区的 DMA 驱动程序
- en: 'Here''s an implementation of a driver with identical functionality to the one
    in the *A buffer-based driver* section. The difference is the DMA version of the
    driver doesn''t interrupt the application every time a byte is received. The only
    `interrupt` generated is when the entire transfer is complete. To realize this
    driver, we only need to add the following ISR:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个具有与 *A 缓冲区驱动程序* 部分中相同功能的驱动程序实现。区别在于，DMA 版本的驱动程序在每次接收到字节时不会中断应用程序。唯一生成的 `中断`
    是当整个传输完成时。为了实现此驱动程序，我们只需要添加以下中断服务例程（ISR）：
- en: '[PRE17]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The significant portions of the driver are in bold. If a reception is in progress
    (based on the value of `rxInProgress` and the transmit complete flag, `DMA_HISR_TCIF5`,
    the following takes place:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序的重要部分已加粗。如果接收正在进行中（基于 `rxInProgress` 的值和传输完成标志 `DMA_HISR_TCIF5`），则以下操作发生：
- en: The DMA interrupt flag is cleared.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清除 DMA 中断标志。
- en: The `rxDone` semaphore is given.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送 `rxDone` 信号量。
- en: This is all that is required when using DMA-based transfers since the DMA controller
    does all of the bookkeeping associated with the buffer. At this point, the rest
    of the code functions in an identical way to the `interrupt` version (the only
    difference is that less CPU time is spent servicing interrupts).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用基于 DMA 的传输时，这已经足够了，因为 DMA 控制器处理与缓冲区相关的所有账目。此时，其余代码的功能与 `中断` 版本完全相同（唯一的区别是服务中断所花费的
    CPU 时间更少）。
- en: Performance analysis
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能分析
- en: 'Let''s take a look at the performance of the DMA-based implementation compared
    to the interrupt-driven approach:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较基于 DMA 的实现与中断驱动方法的性能：
- en: '![](img/ff5bfae7-0dec-4e40-9edb-58d00bcffe90.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ff5bfae7-0dec-4e40-9edb-58d00bcffe90.png)'
- en: 'This time around, we can make the following observations about the overall
    system behavior:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们可以对整体系统行为做出以下观察：
- en: The (DMA) ISR is now consuming < 0.1% of CPU cycles at 9,600 baud.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (DMA) 中断服务例程现在在 9,600 波特率下消耗的 CPU 周期小于 0.1%。
- en: The Scheduler CPU's consumption is still very low.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调度器 CPU 的消耗仍然非常低。
- en: The frequency of the ISR has been reduced to only 60 Hz (from 960 Hz). This
    is because, rather than creating an interrupt for every byte, there is only an
    interrupt generated at the end of the transfer of 16 bytes. The Idle task is being
    context-switched significantly less often as well. Although it seems trivial with
    these simple examples, excessive context-switching can become a very real problem
    in large applications with many tasks and interrupts.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ISR的频率已降低到仅60赫兹（从960赫兹）。这是因为，而不是为每个字节创建一个中断，只有在16字节传输结束时才生成一个中断。空闲任务也被上下文切换得少得多。虽然在这些简单的示例中这似乎微不足道，但在具有许多任务和中断的大型应用程序中，过多的上下文切换可能成为一个非常真实的问题。
- en: 'The overall flow is similar to that of the interrupt buffer-based approach,
    with the only difference being that there is only a single ISR executed when the
    entire transfer is complete (instead of one interrupt for each byte transferred):'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 整体流程与基于中断缓冲区的方法相似，唯一的区别在于，当整个传输完成时，只有一个中断服务例程（ISR）被执行（而不是每个字节传输一个中断）：
- en: '![](img/99336104-c2df-4bba-9049-a32f2313ccf2.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/99336104-c2df-4bba-9049-a32f2313ccf2.png)'
- en: 'From the preceding screenshot, we can observe the following:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的屏幕截图，我们可以观察到以下情况：
- en: The DMA ISR is executed once (after all 16 bytes are transferred into the buffer).
    A semaphore is shown by the tick mark that arrow 1 is pointing to in the screenshot.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMA ISR在所有16字节传输到缓冲区后执行一次。截图中的箭头1所指的标记显示了信号量。
- en: The ISR wakes up the blocked `uartPrint` function. Arrow 2 is pointing to where
    the semaphore is taken.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ISR唤醒了阻塞的`uartPrint`函数。箭头2指向了在截图中所指的信号量被获取的地方。
- en: The two i infoboxes show where the console print messages are generated (~35
    and 40 us after the final byte has been received). The remainder of the time this
    task spends is on re-initializing the buffer and setting up the next transfer.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个信息框显示控制台打印消息生成的地方（在最后一个字节接收后约35和40微秒）。其余时间这个任务花在重新初始化缓冲区和设置下一次传输上。
- en: 'Here is a wider view of all of the processor activity. Notice that the only
    activity occurs approximately once every 16 ms (after all the bytes have been
    transferred into memory):'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是所有处理器活动的更宽视角。请注意，唯一的活动大约每16毫秒发生一次（在所有字节都传输到内存之后）：
- en: '![](img/2c06339b-87a6-4308-90c0-cca4b32f7e05.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2c06339b-87a6-4308-90c0-cca4b32f7e05.png)'
- en: The real capability of a fully DMA-based approach is most valuable when transferring
    large amounts of data very quickly. The following example shows the same dataset
    (only 16 bytes) transferred at 256,400 baud (the fastest that could be reliably
    achieved without error due to poor signal integrity).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 基于完全DMA方法的实际能力在快速传输大量数据时最为宝贵。以下示例显示了相同的数据集（仅16字节）以256,400波特率（在没有错误的情况下可靠实现的最快速度）进行传输。
- en: The baud rate can be easily changed in the examples by modifying `#define BAUDRATE`  in
    `main<exampleame>.c`. They are configured so that a single change will modify
    both the USART2 and UART4 baud rates.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，可以通过修改`main<exampleame>.c`中的`#define BAUDRATE`来轻松更改波特率。它们被配置为单个更改将修改USART2和UART4的波特率。
- en: 'The following is an example of transfers being made at 256,000 baud. A new
    set of 16 bytes is available in the buffer, approximately every 624 µS:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在256,000波特率下进行传输的示例。缓冲区中每624微秒就可用一组新的16字节：
- en: '![](img/9903f26b-f4aa-4047-a4d1-90c6f33ebf80.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9903f26b-f4aa-4047-a4d1-90c6f33ebf80.png)'
- en: 'By increasing the baud rate from 9,600 to 256,000, our CPU usage has increased
    from around 0.5% to around 11%. This is in line with the 26x increase in baud
    rate—all of the function''s calls are proportionate to the baud rate:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将波特率从9,600提高到256,000，我们的CPU使用率从大约0.5%增加到大约11%。这与波特率26倍的提高相一致——所有函数调用都与波特率成比例：
- en: '![](img/09e72b29-d689-42e0-b687-40eacf3fe51e.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/09e72b29-d689-42e0-b687-40eacf3fe51e.png)'
- en: 'Notice the following:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下情况：
- en: The DMA interrupt consumes 2.29%.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DMA中断消耗了2.29%。
- en: Our `uartPrint` task is the highest consumer of CPU cycles (a little over 6%).
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的`uartPrint`任务是CPU周期的最大消费者（略超过6%）。
- en: Even though we've proved to ourselves that it is possible to efficiently transfer
    data quickly by using DMA, this current setup doesn't have the same convenience
    that the interrupt-driven queue solution did. Tasks rely on entire blocks to be
    transferred, rather than using a queue. This might be fine or might be an inconvenience,
    depending on what the goals of the higher-level code are.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经证明使用DMA可以快速高效地传输数据，但当前的设置并没有中断驱动的队列解决方案那样的便利性。任务依赖于整个块的传输，而不是使用队列。这可能是合适的，也可能是不便的，这取决于高级代码的目标。
- en: Character-based protocols will tend to be easier to implement when written on
    top of a queue-based driver API, rather than a buffer-based driver API (such as
    the one we've implemented here). However, we saw in the *Queue-based driver* section
    that queues become computationally expensive very quickly. Each byte took around
    30 us to be added to the queue. Transferring data at 256,000 baud would consume
    most of the available CPU in the UART ISR alone (a new byte is received every
    40 us and it takes 30 us to process).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 当基于队列的驱动API而不是基于缓冲区的驱动API（如我们在这里实现的）编写基于字符的协议时，通常会更容易实现。然而，我们在*基于队列的驱动*部分看到，队列很快就会变得计算成本高昂。每个字节被添加到队列中大约需要30微秒。以256,000波特率传输数据将消耗掉UART中断服务例程（ISR）中大部分可用的CPU（每个40微秒接收一个新字节，处理它需要30微秒）。
- en: In the past, if you really needed to implement a character-oriented driver,
    you could roll your own highly efficient ring buffer implementation and feed it
    directly from low-level ISRs (bypassing most of the FreeRTOS primitives to save
    time).  However, as of FreeROTS 10, there is another alternative—stream buffers.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，如果你真的需要实现一个面向字符的驱动程序，你可以自己实现一个高度高效的环形缓冲区实现，并直接从低级ISR中提供（绕过大多数FreeRTOS原语以节省时间）。然而，从FreeROTS
    10开始，还有一个替代方案——流缓冲区。
- en: Stream buffers (FreeRTOS 10+)
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流缓冲区（FreeRTOS 10+）
- en: Stream buffers combine the convenience of a queue-based system with the speed
    closer to that of the raw buffer implementations we created previously. They have
    some flexibility limitations that are similar to the limitations of task notification
    systems compared to semaphores. *Stream buffers can only be used by one sender
    and one receiver at a time.* Otherwise, they'll need external protection (such
    as a mutex), if they are to be used by multiple tasks.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 流缓冲区结合了基于队列系统的便利性和与我们之前创建的原始缓冲区实现相近的速度。它们有一些灵活性限制，这些限制与任务通知系统与信号量相比的限制相似。*流缓冲区一次只能由一个发送者和一个接收者使用。*
    否则，如果它们要被多个任务使用，将需要外部保护（例如互斥锁）。
- en: The programming model for stream buffers is very similar to queues, except that
    instead of functions being limited to queueing one item at a time, they can queue
    multiple items at a time (which saves considerable CPU time when queuing blocks
    of data). In this example, we'll explore stream buffers through an efficient DMA-based
    circular buffer implementation for UART reception.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 流缓冲区的编程模型与队列非常相似，除了函数不是每次限制于排队一个项目，而是可以一次排队多个项目（这在排队数据块时可以节省大量的CPU时间）。在这个例子中，我们将通过UART接收的高效DMA环形缓冲区实现来探索流缓冲区。
- en: 'The goals of this driver example are the following:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 本驱动程序示例的目标如下：
- en: Provide an easy-to-use character-based queue for users of the driver.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为驱动程序的用户提供一个易于使用的基于字符的队列。
- en: Maintain efficiency at high data rates.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在高数据速率下保持效率。
- en: Always be ready to receive data.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是准备好接收数据。
- en: So, let's begin!
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧！
- en: Using the stream buffer API
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用流缓冲区API
- en: First, let's take a look at an example of how the stream buffer API will be
    used by `uartPrintOutTask` in this example. The following excerpts are from `mainUartDMAStreamBufferCont.c`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看在这个例子中`uartPrintOutTask`如何使用流缓冲区API的示例。以下摘录来自`mainUartDMAStreamBufferCont.c`。
- en: 'Here''s a look at the definition of `xSttreamBufferCreate()`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`xSttreamBufferCreate()`函数定义的示例：
- en: '[PRE18]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Note the following in the preceding code:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下前述代码中的内容：
- en: '`xBufferSizeBytes` is the number of bytes the buffer is capable of holding.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xBufferSizeBytes`是缓冲区能够容纳的字节数。'
- en: '`xTriggerLevelBytes` is the number of bytes that need to be available in the
    stream before a call to `xStreamBufferReceive()` will return (otherwise, a timeout
    will occur).'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xTriggerLevelBytes`是在调用`xStreamBufferReceive()`之前需要在流中可用的字节数（否则，将发生超时）。'
- en: 'The following example code sets up a stream buffer:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码设置了一个流缓冲区：
- en: '[PRE19]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding snippet, we can observe the following:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们可以观察到以下内容：
- en: '`rxStream` is capable of holding `NUM_BYTES` (100 bytes).'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rxStream`能够容纳`NUM_BYTES`（100字节）。'
- en: Each time a task blocks data from being added to the stream, it won't be unblocked
    until at least `MIN_NUM_BYTES` (2 bytes) are available in the stream. In this
    example, calls to `xStreamBufferReceive` will block until a minimum of 2 bytes
    are available in the stream (or a timeout occurs).
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次任务阻止数据被添加到流中时，它将不会解除阻塞，直到流中至少有`MIN_NUM_BYTES`（2字节）可用。在这个例子中，对`xStreamBufferReceive`的调用将阻塞，直到流中至少有2字节可用（或者发生超时）。
- en: If using the FreeRTOS heap, be sure to check that there is enough space for
    the allocation of the stream buffer by checking the returned handle isn't `NULL`.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用FreeRTOS堆，请确保通过检查返回的句柄是否为`NULL`来确认有足够的空间用于分配流缓冲区。
- en: 'The function for receiving data from a stream buffer is `xStreamBufferReceive()`:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 从流缓冲区接收数据的函数是`xStreamBufferReceive()`：
- en: '[PRE20]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here is a straightforward example of receiving data from a stream buffer:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个从流缓冲区接收数据的简单示例：
- en: '[PRE21]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding snippet, note the following:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，请注意以下内容：
- en: '`rxStream`: The pointer/handle to `StreamBuffer`.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rxStream`：`StreamBuffer`的指针/句柄。'
- en: '`rxBufferedData`: The local buffer that bytes will be copied into.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rxBufferedData`：字节将被复制到的本地缓冲区。'
- en: '`maxBytesReceived`: The maximum number of bytes that will be copied into `rxBufferedData`.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxBytesReceived`：将复制到`rxBufferedData`中的最大字节数。'
- en: The timeout is `100` ticks (`xStreamBufferReceive()` will return after at least
    `xTriggerLevelBytes` (`2` in this example) are available or 100 ticks have elapsed).
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超时是`100`个滴答（`xStreamBufferReceive()`将在至少`xTriggerLevelBytes`（在这个例子中是`2`）可用或100个滴答已过之后返回）。
- en: Calls to `xStreamBufferReceive()` behave in a similar way to a call to `xQueueReceive()` in
    that they both block until data is available. However, a call to `xStreamBufferReceive()` will
    block until the minimum number of bytes (defined when calling `xStreamBufferCreate()`) or
    the specified number of ticks has elapsed.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 对`xStreamBufferReceive()`的调用行为与对`xQueueReceive()`的调用类似，它们都会在数据可用时阻塞。然而，对`xStreamBufferReceive()`的调用将阻塞，直到最小数量的字节（在调用`xStreamBufferCreate()`时定义）或指定的滴答数已过。
- en: 'In this example, the call to `xStreamBufferReceive()` blocks until one of the
    following conditions is met:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，对`xStreamBufferReceive()`的调用将阻塞，直到以下条件之一满足：
- en: The number of bytes in the buffer exceeds `MIN_NUM_BYTES` (`2` in this example).
    If more bytes are available, they will be moved into `rxBufferedData`—but only
    up to the `maxBytesReceived` bytes (`16` in this example).
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲区中的字节数超过了`MIN_NUM_BYTES`（在这个例子中是`2`）。如果还有更多的字节可用，它们将被移动到`rxBufferedData`——但不超过`maxBytesReceived`字节（在这个例子中是`16`）。
- en: A timeout occurs. All available bytes in the stream are moved into `rxBufferedData` . 
    The exact number of bytes placed into `rxBufferedData` is returned by `xStreamBuffereReceive() -` ( `0`
    or `1` in this example).
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发生超时。流中的所有可用字节都移动到`rxBufferedData`。`xStreamBuffereReceive()`返回放置到`rxBufferedData`中的确切字节数（在这个例子中是`0`或`1`）。
- en: Now that we have a good idea of what the receiving side looks like, let's look
    at some of the details of the driver itself.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经对接收方有了很好的了解，让我们来看看驱动程序本身的某些细节。
- en: Setting up double-buffered DMA
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置双缓冲DMA
- en: As we saw earlier, using DMA can be very beneficial for reducing CPU usage (versus
    interrupts). However, one of the features that wasn't covered in the last example
    was continuously populating a queue (the driver required block-based calls to
    be made before data could be received). The driver in this example will transfer
    data into the stream buffer constantly, without requiring any intervention from
    the code calling it. That is, the driver will always be receiving bytes and pushing
    them into the stream buffer.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，使用DMA可以非常有益于减少CPU使用率（相对于中断）。然而，上一个例子中没有涵盖的一个特性是持续填充队列（驱动程序需要在进行数据接收之前进行基于块的调用）。在这个例子中的驱动程序将不断将数据传输到流缓冲区，而不需要调用它的代码进行任何干预。也就是说，驱动程序将始终接收字节并将它们推入流缓冲区。
- en: 'Always receiving data presents two interesting problems for a DMA-based system:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于DMA的系统，持续接收数据会带来两个有趣的问题：
- en: How to deal with **roll-over**—when a buffer has been completely filled and
    high-speed data could still be coming in.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理**溢出**——当缓冲区已完全填满，但高速数据仍然可以进入时。
- en: How to terminate transfers before a buffer is completely filled. DMA transfers
    typically require the number of bytes to be specified before the transfer starts.
    However, we need a way to stop the transfer when data has stopped being received
    and copy that data into the stream buffer.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在缓冲区完全填满之前终止传输。DMA传输通常需要在传输开始之前指定字节数。然而，我们需要一种方法在数据停止接收时停止传输，并将该数据复制到流缓冲区。
- en: 'DMA double buffering will be used to ensure our driver will always be able
    to accept data (even when a single buffer has been filled). In the previous example,
    a single buffer was filled and an interrupt was generated, then the data was operated
    on directly before restarting the transfer. With double buffering, a second buffer
    is added. After the DMA controller fills the first buffer, it automatically starts
    filling the second buffer:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用DMA双缓冲来确保我们的驱动程序始终能够接收数据（即使单个缓冲区已被填满）。在先前的例子中，一个缓冲区被填满并生成中断，然后直接操作数据，在重新启动传输之前。使用双缓冲，添加第二个缓冲区。在DMA控制器填满第一个缓冲区后，它将自动开始填充第二个缓冲区：
- en: '![](img/02139e92-a978-4408-b468-da094f33ff01.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](img/02139e92-a978-4408-b468-da094f33ff01.png)'
- en: After the first buffer is filled and the interrupt is generated, the ISR can
    safely operate on data in the first buffer, `rxData1`, while the second buffer, `rxData2`,
    is filled. In our example, we're transferring that data into the FreeRTOS stream
    buffer from inside the ISR.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个缓冲区被填满并生成中断后，ISR可以安全地操作第一个缓冲区`rxData1`中的数据，同时第二个缓冲区`rxData2`被填满。在我们的例子中，我们是在ISR内部将数据传输到FreeRTOS流缓冲区。
- en: 'It is important to note that `xStreamBufferSendFromISR()` adds a *copy* of
    the data to the stream buffer, not a reference. So, in this example, as long as
    the DMA ISR''s call to `xStreamBufferSendFromISR()` executes before `rxData2` has
    been filled, data will be available with no loss. This is unlike traditional **bare-metal**
    double-buffer implementations since higher-level code making calls to `xStreamBufferReceive() ` isn''t
    required to extract data from `rxData1` before  `rxData2` is filled. It only needs
    to call `xStreamBufferReceive()` before the stream buffer has been filled:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`xStreamBufferSendFromISR()`会将数据的**副本**添加到流缓冲区，而不是引用。因此，在这个例子中，只要DMA
    ISR对`xStreamBufferSendFromISR()`的调用在`rxData2`被填满之前执行，数据就可以无损失地可用。这与传统的**裸机**双缓冲实现不同，因为不需要调用`xStreamBufferReceive()`的高级代码从`rxData1`中提取数据，在`rxData2`被填满之前：
- en: '![](img/17705c53-8c3d-4ee4-8bd1-494fa6b123eb.png)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![](img/17705c53-8c3d-4ee4-8bd1-494fa6b123eb.png)'
- en: Even if you're programming for an MCU without an explicit **double-buffer mode**,
    most DMA controllers will have a **circular** mode with **half-transfer** and
    **full-transfer** interrupts. In this case, the same functionality can be achieved
    by generating an interrupt after each half of the buffer is filled.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你在为没有明确**双缓冲模式**的MCU编程，大多数DMA控制器也将具有**循环**模式，包括**半传输**和**全传输**中断。在这种情况下，可以通过在每个缓冲区的一半被填满后生成一个中断来达到相同的功能。
- en: 'The secondary buffer, `rxData2`, is set up by writing its address to the `DMA_SxM1AR`
    register (some casting is required to keep the compiler from complaining too loudly
    that we''re writing a pointer to a 32-bit memory address):'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将地址写入`DMA_SxM1AR`寄存器（需要一些类型转换以防止编译器大声抱怨我们在写入一个指向32位内存地址的指针）来设置二级缓冲区`rxData2`：
- en: '[PRE22]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Interestingly enough, STM HAL doesn''t support double-buffer mode directly.
    In fact, calls to `HAL_DMA_Start` explicitly disable the mode. So, some manual
    setup with registers is required (after letting `HAL` take care of most of the
    leg work):'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 很有趣的是，STM HAL不直接支持双缓冲模式。实际上，对`HAL_DMA_Start`的调用会明确禁用该模式。因此，需要通过寄存器进行一些手动设置（在`HAL`处理大部分基础工作之后）：
- en: '[PRE23]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: After the DMA stream is enabled, the UART is enabled, which will start transfers
    (this is identical to the previous examples).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在DMA流启用后，UART被启用，这将开始传输（这与前面的示例相同）。
- en: Populating the stream buffer
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充流缓冲区
- en: 'The stream buffer will be populated from inside the DMA ISR:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 流缓冲区将由DMA中断服务例程（ISR）内部填充：
- en: '[PRE24]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here are some of the more noteworthy items in this ISR:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个ISR中，有一些值得注意的项目：
- en: '`if(rxInProgress && (DMA1->HISR & DMA_HISR_TCIF5))`: This line guards against
    the stream buffer being written to before the scheduler is started. Even if the
    ISR was to execute before the scheduler was started, `rxInProgress` wouldn''t
    be true until after everything was initialized. Checking the transmit complete
    flag, `DMA_HISR_TCIF5`, guarantees that a transfer has, indeed, completed (rather
    than entering the ISR because of an error).'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if(rxInProgress && (DMA1->HISR & DMA_HISR_TCIF5))`：这一行防止在调度器启动之前写入流缓冲区。即使ISR在调度器启动之前执行，`rxInProgress`也不会为真，直到一切初始化完成。检查传输完成标志`DMA_HISR_TCIF5`可以确保确实完成了一次传输（而不是因为错误而进入ISR）。'
- en: '`DMA1_Stream5->CR & DMA_SxCR_CT`: Checks the current target bit. Since this
    bit indicates which target buffer (`DMA_SxM0AR`  or `DMA_SxM1AR`) is currently
    being **filled** by the DMA controller, we''ll take the other and push that data
    into the stream buffer.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DMA1_Stream5->CR & DMA_SxCR_CT`：检查当前目标位。由于此位指示DMA控制器当前正在填充哪个目标缓冲区（`DMA_SxM0AR`或`DMA_SxM1AR`），我们将选择另一个并推入流缓冲区。'
- en: The call to `xStreamBufferSendFromISR` pushes the entirety of `rxBuff1` or `rxBuff2` (each
    of an `RX_BUFF_LEN` length) into `rxStream` in one go.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xStreamBufferSendFromISR`的调用一次将`rxBuff1`或`rxBuff2`（每个长度为`RX_BUFF_LEN`）的全部内容推入`rxStream`。'
- en: 'A few things to remember are as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住以下几点：
- en: Data is being transferred to the stream by value (not reference). That is, FreeRTOS
    is using `memcpy` to make a copy of all of the data moving into the stream buffer
    (and again when removing data). The larger the buffer, the more time it will take
    to copy—additional RAM will also be used.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据是通过值（而非引用）传输到流中的。也就是说，FreeRTOS正在使用`memcpy`来复制所有移动到流缓冲区的数据（在移除数据时再次复制）。缓冲区越大，复制所需的时间就越长——还会使用额外的RAM。
- en: Instead of performing the copy inside the interrupt, under certain circumstances,
    it may be preferable to signal a semaphore or task notification and perform the
    copy in a high-priority task instead—for example, if a large buffer is being filled.
    However, you'll need to guarantee that other interrupts don't starve the task
    performing the `xStreamBufferSend` or data will be lost.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些情况下，而不是在中断内部执行复制，可能更倾向于发出信号量或任务通知，并在高优先级任务中执行复制——例如，如果正在填充大缓冲区。然而，你需要保证其他中断不会使执行`xStreamBufferSend`的任务饿死，否则数据将会丢失。
- en: There are trade-offs when using DMA. Larger buffers mean fewer interruptions
    to transfer data, but they also mean an increase in latency. The larger the buffer,
    the longer the data will sit in the buffer before being processed.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用DMA时存在权衡。更大的缓冲区意味着更少的数据传输中断，但同时也意味着延迟的增加。缓冲区越大，数据在缓冲区中停留的时间就越长，直到被处理。
- en: This implementation is only well suited to continuous data streams—if the data
    stream stops, the last DMA transfer will never complete.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此实现仅适用于连续数据流——如果数据流停止，最后的DMA传输将永远不会完成。
- en: This approach to pushing received data from a peripheral into memory works very
    well when data is continuously streaming. It can also work extremely well for
    the reception of messages with a known number of bytes. However, there are some
    ways to improve it.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 将从外围设备推送到内存中的数据的方法在数据连续流式传输时效果非常好。它也可以在接收已知字节数的消息时表现得极为出色。然而，还有一些方法可以改进它。
- en: Improving the stream buffer
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进流缓冲区
- en: 'In order to deal with an intermittent data stream, there are two possible approaches
    (for this specific setup):'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理间歇性数据流，有两种可能的方法（针对此特定设置）：
- en: The USART peripheral on this MCU is capable of detecting an "idle line" and
    generating an interrupt by setting the `USART_CR1:IDLEE` bit when an idle line
    is detected.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此MCU上的USART外围设备能够检测到“空闲线”，并在检测到空闲线时通过设置`USART_CR1:IDLEE`位来生成中断。
- en: The USART peripheral also has a `receive` timeout that can also generate an
    interrupt after no start bits have been detected for a specified number of bit
    times (0-16,777,215).
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: USART外围设备还有一个`接收`超时，可以在检测到指定数量的位时间（0-16,777,215）内没有检测到起始位后生成中断。
- en: This timeout is specified in the `USART_RTOR:RTO[23:0]` register.
  id: totrans-369
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此超时在`USART_RTOR:RTO[23:0]`寄存器中指定。
- en: The feature can be enabled with `USART_CR2:RTOEN` and the interrupts can be
    enabled with  `USART_CR1:RTOIE`.
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该功能可以通过`USART_CR2:RTOEN`启用，并且可以通过`USART_CR1:RTOIE`启用中断。
- en: Either of these features could be used to generate a USART interrupt, cut the
    DMA transfer short, and transfer the data to the stream buffer.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个功能都可以用来生成USART中断，缩短DMA传输，并将数据传输到流缓冲区。
- en: For extremely high baud rates, care needs to be taken when using the idle line
    approach because the number of interrupts generated is only capped by the baud
    rate. If there is inter-character spacing (idle time between each character being
    sent), you'll wind up with an interrupt-driven approach (with even more overhead
    than normal).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 对于极高的波特率，在使用空闲线路方法时需要格外小心，因为产生的中断数量仅受波特率限制。如果存在字符间间隔（每个发送字符之间的空闲时间），你将得到一个中断驱动的方案（比正常情况有更多的开销）。
- en: On the other hand, using the `receive` timeout feature means additional latency
    before processing the incoming data. As usual, there is no *one-size-fits-all* solution
    here.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用`接收`超时功能意味着在处理传入数据之前会有额外的延迟。通常，这里没有一种“一刀切”的解决方案。
- en: Analyzing the performance
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析性能
- en: 'So, how does this DMA stream buffer implementation compare to the ISR-based
    queue implementation? Well, on one hand, there is no comparison... *the ISR based
    implementation doesn''t work at 256,400 baud*. At this baud rate, a new character
    is received every 39 uS. With the ISR taking around 18 us to execute, we simply
    don''t have enough time to also run `printUartTask()` reliably without dropping
    data:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这种DMA流缓冲区实现与基于ISR的队列实现相比如何？好吧，一方面，没有比较……基于ISR的实现无法在256,400波特率下工作。在这个波特率下，每个字符的接收间隔为39
    uS。由于ISR的执行大约需要18 us，我们根本无法在丢弃数据的情况下可靠地运行`printUartTask()`：
- en: '![](img/a06c4874-d4bf-439c-ad97-ae7f348fc6ed.png)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a06c4874-d4bf-439c-ad97-ae7f348fc6ed.png)'
- en: Notice that there is absolutely no time spent on the Idle task—the CPU is completely
    consumed by attempting to keep up with the incoming data from UART2.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在空闲任务上绝对没有花费时间——CPU完全被尝试跟上UART2传入的数据所消耗。
- en: 'As you can see in the following screenshot, data is occasionally dropped when
    the processor is set up to receive data at 256,400 baud using an ISR that executes
    once per character:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下屏幕截图所示，当处理器设置为使用每字符执行一次的中断在256,400波特率接收数据时，数据偶尔会丢失：
- en: '![](img/b455799d-dae7-45c5-8b44-5b0a964e9d05.png)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b455799d-dae7-45c5-8b44-5b0a964e9d05.png)'
- en: 'Now, for comparison, here''s the (nearly) equivalent implementation using stream
    buffers and DMA:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了比较，这里是用流缓冲区和DMA实现的（几乎）等效实现：
- en: '![](img/c7c73613-e70d-4ef6-bcd9-679451cc9d15.png)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7c73613-e70d-4ef6-bcd9-679451cc9d15.png)'
- en: 'The combination of stream buffers and DMA has freed up quite a bit of the CPU
    time; the queue-based ISR implementation consumed > 100% of the CPU. As we can
    see in the following processing breakdown, the total CPU usage for a stream buffer
    using DMA is around 10%:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 流缓冲区和DMA的组合释放了相当多的CPU时间；基于队列的中断服务例程（ISR）实现消耗了>100%的CPU。正如以下处理分解所示，使用DMA的流缓冲区的总CPU使用率约为10%：
- en: '![](img/32c61441-bf2d-4c51-8527-25d5e6805684.png)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![](img/32c61441-bf2d-4c51-8527-25d5e6805684.png)'
- en: 'Note the following:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下内容：
- en: The DMA-/stream buffer-based solution leaves nearly 90% of the CPU cycles available
    for other tasks.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于DMA/流缓冲区的解决方案几乎为其他任务留下了90%的CPU周期。
- en: More time is being spent printing debug statements (and pulling bytes off the
    queue) than servicing the DMA ISR.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花在打印调试语句（和从队列中取出字节）上的时间比服务DMA ISR的时间要多。
- en: The multi-byte stream buffer transactions also eliminate a large amount of context
    switching (notice the scheduler is only utilizing around 1% CPU), which will leave
    more contiguous time for other processing tasks.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多字节流缓冲区事务还消除了大量的上下文切换（注意调度器只利用了大约1%的CPU），这将为其他处理任务留下更多连续的时间。
- en: So, now that we've worked through a very simple example of each driver type,
    which one should you implement?
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经处理了每种驱动类型的非常简单的示例，那么你应该实现哪一个呢？
- en: Choosing a driver model
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择驱动器模型
- en: 'Selecting the *best* driver for a given system depends on several different
    factors:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 选择给定系统的*最佳*驱动器取决于几个不同的因素：
- en: How is the calling code designed?
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用代码是如何设计的？
- en: How much delay is acceptable?
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以接受多少延迟？
- en: How fast is data moving?
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据移动有多快？
- en: What type of device is it?
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是什么类型的设备？
- en: Let's answer these questions one by one.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一回答这些问题。
- en: How is the calling code designed?
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用代码是如何设计的？
- en: What is the intended design of higher-level code using the driver? Will it operate
    on individual characters or bytes as they come in? Or does it make more sense
    for the higher-level code to batch transfers into blocks/frames of bytes?
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 使用驱动器的高级代码的预期设计是什么？它将操作传入的每个字符或字节吗？或者，对于高级代码来说，将传输批量到字节的块/帧中更有意义吗？
- en: 'Queue-based drivers are very useful when dealing with unknown amounts (or streams)
    of data that can come in at any point in time. They are also a very natural fit
    for code that processes individual bytes—`uartPrintOutTask` was a good example
    of this:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 基于队列的驱动程序在处理未知数量（或流）的数据时非常有用，这些数据可以在任何时间点到来。它们也非常适合处理单个字节的代码——`uartPrintOutTask`就是一个很好的例子：
- en: '[PRE25]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: While ring-buffer implementations (such as the one in the preceding code) are
    perfect for streamed data, other code naturally gravitates toward operating on
    blocks of data. Say, for example, our high-level code is meant to read in one
    of the structures defined in [Chapter 9](495bdcc0-2a86-4b22-9628-4c347e67e49e.xhtml), *Intertask
    Communication*, over a serial port.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然环形缓冲区实现（如前述代码中的实现）非常适合流数据，但其他代码自然倾向于操作数据块。例如，如果我们的高级代码旨在通过串行端口读取[第9章](495bdcc0-2a86-4b22-9628-4c347e67e49e.xhtml)中定义的结构之一，即*任务间通信*：
- en: 'The following excerpt is from `Chapter_9/MainQueueCompositePassByValue.c`:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 以下摘录来自`Chapter_9/MainQueueCompositePassByValue.c`：
- en: '[PRE26]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Rather than operate on individual bytes, it is very convenient for the receiving
    side to pull in an instance of the entire struct at once. The following code is
    designed to receive an entire copy of `LedStates_t` from a queue. After the struct
    is received, it can be operated on by simply referencing members of the struct,
    such as checking `redLEDState`, in this example:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 与操作单个字节相比，接收方一次性拉取整个结构体的实例要方便得多。以下代码旨在从队列中接收`LedStates_t`的整个副本。在接收到结构体之后，可以通过引用结构体的成员来操作它，例如在这个例子中检查`redLEDState`：
- en: '[PRE27]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This can be accomplished by **serializing** the data structure and passing
    it over the communication medium. Our `LedStates_t` struct can be serialized as
    a block of 5 bytes. All three red, green, and blue state values can be packed
    into 3 bits of a byte and the delay time will take 4 bytes:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过**序列化**数据结构并将其通过通信介质传递来实现。我们的`LedStates_t`结构可以序列化为5字节的块。所有三个红色、绿色和蓝色状态值都可以打包到一个字节的3位中，延迟时间将占用4字节：
- en: '![](img/9a624631-0150-4a45-986d-39bf6189d06c.png)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9a624631-0150-4a45-986d-39bf6189d06c.png)'
- en: Serialization is a broad topic in itself. There are trade-offs to be made for
    portability, ease of use, code fragility, and speed. A discussion on all of these
    points is outside the scope of this chapter. Details of endianness and the *best*
    way of serializing/deserializing this particular data structure have been purposely
    ignored in the diagram. The main takeaway is that the struct can be represented
    by a block of 5 bytes.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化本身是一个广泛的话题。在可移植性、易用性、代码脆弱性和速度之间需要做出权衡。关于所有这些点的讨论超出了本章的范围。关于端序和**最佳**序列化/反序列化此特定数据结构的方法的细节已被故意忽略在图中。主要收获是，结构体可以用5字节的块来表示。
- en: 'In this case, it makes sense for the underlying peripheral driver to operate
    on a buffer of 5 bytes, so a buffer-based approach that groups a transfer into
    a block of 5 bytes is more natural than a stream of bytes. The following pseudo-code
    outlines an approach based on the buffer-based driver we wrote in the previous
    section:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，底层外设驱动程序以5字节为一个缓冲区进行操作是有意义的，因此将传输分组为5字节的缓冲区方法比字节流更自然。以下伪代码概述了基于我们在上一节中编写的基于缓冲区的驱动程序的方案：
- en: '[PRE28]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In a situation like the previous one, we have covered two different approaches
    that can provide efficient implementations:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在类似前述情况的情况下，我们已经介绍了两种可以提供高效实现的不同方法：
- en: A buffer-based driver (receiving 5 bytes at a time)
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于缓冲区的驱动程序（每次接收5字节）
- en: A stream buffer (the receiving side can be configured to acquire 5 bytes at
    a time)
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流缓冲区（接收方可以配置为每次获取5字节）
- en: FreeRTOS message buffers could also be used instead of a stream buffer to provide
    a more flexible solution. Message buffers are built on top of stream buffers,
    but have a more flexible blocking configuration. They allow different message
    sizes to be configured per `receive` call, so the same buffer can be used to group
    receptions into a size of 5 bytes (or any other desired size) each time `xMessageBufferReceive`
    is called. With stream buffers, the message size is rigidly defined when creating
    the stream buffer by setting the `xTriggerLevelBytes` parameter in `xStreamBufferCreate`. 
    Unlike stream buffers, message buffers will only return full messages, not individual
    bytes.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: FreeRTOS 消息缓冲区也可以用来代替流缓冲区，以提供更灵活的解决方案。消息缓冲区建立在流缓冲区之上，但具有更灵活的阻塞配置。它们允许在每次`receive`调用时配置不同的消息大小，因此相同的缓冲区可以用来将接收分组为每次5字节（或任何其他所需大小）。在使用流缓冲区的情况下，消息大小在创建流缓冲区时通过设置`xStreamBufferCreate`中的`xTriggerLevelBytes`参数而被严格定义。与流缓冲区不同，消息缓冲区将只返回完整的消息，而不是单个字节。
- en: How much delay is acceptable?
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可以接受多少延迟？
- en: Depending on the exact function being implemented, minimal delay may be desired.
    In this case, buffer-based implementations can sometimes have a slight advantage.
    They allow the calling code to be set up as an extremely high priority, without
    causing significant context switching in the rest of the application.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 根据要实现的特定功能，可能需要最小的延迟。在这种情况下，基于缓冲区的实现有时可能具有轻微的优势。它们允许调用代码被设置为极高的优先级，而不会在应用程序的其他部分引起显著的任务上下文切换。
- en: With a buffer-based setup, after the last byte of a message is transferred,
    the task will be notified and immediately run. This is better than having the
    high-priority task perform byte-wise parsing of the message since it will be interrupting
    other tasks continually each time a byte is received. In a byte-wise queue-based
    approach, the task waiting on the queue would need to be set to a very high priority
    if the incoming message was extremely important. This combination causes quite
    a bit of task context switching versus a buffer approach, which only has a single
    semaphore (or direct task notification) when the transfer is finished.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于缓冲区的设置中，消息的最后一个字节传输完成后，任务将被通知并立即运行。这比让高优先级任务进行字节解析消息要好，因为它会在每次接收到一个字节时不断中断其他任务。在基于字节的队列方法中，如果传入的消息非常重要，等待队列的任务需要被设置为非常高的优先级。这种组合与缓冲区方法相比，会导致相当多的任务上下文切换，因为缓冲区方法在传输完成后只有一个信号量（或直接任务通知）。
- en: Sometimes, timing constraints are so tight neither queues nor an entire block
    transfer may be acceptable (bytes might need to be processed as they come in).
    This approach will sometimes eliminate the need for intermediate buffers as well.
    A fully custom ISR can be written in these cases, but it won't be easily reused.
    Try to avoid lumping **business logic** (application-level logic not immediately
    required for servicing the peripheral) into ISRs whenever possible. It complicates
    testing and reduces code reuse. After a few months (or years) of writing code
    like this, you'll likely notice that you've got dozens of ISRs that look *almost* the
    same but behave in subtlety different ways, which can make for buggy systems when
    modifications to higher-level code are required.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，时间约束非常严格，既不能接受队列，也不能接受整个块传输（字节可能需要随着接收到来进行处理）。这种方法有时还会消除对中间缓冲区的需求。在这些情况下，可以编写一个完全定制的ISR，但它不容易重用。尽可能避免将**业务逻辑**（非立即用于服务外设的应用级逻辑）放入ISR中。这会复杂化测试并减少代码重用。在编写了几个月（或几年）这样的代码之后，你可能会发现你已经有几十个看起来几乎相同但行为略有不同的ISR，这在需要修改高级代码时可能会造成有缺陷的系统。
- en: How fast is data moving?
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据移动有多快？
- en: While extremely convenient, queues are a fairly expensive way to pass individual
    bytes around a system. Even an interrupt-based driver has limitations on how long
    it has to deal with incoming data. Our example used a meager 9,600 baud transfer.
    Individual characters were transferred into the queue within 40 us of being received,
    but what happens if the baud rate is 115,200 baud? Now, instead of having around
    1 character per millisecond, each character would need to be added to the queue
    in less than 9 us. A driver that takes 40 us per interrupt isn't going to be acceptable
    here, so using a simple queue approach isn't a viable option.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然非常方便，但队列是传递单个字节在系统中的相当昂贵的方式。即使基于中断的驱动程序也有处理传入数据的时间限制。我们的例子使用了9600波特率的传输。字符在被接收后40微秒内被传输到队列中，但波特率是115,200波特时会发生什么？现在，每个字符需要在不低于9微秒内添加到队列中。每个中断需要40微秒的驱动程序在这里是不可接受的，因此使用简单的队列方法不是一个可行的选项。
- en: We saw that the stream buffer implementation with DMA was a viable solution
    in place of a queue. Using some type of double-buffering technique for high-speed,
    continuous streams of data is critical. This becomes an especially convenient technique
    when coupled with a highly efficient RTOS primitive, such as stream buffers or
    message buffers.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，使用DMA的流缓冲区实现是队列的可行替代方案。对于高速、连续的数据流，使用某种类型的双缓冲技术至关重要。当与高度有效的RTOS原语（如流缓冲区或消息缓冲区）结合使用时，这成为了一种特别方便的技术。
- en: Interrupts and DMA-based drivers that moved data directly into a **raw** memory
    buffer are also quite viable when speeds are high, but they don't have the convenience
    of a queue-like interface.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 当速度较高时，基于中断和DMA的驱动程序将数据直接移动到**原始**内存缓冲区也是相当可行的，但它们没有队列-like界面的便利性。
- en: What type of device are you interfacing?
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你正在与哪种类型的设备接口？
- en: Some peripherals and external devices will naturally lean toward one implementation
    or another. When receiving asynchronous data, queues are a fairly natural choice
    because they provide an easy mechanism for constantly capturing incoming data. UARTs,
    USB virtual comms, network streams, and timer captures are all very naturally
    implemented with a byte-wise queue implementation (at least at the lowest level).
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 一些外围设备和外部设备会自然倾向于一种或另一种实现。在接收异步数据时，队列是一个相当自然的选择，因为它们提供了一个易于捕获不断传入数据的机制。UARTs、USB虚拟串行通信、网络流和定时器捕获都自然地使用字节级队列实现（至少在最低级别）。
- en: Synchronous-based devices, such as a **serial peripheral interface** (**SPI**)
    and **Inter-Integrated Circuit** (**I2C**), are easily implemented with block-based
    transfers on the master side since the number of bytes is known ahead of time (the
    master needs to supply the clock signal for both bytes sent and bytes received).
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 基于同步的设备，如**串行外设接口**（**SPI**）和**集成电路间**（**I2C**），由于事先知道字节数，因此在主侧使用基于块的传输很容易实现（主需要提供发送和接收的字节所需的时钟信号）。
- en: When to use queue-based drivers
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用基于队列的驱动程序
- en: 'Here are some cases where it is an advantage to use a queue as the interface
    of a driver:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些使用队列作为驱动程序接口的优势案例：
- en: When the peripheral/application needs to receive data of an unknown length
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当外围/应用程序需要接收未知长度的数据时
- en: When data must be received asynchronously to requests
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当数据必须异步接收请求时
- en: When a driver should receive data from multiple sources without blocking the
    caller
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当驱动程序应该从多个来源接收数据而不阻塞调用者时
- en: When data rates are sufficiently slow to allow a minimum of 10's of µS per interrupt
    (when being implemented on the hardware, in this example)
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当数据速率足够慢，允许每个中断至少有10的微秒（当在硬件上实现时，例如这个例子）
- en: When to use buffer-based drivers
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用基于缓冲区的驱动程序
- en: 'Some cases where raw buffer-based drivers are extremely useful are as follows:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些原始缓冲区驱动程序极其有用的案例：
- en: When large buffers are required because large amounts of data will be received
    at once
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要大缓冲区时，因为将一次性接收大量数据
- en: During transaction-based communication protocols, especially when the length
    of the received data is known in advance
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基于事务的通信协议期间，尤其是在事先知道接收到的数据长度时
- en: When to use stream buffers
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用流缓冲区
- en: Stream buffers provide speed closer to that of raw buffers, but with the added
    benefit of providing an efficient queue API. They can generally be used anywhere
    a standard queue would be used (as long as there is only one consumer task). Stream
    buffers are also efficient enough to be used in place of raw buffers, in many
    cases. As we saw in the `mainUartDMAStreamBufferCont.c` example, they can be combined
    with circular DMA transfers to provide true continuous data capture, without using
    a significant number of CPU cycles.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 流缓冲区提供的速度接近原始缓冲区，但增加了提供高效队列API的好处。它们通常可以在标准队列会被使用的地方使用（只要只有一个消费者任务）。流缓冲区在许多情况下也足够高效，可以替代原始缓冲区。正如我们在`mainUartDMAStreamBufferCont.c`示例中看到的那样，它们可以与循环DMA传输结合使用，提供真正的连续数据捕获，而不需要使用大量的CPU周期。
- en: These are just some of the considerations you'll likely face when creating drivers;
    they are mainly aimed at communication peripherals (since that's what our examples
    covered). There are also some considerations to be made when choosing to use third-party
    libraries and drivers.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是你在创建驱动程序时可能会遇到的一些考虑因素；它们主要针对通信外设（因为我们的示例涵盖了这一点）。在选择使用第三方库和驱动程序时，也有一些考虑因素需要考虑。
- en: Using third-party libraries (STM HAL)
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用第三方库（STM HAL）
- en: 'If you''ve been following along closely, you may have noticed a few things:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直密切关注，你可能已经注意到了一些事情：
- en: STM HAL (the vendor-supplied hardware abstraction layer) is used for initial
    peripheral configuration. This is because HAL does a very good job of making peripheral
    configuration easy. It is also extremely convenient to use tools such as STM Cube
    to generate some boilerplate code as a point of reference when first interacting
    with a new chip.
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STM HAL（供应商提供的硬件抽象层）用于初始外设配置。这是因为HAL在使外设配置变得容易方面做得非常好。使用STM Cube等工具生成一些模板代码作为参考，以便首次与新型芯片交互时也非常方便。
- en: 'When it is time to implement details of interrupt-driven transactions, we''ve
    been making a lot of calls directly to MCU peripheral registers, rather than letting
    HAL manage transactions for us. There were a couple of reasons for this:'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要实现中断驱动的交易细节时，我们一直直接调用MCU外设寄存器，而不是让HAL为我们管理交易。这样做有几个原因：
- en: We wanted to be closer to the hardware to get a better understanding of how
    things were really working in the system.
  id: totrans-442
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望更接近硬件，以便更好地理解系统中的实际工作方式。
- en: Some of the setups weren't directly supported by HAL, such as DMA double buffering.
  id: totrans-443
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些设置没有得到HAL的直接支持，例如DMA双缓冲。
- en: In general, you should use as much vendor-supplied code as you (or your project/company)
    are comfortable with. If the code is well written and works reliably, then there
    *usually* aren't too many arguments for *not* using it.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你应该使用你（或你的项目/公司）感到舒适的供应商提供的代码量。如果代码编写良好且工作可靠，那么通常没有太多理由不使用它。
- en: 'That being said, here are some potential issues when using vendor-supplied
    drivers:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，以下是在使用供应商提供的驱动程序时可能遇到的一些潜在问题：
- en: They may use polling instead of interrupts or DMA.
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可能使用轮询而不是中断或DMA。
- en: Tying into interrupts may be cumbersome or inflexible.
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其与中断绑定可能很繁琐或不灵活。
- en: There is potentially *lots* of extra overhead since many chips/use cases are
    likely covered by drivers (they need to solve *everyone's* problems, not just
    yours).
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能会有很多额外的开销，因为许多芯片/用例可能已经被驱动程序覆盖（它们需要解决**每个人的**问题，而不仅仅是你的）。
- en: It might take longer to fully grasp and understand a complex API than working
    directly with the peripheral hardware (for simple peripherals).
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全掌握和理解复杂的API可能比直接与外设硬件工作（对于简单的外设）需要更长的时间。
- en: 'The following are examples of when to write **bare-metal** drivers:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些编写**裸机**驱动程序的例子：
- en: When a vendors driver is broken/buggy
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当供应商的驱动程序出现故障/有错误时
- en: When speed matters
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当速度很重要时
- en: When an exotic configuration is required
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要特殊配置时
- en: As a learning exercise
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为学习练习
- en: Ideally, transitioning between third-party drivers and your own drivers would
    be perfectly seamless. If it isn't, it means that the higher-level code is tightly
    coupled to the hardware. This tight coupling is perfectly acceptable for sufficiently
    small *one-off* and *throw-away* projects, but if you're attempting to develop
    a code base for the long term, investing in creating a loosely coupled architecture
    will pay dividends. Having loose coupling (eliminating dependencies between the
    exact driver implementation and higher-level code) also provides flexibility in
    the implementation of the individual components. Loose coupling ensures transitioning
    between custom drivers and third-party drivers doesn't necessitate a major rewrite
    of high-level code. Loose coupling also makes testing small portions of the code
    base in isolation possible—see [Chapter 12](8e78a49a-1bcd-4cfe-a88f-fb86a821c9c7.xhtml)*,
    Tips on Creating Well-Abstracted Architecture*, for details.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，在第三方驱动程序和您自己的驱动程序之间切换应该是无缝的。如果不是这样，这意味着高级代码与硬件紧密耦合。这种紧密耦合对于足够小的*一次性*和*废弃*项目来说是完全可以接受的，但如果您试图长期开发代码库，投资于创建松散耦合的架构将会有回报。拥有松散耦合（消除精确驱动程序实现与高级代码之间的依赖关系）也为单个组件的实现提供了灵活性。松散耦合确保在自定义驱动程序和第三方驱动程序之间切换不需要对高级代码进行重大重写。松散耦合还使得在隔离状态下测试代码库的小部分成为可能——有关详细信息，请参阅[第12章](8e78a49a-1bcd-4cfe-a88f-fb86a821c9c7.xhtml)*，创建良好抽象架构的技巧*。
- en: Summary
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we introduced three different ways of implementing low-level
    drivers that interface with hardware peripherals in the MCU. Interrupts and polled-
    and DMA-based drivers were all covered through examples and their performance
    was analyzed and compared using SEGGER SystemView. We also covered three different
    ways that FreeRTOS can interact with ISRs: semaphores, queues, and stream buffers.
    Considerations for choosing between the implementation options were also discussed,
    as well as when it is appropriate to use third-party peripheral drivers (STM HAL)
    and when "rolling your own" is best.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了三种实现低级驱动程序的方法，这些驱动程序与MCU中的硬件外设接口。通过示例涵盖了中断、轮询和基于DMA的驱动程序，并使用SEGGER
    SystemView分析了它们的性能并进行比较。我们还介绍了FreeRTOS与ISRs交互的三个不同方式：信号量、队列和流缓冲区。还讨论了选择实现选项的考虑因素，以及何时使用第三方外设驱动程序（STM
    HAL）以及何时“自行开发”最佳。
- en: To get the most out of this chapter, you're encouraged to run through it on
    actual hardware. The development board was chosen (in part) with the hope that
    you might have access to Arduino shields. After running through the examples,
    an excellent next step would be to develop a driver for a shield or another piece
    of real-world hardware.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用本章内容，我们鼓励您在实际硬件上运行它。开发板的选择（部分原因）是希望您可能能够访问Arduino外壳。在运行示例之后，下一步的绝佳步骤是开发一个外壳或另一件实际硬件的驱动程序。
- en: This chapter was really just the tip of the iceberg when it comes to driver
    implementation. There are many additional approaches and techniques that can be
    used when creating efficient implementations, from using different RTOS primitives
    beyond what is presented in this chapter to configuring MCU-specific functionality.
    Your designs don't need to be limited by what happens to be provided by a vendor.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到驱动程序实现时，本章只是冰山一角。在创建高效实现时，可以使用许多额外的方法和技巧，从使用本章未展示的不同RTOS原语到配置MCU特定的功能。您的设计不需要受限于供应商提供的功能。
- en: You should now have a solid understanding of the many different ways low-level
    drivers can be implemented. In the next chapter, we'll take a look at how these
    drivers can be safely presented to higher-level code across multiple tasks. Providing
    easy access to drivers makes developing the final application fast and flexible.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该对低级驱动程序的不同实现方式有了稳固的理解。在下一章中，我们将探讨如何将这些驱动程序安全地跨多个任务呈现给高级代码。提供驱动程序的便捷访问使得开发最终应用程序变得快速灵活。
- en: Questions
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    of this chapter''s material. You will find the answers in the *Assessments* section
    of the appendix:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们总结之际，这里有一份问题列表，供您测试对本章内容的理解。您将在附录的*评估*部分找到答案：
- en: What type of driver is more complicated to write and use?
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种类型的驱动程序编写和使用的难度更大？
- en: Polled
  id: totrans-464
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轮询
- en: Interrupt-driven
  id: totrans-465
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中断驱动
- en: 'True or false: In FreeRTOS, it is possible to call any RTOS function from any
    ISR?'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断对错：在FreeRTOS中，是否可以从任何中断服务例程（ISR）中调用任何RTOS函数？
- en: 'True'
  id: totrans-467
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是
- en: 'False'
  id: totrans-468
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否
- en: 'True or false: When using an RTOS, interrupts are constantly fighting the scheduler
    for CPU time?'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断对错：在使用实时操作系统（RTOS）时，中断始终在与调度器争夺CPU时间？
- en: 'True'
  id: totrans-470
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是
- en: 'False'
  id: totrans-471
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否
- en: Which technique for a peripheral driver requires the fewest CPU resources when
    transferring large amounts of high-speed data?
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在传输大量高速数据时，哪种外围设备驱动技术需要的CPU资源最少？
- en: Polling
  id: totrans-473
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 投票
- en: Interrupt
  id: totrans-474
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中断
- en: DMA
  id: totrans-475
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: DMA
- en: What does DMA stand for?
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMA代表什么？
- en: Name one case when using a raw buffer-based driver is *not* a good idea.
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举一个使用基于原始缓冲区的驱动程序不是好主意的情况。
- en: Further reading
  id: totrans-478
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Chapter 4* in the *RM0410 STM32F76xxx* reference manual (*USART*)'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RM0410 STM32F76xxx*参考手册的*第4章*（*USART*）'
- en: B1.5.4, **Exception priorities and preemption** section in the *Arm®v7-M Architecture*
    reference manual
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: B1.5.4，在*Arm®v7-M Architecture*参考手册的**异常优先级和抢占**部分
- en: FreeRTOS.org's explanation of CortexM priorities, at [https://www.freertos.org/RTOS-Cortex-M3-M4.html](https://www.freertos.org/RTOS-Cortex-M3-M4.html)
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FreeRTOS.org对CortexM优先级的解释，见[https://www.freertos.org/RTOS-Cortex-M3-M4.html](https://www.freertos.org/RTOS-Cortex-M3-M4.html)
