- en: Collision Detection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: Right now, our spaceships can fly around and shoot at each other, but nothing
    happens.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的太空飞船可以四处飞行并互相射击，但没有发生任何事情。
- en: '**Collision detection** is used in the vast majority of video games to determine
    whether game objects intersect. There are a large number of methods for detecting
    collisions between different game objects. Various methods can work better in
    different situations. There is also a trade-off between the amount of computation
    time and how accurate our collision detection will be.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**碰撞检测**在绝大多数视频游戏中用于确定游戏对象是否相交。有许多方法可以检测不同游戏对象之间的碰撞。不同的方法在不同情况下可能效果更好。在计算时间和我们的碰撞检测的准确性之间也存在权衡。'
- en: 'You will need to include several images in your build to make this project
    work. Make sure you include the `/Chapter07/sprites/` folder from the project''s
    GitHub. If you haven''t yet downloaded the GitHub project, you can get it online
    here: [https://github.com/PacktPublishing/Hands-On-Game-Develop](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly)[ment-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在构建中包含几个图像才能使此项目工作。确保您包含了项目的GitHub中的`/Chapter07/sprites/`文件夹。如果您还没有下载GitHub项目，可以在这里在线获取：[https://github.com/PacktPublishing/Hands-On-Game-Develop](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly)[ment-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly)。
- en: 'In this chapter, we will discuss the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下内容：
- en: Collision detection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: Collider objects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞器对象
- en: Types of colliders
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞器的类型
- en: Adding colliders to our game objects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向我们的游戏对象添加碰撞器
- en: Types of 2D collision detection
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2D碰撞检测类型
- en: I could write an entire book on the kinds of 2D collision detection available
    to us, let alone the number available for collision detection in 3D. I have written
    several TypeScript tutorials on how to use different detection techniques, both
    basic and sophisticated at [https://www.embed.com/typescript-games/basic-collision-detection.html](https://www.embed.com/typescript-games/basic-collision-detection.html),
    but, in this book, we will stick to using a combination of some of the more basic
    collision techniques.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以写一本关于我们可以使用的各种2D碰撞检测方法的书，更不用说3D碰撞检测的数量了。我已经在[https://www.embed.com/typescript-games/basic-collision-detection.html](https://www.embed.com/typescript-games/basic-collision-detection.html)上写了几篇TypeScript教程，介绍了如何使用不同的检测技术，包括基本的和复杂的，但在这本书中，我们将坚持使用一些更基本的碰撞技术的组合。
- en: Circle collision detection
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 圆形碰撞检测
- en: 'The most basic kind of collision detection is **circle** or **distance** collision
    detection. If we treat all of our colliders like little circles with a radius
    and a position, we can calculate the distance between the two locations and see
    whether that distance is less than the sum of our radii. This form of collision
    detection is high-speed, but precision is limited. If you look at the projectile
    in our game, this method works pretty well. Our spaceships, on the other hand,
    don''t fit neatly into a circle. We can adjust the radius of our circle collider
    on any given ship to give slightly different results. When circle collision detection
    works, it can be very efficient:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的碰撞检测是**圆形**或**距离**碰撞检测。如果我们把所有的碰撞器都看作是带有半径和位置的小圆圈，我们可以计算两个位置之间的距离，并查看该距离是否小于我们半径的总和。这种形式的碰撞检测速度很快，但精度有限。如果你看看我们游戏中的抛射物，这种方法效果还不错。另一方面，我们的太空飞船并不完全适合圆形。我们可以调整任何给定飞船的圆形碰撞器的半径，以获得略有不同的结果。当圆形碰撞检测有效时，它可以非常高效：
- en: '![](img/7d6fab86-e4bd-4a7c-9d6c-f8dcd049fe88.png)[Circle collision hit test]'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/7d6fab86-e4bd-4a7c-9d6c-f8dcd049fe88.png)[圆形碰撞检测]'
- en: Rectangle collision detection
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩形碰撞检测
- en: '**Rectangle** collision detection is another fast collision detection method.
    In many cases, it may be faster than circle collision detection. A rectangle collider
    is defined by an *x* and a *y* coordinate that is the position of the top left
    corner of our rectangle, as well as a width and a height. Detecting a rectangle
    collision is pretty straightforward. We look for an overlap on the *x* axis between
    the two rectangles. If there is an overlap on the *x* axis, we then look for an
    overlap on the *y* axis. If we have an overlap on both axes, there is a collision.
    This technique works pretty well for a lot of old-school video games. Several
    classic games released on the Nintendo Entertainment System used this method of
    collision detection. In the game we are writing, we are rotating our sprites,
    so using traditional non-oriented collision detection will not be useful for us.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**矩形**碰撞检测是另一种快速的碰撞检测方法。在许多情况下，它可能比圆形碰撞检测更快。矩形碰撞器由* x *和* y *坐标定义，这是我们矩形左上角的位置，以及宽度和高度。检测矩形碰撞非常简单。我们在*
    x *轴上寻找两个矩形之间的重叠。如果在* x *轴上有重叠，然后我们在* y *轴上寻找重叠。如果两个轴上都有重叠，就会发生碰撞。这种技术对许多老式视频游戏非常有效。在任天堂娱乐系统上发布的几款经典游戏使用了这种碰撞检测方法。在我们编写的游戏中，我们正在旋转我们的精灵，因此使用传统的非定向碰撞检测对我们来说没有用处。'
- en: A short refresher on trigonometry
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三角函数的简短复习
- en: At this point, our collision detection algorithms start to get a lot more complicated.
    You may remember some of the concepts from your high school trigonometry class,
    but some basic trigonometry is very important for many collision detection algorithms.
    Even our circle collision detection that we discussed earlier relies on the Pythagorean
    theorem, so, in reality, unless you are doing simple non-oriented rectangle collision
    detection, at least a tiny amount of trigonometry is required. Trigonometry is
    the study of triangles in mathematics. Most games use what's called a **Cartesian
    coordinate system**. If you're not familiar with that phrase, *Cartesian coordinate
    system* means we have a grid with an *x* and a *y* coordinate (for a 2D game).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们的碰撞检测算法开始变得更加复杂。你可能还记得一些高中三角学课程的概念，但一些基本的三角学对于许多碰撞检测算法非常重要。即使我们之前讨论的圆形碰撞检测也依赖于毕达哥拉斯定理，所以，实际上，除非你在进行简单的非定向矩形碰撞检测，至少需要一点三角学。三角学是数学中三角形的研究。大多数游戏使用所谓的**笛卡尔坐标系**。如果你对这个词不熟悉，*笛卡尔坐标系*意味着我们有一个带有*x*和*y*坐标的网格（对于2D游戏）。
- en: The word *Cartesian* means Rene Descartes invented it—the "*I think; therefore,
    I am"* guy who had a lot of great ideas in mathematics and a lot of stupid ideas
    in philosophy (ghost in the machine…yuck!).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*笛卡尔*这个词是由勒内·笛卡尔发明的——那个“我思故我在”的家伙，在数学上有很多伟大的想法，在哲学上有很多愚蠢的想法（机器中的幽灵…呸！）。'
- en: 'There are a few key concepts we have to remember from our trigonometry classes
    in high school, and they all have to do with right triangles. A right triangle
    is a triangle with a 90-degree angle in it. That is a handy thing when you''re
    working with a Cartesian coordinate system because your *x* and *y* axes happen
    to form a right angle so any line between two points that do not share either
    an *x* or a *y* coordinate could be considered the hypotenuse (long side) of a
    right triangle. There are a few ratios we also need to remember; they are as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须从高中的三角学课程中记住一些关键概念，它们都与直角三角形有关。直角三角形是一个内含90度角的三角形。当你使用笛卡尔坐标系时，这是一个方便的事情，因为你的*x*和*y*轴恰好形成一个直角，所以任何两点之间不共享*x*或*y*坐标的线都可以被视为直角三角形的斜边（长边）。我们还需要记住一些比率；它们如下：
- en: '*Sine - Y / Hypotenuse*'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*正弦 - Y / 斜边*'
- en: '*Cosine - X / Hypotenuse*'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*余弦 - X / 斜边*'
- en: '*Tangent - Y / X*'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*正切 - Y / X*'
- en: Do you remember SOHCAHTOA? (Pronounced "*Sock-Ah-Toe-Ah*")
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得SOHCAHTOA吗？（发音为“Sock-Ah-Toe-Ah”）
- en: 'That was meant to remind you of the following versions of the trigonometry
    ratios:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了提醒你记住三角比率的以下版本：
- en: '*Sine - Opposite / Hypotenuse*'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*正弦 - 对边 / 斜边*'
- en: '*Cosine - Adjacent / Hypotenuse*'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*余弦 - 邻边 / 斜边*'
- en: '*Tangent - Opposite / Adjacent*'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*正切 - 对边 / 邻边*'
- en: 'In this formulation, the *opposite* side of the triangle is the *y* axis, and
    the adjacent side of the triangle is the *x* axis. If you remember SOHCAHTOA,
    you may have an easier time remembering these ratios. If not, just open this book
    back up or use Google:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个公式中，三角形的*对边*是*y*轴，三角形的邻边是*x*轴。如果你记得SOHCAHTOA，你可能更容易记住这些比率。如果不记得，就重新翻开这本书或使用谷歌：
- en: '![](img/1b577127-7c70-4995-b1fc-94ff8c9025ff.png)[SOHCAHTOA]'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/1b577127-7c70-4995-b1fc-94ff8c9025ff.png)[SOHCAHTOA]'
- en: Some people have been taught the phrase "*Some Old Horse Came A-Hoppin' Through
    Our Alley."* I'm not sure if that is helpful. I find it more difficult to remember
    than SOHCAHTOA, but that's a matter of opinion. So, if imagining a horse that
    hops like a rabbit around some city's back alley is your bag, then, by all means,
    use that instead.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人被教导使用短语“*Some Old Horse Came A-Hoppin' Through Our Alley.*”我不确定这是否有帮助。我觉得比SOHCAHTOA更难记住，但这是一个观点问题。所以，如果想象一匹像兔子一样在某个城市的后巷里跳跃的马是你的菜，那么尽管使用那个。
- en: You may remember earlier in this book we used the angle the ship was rotated
    with the `sin` and `cos` math library functions to figure out how fast our ship
    was moving on the *x* axis and the *y* axis. Those functions return the ratio
    for a given angle.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得在本书的前面，我们使用了船舶旋转的角度和`sin`和`cos`数学库函数来计算我们的船在*x*轴和*y*轴上的移动速度。这些函数返回给定角度的比率。
- en: 'Another concept we need to know is the **dot product** between two **unit vectors**.
    A unit vector is a vector with a length of 1\. The dot product between two unit
    vectors is just the cosine of the angle between those two unit vectors. The closer
    the dot products are to 1, the closer the angle between the two vectors is to
    0 degrees. If the dot product is close to 0, the angles between the two vectors
    are close to 90 degrees, and if the dot product between the two angles is close
    to -1, the angle between the two vectors is near 180 degrees. Dot products between
    different vectors are very useful in both collision detection and in-game physics.
    Refer to the following diagram:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要知道的另一个概念是两个单位向量之间的**点积**。单位向量是长度为1的向量。两个单位向量之间的点积就是这两个单位向量之间的角的余弦。点积越接近1，两个向量之间的角度就越接近0度。如果点积接近0，两个向量之间的角度接近90度，如果两个角之间的点积接近-1，两个向量之间的角度接近180度。不同向量之间的点积在碰撞检测和游戏物理中非常有用。参考以下图表：
- en: '![](img/82871b59-db4d-4e5d-b1f9-62e36b1075f3.png)[The dot product of two normalized
    vectors]'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/82871b59-db4d-4e5d-b1f9-62e36b1075f3.png)[两个归一化向量的点积]'
- en: Line collision detection
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线碰撞检测
- en: So, the first thing we need to do is talk about the difference between a line
    and a line segment. We define a line using two points. That line continues after
    the points to infinity. A line segment terminates at the two points and does not
    continue indefinitely. Two lines that are not parallel will always intersect somewhere.
    Two non-parallel line segments may or may not intersect.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要做的第一件事是讨论线和线段之间的区别。我们使用两点来定义一条线。该线在点之后延伸到无穷大。线段在两点处终止，并且不会无限期地继续。不平行的两条线总会在某个地方相交。两条不平行的线段可能会相交，也可能不会相交。
- en: 'For the most part, in games, we are interested in knowing whether two line
    segments intersect:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，在游戏中，我们都对两条线段是否相交感兴趣：
- en: '![](img/b6e81faa-2b8e-49df-b571-e6f1037363e4.png)[Line versus line segment]'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/b6e81faa-2b8e-49df-b571-e6f1037363e4.png)[线与线段]'
- en: It is relatively easy to determine whether a line intersects with a line segment.
    All you have to do is see whether the two points of the line segments are on opposite
    sides of your line. Since a line is infinite, that means your line segment has
    to intersect with your line somewhere. If you want to find out whether two line
    segments intersect, you can do it in two stages. First, find out whether line
    segment A intersects with an infinite line B. If they do intersect, then find
    out whether line segment B intersects with the infinite line A. If this is true
    in both cases, the line segments intersect.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 确定一条线是否与线段相交相对容易。你所要做的就是看看线段的两个点是否在你的线的两侧。由于一条线是无限的，这意味着你的线段必须在某个地方与你的线相交。如果你想要找出两条线段是否相交，你可以分两个阶段来做。首先，找出线段A是否与无限线B相交。如果它们相交，那么找出线段B是否与无限线A相交。如果在这两种情况下都成立，那么线段相交。
- en: 'So, the next question is, how do we know mathematically whether two points
    are on the opposite sides of a line? To do that, we are going to use the previously
    discussed dot product and something called a **vector normal**. A vector normal
    is just a 90-degree rotated version of your vector. See the following diagram:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，下一个问题是，我们如何在数学上知道两点是否在一条线的对立面？为了做到这一点，我们将使用先前讨论过的点积和称为**向量法线**的东西。向量法线只是你的向量的一个90度旋转版本。请参阅以下图表：
- en: '![](img/4af90a66-08e0-48b0-9908-f3459639475b.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4af90a66-08e0-48b0-9908-f3459639475b.png)'
- en: A vector and that vector's normal
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一个向量及该向量的法线
- en: 'We also need the vector that has an origin at the same point but has a direction
    aiming at point 1 of our line segment. If the dot product of those two vectors
    is a positive value, that means the point is on the same side of the line as the
    normalized vector. If the dot product is a negative value, that means the point
    is on the opposite side of the line to our normal vector. If the line segment
    intersects, that means one point has a positive dot product and the other side
    has a negative dot product. Since multiplying two negative numbers and two positive
    numbers both give you a positive result and multiplying a negative and a positive
    number gives you a negative result, multiply the two dot products together and
    see whether the resulting value is negative. If it is, the line segment intersects
    with the line:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个向量，它的起点与同一点相同，但方向指向我们线段的第一个点。如果这两个向量的点积是一个正值，那么这意味着该点与归一化向量在同一侧。如果点积是一个负值，那么这意味着该点在与我们的法向量相反的一侧。如果线段相交，那么意味着一个点有一个正的点积，另一侧有一个负的点积。由于两个负数相乘和两个正数相乘都会得到一个正的结果，而一个负数和一个正数相乘会得到一个负的结果，将这两个点积相乘，看看结果值是否为负数。如果是，那么线段与线相交：
- en: '![](img/c0ad57a9-0d05-4ef3-a8bd-ffd8a4b47b63.png)[Determining whether two points
    are on the opposite side of a line]'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/c0ad57a9-0d05-4ef3-a8bd-ffd8a4b47b63.png)[确定两点是否在线的对立面]'
- en: Compound colliders
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复合碰撞器
- en: A **compound collider** is when a game object uses multiple colliders to determine
    whether there was a collision. We are going to use compound circle colliders on
    our ship to improve the accuracy of our ship collision detection while still providing
    the increased speed of using circle colliders. We will cover our player's ship
    and our enemy ship with three circles. Our projectiles are a circle shape, so
    using a circle for those is entirely natural. There is no reason you need to limit
    compound colliders to using only one shape of collider. Internally, a compound
    collider could mix circle colliders with rectangle colliders or any other type
    you like.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**复合碰撞器**是指游戏对象使用多个碰撞器来确定是否发生了碰撞。我们将在我们的飞船上使用复合圆形碰撞器，以提高我们飞船碰撞检测的准确性，同时仍然提供使用圆形碰撞器的增加速度。我们将用三个圆覆盖我们的玩家飞船和敌人飞船。我们的抛射物是圆形的，因此对于它们使用圆形是非常自然的。没有理由限制复合碰撞器只使用一种形状的碰撞器。在内部，复合碰撞器可以混合圆形碰撞器和矩形碰撞器，或者任何其他你喜欢的类型。'
- en: 'The following diagram shows a hypothetical compound collider made up of a circle
    and two rectangle colliders:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表显示了一个由圆和两个矩形碰撞器组成的假想化复合碰撞器：
- en: '![](img/8d0dbfbf-0bad-4e75-b06e-531557aea8f6.png)[A compound collider composed
    of three basic colliders]'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/8d0dbfbf-0bad-4e75-b06e-531557aea8f6.png)[由三个基本碰撞器组成的复合碰撞器]'
- en: In the next section, we will learn how to implement a basic circle collision
    detection algorithm.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何实现基本的圆形碰撞检测算法。
- en: Implementing circle collision detection
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现圆形碰撞检测
- en: 'We are going to start by implementing circle collision detection because it
    is the fastest collision detection method available. It also fits well with our
    projectiles, which will be the most common kind of collider in our game. It will
    not do a great job on our ships, but later, we can improve that situation by implementing
    a compound collider that will use multiple circle colliders for each spaceship
    instead of just one. Because we only have two spaceships, this will give us the
    best of both worlds in our collision detection: the speed of circle collision
    detection, along with the accuracy of some of our better collision detection methods.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从实现圆形碰撞检测开始，因为这是最快的碰撞检测方法。它也很适合我们的抛射物，这将是我们游戏中最常见的碰撞器。它对我们的飞船的效果不是很好，但是以后，我们可以通过实现一个复合碰撞器来改善这种情况，该碰撞器将为每艘飞船使用多个圆形碰撞器，而不仅仅是一个。因为我们只有两艘飞船，这将为我们的碰撞检测带来最佳的效果：圆形碰撞检测的速度，以及一些更好的碰撞检测方法的准确性。
- en: 'Let''s start by adding a `Collider` class definition into our `game.hpp` file
    and creating a new `collider.cpp` file where we can define the functions used
    by our `Collider` class. Here''s what our new `Collider` class will look like
    in the `game.hpp` file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先在`game.hpp`文件中添加一个`Collider`类定义，并创建一个新的`collider.cpp`文件，在其中我们可以定义`Collider`类使用的函数。以下是我们在`game.hpp`文件中新`Collider`类的样子：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is the code we are putting in the `collider.cpp` file:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们放在`collider.cpp`文件中的代码：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `Collider` class is a pretty simple circle collider. As we discussed earlier,
    a circle collider has an *x* and a *y* coordinate and a radius. The `HitTest`
    function does a pretty simple distance test to see whether the two circles are
    close enough to touch each other. We do this by squaring the *x* distance and
    squaring the *y* distance between the two colliders, which gives us the distance
    squared between the two points. We could take the square root to determine the
    actual distance, but a square root is a relatively slow function to perform, and
    it's much faster to square the sum of the radii to compare.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collider`类是一个相当简单的圆形碰撞器。正如我们之前讨论的，圆形碰撞器有一个*x*和*y*坐标以及一个半径。`HitTest`函数进行了一个相当简单的距离测试，以确定两个圆是否足够接近以触碰彼此。我们通过平方两个碰撞器之间的*x*距离和*y*距离来实现这一点，这给了我们两点之间的距离的平方。我们可以取平方根来确定实际距离，但平方根是一个相对较慢的函数，而平方两个半径的和进行比较要快得多。'
- en: 'We will also need to talk about class inheritance briefly. If you look back
    at our code from earlier, we have a `PlayerShip` class and an `EnemyShip` class.
    These classes share most of their attributes. They all have *x* and *y* coordinates,
    *x* and *y* velocity, and many other attributes that are identical. Many of the
    functions use the same code copied and pasted. Instead of having this code defined
    twice, let''s go back and create a `Ship` class that has all of the features that
    are common to our `PlayerShip` and `EnemyShip` classes. Then, we can refactor
    our `EnemyShip` and `PlayerShip` classes to inherit from our `Ship` class. Here
    is our new `Ship` class definition that we are adding to `game.hpp`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要简要讨论类继承。如果你回顾一下我们之前的代码，我们有一个`PlayerShip`类和一个`EnemyShip`类。这些类共享大部分属性。它们都有*x*和*y*坐标，*x*和*y*速度，以及许多其他相同的属性。许多函数使用相同的复制粘贴的代码。我们不想重复定义这些代码，让我们回过头来创建一个`Ship`类，它包含了`PlayerShip`和`EnemyShip`类共有的所有特性。然后，我们可以重构我们的`EnemyShip`和`PlayerShip`类，让它们继承自我们的`Ship`类。这是我们在`game.hpp`中添加的新`Ship`类定义：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The first line, `Ship class: public Collider`, tells us that `Ship` will inherit
    all of the public and protected members of the `Collider` class. We are doing
    this because we would like to be able to perform a hit test. The `Collider` class
    also now defines the `m_X` and `m_Y` attribute variables that keep track of the
    *x* and *y* coordinates of our object. We have moved everything common to our
    `EnemyShip` and `PlayerShip` classes into the `Ship` class. You will notice that
    we have one virtual function, `virtual void Move() = 0;`. This line tells us that
    we will have a `Move` function in all classes that inherit from `Ship`, but we
    will need to define `Move` inside those classes instead of directly in the `Ship`
    class. That makes `Ship` an **abstract class**, which means that we cannot create
    an instance of `Ship`, but, instead, it is a class from which other classes will
    inherit.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '第一行`Ship class: public Collider`告诉我们`Ship`将继承`Collider`类的所有公共和受保护成员。我们这样做是因为我们希望能够执行碰撞检测。`Collider`类现在也定义了`m_X`和`m_Y`属性变量，用于跟踪对象的*x*和*y*坐标。我们已经将`EnemyShip`和`PlayerShip`类的共同部分移到了`Ship`类中。你会注意到我们有一个虚函数`virtual
    void Move() = 0;`。这一行告诉我们，所有继承自`Ship`的类都将有一个`Move`函数，但我们需要在这些类中定义`Move`，而不是直接在`Ship`类中定义。这使`Ship`成为一个**抽象类**，这意味着我们不能创建`Ship`的实例，而是它是其他类将继承的类。'
- en: Class inheritance, abstract classes, and virtual functions are all a part of
    a style of programming known as **Object-Oriented Programming** (**OOP**). C++
    was created in 1979 by Bjarne Stroustrup to add OOP to the C programming language.
    If you're not familiar with OOP, there are hundreds of books that go into great
    detail on this topic. I will only be able to cover it in a cursory manner in this
    book.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 类继承、抽象类和虚函数都是一种被称为**面向对象编程**（**OOP**）的编程风格的一部分。C++是由Bjarne Stroustrup于1979年创建的，用于将OOP添加到C编程语言中。如果你对OOP不熟悉，有数百本书详细介绍了这个主题。我只能在本书中粗略地介绍它。
- en: 'Next, we are going to modify the `PlayerShip` and `EnemyShip` classes in the
    `game.hpp` file to remove all of the methods and attributes we have moved into
    the parent `Ship` class. We will also modify these classes so that they inherit
    from `Ship`. Here is the new version of the class definitions:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将修改`game.hpp`文件中的`PlayerShip`和`EnemyShip`类，删除我们移动到父类`Ship`中的所有方法和属性。我们还将修改这些类，使它们继承自`Ship`。以下是类定义的新版本：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we need to add a `ship.cpp` file and define all of the methods that will
    be common to `EnemyShip` and `PlayerShip`. These methods were in both `PlayerShip`
    and `EnemyShip` previously, but now we can have them all in one place. Here is
    what the `ship.cpp` file looks like:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要添加一个`ship.cpp`文件，并定义所有`EnemyShip`和`PlayerShip`共有的方法。这些方法之前都在`PlayerShip`和`EnemyShip`中，但现在我们可以将它们都放在一个地方。以下是`ship.cpp`文件的样子：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The only real difference between the versions of these classes that were in
    the `player_ship.cpp` and the `enemy_ship.cpp` files are that, instead of `PlayerShip::`
    or `EnemyShip::` in front of each of the function definitions, we now have `Ship::`
    in front of the function definitions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类的版本之间唯一真正的区别是，在`player_ship.cpp`和`enemy_ship.cpp`文件中，每个函数定义前面不再是`PlayerShip::`或`EnemyShip::`，而是`Ship::`。
- en: 'Next, we are going to need to modify `player_ship.cpp` and `enemy_ship.cpp`
    by removing all of the functions that we now have defined inside the `ship.cpp`
    file. Let''s take a look at what the `enemy_ship.cpp` file looks like broken into
    two parts. The first part is the `#include` of our `game.hpp` file and the `EnemyShip`
    constructor function:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改`player_ship.cpp`和`enemy_ship.cpp`，删除现在在`ship.cpp`文件中定义的所有函数。让我们看看`enemy_ship.cpp`文件分成两部分的样子。第一部分是我们的`game.hpp`文件的`#include`和`EnemyShip`构造函数：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the second part of our `enemy_ship.cpp` file we have the `Move` and `AIStub`
    functions:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在`enemy_ship.cpp`文件的第二部分中，我们有`Move`和`AIStub`函数：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that we have seen what is in the `enemy_ship.cpp` file, let''s take a look
    at what the new `player_ship.cpp` file looks like:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了`enemy_ship.cpp`文件中的内容，让我们看看新的`player_ship.cpp`文件的样子：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, let''s modify the `Move` function in our `ProjectilePool` class so that,
    every time it moves a `Projectile`, it also tests to see whether it hit one of
    our ships:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们修改`ProjectilePool`类中的`Move`函数，以便每次移动`Projectile`时，它也测试是否击中了我们的飞船之一：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For right now, we are only going to print to the console when either the player
    or the enemy collides with a projectile. That will tell us whether our collision
    detection is working correctly. In later sections, we will add animations to destroy
    our ships when they collide with the projectile.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只会在玩家或敌人与抛射物发生碰撞时在控制台上打印。这将告诉我们我们的碰撞检测是否正确。在后面的部分中，我们将添加动画来摧毁我们的飞船当它们与抛射物碰撞时。
- en: 'There is one last change we need to make to the `Launch` function on our `Projectile`
    class. When we launch a projectile from our ships, we give the projectile an x
    and a y position and an *x* and *y* velocity based on the direction the ship was
    facing. We need to take that direction and move the starting point of the projectile.
    That is to prevent the projectile from hitting the ship that launched it by moving
    it out of the collision detection circle for the ship:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对`Projectile`类的`Launch`函数进行最后一个更改。当我们从飞船发射抛射物时，我们给抛射物一个基于飞船面向的方向的x和y位置和*x*和*y*速度。我们需要根据这个方向移动抛射物的起点。这是为了防止抛射物通过移动出碰撞检测圈而击中发射它的飞船：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the next section, we will detect when our ship collides with a projectile
    and run an explosion animation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将检测当我们的飞船与抛射物碰撞时，并运行一个爆炸动画。
- en: Destroying a spaceship on collision
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在碰撞时摧毁飞船
- en: Now that we are detecting collisions between the projectiles and the spaceships,
    it would be nice to do something more interesting than printing a line to the
    console. It would be nice to have a little explosion animation for our projectiles
    and our ships when they hit something. We can add an animation associated with
    each of these objects as they are destroyed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在检测抛射物和飞船之间的碰撞，做一些比在控制台打印一行更有趣的事情会很好。当抛射物和飞船碰到东西时，能有一点爆炸动画会很好。当这些对象被摧毁时，我们可以为每个对象添加一个关联的动画。
- en: Instead of loading multiple sprites for each frame of the animation as we did
    in a previous chapter, I'm going to introduce the concept of **sprite sheets**.
    Instead of loading a single projectile frame and a single ship frame for each
    of our spaceships, we will load a sprite sheet for each that includes not only
    the undamaged version of each but a destruction sequence that we will animate
    through when any of these objects are destroyed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我将介绍**精灵表**的概念，而不是像在之前的章节中那样为动画的每一帧加载多个精灵。我们将为每个飞船加载一个精灵表，其中不仅包括每个未受损版本，还包括我们在这些对象被摧毁时要播放的摧毁序列。
- en: Having three different sprite sheets in this example is done for convenience
    only. When you decide how to pack your sprite sheets for production, there are
    several considerations that you must take into account. You will most likely want
    to break out your sprite sheets based on when you will need them. You may have
    a series of sprites you need that are common to all levels of the game. You may
    choose to break out the sprites based on the level. You also need to take into
    consideration that, for performance reasons WebGL requires power-of-2 sized sprite
    files. That may impact your decisions concerning what sprites to pack into what
    sprite sheets. You may also consider purchasing a tool such as Texture Packer
    to pack sprites for you more quickly than you could do by hand.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中使用三个不同的精灵表只是为了方便。当您决定如何打包精灵表以供生产时，有几个考虑因素。您很可能希望根据需要打包精灵表。您可能会选择根据游戏的级别来打包精灵表。您还需要考虑到，出于性能原因，WebGL需要大小为2的幂的精灵文件。这可能会影响您关于将哪些精灵打包到哪些精灵表中的决定。您还可以考虑购买一个像Texture
    Packer这样的工具，以便比手工更快地为您打包精灵。
- en: We have created three sprite sheets to replace the three sprites we were using.
    These `Sprites` are `FranchiseExp.png` to replace `Franchise.png`, `BirdOfAngerExp.png`
    to replace `BirdOfAnger.png`, and `ProjectileExp.png` to replace `Projectile.png`.
    We are going to need to make some tweaks to the `Projectile` class, `Ship` class,
    `EnemyShip` class, `PlayerShip`, and the `ProjectilePool` class, as well as the
    `game_loop` function.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了三个精灵表来替换我们之前使用的三个精灵。这些`Sprites`分别是`FranchiseExp.png`替换`Franchise.png`，`BirdOfAngerExp.png`替换`BirdOfAnger.png`，以及`ProjectileExp.png`替换`Projectile.png`。我们需要对`Projectile`类、`Ship`类、`EnemyShip`类、`PlayerShip`类以及`ProjectilePool`类，以及`game_loop`函数进行一些调整。
- en: 'We are going to start by modifying the game loop to keep track of the game''s
    timing data. We must remove some code from the `PlayerShip::Move` function inside
    the `player_ship.cpp` file. This code existed from [Chapter 4](f14c80d0-2d87-45b1-96ab-a3305ad35c50.xhtml),
    *Sprite Animations in WebAssembly with SDL*, where we discussed the basics of
    animating a sprite by animating `PlayerShip`. We must delete the following code
    from the first several lines of `PlayerShip::Move`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从修改游戏循环开始，以跟踪游戏的时间数据。我们必须从`player_ship.cpp`文件中的`PlayerShip::Move`函数中删除一些代码。这段代码存在于[第4章](f14c80d0-2d87-45b1-96ab-a3305ad35c50.xhtml)中，*使用SDL在WebAssembly中进行精灵动画*，我们讨论了通过对`PlayerShip`进行动画化来实现精灵动画的基础知识。我们必须从`PlayerShip::Move`的前几行中删除以下代码：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This code gets the current time and calculates all of our time-related information
    we use for speed adjustments and animation timing. We probably should have moved
    this code to the game loop a few chapters ago, but better late than never. The
    following is the code for the new `game_loop` function in `main.cpp`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码获取当前时间并计算我们用于速度调整和动画定时的所有时间相关信息。我们可能应该在几章前将这段代码移到游戏循环中，但迟做总比不做好。以下是`main.cpp`中新的`game_loop`函数的代码：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Strictly speaking, we did not have to make this change, but it makes more sense
    to have the game timing code within the game loop. Now that we have changed our
    game loop, we are going to modify the `Projectile` class. Here are the changes
    to the class definition we must make from within the `game.hpp` file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，我们不必进行这种更改，但将游戏时间代码放在游戏循环中更合理。现在我们已经改变了游戏循环，我们将修改`Projectile`类。以下是我们必须在`game.hpp`文件中进行的类定义更改：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We need to modify the `c_SpriteFile` variable to point to the new sprite sheet
    PNG file instead of the single sprite file. We need to increase the size of its
    width and height. To make space for the explosion, we will make all frames in
    the sprite sheet 16 x 16 instead of 8 x 8\. We also need a source rectangle. When
    each sprite has used an entire file, we could pass in `null` to `SDL_RenderCopy`,
    and the function would render the entire contents of the sprite file. Now we only
    want to render one frame, so we need a rectangle that will start at 0,0 and render
    the width and height of 16\. The sprite sheets we have created are **horizontal
    strip sprite sheets**, meaning that every frame is laid out in order and placed
    horizontally. To render a different frame of our animation, we will only need
    to modify the `.x` value inside our source rectangle. The final attribute we added
    is to the public section and is the `m_CurrentFrame` attribute. That tracks which
    frame in the animation we are currently on. We will keep our current frame at
    0 when we are not rendering the explosion animation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改`c_SpriteFile`变量，使其指向新的精灵表PNG文件，而不是单个精灵文件。我们需要增加宽度和高度。为了为爆炸腾出空间，我们将使精灵表中的所有帧都变为16
    x 16，而不是8 x 8。我们还需要一个源矩形。当每个精灵使用整个文件时，我们可以将`null`传递给`SDL_RenderCopy`，函数将渲染精灵文件的全部内容。现在我们只想渲染一帧，所以我们需要一个从0,0开始并渲染宽度和高度为16的矩形。我们创建的精灵表是**水平条形精灵表**，这意味着每一帧都按顺序排列并水平放置。要渲染动画的不同帧，我们只需要修改源矩形中的`.x`值。我们添加的最后一个属性是公共部分的`m_CurrentFrame`属性。它跟踪我们当前所处动画的帧。当我们不渲染爆炸动画时，我们将保持当前帧为0。
- en: 'Next, we will need to modify a few functions on the `Projectile` class. These
    functions are the `Projectile::Move` function and the `Projectile::Render` function
    inside of the `projectile.cpp` file. Here is the new version of the `Projectile::Move`
    function:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改`Projectile`类上的几个函数。这些函数是`projectile.cpp`文件中的`Projectile::Move`函数和`Projectile::Render`函数。这是`Projectile::Move`函数的新版本：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The top section of the `Move` function is all new. If the current frame is not
    `0`, we will run through the animation until it ends and then deactivate our projectile,
    sending it back to the projectile pool. We do this by subtracting the time since
    the app last ran the game loop. That is the value stored in the `diff_time` global
    variable. The `m_NextFrameTime` attribute variable stores the number of milliseconds
    until we switch to the next frame in our series. Once the values are below 0,
    we increment our current frame and reset `m_NextFrameTime` to the number of milliseconds
    we want between each new frame of our animation. Now that we have incremented
    the current animation frame, we can check to see whether it is greater than or
    equal to the frame number of the last frame in this animation (in this case, 4).
    If so, we need to deactivate the projectile and reset the current frame to 0.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Move`函数的顶部部分都是新的。如果当前帧不是`0`，我们将运行动画直到结束，然后停用我们的抛射物，将其发送回抛射物池。我们通过减去自上次应用程序运行游戏循环以来的时间来实现这一点。这是存储在`diff_time`全局变量中的值。`m_NextFrameTime`属性变量存储了切换到我们系列中下一帧的毫秒数。一旦值低于0，我们就会增加当前帧并将`m_NextFrameTime`重置为我们希望在动画的每一帧之间的毫秒数。现在我们已经增加了当前动画帧，我们可以检查它是否大于或等于此动画中最后一帧的帧数（在本例中为4）。如果是，我们需要停用抛射物并将当前帧重置为0。'
- en: 'Now, that we have made the changes we need to make to the `Move()` function,
    here are the changes we must make to the `Projectile::Render()` function:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经对`Move()`函数进行了所需的更改，接下来我们需要对`Projectile::Render()`函数进行以下更改：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first change to the `Render` function is the addition of the `src` rectangle
    to the `SDL_RenderCopy` call, as well as setting its *x* value immediately above
    that call. Each frame in our sprite sheet is 16 pixels wide, so setting the *x*
    value to `16 * m_CurrentFrame` will select a different 16 x 16 sprite from the
    sprite sheet. The width and height of that rectangle will always be 16, and the
    *y* value will always be 0 because we placed the sprites into this sprite sheet
    as a horizontal strip.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对`Render`函数的第一个更改是在`SDL_RenderCopy`调用中添加了`src`矩形，并在该调用的上方立即设置了它的*x*值。我们的精灵表中的每一帧都是16像素宽，所以将*x*值设置为`16
    * m_CurrentFrame`将从精灵表中选择一个不同的16 x 16精灵。该矩形的宽度和高度将始终为16，*y*值将始终为0，因为我们将精灵放入这个精灵表中作为水平条带。
- en: 'Now we are going to make some modifications to the `Ship` class definitions
    inside the `game.hpp` file:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要对`game.hpp`文件中的`Ship`类定义进行一些修改：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We modified the width and height constants to reflect the new sprite size of
    32 x 32 pixels as it appears in our sprite sheet. We also must add a source rectangle
    to the `Projectile` class. Inside our public attributes section, we have added
    a few variables to track the alive or dead status of the ship, `(m_Alive)`; the
    current frame the game is rendering, `(m_CurrentFrame)`; and the time in milliseconds
    until we render the next frame, `(m_NextFrameTime)`. Next, we will make the necessary
    modifications to the `ship.cpp` file. We need to modify the `Ship::Render` function:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改了宽度和高度常量以反映精灵表中新的精灵大小为32 x 32像素。我们还必须为`Projectile`类添加一个源矩形。在我们的公共属性部分，我们添加了一些变量来跟踪飞船的存活或死亡状态`(m_Alive)`；游戏正在渲染的当前帧`(m_CurrentFrame)`；以及直到渲染下一帧的毫秒数`(m_NextFrameTime)`。接下来，我们将对`ship.cpp`文件进行必要的修改。我们需要修改`Ship::Render`函数：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'At the top of the function, we have added code to check to see whether the
    ship is currently alive. If it is not, we do not want to render the ship, so we
    return. Later on, we set the source rectangle *x* value to 32 times the current
    frame with the line: `src.x = 32 * m_CurrentFrame;`. That changes our render to
    render a different 32 x 32 block of pixels from our sprite sheet based on the
    frame we want to render. Lastly, we must pass that `src` rectangle into the call
    to `SDL_RenderCopyEx`.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数顶部，我们添加了代码来检查飞船当前是否存活。如果不是，我们就不想渲染飞船，所以我们返回。稍后，我们将源矩形*x*值设置为当前帧的32倍，代码如下：`src.x
    = 32 * m_CurrentFrame;`。这样我们的渲染就会根据我们想要渲染的帧来渲染来自精灵表的不同的32 x 32像素块。最后，我们必须将`src`矩形传递给`SDL_RenderCopyEx`调用。
- en: 'Now that we have modified the `Ship` class, we will change the `EnemyShip`
    class definition and the `PlayerShip` class definition to use our sprite sheet
    PNG files instead of the old single sprite files. Here are the modifications to
    those two class definitions inside the `game.hpp` file:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经修改了`Ship`类，我们将改变`EnemyShip`类定义和`PlayerShip`类定义，以使用我们的精灵表PNG文件，而不是旧的单个精灵文件。以下是`game.hpp`文件中这两个类定义的修改：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The only changes made to these class definitions are to the values of the `c_SpriteFile`
    constant in each class. The `c_SpriteFile` constant in the `PlayerShip` class
    was modified from `"sprites/Franchise.png"` to `"sprites/FranchiseExp.png"`, and
    the `c_SpriteFile` constant in `EnemyShip` was modified from `"sprites/BirdOfAnger.png"`
    to `"sprites/BirdOfAngerExp.png"`. Now that we have made that change, these classes
    will use the sprite sheet `.png` files instead of the original sprite files.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对这些类定义的唯一更改是在每个类中的`c_SpriteFile`常量的值。`PlayerShip`类中的`c_SpriteFile`常量从`"sprites/Franchise.png"`修改为`"sprites/FranchiseExp.png"`，`EnemyShip`中的`c_SpriteFile`常量从`"sprites/BirdOfAnger.png"`修改为`"sprites/BirdOfAngerExp.png"`。现在我们已经做出了这个改变，这些类将使用精灵表`.png`文件而不是原始精灵文件。
- en: 'Now that we have modified the definitions for these classes, we must change
    the `Move` functions for each of them. First, we will revise the `EnemyShip::Move`
    function inside the `enemy_ship.cpp` file:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经修改了这些类的定义，我们必须改变它们的`Move`函数。首先，我们将修改`enemy_ship.cpp`文件中的`EnemyShip::Move`函数：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There are two places where the code must be changed. First, we do not want
    to do any of the `Move` function''s work if the enemy ship is not alive, so we
    added this check at the beginning of the function to return if the ship is not
    alive:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个地方需要更改代码。首先，如果敌方飞船不再存活，我们不想执行任何`Move`函数的工作，所以我们在函数开头添加了这个检查来返回，如果飞船不再存活：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we needed to add the code to check whether we needed to run the death
    animation. We do this if the current frame is greater than 0\. The code in this
    section is similar to what we did for the projectile to run its death animation.
    We subtract the time between frames, `(diff_time)`, from the next frame time,
    `(m_NextFrameTime)`, to determine whether we need to increment the frame. When
    this value drops below 0, the frame is ready to change by incrementing `m_CurrentFrame`,
    and we reset the `m_NextFrameTime` countdown timer by setting it to the number
    of milliseconds we want between each frame, `(ms_per_frame)`. If our current frame
    hits the end of our frame sprite sheet, `(++m_CurrentFrame >= 8)`, then we set
    the enemy ship to no longer be alive, `(m_Alive = false)`. This is shown here:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加代码来检查是否需要运行死亡动画。如果当前帧大于0，我们就会这样做。这一部分的代码与我们为抛射物运行死亡动画所做的类似。我们从下一帧时间`(m_NextFrameTime)`中减去帧之间的时间`(diff_time)`，以确定是否需要增加帧数。当这个值低于0时，帧数准备好改变，通过增加`m_CurrentFrame`，然后我们通过将其设置为每帧之间的毫秒数`(ms_per_frame)`来重置`m_NextFrameTime`倒计时器。如果我们当前的帧达到了我们帧精灵表的末尾，`(++m_CurrentFrame
    >= 8)`，那么我们将敌方飞船设置为不再存活，`(m_Alive = false)`。如下所示：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, we will make the same changes to the `PlayerShip::Move` function within
    the `player_ship.cpp` file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将对`player_ship.cpp`文件中的`PlayerShip::Move`函数进行相同的更改：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Just like in our `EnemyShip::Move` functions, we add a check to see whether
    the player is alive with the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在我们的`EnemyShip::Move`函数中一样，我们添加了一个检查，看玩家是否还活着，代码如下：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And we also add some code to run the death animation if our current frame is
    greater than 0:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一些代码，如果当前帧大于0，就运行死亡动画：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The last thing we need to do is modify the collision detection code we added
    earlier to the `ProjectilePool::MoveProjectiles` function to run the death animation
    for a ship and a projectile if the two collide. Here is the new version of `ProjectilePool::MoveProjectiles`
    inside of the `projectile_pool.cpp` file:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是修改我们之前添加到`ProjectilePool::MoveProjectiles`函数中的碰撞检测代码，以便在两者碰撞时运行飞船和抛射物的死亡动画。这是`projectile_pool.cpp`文件中`ProjectilePool::MoveProjectiles`的新版本：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Inside of this code, every time we move a projectile, we do a hit test against
    that projectile and the player as well as a hit test between that projectile and
    the enemy. If either the ship or the projectile is running its death animation
    (`m_CurrentFrame == 0` is false), then we do not need to run the hit test because
    the ship or the projectile has already been destroyed. If the hit test returns
    true, then we need to set the current frame of both the projectile and the ship
    to 1 to begin the destruction animation. We also need to set the next frame time
    to the number of milliseconds until the frame changes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，每次移动抛射物时，我们都会对该抛射物和玩家进行碰撞测试，以及对该抛射物和敌人进行碰撞测试。如果飞船或抛射物正在运行死亡动画（`m_CurrentFrame
    == 0`为false），那么我们就不需要运行碰撞测试，因为飞船或抛射物已经被摧毁。如果碰撞测试返回true，那么我们需要将抛射物和飞船的当前帧都设置为1，开始摧毁动画。我们还需要将下一帧时间设置为直到帧变化的毫秒数。
- en: Now that we have added all of this new code, the ship and the enemy ship will
    run an explosion animation that destroys the ship when hit. The projectiles will
    also explode instead of just disappearing. The circle colliders are fast but not
    very precise. In the *Implementing compound circle colliders* section, we will
    learn the modifications we need to make to use multiple circle colliders on a
    single ship. That will give us collisions that look more accurate than simple
    circles.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了所有这些新代码，飞船和敌人飞船将运行一个爆炸动画，当被击中时摧毁飞船。抛射物也会爆炸而不是只是消失。圆形碰撞器速度很快，但不太精确。在*实现复合圆形碰撞器*部分，我们将学习需要进行的修改，以便在单个飞船上使用多个圆形碰撞器。这将使我们的碰撞看起来比简单的圆更准确。
- en: Pointers in memory
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存中的指针
- en: WebAssembly's memory model piggybacks on the asm.js memory model, which uses
    a large typed `ArrayBuffer` to hold all of the raw bytes to be manipulated by
    the module. A JavaScript call to `WebAssembly.Memory` sets up the module's memory
    buffer in 64 KB **pages**.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly的内存模型基于asm.js内存模型，后者使用一个大型的类型化`ArrayBuffer`来保存模块要操作的所有原始字节。JavaScript调用`WebAssembly.Memory`设置模块的内存缓冲区为64KB的**页面**。
- en: 'A *page* is a block of linear data that is the smallest unit of data that can
    be allocated by an operating system, or, in the case of WebAssembly, a virtual
    machine. For more information on memory pages, see the Wikipedia Page: [https://en.wikipedia.org/wiki/Page_%28computer_memory%29](https://en.wikipedia.org/wiki/Page_%28computer_memory%29).'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*页面*是线性数据块，是操作系统或WebAssembly虚拟机分配的最小数据单元。有关内存页面的更多信息，请参阅维基百科页面：[https://en.wikipedia.org/wiki/Page_%28computer_memory%29](https://en.wikipedia.org/wiki/Page_%28computer_memory%29)。'
- en: A WebAssembly module can only access data from within this `ArrayBuffer`. That
    prevents malicious attacks from WebAssembly that create a pointer to a memory
    address outside the browser's sandbox. Because of this design, WebAssembly's memory
    model is just as safe as JavaScript.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly模块只能访问`ArrayBuffer`中的数据。这可以防止WebAssembly对浏览器沙盒之外的内存地址进行恶意攻击。由于这种设计，WebAssembly的内存模型与JavaScript一样安全。
- en: 'In the next section, we will be using C++ pointers in our `collider` object.
    If you are a JavaScript developer, you may not be familiar with **pointers**.
    A pointer is a variable that holds a memory location instead of the value directly.
    Let''s look at a little bit of code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将在`collider`对象中使用C++指针。如果您是JavaScript开发人员，您可能不熟悉**指针**。指针是一个保存内存位置而不是直接值的变量。让我们看一些代码：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this code, we have created a `VAR1` variable and given it a value of 1\.
    In the second line, we use `int*` to create a pointer called `POINTER`. We then
    initialize that pointer to the address of `VAR1` using the `&` character, which,
    in C++, is known as the **address of operator**. This operator gives us the address
    of the `VAR1` that we declared earlier. If we then want to change `VAR1`, we can
    do so using the pointer instead of directly, as shown here:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们创建了一个名为`VAR1`的变量，并给它赋了一个值1。在第二行，我们使用`int*`创建了一个名为`POINTER`的指针。然后我们使用`&`字符将该指针初始化为`VAR1`的地址，这在C++中被称为**地址运算符**。这个运算符给出了我们之前声明的`VAR1`的地址。如果我们想要改变`VAR1`，我们可以使用指针而不是直接改变，如下所示：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Putting the `*` in front of `POINTER` tells C++ to set the value in the memory
    address where `POINTER` is pointing; `*` when used in this way is called the **dereference
    operator**.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在`POINTER`前面加上`*`告诉C++设置内存地址中`POINTER`指向的值；在这种情况下使用的`*`被称为**解引用运算符**。
- en: 'If you would like to learn more about pointers in C++ and how they work, the
    following article goes into a good deal of detail on the subject: [http://www.cplusplus.com/doc/tutorial/pointers/](http://www.cplusplus.com/doc/tutorial/pointers/).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解有关C++中指针及其工作原理的更多信息，以下文章详细介绍了这个主题：[http://www.cplusplus.com/doc/tutorial/pointers/](http://www.cplusplus.com/doc/tutorial/pointers/)。
- en: In the next section, we will implement compound circle colliders for collision
    detection on our spaceships.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将为太空飞船的碰撞检测实现复合圆形碰撞器。
- en: Implementing compound circle colliders
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现复合圆形碰撞器
- en: 'Now that our collision detection is working, and we have our ships and projectiles
    exploding on a collision, let''s see how we can make our collision detection better.
    We chose circle collision detection for two reasons: the collision algorithm is
    fast, and it is simple. We could do better, however, by merely adding more circles
    to each ship. That will increase our collision detection time by a factor of *n*,
    where *n* is the average number of circles we have on each ship. That is because
    the only collision detection we do is between the projectiles and the ships. Even
    so, we don''t want to go overboard with the number of circles we choose to use
    for each ship.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的碰撞检测已经起作用，我们的飞船和抛射物在碰撞时爆炸，让我们看看如何使我们的碰撞检测更好。我们选择圆形碰撞检测有两个原因：碰撞算法快速且简单。然而，我们可以通过简单地为每艘飞船添加更多的圆形来做得更好。这将使我们的碰撞检测时间增加*n*倍，其中*n*是我们每艘飞船上平均圆形的数量。这是因为我们只进行抛射物和飞船之间的碰撞检测。即使如此，我们也不希望在选择用于每艘飞船的圆形数量上过火。
- en: 'For the player ship, the front of the spaceship is covered well by the basic
    circle. However, we could get much better coverage of the back of the player''s
    spaceship by adding a circle to each side:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于玩家飞船，飞船的前部由基本圆形很好地覆盖。然而，通过在每一侧添加一个圆形，我们可以更好地覆盖玩家飞船的后部：
- en: '![](img/bb6abb5f-7d27-4e56-a72b-f41d7f92dde3.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb6abb5f-7d27-4e56-a72b-f41d7f92dde3.png)'
- en: '[Our player ship compound collider]'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[我们的玩家飞船复合碰撞器]'
- en: 'The enemy ship is the opposite. The back of that spaceship is covered pretty
    well by a default circle, but the front could use some better coverage, so, for
    the enemy ship, we will add some additional circles in front:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 敌方飞船则相反。飞船的后部被默认圆形很好地覆盖，但前部需要更好的覆盖，因此对于敌方飞船，我们将在前部添加一些额外的圆形：
- en: '![](img/45d21650-582a-4d43-9686-a132f6146e36.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/45d21650-582a-4d43-9686-a132f6146e36.png)'
- en: '[Our enemy ship compound collider]'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[我们的敌方飞船复合碰撞器]'
- en: 'The first thing we need to do is change the `Collider` class to include information
    from the parent of our collider. Here is the new version of the `Collider` class
    definition inside our `game.hpp` file:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是改变`Collider`类，以包括来自我们碰撞器父级的信息。以下是我们`game.hpp`文件中`Collider`类定义的新版本：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We have added three-pointers to attributes of the parent of our `Collider` class.
    These will point to the *x* and *y* coordinates, as well as the `Rotation` of
    the collider's parent, which will either be the enemy ship, the player ship, or
    `NULL`. We will initialize those values to `NULL` in our constructor, and if the
    value is null, we will not modify the behavior of our collider. If, however, those
    values are set to something else, we will call the `CCHitTest` function to determine
    whether there is a collision. This version of the hit test will adjust the position
    of the collider to be relative to its parent's position and rotation before doing
    the collision test. Now that we have made the changes to the collider's definition,
    we will make changes to the functions inside the `collider.cpp` file to support
    the new compound colliders.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为我们的`Collider`类的父级属性添加了三个指针。这些指针将指向碰撞器的父级的*x*和*y*坐标，以及`Rotation`，它可能是敌方飞船、玩家飞船或`NULL`。我们将在构造函数中将这些值初始化为`NULL`，如果该值为null，我们将不修改碰撞器的行为。然而，如果这些值设置为其他值，我们将调用`CCHitTest`函数来确定是否有碰撞。这个碰撞测试的版本将在进行碰撞测试之前，调整碰撞器的位置，使其相对于其父级的位置和旋转。现在我们已经对碰撞器的定义进行了更改，我们将对`collider.cpp`文件中的函数进行更改，以支持新的复合碰撞器。
- en: 'The first thing to do is modify our constructor to initialize the new pointers
    to `NULL`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是修改我们的构造函数，将新指针初始化为`NULL`：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We have a new function to add to our `collider.cpp` file, the `CCHitTest` function,
    which will be our compound collider hit test. This version of the hit test will
    adjust the *x* and *y* coordinates of our collider to be relative to the position
    and rotation of our parent ship:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个新的函数要添加到我们的`collider.cpp`文件中，即`CCHitTest`函数，它将是我们的复合碰撞器碰撞测试。这个碰撞测试的版本将调整我们的碰撞器的*x*和*y*坐标，使其相对于父级飞船的位置和旋转：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The first thing this function does is take the sine and cosine of the parent''s
    rotation and use that rotation to get a rotated version of *x* and *y* in the
    variables, `rx` and `ry`. We then adjust that rotated *x* and *y* position by
    the parent''s *x* and *y* position, before calculating the distance between the
    two collider *x* and *y* positions. After we add this new `CCHitTest` function,
    we need to modify the `HitTest` function to call this version of the hit test
    if the parent values are set. Here is the latest version of `HitTest`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的第一件事是取父级旋转的正弦和余弦，并使用该旋转来得到变量`rx`和`ry`中*x*和*y*的旋转版本。然后我们调整旋转后的*x*和*y*位置，通过父级的*x*和*y*位置，然后计算两个碰撞器*x*和*y*位置之间的距离。在我们添加了这个新的`CCHitTest`函数之后，我们需要修改`HitTest`函数，以便在设置了父级值时调用这个版本的碰撞测试。以下是`HitTest`的最新版本：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We have created a function to set all of these values called `SetParentInformation`.
    Here is the function definition:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`SetParentInformation`的函数来设置所有这些值。以下是函数定义：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To take advantage of these new kinds of colliders, we need to add a new vector
    of colliders into the `Ship` class. The following is the new class definition
    for `Ship` in the `game.hpp` file:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用这些新类型的碰撞器，我们需要在`Ship`类中添加一个新的碰撞器向量。以下是`game.hpp`文件中`Ship`的新类定义：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'There are two differences between this version and the previous version of
    the `Ship` class. The first is the addition of the `m_Colliders` vector attribute:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本和`Ship`类的上一个版本之间有两个不同之处。第一个是添加了`m_Colliders`向量属性：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The second change is the new `CompoundHitTest` function added at the bottom
    of the class:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个变化是在类底部添加的新的`CompoundHitTest`函数：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'For the change to our class, we will need to add a new function to our `ship.cpp`
    file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的类的更改，我们需要在`ship.cpp`文件中添加一个新的函数：
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This `CompoundHitTest` function is a pretty simple function that loops over
    all of our additional colliders and performs a hit test on them. This line creates
    a vector of collider pointers. We will now modify our `EnemyShip` and `PlayerShip`
    constructors to add some colliders into this vector. First, we will add some new
    lines to the `EnemyShip` constructor inside the `enemy_ship.cpp` file:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`CompoundHitTest`函数是一个非常简单的函数，它循环遍历我们的额外碰撞器并对它们执行碰撞测试。这一行创建了一个碰撞器指针的向量。现在我们将修改`EnemyShip`和`PlayerShip`构造函数，将一些碰撞器添加到这个向量中。首先，我们将在`enemy_ship.cpp`文件中的`EnemyShip`构造函数中添加一些新的行：
- en: '[PRE36]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The code that we added creates new colliders and sets the parent information
    for those colliders as pointers to the *x* and *y* coordinates, as well as the
    radius to the addresses of those values inside of this object. We set the `m_X`
    and `m_Y` values for this collider relative to the position of this object, and
    then we push the new colliders into the `m_Colliders` vector attribute:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的代码创建了新的碰撞器，并将这些碰撞器的父级信息设置为指向该对象内部的*x*和*y*坐标以及半径的地址。我们将这个碰撞器的`m_X`和`m_Y`值相对于该对象的位置进行设置，然后将新的碰撞器推入`m_Colliders`向量属性中。
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We will now do something similar for the `PlayerShip` constructor inside the
    `player_ship.cpp` file:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在`player_ship.cpp`文件中对`PlayerShip`构造函数做类似的事情：
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we have to change our projectile pool to run the collision detection on
    these new compound colliders in our ships. Here is the modified version of the
    `MoveProjectiles` function inside the `projectile_pool.cpp` file:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须修改我们的抛射物池，以在我们的飞船中对这些新的复合碰撞器进行碰撞检测。以下是`projectile_pool.cpp`文件中`MoveProjectiles`函数的修改版本：
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Because we continue to inherit `Collider` in our `Ship` class, we still will
    perform a regular hit test on our player and enemy ships. We have added a call
    to `CompoundHitTest` in our `Ship` class that loops over our `m_Colliders` vector
    and performs a collision hit test on each of the colliders in that vector.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在`Ship`类中继承了`Collider`，所以我们仍然会对玩家和敌人的飞船执行常规的碰撞测试。我们在`Ship`类中添加了对`CompoundHitTest`的调用，它循环遍历我们的`m_Colliders`向量，并对该向量中的每个碰撞器执行碰撞测试。
- en: Our compound collider solution is not generalized, and, for the most part, neither
    is our collision detection. We are only detecting collisions between our ships
    and our projectiles. We are not currently performing any collision detection between
    our ships. To have a generalized approach to collision detection, we would need
    to implement spacial segmenting. That would prevent the number of collision checks
    from growing exponentially with each additional collider added to our game.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的复合碰撞器解决方案并不是通用的，大部分情况下，我们的碰撞检测也不是通用的。我们只检测飞船和抛射物之间的碰撞。我们目前没有执行任何飞船之间的碰撞检测。要实现通用的碰撞检测方法，我们需要实现空间分割。这将防止随着每个额外的碰撞器添加到我们的游戏中，碰撞检测数量呈指数级增长。
- en: Compiling collider.html
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译collider.html
- en: 'The command we use to compile our `collider.html` file is similar to our compile
    command in the last chapter. We will need to add a new `collider.cpp` file into
    the command line, but other than that it should be the same. Here is the command
    you use to compile `collider.html`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来编译`collider.html`文件的命令与上一章中的编译命令类似。我们需要在命令行中添加一个新的`collider.cpp`文件，但除此之外应该是一样的。以下是编译`collider.html`所使用的命令：
- en: '[PRE40]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now that we have `collider.html` compiled, we can serve it from our web server
    of choice, or run it with `emrun`, and load it into a web browser. Here is what
    it looks like:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编译了`collider.html`，我们可以从我们选择的Web服务器中提供它，或者使用`emrun`运行它，并将其加载到Web浏览器中。这是它的样子：
- en: '![](img/72206918-5f5b-4dac-8585-fb42d096df04.png)[The enemy spaceship explodes
    when hit by a projectile]'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/72206918-5f5b-4dac-8585-fb42d096df04.png)[当被抛射物击中时，敌方飞船会爆炸]'
- en: Please remember that you must run WebAssembly apps using a web server, or with
    `emrun`. If you would like to run your WebAssembly app using `emrun`, you must
    compile it with the `--emrun` flag. The web browser requires a web server to stream
    the WebAssembly module. If you attempt to open an HTML page that uses WebAssembly
    in a browser directly from your hard drive, that WebAssembly module will not load.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您必须使用Web服务器或`emrun`来运行WebAssembly应用程序。如果您想使用`emrun`运行WebAssembly应用程序，您必须使用`--emrun`标志进行编译。Web浏览器需要一个Web服务器来流式传输WebAssembly模块。如果您尝试直接从硬盘驱动器在浏览器中打开使用WebAssembly的HTML页面，那么WebAssembly模块将无法加载。
- en: I did not take a screenshot of the entire browser as I have in previous screenshots
    of the game because I wanted to zoom in on the player ship destroying the enemy
    ship. As you can see, we now have colliders that can detect when a projectile
    collides with a spaceship and can destroy that spaceship when the collision happens
    by running an explosion animation.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有像之前游戏截图那样截取整个浏览器，因为我想放大玩家飞船摧毁敌方飞船的画面。正如你所看到的，我们现在有了可以检测抛射物何时与飞船碰撞并在碰撞发生时摧毁飞船的碰撞器，从而运行爆炸动画。
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Circle colliders are what we need right now. They are fast and efficient, and,
    for a simple game such as this, you might be able to get away with not doing anything
    more sophisticated. We added in a compound collider to demonstrate how this simple
    modification could significantly increase the accuracy of your collider. We will
    need to add more collision detection methods later in this book. In the future,
    we will be adding asteroids and a star to our game, and we will be creating an
    **AI** (**Artificial Intelligence**) agent to navigate our game and attack our
    player. This agent will eventually need to know whether it has a line of sight
    with the player so that line collision detection will become more important. Our
    agent will also want to quickly scan the area close to it to see whether there
    are any asteroids it must avoid. For this feature, we will be using rectangle
    collision.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 圆形碰撞体是我们现在需要的。它们快速高效，对于这样一个简单的游戏，你可能可以不用做更复杂的事情就能逃脱。我们添加了一个复合碰撞体来演示这个简单修改如何显著增加碰撞体的准确性。我们将在本书的后面添加更多的碰撞检测方法。在未来，我们将在游戏中添加小行星和一颗星星，并创建一个**AI**（**人工智能**）代理来导航我们的游戏并攻击我们的玩家。这个代理最终需要知道它是否与玩家有视线，因此线碰撞检测将变得更加重要。我们的代理还希望快速扫描其附近的区域，以查看是否有任何必须避开的小行星。对于这个功能，我们将使用矩形碰撞。
- en: There are many types of collision detection techniques for 2D games, and we
    have only scratched the surface in this chapter. We learned how to implement some
    basic circle colliders and compound colliders, and we added code that detects
    collisions between the projectiles in our game and the player and enemy spaceships.
    These kinds of colliders are fast and relatively easy to implement, but they are
    not without their drawbacks.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 2D游戏有许多种碰撞检测技术，在本章中我们只是触及了皮毛。我们学会了如何实现一些基本的圆形碰撞体和复合碰撞体，并添加了代码来检测游戏中抛射物与玩家和敌人飞船之间的碰撞。这些类型的碰撞体快速而相对容易实现，但它们并非没有缺点。
- en: One drawback you may notice with simple colliders such as the ones we have implemented
    is that, if two objects pass each other with a high enough relative velocity,
    it is possible they could pass through each other without colliding. That is because
    our objects have a new position calculated every frame, and they do not continuously
    move from point A to point B. If it takes one frame to move from point A to point
    B, the object effectively teleports between the two points. If there was a second
    object in between those two points, but we are not colliding with that object
    when at either point A or point B, the object collision is missed. That should
    not be a problem in our game because we will be keeping our maximum object velocities
    relatively low. It is, however, something to keep in mind when writing your games.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到我们实现的简单碰撞体的一个缺点是，如果两个对象以足够高的相对速度相互穿过，它们可能会在不发生碰撞的情况下相互穿过。这是因为我们的对象在每一帧都有一个新的位置计算，并且它们不是连续地从A点移动到B点。如果需要一帧的时间从A点移动到B点，那么对象在两个点之间有效地传送。如果在这两个点之间有第二个对象，但当在A点或B点时我们没有与该对象发生碰撞，那么对象碰撞就会被忽略。这在我们的游戏中不应该是一个问题，因为我们将保持我们的最大对象速度相对较低。然而，在编写游戏时要记住这一点。
- en: In the next chapter, we will be building a tool to help us to configure **particle
    systems**.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建一个工具来帮助我们配置**粒子系统**。
