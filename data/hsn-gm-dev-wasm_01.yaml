- en: Introduction to WebAssembly and Emscripten
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍WebAssembly和Emscripten
- en: Welcome to the exciting new world of WebAssembly! These are early days for WebAssembly,
    but the technology is currently taking off like a rocket, and by reading this
    book, you are in a position to get in on the ground floor. If you are interested
    in game development on the web, or you are interested in learning as much about
    this new technology as you can to position yourself for when it does reach maturity,
    you are in the right place. Even though WebAssembly is in its infancy, all major
    browser vendors have adopted it. These are early days and use cases are limited,
    but lucky for us, game development is one of them. So, if you want to be early
    to the party for the next generation of application development on the web, read
    on, adventurer!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到令人兴奋的WebAssembly新世界！对于WebAssembly来说，现在还处于早期阶段，但这项技术目前正如火箭般腾飞，通过阅读本书，您有机会站在起步阶段。如果您对网络游戏开发感兴趣，或者您想尽可能多地了解这项新技术，以便在其成熟时为自己找到位置，那么您来对地方了。尽管WebAssembly还处于萌芽阶段，但所有主要的浏览器供应商都已经采用了它。现在是早期阶段，使用案例有限，但幸运的是，游戏开发是其中之一。因此，如果您想成为下一代网络应用程序开发派对的早期参与者，那就继续阅读吧，冒险家！
- en: In this chapter, I will introduce you to WebAssembly, Emscripten, and some of
    the underlying technologies around WebAssembly. I will teach you the basics of
    the Emscripten toolchain, and how you can use Emscripten to compile C++ code into
    WebAssembly. We will discuss what LLVM is and how it fits into the Emscripten
    toolchain. We will talk about WebAssembly's **Minimum Viable Product** (**MVP**),
    the best use cases for WebAssembly in its current MVP form, and what will soon
    be coming to WebAssembly. I will introduce **WebAssembly text** (**.wat**), how
    we can use it to understand the design of WebAssembly bytecode, and how it differs
    from other machine bytecodes. We will also briefly discuss **asm.js**, and its
    historical significance in the design of WebAssembly. Finally, I will show you
    how to install and run Emscripten on Windows and Linux.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将向您介绍WebAssembly、Emscripten以及围绕WebAssembly的一些基础技术。我将教您Emscripten工具链的基础知识，以及如何使用Emscripten将C++代码编译成WebAssembly。我们将讨论LLVM是什么，以及它如何融入Emscripten工具链。我们将讨论WebAssembly的**最小可行产品**（**MVP**），以及在其当前MVP形式下WebAssembly的最佳使用案例，以及即将到来的内容。我将介绍**WebAssembly文本**（**.wat**），以及我们如何使用它来理解WebAssembly字节码的设计，以及它与其他机器字节码的区别。我们还将简要讨论**asm.js**，以及它在WebAssembly设计中的历史意义。最后，我将向您展示如何在Windows和Linux上安装和运行Emscripten。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is WebAssembly?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是WebAssembly？
- en: Why do we need WebAssembly?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为什么需要WebAssembly？
- en: Why is WebAssembly faster than JavaScript?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么WebAssembly比JavaScript更快？
- en: Will WebAssembly replace JavaScript?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebAssembly会取代JavaScript吗？
- en: What is asm.js?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是asm.js？
- en: A brief introduction to LLVM
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对LLVM的简要介绍
- en: A brief introduction to WebAssembly text
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对WebAssembly文本的简要介绍
- en: What is Emscripten and how do we use it?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是Emscripten，我们如何使用它？
- en: What is WebAssembly?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是WebAssembly？
- en: WebAssembly is not a high-level programming language like JavaScript, but a
    compiled binary format that all major browsers are currently able to execute.
    WebAssembly is a kind of machine bytecode that was not designed to run directly
    on any real machine hardware, but runs in the JavaScript engine built into every
    browser. In some ways, it is similar to the old **Java Virtual Machine** (**JVM**);
    for example, it is a platform-independent compiled bytecode. One major problem
    with JavaScript bytecode is its requirement for a plugin to be downloaded and
    installed in the browser for the bytecode to run. Not only is **WebAssembly**
    designed to be run directly in a browser without a plugin, but it is also intended
    to produce a compact binary format that executes efficiently inside a web browser.
    The MVP version of the specification leverages existing work by the browser makers
    designing their JavaScript **just-in-time** (**JIT**) compiler. WebAssembly is
    currently a young technology and many improvements are planned. However, developers
    using the current version of WebAssembly have already seen performance improvements
    over JavaScript of 10–800%.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly不是像JavaScript那样的高级编程语言，而是一种编译的二进制格式，所有主要浏览器目前都能够执行。WebAssembly是一种机器字节码，不是设计用于直接在任何真实机器硬件上运行，而是在每个浏览器内置的JavaScript引擎中运行。在某些方面，它类似于旧的**Java虚拟机**（**JVM**）；例如，它是一个平台无关的编译字节码。JavaScript字节码的一个主要问题是需要下载和安装浏览器中的插件才能运行字节码。**WebAssembly**不仅旨在在浏览器中直接运行而无需插件，而且还旨在生成在Web浏览器内高效执行的紧凑二进制格式。规范的MVP版本利用了浏览器制造商设计他们的JavaScript
    **即时**（**JIT**）编译器的现有工作。WebAssembly目前是一项年轻的技术，许多改进计划中。然而，使用当前版本的WebAssembly的开发人员已经看到了相对于JavaScript的性能提升10-800%。
- en: 'An MVP is the smallest set of features that can be given to a product to allow
    it to appeal to early adopters. Because the current version is an MVP, the feature
    set is small. For more information, see this excellent article discussing the
    "post-MVP future" of WebAssembly: [https://hacks.mozilla.org/2018/10/webassemblys-post-mvp-future/](https://hacks.mozilla.org/2018/10/webassemblys-post-mvp-future/).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: MVP是可以赋予产品的最小功能集，以使其吸引早期采用者。由于当前版本是MVP，功能集很小。有关更多信息，请参阅这篇关于WebAssembly“后MVP未来”的优秀文章：[https://hacks.mozilla.org/2018/10/webassemblys-post-mvp-future/](https://hacks.mozilla.org/2018/10/webassemblys-post-mvp-future/)。
- en: Why do we need WebAssembly?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们为什么需要WebAssembly？
- en: JavaScript has been around for a long time. It has evolved from a little scripting
    language that allowed bells and whistles to be added to a web page, to a sprawling
    JIT compiled language with a massive ecosystem that can be used to write fully
    fledged applications. Today, JavaScript is doing a lot of things that were probably
    never imagined when it was created by Netscape in 1995\. JavaScript is an interpreted
    language, meaning that it must be parsed, compiled, and optimized on the fly.
    JavaScript is also a dynamically typed language, which creates headaches for an
    optimizer.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript已经存在很长时间了。它已经从一个允许在网页上添加花里胡哨的小脚本语言发展成一个庞大的JIT编译语言生态系统，可以用来编写完整的应用程序。如今，JavaScript正在做许多在1995年由网景创建时可能从未想象过的事情。JavaScript是一种解释语言，这意味着它必须在运行时进行解析、编译和优化。JavaScript也是一种动态类型语言，这给优化器带来了麻烦。
- en: 'Franziska Hinkelmann, a member of the Chrome V8 team, gave a great talk at
    the *Web Rebels 2017* conference where she discusses all the performance improvements
    made to JavaScript over the past 20 years, as well as the difficulties they had
    in squeezing every bit of performance imaginable out of the JavaScript V8 engine:
    [https://youtu.be/ihANrJ1Po0w](https://youtu.be/ihANrJ1Po0w).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome V8团队成员Franziska Hinkelmann在*Web Rebels 2017*会议上发表了一次精彩的演讲，她讨论了过去20年来对JavaScript所做的所有性能改进，以及他们在JavaScript
    V8引擎中尽可能挤出每一点性能时遇到的困难：[https://youtu.be/ihANrJ1Po0w](https://youtu.be/ihANrJ1Po0w)。
- en: WebAssembly solves a lot of the problems created by JavaScript and its long
    history in the browser. Because the JavaScript engine is already in bytecode format,
    it does not need to run a parser, which removes a significant bottleneck in the
    execution of our application. This design also allows the JavaScript engine to
    know what data types it is dealing with at all times. The bytecode makes optimization
    a lot easier. The format allows multiple threads in the browsers to work on compiling
    and optimizing different parts of the code at the same time.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly解决了JavaScript及其在浏览器中的悠久历史所带来的许多问题。因为JavaScript引擎已经是字节码格式，所以不需要运行解析器，这消除了应用程序执行中的一个重要瓶颈。这种设计还允许JavaScript引擎始终知道它正在处理的数据类型。字节码使优化变得更加容易。这种格式允许浏览器中的多个线程同时处理编译和优化代码的不同部分。
- en: 'For a detailed explanation of what is happening when the Chrome V8 engine is
    parsing code, please refer to this video from the *JSConf EU 2017*, in which Marja
    Hölttä (who works on the Chrome V8 tool) goes into more detail than you ever imagined
    you wanted to learn about parsing JavaScript: [https://www.youtube.com/watch?v=Fg7niTmNNLg&t=123s](https://www.youtube.com/watch?v=Fg7niTmNNLg&t=123s).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Chrome V8引擎解析代码时发生的详细解释，请参考*JSConf EU 2017*的这个视频，其中Chrome V8工具的Marja Hölttä（负责人）详细介绍了您可能想要了解有关解析JavaScript的更多细节：[https://www.youtube.com/watch?v=Fg7niTmNNLg&t=123s](https://www.youtube.com/watch?v=Fg7niTmNNLg&t=123s)。
- en: WebAssembly is not a high-level programming language, but a binary file with
    opcodes for a virtual machine. Currently, it is considered to be in an MVP stage
    of development. The technology is still in its infancy, but even now it offers
    notable performance and file size benefits for many use cases, such as game development.
    Because of the current limitations of WebAssembly, we have only two choices for
    languages to use for its development—C/C++ or Rust. The long-term plan for WebAssembly
    is to support a wide selection of programming languages for its development. If
    I wanted to write at the lowest level of abstraction, I could write everything
    in **Web Assembly Text** (**WAT**), but WAT was developed as a language to support
    debugging and testing and was not intended to be used by developers for writing
    applications.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly不是一种高级编程语言，而是一个带有虚拟机操作码的二进制文件。目前，它被认为处于MVP开发阶段。这项技术仍处于初期阶段，但即使现在，它也为许多用例提供了显著的性能和文件大小优势，例如游戏开发。由于WebAssembly目前的限制，我们只有两种选择用于其开发的语言
    - C/C++或Rust。WebAssembly的长期计划是支持多种编程语言进行开发。如果我想以最低的抽象级别编写，我可以在**Web Assembly Text**（**WAT**）中编写所有内容，但WAT是作为一种支持调试和测试的语言开发的，并不打算供开发人员用于编写应用程序。
- en: Why is WebAssembly faster than JavaScript?
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么WebAssembly比JavaScript快？
- en: As I have mentioned, WebAssembly is 10–800% faster than JavaScript, depending
    on the application. To understand why, I need to talk a little about what a JavaScript
    engine does when it runs JavaScript code versus what it has to do when it runs
    WebAssembly. I am going to talk specifically about V8 (the Chrome JavaScript engine),
    although, to my knowledge, the same general process exists within SpiderMonkey
    (Firefox) and the Chakra (IE & Edge) JavaScript engines.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所提到的，WebAssembly比JavaScript快10-800％，这取决于应用程序。要理解原因，我需要谈一下当运行JavaScript代码时JavaScript引擎做了什么，以及当运行WebAssembly时它必须做什么。我将专门谈谈V8（Chrome
    JavaScript引擎），尽管据我所知，相同的一般过程也存在于SpiderMonkey（Firefox）和Chakra（IE和Edge）JavaScript引擎中。
- en: The first thing the JavaScript engine does is parse your source code into an
    **Abstract Syntax Tree** (**AST**). The source is broken into branches and leaves
    based on the logic within your application. At this point, an interpreter starts
    processing the language that you are currently executing. For many years, JavaScript
    was just an interpreted language, so, if you ran the same code in your JavaScript
    100 times, the JavaScript engine had to take that code and convert it to machine
    code 100 times. As you can imagine, this is wildly inefficient.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript引擎的第一件事是将您的源代码解析成**抽象语法树**（**AST**）。源代码根据应用程序内的逻辑被分成分支和叶子。此时，解释器开始处理您当前执行的语言。多年来，JavaScript一直是一种解释语言，因此，如果您在JavaScript中运行相同的代码100次，JavaScript引擎必须将该代码转换为机器代码100次。可以想象，这是极其低效的。
- en: The Chrome browser introduced the first JavaScript JIT compiler in 2008\. A
    JIT compiler contrasts with an **Ahead-of-Time** (**AOT**) compiler in that it
    compiles your code as it is running that code. A profiler sits and watches the
    JavaScript execution looking for code that repeatedly executes. Whenever it sees
    code executed a few times, it marks that code as "warm" for JIT compilation. The
    compiler then compiles a bytecode representation of that JavaScript "stub" code.
    This bytecode is typically an **Intermediate Representation** (**IR**), one step
    removed from the machine-specific assembly language. Decoding the stub will be
    significantly faster than running the same lines of code through our interpreter
    the next time.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome浏览器在2008年引入了第一个JavaScript JIT编译器。JIT编译器与**提前编译**（**AOT**）编译器相对，它在运行代码时编译代码。一种分析器坐在那里观察JavaScript执行，寻找重复执行的代码。每当它看到代码执行几次时，就将该代码标记为JIT编译的“热”代码。然后编译器编译JavaScript“存根”代码的字节码表示。这个字节码通常是**中间表示**（**IR**），与特定于机器的汇编语言相去一步。解码存根将比下次通过解释器运行相同代码的速度快得多。
- en: 'Here are the steps needed to run JavaScript code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是运行JavaScript代码所需的步骤：
- en: '![](img/9dd90a0a-c663-46b1-9fa2-977cf4d76ee7.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9dd90a0a-c663-46b1-9fa2-977cf4d76ee7.png)'
- en: 'Figure 1.1: Steps required by a modern JavaScript engine'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：现代JavaScript引擎所需的步骤
- en: While all of this is going on, there is an **optimizing compiler** that is watching
    the profiler for "hot" code branches. The optimizing compiler then takes these
    code branches and optimizes the bytecode that was created by the JIT into highly
    optimized machine code. At this point, the JavaScript engine has created some
    super fast running code, but there is a catch (or maybe a few).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些情况下，还有一个**优化编译器**正在观察分析器以寻找“热”代码分支。优化编译器然后将这些代码分支优化为JIT创建的字节码的高度优化的机器代码。此时，JavaScript引擎已经创建了一些运行速度非常快的代码，但有一个问题（或者可能有几个）。
- en: The JavaScript engine must make some assumptions about the data types to have
    an optimized machine code. The problem is, JavaScript is a dynamically typed language.
    Dynamic typing makes it easier for a programmer to learn how to program JavaScript,
    but it is a terrible choice for code optimizers. The example I often see is what
    happens when JavaScript sees the expression `c = a + b` (although we could use
    this example for almost any expression).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript引擎必须对数据类型做出一些假设，以获得优化的机器代码。问题是，JavaScript是一种动态类型语言。动态类型使程序员更容易学习如何编写JavaScript代码，但对于代码优化器来说却是一个糟糕的选择。我经常看到的例子是，当JavaScript看到表达式`c
    = a + b`时会发生什么（尽管我们几乎可以将此示例用于任何表达式）。
- en: 'Just about any machine code that performs this operation does it in three steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此操作的任何机器代码几乎都需要三个步骤：
- en: Load the `a` value into a register.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`a`值加载到一个寄存器中。
- en: Add the `b` value into a register.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`b`值添加到一个寄存器中。
- en: Then store the register into `c`.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将寄存器存储到`c`中。
- en: 'The following pseudo code was taken from section 12.8.3 of the *ECMAScript®
    2018 Language Specification* and describes the code that must run whenever the
    addition operator (+) is used within JavaScript:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下伪代码摘自*ECMAScript® 2018语言规范*的第12.8.3节，描述了JavaScript中使用加法运算符（+）时必须运行的代码：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can find the *ECMAScript® 2018 Language Specification* on the web at [https://www.ecma-international.org/ecma-262/9.0/index.html](https://www.ecma-international.org/ecma-262/9.0/index.html).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在网上找到*ECMAScript® 2018语言规范*，网址为[https://www.ecma-international.org/ecma-262/9.0/index.html](https://www.ecma-international.org/ecma-262/9.0/index.html)。
- en: 'This pseudo code is not the entirety of what we must evaluate. Several of these
    steps are calling high-level functions, not running machine code commands. `GetValue`
    for example, has 11 steps of its own that are, in turn, calling other steps. All
    of this could end up resulting in hundreds of machine opcodes. The vast majority
    of what is happening here is type checking. In JavaScript, when you execute `a
    + b`, each one of those variables could be any one of the following types:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个伪代码并不是我们必须评估的全部内容。其中几个步骤是调用高级函数，而不是运行机器代码命令。例如，`GetValue`本身就有11个步骤，反过来又调用其他步骤。所有这些可能最终导致数百个机器操作码。这里发生的绝大部分是类型检查。在JavaScript中，当您执行`a
    + b`时，每个变量都可能是以下类型之一：
- en: Integer
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数
- en: Float
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点数
- en: String
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Object
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象
- en: Any combination of these
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些的任何组合
- en: 'To make matters worse, objects in JavaScript are also highly dynamic. For example,
    maybe you have defined a function called `Point` and created two objects with
    that function using the new operator:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，JavaScript中的对象也是高度动态的。例如，也许您已经定义了一个名为`Point`的函数，并使用`new`运算符创建了两个具有该函数的对象：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now we have two points that share the same class. Say we added this line:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个共享相同类的点。假设我们添加了这行：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This would mean that these two points would then no longer share the same class.
    Effectively, `p2` has become a brand new class, and this has consequences for
    where that object exists in memory and available optimizations. JavaScript was
    designed to be a highly flexible language, but this fact creates a lot of corner
    cases, and corner cases make optimization difficult.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着这两个点将不再共享相同的类。实际上，`p2`已经成为一个全新的类，这对该对象在内存中的存在位置和可用的优化产生了影响。JavaScript被设计为一种高度灵活的语言，但这一事实产生了许多特殊情况，而特殊情况使优化变得困难。
- en: Another problem with optimization created by the dynamic nature of JavaScript
    is that no optimization is definitive. All optimizations around typing have to
    use resources continually checking to see whether their typing assumptions are
    still valid. Also, the optimizer has to keep the non-optimized code just in case
    those assumptions turn out to be false. The optimizer may determine that assumptions
    made initially turn out not to have been correct assumptions. That results in
    a "bailout" where the optimizer will throw away its optimized code and deoptimize,
    causing performance inconsistencies.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript动态特性带来的另一个优化问题是，没有一种优化是最终的。所有围绕类型的优化都必须不断使用资源进行检查，以查看它们的类型假设是否仍然有效。此外，优化器必须保留非优化代码，以防这些假设被证明是错误的。优化器可能会确定最初做出的假设结果是不正确的。这会导致“退出”，优化器将丢弃其优化代码并取消优化，导致性能不一致。
- en: Finally, JavaScript is a language with **Garbage Collection** (**GC**), which
    allows the authors of the JavaScript code to take on less of the burden of memory
    management while writing their code. Although this is a convenience for the developer,
    it just pushes the work of memory management on to the machine at run time. GC
    has become much more efficient in JavaScript over the years, but it is still work
    that the JavaScript engine must do when running JavaScript that it does not need
    to do when running WebAssembly.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，JavaScript是一种具有**垃圾收集**（**GC**）的语言，这使得JavaScript代码的作者在编写代码时可以承担更少的内存管理负担。尽管这对开发人员来说很方便，但它只是将内存管理的工作推迟到运行时的机器上。多年来，JavaScript中的GC变得更加高效，但在运行JavaScript时，JavaScript引擎仍然必须执行这项工作，而在运行WebAssembly时则不需要。
- en: Executing a WebAssembly module removes many of the steps required to run JavaScript
    code. WebAssembly eliminates parsing because the AOT compiler completes that function.
    An interpreter is unnecessary. Our JIT compiler is doing a near one-to-one translation
    from bytecode to machine code, which is extremely fast. JavaScript requires the
    majority of its optimizations because of dynamic typing that does not exist in
    WebAssembly. Hardware agnostic optimizations can be done in the AOT compiler before
    the WebAssembly compiles. The JIT optimizer need only perform hardware-specific
    optimizations that the WebAssembly AOT compiler cannot.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 执行WebAssembly模块消除了运行JavaScript代码所需的许多步骤。WebAssembly消除了解析，因为AOT编译器完成了该功能。解释器是不必要的。我们的JIT编译器正在进行近乎一对一的字节码到机器码的转换，这是非常快的。JavaScript需要大部分优化是因为WebAssembly中不存在的动态类型。在WebAssembly编译之前，AOT编译器可以进行与硬件无关的优化。JIT优化器只需要执行WebAssembly
    AOT编译器无法执行的特定于硬件的优化。
- en: 'Here are the steps performed by the JavaScript engine to run a WebAssembly
    binary:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是JavaScript引擎执行WebAssembly二进制文件的步骤：
- en: '![](img/1d7fb906-b411-416d-a1a2-b32a2812d1ac.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d7fb906-b411-416d-a1a2-b32a2812d1ac.png)'
- en: 'Figure 1.2: The steps required to execute WebAssembly'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：执行WebAssembly所需的步骤
- en: The last thing that I would like to mention is not a feature of the current
    MVP, but a potential future enabled by WebAssembly. All the code that makes modern
    JavaScript fast takes up memory. Keeping old copies of the nonoptimized code for
    bailout takes up memory. Parsers, interpreters, and garbage collectors all take
    up memory. On my desktop, Chrome frequently takes up about 1 GB of memory. By
    running a few tests on my website using [https://www.classicsolitaire.com](https://www.classicsolitaire.com),
    I can see that with the JavaScript engine turned on, the Chrome browser takes
    up about 654 MB of memory.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要提到的最后一件事不是当前MVP的特性，而是WebAssembly可能带来的未来。使现代JavaScript运行速度快的所有代码都占用内存。保留非优化代码的旧副本占用内存。解析器、解释器和垃圾收集器都占用内存。在我的桌面上，Chrome经常占用大约1GB的内存。通过在我的网站[https://www.classicsolitaire.com](https://www.classicsolitaire.com)上运行一些测试，我可以看到启用JavaScript引擎时，Chrome浏览器占用约654MB的内存。
- en: 'Here is a Task Manager screenshot:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个任务管理器的截图：
- en: '![](img/8d052928-1b7a-4284-a3c1-f65bae8e02e6.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d052928-1b7a-4284-a3c1-f65bae8e02e6.png)'
- en: 'Figure 1.3: Chrome Task Manager process screenshot with JavaScript'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3：启用JavaScript的Chrome任务管理器进程截图
- en: With JavaScript turned off, the Chrome browser takes up about 295MB.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭JavaScript后，Chrome浏览器占用约295MB。
- en: 'Here is a Task Manager screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个任务管理器的截图：
- en: '![](img/2a92e10a-f57d-4275-92d0-09154ab9b9ea.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2a92e10a-f57d-4275-92d0-09154ab9b9ea.png)'
- en: 'Figure 1.4: Chrome Task Manager process screenshot without JavaScript'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4：没有JavaScript的Chrome任务管理器进程截图
- en: Because this is one of my websites, I know there are only a few hundred kilobytes
    of JavaScript code on that website. It's a little shocking to me that running
    that tiny amount of JavaScript code can increase my browser footprint by about
    350 MB. Currently, WebAssembly runs on top of the existing JavaScript engines
    and still requires quite a bit of JavaScript glue code to make everything work,
    but in the long run, WebAssembly will not only allow us to speed up execution
    on the web but will also let us do it with a much smaller memory footprint.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是我的网站之一，我知道该网站上只有几百千字节的JavaScript代码。对我来说，令人震惊的是，运行这么少量的JavaScript代码会使我的浏览器占用大约350MB的内存。目前，WebAssembly在现有的JavaScript引擎上运行，并且仍然需要相当多的JavaScript粘合代码来使一切正常运行，但从长远来看，WebAssembly不仅将允许我们加快Web上的执行速度，还将使我们能够以更小的内存占用来实现。
- en: Will WebAssembly replace JavaScript?
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebAssembly会取代JavaScript吗？
- en: The short answer to this question is not anytime soon. At present, WebAssembly
    is still in its MVP stage. At this stage, the number of use cases is limited to
    applications where WebAssembly has limited back and forth with the JavaScript
    and the **D****ocument Object Model** (**DOM**). WebAssembly is not currently
    able to directly interact with the DOM, and Emscripten uses JavaScript "glue code"
    to make that interaction work. That interaction will probably change soon, possibly
    by the time you are reading this, but in the next few years, WebAssembly will
    need additional features to increase the number of possible use cases.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的回答是不会很快。目前，WebAssembly仍处于MVP阶段。在这个阶段，使用案例的数量仅限于WebAssembly与JavaScript和文档对象模型（DOM）之间的有限来回。WebAssembly目前无法直接与DOM交互，Emscripten使用JavaScript“粘合代码”来实现该交互。这种交互可能很快会发生变化，可能在您阅读本文时就已经发生了，但在未来几年，WebAssembly将需要额外的功能来增加可能的使用案例数量。
- en: WebAssembly is not a "feature complete" platform. Currently, it cannot be used
    with any languages that require GC. That will change and, eventually, almost all
    strongly typed languages will target WebAssembly. In addition, WebAssembly will
    soon become tightly integrated with JavaScript, allowing frameworks such as React,
    Vue, and Angular to begin replacing significant amounts of their JavaScript code
    with WebAssembly without impacting the **application programming interface** (**API**).
    The React team is currently working on this to improve the performance of React.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly并不是一个“功能完备”的平台。目前，它无法与任何需要GC的语言一起使用。这种情况将会改变，最终，几乎所有强类型语言都将以WebAssembly为目标。此外，WebAssembly很快将与JavaScript紧密集成，允许诸如React、Vue和Angular等框架开始用WebAssembly替换大量的JavaScript代码，而不影响应用程序编程接口（API）。React团队目前正在努力改进React的性能。
- en: In the long run, it is possible that JavaScript may compile into WebAssembly.
    For technical reasons, this is a very long way off. Not only does JavaScript require
    a GC (not currently supported), but because of its dynamic nature, JavaScript
    also requires a runtime profiler to optimize. Therefore, JavaScript would produce
    very poorly optimized code, or significant modifications would be needed to support
    strict typing. It is more likely that a language, such as TypeScript, will add
    features that allow it to compile into WebAssembly.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从长远来看，JavaScript可能会编译成WebAssembly。出于技术原因，这还有很长的路要走。JavaScript不仅需要GC（目前不支持），而且由于其动态特性，JavaScript还需要运行时分析器来进行优化。因此，JavaScript将产生非常糟糕的优化代码，或者需要进行重大修改以支持严格类型。更有可能的是，像TypeScript这样的语言将添加功能，使其能够编译成WebAssembly。
- en: The *AssemblyScript* project in development on GitHub is working on a TypeScript-to-WebAssembly
    compiler. This project creates JavaScript and uses Binaryen to compile that JavaScript
    into WebAssembly. How AssemblyScript handles the problem of garbage collection
    is unclear. For more information, refer to [https://github.com/AssemblyScript/assemblyscript](https://github.com/AssemblyScript/assemblyscript).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub上开发的*AssemblyScript*项目正在开发一个TypeScript到WebAssembly的编译器。该项目创建JavaScript并使用Binaryen将该JavaScript编译成WebAssembly。AssemblyScript如何处理垃圾回收的问题尚不清楚。有关更多信息，请参阅[https://github.com/AssemblyScript/assemblyscript](https://github.com/AssemblyScript/assemblyscript)。
- en: JavaScript is currently ubiquitous on the web; there are a tremendous number
    of libraries and frameworks developed in JavaScript. Even if there were an army
    of developers eager to rewrite the entire web in C++ or Rust, WebAssembly is not
    yet ready to replace these JavaScript libraries and frameworks. The browser makers
    have put immense efforts into making JavaScript run (relatively) fast, so JavaScript
    will probably remain as the standard scripting language for the web. The web will
    always need a scripting language, and countless developers have already put in
    the work to make JavaScript that scripting language, so it seems unlikely that
    JavaScript will ever go away.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript目前在网络上无处不在；有大量的库和框架是用JavaScript开发的。即使有一大批开发人员渴望用C++或Rust重写整个网络，WebAssembly也还没有准备好取代这些JavaScript库和框架。浏览器制造商已经付出了巨大的努力来使JavaScript运行（相对）快速，因此JavaScript可能仍然会成为网络的标准脚本语言。网络将始终需要一种脚本语言，无数开发人员已经努力使JavaScript成为这种脚本语言，因此JavaScript很可能永远不会消失。
- en: There is, however, a need for a compiled format for the web that WebAssembly
    is likely to fulfill. Compiled code may be a niche on the web at the moment, but
    it is a standard just about everywhere else. As WebAssembly approaches feature-complete
    status, it will offer more choices and better performance than JavaScript, and
    businesses, frameworks, and libraries will gradually migrate toward it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，网络需要一种编译格式，WebAssembly很可能会满足这种需求。目前，编译代码可能在网络上只是一个小众市场，但在其他地方却是标准。随着WebAssembly接近功能完备的状态，它将提供比JavaScript更多的选择和更好的性能，企业、框架和库将逐渐向其迁移。
- en: What is asm.js?
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是asm.js？
- en: One early attempt to achieve native-like speed in the web browser using JavaScript
    was asm.js. Although that goal was reached and asm.js was adopted by all the major
    browser vendors, it never achieved widespread adoption by developers. The beauty
    of asm.js is that it still runs in most browsers, even in those that do not optimize
    for it. The idea behind asm.js was that typed arrays could be used in JavaScript
    to fake a C++ memory heap. The browser simulates pointers and memory allocation
    in C++, as well as types. A well-designed JavaScript engine can avoid dynamic
    type checking. Using asm.js, browser makers could get around many of the optimization
    problems created by the dynamic nature of JavaScript, by just pretending that
    this version of JavaScript is not dynamically typed. Emscripten, designed as a
    C++-to-JavaScript compiler, quickly adopted asm.js as the subset of JavaScript
    that it would compile to because of its improved performance in most browsers.
    The performance improvements driven by asm.js lead the way to WebAssembly. The
    same engine modifications used to make asm.js perform well could be used to bootstrap
    the WebAssembly MVP. Only the addition of a bytecode-to-bytecode compiler was
    required to take the WebAssembly bytecode and directly convert it into the IR
    bytecode used by the browser.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 早期实现在Web浏览器中使用JavaScript实现类似本机速度的尝试是asm.js。尽管达到了这个目标，并且asm.js被所有主要浏览器供应商采用，但它从未被开发人员广泛采用。asm.js的美妙之处在于它仍然可以在大多数浏览器中运行，即使在那些不对其进行优化的浏览器中也是如此。asm.js的理念是，可以在JavaScript中使用类型化数组来模拟C++内存堆。浏览器模拟C++中的指针和内存分配，以及类型。设计良好的JavaScript引擎可以避免动态类型检查。使用asm.js，浏览器制造商可以避开JavaScript动态特性带来的许多优化问题，只需假装这个版本的JavaScript不是动态类型的即可。Emscripten作为C++到JavaScript编译器，迅速采用了asm.js作为其编译的JavaScript子集，因为它在大多数浏览器中的性能得到了改善。由asm.js带来的性能改进引领了WebAssembly的发展。用于使asm.js性能良好的相同引擎修改可以用来引导WebAssembly
    MVP。只需要添加一个字节码到字节码编译器，就可以将WebAssembly字节码直接转换为浏览器使用的IR字节码。
- en: At the time of writing, Emscripten does not compile directly from LLVM to WebAssembly.
    Instead, it compiles to asm.js and uses a tool called Binaryen to convert the
    asm.js output from Emscripten into WebAssembly.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Emscripten不能直接从LLVM编译到WebAssembly。相反，它将编译为asm.js，并使用一个名为Binaryen的工具将Emscripten的asm.js输出转换为WebAssembly。
- en: A brief introduction to LLVM
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LLVM简介
- en: Emscripten is the tool we will be using to compile C++ into WebAssembly. Before
    I discuss Emscripten, I need to explain a technology called LLVM and its relationship
    to Emscripten.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Emscripten是我们将用来将C++编译成WebAssembly的工具。在讨论Emscripten之前，我需要解释一下一个名为LLVM的技术以及它与Emscripten的关系。
- en: 'First, take a moment to think of airlines (stay with me here). Airlines want
    to get passengers from one airport to another airport. But it''s challenging to
    offer a direct flight from every single airport to every other airport on Earth.
    That would mean that airlines would have to provide a vast number of direct flights,
    such as Akron, Ohio to Mumbai, India. Let''s travel back in time to the 1990s—that
    was the state of the compiler world. If you wanted to compile from C++ to ARM,
    you needed a compiler capable of compiling C++ to ARM. If you needed to compile
    from Pascal to x86, you needed a compiler that could compile from Pascal to x86\.
    These are like having only direct flights between any two cities: a compiler for
    every combination of language and hardware. The result is either that you have
    to limit the number of languages you write compilers for, limit the number of
    platforms you can support with that language, or more likely, both.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，花点时间想想航空公司（跟着我）。航空公司希望将乘客从一个机场运送到另一个机场。但是要为每个机场到地球上的每个其他机场提供直达航班是具有挑战性的。这意味着航空公司必须提供大量的直达航班，比如从俄亥俄州的阿克伦到印度的孟买。让我们回到20世纪90年代，那是编译器世界的状态。如果你想要从C++编译到ARM，你需要一个能够将C++编译到ARM的编译器。如果你需要从Pascal编译到x86，你需要一个能够将Pascal编译到x86的编译器。这就像在任何两个城市之间只有直达航班一样：每种语言和硬件的组合都需要一个编译器。结果要么是你必须限制你为其编写编译器的语言数量，限制你可以支持的平台数量，或者更可能的是两者都有。
- en: 'In 2003, a student at the University of Illinois named Chris Lattner wondered,
    "What if we created a hub-and-spoke model for programming languages?" His idea
    led to LLVM, which originally stood for "Low-Level Virtual Machine." The idea
    was that, instead of compiling your source code for any possible distribution,
    you compile it for LLVM. There are then compilers between the intermediate language
    and your final output language. In theory, this means that if you develop a new
    target platform on the right side of the following diagram, you get all languages
    on the left side right away:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 2003年，伊利诺伊大学的一名学生克里斯·拉特纳想到了一个问题：“如果我们为编程语言创建一个轮毂和辐条模型会怎样？”他的想法导致了LLVM的诞生，LLVM最初代表“低级虚拟机”。其理念是，不是为了任何可能的分发编译源代码，而是为了LLVM。然后在中间语言和最终输出语言之间进行编译。理论上，这意味着如果你在下图的右侧开发了一个新的目标平台，你立即就能得到左侧所有语言：
- en: '![](img/e5aaec1e-100f-4f61-9bb7-d072053b93dc.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5aaec1e-100f-4f61-9bb7-d072053b93dc.png)'
- en: 'Figure 1.5: LLVM as a hub between programming languages and the hardware'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5：LLVM作为编程语言和硬件之间的轮毂。
- en: 'To learn more about LLVM, visit the LLVM project home page at [https://llvm.org](https://llvm.org)
    or read the *LLVM Cookbook*, *Mayur Padney*, *and Suyog Sarda*, *Packt Publishing*:
    [https://www.packtpub.com/application-development/llvm-cookbook](https://www.packtpub.com/application-development/llvm-cookbook).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于LLVM的信息，请访问LLVM项目主页[https://llvm.org](https://llvm.org)或阅读《LLVM Cookbook》，作者Mayur
    Padney和Suyog Sarda，Packt Publishing：[https://www.packtpub.com/application-development/llvm-cookbook](https://www.packtpub.com/application-development/llvm-cookbook)。
- en: A brief introduction to WebAssembly text
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebAssembly文本简介
- en: WebAssembly binary is not a language, but a build target similar to building
    for ARM or x86\. The bytecode, however, is structured differently than other hardware-specific
    build targets. The designers of the WebAssembly bytecode had the web in mind.
    The aim was to create a bytecode that was compact and streamable. Another goal
    was that the user should be able to do a "view/source" on the WebAssembly binary
    to see what is going on. WebAssembly text is a companion code to the WebAssembly
    binary that allows the user to view the bytecode instructions in a human-readable
    form, similar to the way an assembly language would let you see what opcodes execute
    in a machine-readable form.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly二进制不是一种语言，而是类似于为ARM或x86构建的构建目标。然而，字节码的结构与其他特定硬件的构建目标不同。WebAssembly字节码的设计者考虑了网络。目标是创建一种紧凑且可流式传输的字节码。另一个目标是用户应该能够对WebAssembly二进制执行“查看/源代码”以查看发生了什么。WebAssembly文本是WebAssembly二进制的伴随代码，允许用户以人类可读的形式查看字节码指令，类似于汇编语言可以让您以机器可读的形式查看操作码。
- en: WebAssembly text may initially look unfamiliar to someone used to writing assembly
    for hardware such as ARM, x86, or 6502 (if you're old school). You write WebAssembly
    text in S-expressions, which has a parentheses-heavy tree structure. Some of the
    operations are also strikingly high level for an assembly language, such as if/else
    and loop opcodes. That makes a lot more sense if you remember that WebAssembly
    was not designed to run directly on computer hardware, but to download and translate
    into machine code quickly.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于习惯于为ARM、x86或6502（如果您是老派的话）等硬件编写汇编的人来说，WebAssembly文本可能一开始看起来很陌生。您可以使用S表达式编写WebAssembly文本，它具有括号密集的树结构。一些操作对于汇编语言来说也非常高级，例如if/else和loop操作码。如果您记得WebAssembly不是设计为直接在计算机硬件上运行，而是快速下载和转换为机器码，那么这就更有意义了。
- en: Another thing that will seem a little alien at first when you are dealing with
    WebAssembly text is the lack of registers. WebAssembly is designed to be a virtual
    *stack machine*, which is an alternative to a *register machine*, such as x86
    and ARM, with which you might be familiar. A stack machine has the advantage of
    producing significantly smaller bytecode than a register machine, which is one
    good reason to choose a stack machine for WebAssembly. Instead of using a series
    of registers to store and manipulate numbers, every opcode in a stack machine
    pushes values on or off a stack (and sometimes does both). For example, a call
    to `i32.add` in WebAssembly pulls two 32-bit integers off the stack, adds them
    together, then pushes their value back on to the stack. The computer hardware
    can make the best use of whichever registers are available to perform this operation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 处理WebAssembly文本时，刚开始会感到有些陌生的另一件事是缺少寄存器。WebAssembly被设计为一种虚拟*堆栈机*，这是一种与您可能熟悉的x86和ARM等*寄存器机*不同的替代机器。堆栈机的优势在于生成的字节码比寄存器机小得多，这是选择堆栈机用于WebAssembly的一个很好的理由。堆栈机不是使用一系列寄存器来存储和操作数字，而是在堆栈上推送或弹出值（有时两者都有）。例如，在WebAssembly中调用`i32.add`会从堆栈中取出两个32位整数，将它们相加，然后将结果推送回堆栈。计算机硬件可以充分利用可用的寄存器来执行此操作。
- en: Emscripten
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Emscripten
- en: Now that we know what LLVM is, we can discuss Emscripten. Emscripten was developed
    to compile LLVM IR into JavaScript, but has recently been updated to compile LLVM
    into WebAssembly. The idea is that, when you get the LLVM compiler working, you
    can have the benefit of all the languages that compile to LLVM IR. In practice,
    the WebAssembly specification is still in its early days and does not support
    common language features such as GC. Therefore, only non-GC languages such as
    C/C++ and Rust are currently supported. WebAssembly is still in the early MVP
    phase of its development, but the addition of GC and other common language features
    are coming soon. When that happens, there should be an explosion of programming
    languages that will compile to WebAssembly.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了LLVM是什么，我们可以讨论Emscripten。Emscripten最初是开发为将LLVM IR编译成JavaScript，但最近已更新为将LLVM编译成WebAssembly。其想法是，一旦您使LLVM编译器工作，您就可以获得编译为LLVM
    IR的所有语言的好处。实际上，WebAssembly规范仍处于早期阶段，不支持诸如GC之类的常见语言特性。因此，目前仅支持非GC语言，如C/C++和Rust。WebAssembly仍处于其发展的早期MVP阶段，但很快将添加GC和其他常见语言特性。发生这种情况时，应该会有大量编程语言可以编译为WebAssembly。
- en: When Emscripten was released in 2012, it was intended to be an LLVM-to-JavaScript
    compiler. In 2013, support was added for asm.js, which is a faster, easily optimized
    subset of the JavaScript language. In 2015, Emscripten began to add support for
    LLVM-to-WebAssembly compiling. Emscripten also provides a **Software Development
    Kit** (**SDK**) for both C++ and JavaScript that provides glue code to give users
    better tools for interaction between JavaScript and WebAssembly than those currently
    offered by the WebAssembly MVP alone. Emscripten also integrates with a C/C++-to-LLVM
    compiler called Clang, so that you can compile your C++ into WebAssembly. In addition,
    Emscripten will generate the HTML and JavaScript glue code you need to get your
    project started.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Emscripten于2012年发布时，旨在成为LLVM到JavaScript的编译器。2013年，添加了对asm.js的支持，这是JavaScript语言的更快、更易优化的子集。2015年，Emscripten开始添加对LLVM到WebAssembly的编译支持。Emscripten还为C++和JavaScript提供了**软件开发工具包**（**SDK**），提供了比WebAssembly
    MVP本身提供的更好的JavaScript和WebAssembly交互工具。Emscripten还集成了一个名为Clang的C/C++到LLVM编译器，因此您可以将C++编译成WebAssembly。此外，Emscripten将生成您启动项目所需的HTML和JavaScript粘合代码。
- en: Emscripten is a very dynamic project and changes to the toolchain happen frequently.
    To stay up to date with the latest changes in Emscripten, visit the project home
    page at [https://emscripten.org](https://emscripten.org).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Emscripten是一个非常动态的项目，工具链经常发生变化。要了解Emscripten的最新变化，请访问项目主页[https://emscripten.org](https://emscripten.org)。
- en: Installing Emscripten on Windows
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows上安装Emscripten
- en: 'I am going to keep this section brief because these instructions are subject
    to change. You can supplement these instructions with the official Emscripten
    download and install instructions found on the Emscripten website: [https://emscripten.org/docs/getting_started/downloads.html](https://emscripten.org/docs/getting_started/downloads.html).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我将保持本节简短，因为这些说明可能会发生变化。您可以在Emscripten网站上找到官方Emscripten下载和安装说明来补充这些说明：[https://emscripten.org/docs/getting_started/downloads.html](https://emscripten.org/docs/getting_started/downloads.html)。
- en: We will need to download and build Emscripten from the emsdk source files on
    GitHub. First, we will walk through what to do on Windows.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从GitHub上的emsdk源文件下载并构建Emscripten。首先，我们将介绍在Windows上的操作。
- en: 'Python 2.7.12 or higher is a prerequisite. If you do not have a version of
    Python higher than 2.7.12 installed, you will need to get the windows installer
    from [python.org](http://python.org) and install that first: [https://www.python.org/downloads/windows/](https://www.python.org/downloads/windows/).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Python 2.7.12或更高版本是必需的。如果您尚未安装高于2.7.12的Python版本，您需要从[python.org](http://python.org)获取Windows安装程序并首先安装：[https://www.python.org/downloads/windows/](https://www.python.org/downloads/windows/)。
- en: 'If you have installed Python and you are still getting errors telling you that
    Python is not found, you may need to add Python to your Windows PATH variable.
    For more information, refer to this tutorial: [https://www.pythoncentral.io/add-python-to-path-python-is-not-recognized-as-an-internal-or-external-command/](https://www.pythoncentral.io/add-python-to-path-python-is-not-recognized-as-an-internal-or-external-command/).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已安装Python，但仍然收到Python未找到的错误提示，可能需要将Python添加到Windows的PATH变量中。有关更多信息，请参考本教程：[https://www.pythoncentral.io/add-python-to-path-python-is-not-recognized-as-an-internal-or-external-command/](https://www.pythoncentral.io/add-python-to-path-python-is-not-recognized-as-an-internal-or-external-command/)。
- en: 'If you have Git installed already, cloning the repository is relatively simple:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经安装了Git，则克隆存储库相对简单：
- en: 'Run the following command to clone the repository:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来克隆存储库：
- en: '[PRE3]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Wherever you run this command, it will create an `emsdk` directory. Enter that
    directory using the following:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论您在何处运行此命令，它都将创建一个“emsdk”目录。使用以下命令进入该目录：
- en: '[PRE4]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You may not have Git installed, in which case, the following steps will bring
    you up to speed:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能尚未安装Git，在这种情况下，以下步骤将帮助您迅速掌握：
- en: 'Go to the following URL in a web browser: [https://github.com/emscripten-core/emsdk](https://github.com/juj/emsdk).'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Web浏览器中转到以下URL：[https://github.com/emscripten-core/emsdk](https://github.com/juj/emsdk)。
- en: 'You will see a green button on the right-hand side that says Clone or download.
    Download the ZIP file:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将在右侧看到一个绿色按钮，上面写着克隆或下载。下载ZIP文件：
- en: '![](img/bb90bfed-56b4-4e14-a43d-455d5d850245.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb90bfed-56b4-4e14-a43d-455d5d850245.png)'
- en: Unzip the downloaded file to the `c:\emsdk` directory.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将下载的文件解压缩到`c:\emsdk`目录。
- en: Open up a Windows Command Prompt by typing `cmd` into the start menu and pressing
    *Enter*.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在开始菜单中输入“cmd”并按*Enter*来打开Windows命令提示符。
- en: 'From there, you can change to the `c:\emsdk\emsdk-master` directory by typing
    the following:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过输入以下内容将目录更改为`c:\emsdk\emsdk-master`目录：
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'At this point, it does not matter whether you had Git installed or not. Let''s
    move forward:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，无论您是否已安装Git都无关紧要。让我们继续向前：
- en: 'Install `emsdk` from the source code running the following command:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从源代码安装`emsdk`，运行以下命令：
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then activate the latest `emsdk`:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后激活最新的`emsdk`：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, set up our path and environment variables:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，设置我们的路径和环境变量：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This last step will need to be rerun from your install directory every time
    you open a new command-line window. Unfortunately, it does not permanently set
    the Windows environment variables. Hopefully, that will change in the future.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一步需要在您的安装目录中的每次打开新的命令行窗口时重新运行。不幸的是，它不会永久设置Windows环境变量。希望这在未来会有所改变。
- en: Installing Emscripten on Ubuntu
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Ubuntu上安装Emscripten
- en: 'If you are installing on Ubuntu, you should be able to use the `apt-get` package
    manager and git for the complete install. Let''s move forward:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Ubuntu上安装，您应该能够使用`apt-get`软件包管理器和git进行完整安装。让我们继续向前：
- en: 'Python is required, so if you do not have Python installed, be sure to run
    the following:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python是必需的，因此如果您尚未安装Python，请务必运行以下命令：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you do not already have Git installed, run the following:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您尚未安装Git，请运行以下命令：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now you will need to clone the Git repository for `emsdk`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您需要克隆`emsdk`的Git存储库：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Change your directory to move into the `emsdk` directory:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改您的目录以进入`emsdk`目录：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'From here, you need to install the latest version of the SDK tools, activate
    it, and set your environment variables:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这里，您需要安装最新版本的SDK工具，激活它，并设置您的环境变量：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To make sure everything was installed correctly, run the following command:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保一切安装正确，运行以下命令：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using Emscripten
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Emscripten
- en: 'We run Emscripten from the command line; therefore, you can use any text editor
    you choose to write your C/C++ code. Personally, I am partial to Visual Studio
    Code, which you can download here: [https://code.visualstudio.com/download](https://code.visualstudio.com/download).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过命令行运行Emscripten；因此，您可以使用任何文本编辑器来编写C/C++代码。我个人偏爱Visual Studio Code，您可以在此处下载：[https://code.visualstudio.com/download](https://code.visualstudio.com/download)。
- en: One beautiful thing about Visual Studio Code is that it has a built-in command-line
    terminal, which lets you compile your code without switching windows. It also
    has an excellent C/C++ extension that you can install. Just search for C/C++ from
    the extensions menu and install the Microsoft C/C++ Intellisense extension.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code的一个美妙之处在于它具有内置的命令行终端，这样您就可以在不切换窗口的情况下编译代码。它还有一个出色的C/C++扩展，您可以安装它。只需从扩展菜单中搜索C/C++并安装Microsoft
    C/C++ Intellisense扩展。
- en: Whatever you choose for your text editor or integrated development environment,
    you need a simple piece of C code to test out the emcc compiler.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您选择哪种文本编辑器或集成开发环境，您都需要一个简单的C代码片段来测试emcc编译器。
- en: Create a new text file and name it `hello.c`.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文本文件并将其命名为`hello.c`。
- en: 'Type the following code into `hello.c`:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`hello.c`中输入以下代码：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now I can compile the `hello.c` file into WebAssembly and generate a `hello.html`
    file:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我可以将`hello.c`文件编译成WebAssembly，并生成一个`hello.html`文件：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `--emrun` flag is necessary if you want to run the HTML page from `emrun`.
    This flag adds code that will capture `stdout`, `stderr`, and exit in the C code
    and `emrun` will not work without it:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想要从`emrun`运行HTML页面，则需要`--emrun`标志。此标志会在C代码中添加代码，以捕获`stdout`、`stderr`和退出，没有它`emrun`将无法工作：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Running `emrun` with the `--browser` flag will pick the browser where you would
    like to run the script. The behavior of `emrun` seems to be different between
    browsers. Chrome will close the window when the C program exits. That can be annoying
    because we are just trying to display a simple print message. If you have Firefox,
    I would suggest running `emrun` using the `--browser` flag.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`--browser`标志运行`emrun`将选择您想要运行脚本的浏览器。`emrun`的行为在不同的浏览器之间似乎是不同的。Chrome将在C程序退出时关闭窗口。这可能很烦人，因为我们只是想显示一个简单的打印消息。如果您有Firefox，我建议使用`--browser`标志运行`emrun`。
- en: I do not want to imply that Chrome cannot run WebAssembly. Chrome does have
    different behavior when a WebAssembly module exits. Because I was trying to keep
    our WebAssembly module as simple as possible, it exits when the main function
    completes. That is what is causing problems in Chrome. These problems will go
    away later when we learn about game loops.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我不想暗示Chrome不能运行WebAssembly。当WebAssembly模块退出时，Chrome的行为确实有所不同。因为我试图尽可能简化我们的WebAssembly模块，所以当主函数完成时，它就会退出。这就是在Chrome中出现问题的原因。当我们学习游戏循环时，这些问题将会消失。
- en: 'To find out what browsers are available to you, run the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看可用的浏览器，请运行以下命令：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`emrun` should open an Emscripten-templated HTML file in a browser.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`emrun`应该在浏览器中打开一个Emscripten模板的HTML文件。'
- en: 'Make sure you have a browser capable of running WebAssembly. The following
    versions of the major browsers should work with WebAssembly:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的浏览器能够运行WebAssembly。以下主要浏览器的版本应该能够运行WebAssembly：
- en: Edge 16
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Edge 16
- en: Firefox 52
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firefox 52
- en: Chrome 57
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chrome 57
- en: Safari 11
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Safari 11
- en: Opera 44
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Opera 44
- en: If you are familiar with setting up your own web server, you may want to consider
    using it rather than emrun. After using emrun for the first few chapters of this
    book, I returned to using my Node.js web server. I found it easier to have a Node-based
    web server up and running at all times, rather than restarting the emrun web server
    every time I wanted to test my code. If you know how to set up an alternative
    web server (such as one for Node, Apache, and IIS), you may use whatever web server
    you prefer. Although IIS requires some additional configuration to handle WebAssembly
    MIME types.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉设置自己的Web服务器，您可能希望考虑使用它而不是emrun。在本书的前几章中使用emrun后，我又开始使用我的Node.js Web服务器。我发现随时运行基于Node的Web服务器更容易，而不是每次想要测试代码时都重新启动emrun
    Web服务器。如果您知道如何设置替代Web服务器（如Node、Apache和IIS），您可以使用您喜欢的任何Web服务器。尽管IIS需要一些额外的配置来处理WebAssembly
    MIME类型。
- en: Additional installation resources
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他安装资源
- en: 'Creating an installation guide for Emscripten is going to be somewhat problematic.
    The WebAssembly technology changes frequently and the installation process for
    Emscripten may be different by the time you read this. I would recommend consulting
    the download and install instructions on the Emscripten website if you have any
    problems: [https://emscripten.org/docs/getting_started/downloads.html](https://emscripten.org/docs/getting_started/downloads.html).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为Emscripten创建安装指南可能会有些问题。WebAssembly技术经常发生变化，而Emscripten的安装过程在您阅读本文时可能已经不同。如果您遇到任何问题，我建议查阅Emscripten网站上的下载和安装说明：[https://emscripten.org/docs/getting_started/downloads.html](https://emscripten.org/docs/getting_started/downloads.html)。
- en: 'You may also want to consult the Emscripten page on GitHub: [https://github.com/emscripten-core/emsdk](https://github.com/emscripten-core/emsdk).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还想查阅GitHub上的Emscripten页面：[https://github.com/emscripten-core/emsdk](https://github.com/emscripten-core/emsdk)。
- en: 'Google Groups has an Emscripten discussion forum where you may ask questions
    if you are having installation problems: [https://groups.google.com/forum/?nomobile=true#!forum/emscripten-discuss](https://groups.google.com/forum/?nomobile=true#!forum/emscripten-discuss).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Google Groups有一个Emscripten讨论论坛，如果您在安装过程中遇到问题，可以在那里提问：[https://groups.google.com/forum/?nomobile=true#!forum/emscripten-discuss](https://groups.google.com/forum/?nomobile=true#!forum/emscripten-discuss)。
- en: 'You can also contact me on Twitter (`@battagline`), and I will do my best to
    help you: [https://twitter.com/battagline](https://twitter.com/battagline).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在Twitter上联系我（`@battagline`），我会尽力帮助您：[https://twitter.com/battagline](https://twitter.com/battagline)。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned what WebAssembly is and why it will be the future
    of application development on the web. We learned why we need WebAssembly, even
    though we already have a robust language like JavaScript. We learned why WebAssembly
    is so much faster than JavaScript, and how it has the potential to increase its
    performance lead. We have also discussed the possibility of WebAssembly replacing
    JavaScript as the de facto standard for application development on the web.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了WebAssembly是什么，以及为什么它将成为Web应用程序开发的未来。我们了解了为什么我们需要WebAssembly，尽管我们已经有了像JavaScript这样强大的语言。我们了解了为什么WebAssembly比JavaScript快得多，以及它如何有可能增加其性能优势。我们还讨论了WebAssembly取代JavaScript成为Web应用程序开发的事实标准的可能性。
- en: We have discussed the practical side of creating a WebAssembly module as it
    is done today using Emscripten and LLVM. We have talked about WebAssembly text
    and how it is structured. We have also discussed using Emscripten to compile our
    first WebAssembly module, as well as using it to create the HTML and JavaScript
    glue code to run that module.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了使用Emscripten和LLVM创建WebAssembly模块的实际方面。我们已经讨论了WebAssembly文本及其结构。我们还讨论了使用Emscripten编译我们的第一个WebAssembly模块，以及使用它创建运行该模块的HTML和JavaScript粘合代码。
- en: In the next chapter, we will go into further detail on how to use Emscripten
    to create our WebAssembly module, as well as the HTML/CSS and JavaScript used
    to drive it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更详细地讨论如何使用Emscripten来创建我们的WebAssembly模块，以及用于驱动它的HTML/CSS和JavaScript。
