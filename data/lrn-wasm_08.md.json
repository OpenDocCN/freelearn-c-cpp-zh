["```cpp\n\u251c\u2500\u2500 board.cpp\n\u251c\u2500\u2500 board.h\n\u251c\u2500\u2500 constants.h\n\u251c\u2500\u2500 game.cpp\n\u251c\u2500\u2500 game.h\n\u251c\u2500\u2500 main.cpp\n\u251c\u2500\u2500 piece.cpp\n\u2514\u2500\u2500 piece.h\n```", "```cpp\n#ifndef TETRIS_CONSTANTS_H\n#define TETRIS_CONSTANTS_H\n\nnamespace Constants {\n    const int BoardColumns = 10;\n    const int BoardHeight = 720;\n    const int BoardRows = 20;\n    const int BoardWidth = 360;\n    const int Offset = BoardWidth / BoardColumns;\n    const int PieceSize = 4;\n    const int ScreenHeight = BoardHeight + 50;\n}\n\n#endif // TETRIS_CONSTANTS_H\n```", "```cpp\n#ifndef TETRIS_PIECE_H\n#define TETRIS_PIECE_H\n\n#include <SDL2/SDL.h>\n#include \"constants.h\"\n\nclass Piece {\n public:\n  enum Kind { I = 0, J, L, O, S, T, Z };\n\n  explicit Piece(Kind kind);\n\n  void draw(SDL_Renderer *renderer);\n  void move(int columnDelta, int rowDelta);\n  void rotate();\n  bool isBlock(int column, int row) const;\n  int getColumn() const;\n  int getRow() const;\n\n private:\n  Kind kind_;\n  int column_;\n  int row_;\n  int angle_;\n};\n\n#endif // TETRIS_PIECE_H\n```", "```cpp\n#include \"piece.h\"\n\nusing namespace Constants;\n\nPiece::Piece(Piece::Kind kind) :\n    kind_(kind),\n    column_(BoardColumns / 2 - PieceSize / 2),\n    row_(0),\n    angle_(0) {\n}\n\nvoid Piece::draw(SDL_Renderer *renderer) {\n    switch (kind_) {\n        case I:\n            SDL_SetRenderDrawColor(renderer,\n                /* Cyan: */ 45, 254, 254, 255);\n            break;\n        case J:\n            SDL_SetRenderDrawColor(renderer,\n                /* Blue: */ 11, 36, 251, 255);\n            break;\n        case L:\n            SDL_SetRenderDrawColor(renderer,\n                /* Orange: */ 253, 164, 41, 255);\n            break;\n        case O:\n            SDL_SetRenderDrawColor(renderer,\n                /* Yellow: */ 255, 253, 56, 255);\n            break;\n       case S:\n            SDL_SetRenderDrawColor(renderer,\n                /* Green: */ 41, 253, 47, 255);\n            break;\n        case T:\n            SDL_SetRenderDrawColor(renderer,\n                /* Purple: */ 126, 15, 126, 255);\n            break;\n        case Z:\n            SDL_SetRenderDrawColor(renderer,\n                /* Red: */ 252, 13, 28, 255);\n            break;\n        }\n\n        for (int column = 0; column < PieceSize; ++column) {\n            for (int row = 0; row < PieceSize; ++row) {\n                if (isBlock(column, row)) {\n                    SDL_Rect rect{\n                        (column + column_) * Offset + 1,\n                        (row + row_) * Offset + 1,\n                        Offset - 2,\n                        Offset - 2\n                    };\n                SDL_RenderFillRect(renderer, &rect);\n            }\n        }\n    }\n}\n```", "```cpp\nvoid Piece::move(int columnDelta, int rowDelta) {\n    column_ += columnDelta;\n    row_ += rowDelta;\n}\n\nvoid Piece::rotate() {\n    angle_ += 3;\n    angle_ %= 4;\n}\n\nbool Piece::isBlock(int column, int row) const {\n    static const char *Shapes[][4] = {\n        // I\n        {\n            \" *  \"\n            \" *  \"\n            \" *  \"\n            \" *  \",\n            \"    \"\n            \"****\"\n            \"    \"\n            \"    \",\n            \" *  \"\n            \" *  \"\n            \" *  \"\n            \" *  \",\n            \"    \"\n            \"****\"\n            \"    \"\n            \"    \",\n        },\n        // J\n        {\n            \"  * \"\n            \"  * \"\n            \" ** \"\n            \"    \",\n            \"    \"\n            \"*   \"\n            \"*** \"\n            \"    \",\n            \" ** \"\n            \" *  \"\n            \" *  \"\n            \"    \",\n            \"    \"\n            \"    \"\n            \"*** \"\n            \" *  \",\n        },\n        ...\n    };\n    return Shapes[kind_][angle_][column + row * PieceSize] == '*';\n}\n\nint Piece::getColumn() const {\n return column_;\n}\nint Piece::getRow() const {\n return row_;\n}\n```", "```cpp\nint Piece::getColumn() const {\n    return column_;\n}\n\nint Piece::getRow() const {\n    return row_;\n}\n```", "```cpp\n#ifndef TETRIS_BOARD_H\n#define TETRIS_BOARD_H\n\n#include <SDL2/SDL.h>\n#include <SDL2/SDL2_ttf.h>\n#include \"constants.h\"\n#include \"piece.h\"\n\nusing namespace Constants;\n\nclass Board {\n public:\n  Board();\n  void draw(SDL_Renderer *renderer, TTF_Font *font);\n  bool isCollision(const Piece &piece) const;\n  void unite(const Piece &piece);\n\n private:\n  bool isRowFull(int row);\n  bool areFullRowsPresent();\n  void updateOffsetRow(int fullRow);\n  void displayScore(SDL_Renderer *renderer, TTF_Font *font);\n\n  bool cells_[BoardColumns][BoardRows];\n  int currentScore_;\n};\n\n#endif // TETRIS_BOARD_H\n```", "```cpp\n#include <sstream>\n#include \"board.h\"\n\nusing namespace Constants;\n\nBoard::Board() : cells_{{ false }}, currentScore_(0) {}\n\nvoid Board::draw(SDL_Renderer *renderer, TTF_Font *font) {\n    displayScore(renderer, font);\n    SDL_SetRenderDrawColor(\n        renderer,\n        /* Light Gray: */ 140, 140, 140, 255);\n    for (int column = 0; column < BoardColumns; ++column) {\n        for (int row = 0; row < BoardRows; ++row) {\n            if (cells_[column][row]) {\n                SDL_Rect rect{\n                    column * Offset + 1,\n                    row * Offset + 1,\n                    Offset - 2,\n                    Offset - 2\n                };\n                SDL_RenderFillRect(renderer, &rect);\n            }\n        }\n    }\n}\n```", "```cpp\nbool Board::isCollision(const Piece &piece) const {\n    for (int column = 0; column < PieceSize; ++column) {\n        for (int row = 0; row < PieceSize; ++row) {\n            if (piece.isBlock(column, row)) {\n                int columnTarget = piece.getColumn() + column;\n                int rowTarget = piece.getRow() + row;\n                if (\n                    columnTarget < 0\n                    || columnTarget >= BoardColumns\n                    || rowTarget < 0\n                    || rowTarget >= BoardRows\n                ) {\n                    return true;\n                }\n                if (cells_[columnTarget][rowTarget]) return true;\n            }\n        }\n    }\n    return false;\n}\n```", "```cpp\nvoid Board::unite(const Piece &piece) {\n    for (int column = 0; column < PieceSize; ++column) {\n        for (int row = 0; row < PieceSize; ++row) {\n            if (piece.isBlock(column, row)) {\n                int columnTarget = piece.getColumn() + column;\n                int rowTarget = piece.getRow() + row;\n                cells_[columnTarget][rowTarget] = true;\n            }\n        }\n    }\n\n    // Continuously loops through each of the rows until no full rows are\n    // detected and ensures the full rows are collapsed and non-full rows\n    // are shifted accordingly:\n    while (areFullRowsPresent()) {\n        for (int row = BoardRows - 1; row >= 0; --row) {\n            if (isRowFull(row)) {\n                updateOffsetRow(row);\n                currentScore_ += 1;\n                for (int column = 0; column < BoardColumns; ++column) {\n                    cells_[column][0] = false;\n                }\n            }\n        }\n    }\n}\n\nbool Board::isRowFull(int row) {\n    for (int column = 0; column < BoardColumns; ++column) {\n        if (!cells_[column][row]) return false;\n    }\n    return true;\n}\n\nbool Board::areFullRowsPresent() {\n    for (int row = BoardRows - 1; row >= 0; --row) {\n        if (isRowFull(row)) return true;\n    }\n    return false;\n}\n\nvoid Board::updateOffsetRow(int fullRow) {\n    for (int column = 0; column < BoardColumns; ++column) {\n        for (int rowOffset = fullRow - 1; rowOffset >= 0; --rowOffset) {\n            cells_[column][rowOffset + 1] =\n            cells_[column][rowOffset];\n        }\n    }\n}\n```", "```cpp\nvoid Board::displayScore(SDL_Renderer *renderer, TTF_Font *font) {\n    std::stringstream message;\n    message << \"ROWS: \" << currentScore_;\n    SDL_Color white = { 255, 255, 255 };\n    SDL_Surface *surface = TTF_RenderText_Blended(\n        font,\n        message.str().c_str(),\n        white);\n    SDL_Texture *texture = SDL_CreateTextureFromSurface(\n        renderer,\n        surface);\n    SDL_Rect messageRect{ 20, BoardHeight + 15, surface->w, surface->h };\n    SDL_FreeSurface(surface);\n    SDL_RenderCopy(renderer, texture, nullptr, &messageRect);\n    SDL_DestroyTexture(texture);\n}\n```", "```cpp\n#ifndef TETRIS_GAME_H\n#define TETRIS_GAME_H\n\n#include <SDL2/SDL.h>\n#include <SDL2/SDL2_ttf.h>\n#include \"constants.h\"\n#include \"board.h\"\n#include \"piece.h\"\n\nclass Game {\n public:\n  Game();\n  ~Game();\n  bool loop();\n\n private:\n  Game(const Game &);\n  Game &operator=(const Game &);\n\n  void checkForCollision(const Piece &newPiece);\n  void handleKeyEvents(SDL_Event &event);\n\n  SDL_Window *window_;\n  SDL_Renderer *renderer_;\n  TTF_Font *font_;\n  Board board_;\n  Piece piece_;\n  uint32_t moveTime_;\n};\n\n#endif // TETRIS_GAME_H\n```", "```cpp\n#include <cstdlib>\n#include <iostream>\n#include <stdexcept>\n#include \"game.h\"\n\nusing namespace std;\nusing namespace Constants;\n\nGame::Game() :\n    // Create a new random piece:\n    piece_{ static_cast<Piece::Kind>(rand() % 7) },\n    moveTime_(SDL_GetTicks())\n{\n    if (SDL_Init(SDL_INIT_VIDEO) != 0) {\n        throw runtime_error(\n            \"SDL_Init(SDL_INIT_VIDEO): \" + string(SDL_GetError()));\n        }\n        SDL_CreateWindowAndRenderer(\n            BoardWidth,\n            ScreenHeight,\n            SDL_WINDOW_OPENGL,\n            &window_,\n            &renderer_);\n        SDL_SetWindowPosition(\n            window_,\n            SDL_WINDOWPOS_CENTERED,\n            SDL_WINDOWPOS_CENTERED);\n        SDL_SetWindowTitle(window_, \"Tetris\");\n\n    if (TTF_Init() != 0) {\n        throw runtime_error(\"TTF_Init():\" + string(TTF_GetError()));\n    }\n    font_ = TTF_OpenFont(\"PressStart2P.ttf\", 18);\n    if (font_ == nullptr) {\n        throw runtime_error(\"TTF_OpenFont: \" + string(TTF_GetError()));\n    }\n}\n\nGame::~Game() {\n    TTF_CloseFont(font_);\n    TTF_Quit();\n    SDL_DestroyRenderer(renderer_);\n    SDL_DestroyWindow(window_);\n    SDL_Quit();\n}\n```", "```cpp\nbool Game::loop() {\n    SDL_Event event;\n    while (SDL_PollEvent(&event)) {\n        switch (event.type) {\n            case SDL_KEYDOWN:\n                handleKeyEvents(event);\n                break;\n            case SDL_QUIT:\n                return false;\n            default:\n                return true;\n        }\n    }\n\n    SDL_SetRenderDrawColor(renderer_, /* Dark Gray: */ 58, 58, 58, 255);\n    SDL_RenderClear(renderer_);\n    board_.draw(renderer_, font_);\n    piece_.draw(renderer_);\n\n    if (SDL_GetTicks() > moveTime_) {\n        moveTime_ += 1000;\n        Piece newPiece = piece_;\n        newPiece.move(0, 1);\n        checkForCollision(newPiece);\n    }\n    SDL_RenderPresent(renderer_);\n    return true;\n}\n\nvoid Game::checkForCollision(const Piece &newPiece) {\n    if (board_.isCollision(newPiece)) {\n        board_.unite(piece_);\n        piece_ = Piece{ static_cast<Piece::Kind>(rand() % 7) };\n        if (board_.isCollision(piece_)) board_ = Board();\n    } else {\n        piece_ = newPiece;\n    }\n}\n\nvoid Game::handleKeyEvents(SDL_Event &event) {\n    Piece newPiece = piece_;\n    switch (event.key.keysym.sym) {\n        case SDLK_DOWN:\n            newPiece.move(0, 1);\n            break;\n        case SDLK_RIGHT:\n            newPiece.move(1, 0);\n            break;\n        case SDLK_LEFT:\n            newPiece.move(-1, 0);\n            break;\n        case SDLK_UP:\n            newPiece.rotate();\n            break;\n        default:\n            break;\n     }\n     if (!board_.isCollision(newPiece)) piece_ = newPiece;\n}\n```", "```cpp\n#include \"game.h\"\n\nint main() {\n    Game game;\n    while (game.loop());\n    return 0;\n}\n```", "```cpp\n<!doctype html>\n<html lang=\"en-us\">\n<head>\n  <title>Tetris</title>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"styles.css\" />\n</head>\n<body>\n  <div class=\"wrapper\">\n    <h1>Tetris</h1>\n    <div>\n      <canvas id=\"canvas\"></canvas>\n      <div class=\"scoreWrapper\">\n        <span>ROWS:</span><span id=\"score\"></span>\n      </div>\n    </div>\n  </div>\n  <script type=\"application/javascript\" src=\"img/index.js\"></script>\n  <script type=\"application/javascript\">\n    Module({ canvas: (() => document.getElementById('canvas'))() })\n  </script>\n</body>\n</html>\n```", "```cpp\n@import url(\"https://fonts.googleapis.com/css?family=Press+Start+2P\");\n\n* {\n  font-family: \"Press Start 2P\", sans-serif;\n}\n\nbody {\n  margin: 24px;\n}\n\nh1 {\n  font-size: 36px;\n}\n\nspan {\n  color: white;\n  font-size: 24px;\n}\n\n.wrapper {\n  display: flex;\n  align-items: center;\n  flex-direction: column;\n}\n\n.titleWrapper {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.header {\n  font-size: 24px;\n  margin-left: 16px;\n}\n\n.scoreWrapper {\n  background-color: #3A3A3A;\n  border-top: 1px solid white;\n  padding: 16px 0;\n  width: 360px;\n}\n\nspan:first-child {\n  margin-left: 16px;\n  margin-right: 8px;\n}\n```", "```cpp\nnamespace Constants {\n    const int BoardColumns = 10;\n    const int BoardHeight = 720;\n    const int BoardRows = 20;\n    const int BoardWidth = 360;\n    const int Offset = BoardWidth / BoardColumns;\n    const int PieceSize = 4;\n    // const int ScreenHeight = BoardHeight + 50; <----- Delete this line\n}\n```", "```cpp\nvoid Board::displayScore(SDL_Renderer *renderer, TTF_Font *font) {\n    std::stringstream message;\n    message << \"ROWS: \" << currentScore_;\n    SDL_Color white = { 255, 255, 255 };\n    SDL_Surface *surface = TTF_RenderText_Blended(\n        font,\n        message.str().c_str(),\n        white);\n    SDL_Texture *texture = SDL_CreateTextureFromSurface(\n        renderer,\n        surface);\n    SDL_Rect messageRect{ 20, BoardHeight + 15, surface->w, surface->h };\n    SDL_FreeSurface(surface);\n    SDL_RenderCopy(renderer, texture, nullptr, &messageRect);\n    SDL_DestroyTexture(texture);\n }\n```", "```cpp\nvoid Board::displayScore(int newScore) {\n    std::stringstream action;\n    action << \"document.getElementById('score').innerHTML =\" << newScore;\n    emscripten_run_script(action.str().c_str());\n }\n```", "```cpp\nvoid Board::unite(const Piece &piece) {\n    for (int column = 0; column < PieceSize; ++column) {\n        for (int row = 0; row < PieceSize; ++row) {\n            if (piece.isBlock(column, row)) {\n                int columnTarget = piece.getColumn() + column;\n                int rowTarget = piece.getRow() + row;\n                cells_[columnTarget][rowTarget] = true;\n            }\n        }\n    }\n\n    // Continuously loops through each of the rows until no full rows are\n    // detected and ensures the full rows are collapsed and non-full rows\n    // are shifted accordingly:\n    while (areFullRowsPresent()) {\n        for (int row = BoardRows - 1; row >= 0; --row) {\n            if (isRowFull(row)) {\n                updateOffsetRow(row);\n                currentScore_ += 1;\n                for (int column = 0; column < BoardColumns; ++column) {\n                    cells_[column][0] = false;\n                }\n            }\n        }\n        displayScore(currentScore_); // <----- Add this line\n    }\n}\n```", "```cpp\nvoid Board::draw(SDL_Renderer *renderer/*, TTF_Font *font */) {\n                                        // ^^^^^^^^^^^^^^ <-- Remove this argument\n    // displayScore(renderer, font); <----- Delete this line\n    SDL_SetRenderDrawColor(\n        renderer,\n        /* Light Gray: */ 140, 140, 140, 255);\n    for (int column = 0; column < BoardColumns; ++column) {\n        for (int row = 0; row < BoardRows; ++row) {\n            if (cells_[column][row]) {\n                SDL_Rect rect{\n                    column * Offset + 1,\n                    row * Offset + 1,\n                    Offset - 2,\n                    Offset - 2\n                };\n                SDL_RenderFillRect(renderer, &rect);\n            }\n        }\n    }\n }\n```", "```cpp\nBoard::Board() : cells_{{ false }}, currentScore_(0) {\n    displayScore(0); // <----- Add this line\n}\n```", "```cpp\n#ifndef TETRIS_BOARD_H\n#define TETRIS_BOARD_H\n\n#include <SDL2/SDL.h>\n// #include <SDL2/SDL2_ttf.h> <----- Delete this line\n#include \"constants.h\"\n#include \"piece.h\"\n\nusing namespace Constants;\n\nclass Board {\n public:\n  Board();\n  void draw(SDL_Renderer *renderer /*, TTF_Font *font */);\n                                    // ^^^^^^^^^^^^^^ <-- Remove this\n  bool isCollision(const Piece &piece) const;\n  void unite(const Piece &piece);\n\n private:\n  bool isRowFull(int row);\n  bool areFullRowsPresent();\n  void updateOffsetRow(int fullRow);\n  void displayScore(SDL_Renderer *renderer, TTF_Font *font);\n                                         // ^^^^^^^^^^^^^^ <-- Remove this\n  bool cells_[BoardColumns][BoardRows];\n  int currentScore_;\n};\n\n#endif // TETRIS_BOARD_H\n```", "```cpp\n#include <emscripten/emscripten.h>\n#include <SDL2/SDL.h>\n#include <stdexcept>\n#include \"constants.h\"\n#include \"board.h\"\n#include \"piece.h\"\n\nusing namespace std;\nusing namespace Constants;\n\nstatic SDL_Window *window = nullptr;\nstatic SDL_Renderer *renderer = nullptr;\nstatic Piece currentPiece{ static_cast<Piece::Kind>(rand() % 7) };\nstatic Board board;\nstatic int moveTime;\n\nvoid checkForCollision(const Piece &newPiece) {\n    if (board.isCollision(newPiece)) {\n        board.unite(currentPiece);\n        currentPiece = Piece{ static_cast<Piece::Kind>(rand() % 7) };\n        if (board.isCollision(currentPiece)) board = Board();\n    } else {\n        currentPiece = newPiece;\n    }\n}\n\nvoid handleKeyEvents(SDL_Event &event) {\n    Piece newPiece = currentPiece;\n    switch (event.key.keysym.sym) {\n        case SDLK_DOWN:\n            newPiece.move(0, 1);\n            break;\n        case SDLK_RIGHT:\n            newPiece.move(1, 0);\n            break;\n        case SDLK_LEFT:\n            newPiece.move(-1, 0);\n            break;\n        case SDLK_UP:\n            newPiece.rotate();\n            break;\n        default:\n            break;\n    }\n    if (!board.isCollision(newPiece)) currentPiece = newPiece;\n}\n\nvoid loop() {\n    SDL_Event event;\n    while (SDL_PollEvent(&event)) {\n        switch (event.type) {\n            case SDL_KEYDOWN:\n                handleKeyEvents(event);\n                break;\n            case SDL_QUIT:\n                break;\n            default:\n                break;\n        }\n    }\n\n    SDL_SetRenderDrawColor(renderer, /* Dark Gray: */ 58, 58, 58, 255);\n    SDL_RenderClear(renderer);\n    board.draw(renderer);\n    currentPiece.draw(renderer);\n\n    if (SDL_GetTicks() > moveTime) {\n        moveTime += 1000;\n        Piece newPiece = currentPiece;\n        newPiece.move(0, 1);\n        checkForCollision(newPiece);\n    }\n    SDL_RenderPresent(renderer);\n}\n\nint main() {\n    moveTime = SDL_GetTicks();\n    if (SDL_Init(SDL_INIT_VIDEO) != 0) {\n        throw std::runtime_error(\"SDL_Init(SDL_INIT_VIDEO)\");\n    }\n    SDL_CreateWindowAndRenderer(\n        BoardWidth,\n        BoardHeight,\n        SDL_WINDOW_OPENGL,\n        &window,\n        &renderer);\n\n    emscripten_set_main_loop(loop, 0, 1);\n\n    SDL_DestroyRenderer(renderer);\n    renderer = nullptr;\n    SDL_DestroyWindow(window);\n    window = nullptr;\n    SDL_Quit();\n    return 0;\n}\n```", "```cpp\n{\n  \"label\": \"Remove Existing Web Files\",\n  \"type\": \"shell\",\n  \"command\": \"rimraf\",\n  \"options\": {\n    \"cwd\": \"${workspaceRoot}/public\"\n  },\n  \"args\": [\n    \"index.js\",\n    \"index.wasm\"\n  ]\n}\n```", "```cpp\n{\n  \"label\": \"Build WebAssembly\",\n  \"type\": \"shell\",\n  \"command\": \"emcc\",\n  \"args\": [\n    \"--bind\", \"src/board.cpp\", \"src/piece.cpp\", \"src/main.cpp\",\n    \"-std=c++14\",\n    \"-O3\",\n    \"-s\", \"WASM=1\",\n    \"-s\", \"USE_SDL=2\",\n    \"-s\", \"MODULARIZE=1\",\n    \"-o\", \"public/index.js\"\n  ],\n  \"group\": {\n    \"kind\": \"build\",\n    \"isDefault\": true\n  },\n  \"problemMatcher\": [],\n  \"dependsOn\": [\"Remove Existing Web Files\"]\n}\n```", "```cpp\n# This allows you to just run the \"make\" command without specifying\n# arguments:\n.DEFAULT_GOAL := build\n\n# Specifies which files to compile as part of the project:\nCPP_FILES = $(wildcard src/*.cpp)\n\n# Flags to use for Emscripten emcc compile command:\nFLAGS = -std=c++14 -O3 -s WASM=1 -s USE_SDL=2 -s MODULARIZE=1 \\\n        --bind $(CPP_FILES)\n\n# Name of output (the .wasm file is created automatically):\nOUTPUT_FILE = public/index.js\n\n# This is the target that compiles our executable\ncompile: $(CPP_FILES)\n    emcc  $(FLAGS) -o $(OUTPUT_FILE)\n\n# Removes the existing index.js and index.wasm files:\nclean:\n    rimraf $(OUTPUT_FILE)\n    rimraf public/index.wasm\n\n# Removes the existing files and builds the project:\nbuild: clean compile\n    @echo \"Build Complete!\"\n```", "```cpp\nmake\n```", "```cpp\nemrun --browser chrome --no_emrun_detect public/index.html\n```"]