- en: Creating a Multiplayer Experience in VR
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在虚拟现实中创建多人游戏体验
- en: In this chapter, we're going to move into some more advanced territory. Multiplayer
    software is significantly more complicated to write than single-player applications.
    There's no way around the reality that to write successful multiplayer code, you
    have to build a clear mental model of what's going on and how your data is getting
    from one computer to the other. The good news is that's what we're here to do.
    We're going to be dropping a lot more theory in this chapter than we usually do,
    and the reason for this is that if we simply walked you through the steps of setting
    up a networked application, that's really not going to help you. You have to understand
    how networking works to understand how you need to build your application. But
    don't worry—we'll try to alternate between theory and practical examples so you
    can build a hands-on understanding of how this stuff works.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进入一些更高级的领域。与单人应用程序相比，多人游戏软件的编写要复杂得多。无论如何，要编写成功的多人游戏代码，您必须建立一个清晰的心智模型，了解数据是如何从一台计算机传输到另一台计算机的。好消息是，这正是我们在这里要做的。在本章中，我们将会介绍更多的理论知识，因为如果我们只是简单地引导您完成设置网络应用程序的步骤，那是不会对您有所帮助的。您必须了解网络是如何工作的，才能了解您需要如何构建应用程序。但是不要担心，我们将尝试在理论和实际示例之间进行交替，以便您可以建立对这些内容如何工作的实际理解。
- en: We also need to be clear that networking is a big topic and it's fairly advanced.
    We're not going to have space in this chapter to go over every dark corner of
    the art, but we'll consider it a success if you finish this chapter with a good
    understanding of how networked applications fit together, what the major parts
    are, and how information most commonly moves around. If you come away with this
    understanding in a reasonably clear state, you'll be set up well to understand
    what you're seeing as you learn more about this topic.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要明确的是，网络是一个庞大而相当高级的主题。在本章中，我们没有足够的空间来讨论艺术的每一个黑暗角落，但如果您在本章结束时对网络应用程序的组成方式、主要部分以及信息如何最常见地传递有一个良好的理解，那就算是成功了。如果您能以一个相对清晰的状态理解这一点，那么当您进一步了解这个主题时，您将能够很好地理解您所看到的内容。
- en: 'In this chapter, we''re going to learn to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: Work with Unreal's client-server model to ensure that important gameplay events
    happen on the server
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与虚幻的客户端-服务器模型一起工作，确保重要的游戏事件发生在服务器上
- en: Replicate actors from the server to connected clients
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将角色从服务器复制到连接的客户端
- en: Replicate variables and call functions automatically when their values change
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当变量的值发生变化时，自动复制变量并调用函数
- en: Create a pawn that looks more different to the owning player than it does to
    other players
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个对拥有者玩家而言与其他玩家不同的角色
- en: Use remote procedure calls to call events on remote machines
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用远程过程调用在远程机器上调用事件
- en: Let's jump in!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Testing multiplayer sessions
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试多人游戏会话
- en: Before we get into the weeds talking about how networking works, let's learn
    how to launch a multiplayer session. There are a number of ways you can do this.
    The easiest is to launch the multiplayer session directly from within your editor,
    and most of the time when you're testing network replication, this is going to
    be fine. For more comprehensive tests, or if you need one of the sessions to run
    in VR, you can launch two separate game sessions and connect them to each other.
    We'll show examples of how to do this a little later on when we discuss session
    types.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论网络工作原理之前，让我们先学习如何启动一个多人游戏会话。有多种方法可以做到这一点。最简单的方法是直接从编辑器中启动多人游戏会话，在测试网络复制时，大多数情况下这样做就可以了。对于更全面的测试，或者如果您需要其中一个会话在虚拟现实中运行，您可以启动两个独立的游戏会话并将它们连接在一起。稍后我们将展示如何做到这一点，当我们讨论会话类型时。
- en: Testing multiplayer from the editor
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从编辑器中测试多人游戏
- en: 'Fortunately, the Unreal editor makes it fairly easy to set up a multiplayer
    session from within the editor on a single machine. To perform this test, we''re
    going to use the **Content Examples** project:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，虚幻编辑器使得在单台机器上从编辑器中设置多人游戏会相当容易。为了进行这个测试，我们将使用“内容示例”项目：
- en: If you haven't already downloaded the Content Examples project, do so now by
    selecting Content Examples | Create Project from the Unreal Engine | Learn tab
    in your Epic Games Launcher. You should get into the habit of always keeping a
    current version of Content Examples installed on your system and using it for
    reference.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有下载“内容示例”项目，请在Epic Games Launcher中选择“虚幻引擎”标签下的“内容示例 | 创建项目”来下载。您应该养成始终在系统上安装当前版本的“内容示例”并将其用作参考的习惯。
- en: Open the Content Examples project and open the Network_Features level.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“内容示例”项目并打开“网络功能”关卡。
- en: 'Select the dropdown beside your toolbar''s Play button and set the Multiplayer
    Options | Number of Players to 2\. Refer to the following screenshot:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工具栏的“播放”按钮旁边选择下拉菜单，将“多人游戏选项 | 玩家数量”设置为2。请参考以下截图：
- en: '![](img/3d0d4414-ca6c-4892-8a15-53780e541672.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d0d4414-ca6c-4892-8a15-53780e541672.png)'
- en: 'Select New Editor Window (PIE) to launch a multiplayer session as shown in
    the following screenshot (unfortunately, we can''t use the multiplayer options
    to support a multiplayer VR session on a single machine):'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“新建编辑器窗口（PIE）”以启动一个多人游戏会话，如下图所示（不幸的是，我们不能使用多人游戏选项在单台机器上支持多人虚拟现实会话）：
- en: '![](img/df10c014-8ab5-4341-8f6f-4cc09b4a7ea5.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df10c014-8ab5-4341-8f6f-4cc09b4a7ea5.png)'
- en: 'Explore the scene playing as both server and client. Notice the differences
    between what appears on the server and what appears on the client. We''re going
    to look at these things in greater depth shortly:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以服务器和客户端身份进行场景探索。注意服务器和客户端之间的差异。我们将在不久的将来更深入地研究这些内容：
- en: '![](img/ac9155ca-37df-4151-ad46-34187958b606.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac9155ca-37df-4151-ad46-34187958b606.png)'
- en: In this example, the ghost on the left is visible on the server but not on the
    client because it has not been set to replicate to clients.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，左边的幽灵在服务器上可见，但在客户端上不可见，因为它没有被设置为复制到客户端。
- en: Take some time to understand what each of these displays is telling you in the
    context of what we've described so far, but don't worry if some things are still
    fuzzy—we're going to make more use of these ideas in our upcoming exercises.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间理解到目前为止我们所描述的每个显示内容在什么情况下告诉你什么，但如果有些东西还不清楚，不要担心——我们将在接下来的练习中更多地利用这些概念。
- en: For additional information about multiplayer-testing options in-editor, refer
    to the documentation here: [https://docs.unrealengine.com/en-us/Gameplay/HowTo/Networking/TestMultiplayer](https://docs.unrealengine.com/en-us/Gameplay/HowTo/Networking/TestMultiplayer).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有关编辑器中多人游戏测试选项的更多信息，请参阅此处的文档：[https://docs.unrealengine.com/en-us/Gameplay/HowTo/Networking/TestMultiplayer](https://docs.unrealengine.com/en-us/Gameplay/HowTo/Networking/TestMultiplayer)。
- en: Understanding the client-server model
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解客户端-服务器模型
- en: Now that we have a running test we can play with, let's get a bit of theory
    out of the way. It wouldn't be a bad idea to leave this test level open and explore
    it while we talk about this next concept.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个正在运行的测试，我们可以在谈论下一个概念时进行一些实践。最好保持这个测试关卡打开，并在我们讨论下一个概念时进行探索。
- en: To understand how multiplayer gameplay works in Unreal, you first need to understand
    how information moves between the connected game sessions and how changes are
    made to the game environment. There's no way around this. To write multiplayer
    code successfully, you have to build a clear mental model of what's going on,
    or you'll wind up hitting a lot of walls. Multiplayer is challenging to debug—if
    something doesn't work, you can't simply set a breakpoint in your blueprint and
    trace through to see what happened. Very often, all you'll know is that a bit
    of information you thought should have gone to the other machine never got there.
    If you take the time to understand how networking works, you'll have a much easier
    time figuring out what's gone wrong when something doesn't work as you expected
    it to. Multiplayer is absolutely not something you can debug by stabbing in the
    dark.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解虚幻引擎中的多人游戏玩法是如何工作的，首先需要了解信息如何在连接的游戏会话之间传递，以及对游戏环境进行的更改。没有捷径可走。要成功编写多人游戏代码，必须建立一个清晰的心智模型，了解正在发生的事情，否则你将遇到很多困难。多人游戏很难调试——如果某些东西不起作用，你不能简单地在蓝图中设置断点并跟踪以查看发生了什么。很多时候，你只会知道你认为应该传递到另一台机器的一些信息从未到达那里。如果你花时间了解网络工作原理，当某些事情不像你预期的那样工作时，你会更容易找出问题所在。多人游戏绝对不是你可以靠胡乱尝试来调试的东西。
- en: So, let's learn how networking in Unreal works.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们学习一下虚幻引擎中的网络工作原理。
- en: To begin thinking about this, let's imagine a scenario. Let's say you've created
    a multiplayer shooter, and two players have joined a session and are both playing.
    One of the players aims and fires, and now we need to show both players what happened.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始思考这个问题，让我们想象一个场景。假设你创建了一个多人射击游戏，有两个玩家加入了一个会话并且都在玩。其中一个玩家瞄准并开火，现在我们需要向两个玩家展示发生了什么。
- en: Sounds simple enough at first, but it isn't.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 起初听起来很简单，但实际上并不是这样。
- en: Player A is aiming, but this is happening on player A's game instance. How does
    player B's game instance know where player A is at all, let alone where they're
    aiming? Player A fires. How does player B's game instance find out that this happened?
    Now, someone needs to figure out whether player A's shot hit player B's avatar.
    Who figures out whether the shot hit? What if player B is on a slow network connection
    and the information about where player A was aiming hasn't gotten there yet? If
    both game instances were allowed to decide whether the shot hit, they wouldn't
    agree. Whose opinion would win?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: A玩家正在瞄准，但这是在A玩家的游戏实例中发生的。B玩家的游戏实例如何知道A玩家在哪里，更不用说他们在瞄准什么了？A玩家开火了。B玩家的游戏实例如何得知这一点？现在，有人需要确定A玩家的射击是否击中了B玩家的角色。谁来决定射击是否命中？如果B玩家的网络连接较慢，关于A玩家瞄准位置的信息还没有到达，怎么办？如果两个游戏实例都被允许决定射击是否命中，它们不会达成一致。谁的意见会占上风？
- en: The answer to the first question—how does player B's game instance know about
    player A's movements and actions—is handled through a process called **replication**.
    When player A moves, their avatar's movement is **replicated** to player B's game
    instance, and when player B moves, their movement is replicated to player A's
    game instance.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题的答案——B玩家的游戏实例如何知道A玩家的移动和动作——是通过一种称为**复制**的过程来处理的。当A玩家移动时，他们的角色移动会被**复制**到B玩家的游戏实例中，当B玩家移动时，他们的移动会被复制到A玩家的游戏实例中。
- en: The answer to the last question—who decides whether the shot hit—is handled
    by the **server**, and it's worth taking some time to understand this.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个问题——谁决定射击是否命中——由**服务器**处理，值得花些时间来理解这一点。
- en: Unreal Engine uses a **client-server** model of network management. What this
    means is that only one of the game instances connected to a game session is actually
    allowed to make important decisions about what's really happening. The server
    is **authoritative**, and the clients are not. If the server and a client come
    to two different conclusions about a thing that just happened, the server's opinion
    is the one that gets used.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虚幻引擎使用**客户端-服务器**模型进行网络管理。这意味着只有一个连接到游戏会话的游戏实例被允许对实际发生的事情做出重要决策。服务器是**权威**的，而客户端不是。如果服务器和客户端对刚刚发生的事情得出了两个不同的结论，那么服务器的意见将被采用。
- en: 'In a **peer-to-peer** model, everybody would be equal. Peer-to-peer network
    architectures are relatively easy to set up, but they come at a high cost: when
    one of the connected peers gets out of sync with the other, nobody knows which
    one''s state is actually true. That may be fine for a demo or a class project
    but would be absolutely unacceptable in an environment where players actually
    cared about the outcomes. We need to know without question what the actual state
    of the game and all its players is, and the client-server model gives us a reliable
    way to do this.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在点对点模型中，每个人都是平等的。点对点网络架构相对容易设置，但代价很高：当其中一个连接的对等方与其他对等方不同步时，没有人知道哪个状态实际上是真实的。这对于演示或课堂项目可能没问题，但在玩家真正关心结果的环境中是绝对不可接受的。我们需要毫无疑问地知道游戏及其所有玩家的实际状态，而客户端-服务器模型为我们提供了一种可靠的方法来实现这一点。
- en: 'Here''s what actually happens:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实际发生的情况：
- en: Player A moves, and their movement is replicated to the server, which replicates
    their movement to all the other connected game instances.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家A移动，他们的移动被复制到服务器，服务器将他们的移动复制到所有其他连接的游戏实例。
- en: Player B and any other connected players see a **proxy** in their game sessions,
    which shows them where the server says player A's avatar is.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家B和其他连接的玩家在他们的游戏会话中看到一个代理，它显示了服务器说玩家A的角色所在的位置。
- en: When player A aims and fires, player A's client actually sends a request to
    the server telling it that it wants to fire, and the server makes the actual determination
    of whether it can.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当玩家A瞄准并开火时，玩家A的客户端实际上会向服务器发送请求，告诉服务器它想要开火，服务器会进行实际决定是否可以开火。
- en: If the server determines that player A has ammo, is in the right state, or whatever
    the game rules specify, it fires the weapon and tells all the connected game instances
    that it did.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果服务器确定玩家A有弹药，处于正确状态，或者符合游戏规则的要求，它会开火并告诉所有连接的游戏实例。
- en: The server has also been receiving player B's replicated movement, so it has
    the information it needs to figure out whether player A's shot hit.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器还收到了玩家B的复制移动，因此它具有确定玩家A的射击是否命中的所需信息。
- en: If it determines that it did, it decreases player B's health or does whatever
    it needs to do to respond to this event and tells all the connected clients that
    player B was hit.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果服务器确定它确实发生了，它会减少玩家B的生命值或执行其他必要的操作来响应此事件，并告诉所有连接的客户端玩家B被击中。
- en: 'Each client then updates its local state information, plays hit animations
    and effects, and updates its UI:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，每个客户端更新其本地状态信息，播放击中动画和效果，并更新其用户界面：
- en: '![](img/39627582-40b9-4801-8485-947381232269.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/39627582-40b9-4801-8485-947381232269.png)
- en: The top panel represents the server's view, while the bottom panel is the client's
    view. Lines have been added to indicate objects whose states can change and need
    to be replicated to clients.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部面板表示服务器的视图，而底部面板表示客户端的视图。添加了线条以指示状态可能发生变化并需要复制到客户端的对象。
- en: Unreal's network architecture is astonishingly efficient, which is why a game
    such as *Fortnite* can run in real-time even when a large number of players are
    simultaneously connected. There are a number of reasons for this, and many of
    them are under your control as a developer. We'll cover a few of the important
    ones in depth later on in the chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虚幻引擎的网络架构非常高效，这就是为什么像《堡垒之夜》这样的游戏可以在大量玩家同时连接时实时运行的原因。这其中有很多原因，其中许多是作为开发人员在您的控制之下的。我们将在本章后面深入介绍其中一些重要原因。
- en: Now, let's take a closer look at a few important concepts.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们仔细看一下几个重要的概念。
- en: The server
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器
- en: The term **server** refers to the **network authority** in a multiplayer environment.
    You'll hear these terms used interchangeably. Technical documentation will tend
    to use the term *network authority*, as that describes more precisely what it
    really is, while most of the other material you read will call it the *server*.
    Both refer to the same thing.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 术语“服务器”指的是多人环境中的“网络授权”。您会听到这些术语互换使用。技术文档往往会使用术语“网络授权”，因为这更准确地描述了它的实际含义，而您阅读的其他大部分材料将称其为“服务器”。两者指的是同一件事。
- en: A great deal of the time, when something goes wrong in your networked application,
    it's going to be because you allowed a client to try to change the game state
    when instead it needed to ask the network authority to make the change.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的网络应用程序出现问题时，很大一部分时间是因为您允许客户端尝试更改游戏状态，而实际上它需要请求网络授权来进行更改。
- en: 'The architecture works like this: the server *hosts* the game and allows multiple
    clients to connect to it and communicate data back and forth. Communication happens
    between clients and the server, and clients almost never communicate directly
    with one another:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 架构的工作方式如下：服务器托管游戏，并允许多个客户端连接并相互通信数据。通信发生在客户端和服务器之间，客户端几乎不直接与其他客户端通信：
- en: '![](img/2a690e3a-07d6-4d3b-9273-c4012a39b1bf.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/2a690e3a-07d6-4d3b-9273-c4012a39b1bf.png)
- en: When a player performs an action, information about what the player is doing
    or wants to do is sent from that player's client to the server. The server validates
    this information and responds, telling the connected clients what it decided.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家执行操作时，关于玩家正在做什么或想要做什么的信息从该玩家的客户端发送到服务器。服务器验证此信息并做出响应，告诉连接的客户端它的决定。
- en: If, for example, you move your player avatar in a multiplayer game, you're not
    really moving your avatar locally at all. Instead, your client will tell the server
    that you want to move, and the server will then determine how you've moved and
    replicate your new position back to your client and to the other connected clients.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您在多人游戏中移动您的玩家角色，实际上您根本没有在本地移动您的角色。相反，您的客户端将告诉服务器您想要移动，然后服务器将确定您的移动方式，并将您的新位置复制回您的客户端和其他连接的客户端。
- en: This is true for seemingly-direct messages between clients as well. If you send
    a chat message to another client, you're actually sending it to the server, and
    then the server decides which client or group of clients should receive it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于看似直接的客户端之间的消息也是如此。如果你向另一个客户端发送聊天消息，实际上是将它发送到服务器，然后服务器决定哪个客户端或一组客户端应该接收它。
- en: The server, as we mentioned previously, is the network authority responsible
    for maintaining the actual **authoritative state** of the multiplayer session.
    This idea of **authority** is one of the most important concepts to grok about
    networking and you're going to see when we get to the practical examples that
    we check for authority with almost everything we do. If you keep clear in your
    mind who should be allowed to make a change and you check to make sure that any
    change really is being made by the entity allowed to make it, you'll be ahead
    of the game.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，服务器是负责维护多人游戏会话的实际权威状态的网络授权机构。这个“权威”的概念是关于网络的最重要的概念之一，当我们到达实际的例子时，你会看到我们几乎在做任何事情时都会检查权限。如果你清楚地知道谁应该被允许做出改变，并检查确保任何改变确实是由被允许的实体进行的，你就会领先一步。
- en: 'A good rule of thumb to follow is this: if any other player would care about
    this change, it belongs on the server. If nobody else would care, do it locally.
    So, if you''re playing a visual effect that doesn''t matter to the game, don''t
    bother running it on the server, but if you''re changing a player''s health or
    moving them around, do that on the server, since everybody else is going to need
    to agree on it.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的经验法则是：如果其他玩家关心这个变化，它就属于服务器。如果没有其他人关心，就在本地进行。所以，如果你正在播放一个对游戏无关紧要的视觉效果，就不要在服务器上运行它，但如果你正在改变玩家的生命值或移动他们，就在服务器上进行，因为其他人都需要同意这个改变。
- en: In addition to ensuring that there's only one description at a time of anything
    important to the game, there's another reason why it's important to maintain a
    single network authority, and that is to ensure that a player can't easily cheat
    by modifying their client. When important decisions are left to the server, the
    server can fairly easily override results on a hacked client. If the player wants
    to fire a weapon, make sure their client tells the server about it, and let the
    server decide whether they have enough ammo and are allowed to take the shot.
    Never process an important gameplay event directly on the client. Only let them
    happen once the server allows it. Never trust the client.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 除了确保游戏中的任何重要事物一次只有一个描述之外，还有另一个重要原因要维护一个单一的网络授权，那就是确保玩家不能轻易通过修改客户端来作弊。当重要决策留给服务器时，服务器可以相对容易地覆盖黑客客户端上的结果。如果玩家想要开火，确保他们的客户端告诉服务器，让服务器决定他们是否有足够的弹药并且被允许开枪。不要直接在客户端上处理重要的游戏事件。只有在服务器允许的情况下才让它们发生。不要相信客户端。
- en: Listen servers, dedicated dervers, and clients
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监听服务器、专用服务器和客户端
- en: 'There are three fundamental types of game session that can be running in an
    Unreal networked environment: two types of servers and one client type.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻网络环境中，有三种基本类型的游戏会话：两种类型的服务器和一种客户端类型。
- en: Listen servers
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监听服务器
- en: When you run a **listen server**, your machine is acting as the host for the
    game session and as the authority over that game session, but it is also running
    a client. If you've ever set up a networked game in Unreal, it may have looked
    as though you were running a peer-to-peer session, but this is what was really
    going on. The listen server is pretty much invisible to the local player—it doesn't
    look like a separate running process, but it actually is separate from the local
    client exactly as it would be if it were on another machine.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行一个**监听服务器**时，你的机器充当游戏会话的主机和该游戏会话的授权机构，但它也在运行一个客户端。如果你曾经在虚幻中设置过一个网络游戏，可能看起来好像你正在运行一个点对点会话，但实际上是这样的。监听服务器对于本地玩家来说几乎是看不见的-它看起来不像是一个单独的运行进程，但实际上它与本地客户端是分开的，就像它在另一台机器上一样。
- en: 'The following command-line arguments will launch a listen server using uncooked
    editor data:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令行参数将使用未烹饪的编辑器数据启动一个监听服务器：
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Often, your easiest way to use these commands will be to create shortcuts containing
    the arguments, or to write a simple `.bat` file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用这些命令的最简单方法是创建包含参数的快捷方式，或者编写一个简单的.bat文件。
- en: 'The following `.bat` file will launch a listen server using the Content Examples
    project''s Network_Features map:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的.bat文件将使用Content Examples项目的Network_Features地图启动一个监听服务器：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, we're setting variables for our executable location, project
    path, and map name just to make the file easier to read and edit. We're also turning
    on the log and setting the window sizes and locations explicitly to make it easier
    to see what's going on and fit other sessions on the screen.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们设置了可执行文件位置、项目路径和地图名称的变量，只是为了使文件更容易阅读和编辑。我们还打开了日志，并明确设置了窗口大小和位置，以便更容易看到正在发生的事情，并在屏幕上适应其他会话。
- en: Dedicated servers
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 专用服务器
- en: A **dedicated server** does not have a client running in the same session. It
    doesn't accept input or render output, and because of this it can be optimized
    to run less expensively than a listen server. Because dedicated servers are so
    much smaller than full game clients since they don't need to include anything
    that's going to be rendered to the player, you can fit many of them on a single
    machine for hosting. Your existing game executable can be told to run itself as
    a dedicated server, or developers have the option to compile a separate executable
    for dedicated servers, which can further deter cheating and can make the executable's
    footprint on the disk much smaller.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**专用服务器**在同一会话中没有运行客户端。它不接受输入或渲染输出，因此可以进行优化，以比监听服务器更便宜地运行。由于专用服务器比完整的游戏客户端要小得多，因为它们不需要包含任何将呈现给玩家的内容，所以可以在单台机器上容纳许多个专用服务器进行托管。现有的游戏可执行文件可以被告知将自己作为专用服务器运行，或者开发人员可以选择编译一个专用服务器的单独可执行文件，这可以进一步防止作弊，并且可以使可执行文件在磁盘上的占用空间更小。'
- en: 'This command will launch a dedicated server using editor data:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将使用编辑器数据启动一个专用服务器：
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that we've chosen to turn on the log for this session. This is because
    dedicated servers don't open a rendering window, so a visible log becomes essential
    for knowing what it's doing.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们选择为此会话打开日志。这是因为专用服务器不会打开渲染窗口，所以一个可见的日志对于了解它在做什么是至关重要的。
- en: 'We could modify the preceding `.bat` file to launch a dedicated server:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改前面的.bat文件来启动一个专用服务器：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, we replaced the `?listen` directive with a `-server` argument,
    and of course we didn't need any of the window placement specifications, since
    a dedicated server won't open a game window.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们用-server参数替换了?listen指令，当然我们也不需要任何窗口放置规格，因为专用服务器不会打开游戏窗口。
- en: Clients
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端
- en: A **client** is the point of contact between a networked application and the
    player. The client may be running on the same system as the server if we're using
    a listen server, or it may stand entirely on its own if it's connected to a remote
    host or to a dedicated server. The client is responsible for accepting input from
    the player, communicating that input to the server via **remote procedure calls**
    (**RPC**), and receiving new information about the gamestate from the server via
    replication.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端**是网络应用程序和玩家之间的联系点。如果我们使用监听服务器，客户端可能在与服务器相同的系统上运行，或者如果连接到远程主机或专用服务器，则完全独立于服务器。客户端负责接受玩家的输入，通过**远程过程调用**（**RPC**）将输入传递给服务器，并通过复制从服务器接收有关游戏状态的新信息。'
- en: 'The following command will launch a client:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将启动一个客户端：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that in the preceding example, `ServerIP` is the IP address of the server
    to which you're trying to connect. If you're connecting to a server running on
    your own machine for testing, the default home address of `127.0.0.1` will connect
    to a server running on the local machine.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上面的示例中，“ServerIP”是您要连接的服务器的IP地址。如果您连接到在您自己的机器上运行的服务器进行测试，则默认的主机地址“127.0.0.1”将连接到在本地机器上运行的服务器。
- en: 'This `.bat` file will launch a client that connects to a server running on
    the same machine:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个.bat文件将启动一个连接到同一台机器上运行的服务器的客户端：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Again, the `-log` and window size arguments are entirely optional—it just makes
    it easier to test multiplayer sessions if you set up your shortcuts to place your
    windows out of each other's way when they start up.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，-log和窗口大小参数完全是可选的-如果您设置快捷方式以使窗口在启动时互不干扰，那么测试多人会话将更加容易。
- en: Now that we've done a bit of preliminary experimentation and talked about a
    few fundamental ideas, let's set up our own test project so we can perform our
    own experiments.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经进行了一些初步的实验并讨论了一些基本的想法，让我们设置我们自己的测试项目，这样我们就可以进行自己的实验了。
- en: Testing multiplayer VR
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试多人虚拟现实
- en: To test multiplayer in VR, you're generally going to need two separate PCs on
    the network. It is sometimes possible to test multiplayer VR on a single machine,
    but some VR headset drivers will automatically send a quit signal to a running
    3D application when a second one starts up.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要在虚拟现实中测试多人游戏，通常需要在网络上有两台单独的PC。有时可以在单台机器上测试多人虚拟现实，但是某些虚拟现实头戴设备驱动程序会在第二个应用程序启动时自动发送退出信号给正在运行的3D应用程序。
- en: As of Unreal 4.21, the HTC Vive plugin automatically shuts down an existing
    Unreal session if a second one starts up. (The code that does this lives in `FSteamVRHMD::OnStartGameFrame(),`
    but unfortunately there's no easy way for users of the installed binaries to change
    this behavior.) The Oculus HMD plugin does not automatically quit existing sessions,
    so if you're using an Oculus Rift, you'll likely be able to test multiplayer on
    a single machine, but if you're using a Vive, you'll need two PCs.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从Unreal 4.21开始，HTC Vive插件会在第二个插件启动时自动关闭现有的Unreal会话。（执行此操作的代码位于`FSteamVRHMD::OnStartGameFrame()`中，但不幸的是，已安装的二进制文件的用户无法轻松更改此行为。）Oculus
    HMD插件不会自动退出现有会话，因此如果您使用Oculus Rift，则可能能够在单台机器上测试多人游戏，但如果您使用Vive，则需要两台PC。
- en: If you'd like to give it a shot, simply add the `-vr` keyword to any launch
    string.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想试一试，只需在任何启动字符串中添加“-vr”关键字。
- en: 'A server launch string would look something like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一个服务器启动字符串看起来会像这样：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And, a client launch string would look something like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，客户端启动字符串看起来会像这样：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Of course, if you're trying to test on a single machine, only set one session
    to use VR at a time.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你想在单台机器上进行测试，只需设置一个会话一次使用VR。
- en: Because it's going to be impractical for many users to test multiplayer VR with
    a single machine, we're going to run through our multiplayer examples in 2D for
    the most part so you can learn the concepts in an environment that can reasonably
    support testing. We will, however, still go through certain specific things you'll
    need to do to make a player character's animations respond appropriately to headset
    and motion controller movements, so you'll exit this chapter with a good foundation
    from which to get started in multiplayer VR.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因为对许多用户来说，使用单台机器测试多人虚拟现实是不切实际的，所以我们将在大部分时间内以2D方式运行我们的多人示例，以便您可以在一个可以合理支持测试的环境中学习这些概念。然而，我们仍然会讨论一些特定的事情，您需要做一些特定的事情，以使玩家角色的动画对头戴式显示器和动作控制器的移动做出适当的响应，这样您就可以在多人虚拟现实中有一个良好的起点。
- en: Setting up our own test project
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们自己的测试项目
- en: 'As we did with our last chapter, we''re going to start out simply by creating
    a clean project with the following settings:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章一样，我们将从创建一个带有以下设置的干净项目开始：
- en: Blank blueprint template
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 空白的蓝图模板
- en: Mobile/tablet hardware target
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动/平板硬件目标
- en: Scalable 3D or 2D graphics target
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可扩展的3D或2D图形目标
- en: No Starter Content
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有起始内容
- en: 'As usual, here''s our project settings cheat sheet:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，这是我们的项目设置备忘单：
- en: Engine | Rendering | Forward Renderer | Forward Shading: True
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引擎|渲染|前向渲染器|前向着色：True
- en: Engine | Rendering | Default Settings | Ambient Occlusion Static Fraction: False
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引擎|渲染|默认设置|环境光遮蔽静态分数：False
- en: Engine | Rendering | Default Settings | Anti-Aliasing Method: MSAA
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引擎 | 渲染 | 默认设置 | 抗锯齿方法：MSAA
- en: Engine | Rendering | VR | Instanced Stereo: True
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引擎 | 渲染 | VR | 实例化立体声：True
- en: Engine | Rendering | VR | Round Robin Occlusion Queries: True
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引擎 | 渲染 | VR | 循环Robin遮挡查询：True
- en: 'We''re going to set one value differently, however, for this test because we''re
    going to be working mostly in the flat screen to simplify learning this challenging
    topic:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了简化学习这个具有挑战性的主题，我们将以不同的方式设置一个值：
- en: Project | Description | Settings | Start in VR: False
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目 | 描述 | 设置 | 在VR中启动：False
- en: Allow the project to restart once all these settings have been set.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置完所有这些设置后，允许项目重新启动。
- en: Adding an environment
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个环境
- en: Let's give ourselves some environment assets to play with so we're not stuck
    looking at an empty level.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给自己一些环境资产来玩，这样我们就不会一直看着一个空的关卡了。
- en: 'Open your Epic Games Launcher and find the Infinity Blade: Ice Lands pack.
    Add it to your project.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '打开你的Epic Games启动器，找到Infinity Blade: Ice Lands包。将其添加到你的项目中。'
- en: If you're unable to add a content pack to a project because it says it's not
    compatible with your current project version, you can very often get around this
    just by adding the content pack to a project built with the highest version the
    content pack allows, and then migrating its assets to your new project. So, for
    example, if I'm trying to add Ice Lands to a 4.21 project, and the launcher tells
    me I can't because Ice Lands has only been flagged as compatible with 4.20, I
    can add the content to a 4.20 project and then migrate it to a 4.21 project. Most
    of the time, this will work.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法向项目添加内容包，因为它说它与你当前的项目版本不兼容，你通常可以通过将内容包添加到一个使用内容包允许的最高版本构建的项目中，然后将其资产迁移到你的新项目中来解决这个问题。所以，例如，如果我想将Ice
    Lands添加到一个4.21项目中，而启动器告诉我不能这样做，因为Ice Lands只与4.20兼容，我可以将内容添加到一个4.20项目中，然后将其迁移到4.21项目中。大多数情况下，这样做是有效的。
- en: This may take a while. Once these assets have been added, open up your project.
    We're going to begin by creating a new Game Mode to get ourselves set up for a
    multiplayer session.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能需要一些时间。一旦这些资产被添加，打开你的项目。我们将通过创建一个新的游戏模式来为多人游戏会话做好准备。
- en: Creating a network Game Mode
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个网络游戏模式
- en: Remember when we mentioned a long time ago that the Game Mode is responsible
    for the rules of a game? In a multiplayer game, this takes on additional significance
    because, as we've mentioned, important gameplay events should only ever happen
    on the server. If you put these two considerations together, then it shouldn't
    surprise you to learn that when a multiplayer game is underway, there's only one
    Game Mode, and it lives on the server.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们很久以前提到过游戏模式负责游戏规则吗？在多人游戏中，这变得更加重要，因为如我们所提到的，重要的游戏事件只应该发生在服务器上。如果你将这两个考虑因素结合起来，那么当多人游戏进行时，只会有一个游戏模式，并且它存在于服务器上。
- en: What this means for you as a developer is if you write code that talks directly
    to the Game Mode, it's going to run fine when you test in a single-player session,
    but will fail when you try to test it in multiplayer because the game mode isn't
    going to be there on the client. This confuses many new multiplayer developers,
    so this would be a good time to take a quick look at Unreal's network framework
    and understand where different objects live.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发者来说，这意味着如果你编写直接与游戏模式交互的代码，在单人游戏会话中测试时会运行良好，但在多人游戏中测试时会失败，因为客户端上没有游戏模式。这让许多新的多人游戏开发者感到困惑，所以现在是一个好时机来快速了解虚幻的网络框架，并理解不同对象的位置。
- en: Objects on the network
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络上的对象
- en: 'When thinking about objects in the multiplayer framework, you can think of
    them as occupying four different domains:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在思考多人游戏框架中的对象时，你可以将它们看作占据四个不同的领域：
- en: Server Only: Objects exist only on the server.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅服务器：对象仅存在于服务器上。
- en: Server & Clients: Objects exist on the server and on every client.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器和客户端：对象存在于服务器和每个客户端上。
- en: Server & Owning Client: Objects exist on the server and the client that owns
    them, but they do not exist on any other client.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器和拥有客户端：对象存在于服务器和拥有它们的客户端上，但在其他客户端上不存在。
- en: Owning Client Only: Objects exist only on the client that owns them.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅拥有客户端：对象仅存在于拥有它们的客户端上。
- en: 'Refer to the following screenshot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下截图：
- en: '![](img/2be14d13-b54d-48dc-8635-f5b958c54c20.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2be14d13-b54d-48dc-8635-f5b958c54c20.png)'
- en: While this may seem at first like an academic point, you're really going to
    need to understand this. More than once in your early networking career, you're
    going to try to communicate with an object that doesn't live where you think it
    does because in a single-player session you never needed to think about this.
    Everything lives in the same space in a single-player game. In multiplayer, they
    don't, and you need to learn where they are.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这一点乍一看可能像是一个学术问题，但你真的需要理解这一点。在你早期的网络职业生涯中，你会尝试与一个你认为它存在的对象进行通信，但实际上它并不在你认为的位置，因为在单人游戏中你从来不需要考虑这个问题。在多人游戏中，它们并不在同一个空间中，你需要学会它们在哪里。
- en: 'Let''s look at this another way:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们换个角度来看：
- en: '![](img/0a44a5d2-7c9a-4b48-946d-9591700d1bb9.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a44a5d2-7c9a-4b48-946d-9591700d1bb9.png)'
- en: Diagram based on Cedric Neukirchen's excellent Multiplayer Network Compendium,
    found here: http://cedric-neukirchen.net/2017/02/14/multiplayer-network-compendium/
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Cedric Neukirchen出色的多人网络手册的图表，可以在这里找到：http://cedric-neukirchen.net/2017/02/14/multiplayer-network-compendium/
- en: 'In the preceding diagram, you can see the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的图表中，你可以看到以下内容：
- en: The server owns the GameMode, and no client has access to it.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器拥有游戏模式，没有客户端可以访问它。
- en: The server and each connected client can see the Game State. There's only one
    of these.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器和每个连接的客户端都可以看到游戏状态。只有一个这样的状态。
- en: The server and each connected client can see a Player State for each client.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器和每个连接的客户端可以看到每个客户端的玩家状态。
- en: The server and each connected client can see each client's pawn.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器和每个连接的客户端可以看到每个客户端的角色。
- en: The server can see each connected client's player controller, but clients can't
    see other clients' player controllers.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器可以看到每个连接的客户端的玩家控制器，但客户端无法看到其他客户端的玩家控制器。
- en: The HUD and UI elements only exist on clients, and nobody else knows about them.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HUD和UI元素仅存在于客户端上，其他人都不知道它们。
- en: Let's talk briefly about what each of these objects does with regard to multiplayer
    gameplay.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地讨论一下每个对象在多人游戏中的作用。
- en: Server-only objects
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅服务器拥有的对象
- en: The Game Mode, as we mentioned a moment ago, lives on the server only. It runs
    the game and is the sole authority on what's going on. Clients, by design, cannot
    access the game mode directly. We've seen already that the game mode is responsible
    for deciding what object classes are created for a game. In a multiplayer game,
    the game mode often takes on additional responsibilities, such as choosing which
    team a player spawns into, where their pawn appears, and whether a match is ready
    to begin or ready to end.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才提到的，游戏模式仅存在于服务器上。它运行游戏并是正在进行的游戏的唯一权威。按设计，客户端无法直接访问游戏模式。我们已经看到游戏模式负责决定为游戏创建哪些对象类。在多人游戏中，游戏模式通常承担额外的责任，例如选择玩家生成到哪个队伍，他们的角色出现在哪里，以及比赛是否准备好开始或结束。
- en: The game mode also applies and enforces the rules of the game. Let's say our
    game's map was split up into sections and these sections can turn into danger
    zones that will damage players if they remain in them. The game mode would be
    responsible for determining which section turned dangerous, and when it happened.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏模式还适用并执行游戏规则。假设我们的游戏地图被分成了几个区域，这些区域可以变成危险区，如果玩家留在其中，就会受到伤害。游戏模式将负责确定哪个区域变得危险，以及何时发生。
- en: This raises a question though. If the game mode exists only on the server and
    cannot be seen by the clients, how do the clients find out which sections are
    dangerous and which ones aren't?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这引发了一个问题。如果游戏模式仅存在于服务器上，客户端无法看到它，那么客户端如何知道哪些区域是危险的，哪些不是呢？
- en: This is where the next layer of objects comes in—those that exist on both client
    and server.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是下一层对象的作用-它们在客户端和服务器上都存在。
- en: Server and client objects
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器和客户端对象
- en: When clients need to get information about the state of the game, they get it
    from the **Game State**, which is owned by the server but replicated to clients.
    We haven't really talked about replication yet, so for now you can think of it
    as a copy of an object that gets sent from the server to the connected clients.
    The game mode reads information from the game state and writes to it, and the
    server sends copies of the updated game state to all the connected clients through
    replication.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端需要获取游戏状态的信息时，它们从**游戏状态**中获取，该状态由服务器拥有但复制给客户端。我们还没有真正讨论过复制，所以现在你可以将其视为从服务器发送到连接的客户端的对象副本。游戏模式从游戏状态中读取信息并写入信息，服务器通过复制将更新后的游戏状态的副本发送给所有连接的客户端。
- en: Returning to our previous example, if the game mode simply stored information
    about which zones were dangerous in a variable contained within itself, nobody
    is going to know about it. If the game mode instead stores this information on
    a game state that's replicated to the clients, they can read this information
    from the game state and respond to it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们之前的例子，如果游戏模式仅在自身的变量中存储有关哪些区域是危险的信息，那么没有人会知道它。如果游戏模式将此信息存储在复制给客户端的游戏状态上，客户端可以从游戏状态中读取此信息并做出响应。
- en: What if our game mode is also updating scores for each player? Where should
    we put this information? We know of course that it shouldn't go on the game mode,
    since nobody can see it there. We could put it in the game state, and maintain
    an array of scores for each player, but there's a better place for this information.
    The game state maintains an array of **Player State** objects for each connected
    client. This is an ideal place to put information such as a player's score that
    applies to a single player, but that other players need to know about.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的游戏模式还要更新每个玩家的分数，我们应该把这些信息放在哪里？当然，我们知道它不应该放在游戏模式中，因为在那里没有人能看到它。我们可以将其放在游戏状态中，并为每个玩家维护一个分数数组，但有一个更好的地方可以存放这些信息。游戏状态为每个连接的客户端维护了一个**玩家状态**对象的数组。这是一个理想的位置，可以存放适用于单个玩家但其他玩家需要了解的信息，比如玩家的分数。
- en: We're already familiar with the work that pawns do—these are players' avatars
    in the virtual world. They're maintained on the server and replicated to clients,
    so their movement and other state information can be seen by other players.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉了角色扮演的工作-这些是玩家在虚拟世界中的化身。它们在服务器上维护并复制到客户端，因此其他玩家可以看到它们的移动和其他状态信息。
- en: Server and owning client objects
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器和拥有客户端的对象
- en: We've seen previously that the player controller is responsible for managing
    input coming from the player and the output being displayed to the player. It
    owns the camera and the HUD, and it handles input events. Each connected client
    in a multiplayer game has a player controller associated with it, and can access
    it just as it would in a single-player session. The server is aware of what's
    going on with each client's player controller as well, but clients cannot see
    anything about each other's player controllers.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经看到，玩家控制器负责管理来自玩家的输入和显示给玩家的输出。它拥有摄像机和HUD，并处理输入事件。多人游戏中的每个连接的客户端都有一个与之关联的玩家控制器，并且可以像在单人游戏会话中一样访问它。服务器也知道每个客户端的玩家控制器的情况，但客户端无法看到其他客户端的玩家控制器的任何信息。
- en: Owning client only objects
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅拥有客户端的对象
- en: Finally, objects such as UI display widgets exist only on the clients to which
    they apply. The server doesn't know or care about them, and neither do any other
    clients. These are purely local objects.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，UI显示小部件等对象仅存在于适用于它们的客户端上。服务器不知道也不关心它们，其他客户端也一样。这些是纯粹的本地对象。
- en: That was quite a lot of of theory to dump on you, we know, but, as we mentioned,
    it's important. If you take a bit of time to internalize the structure described,
    you'll have a much less-confusing time writing multiplayer applications.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，我们给你提供了很多理论知识，但正如我们所提到的，这很重要。如果你花一点时间来理解所描述的结构，编写多人应用程序时就会少些困惑。
- en: That having been said, let's get back to some hands-on work.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们回到一些实际操作。
- en: Creating our network game mode
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的网络游戏模式
- en: 'We''re going to use this login to spawn different players at different spawn
    points. Before we go on, let''s jump into our map and add a second player start
    object:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用此登录来在不同的生成点生成不同的玩家。在继续之前，让我们进入地图并添加第二个玩家起始对象：
- en: 'From your Modes panel, select Basic | Player Start, and drag it on to your
    map somewhere, and save your map:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从模式面板中，选择“基本 | 玩家起始点”，将其拖放到地图的某个位置，并保存地图：
- en: Remember to use the *P* key to verify that your spawn point is on an area with
    a valid navmesh. (We don't actually need the navmesh yet, but this is a good way
    to verify that the floor collision is good in the location you've chosen and that
    it's inside the gameplay area.)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 记得使用*P*键来验证你的生成点是否在一个具有有效导航网格的区域上。（我们现在实际上不需要导航网格，但这是验证你选择的位置的地板碰撞是否良好以及是否在游戏区域内的好方法。）
- en: '![](img/a267cc36-e75e-4d4c-870d-7bd663f0a600.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a267cc36-e75e-4d4c-870d-7bd663f0a600.png)'
- en: Here we've added a second player start at the other end of the map from the
    first.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在地图的另一端添加了第二个玩家起始点。
- en: 'Now, let''s create a game mode to manage our network gameplay:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个游戏模式来管理我们的网络游戏：
- en: With your new project open, create a directory for it inside your Content Browser.
    Name it `Multiplayer` (or anything you like).
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的新项目后，在内容浏览器中创建一个目录。将其命名为`Multiplayer`（或者你喜欢的其他名称）。
- en: Create a blueprints subdirectory within this directory.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此目录中创建一个蓝图子目录。
- en: Right-click to create Basic Asset | Blueprint Class | Game Mode Base. Name it
    `BP_MultiplayerGameMode`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击创建基本资产 | 蓝图类 | 游戏模式基类。将其命名为`BP_MultiplayerGameMode`。
- en: If you look in the Content Examples project's BP_GameMode_Network, you'll see
    that it implements its own player start selection in Event OnPostLogin. You don't
    need to do this. The native GameModeBase class does it for you. If you did want
    to create special rules for selecting player starts (to select them by team, for
    example, the correct way to do this is to override the ChoosePlayerStart function.
    To do this, select Functions | Override | Choose Player Start, and put whatever
    logic you want in the resulting graph).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看Content Examples项目的BP_GameMode_Network，你会看到它在事件OnPostLogin中实现了自己的玩家起始点选择。你不需要这样做。原生的GameModeBase类已经为你做了这个。如果你确实想要为选择玩家起始点创建特殊规则（例如按团队选择），正确的方法是重写ChoosePlayerStart函数。要做到这一点，选择“函数
    | 覆盖 | 选择玩家起始点”，并在生成的图表中放入任何你想要的逻辑。
- en: Open Settings | Project Settings | Project | Maps & Modes, and set the Default
    GameMode to our new game mode.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开设置 | 项目设置 | 项目 | 地图和模式，并将默认游戏模式设置为我们的新游戏模式。
- en: 'Let''s test it out:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下：
- en: Select the dropdown beside your toolbar's Play button and set the Multiplayer
    Options | Number of Players to 2.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择工具栏“播放”按钮旁边的下拉菜单，将“Multiplayer Options | Number of Players”设置为2。
- en: Select Play This Level in a New Window from your Play button to launch a two-player
    test.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从播放按钮中选择“在新窗口中播放此级别”，以启动一个双人测试。
- en: You should see one player spawning at the original spawn point and the other
    spawning at the new spawn point you just created.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到一个玩家生成在原始生成点，另一个玩家生成在你刚刚创建的新生成点。
- en: Creating a network client HUD
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个网络客户端HUD
- en: Let's add a simple HUD to our clients so we can display information about the
    game to our user. Again, if we were planning this game to run exclusively in VR,
    we would not be using a HUD object, but rather building this in 3D as an attached
    widget. We're doing it this way here because we have quite a lot of ground to
    cover in this chapter and we want to keep it focused on networking.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为客户端添加一个简单的HUD，以便向用户显示有关游戏的信息。同样，如果我们计划此游戏仅在VR中运行，我们将不使用HUD对象，而是将其构建为附加小部件的3D形式。我们之所以这样做，是因为在本章中我们有很多内容要涵盖，我们希望将其集中在网络上。
- en: While we're going to stay focused on creating a 2D HUD for this chapter, we
    can take this opportunity to add a bit of safety to ensure that we don't try to
    display 2D elements in 3D space.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将专注于为本章创建2D HUD，但我们可以借此机会添加一些安全性，以确保我们不会尝试在3D空间中显示2D元素。
- en: 'Let''s create a new HUD to work with:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的HUD来使用：
- en: 'From your project''s blueprints directory, right-click on Create Basic Asset
    | Blueprint Class, and expand the All Classes expander and select HUD as your
    class. Refer to the following screenshot:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目的蓝图目录中，右键单击“创建基本资产 | 蓝图类”，展开“所有类”扩展器，并选择HUD作为您的类。请参考以下截图：
- en: '![](img/44adc815-5e04-4519-9af4-bed8c5165ca1.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44adc815-5e04-4519-9af4-bed8c5165ca1.png)'
- en: Hit the Select button to create it.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“选择”按钮来创建它。
- en: Name it `BP_MultiplayerHUD`.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为`BP_MultiplayerHUD`。
- en: Open our new game mode and set this HUD as its HUD Class.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们的新游戏模式，并将此HUD设置为其HUD类。
- en: Creating a widget for our HUD
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的HUD创建一个小部件
- en: 'Now, let''s create a widget to display on our HUD:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个小部件来显示在我们的HUD上：
- en: Right-click or select Add New | User Interface | Widget Blueprint, and name
    the resulting widget `WBP_NetworkStatus`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击或选择“添加新建 | 用户界面 | 小部件蓝图”，并将生成的小部件命名为`WBP_NetworkStatus`。
- en: Open up its designer panel and drag a text block on to the lower-left corner
    of the panel.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开其设计面板，并将一个文本块拖放到面板的左下角。
- en: Note that because we're creating a 2D interface in this case, we don't specify
    an explicit screen size; instead, we're allowing it to fill the screen. As you'll
    recall from our earlier UI work, when you're building a widget for 3D use, you'll
    want to specify its size.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，因为我们在这种情况下创建了一个2D界面，我们没有指定显式的屏幕大小；相反，我们允许它填充整个屏幕。正如你在之前的UI工作中所记得的，当你构建一个用于3D使用的小部件时，你会想要指定其大小。
- en: Set the Text Block's Anchor to the lower-left corner.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本块的锚点设置为左下角。
- en: Set its Position X to 64.0 and its Position Y to -64.0.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其Position X设置为64.0，将其Position Y设置为-64.0。
- en: Set its Alignment to X=0.0, Y=1.0.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其对齐设置为X=0.0，Y=1.0。
- en: Name it `txt_ClientOrServer`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为“txt_ClientOrServer”。
- en: 'Hit the Bind button beside its Content | Text entry to create a binding for
    it and select Create Binding:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击其Content | Text条目旁边的Bind按钮以创建一个绑定，并选择Create Binding：
- en: '![](img/3e28d546-8396-489a-a8ec-ff27bfdb8617.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/3e28d546-8396-489a-a8ec-ff27bfdb8617.png)
- en: 'In the resulting function graph, we''re going to check to see whether this
    widget''s owning player controller is a client or a server and we''ll set this
    widget''s text accordingly:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成的函数图中，我们将检查此小部件的拥有玩家控制器是客户端还是服务器，并相应地设置此小部件的文本：
- en: Create a Get Owning Player node.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Get Owning Player节点。
- en: Drag the resulting player controller reference from its return value and call
    Has Authority on it.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从其返回值中拖出生成的玩家控制器引用并调用Has Authority。
- en: Create a Select node from the Has Authority call's result.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Has Authority调用的结果创建一个Select节点。
- en: Drag the Select node's return value into the function's Return Value.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Select节点的返回值拖入函数的返回值中。
- en: 'Type `Client` into the Select node''s False entry and Server into its True
    entry:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Select节点的False输入中输入“Client”，在True输入中输入“Server”：
- en: '![](img/0ced092c-d829-4de8-87d1-602b24347b3d.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/0ced092c-d829-4de8-87d1-602b24347b3d.png)
- en: Let's talk about a few things here.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里谈论一些事情。
- en: Remember how we we described the server as the *network authority*? This Has
    Authority check is now testing to see whether the owning player controller is
    resident on a server. You'll be testing for authority very frequently whenever
    you write network code, because you'll often have to do something different depending
    on whether your code is running on a client or a server. File this mentally as
    a very important concept to keep in mind. Checking for authority is how you're
    going to specify which behaviors happen on the server and which happen on the
    client.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们将服务器描述为“网络权限”吗？现在，Has Authority检查正在测试所拥有的玩家控制器是否驻留在服务器上。在编写网络代码时，您经常需要测试权限，因为您经常需要根据代码是在客户端还是服务器上运行而采取不同的操作。将此作为一个非常重要的概念记在心中。检查权限是您指定哪些行为发生在服务器上，哪些行为发生在客户端上的方式。
- en: Notice also the lightning-bolt and screen icon on the Get Owning Player node.
    In single-player applications, we didn't care about this icon, but it matters
    in a multiplayer setting. This icon is indicating that the call in question will
    only occur on a client and cannot be used on a server. In this case, this is fine.
    If you recall from the previous diagrams, the HUD and the widgets it owns exist
    on clients only, so this client-only call is going to work. The player controller
    reference it returns can exist on a client or on a server, which is why we're
    going to get a valid result from our Has Authority check.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意Get Owning Player节点上的闪电和屏幕图标。在单人游戏应用程序中，我们不关心这个图标，但在多人游戏中很重要。该图标表示所调用的函数仅在客户端上发生，不能在服务器上使用。在这种情况下，这是可以的。如果您回想一下之前的图表，HUD及其拥有的小部件仅存在于客户端上，因此这个仅限客户端的调用将起作用。它返回的玩家控制器引用可以存在于客户端或服务器上，这就是为什么我们将从Has
    Authority检查中获得有效结果的原因。
- en: Refer back to the network framework diagrams as you think this through.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在思考时，请参考网络框架图。
- en: Adding a widget to our HUD
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将一个小部件添加到我们的HUD中
- en: 'Now, we''re going to add this widget to our HUD:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将把这个小部件添加到我们的HUD中：
- en: Open the HUD's Event Graph and find or create an Event BeginPlay node.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开HUD的事件图，并找到或创建一个Event BeginPlay节点。
- en: Create an Is Head Mounted Display Enabled node.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Is Head Mounted Display Enabled节点。
- en: Create a Branch using its result.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用其结果创建一个分支。
- en: From the Branch node's False output, drag and create a Create Widget call.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从分支节点的False输出中拖出并创建一个Create Widget调用。
- en: Set its Class to the widget blueprint we just made.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其类设置为刚刚创建的小部件蓝图。
- en: Create a Get Owning Player Controller node and feed its result into the Create
    Widget node's Owning Player input.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Get Owning Player Controller节点，并将其结果馈入Create Widget节点的Owning Player输入。
- en: 'Drag out the Create Widget node''s Return Value and call Add to Viewport on
    it:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖出Create Widget节点的返回值并调用Add to Viewport：
- en: '![](img/addde112-e480-4238-9cb4-6de7c08ab536.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/addde112-e480-4238-9cb4-6de7c08ab536.png)
- en: What we've just done here is check to see whether we're in VR, and if we're
    not, create an instance of our network status widget and add it to the HUD.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚做的是检查我们是否在VR中，如果不是，则创建一个网络状态小部件的实例并将其添加到HUD中。
- en: If you wanted to implement a 3D widget for use in VR, this would be a reasonable
    place to do it. You could create a 3D widget in much the same way we did before,
    and use a Get Owning Pawn call to grab the player pawn and attach the widget's
    containing actor to it. It would be equally reasonable to create a 3D widget on
    the pawn as we did earlier, and hide or destroy it if an Is Head Mounted Display
    Enabled check returned false.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要在VR中实现一个3D小部件，这将是一个合理的地方。您可以以与之前相同的方式创建一个3D小部件，并使用Get Owning Pawn调用来获取玩家Pawn并将小部件的包含的actor附加到它上面。同样合理的是，我们可以像之前一样在Pawn上创建一个3D小部件，并在Is
    Head Mounted Display Enabled检查返回false时隐藏或销毁它。
- en: Let's test it. You should see one session labeled Server, and the other session
    labeled Client.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下。您应该会看到一个标记为“服务器”的会话，另一个标记为“客户端”的会话。
- en: 'Now, try checking the Run Dedicated Server checkbox on the Play menu and run
    it again:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试在播放菜单上选中“运行专用服务器”复选框并再次运行它：
- en: '![](img/0dccb107-47a5-45e3-bdb8-36cdebbbfb36.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/0dccb107-47a5-45e3-bdb8-36cdebbbfb36.png)
- en: This time, you'll see that both sessions indicate that they're clients. What's
    happened here is that a dedicated server has been spawned invisibly and both players
    have connected to it as clients. After you've run this test, uncheck Run Dedicated
    Server again. We're going to need a visible server and client for the next section.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，您会看到两个会话都标记为客户端。这里发生的情况是，一个专用服务器以不可见的方式生成，并且两个玩家都作为客户端连接到它。在运行此测试之后，再次取消选中“运行专用服务器”。我们将需要一个可见的服务器和客户端来进行下一部分的操作。
- en: Network replication
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络复制
- en: Now that we've talked a bit about servers and clients, let's learn more about
    how information moves between them.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经谈了一些关于服务器和客户端的内容，让我们更多地了解信息是如何在它们之间传递的。
- en: The first and most important concept to talk about is **replication**. Replication
    is a process by which an actor or a variable value that exists on one system is
    communicated to another connected system so it can be used there as well.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，也是最重要的概念是**复制**。复制是一个过程，通过该过程，一个存在于一个系统上的角色或变量值被传递到另一个连接的系统，以便在那里也可以使用。
- en: 'This brings up an important point: only those items that you choose to replicate
    will be communicated to the other connected systems, and this is deliberate. Unreal''s
    networking infrastructure is designed for efficiency, and a major way to maintain
    that efficiency, especially if you have a lot of players, is to send only the
    information you absolutely need to send over the network, and send it only to
    those who actually need to receive it. Think about a massively-scoped game such
    as *Fortnite*. It simply could not run if every single piece of data about every
    connected player was being sent to every other player. Unreal can handle very
    large player populations, and it does this by giving you as a developer complete
    control over exactly what gets replicated and to whom. With this power comes responsibility
    though. If you don''t tell an actor or a variable to replicate, it won''t, and
    you won''t see it on a connected machine.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这带来了一个重要的观点：只有你选择复制的那些项目才会被传递给其他连接的系统，这是有意的。虚幻引擎的网络基础设施被设计为高效，而保持这种效率的一个主要方法，特别是如果你有很多玩家，就是只发送你绝对需要通过网络发送的信息，并且只发送给那些实际上需要接收它的人。想想像《堡垒之夜》这样的大规模游戏。如果每个连接的玩家的每个数据都被发送给其他玩家，它根本无法运行。虚幻引擎可以处理非常庞大的玩家人数，它通过让你作为开发者完全控制什么被复制以及复制给谁来实现这一点。然而，这种权力也带来了责任。如果你不告诉一个角色或变量进行复制，它就不会复制，你在连接的机器上也看不到它。
- en: Let's start with a simple example to see how this works.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的例子开始，看看这是如何工作的。
- en: Creating a replicated actor
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个复制的角色
- en: Let's say we wanted to use a flag to mark something in the game, and it was
    important that all players could see where it was.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想使用旗帜来标记游戏中的某个东西，并且所有玩家都能看到它的位置很重要。
- en: 'We can begin by creating an actor for our flag, so let''s do this first:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从创建一个角色开始，所以让我们首先这样做：
- en: Inside your `Blueprints` folder, right-click to select Create Basic Asset |
    Blueprint Class | Actor. We can name our actor `BP_ReplicatedFlag`. Open it up.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`Blueprints`文件夹中，右键选择创建基本资产 | 蓝图类 | 角色。我们可以将我们的角色命名为`BP_ReplicatedFlag`。打开它。
- en: Select Add Component | Static Mesh.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择添加组件 | 静态网格。
- en: Set the component's Static Mesh property to `/Game/InfinityBladeIceLands/Environments/Ice/Env_Ice_Deco2/StaticMesh/SM_Env_Ice_Deco2_flag2`.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将组件的静态网格属性设置为`/Game/InfinityBladeIceLands/Environments/Ice/Env_Ice_Deco2/StaticMesh/SM_Env_Ice_Deco2_flag2`。
- en: With the static mesh component selected, select Add Component | Skeletal Mesh
    to create a child skeletal mesh attached to the flagpole's static mesh.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择静态网格组件后，选择添加组件 | 骨骼网格，以创建附加到旗杆静态网格的子骨骼网格。
- en: Set the component's Skeletal Mesh property to `/Game/InfinityBladeIceLands/Environments/Ice/EX_EnvAssets/Meshes/SK_Env_Ice_Deco2_BlowingFlag3`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将组件的骨骼网格属性设置为`/Game/InfinityBladeIceLands/Environments/Ice/EX_EnvAssets/Meshes/SK_Env_Ice_Deco2_BlowingFlag3`。
- en: Set the skeletal mesh component's Location to (X=40.0, Y=0.0, Z=270.0) and its
    Scale to (X=1.8, Y=1.8, Z=1.8).
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将骨骼网格组件的位置设置为（X=40.0，Y=0.0，Z=270.0），并将其缩放设置为（X=1.8，Y=1.8，Z=1.8）。
- en: Drag the static mesh component on to the root component and set it as the new
    root.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将静态网格组件拖到根组件上，并将其设置为新的根。
- en: Add a Point Light component and set its Location to (X=40.0, Y=0.0, Z=270.0)
    so our flag stands out.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个点光源组件，并将其位置设置为（X=40.0，Y=0.0，Z=270.0），这样我们的旗帜就会显眼起来。
- en: Spawning an actor on the server only
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅在服务器上生成一个角色
- en: 'Now, let''s spawn our flag into the level, but only on the server:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将旗帜生成到关卡中，但只在服务器上生成：
- en: From your Modes panel, drag a Target Point somewhere on your map. Name it `FlagSpawnPoint`.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的模式面板上，拖动一个目标点到地图上的某个位置。将其命名为`FlagSpawnPoint`。
- en: Open up your level blueprint, and with FlagSpawnPoint still selected, right-click
    in the event graph to create a reference to it.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的关卡蓝图，在FlagSpawnPoint仍然被选中的情况下，右键单击事件图表以创建对它的引用。
- en: Find or create an Event BeginPlay node.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到或创建一个事件BeginPlay节点。
- en: Drag the execution line from this node and create a Switch Has Authority node.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这个节点拖动执行线，并创建一个Switch Has Authority节点。
- en: Drag the execution line from the Switch Has Authority node's Authority output
    and create a Spawn Actor from Class node.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Switch Has Authority节点的Authority输出中拖动执行线，并创建一个Spawn Actor from Class节点。
- en: Set its Class to the BP_ReplicatedFlag actor we just created.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其类设置为我们刚刚创建的BP_ReplicatedFlag角色。
- en: Drag an output from the reference to your flag spawn point in the level and
    call Get Actor Transform on it.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从引用中拖动一个输出到你在关卡中的旗帜生成点，并调用Get Actor Transform。
- en: 'Feed the transform into the Spawn node''s Spawn Transform:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将变换输入到生成节点的生成变换中：
- en: '![](img/1775344c-0812-4ac1-8e7b-3fbb40d58bbd.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1775344c-0812-4ac1-8e7b-3fbb40d58bbd.png)'
- en: Run it. You'll see the flag spawned on your server, but you won't see it on
    the client. Let's talk this through to see why this is.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它。你会看到旗帜在服务器上生成，但你在客户端上看不到它。让我们通过讨论来看看为什么会这样。
- en: In the preceding screenshot, the first thing we did on `BeginPlay` was check
    to see whether we have authority. Again, *network authority* is simply another
    term for the server. If we have authority, meaning we're running on the server,
    we spawn the flag at the location we supplied. If we're not on the server, we
    don't spawn it, which is why we didn't see it in our client view.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，我们在`BeginPlay`上做的第一件事是检查我们是否有权限。再次强调，*网络权限*只是服务器的另一个术语。如果我们有权限，意味着我们在服务器上运行，我们会在我们提供的位置生成旗帜。如果我们不在服务器上，我们就不会生成它，这就是为什么我们在客户端视图中没有看到它的原因。
- en: This is an important pattern to remember. When we talk about making sure important
    gameplay events happen only on the server, this is how you do it. Check to see
    whether you have authority, and perform the action only if you do.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的模式要记住。当我们谈论确保重要的游戏事件仅在服务器上发生时，这就是您要做的。检查是否具有权限，并仅在具有权限时执行操作。
- en: Replicating the actor to the client
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将角色复制到客户端
- en: 'Now of course in this instance, we want to see this actor on the client as
    well, but at present we can''t because it exists only on the server. Let''s change
    this by making it into a *replicated* actor:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在这种情况下，我们也希望在客户端上看到这个角色，但目前我们不能，因为它只存在于服务器上。让我们通过将其变成一个*复制*角色来改变这一点：
- en: 'Open our flag actor''s blueprint, and in its Details | Replication section,
    set Replicates to true:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们的旗帜角色蓝图，在其详细信息|复制部分中，将Replicates设置为true：
- en: '![](img/0b02951d-cd47-488e-b3c7-2e1afd00e7d5.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b02951d-cd47-488e-b3c7-2e1afd00e7d5.png)'
- en: Test it again. Now, we see the flag on the client as well.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 再次进行测试。现在，我们也在客户端上看到了标志。
- en: By indicating that this actor should replicate, we've now told the server to
    send the spawned object to all of the connected clients as well. You may have
    noticed as you were testing that you're able to see the other player's location
    represented as a gray sphere floating through space. This is because the default
    pawn class we're currently using is set to replicate as well. (If you're interested
    in seeing this in the source code, open `<Your Engine Install location|\Engine\Source\Runtime\Engine\Private\DefaultPawn.cpp`,
    and you'll see that `bReplicates` is set to true in the constructor.)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指示该角色应该复制，我们现在告诉服务器将生成的对象发送给所有连接的客户端。您可能已经注意到，在测试时，您可以看到其他玩家的位置表示为一个灰色的球体漂浮在空间中。这是因为我们当前使用的默认pawn类也设置为复制。（如果您有兴趣在源代码中看到这一点，请打开`<您的引擎安装位置|\Engine\Source\Runtime\Engine\Private\DefaultPawn.cpp`，您将看到构造函数中的`bReplicates`设置为true。）
- en: Replicating a variable
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制一个变量
- en: Let's take this a step further and imagine that this point light we put on our
    flag is meaningful to our game. If that's the case, we need to be sure that only
    the server changes its value, and that all clients can see what that value is.
    That means that we need to ensure that we have authority before we change it,
    and then we need to replicate that change down to the connected clients.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步思考一下，假设我们在旗帜上放置的这个点光源对我们的游戏很重要。如果是这样的话，我们需要确保只有服务器改变其值，并且所有客户端都可以看到该值。这意味着我们需要在改变之前确保我们有权限，然后将该更改复制到连接的客户端。
- en: Open the flag's blueprint and in the Variables section, and add a Boolean variable
    named `bFlagActive`.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开旗帜的蓝图，在变量部分添加一个名为`bFlagActive`的布尔变量。
- en: Compile and save your blueprint.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并保存蓝图。
- en: In the event graph, on Event BeginPlay, add a Switch Has Authority node.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件图中，在事件BeginPlay上，添加一个Switch Has Authority节点。
- en: From the Authority execution line, *Alt* + drag a setter for `bFlagActive` and
    set it to False.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Authority执行行中，*Alt* +拖动`bFlagActive`的setter并将其设置为False。
- en: Create a Set Timer by Event node and connect it to your `bFlagActive` setter.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Set Timer by Event节点，并将其连接到您的`bFlagActive` setter。
- en: Set its Time to 3.0 and its Looping property to True.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其时间设置为3.0，并将其循环属性设置为True。
- en: Create a Custom Event and name it `ToggleFlagState`.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个自定义事件，并将其命名为`ToggleFlagState`。
- en: Connect the red connector (this is called an **Event Delegate** by the way)
    from your timer to your custom event.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将计时器的红色连接器（顺便说一下，这被称为**事件委托**）连接到自定义事件。
- en: '*Alt* + drag another setter for `bFlagActive` on to the graph and connect it
    to your ToggleFlagState event.'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*Alt* +拖动另一个`bFlagActive`的setter到图表上，并将其连接到ToggleFlagState事件。'
- en: '*Ctrl* + drag a getter for `bFlagActive` on to the graph.'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*Ctrl* +拖动`bFlagActive`的getter到图表上。'
- en: 'Create a Not Boolean node from its output and connect its result to the setter''s
    input:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从其输出创建一个Not Boolean节点，并将其结果连接到setter的输入：
- en: '![](img/c41f139f-e9ff-4481-a22c-d948fdf83eab.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c41f139f-e9ff-4481-a22c-d948fdf83eab.png)'
- en: What we've just done here is, if we're on the server, initialize the `bFlagActive`
    variable, and then set up a looping timer that flips its value to the opposite
    value every three seconds.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚做的是，如果我们在服务器上，初始化`bFlagActive`变量，然后设置一个循环计时器，每三秒翻转其值。
- en: You have two Set Timer event types available to you. You can set timers to call
    functions by name when they trigger, or to call events. If you're working in the
    event graph, it's often more readable to connect an event directly to the timer's
    delegate connector. If you're working inside a function, where events are not
    available to you, call a function by name instead.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 您有两种可用的Set Timer事件类型。您可以设置定时器在触发时调用函数的名称，或者调用事件。如果您在事件图中工作，直接将事件连接到定时器的委托连接器通常更可读。如果您在函数内部工作，其中事件对您不可用，请改为按名称调用函数。
- en: 'Now, we need to give ourselves a way to see the flag changing state:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要找到一种方法来查看标志的状态变化：
- en: Find or create the Event Tick node.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到或创建事件Tick节点。
- en: Drag a reference to your point light on to the graph.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对点光源的引用拖动到图表上。
- en: Create a Set Intensity node and call it on the point light.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Set Intensity节点，并在点光源上调用它。
- en: '*Ctrl* + drag a getter for your `bFlagActive` variable on to the graph.'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*Ctrl* +拖动`bFlagActive`变量的getter到图表上。'
- en: Drag out its result and create a Select node from it.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖出其结果并创建一个Select节点。
- en: Connect the Select node's Return Value to the Set Intensity node's New Intensity
    input.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Select节点的返回值连接到Set Intensity节点的New Intensity输入。
- en: 'Set the Select node''s False value to 0.0 and its True value to 5000.0:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将选择节点的False值设置为0.0，将True值设置为5000.0：
- en: '![](img/c1f7bb7c-ff3e-458d-b3d8-8f7d7893dbbc.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1f7bb7c-ff3e-458d-b3d8-8f7d7893dbbc.png)'
- en: As you may recall, we're not fans of polling values on the tick event. It's
    a wasteful and generally sloppy technique. Don't worry—we're going to set up a
    better way to do this in just a moment.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能记得的那样，我们不喜欢在tick事件上轮询值。这是一种浪费和通常不规范的技术。别担心，我们马上就会设置一种更好的方法来做到这一点。
- en: In the meantime, though, let's test it.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，让我们进行测试。
- en: 'We can see our light turning on and off on the server, but not on the client.
    You may be able to guess now why this is. Because of our authority check, we''re
    only changing the value of `bFlagActive` on the server, and we''re never telling
    any of the clients about this change. Fixing this is fairly straightforward:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在服务器上看到我们的灯开关，但在客户端上看不到。现在你可能能猜到为什么了。由于我们的权限检查，我们只在服务器上改变了`bFlagActive`的值，而没有告诉任何客户端这个改变。修复这个问题相当简单：
- en: 'Select the `bFlagActive` variable and, in its Details section, set Variable
    | Replication to Replicated:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`bFlagActive`变量，并在其详细信息部分将变量 | 复制设置为复制：
- en: '![](img/42d06f05-4aa6-46f1-a84f-ff9b4cf9391c.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/42d06f05-4aa6-46f1-a84f-ff9b4cf9391c.png)'
- en: Run your test again. Now, you should see the flag's state changing on the client
    as well.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试。现在，你应该在客户端上看到标志的状态也在改变。
- en: This brings up an important point. Just because an actor is replicated doesn't
    mean that any of its properties, other than their initial states, are replicated.
    Again, this is deliberate. You don't want to send anything over the network that
    you don't need to send. Every bit of traffic adds to the bandwidth load and adds
    to the cost of adding additional players. Unreal by default replicates only what
    you tell it to replicate.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这提出了一个重要的问题。只因为一个actor被复制并不意味着它的任何属性（除了它们的初始状态）都会被复制。再次强调，这是有意的。你不希望发送任何你不需要发送的东西到网络上。每一点流量都增加了带宽负载，并增加了添加额外玩家的成本。Unreal默认只复制你告诉它要复制的内容。
- en: Notifying clients that a value has changed using RepNotify
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RepNotify通知客户端值已更改
- en: Now, we mentioned a moment ago that polling values on the tick is wasteful,
    since it performs an operation on every update even if there's no need to do it.
    It's nearly always a better idea to respond to events.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 刚才我们提到，轮询tick上的值是浪费的，因为它会在每次更新时执行一次操作，即使没有必要执行。响应事件几乎总是一个更好的主意。
- en: 'As it turns out, this is easy to do with replicated variables:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，使用复制变量很容易做到这一点：
- en: Select your `bFlagActive` variable and, in its Details | Variable block, set
    its Replication property to RepNotify instead of Replicated.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你的`bFlagActive`变量，并在其详细信息 | 变量块中，将其复制属性设置为RepNotify，而不是复制。
- en: Take a look at your Functions list. A new function was just automatically added,
    called `OnRep_bFlagActive`.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看你的函数列表。刚刚自动添加了一个新函数，名为`OnRep_bFlagActive`。
- en: Take everything you had on your Event Tick, select it, and *Ctrl* + *X* to cut
    it out.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你在Event Tick上的所有内容选中，然后按*Ctrl* + *X*剪切出来。
- en: 'Open up your new `OnRep_bFlagActive` function and paste everything into it,
    connecting the function''s execution line to your Set Intensity node:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的新的`OnRep_bFlagActive`函数，并将所有内容粘贴到其中，将函数的执行线连接到你的Set Intensity节点：
- en: '![](img/1f0af24f-0589-4ebf-9226-158c699bbf70.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1f0af24f-0589-4ebf-9226-158c699bbf70.png)'
- en: This is a more efficient way to respond to changes in the value. The `OnRep`
    function for a variable with its replication set to RepNotify will be called automatically
    every time that variable receives a new value from the server. This makes it easy
    and efficient to respond to those changes, and if we wanted to trigger an effect
    such as a particle system or perform some other operation when a new value arrived
    through replication, we now have a natural place to do this.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种更高效的响应值变化的方式。具有复制设置为RepNotify的变量的`OnRep`函数将在该变量每次从服务器接收到新值时自动调用。这使得响应这些变化变得简单高效，如果我们想在通过复制接收到新值时触发一个效果，比如粒子系统或执行其他操作，我们现在有了一个自然的地方来做这个。
- en: If you need something to happen when a new value arrives on a client through
    replication, use RepNotify to create an OnRep function, and do the operation there.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在客户端通过复制收到新值时发生某些事情，可以使用RepNotify创建一个OnRep函数，并在那里执行操作。
- en: The example we've built so far is fairly simple, but it actually illustrates
    a number of very important points. We've talked a bit about where objects live
    in the network framework, how to determine whether an action takes place on a
    network authority (server), or on a remote (client) session, how to determine
    whether an actor replicates from a server to clients, and how to replicate new
    values to clients and respond to their changes. Now, let's take things a step
    further and start to build something that looks a bit more like a game.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们构建的示例非常简单，但实际上它展示了一些非常重要的点。我们已经谈到了对象在网络框架中的位置，如何确定一个动作是在网络权限（服务器）上执行还是在远程（客户端）会话上执行，如何确定一个Actor是否从服务器复制到客户端，以及如何将新值复制到客户端并响应其变化。现在，让我们进一步构建一些看起来更像游戏的东西。
- en: Creating network-aware pawns for multiplayer
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为多人游戏创建网络感知pawn
- en: Now that we've seen a bit about how information moves from the server to the
    clients, let's explore the ways player actions get communicated from the clients
    back to the server. To get ready for this, we're going to take a shortcut and
    add a pawn that can already perform a few basic actions, and we'll get right to
    the task of making these actions work in a multiplayer setting.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了信息如何从服务器传递到客户端，让我们探索一下玩家操作如何从客户端传递回服务器。为了做好准备，我们将采取捷径，添加一个可以执行一些基本操作的pawn，并立即开始使这些操作在多人游戏中起作用。
- en: Adding a first-person pawn
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加第一人称Pawn
- en: 'We''re going to set ourselves up by adding the pawn from the First Person template:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过添加来自第一人称模板的pawn来设置自己：
- en: Create or open a project made using the Blueprint | First Person template.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建或打开一个使用蓝图 | 第一人称模板创建的项目。
- en: Select Content | FirstPersonBP | Blueprints | FirstPersonCharacter, and migrate
    this character into our working project.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Content | FirstPersonBP | Blueprints | FirstPersonCharacter，并将这个角色迁移到我们的工作项目中。
- en: Now, we need to tell our game mode to use it.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要告诉我们的游戏模式使用它。
- en: Open BP_MultiplayerGameMode, and set its Default Pawn Class to the FirstPersonCharacter
    we just migrated in.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开BP_MultiplayerGameMode，并将其默认的Pawn Class设置为我们刚刚迁移进来的FirstPersonCharacter。
- en: Let's test it. We should see a number of problems here. Our projectiles are
    bouncing off invisible walls. When players fire, we can't see it happen from the
    other machine. The other player's representation just appears as a first-person
    weapon. We'll fix all of these.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下。我们应该会看到一些问题。我们的抛射物会从看不见的墙壁上弹开。当玩家开火时，我们无法从另一台机器上看到发生的情况。另一个玩家的表示只会出现为第一人称武器。我们将修复所有这些问题。
- en: Setting collision response presets
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置碰撞响应预设
- en: 'First, let''s fix the collision problem. While it isn''t directly network-related,
    it''s distracting and not hard to correct:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们修复碰撞问题。虽然它与网络直接相关，但它会分散注意力，而且不难修正：
- en: 'Select one of the blocking volumes that''s blocking our projectiles:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个阻挡我们抛射物的阻挡体：
- en: '![](img/bdb8364d-fb07-406d-ac9a-78eeb4e340f3.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bdb8364d-fb07-406d-ac9a-78eeb4e340f3.png)'
- en: Take a look at its Details | Collision | Collision Presets to see what collision
    preset it's using.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看其详细信息|碰撞|碰撞预设，以查看它使用的碰撞预设。
- en: We can see that it's using the Invisible Wall preset. Probably, this preset
    is blocking a lot of things we don't want it to block. For our game, we really
    only want to stop pawns.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到它使用了Invisible Wall预设。很可能，这个预设正在阻挡我们不想阻挡的很多东西。对于我们的游戏，我们只想停止Pawn。
- en: Open Settings | Project Settings | Collision, and expand the Preset section.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开设置|项目设置|碰撞，并展开预设部分。
- en: 'Find the Invisible Wall preset, and hit the Edit button:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到Invisible Wall预设，并点击编辑按钮：
- en: '![](img/65cc6b46-f25e-47f6-a57a-cd92dd0a40e3.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![](img/65cc6b46-f25e-47f6-a57a-cd92dd0a40e3.png)'
- en: Here we've found and selected the InvisibleWall collision preset from the Engine
    | Collision | Preset list.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们找到并选择了引擎|碰撞|预设列表中的InvisibleWall碰撞预设。
- en: 'Sure enough, we can see that it''s blocking everything except visibility. Let''s
    change this. Set it to ignore everything except the Pawn in the Trace Type:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，我们可以看到它阻挡了除了可见性之外的一切。让我们进行更改。将其设置为除了Pawn之外的一切都忽略的Trace Type：
- en: '![](img/9c16e2a3-7b5d-42db-b2b3-1ee27e9925ca.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c16e2a3-7b5d-42db-b2b3-1ee27e9925ca.png)'
- en: 'We also need to make a change to our projectile:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要对我们的抛射物进行一些更改：
- en: Open `Content/FirstPersonBP/Blueprints/FirstPersonProjectile`, and select its
    `CollisionComponent`.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Content/FirstPersonBP/Blueprints/FirstPersonProjectile`，并选择其`CollisionComponent`。
- en: Under Details | Collision, set its Collision Presets property to OverlapAllDynamic.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在详细信息|碰撞下，将其碰撞预设属性设置为OverlapAllDynamic。
- en: This will be good enough for now. The walls no longer block anything but pawns,
    and the projectiles no longer attempt to bounce off objects in the world.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这已经足够好了。墙壁不再阻挡除了Pawn之外的任何东西，抛射物也不再试图从世界中的物体上弹开。
- en: With this out of the way, let's get back to setting up our networking.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这一步后，让我们回到设置我们的网络。
- en: Setting up a third-person character mesh
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置第三人称角色模型
- en: 'The first thing we want to do is get our remote pawn using a proper third-person
    mesh. Let''s add the content we''re going to need for this:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是使用适当的第三人称模型获取我们的远程角色。让我们添加我们需要的内容：
- en: 'From your Content Browser, hit Add New | Add Feature or Content Pack..., and
    select Blueprint Feature | Third Person:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从内容浏览器中，点击添加新内容|添加功能或内容包...，然后选择蓝图功能|第三人称：
- en: '![](img/c5da0440-bd3d-4a25-a3fb-06781f14e365.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5da0440-bd3d-4a25-a3fb-06781f14e365.png)'
- en: Here we're adding the Third Person content pack to our project.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在将第三人称内容包添加到我们的项目中。
- en: Add it to your project.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其添加到你的项目中。
- en: 'Now, we''re going to modify our pawn to use the third-person mesh:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们要修改我们的角色以使用第三人称模型：
- en: Open your FirstPersonCharacter blueprint, and hit Add Component | Skeletal Mesh.
    Make sure the actor or its CapsuleComponent is selected so this new component
    is created as a child of the CapsuleComponent.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的FirstPersonCharacter蓝图，并点击添加组件|骨骼网格。确保选择了角色或其CapsuleComponent，以便将此新组件创建为CapsuleComponent的子组件。
- en: Name the new component `ThirdPerson`.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新组件命名为`ThirdPerson`。
- en: Set its Details | Mesh | Skeletal Mesh to the SK_Mannequin mesh that just arrived
    with our third-person content.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其详细信息|网格|骨骼网格设置为刚刚与我们的第三人称内容一起到达的SK_Mannequin网格。
- en: Set its Details | Animation | Anim Class to use the ThirdPerson_AnimBP_C animation
    blueprint from our third-person pack.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其详细信息|动画|动画类设置为使用ThirdPerson_AnimBP_C动画蓝图。
- en: 'Adjust its position so it lines up appropriately with the capsule (setting
    its Location Z value to -90.0 and its Rotation Z (Yaw) value to -90.0 works well
    enough):'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整其位置，使其与胶囊对齐（将其位置Z值设置为-90.0，将其旋转Z（偏航）值设置为-90.0即可）：
- en: '![](img/a03fc764-8494-4adb-abef-27e2685bcf38.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a03fc764-8494-4adb-abef-27e2685bcf38.png)'
- en: 'If we run it right now, we''ll see that the third-person mesh is blocking our
    camera view. We want to display this mesh for other players, but hide it for ourselves:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行它，我们会看到第三人称模型阻挡了我们的摄像机视图。我们希望为其他玩家显示此模型，但对于自己来说隐藏它：
- en: Jump over to the Event Graph of FirstPersonCharacter and find its Event BeginPlay node.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳转到FirstPersonCharacter的事件图表，并找到其Event BeginPlay节点。
- en: Drag the Event BeginPlay node out a bit to give yourself some room to work.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Event BeginPlay节点拖动出一点，以便有足够的空间进行操作。
- en: Right-click and add an Is Locally Controlled node to the graph.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击并添加一个Is Locally Controlled节点到图表中。
- en: Create a Branch from your Is Locally Controlled node, and connect execution
    output of Begin Play to it.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的Is Locally Controlled节点创建一个分支，并将Begin Play的执行输出连接到它。
- en: Drag a reference to the `ThirdPerson` component on to your graph.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对`ThirdPerson`组件的引用拖动到你的图表中。
- en: Call Set Hidden in Game on it, with New Hidden set to true.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中调用Set Hidden in Game，将New Hidden设置为true。
- en: Execute this Set Hidden in Game call from the Branch node's True output.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从分支节点的True输出执行此Set Hidden in Game调用。
- en: Connect execution output of Set Hidden in Game to the Branch node that Event
    BeginPlay used to feed into.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Set Hidden in Game的执行输出连接到Event BeginPlay用于输入的分支节点。
- en: Connect your Is Locally Controlled branch's `False` output to the Is Head Mounted
    Display Enabled branch's input.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的Is Locally Controlled分支的`False`输出连接到Is Head Mounted Display Enabled分支的输入。
- en: In an instance such as this, it's a good idea to double-click your execution
    lines to create reroute nodes to avoid crossing under other nodes, and to make
    it clear where the conditional part of an execution begins and ends. This has
    no effect on the behavior of the blueprint, but it can improve its readability.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，双击执行线以创建重定向节点是一个好主意，以避免在其他节点下交叉，并清楚地标明执行的条件部分的开始和结束。这对蓝图的行为没有影响，但可以提高其可读性。
- en: 'Your graph should now look something like this screenshot:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 您的图表现在应该类似于此屏幕截图：
- en: '![](img/eaa574f9-dd5d-4795-bfc0-51e015af9e77.png)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eaa574f9-dd5d-4795-bfc0-51e015af9e77.png)'
- en: Checking whether an actor is locally controlled is a thing you'll do often in
    network development. In a single-player environment, of course, this isn't a consideration,
    everything is locally-controlled, but once you're dealing with objects that are
    arriving through replication, it can often be the case that you'll want to treat
    them differently if they belong to someone else.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络开发中，经常需要检查一个actor是否是本地控制的。在单人游戏环境中，当然不需要考虑这个问题，因为一切都是本地控制的，但一旦涉及到通过复制到达的对象，如果它们属于其他人，通常情况下您可能希望对它们进行不同的处理。
- en: You can also achieve this by setting the ThirdPerson component's Details | Rendering
    | Owner No See setting to True. This flag, and its companion, Only Owner See,
    can also be used to make certain things visible only to owners or invisible to
    them. You'll have to expand the Advanced area of the Rendering options to see
    it. For this example, we chose to use the Is Locally Controlled check because
    there are so many other cases in which it will be used, but it's worth it to know
    that these shortcuts exist.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过将ThirdPerson组件的详细信息|渲染|Owner No See设置为True来实现这一点。这个标志及其伴侣Only Owner See也可以用于使某些东西只对所有者可见或对其不可见。您必须展开渲染选项的高级区域才能看到它。对于这个例子，我们选择使用Is
    Locally Controlled检查，因为有很多其他情况会使用它，但了解这些快捷方式是值得的。
- en: Let's run it again, and you'll now see the third-person mesh for the remote
    character, and the first-person mesh for the locally-controlled character.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行它，现在您将看到远程角色的第三人称模型和本地控制角色的第一人称模型。
- en: Adjusting the third-person weapon
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整第三人称武器
- en: 'The weapon is in a strange place for the third-person character. Let''s fix
    that:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第三人称角色来说，武器的位置很奇怪。让我们来修复一下：
- en: Open `Content/Mannequin/Character/Mesh/UE4_Mannequin_Skeleton` and find the
    hand_r bone in the skeleton tree.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Content/Mannequin/Character/Mesh/UE4_Mannequin_Skeleton`，在骨骼树中找到hand_r骨骼。
- en: 'Right-click the bone and select Add Socket:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击骨骼并选择添加插座：
- en: '![](img/02be199f-0f1c-42b6-a391-0f071141bfa3.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![](img/02be199f-0f1c-42b6-a391-0f071141bfa3.png)'
- en: Right click the hand_r bone and select Add Socket here.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击hand_r骨骼并选择在此处添加插座。
- en: Name the new socket `Weapon`.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新插座命名为`Weapon`。
- en: Right-click the socket and select Add Preview Asset, and select SK_FPGun as
    the preview.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击插座，选择添加预览资产，并选择SK_FPGun作为预览。
- en: Move the socket until the weapon appears to be lined up properly with the hand.
    (Setting Relative Location to X=-12.5, Y=5.8, Z=0.2, and setting the Relative
    Rotation Z (Yaw) value to 80.0 seems to work well enough.)
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动插座，直到武器与手部正确对齐。（将相对位置设置为X=-12.5，Y=5.8，Z=0.2，并将相对旋转Z（偏航）值设置为80.0似乎效果不错。）
- en: 'Now, we need to attach the weapon to the socket we just made, but only for
    remote players:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将武器附加到刚刚创建的插座上，但仅适用于远程玩家：
- en: Jump back to our event graph of FirstPersonCharacter and find the Event BeginPlay
    node.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳回到FirstPersonCharacter的事件图，并找到Event BeginPlay节点。
- en: From the Is Locally Controlled branch's False output, connect an AttachToComponent
    (FP_Gun) node.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Is Locally Controlled分支的False输出中，连接一个AttachToComponent（FP_Gun）节点。
- en: We've seen this before, but again, as a reminder, there are two versions of
    AttachToComponent—one works on actors, while the other works on components. Select
    the one that's bound to your FP_Gun component.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前见过这个，但再次提醒一下，AttachToComponent有两个版本，一个适用于actors，另一个适用于components。选择与您的FP_Gun组件绑定的版本。
- en: Drag your third-person component into the AttachToComponent node's parent input.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的第三人称组件拖动到AttachToComponent节点的父级输入中。
- en: 'Enter the name of the socket you created on your skeleton in Socket Name. (Weapon):'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在插座名称中输入您在骨骼上创建的插座的名称（Weapon）：
- en: '![](img/71fd75ae-93e1-4f7f-86a7-63ddf67caeae.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71fd75ae-93e1-4f7f-86a7-63ddf67caeae.png)'
- en: Run it again. The weapon should now be more reasonably-placed. It's not aiming
    where the other player is aiming because we haven't added anything to the third-person
    animation blueprint to handle this. Adding this capability falls outside the scope
    of this chapter, since it really takes us out of networking, so for the purposes
    of our game here, we're going to leave this as it is.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行。现在武器应该放置得更合理。它没有瞄准其他玩家瞄准的位置，因为我们还没有在第三人称动画蓝图中添加任何内容来处理这个问题。添加这个功能超出了本章的范围，因为它真的让我们脱离了网络，所以对于我们这里的游戏目的，我们将保持现状。
- en: The next thing we need to do is make sure that when a player fires their weapon,
    the server handles the shot, and replicates it to the other clients.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确保当玩家开火时，服务器处理射击并将其复制到其他客户端。
- en: Replicating player actions
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制玩家的动作
- en: 'As we saw earlier, in the current build players can''t see it when other players
    fire their weapons. We''ll begin simply enough, by making sure projectiles replicate
    from the server to the clients when they''re spawned:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，在当前版本中，其他玩家开火时玩家看不到它。我们将从简单的开始，确保当生成时，从服务器到客户端复制弹丸：
- en: Open up the FirstPersonProjectile blueprint, and in its Details | Replication
    section, set Replicates to true.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开FirstPersonProjectile蓝图，在其详细信息|复制部分中，将Replicates设置为true。
- en: Run it now, and you'll see that if you fire the weapon on the server, the client
    can see the projectiles, but if you fire the weapon on the client, the server
    doesn't see it.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行它，您会发现如果在服务器上开火，客户端可以看到弹丸，但如果在客户端上开火，服务器看不到它。
- en: 'Take a moment to form a clear mental picture of why this is. Replication goes
    one way: from the server to the client. When we spawned the flag on the server
    in our earlier example, we saw it on the client because we''d told the server
    to replicate it. The same thing is now happening with the projectiles. So, the
    question, then, is how does a client tell the server that it needs to spawn a
    projectile?'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 花一点时间形成一个清晰的心理图像，为什么会这样。复制是单向的：从服务器到客户端。当我们在之前的示例中在服务器上生成旗帜时，我们在客户端上看到了它，因为我们告诉服务器要复制它。现在，同样的事情也发生在投射物上。那么，问题是，客户端如何告诉服务器它需要生成一个投射物呢？
- en: Using remote procedure calls to talk to the server
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用远程过程调用与服务器通信
- en: The answer comes through a process called a **remote procedure** (**RPC**).
    A remote procedure call is a call made from one system that's intended to run
    on another system. In our case, when we want to fire the weapon, we'll have the
    client make an RPC to the server telling it that we want to fire, and the server
    will handle actually firing the weapon.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 答案通过一种称为**远程过程**（**RPC**）的过程传递。远程过程调用是从一个系统发出的，旨在在另一个系统上运行的调用。在我们的例子中，当我们想要开火时，我们将让客户端向服务器发出一个RPC，告诉它我们想要开火，服务器将处理实际的开火操作。
- en: 'Let''s change our pawn''s firing method to use an RPC:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的角色的开火方法更改为使用RPC：
- en: Open your FirstPersonCharacter blueprint's Event Graph, and look for InputAction
    Fire.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的FirstPersonCharacter蓝图的事件图，找到InputAction Fire。
- en: Somewhere nearby, create a custom event. Call it `ServerFire`.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在附近创建一个自定义事件。将其命名为`ServerFire`。
- en: 'In the custom event''s Details, set its Graph | Replicates value to Run on
    Server:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在自定义事件的详细信息中，将其Graph | Replicates值设置为Run on Server：
- en: '![](img/bcbc04ea-e48b-4f85-ac3e-876bacd2560c.png)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bcbc04ea-e48b-4f85-ac3e-876bacd2560c.png)'
- en: Now, let's get ready to use this call. The first thing we're going to want to
    do with our weapon firing is separate those things that are gameplay-relevant
    and should be run on the server, and those things that are purely cosmetic and
    can be run on the client.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们准备使用这个调用。我们首先要做的是将武器开火的那些与游戏相关且应在服务器上运行的部分与纯粹的用于装饰的部分分开。
- en: Let's create an additional Custom Event to handle the non-essential client stuff.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个额外的自定义事件来处理非必要的客户端内容。
- en: Create a Custom Event and call it `SimulateWeaponFire`.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个自定义事件并将其命名为`SimulateWeaponFire`。
- en: Unreal developers commonly follow a naming convention whereby non-essential
    cosmetic aspects of a network action are named with the prefix *simulate*. This
    indicates to the reader that this function is safe to run on the client and contains
    only non-state-changing actions (sounds, animations, particles, those sorts of
    things). It also indicates to the reader that the function in question is safe
    to skip on a dedicated server.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 虚幻引擎开发者通常遵循一种命名约定，即将网络操作的非必要装饰性方面命名为前缀*simulate*。这向读者表明该函数可以安全地在客户端上运行，并且只包含非状态更改的操作（声音、动画、粒子等）。它还向读者表明该函数在专用服务器上可以安全地跳过。
- en: Grab the Play Sound at Location call and the GetActorLocation call feeding it,
    disconnect them from the SpawnActor FirstPersonProjectile node, and connect them
    to your new SimulateWeaponFire event.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到Play Sound at Location调用和GetActorLocation调用，将它们从SpawnActor FirstPersonProjectile节点断开连接，并将它们连接到新的SimulateWeaponFire事件。
- en: Get rid of the Branch feeding from the InputTouch node's FingerIndex. There's
    no execution line going into it, which means it's not doing anything. This is
    just clutter; someone didn't bother to clean out the graph.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 摆脱从InputTouch节点的FingerIndex分支出来的分支。它没有任何执行线进入它，这意味着它没有起作用。这只是一种杂乱无章的情况；有人没有清理图表。
- en: 'The partially-updated graph should look something like this, so far:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 部分更新的图应该看起来像这样：
- en: '![](img/968a95f1-17e2-438b-8a56-f45f94990b8f.png)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![](img/968a95f1-17e2-438b-8a56-f45f94990b8f.png)'
- en: The Spawn Projectile method from the Third Person content pack we migrated into
    our project
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 从第三人称内容包中迁移到我们项目中的生成投射物的方法
- en: Now, grab that Montage Play call, disconnect it from the execution line it's
    currently in, and put it on to the SimulateWeaponFire execution line.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，获取那个Montage Play调用，将其从当前所在的执行线断开连接，并将其放到SimulateWeaponFire的执行线上。
- en: What we've done now has been to take everything that's purely decorative and
    move it to its own event that can be called separately.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在所做的是将所有纯装饰性的东西移到一个可以单独调用的事件中。
- en: This is a good convention to follow even when you're developing a single-player
    application because it makes it easy to see which chunks of code are actually
    changing things and which ones are cosmetic. It's a worthwhile practice to get
    into the habit of keeping them separate.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在开发单人应用程序时，遵循这个约定也是一个好习惯，因为它可以很容易地看出哪些代码块实际上正在改变事物，哪些是装饰性的。将它们分开是一个值得养成的好习惯。
- en: 'Now that we''ve created our `SimulateWeaponFire` event and populated it, we''ll
    make sure it gets called on any system that receives the input:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了`SimulateWeaponFire`事件并填充了它，我们将确保在接收输入的任何系统上调用它：
- en: Now, put a call to SimulateWeaponFire where the Montage Play node used to be,
    so it will get called any time this input event gets heard.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在Montage Play节点曾经所在的位置上调用SimulateWeaponFire，这样它将在每次听到此输入事件时被调用。
- en: Add a Switch Has Authority node right after the Simulate Weapon Fire call.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Simulate Weapon Fire调用之后添加一个Switch Has Authority节点。
- en: Connect the Switch node's Authority output to the SpawnActor First Person Projectile
    call.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Switch节点的Authority输出连接到SpawnActor First Person Projectile调用。
- en: From its Remote branch, make a call to the ServerFire node we created earlier.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从其Remote分支，调用我们之前创建的ServerFire节点。
- en: Feed the ServerFire node's execution output into the SpawnActor First Person
    Projectile node's input.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将ServerFire节点的执行输出连接到SpawnActor First Person Projectile节点的输入。
- en: 'Your SpawnProjectile graph should now look something like this screenshot:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的SpawnProjectile图应该看起来像这样：
- en: '![](img/669f3201-9fd6-4ccc-b1a4-2f10c8ee7dc7.png)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
  zh: '![](img/669f3201-9fd6-4ccc-b1a4-2f10c8ee7dc7.png)'
- en: 'And, the SimulateWeaponFire graph should look like this screenshot:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: SimulateWeaponFire图应该如下所示：
- en: '![](img/fe474686-8ce1-4b2c-ad2d-49d46918dd35.png)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe474686-8ce1-4b2c-ad2d-49d46918dd35.png)'
- en: Try it out. Aiming is going to be incorrect for clients because we're not doing
    anything to send the client's weapon aiming to the server, but you should now
    see the projectile spawning and hear the fire sound in both directions.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 试一试。对于客户端来说，瞄准会不准确，因为我们没有做任何事情来将客户端的武器瞄准发送到服务器，但是现在你应该能看到抛射物生成并且听到火焰声音。
- en: Let's improve this.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改进一下。
- en: 'At present, the projectile''s spawn rotation is coming from the first-person
    camera. This isn''t going to work when communicating from the client to the server,
    because the server doesn''t know anything about that camera. Let''s replace this
    with a value the server does know about:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，抛射物的生成旋转来自第一人称相机。当从客户端向服务器通信时，这种方法行不通，因为服务器对相机一无所知。让我们用服务器知道的一个值来替换它：
- en: 'Right-click in the graph to create a Get Base Aim Rotation node, and feed it
    into the Make Transform node, replacing the input from the camera''s GetWorldRotation:'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图表中右键单击创建一个“Get Base Aim Rotation”节点，并将其输入连接到“Make Transform”节点，替换相机的“GetWorldRotation”输入：
- en: '![](img/4d1d9cba-f4d0-42e4-8326-5e29c02b5ea6.png)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d1d9cba-f4d0-42e4-8326-5e29c02b5ea6.png)'
- en: Test it again. The origin for the client's projectile when seen on the server
    is still going to be incorrect, but the aim rotation is now correct. (Fixing the
    origin would really require us to build a proper third-person animation blueprint,
    which takes us beyond the scope of this chapter.)
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 再次测试。当在服务器上看到客户端的抛射物时，其起点仍然不正确，但是瞄准旋转现在是正确的。（修复起点实际上需要我们构建一个适当的第三人称动画蓝图，这超出了本章的范围。）
- en: Let's talk about how this is working so far. There's an important pattern embedded
    here that's worth internalizing.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来讨论一下目前的工作原理。这里有一个重要的模式值得内化。
- en: When the fire input event arrives, we check to see whether we have authority
    to spawn the particle. If we do, we just go ahead and spawn it. If we don't, however,
    we make a remote procedure call to the server to tell it to spawn it. It does,
    and then we see it here on our local client because it's been replicated.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 当火焰输入事件到达时，我们检查是否有权限生成粒子。如果有，我们就直接生成它。然而，如果没有权限，我们会向服务器发起远程过程调用，告诉它生成粒子。它生成了粒子，然后我们在本地客户端看到了它，因为它已经被复制了。
- en: 'Most gameplay events in multiplayer games will be written according to this
    pattern. Here''s a simplified example for clarity:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数多人游戏中的游戏事件都会按照这个模式编写。以下是一个简化的示例，以便更清楚地理解：
- en: '![](img/d87eab2b-5b83-4d35-a459-81372f832fed.png)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d87eab2b-5b83-4d35-a459-81372f832fed.png)'
- en: In the preceding screenshot, the Do the thing call will only ever run on the
    server. If the event that triggers it is happening on the server, it just runs,
    and if the event is happening on a client, the client calls the Server Do the
    Thing RPC, which then handles calling Do the Thing. This pattern is worth committing
    to memory. You'll use it a lot.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，执行“Do the thing”调用的只会在服务器上运行。如果触发它的事件发生在服务器上，它就会直接运行；如果事件发生在客户端上，客户端会调用“Server
    Do the Thing”RPC，然后处理调用“Do the Thing”。这种模式值得记住。你会经常使用它。
- en: There's a common convention among Unreal developers whereby we prefix the names
    of the RPCs that run on the server with the prefix *Server*. You don't have to
    do this, but it's a good idea, and Unreal developers will cast disapproving glances
    your way if you don't. It makes it much easier to see which functions are RPCs
    and which ones run locally.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻开发者中有一个常见的约定，即我们将在服务器上运行的RPC的名称前缀为“Server”。你不一定要这样做，但这是一个好主意，如果你不这样做，虚幻开发者会不满地看着你。这样做可以更容易地看到哪些函数是RPC，哪些函数是本地运行的。
- en: Using multicast RPCs to communicate to clients
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多播RPC与客户端通信
- en: 'There''s another problem with what we''ve written that will be difficult to
    detect if you''re testing on a single machine: the simulated sounds and animations
    only play on the owning client. If we were playing on two separate machines and
    the other player fired near us, we wouldn''t hear it.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所编写的代码还存在另一个问题，如果你在单台机器上进行测试，很难发现：模拟的声音和动画只会在拥有者客户端上播放。如果我们在两台独立的机器上进行游戏，并且另一个玩家在我们附近开火，我们是听不到的。
- en: Why not?
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不呢？
- en: In the previous screenshot, when the input event is received on the local client,
    it calls the `Simulate` method to play the sound and animation, and then checks
    to see whether it has authority to decide whether to spawn the projectile itself
    or ask the server to handle it. But, what if there's another player standing nearby?
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个截图中，当本地客户端接收到输入事件时，它调用“Simulate”方法播放声音和动画，然后检查是否有权限决定自己生成抛射物还是请求服务器处理。但是，如果附近还有另一个玩家呢？
- en: Player A's client will send the RPC to the server to spawn the projectile, so
    everybody's going to see that, but the call to simulate the firing event only
    ever happened on player A's machine. The representation of player A's pawn over
    on player B's machine (we call this representation a *remote proxy*) was never
    told to play the animation, so it doesn't.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家A的客户端将发送RPC到服务器以生成抛射物，所以每个人都会看到，但是触发开火事件的调用只会在玩家A的机器上发生。在玩家B的机器上，玩家A的角色（我们称之为*远程代理*）没有被告知播放动画，所以它不会播放。
- en: We can solve this using another type of RPC, called a **multicast event**.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用另一种类型的RPC来解决这个问题，称为**多播事件**。
- en: You'll often hear developers referring to multicast events as **net multicast** events,
    or as **broadcast** events. These terms refer to the same thing. By convention,
    just as server RPC event names are prefixed with *server*, multicast events are
    often named with *broadcast* as a prefix. This is a less-commonly-followed convention
    than the *server* prefix and you don't have to do it, but you'll have an easier
    time following your blueprints later on if you make this a habit.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会听到开发者将多播事件称为**网络多播**事件，或者称为**广播**事件。这些术语指的是同一件事。按照惯例，就像服务器RPC事件名称以“server”为前缀一样，多播事件通常以“broadcast”作为前缀命名。这个约定不如“server”前缀常见，你不一定要这样做，但是如果你养成这个习惯，以后在蓝图中会更容易跟踪。
- en: 'Since we''ve already abstracted our simulate methods to their own event, this
    isn''t hard to do:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经将模拟方法抽象到了它们自己的事件中，所以这并不难做到：
- en: 'Select your SimulateWeaponFire event, and in its Details | Graph, set its Replicates
    property to Multicast:'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择你的SimulateWeaponFire事件，在其详细信息|图表中，将其复制属性设置为Multicast：
- en: '![](img/74351ba0-a09d-498b-ab14-2a1f8273d3e1.png)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![](img/74351ba0-a09d-498b-ab14-2a1f8273d3e1.png)'
- en: What this will do is send this event to the server and instruct it to send it
    down to all connected clients.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把这个事件发送到服务器，并指示服务器将其发送给所有连接的客户端。
- en: Now, when Player A fires, the call to spawn the projectile will happen only
    on the server, but the call to play the fire sound and animation will happen on
    every representation of player A's pawn across the network.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当玩家A开火时，生成抛射物的调用只会在服务器上发生，但播放开火声音和动画的调用会在网络上的玩家A的所有表示中发生。
- en: If you'd like, you can rename your `SimulateWeaponFire` event `BroadcastSimulateWeaponFire`.
    Some developers follow this convention, others don't. In general, though, the
    more information you give yourself and other developers about what you're doing,
    the easier a time you or they are going to have debugging or maintaining your
    code.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以将你的`SimulateWeaponFire`事件重命名为`BroadcastSimulateWeaponFire`。一些开发者遵循这个约定，而其他人则不遵循。总的来说，你给自己和其他开发者提供的关于你正在做什么的信息越多，你或他们在调试或维护代码时就会更容易。
- en: Client RPCs
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端RPC
- en: There's one more type of RPC, which we're not going to demonstrate here, but
    that we should discuss for the sake of completeness. Let's say you were running
    an operation on the server and you needed to make a call specifically to the client
    that owns the object you were operating on. You can do this by setting the event
    to Run on owning Client.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种RPC类型，我们在这里不打算演示，但为了完整起见，我们应该讨论一下。假设你在服务器上运行一个操作，并且你需要专门向拥有该对象的客户端发出调用。你可以通过将事件设置为在拥有客户端上运行来实现这一点。
- en: Reliable RPCs
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可靠的RPC
- en: There's one final determination we have to make when we're deciding how to replicate
    a function call, and that's whether to make the call reliable.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们决定如何复制函数调用时，还有一个最终的决定要做，那就是是否使调用可靠。
- en: To understand what this flag means, we need to understand something critical
    about networking. The internet is an unreliable thing. Just because you send an
    RPC to someone on the other side of the globe, there's absolutely no guarantee
    that it will get there. Packets get lost all the time. That's not an unreal thing;
    it's a reality-of-the-world thing. The choice you need to make as a developer
    is what to do about this.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这个标志的含义，我们需要了解一些关于网络的关键知识。互联网是不可靠的。仅仅因为你向地球另一边的某人发送了一个远程过程调用（RPC），并不能保证它一定会到达。数据包经常会丢失。这不是虚幻的事情，而是现实世界的事情。作为开发者，你需要做出的选择是如何处理这个问题。
- en: If an RPC is important to the game, such as firing a weapon, make it reliable.
    What this will do is instruct the network interface to re-send it until it receives
    confirmation from the other system that the call was received. This adds traffic
    to your network, however, so do it only for those calls you care about. If you're
    just broadcasting a cosmetic call, such as a weapon sound, leave it unreliable,
    since your game isn't going to break if it doesn't arrive. The call to fire the
    weapon, however, should be reliable, since it matters to the player and to the
    game whether it happens.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个RPC对游戏很重要，比如开火，那就让它可靠。这将指示网络接口在收到来自其他系统的调用确认之前，重新发送它。然而，这会增加网络流量，所以只对你关心的那些调用进行可靠处理。如果你只是广播一个装饰性的调用，比如武器声音，那就让它不可靠，因为如果它没有到达，你的游戏不会出错。然而，开火的调用应该是可靠的，因为它对玩家和游戏的发展都很重要。
- en: 'Let''s make this change now:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们进行这个更改：
- en: Find your ServerFire custom event, and in its Details | Graph, set its Reliable
    property to true.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到你的ServerFire自定义事件，在其详细信息|图表中，将其可靠属性设置为true。
- en: Leave your BroadcastSimulateWeaponFire event unreliable, because it's just playing
    cosmetic events that aren't important enough to be worth clogging the network.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的BroadcastSimulateWeaponFire事件设置为不可靠，因为它只是播放不重要的装饰性事件，不值得堵塞网络。
- en: Going further
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步了解
- en: Networking is a substantial topic, and, to be honest, we've only scratched the
    surface here. Our purpose in writing this has been to give you a solid mental
    model from which you can understand what Unreal's network framework looks like,
    and what sorts of things you need to understand to work within it.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是一个重要的主题，老实说，我们在这里只是浅尝辄止。我们写这篇文章的目的是为了给你一个坚实的思维模型，让你能够理解虚幻的网络框架是什么样的，以及你需要理解哪些方面才能在其中工作。
- en: This is heady stuff, and it can get fairly confusing to new developers. The
    trick to network development is to create a clear mental model of what's going
    on. Take your time to understand these concepts, and you'll have a much easier
    time.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一项复杂的工作，对于新开发者来说可能会相当困惑。网络开发的诀窍是创建一个清晰的思维模型来理解正在发生的事情。花些时间来理解这些概念，你会更容易上手。
- en: There are a few topics we didn't cover here, such as hosting sessions and making
    it possible for others to join them, and quite a lot of the finer points of how
    networking works, such as relevance. These things are worth understanding, and
    there are a few good resources available to you to take your understanding further.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些我们没有涵盖到的话题，比如主持会话和让其他人加入会话，以及网络工作的一些细节，比如相关性。这些都是值得了解的，而且有一些很好的资源可以帮助你进一步理解。
- en: First, check out the Network Examples map in your Content Examples project,
    and take some time to understand what they're showing. Next, Cedric Neukirchen's
    *Multiplayer Network Compendium*, [http://cedric-neukirchen.net/2017/02/14/multiplayer-network-compendium/](http://cedric-neukirchen.net/2017/02/14/multiplayer-network-compendium/), is
    an outstanding resource for learning how Unreal's networking framework works.
    Unreal's documentation lives here: [https://docs.unrealengine.com/en-us/Gameplay/Networking](https://docs.unrealengine.com/en-us/Gameplay/Networking),
    and it's absolutely worthwhile to spend some time picking through its Multiplayer
    Shootout project in light of what you've learned here.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，查看你的Content Examples项目中的Network Examples地图，并花些时间理解它们展示的内容。接下来，Cedric Neukirchen的《多人网络手册》[http://cedric-neukirchen.net/2017/02/14/multiplayer-network-compendium/](http://cedric-neukirchen.net/2017/02/14/multiplayer-network-compendium/)
    是一个学习虚幻网络框架工作原理的杰出资源。虚幻的文档在这里：[https://docs.unrealengine.com/en-us/Gameplay/Networking](https://docs.unrealengine.com/en-us/Gameplay/Networking)，根据你在这里学到的知识，花些时间研究它的Multiplayer
    Shootout项目是非常值得的。
- en: Summary
  id: totrans-443
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter involved a bit more theory than other chapters have, and it's entirely
    fine if a good chunk of it is still sinking in.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章涉及的理论比其他章节多一些，如果其中的大部分内容仍然需要时间消化，那完全没关系。
- en: In this chapter, we talked a fair bit about Unreal's client-server architecture,
    and which objects live in which domains. It's important to get a good working
    knowledge of this structure in place. We also learned a bit about how information
    and events move between machines via replication and remote procedure calls.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们谈到了虚幻的客户端-服务器架构，以及哪些对象存在于哪些域中。了解这个结构是非常重要的。我们还学习了一些关于信息和事件如何通过复制和远程过程调用在机器之间传递的知识。
- en: It's our hope that this chapter has given you a good foundation on which to
    stand as you dig into networking and really explore how it works. Be patient with
    yourself and take time to experiment.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这一章为你提供了一个良好的基础，让你在网络方面深入研究并真正探索它的工作原理。对自己有耐心，花时间去实验。
- en: We've now reached the point where we've covered a huge range of things you need
    to know to develop VR using Unreal Engine. Next, we're going to take a look at
    a few tools and plugins that can greatly accelerate your work in VR. With what
    you've learned so far in this book, you should be ready to dig through them and
    understand how they can help you develop and save you substantial amounts of time.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经达到了一个点，我们已经涵盖了许多你需要了解的内容，以使用虚幻引擎开发VR。接下来，我们将看一些工具和插件，可以大大加快你在VR中的工作。通过你在本书中学到的知识，你应该已经准备好去研究它们，并理解它们如何帮助你开发并节省大量时间。
