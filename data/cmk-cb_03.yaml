- en: Detecting the Environment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测环境
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Discovering the operating system
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现操作系统
- en: Dealing with platform-dependent source code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理依赖于平台的源代码
- en: Dealing with compiler-dependent source code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理依赖于编译器的源代码
- en: Discovering the host processor architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现主机处理器架构
- en: Discovering the host processor instruction set
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现主机处理器指令集
- en: Enabling vectorization for the Eigen library
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Eigen库启用矢量化
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: Although CMake is cross-platform and in our projects we strive for the source
    code to be portable across platforms, operating systems, and compilers, sometimes
    the source code is not fully portable; for example, when using vendor-dependent
    extensions, we may find it necessary to configure and/or build code slightly differently
    depending on the platform. This is particularly relevant for legacy code or when
    cross-compiling, a topic we will return to in [Chapter 13](ea785243-b9e8-4993-ac0d-1038f181b496.xhtml),
    *Alternative Generators and Cross-compilation*. It can also be advantageous to
    know the processor instruction set to optimize performance for a specific target
    platform. This chapter presents recipes to detect such environments and provides
    recommendations for how to implement such solutions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管CMake是跨平台的，在我们的项目中我们努力使源代码能够在不同平台、操作系统和编译器之间移植，但有时源代码并不完全可移植；例如，当使用依赖于供应商的扩展时，我们可能会发现有必要根据平台以略有不同的方式配置和/或构建代码。这对于遗留代码或交叉编译尤其相关，我们将在[第13章](ea785243-b9e8-4993-ac0d-1038f181b496.xhtml)，*替代生成器和交叉编译*中回到这个话题。了解处理器指令集以针对特定目标平台优化性能也是有利的。本章提供了检测此类环境的食谱，并提供了如何实施此类解决方案的建议。
- en: Discovering the operating system
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现操作系统
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-01](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-01).
    The recipe is valid with CMake version 3.5 (and higher) and has been tested on
    GNU/Linux, macOS, and Windows.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-01](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-01)找到。该食谱适用于CMake版本3.5（及以上），并在GNU/Linux、macOS和Windows上进行了测试。
- en: CMake is a set of cross-platform tools. Nevertheless, it can be very useful
    to know on which operating system (OS) the configuration or build step is executed.
    Such OS discovery can be used either to tweak CMake code for a particular OS,
    to enable conditional compilation depending on the OS, or to use compiler-specific
    extensions if available or necessary. In this recipe, we will demonstrate how
    to use CMake to detect the OS with an example that does not require compilation
    of any source code. For simplicity, we will only consider the configuration step.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管CMake是一套跨平台的工具，但了解配置或构建步骤在哪个操作系统（OS）上执行仍然非常有用。这种操作系统检测可以用来调整CMake代码以适应特定的操作系统，根据操作系统启用条件编译，或者在可用或必要时使用编译器特定的扩展。在本食谱中，我们将展示如何使用CMake来检测操作系统，并通过一个不需要编译任何源代码的示例来说明。为了简单起见，我们只考虑配置步骤。
- en: How to do it
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'We will demonstrate OS discovery with a very simple `CMakeLists.txt`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个非常简单的`CMakeLists.txt`来演示操作系统检测：
- en: 'We first define the minimum CMake version and project name. Note that our language
    requirement is `NONE`:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义最小CMake版本和项目名称。请注意，我们的语言要求是`NONE`：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then we wish to print a custom message depending on the detected OS:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们希望根据检测到的操作系统打印一条自定义消息：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Before testing it out, first examine the preceding code block and consider what
    behavior you expect on your system.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试之前，首先检查前面的代码块，并考虑你期望在你的系统上看到的行为。
- en: 'Now we are ready to test it out and configure the project:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备测试并配置项目：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Of the CMake output, one line is interesting here – on a Linux system, this
    is the line of interest (on other systems, the output will hopefully be different):'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在CMake的输出中，有一行在这里很有趣——在Linux系统上，这是感兴趣的行（在其他系统上，输出可能会有所不同）：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: CMake correctly defines `CMAKE_SYSTEM_NAME` for the target OS and therefore
    there is typically no need to use custom commands, tools, or scripts to query
    this information. The value of this variable can then be used to implement OS-specific
    conditionals and workarounds. On systems that have the `uname` command, this variable
    is set to the output of `uname -s`. The variable is set to "Darwin" on macOS.
    On Linux and Windows, it evaluates to "Linux" and "Windows", respectively. We
    now know how to execute a specific CMake code on a certain OS if we need to. Of
    course, we should try to minimize such customization in order to simplify migration
    to new platforms.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: CMake正确地为目标操作系统定义了`CMAKE_SYSTEM_NAME`，因此通常不需要使用自定义命令、工具或脚本来查询此信息。该变量的值随后可用于实现操作系统特定的条件和解决方法。在具有`uname`命令的系统上，该变量设置为`uname
    -s`的输出。在macOS上，该变量设置为"Darwin"。在Linux和Windows上，它分别评估为"Linux"和"Windows"。现在我们知道，如果我们需要在特定操作系统上执行特定的CMake代码，该如何操作。当然，我们应该尽量减少这种定制，以便简化迁移到新平台的过程。
- en: To minimize trouble when moving from one platform to another, you should avoid
    using Shell commands directly and also avoid explicit path delimiters (forward
    slashes on Linux and macOS and backward slashes on Windows). Only use forward
    slashes in CMake code as path delimiters and CMake will automatically translate
    them for the OS environment in question.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在从一个平台迁移到另一个平台时尽量减少麻烦，应避免直接使用Shell命令，并避免使用显式的路径分隔符（Linux和macOS上的正斜杠和Windows上的反斜杠）。在CMake代码中只使用正斜杠作为路径分隔符，CMake会自动为所涉及的操作系统环境进行转换。
- en: Dealing with platform-dependent source code
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理平台依赖的源代码
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-02](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-02)
    and has a C++ example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-02](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-02)找到，并包含一个C++示例。该食谱适用于CMake版本3.5（及以上），并在GNU/Linux、macOS和Windows上进行了测试。
- en: Ideally, we should avoid platform-dependent source code, but sometimes we have
    no choice – particularly when we are given code to configure and compile that
    we have not written ourselves. In this recipe, we will demonstrate how to use
    CMake to conditionally compile source code depending on the OS.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们应该避免平台依赖的源代码，但有时我们别无选择——尤其是当我们被给予需要配置和编译的代码时，而这些代码并非我们自己编写的。在本食谱中，我们将演示如何使用CMake根据操作系统有条件地编译源代码。
- en: Getting ready
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this example, we will modify the `hello-world.cpp` example code from [Chapter
    1](037080e9-3b67-421a-b6ec-71b1e51dbe42.xhtml), *From a Simple Executable to Libraries*,
    Recipe 1, *Compiling a single source file into an executable*:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将修改来自[第1章](037080e9-3b67-421a-b6ec-71b1e51dbe42.xhtml)，*从简单可执行文件到库*，食谱1，*将单个源文件编译成可执行文件*的`hello-world.cpp`示例代码：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How to do it
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Let us build a corresponding `CMakeLists.txt` instance, which will enable us
    to conditionally compile the source code based on the target OS:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个对应的`CMakeLists.txt`实例，这将使我们能够根据目标操作系统有条件地编译源代码：
- en: 'We first set the minimum CMake version, project name, and supported language:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先设置最小CMake版本、项目名称和支持的语言：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then we define the executable and its corresponding source file:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义可执行文件及其对应的源文件：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then we let the preprocessor know the system name by defining the following
    target compile definitions:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们通过定义以下目标编译定义来让预处理器知道系统名称：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Before continuing, first examine the preceding expressions and consider what
    behavior you expect on your system.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，先检查前面的表达式并考虑在你的系统上你期望的行为。
- en: 'Now we are ready to test it out and to configure the project:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备测试并配置项目：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: On a Windows system, you will see `Hello from Windows!`; other operating systems
    will yield different outputs.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows系统上，你会看到`Hello from Windows!`；其他操作系统将产生不同的输出。
- en: How it works
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'The interesting part in the `hello-world.cpp` example is the conditional compilation
    based on the preprocessor definitions `IS_WINDOWS`, `IS_LINUX`, or `IS_MACOS`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在`hello-world.cpp`示例中，有趣的部分是基于预处理器定义`IS_WINDOWS`、`IS_LINUX`或`IS_MACOS`的条件编译：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These definitions are defined at configure time by CMake in `CMakeLists.txt` by
    using `target_compile_definitions` before being passed on to the preprocessor.
    We could have achieved a more compact expression without repeating `if-endif` statements
    and we will demonstrate this refactoring in the next recipe. We could also have
    joined the `if-endif` statements into one `if-elseif-elseif-endif` statement.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义在配置时由CMake在`CMakeLists.txt`中使用`target_compile_definitions`定义，然后传递给预处理器。我们可以实现一个更紧凑的表达式，而不重复`if-endif`语句，我们将在下一个食谱中演示这种重构。我们还可以将`if-endif`语句合并为一个`if-elseif-elseif-endif`语句。
- en: 'At this stage, we should point out that we could have set the definitions using `add_definitions(-DIS_LINUX)`
    (of course, adjusting the definition according to the platform in question) instead
    of using `target_compile_definitions`. The disadvantage of using `add_definitions`
    is that it modifies compile definitions for the entire project, whereas `target_compile_definitions`
    gives us the possibility to restrict both the scope of the definitions to a specific
    target, as well as to restrict visibility of these definitions by using the `PRIVATE`,
    `PUBLIC`, or `INTERFACE` qualifiers. These qualifiers have the same meaning they
    had for compiler flags, as we have seen already in [Chapter 1](037080e9-3b67-421a-b6ec-71b1e51dbe42.xhtml),
    *From a Simple Executable to Libraries,* Recipe 8, *Controlling compiler flags*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们应该指出，我们可以使用`add_definitions(-DIS_LINUX)`（当然，根据所讨论的平台调整定义）而不是使用`target_compile_definitions`来设置定义。使用`add_definitions`的缺点是它修改了整个项目的编译定义，而`target_compile_definitions`给了我们限制定义范围到特定目标的可能性，以及通过使用`PRIVATE`、`PUBLIC`或`INTERFACE`限定符限制这些定义的可见性。这些限定符具有与编译器标志相同的含义，正如我们在[第一章](037080e9-3b67-421a-b6ec-71b1e51dbe42.xhtml)，*从简单的可执行文件到库*，第8个食谱，*控制编译器标志*中已经看到的：
- en: With the `PRIVATE` qualifier, compile definitions will only be applied to the
    given target and not by other targets consuming it.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`PRIVATE`限定符，编译定义将仅应用于给定目标，而不会被其他消费目标应用。
- en: With the `INTERFACE` qualifier, compile definitions on a given target will only
    be applied to targets consuming it.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`INTERFACE`限定符，编译定义将仅应用于消费该定义的目标。
- en: With the `PUBLIC` qualifier, compile definitions will be applied to the given
    target and all other targets consuming it.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`PUBLIC`限定符，编译定义将应用于给定目标以及所有其他消费目标。
- en: Minimize platform-dependent source code in your project to make porting easier.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量减少项目中依赖于平台的源代码，以便更容易移植。
- en: Dealing with compiler-dependent source code
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理依赖于编译器的源代码
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-03](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-03)
    and has a C++ and a Fortran example. The recipe is valid with CMake version 3.5
    (and higher) and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-03](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-03)找到，并包含C++和Fortran示例。本食谱适用于CMake版本3.5（及更高版本），并在GNU/Linux、macOS和Windows上进行了测试。
- en: 'This recipe is similar to the previous one in the sense that we will use CMake
    to accommodate the compilation of conditional source code that is dependent on
    the environment: in this case, it will be dependent on the chosen compiler. Again,
    for the sake of portability, this is a situation that we try to avoid when writing
    new code, but it is also a situation that we are almost guaranteed to meet sooner
    or later, especially when using legacy code or when dealing with compiler-dependent
    tooling, such as sanitizers. From the recipes of this and the previous chapter,
    we have all the ingredients to achieve this. Nevertheless, it will be useful to
    discuss the problem of dealing with compiler-dependent source code since we will
    have the chance to introduce some new aspects of CMake.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱与前一个食谱类似，因为我们使用CMake来适应依赖于环境的条件源代码的编译：在这种情况下，它将依赖于所选的编译器。同样，为了便携性，这是我们在编写新代码时尽量避免的情况，但这也是我们几乎肯定会在某个时候遇到的情况，尤其是在使用遗留代码或处理依赖于编译器的工具（如sanitizers）时。从本章和前一章的食谱中，我们已经具备了实现这一点的所有要素。尽管如此，讨论处理依赖于编译器的源代码的问题仍然很有用，因为我们有机会介绍一些新的CMake方面。
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In this recipe, we will start out with an example in C++, and later we will
    demonstrate a Fortran example and attempt to refactor and simplify the CMake code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将从C++示例开始，稍后我们将展示一个Fortran示例，并尝试重构和简化CMake代码。
- en: 'Let us consider the following `hello-world.cpp` source code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下`hello-world.cpp`源代码：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will also use a corresponding Fortran example (`hello-world.F90`):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用相应的Fortran示例（`hello-world.F90`）：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How to do it
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: 'We shall start out with the C++ example before moving on to the Fortran example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在转向Fortran示例之前从C++示例开始：
- en: 'In the `CMakeLists.txt` file, we define the now familiar minimum version, project
    name, and supported language:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CMakeLists.txt`文件中，我们定义了现在熟悉的最低版本、项目名称和支持的语言：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We then define the executable target and its corresponding source file:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义可执行目标及其对应的源文件：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then we let the preprocessor know about the compiler name and vendor by defining
    the following target compile definitions:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们通过定义以下目标编译定义，让预处理器了解编译器名称和供应商：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The previous recipes have trained our eyes and now we can already anticipate
    the result:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的配方已经训练了我们的眼睛，现在我们甚至可以预见到结果：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you use a different compiler vendor, then this example code will provide
    a different greeting.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是不同的编译器供应商，那么此示例代码将提供不同的问候。
- en: The `if` statements in the `CMakeLists.txt` file in the preceding example and
    the previous recipe seem repetitive, and as programmers, we do not like to repeat
    ourselves. Can we express this more compactly? Indeed we can! For this, let us
    turn to the Fortran example.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例和之前的配方中的`CMakeLists.txt`文件中的`if`语句似乎是重复的，作为程序员，我们不喜欢重复自己。我们能更简洁地表达这一点吗？确实可以！为此，让我们转向Fortran示例。
- en: 'In the `CMakeLists.txt` file of the Fortran example, we need to do the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在Fortran示例的`CMakeLists.txt`文件中，我们需要执行以下操作：
- en: 'We need to adapt the language to Fortran:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将语言调整为Fortran：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then we define the executable and its corresponding source file; in this case,
    with an uppercase `.F90` suffix:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义可执行文件及其对应的源文件；在这种情况下，使用大写的`.F90`后缀：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then we let the preprocessor know very compactly about the compiler vendor
    by defining the following target compile definition:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们通过定义以下目标编译定义，让预处理器非常简洁地了解编译器供应商：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The remaining behavior of the Fortran example is the same as in the C++ example.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的Fortran示例行为与C++示例相同。
- en: How it works
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: The preprocessor definitions are defined at configure time by CMake in `CMakeLists.txt`
    and are passed on to the preprocessor. The Fortran example contains a very compact
    expression where we use the `CMAKE_Fortran_COMPILER_ID` variable to construct
    the preprocessor definition using `target_compile_definitions`. To accommodate
    this, we had to change the case of "Intel" from `IS_INTEL_CXX_COMPILER` to `IS_Intel_FORTRAN_COMPILER`.
    We could achieve the same for C or C++ by using the corresponding `CMAKE_C_COMPILER_ID` and
    `CMAKE_CXX_COMPILER_ID` variables. Please do note, however, that `CMAKE_<LANG>_COMPILER_ID`
    *is not guaranteed* to be defined for all compilers or languages.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理器定义是在配置时由CMake在`CMakeLists.txt`中定义的，并传递给预处理器。Fortran示例包含一个非常紧凑的表达式，我们使用`CMAKE_Fortran_COMPILER_ID`变量来构造预处理器定义，使用`target_compile_definitions`。为了适应这一点，我们不得不将“Intel”的案例从`IS_INTEL_CXX_COMPILER`更改为`IS_Intel_FORTRAN_COMPILER`。我们可以通过使用相应的`CMAKE_C_COMPILER_ID`和`CMAKE_CXX_COMPILER_ID`变量为C或C++实现相同的效果。但是请注意，`CMAKE_<LANG>_COMPILER_ID`*并不保证*为所有编译器或语言定义。
- en: Use the `.F90` suffix for Fortran code that is supposed to be preprocessed and
    use the `.f90` suffix for code that is not to be preprocessed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于应该被预处理的Fortran代码，使用`.F90`后缀，对于不应该被预处理的代码，使用`.f90`后缀。
- en: Discovering the host processor architecture
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索主机处理器架构
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-04](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-04)
    and has a C++ example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-04](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-04)获取，并包含一个C++示例。该配方适用于CMake版本3.5（及更高版本），并在GNU/Linux、macOS和Windows上进行了测试。
- en: The advent of 64-bit integer arithmetic in 1970s supercomputing and 64-bit addressing
    in the early 2000s for personal computers has widened the memory-addressing range,
    and significant resources have been invested into porting code that was hardcoded
    for 32-bit architectures to enable 64-bit addressing. A number of blog posts,
    such as [https://www.viva64.com/en/a/0004/](https://www.viva64.com/en/a/0004/),
    are devoted to discussing typical issues and solutions in porting C++ code to
    64-bit platforms. It is very much advisable to program in a way that avoids explicitly
    hardcoded limits, but you may be in a situation where you need to accommodate hardcoded
    limits in a code configured with CMake, and in this recipe, we wish to discuss
    options for detecting the host processor architecture.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 20世纪70年代超级计算中64位整数运算的出现以及21世纪初个人计算机中64位寻址的出现扩大了内存寻址范围，并且投入了大量资源将硬编码为32位架构的代码移植到支持64位寻址。许多博客文章，例如[https://www.viva64.com/en/a/0004/](https://www.viva64.com/en/a/0004/)，都致力于讨论在将C++代码移植到64位平台时遇到的典型问题和解决方案。非常建议以避免明确硬编码限制的方式编程，但您可能处于需要容纳硬编码限制的代码配置与CMake的情况，在本菜谱中，我们希望讨论检测宿主处理器架构的选项。
- en: Getting ready
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will use the following `arch-dependent.cpp` example source:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下`arch-dependent.cpp`示例源代码：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How to do it
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Now let us turn to the CMake side. In the `CMakeLists.txt` file, we need to
    apply the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转向CMake方面。在`CMakeLists.txt`文件中，我们需要应用以下内容：
- en: 'We first define the executable and its source file dependency:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义可执行文件及其源文件依赖项：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We check for the size of the `void` pointer type. This is defined in the `CMAKE_SIZEOF_VOID_P`
    CMake variable and will tell us whether the CPU is 32 or 64 bits. We let the user
    know about the detected size with a status message and set a preprocessor definition:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查`void`指针类型的大小。这在`CMAKE_SIZEOF_VOID_P` CMake变量中定义，并将告诉我们CPU是32位还是64位。我们通过状态消息让用户知道检测到的大小，并设置一个预处理器定义：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then we let the preprocessor know about the host processor architecture by
    defining the following target compile definitions, at the same time printing status
    messages during configuration:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们通过定义以下目标编译定义让预处理器知道宿主处理器架构，同时在配置期间打印状态消息：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We configure the project and note the status message (the precise message may
    of course change):'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们配置项目并记录状态消息（当然，确切的消息可能会发生变化）：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we build and execute the code (the actual output will depend on the
    host processor architecture):'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们构建并执行代码（实际输出将取决于宿主处理器架构）：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: CMake defines the `CMAKE_HOST_SYSTEM_PROCESSOR` variable to contain the name
    of the processor it is currently running on. This can be set to "i386", "i686",
    "x86_64", "AMD64", and such like, depending, of course, on the CPU at hand. `CMAKE_SIZEOF_VOID_P`
    is defined to hold the size of a pointer to the `void` type. We can query both
    at the CMake level in order to modify targets or target compile definitions. Using
    preprocessor definitions, we can branch source code compilation based on the detected
    host processor architecture. As discussed in previous recipes, such customization
    should be avoided when writing new code, but sometimes it is useful when working
    with legacy code or when cross-compiling, which is the subject of [Chapter 13](ea785243-b9e8-4993-ac0d-1038f181b496.xhtml),
    *Alternative Generators and Cross-compilation*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: CMake定义了`CMAKE_HOST_SYSTEM_PROCESSOR`变量，其中包含当前正在运行的处理器的名称。这可以设置为“i386”、“i686”、“x86_64”、“AMD64”等，当然，这取决于当前的CPU。`CMAKE_SIZEOF_VOID_P`被定义为持有指向`void`类型的指针的大小。我们可以在CMake级别查询这两个变量，以便修改目标或目标编译定义。使用预处理器定义，我们可以根据检测到的宿主处理器架构分支源代码编译。正如在前面的菜谱中讨论的那样，在编写新代码时应避免这种定制，但在处理遗留代码或进行交叉编译时，有时是有用的，这是[第13章](ea785243-b9e8-4993-ac0d-1038f181b496.xhtml)，*替代生成器和交叉编译*的主题。
- en: Using `CMAKE_SIZEOF_VOID_P` is the only truly portable way of checking whether
    the CPU at hand has a 32- or 64-bit architecture.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`CMAKE_SIZEOF_VOID_P`是检查当前CPU是32位还是64位架构的唯一真正可移植的方法。
- en: There is more
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容
- en: In addition to `CMAKE_HOST_SYSTEM_PROCESSOR`, CMake also defines the `CMAKE_SYSTEM_PROCESSOR`
    variable. Whereas the former contains the name of the CPU CMake is **currently
    running on**, the latter will contain the name of the CPU we are **currently building
    for**. This is a subtle difference that plays a very fundamental role when cross-compiling.
    We will see more about cross-compilation in [Chapter 13](ea785243-b9e8-4993-ac0d-1038f181b496.xhtml),
    *Alternative Generators and Cross-compilation*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`CMAKE_HOST_SYSTEM_PROCESSOR`，CMake还定义了`CMAKE_SYSTEM_PROCESSOR`变量。前者包含CMake**当前正在运行**的CPU的名称，后者将包含我们**当前正在构建**的CPU的名称。这是一个微妙的区别，在交叉编译时起着非常基本的作用。我们将在[第13章](ea785243-b9e8-4993-ac0d-1038f181b496.xhtml)，*替代生成器和交叉编译*中了解更多关于交叉编译的信息。
- en: 'An alternative to letting CMake detect the host processor architecture is to
    use symbols defined within C or C++ and use CMake''s `try_run` function to build
    and attempt to execute the source code (see [Chapter 5](9612acc1-56f6-4158-a55f-9a9db3714759.xhtml), *Configure-time
    and Build-time Operations,* Recipe 8, *Probing execution*) that is branched by
    the preprocessor symbols. This returns well-defined errors that can be caught
    on the CMake side (this strategy is inspired by [https://github.com/axr/solar-cmake/blob/master/TargetArch.cmake](https://github.com/axr/solar-cmake/blob/master/TargetArch.cmake)):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让CMake检测主机处理器架构的替代方法是使用C或C++中定义的符号，并使用CMake的`try_run`函数来构建并尝试执行源代码（参见[第5章](9612acc1-56f6-4158-a55f-9a9db3714759.xhtml)，*配置时间和构建时间操作*，第8个配方，*探测执行*），该操作由预处理器符号分支。这会返回可以在CMake侧捕获的定义良好的错误（此策略的灵感来自[https://github.com/axr/solar-cmake/blob/master/TargetArch.cmake](https://github.com/axr/solar-cmake/blob/master/TargetArch.cmake)）：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This strategy is also the recommended one for detecting the target processor
    architecture, where CMake does not seem to offer a portable intrinsic solution.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此策略也是检测目标处理器架构的首选方法，其中CMake似乎没有提供便携式内置解决方案。
- en: 'Yet another alternative exists. It will only use CMake, doing away entirely
    with the preprocessor, at the expense of having a different source file for each
    case, which would then be set as the source file for the executable target `arch-dependent`
    using the `target_sources` CMake command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 还存在另一种替代方案。它将仅使用CMake，完全摆脱预处理器，代价是每个情况都有一个不同的源文件，然后使用`target_sources` CMake命令将其设置为可执行目标`arch-dependent`的源文件：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This approach will clearly require more work for an existing project, since
    the source files will need to be separated. Moreover, code duplication between
    the different source files might certainly become a problem.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法显然需要对现有项目进行更多工作，因为源文件需要分开。此外，不同源文件之间的代码重复可能确实成为一个问题。
- en: Discovering the host processor instruction set
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现主机处理器指令集
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-05](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-05)
    and has a C++ example. The recipe is valid with CMake version 3.10 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-05](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-05)获取，并包含一个C++示例。该配方适用于CMake版本3.10（及更高版本），并在GNU/Linux、macOS和Windows上进行了测试。
- en: In this recipe, we will discuss how to discover the host processor instruction
    set with the help of CMake. This functionality has been added to CMake relatively
    recently and requires CMake 3.10 or later. The detected host system information
    can be used to either set corresponding compiler flags or to implement optional
    compilation of sources or source code generation depending on the host system.
    In this recipe, our goal will be to detect the host system information, pass it
    to the C++ source code using preprocessor definitions, and print the information
    to the output.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将讨论如何借助CMake发现主机处理器指令集。此功能相对较新地添加到CMake中，并需要CMake 3.10或更高版本。检测到的主机系统信息可用于设置相应的编译器标志，或根据主机系统实现可选的源代码编译或源代码生成。在本配方中，我们的目标是检测主机系统信息，使用预处理器定义将其传递给C++源代码，并将信息打印到输出。
- en: Getting ready
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Our example C++ source file (`processor-info.cpp`) consists of the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例C++源文件（`processor-info.cpp`）包含以下内容：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This file includes `config.h`, which we will generate from `config.h.in`, given
    here:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件包含`config.h`，我们将从`config.h.in`生成，如下所示：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How to do it
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: 'We will use CMake to fill the definitions in `config.h` with sensible values
    for our platform and to compile our sample source file into an executable:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用CMake来填充`config.h`中对我们平台有意义的定义，并将我们的示例源文件编译成可执行文件：
- en: 'First, we define the minimum CMake version, project name, and project language:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义最小CMake版本、项目名称和项目语言：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We then define the target executable, its source file, and include directories:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义目标可执行文件、其源文件和包含目录：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We then go on to query the host system information for a number of keys:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们继续查询主机系统信息的一系列键：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Having defined the corresponding variables, we configure `config.h`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义了相应的变量后，我们配置`config.h`：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now we are ready to configure, build, and test the project:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备好配置、构建和测试项目了：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The output will of course vary depending on the processor.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出当然会根据处理器而变化。
- en: How it works
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: The `foreach` loop in `CMakeLists.txt` queries values for a number of keys and
    defines corresponding variables. The core function of this recipe is `cmake_host_system_information`,
    which queries system information of the host system on which CMake runs. This
    function can be invoked with multiple keys in one function call, but in this case,
    we have used one function call per key. We then use these variables to configure
    the placeholders in `config.h.in` and generate `config.h` . This configuration
    is done with the `configure_file` command. Finally, `config.h` is included in
    `processor-info.cpp`, and once compiled, it will print the values to the screen.
    We will revisit this approach in [Chapter 5](9612acc1-56f6-4158-a55f-9a9db3714759.xhtml), *Configure-time
    and Build-time Operations*, and [Chapter 6](48392b14-6669-412e-909a-3185624a7ff2.xhtml),
    *Generating Source Code*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CMakeLists.txt`中的`foreach`循环查询多个键的值，并定义相应的变量。本食谱的核心功能是`cmake_host_system_information`，它查询CMake运行所在的主机系统的系统信息。此函数可以一次调用多个键，但在这种情况下，我们为每个键使用一次函数调用。然后，我们使用这些变量来配置`config.h.in`中的占位符，并生成`config.h`。此配置是通过`configure_file`命令完成的。最后，`config.h`被包含在`processor-info.cpp`中，一旦编译，它将打印值到屏幕上。我们将在[第5章](9612acc1-56f6-4158-a55f-9a9db3714759.xhtml)，*配置时间和构建时间操作*，和[第6章](48392b14-6669-412e-909a-3185624a7ff2.xhtml)，*生成源代码*中重新审视这种方法。
- en: There is more
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: For a more fine-grained processor instruction set detection, consider this module: [https://github.com/VcDevel/Vc/blob/master/cmake/OptimizeForArchitecture.cmake](https://github.com/VcDevel/Vc/blob/master/cmake/OptimizeForArchitecture.cmake).
    We would also like to note that, sometimes, the host building the code may not
    be the same as the host running the code. This is often the case on compute clusters
    where the login node architecture may differ from the architecture found on compute
    nodes. One way to solve this is to submit the configuration and compilation as
    a computation step and deploy it to the compute nodes.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更精细的处理器指令集检测，请考虑使用此模块：[https://github.com/VcDevel/Vc/blob/master/cmake/OptimizeForArchitecture.cmake](https://github.com/VcDevel/Vc/blob/master/cmake/OptimizeForArchitecture.cmake)。我们还想指出，有时构建代码的主机可能与运行代码的主机不同。这在计算集群中很常见，登录节点的架构可能与计算节点的架构不同。解决此问题的一种方法是提交配置和编译作为计算步骤，并将其部署到计算节点。
- en: We have not used all keys available in `cmake_host_system_information`. For
    this, please consult [https://cmake.org/cmake/help/latest/command/cmake_host_system_information.html](https://cmake.org/cmake/help/latest/command/cmake_host_system_information.html).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有使用`cmake_host_system_information`中的所有可用键。为此，请参考[https://cmake.org/cmake/help/latest/command/cmake_host_system_information.html](https://cmake.org/cmake/help/latest/command/cmake_host_system_information.html)。
- en: Enabling vectorization for the Eigen library
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Eigen库启用矢量化
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-06](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-06)
    and has a C++ example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-06](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-06)找到，并包含一个C++示例。该食谱适用于CMake版本3.5（及更高版本），并在GNU/Linux、macOS和Windows上进行了测试。
- en: The vector capabilities of modern processor architectures can dramatically enhance
    the performance of your code. This is particularly the case for certain classes
    of operations, and linear algebra is foremost among these. This recipe will show
    how to enable vectorization to speed up a simple executable using the Eigen C++
    library for linear algebra.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现代处理器架构的向量能力可以显著提高代码的性能。对于某些类型的操作，这一点尤其明显，而线性代数是其中最突出的。本食谱将展示如何启用向量化以加速使用Eigen
    C++库进行线性代数的简单可执行文件。
- en: Getting ready
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We will use the Eigen C++ template library for linear algebra and show how
    to set up compiler flags to enable vectorization. The source code for this recipe
    the `linear-algebra.cpp` file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Eigen C++模板库进行线性代数运算，并展示如何设置编译器标志以启用向量化。本食谱的源代码是`linear-algebra.cpp`文件：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We expect vectorization to speed up the execution of the dot product operation
    in `simple_function`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望向量化能够加速`simple_function`中点积操作的执行。
- en: How to do it
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'According to the documentation of the Eigen library, it is sufficient to set
    the appropriate compiler flag to enable the generation of vectorized code. Let
    us look at `CMakeLists.txt`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Eigen库的文档，只需设置适当的编译器标志即可启用向量化代码的生成。让我们看看`CMakeLists.txt`：
- en: 'We declare a C++11 project:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明一个C++11项目：
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Since we wish to use the Eigen library, we need to find its header files on
    the system:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们希望使用Eigen库，因此我们需要在系统上找到其头文件：
- en: '[PRE37]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We include the `CheckCXXCompilerFlag.cmake` standard module file:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们包含`CheckCXXCompilerFlag.cmake`标准模块文件：
- en: '[PRE38]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We check that the `-march=native` compiler flag works:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查`-march=native`编译器标志是否有效：
- en: '[PRE39]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The alternative `-xHost` compiler flag is also checked:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还检查了替代的`-xHost`编译器标志：
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We set an empty variable, `_CXX_FLAGS`, to hold the one compiler flag that
    was found to work among the two we just checked. If we see `_march_native_works`,
    we set`_CXX_FLAGS` to `-march=native`. If we see `_xhost_works`, we set`_CXX_FLAGS`
    to `-xHost`. If none of them worked, we will leave `_CXX_FLAGS` empty and vectorization
    will be disabled:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置一个空变量`_CXX_FLAGS`，以保存我们刚刚检查的两个标志中找到的一个有效标志。如果我们看到`_march_native_works`，我们将`_CXX_FLAGS`设置为`-march=native`。如果我们看到`_xhost_works`，我们将`_CXX_FLAGS`设置为`-xHost`。如果两者都不起作用，我们将保持`_CXX_FLAGS`为空，向量化将被禁用：
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'For comparison, we also define an executable target for the unoptimized version
    where we do not use the preceding optimization flags:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了进行比较，我们还为未优化的版本定义了一个可执行目标，其中我们不使用前面的优化标志：
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In addition, we define an optimized version:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们还定义了一个优化版本：
- en: '[PRE43]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let us compare the two executables—first we configure (in this case, `-march=native_works`):'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们比较这两个可执行文件——首先我们进行配置（在这种情况下，`-march=native_works`）：
- en: '[PRE44]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, let us compile and compare timings:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们编译并比较时间：
- en: '[PRE46]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'Most modern processors provide vector instruction sets. Carefully crafted code
    can exploit these and achieve enhanced performance with respect to non-vectorized
    code. The Eigen library has been written with vectorization explicitly in mind
    since linear algebra operations can greatly benefit from it. All we need to do
    is instruct the compiler to inspect the processor for us and generate the native
    set of instructions for the current architecture. Different compiler vendors use
    different flags to achieve this: the GNU compiler implements this by means of
    the `-march=native` flag, whereas the Intel compiler uses the `-xHost` flag. We
    then use the `check_cxx_compiler_flag` function offered by the `CheckCXXCompilerFlag.cmake`
    module:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代处理器提供向量指令集。精心编写的代码可以利用这些指令集，并在与非向量化代码相比时实现增强的性能。Eigen库在编写时就明确考虑了向量化，因为线性代数操作可以从中大大受益。我们所需要做的就是指示编译器为我们检查处理器，并为当前架构生成原生指令集。不同的编译器供应商使用不同的标志来实现这一点：GNU编译器通过`-march=native`标志实现这一点，而Intel编译器使用`-xHost`标志。然后我们使用`CheckCXXCompilerFlag.cmake`模块提供的`check_cxx_compiler_flag`函数：
- en: '[PRE47]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This function accepts two arguments: the first one is the compiler flag to
    check, the second is a variable for storing the result, `true` or `false`, of
    the check. If the check is positive, we add the working flag to the `_CXX_FLAGS`
    variable, which will then be used to set the compiler flags for our executable
    target.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受两个参数：第一个是要检查的编译器标志，第二个是用于存储检查结果的变量，即`true`或`false`。如果检查结果为正，我们将工作标志添加到`_CXX_FLAGS`变量中，然后该变量将用于设置我们可执行目标的编译器标志。
- en: There is more
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: This recipe could be combined with the previous recipe; processor capabilities
    could be queried using `cmake_host_system_information`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方可以与之前的配方结合使用；可以使用`cmake_host_system_information`查询处理器能力。
