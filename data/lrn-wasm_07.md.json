["```cpp\n// Create a new directory and cd into it:\nmkdir cook-the-books\ncd cook-the-books\n\n// Create a package.json file with default values\nnpm init -y\n```", "```cpp\nnpm install -D browser-sync@^2.24.4\n```", "```cpp\n...\n\"scripts\": {\n ...\n \"start\": \"browser-sync start --server \\\"src\\\" --files \\\"src/**\\\" --single --no-open --port 4000\"\n},\n\u2026\n```", "```cpp\n{\n  \"name\": \"cook-the-books\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Example application for Learn WebAssembly\",\n  \"main\": \"src/index.js\",\n  \"scripts\": {\n    \"start\": \"browser-sync start --server \\\"src\\\" --files \\\"src/**\\\" --single --no-open --port 4000\",\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [],\n  \"author\": \"Mike Rourke\",\n  \"license\": \"MIT\",\n  \"devDependencies\": {\n    \"browser-sync\": \"^2.24.4\"\n  }\n}\n```", "```cpp\n\"args\": [\n  \"${workspaceFolder}/lib/main.c\",\n  \"-Os\",\n  \"-s\", \"WASM=1\",\n  \"-s\", \"SIDE_MODULE=1\",\n  \"-s\", \"BINARYEN_ASYNC_COMPILATION=0\",\n  \"-o\", \"${workspaceFolder}/src/assets/main.wasm\"\n],\n```", "```cpp\n\u251c\u2500\u2500 /.vscode\n\u2502    \u251c\u2500\u2500 tasks.json\n\u2502    \u2514\u2500\u2500 c_cpp_properties.json\n\u251c\u2500\u2500 /lib\n\u251c\u2500\u2500 /src\n\u2502    \u2514\u2500\u2500 /assets\n\u2502         \u2514\u2500\u2500 memory.wasm\n\u251c\u2500\u2500 package.json\n\u2514\u2500\u2500 package-lock.json\n```", "```cpp\n#include <stdlib.h>\n\nstruct Node {\n  int id;\n  int categoryId;\n  float rawAmount;\n  float cookedAmount;\n  struct Node *next;\n  struct Node *prev;\n};\n\ntypedef enum {\n  RAW = 1,\n  COOKED = 2\n} AmountType;\n\nstruct Node *transactionsHead = NULL;\nstruct Node *categoriesHead = NULL;\n```", "```cpp\nvoid deleteNode(struct Node **headNode, struct Node *delNode) {\n    // Base case:\n    if (*headNode == NULL || delNode == NULL) return;\n\n    // If node to be deleted is head node:\n    if (*headNode == delNode) *headNode = delNode->next;\n\n    // Change next only if node to be deleted is NOT the last node:\n    if (delNode->next != NULL) delNode->next->prev = delNode->prev;\n\n    // Change prev only if node to be deleted is NOT the first node:\n    if (delNode->prev != NULL) delNode->prev->next = delNode->next;\n\n    // Finally, free the memory occupied by delNode:\n    free(delNode);\n}\n\nvoid appendNode(struct Node **headNode, int id, int categoryId,\n                float rawAmount, float cookedAmount) {\n    // 1\\. Allocate node:\n    struct Node *newNode = (struct Node *) malloc(sizeof(struct Node));\n    struct Node *last = *headNode; // Used in Step 5\n\n    // 2\\. Populate with data:\n    newNode->id = id;\n    newNode->categoryId = categoryId;\n    newNode->rawAmount = rawAmount;\n    newNode->cookedAmount = cookedAmount;\n\n    // 3\\. This new node is going to be the last node, so make next NULL:\n    newNode->next = NULL;\n\n    // 4\\. If the linked list is empty, then make the new node as head:\n    if (*headNode == NULL) {\n        newNode->prev = NULL;\n        *headNode = newNode;\n        return;\n    }\n\n    // 5\\. Otherwise, traverse till the last node:\n    while (last->next != NULL) {\n        last = last->next;\n    }\n\n    // 6\\. Change the next of last node:\n    last->next = newNode;\n\n    // 7\\. Make last node as previous of new node:\n    newNode->prev = last;\n}\n```", "```cpp\nstruct Node *findNodeById(int id, struct Node *withinNode) {\n    struct Node *node = withinNode;\n    while (node != NULL) {\n        if (node->id == id) return node;\n        node = node->next;\n    }\n    return NULL;\n}\n\nvoid addTransaction(int id, int categoryId, float rawAmount,\n                    float cookedAmount) {\n    appendNode(&transactionsHead, id, categoryId, rawAmount, cookedAmount);\n}\n\nvoid editTransaction(int id, int categoryId, float rawAmount,\n                     float cookedAmount) {\n    struct Node *foundNode = findNodeById(id, transactionsHead);\n    if (foundNode != NULL) {\n        foundNode->categoryId = categoryId;\n        foundNode->rawAmount = rawAmount;\n        foundNode->cookedAmount = cookedAmount;\n    }\n}\n\nvoid removeTransaction(int id) {\n    struct Node *foundNode = findNodeById(id, transactionsHead);\n    if (foundNode != NULL) deleteNode(&transactionsHead, foundNode);\n}\n```", "```cpp\nvoid calculateGrandTotals(float *totalRaw, float *totalCooked) {\n    struct Node *node = transactionsHead;\n    while (node != NULL) {\n        *totalRaw += node->rawAmount;\n        *totalCooked += node->cookedAmount;\n        node = node->next;\n    }\n}\n\nfloat getGrandTotalForType(AmountType type) {\n    float totalRaw = 0;\n    float totalCooked = 0;\n    calculateGrandTotals(&totalRaw, &totalCooked);\n\n    if (type == RAW) return totalRaw;\n    if (type == COOKED) return totalCooked;\n    return 0;\n}\n\nfloat getFinalBalanceForType(AmountType type, float initialBalance) {\n    float totalForType = getGrandTotalForType(type);\n    return initialBalance + totalForType;\n}\n```", "```cpp\nvoid upsertCategoryNode(int categoryId, float transactionRaw,\n                        float transactionCooked) {\n    struct Node *foundNode = findNodeById(categoryId, categoriesHead);\n    if (foundNode != NULL) {\n        foundNode->rawAmount += transactionRaw;\n        foundNode->cookedAmount += transactionCooked;\n    } else {\n        appendNode(&categoriesHead, categoryId, categoryId, transactionRaw,\n                   transactionCooked);\n    }\n}\n\nvoid buildValuesByCategoryList() {\n    struct Node *node = transactionsHead;\n    while (node != NULL) {\n        upsertCategoryNode(node->categoryId, node->rawAmount,\n                           node->cookedAmount);\n        node = node->next;\n    }\n}\n\nvoid recalculateForCategories() {\n    categoriesHead = NULL;\n    buildValuesByCategoryList();\n}\n\nfloat getCategoryTotal(AmountType type, int categoryId) {\n    // Ensure the category totals have been calculated:\n    if (categoriesHead == NULL) buildValuesByCategoryList();\n\n    struct Node *categoryNode = findNodeById(categoryId, categoriesHead);\n    if (categoryNode == NULL) return 0;\n\n    if (type == RAW) return categoryNode->rawAmount;\n    if (type == COOKED) return categoryNode->cookedAmount;\n    return 0;\n}\n```", "```cpp\nemcc lib/main.c -Os -s WASM=1 -s SIDE_MODULE=1 -s BINARYEN_ASYNC_COMPILATION=0 -o src/assets/main.wasm\n```", "```cpp\n/**\n * Returns an array of compiled (not instantiated!) Wasm modules.\n * We need the main.wasm file we created, as well as the memory.wasm file\n * that allows us to use C functions like malloc() and free().\n */\nconst fetchAndCompileModules = () =>\n  Promise.all(\n    ['../assets/main.wasm', '../assets/memory.wasm'].map(fileName =>\n      fetch(fileName)\n        .then(response => {\n          if (response.ok) return response.arrayBuffer();\n          throw new Error(`Unable to fetch WebAssembly file: ${fileName}`);\n        })\n        .then(bytes => WebAssembly.compile(bytes))\n    )\n  );\n\n/**\n * Returns an instance of the compiled \"main.wasm\" file.\n */\nconst instantiateMain = (compiledMain, memoryInstance, wasmMemory) => {\n  const memoryMethods = memoryInstance.exports;\n  return WebAssembly.instantiate(compiledMain, {\n    env: {\n      memoryBase: 0,\n      tableBase: 0,\n      memory: wasmMemory,\n      table: new WebAssembly.Table({ initial: 16, element: 'anyfunc' }),\n      abort: console.log,\n      _consoleLog: value => console.log(value),\n      _malloc: memoryMethods.malloc,\n      _free: memoryMethods.free\n    }\n  });\n};\n\n/**\n * Compiles and instantiates the \"memory.wasm\" and \"main.wasm\" files and\n * returns the `exports` property from main's `instance`.\n */\nexport default async function initializeWasm() {\n  const wasmMemory = new WebAssembly.Memory({ initial: 1024 });\n  const [compiledMain, compiledMemory] = await fetchAndCompileModules();\n\n  const memoryInstance = await WebAssembly.instantiate(compiledMemory, {\n    env: {\n      memory: wasmMemory\n    }\n  });\n\n  const mainInstance = await instantiateMain(\n    compiledMain,\n    memoryInstance,\n    wasmMemory\n  );\n\n  return mainInstance.exports;\n}\n```", "```cpp\nimport initializeWasm from './initializeWasm.js';\n\n/**\n * Class used to wrap the functionality from the Wasm module (rather\n * than access it directly from the Vue components or store).\n * @class\n */\nexport default class WasmTransactions {\n  constructor() {\n    this.instance = null;\n    this.categories = [];\n  }\n\n  async initialize() {\n    this.instance = await initializeWasm();\n    return this;\n  }\n\n  getCategoryId(category) {\n    return this.categories.indexOf(category);\n  }\n\n  // Ensures the raw and cooked amounts have the proper sign (withdrawals\n  // are negative and deposits are positive).\n  getValidAmounts(transaction) {\n    const { rawAmount, cookedAmount, type } = transaction;\n    const getAmount = amount =>\n      type === 'Withdrawal' ? -Math.abs(amount) : amount;\n    return {\n      validRaw: getAmount(rawAmount),\n      validCooked: getAmount(cookedAmount)\n    };\n  }\n\n  // Adds the specified transaction to the linked list in the Wasm module.\n  addToWasm(transaction) {\n    const { id, category } = transaction;\n    const { validRaw, validCooked } = this.getValidAmounts(transaction);\n    const categoryId = this.getCategoryId(category);\n    this.instance._addTransaction(id, categoryId, validRaw, validCooked);\n  }\n\n  // Updates the transaction node in the Wasm module:\n  editInWasm(transaction) {\n    const { id, category } = transaction;\n    const { validRaw, validCooked } = this.getValidAmounts(transaction);\n    const categoryId = this.getCategoryId(category);\n    this.instance._editTransaction(id, categoryId, validRaw, validCooked);\n  }\n\n  // Removes the transaction node from the linked list in the Wasm module:\n  removeFromWasm(transactionId) {\n    this.instance._removeTransaction(transactionId);\n  }\n\n  // Populates the linked list in the Wasm module. The categories are\n  // needed to set the categoryId in the Wasm module.\n  populateInWasm(transactions, categories) {\n    this.categories = categories;\n    transactions.forEach(transaction => this.addToWasm(transaction));\n  }\n\n  // Returns the balance for raw and cooked transactions based on the\n  // specified initial balances.\n  getCurrentBalances(initialRaw, initialCooked) {\n    const currentRaw = this.instance._getFinalBalanceForType(\n      AMOUNT_TYPE.raw,\n      initialRaw\n    );\n    const currentCooked = this.instance._getFinalBalanceForType(\n      AMOUNT_TYPE.cooked,\n      initialCooked\n    );\n    return { currentRaw, currentCooked };\n  }\n\n  // Returns an object that has category totals for all income (deposit)\n  // and expense (withdrawal) transactions.\n  getCategoryTotals() {\n    // This is done to ensure the totals reflect the most recent\n    // transactions:\n    this.instance._recalculateForCategories();\n    const categoryTotals = this.categories.map((category, idx) => ({\n      category,\n      id: idx,\n      rawTotal: this.instance._getCategoryTotal(AMOUNT_TYPE.raw, idx),\n      cookedTotal: this.instance._getCategoryTotal(AMOUNT_TYPE.cooked, idx)\n    }));\n\n    const totalsByGroup = { income: [], expenses: [] };\n    categoryTotals.forEach(categoryTotal => {\n      if (categoryTotal.rawTotal < 0) {\n        totalsByGroup.expenses.push(categoryTotal);\n      } else {\n        totalsByGroup.income.push(categoryTotal);\n      }\n    });\n    return totalsByGroup;\n  }\n}\n```", "```cpp\n// Paste your jsonstore.io endpoint here (no ending slash):\nconst API_URL = '[JSONSTORE.IO ENDPOINT]';\n\n/**\n * Wrapper for performing API calls. We don't want to call response.json()\n * each time we make a fetch call.\n * @param {string} endpoint Endpoint (e.g. \"/transactions\" to make API call to\n * @param {Object} init Fetch options object containing any custom settings\n * @returns {Promise<*>}\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch\n */\nconst performApiFetch = (endpoint = '', init = {}) =>\n  fetch(`${API_URL}${endpoint}`, {\n    headers: {\n      'Content-type': 'application/json'\n    },\n    ...init\n  }).then(response => response.json());\n\nexport const apiFetchTransactions = () =>\n  performApiFetch('/transactions').then(({ result }) =>\n    /*\n     * The response object looks like this:\n     * {\n     *   \"result\": {\n     *     \"1\": {\n     *       \"category\": \"Sales Revenue\",\n     *       ...\n     *     },\n     *     \"2\": {\n     *       \"category\": \"Hotels\",\n     *       ...\n     *     },\n     *     ...\n     *   }\n     * }\n     * We need the \"1\" and \"2\" values for deleting or editing existing\n     * records, so we store that in the transaction record as \"apiId\".\n     */\n    Object.keys(result).map(apiId => ({\n      ...result[apiId],\n      apiId\n    }))\n  );\n\nexport const apiEditTransaction = transaction =>\n  performApiFetch(`/transactions/${transaction.apiId}`, {\n    method: 'POST',\n    body: JSON.stringify(transaction)\n  });\n\nexport const apiRemoveTransaction = transaction =>\n  performApiFetch(`/transactions/${transaction.apiId}`, {\n    method: 'DELETE'\n  });\n\nexport const apiAddTransaction = transaction =>\n  performApiFetch(`/transactions/${transaction.apiId}`, {\n    method: 'POST',\n    body: JSON.stringify(transaction)\n  });\n```", "```cpp\nimport {\n  apiFetchTransactions,\n  apiAddTransaction,\n  apiEditTransaction,\n  apiRemoveTransaction\n} from './api.js';\nimport WasmTransactions from './WasmTransactions.js';\n\nexport const store = {\n  wasm: null,\n  state: {\n    transactions: [],\n    activeTransactionId: 0,\n    balances: {\n      initialRaw: 0,\n      currentRaw: 0,\n      initialCooked: 0,\n      currentCooked: 0\n    }\n  },\n  ...\n```", "```cpp\n...\n  getCategories() {\n    const categories = this.state.transactions.map(\n      ({ category }) => category\n    );\n    // Remove duplicate categories and sort the names in ascending order:\n    return _.uniq(categories).sort();\n  },\n\n  // Populate global state with the transactions from the API response:\n  populateTransactions(transactions) {\n    const sortedTransactions = _.sortBy(transactions, [\n      'transactionDate',\n      'id'\n    ]);\n    this.state.transactions = sortedTransactions;\n    store.wasm.populateInWasm(sortedTransactions, this.getCategories());\n    this.recalculateBalances();\n  },\n\n  addTransaction(newTransaction) {\n    // We need to assign a new ID to the transaction, so this just adds\n    // 1 to the current maximum transaction ID:\n    newTransaction.id = _.maxBy(this.state.transactions, 'id').id + 1;\n    store.wasm.addToWasm(newTransaction);\n    apiAddTransaction(newTransaction).then(() => {\n      this.state.transactions.push(newTransaction);\n      this.hideTransactionModal();\n    });\n  },\n\n  editTransaction(editedTransaction) {\n    store.wasm.editInWasm(editedTransaction);\n    apiEditTransaction(editedTransaction).then(() => {\n      this.state.transactions = this.state.transactions.map(\n        transaction => {\n          if (transaction.id === editedTransaction.id) {\n            return editedTransaction;\n          }\n          return transaction;\n        }\n      );\n      this.hideTransactionModal();\n    });\n  },\n\n  removeTransaction(transaction) {\n    const transactionId = transaction.id;\n    store.wasm.removeFromWasm(transactionId);\n\n    // We're passing the whole transaction record into the API call\n    // for the sake of consistency:\n    apiRemoveTransaction(transaction).then(() => {\n      this.state.transactions = this.state.transactions.filter(\n        ({ id }) => id !== transactionId\n      );\n      this.hideTransactionModal();\n    });\n  },\n...\n```", "```cpp\n...\n  showTransactionModal(transactionId) {\n    this.state.activeTransactionId = transactionId || 0;\n    const transactModal = document.querySelector('#transactionModal');\n    UIkit.modal(transactModal).show();\n  },\n\n  hideTransactionModal() {\n    this.state.activeTransactionId = 0;\n    const transactModal = document.querySelector('#transactionModal');\n    UIkit.modal(transactModal).hide();\n  },\n\n  getActiveTransaction() {\n    const { transactions, activeTransactionId } = this.state;\n    const foundTransaction = transactions.find(transaction =>\n      transaction.id === activeTransactionId);\n    return foundTransaction || { id: 0 };\n  },\n...\n```", "```cpp\n...\n  updateInitialBalance(amount, fieldName) {\n    this.state.balances[fieldName] = amount;\n  },\n\n  // Update the \"balances\" object in global state based on the current\n  // initial balances:\n  recalculateBalances() {\n    const { initialRaw, initialCooked } = this.state.balances;\n    const { currentRaw, currentCooked } = this.wasm.getCurrentBalances(\n      initialRaw,\n      initialCooked\n    );\n    this.state.balances = {\n      initialRaw,\n      currentRaw,\n      initialCooked,\n      currentCooked\n    };\n  }\n};\n```", "```cpp\n/**\n * This function instantiates the Wasm module, fetches the transactions\n * from the API endpoint, and loads them into state and the Wasm\n * instance.\n */\nexport const initializeStore = async () => {\n  const wasmTransactions = new WasmTransactions();\n  store.wasm = await wasmTransactions.initialize();\n  const transactions = await apiFetchTransactions();\n  store.populateTransactions(transactions);\n};\n```", "```cpp\nimport App from './components/App.js';\nimport { store, initializeStore } from './store/store.js';\n\n// This allows us to use the <vue-numeric> component globally:\nVue.use(VueNumeric.default);\n\n// Create a globally accessible store (without having to pass it down\n// as props):\nwindow.$store = store;\n\n// Since we can only pass numbers into a Wasm function, these flags\n// represent the amount type we're trying to calculate:\nwindow.AMOUNT_TYPE = {\n  raw: 1,\n  cooked: 2\n};\n\n// After fetching the transactions and initializing the Wasm module,\n// render the app.\ninitializeStore()\n  .then(() => {\n    new Vue({ render: h => h(App), el: '#app' });\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```", "```cpp\n<!doctype html>\n<html lang=\"en-us\">\n<head>\n  <title>Cook the Books</title>\n  <link\n    rel=\"stylesheet\"\n    type=\"text/css\"\n    href=\"https://cdnjs.cloudflare.com/ajax/libs/uikit/3.0.0-rc.6/css/uikit.min.css\"\n  />\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"styles.css\" />\n  <script src=\"img/uikit.min.js\"></script>\n  <script src=\"img/uikit-icons.min.js\"></script>\n  <script src=\"img/accounting.umd.js\"></script>\n  <script src=\"img/lodash.min.js\"></script>\n  <script src=\"img/d3.min.js\"></script>\n  <script src=\"img/vue.min.js\"></script>\n  <script src=\"img/vue-numeric.min.js\"></script>\n  <script src=\"img/main.js\" type=\"module\"></script>\n</head>\n<body>\n  <div id=\"app\"></div>\n</body>\n</html>\n```", "```cpp\n@import url(\"https://fonts.googleapis.com/css?family=Quicksand\");\n\n:root {\n  --blue: #2889ed;\n}\n\n* {\n  font-family: \"Quicksand\", Helvetica, Arial, sans-serif !important;\n}\n\n#app {\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.addTransactionButton {\n  color: white;\n  height: 64px;\n  width: 64px;\n  background: var(--blue);\n  position: fixed;\n  bottom: 24px;\n  right: 24px;\n}\n\n.addTransactionButton:hover {\n  color: white;\n  background-color: var(--blue);\n  opacity: .6;\n}\n\n.errorText {\n  color: white;\n  font-size: 36px;\n}\n\n.appHeader {\n  height: 80px;\n  margin: 0;\n}\n\n.balanceEntry {\n  font-size: 2rem;\n}\n\n.tableAmount {\n  white-space: pre;\n}\n```", "```cpp\nimport SomeComponent from './SomeComponent.js';\n\nexport default {\n  name: 'dummy-component',\n\n  // Props passed from other components:\n  props: {\n    label: String,\n  },\n\n  // Other Vue components to render within the template:\n  components: {\n    SomeComponent\n  },\n\n  // Used to store local data/state:\n  data() {\n    return {\n      amount: 0\n    }\n  },\n\n  // Used to store complex logic that outside of the `template`:\n  computed: {\n    negativeClass() {\n      return {\n        'negative': this.amount < 0\n      };\n    }\n  },\n\n  // Methods that can be performed within the component:\n  methods: {\n    addOne() {\n      this.amount += 1;\n    }\n  },\n\n  // Perform actions if the local data changes:\n  watch: {\n    amount(val, oldVal) {\n      console.log(`New: ${val} | Old: ${oldVal}`);\n    }\n  },\n\n  // Contains the HTML to render the component:\n  template: `\n    <div>\n      <some-component></some-component>\n      <label for=\"someAmount\">{{ label }}</label>\n      <input\n        id=\"someAmount\"\n        :class=\"negativeClass\"\n        v-model=\"amount\"\n        type=\"number\"\n      />\n      <button @click=\"addOne\">Add One</button>\n    </div>\n  `\n};\n```", "```cpp\nimport BalancesBar from './BalancesBar/BalancesBar.js';\nimport ChartsTab from './ChartsTab/ChartsTab.js';\nimport TransactionsTab from './TransactionsTab/TransactionsTab.js';\n\n/**\n * This component is the entry point for the application. It contains the\n * header, tabs, and content.\n */\nexport default {\n  name: 'app',\n  components: {\n    BalancesBar,\n    ChartsTab,\n    TransactionsTab\n  },\n  data() {\n    return {\n      balances: $store.state.balances,\n      activeTab: 0\n    };\n  },\n  methods: {\n    // Any time a transaction is added, edited, or removed, we need to\n    // ensure the balance is updated:\n    onTransactionChange() {\n      $store.recalculateBalances();\n      this.balances = $store.state.balances;\n    },\n\n    // When the \"Charts\" tab is activated, this ensures that the charts\n    // get automatically updated:\n    onTabClick(event) {\n      this.activeTab = +event.target.dataset.tab;\n    }\n  },\n  template: `\n    <div>\n      <div class=\"appHeader uk-background-primary uk-flex uk-flex-middle\">\n        <h2 class=\"uk-light uk-margin-remove-bottom uk-margin-left\">\n          Cook the Books\n        </h2>\n      </div>\n      <div class=\"uk-position-relative\">\n        <ul uk-tab class=\"uk-margin-small-bottom uk-margin-top\">\n          <li class=\"uk-margin-small-left\">\n            <a href=\"#\" data-tab=\"0\" @click=\"onTabClick\">Transactions</a>\n          </li>\n          <li>\n            <a href=\"#\" data-tab=\"1\" @click=\"onTabClick\">Charts</a>\n          </li>\n        </ul>\n        <balances-bar\n          :balances=\"balances\"\n          :onTransactionChange=\"onTransactionChange\">\n        </balances-bar>\n        <ul class=\"uk-switcher\">\n          <li>\n            <transactions-tab :onTransactionChange=\"onTransactionChange\">\n            </transactions-tab>\n          </li>\n          <li>\n            <charts-tab :isActive=\"this.activeTab === 1\"></charts-tab>\n          </li>\n        </ul>\n      </div>\n    </div>\n  `\n};\n```", "```cpp\n<balance-card\n  title=\"Initial Raw Balance\"\n  :value=\"balances.initialRaw\"\n  :onChange=\"amount => onBalanceChange(amount, 'initialRaw')\">\n</balance-card>\n```", "```cpp\ngetFormattedTransactions() {\n  const getDisplayAmount = (type, amount) => {\n    if (amount === 0) return accounting.formatMoney(amount);\n    return accounting.formatMoney(amount, {\n      format: { pos: '%s %v', neg: '%s (%v)' }\n    });\n  };\n\n  const getDisplayDate = transactionDate => {\n    if (!transactionDate) return '';\n    const parsedTime = d3.timeParse('%Y-%m-%d')(transactionDate);\n    return d3.timeFormat('%m/%d/%Y')(parsedTime);\n  };\n\n  return $store.state.transactions.map(\n    ({\n      type,\n      rawAmount,\n      cookedAmount,\n      transactionDate,\n      ...transaction\n    }) => ({\n      ...transaction,\n      type,\n      rawAmount: getDisplayAmount(type, rawAmount),\n      cookedAmount: getDisplayAmount(type, cookedAmount),\n      transactionDate: getDisplayDate(transactionDate)\n    })\n  );\n}\n```", "```cpp\narc\n  .append('path')\n  .attr('fill', d => colorScale(d.data.category))\n  .transition()\n  .delay((d, i) => i * 100)\n  .duration(500)\n  .attrTween('d', d => {\n    const i = d3.interpolate(d.startAngle + 0.1, d.endAngle);\n    return t => {\n      d.endAngle = i(t);\n      return arcPath(d);\n    };\n  });\n```", "```cpp\nhttps://bl.ocks.org. That's it for the components review; let's try running the application.\n```", "```cpp\n\u251c\u2500\u2500 /assets\n\u2502    \u251c\u2500\u2500 main.wasm\n\u2502    \u2514\u2500\u2500 memory.wasm\n\u251c\u2500\u2500 /components\n\u2502    \u251c\u2500\u2500 /BalancesBar\n\u2502    \u2502    \u251c\u2500\u2500 BalanceCard.js\n\u2502    \u2502    \u2514\u2500\u2500 BalancesBar.js\n\u2502    \u251c\u2500\u2500 /ChartsTab\n\u2502    \u2502    \u251c\u2500\u2500 ChartsTab.js\n\u2502    \u2502    \u2514\u2500\u2500 PieChart.js\n\u2502    \u251c\u2500\u2500 /TransactionsTab\n\u2502    \u2502    \u251c\u2500\u2500 ConfirmationModal.js\n\u2502    |    \u251c\u2500\u2500 TransactionModal.js\n\u2502    |    \u251c\u2500\u2500 TransactionsTab.js\n\u2502    |    \u2514\u2500\u2500 TransactionsTable.js\n\u2502    \u2514\u2500\u2500 App.js\n\u251c\u2500\u2500 /store\n\u2502    \u251c\u2500\u2500 api.js\n\u2502    \u251c\u2500\u2500 initializeWasm.js\n\u2502    \u251c\u2500\u2500 store.js\n\u2502    \u2514\u2500\u2500 WasmTransactions.js\n\u251c\u2500\u2500 index.html\n\u251c\u2500\u2500 main.js\n\u2514\u2500\u2500 styles.css\n```", "```cpp\nnpm start\n```"]