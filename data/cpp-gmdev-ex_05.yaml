- en: Setting Up Your Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置您的游戏
- en: In this chapter, we will start with the basics of how a game is made and what
    basic graphical components the game requires. Since this book is going to be covering
    graphics with C++, we will mostly look at what is graphically required from the
    graphics engine in a game. We will also cover the sound system so that we can
    make the game more interesting.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从游戏制作的基础知识以及游戏所需的基本图形组件开始。由于本书将涵盖使用 C++ 的图形，我们将主要关注游戏中图形引擎所需的图形功能。我们还将介绍音效系统，以便使游戏更加有趣。
- en: To create a basic graphics engine, we will be using the **Simple and Fast Multimedia
    Library** (**SFML**) since this includes most of the functionality that is needed
    to get a game up and running. The reason for choosing SFML is that it is very
    basic and easy to understand, unlike other engines and frameworks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个基本的图形引擎，我们将使用**简单快速多媒体库**（**SFML**），因为它包含了启动游戏所需的大部分功能。选择 SFML 的原因是它非常基础且易于理解，与其他引擎和框架不同。
- en: In this chapter, we will create a window for our game and add animations to
    it. We will also learn how to create and control our player's movements.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为我们的游戏创建一个窗口并向其中添加动画。我们还将学习如何创建和控制玩家的移动。
- en: 'The following topics are covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: An overview of SFML
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SFML 概述
- en: Downloading SFML and configuring Visual Studio
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载 SFML 并配置 Visual Studio
- en: Creating a window
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建窗口
- en: Drawing shapes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制形状
- en: Adding sprites
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加精灵
- en: Keyboard input
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键盘输入
- en: Handing player movement
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理玩家移动
- en: An overview of SFML
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SFML 概述
- en: Games and video games (unlike other entertainment media) actually involve loading
    various resources, such as images, videos, sound, font types, and more. SFML provides
    functions for loading all of these features into games.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏（与其它娱乐媒体不同）实际上涉及加载各种资源，如图像、视频、声音、字体类型等。SFML 提供了将所有这些功能加载到游戏中的函数。
- en: SFML is cross-platform compatible, which implies that it permits you to develop
    and run games on diverse platforms. It also supports various languages other than
    C++. Additionally, it is open source, so you can take a look at the source code
    and add a feature to it (if it is not included).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: SFML 兼容多个平台，这意味着它允许你在不同的平台上开发和运行游戏。它还支持除 C++ 之外的各种语言。此外，它是开源的，因此你可以查看源代码并向其添加功能（如果尚未包含）。
- en: 'SFML is broken down into five modules, which can be defined as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: SFML 被分解为五个模块，可以定义为以下内容：
- en: '**System**: This module directly interacts with a system such as Windows, which
    is essentially the **o****perating system** (**OS**) that it will use. Since SFML
    is cross-platform compatible and each OS is different in terms of how it handles
    data, this module takes care of interacting with the OS.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统**：此模块直接与系统（如 Windows）交互，该系统本质上将是它将使用的**操作系统**（**OS**）。由于 SFML 兼容多个平台，并且每个操作系统在处理数据方面都有所不同，因此此模块负责与操作系统交互。'
- en: '**Window**: When rendering anything to the screen, the first thing we need
    is a viewport or a window. Once we have access to this, we can start sending our
    rendered scene to it. The window module takes care of how a window is created,
    how the input is handled, and more.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**窗口**：在屏幕上渲染任何内容时，我们首先需要的是一个视口或窗口。一旦我们获得访问权限，我们就可以开始将渲染的场景发送到它。窗口模块负责窗口的创建、输入处理等。'
- en: '**Graphics**: After we have access to a window, we can use the graphics module
    to begin rendering our scene to the window. In SFML, the graphics module is primarily
    rendered using OpenGL and deals with 2D scene rendering only. Therefore, it can''t
    be used to make 3D games.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图形**：在我们获得窗口访问权限后，我们可以使用图形模块开始将场景渲染到窗口中。在 SFML 中，图形模块主要使用 OpenGL 进行渲染，仅处理
    2D 场景渲染。因此，它不能用于制作 3D 游戏。'
- en: '**Audio**: The audio module is responsible for playing audio and audio streams,
    as well as recording audio.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**音频**：音频模块负责播放音频和音频流，以及录音。'
- en: '**Networking**: SFML also includes a networking library for sending and receiving
    data, which can be used for developing multiplayer games.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络**：SFML 还包括一个用于发送和接收数据的网络库，可用于开发多人游戏。'
- en: Downloading SFML and configuring Visual Studio
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载 SFML 并配置 Visual Studio
- en: 'Now that we are familiar with the basics, let''s get started:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了基础知识，让我们开始吧：
- en: 'Navigate to the SFML download page ([https://www.sfml-dev.org/download.php](https://www.sfml-dev.org/download.php.)):'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '导航到 SFML 下载页面 ([https://www.sfml-dev.org/download.php](https://www.sfml-dev.org/download.php)):'
- en: '![](img/65814d16-760b-4b41-b355-8e269710b1f5.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/65814d16-760b-4b41-b355-8e269710b1f5.png)'
- en: Select **SFML 2.5.1**. Alternatively, you can clone the repository and build
    the latest version using CMake.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**SFML 2.5.1**。或者，您也可以克隆仓库并使用CMake构建最新版本。
- en: Download either the 32-bit or 64-bit version (depending on your OS) for Visual
    Studio 2017.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载32位或64位版本（取决于您的操作系统）用于Visual Studio 2017。
- en: Although we are going to be developing the game for Windows, you can download
    SFML for Linux or macOS from the same web page.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将为Windows开发游戏，但您可以从同一网页下载SFML的Linux或macOS版本。
- en: 'In the downloaded ZIP file, you will see the following directories:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在下载的ZIP文件中，您将看到以下目录：
- en: '![](img/cc138488-540c-41c0-b3a3-081fdc183027.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cc138488-540c-41c0-b3a3-081fdc183027.png)'
- en: 'These directories can be defined as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些目录可以定义如下：
- en: '`bin`: This contains all the **dynamic link libraries** (**DLLs**) that are
    required for running all the SFML modules. This has a `.dll` file, which contains
    the debug and release versions. The debug version has a `-d` suffix at the end
    of the file. Files that don''t have this suffix are the release version `.dll`
    files.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bin`：这里包含运行所有SFML模块所需的全部**动态链接库**（DLLs）。这包含一个`.dll`文件，其中包含调试和发布版本。调试版本在文件末尾有一个`-d`后缀。没有这个后缀的文件是发布版本的`.dll`文件。'
- en: '`doc`: This contains the documentation for SFML provided in HTML format.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doc`：这里包含以HTML格式提供的SFML文档。'
- en: '`examples`: This contains examples we can use to implement the modules and
    features of SFML. It tells us how to open a window, include OpenGL, carry out
    networking, and how to create a basic pong-like game.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`examples`：这里包含我们可以用来实现SFML模块和功能的示例。它告诉我们如何打开窗口、包含OpenGL、执行网络操作以及如何创建一个基本的pong游戏。'
- en: '`include`: This contains all the header files for the modules. The graphics
    module has classes for creating sprites, loading textures, creating shapes, and
    more.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include`：这里包含所有模块的头文件。图形模块有用于创建精灵、加载纹理、创建形状等类的类。'
- en: '`lib`: This contains all the library files that we will need in order to run
    SFML.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lib`：这里包含我们运行SFML所需的全部库文件。'
- en: There are also two files: `readme.md` and `license.md`. The license file indicates
    that SFML can be used for commercial purposes. Therefore, it can be altered and
    redistributed, provided that you don't claim that you created it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有两个文件：`readme.md` 和 `license.md`。许可文件表明SFML可用于商业目的。因此，它可以被修改和重新分发，前提是你不要声称是你创建的。
- en: To set up a Visual Studio project, create a new project called `SFMLProject`.
    In this Visual Studio project root directory, where `SFMLProject.vcxproj` is located,
    extract the `SFML-2.5.1` folder and place it here.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要设置Visual Studio项目，创建一个名为`SFMLProject`的新项目。在这个Visual Studio项目根目录中，`SFMLProject.vcxproj`文件所在的位置，提取`SFML-2.5.1`文件夹并将其放置在此处。
- en: 'Then, in the root directory, move all the `.dll` files from the `.bin` folder
    into the root directory. Your project root directory should look similar to the
    following screenshot:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在根目录中，将`.bin`文件夹中的所有`.dll`文件移动到根目录。您的项目根目录应类似于以下截图：
- en: '![](img/9e2adfcc-5ba7-4ff8-9644-2bc7d108f23e.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9e2adfcc-5ba7-4ff8-9644-2bc7d108f23e.png)'
- en: In the Visual Studio project, create a new `source.cpp` file.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio项目中，创建一个新的`source.cpp`文件。
- en: Next, open Project Properties by right-clicking on the project in the Solution
    Explorer.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过在解决方案资源管理器中右键单击项目来打开项目属性。
- en: 'Make sure that the Win32 configuration is selected. Under Configuration Properties,
    select VC++ Directories. Add $(ProjectDir)\SFML-2.5.1\include to the Include Directories.
    Then, add $(ProjectDIr)\SFML-2.5.1\lib in Library Directories, as shown in the
    following screenshot:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保选择了Win32配置。在配置属性下，选择VC++目录。将`$(ProjectDir)\SFML-2.5.1\include`添加到包含目录。然后，将`$(ProjectDIr)\SFML-2.5.1\lib`添加到库目录，如以下截图所示：
- en: '![](img/80696d8b-ade1-4424-b7af-97c629910851.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/80696d8b-ade1-4424-b7af-97c629910851.png)'
- en: The `$(ProjectDir)` keyword always makes sure that files are searched with reference
    to the project directory, which is where the `.vcxproj` file is located. This
    makes the project portable and able to run on any Windows system.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(ProjectDir)`关键字始终确保文件是相对于项目目录进行搜索的，即`.vcxproj`文件所在的目录。这使得项目可移植，并且能够在任何Windows系统上运行。'
- en: 'Next, we have to set what libraries we want to use; select Input from the Linker dropdown
    menu and type in the following `.lib` files:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须设置我们想要使用的库；在链接器下拉菜单中选择“输入”，并输入以下`.lib`文件：
- en: '![](img/ec65240f-e234-4388-8ff4-8683652e3140.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ec65240f-e234-4388-8ff4-8683652e3140.png)'
- en: Although we won't be using `sfml-network-d.lib` in this book, it is better to
    include it so that, if you do want to make a multiplayer game later, then you
    will already be set up for it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这本书中不会使用`sfml-network-d.lib`，但最好还是包含它，这样，如果您以后想要制作多人游戏，您就已经为它做好了准备。
- en: Now that we've completed the setup, we can finally start typing some code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了设置，我们终于可以开始编写一些代码了。
- en: Creating a window
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建窗口
- en: 'Before we draw anything, the first thing we need is a window so that we can
    display something on the screen. Let''s create a window:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们绘制任何东西之前，我们首先需要的是一个窗口，这样我们才能在屏幕上显示一些内容。让我们创建一个窗口：
- en: 'At the top of the `source.cpp` file, include the `Graphics.hpp` file to gain
    access to the SFML graphics library:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`source.cpp`文件的顶部，包含`Graphics.hpp`文件以访问SFML图形库：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, add the main function, which will be the application''s main entry point:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加主函数，它将是应用程序的主要入口点：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To create the window, we have to specify the size of the window that we want
    to create. SFML has a `Vector2f` data type, which takes an `x` and a `y` value
    and uses them to define the size of the window that we will be using.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建窗口，我们必须指定我们想要创建的窗口大小。SFML有一个`Vector2f`数据类型，它接受一个`x`值和一个`y`值，并使用它们来定义我们将要使用的窗口大小。
- en: 'Between `include` and `main`, add the following line of code. Create a variable
    called `viewSize` and set the `x` and `y` values to `1024` and `768`, respectively:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在`include`和`main`之间添加以下代码行。创建一个名为`viewSize`的变量，并将`x`和`y`值分别设置为`1024`和`768`：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The assets for the game are created for the resolution, so I am using this view
    size; we also need to specify a `viewMode` class.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏资源是为分辨率创建的，因此我正在使用这个视图大小；我们还需要指定一个`viewMode`类。
- en: '`viewMode` is an SFML class that sets the width and height of the window. It
    also gets the bits that are required to represent a color value in a pixel. `viewMode`
    also obtains the different resolutions that your monitor supports so that you
    can let the user set the resolution of the game to glorious 4K resolution if they
    desire.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewMode`是一个SFML类，用于设置窗口的宽度和高度。它还获取表示像素中颜色值的位数。`viewMode`还获取您的显示器支持的分辨率，这样您就可以让用户将游戏的分辨率设置为所需的4K分辨率。'
- en: 'To set the view mode, add the following code after setting the `viewSize` variable:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要设置视图模式，在设置`viewSize`变量后添加以下代码：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we can finally create a window. The window is created using the `RenderWindow`
    class. The `RenderWindow` constructor takes three parameters: a `viewMode` parameter,
    a window name parameter, and a `Style` parameter.'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们终于可以创建一个窗口了。窗口是通过`RenderWindow`类创建的。`RenderWindow`构造函数接受三个参数：一个`viewMode`参数、一个窗口名称参数和一个`Style`参数。
- en: 'We have already created a `viewMode` parameter and we can pass in a window
    name here using a string. The third parameter, `Style`. `Style`, is an `enum` value;
    we can add a number of values, called a bitmask, to create the window style that
    we want:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个`viewMode`参数，并且我们可以使用一个字符串在这里传递窗口名称。第三个参数，`Style`。`Style`是一个`enum`值；我们可以添加一个称为位掩码的数值，以创建我们想要的窗口样式：
- en: '`sf::style::Titlebar`: This adds a title bar to the top of the window.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sf::style::Titlebar`：这将在窗口顶部添加一个标题栏。'
- en: '`sf::style::Fullscreen`: This creates a full-screen mode window.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sf::style::Fullscreen`：这创建了一个全屏模式的窗口。'
- en: '`sf::style::Default`: This is the default style that combines the ability to
    resize a window, close it, and add a title bar.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sf::style::Default`：这是默认样式，它结合了调整窗口大小、关闭窗口和添加标题栏的能力。'
- en: 'Let''s create a default-style window. First, create the window using the following
    command and add it after the creation of the `viewMode` parameter:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个默认样式的窗口。首先，使用以下命令创建窗口，并在创建`viewMode`参数后添加它：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the `main()` class, we will create a `while` loop, which handles the main
    game loop for our game. This will check whether or not the window is open so that
    we can add some keyboard events by updating and rendering the objects in the scene.
    The `while` loop will run as long as the window is open. In the `main` function,
    add the following code:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`类中，我们将创建一个`while`循环，它将处理游戏的主循环。这将检查窗口是否打开，这样我们就可以通过更新和渲染场景中的对象来添加一些键盘事件。`while`循环将在窗口打开时运行。在`main`函数中添加以下代码：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, run the application. Here, you have your not-so-interesting game with a
    window that has a white background. Hey, at least you have a window now! To display
    something here, we have to clear the window and display whatever we draw in every
    frame.  This is done using the `clear` and `display` functions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行应用程序。在这里，你有一个不那么有趣的带有白色背景的窗口。嘿，至少你现在有一个窗口了！要在这里显示某些内容，我们必须清除窗口并在每一帧中显示我们绘制的任何内容。这是通过使用`clear`和`display`函数来完成的。
- en: We have to call `window.clear()` before we can render the scene and then call
    `window.display()` afterward to display the scene objects.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们可以渲染场景之前，我们必须调用`window.clear()`，然后调用`window.display()`来显示场景对象。
- en: 'In the `while` loop, add the `clear` and `display` functions. Game objects
    will be drawn between the `clear` function and the `display` function:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`循环中，添加`clear`和`display`函数。游戏对象将在`clear`函数和`display`函数之间绘制：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `clear` function takes in a clear color. Here, we are passing in the color
    red as a value into the function. This function fills in the whole window with
    this solid color value:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`clear`函数接受一个清除颜色。在这里，我们将颜色红色作为值传递给函数。此函数用这种实色值填充整个窗口：'
- en: '![](img/4202f8f9-7655-403d-beab-f571306cec60.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4202f8f9-7655-403d-beab-f571306cec60.png)'
- en: Drawing shapes
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制形状
- en: 'SFML provides us with the functionality to draw basic shapes such as a rectangle,
    circle, and triangle. The shape can be set to a certain size and has functions,
    such as `fillColor`, `Position`, and `Origin`, so that we can set the color, the
    position of the shape in the viewport, and the origin around which the shape can
    rotate respectively. Let''s take a look at an example of a rectangular shape:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: SFML为我们提供了绘制基本形状（如矩形、圆形和三角形）的功能。形状可以设置到一定的大小，并具有如`fillColor`、`Position`和`Origin`等函数，这样我们就可以分别设置颜色、形状在视口中的位置以及形状可以围绕其旋转的原点。让我们看看一个矩形形状的例子：
- en: 'Before the `while` loop, add the following code to set up the rectangle:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`while`循环之前，添加以下代码来设置矩形：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we created a `Rectangle` parameter of the `RectangleShape` type and named
    it `rect`. The constructor of `RectangleShape` takes in the size of the rectangle.
    Its size is `500` by `300`. Then, we set the color of the rectangle to yellow.
    After this, we set the position of the rectangle to the center of the viewport
    and set the origin to the center of the rectangle.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个`Rectangle`参数，其类型为`RectangleShape`，并命名为`rect`。`RectangleShape`的构造函数接受矩形的尺寸。其尺寸为`500`
    x `300`。然后，我们将矩形的颜色设置为黄色。之后，我们将矩形的设置在视口的中心，并将原点设置为矩形的中心。
- en: 'To draw the rectangle, we have to call the `window.draw()` function and pass
    the rectangle into it. Make sure that you call this function between the `clear`
    and `display` functions in the `while` loop. Now, add the following code:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要绘制矩形，我们必须调用`window.draw()`函数并将矩形传递给它。确保你在`while`循环中的`clear`和`display`函数之间调用此函数。现在，添加以下代码：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, run the project; you will see a yellow rectangle in a red viewport, as
    follows:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行项目；你将看到一个黄色的矩形在红色的视口中，如下所示：
- en: '![](img/9efb88d6-b2f6-4ae1-a98f-9ab5d9f53a25.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9efb88d6-b2f6-4ae1-a98f-9ab5d9f53a25.png)'
- en: 'If we set the position to `(0, 0)`, you will see where the origin is for the
    2D rectangle in SFML—it is in the top left corner of the viewport:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们将位置设置为`(0, 0)`，你将看到在SFML中的2D矩形的原点在哪里——它在视口的左上角：
- en: '![](img/2ffda409-1467-4cde-87fe-8d5ce8fa778e.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ffda409-1467-4cde-87fe-8d5ce8fa778e.png)'
- en: 'Move it back to the center of the viewport by undoing the previous action.
    Then, set the rectangle to the center of the viewport again, as follows:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过撤销上一个动作将其移回视口的中心。然后，再次将矩形设置为视口的中心，如下所示：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we can add a few more shapes, such as a circle and a triangle. We can
    create a circle using the `CircleShape` class, whereas we can create a triangle
    using the `ConvexShape` class. Before the main loop, we will create a circle by
    using `CircleShape` and `Triangle` with `ConvexShape`, as follows:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以添加一些更多的形状，例如圆形和三角形。我们可以使用`CircleShape`类来创建圆形，而使用`ConvexShape`类来创建三角形。在主循环之前，我们将使用`CircleShape`和`Triangle`与`ConvexShape`创建一个圆形，如下所示：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `CircleShape` class takes only one parameter (which is the radius of the
    circle), in comparison to the rectangle, which takes two parameters. We set the
    color of the circle to green using the `setFIllColor` function, and then set its
    position and origin.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`CircleShape`类只接受一个参数（即圆的半径），与需要两个参数的矩形相比。我们使用`setFillColor`函数将圆的颜色设置为绿色，然后设置其位置和原点。'
- en: 'To create the triangle, we use the `ConvexShape` class. To create a shape,
    we specify the `setPointCount`, which takes one parameter. We will use it to specify
    how many points will make up the shape. Next, using the `setPoint` function, we
    set the location of the points. This takes two parameters: the first is the index
    of the point and the second is the location of the point.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建三角形，我们使用`ConvexShape`类。要创建一个形状，我们指定`setPointCount`，它接受一个参数。我们将使用它来指定组成形状的点数。接下来，使用`setPoint`函数，我们设置点的位置。这需要两个参数：第一个是点的索引，第二个是点的位置。
- en: 'To create the triangle, we use three points: the first, with an index of `0` and
    a location of `(-100, 0)`; the second, with an index of `1` and a location of
    `(0, -100)`; and the third, with an index of `2` and a location of `(100, 0)`.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建三角形，我们使用三个点：第一个，索引为`0`，位置为`(-100, 0)`；第二个，索引为`1`，位置为`(0, -100)`；第三个，索引为`2`，位置为`(100,
    0)`。
- en: Now, we need to set the color of the triangle. We do this by setting the values
    of the red, green, blue, and alpha values. Colors in SFML are 8-bit integer values.
    This means that each color range is between 0 and 255, where 0 is black and 255
    is the maximum color range. So, when we set the color of the triangle to `triangle.setFillColor(sf::Color(128,
    0, 128, 255));`, red is half of its maximum range, there is no green, blue is
    also half of its maximum range, and alpha is `255`, making the triangle fully
    opaque. Then, we set the position of the triangle so that it's at the center of
    the screen.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要设置三角形的颜色。我们通过设置红色、绿色、蓝色和alpha值来实现这一点。在SFML中，颜色是8位整数值。这意味着每个颜色范围在0到255之间，其中0是黑色，255是最大颜色范围。所以，当我们把三角形的颜色设置为`triangle.setFillColor(sf::Color(128,
    0, 128, 255));`时，红色是其最大范围的二分之一，没有绿色，蓝色也是最大范围的二分之一，alpha值为`255`，使三角形完全不透明。然后，我们设置三角形的位置，使其位于屏幕中心。
- en: 'Next, we draw the circle and triangle. Call the `draw` function for the circle
    and triangle after drawing the rectangle, as follows:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们绘制圆形和三角形。在绘制矩形之后，调用圆形和三角形的`draw`函数，如下所示：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/bc59e484-d415-4dac-9c27-8baf8f7f5a2b.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bc59e484-d415-4dac-9c27-8baf8f7f5a2b.png)'
- en: 'Note that, when creating the triangle, the second point was created with a
    negative *y* value of `100`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在创建三角形时，第二个点的*y*值被设置为负`100`：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'However, the triangle is pointing upward. This means that the *+y* axis is
    pointing downward. You will find that this is mostly the case in 2D frameworks.
    Furthermore, the origin for the scene is in the top-left corner, so the coordinate
    system is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，三角形是向上指的。这意味着*+y*轴是向下的。你会发现这种情况在2D框架中很常见。此外，场景的原点位于左上角，因此坐标系如下：
- en: '![](img/cfe38702-fcdf-4381-b183-15686c0cd830.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cfe38702-fcdf-4381-b183-15686c0cd830.png)'
- en: It is also important to note that the drawing order matters. Drawing happens
    from back to front. So, the first shape that's drawn will be behind the shapes
    that are drawn later in the same location. Objects that are drawn later simply
    draw over the earlier objects, in the same way that an artist would draw in real
    life when painting on a canvas. So, make sure that you draw the bigger objects
    first and then draw the smaller ones later. If you draw the smaller objects before
    the bigger ones, then the smaller objects will be behind the bigger objects and
    you won't be able to see them. Make sure this doesn't happen as you won't get
    any errors and everything in the code will be correct, so you won't know if something's
    gone wrong.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，绘制顺序很重要。绘制是从后往前进行的。因此，首先绘制的形状将位于同一位置上后来绘制的形状之后。后来绘制的对象只是简单地覆盖了先前的对象，就像艺术家在画布上绘画时在现实生活中所做的那样。所以，请确保先绘制较大的对象，然后稍后绘制较小的对象。如果你在绘制较大的对象之前绘制了较小的对象，那么较小的对象将位于较大的对象之后，你将看不到它们。确保这种情况不会发生，因为你不会得到任何错误，代码中的所有内容都将正确，所以你不会知道是否出了问题。
- en: Adding sprites
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加精灵
- en: 'A sprite is a rectangle with a picture applied to it. You may be wondering,
    *why not just use a picture?* Of course, we do load a picture up, then we won''t
    be able to move or rotate it. Therefore, we apply a picture or texture to a rectangle
    that is able to move and rotate, making it look as if the picture is doing so.
    Let''s learn how to do this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵是一个应用了图片的矩形。你可能想知道，“为什么不直接使用图片呢？”当然，我们确实加载了一张图片，然后我们无法移动或旋转它。因此，我们将图片或纹理应用到可以移动和旋转的矩形上，使其看起来像图片在这样做。让我们学习如何做到这一点：
- en: Since we will be loading images into our game project, which is in the root
    directory of the project, let's create a folder called `Assets`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将在游戏项目中加载图像，该游戏项目位于项目的根目录，因此让我们创建一个名为 `Assets` 的文件夹。
- en: 'In this folder, create another folder called `graphics`, and then copy and
    paste the `sky.png` file into the `graphics` folder:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件夹中，创建一个名为 `graphics` 的子文件夹，然后将 `sky.png` 文件复制粘贴到 `graphics` 文件夹中：
- en: '![](img/73547c73-e482-4051-8ea6-4255b56d8cba.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/73547c73-e482-4051-8ea6-4255b56d8cba.png)'
- en: To create sprites, we use the `Sprite` class from SFML. The `Sprite` class takes
    in a texture. Then, the picture is loaded using the `Texture` class. While drawing,
    you need to call `window.draw.(sprite)` to draw the sprite. Let's take a look
    at how to do this.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建精灵，我们使用 SFML 的 `Sprite` 类。`Sprite` 类接受一个纹理。然后，使用 `Texture` 类加载图片。在绘制时，你需要调用
    `window.draw.(sprite)` 来绘制精灵。让我们看看如何做到这一点。
- en: 'Declare a `Texture` class called `skyTexture` and a `Sprite` class called `skySprite`
    globally. This should be done after the creation of the `RenderWindow` class:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `skyTexture` 的 `Texture` 类和一个名为 `skySprite` 的 `Sprite` 类。这应该在创建 `RenderWindow`
    类之后完成：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a new function called `init` in the `source.cpp` file that appears right
    before the `main` function. Since we don''t want the `main` function to be cluttered,
    we will add the code to initialize `skyTexture` and `skySprite` to it. In the
    `init` function, add the following code:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `source.cpp` 文件中创建一个名为 `init` 的新函数，它位于 `main` 函数之前。由于我们不希望 `main` 函数过于杂乱，我们将添加初始化
    `skyTexture` 和 `skySprite` 的代码到其中。在 `init` 函数中，添加以下代码：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, we load the `skyTexture` function by calling the `loadFromFile` function.
    We pass in the path and filename of the file that we want to load. Here, we want
    to load the `sky.png` file from the `Assets` folder.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过调用 `loadFromFile` 函数加载 `skyTexture` 函数。我们传入要加载的文件的路径和文件名。在这里，我们想从 `Assets`
    文件夹中加载 `sky.png` 文件。
- en: Next, we use the `setTexture` function of the sprite and pass the `skyTexture` function
    into it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用精灵的 `setTexture` 函数，并将 `skyTexture` 函数传递给它。
- en: 'To do this, create a new function called `draw()` above the `main` and `init` functions.
    We call draw (`skySprite`) in it in order to draw the sprite, as follows:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要做到这一点，在 `main` 和 `init` 函数上方创建一个名为 `draw()` 的新函数。我们在其中调用 `draw (`skySprite`)
    来绘制精灵，如下所示：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we have to call `init()` at the beginning of the `main` function and `draw()`
    in the `while` loop that we added to the `main` function. You can remove all the
    code that was used for creating and drawing the shapes from the `main` function.
    Your `main` function should look as follows:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须在 `main` 函数的开始处调用 `init()`，并在我们添加到 `main` 函数的 `while` 循环中调用 `draw()`。你可以从
    `main` 函数中删除用于创建和绘制形状的所有代码。你的 `main` 函数应该如下所示：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output is as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/afd3616f-cc49-4c28-a5e2-d82b246818d4.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/afd3616f-cc49-4c28-a5e2-d82b246818d4.png)'
- en: Praise the sun! Lo and behold, we have the sky texture loaded and have drawn
    it as a sprite in the window.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 向太阳致敬！瞧，我们已经加载了天空纹理，并在窗口中以精灵的形式绘制了它。
- en: I have included a background texture picture as well, called `bg.png`, which
    is available in the `Assets` folder of this chapter's project. Try and load the
    texture and draw the texture in the same way.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我还包含了一张背景纹理图片，名为 `bg.png`，它位于本章项目的 `Assets` 文件夹中。尝试以相同的方式加载纹理并绘制纹理。
- en: I named the variables of the background texture and sprite `bgTexture` and `bgSprite`,
    respectively, and drew the `bgSprite` variable into the scene. Don't forget to
    add the `bg.png` file to the `Assets/graphics` directory.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我将背景纹理和精灵的变量分别命名为 `bgTexture` 和 `bgSprite`，并将 `bgSprite` 变量绘制到场景中。别忘了将 `bg.png`
    文件添加到 `Assets/graphics` 目录。
- en: 'Your scene should now look as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你的场景现在应该如下所示：
- en: '![](img/db72e296-c03e-40bd-a81b-14fe9ddf80fe.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/db72e296-c03e-40bd-a81b-14fe9ddf80fe.png)'
- en: 'Next, add another sprite called `heroSprite` and load in the picture with `heroTexture`.
    Set the origin of the sprite to its center and place it in the middle of the scene.
    The `hero.png` file image is provided here, so make sure you place it in the `Assets/graphics`
    folder. Now, declare `heroSprite` and `heroTexture`, as follows:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加另一个名为 `heroSprite` 的精灵，并使用 `heroTexture` 加载图片。将精灵的原点设置为它的中心，并将其放置在场景的中间。这里提供了
    `hero.png` 文件图像，确保将其放置在 `Assets/graphics` 文件夹中。现在，声明 `heroSprite` 和 `heroTexture`，如下所示：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To set the origin of the sprite, we take the textures and the height and divide
    them by `2`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要设置精灵的原点，我们将纹理和高度除以 `2`。
- en: 'Using the `draw` function, draw the `heroSprite` sprite, as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `draw` 函数绘制 `heroSprite` 精灵，如下所示：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Our hero will now appear in the scene, as follows:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的英雄现在将出现在场景中，如下所示：
- en: '![](img/2dfe1e8c-a587-4105-b894-c837d2da6aae.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2dfe1e8c-a587-4105-b894-c837d2da6aae.png)'
- en: Keyboard input
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 键盘输入
- en: It is great that we are able to add shapes, sprites, and textures; however,
    computer games, by nature, are interactive. We will need to allow players to use
    keyboard inputs so that they can access the game's content. But how do we know
    which button the player is pressing? Well, that is handled through the polling
    of events. Polling just checks the status of the keys regularly; events are used
    to check whether an event was triggered, such as the closing of the viewport.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 能够添加形状、精灵和纹理是很好的，然而，计算机游戏本质上都是交互式的。我们需要允许玩家使用键盘输入，以便他们可以访问游戏内容。但我们如何知道玩家按下了哪个按钮呢？嗯，这是通过事件轮询来处理的。轮询只是定期检查键的状态；事件用于检查是否触发了事件，例如视口的关闭。
- en: SFML provides the `sf::Event` class so that we can poll events. We can use the
    `pollEvent` function of the window to check for events that may be occurring,
    such as a player pressing a button.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: SFML 提供了 `sf::Event` 类，以便我们可以轮询事件。我们可以使用窗口的 `pollEvent` 函数来检查可能发生的事件，例如玩家按下按钮。
- en: Create a new function called `updateInput()`. Here, we will create a new object
    of the `sf::Event` class called `event`. We will create a `while` loop called `window.pollEvent` and
    then pass in the `event` variable to check for events.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `updateInput()` 的新函数。在这里，我们将创建一个名为 `event` 的新 `sf::Event` 类对象。我们将创建一个名为
    `window.pollEvent` 的 `while` 循环，并将 `event` 变量传递进去以检查事件。
- en: 'So far, we have been using *Shift* + *F5* or the stop button in Visual Studio to
    stop the application. One of the basic things we can do is check whether the *Esc*
    key has been pressed. If it has been pressed, we want to close the window. To
    do this, add the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用 *Shift* + *F5* 或 Visual Studio 中的停止按钮来停止应用程序。我们可以做的基本事情之一是检查 *Esc*
    键是否被按下。如果被按下，我们希望关闭窗口。为此，添加以下代码：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the `while` loop, we need to check whether the event key code is that of
    the *Esc* key code, or whether the event is `Event::closed`. Then, we call the
    `window.close()` function to close the window. When we close the window, it shuts
    down the application.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `while` 循环中，我们需要检查事件键码是否是 *Esc* 键码，或者事件是否是 `Event::closed`。然后，我们调用 `window.close()`
    函数来关闭窗口。当我们关闭窗口时，它将关闭应用程序。
- en: Call the `updateInput()` function in the main `while` loop before the `window.clear()`
    function. Now, when you press *Esc* while the application is running, it will
    close. SFML doesn't limit inputs just to keyboards; it also provides functionality
    for mouse, joystick, and touch input.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在主 `while` 循环中在 `window.clear()` 函数之前调用 `updateInput()` 函数。现在，当应用程序运行时按下 *Esc*，它将关闭。SFML
    不只是限制输入到键盘；它还提供了鼠标、摇杆和触摸输入的功能。
- en: Handing player movement
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理玩家移动
- en: 'Now that we have access to the player''s keyboard, we can learn how to move
    game objects. Let''s move the player character to the right when the right arrow
    key is pressed on the keyboard. We will stop moving the hero when the right arrow
    key is released:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经可以访问玩家的键盘，我们可以学习如何移动游戏对象。当键盘上按下右箭头键时，让我们将玩家角色向右移动。当右箭头键释放时，我们将停止移动英雄：
- en: Create a global `Vector2f` called `playerPosition`, right after `heroSprite`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `heroSprite` 之后创建一个全局的 `Vector2f` 叫做 `playerPosition`。
- en: Create a Boolean data type called `playerMoving` and set it to `false`.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个布尔数据类型 `playerMoving` 并将其设置为 `false`。
- en: In the `updateInput` function, we will check whether the right key has been
    pressed or released. If the button is pressed, we set `playerMoving` to `true`.
    If the button is released, then we set `playerMoving` to `false`.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `updateInput` 函数中，我们将检查右键是否被按下或释放。如果按钮被按下，我们将 `playerMoving` 设置为 `true`。如果按钮被释放，则将
    `playerMoving` 设置为 `false`。
- en: 'The `updateInput` function should be as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateInput` 函数应该如下所示：'
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To update the objects in the scene, we will create a function called `update`,
    which will take a float called `dt`. This stands for delta time and refers to
    the time that has passed between the previous update and the current update call.
    In the `update` function, we will check whether the player is moving. If the player
    is moving, then we will move the position of the player in the *+x* direction
    and multiply this by `dt`.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更新场景中的对象，我们将创建一个名为 `update` 的函数，它将接受一个名为 `dt` 的浮点数。这代表时间差，指的是上一次更新和当前更新调用之间经过的时间。在
    `update` 函数中，我们将检查玩家是否在移动。如果玩家在移动，那么我们将沿着 *+x* 方向移动玩家的位置，并将其乘以 `dt`。
- en: The reason we multiply by delta time is because if we don't, then the update
    will not be time-dependent, but processor-dependent instead. If you don't multiply
    the position by `dt`, then the update will happen faster on a faster PC and will
    be slower on a slower PC. So, make sure that any movement is always multiplied
    by `dt`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们乘以时间步长（delta time）的原因是，如果不这样做，更新将不会是时间依赖的，而是处理器依赖的。如果你不将位置乘以 `dt`，那么在更快的电脑上更新将会更快，而在较慢的电脑上则会更慢。所以，确保任何移动都是乘以
    `dt`。
- en: 'The `update` function should look as follows. Make sure that this function
    appears before the `main` function:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`update` 函数应该如下所示。确保这个函数出现在 `main` 函数之前：'
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: At the beginning of the `main` function, create an object of the `sf::Clock` type
    called `Clock`. The `Clock` class takes care of getting the system clock and allows
    us to get the delta time in seconds, milliseconds, or microseconds.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 函数的开始处，创建一个名为 `Clock` 的 `sf::Clock` 类型的对象。`Clock` 类负责获取系统时钟，并允许我们以秒、毫秒或微秒为单位获取时间步长。
- en: In the `while` loop, after calling `updateInput()`, create a variable called
    `dt` of the `sf::Time` type and set the `dt` variable by calling `clock.restart().`
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `while` 循环中，在调用 `updateInput()` 之后，创建一个名为 `dt` 的 `sf::Time` 类型的变量，并通过调用 `clock.restart()`
    来设置 `dt` 变量。
- en: Now, call the `update` function and pass in `dt.asSeconds()`, which will give
    the delta time as 60 frames per second, which is approximately .0167 seconds.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，调用 `update` 函数并传入 `dt.asSeconds()`，这将给出每秒 60 帧的时间步长，大约是 .0167 秒。
- en: 'The `main` function should appear as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 函数应该如下所示：'
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, when you run the project and press the right arrow key on the keyboard,
    the player will start moving right, and will stop when you release the right arrow
    key:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当你运行项目并按键盘上的右箭头键时，玩家将开始向右移动，并且当你释放右箭头键时停止：
- en: '![](img/44a97710-1da7-4ba3-8fb2-3ee7edef437b.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/44a97710-1da7-4ba3-8fb2-3ee7edef437b.png)'
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how to set up SFML so that we can start creating
    a game. We covered the five basic modules that make up SFML, and also looked at
    creating shapes using SFML and adding the background and player sprite to the
    scene. We also added keyboard input and used this to make the player character
    move within the scene.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何设置 SFML 以便我们可以开始创建游戏。我们涵盖了构成 SFML 的五个基本模块，并查看如何使用 SFML 创建形状，以及将背景和玩家精灵添加到场景中。我们还添加了键盘输入，并使用它来使玩家角色在场景内移动。
- en: In the next chapter, we will create the basic skeleton of the game. We will
    also move the player character to a separate class and add some basic physics
    to the character to allow them to jump in the game.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将创建游戏的基本框架。我们还将把玩家角色移动到单独的类中，并为角色添加一些基本的物理属性，以便它们可以在游戏中跳跃。
