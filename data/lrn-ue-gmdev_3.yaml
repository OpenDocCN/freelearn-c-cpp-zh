- en: Chapter 3. Game Objects – More and Move
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 游戏对象 – 更多和移动
- en: We created our first room in the Unreal Editor in [Chapter 2](ch02.html "Chapter 2. Creating
    Your First Level"), *Creating Your First Level*. In this chapter, we will cover
    some information about the structure of objects we have used to prototype the
    level in [Chapter 2](ch02.html "Chapter 2. Creating Your First Level"), *Creating
    Your First Level*. This is to ensure that you have a solid foundation in some
    important core concepts before moving forward. Then, we will progressively introduce
    various concepts to make the objects move upon a player's interaction.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](ch02.html "第2章. 创建你的第一个关卡") *创建你的第一个关卡*中在虚幻编辑器中创建了我们的第一个房间。在本章中，我们将介绍一些关于我们用于在[第2章](ch02.html
    "第2章. 创建你的第一个关卡") *创建你的第一个关卡*中原型化关卡的结构的信息。这是为了确保你在继续前进之前对一些重要核心概念有坚实的基础。然后，我们将逐步介绍各种概念，使对象在玩家的交互下移动。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: BSP Brush
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BSP刷子
- en: Static Mesh
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态网格
- en: Texture and Materials
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理和材质
- en: Collision
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞
- en: Volumes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 体积
- en: Blueprint
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝图
- en: BSP Brush
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BSP刷子
- en: We used the BSP Box Brush in [Chapter 2](ch02.html "Chapter 2. Creating Your
    First Level"), *Creating Your First Level*, extensively to create the ground and
    the walls.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](ch02.html "第2章. 创建你的第一个关卡") *创建你的第一个关卡*中广泛使用了BSP盒刷来创建地面和墙壁。
- en: BSP Brushes are the primary building blocks for level creation in the game development.
    They are used for quick prototyping levels like how we have used them in [Chapter
    2](ch02.html "Chapter 2. Creating Your First Level"), *Creating Your First Level*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: BSP刷子是游戏开发中关卡创建的主要构建块。它们被用来快速原型化关卡，就像我们在[第2章](ch02.html "第2章. 创建你的第一个关卡") *创建你的第一个关卡*中使用的那样。
- en: In Unreal, BSP Brushes come in the form of primitives (box, sphere, and so on)
    and also predefined/custom shapes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎中，BSP刷子以原语（盒子、球体等）和预定义/自定义形状的形式出现。
- en: Background
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景
- en: BSP stands for **binary space partitioning**. The structure of a BSP tree allows
    spatial information to be accessed quickly for rendering, especially in 3D scenes
    made up of polygons. A scene is recursively divided into two, until each node
    of the BSP tree contains only polygons that can render in arbitrary order. A scene
    is rendered by traversing down the BSP tree from a given node (viewpoint).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: BSP代表**二叉空间划分**。BSP树的结构允许快速访问空间信息以进行渲染，尤其是在由多边形组成的3D场景中。场景递归地分为两个部分，直到BSP树的每个节点只包含可以任意顺序渲染的多边形。场景通过从给定节点（视点）向下遍历BSP树来渲染。
- en: Since a scene is divided using the BSP principle, placing objects in the level
    could be viewed as cutting into the BSP partitions in the scene. Geometry Brushes
    use **Constructive Solid Geometry** (**CSG**) technique to create polygon surfaces.
    CSG combines simple primitives/custom shapes using Boolean operators such as union,
    subtraction, and intersection to create complex shapes in the level.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于场景是使用BSP原则划分的，因此在关卡中放置对象可以看作是在场景的BSP分区中进行切割。几何刷子使用**构造实体几何**（**CSG**）技术来创建多边形表面。CSG通过使用布尔运算符（如并集、减法和交集）组合简单的原语/自定义形状，以在关卡中创建复杂形状。
- en: So, the CSG technique is used to create surfaces of the object in the level,
    and rendering the level is based on processing these surfaces using the BSP tree.
    This relationship has resulted in Geometry Brushes being known also as BSP Brushes,
    but more accurately, CSG surfaces.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，CSG技术用于创建关卡中对象的表面，而渲染关卡则是基于使用BSP树对这些表面进行处理。这种关系导致几何刷子也被称为BSP刷子，但更准确地说，是CSG表面。
- en: Brush type
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刷子类型
- en: BSP Brushes can either be additive or subtractive in nature. Additive brushes
    are like volumes that fill up the space. Additive brushes were used for the ground
    and the walls in our map in [Chapter 2](ch02.html "Chapter 2. Creating Your First
    Level"), *Creating Your First Level*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: BSP刷子可以是加法或减法性质。加法刷子就像填充空间的体积。在[第2章](ch02.html "第2章. 创建你的第一个关卡") *创建你的第一个关卡*中，我们使用了加法刷子来制作地图的地面和墙壁。
- en: Subtractive brushes can be used to form hollow spaces. These were used to create
    a hole in the wall in which to place a door and its frame in [Chapter 2](ch02.html
    "Chapter 2. Creating Your First Level"), *Creating Your First Level*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 减法刷子可以用来形成空心空间。这些在[第2章](ch02.html "第2章. 创建你的第一个关卡") *创建你的第一个关卡*中用来在墙上开洞放置门及其框架。
- en: Brush solidity
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刷子坚固性
- en: 'For additive brushes, there are various states it can be in: solid, semi-solid,
    or non-solid.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于加法刷子，它可能处于以下各种状态：实心、半实心或非实心。
- en: Since subtractive brushes create empty spaces, players are allowed to move freely
    within them. Subtractive brushes can only be solid brushes.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于减法笔刷创建空隙，玩家可以在其中自由移动。减法笔刷只能是实体笔刷。
- en: 'Refer to the following table for comparison of their properties:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下表格比较它们的属性：
- en: '| Brush solidity | Brush type | Degree of blocking | BSP cutting |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 笔刷实体性 | 笔刷类型 | 阻挡程度 | BSP切割 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Solid | Additive and subtractive | Blocks both players and projectiles |
    Creates BSP cuts to the surrounding world geometry |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 实体 | 添加和减去 | 阻挡玩家和弹体 | 对周围世界几何体造成BSP切割 |'
- en: '| Semi-solid | Additive only | Blocks both players and projectiles | Does not
    cause BSP cuts to the surrounding world geometry |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 半实体 | 仅添加 | 阻挡玩家和弹体 | 不会对周围世界几何体造成BSP切割 |'
- en: '| Non-solid | Additive only | Does not block players or projectiles | Does
    not cause BSP cuts to the surrounding world geometry |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 非实体 | 仅添加 | 不阻挡玩家或弹体 | 不会对周围世界几何体造成BSP切割 |'
- en: Static Mesh
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态网格
- en: Static Mesh is a geometry made up of polygons. Looking more microscopically
    at what a mesh is made of, it is made up of lines connecting vertices.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 静态网格是由多边形组成的几何形状。更微观地看，一个网格是由连接顶点的线条组成的。
- en: Static Mesh has vertices that cannot be animated. This means is that you cannot
    animate a part of the mesh and make that part move relative to itself. But the
    entire mesh can be translated, rotated, and scaled. The lamp and the door that
    we have added in [Chapter 2](ch02.html "Chapter 2. Creating Your First Level"),
    *Creating Your First Level*, are examples of Static Meshes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 静态网格的顶点不能被动画化。这意味着你不能对网格的一部分进行动画处理，并使该部分相对于自身移动。但整个网格可以被平移、旋转和缩放。我们在[第2章](ch02.html
    "第2章。创建您的第一个关卡")“创建您的第一个关卡”中添加的灯和门就是静态网格的例子。
- en: A higher-resolution mesh has more polygons as compared to a lower-resolution
    mesh. This also implies that a higher resolution mesh has a larger number of vertices.
    A higher resolution mesh takes more time to render but is able to provide more
    details in the object.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与低分辨率网格相比，高分辨率网格具有更多的多边形。这也意味着高分辨率网格具有更多的顶点。高分辨率网格需要更多的时间来渲染，但能够提供更多的细节。
- en: Static Meshes are usually first created in external software programs, such
    as Maya or 3ds Max, and then imported into Unreal for placement in game maps.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 静态网格通常首先在外部软件程序中创建，例如Maya或3ds Max，然后导入Unreal以放置在游戏地图中。
- en: The door, its frame, and the lamp that we added in [Chapter 2](ch02.html "Chapter 2. Creating
    Your First Level"), *Creating Your First Level*, are Static Meshes. Notice that
    these objects are not simple geometry looking objects.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](ch02.html "第2章。创建您的第一个关卡")“创建您的第一个关卡”中添加的门、其框架和灯都是静态网格。请注意，这些对象不是简单的几何形状。
- en: BSP Brush versus Static Mesh
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BSP笔刷与静态网格
- en: In game development, many objects in the game are Static Meshes. Why is that
    so? Static Mesh is considered more efficient, especially for a complex object
    with many vertices, as they can be cached to a video memory and are drawn by the
    computer's graphics card. So, Static Meshes are preferred when creating objects
    as they have better render performance, even for complex objects. However, this
    does not mean that BSP Brushes do not have a role in creating games.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，游戏中的许多对象都是静态网格。为什么是这样呢？静态网格被认为更高效，特别是对于具有许多顶点的复杂对象，因为它们可以被缓存到视频内存中，并由计算机的显卡绘制。因此，在创建对象时，静态网格更受欢迎，因为它们具有更好的渲染性能，即使是复杂对象也是如此。然而，这并不意味着BSP笔刷在创建游戏时没有作用。
- en: When BSP Brush is simple, it can still be used without causing too much serious
    impact to the performance. BSP Brush can be easily created in the Unreal Editor,
    hence it is very useful for quick prototyping by the game/level designers. Simple
    BSP Brushes can be created and used as temporary placeholder objects while the
    actual Static Mesh is being modeled by the artists. The creation of a Static Mesh
    takes time, even more so for a highly detailed Static Mesh. We will cover a little
    information about the Static Mesh creation pipeline later in this chapter, so
    we have an idea of the amount of work that needs to be done to get a Static Mesh
    into the game. So, BSP Brush is great for an early game play testing without having
    to wait for all Static Meshes to be created.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当BSP刷子简单时，它仍然可以用来而不会对性能造成太大的影响。BSP刷子可以在Unreal编辑器中轻松创建，因此它对于游戏/关卡设计师的快速原型设计非常有用。简单的BSP刷子可以在建模艺术家正在创建实际的静态网格时作为临时占位符对象创建和使用。创建静态网格需要时间，对于高度详细的静态网格来说更是如此。我们将在本章后面简要介绍静态网格创建流程，以便我们了解将静态网格放入游戏所需完成的工作量。因此，BSP刷子非常适合在没有等待所有静态网格创建的情况下进行早期游戏测试。
- en: Making Static Mesh movable
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使静态网格可移动
- en: Let us open our saved map that we have created in [Chapter 2](ch02.html "Chapter 2. Creating
    Your First Level"), *Creating Your First Level*, and let us first save the level
    as a new `Chapter3Level`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开我们在[第2章](ch02.html "第2章。创建您的第一个关卡")，*创建您的第一个关卡*中创建的已保存地图，并首先将其保存为新的`Chapter3Level`。
- en: Go to **Content Browser** | **Content** | **StarterContent** | **Props**, and
    search for **SM_Chair**, which is a standard Static Mesh prop. Click and drag
    it into our map.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入**内容浏览器** | **内容** | **启动内容** | **道具**，搜索**SM_Chair**，这是一个标准的静态网格道具。点击并拖动它到我们的地图中。
- en: The chair we have in the level now is unmovable. You can quickly build and run
    the level to check it out. To make it movable, we need to change a couple of settings
    under the chair's details.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在关卡中的椅子是不可移动的。您可以快速构建和运行关卡来检查它。要使其可移动，我们需要在椅子的详细信息下更改一些设置。
- en: First, ensure **SM_Chair** is selected, go to the **Details** tab. Go to **Transform**
    | **Mobility**, change it from **Static** to **Movable**. Take a look at the following
    screenshot, which describes how to make the chair movable:![Making Static Mesh
    movable](img/B03679_03_01.jpg)
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，确保**SM_Chair**被选中，转到**详细信息**选项卡。转到**变换** | **移动性**，将其从**静态**更改为**可移动**。看看以下截图，它描述了如何使椅子可移动：![使静态网格可移动](img/B03679_03_01.jpg)
- en: Next, we want the chair to be able to respond to us. Scroll a little down the
    **Details** tab to change the **Physics** setting for the chair. Go to **Details**
    | **Physics**. Make sure the checkbox for **Simulate Physics** is checked. When
    this checkbox is checked, the auto-link setting sets the **Collision** to be a
    **PhysicsActor**. The following screenshot shows the **Physics** settings of the
    chair:![Making Static Mesh movable](img/B03679_03_02.jpg)
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们想让椅子能够响应我们。在**详细信息**选项卡中向下滚动一点，更改椅子的**物理**设置。转到**详细信息** | **物理**。确保**模拟物理**复选框被勾选。当此复选框被勾选时，自动链接设置将**碰撞**设置为**物理Actor**。以下截图显示了椅子的**物理**设置：![使静态网格可移动](img/B03679_03_02.jpg)
- en: Let us now build and play the level. When you walk into the chair, you will
    be able to push it around. Just to note, the chair is still known as Static Mesh,
    but it is now movable.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在构建并玩这个关卡。当你走进椅子时，你将能够推动它。只是要注意，椅子仍然被称为静态网格，但现在它是可移动的。
- en: Materials
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 材质
- en: In [Chapter 2](ch02.html "Chapter 2. Creating Your First Level"), *Creating
    Your First Level*, we selected a walnut polished material and applied it to the
    ground. This changed the simple dull ground into a brown polished wood floor.
    Using materials, we are able to change the look and feel of the objects.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。创建您的第一个关卡")，*创建您的第一个关卡*中，我们选择了一款核桃抛光材质并将其应用于地面。这改变了简单暗淡的地面，变成了棕色抛光木地板。使用材质，我们能够改变物体的外观和感觉。
- en: The reason for a short introduction of materials here is because it is a concept
    that we need to have learned about before we can construct a Static Mesh. We already
    know that we need Static Meshes in the game and we cannot only rely on the limited
    selection that we have in the default map package. We will need to know how to
    create our own Static Meshes, and we rely heavily on Materials to give the Static
    Meshes their look and feel.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里对材质的简要介绍是因为这是一个在我们能够构建静态网格之前需要了解的概念。我们已经知道在游戏中我们需要静态网格，我们不能仅仅依赖于默认地图包中有限的选项。我们需要知道如何创建自己的静态网格，并且我们高度依赖于材质来赋予静态网格外观和感觉。
- en: So, when do we apply Materials while creating our custom Static Mesh? Materials
    are applied to the Static Mesh during its creation process outside the editor,
    which we will cover in a later section of this chapter. For now, let us first
    learn how Materials are constructed in the editor.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在创建自定义静态网格时，我们何时应用材质？材质是在编辑器外部的创建过程中应用于静态网格的，我们将在本章后面的部分进行介绍。现在，让我们首先学习如何在编辑器中构建材质。
- en: Creating a Material in Unreal
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Unreal中创建材质
- en: To fully understand the concept of a Material, we need to break it down into
    its fundamental components. How a surface looks is determined by many factors,
    including color, presence of print/pattern/designs, reflectivity, transparency,
    and many more. These factors combine together to give the surface its unique look.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全理解材质的概念，我们需要将其分解为其基本组成部分。一个表面的外观是由许多因素决定的，包括颜色、图案/图案/设计的存在、反射性、透明度等等。这些因素结合在一起赋予表面其独特的样子。
- en: In Unreal Engine, we are able to create our very own material by using the Material
    Editor. Based on the explanation given earlier, a Material is determined by many
    factors and all these factors combine together to give the Material its own look
    and feel.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unreal Engine中，我们可以通过使用材质编辑器来创建我们自己的材质。根据前面的解释，材质是由许多因素决定的，所有这些因素结合在一起赋予材质其独特的外观和感觉。
- en: Unreal Engine offers a base Material node that has a list of customizable factors,
    which we can use to design our Material. By using different values to different
    factors, we can come up with our very own Material. Let us take a look at what
    is behind the scene in a material that we have used in [Chapter 2](ch02.html "Chapter 2. Creating
    Your First Level"), *Creating Your First Level*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal Engine 提供了一个基础材质节点，它包含一系列可定制的因素，我们可以利用这些因素来设计我们的材质。通过为不同的因素赋予不同的值，我们可以创造出我们自己的材质。让我们来看看我们在[第2章](ch02.html
    "第2章。创建你的第一个关卡")中使用的材质背后是什么，*创建你的第一个关卡*。
- en: Go to **Content Browser** | **Content** | **Starter Content** | **Materials**
    and double-click on **M_Brick_Clay_New**. This opens up the Material Editor. The
    following screenshot shows the zoomed-in version of the base Material node for
    the brick clay material. You might notice that **Base Color**, **Roughness**,
    **Normal**, and **Ambient Occlusion** have inputs to the base **M_Brick_Clay_New**
    material node. These inputs make the brick wall look like a brick wall.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 打开**内容浏览器** | **内容** | **入门内容** | **材质**，双击**M_Brick_Clay_New**。这会打开材质编辑器。以下截图显示了砖泥材质的基础材质节点的放大版本。你可能注意到**基础颜色**、**粗糙度**、**法线**和**环境遮蔽**都有输入到基础**M_Brick_Clay_New**材质节点中。这些输入使砖墙看起来像砖墙。
- en: '![Creating a Material in Unreal](img/B03679_03_03.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![在Unreal中创建材质](img/B03679_03_03.jpg)'
- en: The inputs to these nodes can take on values from various sources. Take **Base
    Color** for example, we can define the color using RGB values or we can take the
    color from the texture input. Textures are images in formats, such as `.bmp`,
    `.jpg`, `.png`, and so on, which we can create using tools, such as Photoshop
    or ZBrush.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些节点的输入可以来自各种来源。以**基础颜色**为例，我们可以使用RGB值定义颜色，或者从纹理输入中获取颜色。纹理是以`.bmp`、`.jpg`、`.png`等格式存在的图像，我们可以使用Photoshop或ZBrush等工具创建它们。
- en: We will talk more about the construction of the materials a little later in
    this book. For now, let us just keep in mind that materials are applied to the
    surfaces and textures are what we can use in combination, to give the materials
    its overall visual look.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书稍后更详细地讨论材质的构建。现在，让我们记住，材质应用于表面，纹理是我们可以用作组合来赋予材质整体视觉外观的东西。
- en: Materials versus Textures
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 材质与纹理的比较
- en: Notice that I have used both Materials and Textures in the previous section.
    It has often caused quite a bit of confusion for a newbie in the game development.
    Material is what we apply to surfaces and they are made up of a combination of
    different textures. Materials take on the properties from the textures depending
    on what was specified, including color, transparency, and so on.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我在上一节中同时使用了材料和纹理。这对于游戏开发的新手来说常常会引起相当多的困惑。材料是我们应用到表面上的东西，它们由不同纹理的组合构成。材料根据指定的属性从纹理中获取属性，包括颜色、透明度等等。
- en: As explained earlier, Textures are simple images in formats such as `.tga`,
    `.bmp`, `.jpg`, `.png`, and so on.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，纹理是简单的图像，格式如`.tga`、`.bmp`、`.jpg`、`.png`等。
- en: Texture/UV mapping
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纹理/UV映射
- en: Now, we understand that a custom material is made up of a combination of textures
    and material is applied onto surfaces to give the polygon meshes its identity
    and realism. The next question is how do we apply these numerous textures that
    come with the material onto the surfaces? Do we simply slap them onto the 3D object?
    There must be a predictable manner in which we paint these textures onto the surfaces.
    The method used is called **Texture Mapping** , which was pioneered by Edwin Catmull
    in 1974.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们了解到自定义材料是由纹理和材料的组合构成的，材料被应用到表面上，以赋予多边形网格其身份和真实感。下一个问题是，我们如何将这些与材料一起提供的众多纹理应用到表面上？我们只是简单地将其粘贴到3D对象上吗？我们必须有一种可预测的方式来将这些纹理绘制到表面上。所使用的方法被称为**纹理映射**，它由Edwin
    Catmull在1974年首创。
- en: Texture mapping assigns pixels from a texture image to a point on the surface
    of the polygon. The texture image is called a **UV texture map**. The reason we
    are using UV as an alternative to the XY coordinates is because we are already
    using XY to describe the geometric space of the object. So the UV coordinates
    are the texture's XY coordinates, and it is solely used to determine how to paint
    a 3D surface.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理映射将纹理图像的像素分配到多边形表面的一个点上。这个纹理图像被称为**UV纹理图**。我们使用UV作为XY坐标的替代品的原因是因为我们已经在使用XY来描述对象的几何空间。因此，UV坐标是纹理的XY坐标，它仅用于确定如何绘制3D表面。
- en: How to create and use a Texture Map
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何创建和使用纹理图
- en: 'We will first need to unwrap a mesh at its seams and lay it out flat in 2D.
    This 2D surface is then painted upon to create the texture. This painted texture
    (also known as **Texture Map**) will then be wrapped back around the mesh by assigning
    the UV coordinates of the texture on each face of the mesh. To help you better
    visualize, take a look at the following illustration:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要将网格在其接缝处展开，并在2D中平铺。然后在这个2D表面上绘制以创建纹理。这个绘制的纹理（也称为**纹理图**）然后通过为网格的每个面分配纹理的UV坐标将其包裹回网格。为了更好地帮助您可视化，请查看以下插图：
- en: '![How to create and use a Texture Map](img/B03679_03_04.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![如何创建和使用纹理图](img/B03679_03_04.jpg)'
- en: 'Source: Wikipedia ([https://en.wikipedia.org/wiki/UV_mapping](https://en.wikipedia.org/wiki/UV_mapping))'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：维基百科 ([https://en.wikipedia.org/wiki/UV_mapping](https://en.wikipedia.org/wiki/UV_mapping))
- en: As a result of this, shared vertices can have more than one set of UV coordinates
    assigned.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，共享的顶点可以分配多个UV坐标集。
- en: Multitexturing
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多纹理
- en: To create a better appearance in surfaces, we can use multiple textures to create
    the eventual end result desired. This layering technique allows for many different
    textures to be created using different combinations of textures. More importantly,
    it gives the artists better control of details and/or lighting on a surface.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在表面上获得更好的外观，我们可以使用多个纹理来创建最终所需的结果。这种分层技术允许使用不同纹理的组合创建许多不同的纹理。更重要的是，它为艺术家提供了对表面细节和/或光照的更好控制。
- en: A special form of texture maps – Normal Maps
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一种特殊的纹理映射形式——法线图
- en: Normal Maps are a type of texture maps. They give the surfaces little bumps
    and dents. Normal Maps add the details to the surfaces without increasing the
    number of polygons. One very effective use of Normal Mapping is to generate Normal
    Maps from a high polygon 3D model and use it to texture the lower polygon model,
    which is also known as **baking**. We will discuss why we need the same 3D model
    with different number of polygons in the next section.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 法线图是一种纹理图。它们给表面带来小凹凸和凹坑。法线图在不增加多边形数量的情况下为表面添加细节。法线图的一个非常有效的用途是从高多边形3D模型生成法线图，并使用它来纹理低多边形模型，这被称为**烘焙**。我们将在下一节讨论为什么我们需要具有不同多边形数量的相同3D模型。
- en: 'Normal maps are commonly stored as regular RGB images where the RGB components
    correspond to the X, Y, and Z coordinates, respectively, of the surface normal.
    The following image shows an example of a normal map taken from [http://www.bricksntiles.com/textures/](http://www.bricksntiles.com/textures/):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 法线贴图通常存储为常规RGB图像，其中RGB分量分别对应于表面法线的X、Y和Z坐标。以下图像显示了从[http://www.bricksntiles.com/textures/](http://www.bricksntiles.com/textures/)获取的法线贴图示例：
- en: '![A special form of texture maps – Normal Maps](img/B03679_03_05.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![一种特殊的纹理映射形式——法线贴图](img/B03679_03_05.jpg)'
- en: Level of detail
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 细节级别
- en: We create objects with varying **level of details** (**LODs**) to increase the
    efficiency of rendering. For objects that are closer to the player, high LODs
    objects are rendered. Objects with higher LODs have a higher number of polygons.
    For objects that are far away from the player, a simpler version of the object
    is rendered instead.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建具有不同**细节级别**（**LODs**）的对象，以提高渲染效率。对于靠近玩家的对象，渲染高LOD对象。具有更高LOD的对象具有更多的多边形。对于远离玩家的对象，则渲染对象的简化版本。
- en: Artists can create different LOD versions of the 3D object using automated LOD
    algorithms, deployed through software or manually reducing the number of vertices,
    normals, edges in the 3D Models, to create a lower polygon count model. When creating
    models of different LODs, note that we always start by creating the most detailed
    model with the most number of polygons first and then reduce the number accordingly
    to create the other LOD versions. It is much harder to work the models the other
    way around. Do remember to keep the UV coherent when working with objects with
    different LODs. Currently, different LODs need to be light mapped separately.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 艺术家可以使用自动化的LOD算法，通过软件部署或手动减少3D模型中的顶点、法线和边数，来创建不同LOD版本的3D对象，从而创建一个多边形数量更少的模型。在创建不同LOD的模型时，请注意，我们总是先创建具有最多多边形的最详细模型，然后相应地减少以创建其他LOD版本。反过来工作模型要困难得多。务必记住，在处理不同LOD的对象时保持UV一致性。目前，不同的LOD需要分别进行光照贴图。
- en: 'The following image is taken from [http://renderman.pixar.com/view/level-of-detail](http://renderman.pixar.com/view/level-of-detail)
    and very clearly shows the polygon count based on the distance away from the camera:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像来自[http://renderman.pixar.com/view/level-of-detail](http://renderman.pixar.com/view/level-of-detail)，非常清楚地显示了基于距离相机距离的多边形数量：
- en: '![Level of detail](img/B03679_03_06.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![细节级别](img/B03679_03_06.jpg)'
- en: Collisions
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞
- en: Objects in Unreal Engine have collision properties that can be modified to design
    the behavior of the object when it collides with another object.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal Engine中的对象具有可以修改的碰撞属性，以设计对象与其他对象碰撞时的行为。
- en: In real life, collisions occur when two objects move and meet each other at
    a point of contact. Their individual object properties will determine what kind
    of collision we get, how they respond to the collision, and their path after the
    collision. This is what we try to achieve in the game world as well.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，碰撞发生在两个物体移动并在接触点相遇时。它们的个别对象属性将决定我们得到什么样的碰撞，它们如何响应碰撞，以及碰撞后的路径。这就是我们在游戏世界中试图实现的内容。
- en: 'The following screenshot shows the collision properties available to an object
    in Unreal Engine 4:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了Unreal Engine 4中对象可用的碰撞属性：
- en: '![Collisions](img/B03679_03_07.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![碰撞](img/B03679_03_07.jpg)'
- en: If you are still confused about the concept of collision, imagine Static Mesh
    to give an object its shape (how large it is, how wide it is, and so on), while
    the collision of the object is able to determine the behavior of this object when
    placed on the table—whether the object is able to fall through the table in the
    level or lay stationery on the table.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然对碰撞的概念感到困惑，想象一下静态网格为对象提供形状（它有多大，有多宽等等），而对象的碰撞能够确定当放置在桌子上时该对象的行为——该对象是否能够在关卡中穿过桌子，或者静止地放在桌子上。
- en: Collision configuration properties
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞配置属性
- en: Let us go through some of the possible configurations in Unreal's **Collision**
    properties that we should get acquainted with.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看Unreal的**碰撞**属性中的一些可能配置，这些是我们应该熟悉的。
- en: Simulation Generates Hit Events
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟生成碰撞事件
- en: When an object has the **Simulation Generates Hit Events** flag checked, an
    alert is raised when the object has a collision. This alert notification can be
    used to trigger the onset of other game actions based on this collision.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象具有**模拟生成击中事件**标志被勾选时，当对象发生碰撞时，会发出警报。此警报通知可用于根据此碰撞触发其他游戏动作。
- en: Generate Overlap Events
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成重叠事件
- en: The **Generate Overlap Events** flag is similar to the **Simulation Generates
    Hit Events** flag, but when this flag is checked, in order to generate an event,
    all the object needs is to have another object to overlap with it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**生成重叠事件**标志与**模拟生成击中事件**标志类似，但当此标志被勾选时，为了生成一个事件，所有对象需要的只是与另一个对象重叠。'
- en: Collision Presets
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 碰撞预设
- en: The **Collision Presets** property contains a few frequently used settings that
    have been preconfigured for you. If you wish to create your own custom collision
    properties, set this to **Custom**.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**碰撞预设**属性包含一些预配置的常用设置。如果您希望创建自己的自定义碰撞属性，请将其设置为**自定义**。'
- en: Collision Enabled
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 碰撞启用
- en: 'The **Collision Enabled** property allows three different settings: **No Collision**,
    **No Physics Collision**, and **Collision Enabled**. **No Physics Collision**
    is selected when this object is used only for non-physical types of collision
    such as raycasts, sweeps, and overlaps. **Collision Enabled** is selected when
    physics collision is needed. No Collision is selected when absolutely no collision
    is wanted.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**碰撞启用**属性允许三种不同的设置：**无碰撞**、**无物理碰撞**和**碰撞启用**。当此对象仅用于非物理类型的碰撞，如射线投射、扫掠和重叠时，选择**无物理碰撞**。当需要物理碰撞时，选择**碰撞启用**。当绝对不需要碰撞时，选择**无碰撞**。'
- en: Object Type
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象类型
- en: 'Objects can be categorized into several groups: **WorldStatic**, **WorldDynamic**,
    **Pawn**, **PhysicsBody**, **Vehicle**, **Destructible**, and **Projectile**.
    The type selected determines the interactions it takes on as it moves.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对象可以被分类到几个组中：**WorldStatic**、**WorldDynamic**、**Pawn**、**PhysicsBody**、**Vehicle**、**Destructible**和**Projectile**。所选类型决定了它在移动时采取的交互。
- en: Collision Responses
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 碰撞响应
- en: The **Collision Responses** option sets the property values for all **Trace**
    and **Object Responses** that come with it. When **Block** is selected for **Collision
    Responses**, all the properties under **Trace** and **Object Responses** are also
    set to **Block**.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**碰撞响应**选项设置所有随附的**追踪**和**对象响应**的属性值。当**碰撞响应**选择**阻止**时，**追踪**和**对象响应**下的所有属性也设置为**阻止**。'
- en: Trace Responses
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 追踪响应
- en: The **Trace Responses** option affects how the object interacts with traces.
    **Visibility** and **Camera** are the two types of traces that you can choose
    to block, overlap, or ignore.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**追踪响应**选项影响对象与追踪的交互方式。**可见性**和**相机**是您可以选择的两种追踪类型，您可以选择阻止、重叠或忽略。'
- en: Object Responses
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对象响应
- en: The **Object Responses** option affects how this object interacts with other
    object types. Remember the **Object Type** selection earlier? The **Object Type**
    property determines the type of object, and under this category, you can configure
    the collision response this object has with the different types of objects.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象响应**选项影响此对象与其他对象类型的交互方式。记得之前提到的**对象类型**选择吗？**对象类型**属性确定对象的类型，在此类别下，您可以配置此对象与不同类型对象的碰撞响应。'
- en: Collision hulls
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 碰撞外壳
- en: 'For a collision to occur in Unreal Engine, hulls are used. To view an example
    of the collision hull for a Static Mesh, take a look at the light blue lines surrounding
    the cube in the following screenshot; it''s a box collision hull:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎中，要发生碰撞，使用外壳。要查看静态网格的碰撞外壳示例，请查看以下截图中的围绕立方体的浅蓝色线条；它是一个盒式碰撞外壳：
- en: '![Collision hulls](img/B03679_03_08.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![碰撞外壳](img/B03679_03_08.jpg)'
- en: 'Hulls can be generated in Static Mesh Editor for static meshes. The following
    screenshot shows the menu options available for creating an auto-generated collision
    hull in Static Mesh Editor:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 外壳可以在静态网格编辑器中为静态网格生成。以下截图显示了在静态网格编辑器中创建自动生成的碰撞外壳的可用菜单选项：
- en: '![Collision hulls](img/B03679_03_09.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![碰撞外壳](img/B03679_03_09.jpg)'
- en: Simple geometry objects can be combined and overlapped to form a simple hull.
    A simple hull/bounding box reduces the amount of calculation it needs during a
    collision. So for complex objects, a generalized bounding box can be used to encompass
    the object. When creating static mesh that has a complex shape, not a simple geometry
    type of object, you will need to refer to the *Static Mesh creation pipeline*
    section later on in the chapter to learn how to create a suitable collision bounding
    box for it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的几何对象可以组合并重叠以形成一个简单的船体。一个简单的船体/边界框可以减少碰撞时的计算量。因此，对于复杂对象，可以使用通用边界框来包围对象。当创建具有复杂形状的静态网格，而不是简单几何类型的对象时，你需要参考本章后面的*静态网格创建流程*部分，以了解如何为它创建合适的碰撞边界框。
- en: Interactions
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交互
- en: When designing collisions, you will also need to decide what kind of interactions
    the object has and what it will interact with.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计碰撞时，你还需要决定对象有哪些交互类型以及它会与什么交互。
- en: To block means they will collide, and to overlap can mean that no collision
    will occur. When a block or an overlap happens, it is possible to flag the event
    so that other actions resulting from this interaction can be taken. This is to
    allow customized events, which you can have in game.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 阻挡意味着它们将发生碰撞，而重叠可能意味着不会发生碰撞。当发生阻挡或重叠时，可以标记事件，以便可以采取由此交互产生的其他操作。这是为了允许自定义事件，你可以在游戏中实现。
- en: Note that for a block to actually occur, both objects must be set to **Block**
    and they must be set so that they block the right type of objects too. If one
    is set to block and the other to overlap, the overlap will occur but not the block.
    Block and overlap can happen when objects are moving at a high speed, but events
    can only be triggered on either overlap or block, not both. You can also set the
    blocking to ignore a particular type of object, for example, **Pawn**, which is
    the player.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了实际发生碰撞，两个对象都必须设置为**Block**，并且它们必须设置为能够阻挡正确类型的对象。如果一个设置为阻挡而另一个设置为重叠，则将发生重叠但不会发生阻挡。当对象以高速移动时，可能会同时发生阻挡和重叠，但事件只能在重叠或阻挡中触发，不能同时触发。你还可以设置阻挡以忽略特定类型的对象，例如，**Pawn**，即玩家。
- en: Static Mesh creation pipeline
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态网格创建流程
- en: Static Mesh creation pipeline is done outside of the editor using 3D modeling
    tools such as Autodesk's Maya and 3D's Max. Unreal Engine 4 is compatible to import
    the FBX 2013 version of the files.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 静态网格创建流程是在编辑器外使用3D建模工具（如Autodesk的Maya和3D的Max）完成的。Unreal Engine 4兼容导入FBX 2013版本的文件。
- en: This creation pipeline is used mainly by the artists to create game objects
    for the project.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此创建流程主要被艺术家用来为项目创建游戏对象。
- en: The actual steps and naming convention when importing Static Mesh into the editor
    are well documented on the Unreal 4 documentation website. You may refer to [https://docs.unrealengine.com/latest/INT/Engine/Content/FBX/StaticMeshes/index.html](https://docs.unrealengine.com/latest/INT/Engine/Content/FBX/StaticMeshes/index.html)
    for more details.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将静态网格导入编辑器的实际步骤和命名约定在Unreal 4文档网站上都有很好的记录。你可以参考[https://docs.unrealengine.com/latest/INT/Engine/Content/FBX/StaticMeshes/index.html](https://docs.unrealengine.com/latest/INT/Engine/Content/FBX/StaticMeshes/index.html)获取更多详细信息。
- en: Introducing volumes
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍体积
- en: Volumes are invisible areas that are created to help the game developers perform
    a certain function. They are used in conjunction with the objects in the level
    to perform a specific purpose. Volumes are commonly used to set boundaries that
    are intended to prevent players from gaining access to trigger events in the game,
    or use the Lightmass Importance Volume to change how light is calculated within
    an area in the map as in [Chapter 2](ch02.html "Chapter 2. Creating Your First
    Level"), *Creating Your First Level*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 体积是无形的区域，创建它们是为了帮助游戏开发者执行特定功能。它们与关卡中的对象一起使用，以执行特定目的。体积通常用于设置边界，目的是防止玩家进入游戏中的触发事件，或使用Lightmass重要性体积来改变地图中某个区域的灯光计算方式，如[第2章](ch02.html
    "第2章。创建你的第一个关卡")，*创建你的第一个关卡*中所述。
- en: Here's a list of the different types of volumes that can be customized and used
    in Unreal Engine 4\. But feel free to quickly browse through each of the volumes
    here for now, and revisit them later when we start learning how to use them later
    in the book. For this chapter, you may focus your attention first on the Trigger
    Volume, as we will be using that in the later examples of this chapter.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了可以在虚幻引擎4中自定义和使用的不同类型的体积。但现在您可以快速浏览每个体积，稍后当我们开始学习如何在书中使用它们时再回来查看。对于本章，您可能首先关注触发体积，因为我们将在此章的后续示例中使用它。
- en: Blocking Volume
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阻挡体积
- en: The Blocking Volume can be used to prevent players/characters/game objects from
    entering a certain area of the map. It is quite similar to collision hull which
    we have described earlier and can be used in place of Static Mesh collision hull,
    as they are simpler in shapes (block shapes), hence easier to calculate the response
    of the collision. These volumes also have the ability to detect which objects
    overlap with themselves quickly.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 阻挡体积可以用来防止玩家/角色/游戏对象进入地图的某个区域。它与我们在前面描述的碰撞外壳非常相似，可以用作静态网格碰撞外壳的替代品，因为它们的形状更简单（块状），因此更容易计算碰撞响应。这些体积还具有快速检测哪些对象与其自身重叠的能力。
- en: An example of the usage of the Blocking Volume is to prevent the player from
    walking across a row of low bushes. In this case, since the bushes are rather
    irregularly shaped but are roughly forming a straight line, like a hedge, an invisible
    Blocking Volume would be a very good way of preventing the player from crossing
    the bushes.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 阻挡体积的一个使用示例是防止玩家穿越一排低矮的灌木丛。在这种情况下，由于灌木丛形状相当不规则，但大致形成一条直线，就像树篱一样，一个不可见的阻挡体积将是非常好的防止玩家穿越灌木丛的方法。
- en: The following screenshot shows the properties for the Blocking Volume. We can
    change the shape and size of the volume under **Brush Settings**. Collision events
    and triggers other events using Blueprint. This is pretty much the basic configuration
    we will get for all other volumes too.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了阻挡体积的属性。我们可以在**刷子设置**下更改体积的形状和大小。使用蓝图更改碰撞事件和触发其他事件。这基本上是我们将获得的所有其他体积的基本配置。
- en: '![Blocking Volume](img/B03679_03_10.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![阻挡体积](img/B03679_03_10.jpg)'
- en: Camera Blocking Volume
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摄像头阻挡体积
- en: The Camera Blocking Volume works in the same way as the Blocking Volume but
    it is used specifically to block cameras. It is useful when you want to limit
    the player from exploring with the camera beyond a certain range.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 摄像头阻挡体积的工作方式与阻挡体积相同，但它专门用于阻挡摄像头。当您想限制玩家使用摄像头探索超过一定范围时，这很有用。
- en: Trigger Volume
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 触发体积
- en: The Trigger Volume is probably one of the most used volumes. This is also the
    volume which we would be using to create events for the game level that we have
    been working on. As the name implies, upon entering this volume, we can trigger
    events, and via Blueprint, we can create a variety of events for our game, such
    as moving an elevator or spawning NPCs.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 触发体积可能是最常用的体积之一。这也是我们将用来为我们在游戏中正在工作的关卡创建事件的体积。正如其名所示，进入这个体积后，我们可以触发事件，并且通过蓝图，我们可以为我们的游戏创建各种事件，例如移动电梯或生成NPC。
- en: Nav Mesh Bounds Volume
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航网格边界体积
- en: The Nav Mesh Bounds Volume is used to indicate the space in which NPCs are able
    to freely navigate around. NPCs could be enemies in the game who need some sort
    of path finding method to get around the level on their own. This Nav Mesh Bounds
    Volume will set up the area in the game that they are able to walk through. This
    is important as there could be obstacles such as bridges that they will need to
    use to in order get across to the other side (instead of walking straight into
    the river and possibly drowning).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 导航网格边界体积用于指示NPC能够自由导航的空间。NPC可能是游戏中的敌人，他们需要某种路径寻找方法来独自在关卡中移动。这个导航网格边界体积将设置游戏中他们能够穿过的区域。这很重要，因为可能会有障碍物，如桥梁，他们需要使用这些障碍物才能到达另一边（而不是直接走进河流并可能溺水）。
- en: Physics Volume
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物理体积
- en: 'The Physics Volume is used to create areas in which the physics properties
    of the player/objects in the level change. An example of this would be altering
    the gravity within a space ship only when it reaches the orbit. When the gravity
    is changed in these areas, the player starts to move slower and float in the space
    ship. We can then turn this volume off when the ship comes back to earth. The
    following screenshot shows the additional settings we get from the Physics Volume:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 物理体积用于创建玩家/级别中的玩家/对象的物理属性发生变化的区域。一个例子是在太空船达到轨道时仅改变太空船内的重力。在这些区域内改变重力时，玩家开始移动得更慢，并在太空船中漂浮。然后，当飞船返回地球时，我们可以关闭这个体积。以下截图显示了从物理体积获得的附加设置：
- en: '![Physics Volume](img/B03679_03_11.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![物理体积](img/B03679_03_11.jpg)'
- en: Pain Causing Volume
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 疼痛造成体积
- en: 'The Pain Causing Volume is a very specialized volume used to create damage
    to the players upon entry. It is a "milder" version of the Kill Z Volume. Reduction
    of health and the amount of damage per second are customizable, according to your
    game needs. The following screenshot shows the properties you can adjust to control
    how much pain to inflict on the player:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 疼痛造成体积是一个非常专业的体积，用于在玩家进入时对其造成伤害。它是杀戮体积的“较轻”版本。健康值的减少和每秒造成的伤害量可以根据您的游戏需求进行自定义。以下截图显示了您可以调整的属性，以控制对玩家施加的疼痛程度：
- en: '![Pain Causing Volume](img/B03679_03_12.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![疼痛造成体积](img/B03679_03_12.jpg)'
- en: Kill Z Volume
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 杀戮体积
- en: 'We kill the player when it enters the Kill Z Volume. This is a very drastic
    volume that kills the player immediately. An example of its usage is to kill the
    player immediately when the player falls off a high building. The following screenshot
    shows the properties of Kill Z Volume to determine the point at which the player
    is killed:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家进入杀戮体积时，我们会将其消灭。这是一个非常剧烈的体积，会立即消灭玩家。其用法的一个例子是当玩家从高楼坠落时立即将其消灭。以下截图显示了杀戮体积的属性，以确定玩家被消灭的点：
- en: '![Kill Z Volume](img/B03679_03_13.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![杀戮体积](img/B03679_03_13.jpg)'
- en: Level Streaming Volume
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 级别流体积
- en: 'The Level Streaming Volume is used to display the levels when you are within
    the volume. It generally fills the entire space where you want the level to be
    loaded. The reason we need to stream levels is to give players an illusion that
    we have a large open game level, when in fact the level is broken up into chunks
    for more efficient rendering. The following screenshot shows the properties that
    can be configured for the Level Streaming Volume:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 级别流体积用于在您处于体积内时显示级别。它通常填充您希望加载级别的整个空间。我们需要流式传输级别的理由是为了给玩家一种我们有一个大型开放游戏级别的错觉，而实际上级别被分割成块以实现更高效的渲染。以下截图显示了可以为级别流体积配置的属性：
- en: '![Level Streaming Volume](img/B03679_03_14.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![级别流体积](img/B03679_03_14.jpg)'
- en: Cull Distance Volume
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清除距离体积
- en: The Cull Distance Volume allows objects to be culled in the volume. The definition
    of cull is to select from a group. The Cull Distance Volume is used to select
    objects in the volume that need to disappear (or not rendered) based on the distance
    away from the camera. Tiny objects that are far away from the camera cannot be
    seen visibly. These objects can be culled if the camera is too far away from those
    objects. Using the Cull Distance Volume, you would be able to decide upon the
    distance and size of objects, which you want to cull within a fixed space. This
    can greatly improve performance of your game when used effectively.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 清除距离体积允许在体积内清除对象。清除的定义是从一组中选择。清除距离体积用于根据与摄像机的距离选择需要消失（或未渲染）的对象。远离摄像机的微小对象无法被肉眼看到。如果摄像机距离这些对象太远，则可以清除这些对象。使用清除距离体积，您可以决定在固定空间内要清除的对象的距离和大小。如果有效使用，这可以大大提高您游戏的表现。
- en: This might seem very similar to the idea of occlusion. Occlusion is implemented
    by selecting object by object, when it is not rendered on screen. These are normally
    used for larger objects in the scene. Cull Distance Volume can be used over a
    large area of space and using conditions to specify whether or not the objects
    are rendered.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来与遮挡的概念非常相似。遮挡是通过选择对象并逐个实现，当它不在屏幕上渲染时。这些通常用于场景中的大型对象。清除距离体积可以在大范围的空间中使用，并使用条件来指定对象是否渲染。
- en: 'The following screenshot shows the configuration settings that are available
    to the Cull Distance Volume:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了清除距离体积可用的配置设置：
- en: '![Cull Distance Volume](img/B03679_03_15.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![清除距离体积](img/B03679_03_15.jpg)'
- en: Audio Volume
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 音量
- en: The Audio Volume is used to mimic real ambient sound changes when one transits
    from one place to another, especially when transiting to and from very different
    environments, such as walking into a clock shop from a busy street, or walking
    in and out of a restaurant with a live band playing in the background.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 音量用于模拟从一个地方过渡到另一个地方时真实的环绕声音变化，尤其是在从一个地方过渡到另一个非常不同的环境时，例如从繁忙的街道走进钟表店，或者从有现场乐队演奏的餐厅进进出出。
- en: The volume is placed surrounding the boundaries of one of the areas creating
    an artificial border dividing the spaces into interior and exterior. With this
    artificially created boundary and settings that come with this Audio Volume, sound
    artists are able to configure how sounds are played during this transition.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 音量放置在某个区域的边界周围，创建一个人工边界，将空间分为内部和外部。有了这个人工创建的边界和与这个音量相关的设置，声音艺术家能够配置在过渡期间如何播放声音。
- en: PostProcess Volume
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后处理体积
- en: The PostProcess Volume affects the overall scene using post-processing techniques.
    Post-processing effects include Bloom effects, Anti-Aliasing, and Depth of Field.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 后处理体积使用后处理技术影响整个场景。后处理效果包括光晕效果、抗锯齿和景深。
- en: Lightmass Importance Volume
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 光线重要性体积
- en: We have used Lightmass Importance Volume in [Chapter 2](ch02.html "Chapter 2. Creating
    Your First Level"), *Creating Your First Level*, to focus the light on the section
    of the map that has the objects in. The size of the volume should encompass your
    entire level.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](ch02.html "第2章。创建你的第一个关卡")“创建你的第一个关卡”中使用了光线重要性体积，以聚焦于地图上有物体的部分。体积的大小应该包括你的整个关卡。
- en: Introducing Blueprint
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍蓝图
- en: The Unreal Editor offers the ability to create custom events for game levels
    through a visual scripting system. Before Unreal Engine 4, it was known as the
    **Kismet system**. In Unreal Engine 4, this system was revamped with more features
    and capabilities. The improved system was launched with the new name of Blueprint.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 虚幻编辑器通过一个可视化脚本系统提供了为游戏关卡创建自定义事件的能力。在虚幻引擎4之前，它被称为**Kismet系统**。在虚幻引擎4中，这个系统经过改进，增加了更多功能和能力。改进后的系统以新的名称“蓝图”推出。
- en: 'There are several types of Blueprint: Class Blueprint, Data-Only Blueprint,
    and Level Blueprint. These are more or less equivalent to what we used to know
    as Kismet, which is now known as Level Blueprint.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝图有几种类型：类蓝图、仅数据蓝图和关卡蓝图。这些大致相当于我们以前所知道的Kismet，现在被称为关卡蓝图。
- en: Why do I need Blueprint? The simple answer is that through Blueprint, we are
    able to control gameplay without having to dive into the actual coding. This makes
    it convenient for non-programmers to design and modify the gameplay. So, it mainly
    benefits the game designers/artists who can configure the game through the Blueprint
    editor.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我需要蓝图？简单的答案是，通过蓝图，我们能够在不深入实际编码的情况下控制游戏玩法。这使得非程序员能够方便地设计和修改游戏玩法。因此，它主要受益于能够通过蓝图编辑器配置游戏的游戏设计师/艺术家。
- en: So, how can we use Blueprint and what can I use Blueprint for? Blueprint is
    just like coding with an interface. You can select, drag, and drop function nodes
    into the editor, and link them up logically to evoke the desired response to specified
    scenarios in your game. For programmers, they will be able to pick it up pretty
    quickly, since Blueprint is in fact coding but through a visual interface.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何使用蓝图？我能用蓝图做什么？蓝图就像通过界面进行编码。你可以选择、拖放功能节点到编辑器中，并将它们逻辑上连接起来，以触发游戏中特定场景的期望响应。对于程序员来说，他们能够很快地掌握它，因为蓝图实际上是一种编码，但通过一个可视化界面进行。
- en: For the benefit of everyone who is new to Unreal Engine 4 and maybe programming
    as well, we will go through a basic example of how Level Blueprint works here
    and use that as an example to go through some basic programming concepts at the
    same time.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让所有刚开始接触虚幻引擎4以及可能编程的新手受益，我们将在这里通过一个基本示例来讲解关卡蓝图的工作原理，并以此为例同时介绍一些基本的编程概念。
- en: What will we be using Blueprint for? Blueprint has the capabilities to prototype,
    implement, or modify virtually any gameplay element. The gameplay elements affect
    how game objects are spawned, what gets spawned, where they are spawned, and under
    what conditions they are spawned. The game objects can include lights, camera,
    player's input, triggers, meshes, and character models. Blueprint can control
    properties of these game objects dynamically to create countless gameplay scenarios.
    The examples of usage include altering the color of the lights when you enter
    a room in the game, triggering the door to shut behind you after entering the
    room and playing the sound effect of the door closing shut, spawning weapons randomly
    among three possible locations in the map, and so on.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将如何使用蓝图？蓝图具有原型设计、实施或修改几乎任何游戏元素的能力。游戏元素影响游戏对象如何生成、生成什么、在哪里生成以及它们在什么条件下生成。游戏对象可以包括灯光、摄像机、玩家的输入、触发器、网格和角色模型。蓝图可以动态控制这些游戏对象的属性，以创建无数的游戏场景。使用的例子包括在游戏中进入房间时改变灯光的颜色、进入房间后触发门关闭并在关闭时播放门关闭的声音效果、在地图中的三个可能位置随机生成武器等等。
- en: In this chapter, we will focus on Level Blueprint first, since it is the most
    commonly used form of Blueprint.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先关注级别蓝图，因为它是最常用的蓝图形式。
- en: Level Blueprint
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 级别蓝图
- en: Level Blueprint is a type of Blueprint that has influence over what happens
    in the level. Events that are created in this Blueprint affect what happens in
    the level, and are made specific to the situation by specifying the particular
    object it targets.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 级别蓝图是一种影响级别发生事件的蓝图类型。在此蓝图创建的事件会影响级别中发生的事情，并通过指定目标特定对象来使事件具体化。
- en: Feel free to jump to the next section first where we will go through a Blueprint
    example, so that we are able to understand Level Blueprint a little better.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 随意跳到下一节，我们将通过一个蓝图示例来了解，这样我们就能更好地理解级别蓝图。
- en: The following screenshot shows a blank Level Blueprint. The most used window
    is **Event Graph**, which is in the center. Using different node types in **Event
    Graph** and linking it up appropriately creates a responsive interaction within
    the game. The nodes come with variables, values, and other similar properties
    used in programming to control the game events graphically (without writing a
    single line of script or code).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了一个空白的级别蓝图。最常用的窗口是**事件图**，位于中央。使用**事件图**中的不同节点类型并适当地连接它们，可以在游戏中创建响应式交互。节点包含变量、值和其他在编程中用于控制游戏事件图形（不写一行脚本或代码）的类似属性。
- en: '![Level Blueprint](img/B03679_03_16.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![级别蓝图](img/B03679_03_16.jpg)'
- en: Using the Trigger Volume to turn on/off light
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用触发体积来打开/关闭灯光
- en: We are now ready to use what we have learned to construct the next room for
    our game. We will duplicate the first room we have created in order to create
    our second room.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用所学知识来构建我们游戏的下一个房间。我们将复制我们创建的第一个房间以创建第二个房间。
- en: Open the level that we created in [Chapter 2](ch02.html "Chapter 2. Creating
    Your First Level"), *Creating Your First Level*, (`Chapter2_Level`) and save it
    as a new level called `Chapter3_Level`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们在[第2章](ch02.html "第2章。创建您的第一个关卡")中创建的级别，*创建您的第一个关卡*（`Chapter2_Level`），并将其保存为名为`Chapter3_Level`的新级别。
- en: Select all the walls, the floor, the door, and the door frame.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有墙壁、地板、门和门框。
- en: Hold down *Alt* + *Shift* and drag to duplicate the room.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住*Alt* + *Shift*并拖动以复制房间。
- en: Place the duplicated room with the duplicated door aligned to the wall of the
    first room. Refer to the following screenshot to see how the walls are aligned
    from a **Top** view perspective:![Using the Trigger Volume to turn on/off light](img/B03679_03_17.jpg)
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将复制的房间与复制的门对齐到第一个房间的墙上。参考以下截图以了解从**顶部**视角墙壁是如何对齐的：![使用触发体积打开/关闭灯光](img/B03679_03_17.jpg)
- en: Delete the back wall of the first room to link both the rooms.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除第一个房间的后墙以连接两个房间。
- en: Delete all the doors to allow easy access to the second room.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除所有门以方便进入第二个房间。
- en: Move the standing lamp and chair to the side. Take a look the following screenshot
    to understand how the rooms look at this point:![Using the Trigger Volume to turn
    on/off light](img/B03679_03_18.jpg)
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将立式台灯和椅子移到旁边。查看以下截图以了解此时房间的样子：![使用触发体积打开/关闭灯光](img/B03679_03_18.jpg)
- en: Rebuild the lights. The following screenshot shows the room correctly illuminated
    after building the lights:![Using the Trigger Volume to turn on/off light](img/B03679_03_19.jpg)
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重建灯光。以下截图显示了在建立灯光后房间被正确照亮的情景：![使用触发体积打开/关闭灯光](img/B03679_03_19.jpg)
- en: Now, let us focus on working on the second room. We will create a narrower walkway
    using the second room that we have just created.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们专注于第二个房间的制作。我们将使用刚刚创建的第二个房间来创建一个更窄的通道。
- en: Move the sidewalls closer to each other—about 30 cm from the previous sidewall
    towards the center. Refer to the next two screenshots for the **Top** and **Perspective**
    views after moving the sidewalls:![Using the Trigger Volume to turn on/off light](img/B03679_03_20.jpg)![Using
    the Trigger Volume to turn on/off light](img/B03679_03_21.jpg)
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将侧墙向彼此靠近——大约从之前的侧墙向中心方向30厘米。参考以下两个截图了解移动侧墙后的**顶视图**和**透视视图**：![使用触发体积打开/关闭灯光](img/B03679_03_20.jpg)![使用触发体积打开/关闭灯光](img/B03679_03_21.jpg)
- en: Note that LightMass Importance Volume is not encompassing the entire level now.
    Increase the size of the volume to cover the whole level. Take a look at the following
    screenshot to see how to extend the size of the volume correctly:![Using the Trigger
    Volume to turn on/off light](img/B03679_03_22.jpg)
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，LightMass重要性体积现在并没有覆盖整个楼层。增加体积的大小以覆盖整个楼层。查看以下截图以了解如何正确地扩展体积的大小：![使用触发体积打开/关闭灯光](img/B03679_03_22.jpg)
- en: Go to **Content Browser** | **Props**. Click and drop **SM_Lamp_Wall** into
    the level. Rotate the lamp if necessary so that it lies nicely on the side wall.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**内容浏览器** | **道具**。点击并将**SM_Lamp_Wall**拖放到楼层中。如果需要，旋转灯具，使其平稳地放置在侧墙上。
- en: Go to **Modes** | **Lights**. Click and drop a Point Light into the second room.
    Place it just above the light source on the wall light, which we added in the
    previous step. Take a look at the following screenshot to see the placement of
    the lamp and Point Light that we have just added:![Using the Trigger Volume to
    turn on/off light](img/B03679_03_23.jpg)
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**模式** | **灯光**。点击并将点光源拖放到第二个房间中。将其放置在之前步骤中添加的墙灯上的光源正上方。查看以下截图以了解我们刚刚添加的灯具和点光源的放置位置：![使用触发体积打开/关闭灯光](img/B03679_03_23.jpg)
- en: 'Adjust the Point Light settings: Intensity = 1700.0\. This is approximately
    the light intensity coming off a light bulb. The following screenshot shows the
    settings for the Point Light:![Using the Trigger Volume to turn on/off light](img/B03679_03_24.jpg)'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整点光源的设置：强度 = 1700.0。这大约是灯泡发出的光强度。以下截图显示了点光源的设置：![使用触发体积打开/关闭灯光](img/B03679_03_24.jpg)
- en: Next, go to **Light Color** and adjust the color of the light to **#FF9084FF**,
    to adjust the mood of the level.![Using the Trigger Volume to turn on/off light](img/B03679_03_25.jpg)
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到**灯光颜色**并调整灯光颜色为**#FF9084FF**，以调整楼层的氛围。![使用触发体积打开/关闭灯光](img/B03679_03_25.jpg)
- en: Now, let us rename the Point Light to `WalkwayLight` and the **Wall Lamp prop**
    to `WallLamp`.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将点光源重命名为`WalkwayLight`，并将**壁灯道具**重命名为`WallLamp`。
- en: Select the Point Light and right-click to display the contextual menu. Go to
    **Attach To** and select **WallLamp**. This attaches the light to the prop so
    that when we move the prop, the light moves together. The following screenshot
    shows that **WalkwayLight** is linked to **WallLamp**:![Using the Trigger Volume
    to turn on/off light](img/B03679_03_26.jpg)
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择点光源，右键点击以显示上下文菜单。转到**附加到**并选择**WallLamp**。这样就将灯光附加到道具上，以便当我们移动道具时，灯光也会一起移动。以下截图显示了**WalkwayLight**与**WallLamp**的链接：![使用触发体积打开/关闭灯光](img/B03679_03_26.jpg)
- en: Now, let us create a Trigger Volume. Go to **Modes** | **Volumes**. Click and
    drag the Trigger Volume into the level.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个触发体积。转到**模式** | **体积**。点击并拖动触发体积到楼层中。
- en: Resize the volume to cover the entrance of the door dividing the two rooms.
    Refer to the next two screenshots on how to position the volume (**Perspective**
    view and **Top** view). Make sure that the volume covers the entire space of the
    door.![Using the Trigger Volume to turn on/off light](img/B03679_03_27.jpg)![Using
    the Trigger Volume to turn on/off light](img/B03679_03_28.jpg)
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整体积的大小以覆盖分隔两个房间的门入口。参考以下两个截图了解如何定位体积（**透视**视图和**顶视图**）。确保体积覆盖了门的整个空间。![使用触发体积打开/关闭灯光](img/B03679_03_27.jpg)![使用触发体积打开/关闭灯光](img/B03679_03_28.jpg)
- en: Rename **Trigger Volume** to `WalkwayLightTrigger`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**触发体积**重命名为`WalkwayLightTrigger`。
- en: In order to use the Trigger Volume to turn the light on and off, we need to
    figure out which property from the Point Light controls this feature. Click on
    the Point Light (**WalkwayLight**) to display the properties of the light. Scroll
    down to **Rendering** and uncheck the property box for **Visible**. Notice that
    the light is now turned off. We want to keep the light turned off until we trigger
    it.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用触发体积来打开和关闭灯光，我们需要找出点光源中哪个属性控制这个功能。点击点光源（**WalkwayLight**）以显示灯光的属性。向下滚动到**渲染**并取消勾选**可见**属性框。注意，灯光现在已关闭。我们希望在触发之前保持灯光关闭。
- en: So, the next step is to link the sequence of events up. This is done via **Level
    Blueprint**. We will need to trigger this change in property using the Trigger
    Volume, which we have created and turn the light back on.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，下一步是链接事件序列。这是通过**级别蓝图**完成的。我们需要使用我们创建的触发体积来触发属性变化，并将灯光重新打开。
- en: With the Point Light still selected, go to the top ribbon and select **Blueprints**
    | **Open Level Blueprint**. This opens up the **Level Blueprint** window. Make
    sure that the Point Light (**WalkwayLight**) is still selected as shown in the
    following screenshot:![Using the Trigger Volume to turn on/off light](img/B03679_03_29.jpg)
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择点光源的情况下，转到顶部工具栏并选择**蓝图**|**打开级别蓝图**。这会打开**级别蓝图**窗口。确保点光源（**WalkwayLight**）仍然被选中，如以下截图所示：![使用触发体积打开/关闭灯光](img/B03679_03_29.jpg)
- en: Right-click in the **Event Graph** of the **Level Blueprint** window to display
    what actions can be added to the **Level Blueprint**.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**级别蓝图**窗口的**事件图**中右键单击以显示可以添加到**级别蓝图**中的操作。
- en: Due to Level Blueprint's ability to guide what actions are possible, we can
    simply select **Add Reference to WalkwayLight**. This creates the **WalkwayLight**
    actor in **Level Blueprint**. The following screenshot shows the **WalkwayLight**
    actor correctly added in **Blueprint**:![Using the Trigger Volume to turn on/off
    light](img/B03679_03_30.jpg)
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于级别蓝图能够指导可能执行的操作，我们可以简单地选择**添加WalkwayLight引用**。这将在**级别蓝图**中创建**WalkwayLight**演员。以下截图显示了**WalkwayLight**演员正确添加到**蓝图**中：![使用触发体积打开/关闭灯光](img/B03679_03_30.jpg)
- en: You can keep the **Level Blueprint** window open, and go to the Trigger Volume
    we have created the in the level.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以保持**级别蓝图**窗口打开，并转到我们在级别中创建的触发体积。
- en: Select the Trigger Volume (**WalkwayLightTrigger**), right-click and select
    **Add Event** and then **OnActorBeginOverlap**. The following screenshot shows
    how to add **OnActorBeginOverlap** in **Level Blueprint**:![Using the Trigger
    Volume to turn on/off light](img/B03679_03_31.jpg)
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择触发体积（**WalkwayLightTrigger**），右键单击并选择**添加事件**然后**OnActorBeginOverlap**。以下截图显示了如何在**级别蓝图**中添加**OnActorBeginOverlap**：![使用触发体积打开/关闭灯光](img/B03679_03_31.jpg)
- en: To control a variable in the Point Light, we will click and drag on the tiny
    blue circle on the **WalkwayLight** node added. This creates a blue line originating
    from the tiny blue circle. This also opens up a menu, where we can see what action
    can be done to the Point Light. Enter `visi` into the search bar to display the
    options. Click on **Set Visibility**. The following screenshot shows how to add
    the **Set Visibility** function to the Point Light (**WalkwayLight**):![Using
    the Trigger Volume to turn on/off light](img/B03679_03_32.jpg)
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要控制点光源中的变量，我们将在添加的**WalkwayLight**节点上的小蓝色圆圈上点击并拖动。这会在小蓝色圆圈处创建一条蓝色线条。这还会打开一个菜单，我们可以看到可以对点光源执行哪些操作。在搜索栏中输入`visi`以显示选项。点击**设置可见性**。以下截图显示了如何将**设置可见性**功能添加到点光源（**WalkwayLight**）中：![使用触发体积打开/关闭灯光](img/B03679_03_32.jpg)
- en: Check the **New Visiblity** checkbox in the **Set Visiblity** function. The
    following screenshot shows the configuration we want:![Using the Trigger Volume
    to turn on/off light](img/B03679_03_33.jpg)
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**设置可见性**函数中勾选**新可见性**复选框。以下截图显示了我们要配置的设置：![使用触发体积打开/关闭灯光](img/B03679_03_33.jpg)
- en: Now, we are ready to link the **OnActorBeginOverlap** event to the **Set Visibility**
    function. Click and drag the white triangular box from **OnActorBeginOverlap**
    and drop it on the white triangular box at the **Set Visibility** function. The
    following screenshot shows the event correctly linked up:![Using the Trigger Volume
    to turn on/off light](img/B03679_03_34.jpg)
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已准备好将**OnActorBeginOverlap**事件链接到**设置可见性**函数。从**OnActorBeginOverlap**点击并拖动白色三角形框，并将其放置在**设置可见性**函数的白色三角形框上。以下截图显示了事件正确链接：![使用触发体积打开/关闭灯光](img/B03679_03_34.jpg)
- en: Now, build the level and play. Walk through the door from the first room to
    the second room. The light should be triggered on.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，构建关卡并播放。从第一个房间穿过门进入第二个房间。灯光应该被触发开启。
- en: But what happens when you walk back into the first room? The light remained
    turned on and nothing happens when you walk back into the second room. In the
    next example, we will go through how you can toggle the light on and off as you
    walk in and out the room. It is an alternative way to implement the control of
    the light and I shall leave it as optional for you to try it out.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 但当你走回第一个房间时会发生什么？灯光保持开启状态，当你走回第二个房间时没有任何反应。在下一个示例中，我们将介绍如何在你进出房间时切换灯光的开和关。这是一种实现灯光控制的替代方法，我将将其作为可选内容供您尝试。
- en: Using Trigger Volume to toggle light on/off (optional)
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用触发体积切换灯光开/关（可选）
- en: 'The following steps can be used to trigger volume to toggle lights on or off:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤可用于触发体积以切换灯光的开和关：
- en: We need to replace the **Set Visibility** node in **Event Graph**. Click and
    drag the blue dot from Point Light (**WalkwayLight**) and drop it onto any blank
    space. This opens up the contextual menu. The following screenshot shows the contextual
    menu to place a new node from **WalkwayLight**:![Using Trigger Volume to toggle
    light on/off (optional)](img/B03679_03_35.jpg)
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在**事件图**中替换**设置可见性**节点。点击并拖动来自点光源（**WalkwayLight**）的蓝色点，并将其拖放到任何空白空间。这会打开上下文菜单。以下截图显示了放置新节点从**WalkwayLight**的上下文菜单：![使用触发体积切换灯光开/关（可选）](img/B03679_03_35.jpg)
- en: Select **Toggle Visibility**. This creates an additional new node in **Event
    Graph**; we will need to rewire the links as per the following screenshot in order
    to link **OnActorBeginOverlap** to **Toggle Visibility**:![Using Trigger Volume
    to toggle light on/off (optional)](img/B03679_03_36.jpg)
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**切换可见性**。这将在**事件图**中创建一个额外的新的节点；我们需要根据以下截图重新连接链接，以便将**OnActorBeginOverlap**链接到**切换可见性**：![使用触发体积切换灯光开/关（可选）](img/B03679_03_36.jpg)
- en: The last step is to delete the **Set Visiblity** node and we are ready to toggle
    the light on and off as we move in and out of the room. The following screenshot
    shows the final **Event Graph** we want. Compile and play the level to see how
    you can toggle the light on and off.![Using Trigger Volume to toggle light on/off
    (optional)](img/B03679_03_37.jpg)
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是删除**设置可见性**节点，然后我们就可以在进入和离开房间时切换灯光的开和关。以下截图显示了我们想要的最终**事件图**。编译并播放关卡以查看如何切换灯光的开和关。![使用触发体积切换灯光开/关（可选）](img/B03679_03_37.jpg)
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have covered a number of very important concepts about the objects that we
    use to populate our game world in Unreal Engine 4\. We have broken one of the
    most common types of game object, Static Mesh, into its most fundamental components
    in order to understand its construction. We have also compared two types of game
    objects (Static Meshes and BSP), how they are different, and why they have their
    spot in the game. This will help you decide what kind of objects need to be created
    and how they will be created for your game level.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了一些关于我们在虚幻引擎4中用于构建游戏世界的对象的重要概念。我们将最常见的游戏对象类型之一，静态网格，分解为其最基本的组件，以便理解其结构。我们还比较了两种游戏对象类型（静态网格和BSP），它们之间的区别以及它们在游戏中的位置。这将帮助您决定需要创建哪种类型的对象以及如何为您的游戏关卡创建它们。
- en: The chapter also briefly introduced textures and materials, how they are created,
    and applied onto the meshes. We will go into more details about Materials in the
    next chapter. So you might want to read [Chapter 4](ch04.html "Chapter 4. Material
    and Light"), *Material and Light*, first before creating/applying materials to
    your newly created game objects. To help you optimize your game, this chapter
    also covered the mesh creation pipeline and the concept of LOD. For interactions
    to take place, we also needed to learn how objects interact and collide with one
    another in Unreal, what object properties are configurable to allow different
    physics interaction.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还简要介绍了纹理和材质，它们的创建方式以及如何应用到网格上。我们将在下一章更详细地介绍材质。因此，您可能想先阅读[第4章](ch04.html "第4章。材质和灯光")，*材质和灯光*，然后再创建/应用材质到您新创建的游戏对象上。为了帮助您优化游戏，本章还涵盖了网格创建流程和LOD的概念。为了进行交互，我们还需要学习在虚幻中对象如何相互交互和碰撞，以及哪些对象属性可以配置以允许不同的物理交互。
- en: This chapter also covered our first introduction to Blueprint, the graphical
    scripting of Unreal Engine4\. Through a simple Blueprint example, we learned how
    to turn on and off lights for our level using one of the many useful volumes that
    are in Unreal, Trigger Volume. In the next chapter, we will continue to build
    on the level we have created with more exciting materials and lights.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还介绍了我们对蓝图的第一印象，即Unreal Engine 4的图形脚本。通过一个简单的蓝图示例，我们学习了如何使用Unreal中众多有用的体积之一——触发体积（Trigger
    Volume），来为我们的关卡打开和关闭灯光。在下一章中，我们将继续使用更多令人兴奋的材料和灯光来构建我们已创建的关卡。
