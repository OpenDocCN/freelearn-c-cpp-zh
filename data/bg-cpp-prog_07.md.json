["```cpp\n    class os_file \n    { \n        const string file_name; \n        int file_handle; \n        // other data members \n    public: \n        long get_size_in_bytes(); \n        // other methods \n    };\n```", "```cpp\n    class mp3_file : public os_file \n    { \n        long length_in_secs; \n        // other data members \n    public: \n        long get_length_in_seconds(); \n        // other methods \n    };\n```", "```cpp\n    class os_file \n    { \n    public: \n        os_file(const string& name)  \n            : file_name(name), file_handle(open_file(name)) \n        {} \n        ~os_file() { close_file(file_handle); } \n    }; \n\n    class mp3_file : public os_file \n    { \n    public: \n        mp3_file(const string& name) : os_file(name) {} \n        ~mp3_file() { /* clean up mp3 stuff*/ } \n    };\n```", "```cpp\n    struct base \n    { \n        void f(){ /* do something */ } \n        void g(){ /* do something */ } \n    }; \n\n    struct derived : base \n    { \n        void f() \n        { \n            base::f(); \n            // do more stuff \n        } \n    };\n```", "```cpp\n    derived d; \n    d.f(); // calls derived::f \n    d.g(); // calls base::g\n```", "```cpp\n    struct derived : base \n    { \n        void f(int i) \n        { \n            base::f(); \n            // do more stuff with i \n        } \n    };\n```", "```cpp\n    derived d; \n    d.f(42); // OK \n    d.f();   // won't compile, derived::f(int) hides base::f\n```", "```cpp\n    derived d; \n    d.derived::f(42); // same call as above \n    d.base::f();      // call base class method \n    derived *p = &d;  // get an object pointer \n    p->base::f();     // call base class method \n    delete p;\n```", "```cpp\n    // bad code \n    void print_y(base *pb) \n    { \n       // be wary of this \n       derived *pd = static_cast<derived*>(pb); \n       cout << \"y = \" << pd->y << endl; \n    } \n\n    void f() \n    { \n       derived d; \n       print_y(&d); // implicit cast to base* \n    }\n```", "```cpp\n    class base \n    { \n    protected: \n        void test(); \n    }; \n\n    class derived : public base \n    { \n    public: \n        void f() { test(); } \n    };\n```", "```cpp\n    base b; \n    b.test();  // won't compile \n    derived d; \n    d.f();     // OK \n    d.test();  // won't compile\n```", "```cpp\n    class base \n    { \n    public: \n        // methods available through the derived object \n        protected: \n        ~base(){} \n    };\n```", "```cpp\n    class base \n    { \n        protected: \n        void f(); \n    public: \n        void g(); \n    }; \n\n    class derived : public base \n    { \n    public: \n        void f(); \n        protected: \n        void g(); \n    };\n```", "```cpp\n    class base \n    { \n    protected: \n        void f(){ /* code */}; \n    }; \n\n    class derived: public base \n    { \n    public: \n        using base::f; \n    };\n```", "```cpp\n    class base \n    { \n    public: \n        void f(); \n    }; \n\n    class derived: public base \n    { \n    protected: \n        using base::f; \n    };\n```", "```cpp\n    base b; \n    b.f(); // OK \n    derived d; \n    d.f(); // won't compile\n```", "```cpp\n    class derived: public base \n    { \n    public: \n        void f() = delete; \n\n        void g() \n        { \n            base::f(); // call the base class method \n        } \n    };\n```", "```cpp\n    class base1 { public: void a(); }; \n    class base2 { public: void b(); }; \n    class derived : public base1, public base2  \n    { \n    public: \n        // gets a and b \n    };\n```", "```cpp\n    class base1 { public: int x = 1; }; \n    class base2 { public: int x = 2; }; \n    class derived : public base1, public base2 {};\n```", "```cpp\n    derived d; \n    cout << d.base1::x << endl; // the base1 version \n    cout << d.base2::x << endl; // the base2 version\n```", "```cpp\n    class base1 { public: void a(int); }; \n    class base2 { public: void a(); }; \n    class derived : public base1, public base2 {};\n```", "```cpp\n    derived d; \n    d.a();          // should be a from base2, compiler still complains\n```", "```cpp\n    derived d; \n    d.base1::a(42); // the base1 version \n    d.base2::a();   // the base2 version\n```", "```cpp\n    struct base { /*members*/ }; \n    struct derived : base { /*members*/ }; \n\n    derived d; \n    base b1 = d; // slicing through the copy constructor   \n    base b2; \n    b2 = d;      // slicing through assignment\n```", "```cpp\n    void f(base b) \n    { \n        // can only access the base members \n    }\n```", "```cpp\n    class base { /*members*/ }; \n    class derived1 : public base { /*members*/ }; \n    class derived2 : public base { /*members*/ }; \n    class derived3 : public base { /*members*/ };\n```", "```cpp\n    struct base  \n    {  \n        void who() { cout << \"base \"; }  \n    }; \n    struct derived1 : base  \n    {  \n        void who() { cout << \"derived1 \"; }  \n    }; \n    struct derived2 : base \n    { \n        void who() { cout << \"derived2 \"; } \n    }; \n    struct derived3 : derived2 \n    { \n        void who() { cout << \"derived3 \"; } \n    }; \n\n    void who_is_it(base& r) \n    { \n        p.who(); \n    } \n\n    int main() \n    { \n        derived1 d1; \n        who_is_it(d1); \n        derived2 d2; \n        who_is_it(d2); \n        derived3 d3; \n        who_is_it(d3); \n        cout << endl; \n        return 0; \n    }\n```", "```cpp\n    base base base\n```", "```cpp\n    struct base \n    { \n virtual void who() { cout << \"base \"; } \n    };\n```", "```cpp\n     derived1 derived2 derived3\n```", "```cpp\n    derived1 d1; \n    derived2 d2; \n    derived3 d3; \n\n    base *arr[] = { &d1, &d2, &d3 }; \n    for (auto p : arr) p->who(); \n    cout << endl;\n```", "```cpp\n     derived1 derived2 derived3\n```", "```cpp\n    derived1 d1; \n    derived2 d2; \n    derived3 d3; \n    vector<base> vec = { d1, d2, d3 }; \n    for (auto b : vec) b.who(); \n    cout << endl;\n```", "```cpp\n    vector<base&> vec;\n```", "```cpp\n    vector<reference_wrapper<base> > vec = { d1, d2, d3 }; \n    for (auto b : vec) b.get().who(); \n    cout << endl;\n```", "```cpp\n    class base \n    {\n        int x = 0; \n    public: \n        friend ostream& operator<<(ostream& stm, const base& b) \n        { \n            // thru b we can access the base private/protected members \n            stm << \"base: \" << b.x << \" \"; \n            return stm; \n        } \n    };\n```", "```cpp\n    class base \n    { \n        int x = 0;  \n        protected: \n        virtual void output(ostream& stm) const { stm << x << \" \"; } \n    public: \n        friend ostream& operator<<(ostream& stm, const base& b) \n        { \n            b.output(stm); \n            return stm; \n        } \n    }; \n\n    class derived : public base \n    { \n        int y = 0; \n    protected: \n        virtual void output(ostream& stm) const \n        { \n            base::output(stm); \n            stm << y << \" \"; \n        } \n    };\n```", "```cpp\n    struct base  \n    {  \n        virtual int f(int i);  \n    }; \n\n    struct derived: base  \n    {  \n        virtual int f(short i) override; \n    };\n```", "```cpp\n    class complete final { /* code */ }; \n    class extend: public complete{}; // won't compile\n```", "```cpp\n    struct base { int x = 0; }; \n    struct derived1 : base { /*members*/ }; \n    struct derived2 :  base { /*members*/ }; \n    struct most_derived : derived1, derived2 { /*members*/ };\n```", "```cpp\n    struct derived1 : virtual base { /*members*/ }; \n    struct derived2 : virtual base { /*members*/ };\n```", "```cpp\n    derived1::derived1() : base(){} \n    derived2::derived2() : base(){} \n    most_derived::most_derived() : derived1(), derived2(), base(){}\n```", "```cpp\n    struct abstract_base \n    { \n virtual void f() = 0; \n        void g() \n        { \n            cout << \"do something\" << endl; \n            f(); \n        } \n    };\n```", "```cpp\n    abstract_base b;\n```", "```cpp\n    void call_it(abstract_base& r) \n    { \n        r.g(); \n    }\n```", "```cpp\n    void call_it2(abstract_base& r) \n    { \n        r.f(); \n    }\n```", "```cpp\n    struct derived1 : abstract_base \n    { \n        virtual void f() override { cout << \"derived1::f\" << endl; } \n    }; \n\n    struct derived2 : abstract_base \n    { \n        virtual void f() override { cout << \"derived2::f\" << endl; } \n    };\n```", "```cpp\n    derived1 d1; \n    call_it(d1); \n    derived2 d2; \n    call_it(d2);\n```", "```cpp\n    struct abstract_base \n    { \n        virtual int h() = 0 { return 42; } \n    };\n```", "```cpp\n    struct derived : abstract_base \n    { \n        virtual int h() override { return abstract_base::h() * 10; } \n    };\n```", "```cpp\n    string str = \"hello\"; \n    const type_info& ti = typeid(str); \n    cout << ti.name() << endl;\n```", "```cpp\n    class std::basic_string<char,struct std::char_traits<char>,\n class std::allocator<char> >\n```", "```cpp\n    struct base {}; \n    struct derived { void f(); }; \n\n    void call_me(base *bp) \n    { \n        derived *dp = (typeid(*bp) == typeid(derived))  \n            ? static_cast<derived*>(bp) : nullptr; \n        if (dp != nullptr) dp->f(); \n    } \n\n    int main() \n    { \n        derived d; \n        call_me(&d); \n        return 0; \n    }\n```", "```cpp\n    void call_me(base *bp) \n    { \n        derived *dp = dynamic_cast<derived*>(bp); \n        if (dp != nullptr) dp->f(); \n    }\n```", "```cpp\n    struct base1 { void f(); }; \n    struct base2 { void g(); }; \n    struct derived : base1, base2 {};\n```", "```cpp\n    void call_me(base1 *b1)  \n    { \n        base2 *b2 = dynamic_cast<base2*>(b1); \n        if (b2 != nullptr) b2->g(); \n    }\n```", "```cpp\n    struct base  \n    {  \n        Virtual ~base() {} \n        virtual void who() = 0;  \n    }; \n\n    struct derived : base  \n    {  \n        virtual void who() { cout << \"derivedn\"; }  \n    };\n```", "```cpp\n    // both of these are acceptable \n    shared_ptr<base> b_ptr1(new derived);  \n    shared_ptr<base> b_ptr2 = make_shared<derived>();\n```", "```cpp\n    shared_ptr<base> b_ptr(new derived); \n    b_ptr->who(); // prints \"derived\"\n```", "```cpp\n    struct base1  \n    {  \n        Virtual ~base1() {} \n        virtual void who() = 0;  \n    }; \n\n    struct base2  \n    {  \n        Virtual ~base2() {} \n        virtual void what() = 0;  \n    }; \n\n    struct derived : base1, base2  \n    {  \n        virtual void who()  { cout << \"derivedn\"; }  \n        virtual void what() { cout << \"derivedn\"; }  \n    };\n```", "```cpp\n    shared_ptr<derived> d_ptr(new derived); \n    d_ptr->who(); \n    d_ptr->what(); \n\n    base1 *b1_ptr = d_ptr.get(); \n    b1_ptr->who(); \n    base2 *b2_ptr = dynamic_cast<base2*>(b1_ptr); \n    b2_ptr->what();\n```", "```cpp\n    shared_ptr<base1> b1_ptr(d_ptr.get());\n```", "```cpp\n    #define interface struct \n\n    interface IPrint \n    { \n        virtual void set_page(/*size, orientation etc*/) = 0; \n        virtual void print_page(const string &str) = 0; \n    };\n```", "```cpp\n    class inkjet_printer : public IPrint \n    { \n    public: \n        virtual void set_page(/*size, orientation etc*/) override \n        { \n            // set page properties \n        } \n        virtual void print_page(const string &str) override \n        { \n            cout << str << endl; \n        } \n    }; \n\n    void print_doc(IPrint *printer, vector<string> doc);\n```", "```cpp\n    inkjet_printer inkjet; \n    IPrint *printer = &inkjet; \n    printer->set_page(/*properties*/); \n    vector<string> doc {\"page 1\", \"page 2\", \"page 3\"}; \n    print_doc(printer, doc);\n```", "```cpp\n    interface IScan \n    { \n        virtual void set_page(/*resolution etc*/) = 0; \n        virtual string scan_page() = 0; \n    };\n```", "```cpp\n    class inkjet_printer : public IPrint, public IScan \n    { \n    public: \n        virtual void IPrint::set_page(/*etc*/) override { /*etc*/ } \n        virtual void print_page(const string &str) override \n        { \n            cout << str << endl; \n        } \n        virtual void IScan::set_page(/*etc*/) override { /*etc*/ } \n        virtual string scan_page() override \n        { \n            static int page_no; \n            string str(\"page \"); \n            str += to_string(++page_no); \n            return str; \n        } \n    }; \n\n    void scan_doc(IScan *scanner, int num_pages);\n```", "```cpp\n    inkjet_printer inkjet; \n    IScan *scanner = &inkjet; \n    scanner->set_page(/*properties*/); \n    scan_doc(scanner, 5);\n```", "```cpp\n    IPrint *printer = dynamic_cast<IPrint*>(scanner); \n    if (printer != nullptr) \n    { \n        printer->set_page(/*properties*/); \n        vector<string> doc {\"page 1\", \"page 2\", \"page 3\"}; \n        print_doc(printer, doc); \n    }\n```", "```cpp\n    interface IPrint2 : IPrint \n    { \n        virtual void print_doc(const vector<string> &doc) = 0; \n    };\n```", "```cpp\n class inkjet_printer : public IPrint2, public IScan \n    { \n    public: \n virtual void print_doc(const vector<string> &doc) override { \n            /* code*/\n        } \n        // other methods \n    };\n```", "```cpp\n    // Library code \n    template <typename BASE> \n    class mixin : public BASE \n    { \n    public: \n        void something() \n        { \n            cout << \"mixin do something\" << endl; \n            BASE::something(); \n            cout << \"mixin something else\" << endl; \n        } \n    }; \n\n    // Client code to adapt the mixin class \n    class impl  \n    { \n    public: \n        void something() \n        { \n            cout << \"impl do something\" << endl; \n        } \n    };\n```", "```cpp\n    mixin<impl> obj; \n    obj.something();\n```", "```cpp\n    mixin do something\nimpl do something\nmixin something else\n```", "```cpp\n    template <typename BASE> \n    class mixin2 : public BASE \n    { \n    public: \n        void something() \n        { \n            cout << \"mixin2 do something\" << endl; \n            BASE::something(); \n            cout << \"mixin2 something else\" << endl; \n        } \n    };\n```", "```cpp\n    mixin2< mixin<impl> > obj; \n    obj.something();\n```", "```cpp\n    mixin2 do something\nmixin do something\nimpl do something\nmixin something else \nmixin2 something else\n```", "```cpp\n    mixin2< mixin<impl> > obj; \n    obj.impl::init(/* parameters */);  // call impl::init \n    obj.mixin::init(/* parameters */); // call mixin::init \n    obj.init(/* parameters */);        // call mixin2::init \n    obj.something();\n```", "```cpp\n    #include <iostream> \n    #include <string> \n    #include <vector> \n    #include <fstream> \n    #include <memory> \n    using namespace std;\n```", "```cpp\n    int main(int argc, const char *argv[]) \n    { \n        return 0;  \n    }\n```", "```cpp\n    #define interface struct\n```", "```cpp\n    interface IWork \n    { \n        virtual const char* get_name() = 0; \n        virtual const char* get_position() = 0; \n        virtual void do_work() = 0; \n    }; \n\n    interface IManage \n    { \n        virtual const vector<unique_ptr<IWork>>& get_team() = 0; \n        virtual void manage_team() = 0; \n    }; \n\n    interface IDevelop  \n    { \n        virtual void write_code() = 0; \n    };\n```", "```cpp\n    class worker : public IWork \n    { \n        string name; \n        string position; \n    public: \n        worker() = delete; \n        worker(const char *n, const char *p) : name(n), position(p) {} \n        virtual ~worker() {} \n        virtual const char* get_name() override  \n        { return this->name.c_str(); } \n        virtual const char* get_position() override  \n        { return this->position.c_str(); } \n        virtual void do_work() override { cout << \"works\" << endl; } \n    };\n```", "```cpp\n    class manager : public worker, public IManage \n    { \n        vector<unique_ptr<IWork>> team; \n    public: \n        manager() = delete; \n        manager(const char *n, const char* p) : worker(n, p) {} \n        const vector<unique_ptr<IWork>>& get_team() { return team; } \n        virtual void manage_team() override  \n        { cout << \"manages a team\" << endl; } \n        void add_team_member(IWork* worker) \n        { team.push_back(unique_ptr<IWork>(worker)); } \n        virtual void do_work() override { this->manage_team(); } \n    };\n```", "```cpp\n    class project_manager : public manager \n    { \n    public: \n        project_manager() = delete; \n        project_manager(const char *n) : manager(n, \"Project Manager\") \n        {} \n        virtual void manage_team() override  \n        { cout << \"manages team of developers\" << endl; } \n    };\n```", "```cpp\n    project_manager pm(\"Agnes\"); \n    pm.add_team_member(new worker(\"Bill\", \"Developer\")); \n    pm.add_team_member(new worker(\"Chris\", \"Developer\")); \n    pm.add_team_member(new worker(\"Dave\", \"Developer\")); \n    pm.add_team_member(new worker(\"Edith\", \"DBA\"));\n```", "```cpp\n    void print_team(IWork *mgr) \n    { \n        cout << mgr->get_name() << \" is \"  \n             << mgr->get_position() << \" and \"; \n        IManage *manager = dynamic_cast<IManage*>(mgr); \n        if (manager != nullptr) \n        { \n            cout << \"manages a team of: \" << endl; \n            for (auto team_member : manager->get_team()) \n            { \n                cout << team_member->get_name() << \" \" \n                     << team_member->get_position() << endl; \n            } \n        } \n        else { cout << \"is not a manager\" << endl; } \n    }\n```", "```cpp\n    print_team(&pm)\n```", "```cpp\n Agnes is Project Manager and manages a team of:\n Bill Developer\n Chris Developer\n Dave Developer\n Edith DBA\n```", "```cpp\n    class cpp_developer : public worker, public IDevelop \n    { \n    public: \n        cpp_developer() = delete; \n        cpp_developer(const char *n) : worker(n, \"C++ Dev\") {} \n        void write_code() { cout << \"Writing C++ ...\" << endl; } \n        virtual void do_work() override { this->write_code(); } \n    }; \n\n    class database_admin : public worker, public IDevelop \n    { \n    public: \n        database_admin() = delete; \n        database_admin(const char *n) : worker(n, \"DBA\") {} \n        void write_code() { cout << \"Writing SQL ...\" << endl; } \n        virtual void do_work() override { this->write_code(); } \n    };\n```", "```cpp\n    project_manager pm(\"Agnes\"); \n    pm.add_team_member(new cpp_developer(\"Bill\")); \n    pm.add_team_member(new cpp_developer(\"Chris\")); \n    pm.add_team_member(new cpp_developer(\"Dave\")); \n    pm.add_team_member(new database_admin(\"Edith\")); \n    print_team(&pm);\n```", "```cpp\n    #define interface struct \n\n interface IWork; \n    // forward declaration interface ISerializer { virtual void write_string(const string& line) = 0; virtual void write_worker(IWork *worker) = 0; virtual void write_workers ( const vector<unique_ptr<IWork>>& workers) = 0; }; interface ISerializable { virtual void serialize(ISerializer *stm) = 0; };\n```", "```cpp\n    class file_writer : public ISerializer \n    { \n        ofstream stm; \n    public: \n        file_writer() = delete; \n        file_writer(const char *file) { stm.open(file, ios::out); } \n        ~file_writer() { close(); } \n        void close() { stm.close(); } \n        virtual void write_worker(IWork *worker) override \n        { \n            ISerializable *object = dynamic_cast<ISerializable*>(worker); \n            if (object != nullptr) \n            { \n                ISerializer *serializer = dynamic_cast<ISerializer*>(this); \n                serializer->write_string(typeid(*worker).raw_name()); \n         object->serialize(serializer); \n            } \n        } \n        virtual void write_workers( \n        const vector<unique_ptr<IWork>>& workers) override \n        { \n            write_string(\"[[\"); \n            for (const unique_ptr<IWork>& member : workers) \n            { \n                write_worker(member.get()); \n            } \n            write_string(\"]]\"); // end marker of team \n        } \n        virtual void write_string(const string& line) override \n        { \n            stm << line << endl; \n        } \n    };\n```", "```cpp\n    class worker : public IWork, public ISerializable\n```", "```cpp\n    virtual void serialize(ISerializer *stm) override \n    { \n        stm->write_string(name); \n        stm->write_string(position); \n    }\n```", "```cpp\n    virtual void serialize(ISerializer* stm) override \n    { worker::serialize(stm); }\n```", "```cpp\n    virtual void serialize(ISerializer* stm) override \n    { manager::serialize(stm); }\n```", "```cpp\n    virtual void serialize(ISerializer* stm) override \n    { \n        worker::serialize(stm); \n        stm->write_workers(this->team); \n    }\n```", "```cpp\n    void serialize(const char* file) \n    { \n        project_manager pm(\"Agnes\"); \n        pm.add_team_member(new cpp_developer(\"Bill\")); \n        pm.add_team_member(new cpp_developer(\"Chris\")); \n        pm.add_team_member(new cpp_developer(\"Dave\")); \n        pm.add_team_member(new database_admin(\"Edith\")); \n        print_team(&pm); \n\n        cout << endl << \"writing to \" << file << endl; \n\n        file_writer writer(file); \n        ISerializer* ser = dynamic_cast<ISerializer*>(&writer); \n        ser->write_worker(&pm); \n        writer.close(); \n    }\n```", "```cpp\n    void usage() \n    { \n        cout << \"usage: team_builder file [r|w]\" << endl; \n        cout << \"file is the name of the file to read or write\" << endl; \n        cout << \"provide w to file the file (the default)\" << endl; \n        cout << \"        r to read the file\" << endl; \n    } \n\n    int main(int argc, char* argv[]) \n    { \n        if (argc < 2) \n        { \n            usage(); \n            return 0; \n        } \n\n        bool write = true; \n        const char *file = argv[1]; \n        if (argc > 2) write = (argv[2][0] == 'w'); \n\n        cout << (write ? \"Write \" : \"Read \") << file << endl << endl; \n\n        if (write) serialize(file); \n        return 0; \n    }\n```", "```cpp\n    team_builder cpp_team.txt w\n```", "```cpp\n    .?AVproject_manager@@ \n    Agnes \n    Project Manager \n    [[ \n    .?AVcpp_developer@@ \n    Bill \n    C++ Dev \n    .?AVcpp_developer@@ \n    Chris \n    C++ Dev \n    .?AVcpp_developer@@ \n    Dave \n    C++ Dev \n    .?AVdatabase_admin@@ \n    Edith \n    DBA \n    ]]\n```", "```cpp\n    interface IDeserializer \n    { \n        virtual string read_string() = 0; \n        virtual unique_ptr<IWork> read_worker() = 0; \n        virtual void read_workers(vector<unique_ptr<IWork>>& team) = 0; \n    };\n```", "```cpp\n    worker(IDeserializer *stm) \n    { \n        name = stm->read_string(); \n        position = stm->read_string(); \n    }\n```", "```cpp\n    cpp_developer(IDeserializer* stm) : worker(stm) {}\n```", "```cpp\n    manager(IDeserializer* stm) : worker(stm) \n    { stm->read_workers(this->team); }\n```", "```cpp\n    project_manager(IDeserializer* stm) : manager(stm) {}\n```", "```cpp\n    class file_reader : public IDeserializer \n    { \n        ifstream stm; \n    public: \n        file_reader() = delete; \n        file_reader(const char *file) { stm.open(file, ios::in); } \n        ~file_reader() { close(); } \n        void close() { stm.close(); } \n        virtual unique_ptr<IWork> read_worker() override; \n        virtual void read_workers( \n            vector<unique_ptr<IWork>>& team) override; \n        virtual string read_string() override \n        { \n            string line; \n            getline(stm, line); \n            return line; \n        } \n    };\n```", "```cpp\n    unique_ptr<IWork> file_reader::read_worker() \n    { \n    } \n    void file_reader::read_workers(vector<unique_ptr<IWork>>& team) \n    { \n        while (true) \n        { \n            unique_ptr<IWork> worker = read_worker(); \n            if (!worker) break; \n            team.push_back(std::move(worker)); \n        } \n    }\n```", "```cpp\n    unique_ptr<IWork> file_reader::read_worker() \n    { \n        string type = read_string(); \n        if (type == \"[[\") type = read_string(); \n        if (type == \"]]\") return nullptr; \n        if (type == typeid(worker).raw_name()) \n        { \n            return unique_ptr<IWork>( \n            dynamic_cast<IWork*>(new worker(this))); \n        }    \n        return nullptr; \n    }\n```", "```cpp\n    if (type == typeid(project_manager).raw_name()) \n    { \n        return unique_ptr<IWork>( \n        dynamic_cast<IWork*>(new project_manager(this))); \n    } \n    if (type == typeid(cpp_developer).raw_name()) \n    { \n        return unique_ptr<IWork>( \n        dynamic_cast<IWork*>(new cpp_developer(this))); \n    } \n    if (type == typeid(database_admin).raw_name()) \n    { \n        return unique_ptr<IWork>( \n        dynamic_cast<IWork*>(new database_admin(this))); \n    }\n```", "```cpp\n    void deserialize(const char* file) \n    { \n        file_reader reader(file); \n        while (true) \n        { \n            unique_ptr<IWork> worker = reader.read_worker(); \n            if (worker) print_team(worker.get()); \n            else break; \n        } \n        reader.close(); \n    }\n```", "```cpp\n    cout << (write ? \"Write \" : \"Read \") << file << endl << endl; \n    if (write) serialize(file); \n else deserialize(file);\n```", "```cpp\n    team_builder cpp_team.txt r\n```"]