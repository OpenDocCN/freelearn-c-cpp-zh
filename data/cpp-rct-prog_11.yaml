- en: Design Patterns and Idioms for C++ Rx Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ Rx编程的设计模式和成语
- en: We have covered quite a bit of ground in using reactive programming model with
    C++. So far, we have learned about the RxCpp library and its programming model,
    key elements of the RxCpp library, reactive GUI programming and the topic of writing 
    custom Operators. Now, to take the matter to the next level, we will cover some
    Design patterns and Idioms which help us in advanced software development tasks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在使用C++的响应式编程模型方面取得了相当大的进展。到目前为止，我们已经了解了RxCpp库及其编程模型、RxCpp库的关键元素、响应式GUI编程以及编写自定义操作符的主题。现在，为了将问题提升到下一个级别，我们将涵盖一些设计模式和成语，这些模式和成语有助于我们进行高级软件开发任务。
- en: 'In this chapter, we will cover following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: An introduction to patterns and the pattern movement
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式和模式运动的介绍
- en: GOF design patterns and reactive programming
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GOF设计模式和响应式编程
- en: Some reactive programming patterns and idioms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些响应式编程模式和成语
- en: The OOP and Design patterns movement
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程和设计模式运动
- en: The **Object Oriented Programming** (**OOP**)  reached critical mass in early
    90s when the C++ programming language began to make inroads into  areas where
    C programming language  was the primary programming language.  After the advent
    of Microsoft C++ compiler in the year 1992 ,  followed by Microsoft Foundation
    Class (MFC)  library, the C++ programming became mainstream under Microsoft Windows.
    In the  POSIX world,  C++ GUI toolkits like WxWidgets, and Qt,signaled the arrival
    of OOP.   The early pioneers of the  OOP movement wrote articles in various magazines
    like Dr. Dobb's Journal , C++ Report  ,Microsoft Systems Journal and so on., to
    propagate their ideas.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在90年代初，面向对象编程（OOP）达到了临界点，当时C++编程语言开始在C编程语言是主要编程语言的领域中取得进展。1992年微软C++编译器的出现，随后是微软基础类（MFC）库，使C++编程成为了微软Windows下的主流。在POSIX世界中，C++
    GUI工具包如WxWidgets和Qt，标志着面向对象编程的到来。面向对象编程运动的早期先驱者在各种杂志上写文章，如《Dr. Dobb's Journal》、《C++
    Report》、《Microsoft Systems Journal》等，以传播他们的想法。
- en: James Coplien published an influential book titled *Advanced C++ Styles and
    Idioms*, which dealt with the low-level patterns (idioms) associated with usage
    of the C++ programming language. Even though it is not widely cited, authors of
    this  book consider it as a  notable book for cataloging best practices and techniques
    of OOP.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 詹姆斯·科普利恩出版了一本有影响力的书，名为《高级C++风格和成语》，讨论了与C++编程语言的使用相关的低级模式（成语）。尽管它并不被广泛引用，但这本书的作者们认为它是一本记录面向对象编程最佳实践和技术的重要书籍。
- en: 'Erich Gamma began to work on a pattern catalog as part of his Ph.D. thesis,
    getting inspiration from  Christopher Alexander''s *A Pattern of Towns and building* 
    book.  While working on the thesis, people with similar thoughts, namely Ralph
    Johnson, John Vlissides, and Richard Helm, joined hands with Erich Gamma to create
    a catalog of 23 Design patterns, now known as **Gang of Four** (**GOF**) Design
    patterns. The Addison Wesley published the book *Design Patterns : Elements of
    Reusable Object-Oriented Software* in the year  1994, based on their work. This
    soon became a great reference for programmers, and fueled pattern oriented software
    development. The GOF catalog was mostly focused on software design and soon pattern
    catalogs began to appear in areas like architecture,enterprise application integration,
    enterprise application architecture and so on.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 埃里希·伽玛开始在他的博士论文中编写模式目录，从克里斯托弗·亚历山大的《城镇和建筑的模式》一书中获得灵感。在论文的过程中，有类似想法的人，即拉尔夫·约翰逊、约翰·弗利西德斯和理查德·赫尔姆，与埃里希·伽玛一起创建了一个包含23种设计模式的目录，现在被称为**四人帮**（**GOF**）设计模式。Addison
    Wesley在1994年出版了基于他们工作的书籍《设计模式：可重用面向对象软件的元素》。这很快成为程序员的重要参考，并推动了面向模式的软件开发。GOF目录主要集中在软件设计上，很快模式目录开始出现在建筑、企业应用集成、企业应用架构等领域。
- en: In 1996, a group of engineers from Siemens published the book, *Pattern Oriented
    Software Architecture (POSA)*, which mainly focused on architectural aspects of
    building a system. The entire POSA pattern catalog was documented in five books,
    published by John Wiley and Sons. A flood of activity followed the two preceding
    initiatives. Other notable  pattern catalogs are given below
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 1996年，西门子的一群工程师出版了《面向模式的软件架构（POSA）》一书，主要关注系统建设的架构方面。整个POSA模式目录被记录在由约翰·威利和儿子出版的五本书中。在这两项倡议之后，出现了一大波活动。其他值得注意的模式目录如下
- en: '*Patterns of Enterprise Application Architecture*, by Martin Fowler, et al.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《企业应用架构模式》，作者马丁·福勒等。
- en: '*Enterprise Integration Patterns*, by Gregor Hope and Boby Wulf.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《企业集成模式》，作者格雷戈尔·霍普和鲍比·沃尔夫。
- en: '*Core J2EE Patterns*, by Deepak Alur, et al.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《核心J2EE模式》，作者迪帕克·阿卢等。
- en: '*Domain Driven Design*, by Eric Evans.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《领域驱动设计》，作者埃里克·埃文斯。
- en: '*The Enterprise Patterns and the MDA*, by Jim Arlow and Illa Neustadt.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《企业模式和MDA》，作者吉姆·阿洛和伊拉·纽斯塔特。
- en: Even though these books were significant in their own right, they were skewed
    towards the then-burgeoning area of enterprise software development. For C++ developers,
    the GOF catalog and POSA catalog are the most important.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些书在自己的领域内具有重要意义，但它们偏向于当时蓬勃发展的企业软件开发领域。对于C++开发人员，GOF目录和POSA目录是最重要的。
- en: Key Pattern catalogs
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关键模式目录
- en: A pattern is a named solution for a commonly occurring problem in software design.
    Patterns are most often cataloged in some kind of repository. Some of them are
    published as books. The most popular and widely used pattern catalog is GOF.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 模式是软件设计中常见问题的命名解决方案。模式通常被编入某种存储库。其中一些被出版成书。最受欢迎和广泛使用的模式目录是GOF。
- en: The GOF catalog
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GOF目录
- en: The Gang of Four (GOF), named after creators of the catalog, started the pattern
    movement. The creators were mostly focused on design and architecture of  object
    oriented software. The ideas of Christopher Alexander were borrowed from building
    architecture and applied   to software engineering .Soon, people began pattern
    initiatives in  the area of  application architecture, concurrency, security,
    and so on. The Gang Of Four divided the catalog into structural, creational, and
    behavioral patterns. The original book used C++ and Smalltalk for explaining the
    concepts. These patterns have been ported and leveraged in most of the OOP languages
    that exist  today. The table below lists patterns from the GOF catalog.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Gang of Four（GOF）以目录的创建者命名，开始了模式运动。创建者们主要关注面向对象软件的设计和架构。克里斯托弗·亚历山大的想法从建筑架构中借鉴并应用到软件工程中。很快，人们开始在应用架构、并发、安全等领域进行模式倡议。Gang
    Of Four将目录分为结构、创建和行为模式。原始书籍使用C++和Smalltalk来解释这些概念。这些模式已经被移植并在今天存在的大多数面向对象的编程语言中得到利用。下表列出了GOF目录中的模式。
- en: '| **Sl. No.** | **Pattern Type** | **Patterns** |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| **序号** | **模式类型** | **模式** |'
- en: '| 1 | Creational patterns | Abstract Factory, Builder, Factory Method, Prototype,
    Singleton |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 创建模式 | 抽象工厂，生成器，工厂方法，原型，单例 |'
- en: '| 2 | Structural patterns | Adapter, Bridge, Composite, Decorator, Facade,
    Flyweight, Proxy |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 结构模式 | 适配器，桥接，组合，装饰器，外观，享元，代理 |'
- en: '| 3 | Behavioral patterns | Chain of Responsibility, Command, Interpreter,
    Iterator, Mediator, Memento, Observer , State, Strategy, Template Method, Visitor
    |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 行为模式 | 责任链，命令，解释器，迭代器，中介者，备忘录，观察者，状态，策略，模板方法，访问者 |'
- en: We believe that a good understanding of GOF patterns is necessary for any programmer.
    These patterns occur everywhere, regardless of the application domain. GOF patterns
    help us to communicate and reason about  software systems in a language agnostic
    manner. They are widely implemented in the C++, .NET and Java worlds. The Qt framework
    leverages patterns in the GOF repository extensively, for giving an intuitive
    programming model in the C++ programming language., primarily for writing GUI
    applications.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为对GOF模式的深入理解对于任何程序员都是必要的。这些模式无论在应用领域如何，都随处可见。GOF模式帮助我们以一种与语言无关的方式来交流和推理软件系统。它们在C++、.NET和Java世界中得到广泛实现。Qt框架广泛利用了GOF存储库中的模式，为C++编程语言提供了直观的编程模型，主要用于编写GUI应用程序。
- en: The POSA catalog
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POSA目录
- en: '*Patterns of Software Architecture* (five volumes) is an influential book series,
    which covers most of the applicable patterns for developing mission critical systems.
    The catalog is good for people who write mission critical sub-systems of large
    software, especially database engines, distributed systems, middleware systems,
    and so on. Another advantage of the catalog is that it is well suited for C++
    programmers.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*软件架构模式*（五卷）是一本有影响力的书系，涵盖了开发关键任务系统的大部分适用模式。该目录适合编写大型软件的关键子系统的人，特别是数据库引擎、分布式系统、中间件系统等。该目录的另一个优点是非常适合C++程序员。'
- en: The catalog, which spans five published volumes, is worthy of independent study.
    This catalog is quite handy if we want to write Industrial strength middleware
    software like web server, protocol servers ,database servers and so on.    The
    following table contains a list of pattern types and associated patterns
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 该目录共有五卷，值得独立研究。如果我们想要编写像Web服务器、协议服务器、数据库服务器等工业强度的中间件软件，这个目录非常方便。以下表格包含了一系列模式类型和相关模式
- en: '| **Sl. No.** | **Pattern Type** | **Patterns** |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **序号** | **模式类型** | **模式** |'
- en: '| 1 | Architectural | Layers, Pipes and Filters, Blackboard, Broker, MVC, Presentation-Abstraction-Control,
    Microkernel, Reflection |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 架构 | 层，管道和过滤器，黑板，经纪人，MVC，表示-抽象-控制，微内核，反射 |'
- en: '| 2 | Design | Whole-Part, Mater-Slave, Proxy, Command Processor, View Handler,
    Forwarder-Receiver, Client-Dispatcher-Server, Publisher-Subscriber |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 设计 | 整体-部分，主从，代理，命令处理器，视图处理器，转发-接收器，客户端-调度器-服务器，发布者-订阅者 |'
- en: '| 3 | Service access and configuration patterns | Wrapper Façade, Component
    Configurator, Interceptor, Extension Interface |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 服务访问和配置模式 | 包装器外观，组件配置器，拦截器，扩展接口 |'
- en: '| 4 | Event handling patterns | Reactor, Proactor, Asynchronous Completion
    Token, Acceptor-Connector |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 事件处理模式 | 反应器，主动器，异步完成令牌，接收器-连接器 |'
- en: '| 5 | Synchronization patterns | Scoped Locking, Strategized Locking, Thread-Safe
    Interface, Double-Checked Locking Optimization |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 同步模式 | 作用域锁定，策略化锁定，线程安全接口，双重检查锁定优化 |'
- en: '| 6 | Concurrency patterns | Active Object, Monitor Object, Half-Sync/Half-Async,
    Leader/Followers, Thread-Specific Storage |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 并发模式 | 主动对象，监视器对象，半同步/半异步，领导者/跟随者，线程特定存储 |'
- en: '| 7 | Resource acquisition patterns | Lookup, Lazy Acquisition, Eager Acquisition,
    Partial Acquisition |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 资源获取模式 | 查找，延迟获取，急切获取，部分获取 |'
- en: '| 8 | Resource lifecycle | Caching, Pooling, Coordinator, Resource Lifecycle
    Manager |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 资源生命周期 | 缓存，池化，协调器，资源生命周期管理器 |'
- en: '| 9 | Resource release patterns | Leasing, Evictor |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 资源释放模式 | 租赁，驱逐者 |'
- en: '| 10 | A pattern language for distributive computing | Rather than introducing
    new patterns , a consolidation of patterns from different catalogs, in being done
    in the context of distributed programming |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 分布式计算的模式语言 | 不是引入新模式，而是在分布式编程的上下文中对来自不同目录的模式进行整合 |'
- en: '| 11 | On patterns and pattern languages | This last volume gives some meta-information
    about patterns, pattern languages, and usage |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 关于模式和模式语言 | 这最后一卷提供了有关模式、模式语言和使用的一些元信息 |'
- en: The POSA catalog needs to be studied to gain deep insights into the architectural
    underpinnings of large-scale systems, which are deployed across the world. We
    believe that, despite its importance, this catalog has not received the attention,
    it deserves.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 需要研究POSA目录，以深入了解部署在全球范围内的大型系统的架构基础。我们认为，尽管其重要性，这个目录并没有得到应有的关注。
- en: The Design pattern redux
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式重温
- en: The GOF pattern and reactive programming do have a deeper connection than that
    is obvious from the surface. The GOF pattern is mostly concerned with writing
    OOP-based software . Reactive programming is a combination of functional programming,
    stream programming, and concurrent programming. We already learned that reactive
    programming rectifies some deficiencies in the classic GOF Observer pattern(in
    the first section of [Chapter 5](c73fa9f3-6f2b-47f6-946d-155446d3225f.xhtml),
    *Introduction to Observables*, we covered this issue).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: GOF模式和响应式编程确实有比表面上显而易见的更深层次的联系。GOF模式主要关注编写基于面向对象的软件。响应式编程是函数式编程、流编程和并发编程的结合。我们已经了解到，响应式编程纠正了经典的GOF观察者模式的一些缺陷（在[第5章](c73fa9f3-6f2b-47f6-946d-155446d3225f.xhtml)的第一节“可观察对象简介”中，我们涵盖了这个问题）。
- en: Writing OOP software is basically about modeling hierarchies, and from the pattern
    world, the Composite pattern is the way to model Part/Whole hierarchies. Wherever
    there is a Composite (which models a structure), a collection of Visitor pattern
    implementations (to model behavior ) will follow suit. The primary purpose of
    Visitor pattern is processing Composites. In other words, the Composite-Visitor
    duo is the canonical model  for writing object oriented systems.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 编写面向对象的软件基本上是关于建模层次结构，从模式世界来看，组合模式是建模部分/整体层次结构的方法。无论何处有一个组合（用于建模结构），都会有一系列访问者模式的实现（用于建模行为）。访问者模式的主要目的是处理组合。换句话说，组合-访问者二元组是编写面向对象系统的规范模型。
- en: The Visitor implementations should possess some awareness about the structure
    of Ccmposites. Behavioral processing using the Visitor pattern becomes difficult,
    as the number of Visitors for a given Composite proliferates. Moreover, adding
    transformations and filters to the processing layer  further complicates the matter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者的实现应该对组合的结构具有一定的认识。使用访问者模式进行行为处理变得困难，因为给定组合的访问者数量不断增加。此外，向处理层添加转换和过滤进一步复杂化了问题。
- en: Enter the Iterator pattern, which is good for the navigation of a sequence,,
    or list of items. Using object/functional programming constructs, we can filter
    and transform sequences very easily. Microsoft's  LINQ  and  processing collection
    classes using lambdas in Java (8 and above) are good examples of the Iterator
    pattern.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 引入迭代器模式，用于导航序列或项目列表。使用对象/函数式编程构造，我们可以非常容易地过滤和转换序列。微软的LINQ和Java（8及以上）中使用lambda处理集合类的例子都是迭代器模式的好例子。
- en: 'Now, how will we transform hierarchical data into a linear structure? Most
    hierarchies can be flattened into a list for further processing. Recently, people
    have started doing the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何将层次数据转换为线性结构呢？大多数层次结构可以被展平为一个列表以进行进一步处理。最近，人们已经开始做以下事情：
- en: Modeling their hierarchies using the Composite pattern.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用组合模式对它们的层次进行建模。
- en: Flattening the hierarchy into a sequence by using a Visitor meant for the purpose.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用专门用于此目的的访问者将层次结构展平为序列。
- en: Navigating those sequences using the Iterator pattern.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用迭代器模式导航这些序列。
- en: Applying a series of transformations and filters to sequences before performing
    actions on them.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行操作之前，对序列应用一系列转换和过滤。
- en: 'The preceding method is called the `pull` method of programming. Consumers
    or Clients pull data from the event or data source to process it. This scheme
    suffers from the following issues:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法被称为“拉”式编程方法。消费者或客户端从事件或数据源中拉取数据进行处理。这种方案存在以下问题：
- en: The data is unnecessarily pulled into the client.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据被不必要地拉入客户端。
- en: The transformations and filters are applied on the event sink (client) side.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换和过滤应用在事件接收器（客户端）端。
- en: The event sink can block the server.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件接收器可以阻塞服务器。
- en: The style is not good for asynchronous processing, where data varies over time.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种风格不适合异步处理，其中数据随时间变化。
- en: A good solution to the problem is to reverse the gaze, where data is pushed
    from the server asynchronously as a Stream, and the event sink will react to the
    Stream. Another advantage of this kind of system is the placement of transformations
    and filters on the event source side. This leads to a scenario where (only) data
    that is absolutely essential ,needs to be processed on the sink side.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一个好方法是逆向注视，即数据从服务器异步地作为流推送，事件接收器将对流做出反应。这种系统的另一个优点是在事件源端放置转换和过滤。这导致了一个场景，即只有绝对必要的数据需要在接收端进行处理。
- en: 'The scheme is as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 方案如下：
- en: The data is treated as streams, which are called Observables.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据被视为称为可观察对象的流。
- en: We can apply a series of Operators, or higher order Operators, to them.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以对它们应用一系列操作符，或者更高级的操作符。
- en: An Operator always takes an Observable and returns another Observable.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作符总是接收一个可观察对象并返回另一个可观察对象。
- en: We can subscribe to an Observable for notifications.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以订阅一个可观察对象以获取通知。
- en: Observers have standard mechanisms to process them.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者有标准机制来处理它们。
- en: In this section, we learned how OOP patterns and reactive programming are closely
    related. Judicious mixing of both paradigms produces high quality, maintainable
    code. We also discussed how OOP design patterns (Composite/Visitor) can be transformed
    (flattening the structure) to leverage Iterator pattern. We discussed how the
    scheme of iteration can be improved with a slight nudge (a fire and forget idiom
    on the event source side).to arrive at Observables.  In the next section, we will
    demonstrate the whole technique by writing code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了面向对象编程模式和响应式编程是如何密切相关的。合理地混合这两种范式可以产生高质量、可维护的代码。我们还讨论了如何将面向对象编程设计模式（组合/访问者）转换（扁平化结构）以利用迭代器模式。我们讨论了如何通过轻微的改进（在事件源端使用一种忘记即可的习语）来改进迭代方案，从而得到可观察对象。在下一节中，我们将通过编写代码来演示整个技术。
- en: From Design patterns to Reactive programming
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从设计模式到响应式编程
- en: 'Even though the design pattern movement is aligned with OOP, and reactive programming
    is aligned towards FP, there are close similarities between them. In a previous
    chapter([Chapter 5](c73fa9f3-6f2b-47f6-946d-155446d3225f.xhtml), *Introduction
    to Observables)*, we learned the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管设计模式运动与面向对象编程相一致，而响应式编程则更倾向于函数式编程，但它们之间存在着密切的相似之处。在前一章（[第5章](c73fa9f3-6f2b-47f6-946d-155446d3225f.xhtml)，*可观察对象简介*）中，我们学到了以下内容：
- en: The OOP model is good for modeling the structural aspects of a system.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程模型适用于对系统的结构方面进行建模。
- en: The FP model is good for modeling the behavioral aspects of a system.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程模型适用于对系统的行为方面进行建模。
- en: To illustrate the connection between OOP and reactive programming, we will write
    a program that will traverse directories to enumerate files and sub-folders within
    a given folder.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明面向对象编程和响应式编程之间的联系，我们将编写一个程序，用于遍历目录以枚举给定文件夹中的文件和子文件夹。
- en: 'We will create a composite structure that contains the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个包含以下内容的组合结构：
- en: A `FileNode` (inherits from the abstract class  `EntryNode`) that models file
    information
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个继承自抽象类`EntryNode`的`FileNode`，用于模拟文件信息
- en: A `DirectoryNode` (inherits from the abstract class  `EntryNode`) that models
    folder information
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个继承自抽象类`EntryNode`的`DirectoryNode`，用于模拟文件夹信息
- en: 'After defining the preceding Composites, we will define Visitors for the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了上述的组合后，我们将为以下内容定义访问者：
- en: Printing filenames and folder names
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印文件名和文件夹名
- en: Converting a composite hierarchy to a list of filenames
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将组合层次结构转换为文件名列表
- en: 'Without further ado, let''s get into meat of the stuff. Take a look at this
    code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 话不多说，让我们来看看这段代码：
- en: '[PRE0]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding forward declarations are undertaken to silence the compiler from
    issuing errors and warnings while compiling the program. The `FileNode` stores
    a filename and its size as an instance variable. The `DirectoryNode` stores a
    folder name and a list of `FileNode`, to indicate files and folders within a directory.
    The `FileNode`/`DirectoryNode` hierarchy is processed by the `IFileFolderVisitor`
    interface. Now, let us the declaration for these data types.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 上述的前向声明是为了在编译程序时消除编译器发出的错误和警告。`FileNode`存储文件名和文件大小作为实例变量。`DirectoryNode`存储文件夹名和`FileNode`列表，以表示目录中的文件和文件夹。`FileNode`/`DirectoryNode`层次结构由`IFileFolderVisitor`接口处理。现在，让我们为这些数据类型进行声明。
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When we create a Composite, we need to create a node class that acts as a base
    class for all members of the hierarchy. In our case, the `EntryNode` class does
    that. We store the file or folder name, the size, and so on, in the base class.
    Other than the three virtual functions, which should be implemented by the derived
    class, we have a virtual destructor, as well. The presence of a virtual destructor
    makes sure that destructors are applied properly, to avoid resource leaks. Now,
    let us see the Visitor base class declaration given below.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个组合时，我们需要创建一个作为层次结构所有成员的基类的节点类。在我们的情况下，`EntryNode`类就是这样做的。我们在基类中存储文件或文件夹的名称、大小等。除了应该由派生类实现的三个虚拟函数之外，我们还有一个虚拟析构函数。虚拟析构函数的存在确保了适当地应用析构函数，以避免资源泄漏。现在，让我们看看下面给出的访问者基类声明。
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Whenever we define a hierarchy using a Composite pattern style implementation,
    we define a Visitor interface to process nodes in the Composite. For each node
    in the Composite, there will be a corresponding  `visit` method for it in the
    Visitor interface. Every node in the class hierarchy of the Composite will have
    an `accept` method, and the Visitor interface, during traversal of the Composite,
    dispatches call to the respective node''s `accept` method. The `accept` method
    dispatches the call back to the correct `visit` method in the Visitor. This process
    is called **double dispatch**:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们使用组合模式风格的实现来定义层次结构时，我们会定义一个访问者接口来处理组合中的节点。对于组合中的每个节点，在访问者接口中都会有一个相应的`visit`方法。组合中类层次结构的每个节点都将有一个`accept`方法，在遍历组合时，访问者接口会将调用分派到相应节点的`accept`方法。`accept`方法将调用正确的访问者中的`visit`方法。这个过程被称为**双重分派**：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `FileNode` class just stores the name and the size of the file. The class
    also implements all virtual methods declared in the base class (`EntryNode`).
    The `accept` method redirects the call to the correct Visitor level method, as
    shown here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileNode`类只存储文件的名称和大小。该类还实现了基类（`EntryNode`）中声明的所有虚拟方法。`accept`方法将调用重定向到正确的访问者级别方法，如下所示：'
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `DirectoryNode` class models a folder with a list of files and sub-folders.
    We are using smart pointers to store the entry. As usual, we have also implemented
    all virtual functions associated with the `EntryNode` class. The methods `AddFile`
    and `AddDirectory` are meant to populate the list. While traversing the directory
    using the OS specific functions, we populate contents of  a `DirectoryNode`  object
    with the preceding two methods:  Let us see prototype of the directory traversal
    helper function. We have omitted the full  listing of the source code (available
    online )
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`DirectoryNode` 类模拟了一个带有文件和子文件夹列表的文件夹。我们使用智能指针来存储条目。和往常一样，我们也实现了与 `EntryNode`
    类相关的所有虚拟函数。`AddFile` 和 `AddDirectory` 方法用于填充列表。在使用特定于操作系统的函数遍历目录时，我们使用前面两种方法填充了
    `DirectoryNode` 对象的内容。让我们看一下目录遍历辅助函数的原型。我们省略了源代码的完整列表（可在网上找到）。'
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `DirHelper` logic varies between Windows and GNU Linux/macOS X. We have
    omitted source code of the implementation, from the book. The associated website
    contains full source code for the preceding class. Basically, the code recursively
    traverses directories  to populate the data structure.  Now, we will move to the
    topic of traversing the Composite created above. The following code shows how
    we can traverse the Composite using  a Visitor class, which implements the IFileFolderVisitor
    interface.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`DirHelper` 逻辑在 Windows 和 GNU Linux/macOS X 之间有所不同。我们省略了书中实现的源代码。相关网站包含了前述类的完整源代码。基本上，该代码递归遍历目录以填充数据结构。现在，我们将转移到上面创建的
    Composite 的遍历主题。以下代码展示了如何使用实现了 IFileFolderVisitor 接口的 Visitor 类来遍历 Composite。'
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `PrintFolderVisitor` class is a Visitor implementation that displays the
    file and folder information to the console. The class demonstrates how a basic
    Visitor can be implemented for a Composite. In our case, the Composite has only
    two nodes, and it is very easy to write the Visitor implementation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrintFolderVisitor` 类是一个 Visitor 实现，用于在控制台上显示文件和文件夹信息。该类演示了如何为 Composite 实现一个基本的访问者。在我们的情况下，Composite
    只有两个节点，编写访问者实现非常容易。'
- en: 'In certain cases, the number of node types in a hierarchy are numerous, and
    writing a Visitor implementation is not trivial. Writing filters and transformations
    for Visitors can be difficult, and the logic is ad hoc. Let''s write a program
    to print the contents of a folder. Here it is:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，层次结构中节点类型的数量很多，编写访问者实现并不容易。为访问者编写过滤器和转换可能很困难，逻辑是临时的。让我们编写一个程序来打印文件夹的内容。代码如下：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding function recursively traverses a directory and creates a Composite
    (`DirectoryNode *`). We use `PrintFolderVisitor` to print the contents of the
    folder, as shown below:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数递归遍历目录并创建一个 Composite（`DirectoryNode *`）。我们使用 `PrintFolderVisitor` 来打印文件夹的内容，如下所示：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Flattening the hierarchy to navigate through it
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将层次结构展平以便遍历
- en: 'The Visitor implementation has to posses some idea of the structure of the
    Composite. In some instances of Composite implementation, there will be scores
    of Visitors  needs to be implemented. Moreover, applying transformations and filters
    on nodes are bit difficult in the case of Visitor interfaces. The GOF pattern
    catalog has an Iterator pattern that can be used to navigate a sequence of items.
    The problem is: How can we linearize a hierarchy for processing using the Iterator
    pattern? Most hierarchies can be flattened to a list, sequence, or stream by writing
    a Visitor implementation for that purpose. Let us write a flattening Visitor for
    the said task.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者实现必须对 Composite 的结构有一定的了解。在某些 Composite 实现中，需要实现大量的访问者。此外，在访问者接口的情况下，对节点应用转换和过滤有些困难。GOF
    模式目录中有一个迭代器模式，可用于遍历一系列项。问题是：如何使用迭代器模式将层次结构线性化以进行处理？大多数层次结构可以通过编写用于此目的的访问者实现来展平为列表、序列或流。让我们为所述任务编写一个展平访问者。
- en: 'Take a look at the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `FlattenVisitor` class collects files and folders in a STL list. For each
    directory, we iterate through the list of files and issue the `accept` method,using
    the familiar double dispatch.  Let us write a function that returns a list of
    `FileInformation` for us to iterate through. Here is the code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`FlattenVisitor` 类在 STL 列表中收集文件和文件夹。对于每个目录，我们遍历文件列表并使用熟悉的双重分发调用 `accept` 方法。让我们编写一个函数，返回一个
    `FileInformation` 列表供我们遍历。代码如下：'
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `FlattenVisitor` class traverses the `DirectoryNode` hierarchy and collects
    the fully expanded pathname into a STL list container. Once we have linearized
    the hierarchy into a list, we can iterate over it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`FlattenVisitor` 类遍历 `DirectoryNode` 层次结构，并将完全展开的路径名收集到 STL 列表容器中。一旦我们将层次结构展平为列表，就可以对其进行迭代。'
- en: We have learned how to model a hierarchy as a Composite, and eventually flatten
    it to a form that is suitable for navigation with the Iterator pattern. In the
    next section, we will learn how Iterators can be transformed into Observables.
    We will use RxCpp to implement the Observables by using a fire and forget model,
    pushing values from the event source to the event sink.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何将层次结构建模为 Composite，并最终将其展平为适合使用迭代器模式进行导航的形式。在下一节中，我们将学习如何将迭代器转换为可观察对象。我们将使用
    RxCpp 来实现可观察对象，通过使用一种推送值从事件源到事件接收端的“发射并忘记”模型。
- en: From Iterators to Observables
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从迭代器到可观察对象
- en: 'The Iterator pattern is the standard mechanism to pull data from STL containers,
    generators, and streams. They are well suited for data that has been aggregated
    in the space. Essentially, this means that we know ahead of time how much data
    is supposed to be retrieved, or that the data has already been captured. There
    are scenarios where the data arrives asynchronously and the consumers are not
    aware of how much data there is or when the data arrives. In such cases, Iterators
    need to wait, or we need to resort to timeout strategies to handle the scenario.
    In such a scenario, a push-based approach seems to be a better option. Using the
    Subject construct of Rx, we can use a fire and forget strategy. Let''s write a
    class that emits the contents of a directory, as shown here:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器模式是从STL容器、生成器和流中拉取数据的标准机制。它们非常适合在空间中聚合的数据。基本上，这意味着我们预先知道应该检索多少数据，或者数据已经被捕获。有些情况下，数据是异步到达的，消费者不知道有多少数据或数据何时到达。在这种情况下，迭代器需要等待，或者我们需要采用超时策略来处理这种情况。在这种情况下，基于推送的方法似乎是更好的选择。使用Rx的Subject构造，我们可以使用fire
    and forget策略。让我们编写一个类，发出目录的内容，如下所示：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `DirectoryEmitter` class uses modern C++'s `packaged_task` construct to
    make asynchronous calls in a fire and forget manner. In the preceding listing,
    we were waiting for the result (using `std::future<T>`). We can comment a line
    in the above code listing  (see the inline comment in the listing ) to return
    immediately.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`DirectoryEmitter`类使用现代C++的`packaged_task`构造以fire and forget的方式进行异步调用。在前面的列表中，我们正在等待结果（使用`std::future<T>`）。我们可以在上面的代码列表中注释一行（参见列表中的内联注释），以立即返回。'
- en: The Cell pattern
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cell模式
- en: 'We have already learned that reactive programming is all about processing values
    that vary over time. The reactive programming model is centered on the notion
    of Observables. There are two variants of Observables, which are as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学到，响应式编程是关于处理随时间变化的值。响应式编程模型以Observable的概念为中心。Observable有两种变体，如下所示：
- en: 'Cells: A cell is an entity (a variable, or a memory location) where values
    are regularly updated over time. They are also called properties or behaviors,
    in some contexts.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元：单元是一个实体（变量或内存位置），其值随时间定期更新。在某些情境中，它们也被称为属性或行为。
- en: 'Streams: A stream represents a series of events. They are data that is often
    associated with actions. When people think of Observables, they have got stream
    variant of Observables in their mind.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流：流代表一系列事件。它们通常与动作相关的数据。当人们想到Observable时，他们脑海中有Observable的流变体。
- en: We will implement a toy version of a Cell programming pattern. We will only
    focus on implementing basic functionality. The code needs tidying up for production
    use.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个Cell编程模式的玩具版本。我们只专注于实现基本功能。该代码需要整理以供生产使用。
- en: 'The following implementation can be optimized, if we are implementing a a controller
    class called Cell controller. . Then, the Cell controller class ( which contains
    a single Rx Subject for all cells)  can receive notifications from all cells (to
    a central place) and update dependencies by evaluating expressions. Here, we have
    attached  Subjects with every Cell.  This implementation shows how the Cell pattern
    is a viable mechanism for dependent computations:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的实现可以进行优化，如果我们正在实现一个名为Cell controller的控制器类。然后，Cell controller类（包含所有单元的单个Rx
    Subject）可以从所有单元（到一个中央位置）接收通知，并通过评估表达式来更新依赖关系。在这里，我们已经为每个单元附加了Subject。这个实现展示了Cell模式是一个可行的依赖计算机制：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The Cell class makes an assumption that each cell has two parent dependencies
    (to make the implementation simple), and whenever there is a change in value of
    parents, the cell''s value will be recalculated. We have only  implemented an
    addition operator (to keep listings small). The `recalculate` method implements
    the logic, as shown above: Let us write a main program to put everything together.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Cell类假设每个单元有两个父依赖关系（为了简化实现），每当父级的值发生变化时，单元的值将被重新计算。我们只实现了加法运算符（为了保持列表的简洁）。`recalculate`方法实现了上面显示的逻辑：让我们编写一个主程序把所有东西放在一起。
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The main program demonstrates how we can use the Cell pattern to propagate changes
    down into the dependencies. By changing values in cless, we force the re-computation
    of values in the dependent cells.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 主程序演示了如何使用Cell模式将更改传播到依赖项中。通过更改cless中的值，我们强制重新计算依赖单元中的值。
- en: The Active object pattern
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Active对象模式
- en: 'An Active object is a class that decouples method invocations and method executions,
    and is well suited for fire and forget asynchronous calls. A scheduler attached
    to the class handles the execution requests. The pattern consists of six elements,
    which are as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Active对象是一个将方法调用和方法执行分离的类，非常适合于fire and forget的异步调用。附加到类的调度程序处理执行请求。该模式由六个元素组成，如下所示：
- en: A proxy, which provides an interface for clients with publicly accessible methods
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理，为客户端提供具有公开可访问方法的接口
- en: An interface that defines the method request on an Active object
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义Active对象上的方法请求的接口
- en: A list of pending requests from clients
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自客户端的待处理请求列表
- en: A Scheduler, which decides which request to execute next
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定下一个要执行的请求的调度程序
- en: The implementation of the Active object method
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Active对象方法的实现
- en: A callback or variable, for the client to receive the result
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端接收结果的回调或变量
- en: 'We will dissect an implementation of the Active object pattern. This program
    is written for elucidation; for production use, we need to use a bit more sophistication.
    Attempting a production quality implementation would make the code considerably
    longer. Let''s take a look at the code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将剖析Active对象模式的实现。这个程序是为了阐明而编写的；在生产中使用，我们需要使用更复杂的方法。尝试生产质量的实现会使代码变得相当长。让我们看一下代码：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding implementation declares an instance of the `subject<T>` class,
    to act as a notification mechanism. The `FireNForget` method places the value
    into the subject by invoking the `get_subscriber` method. The method immediately
    returns, and the subscription method will retrieve the value and call the `Execute`
    method. The class is supposed to be overridden by a concrete implementation. Let''s
    take a look at the code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的实现声明了一个`subject<T>`类的实例，作为通知机制。`FireNForget`方法通过调用`get_subscriber`方法将值放入subject中。该方法立即返回，订阅方法将检索该值并调用`Execute`方法。该类应该被具体实现所重写。让我们来看一下代码：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The previous code snippet calls the `FireNForget` method, with a double value.
    On the console, we can see the value being displayed. The overridden `Execute`
    method is automatically invoked.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段调用了`FireNForget`方法，传入了一个双精度值。在控制台上，我们可以看到该值被显示出来。重写的`Execute`方法会自动被调用。
- en: The Resource Loan pattern
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源借贷模式
- en: 'The Loan pattern, as the  name suggest, loans a resource to a function  In
    the example given below, a file handle is loaned to consumers of the class. It
    performs following steps:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 借贷模式，正如其名字所示，将资源借给一个函数。在下面给出的示例中，文件句柄被借给了类的消费者。它执行以下步骤：
- en: It creates a resource that you can use (a file handle )
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它创建一个可以使用的资源（文件句柄）
- en: It loans the resource (file handle ) to functions  (lambdas) that will use it
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将资源（文件句柄）借给将使用它的函数（lambda）
- en: This function is passed by the caller and executed by the resource holder
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数由调用者传递并由资源持有者执行
- en: The resource (file handle ) is closed or destroyed  by the resource holder
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源（文件句柄）由资源持有者关闭或销毁
- en: 'The following code implements the Resource Loan pattern for resource management.
    The pattern helps to avoid resource leakage when writing code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码实现了资源管理的资源借贷模式。该模式有助于在编写代码时避免资源泄漏：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The Resource Loan pattern is suitable for avoiding resource leakage. The holder
    of the resource never hands over   handle or pointer of the resource to its consumers.
    The main program demonstrates how we can consume the implementation. The ResourceLoan
    class never allows its consumer to access the file handle directly.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 资源借贷模式适用于避免资源泄漏。资源的持有者从不直接将资源的句柄或指针交给其消费者。主程序演示了我们如何消费该实现。ResourceLoan类从不允许其消费者直接访问文件句柄。
- en: The Event bus pattern
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件总线模式
- en: The Event bus acts as a intermediary between event sources and event sinks.
    An event source, or producer, emits the events to a bus, and classes that have
    subscribed to events (consumers) will get notified. The pattern could be an instance
    of the Mediator design pattern. In an Event bus implementation, we have the following
    archetypes
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 事件总线充当事件源和事件接收器之间的中介。事件源或生产者向总线发出事件，订阅事件的类（消费者）将收到通知。该模式可以是中介者设计模式的一个实例。在事件总线实现中，我们有以下原型
- en: '**Producers**: Classes which produce events'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产者**：产生事件的类'
- en: '**Consumers**: Classes which consume events'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消费者**：消费事件的类'
- en: '**Controllers**: Classes which act as producers and consumers'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：充当生产者和消费者的类'
- en: 'In the implementation that follows, we have omitted the implementation of Controllers.
    The following code implements a toy version of an Event bus:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的实现中，我们省略了控制器的实现。以下代码实现了事件总线的一个玩具版本：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `EVENT_INFO` struct models an event, and it has the following content:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`EVENT_INFO`结构模拟了一个事件，它包含以下内容：'
- en: '`Id`: Event ID'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Id`：事件ID'
- en: '`err_code`: Error code'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`err_code`：错误代码'
- en: '`description`: Description of the events'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`：事件描述'
- en: 'The rest of the code is fairly obvious; here it is:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的代码相当明显；在这里是：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Implementation of the Producer class is fairly simple. The skeleton implementation
    is rather trivial. The `Fire` method takes a compatible `EventBus<T>` as a parameter
    and calls the `FireEvent` method of the `EventBus<T>` class. A production implementation
    requires some bells and whistles. Let's take a look at the code for the Consumer
    class.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 生产者类的实现相当简单。骨架实现相当琐碎。`Fire`方法以兼容的`EventBus<T>`作为参数，并调用`EventBus<T>`类的`FireEvent`方法。生产实现需要一些花里胡哨的东西。让我们来看一下消费者类的代码。
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The functionality of `Consumer<T>` is pretty obvious. The `Connect` method
    does the work of subscribing to the Observable side of the Subject in the `EventBus<T>`
    class. Each time a new connection request comes in, the existing subscription
    is unsubscribed, as shown here:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`Consumer<T>`的功能非常明显。`Connect`方法负责订阅`EventBus<T>`类中Subject的Observable端。每当有新的连接请求时，现有的订阅将被取消订阅，如下所示：'
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `EventBus<T>` class acts as a conduit between the Producers and Consumers.
    We are using a `replaysubject` under the hood, to notify the Consumers. Now that,
    we have finished writing Producer and Consumer class, let us see how we can utilize
    the code written above.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventBus<T>`类充当生产者和消费者之间的导管。我们在底层使用`replaysubject`来通知消费者。现在，我们已经完成了生产者和消费者类的编写，让我们看看如何利用上面编写的代码。'
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the main function, we are performing the following tasks:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数中，我们正在执行以下任务：
- en: Creating an instance of the `EventBus<T>`
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`EventBus<T>`的实例
- en: Creating an instance of Producers
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建生产者的实例
- en: Creating an instance of Consumers
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建消费者的实例
- en: Dispatching events to the bus
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向总线分发事件
- en: We have only covered a subset of the design patterns that are suitable for writing
    reactive programs. Primarily, our focus has been on bridging from GOF design patterns
    to the reactive programming world. In fact, authors of this book believe that
    the reactive programming model is an enhanced implementation of classic GOF design
    patterns. The enhancement is possible due to the functional programming constructs
    added to modern programming languages. In fact, object/functional programming
    is a good approach for writing modern C++ code. This chapter was largely based
    on the very idea.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只涵盖了适用于编写响应式程序的设计模式的子集。主要，我们的重点是从GOF设计模式过渡到响应式编程世界。事实上，本书的作者认为响应式编程模型是经典GOF设计模式的增强实现。这种增强是由于现代编程语言中添加的函数式编程构造。事实上，对象/函数式编程是编写现代C++代码的良好方法。本章在很大程度上是基于这个想法。
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we delved into the wonderful world of design patterns/idioms
    associated with C++ programming and reactive programming. Starting with GOF design
    patterns, we moved on to reactive programming patterns and  gradual transition
    from OOP to reactive programming is a highlight of this chapter.  Later,we covered
    reactive programming patterns such as Cell, Active object, Resource loan, and
    Event bus. Bridging from GOF patterns to reactive programming helps you to look
    at reactive programming in a broader sense.In the next chapter, we will learn
    about micro-service development using C++.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了与C++编程和响应式编程相关的设计模式/习惯用法的美妙世界。从GOF设计模式开始，我们转向了响应式编程模式，逐渐过渡从面向对象编程到响应式编程是本章的亮点。之后，我们涵盖了诸如Cell、Active
    object、Resource loan和Event bus等响应式编程模式。从GOF模式过渡到响应式编程有助于你以更广泛的视角看待响应式编程。在下一章中，我们将学习使用C++进行微服务开发。
