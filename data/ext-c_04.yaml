- en: Chapter 04
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章
- en: Process Memory Structure
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程内存结构
- en: In this chapter, we are going to talk about memory and its structure within
    a process. For a C programmer, memory management is always a crucial topic, and
    applying its best practices requires a basic knowledge about memory structure.
    In fact, this is not limited to C. In many programming languages such as C++ or
    Java, you need to have a fundamental understanding of memory and the way it works;
    otherwise, you face some serious issues that cannot be easily traced and fixed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论进程内部的内存及其结构。对于C程序员来说，内存管理始终是一个关键话题，而应用最佳实践需要关于内存结构的基本知识。实际上，这不仅仅局限于C。在许多编程语言（如C++或Java）中，你需要对内存及其工作方式有一个基本理解；否则，你可能会遇到一些严重的问题，这些问题难以追踪和修复。
- en: You might know that memory management is fully manual in C, and more than that,
    the programmer is the sole responsible person who allocates memory regions and
    deallocates them once they're no longer needed.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能知道，在C语言中内存管理是完全手动的，而且不仅如此，程序员是唯一负责分配内存区域并在不再需要时释放它们的责任人。
- en: Memory management is different in high-level programming languages such as Java
    or C#, and it is done partly by the programmer and partly by the underlying language
    platform, such as **Java Virtual Machine** (**JVM**) in the case of using Java.
    In these languages, the programmer only issues memory allocations, but they are
    not responsible for the deallocations. A component called the *garbage collector*
    does the deallocation and frees up the allocated memory automatically.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在高级编程语言（如Java或C#）中，内存管理是不同的，它部分由程序员完成，部分由底层语言平台完成，例如在使用Java时，底层平台是**Java虚拟机**（**JVM**）。在这些语言中，程序员只负责发出内存分配的指令，但他们对释放操作不负责。一个称为*垃圾回收器*的组件负责释放和自动释放分配的内存。
- en: Since there is no such garbage collector in C and C++, having some dedicated
    chapters for covering the concepts and issues regarding memory management is essential.
    That's why we have dedicated this chapter and the next to memory-related concepts,
    and these chapters together should give you a basic understanding of how memory
    works in C/C++.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C和C++中没有这样的垃圾回收器，因此为内存管理相关的概念和问题设置一些专门的章节是必不可少的。这就是为什么我们专门用这一章和下一章来介绍与内存相关的概念，这两章合起来应该能给你一个关于C/C++中内存如何工作的基本理解。
- en: 'Throughout this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: We start by looking at the typical memory structure of a process. This will
    help us to discover the anatomy of a process and the way it interacts with the
    memory.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先查看进程的典型内存结构。这将帮助我们了解进程的解剖结构和它与内存的交互方式。
- en: We discuss static and dynamic memory layouts.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了静态和动态内存布局。
- en: We introduce the segments found in the aforementioned memory layouts. We see
    that some of them reside in the executable object file and the rest are created
    while the process is loading.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们介绍了上述内存布局中发现的段。我们发现其中一些位于可执行对象文件中，其余的则在进程加载时创建。
- en: We introduce the probing tools and commands which can help us to detect the
    segments and see their content, both inside an object file and deep within a running
    process.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们介绍了可以帮助我们检测段及其内容的探测工具和命令，这些段既可以在对象文件内部，也可以在运行进程的深处看到。
- en: As part of this chapter, we get to know two segments called *Stack* and *Heap*.
    They are part of the dynamic memory layout of a process and all the allocations
    and deallocations happen in these segments. In the following chapter, we will
    discuss Stack and Heap segments in a greater detail because in fact, they are
    the segments that a programmer interacts with the most.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的一部分，我们将了解两个称为*栈*和*堆*的部分。它们是进程动态内存布局的一部分，所有的分配和释放操作都发生在这两个部分中。在下一章中，我们将更详细地讨论栈和堆部分，因为实际上，它们是程序员与之交互最多的部分。
- en: Let's start this chapter by talking about the *process memory layout*. This
    will give you an overall idea about how the memory of a running process is segmented,
    and what each segment is used for.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从讨论*进程内存布局*开始这一章。这将让你对正在运行的进程的内存是如何分段的，以及每个部分用于什么有一个整体的概念。
- en: Process memory layout
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程内存布局
- en: Whenever you run an executable file, the operating system creates a new process.
    A process is a live and running program that is loaded into the memory and has
    a unique **Process Identifier** (**PID**). The operating system is the sole responsible
    entity for spawning and loading new processes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行可执行文件时，操作系统都会创建一个新的进程。进程是一个活跃且正在运行的程序，它被加载到内存中，并具有一个唯一的**进程标识符**（**PID**）。操作系统是负责生成和加载新进程的唯一实体。
- en: A process remains running until it either exits normally, or the process is
    given a signal, such as `SIGTERM`, `SIGINT`, or `SIGKILL`, which eventually makes
    it exit. The `SIGTERM` and `SIGINT` signals can be ignored, but `SIGKILL` will
    kill the process immediately and forcefully.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 进程会一直运行，直到它正常退出，或者进程收到信号，如`SIGTERM`、`SIGINT`或`SIGKILL`，最终导致它退出。`SIGTERM`和`SIGINT`信号可以被忽略，但`SIGKILL`会立即且强制地终止进程。
- en: '**Note**:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: 'The signals mentioned in the preceding section are explained as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个章节中提到的信号解释如下：
- en: '`SIGTERM`: This is the termination signal. It allows the process to clean up.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGTERM`：这是终止信号。它允许进程进行清理。'
- en: '`SIGINT`: This is the interrupt signal usually sent to the foreground process
    by pressing `Ctrl` + `C`.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGINT`：这是中断信号，通常在按下`Ctrl` + `C`时发送给前台进程。'
- en: '`SIGKILL`: This is the kill signal and it closes the process forcefully without
    letting it clean up.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGKILL`：这是终止信号，它会强制关闭进程，不允许它进行清理。'
- en: When creating a process, one of the first things that operating systems do is
    allocate a portion of memory dedicated to the process and then apply a predefined
    memory layout. This predefined memory layout is more or less the same in different
    operating systems, especially in Unix-like operating systems.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建进程时，操作系统首先做的事情之一是为进程分配一块专用的内存部分，然后应用预定义的内存布局。这种预定义的内存布局在不同的操作系统中大致相同，尤其是在类Unix操作系统中。
- en: In this chapter, we're going to explore the structure of this memory layout,
    and a number of important and useful terms are introduced.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨这种内存布局的结构，并介绍一些重要且有用的术语。
- en: 'The memory layout of an ordinary process is divided into multiple parts. Each
    part is called a *segment*. Each segment is a region of memory which has a definite
    task and it is supposed to store a specific type of data. You can see the following
    list of segments being part of the memory layout of a running process:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 普通进程的内存布局被划分为多个部分。每个部分被称为*段*。每个段是内存的一个区域，它具有特定的任务，并存储特定类型的数据。您可以看到以下列表中的段是运行进程内存布局的一部分：
- en: Uninitialized data segment or **Block Started by Symbol** (**BSS**) segment
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未初始化的数据段或**块起始符号**（**BSS**）段
- en: Data segment
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据段
- en: Text segment or Code segment
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本段或代码段
- en: Stack segment
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈段
- en: Heap segment
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆段
- en: In the following sections, we will study each of these segments individually,
    and we discuss the way they contribute to the execution of a program. In the next
    chapter, we will focus on Stack and Heap segments and we'll discuss them thoroughly.
    As part of our quest, let's introduce some tools that help us inspect the memory
    before going into the specifics of the above segments.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将分别研究这些段，并讨论它们如何有助于程序的执行。在下一章中，我们将重点关注栈和堆段，并对其进行详细讨论。作为我们探索的一部分，让我们介绍一些帮助我们检查内存的工具，然后再深入研究上述段的具体细节。
- en: Discovering memory structure
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现内存结构
- en: Unix-like operating systems provide a set of tools for inspecting the memory
    segments of a process. You learn in this section that some of these segments reside
    within the executable object file, and other segments are created dynamically
    at runtime, when the process is spawned.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 类Unix操作系统提供了一套工具来检查进程的内存段。在本节中，您将了解到其中一些段位于可执行目标文件中，而其他段是在进程生成时动态创建的。
- en: As you should already know from the two previous chapters, an executable object
    file and a process are not the same thing, therefore it is expected to have different
    tools for inspecting each of them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前两个章节中应该已经了解到的，可执行目标文件和进程不是同一件事，因此预期会有不同的工具来检查它们中的每一个。
- en: From the previous chapters, we know that an executable object file contains
    the machine instructions, and it is produced by the compiler. But a process is
    a running program spawned by executing an executable object file, consuming a
    region of the main memory, and the CPU is constantly fetching and executing its
    instructions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的章节中，我们知道可执行目标文件包含机器指令，并且是由编译器生成的。但进程是由执行可执行目标文件而生成的正在运行的程序，它消耗主内存的一部分，而
    CPU 则不断获取并执行其指令。
- en: A process is a living entity that is being executed inside the operating system
    while the executable object file is just a file containing a premade initial layout
    acting as a basis for spawning future processes. It is true that in the memory
    layout of a running process, some segments come directly from the base executable
    object file, and the rest are built dynamically at runtime while the process is
    being loaded. The former layout is called the **static memory layout**, and the
    latter is called the **dynamic memory layout**.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 进程是一个在操作系统内部执行的生命实体，而可执行目标文件只是一个包含预先制作初始布局的文件，该布局作为未来进程生成的依据。确实，在运行进程的内存布局中，一些段直接来自基本可执行目标文件，其余的则在进程加载时动态构建。前者布局称为**静态内存布局**，后者称为**动态内存布局**。
- en: Static and dynamic memory layouts both have a predetermined set of segments.
    The content of the static memory layout is prewritten into the executable object
    file by the compiler, when compiling the source code. On the other hand, the content
    of the dynamic memory layout is written by the process instructions allocating
    memory for variables and arrays, and modifying them according to the program's
    logic.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 静态和动态内存布局都有一组预定义的段。静态内存布局的内容是由编译器在编译源代码时预先写入可执行目标文件的。另一方面，动态内存布局的内容是由分配变量和数组内存的进程指令写入的，并根据程序的逻辑对其进行修改。
- en: With all that said, we can guess the content of the static memory layout either
    by just looking at the source code or the compiled object file. But this is not
    that easy regarding the dynamic memory layout as it cannot be determined without
    running the program. In addition, different runs of the same executable file can
    lead to different content in the dynamic memory layout. In other words, the dynamic
    content of a process is unique to that process and it should be investigated while
    the process is still running.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们可以通过仅查看源代码或编译后的目标文件来猜测静态内存布局的内容。但关于动态内存布局，这并不容易，因为它不能在没有运行程序的情况下确定。此外，同一可执行文件的多次运行可能导致动态内存布局中的内容不同。换句话说，进程的动态内容对该进程是唯一的，并且应该在进程仍在运行时进行调查。
- en: Let's begin with inspecting the static memory layout of a process.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从检查进程的静态内存布局开始。
- en: Probing static memory layout
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探测静态内存布局
- en: 'The tools used for inspecting the static memory layout usually work on the
    object files. To get some initial insight, we''ll start with an example, *example
    4.1*, which is a minimal C program that doesn''t have any variable or logic as
    part of it:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 用于检查静态内存布局的工具通常作用于目标文件。为了获得一些初步的见解，我们将从一个例子开始，即*示例 4.1*，这是一个没有包含任何变量或逻辑的最小 C
    程序：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Code Box 4-1 [ExtremeC_examples_chapter4_1.c]: A minimal C program'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 4-1 [ExtremeC_examples_chapter4_1.c]：一个最小的 C 程序
- en: 'First, we need to compile the preceding program. We compile it in Linux using
    `gcc`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要编译前面的程序。我们使用 `gcc` 在 Linux 中编译它：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Shell Box 4-1: Compiling example 4.1 using gcc in Linux'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 4-1：在 Linux 中使用 gcc 编译 example 4.1
- en: After a successful compilation and having the final executable binary linked,
    we get an executable object file named `ex4_1-linux.out`. This file contains a
    predetermined static memory layout that is specific to the Linux operating system,
    and it will exist in all future processes spawned based on this executable file.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功编译并链接最终的可执行二进制文件后，我们得到一个名为 `ex4_1-linux.out` 的可执行目标文件。该文件包含一个特定于 Linux 操作系统的预定义静态内存布局，并且它将存在于基于此可执行文件启动的所有未来进程中。
- en: The `size` command is the first tool that we want to introduce. It can be used
    to print the static memory layout of an executable object file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`size` 命令是我们首先想要介绍的工具。它可以用来打印可执行目标文件的静态内存布局。'
- en: 'You can see the usage of the `size` command in order to see the various segments
    found as part of the static memory layout as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下方式查看 `size` 命令的用法，以查看作为静态内存布局一部分找到的各种段：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Shell Box 4-2: Using the size command to see the static segments of ex4_1-linux.out'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 4-2：使用size命令查看ex4_1-linux.out的静态段
- en: As you see, we have Text, Data, and BSS segments as part of the static layout.
    The shown sizes are in bytes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，静态布局中包含文本、数据和BSS段。显示的大小以字节为单位。
- en: 'Now, let''s compile the same code, *example 4.1*, in a different operating
    system. We have chosen macOS and we are going to use the `clang` compiler:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在不同的操作系统上编译相同的代码，*示例4.1*。我们选择了macOS，并将使用`clang`编译器：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Shell Box 4-3: Compiling example 4.1 using clang in macOS'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 4-3：在macOS中使用clang编译示例4.1
- en: 'Since macOS is a POSIX-compliant operating system just like Linux, and the
    `size` command is specified to be part of the POSIX utility programs, macOS should
    also have the `size` command. Therefore, we can use the same command to see the
    static memory segments of `ex4_1-macos.out`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于macOS与Linux一样，是一个符合POSIX标准的操作系统，并且`size`命令被指定为POSIX实用程序的一部分，因此macOS也应该有`size`命令。因此，我们可以使用相同的命令来查看`ex4_1-macos.out`的静态内存段：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Shell Box 4-4: Using the size command to see the static segments of ex4_1-macos.out'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 4-4：使用size命令查看ex4_1-macos.out的静态段
- en: In the preceding shell box, we have run the `size` command twice; the second
    run gives us more details about the found memory segments. You might have noticed
    that we have Text and Data segments in macOS, just like Linux, but there is no
    BSS segment. Note that the BSS segment also exists in macOS, but it is not shown
    in the `size` output. Since the BSS segment contains uninitialized global variables,
    there is no need to allocate some bytes as part of the object file and it is enough
    to know how many bytes are required for storing those global variables.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的shell框中，我们运行了`size`命令两次；第二次运行提供了关于找到的内存段的更多详细信息。你可能已经注意到，macOS中与Linux一样，有文本和数据段，但没有BSS段。请注意，BSS段在macOS中也是存在的，但在`size`输出中并未显示。由于BSS段包含未初始化的全局变量，不需要在对象文件中分配一些字节，知道存储这些全局变量所需的字节数就足够了。
- en: In the preceding shell boxes, there is an interesting point to note. The size
    of the Text segment is 1,099 bytes in Linux while it is 4 KB in macOS. It can
    also be seen that the Data segment for a minimal C program has a non-zero size
    in Linux, but it is empty in macOS. It is apparent that the low-level memory details
    are different on various platforms.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的shell框中，有一个需要注意的有趣点。在Linux中，文本段的大小为1,099字节，而在macOS中为4 KB。还可以看到，对于最小化的C程序，Linux中的数据段具有非零大小，但在macOS中为空。很明显，不同平台上的低级内存细节是不同的。
- en: Despite these little differences between Linux and macOS, we can see that both
    platforms have the Text, Data, and BSS segments as part of their static layout.
    From now on, we gradually explain what each of these segments are used for. In
    the upcoming sections, we'll discuss each segment separately and we give an example
    slightly different from *example 4.1* for each, in order to see how differently
    each segment responds to the minor changes in the code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Linux和macOS之间存在这些小小的差异，但我们可以看到，这两个平台都将文本、数据和BSS段作为它们静态布局的一部分。从现在开始，我们将逐步解释每个段的使用目的。在接下来的章节中，我们将分别讨论每个段，并为每个段提供一个与*示例4.1*略有不同的示例，以便看到每个段如何对代码中的微小变化做出不同的反应。
- en: BSS segment
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BSS段
- en: We start with the BSS segment. **BSS** stands for **Block Started by Symbol**.
    Historically, the name was used to denote reserved regions for uninitialized words.
    Basically, that's the purpose that we use the BSS segment for; either uninitialized
    global variables or global variables set to zero.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从BSS段开始。**BSS**代表**Block Started by Symbol**。从历史上看，这个名字被用来表示为未初始化的字保留的区域。基本上，这就是我们使用BSS段的目的；要么是未初始化的全局变量，要么是设置为0的全局变量。
- en: 'Let''s expand *example 4.1* by adding a few uninitialized global variables.
    You see that uninitialized global variables will contribute to the BSS segment.
    The following code box demonstrates *example 4.2*:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加一些未初始化的全局变量来扩展*示例4.1*。你会看到未初始化的全局变量将贡献到BSS段。以下代码框展示了*示例4.2*：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Code Box 4-2 [ExtremeC_examples_chapter4_2.c]: A minimal C program with a few
    global variables either uninitialized or set to zero'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框4-2 [ExtremeC_examples_chapter4_2.c]：一个包含一些全局变量（未初始化或设置为0）的最小化C程序
- en: 'The integers `global_var1`, `global_var2`, and `global_var3` are global variables
    which are uninitialized. For observing the changes made to the resulting executable
    object file in Linux, in comparison to *example 4.1*, we again run the `size`
    command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 整数 `global_var1`、`global_var2` 和 `global_var3` 是未初始化的全局变量。为了观察与 *example 4.1*
    相比，Linux 中生成的可执行目标文件中做出的更改，我们再次运行 `size` 命令：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Shell Box 4-5: Using the size command to see the static segments of ex4_2-linux.out'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 4-5：使用 size 命令查看 ex4_2-linux.out 的静态段
- en: If you compare the preceding output with a similar output from *example 4.1*,
    you will notice that the size of the BSS segment has changed. In other words,
    declaring global variables that are *not* initialized or set to zero will add
    up to the BSS segment. These special global variables are part of the static layout
    and they become preallocated when a process is loading, and they never get deallocated
    until the process is alive. In other words, they have a static lifetime.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将前面的输出与 *example 4.1* 的类似输出进行比较，你会注意到 BSS 段的大小已更改。换句话说，声明未初始化或设置为零的全局变量将累加到
    BSS 段。这些特殊的全局变量是静态布局的一部分，当进程加载时，它们被预分配，并且只有在进程存活时才不会被释放。换句话说，它们具有静态生命周期。
- en: '**Note**:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**:'
- en: Because of design concerns, we usually prefer to use local variables in our
    algorithms. Having too many global variables can increase the binary size. In
    addition, keeping sensitive data in the global scope, it can introduce security
    concerns. Concurrency issues, especially data races, namespace pollution, unknown
    ownership, and having too many variables in the global scope, are some of the
    complications that global variables introduce.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于设计考虑，我们通常更喜欢在我们的算法中使用局部变量。全局变量过多会增加二进制文件的大小。此外，在全局作用域中保留敏感数据可能会引入安全风险。并发问题，特别是数据竞争、命名空间污染、未知所有权以及在全局作用域中变量过多，是全球变量引入的一些复杂问题。
- en: 'Let''s compile *example 4.2* in macOS and have a look at the output of the
    `size` command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 macOS 中编译 *example 4.2* 并查看 `size` 命令的输出：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Shell Box 4-6: Using the size command to see the static segments of ex4_2-macos.out'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 4-6：使用 size 命令查看 ex4_2-macos.out 的静态段
- en: And again, it is different from Linux. In Linux, we had preallocated 8 bytes
    for the BSS segment, when we had no global variables. In *example 4.2*, we added
    three new uninitialized global variables whose sizes sum up to 12 bytes, and the
    Linux C compiler expanded the BSS segment by 8 bytes. But in macOS, we still have
    no BSS segment as part of the `size`'s output, but the compiler has expanded the
    `data` segment from 0 bytes to 4KB, which is the default page size in macOS. This
    means that `clang` has allocated a new memory page for the `data` segment inside
    the layout. Again, this simply shows how much the details of the memory layout
    can be different in various platforms.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这与 Linux 不同。在 Linux 中，我们没有全局变量时，为 BSS 段预分配了 8 个字节。在 *example 4.2* 中，我们添加了三个新的未初始化的全局变量，其大小总和为
    12 个字节，Linux C 编译器将 BSS 段扩展了 8 个字节。但在 macOS 中，我们仍然没有 BSS 段作为 `size` 输出的一部分，但编译器已将
    `data` 段从 0 字节扩展到 4KB，这是 macOS 中的默认页面大小。这意味着 `clang` 在布局内部为 `data` 段分配了一个新的内存页。再次强调，这仅仅显示了不同平台在内存布局细节上的差异有多大。
- en: '**Note**:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**:'
- en: 'While allocating the memory, it doesn''t matter how many bytes a program needs
    to allocate. The *allocator* always acquires memory in terms of *memory pages*
    until the total allocated size covers the program''s need. More information about
    the Linux memory allocator can be found here: [https://www.kernel.org/doc/gorman/html/understand/understand009.html](https://www.kernel.org/doc/gorman/html/understand/understand009.html).'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在分配内存时，程序需要分配多少字节并不重要。*分配器*总是以 *内存页* 为单位获取内存，直到总分配大小覆盖程序的需求。有关 Linux 内存分配器的更多信息，请参阅此处：[https://www.kernel.org/doc/gorman/html/understand/understand009.html](https://www.kernel.org/doc/gorman/html/understand/understand009.html)。
- en: In *Shell Box 4-6*, we have a section named `__common`, inside the `_DATA` segment,
    which is 12 bytes, and it is in fact referring to the BSS segment that is not
    shown as BSS in the `size`'s output. It refers to 3 uninitialized global integer
    variables or 12 bytes (each integer being 4 bytes). It's worth taking note that
    uninitialized global variables are set to *zero* by default. There is no other
    value that could be imagined for uninitialized variables.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Shell 框 4-6* 中，我们在 `_DATA` 段内部有一个名为 `__common` 的部分，它占 12 字节，实际上它指的是未在 `size`
    输出中显示的 BSS 段。它指的是 3 个未初始化的全局整数变量或 12 字节（每个整数是 4 字节）。值得注意的是，未初始化的全局变量默认设置为 *零*。对于未初始化变量，没有其他可以想象出的值。
- en: Let's now talk about the next segment in the static memory layout; the Data
    segment.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来谈谈静态内存布局中的下一个段；数据段。
- en: Data segment
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据段
- en: 'In order to show what type of variables are stored in the Data segment, we
    are going to declare more global variables, but this time we initialize them with
    non-zero values. The following example, *example 4.3*, expands *example 4.2* and
    adds two new initialized global variables:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示存储在数据段中的变量类型，我们将声明更多的全局变量，但这次我们用非零值初始化它们。以下示例，*示例 4.3*，扩展了 *示例 4.2* 并添加了两个新的初始化全局变量：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Code Box 4-3 [ExtremeC_examples_chapter4_3.c]: A minimal C program with both
    initialized and uninitialized global variables'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 4-3 [ExtremeC_examples_chapter4_3.c]：一个包含已初始化和未初始化全局变量的最小 C 程序
- en: 'The following shell box shows the output of the `size` command, in Linux, and
    for *example 4.3*:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 shell 框显示 Linux 中 `size` 命令的输出，以及 *示例 4.3*：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Shell Box 4-7: Using the size command to see the static segments of ex4_3-linux.out'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 4-7：使用 size 命令查看 ex4_3-linux.out 的静态段
- en: We know that the Data segment is used to store the initialized global variables
    set to a non-zero value. If you compare the output of the `size` command for *examples
    4.2* and *4.3*, you can easily see that the Data segment is increased by 9 bytes,
    which is the sum of the sizes of the two newly added global variables (one 8-byte
    `double` and one 1-byte `char`).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道数据段用于存储设置为非零值的初始化全局变量。如果你比较 *示例 4.2* 和 *4.3* 的 `size` 命令输出，你可以很容易地看到数据段增加了
    9 字节，这是两个新添加的全局变量尺寸之和（一个 8 字节的 `double` 和一个 1 字节的 `char`）。
- en: 'Let''s look at the changes in macOS:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 macOS 中的变化：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Shell Box 4-8: Using the size command to see the static segments of ex4_3-macos.out'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 4-8：使用 size 命令查看 ex4_3-macos.out 的静态段
- en: In the first run, we see no changes since the size of all global variables summed
    together is still way below 4KB. But in the second run, we see a new section as
    part of the `_DATA` segment; the `__data` section. The memory allocated for this
    section is 9 bytes, and it is in accordance with the size of the newly introduced
    initialized global variables. And still, we have 12 bytes for uninitialized global
    variables as we had in *example 4.2*, and in macOS.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次运行中，我们没有看到任何变化，因为所有全局变量的总和仍然远低于 4KB。但在第二次运行中，我们看到 `_DATA` 段的一部分出现了一个新的部分；`__data`
    部分。为这个部分分配的内存是 9 字节，这与新引入的初始化全局变量的尺寸相符合。而且，我们仍然有 12 字节用于未初始化的全局变量，就像在 *示例 4.2*
    和 macOS 中一样。
- en: On a further note, the `size` command only shows the size of the segments, but
    not their contents. There are other commands, specific to each operating system,
    that can be used to inspect the content of segments found in an object file. For
    instance, in Linux, you have `readelf` and `objdump` commands in order to see
    the content of *ELF* files. These tools can also be used to probe the static memory
    layout inside the object files. As part of two previous chapters we explored some
    of these commands.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步来说，`size` 命令只显示段的尺寸，但不显示其内容。有其他特定于每个操作系统的命令可以用来检查在对象文件中找到的段的内容。例如，在 Linux
    中，你有 `readelf` 和 `objdump` 命令来查看 *ELF* 文件的内容。这些工具也可以用来探测对象文件内部的静态内存布局。作为前两章的一部分，我们探索了一些这些命令。
- en: 'Other than global variables, we can have some static variables declared inside
    a function. These variables retain their values while calling the same function
    multiple times. These variables can be stored either in the Data segment or the
    BSS segment depending on the platform and whether they are initialized or not.
    The following code box demonstrates how to declare some static variables within
    a function:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 除了全局变量之外，我们还可以在函数内部声明一些静态变量。这些变量在多次调用同一函数时保留其值。这些变量可以存储在数据段或 BSS 段中，具体取决于平台以及它们是否已初始化。以下代码框演示了如何在函数内部声明一些静态变量：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Code Box 4-4: Declaration of two static variables, one initialized and the
    other one uninitialized'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 4-4：两个静态变量的声明，一个已初始化，另一个未初始化
- en: As you see in *Code Box 4-4*, the `i` and `j` variables are static. The `i`
    variable is uninitialized and the `j` variable is initialized with value `1`.
    It doesn't matter how many times you enter and leave the `func` function, these
    variables keep their most recent values.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在*Code Box 4-4*中看到的，`i`和`j`变量是静态的。`i`变量未初始化，而`j`变量初始化为值`1`。无论你进入和离开`func`函数多少次，这些变量都保持它们最新的值。
- en: To elaborate more on how this is done, at runtime, the `func` function has access
    to these variables located in either the Data segment or the BSS segment, which
    has a static lifetime. That's basically why these variables are called *static*.
    We know that the `j` variable is located in the Data segment simply because it
    has an initial value, and the `i` variable is supposed to be inside the BSS segment
    since it is not initialized.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更详细地说明这是如何完成的，在运行时，`func`函数可以访问位于Data段或BSS段中的这些变量，这些段具有静态生命周期。这就是为什么这些变量被称为*静态*的原因。我们知道`j`变量位于Data段，仅仅因为它有一个初始值，而`i`变量应该位于BSS段，因为它没有初始化。
- en: Now, we want to introduce the second command to examine the content of the BSS
    segment. In Linux, the `objdump` command can be used to print out the content
    of memory segments found in an object file. This corresponding command in macOS
    is `gobjdump` which should be installed first.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想介绍第二个命令来检查BSS段的内容。在Linux中，可以使用`objdump`命令打印出在目标文件中找到的内存段的内容。在macOS中对应的命令是`gobjdump`，需要首先安装。
- en: 'As part of *example 4.4*, we try to examine the resulting executable object
    file to find the data written to the Data segment as some global variables. The
    following code box shows the code for *example 4.4*:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 作为*example 4.4*的一部分，我们试图检查生成的可执行目标文件，以找到写入Data段的某些全局变量的数据。以下代码框显示了*example 4.4*的代码：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Code Box 4-5 [ExtremeC_examples_chapter4_4.c]: Some initialized global variables
    which should be written to the Data segment'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 4-5 [ExtremeC_examples_chapter4_4.c]：一些应该写入Data段的已初始化全局变量
- en: The preceding code is easy to follow. It just declares three global variables
    with some initial values. After compilation, we need to dump the content of the
    Data segment in order to find the written values.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码很容易理解。它只是声明了三个具有一些初始值的全局变量。在编译后，我们需要转储Data段的内容，以便找到写入的值。
- en: 'The following commands will demonstrate how to compile and use `objdump` to
    see the content of the Data segment:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将演示如何编译和使用`objdump`来查看Data段的内容：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Shell Box 4-9: Using the objdump command to see the content of the Data segment'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 4-9：使用`objdump`命令查看Data段的内容
- en: Let's explain how the preceding output, and especially the contents of the section
    `.data`, should be read. The first column on the left is the address column. The
    next four columns are the contents, and each of them is showing `4` bytes of data.
    So, in each row, we have the contents of 16 bytes. The last column on the right
    shows the ASCII representation of the same bytes shown in the middle columns.
    A dot character means that the character cannot be shown using alphanumerical
    characters. Note that the option `-s` tells `objdump` to show the full content
    of the chosen section and the option `-j .data` tells it to show the content of
    the section `.data`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来解释一下前面的输出应该如何读取，尤其是关于`.data`部分的说明。最左侧的列是地址列。接下来的四列是内容列，每列显示`4`个字节数据。因此，在每一行中，我们都有16个字节的内容。最右侧的列显示了中间列中相同字节ASCII表示。点字符表示该字符无法使用字母数字字符显示。请注意，选项`-s`告诉`objdump`显示所选部分的全部内容，而选项`-j
    .data`告诉它显示`.data`部分的内容。
- en: The first line is 16 bytes filled by zeros. There is no variable stored here,
    so nothing special for us. The second line shows the contents of the Data segment
    starting with the address `0x601030`. The first 4 bytes is the value stored in
    the `x` variable found in *example 4.4*. The next 4 bytes also contain the value
    for the `y` variable. The final 6 bytes are the characters inside the `z` array.
    The contents of `z` can be clearly seen in the last column.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是16个字节填充为零。这里没有存储变量，所以对我们来说没有什么特殊之处。第二行显示了从地址`0x601030`开始的Data段的内容。前4个字节是`example
    4.4`中找到的`x`变量的值。接下来的4个字节也包含了`y`变量的值。最后的6个字节是`z`数组中的字符。`z`的内容在最后一列中可以清楚地看到。
- en: If you pay enough attention to the content shown in *Shell Box 4-9*, you see
    that despite the fact that we write 33, in decimal base, as `0x00000021`, in hexadecimal
    base it is stored differently in the segment. It is stored as `0x21000000`. This
    is also true for the content of the `y` variable. We have written it as `0x12153467`,
    but it is stored differently as `0x67341512`. It seems that the order of bytes
    is reversed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你足够关注 *Shell Box 4-9* 中显示的内容，你会看到，尽管我们以十进制基数写作 33，作为 `0x00000021` 的十六进制基数，它在段中的存储方式不同。它被存储为
    `0x21000000`。`y` 变量的内容也是如此。我们将其写作 `0x12153467`，但它以不同的方式存储为 `0x67341512`。这似乎是字节顺序被反转了。
- en: The effect explained is because of the *endianness* concept. Generally, we have
    two different types of endianness, *big-endian* and *little-endian*. The value
    `0x12153467` is the big-endian representation for the number `0x12153467`, as
    the biggest byte, `0x12`, comes first. But the value `0x67341512` is the little-endian
    representation for the number `0x12153467`, as the smallest byte, `0x67`, comes
    first.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 解释的效果是由于**字节序**的概念。通常，我们有两种不同的字节序类型，**大端序**和**小端序**。值 `0x12153467` 是数字 `0x12153467`
    的大端序表示，因为最大的字节 `0x12` 是第一个。但值 `0x67341512` 是数字 `0x12153467` 的小端序表示，因为最小的字节 `0x67`
    是第一个。
- en: No matter what the endianness is, we always read the correct value in C. Endianness
    is a property of the CPU and with a different CPU you may get a different byte
    order in your final object files. This is one of the reasons why you cannot run
    an executable object file on hardware with different endianness.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 无论字节序如何，我们总是在 C 中读取正确的值。字节序是 CPU 的属性，不同的 CPU 可能会在最终的目标文件中得到不同的字节序。这也是为什么你不能在不同的字节序硬件上运行可执行目标文件的原因之一。
- en: 'It would be interesting to see the same output on a macOS machine. The following
    shell box demonstrates how to use the `gobjdump` command in order to see the content
    of the Data segment:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 机器上看到相同的输出将很有趣。以下 shell 框演示了如何使用 `gobjdump` 命令来查看数据段的内容：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Shell Box 4-10: Using the gobjdump command in macOS to see the content of the
    Data segment'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 4-10：使用 macOS 中的 gobjdump 命令查看数据段的内容
- en: It should be read exactly like the Linux output found as part of *Shell Code
    4-9*. As you see, in macOS, there are no 16-byte zero headers in the data segment.
    Endianness of the contents also shows that the binary has been compiled for a little-endian
    processor.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 应该像在 *Shell Code 4-9* 中找到的 Linux 输出一样精确地读取。正如你所见，在 macOS 中，数据段中没有 16 字节的零头。内容字节序也表明，二进制文件是为小端序处理器编译的。
- en: As a final note in this section, other tools like `readelf` in Linux and `dwarfdump`
    in macOS can be used in order to inspect the content of object files. The binary
    content of the object files can also be read using tools such as `hexdump`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后，其他工具如 Linux 中的 `readelf` 和 macOS 中的 `dwarfdump` 可以用来检查目标文件的内容。目标文件的二进制内容也可以使用
    `hexdump` 等工具读取。
- en: In the following section, we will discuss the Text segment and how it can be
    inspected using `objdump`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论文本段以及如何使用 `objdump` 检查它。
- en: Text segment
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本段
- en: As we know from *Chapter 2*, *Compilation and Linking*, the linker writes the
    resulting machine-level instructions into the final executable object file. Since
    the Text segment, or the Code segment, contains all the machine-level instructions
    of a program, it should be located in the executable object file, as part of its
    static memory layout. These instructions are fetched by the processor and get
    executed at runtime when the process is running.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从 *第二章*，*编译和链接* 中所知，链接器将生成的机器级指令写入最终的执行目标文件。由于文本段，或代码段，包含程序的所有机器级指令，它应该位于执行目标文件中，作为其静态内存布局的一部分。这些指令由处理器检索并在进程运行时执行。
- en: 'To dive deeper, let''s have a look at the Text segment of a real executable
    object file. For this purpose, we propose a new example. The following code box
    shows *example 4.5*, and as you see, it is just an empty `main` function:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解，让我们看看一个真实可执行目标文件的文本段。为此，我们提出一个新的例子。下面的代码框展示了 *示例 4.5*，正如你所见，它只是一个空的 `main`
    函数：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Code Box 4-6 [ExtremeC_examples_chapter4_5.c]: A minimal C program'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 4-6 [ExtremeC_examples_chapter4_5.c]：一个最小的 C 程序
- en: We can use the `objdump` command to dump the various parts of the resulting
    executable object file. Note that the `objdump` command is only available in Linux,
    while other operating systems have their own set of commands to do the same.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `objdump` 命令转储生成的执行对象文件的各个部分。请注意，`objdump` 命令仅在 Linux 中可用，而其他操作系统有自己的命令集来完成相同的工作。
- en: 'The following shell box demonstrates using the `objdump` command to extract
    the content of various sections present in the executable object file resulting
    from *example 4.5*. Note that the output is shortened in order to only show the
    `main` function''s corresponding section and its assembly instructions:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 Shell Box 展示了使用 `objdump` 命令提取由 *示例 4.5* 生成的可执行对象文件中存在的各个节的内容。请注意，输出被缩短了，只显示了
    `main` 函数对应的节及其汇编指令：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Shell Box 4-11: Using objdump to show the content of the section corresponding
    to the main function'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 4-11：使用 objdump 显示与主函数对应的节的内容
- en: 'As you see in the preceding shell box, there are various sections containing
    machine-level instructions: the `.text`, `.init`, and `.plt` sections and some
    others, which all together allow a program to become loaded and running. All of
    these sections are part of the same Text segment found in the static memory layout,
    inside the executable object file.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在先前的 Shell Box 中所见，存在各种包含机器级指令的节：`.text`、`.init` 和 `.plt` 节以及其他一些节，所有这些节共同允许程序被加载并运行。所有这些节都是静态内存布局中可执行对象文件内的同一个文本段的一部分。
- en: Our C program, written for *example 4.5*, had only one function, the `main`
    function, but as you see, the final executable object file has a dozen other functions.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为 *示例 4.5* 编写的 C 程序只有一个函数，即 `main` 函数，但正如你所见，最终的执行对象文件中还有一打其他的函数。
- en: The preceding output, seen as part of *Shell Box 4-11*, shows that the `main`
    function is not the first function to be called in a C program and there are logics
    before and after `main` that should be executed. As explained in *Chapter 2*,
    *Compilation and Linking*, in Linux, these functions are usually borrowed from
    the `glibc` library, and they are put together by the linker to form the final
    executable object file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的输出，作为 *Shell Box 4-11* 的一部分，显示 `main` 函数不是 C 程序中首先被调用的函数，并且在 `main` 之前和之后还有逻辑应该被执行。正如
    *第二章* 中所解释的，在 Linux 中，这些函数通常是从 `glibc` 库中借用的，并且由链接器组合在一起形成最终的执行对象文件。
- en: In the following section, we start to probe the dynamic memory layout of a process.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将开始探测进程的动态内存布局。
- en: Probing dynamic memory layout
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探测动态内存布局
- en: The dynamic memory layout is actually the runtime memory of a process, and it
    exists as long as the process is running. When you execute an executable object
    file, a program called *loader* takes care of the execution. It spawns a new process
    and it creates the initial memory layout which is supposed to be dynamic. To form
    this layout, the segments found in the static layout will be copied from the executable
    object file. More than that, two new segments will also be added to it. Only then
    can the process proceed and become running.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 动态内存布局实际上是进程的运行时内存，只要进程在运行，它就存在。当你执行一个可执行对象文件时，一个名为 *loader* 的程序负责执行。它启动一个新的进程，并创建初始的内存布局，这个布局应该是动态的。为了形成这个布局，静态布局中找到的段将从可执行对象文件中复制过来。不仅如此，还会添加两个新的段。只有这样，进程才能继续并运行。
- en: In short, we expect to have five segments in the memory layout of a running
    process. Three of these segments are directly copied from the static layout found
    in the executable object file. The two newly added segments are called Stack and
    Heap segments. These segments are dynamic, and they exist only when the process
    is running. This means that you cannot find any trace of them as part of the executable
    object file.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们期望在运行进程的内存布局中有五个段。其中三个段直接从可执行对象文件中找到的静态布局复制而来。新增的两个段被称为栈段和堆段。这些段是动态的，并且只有在进程运行时才存在。这意味着你无法在可执行对象文件中找到它们的任何痕迹。
- en: In this section, our ultimate goal is to probe the Stack and Heap segments and
    introduce tools and places in an operating system which can be used for this purpose.
    From time to time, we might refer to these segments as the process's dynamic memory
    layout, without considering the other three segments copied from the object file,
    but you should always remember that the dynamic memory of a process consists of
    all five segments together.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们的最终目标是探测栈和堆段，并介绍操作系统中的工具和位置，这些工具和位置可以用于此目的。不时地，我们可能会将这些段称为进程的动态内存布局，而不考虑从对象文件中复制的其他三个段，但你应该始终记住，进程的动态内存由这五个段共同组成。
- en: The Stack segment is the default memory region where we allocate variables from.
    It is a limited region in terms of size, and you cannot hold big objects in it.
    In contrast, the Heap segment is a bigger and adjustable region of memory which
    can be used to hold big objects and huge arrays. Working with the Heap segment
    requires its own API which we introduce as part of our discussion.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 栈段是我们从其中分配变量的默认内存区域。在大小方面，它是一个有限的区域，你不能在其中存放大型对象。相比之下，堆段是一个更大且可调整的内存区域，可以用来存放大型对象和巨大的数组。与堆段一起工作需要自己的
    API，我们将在我们的讨论中介绍。
- en: Remember, dynamic memory layout is different from *Dynamic Memory Allocation*.
    You should not mix these two concepts, since they are referring to two different
    things! As we progress, we'll learn more about different types of memory allocations,
    especially dynamic memory allocation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，动态内存布局与*动态内存分配*不同。你不应该混淆这两个概念，因为它们指的是两件不同的事情！随着我们的进展，我们将了解更多关于不同类型的内存分配，特别是动态内存分配。
- en: The five segments found in the dynamic memory of a process are referring to
    parts of the main memory that are already *allocated*, *dedicated*, and *private*
    to a running process. These segments, excluding the Text segment, which is literally
    static and constant, are dynamic in a sense that their contents are always changing
    at runtime. That's due to the fact that these segments are constantly being modified
    by the algorithm that the process is executing.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 进程动态内存中的五个部分指的是主内存中已经*分配*、*专用*和*私有*给运行进程的部分。这些部分，除了文本段，它是字面意义上的静态和常量，在某种程度上是动态的，因为它们的内
    容在运行时总是变化的。这是由于这些部分不断地被进程执行的算法修改。
- en: Inspecting the dynamic memory layout of a process requires its own procedure.
    This implies that we need to have a running process before being able to probe
    its dynamic memory layout. This requires us to write examples which remain running
    for a fairly long time in order to keep their dynamic memory in place. Then, we
    can use our inspection tools to study their dynamic memory structure.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 检查进程的动态内存布局需要特定的程序。这意味着在能够探测其动态内存布局之前，我们需要有一个正在运行的过程。这要求我们编写一些长时间运行以保持其动态内存不变的例子。然后，我们可以使用我们的检查工具来研究它们的动态内存结构。
- en: In the following section, we give an example on how to probe the structure of
    dynamic memory.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们给出了如何探测动态内存结构的示例。
- en: Memory mappings
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存映射
- en: 'Let''s start with a simple example. *Example 4.6* will be running for an indefinite
    amount of time. This way, we have a process that never dies, and in the meantime,
    we can probe its memory structure. And of course, we can *kill* it whenever we
    are done with the inspection. You can find the example in the following code box:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的例子开始。*示例 4.6* 将会运行一个不确定的时间长度。这样，我们就有了一个永远不会结束的过程，同时，我们可以在检查过程中探测其内存结构。当然，我们可以在检查完成后随时*终止*它。你可以在下面的代码框中找到这个例子：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Code Box 4-6 [ExtremeC_examples_chapter4_6.c]: Example 4.6 used for probing
    dynamic memory layout'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 4-6 [ExtremeC_examples_chapter4_6.c]：用于探测动态内存布局的示例 4.6
- en: As you see, the code is just an infinite loop, which means that the process
    will run forever. So, we have enough time to inspect the process's memory. Let's
    first build it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，代码只是一个无限循环，这意味着进程将永远运行。因此，我们有足够的时间检查进程的内存。让我们首先构建它。
- en: '**Note**:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: The `unistd.h` header is available only on Unix-like operating systems; to be
    more precise, in POSIX-compliant operating systems. This means that on Microsoft
    Windows, which is not POSIX-compliant, you have to include the `windows.h` header
    instead.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`unistd.h` 头文件仅在类 Unix 操作系统上可用；更准确地说，在符合 POSIX 标准的操作系统中。这意味着在不符合 POSIX 标准的
    Microsoft Windows 上，你必须包含 `windows.h` 头文件。'
- en: 'The following shell box shows how to compile the example in Linux:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 shell 框展示了如何在 Linux 中编译这个例子：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Shell Box 4-12: Compiling example 4.6 in Linux'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 4-12：在 Linux 中编译示例 4.6
- en: 'Then, we run it as follows. In order to use the same prompt for issuing further
    commands while the process is running, we should start the process in the background:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们按照以下方式运行它。为了在进程运行期间使用相同的提示符来发出进一步的命令，我们应该在后台启动进程：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Shell Box 4-13: Running example 4.6 in the background'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 4-13：在后台运行示例 4.6
- en: The process is now running in the background. According to the output, the PID
    of the recently started process is 402, and we will use this PID to kill it in
    the future. The PID is different every time you run a program; therefore, you'll
    probably see a different PID on your computer. Note that whenever you run a process
    in the background, the shell prompt returns immediately, and you can issue further
    commands.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 进程现在正在后台运行。根据输出，最近启动的进程的 PID 是 402，我们将使用这个 PID 在将来将其终止。每次运行程序时，PID 都会不同；因此，您可能在您的计算机上看到不同的
    PID。请注意，每次您在后台运行进程时，shell 提示符都会立即返回，您可以发出进一步的命令。
- en: '**Note**:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: 'If you have the PID (Process ID) of a process, you can easily end it using
    the `kill` command. For example, if the PID is 402, the following command will
    work in Unix-like operating systems: `kill -9 402`.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个进程的 PID（进程 ID），您可以使用 `kill` 命令轻松地结束它。例如，如果 PID 是 402，以下命令将在类 Unix 操作系统中生效：`kill
    -9 402`。
- en: The PID is the identifier we use to inspect the memory of a process. Usually,
    an operating system provides its own specific mechanism to query various properties
    of a process based on its PID. But here, we are only interested in the dynamic
    memory of a process and we'll use the available mechanism in Linux to find more
    about the dynamic memory structure of the above running process.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: PID 是我们用来检查进程内存的标识符。通常，操作系统会提供自己的特定机制，根据 PID 查询进程的各种属性。但在这里，我们只对进程的动态内存感兴趣，我们将使用
    Linux 中可用的机制来了解更多关于上述运行进程的动态内存结构。
- en: On a Linux machine, the information about a process can be found in files under
    the `/proc` directory. It uses a special filesystem called *procfs*. This filesystem
    is not an ordinary filesystem meant for keeping actual files, but it is more of
    a hierarchical interface to query about various properties of an individual process
    or the system as a whole.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 机器上，进程的信息可以在 `/proc` 目录下的文件中找到。它使用一个称为 *procfs* 的特殊文件系统。这个文件系统不是一个普通的文件系统，用于保存实际的文件，而更像是一个查询单个进程或整个系统各种属性的分层接口。
- en: '**Note**:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: procfs is not limited to Linux. It is usually part of Unix-like operating systems,
    but not all Unix-like operating systems use it. For example, FreeBSD uses this
    filesystem, but macOS doesn't.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: procfs 不仅限于 Linux。它通常是类 Unix 操作系统的一部分，但并非所有类 Unix 操作系统都使用它。例如，FreeBSD 使用这个文件系统，但
    macOS 不使用。
- en: Now, we are going to use procfs to see the memory structure of the running process.
    The memory of a process consists of a number of *memory mappings*. Each memory
    mapping represents a dedicated region of memory which is mapped to a specific
    file or segment as part of the process. Shortly, you'll see that both Stack and
    Heap segments have their own memory mappings in each process.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用 procfs 来查看运行进程的内存结构。进程的内存由多个 *内存映射* 组成。每个内存映射代表一个专用的内存区域，该区域作为进程的一部分映射到特定的文件或段。简而言之，您将看到栈（Stack）和堆（Heap）段在每个进程中都有自己的内存映射。
- en: One of the things that you can use procfs for is to observe the current memory
    mappings of the process. Next, we are going to show this.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 procfs 做的事情之一是观察进程当前的内存映射。接下来，我们将展示这一点。
- en: 'We know that the process is running with PID 402\. Using the `ls` command,
    we can see the contents of the `/proc/402` directory, shown as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道进程正在以 PID 402 运行。使用 `ls` 命令，我们可以看到 `/proc/402` 目录的内容，如下所示：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Shell Box 4-14: Listing the content of /proc/402'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 4-14：列出 /proc/402 的内容
- en: 'As you can see, there are many files and directories under the `/proc/402`
    directory. Each of these files and directories corresponds to a specific property
    of the process. For querying the memory mappings of the process, we have to see
    the contents of the file `maps` under the PID directory. We use the `cat` command
    to dump the contents of the `/proc/402/maps` file. It can be seen as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在 `/proc/402` 目录下有许多文件和目录。这些文件和目录中的每一个都对应于进程的特定属性。为了查询进程的内存映射，我们必须查看 PID
    目录下 `maps` 文件的内容。我们使用 `cat` 命令来转储 `/proc/402/maps` 文件的内容。如下所示：
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Shell Box 4-15: Dumping the content of /proc/402/maps'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 4-15：导出 /proc/402/maps 的内容
- en: 'As you see in *Shell Box 4-15*, the result consists of a number of rows. Each
    row represents a memory mapping that indicates a range of memory addresses (a
    region) that are allocated and mapped to a specific file or segment in the dynamic
    memory layout of the process. Each mapping has a number of fields separated by
    one or more spaces. Next, you can find the descriptions of these fields from left
    to right:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在 *Shell Box 4-15* 中所见，结果由多行组成。每一行代表一个内存映射，它指示一组内存地址（一个区域）被分配并映射到进程动态内存布局中的特定文件或段。每个映射由一个或多个空格分隔的字段组成。接下来，你可以从左到右找到这些字段的描述：
- en: '**Address range**: These are the start and end addresses of the mapped range.
    You can find a file path in front of them if the region is mapped to a file. This
    is a smart way to map the same loaded shared object file in various processes.
    We have talked about this as part of *Chapter 3*, *Object Files*.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**地址范围**：这是映射范围的起始和结束地址。如果该区域映射到文件，则可以在它们前面找到文件路径。这是一种智能地映射在各个进程中加载的相同共享对象文件的方法。我们已经在
    *第3章*，*对象文件* 中讨论了这一点。'
- en: '**Permissions**: This indicates whether the content can be executed (`x`),
    read (`r`), or modified (`w`). The region can also be shared (`s`) by the other
    processes or be private (`p`) only to the owning process.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**权限**：这表示内容是否可执行（`x`）、可读（`r`）或可修改（`w`）。该区域也可以由其他进程共享（`s`）或仅由拥有进程私有（`p`）。'
- en: '**Offset**: If the region is mapped to a file, this is the offset from the
    beginning of the file. It is usually 0 if the region is not mapped to a file.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**偏移量**：如果该区域映射到一个文件，这将是从文件开始的偏移量。如果该区域未映射到文件，则通常为0。'
- en: '**Device**: If the region is mapped to a file, this would be the device number
    (in the form of m:n), indicating a device that contains the mapped file. For example,
    this would be the device number of the hard disk that contains a shared object
    file.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备**：如果该区域映射到一个文件，这将是指示包含映射文件的设备号（形式为 m:n），表示包含映射文件的设备。例如，这将是指向包含共享对象文件的硬盘的设备号。'
- en: '**The inode**: If the region is mapped to a file, that file should reside on
    a filesystem. Then, this field would be the inode number of the file in that filesystem.
    An *inode* is an abstract concept within filesystems such as *ext4* which are
    mostly used in Unix-like operating systems. Each inode can represent both files
    and directories. Every inode has a number that is used to access its content.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**inode**：如果该区域映射到一个文件，那么该文件应该位于一个文件系统上。然后，这个字段将是该文件系统中文件的inode号。*inode* 是在类似
    *ext4* 这样的文件系统中的一个抽象概念，这些文件系统主要在类Unix操作系统中使用。每个inode可以代表文件和目录。每个inode都有一个用于访问其内容的数字。'
- en: '**Pathname or description**: If the region is mapped to a file, this would
    be the path to that file. Otherwise, it would be left empty, or it would describe
    the purpose of the region. For example, `[stack]` indicates that the region is
    actually the Stack segment.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路径名或描述**：如果该区域映射到一个文件，这将是指向该文件的路径。否则，它将被留空，或者它将描述该区域的目的。例如，`[stack]` 表示该区域实际上是栈段。'
- en: The `maps` file provides even more useful information regarding the dynamic
    memory layout of a process. We'll need a new example to properly demonstrate this.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`maps` 文件提供了有关进程动态内存布局的更多有用信息。我们需要一个新的例子来正确演示这一点。'
- en: Stack segment
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈段
- en: First, let's talk more about the Stack segment. The Stack is a crucial part
    of the dynamic memory in every process, and it exists in almost all architectures.
    You have seen it in the memory mappings described as `[stack]`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们更详细地谈谈栈段。栈是每个进程动态内存的一个关键部分，它几乎存在于所有架构中。你在描述为 `[stack]` 的内存映射中已经看到了它。
- en: Both Stack and Heap segments have dynamic contents which are constantly changing
    while the process is running. It is not easy to see the dynamic contents of these
    segments and most of the time you need a debugger such as `gdb` to go through
    the memory bytes and read them while a process is running.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 栈和堆段都具有动态内容，这些内容在进程运行过程中不断变化。查看这些段的动态内容并不容易，大多数时候你需要一个调试器，如 `gdb`，在进程运行时遍历内存字节并读取它们。
- en: As pointed out before, the Stack segment is usually limited in size, and it
    is not a good place to store big objects. If the Stack segment is full, the process
    cannot make any further function calls since the function call mechanism relies
    heavily on the functionality of the Stack segment.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，栈段通常大小有限，不是一个存储大对象的好地方。如果栈段满了，由于函数调用机制严重依赖于栈段的功能，进程将无法进行任何进一步的函数调用。
- en: If the Stack segment of a process becomes full, the process gets terminated
    by the operating system. *Stack overflow* is a famous error that happens when
    the Stack segment becomes full. We discuss the function call mechanism in future
    paragraphs.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个进程的栈段满了，操作系统会终止该进程。"栈溢出"是一个著名的错误，当栈段满了时发生。我们将在未来的段落中讨论函数调用机制。
- en: 'As explained before, the Stack segment is a default memory region that variables
    are allocated from. Suppose that you''ve declared a variable inside a function,
    as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，栈段是默认的内存区域，变量是从这里分配的。假设你在函数内部声明了一个变量，如下所示：
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Code Box 4-7: Declaring a local variable which has its memory allocated from
    the Stack segment'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 4-7：声明一个从栈段分配内存的局部变量
- en: In the preceding function, while declaring the variable, we have not mentioned
    anything to let the compiler know which segment the variable should be allocated
    from. Because of this, the compiler uses the Stack segment by default. The Stack
    segment is the first place that allocations are made from.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，声明变量时，我们没有提到任何内容让编译器知道变量应该从哪个段分配。因此，编译器默认使用栈段。栈段是分配的第一个地方。
- en: As its name implies, it is a *stack*. If you declare a local variable, it becomes
    allocated on top of the Stack segment. When you're leaving the scope of the declared
    local variable, the compiler has to pop the local variables first in order to bring
    up the local variables declared in the outer scope.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，它是一个*栈*。如果你声明一个局部变量，它就会分配在栈段顶部。当你离开声明局部变量的作用域时，编译器必须首先弹出局部变量，以便提升外部作用域中声明的局部变量。
- en: '**Note**:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: Stack, in its abstract form, is a **First In, Last Out** (**FILO**) or **Last
    In, First Out** (**LIFO**) data structure. Regardless of the implementation details,
    each entry is stored (pushed) on top of the stack, and it will be buried by further
    entries. One entry cannot be popped out without removing the above entries first.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 栈在抽象形式上是一个**先进先出**（**FILO**）或**后进先出**（**LIFO**）的数据结构。无论实现细节如何，每个条目都是存储（推入）在栈顶的，并且将被后续条目覆盖。如果不先移除上面的条目，就无法弹出任何一个条目。
- en: Variables are not the only entities that are stored in the Stack segment. Whenever
    you make a function call, a new entry called a *stack frame* is placed on top
    of the Stack segment. Otherwise, you cannot return to the calling function or
    return the result back to the caller.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在栈段中的不仅仅是变量。每次你调用一个函数时，都会在栈段顶部放置一个新的条目，称为*栈帧*。否则，你无法返回调用函数或将结果返回给调用者。
- en: Having a healthy stacking mechanism is vital to have a working program. Since
    the size of the Stack is limited, it is a good practice to declare small variables
    in it. Also, the Stack shouldn't be filled by too many stack frames as a result
    of making infinite *recursive* calls or too many function calls.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个健康的堆栈机制对于拥有一个正常工作的程序至关重要。由于栈的大小有限，声明小变量在其中是一个好习惯。此外，不应让太多的栈帧填充栈，这是由于无限递归调用或过多的函数调用造成的。
- en: From a different perspective, the Stack segment is a region used by you, as
    a programmer, to keep your data and declare the local variables used in your algorithms,
    and by the operating system, as the program runner, to keep the data needed for
    its internal mechanisms to execute your program successfully.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一个角度来看，栈段是程序员用来存储数据和声明算法中使用的局部变量的区域，以及操作系统作为程序运行者用来存储执行程序所需的数据的区域。
- en: In this sense, you should be careful when working with this segment because
    misusing it or corrupting its data can interrupt the running process or even make
    it crash. The Heap segment is the memory segment that is only managed by the programmer.
    We will cover the Heap segment in the next section.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个意义上，当你处理这个段时应该小心，因为误用它或损坏其数据可能会中断运行过程，甚至导致程序崩溃。堆段是仅由程序员管理的内存段。我们将在下一节中介绍堆段。
- en: It is not easy to see the contents of the Stack segment from outside if we are
    only using the tools we've introduced for probing the static memory layout. This
    part of memory contains private data and can be sensitive. It is also private
    to the process, and other processes cannot read or modify it.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只使用我们介绍的工具来探测静态内存布局，那么从外部看到栈段的内容并不容易。这部分内存包含私有数据，可能很敏感。它也是进程私有的，其他进程无法读取或修改它。
- en: So, for sailing through the Stack memory, one has to attach something to a process
    and see the Stack segment through the eyes of that process. This can be done using
    a *debugger* program. A debugger attaches to a process and allows a programmer
    to control the target process and investigate its memory content. We will use
    this technique and examine the Stack memory in the following chapter. For now,
    we leave the Stack segment to discuss more about the Heap segment. We will get
    back to the Stack in the next chapter.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了在栈内存中航行，必须将某个东西附加到进程上，并通过该进程的视角查看栈段。这可以通过使用 *调试器* 程序来完成。调试器附加到进程上，允许程序员控制目标进程并调查其内存内容。我们将在下一章中使用这项技术来检查栈内存。现在，我们将栈段留给讨论堆段。我们将在下一章回到栈。
- en: Heap segment
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆段
- en: The following example, *example 4.7*, shows how memory mappings can be used
    to find regions allocated for the Heap segment. It is quite similar to *example
    4.6*, but it allocates a number of bytes from the Heap segment before entering
    the infinite loop.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例，*示例 4.7*，展示了如何使用内存映射来找到为堆段分配的区域。它与 *示例 4.6* 非常相似，但在进入无限循环之前，它从堆段分配了一部分字节。
- en: Therefore, just like we did for *example 4.6*, we can go through the memory
    mappings of the running process and see which mapping refers to the Heap segment.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，就像我们对 *示例 4.6* 所做的那样，我们可以遍历运行进程的内存映射，看看哪个映射指向堆段。
- en: 'The following code box contains the code for *example 4.7*:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框包含了 *示例 4.7* 的代码：
- en: '[PRE23]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Code Box 4-8 [ExtremeC_examples_chapter4_7.c]: Example 4.7 used for probing
    the Heap segment'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 4-8 [ExtremeC_examples_chapter4_7.c]：用于探测堆段的示例 4.7
- en: In the preceding code, we used the `malloc` function. It's the primary way to
    allocate extra memory from the Heap segment. It accepts the number of bytes that
    should be allocated, and it returns a generic pointer.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了 `malloc` 函数。这是从堆段分配额外内存的主要方式。它接受应该分配的字节数，并返回一个通用指针。
- en: As a reminder, a generic pointer (or a void pointer) contains a memory address
    but it cannot be *dereferenced* and used directly. It should be cast to a specific
    pointer type before being used.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，通用指针（或空指针）包含一个内存地址，但它不能被 *解引用* 并直接使用。在使用之前，它应该被转换为特定的指针类型。
- en: 'In *example 4.7*, we allocate 1024 bytes (or 1KB) before entering the loop.
    The program also prints the address of the pointer received from `malloc` before
    starting the loop. Let''s compile the example and run it as we did for *example
    4.7*:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *示例 4.7* 中，我们在进入循环之前分配了 1024 字节（或 1KB）。程序还在开始循环之前打印了从 `malloc` 接收到的指针的地址。让我们编译这个示例并像对
    *示例 4.7* 那样运行它：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Shell Box 4-16: Compiling and running example 4.7'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 4-16：编译和运行示例 4.7
- en: Now, the process is running in the background, and it has obtained the PID 3451\.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，进程在后台运行，并且已经获得了 PID 3451。
- en: 'Let''s see what memory regions have been mapped for this process by looking
    at its `maps` file:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看其 `maps` 文件来查看这个进程映射了哪些内存区域：
- en: '[PRE25]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Shell Box 4-17: Dumping the content of /proc/3451/maps'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 4-17：导出 /proc/3451/maps 的内容
- en: If you look at *Shell Box 4-17* carefully, you will see a new mapping which
    is highlighted, and it is being described by `[heap]`. This region has been added
    because of using the `malloc` function. If you calculate the size of the region,
    it is `0x21000` bytes or 132 KB. This means that to allocate only 1 KB in the
    code, a region of the size 132 KB has been allocated.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细查看 *Shell Box 4-17*，你会看到一个新映射被突出显示，并且它被描述为 `[heap]`。这个区域是由于使用了 `malloc`
    函数而被添加的。如果你计算这个区域的大小，它是 `0x21000` 字节或 132 KB。这意味着为了在代码中只分配 1 KB，已经分配了一个大小为 132
    KB 的区域。
- en: This is usually done in order to prevent further memory allocations when using
    `malloc` again in the future. That's simply because the memory allocation from
    the Heap segment is not cheap and it has both memory and time overheads.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是为了防止未来再次使用 `malloc` 时进一步分配内存。这仅仅是因为从堆段分配内存并不便宜，并且它既有内存开销也有时间开销。
- en: If you go back to the code shown in *Code Box 4-8*, the address that the `ptr`
    pointer is pointing to is also interesting. The Heap's memory mapping, shown in
    *Shell Box 4-17*, is allocated from the address `0x01979000` to `0x0199a000`,
    and the address stored in `ptr` is `0x19790010`, which is obviously inside the
    Heap range, located at an offset of `16` bytes.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾一下*代码框4-8*中显示的代码，`ptr`指针所指向的地址也很有趣。堆的内存映射，如*Shell框4-17*所示，是从地址`0x01979000`到`0x0199a000`分配的，而存储在`ptr`中的地址是`0x19790010`，这显然在堆范围内，位于偏移量`16`字节的位置。
- en: The Heap segment can grow to sizes far greater than 132 KB, even to tens of
    gigabytes, and usually it is used for permanent, global, and very big objects
    such as arrays and bit streams.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 堆段可以增长到远大于132 KB的大小，甚至达到数十吉字节，通常它用于永久、全局和非常大的对象，如数组和位流。
- en: 'As pointed out before, allocation and deallocation within the heap segment
    require a program to call specific functions provided by the C standard. While
    you can have local variables on top of the Stack segment, and you can use them
    directly to interact with the memory, the Heap memory can be accessed only through
    pointers, and this is one of the reasons why knowing pointers and being able to
    work with them is crucial to every C programmer. Let''s bring up *example 4.8*,
    which demonstrates how to use pointers to access the Heap space:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前指出的那样，在堆段内进行分配和释放需要程序调用C标准提供的特定函数。虽然你可以在栈段顶部有局部变量，并且可以直接使用它们与内存交互，但堆内存只能通过指针访问，这也是为什么了解指针并且能够使用它们对于每个C程序员来说至关重要。让我们来看一下*示例4.8*，它展示了如何使用指针访问堆空间：
- en: '[PRE26]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Code Box 4-9 [ExtremeC_examples_chapter4_8.c]: Using pointers to interact with
    the Heap memory'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框4-9 [ExtremeC_examples_chapter4_8.c]: 使用指针与堆内存交互'
- en: The preceding program allocates 10 bytes from the Heap space using the `malloc`
    function. The `malloc` function receives the number of bytes that should be allocated
    and returns a generic pointer addressing the first byte of the allocated memory
    block.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序使用`malloc`函数从堆空间分配了10个字节。`malloc`函数接收应该分配的字节数，并返回一个指向分配内存块第一个字节的通用指针。
- en: For using the returned pointer, we have to cast it to a proper pointer type.
    Since we are going to use the allocated memory to store some characters, we choose
    to cast it to a `char` pointer. The casting is done before calling the `fill`
    function.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用返回的指针，我们必须将其转换为适当的指针类型。由于我们打算使用分配的内存来存储一些字符，我们选择将其转换为`char`指针。转换是在调用`fill`函数之前完成的。
- en: Note that the local pointer variables, `gptr` and `ptr`, are allocated from
    the Stack. These pointers need memory to store their values, and this memory comes
    from the Stack segment. But the address that they are pointing to is inside the
    Heap segment. This is the theme when working with Heap memories. You have local
    pointers which are allocated from the Stack segment, but they are actually pointing
    to a region allocated from the Heap segment. We show more of these in the following
    chapter.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，局部指针变量`gptr`和`ptr`是从栈中分配的。这些指针需要内存来存储它们的值，而这部分内存来自栈段。但是它们所指向的地址位于堆段内部。这是处理堆内存时的主题。你有从栈段分配的局部指针，但实际上它们指向的是从堆段分配的区域。我们将在下一章中展示更多这样的例子。
- en: Note that the `ptr` pointer inside the `fill` function is also allocated from
    the Stack but it is in a different scope, and it is different from the `ptr` pointer
    declared in the `main` function.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`fill`函数内部的`ptr`指针也是从栈中分配的，但它处于不同的作用域，并且与`main`函数中声明的`ptr`指针不同。
- en: When it comes to Heap memory, the program, or actually the programmer, is responsible
    for memory allocation. The program is also responsible for deallocation of the
    memory when it is not needed. Having a piece of allocated Heap memory that is
    not *reachable* is considered a *memory leak*. By not being reachable, we mean
    that there is no pointer that can be used to address that region.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到堆内存时，程序（或者实际上是程序员）负责内存分配。当不再需要时，程序也负责释放内存。有一块分配的堆内存是不可*访问*的，这被认为是*内存泄漏*。这里的不可访问是指没有指针可以用来定位那个区域。
- en: Memory leaks are fatal to programs because having an incremental memory leak
    will eventually use up the whole allowed memory space, and this can kill the process.
    That's why the program is calling the `free` function before returning from the
    `main` function. The call to the `free` function will deallocate the acquired
    Heap memory block, and the program shouldn't use those Heap addresses anymore.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏对程序是致命的，因为持续的内存泄漏最终会耗尽整个允许的内存空间，这可能导致进程死亡。这就是为什么程序在从`main`函数返回之前调用`free`函数的原因。对`free`函数的调用将释放所获得的堆内存块，程序不应再使用这些堆地址。
- en: More on Stack and Heap segments will come in the next chapter.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将详细介绍栈和堆段。
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Our initial goal in this chapter was to provide an overview of the memory structure
    of a process in a Unix-like operating system. As we have covered a lot in this
    chapter, take a minute to read through what we''ve been through, as you should
    now feel comfortable in understanding what we have accomplished:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的初始目标是提供一个在类Unix操作系统中进程内存结构的概述。由于本章涵盖了大量的内容，请花一分钟时间回顾我们所经历的内容，因为你现在应该能够舒适地理解我们所取得的成果：
- en: We described the dynamic memory structure of a running process as well as the
    static memory structure of an executable object file.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们描述了运行进程的动态内存结构以及可执行对象文件的静态内存结构。
- en: We observed that the static memory layout is located inside the executable object
    file and it is broken into pieces which are called segments. We found out that
    the Text, Data, and BSS segments are part of the static memory layout.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们观察到静态内存布局位于可执行对象文件内部，并被分割成称为段的各个部分。我们发现文本、数据和BSS段是静态内存布局的一部分。
- en: We saw that the Text segment or Code segment is used to store the machine-level
    instructions meant to be executed when a new process is spawned out of the current
    executable object file.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们看到文本段或代码段用于存储在从当前可执行对象文件中生成新进程时将要执行的机器级指令。
- en: We saw that the BSS segment is used to store global variables that are either
    uninitialized or set to zero.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们看到BSS段用于存储未初始化或设置为零的全局变量。
- en: We explained that the Data segment is used to store initialized global variables.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们解释说数据段用于存储初始化的全局变量。
- en: We used the `size` and `objdump` commands to probe the internals of object files.
    We can also use object file dumpers like `readelf` in order to find these segments
    inside an object file.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了`size`和`objdump`命令来探测对象文件的内部结构。我们还可以使用对象文件转储工具，如`readelf`，以在对象文件中找到这些段。
- en: We probed the dynamic memory layout of a process. We saw that all segments are
    copied from the static memory layout into the dynamic memory of the process. However,
    there are two new segments in the dynamic memory layout; the Stack segment, and
    the Heap segment.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们探测了进程的动态内存布局。我们看到所有段都是从静态内存布局复制到进程的动态内存中的。然而，在动态内存布局中有两个新的段；栈段和堆段。
- en: We explained that the Stack segment is the default memory region used for allocations.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们解释说栈段是默认的内存区域，用于分配。
- en: We learned that the local variables are always allocated on top of the Stack
    region.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们了解到局部变量始终分配在栈区域顶部。
- en: We also observed that the secret behind the function calls lies within the Stack
    segment and the way it works.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还观察到函数调用的秘密在于栈段及其工作方式。
- en: We saw that we have to use a specific API, or a set of functions, in order to
    allocate and deallocate Heap memory regions. This API is provided by the C standard
    library.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们看到，为了分配和释放堆内存区域，我们必须使用特定的API或一系列函数。这个API由C标准库提供。
- en: We discussed memory leakage and how it can happen regarding Heap memory regions.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了内存泄漏及其在堆内存区域中可能发生的情况。
- en: The next chapter is about the Stack and Heap segments specifically. It will
    use the topics we have covered within this chapter, and it will add more to those
    foundations. More examples will be given, and new probing tools will be introduced;
    this will complete our discussion regarding memory management in C.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将专门介绍栈和堆段。它将使用本章中涵盖的主题，并在此基础上添加更多内容。将给出更多示例，并介绍新的探测工具；这将完成我们对C中内存管理的讨论。
