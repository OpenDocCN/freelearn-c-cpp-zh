- en: Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据
- en: 'In this chapter, we will implement classes to handle the most critical part
    of any Line of Business application—the data. We will introduce self-aware data
    entities, which can automatically serialize to and from **JavaScript Object Notation**
    (**JSON**), a popular serialization format used a lot in web communications. We
    will create the core models we need for our application and wire them up to our
    UI for reading and writing via custom controls. We will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现处理任何业务应用程序中最关键部分的类——数据。我们将引入自我感知的数据实体，它们可以自动序列化到**JavaScript对象表示**（**JSON**）中，这是一种在Web通信中经常使用的流行序列化格式。我们将为应用程序创建核心模型，并通过自定义控件将它们连接到我们的UI以进行读取和写入。我们将涵盖以下主题：
- en: JSON
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON
- en: Data decorators
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据装饰器
- en: Abstract data entities
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象数据实体
- en: Collections of data entities
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据实体的集合
- en: Concrete data models
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具体数据模型
- en: UI controls and data binding
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI控件和数据绑定
- en: JSON
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON
- en: In case you have never come across JSON before, let’s have a quick crash course.
    It is a simple and lightweight way to express hierarchies of objects and their
    properties. It is a very popular choice when sending data in HTTP requests. It
    is similar to XML in intent but is much less verbose.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前从未接触过JSON，让我们快速进行一次简短的课程。这是一种简单而轻量的表达对象层次结构及其属性的方式。在发送HTTP请求时，这是一个非常受欢迎的选择。它类似于XML的意图，但要简洁得多。
- en: 'A JSON object is encapsulated in curly braces `{}`, while properties are denoted
    in the format key: value. Strings are delimited with double quotes `""`. We can
    represent a single client object as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 'JSON对象封装在大括号`{}`中，属性以key: value的格式表示。字符串用双引号`""`括起来。我们可以将单个客户对象表示如下：'
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that white space and control characters such as tab and newline are ignored—the
    indented properties are to simply make things more readable.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，空格和制表符等控制字符会被忽略——缩进的属性只是为了使事情更易读。
- en: It's usually a good idea to strip extraneous characters out of JSON when transmitting
    over the network (for example, in an HTTP request) in order to reduce the size
    of the payload; every byte counts!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过网络传输JSON时，通常最好去除其中的多余字符（例如在HTTP请求中），以减少有效负载的大小；每个字节都很重要！
- en: Property values can be one of the following types: `String`, `Number`, `JSON
    Object`, `JSON Array`, and the literal values `true`, `false`, and `null`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 属性值可以是以下类型之一：`String`，`Number`，`JSON对象`，`JSON数组`，以及字面值`true`，`false`和`null`。
- en: 'We can add the supply address and billing address to our client as child JSON
    objects, providing a unique key for each. While keys can be in any format as long
    as they are unique, it is common practice to use camel case, for example, `myAwesomeJsonKey`.
    We can express an empty address object with null:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将供应地址和账单地址添加到我们的客户作为子JSON对象，为每个对象提供一个唯一的键。虽然键可以是任何格式，只要它们是唯一的，但通常使用驼峰命名法，例如`myAwesomeJsonKey`。我们可以用null表示一个空地址对象：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A collection (array) of objects is enclosed in square brackets `[]` separated
    by commas. We can express no scheduled appointments by simply leaving the square
    brackets empty:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的集合（数组）用方括号`[]`括起来，用逗号分隔。我们可以通过简单地留空方括号来表示没有预约：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Object hierarchy
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象层次结构
- en: 'Most real-world applications represent data in a hierarchical or relational
    manner, with the data rationalized into discrete objects. There is often a central
    "root" object, which parents several other child objects, either as singular objects
    or as a collection. Each discrete object has its own set of data items that can
    be any number of types. The key principles we want to cover are as listed:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现实世界的应用程序以分层或关系方式表示数据，将数据合理化为离散对象。通常有一个中心的“根”对象，它作为父对象包含了几个其他子对象，可以是单个对象或集合。每个离散对象都有自己的一组数据项，可以是任意数量的类型。我们要涵盖的关键原则如下所列：
- en: A range of data types (`string`, `integer`, `datetime`) and an enumerated value
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列数据类型（`string`，`integer`，`datetime`）和枚举值
- en: Object hierarchy
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象层次结构
- en: Multiple single child entities of the same type
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个相同类型的单个子实体
- en: Collections of entities
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体的集合
- en: 'Balancing these goals with simplicity, the data diagram we will work toward
    is as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在平衡这些目标与简单性的基础上，我们将致力于实现以下数据图表：
- en: '![](img/ffa84470-9d21-4f42-93b5-1691a7bdabe0.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ffa84470-9d21-4f42-93b5-1691a7bdabe0.png)'
- en: 'The purpose of each of these models is described in the following table:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模型的目的在下表中描述：
- en: '| **Model** | **Description** |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| **模型** | **描述** |'
- en: '| **Client** | This is the root of our object hierarchy and represents an individual
    or party our company has a relationship with, for example, a customer or a patient.
    |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **客户** | 这是我们对象层次结构的根，代表了我们公司与个人或团体的关系，例如客户或患者。 |'
- en: '| **Contact** | A collection of addresses that we can use to contact the client.
    The possible types of contact will be a telephone, email, and fax. There may be
    one or more contacts per client. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **联系人** | 我们可以用来联系客户的地址集合。可能的联系方式包括电话、电子邮件和传真。每个客户可以有一个或多个联系人。 |'
- en: '| **Appointment** | A collection of scheduled appointments with the client,
    for example, a site visit or consultation. There may be zero or more appointments
    per client. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| **预约** | 与客户安排的预约集合，例如现场访问或咨询。每个客户可以有零个或多个预约。 |'
- en: '| **Supply address** | The address central to the relationship with the client,
    for example, the site our company supplies energy to or the home address of a
    patient. There must be one supply address per client. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| **供应地址** | 与客户关系密切的地址，例如我们公司供应能源的地点或患者的家庭地址。每个客户必须有一个供应地址。 |'
- en: '| **Billing address** | An optional address different to the supply address
    used for invoicing, for example, the head office of a corporation. There may be
    zero or one billing address per client. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| **账单地址** | 用于开具发票的可选地址，例如公司的总部。每个客户可以有零个或一个账单地址。 |'
- en: Another perfectly valid approach would be to aggregate the addresses into a
    collection, much like we have done with our contacts, but I want to demonstrate
    using the same type of object (Address) in multiple properties.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种完全有效的方法是将地址聚合到一个集合中，就像我们在联系人中所做的那样，但我想演示如何在多个属性中使用相同类型的对象（地址）。
- en: With the high-level design in place, we are now in a position to write our classes.
    However, before we start on our data entities, let’s take a look at the data items.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 高级设计就位后，我们现在可以编写我们的类。但是，在开始处理数据实体之前，让我们先看一下数据项。
- en: DataDecorators
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据装饰器
- en: A simple implementation of the `name` property of our client model would be
    to add it as a `QString`; however, this approach has some shortcomings. Whenever
    we display this property in the UI, we will probably want to display an informative
    label next to the textbox so that the user knows what it is for, saying “Name”
    or something similar. Whenever we want to validate a name entered by the user,
    we have to manage that in the code somewhere else. Finally, if we want to serialize
    the value to or from JSON, again there needs to be some other component that does
    it for us.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '我们的客户端模型的`name`属性的一个简单实现是将其添加为`QString`；然而，这种方法有一些缺点。每当我们在UI中显示此属性时，我们可能希望在文本框旁边显示一个信息性标签，以便用户知道它是用来做什么的，比如说“姓名”或类似的内容。每当我们想要验证用户输入的姓名时，我们必须在代码中的其他地方进行管理。最后，如果我们想要将值序列化到JSON中或从JSON中反序列化，再次需要有一些其他组件来为我们完成。 '
- en: To solve all of these problems we will introduce the concept of a `DataDecorator`,
    which will lift a given base data type and give us a label, validation capabilities,
    and JSON serialization out of the box. Our models will maintain a collection of
    `DataDecorators`, allowing them to validate and serialize themselves to JSON too
    by simply walking through the data items and performing the relevant action.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决所有这些问题，我们将引入`DataDecorator`的概念，它将提升给定的基本数据类型，并为我们提供标签、验证功能和JSON序列化。我们的模型将维护一个`DataDecorators`集合，允许它们通过简单地遍历数据项并执行相关操作来验证和将自己序列化为JSON。
- en: 'In our `cm-lib` project, create the following classes in a new folder `cm-lib/source/data`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`cm-lib`项目中，在一个新文件夹`cm-lib/source/data`中创建以下类：
- en: '| **Class** | **Purpose** |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| **类** | **目的** |'
- en: '| `DataDecorator` | Base class for our data items |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `DataDecorator` | 我们数据项的基类 |'
- en: '| `StringDecorator` | Derived class for string properties |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `StringDecorator` | 用于字符串属性的派生类 |'
- en: '| `IntDecorator` | Derived class for integer properties |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `IntDecorator` | 用于整数属性的派生类 |'
- en: '| `DateTimeDecorator` | Derived class for date/time properties |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `DateTimeDecorator` | 用于日期/时间属性的派生类 |'
- en: '| `EnumeratorDecorator` | Derived class for enumerated properties |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `EnumeratorDecorator` | 用于枚举属性的派生类 |'
- en: Our `DataDecorator` base class will house the features shared across all of
    our data items.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`DataDecorator`基类将包含所有数据项共享的特性。
- en: '`data-decorator.h`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`data-decorator.h`：'
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We inherit from QObject, add our `dllexport` macro and wrap the whole thing
    in namespaces as usual. Also, because this is an abstract base class, we ensure
    that we’ve implemented a virtual destructor.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从QObject继承，添加我们的`dllexport`宏，并像往常一样将整个内容放入命名空间中。此外，因为这是一个抽象基类，我们确保已实现了虚拟析构函数。
- en: We know that because we are inheriting from QObject, we want to receive a pointer
    to a parent in our constructor. We also know that all data items will be children
    of an **Entity** (which we will write soon and have forward declared here), which
    will itself be derived from QObject. We can leverage these two facts to parent
    our `DataDecorator` directly to an Entity.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，因为我们从QObject继承，我们希望在构造函数中接收一个父指针。我们还知道所有数据项都将是**Entity**的子项（我们将很快编写并在此处进行前向声明），它本身将从QObject派生。我们可以利用这两个事实，将我们的`DataDecorator`直接作为Entity的子项。
- en: We construct the decorator with a couple of strings. All of our data decorators
    must have a key that will be used when serializing to and from JSON, and they
    will also share a `label` property that the UI can use to display descriptive
    text next to the data control. We tuck these members away in the private implementation
    and implement some accessor methods for them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用一对字符串构造装饰器。我们所有的数据装饰器必须有一个键，该键在序列化到JSON和从JSON中使用时将被使用，并且它们还将共享一个`label`属性，UI可以用来在数据控件旁边显示描述性文本。我们将这些成员隐藏在私有实现中，并为它们实现一些访问器方法。
- en: Finally, we begin implementing our JSON serialization by declaring virtual methods
    to represent the value as a `QJsonValue` and to update the value from a provided
    `QJsonObject`. As the value is not known in the base class and will instead be
    implemented in the derived classes, both these methods are pure virtual functions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们开始实现JSON序列化，声明虚拟方法来表示值为`QJsonValue`，并从提供的`QJsonObject`更新值。由于基类中未知值，而是在派生类中实现，因此这两种方法都是纯虚拟函数。
- en: '`data-decorator.cpp`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`data-decorator.cpp`：'
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The implementation is very straightforward, essentially just managing some data
    members.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 实现非常简单，基本上只是管理一些数据成员。
- en: Next, we'll implement our derived decorator class for handling strings.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现用于处理字符串的派生装饰器类。
- en: '`string-decorator.h`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`string-decorator.h`：'
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There isn’t much else going on here—we’re just adding a strongly typed `QString`
    value property to hold our value. We also override the virtual JSON-related methods.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多其他事情发生 - 我们只是添加了一个强类型的`QString`值属性来保存我们的值。我们还重写了虚拟的与JSON相关的方法。
- en: When deriving from a class that inherits from QObject, you need to add the Q_OBJECT macro
    to the derived class as well as the base class if the derived class implements
    its own signals or slots.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从继承自QObject的类派生时，如果派生类实现了自己的信号或槽，您需要在派生类以及基类中添加`Q_OBJECT`宏。
- en: '`string-decorator.cpp`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`string-decorator.cpp`：'
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Again, there is nothing particularly complicated here. By using the `READ` and
    `WRITE` property syntax rather than the simpler `MEMBER` keyword, we now have
    a way of intercepting values being set by the UI, and we can decide whether or
    not we want to apply the change to the member variable. The mutator can be as
    complex as you need it to be, but all we’re doing for now is setting the value
    and emitting the signal to tell the UI that it has been changed. We wrap the operation
    in an equality check, so we don’t take any action if the new value is the same
    as the old one.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别复杂的。通过使用`READ`和`WRITE`属性语法，而不是更简单的`MEMBER`关键字，我们现在有了一种拦截UI设置值的方法，并且我们可以决定是否要将更改应用到成员变量。修改器可以像你需要的那样复杂，但我们现在所做的一切只是设置值并发出信号告诉UI它已经被更改。我们将操作包装在一个相等检查中，所以如果新值与旧值相同，我们就不会采取任何行动。
- en: Here, the mutator returns a reference to self (*this), which is helpful because
    it enables method chaining, for example,  `myName.setValue(“Nick”).setSomeNumber(1234).setSomeOtherProperty(true)`.
    However, this is not necessary for the property bindings, so feel free to use
    the more common `void` return type if you prefer.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，修改器返回对自身（*this）的引用，这很有帮助，因为它使方法链接成为可能，例如，`myName.setValue(“Nick”).setSomeNumber(1234).setSomeOtherProperty(true)`。然而，这对于属性绑定并不是必要的，所以如果你喜欢的话，可以使用更常见的`void`返回类型。
- en: We use a two-step conversion process, converting our `QString` value into a
    `QVariant` before converting it into our target `QJsonValue` type. The `QJsonValue`
    will be plugged into the parent Entity JSON object using the `key` from the `DataDecorator`
    base class. We will cover that in more detail when we write the **Entity** related
    classes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用两步转换过程，将我们的`QString`值转换为`QVariant`，然后再将其转换为我们目标的`QJsonValue`类型。`QJsonValue`将被插入到父实体JSON对象中，使用`DataDecorator`基类的`key`。当我们编写**Entity**相关的类时，我们将更详细地介绍这一点。
- en: An alternative approach would be to simply represent the value of our various
    data items as a `QVariant` member in the `DataDecorator` base class, removing
    the need to have separate classes for `QString`, `int`, and so on. The problem
    with this approach is that you end up having to write lots of nasty code that
    says “if you have a `QVariant` containing a string then run this code if it contains
    an `int` then run this code...”. I prefer the additional overhead of writing the
    extra classes in exchange for having known types and cleaner, simpler code. This
    will become particularly helpful when we look at data validation. Validating a
    string is completely different from validating a number and different again from
    validating a date.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是简单地将各种数据项的值表示为`DataDecorator`基类中的`QVariant`成员，而不需要为`QString`、`int`等编写单独的类。这种方法的问题在于，最终你将不得不编写大量的恶心代码，比如“如果你有一个包含字符串的`QVariant`，那么运行这段代码，如果它包含一个`int`，那么运行这段代码...”。我更喜欢写额外的类来换取已知类型和更清晰、更简单的代码。当我们进行数据验证时，这将变得特别有帮助。验证字符串与验证数字完全不同，而验证日期又与二者不同。
- en: '`IntDecorator` and `DateTimeDecorator` are virtually identical to `StringDecorator`,
    simply substituting `QString` values for int or `QDateTime`. However, we can supplement
    `DateTimeDecorator` with a few additional properties to help us out. Add the following
    properties and an accessor method to go with each:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`IntDecorator`和`DateTimeDecorator`与`StringDecorator`几乎相同，只是用`QString`值替换为int或`QDateTime`。然而，我们可以为`DateTimeDecorator`补充一些额外的属性来帮助我们。添加以下属性和每个属性对应的访问器方法：'
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The purpose of these properties is to make the UI easily access the date/time
    value as a `QString` preformatted to a few different styles. Let's run through
    the implementation for each of the accessors.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性的目的是使UI能够轻松地访问日期/时间值，作为预先格式化为几种不同样式的`QString`。让我们逐个运行每个访问器的实现。
- en: 'Qt has inbuilt support for ISO8601 format dates, which is a very common format
    when transmitting datetime values between systems, for example, in HTTP requests.
    It is a flexible format that supports several different representations but generally
    follows the format yyyy-MM-ddTHH:mm:ss.zt, where T is a string literal, z is milliseconds,
    and t is the timezone information:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Qt内置支持ISO8601格式的日期，这是在系统之间传输日期时间值时非常常见的格式，例如在HTTP请求中。这是一种灵活的格式，支持几种不同的表示，但通常遵循格式yyyy-MM-ddTHH:mm:ss.zt，其中T是一个字符串文字，z是毫秒，t是时区信息：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we provide a method to display a full datetime in a long human readable
    format, for example, Sat 22 Jul 2017 @ 12:07:45:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们提供一种方法来以长的人类可读格式显示完整的日期时间，例如，Sat 22 Jul 2017 @ 12:07:45：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The final two methods display either the date or time component, for example,
    22 Jul 2017 or 12:07 pm:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两种方法分别显示日期或时间组件，例如，22 Jul 2017或12:07 pm：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Our final type, `EnumeratorDecorator`, is broadly the same as `IntDecorator`,
    but it also accepts a mapper. This container helps us map the stored int value
    to a string representation. If we consider the `Contact.type` enumerator we plan
    to implement, the enumerated value will be 0, 1, 2, so on; however, when it comes
    to the UI, that number won't mean anything to the user. We really need to present
    `Email`, `Telephone`, or some other string representation, and the map allows
    us to do just that.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终类型，`EnumeratorDecorator`，与`IntDecorator`基本相同，但它还接受一个映射器。这个容器帮助我们将存储的整数值映射为字符串表示。如果我们考虑要实现的`Contact.type`枚举器，枚举值将是0、1、2等；然而，当涉及到UI时，这个数字对用户来说没有任何意义。我们真的需要呈现`Email`、`Telephone`或其他字符串表示，而映射允许我们做到这一点。
- en: '`enumerator-decorator.h`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`enumerator-decorator.h`：'
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We store the map as another member variable in our private implementation class
    and then use it to provide the string representation of the enumerated value:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将映射存储为私有实现类中的另一个成员变量，然后使用它来提供枚举值的字符串表示：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now that we have covered the data types we need for our entities, let’s move
    on to the entities themselves.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了我们实体所需的数据类型，让我们继续讨论实体本身。
- en: Entities
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体
- en: As we have a lot of functionality we want to share across our data models, we'll
    implement an **Entity** base class. We need to be able to represent parent/child
    relationships so that a client can have supply and billing addresses. We also
    need to support collections of entities for our contacts and appointments. Finally,
    each entity hierarchy must be able to serialize itself to and from a JSON object.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望在我们的数据模型之间共享许多功能，我们将实现一个**Entity**基类。我们需要能够表示父/子关系，以便客户可以拥有供应和账单地址。我们还需要支持实体的集合，用于我们的联系人和约会。最后，每个实体层次结构必须能够将自身序列化为JSON对象，并从JSON对象中反序列化。
- en: Create a new class Entity in `cm-lib/source/data`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cm-lib/source/data`中创建一个名为Entity的新类。
- en: '`entity.h`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`entity.h`：'
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`entity.cpp`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`entity.cpp`：'
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Much like our `DataDecorator` base class, we assign all entities a unique key, which
    will be used in JSON serialization. We also add an overloaded constructor to which
    we can pass a `QJsonObject` so that we can instantiate an entity from JSON. On
    a related note, we also declare a pair of methods to serialize an existing instance
    to and from JSON.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的`DataDecorator`基类非常相似，我们为所有实体分配一个唯一的键，这将用于JSON序列化。我们还添加了一个重载的构造函数，我们可以通过它传递一个`QJsonObject`，以便我们可以从JSON实例化一个实体。另外，我们还声明了一对方法来将现有实例序列化为JSON并从JSON中反序列化。
- en: Our entity will maintain a few collections—a map of data decorators representing
    the properties of the model, and a map of entities representing individual children.
    We map the key of each item to the instance.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实体将维护一些集合——表示模型属性的数据装饰器的地图，以及表示单个子项的实体的地图。我们将每个项的键映射到实例。
- en: We expose a couple of protected methods that are derived classes will use to
    add its data items and children; for example, our client model will add a name
    data item along with the `supplyAddress` and `billingAddress` children. To complement
    these methods, we also add signals to tell any interested observers that the collections
    have changed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们公开了一些受保护的方法，派生类将使用这些方法来添加其数据项和子项；例如，我们的客户模型将添加一个名称数据项以及`supplyAddress`和`billingAddress`子项。为了补充这些方法，我们还添加了信号，告诉任何感兴趣的观察者集合已经发生了变化。
- en: In both cases, we check that the key doesn’t already exist on the map before
    adding it. We then return the supplied pointer so that the consumer can use it
    for further actions. You’ll see the value of this when we come to implement the
    data models.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们在添加之前检查地图上是否已经存在该键。然后我们返回提供的指针，以便消费者可以将其用于进一步操作。当我们开始实现数据模型时，您将看到这一点的价值。
- en: We use our populated maps for the JSON serialization methods. We’ve already
    declared an `update()` method on our `DataDecorator` base class, so we simply
    iterate through all the data items and pass the JSON object down to each in turn.
    Each derived decorator class has its own implementation to take care of the parsing.
    Similarly, we recursively call `Entity::update()` on each of the child entities.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用填充的地图来进行JSON序列化方法。我们已经在我们的`DataDecorator`基类上声明了一个`update()`方法，因此我们只需迭代所有数据项，并依次将JSON对象传递给每个数据项。每个派生的装饰器类都有自己的实现来处理解析。类似地，我们对每个子实体递归调用`Entity::update()`。
- en: Serializing to a JSON object follows the same pattern. Each data item can convert
    its value to a `QJsonValue` object, so we get each value in turn and append it
    to a root JSON object using the key of each item. We recursively call `Entity::toJson()`
    on each of the children, and this cascades down the hierarchy tree.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 将序列化为JSON对象遵循相同的模式。每个数据项都可以将其值转换为`QJsonValue`对象，因此我们依次获取每个值，并将其附加到根JSON对象中，使用每个项的键。我们对每个子项递归调用`Entity::toJson()`，这样就可以级联到层次结构树下。
- en: Before we can finish off our **Entity**, we need to declare a group of classes
    to represent an entity collection.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成**Entity**之前，我们需要声明一组类来表示实体集合。
- en: Entity collections
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体集合
- en: To implement entity collections, we need to leverage some more advanced C++
    techniques, and we will take a brief break from our conventions so far, implementing
    multiple classes in a single header file.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现实体集合，我们需要利用一些更高级的C++技术，并且我们将暂时中断我们迄今为止的惯例，实现在单个头文件中的多个类。
- en: 'Create `entity-collection.h` in `cm-lib/source/data`, and in it, add our namespaces
    as normal and forward declare Entity:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cm-lib/source/data`中创建`entity-collection.h`，并在其中像平常一样添加我们的命名空间并前向声明Entity：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Next, we’ll walk through the necessary classes in turn, each of which must be
    added in order inside the namespaces.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将依次讨论必要的类，每个类都必须按顺序添加到命名空间中。
- en: 'We first define the root class, which does nothing more than inheriting from
    `QObject` and giving us access to all the goodness that it brings, such as object
    ownership and signals. This is required because classes deriving directly from
    `QObject` cannot be templated:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义根类，它除了继承自`QObject`并给我们访问它带来的所有好处外，什么也不做，比如对象所有权和信号。这是必需的，因为直接从`QObject`派生的类不能被模板化：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You will need to add includes for `QObject` and our DLL export macros. Next,
    we need a type agnostic interface to use with our entities, much the same as we
    have with the `DataDecorator` and Entity maps we’ve implemented. However, things
    are a little more complicated here, as we will not derive a new class for each
    collection we have, so we need some way of getting typed data. We have two requirements.
    Firstly, the UI needs a `QList` of derived types (for example, **Client***) so
    that it can access all the properties specific to a client and display all the
    data. Secondly, our **Entity** class needs a vector of base types (**Entity***)
    so that it can iterate its collections without caring exactly which type it is
    dealing with. The way we achieve this is to declare two template methods but delay
    defining them until later. `derivedEntities()` will be used when the consumer
    wants a collection of the derived type, while `baseEntities()` will be used when
    the consumer just wants access to the base interface:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要添加`QObject`和我们的DLL导出宏的包含。接下来，我们需要一个类型不可知的接口，用于与我们的实体一起使用，就像我们已经实现的`DataDecorator`和实体映射一样。然而，在这里情况会有些复杂，因为我们不会为每个集合派生一个新类，所以我们需要一种获取类型化数据的方法。我们有两个要求。首先，UI需要一个派生类型的`QList`（例如**Client**），这样它就可以访问特定于客户的所有属性并显示所有数据。其次，我们的**Entity**类需要一个基本类型的向量（**Entity***），这样它就可以迭代它的集合而不用关心它正在处理的确切类型。我们实现这一点的方法是声明两个模板方法，但推迟到以后再定义它们。`derivedEntities()`将在消费者想要一个派生类型的集合时使用，而`baseEntities()`将在消费者只想要访问基本接口时使用。
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we declare a full template class where we store our collection of derived
    types and implement all of our methods, except for the two template methods we
    just discussed:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明一个完整的模板类，其中我们存储我们的派生类型的集合并实现我们所有的方法，除了我们刚刚讨论的两个模板方法：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You will need `#include <QJsonValue>` and `<QJsonArray>` for these classes.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要`#include <QJsonValue>`和`<QJsonArray>`来获取这些类。
- en: The `clear()` method simply empties the collection and tidies up the memory; 
    `update()` is conceptually the same as the JSON methods we implemented in Entity,
    except that we are dealing with a collection of entities, so we take a JSON array
    instead of an object. `addEntity()` adds an instance of a derived class to the
    collection, and `derivedEntities()` returns the collection; `baseEntities()` does
    a little more work, creating a new vector on request and populating it with all
    the items in the collection. It is just implicitly casting pointers, so we’re
    not concerned about expensive object instantiation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`clear()`方法只是清空集合并整理内存；`update()`在概念上与我们在Entity中实现的JSON方法相同，只是我们处理的是一组实体，所以我们使用JSON数组而不是对象。`addEntity()`将派生类的实例添加到集合中，`derivedEntities()`返回集合；`baseEntities()`做了更多的工作，根据请求创建一个新的向量，并用集合中的所有项目填充它。它只是隐式地转换指针，所以我们不用担心昂贵的对象实例化。'
- en: 'Finally, we provide the implementation for our magic templated methods:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为我们的魔术模板方法提供实现：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: What we’ve achieved by delaying our implementation of these methods is that
    we’ve now fully declared our templated `EntityCollection` class. We can now "route"
    any calls to the templated methods through to the implementation in the templated
    class. It’s a tricky technique to wrap your head around, but it will hopefully make
    more sense when we start implementing these collections in our real-world models.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过推迟实现这些方法，我们现在已经完全声明了我们的模板化`EntityCollection`类。现在我们可以将任何对模板方法的调用“路由”到模板类中的实现。这是一种让你头脑转弯的棘手技术，但当我们开始在我们的现实世界模型中实现这些集合时，它将有望更加合理。
- en: With our entity collections now ready, we can return to our Entity class and
    add them to the mix.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的实体集合已经准备就绪，我们可以返回到我们的Entity类并将它们加入其中。
- en: 'In the header, `#include <data/entity-collection.h>`, add the signal:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在头文件中，`#include <data/entity-collection.h>`，添加信号：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Also, add the protected method:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 还有，添加受保护的方法：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the implementation file, add the private member:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现文件中，添加私有成员：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, add the method:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加这个方法：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This works in exactly the same way as the other maps, associating a key with
    a pointer to a base class.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这与其他映射的工作方式完全相同，将键与基类的指针关联起来。
- en: 'Next, add the collections to the `update()` method:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将集合添加到`update()`方法中：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, add the collections to the `toJson()` method:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将集合添加到`toJson()`方法中：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You will need `#include <QJsonArray>` for that last snippet.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要`#include <QJsonArray>`来获取最后一段代码。
- en: We use the `baseEntities()` method to give us a collection of `Entity*`. We
    then append the JSON object from each entity to a JSON array and when complete,
    add that array to our root JSON object with the collection’s key.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`baseEntities()`方法来给我们一个`Entity*`的集合。然后我们将每个实体的JSON对象附加到一个JSON数组中，当完成时，将该数组添加到我们的根JSON对象中，带有集合的键。
- en: The past few sections have been quite long and complex and may seem like a lot
    of work just to implement some data models. However, it’s all code that you write
    once, and it gives you a lot of functionality for free with every entity you go
    on and make, so it’s worth the investment in the long run. We’ll go ahead and
    look at how to implement these classes in our data models.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 过去几节内容非常长且复杂，可能看起来需要大量工作才能实现一些数据模型。然而，这是你只需要编写一次的所有代码，并且它可以为你提供大量的功能，让你在创建每个实体时都能免费使用，所以从长远来看是值得投资的。我们将继续看如何在我们的数据模型中实现这些类。
- en: Data models
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据模型
- en: 'Now that we have the infrastructure in place to be able to define data objects
    (entities and entity collections) and properties of various types (data decorators),
    we can move on and build the object hierarchy we laid out earlier in the chapter.
    We already have a default **Client** class created by Qt Creator, so supplement
    that in `cm-lib/source/models` with the following new classes:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了基础设施，可以定义数据对象（实体和实体集合）和各种类型的属性（数据装饰器），我们可以继续构建我们在本章前面所列出的对象层次结构。我们已经有了一个由Qt
    Creator创建的默认**Client**类，所以在`cm-lib/source/models`中补充以下新类：
- en: '| **Class** | **Purpose** |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| **类** | **目的** |'
- en: '| `Address` | Represents a supply or billing address |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `Address` | 代表供应或结算地址 |'
- en: '| `Appointment` | Represents an appointment with a client |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `Appointment` | 代表与客户的约会 |'
- en: '| `Contact` | Represents a method of contacting a client |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `Contact` | 代表与客户联系的方法 |'
- en: We’ll start with the simplest of the models—the address.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从最简单的模型开始——地址。
- en: '`address.h`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`address.h`：'
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We define the properties we designed at the beginning of the chapter, but instead
    of using regular `QString` objects, we use our new `StringDecorators`. To protect
    the integrity of our data, we should really use the `READ` keyword and return
    a `StringDecorator* const` via an accessor method, but for simplicity, we’ll use
    `MEMBER` instead. We also provide an overloaded constructor that we can use to
    construct an address from a `QJsonObject`. Finally, we add a helper `fullAddress()`
    method and property to concatenate the address elements into a single string for
    use in the UI.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了我们在本章开头设计的属性，但是我们使用我们的新`StringDecorators`，而不是使用常规的`QString`对象。为了保护数据的完整性，我们应该真正使用`READ`关键字，并通过访问器方法返回`StringDecorator*
    const`，但为了简单起见，我们将使用`MEMBER`。我们还提供了一个重载的构造函数，我们可以用它来从`QJsonObject`构造地址。最后，我们添加了一个辅助的`fullAddress()`方法和属性，将地址元素连接成一个单一的字符串，以在UI中使用。
- en: '`address.cpp`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`address.cpp`：'
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This is where all of our hard work starts to come together. We need to do two
    things with each of our properties. Firstly, we need a pointer to the derived
    type (`StringDecorator`), which we can present to the UI in order to display and
    edit the value. Secondly, we need to make the base Entity class aware of the base
    type (`DataDecorator`) so that it can iterate the data items and perform the JSON
    serialization work for us. We can use the `addDataItem()` method to achieve both
    these goals in a one-line statement:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们所有辛苦工作开始汇聚的地方。我们需要对我们的每个属性做两件事。首先，我们需要一个指向派生类型（`StringDecorator`）的指针，这样我们就可以向UI呈现并编辑值。其次，我们需要让基本的Entity类知道基本类型（`DataDecorator`），以便它可以迭代数据项并为我们执行JSON序列化工作。我们可以使用`addDataItem()`方法在一行语句中实现这两个目标：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Breaking this down, we create a new `StringDecorator*` with the `building` key and
    `Building` UI label. This is immediately passed to `addDataItem()`, which adds
    it to the `dataDecorators` collection in the **Entity** and returns the data item
    as a `DataDecorator*`. We can then cast it back to a `StringDecorator*` before
    storing it in the `building` member variable.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 分解一下，我们使用`building`键和`Building` UI标签创建一个新的`StringDecorator*`。这立即传递给`addDataItem()`，它将其添加到**Entity**中的`dataDecorators`集合中，并将数据项作为`DataDecorator*`返回。然后我们可以将其强制转换回`StringDecorator*`，然后将其存储在`building`成员变量中。
- en: The only other piece of implementation here is to take a JSON object, construct
    the address as normal by calling the default constructor, and then update the
    model using the `update()` method.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的另一个实现部分是获取JSON对象，通过调用默认构造函数正常构造地址，然后使用`update()`方法更新模型。
- en: 'The `Appointment` and `Contact` models follow the same pattern, just with different
    properties and the appropriate variation of `DataDecorator` for each of their
    data types.  Where `Contact` varies more significantly is in its use of an `EnumeratorDecorator`
    for the `contactType` property. To support this, we first define an enumerator
    in the header file that contains all the possible values we want:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`Appointment`和`Contact`模型遵循相同的模式，只是具有不同的属性和每种数据类型的适当变体的`DataDecorator`。`Contact`的变化更显著的是在其对`contactType`属性使用`EnumeratorDecorator`。为了支持这一点，我们首先在头文件中定义一个枚举器，其中包含我们想要的所有可能值：'
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Note that we have a default value of `Unknown` represented by `0`. This is
    important as it allows us to accommodate an initial unset value. Next, we define
    a mapper container that allows us to map each of the enumerated types to a descriptive
    string:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将`Unknown`的默认值表示为`0`。这很重要，因为它允许我们容纳初始未设置的值。接下来，我们定义一个映射器容器，允许我们将枚举类型中的每个类型映射到一个描述性字符串：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When creating the new `EnumeratorDecorator`, we supply the default value (0
    for `eContactType::Unknown`) along with the mapper:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新的`EnumeratorDecorator`时，我们提供默认值（对于`eContactType::Unknown`为0）以及映射器：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Our client model is a little more complex, as it not only has data items but
    has child entities and collections too. However, the way we create and expose
    these things is very similar to what we have already seen.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户模型稍微复杂一些，因为它不仅有数据项，还有子实体和集合。但是，我们创建和公开这些内容的方式与我们已经看到的非常相似。
- en: '`client.h`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`client.h`：'
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We expose the child entities as pointers to the derived type and the collections
    as pointers to a templated `EntityCollection`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将子实体公开为指向派生类型的指针，将集合公开为指向模板化的`EntityCollection`的指针。
- en: '`client.cpp`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`client.cpp`：'
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Adding child entities follows the same pattern as data items, but using the
    `addChild()` method. Note that we add more than one child of the same address
    type, but ensure that they have different `key` values to avoid duplicates and
    invalid JSON. Entity collections are added with `addChildCollection()` and other
    than being templated, they follow the same approach.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 添加子实体遵循与数据项相同的模式，但使用`addChild()`方法。请注意，我们添加了多个相同地址类型的子实体，但确保它们具有不同的`key`值，以避免重复和无效的JSON。实体集合使用`addChildCollection()`添加，除了使用模板化之外，它们遵循相同的方法。
- en: While it was a lot of work to create our entities and data items, creating models
    is really quite straightforward and now they all come packed with features that
    we wouldn’t otherwise have had.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然创建实体和数据项需要大量工作，但创建模型实际上非常简单，现在它们都具有我们原本没有的功能。
- en: 'Before we can use our fancy new models in the UI, we need to register the types
    in `main.cpp` in `cm-ui`, including the data decorators that represent the data
    items. Remember to add the relevant `#include` statements first:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在UI中使用我们新的模型之前，我们需要在`cm-ui`的`main.cpp`中注册类型，包括表示数据项的数据装饰器。记得先添加相关的`#include`语句：
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: With that done, we’ll create an instance of a client in `MasterController`, which
    we will use to populate data for new clients. This follows exactly the same pattern
    that we’ve used for adding the other controllers.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们将在`MasterController`中创建一个客户端的实例，用于填充新客户端的数据。这完全遵循了我们用于添加其他控制器的相同模式。
- en: 'First, add the member variable to the private implementation of `MasterController`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`MasterController`的私有实现中添加成员变量：
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, initialize it in the `Implementation` constructor:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`Implementation`构造函数中初始化它：
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Third, add the accessor method:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，添加访问器方法：
- en: '[PRE37]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, add `Q_PROPERTY`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加`Q_PROPERTY`：
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We now have an empty instance of a client available for consumption by the
    UI, specifically `CreateClientView`, which we will edit next. Begin by adding
    a shortcut property for the new client instance:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个空的客户端实例可供UI使用，特别是`CreateClientView`，我们将在下一步中编辑它。首先添加一个新客户端实例的快捷属性：
- en: '[PRE39]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Remember that the properties should all be defined at the root Item level and
    that you need to `import CM 1.0` to get access to the registered types. This just
    enables us to use `newClient` as shorthand to access the instance rather than
    having to type out `masterController.ui_newClient` every time.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，所有属性都应在根Item级别定义，并且您需要`import CM 1.0`才能访问已注册的类型。这只是让我们能够使用`newClient`作为访问实例的简写，而不必每次都输入`masterController.ui_newClient`。
- en: At this point, everything is hooked up ready for use, and you should be able
    to run the application and navigate to the new client view with no problems. The
    view isn’t doing anything with the new client instance just yet, but it’s happily
    sitting there ready for action. Now, let’s look at how we can interact with it.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都已经准备就绪，您应该能够运行应用程序并导航到新的客户端视图，而没有任何问题。视图目前还没有使用新的客户端实例，但它已经准备好进行操作。现在，让我们看看如何与它进行交互。
- en: Custom TextBox
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义文本框
- en: 'We’ll start with the `name` data item of our client. Back when we worked with
    another `QString` property in our UI with the welcome message, we displayed it
    with the basic text component. This component is read only, so to view and edit
    our property, we will need to reach for something else. There are a couple of
    options in the base `QtQuick` module: `TextInput` and `TextEdit`. `TextInput`
    is for a single line of editable plain text, while `TextEdit` handles multiline
    blocks of text and also supports rich text. `TextInput` is ideal for our **name**.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从客户端的`name`数据项开始。当我们在UI中使用另一个`QString`属性时，我们使用基本文本组件显示它。这个组件是只读的，所以为了查看和编辑我们的属性，我们需要寻找其他东西。在基本的`QtQuick`模块中有几个选项：`TextInput`和`TextEdit`。`TextInput`用于单行可编辑的纯文本，而`TextEdit`处理多行文本块，并支持富文本。`TextInput`非常适合我们的**name**。
- en: Importing the `QtQuick.Controls` module makes additional text-based components
    like `Label`, `TextField`, and `TextArea` available. Label inherits and extends
    Text, `TextField` inherits and extends `TextInput` and `TextArea` inherits and
    extends `TextEdit`. The basic controls are enough for us at this stage, but be
    aware that these alternatives exist. If you find yourself trying to do something
    with one of the basic controls which it doesn’t seem to support, then import `QtQuick.Controls`
    and take a look at its more powerful cousin. It may well have the functionality
    you are looking for.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 导入`QtQuick.Controls`模块可以使其他基于文本的组件如`Label`、`TextField`和`TextArea`可用。Label继承并扩展Text，`TextField`继承并扩展`TextInput`，`TextArea`继承并扩展`TextEdit`。在这个阶段，基本控件已经足够了，但请注意这些替代品的存在。如果您发现自己尝试使用基本控件做一些它似乎不支持的事情，那么导入`QtQuick.Controls`并查看它更强大的同类。它很可能具有您正在寻找的功能。
- en: 'Let''s build on what we''ve learned and create a new reusable component. As
    usual, we''ll begin by preparing the Style properties we''ll need:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在所学知识的基础上构建一个新的可重用组件。和往常一样，我们将首先准备我们需要的样式属性：
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Next, create `StringEditorSingleLine.qml` in `cm/cm-ui/components`. It’s not
    the most beautiful of names, but at least it’s descriptive!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`cm/cm-ui/components`中创建`StringEditorSingleLine.qml`。这可能不是最美观的名称，但至少它是描述性的！
- en: It's generally helpful to use a prefix with custom QML views and components
    to help distinguish them from the built-in Qt components and avoid naming conflicts.
    If we were using that approach with this project, we could have called this component
    `CMTextBox` or something equally short and simple. Use whatever approach and conventions
    work for you, it makes no functional difference.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通常有助于在自定义QML视图和组件中使用前缀，以帮助区分它们与内置的Qt组件，并避免命名冲突。如果我们在这个项目中使用这种方法，我们可以将这个组件称为`CMTextBox`或者其他同样简短简单的名称。使用任何适合您的方法和约定，这不会产生功能上的差异。
- en: Edit `components.qrc` and `qmldir` as we did previously to make the new component
    available in our components module.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`components.qrc`和`qmldir`，就像我们之前做的那样，以便在我们的组件模块中使用新组件。
- en: 'What we''re trying to achieve with this component is as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试实现这个组件的目标如下：
- en: To be able to pass in any `StringDecorator` property from any data model and
    view/edit the value
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够传递任何数据模型和视图中的`StringDecorator`属性并查看/编辑值
- en: View a descriptive label for the control as defined in the `ui_label` property
    of the `StringDecorator`
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看`StringDecorator`的`ui_label`属性中定义的控件的描述性标签
- en: View/edit the `ui_value` property of the `StringDecorator` in a `TextBox`
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看/编辑`StringDecorator`的`ui_value`属性在`TextBox`中
- en: If the window is wide enough, then the label and textbox are laid out horizontally
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果窗口足够宽，则标签和文本框将水平布局
- en: If the window is not wide enough, then the label and textbox are laid out vertically
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果窗口不够宽，则标签和文本框将垂直布局
- en: 'With these goals in mind, implement `StringEditorSingleLine`, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些目标，实现`StringEditorSingleLine`如下：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We begin with a public `StringDecorator` property (public because it is in the
    root Item element), which we can set from outside of the component.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从公共`StringDecorator`属性开始（因为它在根Item元素中），我们可以从组件外部设置它。
- en: We introduce a new kind of element—Flow—to lay out our label and textbox for
    us. Rather than always laying out content in a single direction like row or column,
    the Flow item will lay out its child elements side by side until it runs out of
    available space and then wraps them like words on a page. We tell it how much
    available space it has to play with by anchoring it to the root Item.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了一种新的元素——Flow——来为我们布置标签和文本框。与始终沿着单个方向（如行或列）布置内容不同，Flow项将将其子元素并排布置，直到可用空间用尽，然后像页面上的单词一样将它们包裹起来。我们通过将其锚定到根Item来告诉它有多少可用空间可以使用。
- en: Next comes our descriptive label in a Text control and the editable value in
    a `TextInput` control. We embed both controls in explicitly sized rectangles.
    The rectangles help us align the elements and give us the opportunity to draw
    backgrounds and borders.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们描述性标签在文本控件中和可编辑值在`TextInput`控件中。我们将两个控件嵌入明确大小的矩形中。这些矩形帮助我们对齐元素，并为我们提供绘制背景和边框的机会。
- en: The `Binding` component establishes a dependency between the properties of two
    different objects; in our case, the `TextInput` control called `textValue` and
    the `StringDecorator` instance called `stringDecorator`. The `target` property
    defines the object we want to update, the `property` is the `Q_PROPERTY` we want
    to set, and `value` is the value we want to set it to. This is a key element that
    gives us true two-way binding. Without this, we will be able to view the value
    from the `StringDecorator`, but any changes we make in the UI will not update
    the value.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`Binding`组件在两个不同对象的属性之间建立了依赖关系；在我们的情况下，是名为`textValue`的`TextInput`控件和名为`stringDecorator`的`StringDecorator`实例。`target`属性定义了我们要更新的对象，`property`是我们要设置的`Q_PROPERTY`，`value`是我们要设置的值。这是一个关键元素，使我们实现了真正的双向绑定。没有这个，我们将能够从`StringDecorator`中查看值，但我们在UI中进行的任何更改都不会更新该值。'
- en: 'Back in `CreateClientView`, replace the old Text element with our new component
    and pass in the `ui_name` property:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`CreateClientView`，用我们的新组件替换旧的文本元素，并传入`ui_name`属性：
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now build and run the app, navigate to the Create Client view, and try editing
    the name:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建并运行应用程序，导航到创建客户端视图，并尝试编辑名称：
- en: '![](img/91a79322-c123-4af2-8e42-736e540130a3.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91a79322-c123-4af2-8e42-736e540130a3.png)'
- en: If you switch to the Find Client view and back again, you will see that the
    value is retained, demonstrating the updates are successfully being set in the
    string decorator.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您切换到查找客户端视图，然后再切换回来，您会看到该值被保留，证明更新成功地设置在字符串装饰器中。
- en: Our newly bound view isn't exactly overflowing with data just yet, but over
    the coming chapters, we will add more and more to this view, so let's add a few
    finishing touches to prepare us.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新绑定的视图目前还没有太多数据，但在接下来的章节中，我们将为这个视图添加更多内容，因此让我们添加一些最后的修饰来做好准备。
- en: Firstly, we only need to add another three or four properties to the view, and
    we'll run out of space as the default size we’ve set for the window is very small,
    so in `MasterView` bump the window size up to something comfortable for your display.
    I'll treat myself and go full HD at 1920 x 1080.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们只需要向视图添加另外三四个属性，我们将会用完空间，因为我们为窗口设置的默认大小非常小，所以在`MasterView`中将窗口大小调整到适合您显示器的舒适大小。我会给自己一些待遇，选择全高清的1920
    x 1080。
- en: Even with a larger window to work with, we still need to prepare for the possibility
    of overflow, so we'll add our content to another new element called `ScrollView`.
    As its name suggests, it works in a similar way to flow and manages its content
    based on the space it has available to it. If the content exceeds the available
    space, it will present scrollbars for the user. It's also a very finger friendly
    control and on a touch screen, the user can just drag the content rather than
    having to fiddle around with a tiny scrollbar.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有更大的窗口可供使用，我们仍然需要准备可能溢出的情况，因此我们将将我们的内容添加到另一个名为`ScrollView`的新元素中。顾名思义，它的工作方式类似于流，并根据其可用的空间来管理其内容。如果内容超出可用空间，它将为用户呈现滚动条。它还是一个非常适合手指操作的控件，在触摸屏上，用户可以直接拖动内容，而不必费力地操作微小的滚动条。
- en: Although we only have one property currently, when we add more, we will need
    to lay them out so we'll add a column.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们目前只有一个属性，但当我们添加更多属性时，我们需要对它们进行布局，因此我们将添加一列。
- en: Finally, the controls are stuck to the bounds of the view, so we'll add a little
    gutter around the view and some spacing in the column.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，控件粘附在视图的边界上，因此我们将在视图周围添加一点间隙和一些列间距。
- en: 'The revised view should look as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的视图应如下所示：
- en: '[PRE44]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Build and run, and you should see the nice neat screen margin. You should also
    be able to resize the window from wide to narrow and see the string editor automatically
    adjust its layout accordingly.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行，您应该会看到漂亮整洁的屏幕边距。您还应该能够将窗口从宽变窄，并看到字符串编辑器自动调整其布局。
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This was a fairly hefty chapter, but we’ve covered arguably the most important
    element of any Line of Business application, and that is the data. We’ve implemented
    a framework of self-aware entities that can serialize themselves to and from JSON
    and started building data bound controls. We’ve designed and created our data
    models and are now entering the homeward stretch. In [Chapter 6](8e0365b0-e826-4ab5-8a7c-858222ce2c00.xhtml),
    *Unit Testing*, we’ll show some love to our so far neglected unit test project
    and check that our entities are behaving as expected.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当庞大的章节，但我们已经涵盖了任何业务应用程序中可能最重要的元素，那就是数据。我们实现了一个能够将自身序列化到JSON并开始构建数据绑定控件的自我意识实体框架。我们已经设计并创建了我们的数据模型，现在正在进入回家的阶段。在[第6章](8e0365b0-e826-4ab5-8a7c-858222ce2c00.xhtml)中，*单元测试*，我们将关注到迄今为止被忽视的单元测试项目，并检查我们的实体是否按预期行为。
