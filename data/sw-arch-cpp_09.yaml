- en: Building and Packaging
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和打包
- en: As an architect, you will need to know about all the elements that make up the
    build process. This chapter will explain all the elements that make up the build
    process. From compiler flags to automation scripts and beyond, we will guide you
    to the point where each possible module, service, and artifact is versioned and
    stored in a central location ready for deployment. We will mainly focus on CMake.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 作为架构师，您需要了解构建过程的所有要素。本章将解释构建过程的所有要素。从编译器标志到自动化脚本等，我们将指导您到每个可能的模块、服务和构件都被版本化并存储在一个中央位置，准备部署。我们将主要关注CMake。
- en: 'In this chapter, you''ll learn about the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解以下内容：
- en: What compiler flags you should consider using
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您应该考虑使用哪些编译器标志
- en: How to create build systems based on Modern CMake
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何基于现代CMake创建构建系统
- en: How to build reusable components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建可重用的组件
- en: How to use external code in CMake cleanly
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在CMake中清洁地使用外部代码
- en: How to create DEB and RPM packages, as well as NSIS installers, using CPack
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用CPack创建DEB和RPM软件包，以及NSIS安装程序
- en: How to use the Conan package manager for installing your dependencies and for
    creating your own packages
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Conan软件包管理器来安装您的依赖项并创建您自己的软件包
- en: After reading this chapter, you'll know how to write state-of-the-art code for
    building and packaging your project.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章后，您将了解如何编写最先进的代码来构建和打包您的项目。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To replicate the examples from this chapter, you should install a recent version
    of **GCC** and **Clang**, **CMake 3.15** or higher, **Conan**, and **Boost 1.69**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要复制本章中的示例，您应安装最新版本的**GCC**和**Clang**，**CMake 3.15**或更高版本，**Conan**和**Boost 1.69**。
- en: The source code snippets from the chapter can be found at [https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter07](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter07)[.](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter07)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码片段可以在[https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter07](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter07)找到。
- en: Getting the most out of compilers
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 充分利用编译器
- en: Compilers are one of the most important tools in every programmer's workshop.
    That's why getting to know them well can help you out in many different ways,
    on countless occasions. In this section, we'll describe a few tips to use them
    effectively. This will only touch the tip of the iceberg as whole books can be
    written about these tools and their vast variety of available flags, optimizations,
    functionalities, and other specifics. GCC even has a wiki page with a list of
    books about compilers! You can find it in the *Further reading* section at the
    end of this chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器是每个程序员工作室中最重要的工具之一。这就是为什么充分了解它们可以在许多不同的场合帮助您的原因。在本节中，我们将描述一些有效使用它们的技巧。这只是冰山一角，因为整本书都可以写关于这些工具及其广泛的可用标志、优化、功能和其他具体内容。GCC甚至有一个关于编译器书籍的维基页面！您可以在本章末尾的*进一步阅读*部分找到它。
- en: Using multiple compilers
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用多个编译器
- en: One of the things you should consider in your build process is using multiple
    compilers instead of just one, the reason being the several benefits that come
    with it. One of them is that they can detect different issues with your code.
    For instance, MSVC has signedness checks enabled by default. Using several compilers
    can help with potential portability issues you may encounter in the future, especially
    when a decision is made to also compile your code on a different OS, such as moving
    from Linux to Windows or the other way. To make such efforts at no cost, you should
    strive to write portable, ISO C++-compliant code. One of the benefits of **Clang**
    is that it strives for compliance with the C++ standards more than GCC. If you're
    using **MSVC**, try adding the `/permissive-` option (available since Visual Studio
    17; enabled by default for projects created using version 15.5+). For **GCC**,
    try not to use the GNU variants when choosing the C++ standard for your code (for
    example, prefer `-std=c++17` to `-std=gnu++17`). If performance is your goal,
    being able to build your software with a wide range of compilers will also allow
    you to pick the one that will offer the fastest binaries for your specific use
    cases.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建过程中应考虑的一件事是使用多个编译器而不仅仅是一个，原因是它带来的几个好处。其中之一是它们可以检测代码中的不同问题。例如，MSVC默认启用了符号检查。使用多个编译器可以帮助您解决将来可能遇到的潜在可移植性问题，特别是当决定在不同操作系统上编译代码时，例如从Linux迁移到Windows或反之。为了使这样的努力不花费任何成本，您应该努力编写可移植的、符合ISO
    C++标准的代码。**Clang**的一个好处是它比GCC更注重符合C++标准。如果您使用**MSVC**，请尝试添加`/permissive-`选项（自Visual
    Studio 17起可用；对于使用版本15.5+创建的项目，默认启用）。对于**GCC**，在为代码选择C++标准时，尽量不要使用GNU变体（例如，更喜欢`-std=c++17`而不是`-std=gnu++17`）。如果性能是您的目标，能够使用多种编译器构建软件还将使您能够选择为特定用例提供最快二进制文件的编译器。
- en: Regardless of which compiler you choose for your release builds, consider using
    Clang for development. It runs on macOS, Linux, and Windows, supports the same
    set of flags as GCC, and aims to provide the fastest build times and concise compilation
    errors.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您选择哪个编译器进行发布构建，都应考虑在开发中使用Clang。它可以在macOS、Linux和Windows上运行，支持与GCC相同的一组标志，并旨在提供最快的构建时间和简洁的编译错误。
- en: 'If you''re using CMake, you have two common ways to add another compiler. One
    is to pass the appropriate compilers when invoking CMake, like so:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用CMake，有两种常见的方法可以添加另一个编译器。一种是在调用CMake时传递适当的编译器，如下所示：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It's also possible to just set CC and CXX before invoking CMake, but those variables
    are not honored on all platforms (such as macOS).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以在调用CMake之前设置CC和CXX，但这些变量并非在所有平台上都受到尊重（例如macOS）。
- en: 'Another approach is to use toolchain files. It''s probably an overkill if you
    just need to use a different compiler, but it''s the go-to solution when you want
    to cross-compile. To use a toolchain file, you should pass it as a CMake argument:
    `-DCMAKE_TOOLCHAIN_FILE=toolchain.cmake`.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用工具链文件。如果你只需要使用不同的编译器，这可能有点过度，但当你想要交叉编译时，这是一个常用的解决方案。要使用工具链文件，你应该将其作为CMake参数传递：`-DCMAKE_TOOLCHAIN_FILE=toolchain.cmake`。
- en: Reducing build times
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少构建时间
- en: Every year, programmers spend countless hours waiting for their builds to complete.
    Reducing build times is an easy way to improve the productivity of whole teams,
    so let's discuss a few approaches to doing it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每年，程序员们花费无数时间等待他们的构建完成。减少构建时间是提高整个团队生产力的简单方法，所以让我们讨论一下几种方法来做到这一点。
- en: Using a fast compiler
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用一个快速编译器
- en: 'One of the simplest ways to have faster builds is sometimes to upgrade your
    compiler. For instance, by upgrading Clang to 7.0.0, you could shave up to 30%
    off of build times using **Precompiled Header** (**PCH**) files. Since Clang 9,
    it has gained the `-ftime-trace` option, which can provide you with information
    on the compilation times of all the files it processes. Other compilers have similar
    switches, too: check out GCC''s `-ftime-report` or MSVC''s `/Bt` and `/d2cgsummary`.
    Often you can get faster compiles by switching the compiler, which is especially
    useful on your development machine; for example, Clang usually compiles code faster
    than GCC.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有时使构建更快的最简单方法之一是升级你的编译器。例如，通过将Clang升级到7.0.0，你可以减少高达30%的构建时间，使用**预编译头**（**PCH**）文件。自Clang
    9以来，它已经获得了`-ftime-trace`选项，它可以为你提供有关它处理的所有文件的编译时间的信息。其他编译器也有类似的开关：比如查看GCC的`-ftime-report`或MSVC的`/Bt`和`/d2cgsummary`。通常情况下，通过切换编译器可以获得更快的编译速度，这在你的开发机器上尤其有用；例如，Clang通常比GCC更快地编译代码。
- en: Once you have a fast compiler, let's take a look at what it needs to compile.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了一个快速的编译器，让我们看看它需要编译什么。
- en: Rethinking templates
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新思考模板
- en: 'Different parts of the compilation process take a different amount of time
    to complete. This is especially important for compile-time constructs. One of
    Odin Holmes'' interns, Chiel Douwes, created the so-called Rule of Chiel based
    on benchmarking the compile-time costs of various template operations. This, and
    other type-based template metaprogramming tricks, can be seen in the *Type Based
    Template Metaprogramming is Not Dead* lecture by Odin Holmes. From fastest to
    slowest, they are as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 编译过程的不同部分需要不同的时间来完成。这对于编译时构造尤为重要。Odin Holmes的一个实习生Chiel Douwes基于对各种模板操作的编译时成本进行基准测试，创造了所谓的Chiel规则。这个规则以及其他基于类型的模板元编程技巧可以在Odin
    Holmes的*基于类型的模板元编程并没有死*讲座中看到。从最快到最慢，它们如下：
- en: Looking up a memoized type (for example, a template instantiation)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找一个记忆化类型（例如，一个模板实例化）
- en: Adding a parameter to an alias call
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向别名调用添加一个参数
- en: Adding a parameter to a type
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个参数到一个类型
- en: Calling an alias
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用一个别名
- en: Instantiating a type
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例化一个类型
- en: Instantiating a function template
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例化一个函数模板
- en: Using **SFINAE** (**Substitution Failure Is Not an Error**)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**SFINAE**（**替换失败不是错误**）
- en: 'To demonstrate this rule, consider the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这个规则，考虑以下代码：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It defines a `conditional` template alias, which stores a type that resolves
    as `T` if condition `B` is true, and to `F` otherwise. The traditional way to
    write such a utility would be as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 它定义了一个`conditional`模板别名，它存储一个类型，如果条件`B`为真，则解析为`T`，否则解析为`F`。编写这样一个实用程序的传统方式如下：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: However, this second way is slower to compile than the first because it relies
    on creating template instances instead of type aliases.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这第二种方法比第一种编译速度慢，因为它依赖于创建模板实例而不是类型别名。
- en: Let's now take a look at what tools and their features you can use to keep compile
    times low.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看你可以使用哪些工具及其特性来保持编译时间低。
- en: Leveraging tools
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用工具
- en: A common technique that can make your builds faster is to use a **single compilation
    unit build,** or **unity build**. It won't speed up every project, but it may
    be worth a shot if there's plenty of code in your header files. Unity builds work
    by just including all your `.cpp` files in one translation unit. Another similar
    idea is to use pre-compiled headers. Plugins such as Cotire for CMake will handle
    both of these techniques for you. CMake 3.16 also adds native support for unity
    builds, which you can enable either for one target, `set_target_properties(<target>
    PROPERTIES UNITY_BUILD ON)`, or globally by setting `CMAKE_UNITY_BUILD` to `true`.
    If you just want PCHs, you might want to take a look into CMake 3.16's `target_precompile_headers`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的技术，可以使你的构建更快，就是使用**单一编译单元构建**，或者**统一构建**。它不会加速每个项目，但如果你的头文件中有大量代码，这可能值得一试。统一构建通过将所有`.cpp`文件包含在一个翻译单元中来工作。另一个类似的想法是使用预编译头文件。像CMake的Cotire这样的插件将为你处理这两种技术。CMake
    3.16还增加了对统一构建的本机支持，你可以通过为一个目标启用它，`set_target_properties(<target> PROPERTIES UNITY_BUILD
    ON`，或者通过将`CMAKE_UNITY_BUILD`设置为`true`来全局启用。如果你只想要PCHs，你可能需要查看CMake 3.16的`target_precompile_headers`。
- en: If you feel like you are including too much in your C++ files, consider using
    a tool named **include-what-you-use** to tidy them up. Preferring forward declaring
    types and functions to including header files can also go a long way in reducing
    the compilation times.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得你在C++文件中包含了太多内容，考虑使用一个名为**include-what-you-use**的工具来整理它们。更倾向于前向声明类型和函数而不是包含头文件也可以在减少编译时间方面走得更远。
- en: 'If your project takes forever to link, there are some ways to deal with this
    as well. Using a different linker, such as LLVM''s LLD or GNU''s Gold, can help
    a lot, especially since they allow multi-threaded linking. If you can''t afford
    to use a different linker, you can always experiment with flags such as `-fvisibility-hidden`
    or `-fvisibility-inlines-hidden` and mark only the functions you want to have
    visible in your shared library with an appropriate annotation in the source code.
    This way, the linker will have less work to perform. If you''re using link-time
    optimization, try to only do that for the builds that are performance-critical:
    those that you plan to profile and those meant for production. Otherwise, you''ll
    probably just waste your developers'' time.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的项目链接需要很长时间，也有一些应对方法。使用不同的链接器，例如LLVM的LLD或GNU的Gold，可以帮助很多，特别是因为它们允许多线程链接。如果您负担不起使用不同的链接器，您可以尝试使用诸如`-fvisibility-hidden`或`-fvisibility-inlines-hidden`等标志，并在源代码中仅标记您希望在共享库中可见的函数。这样，链接器将有更少的工作要做。如果您正在使用链接时优化，尝试仅对性能关键的构建进行优化：计划进行性能分析和用于生产的构建。否则，您可能只会浪费开发人员的时间。
- en: If you're using CMake and aren't tied to a specific generator (for example,
    CLion requires using the `Code::Blocks` generator), you can replace the default
    Make generator with a faster one. **Ninja** is a great one to start with as it
    was created specifically to reduce build times. To use it, just pass `-G Ninja`
    when invoking CMake.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用CMake并且没有绑定到特定的生成器（例如，CLion需要使用`Code::Blocks`生成器），您可以用更快的生成器替换默认的Make生成器。**Ninja**是一个很好的选择，因为它是专门用于减少构建时间而创建的。要使用它，只需在调用CMake时传递`-G
    Ninja`。
- en: There are still two more great tools that will surely give you a boost. One
    of them is **Ccache**. It's a tool that runs its cache of C and C++ compilation
    outputs. If you're trying to build the same thing twice, it will get the results
    from the cache instead of running the compilation. It keeps the statistics, such
    as cache hits and misses, can remember the warnings that it should emit when compiling
    a specific file, and has many configuration options that you can store in the
    `~/.ccache/ccache.conf` file. To obtain its statistics, just run `ccache --show-stats`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个很棒的工具，肯定会给您带来帮助。其中一个是**Ccache**。它是一个运行其C和C++编译输出缓存的工具。如果您尝试两次构建相同的东西，它将从缓存中获取结果，而不是运行编译。它保留统计信息，如缓存命中和未命中，可以记住在编译特定文件时应发出的警告，并具有许多配置选项，可以存储在`~/.ccache/ccache.conf`文件中。要获取其统计信息，只需运行`ccache
    --show-stats`。
- en: The second tool is **IceCC** (or Icecream). It's a fork of distcc, essentially
    a tool to distribute your builds across hosts. With IceCC, it's easier to use
    a custom toolchain. It runs the iceccd daemon on each host and an icecc-scheduler
    service that manages the whole cluster. The scheduler, unlike in distcc, makes
    sure to only use the idle cycles on each machine, so you won't end up overloading
    other people's workstations.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个工具是**IceCC**（或Icecream）。这是distcc的一个分支，本质上是一个工具，可以在多台主机上分发您的构建。使用IceCC，更容易使用自定义工具链。它在每台主机上运行iceccd守护程序和一个管理整个集群的icecc-scheduler服务。调度程序与distcc不同，它确保仅使用每台机器上的空闲周期，因此您不会过载其他人的工作站。
- en: To use both IceCC and Ccache for your CMake builds, just add `-DCMAKE_C_COMPILER_LAUNCHER="ccache;icecc"
    -DCMAKE_CXX_COMPILER_LAUNCHER="ccache;icecc"` to your CMake invocation. If you're
    compiling on Windows, instead of the last two tools, you could use clcache and
    Incredibuild or look for other alternatives.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要在CMake构建中同时使用IceCC和Ccache，只需在CMake调用中添加`-DCMAKE_C_COMPILER_LAUNCHER="ccache;icecc"
    -DCMAKE_CXX_COMPILER_LAUNCHER="ccache;icecc"`。如果您在Windows上编译，您可以使用clcache和Incredibuild，或者寻找其他替代方案，而不是最后两个工具。
- en: Now that you know how to build fast, let's move on to another important topic.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何快速构建，让我们继续另一个重要的主题。
- en: Finding potential code issues
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找潜在的代码问题
- en: Even the quickest builds aren't worth much if your code has bugs. There are
    dozens of flags to warn you of potential issues in your code. This section will
    try to answer which ones you should consider enabling.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 即使最快的构建也不值得，如果你的代码有错误。有数十个标志可以警告您代码中的潜在问题。本节将尝试回答您应该考虑启用哪些标志。
- en: 'First, let''s start with a slightly different matter: how not to get warned
    about issues with code from other libraries. Getting warned about issues that
    you can''t really fix isn''t useful. Fortunately, there are compiler switches
    to disable such warnings. In GCC, for instance, you have two types of `include`
    files: regular (passed using `-I`) and system ones (passed using `-isystem`).
    If you specify a directory using the latter, you won''t get warnings from the
    headers it contains. MSVC has an equivalent for `-isystem`: `/external:I`. Additionally,
    it has other flags to handle external includes, such as `/external:anglebrackets`,
    which tells the compiler to treat all files included using angle brackets as external
    ones, thus disabling warnings for them. You can specify a warning level for external
    files. You can also keep warnings coming from template instantiations caused by
    your code using `/external:templates-`. If you''re looking for a portable way
    to mark `include` paths as system/external ones, and you''re using CMake, you
    can add the `SYSTEM` keyword to a `target_include_directories` directive.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从一个略有不同的问题开始：如何避免收到来自其他库代码的问题警告。收到无法真正修复的问题警告是没有用的。幸运的是，有编译器开关可以禁用此类警告。例如，在GCC中，您有两种类型的`include`文件：常规文件（使用`-I`传递）和系统文件（使用`-isystem`传递）。如果您使用后者指定一个目录，您将不会收到它包含的头文件的警告。MSVC有一个等效于`-isystem`的选项：`/external:I`。此外，它还有其他用于处理外部包含的标志，例如`/external:anglebrackets`，告诉编译器将使用尖括号包含的所有文件视为外部文件，从而禁用对它们的警告。您可以为外部文件指定警告级别。您还可以保留由您的代码引起的模板实例化产生的警告，使用`/external:templates-`。如果您正在寻找一种将`include`路径标记为系统/外部路径的便携方式，并且正在使用CMake，您可以在`target_include_directories`指令中添加`SYSTEM`关键字。
- en: Speaking of portability, if you want to be conformant to a C++ standard (and
    you should), consider adding `-pedantic` to your compile options for GCC or Clang,
    or the `/permissive-` option for MSVC. This way, you'll get informed about every
    non-standard extension that you might be using. If you're using CMake, add the
    following line for each of your targets, `set_target_properties(<target> PROPERTIES
    CXX_EXTENSIONS OFF)`, to disable compiler-specific extensions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到可移植性，如果您想符合C++标准（您应该这样做），请考虑为GCC或Clang的编译选项添加-pedantic，或者为MSVC添加/permissive-选项。这样，您将得到关于您可能正在使用的每个非标准扩展的信息。如果您使用CMake，请为每个目标添加以下行，set_target_properties(<target>
    PROPERTIES CXX_EXTENSIONS OFF)，以禁用特定于编译器的扩展。
- en: 'If you''re using MSVC, strive to compile your code with `/W4`, since it enables
    most of the important warnings. For GCC and Clang, try to use `-Wall -Wextra -Wconversion
    -Wsign-conversion`. The first one, despite its name, enables only some common
    warnings. The second, however, adds another bunch of warnings. The third one is
    based on the tips from a great book by Scott Meyers, titled *Effective C++* (it''s
    a set of good warnings, but check that it''s not too noisy for your needs). The
    last two are about type conversions and signedness conversions. All those flags
    together create a sane safety net, but you can, of course, look for more flags
    to enable. Clang has a `-Weverything` flag. Try to periodically run a build with
    it to discover new, potential warnings that could be worth enabling in your codebase.
    You might be surprised at how many messages you get with this flag, although enabling
    some of the warning flags might not be worth the hassle. An MSVC alternative is
    named `/Wall`. Take a look at the following tables to see some other interesting
    options that are not enabled by the preceding 9:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用MSVC，请努力使用/W4编译代码，因为它启用了大部分重要的警告。对于GCC和Clang，请尝试使用-Wall -Wextra -Wconversion
    -Wsign-conversion。第一个尽管名字是这样，但只启用了一些常见的警告。然而，第二个添加了另一堆警告。第三个基于Scott Meyers的一本名为《Effective
    C++》的好书中的建议（这是一组很好的警告，但请检查它是否对您的需求太吵闹）。最后两个是关于类型转换和符号转换的。所有这些标志一起创建了一个理智的安全网，但您当然可以寻找更多要启用的标志。Clang有一个-Weverything标志。尝试定期使用它运行构建，以发现可能值得在您的代码库中启用的新的潜在警告。您可能会对使用此标志获得多少消息感到惊讶，尽管启用一些警告标志可能不值得麻烦。MSVC的替代方案名为/Wall。看一下以下表格，看看之前未启用的其他一些有趣的选项：
- en: '**GCC/Clang**:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 'GCC/Clang:'
- en: '| **Flag** | **Meaning** |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: Flag | 意义
- en: '| `-Wduplicated-cond` | Warn when the same condition is used in `if` and `else-if`
    blocks. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: -Wduplicated-cond | 当在if和else-if块中使用相同条件时发出警告。
- en: '| `-Wduplicated-branches` | Warn if both branches contain the same source code.
    |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: -Wduplicated-branches | 如果两个分支包含相同的源代码，则发出警告。
- en: '| `-Wlogical-op` | Warn when operands in logical operations are the same and
    when a bitwise operator should be used instead. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: -Wlogical-op | 当逻辑操作中的操作数相同时发出警告，并且应使用位操作符时发出警告。
- en: '| `-Wnon-virtual-dtor` | Warn when a class has virtual functions but not a
    virtual destructor. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: -Wnon-virtual-dtor | 当一个类有虚函数但没有虚析构函数时发出警告。
- en: '| `-Wnull-dereference` | Warn about null dereferences. This check may be inactive
    in unoptimized builds. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: -Wnull-dereference | 警告空指针解引用。此检查可能在未经优化的构建中处于非活动状态。
- en: '| `-Wuseless-cast` | Warn when casting to the same type. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: -Wuseless-cast | 当转换为相同类型时发出警告。
- en: '| `-Wshadow` | A whole family of warnings about declarations that shadow other,
    previous declarations. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: -Wshadow | 一系列关于声明遮蔽其他先前声明的警告。
- en: '**MSVC:**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 'MSVC:'
- en: '| **Flag** | **Meaning** |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: Flag | 意义
- en: '| `/w44640` | Warn on non-thread-safe static member initialization. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: /w44640 | 警告非线程安全的静态成员初始化。
- en: 'One last thing worth mentioning is the question: to `-Werror` (or `/WX` on
    MSVC) or not to `-Werror`? This really depends on your personal preferences as
    issuing errors instead of warnings has its pros and cons. On the plus side, you
    won''t let any of your enabled warnings slip by. Your CI build will fail and your
    code won''t compile. When running multi-threaded builds, you won''t lose any warnings
    in the quickly passing compilation messages. However, there are some minuses too.
    You won''t be able to upgrade your compiler if it enables any new warnings or
    just detects more issues. The same goes for dependencies, which can deprecate
    some functions they provide. You won''t be able to deprecate anything in your
    code if it''s used by other parts of your project. Fortunately, you can always
    use a mixed solution: strive to compile with `-Werror`, but disable it when you
    need to do the things it inhibits. This requires discipline, as if any new warnings
    are to slip in, you may have a hard time eliminating them.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后值得一提的是一个问题：是否使用-Werror（或MSVC上的/WX）？这实际上取决于您的个人偏好，因为发出错误而不是警告有其利弊。好的一面是，您不会让任何已启用的警告溜走。您的CI构建将失败，您的代码将无法编译。在运行多线程构建时，您不会在快速通过的编译消息中丢失任何警告。然而，也有一些坏处。如果编译器启用了任何新的警告或只是检测到更多问题，您将无法升级编译器。对于依赖项也是一样，它们可能会废弃一些提供的函数。如果您的代码被项目的其他部分使用，您将无法废弃其中的任何内容。幸运的是，您总是可以使用混合解决方案：努力使用-Werror进行编译，但在需要执行它所禁止的操作时将其禁用。这需要纪律，因为如果有任何新的警告滑入，您可能会很难消除它们。
- en: Using compiler-centric tools
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用以编译器为中心的工具
- en: Nowadays, compilers allow you to do much more with them than a few years back.
    This is owing to the introduction of LLVM and Clang. By providing APIs and a modular
    architecture allowing easy reuse, caused tools such as sanitizers, automatic refactoring,
    or code completion engines to flourish. You should consider taking advantage of
    what this compiler infrastructure offers you. Use clang-format to ensure all the
    code in your code base conforms to a given standard. Consider adding pre-commit
    hooks using the pre-commit tool to reformat new code before commit. You can also
    add Python and CMake formatters to the mix. Statically analyze the code using
    clang-tidy – a tool that actually understands your code instead of just reasoning
    about it. There's a ton of different checks this tool can perform for you, so
    be sure to customize the list and options to your specific needs. You can also
    run nightly or weekly tests of your software with sanitizers enabled. This way,
    you can detect threading issues, undefined behavior, memory access, management
    issues, and more. Running tests using debug builds can also be of value if your
    release builds have assertions disabled.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编译器允许您做的事情比几年前多得多。这归功于LLVM和Clang的引入。通过提供API和模块化架构，使得诸如消毒剂、自动重构或代码完成引擎等工具得以蓬勃发展。您应该考虑利用这个编译器基础设施所提供的优势。使用clang-format确保代码库中的所有代码符合给定的标准。考虑使用pre-commit工具添加预提交挂钩，在提交之前重新格式化新代码。您还可以将Python和CMake格式化程序添加到其中。使用clang-tidy对代码进行静态分析——这是一个实际理解您的代码而不仅仅是推理的工具。这个工具可以为您执行大量不同的检查，所以一定要根据您的特定需求自定义列表和选项。您还可以在启用消毒剂的情况下每晚或每周运行软件测试。这样，您可以检测线程问题、未定义行为、内存访问、管理问题等。如果您的发布版本禁用了断言，使用调试版本运行测试也可能有价值。
- en: If you think that more could be done, you can consider writing your own code
    refactorizations using Clang's infrastructure. There's already a `clang-rename`
    tool if you want to see how to create an LLVM-based tool of your own. Additional
    checks and fix-its for clang-tidy are also not that hard to create, and they can
    save you hours of manual labor.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您认为还可以做更多，您可以考虑使用Clang的基础设施编写自己的代码重构。如果您想看看如何创建一个基于LLVM的工具，已经有了一个`clang-rename`工具。对于clang-tidy的额外检查和修复也不难创建，它们可以为您节省数小时的手动劳动。
- en: 'You can integrate many tools into your building process. Let''s now discuss
    the heart of the process: the build system.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将许多工具整合到您的构建过程中。现在让我们讨论这个过程的核心：构建系统。
- en: Abstracting the build process
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要构建过程
- en: In this section, we'll delve into CMake scripts, the de facto standard build
    system generator used for C++ projects worldwide.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入研究CMake脚本，这是全球C++项目中使用的事实标准构建系统生成器。
- en: Introducing CMake
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍CMake
- en: What does it mean that CMake is a build system generator and not a build system
    per se? Simply that CMake can be used to generate various types of build systems.
    You can use it to generate Visual Studio projects, Makefile projects, Ninja-based
    ones, Sublime, Eclipse, and a few others.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: CMake是构建系统生成器而不是构建系统本身意味着什么？简单地说，CMake可以用来生成各种类型的构建系统。您可以使用它来生成Visual Studio项目、Makefile项目、基于Ninja的项目、Sublime、Eclipse和其他一些项目。
- en: CMake comes with a set of other tools, such as CTest for executing tests and
    CPack for packaging and creating setup programs. CMake itself allows exporting
    and installing targets too.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: CMake还配备了一系列其他工具，如用于执行测试的CTest和用于打包和创建安装程序的CPack。CMake本身也允许导出和安装目标。
- en: CMake's generators can be either single-configuration, such as Make or NMAKE,
    or multi-configuration, such as Visual Studio. For single-configuration ones,
    you should pass the `CMAKE_BUILD_TYPE` flag when running the generation for the
    first time in a folder. For instance, to configure a debug build, you could run
    `cmake <project_directory> -DCMAKE_BUILD_TYPE=Debug`. Other predefined configurations
    are `Release`, `RelWithDebInfo` (release with debug symbols), and `MinSizeRel`
    (release optimized for minimum binary size). To keep your source directories clean,
    always create a separate build folder and run CMake generation from there.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: CMake的生成器可以是单配置的，比如Make或NMAKE，也可以是多配置的，比如Visual Studio。对于单配置的生成器，在首次在文件夹中运行生成时，应传递`CMAKE_BUILD_TYPE`标志。例如，要配置调试构建，您可以运行`cmake
    <project_directory> -DCMAKE_BUILD_TYPE=Debug`。其他预定义的配置有`Release`、`RelWithDebInfo`（带有调试符号的发布）和`MinSizeRel`（最小二进制大小的发布优化）。为了保持源目录清洁，始终创建一个单独的构建文件夹，并从那里运行CMake生成。
- en: Although it's possible to add your own build type, you should really strive
    not to do so, as this makes using some IDEs much harder and doesn't scale. A much
    better option is to use, well, `option`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以添加自己的构建类型，但您真的应该尽量避免这样做，因为这会使一些IDE的使用变得更加困难，而且不具有可扩展性。一个更好的选择是使用`option`。
- en: 'CMake files can be written in two styles: an obsolete one, based on variables,
    and a target-based Modern CMake style. We''ll focus just on the latter here. Try
    to avoid setting things through global variables, as this causes issues when you
    want to reuse your targets.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: CMake文件可以以两种风格编写：一种是基于变量的过时风格，另一种是基于目标的现代CMake风格。我们这里只关注后者。尽量遏制通过全局变量设置事物，因为这会在您想要重用目标时引起问题。
- en: Creating CMake projects
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建CMake项目
- en: 'Each CMake project should have the following lines in their top-level `CMakeLists.txt`
    file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每个CMake项目的顶层`CMakeLists.txt`文件中应包含以下行：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Setting a minimum and a maximum supported version is important as it influences
    how CMake will behave by setting policies. You can also set them manually if needed.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 设置最低和最大支持的版本很重要，因为它会影响CMake的行为，通过设置策略。如果需要，您也可以手动设置它们。
- en: The definition of our project specifies its name, version (which will be used
    to populate a few variables), and the programming languages that CMake will use
    to build the project (which populates many more variables and finds the required
    tools).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目的定义指定了它的名称、版本（将用于填充一些变量）和CMake将用于构建项目的编程语言（这将填充更多变量并找到所需的工具）。
- en: 'A typical C++ project has the following directories:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的C++项目有以下目录：
- en: '`cmake`: For CMake scripts'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmake`：用于CMake脚本'
- en: '`include`: For public headers, usually with a subfolder named after the project'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include`：用于公共头文件，通常带有一个项目名称的子文件夹'
- en: '`src`: For source files and private headers'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`：用于源文件和私有头文件'
- en: '`test`: For tests'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test`：用于测试'
- en: 'You can use the CMake directory to store your custom CMake modules. To have
    easy access to scripts from this directory, you can add it to CMake''s `include()`
    search path like so:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用CMake目录来存储你的自定义CMake模块。为了方便从这个目录访问脚本，你可以将它添加到CMake的`include()`搜索路径中，就像这样：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When including CMake modules, you can omit the `.cmake` suffix. This means `include(CommonCompileFlags.cmake)`
    is equal to just `include(CommonCompileFlags)`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含CMake模块时，你可以省略`.cmake`后缀。这意味着`include(CommonCompileFlags.cmake)`等同于`include(CommonCompileFlags)`。
- en: Distinguishing between CMake directory variables
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 区分CMake目录变量
- en: 'Navigating through the directories in CMake has a common pitfall that not everyone
    is aware of. When writing CMake scripts, try to distinguish between the following
    built-in variables:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在CMake中浏览目录有一个常见的陷阱，不是每个人都意识到。在编写CMake脚本时，尝试区分以下内置变量：
- en: '`PROJECT_SOURCE_DIR`: The directory where the `project` command was last called
    from a CMake script.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PROJECT_SOURCE_DIR`：`project`命令最后一次从CMake脚本中调用的目录。'
- en: '`PROJECT_BINARY_DIR`: Like the preceding one, but for the build directory tree.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PROJECT_BINARY_DIR`：与前一个相同，但用于构建目录树。'
- en: '`CMAKE_SOURCE_DIR`: Top-level source directory (this may be in another project
    that just adds ours as a dependency/subdirectory).'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_SOURCE_DIR`：顶层源目录（这可能是另一个项目，只是将我们作为依赖项/子目录添加进来）。'
- en: '`CMAKE_BINARY_DIR`: Like `CMAKE_SOURCE_DIR`, but for the build directory tree.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_BINARY_DIR`：与`CMAKE_SOURCE_DIR`相同，但用于构建目录树。'
- en: '`CMAKE_CURRENT_SOURCE_DIR`: The source directory corresponding to the currently
    processed `CMakeLists.txt` file.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_CURRENT_SOURCE_DIR`：对应于当前处理的`CMakeLists.txt`文件的源目录。'
- en: '`CMAKE_CURRENT_BINARY_DIR`: The binary (build) directory matching `CMAKE_CURRENT_SOURCE_DIR`.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_CURRENT_BINARY_DIR`：与`CMAKE_CURRENT_SOURCE_DIR`匹配的二进制（构建）目录。'
- en: '`CMAKE_CURRENT_LIST_DIR`: The directory of `CMAKE_CURRENT_LIST_FILE`. It can
    be different from the current source directory if the current CMake script was
    included from another one (common for CMake modules that are included).'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_CURRENT_LIST_DIR`：`CMAKE_CURRENT_LIST_FILE`的目录。如果当前的CMake脚本是从另一个脚本中包含的（对于被包含的CMake模块来说很常见），它可能与当前源目录不同。'
- en: Having cleared that up, let's now start navigating through those directories.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 搞清楚了这一点，现在让我们开始浏览这些目录。
- en: In your top-level `CMakeLists.txt` file, you will probably want to call `add_subdirectory(src)`
    so that CMake will process that directory.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的顶层`CMakeLists.txt`文件中，你可能想要调用`add_subdirectory(src)`，这样CMake将处理那个目录。
- en: Specifying CMake targets
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定CMake目标
- en: 'In the `src` directory, you should have another `CMakeLists.txt` file, this
    time probably defining a target or two. Let''s add an executable for a customer
    microservice for the Dominican Fair system we mentioned earlier in the book:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src`目录中，你应该有另一个`CMakeLists.txt`文件，这次可能定义了一个或两个目标。让我们为我们之前在书中提到的多米尼加展会系统添加一个客户微服务的可执行文件：
- en: '[PRE5]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Source files can be specified as in the preceding code line or added later using
    `target_sources`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 源文件可以像前面的代码行那样指定，也可以稍后使用`target_sources`添加。
- en: A common CMake antipattern is the use of globs to specify source files. A big
    drawback of using them is that CMake will not know if a file was added until it
    reruns generation. A common consequence of that is that if you pull changes from
    a repository and simply build, you can miss compiling and running new unit tests
    or other code. Even if you used globs with `CONFIGURE_DEPENDS`, the build time
    will get longer because globs must be checked as part of each build. Besides,
    the flag may not work reliably with all generators. Even the CMake authors discourage
    using it in favor of just explicitly stating the source files.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的CMake反模式是使用通配符来指定源文件。使用它们的一个很大的缺点是，CMake不会知道文件是否被添加，直到重新运行生成。这样做的一个常见后果是，如果你从存储库中拉取更改然后简单地构建，你可能会错过编译和运行新的单元测试或其他代码。即使你使用了`CONFIGURE_DEPENDS`和通配符，构建时间也会变长，因为通配符必须作为每次构建的一部分进行检查。此外，该标志可能无法可靠地与所有生成器一起使用。即使CMake的作者也不鼓励使用它，而是更倾向于明确声明源文件。
- en: 'Okay, so we defined our sources. Let''s now specify that our target requires
    C++17 support from the compiler:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们定义了我们的源代码。现在让我们指定我们的目标需要编译器支持C++17：
- en: '[PRE6]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `PRIVATE` keyword specifies that this is an internal requirement, that is,
    just visible to this specific target and not to any targets that will depend on
    it. If you were writing a library that provided a user with a C++17 API, you could
    use the `INTERFACE` keyword. To specify both the interface and internal requirements,
    you could use the `PUBLIC` keyword. When the consumer links to our target, CMake
    will then automatically require C++17 support for it as well. If you were writing
    a target that is not built (that is, a header-only library or an imported target),
    using the `INTERFACE` keyword is usually enough.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`PRIVATE`关键字指定这是一个内部要求，即只对这个特定目标可见，而不对依赖于它的任何目标可见。如果你正在编写一个提供用户C++17 API的库，你可以使用`INTERFACE`关键字。要同时指定接口和内部要求，你可以使用`PUBLIC`关键字。当使用者链接到我们的目标时，CMake将自动要求它也支持C++17。如果你正在编写一个不被构建的目标（即一个仅包含头文件的库或一个导入的目标），通常使用`INTERFACE`关键字就足够了。'
- en: 'You should also note that specifying that our target wants to use C++17 features
    doesn''t enforce the C++ standard or disallow compiler extensions for our target.
    To do so, you should instead call the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该注意，指定我们的目标要使用C++17特性并不强制执行C++标准或禁止编译器扩展。要这样做，你应该调用以下命令：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you want to have a set of compiler flags to pass to each target, you can
    store them in a variable and call the following if you want to create a target
    that has those flags set as `INTERFACE` and doesn''t have any source and uses
    this target in `target_link_libraries`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一组编译器标志传递给每个目标，你可以将它们存储在一个变量中，并在想要创建一个具有这些标志设置为`INTERFACE`的目标时调用以下命令，并且没有任何源并且使用这个目标在`target_link_libraries`中：
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The command automatically propagates include directories, options, macros,
    and other properties, aside from just adding a linker flag. Speaking of linking,
    let''s create a library that we shall link with:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令会自动传播包含目录、选项、宏和其他属性，而不仅仅是添加链接器标志。说到链接，让我们创建一个库，我们将与之链接：
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`add_library` can be used to create static, shared, object, and interface (think
    header-only) libraries, as well as defining any imported libraries.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_library`可用于创建静态、共享、对象和接口（考虑头文件）库，以及定义任何导入的库。'
- en: The **`ALIAS`** version of it creates a namespaced target, which helps debug
    many CMake issues and is a recommended Modern CMake practice.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 它的**`ALIAS`**版本创建了一个命名空间目标，有助于调试许多CMake问题，是一种推荐的现代CMake实践。
- en: Because we gave our target a `lib` prefix already, we set the output name to
    have **`libcustomer.a`** instead of `liblibcustomer.a`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们已经给我们的目标添加了`lib`前缀，所以我们将输出名称设置为**`libcustomer.a`**而不是`liblibcustomer.a`。
- en: Finally, we link our executable with the added library. Try to always specify
    the `PUBLIC`, `PRIVATE`, or `INTERFACE` keyword for the `target_link_libraries`
    command as this is crucial for CMake to effectively manage the transitivity of
    the target dependencies.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将我们的可执行文件与添加的库链接起来。尽量始终为`target_link_libraries`命令指定`PUBLIC`、`PRIVATE`或`INTERFACE`关键字，因为这对于CMake有效地管理目标依赖关系的传递性至关重要。
- en: Specifying the output directories
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定输出目录
- en: 'Once you build your code using commands such as `cmake --build .`, you might
    want to know where to find the build artifacts. By default, CMake will create
    them in a directory matching the source directory they were defined in. For instance,
    if you have a `src/CMakeLists.txt` file with an `add_executable` directive, then
    the binary will land in your build directory''s `src` subdirectory by default.
    We can override this using code such as the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您使用`cmake --build .`等命令构建代码，您可能想知道在哪里找到构建产物。默认情况下，CMake会将它们创建在与它们定义的源目录匹配的目录中。例如，如果您有一个带有`add_executable`指令的`src/CMakeLists.txt`文件，那么二进制文件将默认放在构建目录的`src`子目录中。我们可以使用以下代码来覆盖这一点：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This way, the binaries and DLL files will land in the `bin` subdirectory of
    your project's build directory, while static and shared Linux libraries will be
    placed in the `lib` subdirectory.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，二进制文件和DLL文件将放在项目构建目录的`bin`子目录中，而静态和共享Linux库将放在`lib`子目录中。
- en: Using generator expressions
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用生成器表达式
- en: Setting compile flags in a way to support both single- and multi-configuration
    generators can be tricky, as CMake executes `if` statements and many other constructs
    at configure time, not at build/install time.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以一种既支持单配置生成器又支持多配置生成器的方式设置编译标志可能会很棘手，因为CMake在配置时间执行`if`语句和许多其他结构，而不是在构建/安装时间执行。
- en: 'This means that the following is a CMake antipattern:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着以下是CMake的反模式：
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Instead, generator expressions are the proper way to achieve the same goal,
    as they''re being processed at a later time. Let''s see an example of their use
    in practice. Assuming you want to add a preprocessor definition just for your
    `Release` configuration, you could write the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，生成器表达式是实现相同目标的正确方式，因为它们在稍后的时间被处理。让我们看一个实际使用它们的例子。假设您想为您的`Release`配置添加一个预处理器定义，您可以编写以下内容：
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will resolve to `RUN_FAST` only when building that one selected configuration.
    For others, it will resolve to an empty value. It works for both single- and multi-configuration
    generators. That's not the only use case for generator expressions, though.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将仅在构建所选的配置时解析为`RUN_FAST`。对于其他配置，它将解析为空值。它适用于单配置和多配置生成器。然而，这并不是生成器表达式的唯一用例。
- en: 'Some aspects of our targets may vary when used by our project during builds
    and by other projects when the target is installed. A good example is **include
    directories**. A common way to deal with this in CMake is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建期间由我们的项目使用时，我们的目标的某些方面可能会有所不同，并且在安装目标时由其他项目使用时也会有所不同。一个很好的例子是**包含目录**。在CMake中处理这个问题的常见方法如下：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this case, we have two generator expressions. The first one tells us that
    when installed, the include files can be found in the `include` directory, relative
    to the install prefix (the root of the installation). If we're not installing,
    this expression will become an empty one. This is why we have another expression
    for building. This one will resolve as the `include` subdirectory of the directory
    where the last used `project()` was found.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有两个生成器表达式。第一个告诉我们，当安装时，可以在`include`目录中找到包含文件，相对于安装前缀（安装的根目录）。如果我们不安装，这个表达式将变为空。这就是为什么我们有另一个用于构建的表达式。这将解析为上次使用`project()`找到的目录的`include`子目录。
- en: Don't use `target_include_directories` with a path outside of your module. If
    you do, you're **stealing** someone's headers instead of explicitly declaring
    a library/target dependency. This is a CMake antipattern.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在模块之外的路径上使用`target_include_directories`。如果这样做，您就是**偷**别人的头文件，而不是明确声明库/目标依赖关系。这是CMake的反模式。
- en: CMake defines many generator expressions that you can use to query the compiler
    and platform, as well as the targets (such as full name, the list of object files,
    any property values, and so on). Aside from these, there are expressions that
    run Boolean operations, if statements, string comparisons, and more.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: CMake定义了许多生成器表达式，您可以使用这些表达式来查询编译器和平台，以及目标（例如完整名称、对象文件列表、任何属性值等）。除此之外，还有运行布尔操作、if语句、字符串比较等表达式。
- en: 'Now, for a more complex example, assuming you''d like to have a set of compile
    flags that you use across your targets and that depend on the compiler used, you
    could define it as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，举一个更复杂的例子，假设您想要有一组编译标志，您可以在所有目标上使用，并且这些标志取决于所使用的编译器，您可以定义如下：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will append one set of flags if the compiler is Clang or AppleClang or
    GCC and another one if MSVC is being used instead. Note that we separate the flags
    with a semicolon because that's how CMake separates elements on a list.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编译器是Clang或AppleClang或GCC，则会附加一组标志，如果使用的是MSVC，则会附加另一组标志。请注意，我们使用分号分隔标志，因为这是CMake在列表中分隔元素的方式。
- en: Let's now see how we could add external code for our projects to use.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何为我们的项目添加外部代码供其使用。
- en: Using external modules
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用外部模块
- en: There are several ways for you to fetch the external projects you depend on.
    For instance, you could add them as a Conan dependency, use CMake's `find_package`
    to look for a version provided by the OS or installed in another way, or fetch
    and compile the dependency yourself.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以获取您所依赖的外部项目。例如，您可以将它们添加为Conan依赖项，使用CMake的`find_package`来查找操作系统提供的版本或以其他方式安装的版本，或者自行获取和编译依赖项。
- en: 'The key message of this section is: if you can, you should use Conan. This
    way, you''ll end up using one version of the dependency that matches your project''s
    and its dependencies'' requirements.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的关键信息是：如果可以的话，应该使用Conan。这样，您将最终使用与您的项目及其依赖项要求相匹配的依赖项版本。
- en: If you're aiming to support multiple platforms, or even multiple versions of
    the same distribution, using Conan or compiling everything yourself are the ways
    to go. This way, you'll use the same dependency version regardless of the OS you
    compile on.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的目标是支持多个平台，甚至是同一发行版的多个版本，使用Conan或自行编译都是可行的方法。这样，无论您在哪个操作系统上编译，都将使用相同的依赖项版本。
- en: Let's discuss a few ways of grabbing your dependencies offered by CMake itself,
    and then jump to using the multi-platform package manager named Conan.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下CMake本身提供的几种抓取依赖项的方法，然后转而使用名为Conan的多平台包管理器。
- en: Fetching dependencies
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取依赖项
- en: One of the possible ways to prepare your dependencies from the source is to
    use CMake's built-in `FetchContent` module. It will download your dependencies
    and then build them for you as a regular target.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CMake内置的`FetchContent`模块从源代码准备依赖项的一种可能的方法是。它将为您下载依赖项，然后像常规目标一样构建它们。
- en: The feature arrived in CMake 3.11\. It's a replacement for the `ExternalProject`
    module, which had many flaws. One of them was that it cloned the external repository
    during build time, so CMake couldn't reason about the targets that the external
    project defined, as well as about their dependencies. This made many projects
    resort to manually defining the `include` directories and library paths of such
    external targets and ignoring their required interface compilation flags and dependencies
    completely. Ouch. `FetchContent` doesn't have such issues, so it's recommended
    you use it instead.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能在CMake 3.11中推出。它是`ExternalProject`模块的替代品，后者有许多缺陷。其中之一是它在构建时克隆了外部存储库，因此CMake无法理解外部项目定义的目标，以及它们的依赖关系。这使得许多项目不得不手动定义这些外部目标的`include`目录和库路径，并完全忽略它们所需的接口编译标志和依赖关系。`FetchContent`没有这样的问题，因此建议您使用它。
- en: Before we show how to use it, you must know that both `FetchContent` and `ExternalProject`
    (as well as using Git submodules and similar methods) have one important flaw.
    If you have many dependencies using the same third-party library themselves, you
    might end up with having multiple versions of the same project, such as a few
    versions of Boost. Using package managers such as Conan can help you avoid such
    issues.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在展示如何使用之前，您必须知道`FetchContent`和`ExternalProject`（以及使用Git子模块和类似方法）都有一个重要的缺陷。如果您有许多依赖项使用同一个第三方库，您可能最终会得到同一项目的多个版本，例如几个版本的Boost。使用Conan等包管理器可以帮助您避免这种问题。
- en: 'For the sake of an example, let''s demonstrate how to integrate **GTest** into
    your project using the aforementioned `FetchContent` feature. First, create a
    `FetchGTest.cmake` file and put it in the `cmake` directory in our source tree.
    Our `FetchGTest` script will be defined as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，让我们演示如何使用上述的`FetchContent`功能将**GTest**集成到您的项目中。首先，创建一个`FetchGTest.cmake`文件，并将其放在我们源代码树中的`cmake`目录中。我们的`FetchGTest`脚本将定义如下：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First, we include the built-in `FetchContent` module. Once the module is loaded,
    we declare the dependency using `FetchContent_Declare`. Now, let's name our dependency
    and specify the repository that CMake will clone, along with the revision that
    it will check out.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们包含内置的`FetchContent`模块。一旦加载了该模块，我们就可以使用`FetchContent_Declare`来声明依赖项。现在，让我们命名我们的依赖项，并指定CMake将克隆的存储库以及它将检出的修订版本。
- en: Now, we can read the properties of our external library and populate (that is,
    check it out) it if that wasn't done already. Once we have the sources, we can
    process them using `add_subdirectory`. The `EXCLUDE_FROM_ALL` option will tell
    CMake to not build those targets if they're not needed by other targets when we
    run a command such as `make all`. After successfully processing the directory,
    our script will print a message denoting the directory in which GTests libraries
    will land after being built.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以读取我们外部库的属性并填充（即检出）它（如果尚未完成）。一旦我们有了源代码，我们可以使用`add_subdirectory`来处理它们。`EXCLUDE_FROM_ALL`选项将告诉CMake在运行诸如`make
    all`这样的命令时，如果其他目标不需要它们，就不要构建这些目标。在成功处理目录后，我们的脚本将打印一条消息，指示GTests库在构建后将位于哪个目录中。
- en: If you're not fond of building your dependencies together with your project,
    perhaps the next way of integrating your dependencies will be more suitable for
    you.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不喜欢将依赖项与项目一起构建，也许下一种集成依赖项的方式更适合您。
- en: Using find scripts
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用查找脚本
- en: Assuming your dependency is available somewhere on your host, you can just call
    `find_package` to try to search for it. If your dependency provides a config or
    targets files (more on those later), then just writing this one simple command
    is all you need. That is, of course, assuming that the dependencies are already
    available on your machine. If not, it's your responsibility to install them before
    running CMake for your project.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的依赖项在主机的某个地方可用，你可以调用`find_package`来尝试搜索它。如果你的依赖项提供了配置或目标文件（稍后会详细介绍），那么只需编写这一个简单的命令就足够了。当然，前提是依赖项已经在你的机器上可用。如果没有，你需要在运行CMake之前安装它们。
- en: To create the preceding files, your dependency would need to use CMake, which
    is not always the case. How could you deal with those libraries that don't use
    CMake? If the library is popular, chances are someone already created a find script
    for you to use. The Boost libraries in versions older than 1.70 were a common
    example of this approach. CMake comes with a `FindBoost` module that you can execute
    by just running `find_package(Boost)`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建前面的文件，你的依赖项需要使用CMake，但这并不总是情况。那么，你该如何处理那些不使用CMake的库呢？如果这个库很受欢迎，很可能已经有人为你创建了一个查找脚本。版本早于1.70的Boost库就是这种方法的一个常见例子。CMake自带一个`FindBoost`模块，你可以通过运行`find_package(Boost)`来执行它。
- en: 'To find Boost using the preceding module, you would first need to install it
    on your system. After that, in your CMake lists, you should set any options that
    you find reasonable. For instance, to use dynamic and multi-threaded Boost libraries,
    not linked statically to the C++ runtime, specify the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用前面的模块找到Boost，你首先需要在系统上安装它。之后，在你的CMake列表中，你应该设置任何你认为合理的选项。例如，要使用动态和多线程Boost库，而不是静态链接到C++运行时，指定如下：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, you need to actually search for the library, as shown next:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要实际搜索库，如下所示：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, we specified that we want to just use Beast, a great networking library
    that comes as part of Boost. Once found, you could link it to your target as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定我们只想使用Beast，这是Boost的一部分，一个很棒的网络库。一旦找到，你可以将它链接到你的目标，如下所示：
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now that you know how to properly use a find script, let's learn how to write
    one on your own.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何正确使用查找脚本了，让我们学习如何自己编写一个。
- en: Writing find scripts
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写查找脚本
- en: If your dependency is neither providing config and target files nor has anyone
    written a find module for it, you can always write such a module yourself.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的依赖项既没有提供配置和目标文件，也没有人为其编写查找模块，你总是可以自己编写这样的模块。
- en: This is not something you'll do very often, so we'll try to just skim the topic.
    For an in-depth description, you should also read the guidelines in the official
    CMake documentation (linked in the *Further reading* section) or just look at
    a few find modules installed with CMake (usually in a directory such as `/usr/share/cmake-3.17/Modules`
    on Unix systems). For simplicity, we assume there's just one configuration of
    your dependency that you'd like to find, but it's possible to find `Release` and
    `Debug` binaries separately. This will result in different targets with different
    associated variables being set.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是你经常做的事情，所以我们会尽量简要地介绍一下这个主题。如果你想深入了解，你还应该阅读官方CMake文档中的指南（在*进一步阅读*部分中链接），或者查看CMake安装的一些查找模块（通常在Unix系统的`/usr/share/cmake-3.17/Modules`等目录中）。为简单起见，我们假设你只想找到你的依赖项的一个配置，但也可以分别找到`Release`和`Debug`二进制文件。这将导致设置不同的目标和相关变量。
- en: The script name determines the argument you'll pass to `find_package`; for example,
    if you wish to end up with `find_package(Foo)`, then your script should be named
    `FindFoo.cmake`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本名称决定了你将传递给`find_package`的参数；例如，如果你希望最终得到`find_package(Foo)`，那么你的脚本应该命名为`FindFoo.cmake`。
- en: 'A good practice is to start your script with a `reStructuredText` section describing
    what your script will actually do, which variables it will set, and so on. An
    example of such a description could be as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的做法是从一个`reStructuredText`部分开始编写脚本，描述你的脚本实际要做什么，它将设置哪些变量等等。这样的描述示例可能如下：
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Usually, you''ll also want to describe the variables your script will set:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你还会想描述一下你的脚本将设置的变量：
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If `MyDep` has any dependencies itself, now is the time to find them:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`MyDep`本身有任何依赖项，现在就是找到它们的时候了：
- en: '[PRE21]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we can start our search for the library. A common way to do so is to use
    `pkg-config`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始搜索库了。一个常见的方法是使用`pkg-config`：
- en: '[PRE22]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If `pkg-config` has information on our dependency, it will set some variables
    we can use to find it.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`pkg-config`有关于我们的依赖项的信息，它将设置一些我们可以用来找到它的变量。
- en: A good idea might be to have a variable that the user of our script can set
    to point us to the location of the library. As per CMake conventions, it should
    be named `MyDep_ROOT_DIR`. To provide CMake with this variable, the user can either
    invoke CMake with `-DMyDep_ROOT_DIR=some/path`, modify the variable in `CMakeCache.txt`
    in their build directory, or use the `ccmake` or `cmake-gui` programs.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好主意可能是让我们的脚本用户设置一个变量，指向库的位置。按照CMake的约定，它应该被命名为`MyDep_ROOT_DIR`。用户可以通过在构建目录中调用`-DMyDep_ROOT_DIR=some/path`来提供这个变量给CMake，修改`CMakeCache.txt`中的变量，或者使用`ccmake`或`cmake-gui`程序。
- en: 'Now, we can actually search for the headers and libraries of our dependency
    using the aforementioned paths:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用前面提到的路径实际搜索我们的依赖项的头文件和库：
- en: '[PRE23]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we need to also set the found version, as we promised in the header of
    our script. To use the one found from `pkg-config`, we could write the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们还需要设置找到的版本，就像我们在脚本头部承诺的那样。要使用从`pkg-config`找到的版本，我们可以编写如下内容：
- en: '[PRE24]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Alternatively, we can just manually extract the version either from the contents
    of the header file, from components of the library path, or using any other means.
    Once this is done, let''s leverage CMake''s built-in scripts to decide whether
    the library was successfully found while handling all the possible parameters
    to the `find_package` invocation:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以手动从头文件的内容、库路径的组件或使用其他任何方法中提取版本。完成后，让我们利用CMake的内置脚本来决定库是否成功找到，同时处理`find_package`调用的所有可能参数：
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As we decided to provide a target and not just a bunch of variables, now it''s
    time to define it:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们决定提供一个目标而不仅仅是一堆变量，现在是定义它的时候了：
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, let''s hide our internally used variables with users who don''t want
    to deal with them:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们隐藏我们内部使用的变量，以免让不想处理它们的用户看到：
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we have a complete find module that we can use in the following way:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了一个完整的查找模块，我们可以按以下方式使用它：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is how you can write the find module yourself.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您可以自己编写查找模块的方法。
- en: Don't write `Find\*.cmake` modules for your own packages. Those are meant for
    packages that don't support CMake. Instead, write a `Config\*.cmake` module (as
    described later in this chapter).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 不要为您自己的包编写`Find\*.cmake`模块。这些模块是为不支持CMake的包而设计的。相反，编写一个`Config\*.cmake`模块（如本章后面所述）。
- en: Let's now show how to use a proper package manager instead of doing the heavy
    lifting yourself.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们展示如何使用一个合适的包管理器，而不是自己来处理繁重的工作。
- en: Using the Conan package manager
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Conan包管理器
- en: Conan is an open source, decentralized package manager for native packages.
    It supports multiple platforms and compilers. It can also integrate with multiple
    build systems.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Conan是一个开源的、去中心化的本地包管理器。它支持多个平台和编译器。它还可以与多个构建系统集成。
- en: If a package has not already been built for your environment, Conan will handle
    building it on your machine instead of downloading the already-built version.
    Once built, you can upload it to either the public repositories, your own `conan_server`
    instance, or an Artifactory server.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个包在您的环境中尚未构建，Conan将在您的计算机上处理构建它，而不是下载已构建的版本。构建完成后，您可以将其上传到公共存储库、您自己的`conan_server`实例，或者Artifactory服务器。
- en: Preparing Conan profiles
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备Conan配置文件
- en: 'If this is the first time you''re running Conan, it will create a default profile
    based on your environment. You might want to modify some of its settings either
    by creating a new profile or by updating the default one. Assuming we''re using
    Linux and want to compile everything using GCC 9.x, we could run the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是您第一次运行Conan，它将根据您的环境创建一个默认配置文件。您可能希望通过创建新配置文件或更新默认配置文件来修改其中的一些设置。假设我们正在使用Linux，并且希望使用GCC
    9.x编译所有内容，我们可以运行以下命令：
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If our dependencies come from other repositories than the default ones, we can
    add those using `conan remote add <repo> <repo_url>`. You might want to use this
    to configure your company's one, for instance.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的依赖来自于默认存储库之外的其他存储库，我们可以使用`conan remote add <repo> <repo_url>`来添加它们。例如，您可能希望使用这个来配置您公司的存储库。
- en: Now that we've set Conan up, let's show how to grab our dependencies using Conan
    and integrate all of this into our CMake scripts.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了Conan，让我们展示如何使用Conan获取我们的依赖，并将所有这些集成到我们的CMake脚本中。
- en: Specifying Conan dependencies
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定Conan依赖
- en: 'Our project relies on the C++ REST SDK. To tell this to Conan, we need to create
    a file called `conanfile.txt`. In our case, it will contain the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目依赖于C++ REST SDK。为了告诉Conan这一点，我们需要创建一个名为`conanfile.txt`的文件。在我们的情况下，它将包含以下内容：
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can specify as many dependencies as you want here. Each of them can have
    either a fixed version, a range of the fixed versions, or a tag such as **latest**.
    After the `@` sign, you can find the company that owns the package and the channel
    that allows you to select a specific variant of the package (usually stable and
    testing).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里指定尽可能多的依赖。每个依赖可以有一个固定的版本、一系列固定版本，或者像**latest**这样的标签。在`@`符号之后，您可以找到拥有该包的公司以及允许您选择特定变体的通道（通常是稳定和测试）。
- en: The **generators** section is where you specify what build systems you want
    to use. For CMake projects, you should use `CMakeDeps`. You can also generate
    lots of others, including ones for generating compiler arguments, CMake toolchain
    files, Python virtual environments, and many more.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**生成器**部分是您指定要使用的构建系统的地方。对于CMake项目，您应该使用`CMakeDeps`。您还可以生成许多其他生成器，包括用于生成编译器参数、CMake工具链文件、Python虚拟环境等等。'
- en: 'In our case, we don''t specify any additional options, but you could easily
    add this section and configure variables for your packages and for their dependencies.
    For instance, to compile our dependency as a static library, we could write the
    following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们没有指定任何其他选项，但您可以轻松添加此部分，并为您的包和它们的依赖项配置变量。例如，要将我们的依赖项编译为静态库，我们可以编写以下内容：
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Once we have `conanfile.txt` in place, let's tell Conan to use it.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们放置了`conanfile.txt`，让我们告诉Conan使用它。
- en: Installing Conan dependencies
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装Conan依赖
- en: 'To use our Conan packages in CMake code, we must first install them. In Conan,
    this means downloading the sources and building them or downloading prebuilt binaries,
    as well as creating configuration files that we''ll use in CMake. To make Conan
    handle this for us after we have created our build directory, we should `cd` into
    it and simply run the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要在CMake代码中使用我们的Conan包，我们必须先安装它们。在Conan中，这意味着下载源代码并构建它们，或者下载预构建的二进制文件，并创建我们将在CMake中使用的配置文件。在我们创建了构建目录后，让Conan在我们之后处理这些，我们应该`cd`进入它，然后简单地运行以下命令：
- en: '[PRE32]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: By default, Conan wants to download all the dependencies as prebuilt binaries.
    If the server doesn't have them prebuilt, Conan will build them instead of bailing
    out as we passed the `--build=missing` flag. We tell it to grab the release versions
    built using the same compiler and environment as we have in our profile. You can
    install packages for more than one build type by simply invoking another commands
    with `build_type` set to other CMake build types. This can help you quickly switch
    between them if needed. If you want to use the default profile (the one Conan
    can detect for you automatically), just don't pass the `-pr` flag.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Conan希望下载所有依赖项作为预构建的二进制文件。如果服务器没有预构建它们，Conan将构建它们，而不是像我们传递了`--build=missing`标志那样退出。我们告诉它抓取使用与我们配置文件中相同的编译器和环境构建的发布版本。您可以通过简单地使用`build_type`设置为其他CMake构建类型的另一个命令来为多个构建类型安装软件包。如果需要，这可以帮助您快速切换。如果要使用默认配置文件（Conan可以自动检测到的配置文件），只需不传递`-pr`标志。
- en: If the CMake generator we plan to use was not specified in `conanfile.txt`,
    we can append it to the preceding command. For instance, to use the `compiler_args`
    generator, we should append `--generator compiler_args`. Later you could use what
    it produced by passing `@conanbuildinfo.args` to your compiler invocation.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们计划使用的CMake生成器没有在`conanfile.txt`中指定，我们可以将其附加到前面的命令中。例如，要使用`compiler_args`生成器，我们应该附加`--generator
    compiler_args`。稍后，您可以通过将`@conanbuildinfo.args`传递给编译器调用来使用它生成的内容。
- en: Using Conan targets from CMake
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用CMake中的Conan目标
- en: Once Conan finishes downloading, building, and configuring our dependencies,
    we need to tell CMake to use them.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Conan完成下载、构建和配置我们的依赖关系，我们需要告诉CMake使用它们。
- en: 'If you''re using Conan with the `CMakeDeps` generator, be sure to specify a
    `CMAKE_BUILD_TYPE` value. In other cases, CMake will be unable to use the packages
    configured by Conan. An example invocation (from the same directory you ran Conan)
    could be as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用带有`CMakeDeps`生成器的Conan，请确保指定`CMAKE_BUILD_TYPE`值。否则，CMake将无法使用Conan配置的软件包。例如调用（从您运行Conan的相同目录）可能如下所示：
- en: '[PRE33]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This way, we would build our project in release mode; we must use one of the
    types we installed using Conan. To find our dependencies, we can just use CMake''s
    `find_package`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们将以发布模式构建我们的项目；我们必须使用Conan安装的类型之一。要找到我们的依赖关系，我们可以使用CMake的`find_package`：
- en: '[PRE34]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: First, we add the root build directory to the path CMake will try to find package
    config files in. Then, we find the package config files generated by Conan.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将根构建目录添加到CMake将尝试在其中查找软件包配置文件的路径中。然后，我们找到Conan生成的软件包配置文件。
- en: 'To pass Conan-defined targets as our targets'' dependencies, it''s best to
    use the namespaced target name:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Conan定义的目标作为我们目标的依赖项传递，最好使用命名空间目标名称：
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This way, we'll get an error during CMake's configuration when the package is
    not found. Without the alias, we'd get an error when trying to link.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当找不到包时，我们将在CMake的配置期间收到错误。如果没有别名，我们在尝试链接时会收到错误。
- en: Now that we have compiled and linked our targets just the way we wanted, it's
    time to put them to the test.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经按照我们想要的方式编译和链接了我们的目标，是时候进行测试了。
- en: Adding tests
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加测试
- en: CMake has its own test driver program named `CTest`. It's easy to add new test
    suites to it from your `CMakeLists` either on your own or using the many integrations
    provided by testing frameworks. Later in the book, we'll discuss testing in depth,
    but let's first show how to quickly and cleanly add unit tests based on the GoogleTest,
    or GTest, testing framework.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: CMake有自己的测试驱动程序，名为`CTest`。很容易从您的`CMakeLists`中添加新的测试套件，无论是自己还是使用测试框架提供的许多集成。在本书的后面，我们将深入讨论测试，但首先让我们展示如何快速而干净地基于GoogleTest或GTest测试框架添加单元测试。
- en: 'Usually, to define your tests in CMake, you''ll want to write the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，要在CMake中定义您的测试，您会想要编写以下内容：
- en: '[PRE36]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The preceding snippet will first check whether we are the main project that's
    being built or not. Usually, you just want to run tests for your project and omit
    even building the tests for any third-party components you use. This is why the
    project name is `checked`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的片段将首先检查我们是否是正在构建的主项目。通常，您只想为您的项目运行测试，并且甚至不想为您使用的任何第三方组件构建测试。这就是为什么项目名称是`checked`。
- en: If we are to run our tests, we include the `CTest` module. This loads the whole
    testing infrastructure CTest offers, defines its additional targets, and calls
    a CMake function called `enable_testing`, which will, among other things, enable
    the `BUILD_TESTING` flag. This flag is cached, so you can disable all testing
    when building your project by simply passing a `-DBUILD_TESTING=OFF` argument
    to CMake when generating the build system.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要运行我们的测试，我们包括`CTest`模块。这将加载CTest提供的整个测试基础设施，定义其附加目标，并调用一个名为`enable_testing`的CMake函数，该函数将在其他事项中启用`BUILD_TESTING`标志。此标志是缓存的，因此您可以通过在生成构建系统时简单地传递`-DBUILD_TESTING=OFF`参数来禁用所有测试来构建您的项目。
- en: All such cached variables are actually stored in a text file named `CMakeCache.txt`
    in your build directory. Feel free to modify the variables there to change what
    CMake does; it won't overwrite the settings there until you remove the file. You
    can do so using `ccmake`, `cmake-gui`, or just by hand.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些缓存变量实际上都存储在名为`CMakeCache.txt`的文本文件中，位于您的构建目录中。随意修改那里的变量以更改CMake的操作；直到您删除该文件，它才不会覆盖那里的设置。您可以使用`ccmake`、`cmake-gui`，或者手动进行修改。
- en: 'If `BUILD_TESTING` is true, we simply process the `CMakeLists.txt` file in
    our test directory. It could look like so:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`BUILD_TESTING`为true，我们只需处理我们测试目录中的`CMakeLists.txt`文件。可能看起来像这样：
- en: '[PRE37]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The first include calls the script for providing us GTest that we described
    previously. After fetching GTest, our current `CMakeLists.txt` loads some helper
    function defined in the GoogleTest CMake module by invoking `include(GoogleTest)`.
    This will enable us to integrate our tests into CTest more easily. Finally, let's
    tell CMake to dive into a directory that contains some tests by calling `add_subdirectory(customer)`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个include调用了我们之前描述的提供GTest的脚本。在获取了GTest之后，我们当前的`CMakeLists.txt`通过调用`include(GoogleTest)`加载了GoogleTest
    CMake模块中定义的一些辅助函数。这将使我们更容易地将我们的测试集成到CTest中。最后，让我们告诉CMake进入一个包含一些测试的目录，通过调用`add_subdirectory(customer)`。
- en: 'The `test/customer/CMakeLists.txt` file will simply add an executable with
    tests that is compiled with our predefined set of flags and links to the tested
    module and GTest. Then, we call the CTest helper function that discovers the defined
    tests. All of this is just four lines of CMake code:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/customer/CMakeLists.txt`文件将简单地添加一个使用我们预定义的标志编译的带有测试的可执行文件，并链接到被测试的模块和GTest。然后，我们调用CTest辅助函数来发现已定义的测试。所有这些只是四行CMake代码：'
- en: '[PRE38]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Voilà!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 大功告成！
- en: 'You can now build and execute your tests by simply going to the `build` directory
    and calling the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过简单地转到`build`目录并调用以下命令来构建和执行您的测试：
- en: '[PRE39]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You can pass a `-j` flag for CTest. It works just like with Make or Ninja invocations
    – parallelizes the test execution. If you want to have a shorter command for building,
    just run your build system, that is, by invoking `make`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为CTest传递一个`-j`标志。它的工作方式与Make或Ninja调用相同-并行化测试执行。如果您想要一个更短的构建命令，只需运行您的构建系统，也就是通过调用`make`。
- en: In scripts, it's usually better to use the longer form of the command; this
    will make your scripts independent of the build system used.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中，通常最好使用命令的较长形式；这将使您的脚本独立于所使用的构建系统。
- en: Once your tests have passed, we can now think about providing them to a wider
    audience.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的测试通过了，现在我们可以考虑向更广泛的受众提供它们。
- en: Reusing quality code
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重用优质代码
- en: CMake has built-in utilities that can come a long way when it comes to distributing
    the results of your builds. This section will describe installing and exporting
    utilities and the differences between them. Later sections will show you how to
    package your code using CPack, and how to do it using Conan.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: CMake具有内置的实用程序，当涉及到分发构建结果时，这些实用程序可以走得更远。本节将描述安装和导出实用程序以及它们之间的区别。后续章节将向您展示如何使用CPack打包您的代码，以及如何使用Conan进行打包。
- en: Installing and exporting is not that important for microservices per se, but
    it's very useful if you're delivering libraries for others to reuse.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 安装和导出对于微服务本身并不那么重要，但如果您要为其他人提供库以供重用，这将非常有用。
- en: Installing
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装
- en: If you have written or used Makefiles, you've most probably invoked `make install`
    at one point and seen how the deliverables of a project were installed either
    in the OS directories or in another directory of your choosing. If you're using
    `make` with CMake, using the steps from this section will allow you to install
    the deliverables in the same way. If not, you'll still be able to call the install
    target, of course. Aside from that, in both cases, you will then have an easy
    way to leverage CPack for creating packages based on your installation commands.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您编写或使用过Makefiles，您很可能在某个时候调用了`make install`，并看到项目的交付成果被安装在操作系统目录或您选择的其他目录中。如果您正在使用`make`与CMake，使用本节的步骤将使您能够以相同的方式安装交付成果。如果没有，您仍然可以调用安装目标。除此之外，在这两种情况下，您将有一个简单的方法来利用CPack来创建基于您的安装命令的软件包。
- en: 'If you''re on Linux, it''s probably a good idea to preset some installation
    directories based on the conventions of the OS by calling the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Linux上，预设一些基于操作系统约定的安装目录可能是一个不错的主意，通过调用以下命令：
- en: '[PRE40]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This will make the installer use a directory structure made of `bin`, `lib`,
    and similar other directories. Such directories can be also set manually using
    a few CMake variables.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使安装程序使用由`bin`、`lib`和其他类似目录组成的目录结构。这些目录也可以使用一些CMake变量手动设置。
- en: 'Creating an install target consists of a few more steps. First and foremost
    is to define the targets we want to install, which in our case will be the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 创建安装目标包括一些更多的步骤。首先，首要的是定义我们要安装的目标，这在我们的情况下将是以下内容：
- en: '[PRE41]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This tells CMake to expose our library and executable defined earlier in this
    chapter as `CustomerTargets`, using the directories we set earlier.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉CMake使用我们在本章前面定义的库和可执行文件作为`CustomerTargets`公开，使用我们之前设置的目录。
- en: 'If you plan to install different configurations of your library to different
    folders, you could use a few invocations of the preceding command, like so:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划将您的库的不同配置安装到不同的文件夹中，您可以使用前面命令的几次调用，就像这样：
- en: '[PRE42]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can notice that we specify the directories for executables and libraries,
    but not for include files. We need to provide them in another command, like so:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以注意到我们为可执行文件和库指定了目录，但没有包含文件。我们需要在另一个命令中提供它们，就像这样：
- en: '[PRE43]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This means that the top-level include directory's contents will be installed
    in the include directory under the installation root. The slash after the first
    path fixes some path issues, so take note to use it.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着顶层包含目录的内容将被安装在安装根目录下的包含目录中。第一个路径后面的斜杠修复了一些路径问题，所以请注意使用它。
- en: 'So, we have our set of targets; now we need to generate a file that another
    CMake project could read to understand our targets. This can be done in the following
    way:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们有了一组目标；现在我们需要生成一个文件，另一个CMake项目可以读取以了解我们的目标。可以通过以下方式完成：
- en: '[PRE44]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This command takes our target set and creates a `CustomerTargets.cmake` file
    that will contain all the info about our targets and their requirements. Each
    of our targets will get prefixed with a namespace; for example, `customer` will
    become `domifair::customer`. The generated file will get installed in a subdirectory
    of the library folder in our installation tree.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将获取我们的目标集并创建一个`CustomerTargets.cmake`文件，其中将包含有关我们的目标及其要求的所有信息。我们的每个目标都将使用命名空间进行前缀处理；例如，`customer`将变成`domifair::customer`。生成的文件将安装在我们安装树中库文件夹的子目录中。
- en: To allow dependant projects to find our targets using CMake's `find_package`
    command, we need to provide a `CustomerConfig.cmake` file. If your target doesn't
    have any dependencies, you can just export the preceding targets directly to that
    file instead of the `targets` file. Otherwise, you should write your own config
    file that will include the preceding `targets` file.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许依赖项目使用CMake的`find_package`命令找到我们的目标，我们需要提供一个`CustomerConfig.cmake`文件。如果您的目标没有任何依赖项，您可以直接将前面的目标导出到该文件中，而不是`targets`文件。否则，您应该编写自己的配置文件，其中将包括前面的`targets`文件。
- en: 'In our case, we want to reuse some CMake variables, so we need to create a
    template and use the `configure_file` command to fill it in:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们想要重用一些CMake变量，因此我们需要创建一个模板，并使用`configure_file`命令来填充它：
- en: '[PRE45]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Our `CustomerConfig.cmake.in` file will begin by dealing with our dependencies:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`CustomerConfig.cmake.in`文件将首先处理我们的依赖项：
- en: '[PRE46]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `find_dependency` macro is a wrapper for `find_package` that is meant to
    be used in config files. Although we relied on Conan to provide us with the C++
    REST SDK 2.10.18 as defined in `conanfile.txt`, here we need to specify the dependency
    once more. Our package can be used on another machine, so we require that our
    dependency is installed there too. If you want to use Conan on the target machine,
    you can install the C++ REST SDK as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_dependency`宏是`find_package`的包装器，旨在在配置文件中使用。尽管我们依赖Conan在`conanfile.txt`中定义的C++
    REST SDK 2.10.18，但在这里我们需要再次指定依赖关系。我们的软件包可以在另一台机器上使用，因此我们要求我们的依赖项也在那里安装。如果您想在目标机器上使用Conan，可以按以下方式安装C++
    REST SDK：'
- en: '[PRE47]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'After dealing with the dependencies, our config file template will include
    the `targets` file that we created earlier:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 处理完依赖项后，我们的配置文件模板将包括我们之前创建的`targets`文件：
- en: '[PRE48]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: When `configure_file` executes, it will replace all those `@VARIABLES@` with
    the contents of their matching `${VARIABLES}` defined in our project. This way,
    based on our `CustomerConfig.cmake.in` file template, CMake will create a `CustomerConfig.cmake`
    file.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当`configure_file`执行时，它将用项目中定义的`${VARIABLES}`的内容替换所有这些`@VARIABLES@`。这样，基于我们的`CustomerConfig.cmake.in`文件模板，CMake将创建一个`CustomerConfig.cmake`文件。
- en: 'When finding a dependency using `find_package`, you''ll often want to specify
    a version of the package to find. To support that in our package, we must create
    a `CustomerConfigVersion.cmake` file. CMake offers us a helper function that will
    create this file for us. Let''s use it as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`find_package`查找依赖项时，通常需要指定要查找的软件包的版本。为了在我们的软件包中支持这一点，我们必须创建一个`CustomerConfigVersion.cmake`文件。CMake为我们提供了一个辅助函数，可以为我们创建此文件。让我们按照以下方式使用它：
- en: '[PRE49]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `PACKAGE_VERSION` variable will get populated according to the `VERSION`
    argument we passed when calling `project` at the top of our top-level `CMakeLists.txt`
    file.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`PACKAGE_VERSION`变量将根据我们在调用顶层`CMakeLists.txt`文件顶部的`project`时传递的`VERSION`参数进行填充。'
- en: '`AnyNewerVersion COMPATIBILITY` means our package will be accepted by any package
    search if it is newer or the same as the requested version. Other options include
    `SameMajorVersion`, `SameMinorVersion`, and `ExactVersion`.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnyNewerVersion COMPATIBILITY`表示如果我们的软件包比请求的版本更新或相同，它将被任何软件包搜索接受。其他选项包括`SameMajorVersion`，`SameMinorVersion`和`ExactVersion`。'
- en: 'Once we have created our config and config version files, let''s tell CMake
    that they should be installed along with the binaries and our target file:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了我们的配置和配置版本文件，让我们告诉CMake它们应该与二进制文件和我们的目标文件一起安装：
- en: '[PRE50]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'One last thing we should install is the license for our project. We''ll leverage
    CMake''s command for installing files to put them in our documentation directory:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该安装的最后一件事是我们项目的许可证。我们将利用CMake的安装文件的命令将它们放在我们的文档目录中：
- en: '[PRE51]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: That's all you need to know to successfully create an install target in the
    root of your OS. You may ask how to install the package into another directory,
    such as just for the current user. To do so, you would need to set the `CMAKE_INSTALL_PREFIX`
    variable, for example, when generating the build system.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您成功在操作系统根目录中创建安装目标所需了解的全部内容。您可能会问如何将软件包安装到另一个目录，比如仅供当前用户使用。要这样做，您需要设置`CMAKE_INSTALL_PREFIX`变量，例如，在生成构建系统时。
- en: Note that if we don't install into the root of our Unix tree, we'll have to
    provide the dependent project with a path to the installation directory, such
    as by setting `CMAKE_PREFIX_PATH`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果我们不安装到Unix树的根目录，我们将不得不为依赖项目提供安装目录的路径，例如通过设置`CMAKE_PREFIX_PATH`。
- en: Let's now look at yet another way you could reuse what you just built.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看另一种您可以重用刚刚构建的东西的方法。
- en: Exporting
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出
- en: Exporting is a technique to add information about a package that you built locally
    to CMake's package registry. This is useful when you want your targets to be visible
    right from their build directories, even without installation. A common use for
    exporting is when you have several projects checked out on your development machine
    and you build them locally.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 导出是一种将您在本地构建的软件包的信息添加到CMake的软件包注册表中的技术。当您希望您的目标可以直接从它们的构建目录中看到，即使没有安装时，这将非常有用。导出的常见用途是当您在开发机器上检出了几个项目并在本地构建它们时。
- en: 'It''s quite easy to add support for this mechanism from your `CMakeLists.txt`
    files. In our case, it can be done in this way:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 从您的`CMakeLists.txt`文件中添加对此机制的支持非常容易。在我们的情况下，可以这样做：
- en: '[PRE52]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This way, CMake will create a targets file similar to the one from the *Installing*
    section, defining our library and executable targets in the namespace we provided.
    From CMake 3.15, the package registry is disabled by default, so we need to enable
    it by setting the appropriate preceding variable. Then, we can put the information
    about our targets right into the registry by exporting our package.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，CMake将创建一个类似于*Installing*部分中的目标文件，定义我们在提供的命名空间中的库和可执行目标。从CMake 3.15开始，默认情况下禁用软件包注册表，因此我们需要通过设置适当的前置变量来启用它。然后，通过导出我们的软件包，我们可以将有关我们的目标的信息直接放入注册表中。
- en: 'Note that we now have a `targets` file without a matching config file. This
    means that if our targets depend on any external libraries, they must be found
    before our package is found. In our case, the calls must be ordered in the following
    way:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，现在我们有一个没有匹配配置文件的`targets`文件。这意味着如果我们的目标依赖于任何外部库，它们必须在我们的软件包被找到之前被找到。在我们的情况下，调用必须按照以下方式排序：
- en: '[PRE53]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: First, we find the C++ REST SDK, and only afterward do we look for our package
    that depends on it. That's all you need to know to start exporting your targets.
    Much easier than installing them, isn't it?
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们找到C++ REST SDK，然后再寻找依赖于它的软件包。这就是你需要知道的一切，就可以开始导出你的目标了。比安装它们要容易得多，不是吗？
- en: Let's now move on to a third way of exposing your targets to the external world.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续介绍第三种将您的目标暴露给外部世界的方法。
- en: Using CPack
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CPack
- en: In this section, we'll describe how to use CPack, the packaging tool that comes
    with CMake.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将描述如何使用CMake附带的打包工具CPack。
- en: CPack allows you to easily create packages in various formats, ranging from
    ZIP and TGZ archives through to DEB and RPM packages, and even installation wizards
    such as NSIS or a few OS X-specific ones. Once you have your installation logic
    in place, it's not hard to integrate the tool. Let's show how to use CPack to
    package our project.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: CPack允许您轻松创建各种格式的软件包，从ZIP和TGZ存档到DEB和RPM软件包，甚至安装向导，如NSIS或一些特定于OS X的软件包。一旦您安装逻辑就位，集成工具并不难。让我们展示如何使用CPack来打包我们的项目。
- en: 'First, we need to specify variables that CPack will use when creating the packages:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要指定CPack在创建软件包时将使用的变量：
- en: '[PRE54]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We need to give some information by hand, but some variables can be filled
    based on our project version specified when we defined our project. There are
    many more CPack variables and you can read about all of them in the CPack link
    in the *Further reading* section at the end of the chapter. Some of them are common
    for all package generators, while some are specific to a few of them. For instance,
    if you plan to use the installers, you could set the following two:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要手动提供一些信息，但是一些变量可以根据我们在定义项目时指定的项目版本来填充。CPack变量还有很多，您可以在本章末尾的*进一步阅读*部分的CPack链接中阅读所有这些变量。其中一些对所有软件包生成器都是通用的，而另一些则特定于其中的一些。例如，如果您计划使用安装程序，您可以设置以下两个：
- en: '`set(CPACK_RESOURCE_FILE_LICENSE "${PROJECT_SOURCE_DIR}/LICENSE")`'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`set(CPACK_RESOURCE_FILE_LICENSE "${PROJECT_SOURCE_DIR}/LICENSE")`'
- en: '`set(CPACK_RESOURCE_FILE_README "${PROJECT_SOURCE_DIR}/README.md")`'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`set(CPACK_RESOURCE_FILE_README "${PROJECT_SOURCE_DIR}/README.md")`'
- en: 'Once you''ve set all the interesting variables, it''s time to choose the generators
    for CPack to use. Let''s start with putting some basic ones in `CPACK_GENERATOR`,
    a variable CPack relies on:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您设置了所有有趣的变量，就该选择CPack要使用的生成器了。让我们从在`CPACK_GENERATOR`中放置一些基本的生成器开始，这是CPack依赖的一个变量：
- en: '`list(APPEND CPACK_GENERATOR TGZ ZIP)`'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`list(APPEND CPACK_GENERATOR TGZ ZIP)`'
- en: This will cause CPack to generate those two types of archives based on the installation
    steps we defined earlier in the chapter.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致CPack基于我们在本章前面定义的安装步骤生成这两种类型的存档。
- en: 'You can select different package generators based on many things, for example,
    the tools available on the machine you''re running on. An example would be to
    create Windows installers when building on Windows and a DEB or RPM package if
    building on Linux with the appropriate tools installed. For instance, if you''re
    running Linux, you could check whether `dpkg` is installed and if so, create DEB
    packages:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据许多因素选择不同的软件包生成器，例如，正在运行的机器上可用的工具。例如，在Windows上构建时创建Windows安装程序，在Linux上构建时使用适当的工具安装DEB或RPM软件包。例如，如果你正在运行Linux，你可以检查是否安装了`dpkg`，如果是，则创建DEB软件包：
- en: '[PRE55]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We used the `CPACK_DEBIAN_PACKAGE_DEPENDS` variable to make the DEB package
    require the C++ REST SDK to be installed first.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`CPACK_DEBIAN_PACKAGE_DEPENDS`变量，使DEB软件包要求首先安装C++ REST SDK。
- en: 'For RPM packages, you could manually check for `rpmbuild`:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 对于RPM软件包，您可以手动检查`rpmbuild`：
- en: '[PRE56]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Nifty, right?
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 很巧妙，对吧？
- en: These generators offer a plethora of other useful variables, so feel free to
    look at CMake's documentation if you need anything more than those basic needs
    described here.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这些生成器提供了大量其他有用的变量，所以如果您需要比这里描述的基本需求更多的东西，请随时查看CMake的文档。
- en: 'One last thing when it comes variables – you can also use them to avoid accidentally
    packaging undesired files. This can be done by using the following:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到变量时，最后一件事是，您也可以使用它们来避免意外打包不需要的文件。这可以通过以下方式完成：
- en: '`set(CPACK_SOURCE_IGNORE_FILES /.git /dist /.*build.* /\\\\.DS_Store)`'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`set(CPACK_SOURCE_IGNORE_FILES /.git /dist /.*build.* /\\\\.DS_Store)`'
- en: 'Once we have all that in place, we can include CPack itself from our CMake
    lists:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们把所有这些都放在位子上，我们可以从我们的CMake列表中包含CPack本身：
- en: '`include(CPack)`'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`include(CPack)`'
- en: Remember to always do this as the last step, as CMake won't propagate any variables
    you used later to CPack.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，始终将此作为最后一步进行，因为CMake不会将您稍后使用的任何变量传播给CPack。
- en: 'To run it, directly invoke either just `cpack` or the longer form that will
    also check whether anything needs rebuilding first: `cmake --build . --target
    package`. You can easily override the generators if you just need to rebuild one
    type of package using the `-G` flag, for example, `-G DEB` to build just the DEB
    package, `-G WIX -C Release` to pack a release MSI executable, or `-G DragNDrop`
    to obtain a DMG installer.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行它，直接调用`cpack`或更长的形式，它还会检查是否需要首先重新构建任何内容：`cmake --build . --target package`。您可以轻松地通过`-G`标志覆盖生成器，例如，`-G
    DEB`只需构建DEB软件包，`-G WIX -C Release`打包一个发布的MSI可执行文件，或`-G DragNDrop`获取DMG安装程序。
- en: Let's now discuss a more barbaric way of building packages.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论一种更原始的构建软件包的方法。
- en: Packaging using Conan
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Conan打包
- en: We already showed how to install our dependencies using Conan. Now, let's dive
    into creating our own Conan packages.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了如何使用Conan安装我们的依赖项。现在，让我们深入了解如何创建我们自己的Conan软件包。
- en: 'Let''s create a new top-level directory in our project, simply named `conan`,
    where we will store the files needed for packaging using this tool: a script for
    building our package and an environment to test it.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的项目中创建一个新的顶级目录，简单地命名为`conan`，在那里我们将使用这个工具打包所需的文件：一个用于构建我们的软件包的脚本和一个用于测试的环境。
- en: Creating the conanfile.py script
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建conanfile.py脚本
- en: 'The most important file required for all Conan packages is `conanfile.py`.
    In our case, we''ll want to fill in some of its details using CMake variables,
    so let''s create a `conanfile.py.in` file instead. We''ll use it to create the
    former file by adding the following to our `CMakeLists.txt` files:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Conan软件包所需的最重要的文件是`conanfile.py`。在我们的情况下，我们将使用CMake变量填写一些细节，所以我们将创建一个`conanfile.py.in`文件。我们将使用它来通过将以下内容添加到我们的`CMakeLists.txt`文件来创建前一个文件：
- en: '[PRE57]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Our file will begin with some boring Python imports, such as those required
    by Conan for CMake projects:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的文件将以一些无聊的Python导入开始，例如Conan对于CMake项目所需的导入：
- en: '[PRE58]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now we need to create a class that defines our package:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建一个定义我们软件包的类：
- en: '[PRE59]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'First, we start with a bunch of generic variables, taking the project version
    from our CMake code. Usually, the description will be a multi-line string. The
    topics are useful for finding our library on sites such as JFrog''s Artifactory
    and can tell the readers what our package is about. Let''s now go through other
    variables:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从我们的CMake代码中获取一堆通用变量。通常，描述将是一个多行字符串。主题对于在JFrog的Artifactory等网站上找到我们的库非常有用，并且可以告诉读者我们的软件包是关于什么的。现在让我们浏览其他变量：
- en: '[PRE60]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`homepage` should point to, well, the home page of your project: where the
    docs, tutorials, FAQs, and similar stuff are placed. The `url` one, on the other
    hand, is where the package repository is placed. Many open source libraries have
    their code in one repo and the packaging code in another. A common case is when
    the package is being built by the central Conan package server. In this case,
    `url` should point to `https://github.com/conan-io/conan-center-index`.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`homepage`应该指向项目的主页：文档、教程、常见问题解答等内容的所在地。另一方面，`url`是软件包存储库的位置。许多开源库将其代码放在一个存储库中，将打包代码放在另一个存储库中。一个常见情况是软件包由中央Conan软件包服务器构建。在这种情况下，`url`应该指向`https://github.com/conan-io/conan-center-index`。'
- en: 'Going forward, we can now specify how our package is being built:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们现在可以指定我们的软件包是如何构建的：
- en: '[PRE61]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '`settings` will determine whether the package needs to be built or an already-built
    version can be downloaded.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`settings`将确定软件包是否需要构建，还是可以下载已构建的版本。'
- en: '`options` and the `default_options` values can be whatever you like. `shared`
    and `fPIC` are the two that most packages provide, so let''s follow this convention.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`options`和`default_options`的值可以是任何你喜欢的。`shared`和`fPIC`是大多数软件包提供的两个选项，所以让我们遵循这个约定。'
- en: 'Now that we have defined our variables, let''s start writing methods that Conan
    will use to package our software. First, we specify our libraries that consumers
    of our package should link against:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的变量，让我们开始编写Conan将用于打包我们软件的方法。首先，我们指定我们的库，消费我们软件包的人应该链接到：
- en: '[PRE62]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `self.cpp_info` object allows setting much more than that, but this is the
    bare minimum. Feel free to take a look at other properties in Conan's documentation.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.cpp_info`对象允许设置更多内容，但这是最低限度。请随意查看Conan文档中的其他属性。'
- en: 'Next, let''s specify what other packages requires:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们指定其他需要的软件包：
- en: '[PRE63]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This time, we grab the C++ REST SDK directly from Conan instead of specifying
    what packages the OS''s package manager should depend on. Now, let''s specify
    how (and where) CMake should generate our build system:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们直接从Conan中获取C++ REST SDK，而不是指定OS的软件包管理器应该依赖哪些软件包。现在，让我们指定CMake应该如何（以及在哪里）生成我们的构建系统：
- en: '[PRE64]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In our case, we simply point it to the source directory. Once the build system
    is configured, we will need to actually build our project:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们只需将其指向源目录。一旦配置了构建系统，我们将需要实际构建我们的项目：
- en: '[PRE65]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Conan also supports non-CMake-based build systems. After building our package,
    it''s packaging time, which requires us to provide yet another method:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: Conan还支持非基于CMake的构建系统。构建我们的软件包之后，就是打包时间，这需要我们提供另一种方法：
- en: '[PRE66]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Note how we''re using the same `_configure_cmake()` function to both build
    and package our project. Aside from installing binaries, we also specify where
    the licenses should be deployed. Finally, let''s tell Conan what it should copy
    when installing our package:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在使用相同的`_configure_cmake()`函数来构建和打包我们的项目。除了安装二进制文件之外，我们还指定许可证应该部署的位置。最后，让我们告诉Conan在安装我们的软件包时应该复制什么：
- en: '[PRE67]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The preceding code specifies where to unpack the license files, as well as libraries,
    and executables when installing the library.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码指定了在安装库时解压许可文件、库和可执行文件的位置。
- en: Now that we know how to build a Conan package, let's also see how to test whether
    it works as desired.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何构建一个Conan软件包，让我们也看看如何测试它是否按预期工作。
- en: Testing our Conan package
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试我们的Conan软件包
- en: Once Conan builds our package, it should test whether it was properly built.
    In order to do so, let's start by creating a `test_package` subdirectory in our
    `conan` directory.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Conan构建我们的包，它应该测试它是否被正确构建。为了做到这一点，让我们首先在我们的`conan`目录中创建一个`test_package`子目录。
- en: 'It will also contain a `conanfile.py` script, but this time a shorter one.
    It should start as follows:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 它还将包含一个`conanfile.py`脚本，但这次是一个更短的脚本。它应该从以下内容开始：
- en: '[PRE68]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Nothing too fancy here. Now, we should provide the logic to build the test
    package:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多花哨的东西。现在，我们应该提供构建测试包的逻辑：
- en: '[PRE70]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We''ll write our `CMakeLists.txt` file in a sec. But first, let''s write two
    more things: the `imports` method and the `test` method. The `imports` method
    can be written as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一秒钟内编写我们的`CMakeLists.txt`文件。但首先，让我们写两件事：`imports`方法和`test`方法。`imports`方法可以编写如下：
- en: '[PRE71]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Then we have the heart of our package testing logic – the `test` method:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有我们的包测试逻辑的核心 - `test`方法：
- en: '[PRE72]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We want to run it only if we're building for our native architecture. Otherwise,
    we would most probably be unable to run the compiled executable.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只希望在为本机架构构建时运行它。否则，我们很可能无法运行已编译的可执行文件。
- en: 'Let''s now define our `CMakeLists.txt` file:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义我们的`CMakeLists.txt`文件：
- en: '[PRE73]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Simple as that. We link to all the Conan libraries provided (in our case, just
    our Customer library).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么简单。我们链接到所有提供的Conan库（在我们的情况下，只有我们的Customer库）。
- en: 'Finally, let''s write our `example.cpp` file with just enough logic to check
    whether the package was successfully created:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们编写我们的`example.cpp`文件，其中包含足够的逻辑来检查包是否成功创建：
- en: '[PRE74]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Before we start running all this, there are a few small changes that we need
    to make in our main tree of CMake lists. Let's now see how to export Conan targets
    from our CMake file properly.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始运行所有这些之前，我们需要在我们的CMake列表的主树中进行一些小的更改。现在让我们看看如何正确从我们的CMake文件中导出Conan目标。
- en: Adding Conan packaging code to our CMakeLists
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Conan打包代码添加到我们的CMakeLists
- en: 'Remember that installation logic we wrote in the *Reusing quality code* section?
    If you''re relying on Conan for packaging, you probably don''t need to run the
    bare CMake exporting and installation logic. Assuming you want to only export
    and install if Conan is not used, you need to modify the section of your `CMakeLists`
    described in the *Installing* subsection previously to look similar to this:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在*重用优质代码*部分编写的安装逻辑吗？如果您依赖Conan进行打包，您可能不需要运行裸的CMake导出和安装逻辑。假设您只想在不使用Conan时导出和安装，您需要修改您的`CMakeLists`中的*安装*子部分，使其类似于以下内容：
- en: '[PRE75]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Adding an if statement and a generator expression is a reasonable price for
    having clean packages, and that's all we needed to do.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 添加if语句和生成器表达式是为了获得干净的包，这就是我们需要做的一切。
- en: 'One last thing to make our lives easier – a target that we could **build**
    in order to create the Conan package. We can define it as follows:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事是让我们的生活变得更轻松 - 一个我们可以**构建**以创建Conan包的目标。我们可以定义如下：
- en: '[PRE76]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Now, when we run `cmake --build . --target conan` (or `ninja conan` if we're
    using that generator and want a short invocation), CMake will copy our `test_package`
    directory to the `build` folder, build our Conan package, and test it using the
    copied files.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行`cmake --build . --target conan`（或者如果我们使用该生成器并且想要一个简短的调用，则为`ninja conan`），CMake将把我们的`test_package`目录复制到`build`文件夹中，构建我们的Conan包，并使用复制的文件进行测试。
- en: All done!
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 全部完成！
- en: 'One last remark: what we described here is just the tip of the iceberg when
    it comes to creating Conan packages. For more information, please refer to Conan''s
    documentation. You can find a link in the *Further reading* section.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这是冰山一角，关于创建Conan包的更多信息，请参考Conan的文档。您可以在*进一步阅读*部分找到链接。
- en: Summary
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you've learned a lot about building and packaging your code.
    You're now able to write faster-building template code, know how to choose the
    tools to compile your code faster (you'll learn more about tooling in the next
    chapter), and know when to use forward declarations instead of `#include` directives.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学到了很多关于构建和打包代码的知识。您现在能够编写更快构建的模板代码，知道如何选择工具来更快地编译代码（您将在下一章中了解更多关于工具的知识），并知道何时使用前向声明而不是`#include`指令。
- en: Aside from that, you can now define your build targets and test suites using
    Modern CMake, manage external dependencies using find modules and `FetchContent`,
    create packages and installers in various formats, and last but not least, use
    Conan to install your dependencies and create your own artifacts.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，您现在可以使用现代CMake定义构建目标和测试套件，使用查找模块和`FetchContent`管理外部依赖项，以各种格式创建包和安装程序，最重要的是，使用Conan安装依赖项并创建自己的构件。
- en: In the next chapter, we will look at how to write code that would be easy to
    test. Continuous integration and continuous deployment are useful only if you
    have good test coverage. Continuous deployment without comprehensive testing will
    allow you to introduce new bugs to production much quicker. This is not our goal
    when we design software architecture.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看如何编写易于测试的代码。持续集成和持续部署只有在有很好的测试覆盖率时才有用。没有全面测试的持续部署将使您更快地向生产中引入新的错误。当我们设计软件架构时，这不是我们的目标。
- en: Questions
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What's the difference between installing and exporting your targets in CMake?
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在CMake中安装和导出目标有什么区别？
- en: How do you make your template code compile faster?
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使您的模板代码编译更快？
- en: How do you use multiple compilers with Conan?
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在Conan中使用多个编译器？
- en: What do you do if you'd like to compile your Conan dependencies with the pre-C++11
    GCC ABI?
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想使用预C++11 GCC ABI编译您的Conan依赖项，该怎么办？
- en: How to ensure we force a specific C++ standard in CMake?
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何确保在CMake中强制使用特定的C++标准？
- en: How would you build documentation in CMake and ship it along with your RPM package?
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在CMake中构建文档并将其与您的RPM包一起发布？
- en: Further reading
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'List of compiler books on GCC''s wiki: [https://gcc.gnu.org/wiki/ListOfCompilerBooks](https://gcc.gnu.org/wiki/ListOfCompilerBooks)'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCC维基上的编译器书籍列表：[https://gcc.gnu.org/wiki/ListOfCompilerBooks](https://gcc.gnu.org/wiki/ListOfCompilerBooks)
- en: '*Type Based Template Metaprogramming is Not Dead*, a lecture by Odin Holmes,
    C++Now 2017: [https://www.youtube.com/watch?v=EtU4RDCCsiU](https://www.youtube.com/watch?v=EtU4RDCCsiU)'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于类型的模板元编程并没有消亡，Odin Holmes在C++Now 2017上的演讲：[https://www.youtube.com/watch?v=EtU4RDCCsiU](https://www.youtube.com/watch?v=EtU4RDCCsiU)
- en: 'The Modern CMake online book: [https://cliutils.gitlab.io/modern-cmake](https://cliutils.gitlab.io/modern-cmake)'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代CMake在线书籍：[https://cliutils.gitlab.io/modern-cmake](https://cliutils.gitlab.io/modern-cmake)
- en: 'Conan documentation: [https://docs.conan.io/en/latest/](https://docs.conan.io/en/latest/)'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Conan文档：[https://docs.conan.io/en/latest/](https://docs.conan.io/en/latest/)
- en: 'CMake documentation on creating find scripts: [https://cmake.org/cmake/help/v3.17/manual/cmake-developer.7.html?highlight=find#a-sample-find-module](https://cmake.org/cmake/help/v3.17/manual/cmake-developer.7.html?highlight=find#a-sample-find-module)'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake关于创建查找脚本的文档：[https://cmake.org/cmake/help/v3.17/manual/cmake-developer.7.html?highlight=find#a-sample-find-module](https://cmake.org/cmake/help/v3.17/manual/cmake-developer.7.html?highlight=find#a-sample-find-module)
