- en: Reducing Power Consumption
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 降低功耗
- en: There are many applications for embedded systems that require them to be battery
    powered. From small **IoT **(short for **internet of things**) devices collecting
    data from sensors, pushing it into the cloud for processing, to autonomous vehicles
    and robots—these systems should be as power efficient as possible so that they
    can operate for a long time without a steady external power supply.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统有许多应用需要它们以电池供电。从小型**IoT**（**物联网**的缩写）设备收集传感器数据，将其推送到云端进行处理，到自主车辆和机器人 -
    这些系统应尽可能节能，以便它们可以在没有稳定外部电源供应的情况下长时间运行。
- en: Power efficiency means the smart control of the power consumption of all parts
    of a system, from the peripheral devices to the memory and the processor. The
    efficiency of power control depends significantly on the choice of hardware components
    and the system design. If a processor does not support dynamic voltage control
    or a peripheral device cannot enter power-saving mode when idle, then not much
    can be done on the software side. If, however, hardware components implement standard
    specifications, such as an **advanced configuration and power interface** (**ACPI**),
    then a lot of the burden of power management can be offloaded to the operating
    system kernel.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 功率效率意味着智能控制系统的所有部分的功耗，从外围设备到内存和处理器。功率控制的效率在很大程度上取决于硬件组件的选择和系统设计。如果处理器不支持动态电压控制或外围设备在空闲时无法进入节能模式，那么在软件方面就无法做太多。然而，如果硬件组件实现了标准规范，例如**高级配置和电源接口**（**ACPI**），那么很多功耗管理的负担可以转移到操作系统内核。
- en: In this chapter, we will explore different power-saving modes of modern hardware
    platforms and how they can be utilized. We will learn how to manage the power
    state of external devices and reduce the power consumption of processors by writing
    more efficient software.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索现代硬件平台的不同节能模式以及如何利用它们。我们将学习如何管理外部设备的电源状态，并通过编写更高效的软件来减少处理器的功耗。
- en: 'We will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Exploring power-saving modes in Linux
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux中探索节能模式
- en: Waking up using **RTC** (short for **real-time clock**)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**RTC**（**实时时钟**的缩写）唤醒
- en: Controlling the autosuspend of USB devices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制USB设备的自动挂起
- en: Configuring CPU frequency
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置CPU频率
- en: Using events for waiting
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事件等待
- en: Profiling power consumption with PowerTOP
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PowerTOP对功耗进行分析
- en: The recipes from this chapter will help you efficiently utilize the power-saving
    capabilities of modern operating systems and write code that is optimized for
    battery-powered devices.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的配方将帮助您有效利用现代操作系统的节能功能，并编写针对电池供电设备进行优化的代码。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For running code examples in this chapter, you need to have a Raspberry PI box
    revision 3 or above.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本章中运行代码示例，您需要具有树莓派PI盒子修订版3或更高版本。
- en: Exploring power-saving modes in Linux
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Linux中探索节能模式
- en: When a system is in the idle state and does not have work to do, it can be put
    in a sleep state to save power. Similar to human sleep, it cannot do anything
    until it is woken up by external event, for example an alarm clock.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统处于空闲状态且没有工作要做时，可以将其置于睡眠状态以节省电源。类似于人类的睡眠，它在外部事件唤醒之前无法做任何事情，例如闹钟。
- en: Linux supports multiple sleep modes. The choice of sleep mode and the amount
    of power it can save depends on the hardware support and the time it takes to
    enter the mode and wake up from it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Linux支持多种睡眠模式。选择睡眠模式和它可以节省的功率取决于硬件支持以及进入该模式和从中唤醒所需的时间。
- en: 'The supported modes are as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的模式如下：
- en: '**Suspend-to-idle **(**S2I**): This is a light sleep mode that can be implemented
    purely in software and does not require any support from the hardware. The devices
    are put into low-power mode and time keeping is suspended to let the processor
    spend more time in a power-efficient idle state. A system is woken up by an interrupt
    from any of the peripheral devices.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**挂起到空闲**（**S2I**）：这是一种轻度睡眠模式，可以纯粹通过软件实现，不需要硬件支持。设备进入低功耗模式，时间保持暂停，以便处理器在节能空闲状态下花费更多时间。系统通过来自任何外围设备的中断唤醒。'
- en: '**Standby**: This is similar to S2I, but provides more power saving by taking
    all non boot CPUs offline. Interruption from some devices can wake the system
    up.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**待机**：这类似于S2I，但通过将所有非引导CPU脱机来提供更多的节能。某些设备的中断可以唤醒系统。'
- en: '**Suspend-to-RAM** (**STR** or **S3**): All components of the system (except
    memory), including CPUs, go into low-power mode. The system state is maintained
    in memory until it is woken up by an interrupt from a limited set of devices.
    This mode requires hardware support.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**挂起到RAM**（**STR**或**S3**）：系统的所有组件（除了内存），包括CPU，都进入低功耗模式。系统状态保持在内存中，直到被来自有限设备集的中断唤醒。此模式需要硬件支持。'
- en: '**Hibernation** or **suspend-to-disk**: This provides the greatest power saving,
    since all the system components can be powered off. When entering this state,
    a snapshot of the memory is taken and written to persistent storage (disk or flash).
    After that, the system can be turned off. As part of the boot process, on wake
    up, the saved snapshot is restored and the system resumes its work.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**休眠**或**挂起到磁盘**：这提供了最大的节能，因为所有系统组件都可以关闭电源。进入此状态时，会拍摄内存快照并写入持久存储（磁盘或闪存）。之后，系统可以关闭。作为引导过程的一部分，在唤醒时，恢复保存的快照并系统恢复其工作。'
- en: In this recipe, we will learn how to query the sleep modes supported on a particular
    system and how to switch to one of them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何查询特定系统支持的睡眠模式以及如何切换到其中之一。
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this recipe, we will use simple bash commands to access sleep modes supported
    by a Linux system running in **QEMU **(short for **quick emulator**).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用简单的bash命令来访问在**QEMU**（**快速仿真器**的缩写）中运行的Linux系统支持的睡眠模式。
- en: Run the Raspberry Pi QEMU as described in [Chapter 3](b89bff48-21be-4288-af10-de42f182d426.xhtml),* Working
    with Different Architectures*.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照[第3章](b89bff48-21be-4288-af10-de42f182d426.xhtml)中描述的步骤运行树莓派QEMU，*使用不同的架构*。
- en: Log in as user `pi`, using the password `raspberry`.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以用户`pi`登录，使用密码`raspberry`。
- en: 'Run `sudo` to gain root access:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`sudo`以获取root访问权限：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To get the list of supported sleep modes, run the following command:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取支持的睡眠模式列表，请运行以下命令：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now switch to one of the supported modes:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在切换到其中一个支持的模式：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The system goes to sleep, but we have not instructed it as to how to wake up.
    Close the QEMU window now.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统进入睡眠状态，但我们没有指示它如何唤醒。现在关闭QEMU窗口。
- en: How it works...
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Power management is part of the Linux kernel; that is why we cannot use a Docker
    container to work with it. Docker virtualization is lightweight and uses the kernel
    of the host operating system.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 电源管理是Linux内核的一部分；这就是为什么我们不能使用Docker容器来处理它。Docker虚拟化是轻量级的，并使用主机操作系统的内核。
- en: We cannot use the real Raspberry Pi board either, because it does not provide
    any sleep modes at all because of hardware limitations. QEMU, however, provides
    full virtualization, including power management in the kernel we use to emulate
    Raspberry Pi.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也不能使用真正的树莓派板，因为由于硬件限制，它根本不提供任何睡眠模式。然而，QEMU提供了完整的虚拟化，包括我们用来模拟树莓派的内核中的电源管理。
- en: 'Linux provides access to its power management functions through the sysfs interface.
    Applications can read and write text files in the `/sys/power` directory. Access
    to power-management functions is limited for the root user; that is why we need
    to get the root shell once we log into the system:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Linux通过sysfs接口提供对其电源管理功能的访问。应用程序可以读取和写入`/sys/power`目录中的文本文件。对于root用户，对电源管理功能的访问是受限的；这就是为什么我们需要在登录系统后获取root
    shell：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we can get the list of supported sleep modes. To do this, we read the `/sys/power/state`
    file:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以获取支持的睡眠模式列表。为此，我们读取`/sys/power/state`文件：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The file consists of a single line of text. Each word represents a sleep mode
    that is supported, with the modes separated by spaces. We can see that the QEMU
    kernel supports two modes: `freeze` and `mem`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件由一行文本组成。每个单词代表一个支持的睡眠模式，模式之间用空格分隔。我们可以看到QEMU内核支持两种模式：`freeze`和`mem`：
- en: '![](img/e12ba0b1-2558-41d6-83c6-8ad7026751c3.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e12ba0b1-2558-41d6-83c6-8ad7026751c3.png)'
- en: Freeze represents the S2I state we discussed in the preceding section. The meaning
    of `mem` is defined by the content of the `/sys/power/mem_sleep` file. In our
    system, it contains only `[s2idle]`, representing the same S2I state as `freeze`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Freeze代表我们在前一节中讨论的S2I状态。`mem`的含义由`/sys/power/mem_sleep`文件的内容定义。在我们的系统中，它只包含`[s2idle]`，代表与`freeze`相同的S2I状态。
- en: 'Let''s switch our emulator to `freeze` mode. We write the word `freeze` to
    `/sys/power/state`, and immediately the QEMU window turns black and frozen:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的模拟器切换到`freeze`模式。我们将单词`freeze`写入`/sys/power/state`，立即QEMU窗口变黑并冻结：
- en: '![](img/a3f7043f-286b-49d6-acc7-a05c553aa1dd.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f7043f-286b-49d6-acc7-a05c553aa1dd.png)'
- en: We were able to put the emulated Linux system to sleep, but cannot wake it up—there
    are no sources of interrupts that it can understand. We learned about different
    sleep modes and the kernel API to work with them. Based on the requirements of
    your embedded system, you can use these modes to reduce power consumption.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够让模拟的Linux系统进入睡眠状态，但无法唤醒它——没有它能理解的中断源。我们了解了不同的睡眠模式和内核API来处理它们。根据嵌入式系统的要求，您可以使用这些模式来降低功耗。
- en: There's more...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: More information about sleep modes can be found in the corresponding section
    of the *Linux Kernel Guide* at [https://www.kernel.org/doc/html/v4.19/admin-guide/pm/sleep-states.html](https://www.kernel.org/doc/html/v4.19/admin-guide/pm/sleep-states.html.).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有关睡眠模式的更多信息可以在*Linux内核指南*的相应部分中找到，网址为[https://www.kernel.org/doc/html/v4.19/admin-guide/pm/sleep-states.html](https://www.kernel.org/doc/html/v4.19/admin-guide/pm/sleep-states.html)。
- en: Waking up using RTC
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RTC唤醒
- en: In the preceding recipe, we were able to put our QEMU system to sleep but were
    not able to wake it up. We need a device that can send an interrupt to the system
    when most of its internal components are powered off.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们能够让我们的QEMU系统进入睡眠状态，但无法唤醒它。我们需要一个设备，当其大部分内部组件关闭电源时，可以向系统发送中断。
- en: The **RTC** (**Real-time clock)** is one such device. One of its functions is
    to keep the internal clock running when the system is off, and to do this, it
    has its own battery. RTC power consumption is similar to an electronic watch;
    it uses the same 3 V battery and can function on its power for years.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**RTC**（**实时时钟**）就是这样的设备之一。它的功能之一是在系统关闭时保持内部时钟运行，并且为此，它有自己的电池。RTC的功耗类似于电子手表；它使用相同的3V电池，并且可以在其自身的电源上工作多年。'
- en: RTC can work as an alarm clock, sending an interrupt to the CPU at a given time.
    This makes it an ideal device for waking up a system on schedule.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: RTC可以作为闹钟工作，在给定时间向CPU发送中断。这使得它成为按计划唤醒系统的理想设备。
- en: In this recipe, we will learn how to wake up a Linux system at a specific time
    using the built-in RTC.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何使用内置RTC在特定时间唤醒Linux系统。
- en: How to do it...
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we will set a wake-up time to 1 minute in advance and put the
    system to sleep:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将提前将系统的唤醒时间设置为1分钟，并将系统置于睡眠状态：
- en: Log in to any Linux system that has an RTC clock—any Linux laptop can work.
    Unfortunately, Raspberry Pi does not have an onboard RTC, and cannot be woken
    up without additional hardware.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到任何具有RTC时钟的Linux系统——任何Linux笔记本都可以。不幸的是，树莓派没有内置RTC，并且没有额外的硬件无法唤醒。
- en: 'Get root permissions using `sudo`:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`sudo`获取root权限：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Instruct RTC to wake up the system in `1` minute:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指示RTC在`1`分钟后唤醒系统：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Put the system to sleep:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将系统置于睡眠状态：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Wait for a minute. Your system will wake up.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待一分钟。您的系统将会唤醒。
- en: How it works...
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Like many other functions exposed by the Linux kernel, RTC can be accessed via
    sysfs interfaces. To set an alarm that will send a wake-up interrupt to the system,
    we need to write a **POSIX** (short for** Portable Operating System Interface**)
    timestamp to the `/sys/class/rtc/rtc0/wakealarm` file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与Linux内核提供的许多其他功能一样，RTC可以通过sysfs接口访问。为了设置一个将向系统发送唤醒中断的闹钟，我们需要向`/sys/class/rtc/rtc0/wakealarm`文件写入一个**POSIX**（**Portable
    Operating System Interface**的缩写）时间戳。
- en: The POSIX timestamp, which we discuss in more detail in [Chapter 11](78be8bb8-ddec-4412-9d1e-a5ae2ffec6b7.xhtml),
    *Time Points and Intervals*, is defined as the number of seconds elapsed since
    the Epoch, or 00:00 January 1, 1970.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第11章](78be8bb8-ddec-4412-9d1e-a5ae2ffec6b7.xhtml)中更详细地讨论的POSIX时间戳，定义为自纪元以来经过的秒数，即1970年1月1日00:00。
- en: Though we can write a program to read the current timestamp using the `time`
    function, add 60, and write the result to the `wakealarm` file, we can do this
    in one line using the Unix shell and the `date` command, which is available on
    any modern Unix system.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以编写一个程序，使用`time`函数读取当前时间戳，再加上60，并将结果写入`wakealarm`文件，但我们可以使用Unix shell和`date`命令在一行中完成这个操作，这在任何现代Unix系统上都可以实现。
- en: The date utility can not only format the current time using different formats,
    but it can also interpret dates and times in different formats.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: date实用程序不仅可以使用不同格式格式化当前时间，还可以解释不同格式的日期和时间。
- en: 'We instruct `date` to interpret the time string `+1 minute` and use the formatting
    pattern `%s` to output it as a POSIX timestamp. We redirect its standard output
    to the `wakealarm` file, effectively passing it to the RTC driver:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指示`date`解释时间字符串`+1 minute`，并使用格式化模式`%s`将其输出为POSIX时间戳。我们将其标准输出重定向到`wakealarm`文件，有效地传递给RTC驱动程序：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, knowing that in 60 seconds the alarm will go off, we can put the system
    to sleep. As in the previous recipe, we write the desired sleep mode to the `/sys/power/state`
    file:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，知道60秒后闹钟会响，我们可以让系统进入睡眠状态。与前一个教程一样，我们将所需的睡眠模式写入`/sys/power/state`文件：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The system goes to sleep. You will notice that the screen turns off. If you
    connected to the Linux box using **Secure Shell** (**SSH**), the command line
    freezes. However, in one minute it wakes up, the screen turns on, and the Terminal
    is responsive again.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 系统进入睡眠状态。您会注意到屏幕关闭了。如果您使用**Secure Shell**（**SSH**）连接到Linux框，命令行会冻结。然而，一分钟后它会醒来，屏幕会亮起，终端会再次响应。
- en: This technique is very efficient for tasks such as gathering data from sensors
    on a regular, infrequent basis, such as hourly or daily. The system spends most
    of the time powered off, waking up only to collect data and store it or send it
    to the cloud, and then it goes to sleep again.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术非常适合定期、不经常地从传感器收集数据，比如每小时或每天。系统大部分时间都处于关闭状态，只有在收集数据并存储或发送到云端时才会唤醒，然后再次进入睡眠状态。
- en: There's more...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: An alternative way to set RTC alarms is by using the `rtcwake` utility.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 设置RTC闹钟的另一种方法是使用`rtcwake`实用程序。
- en: Controlling the autosuspend of USB devices
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制USB设备的autosuspend
- en: Turning an external device off is one of the most efficient ways to save power.
    It is, however, not always easy to understand when a device can be turned off
    safely. Peripheral devices such as network cards or memory cards can perform internal
    data processing; otherwise, the caching and powering off of the device at an arbitrary
    point can cause data loss.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭外部设备是节省电力的最有效方法之一。然而，并不总是容易理解何时可以安全地关闭设备。外围设备，如网络卡或存储卡，可以执行内部数据处理；否则，在任意时间关闭设备的缓存和电源可能会导致数据丢失。
- en: To mitigate this problem, many external devices that are connected over the
    USB can switch themselves into low-power consumption mode when requested by the
    host. This way, they can perform all necessary steps to handle internal data safely
    before entering the suspended state.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了缓解这个问题，许多通过USB连接的外部设备在主机请求时可以将自己切换到低功耗模式。这样，它们可以在进入挂起状态之前执行处理内部数据的所有必要步骤。
- en: Since Linux provides access to peripheral devices only through its API, it knows
    when a device is in use by applications and kernel services. If a device is not
    in use for a certain amount of time, the power-management system within the Linux
    kernel can instruct the device to enter power-saving mode automatically—explicit
    requests from userspace applications are not needed. This feature is called **autosuspend**.
    The kernel, however, allows applications to control the device's idle time, after
    which  autosuspend kicks in.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Linux只能通过其API访问外围设备，它知道设备何时被应用程序和内核服务使用。如果设备在一定时间内没有被使用，Linux内核中的电源管理系统可以自动指示设备进入省电模式——不需要来自用户空间应用程序的显式请求。这个功能被称为**autosuspend**。然而，内核允许应用程序控制设备的空闲时间，之后autosuspend会生效。
- en: In this recipe, we will learn how to enable autosuspend and modify the autosuspend
    interval for a particular USB device.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将学习如何启用autosuspend并修改特定USB设备的autosuspend间隔。
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We are going to enable autosuspend and modify its autosuspend time for a USB
    device connected to your Linux box:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将启用autosuspend并修改连接到Linux框的USB设备的autosuspend时间：
- en: Log in to your Linux box (Raspberry Pi, Ubuntu, and Docker containers won't
    work).
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到您的Linux框（树莓派、Ubuntu和Docker容器不适用）。
- en: 'Switch to the root account:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到root账户：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Get the current `autosuspend` status for all USB devices that are connected:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取所有连接的USB设备的当前`autosuspend`状态：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Enable `autosuspend` for one of the devices:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为一个设备启用`autosuspend`：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Read the `autosuspend` interval for the device:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取设备的`autosuspend`间隔：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Modify the `autosuspend` interval:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`autosuspend`间隔：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Check the current power mode of the device:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查设备的当前电源模式：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The same operations can be programmed in C++ using the standard file API.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的操作可以使用标准文件API在C++中编程。
- en: How it works...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Linux exposes its power management API via the sysfs filesystem, which makes
    it possible to read the current status and modify the settings of any device using
    standard file read and write operations. As a result, we can use any programming
    language that supports basic file operations to control peripheral devices in
    Linux.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Linux通过sysfs文件系统公开其电源管理API，这使得可以通过标准文件读写操作读取当前状态并修改任何设备的设置成为可能。因此，我们可以使用支持基本文件操作的任何编程语言来控制Linux中的外围设备。
- en: To simplify our examples, we are going to use the Unix shell, but exactly the
    same logic can be programmed in C++ when necessary.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化我们的示例，我们将使用Unix shell，但在必要时完全相同的逻辑可以用C++编程。
- en: First, we check the `autosuspend` settings for all attached USB devices. In
    Linux, the parameters of each USB device are exposed as a directory under the `/sysfs/bus/usb/devices/`
    folder. Each device directory, in turn, has a set of files that represent the
    device parameters. All parameters related to power management are grouped in the
    `power` subdirectory.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查所有连接的USB设备的`autosuspend`设置。在Linux中，每个USB设备的参数都作为`/sysfs/bus/usb/devices/`文件夹下的目录公开。每个设备目录又有一组代表设备参数的文件。所有与电源管理相关的参数都分组在`power`子目录中。
- en: 'To read the status of `autosuspend`, we need to read the `control` file in
    the `power` directory of a device. Using Unix shell wildcard substitution, we
    can read this file for all USB devices:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取`autosuspend`的状态，我们需要读取设备的`power`目录中的`control`文件。使用Unix shell通配符替换，我们可以为所有USB设备读取此文件：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For each directory matching the wildcard, we display the full path of the control
    file and its content. The result depends on the devices that are connected and
    may look like the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于与通配符匹配的每个目录，我们显示控制文件的完整路径及其内容。结果取决于连接的设备，可能如下所示：
- en: '![](img/ad39f854-2adc-4c82-93d8-22a61a3718a6.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ad39f854-2adc-4c82-93d8-22a61a3718a6.png)'
- en: The reported status may either be autosuspend or `on`. If the status is reported
    as autosuspend, then the automatic power management is enabled; otherwise, the
    device is always kept on.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 报告的状态可能是autosuspend或`on`。如果状态报告为autosuspend，则自动电源管理已启用；否则，设备始终保持开启。
- en: In our case, devices `usb1`, `1-1.1`, and `1-1.2` are on. Let's modify the configuration
    of `1-1.2` to use autosuspend. To do it, we just write a string `_auto_` to the
    corresponding  `_control_`  file.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，设备`usb1`，`1-1.1`和`1-1.2`是开启的。让我们修改`1-1.2`的配置以使用自动挂起。为此，我们只需向相应的`_control_`文件中写入字符串`_auto_`。
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Running the read loop over all devices again shows that the `1-1.2` device
    is now in `autosuspend` mode:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行循环读取所有设备的操作显示，`1-1.2`设备现在处于`autosuspend`模式：
- en: '![](img/a67c2bca-1a51-47ae-a018-07121f050716.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a67c2bca-1a51-47ae-a018-07121f050716.png)'
- en: 'When is it going to be suspended? We can read this from the `autosuspend_delay_ms`
    file in the `power` subdirectory:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 它将在何时被挂起？我们可以从`power`子目录中的`autosuspend_delay_ms`文件中读取：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It shows that the device will be suspended after `2000` milliseconds of idleness:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示设备在空闲`2000`毫秒后将被挂起：
- en: '![](img/eca24651-a7e7-4029-9c0c-a9e827d52322.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eca24651-a7e7-4029-9c0c-a9e827d52322.png)'
- en: 'Let''s change it to `5` seconds. We write `5000` in the `autosuspend_delay_ms`
    file:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其更改为`5`秒。我们在`autosuspend_delay_ms`文件中写入`5000`：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Reading it again shows that the new value is accepted:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 再次读取它显示新值已被接受：
- en: '![](img/7b6ee3c8-c017-4d68-9df7-b5343e3bf17d.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b6ee3c8-c017-4d68-9df7-b5343e3bf17d.png)'
- en: 'Now let''s check the current power state of the device. We can read it from
    the `runtime_status` file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查设备的当前电源状态。我们可以从`runtime_status`文件中读取它：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The status is reported as `active`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 状态报告为`active`：
- en: '![](img/71e3495c-e054-41b5-bdf4-1265560fe78f.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71e3495c-e054-41b5-bdf4-1265560fe78f.png)'
- en: Please note that the kernel does not control the power state of devices directly;
    it only requests them to change the state. Even if a device is requested to switch
    into suspend mode, it may refuse to do it for various reasons—for example, it
    may not support the power-saving mode at all.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，内核不直接控制设备的电源状态；它只请求它们改变状态。即使请求设备切换到挂起模式，它也可能因为各种原因而拒绝这样做，例如，它可能根本不支持节能模式。
- en: Accessing the power-management setting of any device through the sysfs interface
    is a powerful way to tweak the power consumption of the embedded system running
    Linux OS.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过sysfs接口访问任何设备的电源管理设置是调整运行Linux OS的嵌入式系统的功耗的强大方式。
- en: There's more...
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There is no direct way to turn a USB device off immediately; however, in many
    cases, it can be done by writing `0` into the `autosuspend_delay_ms` file. A zero
    autosuspend interval is interpreted by the kernel as an immediate suspend request
    to the device.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 没有直接的方法立即关闭USB设备；但在许多情况下，可以通过向`autosuspend_delay_ms`文件中写入`0`来实现。内核将零的自动挂起间隔解释为对设备的立即挂起请求。
- en: More details on the USB power management in Linux can be found in the corresponding
    section of the Linux kernel documentation, available at [https://www.kernel.org/doc/html/v4.13/driver-api/usb/power-management.html](https://www.kernel.org/doc/html/v4.13/driver-api/usb/power-management.html)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，有关USB电源管理的更多细节可以在Linux内核文档的相应部分中找到，该文档可在[https://www.kernel.org/doc/html/v4.13/driver-api/usb/power-management.html](https://www.kernel.org/doc/html/v4.13/driver-api/usb/power-management.html)上找到。
- en: Configuring CPU frequency
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置CPU频率
- en: The CPU frequency is an important parameter of the system that determines its
    performance and its power consumption. The higher the frequency, the more instructions
    the CPU can perform per second. But it comes with a cost. Higher frequency implies
    a higher power consumption that, in turn, means more heat that needs to be dissipated
    to avoid the processor overheating.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: CPU频率是系统的重要参数，它决定了系统的性能和功耗。频率越高，CPU每秒可以执行的指令就越多。但这是有代价的。更高的频率意味着更高的功耗，反过来意味着需要散热更多的热量以避免处理器过热。
- en: Modern processors are able to use different operating frequencies depending
    on their load. For computationally intense tasks, they use their maximum frequency
    to achieve the maximum performance, but when the system is mostly idle, they switch
    to lower frequencies to reduce both the power consumption and thermal impact.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现代处理器能够根据负载使用不同的操作频率。对于计算密集型任务，它们使用最大频率以实现最大性能，但当系统大部分空闲时，它们会切换到较低的频率以减少功耗和热量影响。
- en: Proper frequency selection is managed by the operating system. In this recipe,
    we will learn how to set the CPU frequency range and select a frequency governor
    in Linux to fine-tune the CPU frequency to your needs.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 适当的频率选择由操作系统管理。在这个示例中，我们将学习如何在Linux中设置CPU频率范围并选择频率管理器，以微调CPU频率以满足您的需求。
- en: How to do it...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We are going to use simple shell commands to adjust the parameters of CPU frequency
    on a Raspberry PI box:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用简单的shell命令来调整树莓派盒子上的CPU频率参数：
- en: Log in to a Raspberry Pi or another nonvirtualized Linux system.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到树莓派或另一个非虚拟化的Linux系统。
- en: 'Switch to the root account:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到root帐户：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Get the current frequency of all CPU cores available in the system:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取系统中所有CPU核心的当前频率：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Get all of the frequencies supported by the CPU:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取CPU支持的所有频率：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Get the available CPU-frequency governors:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取可用的CPU频率管理器：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now let''s check which frequency governor is currently in use:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们检查当前使用的频率管理器是哪个：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Adjust the minimum frequency of the CPU to the highest supported:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将CPU的最小频率调整到最高支持的频率：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Display the current frequencies again to understand the effect:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次显示当前频率以了解效果：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Adjust the minimum frequency to the lowest supported:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将最小频率调整到最低支持的频率：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now let''s check how the CPU frequency depends on the governor in use. Select
    a `performance` governor and get the current frequency:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们检查CPU频率如何取决于所使用的管理器。选择`performance`管理器并获取当前频率：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Select the `powersave` governor and observe the result:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`powersave`管理器并观察结果：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can use a regular file API to implement the same logic in C++.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用常规文件API在C++中实现相同的逻辑。
- en: How it works...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Similar to USB power management, the CPU-frequency management system API is
    exposed via sysfs. We can read and modify its parameters as regular text files.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 与USB电源管理类似，CPU频率管理系统API通过sysfs公开。我们可以像常规文本文件一样读取和修改其参数。
- en: We can find all settings related to CPU cores under the `/sys/devices/system/cpu/`
    directory. Configuration parameters are grouped by CPU cores in subdirectories
    named after each code index, such as `cpu1`, `cpu2`, and so on.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`/sys/devices/system/cpu/`目录下找到与CPU核心相关的所有设置。配置参数按CPU核心分组在名为每个代码索引的子目录中，如`cpu1`，`cpu2`等。
- en: 'We are interested in several parameters related to CPU frequencies management
    that live in the `cpufreq` subdirectory of each core. Let''s read the current
    frequency of all available cores:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对与CPU频率管理相关的几个参数感兴趣，这些参数位于每个核心的`cpufreq`子目录中。让我们读取所有可用核心的当前频率：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can see that all cores have the same frequency, 600 MHz (the `cpufreq` subsystem
    uses KHz as a measurement unit for frequency):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到所有核心的频率都是相同的，为600 MHz（`cpufreq`子系统使用KHz作为频率的测量单位）：
- en: '![](img/6d9f305d-d3ca-47eb-8766-1b3fa5718836.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d9f305d-d3ca-47eb-8766-1b3fa5718836.png)'
- en: 'Next, we figure out all the frequencies supported by our CPU:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们弄清楚CPU支持的所有频率：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The ARM processor of Raspberry Pi 3 supports only two frequencies, 600 MHz
    and 1.2 GHz:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派3的ARM处理器仅支持两种频率，600 MHz和1.2 GHz：
- en: '![](img/dd10cdcb-aff0-4f3d-9b17-7416aac38365.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dd10cdcb-aff0-4f3d-9b17-7416aac38365.png)'
- en: 'We cannot set the desired frequency directly. Linux manages the CPU frequencies
    internally through a so-called **governor**, and only allows us to adjust two
    parameters:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法直接设置所需的频率。Linux通过所谓的**管理器**内部管理CPU频率，并且只允许我们调整两个参数：
- en: A range of frequencies available for the governor
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理器的频率范围
- en: The type of governor
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理器的类型
- en: Though this looks like a limitation, these two parameters give enough flexibility
    to implement fairly complex policies. Let's check how the modification of both
    of these parameters affects the CPU frequency.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这看起来像是一个限制，但这两个参数足够灵活，可以实现相当复杂的策略。让我们看看如何修改这两个参数如何影响CPU频率。
- en: 'First, let''s figure out which governors are supported and which is currently
    in use:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们弄清楚支持哪些管理器以及当前使用的是哪个：
- en: '![](img/52365c50-07d0-495b-942b-f45dc54dd619.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/52365c50-07d0-495b-942b-f45dc54dd619.png)'
- en: The current governor is `ondemand`*. *It adjusts the frequency based on the
    system load. At the moment, the Raspberry Pi board is pretty idle, and so it uses
    the lowest frequency, 600 MHz. But what if we make the lowest frequency equal
    to the highest frequency?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的管理器是`ondemand`。*它根据系统负载调整频率。目前，树莓派板卡相当空闲，因此使用最低频率600 MHz。但是如果我们将最低频率设置为最高频率呢？
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After we updated the `scaling_min_freq` parameter of one core, the frequency
    of all cores was changed to the maximum:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更新了一个核心的`scaling_min_freq`参数后，所有核心的频率都被更改为最大值：
- en: '![](img/ac1af6c9-2bce-4cfa-a881-8d99f9e5ebad.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac1af6c9-2bce-4cfa-a881-8d99f9e5ebad.png)'
- en: Since all four cores belong to the same CPU, we cannot change their frequencies
    independently; changing the frequency of one core affects all cores. We can, however,
    control the frequencies of separate CPUs independently.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 由于四个核心都属于同一个CPU，我们无法独立地改变它们的频率；改变一个核心的频率会影响所有核心。但是，我们可以独立地控制不同CPU的频率。
- en: 'Now we revert the minimum frequency back to 600 MHz and change the governor.
    Instead of the `ondemand` governor that adjusts the frequency, we selected the
    `performance` governor, aiming to deliver maximal performance unconditionally:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将最小频率恢复到600 MHz并更改管理器。我们选择了`performance`管理器，而不是调整频率的`ondemand`管理器，旨在无条件地提供最大性能：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It''s no surprise that it raised the frequency up to the maximum supported
    frequency:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，它将频率提高到最大支持的频率：
- en: '![](img/ac5ded8a-1be2-402d-9f5c-b475828d8ba9.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac5ded8a-1be2-402d-9f5c-b475828d8ba9.png)'
- en: 'On the other hand, the `powersave` governor aims to save as much power as possible
    as it always sticks to the lowest-supported frequency regardless of the load:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`powersave`调度程序旨在尽可能节省电量，因为它始终坚持使用最低支持的频率，而不考虑负载：
- en: '![](img/fc0f3d39-c055-4afe-b659-df0401954695.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc0f3d39-c055-4afe-b659-df0401954695.png)'
- en: As you can see, adjusting both the frequency ranges and the frequency governor
    allows you to flexibly fine-tune the frequency depending on the nature of the
    system and reduce the power consumed by the CPU.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，调整频率范围和频率调度程序可以灵活地调整频率，以便根据系统的性质减少CPU消耗的电量。
- en: There's more...
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Besides `ondemand`, `performance`, and `powersave`, there are other governors
    that provide even more flexible tuning of CPU frequency from userspace applications.
    You can find more details about the available governors and their properties in
    the corresponding section of Linux CPUFreq at [https://www.kernel.org/doc/Documentation/cpu-freq/governors.txt](https://www.kernel.org/doc/Documentation/cpu-freq/governors.txt)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`ondemand`、`performance`和`powersave`之外，还有其他调度程序可以提供更灵活的CPU频率调整，供用户空间应用程序使用。您可以在Linux
    CPUFreq的相应部分中找到有关可用调度程序及其属性的更多详细信息[https://www.kernel.org/doc/Documentation/cpu-freq/governors.txt](https://www.kernel.org/doc/Documentation/cpu-freq/governors.txt)
- en: Using events for waiting
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用事件进行等待
- en: Waiting is an extremely common pattern in software development. Applications
    have to wait for user input or for data to be ready for processing. Embedded programs
    communicate with peripheral devices and need to know when data can be read from
    the device and when the device is ready to accept data.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 等待是软件开发中极为常见的模式。应用程序必须等待用户输入或数据准备好进行处理。嵌入式程序与外围设备通信，需要知道何时可以从设备读取数据以及设备何时准备好接受数据。
- en: Often, developers use variations of the polling technique for waiting. They
    check a device-specific availability flag in a loop, and when it is set to true
    by the device, they proceed with reading or writing data.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，开发人员使用轮询技术的变体进行等待。他们在循环中检查设备特定的可用性标志，当设备将其设置为true时，他们继续读取或写入数据。
- en: Though this approach is easy to implement, it is inefficient from the perspective
    of power consumption. When a processor is constantly busy looping around a flag
    check, it cannot be put into a more power-efficient mode by the operating system
    power manager. Based on the load, the Linux `ondemand` frequency governor that
    we discussed earlier can even decide to increase the CPU frequency despite the
    fact that it is a wait in disguise. Additionally, polling requests may prevent
    the target device or the device bus from staying in power-saving mode until data
    is ready.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种方法易于实现，但从能耗的角度来看效率低下。当处理器不断忙于循环检查标志时，操作系统电源管理器无法将其置于更节能的模式中。根据负载，我们之前讨论的Linux
    `ondemand`频率调度程序甚至可以决定增加CPU频率，尽管这实际上是一种等待。此外，轮询请求可能会阻止目标设备或设备总线保持在节能模式，直到数据准备就绪。
- en: That is why instead of polling programs that care about energy efficiency, it
    should rely on interrupts and events generated by the operating system.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么对于关心能效的轮询程序，它应该依赖于操作系统生成的中断和事件。
- en: In this recipe, we will learn how to use the operating system events to wait
    for a specific USB device to be connected.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何使用操作系统事件来等待特定的USB设备连接。
- en: How to do it...
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We are going to create an application that can monitor USB devices and wait
    until a specific device appears:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个应用程序，可以监视USB设备并等待特定设备出现：
- en: In your working `~/test` directory create a subdirectory called `udev`.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的工作`~/test`目录中创建一个名为`udev`的子目录。
- en: Use your favorite text editor to create a `udev.cpp` file in the `udev` subdirectory.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器在`udev`子目录中创建一个名为`udev.cpp`的文件。
- en: 'Put the essential includes and the `namespace` definition into the `udev.cpp`
    file:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将必要的包含和`namespace`定义放入`udev.cpp`文件中：
- en: '[PRE35]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, let''s define the `Device` class:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义`Device`类：
- en: '[PRE36]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After that, add the definition of the `Monitor` class:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，添加`Monitor`类的定义：
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After `Device` and `Monitor` are defined in the `usb` namespace, add a simple `main` function that
    shows how to use them:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`usb`命名空间中定义了`Device`和`Monitor`之后，添加一个简单的`main`函数，展示如何使用它们：
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Create a `CMakeLists.txt` file containing the build rules for our program:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含我们程序构建规则的`CMakeLists.txt`文件：
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Copy the `udev` directory into your home directory on your Linux box using `ssh`.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ssh`将`udev`目录复制到您Linux系统上的家目录中。
- en: 'Log in to your Linux box, change the directory to `udev`, and build the program
    using `cmake`:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到您的Linux系统，将目录切换到`udev`，并使用`cmake`构建程序：
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You can now build and run the application.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以构建并运行应用程序。
- en: How it works...
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To get system notifications about events on USB devices, we are using a library
    called `libudev`. It provides only a plain C interface, and so we created simple
    C++ wrappers to make coding easier.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取有关USB设备事件的系统通知，我们使用了一个名为`libudev`的库。它只提供了一个简单的C接口，因此我们创建了简单的C++包装器来使编码更容易。
- en: 'For our wrapper classes, we declared a `namespace` named `usb`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的包装器类，我们声明了一个名为`usb`的`namespace`：
- en: '[PRE41]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: It contains two classes. The first class is `Device`, which gives us a C++ interface
    to a low-level `libudev` object called `udev_device`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含两个类。第一个类是`Device`，它为我们提供了一个C++接口，用于低级`libudev`对象`udev_device`。
- en: 'We defined a constructor that created an instance of `Device` from a `udev_device`
    pointer and a destructor to release the `udev_device`. Internally, `libudev` uses
    reference counting for its object, and so our destructor calls a function to decrease
    the reference count of the `udev_device`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个构造函数，从`udev_device`指针创建了一个`Device`实例，并定义了一个析构函数来释放`udev_device`。在内部，`libudev`使用引用计数来管理其对象，因此我们的析构函数调用一个函数来减少`udev_device`的引用计数：
- en: '[PRE42]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This way, we can copy the `Device` instances without memory or file descriptor
    leaks.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以复制`Device`实例而不会出现内存泄漏或文件描述符泄漏。
- en: 'Besides the constructors and the destructor, the `Device` class has only two
    methods: `action` and `attr`. The `action` method returns the most recent USB
    device action:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 除了构造函数和析构函数之外，`Device`类只有两个方法：`action`和`attr`。`action`方法返回最近的USB设备动作：
- en: '[PRE43]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `attr` method returns any sysfs attribute associated with the device:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`attr`方法返回与设备关联的任何sysfs属性：'
- en: '[PRE44]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `Monitor` class also has a constructor and a destructor, but we made it
    noncopyable by disabling the copy constructor:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`Monitor`类也有构造函数和析构函数，但我们通过禁用复制构造函数使其不可复制：'
- en: '[PRE45]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The constructor initializes the `libudev` instance using a static variable
    to ensure it is initialized only once:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数使用静态变量初始化`libudev`实例，以确保它只初始化一次：
- en: '[PRE46]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'It also sets up the monitoring filter and enables monitoring:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 它还设置了监视过滤器并启用了监视：
- en: '[PRE47]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `wait` method contains the most important monitoring logic. It accepts
    a function-like `process` object that is called each time an event is detected:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`wait`方法包含最重要的监视逻辑。它接受类似函数的`process`对象，每次检测到事件时都会调用它：'
- en: '[PRE48]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The function should return `true` if the event and the device it originates
    from are what we need; otherwise, it returns `false` to indicate that `wait` should
    keep working.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事件和它来自的设备是我们需要的，函数应返回`true`；否则，它返回`false`以指示`wait`应继续工作。
- en: 'Internally, the `wait` function creates a file descriptor that is used to deliver
    device events to the program:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`wait`函数创建一个文件描述符，用于将设备事件传递给程序：
- en: '[PRE49]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then it sets up the monitoring loop. Despite its name, the `poll` function does
    not check the status of devices constantly; it waits for events on the specified
    file descriptors. We pass `-1` as a timeout, indicating that we intend to wait
    for events forever:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它设置监视循环。尽管它的名称是`poll`函数，但它并不会不断检查设备的状态；它会等待指定文件描述符上的事件。我们传递`-1`作为超时，表示我们打算永远等待事件：
- en: '[PRE50]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `poll` function returns only in the case of an error or a new USB event.
    We handle an error condition by throwing an exception:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`poll`函数仅在出现错误或新的USB事件时返回。我们通过抛出异常来处理错误情况：'
- en: '[PRE51]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'For each event, we create a new instance of `Device` and pass it to the `process`.
    If `process` returns `true`, we exit the wait loop, returning the instance of
    `Device` to the caller:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个事件，我们创建一个`Device`的新实例，并将其传递给`process`。如果`process`返回`true`，我们退出等待循环，将`Device`的实例返回给调用者：
- en: '[PRE52]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s see how we can use these classes in our application. In the `main` function,
    we create an instance of `Monitor` and invoke its `wait` function. We use a lambda
    function to process each action:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在我们的应用程序中使用这些类。在`main`函数中，我们创建一个`Monitor`实例并调用其`wait`函数。我们使用lambda函数来处理每个动作：
- en: '[PRE53]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the lambda function, we print information about all of the events:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在lambda函数中，我们打印有关所有事件的信息：
- en: '[PRE54]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We also check for the specific action and device `id`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还检查特定的动作和设备`id`：
- en: '[PRE55]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Once found, we display information about its function and power requirements:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到，我们会显示有关其功能和功率需求的信息：
- en: '[PRE56]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Running this application initially does not produce any output:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最初运行此应用程序不会产生任何输出：
- en: '![](img/981bab41-7f4d-4a76-9bd0-5e55b1811789.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/981bab41-7f4d-4a76-9bd0-5e55b1811789.png)'
- en: 'However, once we insert a USB device (a USB microphone in my case), we can
    see the following output:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦我们插入USB设备（在我这里是USB麦克风），我们可以看到以下输出：
- en: '![](img/d8c72d62-873a-42ca-9486-e57804844157.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d8c72d62-873a-42ca-9486-e57804844157.png)'
- en: The application can wait for a specific USB device and handle it after it is
    connected. It does this without busy looping, relying on the information provided
    by the operating system. As a result, the application spends most of the time
    sleeping while the `poll` call is blocked by the operating system.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以等待特定的USB设备，并在连接后处理它。它可以在不忙碌循环的情况下完成，依靠操作系统提供的信息。因此，应用程序大部分时间都在睡眠，而`poll`调用被操作系统阻塞。
- en: There's more...
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are a number of C++ wrappers for `libudev`. You can use one of these or
    create your own using the code from the recipe as a starting point.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多`libudev`的C++包装器。您可以使用其中之一，或者使用本示例中的代码作为起点创建自己的包装器。
- en: Profiling power consumption with PowerTOP
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PowerTOP进行功耗分析
- en: In complex operating systems such as Linux that run multiple userspace and kernel
    space services and control many peripheral devices at once, it is not always easy
    to find components that can cause excessive power drain. Even when inefficiency
    is identified, fixing it may be difficult.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在像Linux这样运行多个用户空间和内核空间服务并同时控制许多外围设备的复杂操作系统中，要找到可能导致过多功耗的组件并不总是容易的。即使找到了效率低下的问题，修复它可能也很困难。
- en: One of the solutions is to use a power profiler tool, such as PowerTOP. It can
    diagnose issues with power consumption in a Linux system and allows the user to
    tweak system parameters that can save power.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个解决方案是使用功耗分析工具，如PowerTOP。它可以诊断Linux系统中的功耗问题，并允许用户调整可以节省功耗的系统参数。
- en: In this recipe, we will learn how to install and use PowerTOP on a Raspberry
    Pi system.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何在树莓派系统上安装和使用PowerTOP。
- en: How to do it...
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we will run PowerTOP in interactive mode and analyze its output:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将以交互模式运行PowerTOP并分析其输出：
- en: Log in to your Raspberry Pi system as user `pi`, using the password `raspberry`.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以`pi`用户身份登录到您的树莓派系统，使用密码`raspberry`。
- en: 'Run `sudo` to gain root access:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`sudo`以获得root访问权限：
- en: '[PRE57]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Install PowerTOP from the repository:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从存储库安装PowerTOP：
- en: '[PRE58]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Staying in a root shell, run PowerTOP:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持在root shell中，运行PowerTOP：
- en: '[PRE59]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The PowerTOP UI will show up in your Terminal. Use the *Tab* key to navigate
    between its screens.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: PowerTOP UI将显示在您的终端中。使用*Tab*键在其屏幕之间导航。
- en: How it works...
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'PowerTOP is a tool created by Intel to diagnose power issues in a Linux system.
    It is part of the Raspbian distribution and can be installed using the `apt-get`
    command:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: PowerTOP是由英特尔创建的用于诊断Linux系统中功耗问题的工具。它是Raspbian发行版的一部分，可以使用`apt-get`命令安装：
- en: '[PRE60]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'When we run it without parameters, it starts in an interactive mode and lists
    all of the processes and kernel tasks, ordered by their power usage and the frequency
    of the events they generate. As we discussed in the *Using events for waiting*
    recipe, the more often a program has to wake up the processor, the less energy
    efficient it is:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在没有参数的情况下运行它时，它会以交互模式启动，并按其功耗和它们生成事件的频率对所有进程和内核任务进行排序。正如我们在*使用事件进行等待*一节中讨论的那样，程序需要频繁唤醒处理器，它的能效就越低：
- en: '![](img/8f7a54ae-1a79-4f1f-91ce-152fbfd006a0.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f7a54ae-1a79-4f1f-91ce-152fbfd006a0.png)'
- en: 'Using the *Tab* key, we can switch to other reporting modes. For example, Device
    stats shows how much energy or CPU time the devices consume:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*Tab*键，我们可以切换到其他报告模式。例如，设备统计显示设备消耗了多少能量或CPU时间：
- en: '![](img/2e968743-e8ab-4fe5-a55b-b05a3742586c.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e968743-e8ab-4fe5-a55b-b05a3742586c.png)'
- en: 'Another interesting tab is Tunab. PowerTOP can check a number of settings that
    affect power consumption and flags those that are suboptimal:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的选项卡是Tunab。PowerTOP可以检查影响功耗的一些设置，并标记那些不够理想的设置：
- en: '![](img/3140c865-d15a-48e7-80de-28bd1c5857a5.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3140c865-d15a-48e7-80de-28bd1c5857a5.png)'
- en: 'As you can see, two of the USB devices are marked as `Bad` because they do
    not use autosuspend. By pressing the *Enter* key, PowerTOP enables autosuspend,
    displaying a command line that can be used from a script to make it permanent.
    After autosuspend is enabled, the tunable status changes to `Good`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，两个USB设备被标记为`Bad`，因为它们没有使用自动挂起。通过按下*Enter*键，PowerTOP启用了自动挂起，并显示了一个可以从脚本中使用以使其永久化的命令行。启用自动挂起后，可调状态变为`Good`：
- en: '![](img/866eb512-32b4-4ea7-a5bd-5f42106a267c.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/866eb512-32b4-4ea7-a5bd-5f42106a267c.png)'
- en: A number of system parameters can be tuned to save power. Sometimes they are
    obvious, like using autosuspend on USB devices. Sometimes they are not, such as
    using timeout on the kernel that is used to flush the file cache to disk. Using
    power diagnostic and optimization tools such as PowerTOP helps you to tune your
    system for maximum power efficiency.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 一些系统参数可以调整以节省电力。有时它们是显而易见的，比如在USB设备上使用自动挂起。有时它们不是，比如在用于将文件缓存刷新到磁盘的内核上使用超时。使用诊断和优化工具，如PowerTOP，可以帮助您调整系统以实现最大功耗效率。
- en: There's more...
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Besides its interactive mode, PowerTOP has other modes to help you optimize
    power use, such as calibration, workload, and auto-tune. More information about
    PowerTOP features, usage scenarios, and the interpretation of results can be found
    in the *PowerTOP User* *Guide* at [https://01.org/sites/default/files/page/powertop_users_guide_201412.pdf](https://01.org/sites/default/files/page/powertop_users_guide_201412.pdf).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 除了交互模式，PowerTOP还有其他模式可帮助您优化功耗，如校准、工作负载和自动调整。有关PowerTOP功能、使用场景和结果解释的更多信息，请参阅[https://01.org/sites/default/files/page/powertop_users_guide_201412.pdf](https://01.org/sites/default/files/page/powertop_users_guide_201412.pdf)中的*PowerTOP用户指南*。
