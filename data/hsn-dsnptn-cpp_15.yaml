- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Policy-Based Design
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于策略的设计
- en: Policy-based design is one of the most well-known C++ patterns. Since the introduction
    of the standard template library in 1998, few new ideas have been more influential
    on the way we design C++ programs than the invention of policy-based design.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 基于策略的设计是C++中最著名的模式之一。自从1998年引入标准模板库以来，很少有新的想法比基于策略的设计对C++程序设计方式的影响更大。
- en: A policy-based design is all about flexibility, extensibility, and customization.
    It is a way to design software that can evolve and can be adapted to the changing
    needs, some of which could not even be anticipated at the time when the initial
    design was conceived. A well-designed policy-based system can remain unchanged
    at the structural level for many years, and serve the changing needs and new requirements
    without compromise.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 基于策略的设计完全是关于灵活性、可扩展性和定制性。这是一种设计软件的方法，可以使软件能够进化，并能够适应不断变化的需求，其中一些需求在最初设计构思时甚至无法预见。一个设计良好的基于策略的系统可以在结构层面上多年保持不变，并在不妥协的情况下满足不断变化的需求和新要求。
- en: Unfortunately, it is also a way to build software that could do all of those
    things if only there was someone who could figure out how it works. The aim of
    this chapter is to teach you to design and understand the systems of the former
    kind while avoiding the excesses that lead to the disasters of the latter one.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这也是构建能够做所有这些事情（如果有人能弄清楚它是如何工作的）的软件的方法。本章的目标是教会你设计和理解前一种类型的系统，同时避免导致后一种类型灾难的过度行为。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Strategy pattern and policy-based design
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略模式和基于策略的设计
- en: Compile time policies in C++
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++中的编译时策略
- en: Implementations of policy-based classes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于策略的类的实现
- en: Guidelines for the use of policies
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略的使用指南
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The example code for this chapter can be found at the following GitHub link:
    [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP_Second_Edition/tree/master/Chapter15](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP_Second_Edition/tree/master/Chapter15).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可以在以下GitHub链接中找到：[https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP_Second_Edition/tree/master/Chapter15](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP_Second_Edition/tree/master/Chapter15)。
- en: Strategy pattern and policy-based design
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略模式和基于策略的设计
- en: The classic Strategy pattern is a behavioral design pattern that enables the
    runtime selection of a specific algorithm for a particular behavior, usually from
    a predefined family of algorithms. This pattern is also known as the *policy pattern*;
    the name predates its application to generic programming in C++. The aim of the
    Strategy pattern is to allow for more flexibility in the design.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的策略模式是一种行为设计模式，它允许在运行时选择特定行为的具体算法，通常是从预定义的算法族中选择。这种模式也被称为*策略模式*；其名称早于其在C++泛型编程中的应用。策略模式的目标是允许设计有更大的灵活性。
- en: Note
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the classic object-oriented Strategy pattern, the decision about which specific
    algorithm to use is deferred until runtime.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典的对象导向策略模式中，关于使用哪个具体算法的决定被推迟到运行时。
- en: As is the case with many classic patterns, the generic programming in C++ applies
    the same approach to algorithm selection at compile time - it allows for compile-time
    customization of specific aspects of the system behavior by selecting from a family
    of related, compatible algorithms. We will now learn the basics of implementing
    classes with policies in C++, then proceed to study more complex and varied approaches
    to policy-based design.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 就像许多经典模式一样，C++中的泛型编程在编译时算法选择上采用相同的方法 - 它允许通过从一系列相关、兼容的算法中选择来对系统行为的特定方面进行编译时定制。我们现在将学习如何在C++中实现具有策略的类的基础知识，然后继续研究更复杂和多样化的基于策略设计的方法。
- en: Foundations of policy-based design
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于策略设计的原理
- en: The Strategy pattern should be considered whenever we design a system that does
    certain operations, but the exact implementation of these operations is uncertain,
    varied, or can change after the system is implemented - in other words, when we
    know the answer to *what the system must do*, but not *how*. Similarly, the compile-time
    strategy (or a policy) is a way to implement a class that has a specific function
    (*what*), but there is more than one way to implement that function (*how*).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设计一个执行某些操作的系统，但具体操作的实施是不确定的、多样的或系统实施后可能发生变化时，应该考虑使用策略模式——换句话说，当我们知道系统必须做什么（*what
    the system must do*），但不知道如何做（*how*）时。同样，编译时策略（或策略）是实现一个具有特定功能（*what*）的类的方法，但实现该功能的方式不止一种（*how*）。
- en: Throughout this chapter, we will design a smart pointer class to illustrate
    different ways to use policies. A smart pointer has many other required and optional
    features besides policies, and we will not cover all of them - for a complete
    implementation of a smart pointer, you will be referred to such examples as the
    C++ standard smart pointers (`unique_ptr` and `shared_ptr`), Boost smart pointers,
    or the Loki smart pointer ([http://loki-lib.sourceforge.net/](http://loki-lib.sourceforge.net/)).
    The material presented in this chapter will help you to understand the choices
    made by the implementers of these libraries, as well as how to design their own
    policy-based classes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将设计一个智能指针类来展示如何使用策略。除了策略之外，智能指针还有许多其他必需和可选的功能，我们不会涵盖所有这些功能——对于智能指针的完整实现，你将被指引到诸如C++标准智能指针（`unique_ptr`和`shared_ptr`）、Boost智能指针或Loki智能指针（[http://loki-lib.sourceforge.net/](http://loki-lib.sourceforge.net/)）等示例。本章中介绍的材料将帮助你理解这些库的实现者所做的选择，以及如何设计自己的基于策略的类。
- en: 'A very minimal initial implementation of a smart pointer may look like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个智能指针的最小初始实现可能看起来像这样：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This pointer has a constructor from the raw pointer of the same type and the
    usual (for a pointer) operators, that is, `*` and `->`. The most interesting part
    here is the destructor - when the pointer is destroyed, it automatically deletes
    the object as well (it is not necessary to check the pointer for the `null` value
    before deleting it; the `operator delete` is required to accept a null pointer
    and do nothing). It follows, therefore, that the expected use of this smart pointer
    is as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此指针有一个从相同类型的原始指针构造函数和通常的（对于指针）操作符，即`*`和`->`。这里最有趣的部分是析构函数——当指针被销毁时，它将自动删除对象（在删除之前不需要检查指针的`null`值；`operator
    delete`需要接受一个空指针并执行无操作）。因此，这个智能指针的预期使用方式如下：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is a basic example of the RAII class. The RAII object - the smart pointer,
    in our case - owns the resource (the constructed object) and releases (deletes)
    it when the owning object itself is deleted. The common applications, which were
    considered in detail in [*Chapter 5*](B19262_05.xhtml#_idTextAnchor199), *A Comprehensive
    Look at RAII*, focus on ensuring that the object that was constructed in the scope
    is deleted when the program exits this scope, no matter how the latter is accomplished
    (for example, if an exception is thrown somewhere in the middle of the code, the
    RAII destructor guarantees that the object is destroyed).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个RAII类的基本示例。RAII对象——在我们的例子中是智能指针——拥有资源（已构造的对象）并在拥有对象本身被删除时释放（删除）它。在[*第5章*](B19262_05.xhtml#_idTextAnchor199)“全面审视RAII”中详细考虑的常见应用，重点是确保在程序退出此作用域时删除在作用域内构造的对象，无论后者是如何完成的（例如，如果在代码的中间某处抛出异常，RAII析构函数将保证对象被销毁）。
- en: 'Two more member functions of the smart pointer are noted, not for their implementation,
    but for their absence - the pointer is made non-copyable as both its copy constructor
    and the assignment operator are disabled. This detail, which is sometimes overlooked,
    is of crucial importance for any RAII class - since the destructor of the pointer
    deletes the owned object, there should never be two smart pointers that point
    to, and will attempt to delete, the same object. On the other hand, moving the
    pointer is a valid operation: it transfers the ownership from the old pointer
    to the new one. Move constructor is necessary for factory functions to work (at
    least prior to C++17).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 智能指针的两个更多成员函数被提及，不是它们的实现，而是它们的缺失——指针被设计为不可复制的，因为它的拷贝构造函数和赋值运算符都被禁用了。这个有时被忽视的细节对于任何RAII类至关重要——由于指针的析构函数会删除所拥有的对象，因此绝对不应该有两个智能指针指向并尝试删除同一个对象。另一方面，移动指针是一个有效的操作：它将所有权从旧指针转移到新指针。移动构造函数对于工厂函数的工作是必要的（至少在C++17之前）。
- en: The pointer we have here is functional, but the implementation is constraining.
    In particular, it can own and delete only an object that was constructed with
    the standard `operator new`, and only a single object. While it could capture
    a pointer that was obtained from a custom `operator new` or a pointer to an array
    of elements, it does not properly delete such objects.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里所拥有的指针是功能性的，但其实现是受限的。特别是，它只能拥有和删除使用标准 `operator new` 构造的对象，并且只能是一个对象。虽然它可以捕获从自定义
    `operator new` 获得的指针或指向元素数组的指针，但它并不能正确地删除这样的对象。
- en: We could implement a different smart pointer for objects that are created on
    a user-defined heap, and another one for objects that are created in client-managed
    memory, and so on, one for every type of object construction with its corresponding
    way of deletion. Most of the code for these pointers would be duplicated - they
    are all pointers, and the entire pointer-like API will have to be copied into
    every class. We can observe that all of these different classes are, fundamentally,
    of the same kind - the answer to the question *what is this type?* is always the
    same - *it’s a* *smart pointer*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为在用户定义的堆上创建的对象实现不同的智能指针，为在客户端管理的内存中创建的对象实现另一个智能指针，等等，为每种类型的对象构造及其相应的删除方式实现一个。这些指针的大部分代码都会重复——它们都是指针，整个指针-like
    API 将必须复制到每个类中。我们可以观察到，所有这些不同的类在本质上都是同一类——对于问题“这是什么类型？”的回答总是相同的——*它是一个* *智能指针*。
- en: 'The only difference is in how the deletion is implemented. This common intent
    with a difference in one particular aspect of the behavior suggests the use of
    the Strategy pattern. We can implement a more general smart pointer where the
    details of how to handle the deletion of the object are delegated to one of any
    number of deletion policies:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别在于删除的实现方式。这种在行为的一个特定方面有差异但意图相同的情况表明了使用策略模式。我们可以实现一个更通用的智能指针，其中处理对象删除的细节被委托给任何数量的删除策略之一：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The deletion policy is an additional template parameter, and an object of the
    type of the deletion policy is passed to the constructor of the smart pointer
    (by default, such an object is default-constructed). The deletion policy object
    is stored in the smart pointer and is used in its destructor to delete the object
    that’s being pointed to by the pointer.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 删除策略是一个额外的模板参数，并且将删除策略类型的对象传递给智能指针的构造函数（默认情况下，这样的对象是默认构造的）。删除策略对象存储在智能指针中，并在其析构函数中使用它来删除指针所指向的对象。
- en: 'Care must be taken when implementing copy and move constructors for such policy-based
    classes: it is very easy to forget that the policy also needs to be moved or copied
    to the new object. In our case, copying is disabled, but move operations are supported.
    They must move not just the pointer itself but also the policy object. We do this
    as we would any other class: by moving the object (moving pointers is more involved
    since they are built-in types, but all classes are assumed to handle their own
    move operations correctly or delete them). In the assignment operator, remember
    that the current object owned by the pointer must be deleted by the corresponding,
    i.e. old, policy; only then do we move the policy from the right-hand side of
    the assignment.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现基于策略的类的复制和移动构造函数时必须小心：很容易忘记策略也需要移动或复制到新对象中。在我们的例子中，复制被禁用，但移动操作是支持的。它们必须移动的不仅仅是指针本身，还有策略对象。我们像处理任何其他类一样做这件事：通过移动对象（移动指针更复杂，因为它们是内置类型，但所有类都假定能够正确处理自己的移动操作或删除它们）。在赋值运算符中，记住指针当前拥有的对象必须由相应的，即旧的策略删除；只有在这种情况下，我们才将策略从赋值运算符的右侧移动过来。
- en: 'The only requirement on the deletion policy type is that it should be callable
    - the policy is invoked, just like a function with one argument, and the pointer
    to the object that must be deleted. For example, the behavior of our original
    pointer that called `operator delete` on the object can be replicated with the
    following deletion policy:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于删除策略类型的要求只有一个，那就是它应该是可调用的——策略被调用，就像一个带有一个参数的函数，以及指向必须删除的对象的指针。例如，我们原始指针在对象上调用
    `operator delete` 的行为可以用以下删除策略来复制：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To use this policy, we must specify its type when constructing the smart pointer,
    and, optionally, pass an object of this type to the constructor, although in this
    case, the default constructed object will work fine:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此策略，我们必须在构造智能指针时指定其类型，并且可以选择性地将此类型的对象传递给构造函数，尽管在这种情况下，默认构造的对象将工作得很好：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In C++17, the **constructor template argument deduction (CTAD)** can usually
    deduce the template parameters:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++17 中，**构造模板参数推导（CTAD）** 通常可以推导出模板参数：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If the deletion policy does not match the object type, a syntax error will
    be reported for the invalid call to `operator()`. This is usually undesirable:
    the error message is not particularly friendly, and, in general, the requirements
    on the policy have to be inferred from the use of the policy throughout the template
    (our policy has only one requirement, but this is our first and simplest policy).
    A good practice for writing classes with policies is to verify and document all
    requirements on the policy explicitly and in one place. In C++20, this can be
    done with concepts:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果删除策略与对象类型不匹配，将报告无效调用 `operator()` 的语法错误。这通常是不希望的：错误消息并不特别友好，并且通常，对策略的要求必须从模板中策略的使用推断出来（我们的策略只有一个要求，但这是我们第一个也是最简单的策略）。为具有策略的类编写的好做法是明确并在一个地方验证和记录策略的所有要求。在
    C++20 中，可以使用概念来完成此操作：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Before C++20, we can accomplish the same result with compile-time asserts:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++20 之前，我们可以通过编译时断言来实现相同的结果：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Even in C++20, you may prefer the assert error messages. Both options accomplish
    the same goal: they verify that the policies meet all requirements and also express
    these requirements in a readable way and in one place in the code. It is up to
    you whether to include “movable” in these requirements: strictly speaking, the
    policy needs to be movable only if you need to move the smart pointer itself.
    It is reasonable to allow non-movable policies and require move operations only
    if they are needed.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在 C++20 中，你也可能更喜欢 assert 错误消息。这两个选项都实现了相同的目标：它们验证策略满足所有要求，并在代码的一个地方以可读的方式表达这些要求。是否在要求中包含“可移动”取决于你：严格来说，策略只需要是可移动的，如果你需要移动智能指针本身。允许非可移动策略并在需要时才要求移动操作是合理的。
- en: 'Other deletion policies are needed for objects that were allocated in different
    ways. For example, if an object is created on a user-given heap object whose interface
    includes the member functions `allocate()` and `deallocate()` to, respectively,
    allocate and free memory, we can use the following heap deletion policy:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以不同方式分配的对象，需要其他删除策略。例如，如果一个对象是在用户提供的包含 `allocate()` 和 `deallocate()` 成员函数的堆对象上创建的，分别用于分配和释放内存，我们可以使用以下堆删除策略：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'On the other hand, if an object is constructed in some memory that is managed
    separately by the caller, then only the destructor of the object needs to be called:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果一个对象是在由调用者单独管理的内存中构造的，那么只需要调用对象的析构函数：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We mentioned earlier that, because the policy is used as a callable entity,
    `deletion_policy_(p_)`, it can be of any type that can be called like a function.
    That includes the actual function:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，由于策略被用作可调用的实体，`deletion_policy_(p_)`，它可以任何可以像函数一样调用的类型。这包括实际的函数：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A template instantiation is also a function and can be used in the same way:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 模板实例化也是一个函数，可以以相同的方式使用：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Of all the possible deletion policies, one is often the most commonly used.
    In most programs, it will likely be deletion by the default `operator delete`
    function. If this is so, it makes sense to avoid specifying this one policy every
    time it’s used and make it the default:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有可能的删除策略中，其中一个通常是最常用的。在大多数程序中，它很可能会是默认的`operator delete`函数的删除。如果是这样，避免每次使用时都指定这个策略，并使其成为默认策略是有意义的：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, our policy-based smart pointer can be used in exactly the same way as
    the original version, with only one deletion option:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的基于策略的智能指针可以像原始版本一样使用，只需删除一个选项：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, the second template parameter is left to its default value, `DeleteByOperator<C>`,
    and a default constructed object of this type is passed to the constructor as
    the default second argument.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第二个模板参数被保留为其默认值，`DeleteByOperator<C>`，并将此类型的默认构造对象传递给构造函数作为默认的第二个参数。
- en: 'At this point, I must caution you against a subtle mistake that could be made
    when implementing such policy-based classes. Note that the policy object is captured
    in the constructor of the smart pointer by a `const` reference:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我必须警告你，在实现这样的基于策略的类时可能会犯的一个微妙错误。请注意，策略对象是通过`const`引用在智能指针的构造函数中被捕获的：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `const` reference here is important since a non-const reference cannot
    be bound to a temporary object (we will consider the r-value references later
    in this section). However, the policy is stored in the object itself by value,
    and, thus, a copy of the policy object must be made:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`const`引用很重要，因为非`const`引用不能绑定到临时对象（我们将在本节稍后考虑右值引用）。然而，策略是通过值存储在对象本身中的，因此必须制作策略对象的副本：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It may be tempting to avoid the copy and capture the policy by reference in
    the smart pointer as well:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会诱使人们避免复制，并在智能指针中通过引用捕获策略：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In some cases, this will even work, for example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这甚至可以工作，例如：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'However, it won’t work for the default way to create smart pointers or any
    other smart pointer that is initialized with a temporary policy object:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这对于默认创建智能指针或以临时策略对象初始化的任何其他智能指针都不会起作用：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This code will compile. Unfortunately, it is incorrect - the temporary `DeleteByOperator<C>`
    object is constructed just before the `SmartPtr` constructor is called, but is
    destroyed at the end of the statement. The reference inside the `SmartPtr` object
    is left dangling. At first glance, this should not surprise anyone - of course,
    the temporary object does not outlive the statement in which it was created -
    it is deleted at the closing semicolon at the latest. A reader who is more versed
    in subtle language details may ask - *doesn’t the standard specifically extend
    the lifetime of a temporary bound to a constant reference?* Indeed, it does; for
    example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以编译。不幸的是，它是错误的——临时`DeleteByOperator<C>`对象在调用`SmartPtr`构造函数之前被构造，但在语句结束时被销毁。`SmartPtr`对象内部的引用留成了悬垂引用。乍一看，这不应该让人感到惊讶——当然，临时对象不会比它被创建的语句活得久——它最晚在语句的闭合分号处被删除。一个对语言细节更熟悉的读者可能会问——*标准不是特别扩展了绑定到常量引用的临时对象的生存期吗？*
    确实如此；例如：
- en: '[PRE19]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this code fragment, the temporary object `C()` is not deleted at the end
    of the sentence, but only at the end of the lifetime of the reference to which
    it is bound. So, why didn’t the same trick work for our deletion policy object?
    The answer is, it sort of did - the temporary object that was created when the
    argument to the constructor was evaluated and bound to the `const` reference argument
    was not destroyed for the lifetime of that reference, which is the duration of
    the constructor call. Actually, it would not have been destroyed anyway - all
    temporary objects that are created during the evaluation of the function arguments
    are deleted at the end of the sentence containing the function call, that is,
    at the closing semicolon. The function, in our case, is the constructor of the
    object, and so the lifetime of the temporaries spans the entire call to the constructor.
    It does not, however, extend to the lifetime of the object - the `const` reference
    member of the object is not bound to the temporary object, but to the constructor
    parameter, which itself is a `const` reference.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，临时对象`C()`在句子的末尾没有被删除，而是在它所绑定引用的生命周期结束时才被删除。那么，为什么同样的技巧没有在我们的删除策略对象上起作用呢？答案是，它某种程度上是起作用的
    - 当构造函数的参数被评估并绑定到`const`引用参数时创建的临时对象，在其引用的生命周期内没有被销毁，这就是构造函数调用的持续时间。实际上，它本来就不会被销毁
    - 在函数参数评估过程中创建的所有临时对象都在包含函数调用的句子的末尾被删除，即关闭分号处。在我们的情况下，函数是对象的构造函数，因此临时对象的生命周期跨越了整个构造函数调用。然而，它并不扩展到对象的生命周期
    - 对象的`const`引用成员不是绑定到临时对象，而是绑定到构造函数参数，而构造函数参数本身也是一个`const`引用。
- en: The lifetime extension works only once - the reference bound to a temporary
    object extends its lifetime. Another reference that’s bound to the first one does
    nothing else and may be left dangling if the object is destroyed (the **address
    sanitizer** (**ASAN**) of GCC and CLANG helps to find such bugs). Therefore, if
    the policy object needs to be stored as a data member of the smart pointer, it
    has to be copied.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期扩展只能使用一次 - 将引用绑定到临时对象会延长其生命周期。另一个绑定到第一个引用的引用不会做任何事情，如果对象被销毁，它可能会留下悬挂引用（GCC和CLANG的**地址清理器**（**ASAN**）有助于找到这样的错误）。因此，如果策略对象需要作为智能指针的数据成员存储，它必须被复制。
- en: 'Usually, policy objects are small, and copying them is trivial. However, sometimes,
    a policy object may have a non-trivial internal state that is expensive to copy.
    You could also imagine a policy object that is non-copyable. In these cases, it
    may make sense to move the argument object into the data member object. This is
    easy to do if we declare an overload that is similar to a move constructor:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，策略对象很小，复制它们是微不足道的。然而，有时策略对象可能具有非平凡的内部状态，复制起来代价高昂。你也可以想象一个不可复制的策略对象。在这些情况下，将参数对象移动到数据成员对象中可能是有意义的。如果我们声明一个类似于移动构造函数的重载，这很容易做到：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we said, the policy objects are usually small, so copying them is rarely
    an issue. If you do need both constructors, make sure that only one has default
    arguments, so the call to a constructor with no arguments or with no policy argument
    is not ambiguous.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说的，策略对象通常很小，所以复制它们很少成为问题。如果你确实需要两个构造函数，请确保只有一个有默认参数，这样调用无参数或无策略参数的构造函数就不会产生歧义。
- en: We now have a smart pointer class that has been implemented once, but whose
    deletion implementation can be customized at compile time by specifying the deletion
    policy. We could even add a new deletion policy that did not exist at the time
    the class was designed, and it will work as long as it conforms to the same calling
    interface. Next, we will consider different ways to implement policy objects.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个已经实现一次的智能指针类，但其删除实现可以在编译时通过指定删除策略进行定制。我们甚至可以添加一个在类设计时不存在的新删除策略，只要它符合相同的调用接口，它就会正常工作。接下来，我们将考虑实现策略对象的不同方法。
- en: Implementation of policies
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略的实现
- en: In the previous section, we learned how to implement the simplest policy object.
    The policy can be of any type as long as it conforms to the interface convention,
    and is stored in the class as a data member. The policy object is most commonly
    generated by a template; however, it could be a regular, non-template, object
    that’s specific to a particular pointer type, or even a function. The use of the
    policy was limited to a specific behavioral aspect, such as the deletion of the
    object owned by the smart pointer.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何实现最简单的策略对象。只要策略符合接口约定，它可以是任何类型，并且作为数据成员存储在类中。策略对象最常见的是通过模板生成的；然而，它也可以是一个特定于特定指针类型的常规非模板对象，甚至是一个函数。策略的使用仅限于特定的行为方面，例如智能指针拥有的对象的删除。
- en: 'There are several ways in which such policies can be implemented and used.
    First of all, let’s review the declaration of a smart pointer with a deletion
    policy:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以实现和使用此类策略。首先，让我们回顾一下具有删除策略的智能指针的声明：
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, let’s look at how we can construct a smart pointer object:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们如何构造一个智能指针对象：
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'One disadvantage of this design jumps out at once - the type `C` is mentioned
    four times in the definition of the object `p` - it must be consistent in all
    four places, or the code will not compile. C++17 allows us to simplify the definition
    somewhat:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计的缺点立即显现出来——类型`C`在对象`p`的定义中提到了四次——它必须在所有四个地方保持一致，否则代码将无法编译。C++17允许我们稍微简化定义：
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, the constructor is used to deduce the parameters of the `class` template
    from the constructor arguments, in a manner similar to that of function templates.
    There are still two mentions of the type `C` that must be consistent.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，构造函数用于从构造函数参数推导出`class`模板的参数，方式类似于函数模板。仍然有两个关于类型`C`的提及必须保持一致。
- en: 'One alternative implementation that works for stateless policies as well as
    for policy objects whose internal state does not depend on the types of the primary
    template (in our case, the type `T` of the `SmartPtr` template) is to make the
    policy itself a non-template object but give it a template member function. For
    example, the `DeleteByOperator` policy is stateless (the object has no data members)
    and can be implemented without a class template:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一种适用于无状态策略以及内部状态不依赖于主模板类型（在我们的例子中，是`SmartPtr`模板的类型`T`）的策略对象实现方法是，将策略本身做成非模板对象，但给它一个模板成员函数。例如，`DeleteByOperator`策略是无状态的（该对象没有数据成员）并且可以不使用类模板来实现：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is a non-template object, so it does not need a type parameter. The member
    function template is instantiated on the type of object that needs to be deleted
    - the type is deduced by the compiler. Since the type of the policy object is
    always the same, we do not have to worry about specifying consistent types when
    creating the smart pointer object:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非模板对象，因此不需要类型参数。成员函数模板在需要删除的对象类型上实例化——类型由编译器推导。由于策略对象类型始终相同，我们不必担心在创建智能指针对象时指定一致的类型：
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This object can be used by our smart pointer as it is, with no changes to the
    `SmartPtr` template, although we may want to change the default template argument:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象可以直接用于我们的智能指针，无需对`SmartPtr`模板进行任何修改，尽管我们可能想要更改默认模板参数：
- en: '[PRE26]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'A more complex policy, such as the heap deletion policy, can still be implemented
    using this approach:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的策略，如堆删除策略，仍然可以使用这种方法实现：
- en: '[PRE27]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This policy has an internal state - the reference to the heap - but nothing
    in this policy object depends on the type `T` of the object we need to delete,
    except for the `operator()` member function. Therefore, the policy does not need
    to be parameterized by the object type.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此策略有一个内部状态——对堆的引用——但在此策略对象中，除了`operator()`成员函数外，没有任何内容依赖于我们需要删除的对象的类型`T`。因此，策略不需要通过对象类型进行参数化。
- en: Since the main template, `SmartPtr`, did not have to be changed when we converted
    our policies from class templates to non-template classes with template member
    functions, there is no reason why we cannot use both types of policies with the
    same class. Indeed, any of the template class policies from the previous subsection
    would still work, so we can have some deletion policies implemented as classes
    and others as class templates. The latter is useful when the policy has data members
    whose type depends on the object type of the smart pointer.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于主模板`SmartPtr`在将我们的策略从类模板转换为具有模板成员函数的非模板类时无需更改，因此我们没有理由不能使用相同类中的两种类型策略。实际上，前一小节中的任何模板类策略仍然有效，因此我们可以将一些删除策略实现为类，而将其他策略实现为类模板。后者在策略具有依赖于智能指针对象类型的成员数据类型时很有用。
- en: 'If the policies are implemented as class templates, we have to specify the
    correct type to instantiate the policy for use with each specific policy-based
    class. In many cases, this is a very repetitive process - the same type is used
    to parameterize the main template and its policies. We can get the compiler to
    do this job for us if we use the entire template and not its particular instantiation
    as a policy:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果策略作为类模板实现，我们必须指定正确的类型来实例化策略，以便与每个特定的基于策略的类一起使用。在许多情况下，这是一个非常重复的过程 - 相同的类型用于参数化主模板及其策略。如果我们使用整个模板而不是其特定的实例作为策略，我们可以让编译器为我们完成这项工作：
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Note the syntax for the second template parameter - `template <typename> class
    DeletionPolicy`. This is known as a *template template* parameter - the parameter
    of a template is itself a template. The `class` keyword is necessary in C++14
    and earlier; in C++17, it can be replaced with `typename`. To use this parameter,
    we need to instantiate it with some type; in our case, it is the main template
    type parameter `T`. This ensures the consistency of the object type in the primary
    smart pointer template and its policies, although the constructor argument still
    must be constructed with the correct type:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第二个模板参数的语法 - `template <typename> class DeletionPolicy`。这被称为*模板模板*参数 - 模板的参数本身也是一个模板。在C++14及之前版本中，`class`关键字是必要的；在C++17中，它可以被`typename`替换。要使用此参数，我们需要用某种类型实例化它；在我们的例子中，它是主模板类型参数`T`。这确保了在主要智能指针模板及其策略中的对象类型的一致性，尽管构造函数的参数仍然必须用正确的类型构造：
- en: '[PRE29]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Again, in C++17, the class template parameters can be deduced by the constructor;
    this works for template template parameters as well:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，在C++17中，类模板参数可以由构造函数推导；这也适用于模板模板参数：
- en: '[PRE30]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The template template parameters seem like an attractive alternative to the
    regular type parameters when the types are instantiated from a template anyway.
    Why don’t we always use them? First of all, as you can see, they are somewhat
    less flexible than template class parameters: they save typing in the common case
    when the policy is a template with the same first argument as the class itself,
    but they don’t work in any other case (the policy may be a non-template or a template
    that requires more than one argument). The other issue is that, as written, the
    template template parameter has one significant limitation - the number of template
    parameters has to match the specification precisely, including the default arguments.
    In other words, let’s say I have the following template:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型是从模板实例化时，模板模板参数似乎是一个吸引人的替代方案，为什么我们总是不使用它们呢？首先，正如你所见，它们在灵活性方面略逊于模板类参数：当策略是一个与类本身具有相同第一个参数的模板时，它们在常见情况下可以节省输入，但在任何其他情况下都不起作用（策略可能是一个非模板或需要多个参数的模板）。另一个问题是，按照目前的写法，模板模板参数有一个显著的限制
    - 模板参数的数量必须与指定完全匹配，包括默认参数。换句话说，假设我有以下模板：
- en: '[PRE31]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This template cannot be used as a parameter of the preceding smart pointer
    - it has two template parameters, while we only specified only one in the declaration
    of `SmartPtr` (a parameter with a default value is still a parameter). This limitation
    is easy to work around: all we have to do is define the template template parameter
    as a variadic template:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板不能用作先前智能指针的参数 - 它有两个模板参数，而我们在`SmartPtr`的声明中只指定了一个（具有默认值的参数仍然是一个参数）。这个限制很容易解决：我们只需要将模板模板参数定义为变长模板：
- en: '[PRE32]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now the deletion policy template can have any number of type parameters as long
    as they have default values (`DeletionPolicy<T>` is what we use in the `SmartPtr`
    and it has to compile). In contrast, we can use an instantiation of the `DeleteHeap`
    template for a smart pointer where the `DeletionPolicy` is a type parameter, not
    a template template parameter - we just need a class, and `DeleteHeap<int, MyHeap>`
    will do as good as any.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，删除策略模板可以有任何数量的类型参数，只要它们有默认值（`DeletionPolicy<T>`是我们用于`SmartPtr`的，它必须能编译）。相比之下，我们可以使用`DeleteHeap`模板的一个实例来为智能指针提供`DeletionPolicy`作为类型参数，而不是模板模板参数——我们只需要一个类，`DeleteHeap<int,
    MyHeap>`就能做得很好。
- en: So far, we have always captured the policy object as a data member of the policy-based
    class. This approach to integrating classes into a larger class is known as **composition**.
    There are other ways in which the primary template can get access to the customized
    behavior algorithms provided by the policies, which we will consider next.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们总是将策略对象捕获为基于策略的类的数据成员。将类集成到更大的类中的这种做法被称为**组合**。还有其他方法可以让主模板访问策略提供的定制行为算法，我们将在下一部分考虑。
- en: Use of policy objects
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略对象的使用
- en: 'All of our examples until now have stored the policy object as a data member
    of the class. This is generally the preferred way of storing the policies, but
    it has one significant downside - a data member always has a non-zero size. Consider
    our smart pointer with one of the deletion policies:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的所有示例都将策略对象存储为类的数据成员。这通常是存储策略的首选方式，但它有一个显著的缺点——数据成员总是有非零大小。考虑我们的具有某种删除策略的智能指针：
- en: '[PRE33]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Note that the policy object has no data members. However, the size of the object
    is not zero, but one byte (we can verify that by printing the value of `sizeof(DeleteByOperator<int>)`).
    This is necessary because every object in a C++ program must have a unique address:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，策略对象没有数据成员。然而，对象的大小不是零，而是1个字节（我们可以通过打印`sizeof(DeleteByOperator<int>)`的值来验证这一点）。这是必要的，因为C++程序中的每个对象都必须有一个唯一的地址：
- en: '[PRE34]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When two objects are laid out consecutively in memory, the difference between
    their addresses is the size of the first object (plus padding, if necessary).
    To prevent both the `d1` and `d2` objects from residing at the same address, the
    standard mandates that their size is at least one byte.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个对象在内存中连续布局时，它们地址之间的差异是第一个对象的大小（如果需要，加上填充）。为了防止`d1`和`d2`对象位于相同的地址，标准规定它们的大小至少为1个字节。
- en: When used as a data member of another class, an object will occupy at least
    as much space as its size requires, which in our case, is one byte. Assuming that
    the pointer takes 8 bytes, the entire object is, therefore, 9 bytes long. But
    the size of an object also has to be padded to the nearest value that meets the
    alignment requirements - if the address of the pointer has to be aligned on 8
    bytes, the object can be either 8 bytes or 16 bytes, but not in-between. So, adding
    an empty policy object to the class ends up changing its size from 8 bytes to
    16 bytes. This is purely a waste of memory and is often undesirable, especially
    for objects that are created in large numbers, such as pointers. It is not possible
    to coax the compiler into creating a data member of zero size; the standard forbids
    it. But there is another way in which policies can be used without the overhead.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当作为另一个类的数据成员使用时，一个对象将占用至少与其大小相等的空间，在我们的例子中，是1个字节。假设指针占用8个字节，因此整个对象长度为9个字节。但是，对象的大小也必须填充到满足对齐要求的最接近的值——如果指针的地址需要对齐到8个字节，对象可以是8个字节或16个字节，但不能介于两者之间。因此，向类中添加一个空的策略对象最终将其大小从8个字节增加到16个字节。这纯粹是内存的浪费，通常是不希望的，尤其是对于大量创建的对象，如指针。无法说服编译器创建零大小的数据成员；标准禁止这样做。但是，策略还可以以另一种方式使用，而不产生开销。
- en: 'The alternative to composition is inheritance - we can use the policy as a
    base class for the primary class:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 组合的替代方法是继承——我们可以将策略作为主类的基类：
- en: '[PRE35]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This approach relies on a particular optimization - if a base class is empty
    (has no non-static data members), it can be completely optimized out of the layout
    of the derived class. This is known as the `SmartPtr` class is only as large as
    necessary to hold its data members - in our case, 8 bytes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法依赖于特定的优化——如果一个基类为空（没有非静态数据成员），它可以完全从派生类的布局中优化掉。这被称为`SmartPtr`类的大小仅取决于其数据成员的必要大小——在我们的例子中，是8个字节。
- en: When using inheritance for policies, the choice must be made between public
    or private inheritance. Usually, the policies are used to provide an implementation
    for a particular aspect of behavior. Such inheritance for implementation is expressed
    through private inheritance. In some cases, a policy may be used to change the
    public interface of the class; in this case, public inheritance should be used.
    For the deletion policy, we are not changing the interface of the class - the
    smart pointer always deletes the object at the end of its life; the only question
    is how. Therefore, the deletion policy should use private inheritance.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用继承策略时，必须在公共继承或私有继承之间做出选择。通常，策略用于为行为的一个特定方面提供实现。这种实现继承通过私有继承来表示。在某些情况下，策略可能用于更改类的公共接口；在这种情况下，应使用公共继承。对于删除策略，我们没有更改类的接口
    - 智能指针在其生命周期结束时始终删除对象；唯一的问题是怎样做。因此，删除策略应使用私有继承。
- en: While the deletion policy using the `operator delete` is stateless, some policies
    have data members that must be preserved from the object given to the constructor.
    Therefore, in general, the base class policy should be initialized from the constructor
    argument by copying or moving it into the base class, similarly to the way we
    initialized the data members. The base classes are always initialized on the member
    initialization list before the data members of the derived class. Finally, the
    `base_type::function_name()` syntax can be used to call a member function of a
    base class; in our case, `DeletionPolicy::operator()(p_)`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用 `operator delete` 的删除策略是无状态的，但某些策略具有必须从构造函数中给出的对象中保留的数据成员。因此，通常，基类策略应通过复制或移动到基类中从构造函数参数初始化，类似于我们初始化数据成员的方式。基类总是在派生类的数据成员之前在成员初始化列表中初始化。最后，可以使用
    `base_type::function_name()` 语法来调用基类的成员函数；在我们的情况下，`DeletionPolicy::operator()(p_)`。
- en: Inheritance or composition are the two choices for integrating the policy class
    into the primary class. In general, the composition should be preferred, unless
    there is a reason to use inheritance. We have already seen one such reason - the
    empty base class optimization. Inheritance is also a necessary choice if we want
    to affect the public interface of the class.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 继承或组合是将策略类集成到主类中的两种选择。通常，应首选组合，除非有使用继承的理由。我们已经看到了这样一个理由 - 空基类优化。如果我们想影响类的公共接口，继承也是一个必要的选项。
- en: 'Our smart pointer is, so far, missing several important features that are commonly
    found in most smart pointer implementations. One such feature is the ability to
    release the pointer, that is, to prevent the automatic destruction of the object
    from taking place. This can be useful if, in some cases, the object is destroyed
    by some other means, or, alternatively, if the lifetime of the object needs to
    be extended and its ownership is passed to another resource-owning object. We
    can easily add this feature to our smart pointer:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们智能指针目前缺少一些在大多数智能指针实现中常见的重要功能。其中一个功能是释放指针的能力，即防止对象自动销毁。在某些情况下，如果对象通过其他方式销毁，或者如果需要延长对象的生存期并将其所有权传递给另一个拥有资源的对象，这可能很有用。我们可以轻松地将此功能添加到我们的智能指针中：
- en: '[PRE36]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we can call `p.release()` on our smart pointer, and the destructor will
    do nothing. We can hard-code the release feature into the pointer, but sometimes
    you may want to enforce the deletion as it is done in the pointer, with no release.
    This calls for making the release feature optional, controlled by another policy.
    We can add a `ReleasePolicy` template parameter to control whether the `release()`
    member function is present, but what should it do? We could, of course, move the
    implementation of `SmartPtr::release()` into the policy:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在我们的智能指针上调用 `p.release()`，析构函数将不会执行任何操作。我们可以将释放功能硬编码到指针中，但有时你可能希望强制执行与指针中相同的删除操作，而不进行释放。这需要使释放功能成为可选的，由另一个策略控制。我们可以添加一个
    `ReleasePolicy` 模板参数来控制 `release()` 成员函数是否存在，但它应该做什么呢？当然，我们可以将 `SmartPtr::release()`
    的实现移动到策略中：
- en: '[PRE37]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, the `SmartPtr` implementation only has to call `ReleasePolicy::release(p_)`
    to delegate the appropriate handling of `release()` to the policy. But what is
    the appropriate handling if we do not want to support the release functionality?
    Our no-release policy can simply do nothing, but this is misleading - the user
    has the expectation that, if `release()` was called, the object would not be destroyed.
    We could assert at runtime and terminate the program. This converts a logic error
    on the part of the programmer - trying to release a no-release smart pointer -
    into a runtime error. The best way would be for the `SmartPtr` class to not have
    the `release()` member function at all if it is not wanted. This way, the incorrect
    code would be impossible to compile. The only way to do this is to make the policy
    inject a new public member function into the public interface of the primary template.
    This can be accomplished using public inheritance:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`SmartPtr` 的实现只需要调用 `ReleasePolicy::release(p_)` 来将 `release()` 的适当处理委托给策略。但如果我们不希望支持释放功能，应该怎么处理呢？我们的无释放策略可以简单地什么都不做，但这会误导用户——用户期望如果调用了
    `release()`，对象就不会被销毁。我们可以在运行时断言并终止程序。这会将程序员逻辑错误——尝试释放一个无释放智能指针——转换为运行时错误。最好的方式是，如果不需要，`SmartPtr`
    类根本就不应该有 `release()` 成员函数。这样，错误的代码就无法编译。实现这一点的唯一方法是将策略注入到主要模板的公共接口中。这可以通过公共继承来完成：
- en: '[PRE38]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, if the release policy has a public member function called `release()`,
    then so does the `SmartPtr` class.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果释放策略有一个名为 `release()` 的公共成员函数，那么 `SmartPtr` 类也有。
- en: 'This solves the interface problem. Now, there is a small matter of implementation.
    The `release()` member function has now moved into the policy class, but it must
    operate on the data member `p_` of the parent class. One way to do this would
    be to pass a reference to this pointer from the derived class to the base policy
    class during construction. This is an ugly implementation - it wastes 8 bytes
    of memory to store a reference to a data member that is almost “right there,”
    which is stored in the derived class right next to the base class itself. A much
    better way is to cast from the base class to the correct derived class. Of course,
    for this to work, the base class needs to know what the correct derived class
    is. The solution to this problem is the **Curiously Recurring Template Pattern**
    (**CRTP**) that we studied in this book: the policy should be a template (so we
    will need a template template parameter) that is instantiated on the derived class
    type.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了接口问题。现在，只剩下实现的小问题。`release()` 成员函数现在已经移动到策略类中，但它必须操作父类的数据成员 `p_`。一种方法是在构造过程中从派生类传递这个指针的引用到基策略类。这是一个丑陋的实现——它浪费了
    8 个字节的内存来存储一个几乎“就在那里”的数据成员的引用，这个数据成员存储在派生类中，紧挨着基类本身。一个更好的方法是从基类转换到正确的派生类。当然，为了使这可行，基类需要知道正确的派生类是什么。这个问题的解决方案是我们在本书中研究的**奇特重复模板模式**（**CRTP**）：策略应该是一个模板（因此我们需要一个模板模板参数），它在派生类类型上实例化。
- en: 'This way, the `SmartPtr` class is both the derived class of the release policy
    and the template parameter of it:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`SmartPtr` 类既是释放策略的派生类，也是它的模板参数：
- en: '[PRE39]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that the `ReleasePolicy` template is specialized with the concrete instantiation
    of the `SmartPtr` template, including all its policies, and including the `ReleasePolicy`
    itself.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`ReleasePolicy` 模板被特化为 `SmartPtr` 模板的实际实例化，包括所有策略，以及 `ReleasePolicy` 本身。
- en: 'Now, the release policy knows the type of the derived class and can cast itself
    to that type. This case is always safe because the correct derived class is guaranteed
    by construction:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，释放策略知道派生类的类型，并且可以将其自身转换成那个类型。这个情况总是安全的，因为正确的派生类在构造时得到了保证：
- en: '[PRE40]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The template parameter `P` will be substituted with the type of the smart pointer.
    Once the smart pointer publicly inherits from the release policy, the public member
    function, `release()`, of the policy is inherited and becomes a part of the smart
    pointer public interface.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 模板参数 `P` 将被替换为智能指针的类型。一旦智能指针公开继承自释放策略，策略的公共成员函数 `release()` 就会被继承并成为智能指针公共接口的一部分。
- en: 'The last detail concerning the implementation of the release policy has to
    do with the access. As we’ve written so far, the data member `p_` is private in
    the `SmartPtr` class and cannot be accessed by its base classes directly. The
    solution to this is to declare the corresponding base class to be a friend of
    the derived class:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 关于释放策略实现的最后一个细节与访问有关。正如我们迄今为止所写的，数据成员`p_`在`SmartPtr`类中是私有的，并且其基类不能直接访问它。解决这个问题的方法是声明相应的基类为派生类的友元：
- en: '[PRE41]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note that inside the body of the `SmartPtr` class, we do not need to repeat
    all the template parameters. The shorthand `SmartPtr` refers to the currently
    instantiated template. This does not extend to the part of the class declaration
    before the opening brace of the class, so we had to repeat the template parameters
    when specifying the policy as a base class.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`SmartPtr`类的主体内部，我们不需要重复所有模板参数。简写`SmartPtr`指的是当前实例化的模板。这并不扩展到类声明中开括号之前的部分，因此当我们指定策略作为基类时，我们必须重复模板参数。
- en: 'The no-release policy is just as easy to write:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 无释放策略的编写同样简单：
- en: '[PRE42]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: There is no `release()` function here, so an attempt to call `release()` on
    a smart pointer with this policy will not compile. This solves our stated requirement
    to have a `release()` public member function only when it makes sense to call
    one. The policy-based design is a complex pattern, and it is rare to be limited
    to just one way to do something. There is another way to accomplish the same objective,
    we are going to study it later in this chapter, in the section, *Using policies
    to control the* *public interface*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有`release()`函数，所以尝试使用此策略调用智能指针上的`release()`将无法编译。这解决了我们提出的只在有调用意义时才需要`release()`公共成员函数的要求。基于策略的设计是一个复杂的模式，很少只限于一种做事的方式。还有另一种实现相同目标的方法，我们将在本章后面的部分，即在*使用策略控制*
    *公共接口*的节中，对其进行研究。
- en: There is yet another way in which policy objects can sometimes be used. This
    applies only to policies that have no internal state in any version of the policy,
    by design. For example, our deletion policies are sometimes stateless, but the
    one with the reference to the caller’s heap is not, so this is a policy that is
    not always stateless. The release policy can always be considered stateless; there
    is no reason for us to add a data member to it, but it is constrained to be used
    through public inheritance because its primary effect is to inject a new public
    member function.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 政策对象有时还可以以另一种方式使用。这仅适用于任何策略版本都没有内部状态的情况，这是设计上的要求。例如，我们的删除策略有时是无状态的，但引用调用者堆的那个不是，所以这是一个不一定是无状态的策略。释放策略始终可以被认为是无状态的；我们没有理由向其中添加数据成员，但它被限制通过公共继承来使用，因为它的主要效果是注入一个新的公共成员函数。
- en: 'Let’s consider another aspect of behavior that we may want to customize - debugging
    or logging. For debugging purposes, it may be convenient to print when an object
    is owned by a smart pointer and when it is deleted. We could add a debugging policy
    to the smart pointer to support this. The debug policy has to do only one thing,
    and that is to print something when a smart pointer is constructed or destroyed.
    It does not need access to the smart pointer if we pass the value of the pointer
    to the printing function. Therefore, we can make the print functions static in
    the debug policy and not store this policy in the smart pointer class at all:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个我们可能想要定制的方面——调试或日志记录。出于调试目的，当对象被智能指针拥有或被删除时打印信息可能很方便。我们可以在智能指针上添加一个调试策略来支持这一点。调试策略只需做一件事，那就是在智能指针构造或销毁时打印一些信息。如果我们将指针的值传递给打印函数，它不需要访问智能指针。因此，我们可以在调试策略中将打印函数声明为静态的，并且根本不需要在智能指针类中存储此策略：
- en: '[PRE43]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'For simplicity, we have omitted the release policy, but multiple policies are
    easy to combine. The debugging policy implementation is straightforward:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们省略了释放策略，但多个策略很容易组合。调试策略实现很简单：
- en: '[PRE44]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We have chosen to implement the policy as a non-template class with template
    static member functions. Alternatively, we could have implemented it as a template,
    parametrized with the object type `T`. The no-debug version of the policy, which
    is the default, is even simpler. It must have the same functions defined, but
    they don’t do anything:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择将策略实现为一个具有模板静态成员函数的非模板类。或者，我们也可以将其实现为一个模板，参数化对象类型`T`。策略的无调试版本，即默认版本，甚至更简单。它必须定义相同的函数，但它们什么都不做：
- en: '[PRE45]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We can expect the compiler to inline the empty template functions at the call
    site and optimize the entire call away since no code needs to be generated.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以期待编译器在调用位置内联空模板函数，并优化整个调用，因为不需要生成任何代码。
- en: Note that by choosing this implementation of policies, we made a somewhat restrictive
    design decision - all versions of the debug policy must be stateless. We may,
    in time, come to regret this decision if we need to, for example, store a custom
    output stream inside a debug policy, instead of the default `std::cout`. But even
    in that case, only the implementation of the smart pointer class will have to
    change - the client code will continue to work with no changes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通过选择这种政策的实现方式，我们做出了一些限制性的设计决策——所有版本的调试政策都必须是无状态的。如果我们需要，比如，在调试政策中存储自定义输出流而不是默认的`std::cout`，我们可能会后悔这个决定。但即使在这种情况下，也只有智能指针类的实现需要改变——客户端代码将继续工作而无需任何更改。
- en: We have considered three different ways to incorporate the policy objects into
    the policy-based class - by composition, by inheritance (public or private), and
    by compile-time incorporation only, where the policy object does not need to be
    stored inside the main object at runtime. We will now move on to more advanced
    techniques for policy-based design.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经考虑了三种将策略对象纳入基于策略类的方法——通过组合、通过继承（公开或私有），以及仅通过编译时结合，在这种情况下，策略对象在运行时不需要存储在主要对象中。我们现在将转向基于策略设计的更高级技术。
- en: Advanced policy-based design
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级策略设计
- en: The techniques we have introduced in the previous section form the foundation
    of policy-based design - policies can be classes, template instantiations, or
    templates (used by template template parameters). The policy classes can be composed,
    inherited, or used statically at compile time. If a policy needs to know the type
    of the primary policy-based class, the CRTP can be used. The rest is largely variations
    on the same theme, as well as tricky ways to combine several techniques to accomplish
    something new. We will now consider some of these more advanced techniques.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中介绍的技术构成了基于策略设计的基石——策略可以是类、模板实例化或模板（由模板模板参数使用）。策略类可以在编译时组合、继承或静态使用。如果一个策略需要知道主要基于策略的类的类型，可以使用CRTP。其余的都是在同一主题上的变体，以及巧妙地结合几种技术以实现新的功能。我们现在将考虑这些更高级的技术。
- en: Policies for constructors
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数政策
- en: Policies can be used to customize almost any aspect of the implementation, as
    well as to alter the class interface. However, there are unique challenges that
    arise when we attempt to customize class constructors using policies.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 政策可以用来定制实现几乎任何方面，以及改变类接口。然而，当我们尝试使用政策定制类构造函数时，会出现一些独特的挑战。
- en: 'As an example, let’s consider another limitation of our current smart pointer.
    As it stands so far, the object owned by the smart pointer is always deleted when
    the smart pointer is deleted. If the smart pointer supports release, then we can
    call the `release()` member function and be wholly responsible for the deletion
    of the object. But how are we going to ensure this deletion? The most likely way
    is, we will let another smart pointer own it:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑我们当前智能指针的另一个限制。到目前为止，智能指针拥有的对象总是在智能指针被删除时删除。如果智能指针支持释放，那么我们可以调用`release()`成员函数，并完全负责对象的删除。但我们如何确保这种删除呢？最可能的方式是，我们将让另一个智能指针拥有它：
- en: '[PRE46]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This approach is verbose and error-prone - we temporarily let two pointers own
    the same object. If something were to happen at this moment that causes both pointers
    to be deleted, we would destroy the same object twice. We also have to remember
    to always release one of these pointers, but only one. We should take the higher-level
    view of the problem - we are trying to pass the ownership of the object from one
    smart pointer to another.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法冗长且容易出错——我们暂时让两个指针拥有同一个对象。如果此时发生任何导致两个指针都被删除的情况，我们将两次销毁同一个对象。我们还必须记住始终只释放这些指针中的一个。我们应该从更高的角度看待这个问题——我们试图将对象的拥有权从第一个智能指针传递到另一个。
- en: 'The better way to do this is by moving the first pointer into the second:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事更好的方法是移动第一个指针到第二个：
- en: '[PRE47]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now, the first pointer is left in the moved-from state, which we can define
    (the only requirement is that the destructor call must be valid). We choose to
    define it to be a pointer that does not own any object, that is, a pointer in
    the released state. The second pointer receives the ownership of the object and
    will delete it in due time.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，第一个指针保留在移动前的状态，我们可以定义它（唯一的要求是析构函数调用必须是有效的）。我们选择将其定义为不拥有任何对象的指针，即处于释放状态的指针。第二个指针接收对象的所有权，并将适时删除它。
- en: 'To support this functionality, we must implement the move constructor. However,
    there may be a reason to sometimes prevent the transfer of ownership. Therefore,
    we may want to have both movable and non-movable pointers. This calls for yet
    another policy to control whether moving is supported:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这个功能，我们必须实现移动构造函数。然而，可能存在某些情况下我们希望阻止所有权的转移。因此，我们可能希望同时拥有可移动和不可移动的指针。这需要另一种策略来控制是否支持移动：
- en: '[PRE48]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'For simplicity, we have reverted to just one other policy - the deletion policy.
    The other policies we have considered can be added alongside the new `MovePolicy`.
    The deletion policy can be implemented in any of the ways we have learned already.
    Since it is likely to benefit from the empty base optimization, we will stay with
    the inheritance-based implementation for it. The move policy can be implemented
    in several different ways, but inheritance is probably the easiest:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们已回退到仅使用另一项政策——删除政策。我们考虑的其他政策可以与新的`MovePolicy`一起添加。删除政策可以通过我们已学到的任何一种方式实现。由于它可能从空基优化中受益，我们将继续使用基于继承的实现方式。移动策略可以通过几种不同的方式实现，但继承可能是最简单的方法：
- en: '[PRE49]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: With both policies integrated using private inheritance, we now have a derived
    object with several base classes. Such multiple inheritance is fairly common in
    policy-based design in C++, and should not alarm you. This technique is sometimes
    known as *mix-in* since the implementation of the derived class is *mixed* from
    the pieces provided by the base classes. In C++, the term *mix-in* is also used
    to refer to a totally different inheritance scheme that is related to the CRTP,
    so the use of this term often creates confusion (in most object-oriented languages,
    *mix-in* unambiguously refers to the application of multiple inheritance that
    we can see here).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用私有继承将两种策略集成，我们现在有一个具有多个基类的派生对象。在C++的基于策略的设计中，这种多重继承相当常见，不应让你感到惊讶。这种技术有时被称为*混入*，因为派生类的实现是从基类提供的部分中混合而成的。在C++中，*混入*这个术语也用来指代与CRTP相关的一种完全不同的继承方案，因此这个术语的使用常常造成混淆（在大多数面向对象的语言中，*混入*明确地指代我们在这里看到的多重继承应用）。
- en: 'The new feature in our smart pointer class is the move constructor. The move
    constructor is unconditionally present in the `SmartPtr` class. However, its implementation
    requires that all base classes be movable. This gives us a way to disable move
    support with a non-movable move policy:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们智能指针类的新特性是移动构造函数。移动构造函数在`SmartPtr`类中无条件存在。然而，它的实现要求所有基类都是可移动的。这为我们提供了一种通过不可移动的移动策略来禁用移动支持的方法：
- en: '[PRE50]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The movable policy is much simpler:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 可移动策略要简单得多：
- en: '[PRE51]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can now construct a movable pointer and a non-movable pointer:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以构造一个可移动指针和一个不可移动指针：
- en: '[PRE52]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: An attempt to move a non-movable pointer does not compile because one of the
    base classes, `MoveForbidden`, is non-movable (does not have a move constructor).
    Note that the moved-from pointer `p` in the preceding example can be safely deleted,
    but cannot be used in any other way. In particular, it cannot be dereferenced.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试移动一个不可移动指针无法编译，因为其中一个基类`MoveForbidden`是不可移动的（没有移动构造函数）。请注意，在先前的例子中，移动前的指针`p`可以安全地删除，但不能以任何其他方式使用。特别是，它不能被解引用。
- en: 'While we are dealing with movable pointers, it would make sense to provide
    a move assignment operator as well:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理可移动指针时，提供移动赋值运算符也是有意义的：
- en: '[PRE53]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note the check for the self-assignment. Unlike the copy assignment, which is
    required to do nothing for self-assignment, the move assignment is less constrained
    by the standard. The only certain requirement is that the self-move should always
    leave an object in a well-defined state (the moved-from state is an example of
    such a state). A no-op self-move is not required but is valid as well. Also, note
    the way in which the base classes are move-assigned - the easiest way is to invoke
    the move assignment operator of each base class directly. There is no need to
    cast the derived class `that` to each of the base types - this is an implicitly
    performed cast. We must not forget to set the moved-from pointer to `nullptr`,
    otherwise, the object owned by these pointers will be deleted twice.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意自我赋值的检查。与必须对自我赋值不执行任何操作的复制赋值不同，移动赋值受标准的约束较少。唯一确定的要求是自我移动应始终使对象处于一个良好定义的状态（已移动的状态是一个这样的状态）。不执行任何操作的自我移动不是必需的，但也是有效的。还要注意基类是如何进行移动赋值的——最简单的方法是直接调用每个基类的移动赋值运算符。没有必要将派生类`that`转换为每个基类型——这是一个隐式执行的转换。我们绝对不能忘记将已移动的指针设置为`nullptr`，否则，这些指针拥有的对象将被删除两次。
- en: For simplicity, we have ignored all of the policies we introduced earlier. This
    is fine – not all designs need everything to be controlled by a policy, and, in
    any case, it is quite straightforward to combine multiple policies. However, it
    is a good opportunity to point out that different policies are sometimes related
    - for example, if we use both a release policy and a move policy, the use of a
    movable move policy strongly suggests that the object must support release (a
    released pointer is similar to a moved-from pointer). Using template metaprogramming,
    we can force such dependence between the policies, if need be.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们忽略了之前引入的所有策略。这没问题——不是所有的设计都需要通过策略来控制所有内容，而且无论如何，组合多个策略都是非常直接的。然而，这是一个指出不同策略有时相关的好机会——例如，如果我们同时使用释放策略和移动策略，使用可移动的移动策略强烈暗示该对象必须支持释放（已释放的指针类似于已移动的指针）。如果需要，我们可以使用模板元编程来强制策略之间的这种依赖关系。
- en: 'Note that a policy that needs to disable or enable constructors does not automatically
    have to be used as a base class - move assignment or construction also moves all
    data members, and, therefore, a non-movable data member will disable the move
    operations just as well. The more important reason to use inheritance here is
    the empty base class optimization: if we introduced a `MovePolicy` data member
    into our class, it would double the object size from 8 to 16 bytes on a 64-bit
    machine.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一个需要禁用或启用构造函数的策略并不一定必须用作基类 - 移动赋值或构造函数也会移动所有数据成员，因此，一个不可移动的数据成员同样可以禁用移动操作。在这里使用继承的更重要原因是空基类优化：如果我们把一个`MovePolicy`数据成员引入我们的类中，它会在64位机器上将对象大小从8字节增加到16字节。
- en: We have considered making our pointers movable. But what about copying? So far,
    we have disallowed copying outright - both the copy constructor and the copy assignment
    operator are deleted in our smart pointer from the very beginning. This makes
    sense so far - we do not want to have two smart pointers own the same object and
    delete it twice. But there is another type of ownership where the copy operation
    makes perfect sense - the shared ownership, such as what’s implemented by a reference-counting
    shared pointer. With this type of pointer, copying the pointer is allowed, and
    both pointers now equally own the pointed-to object. A reference count is maintained
    to count how many pointers to the same object exist in the program. When the very
    last pointer owning a particular object is deleted, so is the object itself, since
    there are no more references to it.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们考虑过使我们的指针可移动。但复制呢？到目前为止，我们明确禁止了复制——在我们的智能指针中，从一开始就删除了复制构造函数和复制赋值运算符。这到目前为止是有意义的——我们不希望有两个智能指针拥有同一个对象并删除它两次。但还有一种所有权的类型，复制操作是完美的——这就是引用计数共享指针所实现的所有权。这种类型的指针允许复制指针，现在两个指针都平等地拥有指向的对象。维护一个引用计数来统计程序中指向同一对象的指针数量。当拥有特定对象的最后一个指针被删除时，该对象本身也会被删除，因为没有更多的引用指向它。
- en: 'There are several ways to implement a reference-counted shared pointer, but
    let’s start with the design of the class and its policies. We still need a deletion
    policy, and it makes sense to have a single policy control the move and copy operations.
    For simplicity, we will again limit ourselves to just the policies we are currently
    exploring:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 实现引用计数的共享指针有几种方法，但让我们从类及其策略的设计开始。我们仍然需要一个删除策略，并且让一个策略控制移动和复制操作是有意义的。为了简单起见，我们再次限制自己只探索当前正在探索的策略：
- en: '[PRE54]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The copy operations are no longer unconditionally deleted. Both the copy and
    the move constructor are provided (the two assignment operators are omitted for
    brevity, but should be implemented in the same way it was done earlier).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 复制操作不再无条件删除。提供了复制和移动构造函数（为了简洁，省略了两个赋值运算符，但应按照之前的方式实现）。
- en: The deletion of the object in the destructor of the smart pointer is no longer
    unconditional - in the case of the reference-counted pointer, the copying policy
    maintains the reference count and knows when there is only one copy of the smart
    pointer for a particular object.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 智能指针析构函数中对象的删除不再是无条件的 - 在引用计数的指针的情况下，复制策略维护引用计数并知道对于特定对象只有一个智能指针副本时。
- en: 'The smart pointer class itself provides the requirements for the policy classes.
    The no-move, no-copy policy must disallow all copy and move operations:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 智能指针类本身提供了策略类的需求。无移动、无复制策略必须禁止所有复制和移动操作：
- en: '[PRE55]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In addition to that, the non-copyable smart pointer always deletes the object
    it owns in its destructor, so the `must_delete()` member function should always
    return `true`. Note that this function must be implemented by all copying policies,
    even if it is trivial, otherwise, the smart pointer class will not compile. However,
    we can fully expect the compiler to optimize the call away and unconditionally
    call the destructor when this policy is used.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，不可复制的智能指针在其析构函数中始终删除它所拥有的对象，因此`must_delete()`成员函数应始终返回`true`。请注意，此函数必须由所有复制策略实现，即使它是微不足道的，否则智能指针类将无法编译。然而，我们可以完全期待编译器优化调用并无条件调用析构函数，当使用此策略时。
- en: 'The move-only policy is similar to the movable policy we had earlier, but now
    we must explicitly enable the move operations and disable the copy operations:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 仅移动策略与之前我们使用的可移动策略类似，但现在我们必须明确启用移动操作并禁用复制操作：
- en: '[PRE56]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Again, the deletion is unconditional (the pointer inside the smart pointer object
    can be null if the object was moved, but this does not prevent us from calling
    `operator delete` on it). This policy allows the move constructor and the move
    assignment operator to compile; the `SmartPtr` class provides the correct implementation
    for these operations, and no additional support from the policy is required.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，删除是无条件的（如果对象被移动，智能指针对象内的指针可以是空的，但这并不阻止我们对其调用`operator delete`）。此策略允许移动构造函数和移动赋值运算符编译；`SmartPtr`类为这些操作提供了正确的实现，不需要策略的额外支持。
- en: 'The reference-counting copying policy is much more complex. Here, we have to
    decide on the shared pointer implementation. The simplest implementation allocates
    the reference counter in a separate memory allocation, which is managed by the
    copying policy. Let’s start with a reference-counted copying policy that does
    not allow move operations:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 基于引用计数的复制策略要复杂得多。在这里，我们必须决定共享指针的实现。最简单的实现是在单独的内存分配中分配引用计数器，该分配由复制策略管理。让我们从一个不允许移动操作的引用计数复制策略开始：
- en: '[PRE57]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: When a smart pointer with this copying policy is constructed, a new reference
    counter is allocated and initialized to one (we have one smart pointer pointing
    to the particular object - the one we are now constructing). When a smart pointer
    is copied, so are all its base classes, including the copy policy. The copy constructor
    of this policy simply increments the reference count. When a smart pointer is
    deleted, the reference count is decremented. The very last smart pointer to be
    deleted also deletes the count itself. The copying policy also controls when the
    pointed-to object is deleted - it happens when the reference count reaches one,
    which means that we are about to delete the very last pointer for this object.
    It is, of course, very important to make sure that the counter is not deleted
    before the `must_delete()` function is called. This is guaranteed to be true since
    the destructors of the base classes run after the destructor of the derived class
    - the derived class of the last smart pointer will see the counter value of one
    and will delete the object; then, the destructor of the copying policy will decrement
    the counter once more, see it drop to zero, and delete the counter itself.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当具有这种复制策略的智能指针被构造时，会分配并初始化一个新的引用计数器，其值为一（我们有一个智能指针指向特定的对象——我们现在正在构造的那个对象）。当智能指针被复制时，包括复制策略在内的所有基类也会被复制。这个策略的复制构造函数只是简单地增加引用计数。当智能指针被删除时，引用计数会减少。最后一个被删除的智能指针也会删除计数器本身。复制策略还控制指向的对象何时被删除——它发生在引用计数达到一的时候，这意味着我们即将删除指向该对象的最后一个指针。当然，确保在调用`must_delete()`函数之前不删除计数器非常重要。这可以通过基类的析构函数在派生类的析构函数之后运行来保证——最后一个智能指针的派生类将看到计数器的值为一，并将删除对象；然后，复制策略的析构函数将再次减少计数器，看到它降到零，并删除计数器本身。
- en: 'With this policy, we can implement shared ownership of an object:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种策略，我们可以实现对象共享所有权：
- en: '[PRE58]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, we have two pointers to the same object, with the reference count of two.
    The object is deleted when the last of the two pointers is, assuming that no more
    copies are created beforehand. The smart pointer is copyable, but not movable:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有两个指向同一对象的指针，引用计数为两个。当最后一个指针被删除时，对象被删除，前提是在此之前没有创建更多副本。智能指针是可复制的，但不可移动：
- en: '[PRE59]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In general, once reference-counted copying is supported, there is probably
    no reason to disallow move operations, unless they are simply not needed (in which
    case, the no-move implementation can be slightly more efficient). To support the
    move, we must give some thought to the moved-from state of the reference-counting
    policy – clearly, it must not decrement the reference counter when it is deleted,
    since a moved-from pointer no longer owns the object. The simplest way is to reset
    the pointer to the reference counter so that it is no longer accessible from the
    copying policy, but then the copying policy must support the special case of a
    null counter pointer:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，一旦支持引用计数复制，可能就没有理由禁止移动操作，除非它们根本不需要（在这种情况下，无移动实现可以稍微高效一些）。为了支持移动操作，我们必须考虑引用计数策略的移动后状态——显然，当它被删除时，它不能减少引用计数，因为移动后的指针不再拥有该对象。最简单的方法是将指针重置到引用计数器，这样它就不再可以从复制策略中访问，但此时复制策略必须支持空计数指针的特殊情况：
- en: '[PRE60]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Finally, a reference-counting copying policy must support the assignment operations
    as well. These are implemented similarly to the copy or move constructors (but
    take care to use the left-hand-side policies for the deletion of the left-hand-side
    objects before assigning the new values to the policies).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，引用计数复制策略还必须支持赋值操作。这些操作与复制或移动构造函数的实现方式类似（但请注意，在将新值赋给策略之前，必须先使用左侧策略删除左侧对象）。 '
- en: As you have seen, some of the policy implementations can get pretty complex,
    and their interactions are even more so. Fortunately, the policy-based design
    is particularly well-suited for writing testable objects. This application of
    policy-based design is so important that it deserves special mention.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，一些政策实施可能相当复杂，它们的交互甚至更为复杂。幸运的是，基于策略的设计特别适合编写可测试的对象。这种基于策略的设计应用非常重要，值得特别提及。
- en: Policies for test
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试策略
- en: We will now show the reader how to use policy-based design to write better tests.
    In particular, policies can be used to make the code more testable by means of
    unit tests. This can be done by substituting a special test-only version of a
    policy instead of the regular one. Let us demonstrate this with the example of
    the reference-counting policy from the previous subsection.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将向读者展示如何使用基于策略的设计来编写更好的测试。特别是，可以通过替换策略的特殊测试版本来使代码更容易通过单元测试进行测试。这可以通过用常规版本替换策略的特殊测试版本来实现。让我们通过之前小节中引用计数策略的例子来演示这一点。
- en: 'The main challenge of that policy is, of course, maintaining the correct reference
    count. We can easily develop some tests that should exercise all of the corner
    cases of reference counting:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 该策略的主要挑战当然是维护正确的引用计数。我们可以轻松地开发一些测试，这些测试应该能够测试引用计数的所有边界情况：
- en: '[PRE61]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The hard part is actually testing that all of this code works the way it is
    supposed to. We know what the reference count should be, but we have no way of
    checking what it really is (adding the public function `count()` to the smart
    pointer solves that problem, but it is the least of the difficulties). We know
    when the object is supposed to be deleted, but it is hard to verify that it actually
    was. We will probably get a crash if we delete the object twice, but even that
    is not certain. It is even harder to catch the case when the object is not deleted
    at all. A sanitizer can find such issues, at least if we use standard memory management,
    but they are not available in all environments and, unless the tests are designed
    to be run with the sanitizer, can produce very noisy output.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上测试所有这些代码是否按预期工作是很困难的。我们知道引用计数应该是多少，但我们没有检查它实际是多少的方法（将公共函数`count()`添加到智能指针中可以解决这个问题，但这只是困难中的一小部分）。我们知道对象应该在何时被删除，但很难验证它实际上是否被删除了。如果我们删除对象两次，我们可能会遇到崩溃，但这并不确定。如果对象根本没有被删除，那就更难捕捉到这种情况。一个清理器可以找到这样的问题，至少如果我们使用标准的内存管理，但它们并不在所有环境中都可用，并且除非测试被设计为与清理器一起运行，否则可能会产生非常嘈杂的输出。
- en: 'Fortunately, we can use policies to give our tests a window into the internal
    working of the object. For example, if we did not implement a public `count()`
    method in all our reference-counting policies, we can create a testable wrapper
    for the reference-counting policy:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以使用策略来让我们的测试能够窥视对象的内部工作原理。例如，如果我们没有在我们的引用计数策略中实现公共的`count()`方法，我们可以为引用计数策略创建一个可测试的包装器：
- en: '[PRE62]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Note that we had to change the `count_` data member from private to protected
    in the main copy policy. We could also declare the test policy a friend, but then
    we would have to do this for every new test policy. Now, we can actually implement
    our tests:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须将主复制策略中的`count_`数据成员从私有改为保护。我们也可以将测试策略声明为友元，但那样的话，我们就必须为每个新的测试策略都这样做。现在，我们实际上可以实施我们的测试：
- en: '[PRE63]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Similarly, we can create an instrumented deletion policy that checks whether
    the object will be deleted, or record in some external logging object that it
    was actually deleted and test that the deletion was properly logged. We would
    need to instrument our smart pointer implementation to make calls to the debugging
    or testing policy:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以创建一个可测量的删除策略，检查对象是否将被删除，或者记录在某个外部日志对象中，表明它实际上已被删除，并测试删除是否已正确记录。我们需要对我们的智能指针实现进行测量，以便调用调试或测试策略：
- en: '[PRE64]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Both debug and production (non-debug) policies must have all the methods referenced
    in the class, but the empty methods of the non-debug policy are going to be inlined
    and optimized down to nothing.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 调试和生产的（非调试）策略都必须包含类中引用的所有方法，但非调试策略的空方法将被内联并优化为无。
- en: '[PRE65]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The debug policies vary, the basic ones simply log all debuggable events:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 调试策略各不相同，基本的策略只是记录所有可调试的事件：
- en: '[PRE66]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The more complex policies can validate that the internal state of the objects
    is consistent with the requirements and that the class invariants are maintained.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的策略可以验证对象的内部状态是否符合要求，并且类的不变性是否得到维护。
- en: 'By now, the reader has likely noticed that the declarations of the policy-based
    objects can be quite long:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，读者可能已经注意到基于策略的对象声明可能相当长：
- en: '[PRE67]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This is one of the most frequently observed problems with policy-based design,
    and we should consider some ways to mitigate this problem.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这是基于策略设计中最常见的观察问题之一，我们应该考虑一些减轻这种问题的方法。
- en: Policy adapters and aliases
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略适配器和别名
- en: 'Perhaps the most obvious drawback of the policy-based design is the way we
    have to declare the concrete objects - specifically, the long list of policies
    that must be repeated every time. Judicious use of default parameters helps to
    simplify the most commonly used cases. For example, let us look at the following
    long declaration:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最明显的缺点是基于策略的设计中我们必须声明具体对象的方式 - 特别是，必须每次都重复的长策略列表。明智地使用默认参数有助于简化最常用的案例。例如，让我们看看以下的长声明：
- en: '[PRE68]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Sometimes, this can be reduced to the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，这可以简化为以下内容：
- en: '[PRE69]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This can be done if the defaults represent the most common case of a movable
    non-debug pointer that uses the `operator delete`. However, what is the point
    of adding the policies if we are not going to use them? A well-thought-out order
    of policy parameters helps to make the more common policy combinations shorter.
    For example, if the most common variation is the deletion policy, then a new pointer
    with a different deletion policy and default remaining policies can be declared
    without repeating the policies we do not need to change:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果默认值代表了一个可移动的非调试指针最常见的使用情况，并且使用了`operator delete`，那么这可以做到。然而，如果我们不打算使用这些策略，添加它们又有什么意义呢？一个经过深思熟虑的策略参数顺序有助于使更常见的策略组合更短。例如，如果最常见的变体是删除策略，那么可以声明一个新的指针，它具有不同的删除策略和默认剩余策略，而不需要重复我们不需要更改的策略：
- en: '[PRE70]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This still leaves the problem of the less commonly used policies. Also, policies
    are often added later as additional features must be added to the design. These
    policies are almost always added to the end of the parameter list. To do otherwise
    would require rewriting every bit of code where a policy-based class is declared
    to reorder its parameters. However, the late-coming policies are not necessarily
    less often used, and this evolution of the design may lead to a case where many
    policy arguments have to be explicitly written, even at their default values,
    so that one of the trailing arguments can be changed.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然留下了不常用策略的问题。此外，策略通常在添加额外功能后作为设计的一部分添加。这些策略几乎总是添加到参数列表的末尾。否则，需要重写声明基于策略类的所有代码，以重新排序其参数。然而，这些后来添加的策略并不一定是不常用的，这种设计演变可能导致许多策略参数必须明确写出，即使是在它们的默认值上，以便可以更改其中一个尾随参数。
- en: While there is no general solution to this problem within the confines of the
    traditional policy-based design, in practice, there are often few commonly used
    groups of policies, and then there are some frequent variations. For example,
    most of our smart pointers may be using `operator delete` and support move and
    release, but we frequently need to alternate between the debug and non-debug versions.
    This can be accomplished by creating adapters that convert a class with many policies
    to a new interface that exposes only the policies we want to change often and
    pins the rest of the policies to their commonly used values. Any large design
    will likely need more than one such adapter, as the commonly used sets of policies
    can vary.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在传统基于策略的设计框架内没有通用的解决方案，但在实践中，通常只有少数常用策略组，然后是一些频繁的变化。例如，我们的大多数智能指针可能使用`operator
    delete`并支持移动和释放，但我们经常需要在调试和非调试版本之间交替。这可以通过创建适配器来实现，这些适配器将具有许多策略的类转换为一个新的接口，该接口仅暴露我们经常想要更改的策略，并将其他策略固定在其常用值上。任何大型设计都可能需要多个这样的适配器，因为常用的策略集可能不同。
- en: 'The simplest way to write such an adapter is with the `using` alias:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 编写此类适配器的最简单方法是使用`using`别名：
- en: '[PRE71]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The other option is to use inheritance:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用继承：
- en: '[PRE72]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This creates a derived class template that pins some of the parameters of the
    base class template while leaving the rest parameterized. The entire public interface
    of the base class is inherited, but some care needs to be taken about the constructors
    of the base class. By default, they are not inherited, and so the newly derived
    class will have the default compiler-generated constructors. This is probably
    not something we want, so we have to bring the base class constructors (and possibly
    the assignment operators) into the derived class:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个派生类模板，它固定了基类模板的一些参数，而将其他参数保持为参数化。基类的整个公共接口被继承，但需要特别注意基类的构造函数。默认情况下，它们不会被继承，因此新派生的类将具有默认的编译器生成的构造函数。这可能不是我们想要的，因此我们必须将基类的构造函数（以及可能的赋值运算符）引入派生类：
- en: '[PRE73]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The `using` alias is definitely easier to write and maintain, but the derived
    class adapter offers more flexibility if it is necessary to also adapt some of
    the member functions, nested types, etc.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`using`别名无疑更容易编写和维护，但如果需要同时适配一些成员函数、嵌套类型等，派生类适配器则提供了更多的灵活性。'
- en: 'We can now use the new adapter when we need a smart pointer with the preset
    policies, but quickly change the debug policy:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要一个具有预设策略的智能指针，但需要快速更改调试策略时，我们现在可以使用新的适配器。
- en: '[PRE74]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: As we said from the beginning, the most common application of policies is to
    select a specific implementation for some aspect of the behavior of the class.
    Sometimes, such variations in the implementation are reflected in the public interface
    of the class as well - some operations may make sense only for some implementations,
    and not for others, and the best way to make sure that an operation that is not
    compatible with the implementation is not invoked is to simply not provide it.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们一开始所说的，策略最常见的应用是选择类行为某个方面的特定实现。有时，这种实现上的变化也会反映在类的公共接口上——某些操作可能只适用于某些实现，而不适用于其他实现，确保与实现不兼容的操作不被调用的最佳方式是简单地不提供它。
- en: Now, let us revisit the issue of selectively enabling parts of the public interface
    using policies.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新审视使用策略选择性地启用公共接口部分的问题。
- en: Using policies to control the public interface
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用策略来控制公共接口
- en: We have previously used policies to control the public interface in one of two
    ways - first, we were able to inject a public member function by inheriting from
    a policy. This approach is reasonably flexible and powerful, but has two drawbacks
    - first, once we inherit publicly from a policy, we have no control over what
    interface gets injected - every public member function of the policy becomes a
    part of the derived class interface. Second, to implement anything useful this
    way, we have to let the policy class cast itself to the derived class, and then
    it has to have access to all of the data members and possibly other policies of
    the class. The second approach we tried relied on a particular property of the
    constructors - to copy or move a class, we have to copy or move all of its base
    classes or data members; if one of them is non-copyable or non-movable, the entire
    constructor will fail to compile. Unfortunately, it usually fails with a rather
    non-obvious syntax error - nothing as straightforward as *no copy constructor
    found in this object.* We can extend this technique to other member functions,
    for example, to assignment operators, but it gets uglier.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前曾使用策略以两种方式控制公共接口：首先，通过从策略继承，我们能够注入一个公共成员函数。这种方法相当灵活且强大，但有两个缺点——首先，一旦我们公开继承自策略，我们就无法控制要注入的接口——策略的每个公共成员函数都成为派生类接口的一部分。其次，要以此方式实现任何有用的功能，我们必须让策略类将自己转换为派生类，然后它必须能够访问所有数据成员以及可能的其他策略。我们尝试的第二种方法依赖于构造函数的特定属性——要复制或移动一个类，我们必须复制或移动其所有基类或数据成员；如果其中之一是不可复制的或不可移动的，整个构造函数将无法编译。不幸的是，它通常以一个相当不明显的语法错误而失败——没有找到这个对象的复制构造函数。我们可以将这种技术扩展到其他成员函数，例如赋值运算符，但它会变得复杂。
- en: 'We will now learn a more direct way to manipulate the public interface of a
    policy-based class. First of all, let’s differentiate between conditionally disabling
    existing member functions and adding new ones. The former is reasonable and generally
    safe: if a particular implementation cannot support certain operations offered
    by the interface, they should not be offered in the first place. The latter is
    dangerous as it allows for the essentially arbitrary and uncontrolled extension
    of the public interface of the class. Therefore, we will focus on providing the
    interface for all possible intended uses of a policy-based class, and then disabling
    parts of that interface when they do not make sense for some choice of policies.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将学习一种更直接的方式来操作基于策略的类的公共接口。首先，让我们区分条件性地禁用现有成员函数和添加新成员函数。前者是合理的且通常安全：如果某个特定实现不支持接口提供的某些操作，那么它们从一开始就不应该被提供。后者是危险的，因为它允许对类的公共接口进行任意和不受控制的扩展。因此，我们将专注于提供基于策略的类的所有可能预期用途的接口，然后在某些策略选择下，禁用该接口的部分功能。
- en: There is already a facility in the C++ language to selectively enable and disable
    member functions. Prior to C++20, this facility is most commonly implemented through
    concepts (if they are available) or `std::enable_if`, but the foundation behind
    it is the SFINAE idiom that we studied in [*Chapter 7*](B19262_07.xhtml#_idTextAnchor314),
    *SFINAE, Concepts, and Overload Resolution Management*. In C++20, the much more
    powerful concepts can replace `std::enable_if` in many cases.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: C++语言中已经存在一种机制来有选择性地启用和禁用成员函数。在C++20之前，这个机制通常通过概念（如果可用）或`std::enable_if`来实现，但其背后的基础是我们已经在[*第7章*](B19262_07.xhtml#_idTextAnchor314)中学习过的SFINAE惯用法，即*SFINAE、概念和重载解析管理*。在C++20中，更强大的概念可以在许多情况下取代`std::enable_if`。
- en: To illustrate the use of SFINAE to let the policies selectively enable a member
    function, we’re going to reimplement the policy controlling the public `release()`
    member function. We have done this once already in this chapter by inheriting
    from a `ReleasePolicy` that may or may not provide the `release()` member function;
    if one is provided, CRTP had to be used to implement it. We are now going to do
    the same but using C++20 concepts.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何使用SFINAE让策略有选择性地启用成员函数，我们将重新实现控制公共`release()`成员函数的策略。我们已经在本章中通过从可能提供或不提供`release()`成员函数的`ReleasePolicy`继承来实现过一次；如果提供了，就必须使用CRTP来实现它。现在，我们将使用C++20的概念来完成同样的工作。
- en: 'As we just said, a policy that relies on SFINAE and concepts cannot add any
    new member functions to the interface of a class; it can only disable some of
    them. Therefore, the first step is to add the `release()` function to the `SmartPtr`
    class itself:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才所说的，依赖于SFINAE和概念的策略不能向类的接口添加任何新的成员函数；它只能禁用其中的一些。因此，第一步是将`release()`函数添加到`SmartPtr`类本身：
- en: '[PRE75]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Right now, it is always enabled, so we need to conditionally enable it using
    some property of the `ReleasePolicy`. Since this policy controls a single behavior,
    all we need is a constant value that tells us whether the release feature should
    be supported:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，它始终处于启用状态，因此我们需要使用`ReleasePolicy`的某个属性来有条件地启用它：
- en: '[PRE76]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now, we need to conditionally enable the `release()` member function with a
    constraint:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要使用约束有条件地启用`release()`成员函数：
- en: '[PRE77]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: That’s all we need in C++20\. Note that we did not need to inherit from `ReleasePolicy`
    because there is nothing in it except for a constant value. We also do not need
    to move or copy this policy, for the same reason.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++20中，我们需要的就这些。请注意，我们不需要从`ReleasePolicy`继承，因为其中除了一个常量值之外没有其他内容。同样地，我们也不需要移动或复制这个策略。
- en: Before C++20 and concepts, we have to use `std::enable_if` to enable or disable
    a particular member function - in general, the expression `std::enable_if<value,
    type>` will compile and yield the specified `type` if the `value` is `true` (it
    must be a compile-time, or `constexpr`, Boolean value). If the `value` is `false`,
    the type substitution fails (no type result is produced). The proper use for this
    template metafunction is in an SFINAE context, where the failure of type substitution
    does not result in a compilation error, but simply disables the function that
    causes the failure (to be more precise, it removes it from the overload resolution
    set).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++20和概念出现之前，我们必须使用`std::enable_if`来启用或禁用特定的成员函数——一般来说，表达式`std::enable_if<value,
    type>`如果`value`为`true`（它必须是一个编译时，或`constexpr`，布尔值）将会编译并产生指定的`type`。如果`value`为`false`，类型替换将失败（不会产生任何类型结果）。这个模板元函数的正确用途是在SFINAE上下文中，类型替换的失败不会导致编译错误，而只是禁用导致失败的函数（更准确地说，是从重载解析集中移除它）。
- en: 'The policies themselves do not have to change at all: both SFINAE and constraints
    need a `constexpr bool` value. What changes is the expression used to disable
    a member function. It is tempting to write it simply as:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 策略本身根本不需要改变：SFINAE和约束都需要一个`constexpr bool`值。改变的是用来禁用成员函数的表达式。简单地写成如下形式是有诱惑力的：
- en: '[PRE78]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Unfortunately, this is not going to work: for the `NoRelease` policy, this
    fails to compile even if we do not try to call `release()`. The reason is that
    SFINAE works only when template parameter substitution is done (`release()` function
    must be a template, and, furthermore, the potential substitution failure has to
    occur during the substitution of template parameters. We do not need any template
    parameters to declare `release()`, but we have to introduce a dummy one to use
    SFINAE:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这行不通：对于 `NoRelease` 策略，即使我们不尝试调用 `release()`，代码也无法编译。原因是 SFINAE 只在模板参数替换时才起作用（`release()`
    函数必须是模板，而且，更重要的是，潜在的替换失败必须发生在模板参数替换过程中。我们不需要任何模板参数来声明 `release()`，但我们必须引入一个虚拟参数来使用
    SFINAE：
- en: '[PRE79]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We have seen such “fake templates” when we were describing the “concept utilities”
    – a way to mimic concepts before C++20 – in [*Chapter 7*](B19262_07.xhtml#_idTextAnchor314)*,
    SFINAE, Concepts, and Overload Resolution Management*. Now we have a template
    type parameter; the fact that it is never going to be used and is always set to
    its default value changes nothing. The conditional expression in the return type
    uses this template parameter (never mind that the part of the expression that
    depends on the parameter can never fail). Therefore, we are now within the SFINAE
    rules.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 [*第 7 章*](B19262_07.xhtml#_idTextAnchor314)*，SFINAE、概念和重载解析管理* 中描述“概念工具”时，我们看到了这样的“假模板”——在
    C++20 之前模仿概念的一种方法。现在我们有一个模板类型参数；它永远不会被使用，并且始终设置为默认值，这并不会改变任何事情。返回类型中的条件表达式使用这个模板参数（尽管表达式依赖于参数的部分永远不会失败）。因此，我们现在处于
    SFINAE 规则之内。
- en: Now that we have a way to disable a member function selectively, we can revisit
    the conditionally enabled constructors to see how we can enable and disable constructors
    as well.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了选择性地禁用成员函数的方法，我们可以重新审视条件启用构造函数，看看我们如何启用和禁用构造函数。
- en: 'In C++20, the answer is “exactly the same way.” We need a policy with a `constexpr`
    Boolean value and a `restrict` constraint to disable any constructor:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++20 中，答案是“完全相同的方式。”我们需要一个具有 `constexpr` 布尔值和 `restrict` 约束的策略来禁用任何构造函数：
- en: '[PRE80]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We can use this policy to constrain any member function, constructors included:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个策略来约束任何成员函数，包括构造函数：
- en: '[PRE81]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Prior to C++20, we have to use SFINAE. The one complication here is that the
    constructors have no return type and we have to hide the SFINAE test somewhere
    else. In addition, we again have to make the constructor a template. We can use
    a dummy template parameter again:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++20 之前，我们必须使用 SFINAE。这里的复杂性在于构造函数没有返回类型，我们必须在其他地方隐藏 SFINAE 测试。此外，我们再次必须使构造函数成为模板。我们还可以再次使用虚拟模板参数：
- en: '[PRE82]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'If you use the concept utilities from [*Chapter 7*](B19262_07.xhtml#_idTextAnchor314)*,
    SFINAE, Concepts, and Overload Resolution Management*, the code is going to look
    simpler and more straightforward, although a dummy template parameter is still
    needed:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 [*第 7 章*](B19262_07.xhtml#_idTextAnchor314)* 中的概念工具，SFINAE、概念和重载解析管理，代码将看起来更简单、更直接，尽管仍然需要一个虚拟模板参数：
- en: '[PRE83]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Now that we have a fully general way to enable or disable specific member functions
    that work for constructors as well, the reader may be wondering, what was the
    point of introducing the earlier way? Firstly, for simplicity - the `enable_if`
    expression has to be used in the right context, and the compiler errors that are
    generated if anything is even slightly wrong are not pretty. On the other hand,
    the notion that a non-copyable base class makes the entire derived class non-copyable
    is very basic and works every time. This technique can even be used in C++03,
    where SFINAE is much more limited and even harder to get to work correctly.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了完全通用的方法来启用或禁用特定的成员函数，包括构造函数，读者可能会想知道，引入早期方法的意义何在？首先，为了简单起见——`enable_if`
    表达式必须在正确的上下文中使用，如果稍有错误，生成的编译器错误并不美观。另一方面，一个不可复制的基类使整个派生类不可复制的概念非常基础，并且每次都有效。这种技术甚至可以在
    C++03 中使用，那时 SFINAE 的限制更多，而且更难正确实现。
- en: 'Also, we have already seen that sometimes policies need to add member variables
    to the class instead of (or in addition to) member functions. Our reference-counting
    pointer is a perfect example: if one of the policies provides reference counting,
    it must also contain the count. Member variables cannot be restricted with constraints,
    so they have to come from the base policy class.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们已经看到，有时策略需要向类中添加成员变量而不是（或除了）成员函数。我们的引用计数指针是一个完美的例子：如果某个策略提供了引用计数，它也必须包含计数。成员变量不能使用约束进行限制，因此它们必须来自基策略类。
- en: 'Yet another reason to at least know the way to inject public member functions
    through policies is that sometimes the `enable_if` alternative requires that the
    entire set of possible functions be declared in the primary class template, and
    then some can be selectively disabled. Sometimes, that set of functions is self-contradicting
    and cannot be present all at once. An example is a set of conversion operators.
    Right now, our smart pointer cannot be converted back into a raw pointer. We could
    enable such conversions and require them to be explicit, or allow implicit conversions:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个至少要知道如何通过策略注入公有成员函数的理由是，有时`enable_if`替代方案要求在主类模板中声明所有可能的函数集，然后可以选择性地禁用其中一些。有时，这个函数集是自相矛盾的，不能同时存在。一个例子是一组转换运算符。目前，我们的智能指针不能转换回原始指针。我们可以启用这些转换并要求它们是显式的，或者允许隐式转换：
- en: '[PRE84]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The conversion operators are defined as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 转换运算符的定义如下：
- en: '[PRE85]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We already decided that we do not want these operators to be unconditionally
    present; instead, we want them controlled by a raw conversion policy. Let us start
    with the same approach we used the last time for a policy that enables a member
    function:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经决定不希望这些运算符无条件地存在；相反，我们希望它们由原始转换策略控制。让我们从上次用于启用成员函数的策略的相同方法开始：
- en: '[PRE86]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Again, we will write C++20 code first, where we can restrict both the explicit
    and the implicit operators using constraints:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将首先编写C++20代码，在那里我们可以使用约束来限制显式和隐式运算符：
- en: '[PRE87]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'For completeness, we also provided conversions to a `const` raw pointer. Note
    that in C++20, there is a simpler way to provide these operators using the conditional
    explicit specifier (another C++20 feature):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，我们还提供了转换到`const`原始指针的转换。请注意，在C++20中，使用条件显式指定符（另一个C++20特性）提供这些运算符有更简单的方法：
- en: '[PRE88]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Prior to C++20, we can attempt to enable one of these operators using `std::enable_if`
    and SFINAE, again based on a conversion policy. The problem is, we cannot declare
    both implicit and explicit conversion to the same type, even if one is later disabled.
    These operators cannot be in the same overload set to begin with:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++20之前，我们可以尝试使用`std::enable_if`和SFINAE来启用这些运算符之一，再次基于转换策略。问题是，即使后来禁用，我们也不能声明到同一类型的隐式和显式转换。这些运算符一开始就不能在同一个重载集中：
- en: '[PRE89]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'If we want to have the option to select one of these operators in our smart
    pointer class, we have to have them generated by the base class policy. Since
    the policy needs to be aware of the smart pointer type, we have to use the CRTP
    again. Here is a set of policies to control the conversion from smart pointers
    to raw pointers:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在智能指针类中选择这些运算符之一，我们必须让它们由基类策略生成。由于策略需要了解智能指针类型，我们必须再次使用CRTP。以下是一组策略来控制从智能指针到原始指针的转换：
- en: '[PRE90]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'These policies add the desired public member function operators to the derived
    class. Since they are templates that need to be instantiated with the derived
    class type, the conversion policy is a template template parameter, and its use
    follows the CRTP:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这些策略将所需的公有成员函数运算符添加到派生类中。由于它们是模板，需要用派生类类型实例化，因此转换策略是一个模板模板参数，其使用遵循CRTP：
- en: '[PRE91]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Once again, note the use of the template template parameter: the template parameter
    `ConversionPolicy` is not a type but a template. When inheriting from an instantiation
    of this policy, we have to write the complete type of our `SmartPtr` class, with
    all its template arguments. We made the conversion policy a template of two arguments
    (the second one is the object type `T`). We could also deduce the type `T` from
    the first template parameter (the smart pointer type), it’s largely a matter of
    style.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意模板模板参数的使用：模板参数`ConversionPolicy`不是一个类型，而是一个模板。当我们从该策略的一个实例继承时，我们必须写出我们`SmartPtr`类的完整类型，包括所有模板参数。我们将转换策略做成一个接受两个参数的模板（第二个参数是对象类型`T`）。我们也可以从第一个模板参数（智能指针类型）推导出类型`T`，这主要是一个风格问题。
- en: 'The selected conversion policy adds its public interface, if any, to that of
    the derived class. One policy adds a set of explicit conversion operators, while
    the other one provides implicit conversions. Just like in the earlier CRTP example,
    the base class needs access to the private data members of the derived class.
    We can either grant friendship to the entire template (and every instantiation
    of it) or, more verbosely, to the specific instantiation used as the base class
    for each smart pointer:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 选定的转换策略将它的公共接口（如果有），添加到派生类的接口中。一个策略添加了一组显式的转换操作符，而另一个则提供了隐式转换。就像在早期的CRTP示例中一样，基类需要访问派生类的私有数据成员。我们可以授予整个模板（及其所有实例化）友情权限，或者更具体地，授予用作每个智能指针基类的特定实例化：
- en: '[PRE92]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: We have learned several different ways to implement new policies. Sometimes,
    the challenge comes in reusing the ones we already have. The next section shows
    one way to do it.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了多种实现新策略的方法。有时，挑战在于重用我们已有的策略。下一节将展示一种实现方法。
- en: Rebinding policies
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新绑定策略
- en: As we have already seen, the policy lists can get quite long. Often, we want
    to change just one policy and create a class *just like that other one, but with
    a small change.* There are at least two ways to do this.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，策略列表可能会变得相当长。通常，我们只想更改一条策略，并创建一个与另一个类似但略有不同的类。至少有两种方法可以做到这一点。
- en: 'The first way is very general but somewhat verbose. The first step is to expose
    the template parameters as aliases, inside the primary template. This is a good
    practice, anyway - without such aliases, it is very difficult to find out, at
    compile time, what a template parameter was in case we ever need to use it outside
    of the template. For example, we have a smart pointer, and we want to know what
    the deletion policy was. The easiest way, by far, is with some help from the smart
    pointer class itself:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法非常通用，但有些冗长。第一步是将模板参数作为别名暴露在主模板中。无论如何，这是一个好习惯——如果没有这样的别名，在编译时很难找出模板参数是什么，以防我们需要在模板外使用它。例如，我们有一个智能指针，我们想知道删除策略是什么。到目前为止，最简单的方法是借助智能指针类本身的一些帮助：
- en: '[PRE93]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Note that we’re using two different types of aliases here - for the regular
    template parameters such as `DeletionPolicy`, we can use a `using` alias. For
    a template template parameter, we have to use the template alias, sometimes called
    template `typedef` - to reproduce the same policy with another smart pointer,
    we need to know the template itself, not the template instantiation, such as `ConversionPolicy<SmartPtr,
    T>`. Now, if we need to create another smart pointer with some of the same policies,
    we can simply query the policies of the original object:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里使用了两种不同类型的别名——对于像`DeletionPolicy`这样的常规模板参数，我们可以使用`using`别名。对于模板模板参数，我们必须使用模板别名，有时称为模板`typedef`——为了使用另一个智能指针重复相同的策略，我们需要知道模板本身，而不是模板实例化，例如`ConversionPolicy<SmartPtr,
    T>`。现在，如果我们需要创建另一个具有一些相同策略的智能指针，我们可以简单地查询原始对象的策略：
- en: '[PRE94]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Now, `p2` and `p1` have exactly the same type. There is, of course, an easier
    way to accomplish that. But the point is, we could alter any one of the types
    in the list and keep the rest, and get a pointer just like `p1`, *except for one
    change.* For example, the pointer `p2` has the same policies but points to a `double`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`p2`和`p1`具有完全相同的类型。当然，还有更简单的方法可以做到这一点。但关键是，我们可以更改列表中的任何一种类型，保留其余的，并得到一个像`p1`一样的指针，*除了一个变化。*例如，指针`p2`具有相同的策略，但指向一个`double`。
- en: 'The latter turns out to be a pretty common case, and there is a way to facilitate
    the *rebinding* or a template to a different type while keeping the rest of the
    arguments intact. To do this, the primary template and all its policies need to
    support such rebinding:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 后者实际上是一个非常常见的案例，并且有一种方法可以在保持其余参数不变的情况下，简化模板到不同类型的*重新绑定*。为此，主模板及其所有策略都需要支持这种重新绑定：
- en: '[PRE95]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The `rebind` alias defines a new template that has only one parameter - the
    type we can change. The rest of the parameters come from the primary template
    itself. Some of these parameters are types that also depend on the primary type
    `T`, and themselves need rebinding (in our example, the deletion policy). By choosing
    not to rebind the copy/move policy, we impose a requirement that none of these
    policies depend on the primary type, otherwise this policy, too, needs to be rebound.
    Finally, the template conversion policy does not need rebinding - we have access
    to the entire template here, so it will be instantiated with the new primary type.
    We can now use the rebinding mechanism to create a *similar* pointer type:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`rebind` 别名定义了一个只有一个参数的新模板——我们可以更改的类型。其余的参数来自主模板本身。其中一些参数也是依赖于主类型 `T` 的类型，并且自身也需要重新绑定（在我们的例子中，是删除策略）。通过选择不重新绑定复制/移动策略，我们强加了一个要求，即这些策略中没有任何一个依赖于主类型，否则这个策略也需要重新绑定。最后，模板转换策略不需要重新绑定——我们在这里可以访问整个模板，因此它将使用新的主类型实例化。现在，我们可以使用重新绑定机制来创建一个*类似*的指针类型：'
- en: '[PRE96]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: If we have direct access to the smart pointer type, we can use it for rebinding
    (for example, in a template context). Otherwise, we can get the type from a variable
    of this type using `decltype()`. The pointer `q` has the same policies as `p`
    but points to a `double`, and the type-dependent policies such as the deletion
    policy have been updated accordingly.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们直接访问智能指针类型，我们可以用它来进行重新绑定（例如，在模板上下文中）。否则，我们可以使用 `decltype()` 从此类变量的类型中获取类型。指针
    `q` 与 `p` 具有相同的策略，但指向一个 `double`，并且根据类型依赖的策略（如删除策略）进行了相应的更新。
- en: We have covered the main ways in which the policies can be implemented and used
    to customize policy-based classes. It is now time to review what we have learned
    and state some general guidelines for the use of policy-based designs.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了策略可以实施和用于定制基于策略类的主要方式。现在是时候回顾我们所学的，并就基于策略设计的使用提出一些一般性指南。
- en: Recommendations and guidelines
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建议和指南
- en: The policy-based design allows for exceptional flexibility in the creation of
    finely customizable classes. Sometimes, this flexibility and power become the
    enemy of a good design. In this section, we will review the strengths and weaknesses
    of the policy-based design and come up with some general recommendations.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 基于策略的设计允许在创建精细可定制的类时具有非凡的灵活性。有时，这种灵活性和力量反而会成为良好设计的敌人。在本节中，我们将回顾基于策略设计的优点和缺点，并提出一些一般性建议。
- en: Strengths of the policy-based design
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于策略设计的优点
- en: The main advantages of the policy-based design are flexibility and extensibility
    of the design. At a high level, these are the same benefits the Strategy pattern
    offers, only realized at compile-time. The policy-based design allows the programmer
    to select, at compile time, one of several algorithms for each specific task or
    operation performed by the system. Since the only constraints on the algorithms
    are the requirements on the interface that binds them into the rest of the system,
    it is equally possible to extend the system by writing new policies for the customizable
    operations.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 基于策略设计的主要优点是设计的灵活性和可扩展性。从高层次来看，这些是策略模式提供的相同好处，只是在编译时实现。基于策略的设计允许程序员在编译时为系统执行的每个特定任务或操作选择多个算法之一。由于算法的唯一约束是绑定它们的接口对整个系统的要求，因此通过编写新策略来扩展系统也是同样可能的。
- en: At a high level, the policy-based design allows the software system to be built
    from components. At a high level, this is hardly a novel idea, certainly not limited
    to policy-based design. The focus of the policy-based design is the use of components
    to define behavior and the implementation of individual classes. There is some
    similarity between policies and callbacks - both allow a user-specified action
    to be taken when a particular event takes place. However, the policies are much
    more general than callbacks - while a callback is a function, policies are entire
    classes, with multiple functions and, possibly, a non-trivial internal state.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，基于策略的设计允许软件系统由组件构建。在高层次上，这几乎不是一个新颖的想法，当然也不限于基于策略的设计。基于策略设计的重点是使用组件来定义行为和实现单个类。策略和回调之间有一些相似之处——两者都允许在特定事件发生时执行用户指定的操作。然而，策略比回调更通用——回调是一个函数，而策略是整个类，具有多个函数，可能还有非平凡的内部状态。
- en: These general concepts translate into a unique set of advantages for the design,
    mostly centered around the ideas of flexibility and extensibility. With the overall
    structure of the system and its high-level components determined by the high-level
    design, the policies allow for a variety of low-level customizations within the
    constraints that were imposed by the original design. Policies can extend the
    class interface (add public member functions), implement or extend the state of
    the class (add data members), and specify implementations (add private member
    functions). The original design, in setting the overall structure of the classes
    and their interactions, in effect authorizes each policy to have one or more of
    these roles.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这些通用概念转化为设计的一套独特优势，主要围绕灵活性和可扩展性。由于系统的整体结构和其高级组件由高级设计确定，因此策略允许在原始设计强加的约束内进行各种低级定制。策略可以扩展类接口（添加公共成员函数），实现或扩展类的状态（添加数据成员），并指定实现（添加私有成员函数）。原始设计在设定类的整体结构和它们之间的交互时，实际上授权每个策略拥有这些角色中的一个或多个。
- en: The result is an extensible system that can be modified to address evolving
    requirements, even ones that have not been anticipated or known at the time when
    the system was designed. The overall architecture remains stable, while the selection
    of possible policies and the constraints on their interfaces offers a systematic,
    disciplined way to modify and extend the software.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个可扩展的系统，可以修改以应对不断变化的需求，甚至包括在系统设计时未预见或未知的那些需求。整体架构保持稳定，而可能策略的选择及其接口的约束提供了一种系统化、规范化的方式来修改和扩展软件。
- en: Disadvantages of policy-based design
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于策略设计的缺点
- en: 'The first problem with the policy-based design that comes to mind is the one
    we have already encountered - declarations of policy-based classes with a specific
    set of policies are extremely verbose, especially if one of the policies at the
    end of the list has to be changed. Consider the declaration of a smart pointer
    with all of the policies we have implemented in this chapter, put together:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到基于策略的设计的第一个问题，是我们已经遇到的问题——具有特定策略集的基于策略类的声明非常冗长，尤其是如果列表末尾的策略需要更改的话。考虑一下声明一个智能指针，其中包含我们在本章中实现的所有策略，合并在一起：
- en: '[PRE97]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: That’s just for a smart pointer - a class with a fairly simple interface and
    limited functionality. Even though it is unlikely that someone will need one pointer
    with all of these customization possibilities, the policy-based classes tend to
    have a lot of policies. This problem may be the most evident, but it is actually
    not the worst. The template aliases help to give concise names to the few policy
    combinations that are actually used by a particular application. In the template
    context, the types of smart pointers used as function arguments are deduced and
    do not need to be explicitly specified. In regular code, `auto` can be used to
    save a lot of typing and also make the code more robust - when the complex type
    declarations that must be consistent are replaced with an automatic way to generate
    these consistent types, the errors caused by typing something slightly different
    in two different places disappear (in general, if there is a recipe to make the
    compiler generate correct-by-construction code, use it).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是针对智能指针的——一个接口相对简单且功能有限的类。尽管不太可能有人需要具有所有这些定制化可能性的单个指针，但基于策略的类往往有很多策略。这个问题可能最为明显，但实际上并不是最糟糕的。模板别名有助于为特定应用实际使用的少量策略组合提供简洁的名称。在模板上下文中，用作函数参数的智能指针类型会被推导出来，无需显式指定。在常规代码中，可以使用`auto`来节省大量输入，并使代码更加健壮——当必须保持一致性的复杂类型声明被替换为自动生成这些一致类型的方式时，由于在两个不同位置输入略有不同而导致的错误就会消失（一般来说，如果有一个方法可以使编译器生成正确构造的代码，就使用它）。
- en: The much more significant, if slightly less visible, problem is that all of
    these policy-based types with different policies are actually different types.
    Two smart pointers that point to the same object type but have different deletion
    policies are different types. Two smart pointers that are otherwise the same but
    have different copying policies are different types. Why is that a problem? Consider
    a function that is called to work on an object that is passed into the function
    using a smart pointer. This function does not copy the smart pointer, so it should
    not matter what the copying policy is - it is never used. And yet, what should
    the argument type be? There is no one type that can accommodate all smart pointers,
    even the ones with very similar functionality.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 更为显著，尽管不太明显的问题是，所有这些具有不同策略的策略类型实际上都是不同的类型。两个指向相同对象类型但具有不同删除策略的智能指针是不同类型。两个在其他方面相同但具有不同复制策略的智能指针也是不同类型。这为什么会成为问题呢？考虑一个被调用来处理通过智能指针传递给函数的对象的函数。这个函数不会复制智能指针，因此复制策略应该无关紧要——它永远不会被使用。然而，参数类型应该是什么？没有一种类型可以容纳所有智能指针，即使是功能非常相似的智能指针。
- en: There are several possible solutions here. The most straightforward one is to
    make all functions that use policy-based types into templates. This does simplify
    the coding, and it reduces code duplication (at least the source code duplication),
    but it has its own downsides - the machine code becomes larger since there are
    multiple copies of every function, and all template code must be in the header
    files.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个可能的解决方案。最直接的一个是将所有使用策略类型的函数都做成模板。这确实简化了编码，并减少了代码重复（至少是源代码的重复），但它也有其自身的缺点——由于每个函数都有多个副本，机器代码会变得更大，并且所有模板代码都必须放在头文件中。
- en: The other option is to erase the policy types. We saw the type erasure technique
    in [*Chapter 6*](B19262_06.xhtml#_idTextAnchor266), *Understanding Type Erasure*.
    Type erasure solves the problem of having many similar types - we could make all
    smart pointers, regardless of their policies, be of the same type (only to the
    extent that the policies determine the implementation and not the public interface,
    of course). However, this comes at a very high cost.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是擦除策略类型。我们在[*第6章*](B19262_06.xhtml#_idTextAnchor266)中看到了类型擦除技术，*理解类型擦除*。类型擦除解决了存在许多相似类型的问题——我们可以使所有智能指针，无论其策略如何，都具有相同的类型（当然，仅限于策略决定实现而不是公共接口）。然而，这代价很高。
- en: One of the main drawbacks of the templates in general, and the policy-based
    design, in particular, is that templates provide a zero-overhead abstraction -
    we can express our programs in terms of convenient high-level abstractions and
    concepts, but the compiler strips it all away, inlines all of the templates, and
    generates the minimum necessary code. Type erasure not only negates this advantage
    but has the opposite effect - it adds a very high overhead of memory allocations
    and indirect function calls.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 模板的一般缺点，尤其是基于策略的设计，在于模板提供了一个零开销的抽象——我们可以用方便的高级抽象和概念来表示我们的程序，但编译器会移除所有这些，内联所有模板，并生成必要的最小代码。类型擦除不仅否定了这一优势，而且产生了相反的效果——它增加了非常高的内存分配和间接函数调用的开销。
- en: The last option is to avoid using policy-based types, at least for some operations.
    Sometimes, this choice carries a little extra cost - for example, a function that
    needs to operate on an object but not delete or own it should take the object
    by reference instead of a smart pointer (see [*Chapter 3*](B19262_03.xhtml#_idTextAnchor110),
    *Memory and Ownership*). In addition to clearly expressing the fact that the function
    is not going to own the object, this neatly solves the problem of what type the
    argument should be - the reference is the same type, no matter which smart pointer
    it came from. This is, however, a limited approach - more often than not, we do
    need to operate on the entire policy-based objects, which are usually much more
    complex than a simple pointer (for example, custom containers are often implemented
    using policies).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个选择是避免使用基于策略的类型，至少对于某些操作来说是这样。有时，这种选择会带来一些额外的成本——例如，一个需要操作对象但不删除或拥有它的函数应该通过引用而不是智能指针来获取对象（参见[*第3章*](B19262_03.xhtml#_idTextAnchor110)，*内存和所有权*）。除了清楚地表达函数不会拥有对象的事实外，这还巧妙地解决了参数应该是什么类型的问题——引用与来自哪个智能指针无关，都是相同的类型。然而，这是一个有限的方法——大多数情况下，我们确实需要操作整个基于策略的对象，这些对象通常比简单的指针复杂得多（例如，自定义容器通常使用策略实现）。
- en: The final disadvantage is the general complexity of the policy-based types,
    although such claims should be made with care - the important question is, complexity
    compared to what? Policy-based designs are usually invoked to solve complex design
    problems where a family of similar types serves the same overall purpose (*what*),
    but does so in slightly different ways (*how)*. This leads us to the recommendations
    on the use of policies.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个缺点是基于策略的类型的一般复杂性，尽管这样的说法应该谨慎对待——重要的是，与什么相比的复杂性？基于策略的设计通常用于解决复杂的设计问题，其中一系列类似类型服务于相同的基本目的（*什么*），但以略有不同的方式（*如何*）。这导致我们对策略使用的建议。
- en: Guidelines for policy-based designs
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于策略的设计指南
- en: The guidelines for policy-based designs boil down to managing the complexity
    and making sure the ends justify the means - the flexibility of the design and
    the elegance of the resulting solutions should justify the complexity of the implementation
    and its use.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 基于策略的设计指南总结为管理复杂性和确保结果合理——设计的灵活性和结果的优雅性应该证明实现复杂性和使用的合理性。
- en: Since most of the complexity comes from the increasing number of policies, this
    is the focus of most of the guidelines. Some policies end up putting together
    very different types that happen to have a similar implementation. The goal of
    such a policy-based type is to reduce code duplication. While a worthwhile objective,
    this is generally not a good enough reason to expose a multitude of disparate
    policy options to the end user of the type. If two different types or type families
    happen to have similar implementations, that implementation can be factored out.
    The private, hidden, implementation-only part of the design can itself use policies
    if it makes the implementation easier.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数复杂性都来自策略数量的增加，这是大多数指南的重点。一些策略最终将非常不同的类型组合在一起，这些类型恰好有类似的实现。这种基于策略的类型的目的是减少代码重复。虽然这是一个值得追求的目标，但这通常不足以将众多不同的策略选项暴露给类型的最终用户。如果两种不同的类型或类型家族恰好有类似的实现，那么这种实现可以被分解出来。设计的私有、隐藏、仅实现部分可以使用策略，如果这使实现更容易的话。
- en: However, these hidden policies should not be selected by the client - the client
    should specify the types that make sense in the application and the policies that
    customize the visible behavior. From these types and policies, the implementation
    can derive additional types as needed. This is no different than calling a common
    function to, say, find the minimum element in a sequence from several different
    unrelated algorithms that all happen to need that operation. The common code is
    not duplicated, but neither is it exposed to the user.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些隐藏的策略不应该由客户端选择——客户端应该指定在应用程序中有意义的类型和定制可见行为的策略。从这些类型和策略中，实现可以根据需要派生额外的类型。这与调用一个通用函数来执行操作没有什么不同，比如从几个不同且无关的算法中找到序列中的最小元素。通用代码没有被重复，也没有暴露给用户。
- en: So, when should a policy-based type be broken up into two or more pieces? A
    good way to look at it is to ask whether the primary type, with a particular set
    of policies, has a good specific name that describes it. For example, a non-copyable
    owning pointer, movable or not, is a *unique pointer -* there is only one such
    pointer for each object at any given time. This is true for any deletion or conversion
    policy.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，何时应该将基于策略的类型分解成两个或更多部分？一个很好的方法是问，具有特定策略集的主要类型是否有描述它的良好特定名称。例如，不可复制的拥有指针，无论是否可移动，是*唯一指针*——在任何给定时间，每个对象只有一个这样的指针。这适用于任何删除或转换策略。
- en: On the other hand, a reference-counted pointer is a *shared pointer,* again,
    with any choice of other policies. This suggests that our one smart pointer to
    end all smart pointers would be, perhaps, better split into two - a non-copyable
    unique pointer and a copyable shared pointer. We still get some code reuse because
    the deletion policy, for example, is common to both pointer types, and does not
    have to be implemented twice. This is, indeed, the choice the C++ standard makes.
    The `std::unique_ptr` has only one policy, the deletion policy. The `std::shared_ptr`
    also has the same policy and can use the same policy objects, but it is type-erased,
    so all shared pointers to a particular object are of one type.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，引用计数的指针是*共享指针*，再次，可以搭配其他任何策略。这表明我们的“终结所有智能指针的智能指针”可能最好分成两个——一个不可复制的唯一指针和一个可复制的共享指针。我们仍然可以获得一些代码重用，因为删除策略，例如，对于这两种指针类型都是通用的，不需要实现两次。这确实是C++标准所做的选择。《std::unique_ptr》只有一个策略，即删除策略。《std::shared_ptr》也有相同的策略，可以使用相同的策略对象，但它进行了类型擦除，因此指向特定对象的共享指针都是同一类型。
- en: 'But what about other policies? Here, we come to the second guideline - the
    policies that restrict the use of the class should be justified by the cost of
    possible errors that are caused by the incorrect use they are trying to prevent.
    For example, do we really need a non-movable policy? On the one hand, it could
    prevent a programming error if the ownership of the object absolutely must not
    be transferred. On the other hand, in many cases, the programmer will simply change
    the code to use a movable pointer. Also, we are forced to use movable pointers
    to return them by value from factory functions. However, a non-copyable policy
    is often justified and should be the default. For example, there are good reasons
    to make most containers non-copyable by default: copying a large collection of
    data is almost always the result of sloppy coding, usually when passing arguments
    to functions.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，其他策略又是如何呢？在这里，我们来到了第二个指导原则——限制类使用的策略应该由它们试图防止的错误可能造成的成本来证明其合理性。例如，我们真的需要非移动策略吗？一方面，如果对象的拥有权绝对不能转让，这可以防止编程错误。另一方面，在许多情况下，程序员会简单地更改代码以使用可移动指针。此外，我们被迫使用可移动指针从工厂函数中按值返回它们。然而，不可复制的策略通常是有理由的，并且应该是默认设置。例如，有很好的理由使大多数容器默认不可复制：复制大量数据几乎总是糟糕编码的结果，通常是在向函数传递参数时。
- en: Similarly, while it is probably desirable to prevent implicit casting to the
    raw pointer as a matter of basic coding discipline, there is always a way to convert
    the smart pointer to the raw one explicitly - if nothing else, `&*p` should always
    work. Again, the benefits of the carefully restricted interface probably do not
    justify adding this policy. However, it makes a great compact learning example
    for a set of techniques that can be used to create more complex and more useful
    policies, and so the time we spent learning how this policy works is entirely
    justified.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，虽然可能希望防止隐式转换为原始指针作为基本的编码纪律，但总有一种方法可以将智能指针显式地转换为原始指针——如果不是其他的话，`&*p`应该始终有效。再次强调，精心限制的接口的好处可能不足以证明添加此策略的合理性。然而，它为一系列可以用来创建更复杂、更有用的策略的技术提供了一个很好的紧凑学习示例，因此我们花费在学习这个策略如何工作上的时间是完全有理由的。
- en: When a policy affecting the public interface is justified, we have to make a
    choice between a constraint-based policy that restricts the existing member functions
    and a CRTP-based policy that adds them. As a rule, a design that relies on constraints
    is preferable, even prior to C++20 where we have to use the “pseudo-concepts.”
    However, this approach cannot be used to add member variables to the class, only
    member functions.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个影响公共接口的策略是合理的，我们必须在基于约束的策略和基于CRTP的策略之间做出选择，前者限制现有的成员函数，后者添加它们。一般来说，依赖于约束的设计是首选的，即使在C++20之前，我们也必须使用“伪概念”。然而，这种方法不能用来向类中添加成员变量，只能添加成员函数。
- en: Another way to look at the question of what the right set of policies is and
    what policies should be broken up into separate groups is to go back to the fundamental
    strength of the policy-based design - the composability of the behavior expressed
    by different policies. If we have a class with four different policies, each of
    which can have four different implementations, that is 256 different versions
    of the class. It is, of course, unlikely that we will need all 256\. But the point
    is, at the time when we implement the class, we do not know which of these versions
    we will actually need later. We could make a guess and implement only a few most
    likely ones. If we are wrong, this will result in much code duplication and copy-pasting.
    With the policy-based design, we have the potential to implement any combination
    of the behavior, without actually having to write them all explicitly up front.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看待正确策略集和策略应该分成哪些单独群体的问题的方法是回到基于策略设计的根本优势——不同策略表达的行为的可组合性。如果我们有一个具有四个不同策略的类，每个策略都可以有四种不同的实现，那么这就是256个不同的类版本。当然，我们不太可能需要所有256个。但关键是，在我们实现类的时候，我们不知道我们将来实际上需要哪个版本。我们可以猜测并只实现最有可能的几个。如果我们错了，这将导致大量的代码重复和粘贴。使用基于策略的设计，我们有潜力实现任何行为组合，而实际上并不需要一开始就明确地写出所有这些行为。
- en: Now that we understand this strength of policy-based designs, we can use it
    to evaluate a particular set of policies - do they need to be composable? Would
    we ever need to combine them in different ways? If some policies always come in
    certain combinations or groups, this calls for automatically deducing these policies
    from one primary user-specified policy. On the other hand, a set of largely independent
    policies that can be combined arbitrarily is probably a good set of policies.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了基于策略设计的这种优势，我们可以利用它来评估一组特定的策略——它们是否需要可组合的？我们是否需要以不同的方式将它们结合起来？如果某些策略总是以特定的组合或群体出现，这就需要从主要用户指定的策略中自动推导出这些策略。另一方面，一组可以任意组合的相对独立的策略可能是一组很好的策略。
- en: Another way to address some of the weaknesses of policy-based design is to try
    and accomplish the same goal by different means. There is no substitute for the
    entirety of the capabilities offered by the policies - the Strategy pattern is
    there for a reason. However, there are alternative patterns that offer somewhat
    superficial similarities and may be used to solve some of the same problems as
    the policy-based design addresses. We will see one such alternative in [*Chapter
    16*](B19262_16.xhtml#_idTextAnchor739), *Adapters and Decorators* when we talk
    about decorators. It is not as general, but when it works, it can provide all
    the advantages of the policies, in particular, the composability, without some
    of the problems.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 解决基于策略的设计的一些弱点的一种方法是通过不同的手段尝试实现相同的目标。没有替代品可以完全替代策略提供的全部功能——策略模式的存在是有原因的。然而，有一些替代模式提供了一些表面的相似性，并且可以用来解决基于策略的设计所解决的问题。当我们讨论装饰器时，我们将在[*第16章*](B19262_16.xhtml#_idTextAnchor739)中看到这样一个替代方案，*适配器和装饰器*。它并不像策略那样通用，但当它起作用时，它可以提供策略的所有优势，特别是可组合性，而不存在一些问题。
- en: Summary
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have studied, extensively, the applications of the Strategy
    pattern (also known as the policy pattern) to C++ generic programming. The combination
    of the two gives rise to one of the most powerful tools in the arsenal of a C++
    programmer - the policy-based design of classes. This approach provides great
    flexibility by allowing us to compose the behavior of the class from many building
    blocks, or policies, each of which is responsible for a particular aspect of the
    behavior.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们广泛研究了策略模式（也称为策略模式）在C++泛型编程中的应用。这两种方法的结合产生了C++程序员武器库中最强大的工具之一——基于策略的类设计。这种方法通过允许我们从许多构建块或策略中组合类的行为，为每个策略负责行为的一个特定方面，提供了极大的灵活性。
- en: We have learned different ways to implement policies - these can be templates,
    classes with template member functions, classes with static functions, and even
    classes with constant values. Just as varied are the ways that we can use policies
    through composition, inheritance, or direct access to static members. Policy parameters
    can be types or templates, each with its own advantages and limitations.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了不同的实现策略的方法——这些可以是模板，具有模板成员函数的类，具有静态函数的类，甚至是具有常量值的类。我们可以通过组合、继承或直接访问静态成员来使用策略的方式同样多种多样。策略参数可以是类型或模板，每种都有其自身的优势和局限性。
- en: A tool as powerful as the policy-based design is also easily misused or applied
    in poor judgment. Often, such situations arise from the gradual evolution of the
    software toward more and more complexity. To mitigate such mischance, we have
    provided a set of guidelines and recommendations that focus on the key advantages
    that the policy-based design offers to the programmer and suggested the techniques
    and constraints that maximize such advantages.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 基于策略的设计这样的强大工具也容易被误用或在不恰当的情况下应用。这种情况通常源于软件逐渐向更复杂的方向发展。为了减轻这种不幸，我们提供了一套指南和建议，这些指南和建议侧重于基于策略的设计为程序员提供的核心优势，并建议了最大化这种优势的技术和约束。
- en: In the next chapter, we will consider a more limited design pattern that can
    sometimes be used to mimic the policy-based approach, without some of its drawbacks.
    This chapter is dedicated to the Decorator pattern and the more general Adapter
    pattern. Both are sort of C++ magic tricks - they make an object appear as something
    it’s not.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将考虑一种更有限的设计模式，有时可以用来模仿基于策略的方法，而不存在其缺点。本章专门介绍装饰器模式以及更通用的适配器模式。两者都是C++的魔法技巧——它们使一个对象看起来像它不是的东西。
- en: Questions
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the Strategy pattern?
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 策略模式是什么？
- en: How is the Strategy pattern implemented at compile time using C++ generic programming?
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 策略模式是如何使用C++泛型编程在编译时实现的？
- en: What types can be used as policies?
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以用作策略的类型有哪些？
- en: How can policies be integrated into the primary template?
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将策略集成到主模板中？
- en: Should I use policies with public member functions or policies with constraint
    variables?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我应该使用具有公共成员函数的策略还是具有约束变量的策略？
- en: What are the main drawbacks of policy-based design?
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于策略的设计的主要缺点是什么？
