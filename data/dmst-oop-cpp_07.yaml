- en: '*Chapter 5*: Exploring Classes in Detail'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第5章*：深入探讨类'
- en: This chapter will begin our pursuit of **object-oriented programming** (**OOP**)
    in C++. We will begin by introducing **object-oriented** (**OO**) concepts, and
    then progress to understanding how these concepts can be implemented in C++. Many
    times, implementing OOP ideas will be done through *direct language support*,
    such as the features in this chapter. Sometimes, however, we will utilize various
    programming techniques to implement object-oriented concepts. These techniques
    will be seen in later chapters. In all cases, it is important to understand the
    object-oriented concepts and how these concepts relate to well-thought-out designs,
    and then have a clear understanding of how to implement these designs with robust
    code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将开始我们对C++中**面向对象编程**（OOP）的追求。我们将首先介绍**面向对象**（OO）的概念，然后逐渐理解这些概念如何在C++中实现。许多时候，实现OOP思想将通过*直接语言支持*来实现，比如本章中的特性。然而，有时我们将利用各种编程技术来实现面向对象的概念。这些技术将在后面的章节中看到。在所有情况下，重要的是理解面向对象的概念以及这些概念如何与深思熟虑的设计相关联，然后清楚地理解如何用健壮的代码实现这些设计。
- en: This chapter will detail C++ class usage in extreme detail. Subtle features
    and nuances are detailed beyond the basics. The goal of this chapter will be to
    get you to understand OO concepts, and for you to begin to think in terms of object-oriented
    programming. Embracing core OO ideals, such as encapsulation and information hiding,
    will allow you to write code that is easier to maintain, and will allow you to
    modify others' code more easily.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将详细介绍C++类的使用。微妙的特性和细微差别将超越基础知识进行详细说明。本章的目标是让您了解OO概念，并开始以面向对象编程的方式思考。拥抱核心的OO理念，如封装和信息隐藏，将使您能够编写更易于维护的代码，并使您更容易修改他人的代码。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Defining object-oriented terminology and concepts – object, class, instance,
    encapsulation, and information hiding
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义面向对象的术语和概念 - 对象、类、实例、封装和信息隐藏
- en: Applying class and member function basics
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用类和成员函数的基础知识
- en: Examining member function internals; the "this" pointer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查成员函数的内部；“this”指针
- en: Using access labels and access regions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用访问标签和访问区域
- en: Understanding constructors – default, overloaded, copy, and conversion constructors
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解构造函数 - 默认、重载、复制和转换构造函数
- en: Understanding destructors and their proper usage
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解析构函数及其正确使用
- en: Applying qualifiers to data members and member functions – inline, const, and
    static
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数据成员和成员函数应用限定符 - 内联、常量和静态
- en: By the end of this chapter, you will understand core object-oriented terminology
    applicable to classes, and how key OO ideas, such as encapsulation and information
    hiding, will lead to software that is easier to maintain.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将了解适用于类的核心面向对象术语，并了解关键的OO思想，如封装和信息隐藏，将导致更易于维护的软件。
- en: You will also appreciate how C++ provides built-in language features to support
    object-oriented programming. You will become well versed in the use of member
    functions, and will understand their underlying implementation through the `this`
    pointer. You will understand how to correctly use access labels and access regions
    to promote encapsulation and information hiding.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您还将了解C++如何提供内置语言特性来支持面向对象编程。您将熟练掌握成员函数的使用，并理解它们通过`this`指针的基本实现。您将了解如何正确使用访问标签和访问区域来促进封装和信息隐藏。
- en: You will understand how constructors can be used to initialize objects, and
    the many varieties of constructors from basic to typical (overloaded) to the copy
    constructor, and even conversion constructors. Similarly, you will understand
    how to make proper use of the destructor prior to an object's end of existence.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您将了解如何使用构造函数来初始化对象，以及从基本到典型（重载）到复制构造函数，甚至转换构造函数的多种类型的构造函数。同样，您将了解如何在对象存在结束之前正确使用析构函数。
- en: You will also understand how qualifiers, such as const, static, and inline,
    may be applied to member functions to support either object-oriented concepts
    or efficiency. Likewise, you will understand how to apply qualifiers, such as
    const and static, to data members to additionally support OO ideals.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您还将了解如何将限定符，如const、static和inline，应用于成员函数，以支持面向对象的概念或效率。同样，您将了解如何将限定符，如const和static，应用于数据成员，以进一步支持OO理念。
- en: C++ can be used as an object-oriented programming language, but it is not automatic.
    To do so, you must understand OO concepts, ideology, and language features that
    will allow you to support this endeavor. Let us begin our pursuit of writing code
    that is easier to modify and maintain by understanding the core and essential
    building block and language feature found in object-oriented C++ OO programs,
    the C++ class.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: C++可以用作面向对象的编程语言，但这并不是自动的。为此，您必须理解OO的概念、意识形态和语言特性，这将使您能够支持这一努力。让我们开始追求编写更易于修改和维护的代码，通过理解在面向对象C++
    OO程序中找到的核心和基本构建块和语言特性，C++类。
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Online code for the full program examples can be found at the following GitHub
    URL: [https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/tree/master/Chapter05).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter05` in a file named `Chp5-Ex1.cpp` under the aforementioned GitHub directory.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 完整程序示例的在线代码可以在以下GitHub URL找到：[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/tree/master/Chapter05)。每个完整程序示例都可以在GitHub存储库中的适当章节标题（子目录）下找到，文件名为该章节号，后跟破折号，再跟该章节中的示例编号。例如，本章的第一个完整程序可以在名为`Chp5-Ex1.cpp`的文件中的`Chapter05`子目录中找到。
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/2OQgiz9](https://bit.ly/2OQgiz9).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可在以下链接观看：[https://bit.ly/2OQgiz9](https://bit.ly/2OQgiz9)。
- en: Introducing object-oriented terminology and concepts
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍面向对象的术语和概念
- en: In this section, we will introduce core object-oriented concepts as well as
    applicable terminology that will accompany these key ideas. Though new terms will
    come up throughout this chapter, we will begin with the terms necessary to understand
    to begin our journey in this section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍核心面向对象的概念以及适用的术语，这些术语将伴随着这些关键思想。虽然本章中会出现新术语，但我们将从必须理解的术语开始，以便在本节开始我们的旅程。
- en: Object-oriented systems are inherently more easily maintained because upgrades
    and modifications to user defined types can be made quickly, and without impact
    to the entire system, due to encapsulation and information hiding.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的系统因为封装和信息隐藏，因此更容易维护。用户定义类型的升级和修改可以快速进行，而不会对整个系统产生影响。
- en: Let's get started with basic object-oriented terminology.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基本的面向对象术语开始。
- en: Understanding object-oriented terminology
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解面向对象的术语
- en: We will begin with basic object-oriented terminology, and then as we introduce
    new concepts, we will extend the terminology to include C++ specific terminology.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从基本的面向对象术语开始，然后在介绍新概念时，我们将扩展术语以包括C++特定的术语。
- en: The terms object, class, and instance are all important and related terms with
    which we can start our definitions. An **object** embodies a meaningful grouping
    of characteristics and behaviors. An object can be manipulated and can receive
    the action or consequences of a behavior. Objects may undergo transformations
    and can change repeatedly over time. Objects can interact with other objects.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对象、类和实例这些术语都是重要且相关的术语，我们可以从这些术语开始定义。**对象**体现了一组特征和行为的有意义的组合。对象可以被操作，可以接收行为的动作或后果。对象可能会经历变化，并且随着时间的推移可以反复改变。对象可以与其他对象互动。
- en: The term object, at times, may be used to describe the blueprint for groupings
    of like items. The term **class** may be used interchangeably with this usage
    of an object. The term object may also (and more often) be used to describe a
    specific item in such a grouping. The term **instance** may be used interchangeably
    with this meaning of an object. The context of usage will often make clear which
    meaning of the term *object* is being applied. To avoid potential confusion, the
    terms *class* and *instance* can preferably be used.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 术语对象有时可能用来描述类似项的组合的蓝图。术语**类**可能与对象的这种用法互换使用。术语对象也可能（更常见）用来描述这种组合中的特定项。术语**实例**可能与对象的这种含义互换使用。使用上下文通常会清楚地表明术语*对象*的哪种含义被应用。为避免潜在的混淆，最好使用术语*类*和*实例*。
- en: 'Let''s consider some examples, using the aforementioned terms:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一些例子，使用上述术语：
- en: '![](img/Figure_5.1_B15930.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_5.1_B15930.jpg)'
- en: Objects also have components. The characteristics of a class are referred to
    as **attributes**. Behaviors of a class are referred to as **operations**. The
    specific implementation of a behavior or operation is referred to as its **method**.
    In other words, the method is how an operation is implemented, or the body of
    code defining the function, whereas the operation is the function's prototype
    or protocol for usage.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对象也有组成部分。类的特征被称为**属性**。类的行为被称为**操作**。行为或操作的具体实现被称为其**方法**。换句话说，方法是操作的实现方式，或者定义函数的代码体，而操作是函数的原型或使用协议。
- en: 'Let''s consider some high-level examples, using the aforementioned terms:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一些高级例子，使用上述术语：
- en: '![](img/Figure_5.2_B15930.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_5.2_B15930.jpg)'
- en: 'Each instance of a class will most likely have distinct values for its attributes.
    For example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 类的每个实例很可能具有其属性的不同值。例如：
- en: '![](img/Figure_5.3_B15930.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_5.3_B15930.jpg)'
- en: Now that we have the basic OO terms under our belt, let's move on to important
    object-oriented concepts that are relevant to this chapter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了基本的面向对象术语，让我们继续介绍与本章相关的重要面向对象概念。
- en: Understanding object-oriented concepts
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解面向对象的概念
- en: The key object-oriented concepts relating to this chapter are *encapsulation*
    and *information hiding*. Incorporating these interrelated ideas into your design
    will provide the basis for writing more easily modifiable and maintainable programs.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章相关的关键面向对象概念是*封装*和*信息隐藏*。将这些相关的想法纳入到你的设计中，将为编写更易于修改和可维护的程序提供基础。
- en: The grouping of meaningful characteristics (attributes) and behaviors (operations)
    that operate on those attributes, bundled together in a single unit, is known
    as **encapsulation**. In C++, we typically group these items together in a class.
    The interface to each class instance is made through operations that model the
    behaviors relevant to each class. These operations may additionally modify the
    internal state of the object by changing the values of its attributes. Concealing
    attributes within a class and providing an interface for operating on those details
    leads us to explore the supportive concept of information hiding.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 将有意义的特征（属性）和行为（操作）捆绑在一起形成一个单一单元的过程称为**封装**。在C++中，我们通常将这些项目组合在一个类中。通过模拟与每个类相关的行为的操作，可以通过每个类实例的接口进行访问。这些操作还可以通过改变其属性的值来修改对象的内部状态。在类中隐藏属性并提供操作这些细节的接口，使我们能够探索信息隐藏的支持概念。
- en: '**Information hiding** refers to the process of *abstracting* the details of
    performing an operation into a class method. That is, the user needs only to understand
    which operation to utilize and its overall purpose; the implementation details
    are hidden within the method (the function''s body). In this fashion, changing
    the underlying implementation (method) will not change the operation''s interface.
    Information hiding can additionally refer to keeping the underlying implementation
    of a class'' attributes hidden. We will explore this further when we introduce
    access regions. Information hiding is a means to achieve proper encapsulation
    of a class. A properly encapsulated class will enable proper class abstraction
    and thus the support of OO designs.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**信息隐藏**是指将执行操作的细节抽象成类方法的过程。也就是说，用户只需要了解要使用哪个操作以及其整体目的；实现细节被隐藏在方法中（函数体）。通过这种方式，改变底层实现（方法）不会改变操作的接口。信息隐藏还可以指保持类属性的底层实现隐藏。当我们介绍访问区域时，我们将进一步探讨这一点。信息隐藏是实现类的正确封装的一种手段。正确封装的类将实现正确的类抽象，从而支持OO设计。'
- en: Object-oriented systems are inherently more easily maintained because classes
    allow upgrades and modifications to be made quickly and without impact to the
    entire system due to encapsulation and information hiding.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的系统因为类允许快速升级和修改而本质上更易于维护，这是由于封装和信息隐藏而不会对整个系统产生影响。
- en: Understanding class and member function basics
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解类和成员函数的基础
- en: A C++ **class** is a fundamental building block in C++ that allows a programmer
    to specify a user defined type, encapsulating related data and behaviors. A C++
    class definition will contain attributes, operations, and sometimes methods. C++
    classes support encapsulation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的**类**是C++中的基本构建块，允许程序员指定用户定义的类型，封装相关数据和行为。C++类定义将包含属性、操作，有时还包括方法。C++类支持封装。
- en: Creating a variable of a class type is known as **instantiation**. The attributes
    in a class are known as **data members** in C++. Operations in a class are known
    as **member functions** in C++, and are used to model behaviors. In OO terms,
    an operation implies the signature of a function, or its prototype (declaration),
    and the method implies its underlying implementation or the body of the function
    (definition). In some OO languages, the term *method* is used more loosely to
    imply either the operation or its method, based on the context of usage. In C++,
    the terms *data member* and *member function* are most often used.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 创建类类型的变量称为**实例化**。在C++中，类中的属性称为**数据成员**。在C++中，类中的操作称为**成员函数**，用于模拟行为。在OO术语中，操作意味着函数的签名，或者它的原型（声明），方法意味着其底层实现或函数的主体（定义）。在一些OO语言中，术语*方法*更松散地用于暗示操作或其方法，根据使用上下文而定。在C++中，最常使用的术语是*数据成员*和*成员函数*。
- en: The prototype for a member function must be placed in a class definition. Most
    often, the member function definition is placed outside of the class definition.
    The scope resolution operator `::` is then used to associate a given member function
    definition to the class of which it is a member. Dot `.` or arrow `->` notation
    is used to access all class members, including member functions, depending on
    whether we are accessing members through an instance or through a pointer to an
    instance.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 成员函数的原型必须放在类定义中。大多数情况下，成员函数定义放在类定义之外。然后使用作用域解析运算符`::`将给定的成员函数定义与其所属的类关联起来。点`.`或箭头`->`符号用于访问所有类成员，包括成员函数，取决于我们是通过实例还是通过指向实例的指针访问成员。
- en: C++ structures may also be used to encapsulate data and their related behaviors.
    A C++ `struct` can do anything a C++ `class` can do; in fact, `class` is implemented
    in terms of `struct` in C++. Though structures and classes may behave identically
    (other than default visibility), classes are more often used to model objects,
    model relationships between object types, and implement object-oriented systems.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: C++结构也可以用于封装数据及其相关行为。C++的`struct`可以做任何C++的`class`可以做的事情；实际上，在C++中，`class`是以`struct`的方式实现的。尽管结构和类可能行为相同（除了默认可见性），类更常用于模拟对象，模拟对象类型之间的关系，并实现面向对象的系统。
- en: 'Let''s take a look at a simple example in which we instantiate a `class` and
    a `struct`, each with member functions, for comparison with one another. We will
    break this example into several segments. The full program example can be found
    in the GitHub repository:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子，我们将实例化一个`class`和一个`struct`，每个都有成员函数，以便进行比较。我们将这个例子分成几个部分。完整的程序示例可以在GitHub存储库中找到：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex1.cpp)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex1.cpp
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, we first define a `student` type using a `struct`,
    and a `University` type using a `class`. Notice, by convention, that user defined
    types created using structures are not capitalized, yet user defined types created
    using classes begin with a capital letter. Also notice that the `class` definition
    requires the label `public:` toward the beginning of its definition. We will explore
    the use of this label later in this chapter; however, for now the `public` label
    is present so that this `class` will have the same default visibility of its members
    as does the `struct`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们首先使用`struct`定义了一个`student`类型，使用`class`定义了一个`University`类型。请注意，按照惯例，使用结构创建的用户定义类型不以大写字母开头，而使用类创建的用户定义类型以大写字母开头。还要注意，`class`定义需要在其定义的开头使用`public:`标签。我们将在本章的后面探讨这个标签的使用；但是，现在`public`标签的存在是为了让这个`class`的成员具有与`struct`相同的默认可见性。
- en: In both the `class` and `struct` definitions, notice the function prototypes
    for `Initialize()` and `Print()`. We will tie these prototypes to member function
    definitions in the next program segment using `::`, the scope resolution operator.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在`class`和`struct`的定义中，注意`Initialize()`和`Print()`的函数原型。我们将在下一个程序段中使用`::`，作用域解析运算符，将这些原型与成员函数定义联系起来。
- en: 'Let''s examine the various member function definitions:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看各种成员函数的定义：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, let's review the various member function definitions for each user defined
    type. The definitions for `void student::Initialize(const char *, float)`, `void
    student::Print()`, `void University::Initialize(const char *, int)`, and `void
    University::Print()` appear consecutively in the above fragment. Notice how the
    scope resolution operator `::` allows us to tie the relevant function definition
    back to the `class` or `struct` of which it is a member.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下每个用户定义类型的各种成员函数定义。在上面的片段中，`void student::Initialize(const char *,
    float)`、`void student::Print()`、`void University::Initialize(const char *, int)`和`void
    University::Print()`的定义是连续的。注意作用域解析运算符`::`如何允许我们将相关的函数定义与其所属的`class`或`struct`联系起来。
- en: Additionally, notice that in each `Initialize()` member function, the input
    parameters are used as values to load the relevant data members for a specific
    instance of a specific class type. For example, in the function definition of
    `void University::Initialize(const char *n, int num)`, the input parameter `num`
    is used to initialize `numStudents` for a particular `University` instance.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意，在每个`Initialize()`成员函数中，输入参数被用作值来加载特定类类型的特定实例的相关数据成员。例如，在`void University::Initialize(const
    char *n, int num)`的函数定义中，输入参数`num`被用来初始化特定`University`实例的`numStudents`。
- en: Note
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The scope resolution operator `::` associates member function definitions with
    the class (or struct) of which they are a member.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域解析运算符`::`将成员函数定义与其所属的类（或结构）关联起来。
- en: 'Let''s see how member functions are called by considering `main()` in this
    example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过考虑这个例子中的`main()`来看看成员函数是如何被调用的：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, in `main()`, we simply define a variable, `s1`, of type `student` and
    a variable, `u1`, of type `University`. In object-oriented terms, it is preferable
    to say that `s1` is an instance of `student`, and `u1` is an instance of `University`.
    The instantiation occurs when the memory for an object is made available. For
    this reason, declaring the pointer variable `u2` using `University *u2;` does
    not instantiate a `University`; it merely declares a pointer to a possible future
    instance. Rather, on the following line, `u2 = new University();`, we instantiate
    a `University` when the memory is allocated.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`中，我们简单地定义了一个`student`类型的变量`s1`和一个`University`类型的变量`u1`。在面向对象的术语中，最好说`s1`是`student`的一个实例，`u1`是`University`的一个实例。实例化发生在为对象分配内存时。因此，使用`University
    *u2;`声明指针变量`u2`并不会实例化`University`；它只是声明了一个可能的未来实例的指针。相反，在下一行`u2 = new University();`中，当分配内存时，我们实例化了一个`University`。
- en: For each of the instances, we initialize their data members by calling their
    respective `Initialize()` member functions, such as `s1.Initialize("Gabby Doone",
    4.0);` or `u1.Initialize("UMD", 4500);`. We then call `Print()` through each respective
    instance, such as `u2->Print();`. Recall that `u2->Print();` may also be written
    as `(*u2).Print();`, which more easily allows us to remember that the instance
    here is `*u2`, whereas `u2` is a pointer to that instance.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个实例，我们通过调用它们各自的`Initialize()`成员函数来初始化它们的数据成员，比如`s1.Initialize("Gabby Doone",
    4.0);`或`u1.Initialize("UMD", 4500);`。然后我们通过每个相应的实例调用`Print()`，比如`u2->Print();`。请记住，`u2->Print();`也可以写成`(*u2).Print();`，这样更容易让我们记住这个实例是`*u2`，而`u2`是指向该实例的指针。
- en: Notice, when we call `Initialize()` through `s1`, we call `student::Initialize()`
    because `s1` is of type `student`, and we initialize `s1`'s data members in the
    body of this function. Similarly, when we call `Print()` through `u1` or `*u2`,
    we call `University::Print()` because `u1` and `*u2` are of type `University`
    and we subsequently print out a particular university's data members.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们通过`s1`调用`Initialize()`时，我们调用`student::Initialize()`，因为`s1`的类型是`student`，我们在这个函数的主体中初始化了`s1`的数据成员。同样，当我们通过`u1`或`*u2`调用`Print()`时，我们调用`University::Print()`，因为`u1`和`*u2`的类型是`University`，我们随后打印出特定大学的数据成员。
- en: Since the instance `u1` was dynamically allocated on the heap, we are responsible
    for releasing its memory using `delete()` toward the end of `main()`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于实例`u1`是在堆上动态分配的，我们有责任在`main()`的末尾使用`delete()`释放它的内存。
- en: 'The output to accompany this program is as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随这个程序的输出如下：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we are creating class definitions with their associated member function
    definitions, it is important to know how developers typically organize their code
    in files. Most often, a class will be broken into a header (`.h`) file, which
    will contain the class definition, and a source code (`.cpp`) file, which will
    `#include` the header file, and then follow with the member function definitions
    themselves. For example, a class named `University` would have a `University.h`
    header file and a `University.cpp` source code file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们正在创建具有其关联的成员函数定义的类定义，重要的是要知道开发人员通常如何在文件中组织他们的代码。大多数情况下，一个类将被分成一个头（`.h`）文件，其中包含类定义，和一个源代码（`.cpp`）文件，它将`#include`头文件，然后跟随成员函数定义本身。例如，名为`University`的类将有一个`University.h`头文件和一个`University.cpp`源代码文件。
- en: Now, let's move forward with our understanding of the details of how member
    functions work by examining the `this` pointer.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过检查`this`指针来继续了解成员函数工作的细节。
- en: Examining member function internals; the "this" pointer
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查成员函数内部；"this"指针
- en: So far, we have noticed that member functions are invoked through objects. We
    have noticed that in the scope of a member function, it is the data members (and
    other member functions) of the particular object that invoked the function that
    may be utilized (in addition to any input parameters). Alas, how and why does
    this work?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经注意到成员函数是通过对象调用的。我们已经注意到，在成员函数的范围内，可以使用调用函数的特定对象的数据成员（和其他成员函数）（除了任何输入参数）。然而，这是如何以及为什么起作用的呢？
- en: It turns out that most often, member functions are invoked through objects.
    Whenever a member function is invoked in this fashion, that member function receives
    a pointer to the instance that invoked the function. A pointer to the object calling
    the function is then passed as an implicit first argument to the function. The
    name of this pointer is **this**.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，大多数情况下，成员函数是通过对象调用的。每当以这种方式调用成员函数时，该成员函数会接收一个指向调用函数的实例的指针。然后，将调用函数的对象的指针作为隐式的第一个参数传递给函数。这个指针的名称是**this**。
- en: Though the `this` pointer may be referred to explicitly in the definition of
    each such member function, it usually is not. Even without its explicit use, the
    data members utilized in the scope of the function belong to `this`, a pointer
    to the object that invoked the function.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在每个成员函数的定义中可能会显式引用`this`指针，但通常不会这样做。即使没有显式使用，函数范围内使用的数据成员属于`this`，即调用函数的对象的指针。
- en: 'Let us take a look at a full program example. Though the example is broken
    into segments, the full program can be found in the following GitHub location:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个完整的程序示例。虽然示例被分成了段落，但完整的程序可以在以下GitHub位置找到：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex2.cpp)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex2.cpp)'
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the first segment of the program, we define the class `Student` with a variety
    of data members, and two member function prototypes. For now, we will place everything
    in the `public` access region.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的第一部分中，我们定义了类`Student`，其中包含各种数据成员和两个成员函数原型。现在，我们将把所有内容放在`public`访问区域。
- en: 'Now, let''s examine the member function definitions for `void Student::Initialize()`
    and `void Student::Print()`. We will also examine what each of these functions
    looks like internally, to C++:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下`void Student::Initialize()`和`void Student::Print()`的成员函数定义。我们还将内部查看每个函数的样子，对于C++来说：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, we see the member function definition for `void Student::Initialize()`,
    which takes a variety of parameters. Notice that in the body of this function,
    we allocate memory for the data member `firstName` to be enough characters to
    hold what the input parameter `fn` requires (plus one for the terminating null
    character). We then `strcpy()` the string from the input parameter, `fn`, to the
    data member `firstName`. We do the same for the data member `lastName` using the
    input parameter `ln`. We proceed similarly, using the various input parameters,
    to initialize the various data members for the specific object that will invoke
    this function.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们看到了`void Student::Initialize()`的成员函数定义，它接受各种参数。请注意，在这个函数的主体中，我们为数据成员`firstName`分配了足够的字符来容纳输入参数`fn`所需的内容（再加上一个终止的空字符）。然后，我们使用`strcpy()`将输入参数`fn`的字符串复制到数据成员`firstName`中。我们使用输入参数`ln`对数据成员`lastName`做同样的操作。然后，我们类似地使用各种输入参数来初始化将调用此函数的特定对象的各种数据成员。
- en: Also, notice in `void Student::Initialize()` the assignment `this->middleInitial
    = mi;`. Here, we have an optional, explicit use of the `this` pointer. It is not
    necessary or customary in this situation to qualify `middleInitial` with `this`,
    but we may choose to do so. However, in the assignment `this->gpa = gpa;`, the
    use of `this` is required. Why? Notice that the input parameter is named `gpa`
    and the data member is also `gpa`. Simply assigning `gpa = gpa;` would set the
    most local version of `gpa` (the input parameter) to itself and would not affect
    the data member. Here, disambiguating `gpa` with `this` on the left-hand side
    of the assignment indicates to set the data member, `gpa`, which is pointed to
    by `this`, to the value of the input parameter, `gpa`. Another solution is to
    use distinct names for data members versus input parameters, such as renaming
    `gpa` in the formal parameter list to `avg` (which we will do in later versions
    of this code).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，在`void Student::Initialize()`中注意赋值`this->middleInitial = mi;`。在这里，我们可以选择性地显式使用`this`指针。在这种情况下，没有必要或习惯性地用`this`限定`middleInitial`，但我们可以选择这样做。然而，在赋值`this->gpa
    = gpa;`中，使用`this`是必需的。为什么？注意输入参数的名称是`gpa`，数据成员也是`gpa`。简单地赋值`gpa = gpa;`会将最局部版本的`gpa`（输入参数）设置为自身，并不会影响数据成员。在这里，通过在赋值的左侧用`this`来消除`gpa`，表示设置数据成员`gpa`，该数据成员由`this`指向，为输入参数`gpa`的值。另一个解决方案是在形式参数列表中对数据成员和输入参数使用不同的名称，比如将形式参数列表中的`gpa`重命名为`avg`（我们将在此代码的后续版本中这样做）。
- en: Now, notice the commented-out version of `void Student::Initialize()`, which
    is below the utilized version of `void Student::Initialize()`. Here, we can see
    how most member functions are internally represented. First, notice that the name
    of the function is *name mangled* to include the data types of its parameters.
    This is internally how functions are represented, and consequentially, allows
    function overloading (that is, two functions with seemingly the same name; internally,
    each has a unique name). Next, notice that among the input parameters, there is
    an additional, first input parameter. The name of this additional (hidden) input
    parameter is `this`, and it is defined as `Student *const this`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，注意`void Student::Initialize()`的注释掉的版本，它在使用的`void Student::Initialize()`的下面。在这里，我们可以看到大多数成员函数是如何在内部表示的。首先，注意函数的名称被*名称混编*以包括其参数的数据类型。这是函数在内部表示的方式，因此允许函数重载（即，两个看似相同名称的函数；在内部，每个函数都有一个唯一的名称）。接下来，注意在输入参数中，有一个额外的第一个输入参数。这个额外的（隐藏的）输入参数的名称是`this`，它被定义为`Student
    *const this`。
- en: Now, in the body of the internalized function view of `void Student::Initialize()`,
    notice that each data member's name is preceded with `this`. We are, in fact,
    accessing the data member of an object that is pointed to by `this`. Where is
    `this` defined? Recall, `this` is the implicit first input parameter to this function,
    and is a constant pointer to the object that invoked this function.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`void Student::Initialize()`的内部化函数视图的主体中，注意每个数据成员的名称前面都有`this`。事实上，我们正在访问由`this`指向的对象的数据成员。`this`在哪里定义？回想一下，`this`是这个函数的隐式第一个输入参数，并且是一个指向调用这个函数的对象的常量指针。
- en: Similarly, we can review the member function definition for `void Student::Print()`.
    In this function, each data member is neatly printed out using `cout` and the
    insertion operator `<<`. However, notice below this function definition the commented-out
    internal version of `void Student::Print()`. Again, `this` is actually an implicit
    input parameter of type `Student *const`. Also, each data member usage is preceded
    with access through the `this` pointer, such as `this->gpa`. Again, we can clearly
    see that a specific instance's members are accessed in the scope of a member function;
    these members are implicitly accessed through the `this` pointer.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以回顾`void Student::Print()`的成员函数定义。在这个函数中，每个数据成员都是用`cout`和插入运算符`<<`清晰地打印出来。然而，注意在这个函数定义下面的`void
    Student::Print()`的注释掉的内部版本。同样，`this`实际上是一个类型为`Student *const`的隐式输入参数。此外，每个数据成员的使用都是通过`this`指针进行的，比如`this->gpa`。同样，我们可以清楚地看到特定实例的成员是如何在成员函数的范围内被访问的；这些成员是通过`this`指针隐式访问的。
- en: Lastly, note that explicit use of `this` is permitted in the body of a member
    function. We can almost always precede usage of a data member or member function,
    accessed in the body of a member function, with explicit use of `this`. Later
    in this chapter, we will see the one contrary case (using a static method). Also,
    later in this book, we will see situations in which explicit usage of `this` will
    be necessary to implement more intermediate-level OO concepts.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，注意在成员函数的主体中允许显式使用`this`。我们几乎总是可以在成员函数的主体中使用数据成员或成员函数之前，用显式使用`this`。在本章的后面，我们将看到一个相反的情况（使用静态方法）。此外，在本书的后面，我们将看到需要显式使用`this`来实现更中级的面向对象概念的情况。
- en: 'Nonetheless, let''s move forward by examining `main()` to complete this program
    example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，让我们通过检查`main()`来完成这个程序示例：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the last segment of this program, we instantiate `Student` twice in `main()`.
    `Student` `s1` is an instance, whereas `s2` is a pointer to a `Student`. Next,
    we utilize either the `.` or `->` notation to invoke the various member functions
    through each relevant instance.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序的最后一部分，我们在`main()`中实例化了两次`Student`。`Student` `s1`是一个实例，而`s2`是一个指向`Student`的指针。接下来，我们通过每个相关实例使用`.`或`->`符号来调用各种成员函数。
- en: Note, when `s1` invokes `Initialize()`, the `this` pointer (in the scope of
    the member function) will point to `s1`. It will be as if `&s1` is passed as the
    first argument to this function. Likewise, when `*s2` invokes `Initialize`, the
    `this` pointer will point to `s2`; it will be as if `s2` (which is already a pointer)
    is passed as an implicit first argument to this function.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当`s1`调用`Initialize()`时，`this`指针（在成员函数的范围内）将指向`s1`。这将好像`&s1`被传递为该函数的第一个参数一样。同样，当`*s2`调用`Initialize`时，`this`指针将指向`s2`；就好像`s2`（已经是一个指针）被作为该函数的隐式第一个参数传递一样。
- en: After each instance invokes `Print()` to display the data members for each `Student`,
    notice that we release various levels of dynamically allocated memory. We start
    with the dynamically allocated data members for each instance, releasing each
    such member using `delete()`. Then, because `s2` is a pointer to an instance that
    we have dynamically allocated, we must also remember to release the heap memory
    comprising the instance itself. We again do so with `delete s2;`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个实例调用`Print()`以显示每个`Student`的数据成员之后，请注意我们释放各种级别的动态分配内存。我们从每个实例的动态分配数据成员开始，使用`delete()`释放每个这样的成员。然后，因为`s2`是我们动态分配的一个实例的指针，我们还必须记得释放包括实例本身的堆内存。我们再次使用`delete
    s2;`来完成这个操作。
- en: 'Here is the output for the full program example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是完整程序示例的输出：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, let's add to our understanding of classes and information hiding by examining
    access labels and regions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过检查访问标签和区域来增进对类和信息隐藏的理解。
- en: Using access labels and access regions
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用访问标签和访问区域
- en: Labels may be introduced into a class (or structure) definition to control the
    access or visibility of class (or structure) members. By controlling the direct
    access of members from various scopes in our application, we can support encapsulation
    and information hiding. That is, we can insist that users of our classes use the
    functions that we select, with the protocols we select, to manipulate data and
    other member functions within the class in ways we, the programmer, find reasonable
    and acceptable. Furthermore, we can hide the implementation details of the class
    by advertising to the user only the desired public interface for a given class.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 标签可以被引入到类（或结构）定义中，以控制类（或结构）成员的访问或可见性。通过控制应用程序中各种范围的直接访问成员，我们可以支持封装和信息隐藏。也就是说，我们可以坚持要求我们类的用户使用我们选择的函数，以我们选择的协议来操作数据和类中的其他成员函数，以我们程序员认为合理和可接受的方式。此外，我们可以通过仅向用户公布给定类的所需公共接口来隐藏类的实现细节。
- en: 'Data members or member functions, collectively referred to as **members**,
    can be individually labeled, or grouped together into access regions. The three
    labels or **access regions** that may be specified are as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 数据成员或成员函数，统称为**成员**，可以单独标记，或者组合到访问区域中。可以指定的三个标签或**访问区域**如下：
- en: '**private**: Data members and member functions in this access region are only
    accessible within the scope of the class. The scope of a class includes member
    functions of that class.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**private**：此访问区域中的数据成员和成员函数只能在类的范围内访问。类的范围包括该类的成员函数。'
- en: '`private` until we introduce inheritance. When inheritance is introduced, `protected`
    will provide a mechanism for allowing access within the derived class scope.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private`直到我们引入继承。当引入继承时，`protected`将提供一种机制，允许在派生类范围内访问。'
- en: '**public**: Data members and member functions in this access region are accessible
    from any scope in the program.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**public**：此访问区域中的数据成员和成员函数可以从程序中的任何范围访问。'
- en: Reminder
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒
- en: Data members and member functions are almost always accessed via instances.
    You will ask, *in what scope is my instance?* and *may I access a particular member
    from this particular scope?*
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎总是通过实例访问数据成员和成员函数。你会问，*我的实例在什么范围内？*以及*我可以从这个特定的范围访问特定的成员吗？*
- en: As many members as required by the programmer may be grouped under a given label
    or `private`. If access labels are omitted in a structure definition, default
    member access is `public`. When access labels are explicitly introduced, rather
    than relying on default visibility, a `class` and a `struct` are identical. Nonetheless,
    in object-oriented programming, we tend to utilize classes for user defined types.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员可以将尽可能多的成员分组到给定的标签或`private`下。如果在结构定义中省略了访问标签，则默认成员访问是`public`。当明确引入访问标签时，而不是依赖于默认可见性，`class`和`struct`是相同的。尽管如此，在面向对象编程中，我们倾向于使用类来定义用户定义的类型。
- en: 'Let''s examine an example to illustrate access regions. Though this example
    will be broken into several segments, the full example will be shown and can also
    be found in the GitHub repository:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来说明访问区域。尽管这个例子将被分成几个部分，但完整的例子将被展示，并且也可以在GitHub存储库中找到。
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex3.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex3.cpp)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex3.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex3.cpp)'
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, we first define the `Student` class. Notice that we add a `private`
    access region near the top of the class definition and place all of the data members
    within this region. This placement will ensure that these data members will only
    be able to be directly accessed and modified within the scope of this class, which
    means by member functions of this class (and friends, which we will much later
    see). By limiting the access of data members only to member functions of their
    own class, safe handling of those data members is ensured; only access through
    intended and safe functions, which the class designer has introduced themself,
    will be allowed.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先定义了`Student`类。请注意，我们在类定义的顶部附近添加了一个`private`访问区域，并将所有数据成员放在这个区域内。这样的安排将确保这些数据成员只能在这个类的范围内直接访问和修改，这意味着只能由这个类的成员函数（和我们稍后将看到的友元）来访问。通过仅限制数据成员的访问只能在其自己类的成员函数中，可以确保对这些数据成员的安全处理；只有通过类设计者自己引入的预期和安全函数的访问将被允许。
- en: Next, notice that the label `public` has been added in the class definition
    prior to the prototypes of the member functions. The implication is that these
    functions will be accessible in any scope of our program. Of course, we will generally
    need to access these functions each via an instance. But the instance can be in
    the scope of `main()` or any other function (even in the scope of another class's
    member functions) when the instance accesses these public member functions. This
    is known as a class' `public` interface.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，请注意在类定义之前的成员函数原型中添加了`public`标签。这意味着这些函数将在我们程序的任何范围内可访问。当然，我们通常需要通过实例分别访问这些函数。但是，当实例访问这些公共成员函数时，实例可以在`main()`或任何其他函数的范围内（甚至在另一个类的成员函数的范围内）。这被称为类的`public`接口。
- en: Access regions support encapsulation and information hiding
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 访问区域支持封装和信息隐藏
- en: A good rule of thumb is to place your data members in the private access region,
    and then specify a safe, appropriate public interface to them using public member
    functions. By doing so, the only access to data members is in manners that the
    class designer has intended, through member functions the class designer has written,
    which have been well tested. With this strategy, the underlying implementation
    of the class may also be changed without causing any calls to the public interface
    to change. This practice supports encapsulation and information hiding.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的经验法则是将数据成员放在私有访问区域中，然后使用公共成员函数指定一个安全、适当的公共接口。通过这样做，对数据成员的唯一访问是类设计者打算的方式，通过类设计者编写的经过充分测试的成员函数。采用这种策略，类的底层实现也可以更改，而不会导致对公共接口的调用发生变化。这种做法支持封装和信息隐藏。
- en: 'Let''s continue by taking a look at the various member function definitions
    in our program:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看看我们程序中各种成员函数的定义：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we have defined the various member functions that were prototyped in our
    class definition. Notice the use of the scope resolution operator `::` to tie
    the class name to the member function name. Internally, these two identifiers
    are *name mangled* together to provide a unique, internal function name. Notice
    that the `void Student::Initialize()` function has been overloaded; one version
    simply initializes all data members to some form of null or zero, whereas the
    overloaded version uses input parameters to initialize the various data members.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了在我们的类定义中原型化的各种成员函数。请注意使用作用域解析运算符`::`将类名与成员函数名绑定在一起。在内部，这两个标识符被*名称混淆*在一起，以提供一个唯一的内部函数名。请注意，`void
    Student::Initialize()`函数已被重载；一个版本只是将所有数据成员初始化为某种空值或零，而重载的版本使用输入参数来初始化各种数据成员。
- en: 'Now, let''s continue by examining our `main()` function in the following segment
    of code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续通过检查以下代码段中的`main()`函数来继续：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the aforementioned `main()` function, we first instantiate a `Student` with
    the declaration `Student s1;`. Next, `s1` invokes the `Initialize()` function
    with the signature matching the parameters provided. Since this member function
    is in the `public` access region, it can be accessed in any scope of our program,
    including `main()`. Similarly, `s1` invokes `Print()`, which is also `public`.
    These functions are in the `Student` class's public interface, and represent some
    of the core functionality for manipulating any given `Student` instance.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述的`main()`函数中，我们首先用声明`Student s1;`实例化了一个`Student`。接下来，`s1`调用了与提供的参数匹配的`Initialize()`函数。由于这个成员函数在`public`访问区域中，它可以在我们程序的任何范围内访问，包括`main()`。同样，`s1`调用了`Print()`，这也是`public`的。这些函数是`Student`类的公共接口，并代表了操纵任何给定`Student`实例的一些核心功能。
- en: Next, in the commented-out line of code, notice that `s1` tries to access `firstName`
    directly using `s1.firstName`. Because `firstName` is `private`, this data member
    can only be accessed in the scope of its own class, which means member functions
    (and later friends) of its class. The `main()` function is not a member function
    of `Student`, hence `s1` may not access `firstName` in the scope of `main()`,
    that is, a scope outside its own class.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在被注释掉的代码行中，请注意`s1`试图直接使用`s1.firstName`访问`firstName`。因为`firstName`是`private`的，这个数据成员只能在其自己的类的范围内访问，这意味着其类的成员函数（以及稍后的友元）。`main()`函数不是`Student`的成员函数，因此`s1`不能在`main()`的范围内访问`firstName`，也就是说，在其自己的类的范围之外。
- en: Lastly, we invoke `s1.CleanUp();`, which also works because `CleanUp()` is `public`
    and is hence accessible from any scope (including `main()`).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用了`s1.CleanUp();`，这也是可以的，因为`CleanUp()`是`public`的，因此可以从任何范围（包括`main()`）访问。
- en: 'The output for this complete example is:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个完整示例的输出是：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that we understand how access regions work, let's move forward by examining
    a concept known as a constructor, and the various types of constructors available
    within C++.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们了解了访问区域是如何工作的，让我们继续通过检查一个称为构造函数的概念，以及C++中可用的各种类型的构造函数。
- en: Understanding constructors
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解构造函数
- en: Did you notice how convenient it has been for the program examples in this chapter
    to have an `Initialize()` member function for each `class` or `struct`? Certainly,
    it is desirable to initialize all data members for a given instance. More so,
    it is crucial to ensure that data members for any instance have bonified values,
    as we know that memory is not provided *clean* or *zeroed-out* by C++. Accessing
    an uninitialized data member, and utilizing its value as if it were bonified,
    is a potential pitfall awaiting the careless programmer.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到本章节中的程序示例有多么方便，每个`class`或`struct`都有一个`Initialize()`成员函数？当然，为给定实例初始化所有数据成员是可取的。更重要的是，确保任何实例的数据成员具有真实的值是至关重要的，因为我们知道C++不会提供*干净*或*清零*的内存。访问未初始化的数据成员，并将其值用作真实值，是等待粗心的程序员的潜在陷阱。
- en: Initializing each data member individually each time a class is instantiated
    can be tedious work. What if we simply overlook setting a value? What if the values
    are `private`, and are therefore not directly accessible? We have seen that an
    `Initialize()` function is beneficial because once written, it provides a means
    to set all data members for a given instance. The only drawback is that the programmer
    must now remember to call `Initialize()` on each instance in the application.
    Instead, what if there is a way to ensure that an `Initialize()` function is called
    every time a class is instantiated? What if we could overload a variety of versions
    to initialize an instance, and the appropriate version could be called based on
    data available at the time? This premise is the basis for a constructor in C++.
    The language provides for an overloaded series of initialization functions, which
    will be automatically called once the memory for an instance becomes available.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 每次实例化一个类时单独初始化每个数据成员可能是繁琐的工作。如果我们简单地忽略了设置一个值会怎么样？如果这些值是`private`，因此不能直接访问呢？我们已经看到，`Initialize()`函数是有益的，因为一旦编写，它就提供了为给定实例设置所有数据成员的方法。唯一的缺点是程序员现在必须记住在应用程序中的每个实例上调用`Initialize()`。相反，如果有一种方法可以确保每次实例化一个类时都调用`Initialize()`函数会怎么样？如果我们可以重载各种版本来初始化一个实例，并且根据当时可用的数据调用适当的版本会怎么样？这个前提是C++中构造函数的基础。语言提供了一系列重载的初始化函数，一旦实例的内存可用，它们就会被自动调用。
- en: Let's take a look at this family of initialization member functions by examining
    the C++ constructor.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过检查C++构造函数来看一下这组初始化成员函数的家族。
- en: Applying constructor basics and overloading constructors
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用构造函数基础知识和构造函数重载
- en: A `class` (or `struct`) to define multiple means by which to initialize an object.
    The return type of a constructor may not be specified.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`class`（或`struct`）用于定义初始化对象的多种方法。构造函数的返回类型可能不会被指定。
- en: Should your `class` or `struct` not contain a constructor, one will be made
    for you, in the `public` access region, with no arguments. This is known as a
    default constructor. Behind the scenes, every time an object is instantiated,
    a constructor call is patched in by the compiler. When a class without a constructor
    is instantiated, the default constructor is patched in as a function call immediately
    following the instantiation. This system-supplied member function will have an
    empty body (method) and it will be linked into your program so that any compiler
    added, implicit, calls to this function upon instantiation can occur without a
    linker error. Typically, a programmer will write their own default (no-argument)
    constructor; that is, one that is used for the default means of instantiation
    with no arguments.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的`class`或`struct`不包含构造函数，系统将为您创建一个公共访问区域中没有参数的构造函数。这被称为默认构造函数。在幕后，每当实例化一个对象时，编译器都会插入一个构造函数调用。当一个没有构造函数的类被实例化时，默认构造函数会被插入为一个函数调用，紧随实例化之后。这个系统提供的成员函数将有一个空的主体（方法），并且它将被链接到您的程序中，以便在实例化时可以发生任何编译器添加的隐式调用，而不会出现链接器错误。通常，程序员会编写自己的默认（无参数）构造函数；也就是说，用于默认实例化的构造函数。
- en: Most programmers provide at least one constructor, in addition to their own
    no-argument default constructor. Recall, constructors can be overloaded. It is
    important to note that if you provide any constructor yourself, you will not then
    receive the system supplied, no-argument default constructor, and that subsequently
    using such an interface for instantiation will cause a compiler error.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序员至少会提供一个构造函数，除了他们自己的无参数默认构造函数。请记住，构造函数可以被重载。重要的是要注意，如果您自己提供了任何构造函数，那么您将不会收到系统提供的无参数默认构造函数，因此在实例化时使用这样的接口将导致编译器错误。
- en: Reminder
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒
- en: Constructors have the same name as the class. You may not specify their return
    type. They can be overloaded. The compiler only creates a public, default (no-argument)
    constructor if you have not provided any constructors (or means for instantiation)
    in your class.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数与类名相同。您不能指定它们的返回类型。它们可以被重载。如果您的类没有提供任何构造函数（或实例化的方法），编译器只会创建一个公共的默认（无参数）构造函数。
- en: 'Let''s introduce a simple example to understand constructor basics:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们介绍一个简单的例子来理解构造函数的基础知识：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex4.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex4.cpp)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex4.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex4.cpp)'
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the previous program segment, we first define `class University`; the data
    members are `private`, and the three member functions are `public`. Notice that
    the first two member functions prototyped are constructors. Both have the same
    name as the class; neither has its return type specified. The two constructors
    are overloaded, in that each has a different signature.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个程序段中，我们首先定义了`class University`；数据成员是`private`，而三个成员函数是`public`。请注意，首先原型化的两个成员函数是构造函数。两者都与类名相同；都没有指定返回类型。这两个构造函数是重载的，因为它们的签名不同。
- en: Next, notice that the three member functions are defined. Notice the use of
    the scope resolution operator `::` preceding each member function name, in each
    of their definitions. Each constructor provides a different means for initializing
    an instance. The `void University::Print()` member function merely provides a
    means to provide simple output for our example.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，请注意三个成员函数的定义。注意在它们的定义中，在每个成员函数名之前都使用了作用域解析运算符`::`。每个构造函数都提供了一个不同的初始化实例的方法。`void
    University::Print()`成员函数仅提供了一个简单输出的方法，供我们的示例使用。
- en: Now, in `main()`, let's create two instances of `University`. The first line
    of code, `University u1;`, instantiates a `University` and then implicitly invokes
    the default constructor to initialize the data members. On the next line of code,
    `University u2("University of Delaware", 23800);`, we instantiate a second `University`.
    Once the memory for that instance has been made available on the stack in `main()`,
    the constructor matching the signature of the arguments provided, namely `University::University(const
    char *, int)`, will be implicitly invoked to initialize the instance.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`main()`中，让我们创建两个`University`的实例。第一行代码`University u1;`实例化一个`University`，然后隐式调用默认构造函数来初始化数据成员。在下一行代码`University
    u2("University of Delaware", 23800);`中，我们实例化了第二个`University`。一旦在`main()`中为该实例在堆栈上分配了内存，将隐式调用与提供的参数签名匹配的构造函数，即`University::University(const
    char *, int)`，来初始化该实例。
- en: We can see that based upon how we instantiate an object, we can specify which
    constructor we would like to be called on our behalf to perform the initialization.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，根据我们实例化对象的方式，我们可以指定我们希望代表我们调用哪个构造函数来执行初始化。
- en: 'The output for this example is:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的输出是：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next, let's add to our knowledge of constructors by examining a copy constructor.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过检查复制构造函数来增加对构造函数的了解。
- en: Creating copy constructors
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建复制构造函数
- en: A **copy constructor** is a specialized constructor that is invoked whenever
    a copy of an object may need to be made. Copy constructors may be invoked during
    the construction of another object. They may also be invoked when an object is
    passed by value to a function via an input parameter, or returned by value from
    a function.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**复制构造函数**是一种专门的构造函数，每当可能需要复制对象时就会被调用。复制构造函数可能在构造另一个对象时被调用。它们也可能在通过输入参数以值传递给函数，或者从函数中以值返回对象时被调用。'
- en: Often, it is easier to make a copy of an object and modify the copy slightly
    than to construct a new object with its individual attributes from scratch. This
    is especially true if a programmer requires a copy of an object that has undergone
    many changes during the life of the application. It may be impossible to recall
    the order of various transformations that may have been applied to the object
    in question in order to create a duplicate. Instead, having the means to copy
    an object is desirable, and possibly crucial.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，复制一个对象并稍微修改副本比从头开始构造一个新对象更容易。如果程序员需要一个经历了应用程序生命周期中的许多变化的对象的副本，这一点尤为真实。可能无法回忆起可能已应用于问题对象的各种转换的顺序，以创建一个副本。相反，拥有复制对象的手段是可取的，可能是至关重要的。
- en: The signature of a copy constructor is `ClassName::ClassName(const ClassName
    &);`. Notice that a single object is explicitly passed as a parameter, and that
    parameter will be a reference to a constant object. The copy constructor, as do
    most member functions, will receive an implicit argument to the function, the
    `this` pointer. The purpose of the copy constructor's definition will be to make
    a copy of the explicit parameter to initialize the object pointed to by `this`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 复制构造函数的签名是`ClassName::ClassName(const ClassName &);`。请注意，一个对象被显式地作为参数传递，并且该参数将是对常量对象的引用。与大多数成员函数一样，复制构造函数将接收一个隐式参数`this`指针。复制构造函数的定义目的将是复制显式参数以初始化`this`指向的对象。
- en: If no copy constructor is implemented by the `class` (or `struct`) designer,
    one will be provided for you (in the `public` access region) that performs a shallow,
    member-wise copy. This is likely not what you want if you have data members in
    your class that are pointers. Instead, the best thing to do is to write a copy
    constructor yourself, and write it to perform a deep copy (allocating memory as
    necessary) for data members that are pointers.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`class`（或`struct`）的设计者没有实现复制构造函数，系统会为您提供一个（在`public`访问区域）执行浅层成员复制的复制构造函数。如果您的类中有指针类型的数据成员，这可能不是您想要的。相反，最好的做法是自己编写一个复制构造函数，并编写它以执行深层复制（根据需要分配内存）以用于指针类型的数据成员。
- en: 'Should the programmer wish to disallow copying during construction, the keyword
    `delete` can be used in the prototype of the copy constructor as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序员希望在构造过程中禁止复制，可以在复制构造函数的原型中使用关键字`delete`，如下所示：
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Alternatively, if the programmer wishes to prohibit object copying, a copy constructor
    may be prototyped in the `private` access region. In this case, the compiler will
    link in the default copy constructor (which performs a shallow copy), but it will
    be considered private. Therefore, instantiations that would utilize the copy constructor
    outside the scope of the class will be prohibited. This technique is used less
    frequently since the advent of `=delete`; however, it may be seen in existing
    code, so it is useful to understand.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果程序员希望禁止对象复制，可以在`private`访问区域中原型化一个复制构造函数。在这种情况下，编译器将链接默认的复制构造函数（执行浅复制），但它将被视为私有。因此，在类的范围之外使用复制构造函数的实例化将被禁止。自从`=delete`出现以来，这种技术的使用频率较低；然而，它可能出现在现有代码中，因此了解它是有用的。
- en: 'Let''s examine a copy constructor, starting with the class definition. Though
    the program is presented in several fragments, the full program example may be
    found in the GitHub repository:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从类定义开始检查一个复制构造函数。尽管程序是以几个片段呈现的，完整的程序示例可以在GitHub存储库中找到：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex5.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex5.cpp)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex5.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex5.cpp)'
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this program segment, we start by defining `class Student`. Notice the usual
    assortment of `private` data members and `public` member function prototypes,
    including the default constructor and an overloaded constructor. Also notice the
    prototype for the copy constructor `Student(const Student &);`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序片段中，我们首先定义了`class Student`。请注意通常的`private`数据成员和`public`成员函数原型，包括默认构造函数和重载构造函数。还请注意复制构造函数`Student(const
    Student &);`的原型。
- en: 'Next, let''s take a look at the member function definitions with the following
    continuation of our program:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来看一下我们程序的下一部分，成员函数的定义：
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the aforementioned code fragment, we have various member function definitions.
    Most notably, let's consider the copy constructor definition, which is the member
    function with the signature of `Student::Student(const Student &s)`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们有各种成员函数的定义。特别要注意的是复制构造函数的定义，它是具有`Student::Student(const Student &s)`签名的成员函数。
- en: Notice that the input parameter, `s`, is a reference to a `Student` that is
    `const`. This means that the source object, which we will be copying from, may
    not be modified. The destination object, which we will be copying into, will be
    the object pointed to by the `this` pointer.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，输入参数`s`是一个指向`Student`的`const`引用。这意味着我们将要复制的源对象可能不会被修改。我们将要复制到的目标对象将是由`this`指针指向的对象。
- en: As we carefully navigate the copy constructor, notice that we successively allocate
    space, as necessary, for any pointer data members that belong to the object pointed
    to by `this`. The space allocated is the same size as required by the data members
    referred to by `s`. We then carefully copy from the source data member to the
    destination data member. We meticulously ensure that we make an exact copy in
    the destination object of the source object.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们仔细浏览复制构造函数时，请注意我们逐步为属于`this`指向的对象的任何指针数据成员分配空间。分配的空间与`s`引用的数据成员所需的大小相同。然后我们小心地从源数据成员复制到目标数据成员。我们确保在目标对象中对源对象进行精确复制。
- en: Notice that we are making a *deep copy* in the destination object. That is,
    rather than simply copying the pointers contained in `s.firstName` to `this->firstName`,
    for example, we instead allocate space for `this->firstName` and then copy over
    the source data. The result of a shallow copy would instead be that the pointer
    data members in each object would share the same dereferenced memory (that is,
    the memory to which each pointer points). This is most likely not what you would
    want in a copy. Also recall, the default behavior of a system-supplied copy constructor
    would be to provide a shallow copy from the source to the destination object.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在目标对象中进行了*深复制*。也就是说，我们不是简单地将`s.firstName`中包含的指针复制到`this->firstName`，而是为`this->firstName`分配空间，然后复制源数据。浅复制的结果将是每个对象中的指针数据成员共享相同的解引用内存（即，每个指针指向的内存）。这很可能不是您在复制时想要的。还要记住，系统提供的复制构造函数的默认行为是从源对象到目标对象提供浅复制。
- en: 'Now, let''s take a look at our `main()` function to see the various ways in
    which the copy constructor could be invoked:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下我们的`main()`函数，看看复制构造函数可能被调用的各种方式：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In `main()`, we declare two instances of `Student`, `s1` and `s2`, and each
    is initialized with the constructor that matches the signature of `Student::Student(const
    char *, const char *, char, float, const char *);`. Notice that the signature
    used in instantiation is how we select which constructor should be implicitly
    called.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`中，我们声明了两个`Student`的实例，`s1`和`s2`，并且每个都使用与`Student::Student(const char
    *, const char *, char, float, const char *);`签名匹配的构造函数进行初始化。请注意，实例化中使用的签名是我们选择隐式调用哪个构造函数的方式。
- en: Next, we instantiate `s3` and pass as an argument to its constructor the object
    `s1` with `Student s3(s1);`. Here, `s1` is of type `Student`, so this instantiation
    will match the constructor that accepts a reference to a `Student`, the copy constructor.
    Once in the copy constructor, we know that we will make a deep copy of `s1` to
    initialize the newly instantiated object, `s3`, which will be pointed to by the
    `this` pointer in the scope of the copy constructor method.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实例化`s3`，并将对象`s1`作为参数传递给它的构造函数，`Student s3(s1);`。在这里，`s1`是`Student`类型，因此这个实例化将匹配接受`Student`引用的构造函数，即复制构造函数。一旦进入复制构造函数，我们知道我们将对`this`指针在复制构造函数方法的范围内指向的新实例化对象`s3`进行`deep
    copy`。
- en: 'Additionally, we instantiate `s4` with the following line of code: `Student
    s4 = s2;`. Here, because this line of code is an initialization (that is, `s4`
    is both declared and given a value in the same statement), the copy constructor
    will also be invoked. The source object of the copy will be `s2` and the destination
    object will be `s4`. Notice that we then modify each of the copies (`s3` and `s4`)
    slightly by modifying their `firstName` data members.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们使用以下代码实例化`s4`：`Student s4 = s2;`。在这里，因为这行代码是一个初始化（也就是说，`s4`在同一语句中被声明并赋值），复制构造函数也将被调用。复制的源对象将是`s2`，目标对象将是`s4`。请注意，然后我们通过修改它们的`firstName`数据成员轻微修改了每个副本（`s3`和`s4`）。
- en: Next, in the commented-out section of code, we instantiate two objects of type
    `Student`, `s5` and `s6`. We then try to assign one to the other with `s5 = s6;`.
    Though this looks similar to the initialization between `s4` and `s2`, it is not.
    The line `s5 = s6;` is an assignment. Each of the objects existed previously.
    As such, the copy constructor is not called for this segment of code. Nonetheless,
    this code is legal and has similar implications as with the assignment operator.
    We will examine these details later in the book when we discuss operator overloading
    in [*Chapter 12*](B15702_12_Final_NM_ePub.xhtml#_idTextAnchor453), *Operator Overloading
    and Friends*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在代码的注释部分，我们实例化了两个`Student`类型的对象`s5`和`s6`。然后我们尝试将一个赋值给另一个`s5 = s6;`。虽然这看起来与`s4`和`s2`之间的初始化类似，但实际上并不是。行`s5
    = s6;`是一个赋值。每个对象之前都已存在。因此，复制构造函数在这段代码中不会被调用。尽管如此，这段代码是合法的，并且具有与赋值运算符类似的含义。我们将在本书后面讨论运算符重载时，详细研究这些细节[*第12章*](B15702_12_Final_NM_ePub.xhtml#_idTextAnchor453)，*运算符重载和友元*。
- en: We then print out objects `s1`, `s2`, `s3`, and `s4`. Then we call `Cleanup()`
    on each of these four objects. Why? Each object contained data members that were
    pointers, so it is appropriate to delete the heap memory contained within each
    instance (that is, selected pointer data members) prior to these outer stack objects
    going out of scope.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们打印出对象`s1`、`s2`、`s3`和`s4`。然后我们对这四个对象中的每一个调用`Cleanup()`。为什么？每个对象都包含了指针数据成员，因此在这些外部栈对象超出范围之前，删除每个实例中包含的堆内存（即选择的指针数据成员）是合适的。
- en: 'Here is the output to accompany the full program example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是完整程序示例的输出：
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The output for this example shows each original `Student` instance, paired with
    its copy. Notice that each copy has been modified slightly from the original (`firstName`
    differs).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的输出显示了每个原始的`Student`实例，以及它的副本。请注意，每个副本都与原始副本略有不同（`firstName`不同）。
- en: Related topic
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 相关主题
- en: It is interesting to note that the assignment operator shares many similarities
    with the copy constructor, in that it can allow data to be copied from a source
    to a destination instance. However, the copy constructor is implicitly invoked
    for the initialization of a new object, whereas the assignment operator will be
    invoked when performing an assignment between two existing objects. Nonetheless,
    the methods of each will look strikingly similar! We will examine overloading
    the assignment operator to customize its behavior to perform a deep assignment
    (much like a deep copy) in [*Chapter 12*](B15702_12_Final_NM_ePub.xhtml#_idTextAnchor453),
    *Friends and Operator Overloading*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，赋值运算符与复制构造函数有许多相似之处，它可以允许数据从源实例复制到目标实例。然而，复制构造函数在初始化新对象时会被隐式调用，而赋值运算符在执行两个现有对象之间的赋值时会被调用。尽管如此，它们的方法看起来非常相似！我们将在[*第12章*](B15702_12_Final_NM_ePub.xhtml#_idTextAnchor453)中研究重载赋值运算符，以定制其行为以执行深度赋值（类似于深复制），*友元和运算符重载*。
- en: Now that we have a deep understanding of copy constructors, let's look at one
    last variety of constructor, the conversion constructor.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对复制构造函数有了深入的了解，让我们来看看最后一种构造函数的变体，转换构造函数。
- en: Creating conversion constructors
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建转换构造函数
- en: Type conversions can be performed from one user defined type to another, or
    from a standard type to a user defined type. A conversion constructor is a language
    mechanism that allows such conversions to occur.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换可以从一个用户定义的类型转换为另一个用户定义的类型，或者从标准类型转换为用户定义的类型。转换构造函数是一种语言机制，允许这种转换发生。
- en: A **conversion constructor** is a constructor that accepts one explicit argument
    of a standard or user defined type, and applies a reasonable conversion or transformation
    on that object to initialize the object being instantiated.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**转换构造函数**是一个接受标准或用户定义类型的一个显式参数，并对该对象应用合理的转换或转换以初始化正在实例化的对象的构造函数。'
- en: 'Let''s take a look at an example illustrating this idea. Though the example
    will be broken into several segments and also abbreviated, the full program can
    be found in the GitHub repository:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个说明这个想法的例子。虽然例子将被分成几个片段并且也有所缩写，完整的程序可以在GitHub存储库中找到：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex6.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex6.cpp)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex6.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex6.cpp)'
- en: '[PRE19]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the previous program segment, we first include a forward declaration to `class
    Student;`—this declaration allows us to refer to the `Student` type prior to its
    definition. We then define `class Employee`. Notice that this class includes several
    `public` data members and three constructor prototypes – a default, alternative,
    and conversion constructor. As a side note, notice that a copy constructor has
    not been programmer-specified. This means that a default (shallow) copy constructor
    will be provided by the compiler. In this case, since there are no pointer data
    members, the shallow copy is acceptable.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序片段中，我们首先包含了对`class Student;`的前向声明——这个声明允许我们在定义之前引用`Student`类型。然后我们定义`class
    Employee`。请注意，这个类包括几个`public`数据成员和三个构造函数原型——默认、替代和转换构造函数。值得一提的是，没有程序员指定的复制构造函数。这意味着编译器将提供默认（浅）复制构造函数。在这种情况下，由于没有指针数据成员，浅复制是可以接受的。
- en: Nonetheless, let us continue by examining the conversion constructor prototype.
    Notice that in the prototype, this constructor takes a single argument. The argument
    is a `Student &`, which is why we needed the forward declaration for `Student`.
    Preferably, we might use a `const Student &` as the parameter type, but we will
    need to understand const member functions (later in this chapter) in order to
    do so. The type conversion that will take place will be to convert a `Student`
    into a newly constructed `Employee`. It will be our job to provide a meaningful
    conversion to accomplish this in the definition for the conversion constructor,
    which we will see shortly.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，让我们继续通过检查转换构造函数的原型来进行。请注意，在原型中，这个构造函数接受一个参数。这个参数是`Student &`，这就是为什么我们需要对`Student`进行前向声明。最好的情况下，我们可能会使用`const
    Student &`作为参数类型，但为了这样做，我们需要了解const成员函数（本章后面会介绍）。将发生的类型转换将是将`Student`转换为新构造的`Employee`。我们的工作是在转换构造函数的定义中提供一个有意义的转换来实现这一点，我们很快就会看到。
- en: Next, we define our `Student` class, which is much the same as we have seen
    in previous examples.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义我们的`Student`类，它与我们在以前的示例中看到的大致相同。
- en: Now, let us continue with the example to see the member function definitions
    for `Employee` and `Student`, and our `main()` function, in the following code
    segment. To conserve space, selected member function definitions will be omitted;
    however, the online code will show the program in its entirety.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续以示例来看`Employee`和`Student`的成员函数定义，以及我们的`main()`函数，在以下代码段中。为了节省空间，选择性地省略了一些成员函数定义；然而，在在线代码中将显示完整的程序。
- en: 'Moving onward, our member functions for `Employee` and `Student` are as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进，我们的`Employee`和`Student`的成员函数如下：
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the previous segment of code, we notice several constructor definitions for
    `Employee`. We have a default, alternate, and conversion constructor.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码段中，我们注意到了`Employee`的几个构造函数定义。我们有默认、替代和转换构造函数。
- en: Examining the definition of the `Employee` conversion constructor, notice that
    the formal parameter for the source object is `s`, which is of type `Student`.
    The destination object will be the `Employee` that is being constructed, which
    will be pointed to by the `this` pointer. In the body of this function, we carefully
    copy the `firstName` and `lastName` from `Student &s` to the newly instantiated
    `Employee`. Note that we used the access functions `const char *Student::GetFirstName()`
    and `const char *Student::GetLastName()` to do so (via an instance of `Student`)
    as these data members were `private`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`Employee`转换构造函数的定义，注意源对象的形式参数是`s`，类型为`Student`。目标对象将是正在构造的`Employee`，它将由`this`指针指向。在这个函数的主体中，我们仔细地从`Student
    &s`复制`firstName`和`lastName`到新实例化的`Employee`。请注意，我们使用了访问函数`const char *Student::GetFirstName()`和`const
    char *Student::GetLastName()`来做到这一点（通过`Student`的一个实例），因为这些数据成员是`private`的。
- en: Let's continue with the conversion constructor. It is our job to provide a meaningful
    conversion from one type to another. In that endeavor, we try to establish an
    initial salary for the `Employee` based on the `gpa` of the source `Student` object.
    Because `gpa` is `private`, an access function, `Student::GetGpa()`, is used to
    retrieve this value (via the source `Student`). Notice that because `Employee`
    did not have any dynamically allocated data members, we did not need to allocate
    memory to assist in a deep copy in the body of this function.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用转换构造函数。我们的工作是提供一种有意义的从一种类型到另一种类型的转换。在这个努力中，我们试图根据源`Student`对象的`gpa`来为`Employee`建立一个初始工资。因为`gpa`是`private`的，所以使用访问函数`Student::GetGpa()`来检索这个值（通过源`Student`）。请注意，因为`Employee`没有任何动态分配的数据成员，所以我们不需要在这个函数的主体中分配内存来辅助深度复制。
- en: To conserve space, the member function definitions for the `Student` default,
    alternate, and copy constructor have been omitted, as have the definitions for
    the `void Student::Print()` and `void Student::CleanUp()` member functions. However,
    they are the same as in the previous full program example illustrating the `Student`
    class.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间，已省略了`Student`默认、替代和复制构造函数的成员函数定义，以及`void Student::Print()`和`void Student::CleanUp()`成员函数的定义。然而，它们与之前展示`Student`类的完整程序示例中的相同。
- en: Notice that access functions for `private` data members in `Student`, such as
    `float Student::GetGpa()`, have been added to provide safe access to those data
    members. Note that the value returned from `float Student::GetGpa()` on the stack
    is a copy of the `gpa` data member. The original `gpa` is in no worry of being
    breached by the use of this function. The same applies for the member functions
    `const char *Student::GetFirstName()` and `const char *Student::GetLastName()`,
    which each returns a `const char *`, ensuring that the data that will be returned
    will not be breached.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`Student`中`private`数据成员的访问函数，比如`float Student::GetGpa()`，已经被添加以提供对这些数据成员的安全访问。请注意，从堆栈返回的`float
    Student::GetGpa()`的值是`gpa`数据成员的副本。原始的`gpa`不会因为使用这个函数而受到侵犯。对于成员函数`const char *Student::GetFirstName()`和`const
    char *Student::GetLastName()`也是一样，它们每个都返回一个`const char *`，确保将返回的数据不会被侵犯。
- en: 'Let''s complete our program by examining our `main()` function:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过检查我们的`main()`函数来完成我们的程序：
- en: '[PRE21]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In our `main()` function, we instantiate a `Student`, namely `s1`, which is
    implicitly initialized with the matching constructor. Then we instantiate an `Employee`,
    `e1`, using the conversion constructor in the call `Employee e1(s1);`. At a quick
    glance, it may seem that we are utilizing the `Employee` copy constructor. But,
    at a closer look, we notice that the actual parameter `s1` is of type `Student`,
    not `Employee`. Hence, we are using `Student s1` as a basis to initialize `Employee
    e1`. Note that in no manner is the `Student`, `s1`, harmed or altered in this
    conversion. For this reason, it would be preferable to define the source object
    as a `const Student &` in the formal parameter list; once we understand const
    member functions, which will then be required for usage in the body of the conversion
    constructor, we can do so.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main()`函数中，我们实例化了一个`Student`，即`s1`，它隐式地使用匹配的构造函数进行初始化。然后我们使用转换构造函数实例化了一个`Employee`，`e1`，在调用`Employee
    e1(s1);`时。乍一看，似乎我们正在使用`Employee`的复制构造函数。但是，仔细观察，我们注意到实际参数`s1`的类型是`Student`，而不是`Employee`。因此，我们使用`Student
    s1`作为初始化`Employee e1`的基础。请注意，在这种转换中，`Student` `s1`并没有受到任何伤害或改变。因此，最好将源对象定义为形式参数列表中的`const
    Student＆`；一旦我们理解了const成员函数，这将成为转换构造函数体中所需的内容，我们就可以这样做。
- en: To conclude this program, we print out the `Employee` using `Employee::Print()`,
    which enables us to visualize the conversion we applied for a `Student` to an
    `Employee`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个程序，我们使用`Employee::Print()`打印出`Employee`，这使我们能够可视化我们对`Student`到`Employee`的转换。
- en: 'Here is the output to accompany our example:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们示例的输出：
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Before we move forward, there's one final, subtle detail about conversion constructors
    that is very important to understand.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，有一个关于转换构造函数的最后一个微妙细节非常重要，需要理解。
- en: Important note
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Any constructor that takes a single argument is considered a conversion constructor,
    which can potentially be used to convert the parameter type to the object type
    of the class to which it belongs. For example, if you have a constructor in the
    `Student` class that takes only a float, this constructor could be employed not
    only in the manner shown in the example above, but also in places where an argument
    of type `Student` is expected (such as a function call) when an argument of type
    float is instead supplied. This may not be what you intend, which is why this
    interesting feature is being called out. If you don't want implicit conversions
    to take place, you can disable this behavior by declaring the constructor with
    the `explicit` keyword at the beginning of its prototype.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 任何只带有一个参数的构造函数都被视为转换构造函数，它可能被用来将参数类型转换为它所属的类的对象类型。例如，如果`Student`类中有一个只接受float的构造函数，这个构造函数不仅可以像上面的示例那样使用，还可以在期望`Student`类型的参数（例如函数调用）的地方使用，而实际提供的是float类型的参数。这可能不是您的意图，这就是为什么要提出这个有趣的特性。如果您不希望进行隐式转换，可以通过在其原型的开头声明带有`explicit`关键字的构造函数来禁用此行为。
- en: Now that we understand basic, alternative, copy, and conversion constructors
    in C++, let's move forward and explore the constructor's complementary member
    function, the C++ destructor.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了C++中的基本、替代、复制和转换构造函数，让我们继续探索构造函数的补充成员函数，C++析构函数。
- en: Understanding destructors
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解析构函数
- en: Can you recall how conveniently a class constructor provides us with a way to
    initialize a newly instantiated object? Rather than having to remember to call
    an `Initialize()` method for each instance of a given type, the constructor allows
    initialization automatically. The signature used in construction helps specify
    which of a series of constructors should be used.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否还记得类构造函数多么方便地为我们提供了初始化新实例对象的方法？而不是必须记住为给定类型的每个实例调用`Initialize()`方法，构造函数允许自动初始化。在构造中使用的签名有助于指定应使用一系列构造函数中的哪一个。
- en: What about object clean-up? Many classes contain dynamically allocated data
    members that are often allocated in a constructor. Shouldn't the memory comprising
    these data members be released when the programmer is done with an instance? Certainly.
    We have written a `CleanUp()` member function for several of our example programs.
    And we have remembered to call `CleanUp()`. Conveniently, similar to a constructor,
    C++ has an automatically built-in feature to serve as a clean-up function. This
    function is known as the destructor.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对象清理呢？许多类包含动态分配的数据成员，这些数据成员通常在构造函数中分配。当程序员完成实例后，组成这些数据成员的内存不应该被释放吗？当然。我们为几个示例程序编写了`CleanUp()`成员函数。并且我们记得调用`CleanUp()`。方便的是，与构造函数类似，C++具有一个自动内置的功能作为清理函数。这个函数被称为析构函数。
- en: Let's look at the destructor to understand its proper usage.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看析构函数以了解其正确的使用方法。
- en: Applying destructor basics and proper usage
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用析构函数的基础知识和正确使用
- en: 'A **destructor** is a member function whose purpose is to relinquish the resources
    an object may have acquired during its existence. A destructor is automatically
    invoked when a class or struct instance either:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**析构函数**是一个成员函数，其目的是释放对象在其存在期间可能获取的资源。当类或结构实例：'
- en: Goes out of scope (this applies to non-pointer variables)
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超出范围（这适用于非指针变量）
- en: Is explicitly deallocated using delete (for pointers to objects)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式使用delete进行释放（对于对象指针）
- en: A destructor should (most often) clean up any memory that may have been allocated
    by the constructor. The destructor's name is a `~` character followed by the `class`
    name. A destructor will have no arguments; therefore, it cannot be overloaded.
    Lastly, the return type for a destructor may not be specified. Both classes and
    structures may have destructors.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数应该（通常）清理构造函数可能分配的任何内存。析构函数的名称是`~`字符后跟`class`名称。析构函数不带参数；因此，它不能被重载。最后，析构函数的返回类型可能不被指定。类和结构都可以有析构函数。
- en: In addition to deallocating memory a constructor may have allocated, a destructor
    may be used to perform other end-of-life tasks for an instance, such as logging
    a value to a database. More complex tasks may include informing objects pointed
    to by class data members (whose memory is not being released) that the object
    at hand will be concluding. This may be important if the linked object contains
    a pointer back to the terminating object. We will see examples of this later in
    the book, in [*Chapter 10*](B15702_10_Final_NM_ePub.xhtml#_idTextAnchor386), *Implementing
    Association, Aggregation, and Composition*.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 除了释放构造函数可能分配的内存之外，析构函数还可以用于执行实例的其他生命周期任务，例如将值记录到数据库中。更复杂的任务可能包括通知类数据成员指向的对象（其内存未被释放）即将结束的对象。如果链接的对象包含指向终止对象的指针，则这可能很重要。我们将在本书的后面看到这方面的例子，在[*第10章*](B15702_10_Final_NM_ePub.xhtml#_idTextAnchor386)，*实现关联、聚合和组合*。
- en: If you have not provided a destructor, the compiler will create and link in
    a `public` destructor with an empty body. This is necessary because a destructor
    call is automatically patched in just prior to the point when local instances
    are popped off the stack, and just prior to `delete()` being applied to dynamically
    allocated instances. It is easier for the compiler to always patch in this call,
    rather than constantly look to see if your class has a destructor or not. A good
    rule of thumb is to always provide a class destructor yourself.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有提供析构函数，编译器将创建并链接一个带空体的`public`析构函数。这是必要的，因为析构函数调用会在本地实例被弹出堆栈之前自动打补丁，并且在应用`delete()`到动态分配的实例之前自动打补丁。对于编译器来说，总是打补丁比不断查看您的类是否有析构函数更容易。一个好的经验法则是始终自己提供类析构函数。
- en: There are some potential pitfalls. For example, if you forget to delete a dynamically
    allocated instance, the destructor call will not be patched in for you. C++ is
    a language that gives you the flexibility and power to do (or not do) anything.
    If you do not delete memory using a given identifier (perhaps two pointers refer
    to the same memory), please remember to delete it through the other identifier
    at a later date.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些潜在的陷阱。例如，如果您忘记删除动态分配的实例，那么析构函数调用将不会为您打补丁。C++是一种给予您灵活性和权力来做（或不做）任何事情的语言。如果您不使用给定标识符删除内存（也许两个指针引用相同的内存），请记住以后通过其他标识符删除它。
- en: There's one last item worth mentioning. Though you may call a destructor explicitly,
    you will rarely ever need to do so. Destructor calls are implicitly patched in
    by the compiler on your behalf in the aforementioned scenarios. Only in very few
    advanced programming situations will you need to explicitly call a destructor
    yourself.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件值得一提的事情。虽然您可以显式调用析构函数，但您很少需要这样做。析构函数调用会在编译器自动为您打补丁在上述情况下。只有在非常少数的高级编程情况下，您才需要自己显式调用析构函数。
- en: 'Let''s take a look at a simple example illustrating a class destructor, which
    will be broken into three segments. Its full example can be seen in the GitHub
    repository listed here:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子，说明一个类析构函数，它将被分为三个部分。完整的示例可以在此处列出的GitHub存储库中看到：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex7.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex7.cpp)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex7.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex7.cpp)'
- en: '[PRE23]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the previous segment of code, we first define `class University`. Notice
    the `private` access region filled with data members, and the `public` interface,
    which includes prototypes for a default, alternate, and copy constructor, as well
    as for the destructor and a `Print()` method.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一段代码中，我们首先定义了`class University`。请注意`private`访问区域中填充了数据成员，以及`public`接口，其中包括默认、替代和复制构造函数的原型，以及析构函数和`Print()`方法。
- en: 'Next, let''s take a look at the various member function definitions:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下各种成员函数的定义：
- en: '[PRE24]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the aforementioned code fragment, we see the various overloaded constructors
    we are now accustomed to seeing, plus `void University::Print()`. The new addition
    is the destructor definition.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们看到了我们现在习惯于看到的各种重载构造函数，以及`void University::Print()`。新添加的是析构函数定义。
- en: Notice the destructor `University::~University()` takes no arguments; it may
    not be overloaded. The destructor simply deallocates memory that may have been
    allocated in any of the constructors. Note that we simply `delete name;`, which
    will work whether `name` points to a valid address or contains a null pointer
    (yes, applying delete to a null pointer is OK). We additionally print the `this`
    pointer in the destructor, just for fun, so that we can see the address of the
    instance that is approaching non-existence.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意析构函数`University::~University()`不带参数；它可能不会被重载。析构函数只是释放可能在任何构造函数中分配的内存。请注意，我们只是`delete
    name;`，无论`name`指向有效地址还是包含空指针（是的，将delete应用于空指针是可以的）。此外，我们在析构函数中打印`this`指针，只是为了好玩，这样我们就可以看到即将不存在的实例的地址。
- en: 'Next, let''s take a look at `main()` to see when the destructor may be called:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下`main()`，看看何时可能调用析构函数：
- en: '[PRE25]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we instantiate two `University` instances; `u1` is an instance and `u2`
    points to an instance. We know that `u2` is instantiated when its memory becomes
    available with `new()`, and that once the memory has become available, the appliable
    constructor is called. Next, we call `University::Print()` for both instances
    to have some output.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们实例化了两个`University`实例；`u1`是一个实例，`u2`指向一个实例。我们知道`u2`在其内存可用时被实例化，并且一旦内存可用，就会调用适用的构造函数。接下来，我们为两个实例调用`University::Print()`以获得一些输出。
- en: Finally, toward the end of `main()`, we delete `u2` to return this memory to
    the heap management facility. Just prior to the call to `delete()`, C++ will patch
    in a call to the destructor for the object pointed to by `u2`. It is as if a secret
    function call, `u2->~University();`, has been patched in prior to `delete u2;`
    (note, this is done automatically; no need for you to do so as well). The implicit
    call to the destructor will delete the memory that may have been allocated for
    any data members within the class. The memory release is now complete for `u2`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`main()`的末尾，我们删除`u2`，将这块内存返回给堆管理设施。就在调用`delete()`之前，C++会插入一个调用`u2`指向的对象的析构函数的指令。就好像在`delete
    u2;`之前，一个秘密的函数调用`u2->~University();`已经被插入了一样（注意，这是自动完成的；你不需要自己这样做）。隐式调用析构函数将删除类中可能已经分配的任何数据成员的内存。现在，对于`u2`，内存释放已经完成。
- en: What about instance `u1`? Will its destructor be called? Yes; `u1` is a stack
    instance. Just prior to its memory being popped off the stack in `main()`, the
    compiler will have patched in a call to its destructor, as if the call `u1.~University();`
    was added on your behalf (again, no need to do so yourself). For instance `u1`,
    the destructor will also deallocate any memory for data members that may have
    been allocated. Likewise, the memory release is now complete for `u1`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 那么实例`u1`呢？它的析构函数会被调用吗？会的；`u1`是一个栈实例。在`main()`中，就在其内存被弹出栈之前，编译器会插入一个调用其析构函数的指令，就好像为你添加了`u1.~University();`的调用一样（同样，你不需要自己这样做）。对于实例`u1`，析构函数也会释放为数据成员分配的任何内存。同样，对于`u1`，内存释放现在已经完成。
- en: Notice that in each destructor call, we have printed a message to illustrate
    when the destructor is called, and have also printed out the memory address for
    `this` to allow you to visualize each specific instance as it is destructed.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在每次析构函数调用时，我们都打印了一条消息，以说明析构函数何时被调用，并且还打印了`this`的内存地址，以便让你在每个特定的实例被析构时进行可视化。
- en: 'Here is the output to accompany our full program example:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们完整程序示例的输出：
- en: '[PRE26]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With this example, we have now examined the destructor, the complement to the
    series of class constructors. Let us move on to another set of useful topics relating
    to classes: various keyword qualifications of data members and member functions.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个例子，我们现在已经检查了析构函数，这是一系列类构造函数的补充。让我们继续讨论与类相关的另一组有用主题：数据成员和成员函数的各种关键字资格。
- en: Applying qualifiers to data members and member functions
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对数据成员和成员函数应用限定符
- en: In this section, we will investigate qualifiers that can be added to both data
    members and member functions. The various qualifiers – `inline`, `const`, and
    `static` – can support program efficiency, aid in keeping private data members
    safe, support encapsulation and information hiding, and additionally be used to
    implement various object-oriented concepts.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将调查可以添加到数据成员和成员函数的限定符。各种限定符——`inline`、`const`和`static`——可以支持程序的效率，帮助保持私有数据成员的安全，支持封装和信息隐藏，并且还可以用于实现各种面向对象的概念。
- en: Let's get started with the various types of member qualifications.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始了解各种成员资格的类型。
- en: Adding inline functions for potential efficiency
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为了提高效率添加内联函数
- en: Imagine a set of short member functions in your program that are repeatedly
    called by various instances. As an object-oriented programmer, you appreciate
    using a `public` member function to provide safe and controlled access to `private`
    data. However, for very short functions, you worry about efficiency, that is,
    the overhead of calling a small function repeatedly. Certainly, it would be more
    efficient to just paste in the two or three lines of code comprising the function.
    Yet, you resist because that may mean providing `public` access to otherwise hidden
    class information, such as data members, which you are hesitant to do. An `inline`
    function can solve this dilemma, allowing you to have the safety of a member function
    to access and manipulate your private data, yet the efficiency of executing several
    lines of code without the overhead of a function call.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你的程序中有一组短的成员函数，它们会被各种实例重复调用。作为一个面向对象的程序员，你喜欢使用`public`成员函数来提供对`private`数据的安全和受控访问。然而，对于非常短的函数，你担心效率问题，也就是说，重复调用一个小函数会带来开销。当然，直接粘贴包含函数的两三行代码会更有效率。但是，你会抵制这样做，因为这可能意味着提供对本来隐藏的类信息（如数据成员）的`public`访问，这是你不愿意做的。内联函数可以解决这个困境，它允许你拥有一个成员函数来访问和操作你的私有数据的安全性，同时又能够执行几行代码而不需要函数调用的开销。
- en: An **inline** function is a function whose invocation is substituted with the
    body of the function itself. Inline functions can help eliminate the overhead
    associated with calling very small functions.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**inline**函数是一个其调用被替换为函数本身的函数。内联函数可以帮助消除调用非常小的函数所带来的开销。'
- en: Why would calling a function have overhead? When a function is called, input
    parameters (including `this`) are pushed onto the stack, space is reserved for
    a return value of the function (though sometimes registers are used), moving to
    another section of code requires storing information in registers to jump to that
    section of code, and so on. Replacing very small function bodies with inline functions
    can add to the program efficiency.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么调用函数会有开销？当调用函数时，输入参数（包括`this`）被推送到栈上，为函数的返回值保留空间（尽管有时会使用寄存器），转移到代码的另一个部分需要在寄存器中存储信息以跳转到代码的那一部分，等等。用内联函数替换非常小的函数体可以提高程序的效率。
- en: 'An inline function may be specified by either:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 内联函数可以通过以下方式之一指定：
- en: Placing the function definition inside the class definition
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数定义放在类定义内部
- en: Placing the keyword `inline` prior to the return type in the (typical) function
    definition, found outside the class definition.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在（典型的）函数定义中，在类定义之外找到关键字“inline”之前的返回类型。
- en: Specifying a function as `inline` in one of the aforementioned two fashions
    is merely a request to the compiler to consider the substitution of the function
    body for its function call. This substitution is not guaranteed. When might the
    compiler not actually inline a given function? If a function is recursive, it
    cannot be made `inline`. Likewise, if a function is lengthy, the compiler will
    not inline the function. Also, if the function call is dynamically bound with
    the specific implementation determined at runtime (virtual functions), it cannot
    be made `inline`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述两种方式中将函数指定为`inline`只是一个请求，要求编译器考虑将函数体替换为其函数调用。这种替换不能保证。编译器何时可能不实际内联给定的函数？如果一个函数是递归的，它就不能被内联。同样，如果一个函数很长，编译器就不会内联这个函数。此外，如果函数调用是动态绑定的，具体实现在运行时确定（虚函数），它就不能被内联。
- en: An `inline` function definition should be declared in the header file with the
    corresponding class definition. This will allow any revisions to the function
    to be re-expanded correctly should the need arise.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`inline`函数定义应该在头文件中与相应的类定义一起声明。这将允许对函数的任何修订在需要时重新扩展正确。'
- en: 'Let''s see an example using `inline` functions. The program will be broken
    into two segments, with some well-known functions removed. However, the full program
    may be seen in the GitHub repository:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用`inline`函数的例子。程序将被分成两个部分，其中一些众所周知的函数被移除。然而，完整的程序可以在GitHub存储库中看到：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex8.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex8.cpp)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex8.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex8.cpp)'
- en: '[PRE27]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the previous program fragment, let's start with the class definition. Notice
    that several access function definitions have been added in the class definition
    itself, namely, functions such as `GetFirstName()`, `GetLastName()`, and so on.
    Look closely; these functions are actually defined within the class definition.
    For example, `float GetGpa() { return gpa; }` is not just the prototype, but the
    full function definition. By virtue of the function placement within the class
    definition, functions such as these are considered `inline`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序片段中，让我们从类定义开始。注意，在类定义中已经添加了几个访问函数定义，即`GetFirstName()`、`GetLastName()`等函数。仔细看；这些函数实际上是在类定义内部定义的。例如，`float
    GetGpa() { return gpa; }`不仅仅是原型，而是完整的函数定义。由于函数放置在类定义内部，这样的函数被认为是`inline`。
- en: These small functions provide safe access to private data members. Notice `const
    char *GetFirstName()`, for example. This function returns a pointer to `firstName`,
    which is stored in the class as a `char *`. But because the return value of this
    function is a `const char *`, this means that anyone calling this function must
    treat the return value as a `const char *`, which means treating it as unmodifiable.
    Should this function's return value be stored in a variable, that variable must
    also be defined as `const char *`. By upcasting this pointer to an unmodifiable
    version of itself with the return value, we are adding the provision that no one
    can get their hands on a `private` data member (which is a pointer) and then change
    its value.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这些小函数提供了对私有数据成员的安全访问。例如，注意`const char *GetFirstName()`。这个函数返回一个指向`firstName`的指针，它在类中存储为`char
    *`。但是因为这个函数的返回值是`const char *`，这意味着调用这个函数的任何人都必须将返回值视为`const char *`，这意味着将其视为不可修改。如果这个函数的返回值被存储在一个变量中，那么这个变量也必须被定义为`const
    char *`。通过将这个指针向上转换为不可修改版本的自身，我们添加了一个规定，即没有人可以得到一个`private`数据成员（指针），然后改变它的值。
- en: Now notice toward the end of the class definition, we have a prototype for `void
    SetCurrentCourse(const char *);`. Then, outside of this class definition, we will
    see the definition for this member function. Notice the keyword `inline` prior
    to the `void` return type of this function definition. The keyword must be explicitly
    used here since the function is defined outside of the class definition. Remember,
    with either style of `inline` designation for a method, the `inline` specification
    is merely a request to the compiler to make the substitution of function body
    for function call.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在注意一下类定义的末尾，我们有一个`void SetCurrentCourse(const char *);`的原型。然后，在类定义之外，我们将看到这个成员函数的定义。注意在这个函数定义的`void`返回类型之前有关键字`inline`。由于这个函数是在类定义之外定义的，必须明确使用关键字。请记住，无论使用哪种`inline`方法，`inline`规范只是一个请求，要求编译器将函数体替换为函数调用。
- en: 'Let''s continue this example by examining the remainder of our program:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续通过检查我们程序的其余部分来继续这个例子：
- en: '[PRE28]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice that in the remainder of our program example, several member function
    definitions have been omitted. The bodies of these functions are identical to
    the previous example illustrating a `Student` class in full, and can also be viewed
    online.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在我们的程序示例的其余部分中，省略了几个成员函数定义。这些函数的主体与前面的示例中完整展示了`Student`类的函数体相同，也可以在线查看。
- en: Let's focus instead on our `main()` function. Here, we instantiate a `Student`,
    namely `s1`. We then invoke several `inline` function calls via `s1`, such as
    `s1.GetFirstName();`. Because `Student::GetFirstName()` is inline, it is as if
    we are accessing the data member `firstName` directly, as the body of this function
    merely has a `return firstName;` statement. We have the safety of using a function
    to access a `private` data member (meaning that no one can modify this data member
    outside the scope of the class), but the speed of an `inline` function's code
    expansion to eliminate the overhead of a function call.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转而关注我们的`main()`函数。在这里，我们实例化了一个`Student`，名为`s1`。然后通过`s1`调用了几个`inline`函数，比如`s1.GetFirstName();`。因为`Student::GetFirstName()`是内联的，所以就好像我们直接访问数据成员`firstName`一样，因为这个函数的主体只有一个`return
    firstName;`语句。我们既可以使用函数来访问`private`数据成员（意味着在类的范围之外没有人可以修改这个数据成员），又可以使用`inline`函数的代码扩展来消除函数调用的开销。
- en: Throughout `main()`, we make several other calls to `inline` functions in this
    same manner, including `s1.SetCurrentCourse();`. We now have the safety of encapsulated
    access with the speed of direct access to data members using small `inline` functions.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`中，我们以相同的方式对`inline`函数进行了几次调用，包括`s1.SetCurrentCourse();`。现在我们既有封装访问的安全性，又可以使用小型的`inline`函数直接访问数据成员，从而提高速度。
- en: 'Here is the output to accompany our full program example:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们完整程序示例的输出：
- en: '[PRE29]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Let's now move onward by investigating another qualifier we can add to class
    members, the `const` qualifier.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续探讨我们可以添加到类成员的另一个限定符，即`const`限定符。
- en: Adding const data members and the member initialization list
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加const数据成员和成员初始化列表
- en: We have already seen earlier in this book how to constant-qualify variables
    and the implications of doing so. To briefly recap, the implication of adding
    a `const` qualifier to a variable is that the variable must be initialized when
    it is declared, and that its value may never again be modified. We previously
    also saw how to add `const` qualification to pointers, such that we could qualify
    the data being pointed to, the pointer itself, or both. Let us now examine what
    it means to add a `const` qualifier to data members within a class, and learn
    about specific language mechanisms that must be employed to initialize those data
    members.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前面，我们已经看到了如何对变量进行常量限定以及这样做的影响。简而言之，向变量添加`const`限定符的含义是变量在声明时必须被初始化，并且其值可能永远不会被修改。我们之前还看到了如何向指针添加`const`限定，以便我们可以对被指向的数据、指针本身或两者都进行限定。现在让我们来看看向类内的数据成员添加`const`限定符意味着什么，以及了解必须使用的特定语言机制来初始化这些数据成员。
- en: Data members that should never be modified should be qualified as `const`. A
    `const` variables, *never modified* means that the data member may not be modified
    using its own identifier. It will then be our job to ensure that we do not initialize
    our data members that are pointers to `const` objects, with objects that are not
    labeled as `const` (lest we provide a backdoor to change our private data).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不应该被修改的数据成员应该被限定为`const`。一个`const`变量，*永远不会被修改*意味着该数据成员不能使用自己的标识符进行修改。那么我们的工作就是确保我们不会用非`const`标记的对象初始化我们的指向`const`对象的数据成员（以免为修改私有数据提供后门）。
- en: Keep in mind that in C++, a programmer can always cast the const-ness away from
    a pointer variable. Not that they should. Nonetheless, we will employ safety measures
    to ensure that by using access regions and appropriate return values from access
    functions, we do not easily provide modifiable access to our `private` data members.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在C++中，程序员总是可以将指针变量的const性质去除。尽管他们不应该这样做。尽管如此，我们将采取安全措施，确保通过使用访问区域和从访问函数返回适当的值，我们不会轻易提供对`private`数据成员的可修改访问。
- en: The **member initialization list** must be used in a constructor to initialize
    any data members that are constant, or that are references. A member initialization
    list offers a mechanism to initialize data members that may never be l-values
    in an assignment. A member initialization list may also be used to initialize
    non-const data members. For performance reasons, the member initialization list
    is most often the preferred way to initialize any data member (const or non-const).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员初始化列表**必须在构造函数中用于初始化任何常量数据成员或引用。成员初始化列表提供了一种机制，用于初始化可能永远不会成为赋值的l-values的数据成员。成员初始化列表也可以用于初始化非const数据成员。出于性能原因，成员初始化列表通常是初始化任何数据成员（const或非const）的首选方式。'
- en: 'A member initialization list may appear in any constructor, and to indicate
    this list, simply place a `:` after the formal parameter list, followed by a comma-separated
    list of data members, paired with the initial value for each data member in parentheses.
    For example, here we use the member initialization list to set two data members,
    `studentId` and `gpa`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 成员初始化列表可以出现在任何构造函数中，只需在形式参数列表后面放置一个`:`，然后是一个逗号分隔的数据成员列表，每个数据成员都与括号中的初始值配对。例如，在这里我们使用成员初始化列表来设置两个数据成员，`studentId`和`gpa`：
- en: '[PRE30]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It is interesting to note that a reference must use the member initialization
    list because references are implemented as constant pointers. That is, the pointer
    itself points to a specific other object and may not point elsewhere. The values
    of that object may change, but the reference always references a specific object,
    the one in which it was initialized.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，引用必须使用成员初始化列表，因为引用被实现为常量指针。也就是说，指针本身指向特定的其他对象，不得指向其他地方。该对象的值可能会改变，但引用始终引用特定的对象，即初始化时的对象。
- en: Using `const` qualification with pointers can be tricky to determine which scenarios
    require initialization with this list, and which do not. For example, a pointer
    to a constant object does not need to be initialized with the member initialization
    list. The pointer could point to any object, but once it does, it may not change
    the referenced value. However, a constant pointer must be initialized with the
    member initialization list because the pointer itself is fixed to a specific address.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 使用指针与`const`限定符可能会让人难以确定哪些情况需要使用初始化列表，哪些情况不需要。例如，指向常量对象的指针不需要使用成员初始化列表进行初始化。指针可以指向任何对象，但一旦指向对象后，就不能改变所引用的值。然而，常量指针必须使用成员初始化列表进行初始化，因为指针本身被固定在特定的地址上。
- en: 'Let''s take a look at a `const` data member and how to use the member initialization
    list to initialize its value in a full program example. We will also see how to
    use this list to initialize non-const data members. Though this example is segmented
    and not shown in its entirety, the full program can be found in the GitHub repository:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个`const`数据成员的例子，以及如何使用成员初始化列表在完整的程序示例中初始化它的值。我们还将看到如何使用这个列表来初始化非const数据成员。虽然这个例子被分割并没有完整显示，但完整的程序可以在GitHub存储库中找到：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex9.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex9.cpp)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex9.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex9.cpp)'
- en: '[PRE31]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the aforesaid `Student` class, notice that we have added a data member, `const
    int studentId;`, to the class definition. This data member will require the use
    of the member initialization list to initialize this constant data member in each
    of the constructors.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述的`Student`类中，注意我们已经在类定义中添加了一个数据成员`const int studentId;`。这个数据成员将需要使用成员初始化列表来初始化每个构造函数中的这个常量数据成员。
- en: 'Let''s take a look at how the use of the member initialization list will work
    with constructors:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看成员初始化列表如何在构造函数中工作：
- en: '[PRE32]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the above code fragment, we see three `Student` constructors. Notice the
    various member initialization lists, designated by a `:` after the formal parameter
    list for each of the three constructors.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们看到了三个`Student`构造函数。注意每个构造函数的形式参数列表后面都有一个`:`指定的各种成员初始化列表。
- en: 'Each constructor will make use of the member initialization list to set the
    values of data members that are `const`, such as `studentId`. Additionally, the
    member initialization list can be used as a simple way to initialize any other
    data member. We can see examples of the member initialization list being used
    to simply set non-const data members by viewing the member initialization list
    in either default or alternate constructor, for example, `Student::Student() :
    studentId(0), gpa(0.0)`. In this example, `gpa` is not `const`, so its use in
    the member initialization list is optional.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '每个构造函数将使用成员初始化列表来设置`const`数据成员的值，比如`studentId`。此外，成员初始化列表可以作为一种简单的方式来初始化任何其他数据成员。我们可以通过查看默认或替代构造函数中的成员初始化列表来看到成员初始化列表被用来简单地设置非const数据成员的例子，例如`Student::Student()
    : studentId(0), gpa(0.0)`。在这个例子中，`gpa`不是`const`，所以在成员初始化列表中使用它是可选的。'
- en: 'Here is the output to accompany our full program example:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们完整程序示例的输出：
- en: '[PRE33]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Next, let's now move forward by adding the `const` qualifier to member functions.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过向成员函数添加`const`限定符来继续前进。
- en: Using const member functions
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用const成员函数
- en: We have seen the constant qualifier used quite exhaustively now with data. It
    can also be used in conjunction with member functions. C++ provides a language
    mechanism to ensure that selected functions may not modify data; this mechanism
    is the `const` qualifier as applied to member functions.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经相当详尽地看到了常量限定符与数据一起使用。它也可以与成员函数一起使用。C++提供了一种语言机制来确保选定的函数不会修改数据；这种机制就是作用于成员函数的`const`限定符。
- en: A **const member function** is a member function that specifies (and enforces)
    that the method can only perform read-only activities on the object invoking the
    function.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**const成员函数**是指定（并强制执行）该方法只能对调用该函数的对象执行只读操作的成员函数。'
- en: A constant member function means that no portion of `this` may be modified.
    However, because C++ allows typecasting, it is possible to cast `this` to its
    non-const counterpart and then change data members. However, if the class designer
    truly meant to be able to modify data members, they simply would not label a member
    function as `const`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 常量成员函数意味着`this`的任何部分都不能被修改。然而，因为C++允许类型转换，可以将`this`转换为它的非const对应部分，然后修改数据成员。然而，如果类设计者真的希望能够修改数据成员，他们简单地不会将成员函数标记为`const`。
- en: Constant instances declared in your program may only invoke `const` member functions.
    Otherwise these objects could be directly modified.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中声明的常量实例只能调用`const`成员函数。否则这些对象可能会被直接修改。
- en: To label a member function as `const`, the keyword `const` should be specified
    after the argument list in the function prototype and in the function definition.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 要将成员函数标记为`const`，关键字`const`应该在函数原型和函数定义的参数列表之后指定。
- en: 'Let''s see an example. It will be divided into two sections with some portions
    omitted; however, the full example can be seen in the GitHub repository:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。它将被分成两个部分，有些部分被省略了；然而，完整的例子可以在GitHub存储库中看到：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex10.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex10.cpp)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex10.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex10.cpp)'
- en: '[PRE34]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the previous program fragment, we see a class definition for `Student`, which
    is becoming very familiar to us. Notice, however, that we have added the `const`
    qualifier to most of the access member functions, that is, to those methods that
    are only providing read-only access to data.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序片段中，我们看到了`Student`的类定义，这对我们来说已经非常熟悉了。然而，请注意，我们已经将`const`限定符添加到大多数访问成员函数中，也就是说，那些只提供只读访问数据的方法。
- en: For example, let us consider `float GetGpa() const { return gpa; }`. The `const`
    keyword after the argument list indicates that this is a constant member function.
    Notice that this function does not modify any data member pointed to by `this`.
    It cannot do so, as it is marked as a `const` member function.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑`float GetGpa() const { return gpa; }`。参数列表后面的`const`关键字表示这是一个常量成员函数。请注意，这个函数不修改`this`指向的任何数据成员。它不能这样做，因为它被标记为`const`成员函数。
- en: 'Now, let''s move on to the remainder of this example:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续探讨这个例子的其余部分：
- en: '[PRE35]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the remainder of this program, notice that we have again chosen not to include
    the definitions for member functions with which we are already familiar, such
    as the constructors, the destructor, and `void Student::SetCurrentCourse()`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本程序的其余部分中，请注意，我们再次选择不包括我们已经熟悉的成员函数的定义，比如构造函数、析构函数和`void Student::SetCurrentCourse()`。
- en: Instead, let's focus our attention on the member function with the signature
    `void Student::Print() const`. Here, the `const` keyword after the argument list
    indicates that no data members pointed to by `this` can be altered in the scope
    of this function. And none are. Likewise, any member functions called on this
    within `void Student::Print()` must also be `const` member functions. Otherwise,
    they could modify `this`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，让我们把注意力集中在具有签名`void Student::Print() const`的成员函数上。在这里，参数列表后面的`const`关键字表示在这个函数的范围内，`this`指向的任何数据成员都不能被修改。同样，`void
    Student::Print()`中调用的任何成员函数也必须是`const`成员函数。否则，它们可能会修改`this`。
- en: Moving forward to examine our `main()` function, we instantiate a `Student`,
    namely `s1`. This `Student` calls several member functions, including some that
    are `const`. `Student s1` then changes their current course using `Student::SetCurrentCourse()`,
    and then the new value of this course is printed.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 继续检查我们的`main()`函数，我们实例化了一个`Student`，即`s1`。这个`Student`调用了几个成员函数，包括一些是`const`的。然后，`Student
    s1`使用`Student::SetCurrentCourse()`改变了他们的当前课程，然后打印了这门课的新值。
- en: Next, we instantiate another `Student`, `s2`, which is qualified as `const`.
    Notice that once this student is instantiated, the only member functions that
    may be applied to `s2` are those that are labeled as `const`. Otherwise, the instance
    may be modified. We then print out data for `s2` using `Student::Print();`, which
    is a `const` member function.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实例化了另一个`Student`，`s2`，它被限定为`const`。请注意，一旦这个学生被实例化，只有那些被标记为`const`的成员函数才能应用于`s2`。否则，实例可能会被修改。然后，我们使用`Student::Print();`打印了`s2`的数据，这是一个`const`成员函数。
- en: 'Did you notice the commented-out line of code: `s2.SetCurrentCourse("Advanced
    C++ Programming");`? This line is illegal and would not compile, because `SetCurrentCourse()`
    is not a constant member function and is hence illegal to be called via a constant
    instance, such as `s2`.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到了被注释掉的代码行：`s2.SetCurrentCourse("Advanced C++ Programming");`吗？这行代码是非法的，不会编译通过，因为`SetCurrentCourse()`不是一个常量成员函数，因此不能通过常量实例（如`s2`）调用。
- en: 'Let''s take a look at the output for the full program example:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下完整程序示例的输出：
- en: '[PRE36]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now that we have fully explored `const` member functions, let's continue to
    the final section of this chapter to delve into `static` data members and `static`
    member functions.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经充分探讨了`const`成员函数，让我们继续到本章的最后一部分，深入研究`static`数据成员和`static`成员函数。
- en: Utilizing static data members and static member functions
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用静态数据成员和静态成员函数
- en: Now that we have been using C++ classes to define and instantiate objects, let's
    add to our knowledge of object-oriented concepts by exploring the idea of a class
    attribute. A data member that is intended to be shared by all instances of a particular
    class is known as a **class attribute**.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经开始使用C++类来定义和实例化对象，让我们通过探索类属性的概念来增加我们对面向对象概念的了解。一个旨在被特定类的所有实例共享的数据成员被称为**类属性**。
- en: Typically, each instance of a given class has distinct values for each of its
    data members. However, on occasion, it may be useful for all instances of a given
    class to share one data member, containing a single value. The object-oriented
    concept of a class attribute can be modeled in C++ using a **static data member**.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，给定类的每个实例都有其数据成员的不同值。然而，偶尔，让给定类的所有实例共享一个包含单个值的数据成员可能是有用的。在C++中，可以使用**静态数据成员**来建模类属性的面向对象概念。
- en: The `static` data members themselves are modeled as external (global) variables
    whose scope is tied back to the class in question using *name mangling*. Hence,
    each static data member can have its scope limited to the class in question.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`static`数据成员本身被建模为外部（全局）变量，其作用域通过*名称修饰*与相关类绑定。因此，每个静态数据成员的作用域可以限制在相关类中。'
- en: To model a `static` data member, an external variable definition, outside the
    class, must follow the `static` data member specification in the class definition.
    Storage for this *class member* is obtained by the external variable, its underlying
    implementation.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟`static`数据成员，必须在类定义中的`static`数据成员规范之后，跟随一个外部变量定义，位于类外部。这个*类成员*的存储是通过外部变量及其底层实现获得的。
- en: '`static` data members within a class or structure. A `static` member function
    does not receive a `this` pointer; hence, it may only manipulate `static` data
    members and other external (global) variables.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 类或结构中的`static`数据成员。`static`成员函数不接收`this`指针；因此，它只能操作`static`数据成员和其他外部（全局）变量。
- en: To indicate a `static` member function, the keyword `static` must be specified
    in front of the function's return type in the member function prototype only.
    The keyword `static` must not appear in the member function definition. If the
    keyword `static` appears in the function definition, the function will additionally
    be `static` in the C programming sense; that is, the function will be limited
    in scope to the file in which it is defined.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 要指示一个`static`成员函数，必须在成员函数原型的返回类型前指定关键字`static`。关键字`static`不得出现在成员函数定义中。如果关键字`static`出现在函数定义中，该函数将在C编程意义上另外成为`static`；也就是说，该函数将被限制在定义它的文件中。
- en: 'Let''s take a look at an example of `static` data member and member function
    usage. The following example will be broken into segments; however, it will appear
    without any functions omitted or abbreviated, as it is the final example in this
    chapter. It can also be found in full in the GitHub repository:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个`static`数据成员和成员函数的使用示例。以下示例将被分成几个部分；但是，它将以完整形式出现，没有省略或缩写任何函数，因为它是本章的最终示例。它也可以在GitHub存储库中完整找到：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex11.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex11.cpp)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex11.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex11.cpp)'
- en: '[PRE37]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the first segment of code comprising our full example, we have our `Student`
    class definition. In the `private` access region, we have added a data member,
    `static int numStudents;`, to model the object-oriented concept of a class attribute,
    a data member that will be shared by all instances of this class.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完整示例的第一个代码段中，我们有我们的`Student`类定义。在`private`访问区域中，我们添加了一个数据成员`static int numStudents;`，以模拟面向对象的概念，即类属性，这是一个将被该类的所有实例共享的数据成员。
- en: Next, notice toward the end of this class definition that we have added a `static`
    member function, `static int GetNumberStudents();`, to provide encapsulated access
    to the `private` data member `numStudents`. Note the keyword `static` is added
    in the prototype only. If we glance outside of the class definition to find the
    member function definition of `int Student::GetNumberStudents()`, we notice that
    there is no usage of the `static` keyword within the definition of this function
    itself. The body of this member function simply returns the shared `numStudents`,
    the static data member.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，请注意在这个类定义的末尾，我们添加了一个`static`成员函数`static int GetNumberStudents();`，以提供对`private`数据成员`numStudents`的封装访问。请注意，关键字`static`只在原型中添加。如果我们在类定义之外查看`int
    Student::GetNumberStudents()`的成员函数定义，我们会注意到在该函数定义本身中没有使用`static`关键字。这个成员函数的主体只是返回共享的`numStudents`，即静态数据成员。
- en: 'Also notice just below the class definition is the external variable definition
    to support the implementation of the static data member: `int Student::numStudents
    = 0;`. Notice with this declaration the use of `::` (the scope resolution operator)
    to associate the class name to the identifier `numStudents`. Though this data
    member is implemented as an external variable, and because the data member is
    labeled as `private`, it may only be accessed by member functions within the `Student`
    class. The implementation of a `static` data member as an external variable helps
    us understand where the memory for this shared data comes from; it is not part
    of any instance of the class, but stored as a separate entity in the global namespace.
    Also notice that the declaration `int Student::numStudents = 0;` initializes this
    shared variable to a value of zero.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，在类定义的下面，有一个外部变量定义，以支持静态数据成员的实现：`int Student::numStudents = 0;`。请注意，这个声明使用`::`（作用域解析运算符）将类名与标识符`numStudents`关联起来。尽管这个数据成员被实现为外部变量，因为数据成员被标记为`private`，它只能被`Student`类中的成员函数访问。将`static`数据成员实现为外部变量有助于我们理解这个共享数据的内存来自哪里；它不是类的任何实例的一部分，而是作为一个单独的实体存储在全局命名空间中。还要注意，声明`int
    Student::numStudents = 0;`将这个共享变量初始化为零。
- en: As an interesting aside, notice that the data member `studentId` has been changed
    from a `const int` to `const char *studentId;` in this new version of our `Student`
    class. Keep in mind that this means `studentId` is a pointer to a constant string,
    not a constant pointer. Because the memory for the pointer itself is not `const`,
    this data member will not need to be initialized using the member initialization
    list, but it will require some special handling.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个有趣的侧面，注意在我们的`Student`类的这个新版本中，数据成员`studentId`已经从`const int`更改为`const char
    *studentId;`。请记住，这意味着`studentId`是一个指向常量字符串的指针，而不是一个常量指针。因为指针本身的内存不是`const`，所以这个数据成员不需要使用成员初始化列表进行初始化，但它将需要一些特殊处理。
- en: 'Let''s continue onward to review additional member functions comprising this
    class:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续审查构成这个类的其他成员函数：
- en: '[PRE38]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the previous program segment of member functions, most member functions look
    as we've grown accustomed to seeing, but there are some subtle differences.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在成员函数的上一个程序段中，大多数成员函数看起来我们已经习惯看到的样子，但也有一些细微的差异。
- en: One difference, which relates to our `static` data member, is that `numStudents`
    is incremented in each of the constructors, and decremented in the destructor.
    Since this `static` data member is shared by all instances of `class Student`,
    each time a new `Student` is instantiated, the counter will increase, and when
    an instance of a `Student` ceases to exist and its destructor is implicitly called,
    the counter will be decremented to reflect the removal of such an instance. In
    this way, `numStudents` will accurately reflect how many `Student` instances exist
    in our application.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 一个与我们的`static`数据成员相关的不同之处是，`numStudents`在每个构造函数中递增，并在析构函数中递减。由于这个`static`数据成员被`class
    Student`的所有实例共享，每次实例化一个新的`Student`，计数器都会增加，当一个`Student`实例停止存在并且它的析构函数被隐式调用时，计数器将递减以反映这样一个实例的移除。这样，`numStudents`将准确反映我们的应用程序中存在多少`Student`实例。
- en: This section of code has a few other interesting details to notice, unrelated
    to `static` data members and member functions. For example, in our class definition,
    we changed `studentId` from a `const int` to a `const char *`. This means that
    the data pointed to is constant, not the pointer itself, so that we are not required
    to use the member initialization list to initialize this data member.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码还有一些其他有趣的细节需要注意，与`static`数据成员和成员函数无关。例如，在我们的类定义中，我们将`studentId`从`const int`更改为`const
    char *`。这意味着指向的数据是常量，而不是指针本身，因此我们不需要使用成员初始化列表来初始化这个数据成员。
- en: Nonetheless, in the default constructor, we choose to use the member initialization
    list to initialize `studentId` to `0`, meaning a null pointer. Recall that we
    may use the member initialization list for any data member, but we must use it
    to initialize `const` data members. That is, if the `const` part equates to memory
    that is allocated with an instance. Since the memory allocated within the instance
    for the data member `studentId` is a pointer and the pointer part of this data
    member is not `const` (just the data pointed to), we do not need to use the member
    initialization list for this data member. We just choose to.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，在默认构造函数中，我们选择使用成员初始化列表将`studentId`初始化为`0`，意味着一个空指针。回想一下，我们可以使用成员初始化列表来初始化任何数据成员，但我们必须使用它来初始化`const`数据成员。也就是说，如果`const`部分等同于为实例分配的内存。由于在数据成员`studentId`的实例中分配的内存是一个指针，并且该数据成员的指针部分不是`const`（只是指向的数据），我们不需要为这个数据成员使用成员初始化列表。我们只是选择这样做。
- en: However, because `studentId` is a `const char *`, this means that the identifier
    `studentId` may not serve as an l-value, or be on the left-hand side of an assignment.
    In the alternate and copy constructors, we wish to initialize `studentId`, and
    need the ability to use `studentId` as an l-value. But we cannot. We circumvent
    this dilemma by instead declaring a helper variable, `char *temp;`, and allocating
    it to contain the amount of memory we need to load the desired data. Then we load
    the desired data into `temp`, and finally we have `studentId` point to `temp`
    to establish a value for `studentId`. When we leave each constructor, the local
    pointer `temp` is popped off the stack; however, the memory is now captured by
    `studentId` and treated as `const`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，因为`studentId`是一个`const char *`，这意味着标识符`studentId`可能不作为l值，或者在赋值的左侧。在替代和复制构造函数中，我们希望初始化`studentId`，并且需要能够使用`studentId`作为l值。但我们不能。我们通过声明一个辅助变量`char
    *temp;`来规避这个困境，并分配它来包含我们需要加载所需数据的内存量。然后我们将所需的数据加载到`temp`中，最后我们让`studentId`指向`temp`来为`studentId`建立一个值。当我们离开每个构造函数时，局部指针`temp`被弹出堆栈；然而，内存现在被`studentId`捕获并被视为`const`。
- en: Lastly, in the destructor, notice that in order to delete the memory associated
    with `const char *studentid`, we will need to typecast `studentId` to a non-constant
    `char *`, as the operator `delete()` expects pointers that are not constant-qualified.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在析构函数中，请注意，为了删除与`const char *studentid`相关联的内存，我们需要将`studentId`强制转换为非常量`char
    *`，因为`delete()`操作符期望的是非常量限定的指针。
- en: 'Now that we have completed reviewing the new details in the member functions,
    let us continue by examining the final portion of this program example:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了对成员函数中新细节的审查，让我们继续通过检查程序示例的最后部分来进行：
- en: '[PRE39]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the `main()` function of our program, we start by instantiating two `Students`,
    `s1` and `s2`. As each instance is initialized with a constructor, the shared
    data member value of `numStudents` is incremented to reflect the number of students
    in our application. Note that the external variable `Student::numStudents`, which
    holds the memory for this shared data member, was initialized to `0` when the
    program started with the statement earlier in our code: `int Student::numStudents
    = 0;`.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们程序的`main()`函数中，我们首先实例化两个`Students`，`s1`和`s2`。当每个实例被构造初始化时，共享数据成员值`numStudents`被递增以反映我们应用程序中的学生数量。请注意，外部变量`Student::numStudents`，它保存了这个共享数据成员的内存，在程序开始时被初始化为`0`，在我们的代码中之前的语句：`int
    Student::numStudents = 0;`。
- en: After we print out some details for each `Student`, we then print out the `static`
    data member `numStudents` using a `static` access function, `Student::GetNumStudents()`.
    The preferred way to call this function is `Student::GetNumStudents();`. Because
    `numStudents` is `private`, only a method of the `Student` class may access this
    data member. We have now provided safe, encapsulated access to a `static` data
    member using a `static` member function.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在为每个`Student`打印一些细节之后，我们使用`static`访问函数`Student::GetNumStudents()`打印出`static`数据成员`numStudents`。调用这个函数的首选方式是`Student::GetNumStudents();`。因为`numStudents`是`private`的，只有`Student`类的方法才能访问这个数据成员。我们现在使用`static`成员函数提供了对`static`数据成员的安全、封装访问。
- en: It is interesting to remember that `static` member functions do not receive
    a `this` pointer, therefore the only data they may manipulate will be `static`
    data in the class (or other external variables). Likewise, the only other functions
    they may call will be other `static` member functions in the same class, or external
    non-member functions.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，要记住`static`成员函数不会接收到`this`指针，因此它们可能操作的唯一数据将是类中的`static`数据（或其他外部变量）。同样，它们可能调用的唯一其他函数将是同一类中的其他`static`成员函数，或者外部非成员函数。
- en: It is also interesting to note that we can seemingly call `Student::GetNumStudents()`
    via any instance, such as `s1.GetNumStudents();`, as we see in the commented-out
    section of code. Though it seems as though we are calling the member function
    through an instance, the function will not receive a `this` pointer. Instead,
    the compiler reinterprets the call, which is seemingly through an instance, and
    replaces the invocation with a call to the internal, *name-mangled* function.
    It is clearer from a programming point of view to call `static` member functions
    using the first calling method, and not seemingly through an instance that would
    never be passed along to the function itself.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们似乎可以通过任何实例调用`Student::GetNumStudents()`，比如`s1.GetNumStudents();`，就像我们在代码的注释部分中看到的那样。尽管看起来我们是通过一个实例调用成员函数，但函数不会接收到`this`指针。相反，编译器会重新解释调用，似乎是通过一个实例，然后用对内部的*name-mangled*函数的调用替换这个调用。从编程的角度来看，使用第一种调用方法来调用`static`成员函数更清晰，而不是似乎是通过一个永远不会传递给函数本身的实例来调用。
- en: 'Finally, here is the output for our full program example:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是我们完整程序示例的输出：
- en: '[PRE40]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now that we have reviewed our final example of this chapter, it is time to recap
    everything that we have learned.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了本章的最后一个例子，是时候总结我们所学到的一切了。
- en: Summary
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have begun our journey with object-oriented programming.
    We have learned many object-oriented concepts and terms, and have seen how C++
    has direct language support to implement these concepts. We have seen how C++
    classes support encapsulation and information hiding, and how implementing designs
    supporting these ideals can lead to code that is easier to modify and maintain.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经开始了面向对象编程的旅程。我们学习了许多面向对象的概念和术语，并看到了C++如何直接支持实现这些概念。我们看到了C++类如何支持封装和信息隐藏，并且实现支持这些理想的设计如何导致更容易修改和维护的代码。
- en: We have detailed class basics, including member functions. We've moved deeper
    into member functions by examining member function internals, including understanding
    what the `this` pointer is, and how it works – including the underlying implementation
    of member functions that implicitly receive a `this` pointer.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经详细介绍了类的基础知识，包括成员函数。我们通过深入研究成员函数的内部，包括理解`this`指针是什么，以及它的工作原理 - 包括隐式接收`this`指针的成员函数的底层实现。
- en: We have explored access labels and access regions. By grouping our data members
    in the `private` access region, and providing a suite of `public` member functions
    to manipulate these data members, we have found that we can provide a safe, well-controlled,
    and well-tested means to manipulate data from the confines of each class. We have
    seen that making changes to a class can be limited to the member functions themselves.
    The user of the class need not know the underlying representation of data members
    – these details are hidden and can be changed as needed without causing a wave
    of changes elsewhere in an application.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了访问标签和访问区域。通过将数据成员分组在`private`访问区域，并提供一套`public`成员函数来操作这些数据成员，我们发现我们可以提供一种安全、受控和经过充分测试的手段来从每个类的范围内操作数据。我们已经看到，对类进行更改可以限制在成员函数本身。类的用户不需要知道数据成员的底层表示
    - 这些细节是隐藏的，并且可以根据需要进行更改，而不会在应用程序的其他地方引起一系列更改。
- en: We have deeply explored the many facets of constructors, by examining default,
    typical (overloaded) constructors, copy constructors and even conversion constructors.
    We have been introduced to the destructor, and understand its proper usage.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经深入探讨了构造函数的许多方面，通过检查默认、典型（重载）构造函数，复制构造函数，甚至转换构造函数。我们已经介绍了析构函数，并了解了它的正确用法。
- en: We've added additional flavor to our classes by using various qualifiers to
    both data members and member functions, such as `inline` for efficiency, `const`
    to safeguard data and to ensure functions will as well, `static` data members
    to model the OO concept of class attributes, and `static` methods to provide safe
    interfaces to these `static` data members.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过对数据成员和成员函数使用各种限定符，如`inline`以提高效率，`const`以保护数据并确保函数也是如此，`static`数据成员以模拟类属性的OO概念，以及`static`方法来提供对这些`static`数据成员的安全接口，为我们的类增添了额外的特色。
- en: By immersing ourselves in object-oriented programming, we have gained a comprehensive
    set of skills relating to classes in C++. With a well-rounded set of skills and
    experience with using classes under our respective belts, and an appreciation
    for object-oriented programming, we can now move forward with [*Chapter 6*](B15702_06_Final_NM_ePub.xhtml#_idTextAnchor262),
    *Implementing Hierarchies with Single Inheritance*, to learn how to grow a hierarchy
    of related classes. Let's move forward!
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 通过沉浸在面向对象编程中，我们获得了与C++中类相关的一套全面的技能。拥有一套全面的技能和使用类的经验，以及对面向对象编程的欣赏，我们现在可以继续前进，学习如何通过[*第6章*](B15702_06_Final_NM_ePub.xhtml#_idTextAnchor262)，*使用单继承实现层次结构*，来构建一系列相关类的层次结构。让我们继续前进！
- en: Questions
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Create a C++ program to encapsulate a `Student`. You may use portions of your
    previous exercises. Try to do this yourself, rather than relying on any online
    code. You will need this class as a basis to move forward with future examples;
    now is a good time to try each feature on your own. Specifically:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个C++程序来封装一个`Student`。您可以使用之前练习的部分。尝试自己做这个，而不是依赖任何在线代码。您将需要这个类作为未来示例的基础；现在是一个很好的时机来尝试每个功能。具体来说：
- en: a. Create or modify your previous `Student` class to fully encapsulate a student.
    Be sure to include several data members that are dynamically allocated. Provide
    several overloaded constructors to provide a means to initialize your class. Be
    sure to include a copy constructor. Also, include a destructor to release any
    dynamically allocated data members.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: a. 创建或修改你之前的`Student`类，完全封装一个学生。确保包含几个动态分配的数据成员。提供多个重载的构造函数来初始化你的类。确保包含一个拷贝构造函数。还要包含一个析构函数来释放任何动态分配的数据成员。
- en: b. Add an assortment of access functions to your class to provide safe access
    to data members within your class. Decide for which data members you will offer
    a `GetDataMember()` interface, and if any of these data members should have the
    ability to be reset after construction with a `SetDataMember()` interface. Apply
    the `const` and `inline` qualifiers to these methods as appropriate.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: b. 为你的类添加一系列访问函数，以提供对类内数据成员的安全访问。决定为哪些数据成员提供`GetDataMember()`接口，以及这些数据成员中是否有任何可以在构造后重置的能力，使用`SetDataMember()`接口。根据需要对这些方法应用`const`和`inline`限定符。
- en: c. Be sure to utilize appropriate access regions – `private` for data members,
    and possibly for some helper member functions to break up a larger task. Add `public`
    member functions as necessary above and beyond your access functions above.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: c. 确保使用适当的访问区域 - 对于数据成员使用`private`，可能对一些辅助成员函数使用`private`来分解一个较大的任务。根据需要添加`public`成员函数，超出上面的访问函数。
- en: d. Include at least one `const` data member in your class and utilize the member
    initialization list to set this member. Add at least one `static` data member
    and one `static` member function.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: d. 在你的类中至少包含一个`const`数据成员，并利用成员初始化列表来设置这个成员。添加至少一个`static`数据成员和一个`static`成员函数。
- en: e. Instantiate a `Student` using each constructor signature, including the copy
    constructor. Make several instances dynamically allocated using `new()`. Be sure
    to `delete()` each of these instances when you are done with them (so that their
    destructor will be called).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: e. 使用每个构造函数签名实例化一个`Student`，包括拷贝构造函数。使用`new()`动态分配多个实例。确保在使用完毕后`delete()`每个实例（这样它们的析构函数将被调用）。
