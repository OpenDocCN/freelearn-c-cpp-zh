- en: 5\. The Philosophers' Dinner – Threads and Concurrency
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 哲学家的晚餐——线程和并发
- en: Learning Objectives
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够：
- en: Create synchronous and asynchronous multithreaded applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建同步和异步多线程应用程序
- en: Apply synchronization to handle data hazards and race conditions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用同步处理数据危害和竞争条件
- en: Develop efficient multithreaded code with C++ thread library primitives
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C++线程库原语开发高效的多线程代码
- en: Create threads using move semantics for multithreading closures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用移动语义创建线程以进行多线程闭包
- en: Implement thread communication with futures, promises, and async
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用futures、promises和async实现线程通信
- en: In this chapter, we will clarify the difference between basic terms in multithreaded
    programming, learn how to write multi-threaded code, find out which resources
    are provided by the C++ Standard Library for data access synchronization, learn
    how to prevent our code from encountering race conditions and deadlocks.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将澄清多线程编程中基本术语的区别，学习如何编写多线程代码，了解C++标准库提供的数据访问同步资源，学习如何防止我们的代码遇到竞争条件和死锁。
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we covered different types of dependencies and coupling
    in C++. We looked at how common API design patterns and idioms can be implemented
    in C++ and what data structures are provided by Standard Libraries, as well as
    their efficacy. We also learned how to work with functional objects, lambdas,
    and captures. This knowledge will help us learn how to write clear and efficient
    multithreaded programs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们涵盖了C++中不同类型的依赖和耦合。我们看了一下如何在C++中实现常见的API设计模式和习惯用法，以及标准库提供的数据结构及其效果。我们还学习了如何使用函数对象、lambda和捕获。这些知识将帮助我们学习如何编写清晰和高效的多线程程序。
- en: The heading of this chapter contains the name of the most significant synchronization
    issue in concurrent programming – The Philosopher's Dinner. In a few words, this
    definition is as follows.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的标题包含了并发编程中最重要的同步问题的名称——哲学家的晚餐。简而言之，这个定义如下。
- en: Three philosophers are sitting at a round dining table with bowls of sushi.
    Chopsticks are placed between each adjacent philosopher. Only one philosopher
    at a time can eat their sushi with two chopsticks. Perhaps each philosopher will
    take one chopstick and then wait until someone gives up another chopstick. Philosophers
    are an analogy for three working processes and chopsticks for shared resources.
    "Who will grab the two chopsticks first"symbolizes the **race condition**. When
    each philosopher holds a chopstick and waits until another chopstick is available,
    it leads to a **deadlock**. This analogy explains what problems occur during multithreading.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 三位哲学家坐在圆桌旁，桌上有寿司碗。筷子放在每个相邻的哲学家之间。一次只有一个哲学家可以用两根筷子吃寿司。也许每个哲学家都会拿一根筷子，然后等待直到有人放弃另一根筷子。哲学家是三个工作进程的类比，筷子是共享资源。"谁会先拿起两根筷子"象征着**竞争条件**。当每个哲学家拿着一根筷子并等待另一根筷子可用时，就会导致**死锁**。这个类比解释了多线程期间出现的问题。
- en: We will start our chapter with a brief introduction to the main multithreaded
    concepts. We will consider the difference between synchronous, asynchronous, and
    threaded execution. Using clear and simple examples, we will start with synchronization,
    data hazards, and race conditions. We will find out why they appear in our code
    and how we can manage them. The next part of this chapter is devoted to the C++
    Standard Library for threaded execution. Using examples, we will learn how and
    when to use thread library primitives, and how does the **move semantic** interact
    with threads. We will also practice with **futures**, **promises**, and **async**
    to receive results from threads.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从对主要多线程概念的简要介绍开始本章。我们将考虑同步、异步和线程执行之间的区别。通过清晰简单的例子，我们将从同步、数据危害和竞争条件开始。我们将找出它们为什么出现在我们的代码中以及我们如何管理它们。本章的下一部分专门讨论了用于线程执行的C++标准库。通过示例，我们将学习如何以及何时使用线程库原语，以及**移动语义**如何与线程交互。我们还将练习使用**futures**、**promises**和**async**来从线程中接收结果。
- en: This chapter will be concluded with a challenging activity in which we'll create
    an Art Gallery simulator that works by simulating visitors and gallery staff.
    We will develop a multithreaded generator that will simultaneously create and
    remove visitors from the art gallery. Next, we will create a multithreaded class
    that is responsible for moving visitors through the gallery. They will interact
    with each other using synchronization techniques. Finally, we will create thread-safe
    storage, instances of which will be accessed from the different threads.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将以一个具有挑战性的活动结束，我们将创建一个艺术画廊模拟器，通过模拟访客和画廊工作人员来工作。我们将开发一个多线程生成器，同时创建和移除艺术画廊的访客。接下来，我们将创建一个负责将访客带过画廊的多线程类。他们将使用同步技术相互交互。最后，我们将创建线程安全的存储，这些实例将从不同的线程中访问。
- en: 'In the next section, we will clarify a nuanced distinction between the concepts
    of concurrent programming: **synchronous**, **asynchronous**, and **threaded**
    execution.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将澄清并发编程概念之间微妙的区别：**同步**、**异步**和**线程**执行。
- en: Synchronous, Asynchronous, and Threaded Execution
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步、异步和线程执行
- en: 'There is a nuanced distinction between the concepts of concurrent programming:
    `synchronous`, `asynchronous`, and `threaded execution`. To clarify it, we will
    start from the very beginning, with the concept of concurrent and parallel programs.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程的概念之间存在微妙的区别：`同步`、`异步`和`线程执行`。为了澄清这一点，我们将从最基本的开始，从并发和并行程序的概念开始。
- en: Concurrency
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并发
- en: 'The idea of `concurrency` is more than one task being executed simultaneously.
    `Concurrency` doesn''t specify how the simultaneity will be achieved. It only
    indicates that more than one task will be completed in a given period. Tasks can
    be `dependent`, `parallel`, `synchronous`, or `asynchronous`. The following diagram
    shows the concept of concurrent work:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`并发性`的概念不仅仅是同时执行多个任务。`并发性`并不指定如何实现同时性。它只表示在给定时间内将完成多个任务。任务可以是`依赖性的`，`并行的`，`同步的`或`异步的`。以下图表显示了并发工作的概念：'
- en: '![Figure 5.1: The abstraction of the concurrency - a few people working on
    the same computer'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1：并发性的抽象 - 一些人在同一台计算机上工作'
- en: '](img/C14583_05_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_05_01.jpg)'
- en: 'Figure 5.1: The abstraction of the concurrency - a few people working on the
    same computer'
  id: totrans-22
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.1：并发性的抽象 - 一些人在同一台计算机上工作
- en: In the preceding diagram, three people are working at the same time on one computer.
    We aren't interested in the way they do that, it's doesn't matter for this level
    of the abstraction.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，三个人同时在一台计算机上工作。我们对他们的工作方式不感兴趣，对于这个抽象层级来说并不重要。
- en: Parallelism
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并行性
- en: '**Parallelism** occurs when several tasks are performed simultaneously. The
    tasks work in parallel due to hardware capabilities. The best example of parallelism
    is a multi-core processor. For parallel execution, the tasks are divided into
    completely independent subtasks that are performed in different processors'' cores.
    After that, the result of the execution can be combined. Look at the following
    diagram to understand the concept of parallelism:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**并行性**发生在多个任务同时执行时。由于硬件的能力，这些任务可以并行工作。最好的并行性示例是多核处理器。对于并行执行，任务被分成完全独立的子任务，这些子任务在不同的处理器核心上执行。之后，执行的结果可以被合并。看一下以下图表，以了解并行性的概念：'
- en: '![](img/C14583_05_02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14583_05_02.jpg)'
- en: 'Figure 5.2: The abstraction of the parallelism - all of the tasks are executed
    by different people; they don''t interact with each other'
  id: totrans-27
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.2：并行性的抽象 - 所有任务都由不同的人执行；他们不相互交互
- en: In the preceding diagram, there are three people working at the same time on
    their own computers – well, they're working in parallel.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，有三个人同时在自己的计算机上工作 - 嗯，他们在并行工作。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '`Concurrency` and `parallelism` are not the same thing. `Parallelism` supplements
    concurrency. It tells us how tasks are performed: they are independent of each
    other and run in different computational units, that is, processors or cores.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`并发性`和`并行性`并不是一回事。`并行性`是对`并发性`的补充。它告诉我们任务是如何执行的：它们彼此独立，并在不同的计算单元上运行，也就是处理器或核心。'
- en: Now, we will smoothly move toward a threaded execution concept. When we talk
    about threads, we mean the thread of execution. This is an abstraction of the
    operating system, which allows us to perform several tasks simultaneously. Remember
    that the entire program executes in a separate process. The operating system allocates
    the `main()` function. We can create a new thread for execution and assign a beginning
    function that will be the starting point of this thread.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将平稳地过渡到线程执行的概念。当我们谈论线程时，我们指的是执行线程。这是操作系统的一个抽象，它允许我们同时执行多个任务。请记住，整个程序在一个单独的进程中执行。操作系统分配`main()`函数。我们可以创建一个新的线程来执行，并分配一个开始函数，这将是这个线程的起始点。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The address space and registers of the processor are called **Thread Context**.
    When the OS interrupts the thread's work, it must store the context of the current
    thread and load the context of the next one.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器的地址空间和寄存器被称为**线程上下文**。当操作系统中断线程的工作时，它必须存储当前线程的上下文并加载下一个线程的上下文。
- en: 'Let''s consider the creation of a new thread in the following example. To create
    a new thread, we must include a `<thread>` header file. It contains classes and
    functions for managing threads. Actually, there are a few possible ways to create
    an `std::thread` object and thread of execution, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下示例中的新线程的创建。要创建一个新线程，我们必须包含`<thread>`头文件。它包含了用于管理线程的类和函数。实际上，有几种可能的方法来创建一个`std::thread`对象和线程执行，如下所示：
- en: 'Create an `std::thread` object without explicit initialization. Remember, the
    thread needs a start function to run its job. We didn''t point out which function
    is the main one for this thread. This means that the thread of execution was not
    created. Let''s look at the following code sample, where we create an empty `std::thread`
    object:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个没有显式初始化的`std::thread`对象。记住，线程需要一个启动函数来运行它的工作。我们没有指出哪个函数是这个线程的主要函数。这意味着执行线程没有被创建。让我们看一下以下代码示例，其中我们创建一个空的`std::thread`对象：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create an `std::thread` object and pass a pointer to a function as a constructor
    argument. Now, the thread of execution will be created and will start its job
    from the function that we passed in the constructor. Let''s look at the following
    code sample:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`std::thread`对象，并将一个指向函数的指针作为构造函数参数传递。现在，执行线程将被创建，并将从我们在构造函数中传递的函数开始执行其工作。让我们看一下以下代码示例：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we created an `std::thread` object and initialized it with the function
    pointer. This is a simple function that returns `void` and doesn't take any parameters.
    Then, we tell the main thread to wait until the new thread finishes using the
    `join()` function. We always have to `join()` or `detach()` a thread until the
    end of the scope of the `std::thread` object. If we don't do that, our application
    will be terminated by the OS using an `std::terminate`() function that is called
    in the `std::thread` destructor. Instead of a function pointer, we can also pass
    any callable object, such as `lambda`, `std::function`, or a class with an overloaded
    `operator()`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个`std::thread`对象，并用函数指针进行了初始化。这是一个简单的返回`void`并且不带任何参数的函数。然后，我们告诉主线程等待直到新线程完成，使用`join()`函数。我们总是必须在`std::thread`对象的作用域结束之前`join()`或`detach()`一个线程。如果不这样做，我们的应用程序将被操作系统使用`std::terminate()`函数终止，该函数在`std::thread`析构函数中被调用。除了函数指针，我们还可以传递任何可调用对象，如`lambda`，`std::function`或具有重载的`operator()`的类。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The thread of execution can finish its job before the destruction of the `std::thread`
    object. It also can be destructed before the thread of execution finishes its
    job. Always `join()` or `detach()` an `std::thread` object before its destruction.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 执行线程可以在`std::thread`对象销毁之前完成其工作。它也可以在执行线程完成其工作之前被销毁。在销毁`std::thread`对象之前，始终要`join()`或`detach()`它。
- en: Now that we know about the main syntax for creating a thread, we can proceed
    to the next important concepts. Let's find out what synchronous, asynchronous,
    and multithreaded execution mean.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了创建线程的主要语法，我们可以继续了解下一个重要概念。让我们找出同步、异步和多线程执行的含义。
- en: Synchronous Execution
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同步执行
- en: The term synchronous execution means that each subtask will be performed sequentially,
    one by one. In other words, this means that if we have a few tasks to execute,
    each of them can only start its work after the previous one has finished its work.
    This term does not specify a way to perform tasks, or whether they will be performed
    in a single or several threads. It only tells us about the execution order. Let's
    go back to the philosophers' dinner example. In a single-threaded world, the philosophers
    will eat one after the other.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 同步执行这个术语意味着每个子任务将按顺序依次执行。换句话说，这意味着如果我们有几个任务要执行，每个任务只能在前一个任务完成工作后才能开始工作。这个术语并没有指定执行任务的方式，或者它们是否将在单个线程或多个线程中执行。它只告诉我们执行顺序。让我们回到哲学家晚餐的例子。在单线程世界中，哲学家们将依次进餐。
- en: 'The first philosopher takes two chopsticks and eats their sushi. Then, the
    second philosopher takes two chopsticks and eats their sushi. They take turns
    until all of them have finished their sushi. Take a look at the following diagram,
    which represents the synchronous execution of four tasks in a single thread:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个哲学家拿起两根筷子吃寿司。然后，第二个哲学家拿起两根筷子吃寿司。他们轮流进行，直到所有人都吃完寿司。看一下以下图表，它表示了在单个线程中同步执行四个任务：
- en: '![Figure 5.3: Synchronous execution in a single thread'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3：单线程中的同步执行'
- en: '](img/C14583_05_03.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_05_03.jpg)'
- en: 'Figure 5.3: Synchronous execution in a single thread'
  id: totrans-48
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.3：单线程中的同步执行
- en: 'Here, each of the tasks waits for the previous task to finish. Tasks can also
    be performed synchronously in multiple threads. Consider the following diagram,
    which represents the synchronous execution of four tasks in multiple threads.
    Again, each of the tasks waits for the previous task to finish:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每个任务都等待前一个任务完成。任务也可以在多个线程中同步执行。考虑以下图表，它表示了在多个线程中同步执行四个任务。同样，每个任务都等待前一个任务完成：
- en: '![](img/C14583_05_04.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14583_05_04.jpg)'
- en: 'Figure 5.4: Synchronous execution in multiple threads'
  id: totrans-51
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.4：多线程中的同步执行
- en: In this case, each task is launched in a separate thread, but only after the
    previous thread has completed its work. In a multithreaded world, the philosophers
    will still eat one after the other, but with a small difference. Now, each of
    them has their own chopsticks, but can only eat in a strict order.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，每个任务在单独的线程中启动，但只有在前一个线程完成其工作后才能启动。在多线程世界中，哲学家们仍然会依次进餐，但有一个小区别。现在，每个人都有自己的筷子，但只能按严格的顺序进餐。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '`Synchronous execution` means that the finishing time of each task is synchronized.
    The order of the execution of tasks is the main point here.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 同步执行意味着每个任务的完成时间是同步的。任务的执行顺序是重点。
- en: 'Let''s consider synchronous execution on the following code sample. When we
    run tasks in a single thread, we just call the usual functions. For example, we
    implemented four functions that print a message to the terminal. We ran them in
    a synchronous, single-threaded way:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下代码示例中的同步执行。当我们在单个线程中运行任务时，我们只需调用通常的函数。例如，我们实现了四个打印消息到终端的函数。我们以同步的单线程方式运行它们：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we call all the functions one by one, and every next function runs after
    the execution of the previous function. Now, let''s run them in the different
    threads:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们依次调用所有函数，每个下一个函数在前一个函数执行完之后运行。现在，让我们在不同的线程中运行它们：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code sample, we created four threads and immediately joined
    them. Thus, every thread finishes its job before the one can be run. As you can
    see, nothing changes for the tasks – they are still executed in a strict order.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们创建了四个线程并立即加入它们。因此，每个线程在运行之前都完成了它的工作。正如你所看到的，对于任务来说没有任何变化-它们仍然按严格的顺序执行。
- en: Asynchronous Execution
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步执行
- en: This is where a few tasks can be executed simultaneously without blocking any
    thread execution. Usually, the main thread initiates an asynchronous operation
    and continues execution. After execution is finished, the results are sent to
    the main thread. Often, performing an asynchronous operation is not related to
    creating a separate thread for it. The task can be performed by someone else,
    such as another computing device, a remote web server, or an external device.
    Let's go back to the philosophers' dinner example.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种几个任务可以同时执行而不阻塞任何线程执行的情况。通常，主线程启动异步操作并继续执行。执行完成后，结果被发送到主线程。通常，执行异步操作与为其创建一个单独的线程无关。任务可以由其他人执行，比如另一个计算设备、远程网络服务器或外部设备。让我们回到哲学家晚餐的例子。
- en: In the case of `asynchronous execution`, all of the philosophers will have their
    own chopsticks and will eat independently from each other. When the sushi is ready
    and the waiter serves it, they all start to eat and can finish in their own time.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在`异步执行`的情况下，所有的哲学家都有自己的筷子，可以独立地进餐。当寿司准备好并且服务员端上来时，他们都开始进餐，并且可以按照自己的时间完成。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: In `asynchronous execution`, as all the tasks work independently of each other,
    it's not important to know the finish time of each task.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在`异步执行`中，所有任务相互独立工作，知道每个任务的完成时间并不重要。
- en: 'Take a look at the following diagram, which represents the asynchronous execution
    of four tasks in multiple threads:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下图表，它表示了在多个线程中异步执行四个任务：
- en: '![Figure 5.5: Asynchronous execution in multiple threads'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.5：多线程中的异步执行'
- en: '](img/C14583_05_05.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_05_05.jpg)'
- en: 'Figure 5.5: Asynchronous execution in multiple threads'
  id: totrans-68
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.5：多线程中的异步执行
- en: 'Each of them was started and finished at a different time. Let''s consider
    this asynchronous execution with a code sample. For example, we implemented four
    functions that print a message to the terminal. We ran them in different threads:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 它们每一个都在不同的时间开始和结束。让我们用一个代码示例来考虑这种异步执行。例如，我们实现了四个打印消息到终端的函数。我们在不同的线程中运行它们：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let's see what happens here. We used four functions from the previous examples,
    but they were changed a little bit. We added the print of the thread's unique
    ID by using the `std::this_thread::get_id()` function. This function returns the
    `std::thread::id` object, which represents the unique ID of the thread. This class
    has overloaded operators for the output and comparison, so we can use it in a
    different manner. For example, we can check the thread ID and if it is the ID
    of the main thread, we can execute a special job. In our example, we can print
    the thread ID to the terminal. Next, we created four threads and detached them.
    This means that no thread will wait for the other to finish working. From this
    moment, they become **daemon threads**.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这里发生了什么。我们使用了前面示例中的四个函数，但它们稍作了修改。我们通过使用`std::this_thread::get_id()`函数添加了线程的唯一ID的打印。这个函数返回`std::thread::id`对象，表示线程的唯一ID。这个类有重载的操作符用于输出和比较，所以我们可以以不同的方式使用它。例如，我们可以检查线程ID，如果是主线程的ID，我们可以执行特殊的任务。在我们的示例中，我们可以将线程ID打印到终端上。接下来，我们创建了四个线程并将它们分离。这意味着没有线程会等待其他线程完成工作。从这一刻起，它们成为**守护线程**。
- en: 'They will continue their job, but nobody knows about that. Then, we used the
    `std::this_thread::sleep_for(2s)` function to make the main thread wait for two
    seconds. We did that because when the main thread finishes its job, the application
    will stop, and we won''t be able to view the output of the detached threads in
    the terminal. The following screenshot is an example of the output to the terminal:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 它们将继续它们的工作，但没有人知道。然后，我们使用了`std::this_thread::sleep_for(2s)`函数让主线程等待两秒。我们这样做是因为当主线程完成它的工作时，应用程序会停止，我们将无法在终端上查看分离线程的输出。下面的截图是终端输出的一个例子：
- en: '![Figure 5.6: The result of an example execution'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.6：示例执行的结果'
- en: '](img/C14583_05_06.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_05_06.jpg)'
- en: 'Figure 5.6: The result of an example execution'
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.6：示例执行的结果
- en: In your IDE, the output can change as the order of execution is undefined. A
    real-world example of asynchronous execution can be an internet browser wherein
    you can open multiple tabs. When a new tab is opened, the application starts a
    new thread and detaches them. Although the threads work independently, they can
    share some resources, such as a file handler, to write logs or do something else.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的IDE中，输出可能会改变，因为执行顺序是不确定的。异步执行的一个现实例子可以是一个互联网浏览器，在其中你可以打开多个标签页。当打开一个新标签页时，应用程序会启动一个新线程并将它们分离。虽然线程工作是独立的，但它们可以共享一些资源，比如文件处理程序，用于写日志或执行其他操作。
- en: Note
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '`std::thread` has a member function called `get_id()` that returns the unique
    ID of the `std::thread` instance. If the `std::thread` instance wasn''t initialized
    or was joined or detached, `get_id()` returns a default `std::thread::id` object.
    This means that no thread of execution is associated with the current `std::thread`
    instance.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::thread`有一个成员函数叫做`get_id()`，它返回`std::thread`实例的唯一ID。如果`std::thread`实例没有初始化，或者已经加入或分离，`get_id()`会返回一个默认的`std::thread::id`对象。这意味着当前`std::thread`实例没有与任何执行线程相关联。'
- en: Let's use some pseudocode to show an example where computations are done by
    another computational unit. For example, let's say we develop an application that
    performs calculations with currency exchange. The user inputs an amount in one
    currency, chooses another currency to exchange, and the application shows them
    the amount in that currency. The application, in the background, sends a request
    to a remote server that holds all the currency exchange rates.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一些伪代码来展示一个例子，其中计算由另一个计算单元完成。例如，假设我们开发了一个应用程序，用于进行货币兑换的计算。用户输入一种货币的金额，选择另一种货币进行兑换，应用程序会显示他们在那种货币中的金额。在后台，应用程序向保存所有货币兑换率的远程服务器发送请求。
- en: 'The remote server calculates the amount of the given currency and sends the
    result back. Your application shows a progress bar at that time and allows the
    user to perform other operations. When it receives the results, it displays them
    on the window. Let''s take a look at the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 远程服务器计算给定货币的金额并将结果返回。您的应用程序在那时显示一个进度条，并允许用户执行其他操作。当它收到结果时，它会在窗口上显示它们。让我们看一下下面的代码：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's see what happens here. In the `main()` function, we created a thread called
    `messageLoop` that executes the `runMessageLoop()` function. Some code that checks
    if there are any new results from the server can be placed in this function. If
    a new result is received, it creates a new thread, `procRes`, that will display
    the results in a window. We also created another thread, `userInput`, in the `main()`
    function that gets currencies and the amount from the user and creates a new thread,
    `request`, that will send a request to the remote server. After sending the request,
    it creates a new thread, `progress`, that will display a progress bar until the
    results are received. Since all the threads were detached, they were able to work
    independently. Sure, this is just pseudocode, but the main idea is clear – our
    application sends a request to the remote server, which performs calculations
    for our application.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这里发生了什么。在`main()`函数中，我们创建了一个名为`messageLoop`的线程，执行`runMessageLoop()`函数。可以在这个函数中放置一些代码，检查是否有来自服务器的新结果。如果收到新结果，它会创建一个新线程`procRes`，该线程将在窗口中显示结果。我们还在`main()`函数中创建了另一个线程`userInput`，它从用户那里获取货币和金额，并创建一个新线程`request`，该线程将向远程服务器发送请求。发送请求后，它创建一个新线程`progress`，该线程将显示一个进度条，直到收到结果。由于所有线程都被分离，它们能够独立工作。当然，这只是伪代码，但主要思想是清楚的-我们的应用程序向远程服务器发送请求，远程服务器为我们的应用程序执行计算。
- en: 'Let''s revise what we have learned about concurrency concepts using an example
    from daily life. Here is a background wherein you''ve to write an application
    and provide all the documentation and architectural concepts related to it:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们通过日常生活中的一个例子学到的并发概念。这是一个背景，在这个背景中，您需要编写一个应用程序，并提供与之相关的所有文档和架构概念：
- en: 'Single-threaded work: You write it yourself.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单线程工作：您自己编写。
- en: 'Multi-threaded work: You invite your friends and write a project together.
    Somebody writes an architectural concept, somebody takes care of documentation
    work, and you focus on the coding part. All participants communicate with each
    other to clarify any questions and share documentation, such as questions about
    specifications.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多线程工作：您邀请朋友一起编写项目。有人编写架构概念，有人负责文档工作，您专注于编码部分。所有参与者彼此沟通，以澄清任何问题并共享文档，例如规格问题。
- en: 'Parallel work: The tasks are divided. Someone writes the documentation for
    the project, someone designs the diagrams, someone writes the test cases, and
    you work independently. Participants don''t communicate at all.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行工作：任务被分开。有人为项目编写文档，有人设计图表，有人编写测试用例，您独立工作。参与者之间根本不沟通。
- en: 'Synchronized work: In this case, each of you are unable to understand what
    they are supposed to do. Thus, you all decide to work one after the other. When
    the architectural work is finished, the developer starts to write the code. Then,
    when the development work is finished, someone starts to write the documentation.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步工作：在这种情况下，每个人都无法理解他们应该做什么。因此，您决定依次工作。当架构工作完成时，开发人员开始编写代码。然后，当开发工作完成时，有人开始编写文档。
- en: 'Asynchronous work: In this case, you hire an outsource company to complete
    the project. While they are developing the project, you''ll be engaged in some
    other task.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步工作：在这种情况下，您雇佣了一个外包公司来完成项目。当他们开发项目时，您将从事其他任务。
- en: Now, let's apply our knowledge in practice and solve an exercise to see how
    all it works.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将我们学到的知识应用到实践中，并解决一个练习，看看它是如何工作的。
- en: 'Exercise 1: Creating Threads in a Different Way'
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习1：以不同的方式创建线程
- en: In this exercise, we'll write a simple application that creates four threads;
    two of them will work in a synchronized way and two of them will work asynchronously.
    All of them will print some symbols to the terminal, so that we can see how the
    operating system switches thread execution.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一个简单的应用程序，创建四个线程；其中两个将以同步方式工作，另外两个将以异步方式工作。它们都将向终端打印一些符号，以便我们可以看到操作系统如何切换线程执行。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'Add the pthread linker flag in your project settings to let the compiler know
    that you will use threading libraries. For Eclipse IDE you can do this following
    this path: `Eclipse Version: 3.8.1`, it may vary in different versions.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目设置中添加pthread链接器标志，以便编译器知道您将使用线程库。对于Eclipse IDE，您可以按照以下路径操作：`Eclipse版本：3.8.1`，不同版本可能会有所不同。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此练习，执行以下步骤：
- en: 'Include some headers for threading support, namely `<thread>`, streaming support,
    namely `<iostream>`, and functional objects support, namely `<functional>`:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括一些用于线程支持的头文件，即`<thread>`，流支持，即`<iostream>`，和函数对象支持，即`<functional>`：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Implement a free function, `printNumbers()`, that prints numbers from 0 to
    100 in a `for` loop:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为`printNumbers()`的自由函数，在`for`循环中打印0到100的数字：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Implement a callable object, that is, a `Printer` class with an overloaded
    `operator()` that prints a "*" symbol from 0 to 100000 in a `for` loop. For every
    `200` iterations, print a new line symbol for more readable output:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个可调用对象，即一个具有重载的`operator()`的`Printer`类，它在`for`循环中从0到100000打印一个"*"符号。每200次迭代，打印一个新行符号，以获得更可读的输出：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Enter the `main()` function and then create a lambda object called `printRevers`
    that prints the numbers from 100 to 0 in a `for` loop:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入`main()`函数，然后创建一个名为`printRevers`的lambda对象，在`for`循环中打印100到0的数字：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Implement an `std::function` object called `printOther` that prints the "^"
    symbol from `0` to `100000` in a `for` loop. For every `200` iterations, print
    a new line symbol for more readable output:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为`printOther`的`std::function`对象，它在`for`循环中从`0`到`100000`打印一个"^"符号。每200次迭代，打印一个新行符号，以获得更可读的输出：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create the first thread, `thr1`, and pass the `printNumbers` free function
    to its constructor. Join it:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第一个线程`thr1`，并将`printNumbers`自由函数传递给其构造函数。加入它：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a second thread, `thr2`, and pass the `printRevers` lambda object to
    its constructor. Join it:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二个线程`thr2`，并将`printRevers` lambda对象传递给其构造函数。加入它：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create an instance of the `Printer` class called `print`. Create a third thread,
    `thr3`, and initialize it with the `print` object. Detach it using the `detach()`
    method:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`print`的`Printer`类的实例。创建第三个线程`thr3`，并用`print`对象初始化它。使用`detach()`方法将其分离：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create the last thread, `thr4`, and initialize it with the `printOther` object.
    Detach it:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建最后一个线程`thr4`，并用`printOther`对象初始化它。分离它：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the `std::getchar()` function call before the exit of the `main()` function.
    This avoids closing the application. We''ll have the possibility to see how detached
    threads work:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`函数退出之前添加`std::getchar()`函数调用。这样可以避免关闭应用程序。我们将有可能看到分离的线程是如何工作的：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Run this code in your editor. You will see that `thr1` starts execution and
    the program waits. After `thr1` has finished, `thr2` starts execution and the
    program waits. This is an example of synchronous execution. After `thr2` has finished
    its work, threads `thr3` and `thr4` start execution. They are detached, so the
    program can proceed with the execution. In the following output, you will see
    that the symbols are mixed. This happens because the operating system performs
    interruptions and the threads work at the same time.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中运行此代码。您将看到`thr1`开始执行，程序等待。`thr1`完成后，`thr2`开始执行，程序等待。这是同步执行的一个例子。`thr2`完成工作后，线程`thr3`和`thr4`开始执行。它们被分离，所以程序可以继续执行。在下面的输出中，您将看到符号混合。这是因为操作系统执行中断，线程同时工作。
- en: 'Your output will be similar to the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出将类似于以下内容：
- en: '![](img/C14583_05_07.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14583_05_07.jpg)'
- en: 'Figure 5.7: The result of the exercise''s execution'
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.7：练习执行的结果
- en: 'In this exercise, we implemented four different ways we can initialize threads:
    with a free function, with a lambda object, with a callable object, and with an
    `std::function` object. There are a few more ways to initialize the thread, but
    we''ll consider them in the next section. We''ve also reviewed how we can implement
    a synchronous program in multiple threads. We also tried to implement the asynchronous
    program and saw that threads really work at the same time and independently. In
    the next section, we''ll learn about data hazards and race conditions and how
    we can avoid them by using synchronization techniques.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们实现了四种不同的初始化线程的方式：使用自由函数、使用lambda对象、使用可调用对象和使用`std::function`对象。还有一些更多的初始化线程的方式，但我们将在下一节中考虑它们。我们还回顾了如何在多个线程中实现同步程序。我们还尝试实现了异步程序，并看到线程确实可以同时独立地工作。在下一节中，我们将学习数据危害和竞争条件，以及如何通过使用同步技术来避免它们。
- en: Review Synchronization, Data Hazards, and Race Conditions
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾同步、数据危害和竞争条件
- en: 'The key challenge of multithreaded programming is knowing how the threads work
    with **shared data**. Shared data, also known as resources, are not only variables,
    but also file descriptors and environment variables, and even Windows registries.
    For example, if the threads just read the data, then there are no problems and
    no synchronization is required. However, if at least one of the threads edits
    the data, **race conditions** could arise. Usually, the operations on the data
    are not atomic, that is, they require several steps. Even the simplest increment
    operation of a numeric variable is performed in the following three steps:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程编程的关键挑战是了解线程如何处理**共享数据**。共享数据，也称为资源，不仅是变量，还包括文件描述符和环境变量，甚至是Windows注册表。例如，如果线程只是读取数据，那么就没有问题，也不需要同步。但是，如果至少有一个线程编辑数据，就可能出现**竞争条件**。通常，对数据的操作不是原子的，也就是说，它们需要几个步骤。即使是对数字变量的最简单的增量操作也是在以下三个步骤中完成的：
- en: Read the value of the variable.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取变量的值。
- en: Increment it.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加它。
- en: Write the new value.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写入新值。
- en: Due to the OSes interruptions, the thread can be stopped before it completes
    the operation. For example, we have threads A and B and have a variable that is
    equal to 0.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于操作系统的中断，线程在完成操作之前可能会被停止。例如，我们有线程A和B，并且有一个等于0的变量。
- en: 'Thread A starts the increment:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 线程A开始增量：
- en: Reads the value of the variable (var = 0).
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取变量的值（var = 0）。
- en: Increments it (tmp = 1).
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加它（tmp = 1）。
- en: Gets interrupted by the OS.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被操作系统中断。
- en: 'Thread B starts the increment:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 线程B开始增量：
- en: Reads the value of the variable (var = 0).
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取变量的值（var = 0）。
- en: Increments it (tmp = 1).
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加它（tmp = 1）。
- en: Writes the new value (var = 1).
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写入新值（var = 1）。
- en: Gets interrupted by the OS.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被操作系统中断。
- en: 'Thread A continues the increment:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 线程A继续增量：
- en: Writes the new value (var = 1).
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写入新值（var = 1）。
- en: 'Thus, we expect the variable to be equal to 2 after the completion of the work,
    but in fact, it is equal to 1\. Have a look at the following diagram to get a
    better understanding of this example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们期望在工作完成后变量等于2，但实际上它等于1。看一下下面的图表，以更好地理解这个例子：
- en: '![Figure 5.8: Two threads increment the same shared variable'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.8：两个线程增加相同的共享变量'
- en: '](img/C14583_05_08.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_05_08.jpg)'
- en: 'Figure 5.8: Two threads increment the same shared variable'
  id: totrans-140
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.8：两个线程增加相同的共享变量
- en: Let's go back to the philosophers' dinner analogy. The original issue was that
    one philosopher had only one chopstick. If all of them are hungry, then they will
    hurry to grab two chopsticks. The first philosopher who grabs two chopsticks will
    be the first to eat, and the others must wait. They will race for the sticks.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到哲学家的晚餐类比。最初的问题是一个哲学家只有一根筷子。如果他们都饿了，那么他们会赶紧抓起两根筷子。第一个抓起两根筷子的哲学家将第一个吃饭，其他人必须等待。他们会争夺筷子。
- en: Now, let's apply our knowledge to practice and write some code to see how the
    race conditions can appear in our code and can damage our data.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将我们的知识应用到实践中，并编写一些代码，看看竞争条件如何出现在我们的代码中，并且如何损害我们的数据。
- en: 'Exercise 2: Writing an Example of Race Conditions'
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习2：编写竞争条件示例
- en: In this exercise, we will write a simple application that will demonstrate race
    conditions in action. We will create a classic example of a "check then act" race
    condition. We will create a thread, which performs the division of two numbers.
    We will pass these numbers by reference. After a check, if a dividend is equal
    to 0, we will set a small timeout. At this time in the main thread, we will set
    the dividend to 0\. When the child thread wakes up, it will perform a division
    to 0\. That will lead to an application crash. We will also add some logs to see
    the execution flow.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一个简单的应用程序，演示竞争条件的实际情况。我们将创建一个经典的“检查然后执行”竞争条件的例子。我们将创建一个线程，执行两个数字的除法。我们将通过引用传递这些数字。在检查后，如果被除数等于0，我们将设置一个小的超时。此时在主线程中，我们将将被除数设置为0。当子线程醒来时，它将执行除以0的操作。这将导致应用程序崩溃。我们还将添加一些日志来查看执行流程。
- en: Note
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: By default, all the variables are copied when they are passed to the thread.
    To pass the variable as a reference, use the `std::ref()` function.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当变量传递给线程时，所有变量都会被复制。要将变量作为引用传递，请使用`std::ref()`函数。
- en: 'First, we implement the code without a race condition and ensure that it works
    as expected. Perform the following steps:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们实现没有竞争条件的代码，并确保它按预期工作。执行以下步骤：
- en: 'Include headers for threading support, namely `<thread>`, streaming support,
    namely `<iostream>`, and functional objects support, namely `<functional>`:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括线程支持的头文件，即`<thread>`，流支持的头文件，即`<iostream>`，和函数对象支持的头文件，即`<functional>`：
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Implement a `divide()` function, which performs a division of two integers.
    Pass the `divisor` and `dividend` variables by reference. Check whether a dividend
    is equal to 0\. Then, add the logs:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`divide()`函数，执行两个整数的除法。通过引用传递`divisor`和`dividend`变量。检查被除数是否等于0。然后，添加日志：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Enter the `main()` function, create two integers called `divisor` and `dividend`,
    and initialize them with any non-zero values:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入`main()`函数，创建两个名为`divisor`和`dividend`的整数，并用任意非零值初始化它们：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create the `thr1` thread, pass the `divide` function, use `divisor` and `dividend`
    by reference, and then detach the thread:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`thr1`线程，传递`divide`函数，使用引用传递`divisor`和`dividend`，然后分离线程：
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: In the `std::this_thread` namespace there is a function called `sleep_for` that
    blocks threads for a given period of time. As a parameter, it takes `std::chrono::duration`
    – a template class to represent a time interval.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在`std::this_thread`命名空间中有一个名为`sleep_for`的函数，它可以阻塞线程一段时间。作为参数，它采用`std::chrono::duration`
    - 一个表示时间间隔的模板类。
- en: 'Run this code in your editor. You will see that the `divide()` function works
    correctly in `thr1`. The output looks as follows:![Figure 5.9: The result of the
    correct exercise execution'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中运行此代码。您将看到`divide()`函数在`thr1`中正常工作。输出如下所示：![图5.9：正确练习执行的结果
- en: '](img/C14583_05_09.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_05_09.jpg)'
- en: 'Figure 5.9: The result of the correct exercise execution'
  id: totrans-160
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.9：正确练习执行的结果
- en: Now, we will continue and make changes that will demonstrate race conditions.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将继续进行更改，以演示竞争条件。
- en: 'Go back to the function and set the sleeping time in `2s` for the child thread
    after the `if` condition. Add the logs:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回函数，并在`if`条件后为子线程设置睡眠时间为`2s`。添加日志：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Go back to the `main()` function and set the sleeping time in `1s` for the
    main thread. After that, set the `dividend` variable to `0`. Add the logs:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回`main()`函数，将主线程的睡眠时间设置为`1s`。之后，将`dividend`变量设置为`0`。添加日志：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `std::chrono_literals` namespace contains literals for time representations:
    ``h`` for `hours`, ``min`` for `minutes`, ``s`` for `seconds`, ``ms`` for `milliseconds`,
    ``us`` for `microseconds`, and ``ns`` for `nanoseconds`. To use them, you should
    just add them to the end of the number, for example, 1s, 1min, 1h, and so on.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::chrono_literals`命名空间包含时间表示的字面量：``h``表示`小时`，``min``表示`分钟`，``s``表示`秒`，``ms``表示`毫秒`，``us``表示`微秒`，``ns``表示`纳秒`。要使用它们，只需将它们添加到数字的末尾，例如，1s，1min，1h等。'
- en: 'Add the `std::getchar()` function call before the exit of the `main()` function.
    This avoids us closing the application and we will have the possibility to see
    how detached threads work:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`函数退出之前添加`std::getchar()`函数调用。这样可以避免关闭应用程序，我们将有可能看到分离线程的工作方式：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run this code in your editor. You will see that the main thread goes to sleep
    for `1s`. Then, the child thread enters the `if` condition and goes to sleep for
    `2s`, which means that it validates a `dividend` and it is not equal to `0`. Then,
    the main thread wakes up and sets a `dividend` variable to 0\. Then, the child
    thread wakes up and performs the division. But because the `dividend` is equal
    to `0` now, the application crashes. If you run this example in Debug mode, you
    will see a `SIGFPE exception` with a message: "Arithmetic exception". You will
    get the following output:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中运行此代码。您将看到主线程睡眠了`1s`。然后，子线程进入`if`条件并睡眠了`2s`，这意味着它验证了`dividend`并且不等于`0`。然后，主线程醒来并将`dividend`变量设置为0。然后，子线程醒来并执行除法。但是因为`dividend`现在等于`0`，应用程序崩溃了。如果在调试模式下运行此示例，您将看到一个带有消息“算术异常”的`SIGFPE异常`。您将得到以下输出：
- en: '![Figure 5.10: The result of the exercise’s execution with race conditions'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.10：带有竞争条件的练习执行结果'
- en: '](img/C14583_05_10.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_05_10.jpg)'
- en: 'Figure 5.10: The result of the exercise''s execution with race conditions'
  id: totrans-173
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.10：带有竞争条件的练习执行结果
- en: 'In this exercise, we considered "check then act" kinds of race conditions.
    We''ve set periods of sleep for threads to emulate the OS interruption, but in
    real-world programs, this situation may well happen but may not. It all depends
    on the OS and its scheduler. This makes it enormously difficult to debug and fix
    race conditions. To avoid race conditions in this example, we can act in a few
    ways:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们考虑了“检查然后执行”类型的竞争条件。我们设置了线程的睡眠时间来模拟操作系统的中断，但在现实世界的程序中，这种情况可能会发生，也可能不会。这完全取决于操作系统及其调度程序。这使得调试和修复竞争条件变得非常困难。为了避免这个例子中的竞争条件，我们可以采取一些措施：
- en: Pass copies of variables to the threaded function instead of passing references.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将变量的副本传递给线程函数，而不是传递引用。
- en: Synchronize access to the shared variables between threads using Standard Library
    primitives.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准库原语在线程之间同步对共享变量的访问。
- en: Join child thread before the main thread changes a `dividend` value to 0.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主线程将“被除数”值更改为0之前，先加入子线程。
- en: Let's look at a few more ways to fix this race condition. All of them depend
    on a task that you try to implement. In the next section, we will consider synchronization
    primitives that are provided by the C++ Standard Library.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看修复这种竞争条件的几种方法。所有这些方法都取决于您尝试实现的任务。在下一节中，我们将考虑C++标准库提供的同步原语。
- en: Data Hazards
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据危害
- en: 'Previously, we considered the most harmless example, but sometimes, there are
    situations where the data is damaged, and this leads to undefined program behavior
    or abnormal termination. Such damage to data, as a result of race conditions or
    simply wrong design, are known as **data hazards**. In general, this term implies
    that the final result of a piece of work depends on the order of the thread''s
    execution. If different threads work with shared data or global variables, it
    may happen that, due to an incorrect order of task execution by different threads,
    the result will vary from time to time. This happens due to the dependencies between
    the data being multi-threaded. Such dependency issues are conditionally divided
    into three groups:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们考虑了最无害的例子，但有时会出现数据损坏的情况，这会导致未定义的程序行为或异常终止。由于竞争条件或简单的错误设计而导致的数据损坏，通常称为数据危害。一般来说，这个术语意味着一项工作的最终结果取决于线程执行的顺序。如果不同的线程使用共享数据或全局变量，可能会由于不同线程的任务执行顺序不正确，导致结果不断变化。这是由于多线程数据之间的依赖关系。这种依赖问题被有条件地分为三组：
- en: 'A **true dependency**: **Read After Writing** (RAW)'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个真依赖：写入后读取（RAW）
- en: 'An **anti-dependency**: **Write After Reading** (WAR)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个反依赖：读取后写入（WAR）
- en: 'An **output dependency**: **Write After Writing** (WAW)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个输出依赖：写入后写入（WAW）
- en: RAW Dependency
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始数据依赖
- en: 'A RAW dependency occurs when one thread calculates the value that is used by
    another thread. For example, `Thread A` should do its job and write the results
    to a variable. `Thread B` must read the value of this variable and do its job.
    In pseudocode, this looks as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个线程计算另一个线程使用的值时，就会发生原始数据依赖。例如，“线程A”应该完成其工作并将结果写入一个变量。 “线程B”必须读取此变量的值并完成其工作。在伪代码中，这看起来如下：
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Difficulties will arise if `Thread B` executes first. It will lead to `Thread
    B` reads an invalid value. The order of the execution of threads should be strictly
    guaranteed. `Thread B` must read the value of the variable, but only after `Thread
    A` has written it. Otherwise, it will lead to undefined behavior. The following
    diagram will help you clarify the RAW data dependency that leads to data hazards:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果“线程B”先执行，将会出现困难。这将导致“线程B”读取无效值。线程的执行顺序应该严格保证。“线程B”必须在“线程A”写入变量后才能读取其值。否则，将导致未定义的行为。以下图表将帮助您澄清导致数据危害的原始数据依赖：
- en: '![Figure 5.11: RAW data dependency between two threads'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.11：两个线程之间的原始数据依赖'
- en: '](img/C14583_05_11.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_05_11.jpg)'
- en: 'Figure 5.11: RAW data dependency between two threads'
  id: totrans-190
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.11：两个线程之间的原始数据依赖关系
- en: WAR Dependency
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WAR依赖
- en: 'A `Thread A` must read the value of a variable and do its job. After that,
    `Thread B` should do its job and write the results to a variable. In pseudocode,
    this looks as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: “线程A”必须读取一个变量的值并完成其工作。之后，“线程B”应该完成其工作并将结果写入一个变量。在伪代码中，这看起来如下：
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Difficulties will arise if `Thread B` executes first. It will lead to `Thread
    B` changing the value before `Thread A` reads it. The order of the execution of
    threads should be strictly guaranteed. `Thread B` should write the new value to
    a variable only after `Thread A` reads its value. The following diagram will help
    you clarify the RAW data dependency that leads to data hazards:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果“线程B”先执行，将会出现困难。这将导致“线程B”在“线程A”读取之前更改值。线程的执行顺序应该严格保证。“线程B”应该在“线程A”读取其值后才将新值写入变量。以下图表将帮助您澄清导致数据危害的原始数据依赖：
- en: '![Figure 5.12: WAR data dependency between two threads'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.12：两个线程之间的WAR数据依赖'
- en: '](img/C14583_05_12.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_05_12.jpg)'
- en: 'Figure 5.12: WAR data dependency between two threads'
  id: totrans-197
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.12：两个线程之间的WAR数据依赖
- en: WAW Dependency
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WAW依赖
- en: 'A `Thread A` executes its job and writes the results to a variable. `Thread
    B` reads the value of the variable and executes its job. `Thread C` executes its
    job and writes the results to the same variable. In pseudocode, this looks as
    follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: “线程A”执行其工作并将结果写入一个变量。 “线程B”读取变量的值并执行其工作。 “线程C”执行其工作并将结果写入相同的变量。在伪代码中，这看起来如下：
- en: '[PRE25]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Difficulties will arise if `Thread C` executes before threads A and B. This
    leads to `Thread B` reads the value that it is not expected to be read. The order
    of the execution of threads should be strictly guaranteed. `Thread C` must write
    a new value to a variable, but only after `Thread A` has written its value and
    `Thread B` has read it. The following diagram will help you clarify the WAW data
    dependency that leads to data hazards:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果“线程C”在A和B线程之前执行，将会出现困难。这将导致“线程B”读取不应该读取的值。线程的执行顺序应该严格保证。“线程C”必须在“线程A”写入其值并且“线程B”读取其值后才能将新值写入变量。以下图表将帮助您澄清导致数据危害的WAW数据依赖：
- en: '![Figure 5.13: WAW data dependency between two threads'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.13：两个线程之间的WAW数据依赖'
- en: '](img/C14583_05_13.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_05_13.jpg)'
- en: 'Figure 5.13: WAW data dependency between two threads'
  id: totrans-204
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.13：两个线程之间的WAW数据依赖
- en: Resource Synchronization
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源同步
- en: To prevent races and data hazards, there is a shared data locking mechanism
    where one of the streams intends to change or read these data. This mechanism
    is called `critical sections`. Synchronization consists of blocking critical sections
    when one of the threads enters it. Other threads that also intend to execute the
    code of this critical section will be blocked. When the thread executing the critical
    section leaves it, the lock is released. Then, the story will repeat with the
    next thread.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止竞争和数据危害，有一个共享数据锁定机制，其中一个流意图更改或读取这些数据。这种机制称为`临界区`。同步包括在一个线程进入临界区时阻塞临界区。也意图执行此临界区代码的其他线程将被阻塞。当执行临界区的线程离开时，锁将被释放。然后，故事将在下一个线程中重复。
- en: Consider the previous example with an increment, but now with synchronized access.
    Remember that we have threads A and B and have a variable that is equal to 0.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑前面的例子，其中有一个增量，但现在是同步访问。记住我们有线程A和B，并且有一个变量等于0。
- en: 'Thread A starts the increment:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 线程A开始增加：
- en: Enters the critical section and locks it.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入临界区并锁定它。
- en: Reads the value of the variable (var = 0).
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取变量的值（var = 0）。
- en: Increments it (tmp = 1).
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加它（tmp = 1）。
- en: Gets interrupted by the OS.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被操作系统中断。
- en: 'Thread B starts the increment:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 线程B开始增加：
- en: Tries to enter the critical section; it's locked, so the thread is waiting.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试进入临界区；它被锁定，所以线程正在等待。
- en: 'Thread A continues the increment:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 线程A继续增加：
- en: Writes the new value (var = 1).
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写入新值（var = 1）。
- en: 'Thread B continues the increment:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 线程B继续增加：
- en: Enters the critical section and locks it.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入临界区并锁定它。
- en: Reads the value of the variable (var = 1).
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取变量的值（var = 1）。
- en: Increments it (tmp = 2).
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加它（tmp = 2）。
- en: Writes the new value (var = 2).
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写入新值（var = 2）。
- en: 'After the completion of both threads, the variable contains the correct result.
    Thus, synchronization ensures that shared data will not be damaged. Have a look
    at the following diagram, to get a better understanding of this example:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个线程完成后，变量包含正确的结果。因此，同步确保了共享数据不会被破坏。看一下以下图表，以更好地理解这个例子：
- en: '![Figure 5.14: Two threads increment the same shared variable in a synchronized
    way'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.14：两个线程以同步的方式增加相同的共享变量'
- en: '](img/C14583_05_14.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_05_14.jpg)'
- en: 'Figure 5.14: Two threads increment the same shared variable in a synchronized
    way'
  id: totrans-225
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.14：两个线程以同步的方式增加相同的共享变量
- en: Highlighting critical sections and anticipating the possible consequences of
    non-synchronized access is a very difficult task. Because excessive synchronization
    negates the very essence of multithreaded work. If two or three threads work on
    one critical section rather quickly, however, there can be dozens of threads in
    the program where all of them will be blocked in the critical section. This will
    greatly slow down the program.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 突出显示临界区并预期非同步访问可能造成的后果是一项非常困难的任务。因为过度同步会否定多线程工作的本质。如果两个或三个线程在一个临界区上工作得相当快，然而，在程序中可能有数十个线程，它们都将在临界区中被阻塞。这将大大减慢程序的速度。
- en: Event Synchronization
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件同步
- en: 'There is another mechanism for synchronizing the work of threads – `Thread
    A`, which receives a message from another process. It writes the message to the
    queue and waits for new messages. There is another thread, `Thread B`, that processes
    these messages. It reads messages from the queue and performs some actions on
    them. When there are no messages, `Thread B` is sleeping. When `Thread A` receives
    a new message, it wakes up `Thread B` and processes it. The following diagram
    provides a clear understanding of the event synchronization of two threads:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种同步线程工作的机制-`线程A`，它从另一个进程接收消息。它将消息写入队列并等待新消息。还有另一个线程，`线程B`，它处理这些消息。它从队列中读取消息并对其执行一些操作。当没有消息时，`线程B`正在睡眠。当`线程A`接收到新消息时，它唤醒`线程B`并处理它。以下图表清楚地说明了两个线程的事件同步：
- en: '![Figure 5.15: Event synchronization of two threads'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.15：两个线程的事件同步'
- en: '](img/C14583_05_15.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_05_15.jpg)'
- en: 'Figure 5.15: Event synchronization of two threads'
  id: totrans-231
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.15：两个线程的事件同步
- en: 'However, even in synchronized code can appear another reason for a race conditions
    – a flawed interface of a class. To get an understanding of what this is, let''s
    consider the following example:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使在同步代码中也可能出现另一个竞争条件的原因-类的缺陷接口。为了理解这是什么，让我们考虑以下例子：
- en: '[PRE26]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, we have a class called `Messages` that has a dynamically allocated array
    of strings. In the constructor, it takes the size of the array and creates an
    array of the given size. It has a function, `full()`, that returns `true` if the
    array is full and `false` otherwise. It also has an `empty()` function that returns
    true if the array is empty and false otherwise. It is the user''s responsibility
    to check if the array is full before pushing a new value and checking if the array
    is empty, and before popping a new value from the array. This is an example of
    a poor interface of the class that leads to race conditions. Even if we protect
    the `push()` and `pop()` functions with locks, race conditions will not disappear.
    Let''s look at the following example of using the `Messages` class:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个名为`Messages`的类，它有一个动态分配的字符串数组。在构造函数中，它接受数组的大小并创建给定大小的数组。它有一个名为`full()`的函数，如果数组已满则返回`true`，否则返回`false`。它还有一个名为`empty()`的函数，如果数组为空则返回`true`，否则返回`false`。在推送新值之前和弹出数组中的新值之前，用户有责任检查数组是否已满并检查数组是否为空。这是一个导致竞争条件的类的糟糕接口的例子。即使我们用锁保护`push()`和`pop()`函数，竞争条件也不会消失。让我们看一下使用`Messages`类的以下示例：
- en: '[PRE27]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, we created a `msgs` variable and then created the first thread, which
    pushes value to the `msgs`. Then, we created the second thread, which pops values
    from the array and detaches them. Even if we protect all the functions by using
    a locking mechanism, one of the threads can check the array's size and can be
    interrupted by the OS. At this time, another thread can change the array. When
    the first thread continues its work, it can try to push to the full array or pop
    from the empty array. So, synchronization is only effective in a pair with a good
    design.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个`msgs`变量，然后创建了第一个线程，该线程将值推送到`msgs`。然后，我们创建了第二个线程，该线程从数组中弹出值并将它们分离。即使我们使用锁定机制保护了所有函数，其中一个线程仍然可以检查数组的大小，并可能被操作系统中断。此时，另一个线程可以更改数组。当第一个线程继续工作时，它可能会尝试向满数组推送或从空数组中弹出。因此，同步只在与良好设计配对时才有效。
- en: Deadlock
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 死锁
- en: 'There is one more synchronization issue. Let''s go back to the philosophers''
    dinner example. The original issue was that one philosopher has only one chopstick.
    So, they can eat their sushi one by one by sharing chopsticks with each other.
    Although it will take a long time for them to finish their sushi, all of them
    will be well-fed. But if each of them grabs a chopstick at the same time and doesn''t
    want to share the second chopstick, they won''t be able to eat their sushi as
    each of them will be waiting for the second chopstick forever. This leads to a
    **deadlock**. This happens when two threads are waiting for another thread to
    continue its job. One of the causes of deadlocks is when one thread joins another
    thread, but another thread joins the first thread. So, when both threads are joined
    to each other, none of them can continue their job. Let''s consider the following
    example of a deadlock:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个同步问题。让我们回到哲学家晚餐的例子。最初的问题是一个哲学家只有一根筷子。所以，他们可以通过彼此共享筷子一个接一个地吃寿司。虽然他们要花很长时间才能吃完寿司，但他们都会吃饱。但是，如果每个人同时拿起一根筷子，又不想分享第二根筷子，他们就无法吃到寿司，因为每个人都将永远等待第二根筷子。这会导致**死锁**。当两个线程等待另一个线程继续执行时，就会发生死锁。死锁的一个原因是一个线程加入另一个线程，而另一个线程加入第一个线程。因此，当两个线程都加入对方时，它们都无法继续执行。让我们考虑以下死锁的例子：
- en: '[PRE28]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the main function, we have two threads, `t1` and `t2`. We initialized the
    `t1` thread with the `someStuff()` function, which does some useful work. We also
    initialized the `t2` thread with the `someAnotherStuff()` function, which does
    some more useful work. We have global pointers to these threads and a join pointer
    to the `t1` thread in the function that's executed by `t2`. We also join a pointer
    to the `t2` thread into the function, which is executed by `t1`. By doing this,
    they joined each other. This causes a deadlock.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数中，我们有两个线程`t1`和`t2`。我们使用`someStuff()`函数初始化了`t1`线程，该函数执行一些有用的工作。我们还使用`someAnotherStuff()`函数初始化了`t2`线程，该函数执行更多有用的工作。我们有这些线程的全局指针，并且在由`t2`执行的函数中有一个指向`t1`线程的加入指针。我们还在由`t1`执行的函数中加入了一个指向`t2`线程的指针。通过这样做，它们相互加入。这导致了死锁。
- en: In the next section, we will consider C++ thread library primitives for synchronization
    and another cause of deadlocks.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将考虑C++线程库原语用于同步和死锁的另一个原因。
- en: Move Semantics for Multithreading Closures
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多线程闭包的移动语义
- en: 'The `std::thread` class cannot be copied, but what if we want to store a few
    threads, or maybe 10 or 20? Sure, we can create the number of threads, and then
    we can join or detach them like so:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::thread`类不能被复制，但是如果我们想要存储几个线程，或者可能是10个或20个呢？当然，我们可以创建这些线程的数量，然后像这样加入或分离它们：'
- en: '[PRE29]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'But it''s more convenient to store a bunch of threads in an **STL container**,
    for example, the vector of threads:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 但是更方便的是将一堆线程存储在**STL容器**中，例如线程的向量：
- en: '[PRE30]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'STL containers cannot be used with objects that don''t support `std::move()`
    function. To initialize the threads in the container, we can do something like
    the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 不支持`std::move()`函数的对象不能与STL容器一起使用。要在容器中初始化线程，我们可以像下面这样做：
- en: '[PRE31]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, we can join or detach all of them:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以加入或分离它们：
- en: '[PRE32]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Move semantics can also be useful when we store an `std::thread` object as
    a class member. In this case, we should design our class carefully, delete the
    copy constructor and assignment operator, and implement a new move constructor
    and move assignment operator. Let''s consider the following code example of such
    a class:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 移动语义在我们将`std::thread`对象存储为类成员时也很有用。在这种情况下，我们应该仔细设计我们的类，删除复制构造函数和赋值运算符，并实现新的移动构造函数和移动赋值运算符。让我们考虑以下这样一个类的代码示例：
- en: '[PRE33]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the move assignment operator, we first check if the thread is joinable. If
    so, we join it and only after that do we perform assignment operation.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动赋值运算符中，我们首先检查线程是否可加入。如果是，我们加入它，然后才执行赋值操作。
- en: Note
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: We should never assign one thread object to another without using `join()` or
    `detach()` on them. This will lead to an `std::terminate()` function call.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绝不能在没有使用`join()`或`detach()`的情况下将一个线程对象分配给另一个。这将导致`std::terminate()`函数调用。
- en: It's also possible to use the `std::move()` function to move objects into a
    thread function. It can be helpful for copying big objects, which is not advisable.
    Let's execute an exercise to ensure that the objects can be moved into thread
    functions.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用`std::move()`函数将对象移动到线程函数中。这对于复制大对象是有帮助的，这是不可取的。让我们执行一个练习，确保对象可以移动到线程函数中。
- en: 'Exercise 3: Moving Objects to a Thread Function'
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习3：将对象移动到线程函数
- en: 'In this exercise, we will write a simple application that demonstrates how
    `std::move()` works for `std::thread` classes. We will create a class that has
    both a copy constructor and a move constructor to see which one will be called
    when we move the object of this class into the `std::thread` function. Perform
    the following steps to complete this exercise:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一个简单的应用程序，演示`std::move()`如何用于`std::thread`类。我们将创建一个既有复制构造函数又有移动构造函数的类，以查看将该类的对象移动到`std::thread`函数时将调用哪一个。执行以下步骤完成此练习：
- en: 'Include headers for threading support, namely `<thread>`, and streaming support,
    namely `<iostream>`:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括线程支持的头文件，即`<thread>`，和流支持的头文件，即`<iostream>`：
- en: '[PRE34]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Implement the `Handler` clas, which has the default constructor, destructor,
    copy constructor, assignment operator, move constructor, and move assignment operator.
    They will do nothing except print a log:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Handler`类，它具有默认构造函数、析构函数、复制构造函数、赋值运算符、移动构造函数和移动赋值运算符。它们除了打印日志外什么都不做：
- en: '[PRE35]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Implement the `doSomeJob()` function, which actually does nothing here and
    just prints a log message:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`doSomeJob()`函数，这里实际上什么也不做，只是打印一个日志消息：
- en: '[PRE36]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Enter the `main()` function and create a `handler` variable of the `Handler`
    type. Create `thr1`, pass the `doSomeJob()` function, and move the handler variable:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入`main()`函数并创建`Handler`类型的`handler`变量。创建`thr1`，传递`doSomeJob()`函数，并移动处理程序变量：
- en: '[PRE37]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Detach the `thr1` thread and add a small sleep for the main thread to avoid
    closing the application. We will be able to see the output from the detached thread:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分离`thr1`线程并为主线程添加一个小睡眠，以避免关闭应用程序。我们将能够看到来自分离线程的输出。
- en: '[PRE38]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Run this code in your editor. In the terminal log, from the default constructor,
    you will see two logs from the move operator, one log from a destructor, a message
    from the `doSomeJob()` function, and, finally, two other log messages from the
    destructor. We can see that the move constructor is called twice.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中运行此代码。在终端日志中，从默认构造函数中，您将看到两个从移动运算符中的日志，一个从析构函数中的日志，来自`doSomeJob()`函数的消息，最后，另外两个从析构函数中的日志。我们可以看到移动构造函数被调用了两次。
- en: 'You will get the following output:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得以下输出：
- en: '![](img/C14583_05_16.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14583_05_16.jpg)'
- en: 'Figure 5.16: The result of the exercise''s execution'
  id: totrans-272
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.16：练习执行的结果
- en: As you can see, the `Handler` object was moved into the thread function. Despite
    that, all the parameters, that were passed without the `std::ref()` function,
    were copied to the thread's memory.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`Handler`对象被移动到线程函数中。尽管如此，所有未使用`std::ref()`函数传递的参数都被复制到线程的内存中。
- en: 'Let''s consider one interesting issue. As you may remember, when we initialize
    `std::thread`, all of the constructor arguments are copied into thread memory,
    including a callable object – a lambda, a function, or an std::function. But what
    if our callable object doesn''t support copy semantics? For example, we created
    a class that has only a move constructor and a move assignment operator:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个有趣的问题。你可能记得，当我们初始化`std::thread`时，所有的构造函数参数都会被复制到线程内存中，包括可调用对象 - lambda、函数或std::function。但是如果我们的可调用对象不支持复制语义怎么办？例如，我们创建了一个只有移动构造函数和移动赋值运算符的类：
- en: '[PRE39]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'How can we pass it to the thread constructor? If we pass it as it is, we will
    get a compiler error; for example:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将其传递给线程构造函数？如果我们按原样传递它，将会得到一个编译器错误；例如：
- en: '[PRE40]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You will get the following output:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得以下输出：
- en: '![](img/C14583_05_17.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14583_05_17.jpg)'
- en: 'Figure 5.17: Example of a compilation error'
  id: totrans-280
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.17：编译错误的示例
- en: 'There are lots of strange errors here. To fix this issue, we can use the `std::move()`
    function to move the callable:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多奇怪的错误。为了解决这个问题，我们可以使用`std::move()`函数来移动可调用对象：
- en: '[PRE41]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, everything is ok – the code is compiled and does exactly what we want it
    to do.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都很好 - 代码已经编译并且确实做了我们想要的事情。
- en: 'Now, let''s consider one more interesting example. For example, you have a
    lambda function that needs to capture a non-copiable object, for example, a `unique_ptr`:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑另一个有趣的例子。例如，您有一个需要捕获不可复制对象的lambda函数，例如`unique_ptr`：
- en: '[PRE42]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Starting from C++ 14, we can use `std::move()` to capture movable objects.
    So, to capture a unique pointer, we can use the following code:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 从C++ 14开始，我们可以使用`std::move()`来捕获可移动对象。因此，要捕获唯一指针，我们可以使用以下代码：
- en: '[PRE43]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As you can see, it's pretty useful to capture value in a lambda by using `std::move`.
    This can be also useful when we do not want to copy some objects because they
    might take a long time to copy.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，通过使用`std::move`在lambda中捕获值非常有用。当我们不想复制某些对象时，这也可能很有用，因为它们可能需要很长时间来复制。
- en: Now, let's put our knowledge to practice and write an application example that
    demonstrates how we can use `std::move` with threads.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将我们的知识付诸实践，并编写一个应用程序示例，演示我们如何在线程中使用`std::move`。
- en: 'Exercise 4: Creating and Working with an STL Container of Threads'
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习4：创建和使用STL线程容器
- en: In this exercise, we will write a simple application where we will use `std::move()`
    with threads. First of all, we will implement a class that is move constructible.
    This class will convert lowercase text into uppercase text. Then, we will create
    a vector of instances of this class. Next, we will create a vector of `std::thread`
    objects. Finally, we will initialize the threads with an object from the first
    vector.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一个简单的应用程序，我们将在其中使用`std::move()`与线程。首先，我们将实现一个可移动构造的类。这个类将把小写文本转换为大写文本。然后，我们将创建一个这个类实例的向量。接下来，我们将创建一个`std::thread`对象的向量。最后，我们将用第一个向量中的对象初始化线程。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此练习：
- en: 'Include headers for threading support, namely `<thread>`, streaming support,
    namely `<iostream>`, and `<vector>`:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括线程支持的头文件，即`<thread>`，流支持的头文件，即`<iostream>`，和`<vector>`：
- en: '[PRE44]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Implement the `Converter` class, which has the `m_bufferIn` private member
    of the `const` `std::vector<std::string>&` type. This is a reference to the original
    vector of strings in lowercase. It also has a user constructor, which takes the
    `bufferIn` variable. Then, we delete the copy constructor and assignment operators.
    Finally, we define the overloaded `operator()`, where we convert all lowercase
    symbols into uppercase. After conversion, we write the result to the result buffer:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Converter`类，它具有`const std::vector<std::string>&`类型的`m_bufferIn`私有成员。这是对原始字符串向量的引用。它还具有一个用户构造函数，它接受`bufferIn`变量。然后，我们删除复制构造函数和赋值运算符。最后，我们定义重载的`operator()`，在其中将所有小写符号转换为大写。转换后，我们将结果写入结果缓冲区：
- en: '[PRE45]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Enter the `main()` function, create a constant value called `numberOfTasks`,
    and set it to `5`. Then, create a vector of a `Converter` object and reserve its
    size with `numberOfTasks`. Then, create a vector of `std::thread` objects and
    reserve its size with `numberOfTasks`:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入`main()`函数，创建一个名为`numberOfTasks`的常量值，并将其设置为`5`。然后，创建一个`Converter`对象的向量，并使用`numberOfTasks`保留其大小。然后，创建一个`std::thread`对象的向量，并使用`numberOfTasks`保留其大小：
- en: '[PRE46]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create the vector of strings, `textArr`, and push five different big strings
    to be converted:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建字符串向量`textArr`，并推入五个不同的大字符串以进行转换：
- en: '[PRE47]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Implement a `for` loop where we push `Converter` objects into the functions
    vector:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`for`循环，将`Converter`对象推入函数向量：
- en: '[PRE48]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Create a result vector of strings and push five empty strings. Then, create
    a variable that will be an index of the array element:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个字符串结果向量，并推入五个空字符串。然后，创建一个将作为数组元素索引的变量：
- en: '[PRE49]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Implement another `for` loop where we push `std::thread` objects into the threads
    vector:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现另一个`for`循环，将`std::thread`对象推入线程向量：
- en: '[PRE50]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Implement a third `for` loop where we detach `std::threads`:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现第三个`for`循环，其中我们分离`std::threads`：
- en: '[PRE51]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Add a small sleep for the main thread to avoid closing the application. Now,
    we can see how detached threads work:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为主线程添加一个小的休眠，以避免关闭应用程序。现在，我们可以看到分离的线程是如何工作的：
- en: '[PRE52]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally print the result into the terminal:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后将结果打印到终端：
- en: '[PRE53]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Run this code in your editor. In the terminal, you can see that all strings
    are in uppercase, which means that all threads were moved and run successfully.
    You will get the following output:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中运行此代码。在终端中，您可以看到所有字符串都是大写的，这意味着所有线程都已成功移动和运行。您将得到以下输出：
- en: '![Figure 5.18: The result of the exercise’s execution'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.18：练习执行的结果'
- en: '](img/C14583_05_18.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_05_18.jpg)'
- en: 'Figure 5.18: The result of the exercise''s execution'
  id: totrans-316
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.18：练习执行的结果
- en: In this exercise, we practiced how to create an STL container of move-only objects.
    We also considered how to pass non-copiable objects to a thread constructor. This
    knowledge will help us in the next section when we learn how to get the result
    from the thread.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们练习了如何创建一个只能移动对象的STL容器。我们还考虑了如何将不可复制的对象传递给线程构造函数。这些知识将在下一节中帮助我们学习如何从线程中获取结果。
- en: Futures, Promises, and Async
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未来、承诺和异步
- en: In the previous section, we learned almost all that we need to work with threads.
    But we still have something interesting to consider, that is, synchronizing threads
    using future results. When we considered condition variables, we didn't cover
    the second type of synchronization with future results. Now, it's time to learn
    about that.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们几乎学会了处理线程所需的所有内容。但是我们仍有一些有趣的事情要考虑，即使用未来结果同步线程。当我们考虑条件变量时，我们没有涵盖使用未来结果进行第二种类型的同步。现在，是时候学习一下了。
- en: 'Suppose there is a situation wherein we run some thread and continue with other
    work. When we need a result, we stop and check if it is ready. This situation
    describes the actual work with future results. In C++, we have a header file called
    `<future>` that contains two template classes which represent future results:
    `std::future<>` and `std::shared_future<>`. We use `std::future<>` when we need
    a single future result and use `std::shared_future<>` when we need multiple valid
    copies. We can compare them with `std::unique_ptr` and `std::shared_ptr`.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有这样一种情况，我们运行一些线程并继续进行其他工作。当我们需要结果时，我们停下来检查它是否准备好。这种情况描述了未来结果的实际工作。在C++中，我们有一个名为`<future>`的头文件，其中包含两个模板类，表示未来结果：`std::future<>`和`std::shared_future<>`。当我们需要单个未来结果时，我们使用`std::future<>`，当我们需要多个有效副本时，我们使用`std::shared_future<>`。我们可以将它们与`std::unique_ptr`和`std::shared_ptr`进行比较。
- en: 'To work with future results, we need a special mechanism to run the task in
    the background and to receive the result later: the `std::async()` template function.
    It takes a callable as a parameter and the launch mode – deferred or async and,
    sure, parameters for the callable. The launch modes `std::launch::async` and `std::launch::deferred`
    indicate how to execute task. When we pass `std::launch::async`, we expect that
    function to be executed in a separate thread. When we pass `std::launch::deferred`,
    the function call will be deferred until we ask for the results. We can also pass
    both of them, for example, `std::launch::deferred|std::launch::async`. This means
    that the run mode will depend on the implementation.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理未来的结果，我们需要一个特殊的机制来在后台运行任务并稍后接收结果：`std::async()`模板函数。它以可调用对象作为参数，并且有启动模式 -
    延迟或异步，当然还有可调用对象的参数。启动模式`std::launch::async`和`std::launch::deferred`表示如何执行任务。当我们传递`std::launch::async`时，我们期望该函数在单独的线程中执行。当我们传递`std::launch::deferred`时，函数调用将被延迟，直到我们要求结果。我们也可以同时传递它们，例如`std::launch::deferred|std::launch::async`。这意味着运行模式将取决于实现。
- en: 'Now, let''s consider an example of usage `std::future` with `std::async`. We
    have a `toUppercase()` function, that converts the given string into uppercase:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一个使用`std::future`和`std::async`的示例。我们有一个`toUppercase()`函数，将给定的字符串转换为大写：
- en: '[PRE54]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Then, in the `main()` function, we create an `std::future` variable with a
    name `result` and initialize it using the `std::async()` return value. Then, we
    fetch the result by using the `get()` function of the result object:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`main()`函数中，创建一个名为`result`的`std::future`变量，并使用`std::async()`的返回值进行初始化。然后，我们使用结果对象的`get()`函数获取结果：
- en: '[PRE55]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Actually, here, we created a future object:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在这里，我们创建了一个未来对象：
- en: '[PRE56]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'As you can see, we didn''t pass the launch mode to the `std::async()` function,
    which means that the default mode will be used: `std::launch::deferred | std::launch::async`.
    You can do this explicitly:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们没有将启动模式传递给`std::async()`函数，这意味着将使用默认模式：`std::launch::deferred | std::launch::async`。您也可以明确这样做：
- en: '[PRE57]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here, we are waiting for the results:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在等待结果：
- en: '[PRE58]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: If our task takes a long time, the thread will wait here until the end.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的任务需要很长时间，线程将在这里等待直到结束。
- en: In general, we can use the `std::async()` function in the same way as we use
    the `std::thread` constructor. We can pass any callable object. All of the arguments
    are copied by default, and we can either move variables and callables or can pass
    them by reference.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们可以像使用`std::thread`构造函数一样使用`std::async()`函数。我们可以传递任何可调用对象。默认情况下，所有参数都会被复制，我们可以移动变量和可调用对象，也可以通过引用传递它们。
- en: The `std::future` object is not protected by race conditions. So, to access
    it from different threads and protect from damage, we should use mutexes. But
    if we need to share a future object, it's better to use `std::shared_future`.
    Shared future results are not thread-safe either. To avoid race conditions, we
    have to use mutexes or store the threads' own copy of `std::shared_future` in
    every thread.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::future`对象不受竞争条件保护。因此，为了从不同的线程访问它并保护免受损害，我们应该使用互斥锁。但是，如果我们需要共享future对象，最好使用`std::shared_future`。共享的future结果也不是线程安全的。为了避免竞争条件，我们必须在每个线程中使用互斥锁或存储线程自己的`std::shared_future`副本。'
- en: Note
  id: totrans-335
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Race conditions for `std::future` objects are very tricky. When the thread calls
    `get()` function, the future object becomes invalid.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::future`对象的竞争条件非常棘手。当线程调用`get()`函数时，future对象变得无效。'
- en: 'We can create a shared future by moving future to a constructor:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将未来移动到构造函数来创建共享的未来：
- en: '[PRE59]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As you can see, we created an `std::shared_future` variable from `std::future`
    and copied it. Both shared future objects are referring to the same result.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们从`std::future`创建了一个`std::shared_future`变量并进行了复制。两个共享的future对象都指向相同的结果。
- en: 'We can also create the shared future object using the `share()` member function
    of the `sdt::future` object:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`std::future`对象的`share()`成员函数来创建共享的future对象：
- en: '[PRE60]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Pay attention that, in both cases, the `std::future` object becomes invalid.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这两种情况下，`std::future`对象都会变得无效。
- en: Another way we can get a future result from a separate thread is by using the
    `std::packaged_task<>` template class. How do we work with them?
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`std::packaged_task<>`模板类从单独的线程获取未来结果的另一种方法。我们如何使用它们？
- en: 'We create a new `std::packaged_task` and declare the callable function signature:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个新的`std::packaged_task`并声明可调用函数签名：
- en: '[PRE61]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, we store the future result in the `std::future` variable:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将未来结果存储在`std::future`变量中：
- en: '[PRE62]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Next, we run this task in a separate thread or call it as a function:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在单独的线程中运行此任务或将其作为函数调用：
- en: '[PRE63]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Finally, we wait until the future results are ready:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们等待未来的结果准备就绪：
- en: '[PRE64]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note
  id: totrans-352
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '`std::packaged_task` is non-copyable. So, to run it in the separate thread,
    use the `std::move()` function.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::packaged_task`是不可复制的。因此，要在单独的线程中运行它，请使用`std::move()`函数。'
- en: 'There is one more important thing to take note of. If you don''t want any results
    from the thread and would prefer to wait until the thread finishes its work, you
    can use `std::future<void>`. Now, when you call `future.get()`, your current thread
    will wait at this point. Let''s consider an example:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件重要的事情需要注意。如果您不希望从线程中获得任何结果，并且更喜欢等待线程完成工作，可以使用`std::future<void>`。现在，当您调用`future.get()`时，您的当前线程将在此处等待。让我们考虑一个例子：
- en: '[PRE65]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: As you can see, by waiting for another thread, we are making use of several
    techniques such as condition variables, future results, and promises.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，通过等待另一个线程，我们正在利用诸如条件变量、未来结果和promises等多种技术。
- en: 'Now, let''s move on to the next important feature in the Standard Library –
    the `std::promise<>` template class. With this class, we can set the value of
    the type that we want to receive and then get it using `std::future`. How do we
    work with them? For that, we need to implement a function that takes an `std::promise`
    parameter:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讨论标准库中的下一个重要特性 - `std::promise<>`模板类。使用这个类，我们可以设置我们想要接收的类型的值，然后使用`std::future`获取它。我们如何使用它们？为此，我们需要实现一个接受`std::promise`参数的函数：
- en: '[PRE66]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'When the work is done, we need to initialize a new value with `std::promise`:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 工作完成后，我们需要使用`std::promise`初始化一个新值：
- en: '[PRE67]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'For creating `std::promise` in the place where we''ll be using it, we need
    to write the following code:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们将要使用它的地方创建`std::promise`，我们需要编写以下代码：
- en: '[PRE68]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Once this is done, we must create `std::future` and get it from the promise:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们必须创建`std::future`并从promise获取它：
- en: '[PRE69]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We need to run this function in the separate thread:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在单独的线程中运行此函数：
- en: '[PRE70]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, we need to wait until the future is set:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要等待直到future设置：
- en: '[PRE71]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The complete example of getting the result using promises is as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 使用promises获取结果的完整示例如下：
- en: '[PRE72]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: So, we covered almost everything that's required to write multithreaded applications,
    except one important thing – what would happen if an exception is thrown in the
    separate thread? For example, you pass a function in the thread and it throws
    an exception. In this case, `std::terminate()` will be called for this thread.
    Other threads will continue their job. Let's consider a simple example.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们几乎涵盖了编写多线程应用程序所需的一切，除了一个重要的事情 - 如果在单独的线程中抛出异常会发生什么？例如，您在线程中传递一个函数，它抛出异常。在这种情况下，将为该线程调用`std::terminate()`。其他线程将继续它们的工作。让我们考虑一个简单的例子。
- en: 'We have a `getException()` function that generates a message with a thread
    ID and throws `std::runtime_error`:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个`getException()`函数，它生成带有线程ID的消息并抛出`std::runtime_error`：
- en: '[PRE73]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We also have the `toUppercase()` function. Which converts the given string
    into uppercase and calls the `getException()` function, which throws an exception:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有`toUppercase()`函数。它将给定的字符串转换为大写，并调用`getException()`函数，该函数会抛出异常：
- en: '[PRE74]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Here is the `main()` function, where we create a new thread, `thr`, in the
    `try-catch` block. We catch an exception and print the message to the terminal:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`main()`函数，我们在其中在`try-catch`块中创建一个新线程`thr`。我们捕获异常并将消息打印到终端：
- en: '[PRE75]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'If you run this code in your IDE, you will see the following output:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在IDE中运行此代码，您将看到以下输出：
- en: '![Figure 5.19: The result of an example’s execution'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.19：示例执行的结果'
- en: '](img/C14583_05_19.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_05_19.jpg)'
- en: 'Figure 5.19: The result of an example''s execution'
  id: totrans-381
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.19：示例执行的结果
- en: We can see that `std::terminate()` was called after throwing an exception. When
    you have lots of threads in your program, it's very hard to find the right place
    where the thread was terminated. Fortunately, we have a few mechanisms for catching
    an exception from another thread. Let's consider them all.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到在抛出异常后调用了`std::terminate()`。当您的程序中有很多线程时，很难找到线程终止的正确位置。幸运的是，我们有一些机制可以捕获来自另一个线程的异常。让我们考虑一下它们。
- en: 'The `std::exception_ptr` in the future result and sets the ready flag. Then,
    when you call `get()`, `std::exception_ptr` stored and rethrows the exception.
    All we need to do is place a `get()` call in the `try-catch` block. Let''s consider
    an example. We will use two helper functions from the previous example, that is,
    `getException()` and `toUppercase()`. They will stay the same. In the `main()`
    function, we create an `std::future` object called `result` and run the `toUppercase()`
    function using the `std::async()` function. Then, we call the `get()` function
    of the result object in the `try-catch` block and catch an exception:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 未来结果中的`std::exception_ptr`并设置就绪标志。然后，当您调用`get()`时，`std::exception_ptr`被存储并重新抛出异常。我们所需要做的就是在`try-catch`块中放置一个`get()`调用。让我们考虑一个例子。我们将使用上一个例子中的两个辅助函数，即`getException()`和`toUppercase()`。它们将保持不变。在`main()`函数中，我们创建了一个名为`result`的`std::future`对象，并使用`std::async()`函数运行`toUppercase()`函数。然后，在`try-catch`块中调用`result`对象的`get()`函数并捕获异常：
- en: '[PRE76]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'If you run the preceding code in your IDE, you will get the following output:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在IDE中运行上述代码，您将得到以下输出：
- en: '![Figure 5.20: The result of the example’s execution'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.20：示例执行的结果'
- en: '](img/C14583_05_20.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_05_20.jpg)'
- en: 'Figure 5.20: The result of the example''s execution'
  id: totrans-388
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.20：示例执行的结果
- en: 'As you can see, we caught an exception and now we can handle it in some way.
    The `std::packaged_task<>` class handles exceptions in the same way – it stores
    `std::exception_ptr` in the future result, sets the ready flag, and then `std::future`
    rethrows an exception in the `get()` call. Let''s consider a small example. We
    will use two helper functions from the previous example - `getException()` and
    `toUppercase()`. They will stay the same. In the `main()` function, we create
    an `std::packaged_task` object called `task`. By using the type of our `toUppercase()`
    function, it returns an integer and takes two integers as parameters. We pass
    the `toUppercase()` function to the `task` object. Then, we create an `std::future`
    object called `result` and get the result from the task object using the `get_future()`
    function. Finally, we run the task object in the new thread, `thr`, and in the
    `try-catch` block call the `get()` function of the `result` variable:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们捕获了异常，现在我们可以以某种方式处理它。`std::packaged_task<>`类以相同的方式处理异常 - 它在未来结果中存储`std::exception_ptr`，设置就绪标志，然后`std::future`在`get()`调用中重新抛出异常。让我们考虑一个小例子。我们将使用上一个例子中的两个辅助函数
    - `getException()`和`toUppercase()`。它们将保持不变。在`main()`函数中，我们创建了一个名为`task`的`std::packaged_task`对象。通过使用我们的`toUppercase()`函数的类型，它返回一个整数，并以两个整数作为参数。我们将`toUppercase()`函数传递给`task`对象。然后，我们创建了一个名为`result`的`std::future`对象，并使用`get_future()`函数从task对象获取结果。最后，我们在新线程`thr`中运行task对象，并在`try-catch`块中调用`result`变量的`get()`函数：
- en: '[PRE77]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'If you run this code in your IDE, you will get the following output:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在IDE中运行此代码，您将得到以下输出：
- en: '![Figure 5.21: The result of this example’s execution'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.21：此示例执行的结果'
- en: '](img/C14583_05_21.jpg)'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_05_21.jpg)'
- en: 'Figure 5.21: The result of this example''s execution'
  id: totrans-394
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.21：此示例执行的结果
- en: 'The `std::promise<>` class handles exceptions in another way. It allows us
    to store an exception manually using the `set_exception()` or `set_exception_at_thread_exit()`
    function. To set an exception in `std::promise`, we have to catch it. If we do
    not catch an exception, an error will be set in the destructor of `std::promise`
    as `std::future_errc::broken_promise` in future result. When you call the `get()`
    function, an exception will be rethrown. Let''s consider an example. We will use
    a helper function from the previous example – `getException()`. It''s staying
    the same. However, we will change the `toUppercase()` function and add the third
    parameter, `std::promise`. Now, we will call the `getException()` function in
    the `try` block, catch an exception, and set it to the `std::promise` value:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::promise<>`类以另一种方式处理异常。它允许我们使用`set_exception()`或`set_exception_at_thread_exit()`函数手动存储异常。要在`std::promise`中设置异常，我们必须捕获它。如果我们不捕获异常，在`std::promise`的析构函数中将设置错误，作为未来结果中的`std::future_errc::broken_promise`。当您调用`get()`函数时，异常将被重新抛出。让我们考虑一个例子。我们将使用上一个例子中的一个辅助函数
    - `getException()`。它保持不变。但是，我们将更改`toUppercase()`函数并添加第三个参数`std::promise`。现在，我们将在`try`块中调用`getException()`函数，捕获异常，并将其设置为`std::promise`的值：'
- en: '[PRE78]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Note
  id: totrans-397
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: There are a few ways to set an exception to the promise. First of all, we can
    catch `std::exception` and convert it into `std::exception_ptr` using the `std::make_exception_ptr()`
    function. You can also use the `std::current_exception()` function, which returns
    the `std::exception_ptr` object.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以将异常设置为promise。首先，我们可以捕获`std::exception`并使用`std::make_exception_ptr()`函数将其转换为`std::exception_ptr`。您还可以使用`std::current_exception()`函数，它返回`std::exception_ptr`对象。
- en: 'In the `main()` function, we create a promise of the integer type called `upperResult`.
    We create a future result called `futureRes` and set it from the `upperResult`
    promise value. Next, we create a new thread, `thr`, pass the `toUppercase()` function
    to it, and move the `upperResult` promise. Then, we call the `wait()` function
    of the `futureRes` object, which makes the calling thread wait until the result
    becomes available. Then, in the `try-catch` block, we call the `get()` function
    of the `futureRes` object and it rethrows an exception:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们创建了一个整数类型的promise，称为`upperResult`。我们创建了一个名为`futureRes`的未来结果，并从`upperResult`
    promise值中设置它。接下来，我们创建一个新线程`thr`，将`toUppercase()`函数传递给它，并移动`upperResult` promise。然后，我们调用`futureRes`对象的`wait()`函数，使调用线程等待直到结果变为可用。然后，在`try-catch`块中，我们调用`futureRes`对象的`get()`函数，它重新抛出异常：
- en: '[PRE79]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Note
  id: totrans-401
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: When we create an `std::promise<>` object, we promise that we will obligatorily
    set the value or the exception. If we do not do any that, the destructor of `std::promise`
    will throw an exception, that is, `std::future_error – std::future_errc::broken_promise`.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个`std::promise<>`对象时，我们承诺我们将强制设置值或异常。如果我们没有这样做，`std::promise`的析构函数将抛出异常，即`std::future_error
    - std::future_errc::broken_promise`。
- en: 'If you run this code in your IDE, you will get the following output:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在IDE中运行此代码，您将得到以下输出：
- en: '![Figure 5.22: The result of this example’s execution'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.22：此示例执行的结果'
- en: '](img/C14583_05_22.jpg)'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_05_22.jpg)'
- en: 'Figure 5.22: The result of this example''s execution'
  id: totrans-406
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.22：此示例执行的结果
- en: That's all for handling exceptions in a multithreaded application. As you can
    see, it's very similar to what we do in a single thread. Now, let's put our knowledge
    to practice and write a simple application example that demonstrates how we can
    use different future results for synchronization.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是在多线程应用程序中处理异常的全部内容。正如您所看到的，这与我们在单个线程中所做的非常相似。现在，让我们将我们的知识付诸实践，并编写一个简单的应用程序示例，演示我们如何使用不同的future结果进行同步。
- en: 'Exercise 5: Synchronization with Future Results'
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习5：使用Future结果进行同步
- en: In this exercise, we will write a simple application to demonstrate how we can
    use future results to receive values from the separate threads. We will run the
    `ToUppercase()` callable object three times. We will execute the first task using
    the `std::async()` function, the second task using the `std::packaged_task<>`
    template class, and the last task using `std::thread` and `std::promise`.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一个简单的应用程序来演示如何使用future结果来接收来自不同线程的值。我们将运行`ToUppercase()`可调用对象三次。我们将使用`std::async()`函数执行第一个任务，使用`std::packaged_task<>`模板类执行第二个任务，并使用`std::thread`和`std::promise`执行最后一个任务。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此练习：
- en: 'Include the headers for threading support, namely `<thread>`, streaming support,
    namely `<iostream>`, and `<future>` for future results support:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括用于线程支持的头文件，即`<thread>`，用于流支持的头文件，即`<iostream>`，以及用于future结果支持的`<future>`：
- en: '[PRE80]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Implement a `ToUppercase` class that will convert the given string into uppercase.
    It has two overloaded operators, `()`. The first `operator()` takes the string
    to be converted and returns the result value in uppercase. The second `operator()`
    takes the string to be converted and an `std::promise` and stores the return value
    in a promise:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`ToUppercase`类，将给定的字符串转换为大写。它有两个重载的运算符，`()`。第一个`operator()`接受要转换的字符串并以大写形式返回结果值。第二个`operator()`接受要转换的字符串和一个`std::promise`，并将返回值存储在promise中：
- en: '[PRE81]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now, create a `ToUppercase` object, namely `ptConverter`, and create an `std::packaged_task`,
    namely `upperCaseResult1`, which takes the `ptConverter` object as a parameter.
    Create an `std::future` value and set it from `upperCaseResult1`. Run this task
    in a separate thread:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个`ToUppercase`对象，即`ptConverter`，并创建一个`std::packaged_task`，即`upperCaseResult1`，它以`ptConverter`对象作为参数。创建一个`std::future`值，并从`upperCaseResult1`设置它。在一个单独的线程中运行这个任务：
- en: '[PRE82]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now, create a second `ToUppercase` object, namely `fConverter`. Create an `std::future`
    object called `futureUpperResult2` and set it from `std::async()`:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建第二个`ToUppercase`对象，即`fConverter`。创建一个名为`futureUpperResult2`的`std::future`对象，并从`std::async()`设置它：
- en: '[PRE83]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now. create a third `ToUppercase` object. namely `pConverter`. Create an `std::promise`
    value called `promiseResult`. Then, create an `std::future` value called `futureUpperResult3`
    and set it from `promiseResult`. Now, run the `pConverter` task in the separate
    thread and pass `promiseResult` as an argument:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建第三个`ToUppercase`对象，即`pConverter`。创建一个名为`promiseResult`的`std::promise`值。然后，创建一个名为`futureUpperResult3`的`std::future`值，并从`promiseResult`设置它。现在，在单独的线程中运行`pConverter`任务，并将`promiseResult`作为参数传递：
- en: '[PRE84]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now, to receive the results from all the threads, wait for `futureUpperResult3`
    to be ready and then get all three results and print them:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要接收所有线程的结果，请等待`futureUpperResult3`准备就绪，然后获取所有三个结果并打印它们：
- en: '[PRE85]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Run this code in your editor. You will see the converted strings from all three
    threads.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中运行此代码。您将看到来自所有三个线程的转换后的字符串。
- en: 'You will get the following output:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到以下输出：
- en: '![Figure 5.23: The result of this exercise’s execution'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.23：此练习执行的结果'
- en: '](img/C14583_05_23.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_05_23.jpg)'
- en: 'Figure 5.23: The result of this exercise''s execution'
  id: totrans-427
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.23：此练习执行的结果
- en: So, what have we done here? We split big calculations into smaller parts and
    ran them in separate threads. For long calculations, this will increase performance.
    In this exercise, we learned how to receive results from threads. In this section,
    we also learned how to pass an exception that was thrown in a separate thread
    to the calling thread. We also learned how to synchronize the work of a few threads
    by an event, not only with condition variables but also with future results.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们在这里做了什么？我们将大的计算分成小部分，并在不同的线程中运行它们。对于长时间的计算，这将提高性能。在这个练习中，我们学会了如何从线程中接收结果。在本节中，我们还学会了如何将在单独线程中抛出的异常传递给调用线程。我们还学会了如何通过事件来同步几个线程的工作，不仅可以使用条件变量，还可以使用future结果。
- en: 'Activity 1: Creating a Simulator to Model the Work of the Art Gallery'
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动1：创建模拟器来模拟艺术画廊的工作
- en: In this activity, we are going to create a simulator to model the working of
    an Art Gallery. We have set a limit of visitors to the Gallery – only 50 people
    can be inside. To implement this simulation, we need to create a `Person` class
    that will represent people in the Art Gallery. Also, we need a `Persons` class,
    which is a thread-safe container for people. We also need a `Watchman` class that
    controls how many people are inside it. If the limit exceeds the Watchman, we
    put all the newcomers into a waiting list. Finally, we need a `Generator` class
    that has two threads – one for creating new visitors and another for notifying
    us that somebody has to leave the Gallery. Thus, we will cover working with threads,
    mutexes, condition variables, lock_guards, and unique_locks. This simulator will
    allow us to utilize the techniques that we've covered in this chapter. Thus, before
    attempting this activity, ensure that you have completed all the previous exercises
    in this chapter.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将创建一个模拟器来模拟艺术画廊的工作。我们设置了画廊的访客限制 - 只能容纳50人。为了实现这个模拟，我们需要创建一个`Person`类，代表艺术画廊中的人。此外，我们需要一个`Persons`类，这是一个线程安全的人员容器。我们还需要一个`Watchman`类来控制里面有多少人。如果超过了看门人的限制，我们将所有新来的人放到等待列表中。最后，我们需要一个`Generator`类，它有两个线程
    - 一个用于创建新的访客，另一个用于通知我们有人必须离开画廊。因此，我们将涵盖使用线程、互斥锁、条件变量、锁保护和唯一锁。这个模拟器将允许我们利用本章中涵盖的技术。因此，在尝试此活动之前，请确保您已完成本章中的所有先前练习。
- en: 'To implement this application, we need to describe our classes. We have the
    following classes:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现此应用程序，我们需要描述我们的类。我们有以下类：
- en: '![Figure 5.24: Description of the classes that are used in this activity'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.24：在此活动中使用的类的描述'
- en: '](img/C14583_05_24.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_05_24.jpg)'
- en: 'Figure 5.24: Description of the classes that are used in this activity'
  id: totrans-434
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.24：在此活动中使用的类的描述
- en: 'Let''s create the class diagram before starting the implementation. All of
    the aforementioned classes with relationships are shown in the following diagram:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实现之前，让我们创建类图。以下图表显示了所有上述类及其关系：
- en: '![Figure 5.25: The class diagram'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.25：类图'
- en: '](img/C14583_05_25.jpg)'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_05_25.jpg)'
- en: 'Figure 5.25: The class diagram'
  id: totrans-438
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.25：类图
- en: 'Follow these steps to implement this activity:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现此活动：
- en: Define and implement the Person class, which does nothing except print logs.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义并实现Person类，除了打印日志外什么也不做。
- en: Create some thread-safe storage for Persons that wraps the std::vector class.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为Person创建一些线程安全的存储，包装std::vector类。
- en: Implement the PersonGenerator class, that, in an infinite loop in different
    threads, creates and removes visitors and notifies the Watchman class.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现PersonGenerator类，在不同的线程中进行无限循环，创建和移除访客，并通知Watchman类。
- en: Create the Watchman class that, in an infinite loop in separate threads, moves
    visitors from the queue to another queue on notification from the PersonGenerator
    class.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建Watchman类，在单独的线程中进行无限循环，从PersonGenerator类的通知中将访问者从队列移动到另一个队列。
- en: Declare the corresponding objects in the main() function to simulate the Art
    Gallery and how it works.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在main()函数中声明相应的对象以模拟艺术画廊及其工作方式。
- en: 'After implementing these steps, you should get the following output, where
    you can see the logs from all the implemented classes. Ensure that the simulation
    flows as expected. The expected output should look similar to the following:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这些步骤后，您应该获得以下输出，其中您可以看到所有实现类的日志。确保模拟流程如预期那样进行。预期输出应该类似于以下内容：
- en: '![Figure 5.26: The result of the application’s execution'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.26：应用程序执行的结果'
- en: '](img/C14583_05_26.jpg)'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_05_26.jpg)'
- en: 'Figure 5.26: The result of the application''s execution'
  id: totrans-448
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.26：应用程序执行的结果
- en: Note
  id: totrans-449
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 681.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第681页找到。
- en: Summary
  id: totrans-451
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about working with threads that are supported by
    the C++ Standard Library. This is fundamental if we want to write robust, fast,
    and clear multithreaded applications.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了使用C++标准库支持的线程。如果我们想编写健壮、快速和清晰的多线程应用程序，这是基础。
- en: We started by looking at general concepts regarding concurrency – what parallel,
    concurrent, synchronous, asynchronous, and threaded execution is. Having a clear
    understanding of these concepts allowed us to understand the architectural design
    of the multithreaded application.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先研究了关于并发的一般概念 - 什么是并行、并发、同步、异步和线程执行。对这些概念有清晰的理解使我们能够理解多线程应用程序的架构设计。
- en: Next, we looked at the different issues that we faced while developing multithreaded
    applications, such as data hazards, race conditions, and deadlocks. Understanding
    these issues helped us build a clear synchronized architecture for our projects.
    We considered the synchronization concept on some real-life examples, which gave
    us a good understanding of the challenges that we may face while programming threaded
    applications.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看了开发多线程应用程序时遇到的不同问题，如数据危害、竞争条件和死锁。了解这些问题有助于我们为项目构建清晰的同步架构。我们考虑了一些现实生活中的同步概念示例，这使我们对编程线程应用程序时可能遇到的挑战有了很好的理解。
- en: Next, we tried to work with different Standard Library primitives for synchronization.
    We tried to figure out how to handle race conditions and implemented examples
    of synchronization by events and synchronization by data. Next, we considered
    how the move semantics apply to multithreading. We learned which classes from
    threading support libraries are non-copiable but movable. We also considered how
    the move semantics work in multithreaded closures. Finally, we learned how to
    receive results from separate threads and how to synchronize threads using futures,
    promises, and async.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们尝试使用不同的标准库原语进行同步。我们试图弄清楚如何处理竞争条件，并通过事件同步和数据同步实现了示例。接下来，我们考虑了移动语义如何应用于多线程。我们了解了哪些来自线程支持库的类是不可复制但可移动的。我们还考虑了移动语义在多线程闭包中的工作方式。最后，我们学会了如何从单独的线程接收结果，以及如何使用期望、承诺和异步来同步线程。
- en: We put all of these new skills into practice by building an Art Gallery simulator.
    We built a multithreaded application with one main thread and four child threads.
    We implemented communication between them by using condition variables. We protected
    them using shared data by mutexes. In all, we employed everything we learned about
    in this chapter.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过构建一个艺术画廊模拟器来将所有这些新技能付诸实践。我们构建了一个多线程应用程序，其中包括一个主线程和四个子线程。我们通过使用条件变量之间实现了它们之间的通信。我们通过互斥锁保护了它们的共享数据。总之，我们运用了本章学到的所有内容。
- en: In the next chapter, we're going to be taking a closer look at I/O operations
    and classes in C++. We will start by looking at the I/O support of the Standard
    Library. Then, we will move on to working with streams and asynchronous I/O operations.
    Next, we will learn about the interaction of threads and I/O. We will write an
    activity that will allow us to master our skills in I/O work in C++.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更仔细地研究C++中的I/O操作和类。我们将首先查看标准库的I/O支持。然后，我们将继续使用流和异步I/O操作。接下来，我们将学习线程和I/O的交互。我们将编写一个活动，让我们能够掌握C++中的I/O工作技能。
