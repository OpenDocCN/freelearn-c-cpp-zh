- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Handling Errors with C++
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 C++ 处理错误
- en: This chapter will focus on error handling in C++. As a programmer, you will
    inevitably encounter situations where you need to determine the best approach
    to propagate program errors. Whether you use error codes or exceptions, we will
    delve into them to gain a better understanding of how to use them effectively.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍 C++ 中的错误处理。作为一名程序员，您不可避免地会遇到需要确定最佳方法来传播程序错误的情况。无论您使用错误代码还是异常，我们都会深入研究它们，以更好地了解如何有效地使用它们。
- en: In this chapter, we will examine how to handle errors reported by POSIX APIs
    using C++. We will begin by covering the `errno` thread-local variable and the
    `strerror` function. After that, we will introduce `std::error_code` and `std::error_condition`
    and demonstrate how they help to wrap POSIX errors that come from POSIX APIs.
    We will also investigate custom error categories, which allow us to compare errors
    produced by various sources and develop platform-independent error-handling code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何使用 C++ 处理 POSIX API 报告的错误。我们将从介绍 `errno` 线程局部变量和 `strerror` 函数开始。之后，我们将介绍
    `std::error_code` 和 `std::error_condition`，并演示它们如何帮助封装来自 POSIX API 的 POSIX 错误。我们还将研究自定义错误类别，这允许我们比较来自不同来源的错误，并开发平台无关的错误处理代码。
- en: As we progress, we will learn about exceptions in C++ and how to convert `std::error_code`
    into a `std::system_error` exception. We will also explore some best practices
    for working with exceptions, such as throwing exceptions by value and catching
    them by reference. Additionally, we will become acquainted with object slicing,
    a side effect that can occur when we catch exceptions by value rather than by
    reference. Finally, we will delve into the RAII technique in C++, which eliminates
    the need for a `finally` construct in the language.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们不断深入，我们将了解 C++ 中的异常以及如何将 `std::error_code` 转换为 `std::system_error` 异常。我们还将探讨一些与异常一起工作的最佳实践，例如通过值抛出异常并通过引用捕获它们。此外，我们将熟悉对象切片，这是一种在通过值而不是通过引用捕获异常时可能发生的副作用。最后，我们将深入研究
    C++ 中的 RAII 技术，该技术消除了语言中 `finally` 构造的需求。
- en: By the end of this chapter, you will have a thorough understanding of the various
    ways to handle errors in C++, and you will be familiar with several techniques
    for creating error-resistant code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将彻底了解在 C++ 中处理错误的多种方式，并且您将熟悉创建容错代码的几种技术。
- en: 'Summing up, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们将涵盖以下主题：
- en: Handling errors from POSIX APIs with C++
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 C++ 处理 POSIX API 的错误
- en: From error codes to exceptions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从错误代码到异常
- en: Alright, it’s time to begin!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在是时候开始了！
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All examples in this chapter have been tested in an environment with the following
    configuration:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有示例都在以下配置的环境中进行了测试：
- en: Linux Mint 21 Cinnamon edition
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux Mint 21 Cinnamon 版本
- en: 'GCC 12.2 with compiler flags:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCC 12.2 及编译器标志：
- en: '`-``std=c++20`'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-std=c++20`'
- en: A stable internet connection
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稳定的互联网连接
- en: Please make sure your environment is at least that recent. For all the examples,
    you can alternatively use [https://godbolt.org/](https://godbolt.org/).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请确保您的环境至少与此一样新。对于所有示例，您还可以使用 [https://godbolt.org/](https://godbolt.org/)。
- en: All code examples in this chapter are available for download from [https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%205](https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%205).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中所有代码示例均可从 [https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%205](https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%205)
    下载。
- en: Handling errors from POSIX APIs with C++
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 C++ 处理 POSIX API 的错误
- en: In POSIX-compliant systems, such as Unix and Linux, error handling is based
    on the use of error codes and error messages to communicate errors between functions
    and applications.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在符合 POSIX 标准的系统（如 Unix 和 Linux）中，错误处理基于使用错误代码和错误消息在函数和应用程序之间通信错误。
- en: In general, when a function encounters an error, it returns a non-zero error
    code and sets the `errno` global variable to a specific error value that indicates
    the nature of the error. The application can then use the `errno` variable to
    determine the cause of the error and take appropriate action.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，当一个函数遇到错误时，它会返回一个非零错误代码并将全局变量 `errno` 设置为特定的错误值，以指示错误的性质。然后应用程序可以使用 `errno`
    变量来确定错误的起因并采取适当的行动。
- en: In addition to error codes, POSIX-compliant functions often provide error messages
    that describe the nature of the error in more detail. These error messages are
    typically accessed using the `strerror` function, which takes an error code as
    input and returns a pointer to a sequence of characters terminated with a null
    character containing the corresponding error message.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了错误代码之外，POSIX 兼容的函数通常还提供描述错误性质的错误消息。这些错误消息通常使用 `strerror` 函数访问，该函数接受一个错误代码作为输入，并返回一个指向以空字符终止的字符序列的指针，包含相应的错误消息。
- en: The POSIX error-handling style requires developers to check for errors after
    each system call or function call that may fail and to handle errors in a consistent
    and meaningful way. This can include logging error messages, retrying failed operations,
    or terminating the program in the event of a critical error.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 错误处理风格要求开发者在每次可能失败的系统调用或函数调用之后检查错误，并以一致且有意义的方式处理错误。这可能包括记录错误消息、重试失败的操作或在发生关键错误时终止程序。
- en: Let’s look at the following example where we demonstrate how to use the `errno`
    variable and the `strerror()` function to handle errors from POSIX functions in
    C++.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例，其中我们演示了如何使用 `errno` 变量和 `strerror()` 函数来处理 C++ 中 POSIX 函数的错误。
- en: 'The example uses the `open()` and `close()` POSIX functions, which try to open
    and close a file from the filesystem of our Linux test environment:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例使用 `open()` 和 `close()` POSIX 函数，这些函数试图从我们的 Linux 测试环境的文件系统中打开和关闭文件：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, we attempt to open a file for reading called `no-such-file.txt`
    using the `open()` function; see marker `{1}`. In case of success, `open()` returns
    a non-negative integer, which corresponds to the file descriptor ID of the successfully
    opened file. If `open()` returns `-1`, we know an error occurred, so we print
    the error message using `strerror(errno)` and return the value of `errno` where
    the corresponding error code is written.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们尝试使用 `open()` 函数打开一个名为 `no-such-file.txt` 的文件进行读取；见标记 `{1}`。如果成功，`open()`
    返回一个非负整数，这对应于成功打开的文件的文件描述符 ID。如果 `open()` 返回 `-1`，我们知道发生了错误，因此我们使用 `strerror(errno)`
    打印错误信息，并返回 `errno` 的值，其中包含相应的错误代码。
- en: If `open()` succeeds, we do something with the file and then close it using
    the `close()` function. If `close()` returns `-1`, we print the error message
    again using `strerror(errno)` and return the value of `errno`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `open()` 成功，我们对文件进行一些操作，然后使用 `close()` 函数关闭它。如果 `close()` 返回 `-1`，我们再次使用
    `strerror(errno)` 打印错误信息，并返回 `errno` 的值。
- en: This is a common error-handling technique for POSIX functions. In case of an
    error, they return `-1` and set the `errno` variable with the corresponding error
    code. The `errno` variable is a *thread-local* modifiable variable of the `int`
    type. This means that it is safe for you to use it in a multithreaded environment.
    Each thread will have its own copy, and POSIX methods invoked by this thread will
    use this instance to report errors.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种常见的 POSIX 函数错误处理技术。在发生错误的情况下，它们返回 `-1` 并将 `errno` 变量设置为相应的错误代码。`errno` 变量是一个
    `int` 类型的 *线程局部* 可修改变量。这意味着在多线程环境中使用它是安全的。每个线程将有自己的副本，并且由该线程调用的 POSIX 方法将使用此实例来报告错误。
- en: 'In order to print a meaningful message in the case of an error, we use the
    `strerror()` function, which accepts an integer and tries to match its value to
    a well-known list of descriptions of system-specific error codes. The `open()`
    function can report several errors and set different values to `errno` depending
    on the type of the occurred error. Let’s see the output of the example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在发生错误的情况下打印有意义的消息，我们使用 `strerror()` 函数，该函数接受一个整数并尝试将其值与一组已知的系统特定错误代码描述相匹配。`open()`
    函数可以报告多个错误，并根据发生的错误类型将不同的值设置为 `errno`。让我们看看示例的输出：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we can see, the `open()` method has failed to open the file because it doesn’t
    exist. In this case, it sets `errno` to a value of `2`, which corresponds to the
    `ENOENT` value specified in the documentation of the function. It is a good practice
    to explicitly set `errno` to `0` before you do a system call to ensure that after
    the call, you can read its real response.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`open()` 方法未能打开文件，因为它不存在。在这种情况下，它将 `errno` 设置为 `2` 的值，这对应于函数文档中指定的 `ENOENT`
    值。在系统调用之前显式将 `errno` 设置为 `0` 是一种良好的做法，以确保调用之后可以读取其实际响应。
- en: Using std::error_code and std::error_condition
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 std::error_code 和 std::error_condition
- en: The C++ Standard Library provides several classes for handling errors from low-level
    APIs such as the POSIX interface. These classes are `std::error_code` for handling
    system-specific errors and `std::error_condition`, which deals with portable error
    codes. Let us explore both styles in more detail.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库为处理来自POSIX接口等低级API的错误提供了几个类。这些类是用于处理特定系统错误的`std::error_code`和用于处理可移植错误代码的`std::error_condition`。让我们更详细地探讨这两种风格。
- en: std::error_code
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: std::error_code
- en: 'Let’s rework our previous example in such a way that we provide a function
    for the creation of a directory with a specific directory path:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新整理之前的例子，以便提供一个用于创建具有特定目录路径的目录的函数：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Rather than the client of our new function, `CreateDirectory`, using the `errno`
    variable directly to determine whether the operation was successful, we will make
    use of a utility class provided by the Standard Library – `std::error_code`. `std::error_code`
    is used to store and transmit error codes as they were generated by libraries
    or system calls. It is a kind of wrapper class for which there are predefined
    categories of errors to work with. The errors returned by the POSIX functions
    are mostly standard and, as such, are predefined in the Standard Library. Therefore,
    it is straightforward to create a `std::error_code` instance from the `errno`
    value and specify that this value corresponds to `std::generic_category()`, as
    done in marker `{1}` in the preceding example. The `errno` value is de facto casted
    to a constant of the `std::errc` enumerator.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们新函数的客户端`CreateDirectory`直接使用`errno`变量来确定操作是否成功不同，我们将利用标准库提供的实用类`std::error_code`。`std::error_code`用于存储和传输由库或系统调用生成的错误代码。它是一种包装类，其中预定义了用于处理错误的错误类别。POSIX函数返回的错误大多是标准的，因此它们在标准库中是预定义的。因此，从`errno`值创建一个`std::error_code`实例并指定该值对应于`std::generic_category()`，就像在先前的例子中的标记`{1}`所做的那样，是直截了当的。`errno`值实际上被转换成了`std::errc`枚举器的一个常量。
- en: The created `std::error_code` object has two methods that can give you details
    about the underlying error. The `std::error_code::message()` method returns a
    meaningful string that can be used for logging purposes. The `std::error_code::value()`method,
    in our example, returns the value initially stored in the `errno` variable. But
    probably the most notable operation that the user can use from the `std::error_code`
    object is the predefined `operator bool()` of the class. In the case of an error
    stored in the object, it returns `true`; otherwise, it returns `false`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的`std::error_code`对象有两个方法可以提供有关底层错误的信息。`std::error_code::message()`方法返回一个有意义的字符串，可用于日志记录。在我们的例子中，`std::error_code::value()`方法返回最初存储在`errno`变量中的值。但用户可能最值得注意的是`std::error_code`对象中预定义的`operator
    bool()`。如果对象中存储了错误，它返回`true`；否则返回`false`。
- en: 'As you can see from the preceding example, the caller of the `CreateCategory()`
    method checks whether an error occurred, and if so, it gets the message stored
    for this error; see marker `{2}`. Here, you can find the output of the program
    run on our test environment:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，`CreateCategory()`方法的调用者检查是否发生了错误，如果是，则获取存储在此错误中的消息；请参阅标记`{2}`。在这里，您可以找到在我们测试环境中运行的程序输出：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As is visible from the program’s output, the first `CreateDirectory()` invocation
    succeeds but the second one fails; see marker `{3}`. This is because the implementation
    of `CreateDirectory()` first checks whether such a directory already exists and
    if not, it creates it for us. But if the directory exists, the `mkdir()` system
    call returns `–1` and sets `errno` to `EEXIST`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如程序输出所示，第一次`CreateDirectory()`调用成功，但第二次调用失败；请参阅标记`{3}`。这是因为`CreateDirectory()`的实现首先检查是否存在这样的目录，如果不存在，则为我们创建它。但如果目录已存在，`mkdir()`系统调用返回`-1`并将`errno`设置为`EEXIST`。
- en: Something important about the `std::error_code` class is that it is platform
    specific. This means that the error values stored in it strongly depend on the
    underlying OS. In the case of a POSIX-like system, which Linux is, the error value
    we have is `EEXIST`. But this is not necessarily true for other OSs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`std::error_code`类的一个重要事实是它是平台特定的。这意味着存储在其中的错误值强烈依赖于底层操作系统。在类似POSIX的系统（如Linux）的情况下，我们有的错误值是`EEXIST`。但这对其他操作系统不一定成立。
- en: 'Therefore, if we design our code to be as platform agnostic as possible, we
    need to avoid comparations such as the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们设计我们的代码尽可能不依赖于平台，我们需要避免以下比较：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: But we also need a way to ensure that a directory that already exists doesn’t
    break our program logic. Yes, from a POSIX standpoint this is an error, but in
    our specific business logic, this is not a problem for the program execution to
    continue.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们还需要一种方法来确保已存在的目录不会破坏我们的程序逻辑。是的，从POSIX的角度来看这是一个错误，但就我们的特定业务逻辑而言，这并不是程序执行继续的问题。
- en: std::error_condition
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: std::error_condition
- en: 'The right approach to address this problem is with the help of another Standard
    Library class – `std::error_condition`. As the name suggests, its main purpose
    is to provide conditional program logic. Let’s slightly rework the `CreateDirectory()`
    method from the earlier example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的正确方法是有助于另一个标准库类——`std::error_condition`。正如其名所示，它的主要目的是提供条件程序逻辑。让我们对前面示例中的`CreateDirectory()`方法进行轻微的重构：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, the difference from the previous example is how we construct
    the `error_code` object. In the reworked code, we first create an object of the
    `std::errc` type and initialize it with the value of POSIX `errno`; see marker
    `{1}`. The `std::errc` class is a scoped enumerator class. It defines *portable
    error conditions* that correspond to the specific POSIX error codes. This implies
    that instead of relying on a platform-specific macro that corresponds to a particular
    POSIX error code, such as `EEXIST`, we switch to an error that will have the same
    error condition regardless of the platform it comes from.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，与上一个示例的不同之处在于我们构建`error_code`对象的方式。在重构的代码中，我们首先创建一个`std::errc`类型的对象，并用POSIX
    `errno`的值初始化它；参见标记 `{1}`。`std::errc`是一个作用域枚举类。它定义了与特定POSIX错误码相对应的*可移植错误条件*。这意味着我们不再依赖于与特定POSIX错误码相对应的平台特定宏，例如`EEXIST`，而是切换到一个无论来自哪个平台都将具有相同错误条件的错误。
- en: Important note
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'You can find the predefined portable error conditions of the `std::errc` scoped
    enumerator, which correspond to their equivalent POSIX error codes, here: [https://en.cppreference.com/w/cpp/error/errc](https://en.cppreference.com/w/cpp/error/errc).'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到`std::errc`作用域枚举器预定义的可移植错误条件，它们对应于它们的等效POSIX错误码：[https://en.cppreference.com/w/cpp/error/errc](https://en.cppreference.com/w/cpp/error/errc)。
- en: Once we create an instance of `std::errc`, we pass it to the factory method
    for the creation of error codes – `std::make_error_code()` (see marker `{2}`)
    – which generates for us a `std::error_code` of a generic category.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了`std::errc`的一个实例，我们就将其传递给创建错误码的工厂方法——`std::make_error_code()`（参见标记 `{2}`）——它为我们生成一个通用类别的`std::error_code`。
- en: 'Now, let’s see how the `main()` method is changed in order to be platform independent:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`main()`方法是如何被修改以实现平台无关性的：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We still have two invocations of the `CreateDirectory()` method, and the second
    one still returns an `error_code`. But the main difference comes from how we compare
    the `ecode` object; see marker `{3}`. Instead of comparing it with an integer
    value of the error POSIX code, we compare it against an object that holds a portable
    error condition – `std::errc::file_exists`. It has the same semantics, saying
    that the file already exists, but it is platform independent. In the next section,
    we will see how useful this could be.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然调用了两次`CreateDirectory()`方法，第二次调用仍然返回了一个`error_code`。但主要的不同之处在于我们比较`ecode`对象的方式；参见标记
    `{3}`。我们不是将其与POSIX错误码的整数值进行比较，而是将其与一个包含可移植错误条件的对象进行比较——`std::errc::file_exists`。它具有相同的语义，表示文件已存在，但它具有平台无关性。在下一节中，我们将看到这有多么有用。
- en: Using custom error categories
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用自定义错误类别
- en: Every software developer should strive as much as possible to write portable
    code. Writing portable code provides reusability, which can significantly reduce
    development costs. Of course, this is not always possible. There are use cases
    where the code you write is dedicated to a specific system. But for all the rest,
    abstracting your code from the underlying system allows you to easily migrate
    it to other systems without carrying out huge refactoring to make it work. This
    is safer and cheaper.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 每个软件开发者都应该尽可能努力编写可移植的代码。编写可移植的代码提供了可重用性，这可以显著降低开发成本。当然，这并不总是可能的。有些情况下，你编写的代码是针对特定系统定制的。但对于所有其他情况，将你的代码从底层系统中抽象出来，可以让你轻松地将它迁移到其他系统，而无需进行大量重构以使其工作。这更安全，也更经济。
- en: Let’s get back to our previous example, where we tried to abstract the error
    code received from a POSIX system call. It should be comparable against a portable
    error condition such as `std::errc::file_exists`. We will extend this with the
    following use case. Imagine that we have a custom library that also works with
    files. Let’s call it `MyFileLibrary`. But this library doesn’t support the POSIX
    error codes. It provides a different *category* of custom error codes that semantically
    correspond to some of the POSIX codes but with different error values.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们之前的例子，我们试图抽象从POSIX系统调用接收到的错误代码。它应该可以与可移植的错误条件，如 `std::errc::file_exists`
    进行比较。我们将通过以下用例扩展这一点。想象一下，我们有一个自定义库，它也处理文件。让我们称它为 `MyFileLibrary`。但这个库不支持POSIX错误代码。它提供了一种不同的
    *类别* 的自定义错误代码，这些代码在语义上对应于一些POSIX代码，但具有不同的错误值。
- en: 'The library supports the following errors with their corresponding error codes:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 该库支持以下错误及其相应的错误代码：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, our library can return the `FileAlreadyExists` enumerated constant,
    just like the `mkdir()` system call does, but with a different error value – `1000`.
    So, the main logic that consumes both `MyFileLibrary` and `mkdir()` should be
    able to handle these errors in the same way, because they are semantically equal.
    Let’s see how this can be done.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的库可以返回 `FileAlreadyExists` 枚举常量，就像 `mkdir()` 系统调用一样，但具有不同的错误值 – `1000`。因此，消耗
    `MyFileLibrary` 和 `mkdir()` 的主要逻辑应该能够以相同的方式处理这些错误，因为它们在语义上是相等的。让我们看看如何做到这一点。
- en: 'In our previous example, we created the error code returned by the POSIX API:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们创建了POSIX API返回的错误代码：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We used `std::generic_category`, which is a derived class from the base category
    class – `std::error_category`. It is predefined for us in the Standard Library
    in such a way that it *knows* POSIX error codes. This is effectively the place
    where the translation between the real error code returned by the API and `std::error_condition`
    is done. So, in order to expose the same capability for `MyFileLibrary`, we need
    to define a new `std::error_category` derived class. We will name it `MyFileLibraryCategory`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `std::generic_category`，它是从基类别类 – `std::error_category` 派生出来的。它在我们标准库中是预定义的，这样它就
    *知道* POSIX 错误代码。这实际上是API返回的实际错误代码与 `std::error_condition` 之间进行转换的地方。因此，为了使 `MyFileLibrary`
    具有相同的特性，我们需要定义一个新的 `std::error_category` 派生类。我们将它命名为 `MyFileLibraryCategory`：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `std::error_category` base class has several *virtual* methods that, if
    overridden in the derived class, allow custom behavior. In our example, we have
    overridden the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::error_category` 基类有几个 *虚* 方法，如果派生类中重写了这些方法，则允许自定义行为。在我们的例子中，我们重写了以下方法：'
- en: The `name()` method, which is used to report which category this error belongs
    to; see marker `{1}`
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name()` 方法，用于报告该错误属于哪个类别；参见标记 `{1}`'
- en: The `message()` method, which is used to report a message string that corresponds
    to a specific error value; see marker `{2}`
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message()` 方法，用于报告与特定错误值相对应的消息字符串；参见标记 `{2}`'
- en: The `equivalent()` method, which is used to make a comparison between the custom
    error code generated by our library and the predefined `std::error_condition`
    values
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equivalent()` 方法，用于将我们的库生成的自定义错误代码与预定义的 `std::error_condition` 值进行比较'
- en: The `equivalent()` method gets the custom error code, casts it to a value of
    `MyFileLibraryError`, and, for each specific case, decides what `condition` it
    matches; see marker `{3}`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`equivalent()` 方法获取自定义错误代码，将其转换为 `MyFileLibraryError` 类型的值，并为每个特定情况决定它匹配的 `condition`；参见标记
    `{3}`。'
- en: 'Now, since we have our new, shiny custom error category – `MyFileLibraryCategory`
    – let’s see how to use it:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，既然我们有了我们新的、闪亮的自定义错误类别 – `MyFileLibraryCategory` – 让我们看看如何使用它：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first step we need to take is to instantiate an object of our custom category;
    see marker `{1}`. Then, we create an `error_code` instance, which we initialize
    with the `FileAlreadyExists` error value and specify that it is from the `MyFileLibraryCategory`
    category; see marker `{2}`. Since we have a valid instance of an error code –
    `file_exists` – we are ready to compare it against the platform-independent `std::errc::file_exists`
    error condition.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要采取的第一步是实例化我们自定义类别的对象；参见标记 `{1}`。然后，我们创建一个 `error_code` 实例，将其初始化为 `FileAlreadyExists`
    错误值，并指定它属于 `MyFileLibraryCategory` 类别；参见标记 `{2}`。由于我们有一个有效的错误代码实例 – `file_exists`
    – 我们现在可以将其与平台无关的 `std::errc::file_exists` 错误条件进行比较。
- en: 'The following is the output of the program:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为程序的输出：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, the comparation between an error generated from `MyFileLibrary`
    and the generic `std::errc::file_exists` is now possible with the help of the
    custom error category we defined – `MyFileLibraryCategory`. The corresponding
    error message is displayed (see marker `{3}`) and the category as well (see marker
    `{4}`).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，借助我们定义的自定义错误类别`MyFileLibraryCategory`，现在可以比较由`MyFileLibrary`生成的错误和通用的`std::errc::file_exists`。相应的错误消息会显示出来（见标记
    `{3}`），以及类别本身（见标记 `{4}`）。
- en: Important note
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Here, you can find the full description with all virtual methods that the `std::error_category`
    base class exposes: [https://en.cppreference.com/w/cpp/error/error_category](https://en.cppreference.com/w/cpp/error/error_category).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以找到`std::error_category`基类公开的所有虚拟方法的完整描述：[https://en.cppreference.com/w/cpp/error/error_category](https://en.cppreference.com/w/cpp/error/error_category)。
- en: Now that we are familiar with the usage of error codes and error conditions,
    let’s see how we can use the powerful mechanism of C++ exceptions and propagate
    errors.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了错误代码和错误条件的使用，让我们看看如何使用C++异常的强大机制来传播错误。
- en: From error codes to exceptions
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从错误代码到异常
- en: Exception handling is an important aspect of programming, especially when dealing
    with errors that can disrupt the normal flow of a program. While there are several
    ways to handle errors in a code base, exceptions provide a powerful mechanism
    for handling errors in a way that separates error flow from normal program flow.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理是编程的一个重要方面，尤其是在处理可能破坏程序正常流程的错误时。虽然代码库中处理错误的方法有多种，但异常提供了一种强大的机制，以分离错误流程和正常程序流程的方式来处理错误。
- en: When working with error codes, it can be challenging to ensure that all error
    cases are properly handled and that the code remains maintainable. By wrapping
    error codes in exceptions, we can create a more pragmatic approach to error handling
    that makes it easier to reason about code and catch errors in a more centralized
    manner.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理错误代码时，确保所有错误情况都得到适当处理并且代码保持可维护性可能具有挑战性。通过将错误代码封装在异常中，我们可以创建一种更实用的错误处理方法，这使得推理代码和集中捕获错误变得更加容易。
- en: It’s hard to say which approach is better when dealing with error handling in
    a code base, and the decision to use exceptions should be based on pragmatic considerations.
    While exceptions can provide significant benefits in terms of code organization
    and maintainability, they may come with a performance penalty that may not be
    acceptable in certain systems.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理代码库中的错误处理时，很难说哪种方法更好，而使用异常的决定应基于实用考虑。虽然异常可以在代码组织和可维护性方面提供显著的好处，但它们可能带来性能上的惩罚，这在某些系统中可能不可接受。
- en: At their core, exceptions are a way to segregate the normal program flow from
    the error flow. Unlike error codes, which can be ignored, exceptions cannot be
    easily overlooked, making them a more reliable way to ensure that errors are handled
    in a consistent and centralized manner.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，异常是一种将正常程序流程与错误流程分离的方法。与可以忽略的错误代码不同，异常不容易被忽视，这使得它们成为确保以一致和集中方式处理错误的一种更可靠的方法。
- en: While exceptions may not be the right choice for every code base, they offer
    a powerful way to handle errors that can make code easier to maintain and reason
    about. By understanding how to correctly use exceptions, programmers can make
    informed decisions about how to handle errors in their code. Let’s get deeper
    into this.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然异常可能不是每个代码库的最佳选择，但它们提供了一种强大的错误处理方式，可以使代码更容易维护和推理。通过了解如何正确使用异常，程序员可以就如何在代码中处理错误做出明智的决定。让我们更深入地探讨这一点。
- en: std::system_error
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`std::system_error`'
- en: 'In the previous section, we created a program that properly handles errors
    reported by the POSIX system call – `mkdir()`. Now, let’s see how we can improve
    the error handling in this program using exceptions instead of error codes. Here
    is the revisited `CreateDirectory()` method:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们创建了一个程序，该程序正确处理了POSIX系统调用`mkdir()`报告的错误。现在，让我们看看如何使用异常而不是错误代码来改进这个程序中的错误处理。以下是重访的`CreateDirectory()`方法：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the `CreateDirectory()` method, we make a system call using the `mkdir()`
    API, which, in the case of failure, returns a non-zero result and stores a POSIX
    error code in the `errno` variable. Nothing new so far. Just as in our previous
    example, we create an `std::error_code` from the value of `errno` (see marker
    `{2}`) to report it to the caller of our `CreateDirectory()` method. But instead
    of returning the error directly as a result of the function, we prefer to use
    an exception for this and make our function `{1}`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `CreateDirectory()` 方法中，我们使用 `mkdir()` API 进行系统调用，如果失败，则返回非零结果并将 POSIX 错误代码存储在
    `errno` 变量中。到目前为止没有什么新的。就像我们之前的例子一样，我们从一个值创建一个 `std::error_code`（参见标记 `{2}`）来向我们的
    `CreateDirectory()` 方法的调用者报告它。但与直接返回函数的结果错误不同，我们更愿意使用异常来做这件事，并使我们的函数 `{1}`。
- en: Since we already have an error code object created, we will use it to create
    an exception from it. In order to do so, we will use a predefined exception class
    from the Standard Library that is explicitly defined to wrap `std::error_code`
    objects – `std::system_error`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经有了一个错误代码对象被创建，我们将使用它来从它创建一个异常。为了做到这一点，我们将使用标准库中的一个预定义的异常类，该类明确定义为封装 `std::error_code`
    对象 – `std::system_error`。
- en: '`std::system_error` is a derived type from the `std::exception` interface class
    from the C++ Standard Library. It is used by various library functions, which
    typically interface with OS facilities and can report errors either by generating
    `std::error_code` or `std::error_condition`.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::system_error` 是从 C++ 标准库的 `std::exception` 接口类派生出来的派生类型。它被各种库函数使用，这些函数通常与
    OS 功能接口，可以通过生成 `std::error_code` 或 `std::error_condition` 来报告错误。'
- en: '![Figure 5.1 – Inheritance diagram of std::system_error exception](img/Figure_5.1_B20833.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – std::system_error 异常的继承图](img/Figure_5.1_B20833.jpg)'
- en: Figure 5.1 – Inheritance diagram of std::system_error exception
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – std::system_error 异常的继承图
- en: In our example, in order to create an `std::system_error` object, we have to
    pass to its constructor the instance of `std::error_code ecode`, which we already
    created; see marker `{3}`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，为了创建一个 `std::system_error` 对象，我们必须将其构造函数传递给 `std::error_code ecode`
    的实例，这是我们之前创建的；参见标记 `{3}`。
- en: As with any other exception derived from the base exception class from the Standard
    Library – `std::exception` – `std::system_error` has the `what()` method. It aims
    to report a meaningful string explaining details about the error behind the exception.
    More specifically, it calls under the hood the `message()` method of the `std::error_code`
    object it wraps and returns its result.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与从标准库的基异常类 `std::exception` 派生出来的任何其他异常一样，`std::system_error` 有一个 `what()` 方法。它的目的是报告一个有意义的字符串，解释异常背后的错误细节。更具体地说，它调用封装的
    `std::error_code` 对象的 `message()` 方法，并返回其结果。
- en: Since we already have a new, shiny exception object created, we now need to
    *throw* it back to the caller of our API. This is done with the `throw` keyword;
    see marker `{4}`. An important note is that we throw the exception object by *value*;
    we don’t throw a reference or a pointer to it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经有了一个新的、闪亮的异常对象被创建，我们现在需要*抛出*它回到我们的 API 的调用者那里。这是通过 `throw` 关键字完成的；参见标记
    `{4}`。一个重要的提示是，我们通过*值*抛出异常对象；我们不抛出对它的引用或指针。
- en: Important note
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As a rule of thumb, wherever possible, throw your exceptions by value.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，尽可能通过值传递抛出异常。
- en: One of the key advantages of exceptions over error codes is that they *can’t
    be omitted* by the caller. When a function returns an error code, it is up to
    the function’s caller to decide whether to check the return value or not. There
    are some cases where the return value is not checked by mistake, and this leads
    to bugs in the program. When using exceptions as an error-handling mechanism,
    there is no such possibility. Once an exception is thrown, it propagates up the
    call stack until it is either caught by the appropriate program exception-handling
    logic or reaches the top of the function stack. If the exception is not caught
    anywhere during its propagation path, known also as *stack unwinding*, then it
    terminates the program by invoking the `std::terminate` function.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 异常相对于错误代码的一个关键优点是它们*不能被调用者省略*。当一个函数返回一个错误代码时，决定是否检查返回值的是函数的调用者。有些情况下，返回值没有检查可能是由于错误，这会导致程序中的错误。当使用异常作为错误处理机制时，没有这样的可能性。一旦抛出异常，它就会沿着调用栈向上传播，直到被适当的程序异常处理逻辑捕获或达到函数栈的顶部。如果在传播路径的任何地方都没有捕获到异常，也称为*栈展开*，那么它将通过调用
    `std::terminate` 函数来终止程序。
- en: Important note
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Check out the following `std::system_error` reference page: [https://en.cppreference.com/w/cpp/error/system_error](https://en.cppreference.com/w/cpp/error/system_error).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下 `std::system_error` 参考页面：[https://en.cppreference.com/w/cpp/error/system_error](https://en.cppreference.com/w/cpp/error/system_error).
- en: 'Now, let’s get back to our example and see how the `main()` method should be
    reworked in order to handle the exception thrown from the `CreateDirectory()`
    method:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的示例，看看 `main()` 方法应该如何重新设计以处理 `CreateDirectory()` 方法抛出的异常：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Unlike error codes, which, once returned by a function, need to be assigned
    and checked, the exceptions need to be caught and appropriate actions should be
    taken. Catching exceptions in C++ is done with the help of the try-catch construction
    in the language. In the preceding example, you can see that we invoke the `CreateDirectory()`
    method twice because the second invocation will generate an error, which will
    be propagated up the stack as an exception. This exception will be caught by the
    `catch` clause in marker `{5}`. As you can see, the `catch` clause expects a parameter
    that specifies what should be caught; see marker `{5}`. Its syntax is similar
    to the function’s parameter list, where you can pass objects either by value or
    by reference.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与错误代码不同，一旦函数返回，就需要分配和检查，异常需要被捕获，并应采取适当的行动。在 C++ 中，通过语言中的 try-catch 构造来捕获异常。在前面的示例中，你可以看到我们调用了两次
    `CreateDirectory()` 方法，因为第二次调用将生成一个错误，该错误将作为异常向上传播。这个异常将被标记 `{5}` 中的 `catch` 子句捕获。正如你所看到的，`catch`
    子句期望一个参数，指定应该捕获什么；参见标记 `{5}`。其语法类似于函数的参数列表，其中你可以通过值或引用传递对象。
- en: In our example, we catch the exception thrown by the `CreateDirectory()` method
    by *constant reference*. The reason why we don’t catch by value is to avoid unnecessary
    object copying and – more importantly – to avoid *object slicing*. We will get
    deeper into the specifics of the exception-catching techniques in C++ soon, but
    for now, let’s focus on our current example. Once we catch the exception, we can
    extract the `error_condition` object from it; see marker `{6}`. This is possible
    because the `system_error` class supports error codes and error conditions and
    enables us to fetch them. When we have `error_condition`, we can successfully
    check against the well-known `errc` codes whether this exception is a real problem
    for our program or it can be omitted; see marker `{7}`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们通过*常量引用*捕获了 `CreateDirectory()` 方法抛出的异常。我们不通过值捕获的原因是避免不必要的对象复制，更重要的是，避免*对象切片*。我们很快将深入了解
    C++ 中异常捕获技术的具体细节，但现在，让我们专注于我们的当前示例。一旦捕获到异常，我们就可以从中提取 `error_condition` 对象；参见标记
    `{6}`。这是可能的，因为 `system_error` 类支持错误代码和错误条件，并使我们能够获取它们。当我们有 `error_condition` 时，我们可以成功地对已知的
    `errc` 代码进行检查，以确定这个异常是否是我们程序的真实问题，或者它可以被忽略；参见标记 `{7}`。
- en: Important note
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Wherever possible, catch exceptions by reference (prefer constant) rather than
    by value to avoid potential object slicing and additional overhead due to object
    copying.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，通过引用（优先使用常量引用）而不是通过值来捕获异常，以避免潜在的切片对象和由于对象复制而产生的额外开销。
- en: Our business program logic expects that errors reporting that a file already
    exists are normal and should not break program execution. Ultimately, it says
    that we try to create a directory that already exists, and that’s fine and we
    can continue. But if the error is something else that we don’t know what to do
    with, then we have to report that error and rethrow it to the upper methods in
    the call stack, which could better know what to do with such a kind of error.
    This is done with the `throw` clause in the language; see marker `{8}`. An important
    detail here is that in order to *rethrow an existing exception* rather than throwing
    a new one, you have to just use `throw;` with *no arguments*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的业务程序逻辑预期，报告文件已存在的错误是正常的，不应该中断程序执行。最终，它表示我们尝试创建一个已存在的目录，这是可以接受的，我们可以继续。但如果错误是其他我们不知道如何处理的情况，那么我们必须报告这个错误并将其重新抛出到调用堆栈中的上层方法，这些方法可能更知道如何处理这种类型的错误。这是通过语言中的
    `throw` 子句完成的；参见标记 `{8}`。这里的一个重要细节是，为了*重新抛出现有的异常*而不是抛出一个新的异常，你必须只使用带有*无参数*的 `throw;`。
- en: Important note
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Use the `throw;` clause with no arguments to rethrow an existing exception.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不带参数的 `throw;` 子句来重新抛出现有的异常。
- en: 'Of course, if the error is what we expect, such as `std::errc::file_exists`,
    then we can safely continue the program execution without the need to rethrow
    this exception. You can find the output of the program as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果错误是我们预期的，比如`std::errc::file_exists`，那么我们可以安全地继续程序执行，而不需要重新抛出这个异常。你可以按照以下方式找到程序的输出：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can see that the exception is thrown by the `CreateDirectory()` method and
    it is caught by the `catch` clause in the `main()` method. In this example, we
    saw that using exceptions instead of error codes clearly segregates the normal
    program execution path from the error path and makes it easier to rethrow errors
    that we can’t properly deal with.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到异常是由`CreateDirectory()`方法抛出的，并在`main()`方法的`catch`子句中被捕获。在这个例子中，我们看到使用异常而不是错误码可以清楚地分离正常程序执行路径和错误路径，并使得重新抛出我们无法正确处理的错误变得更容易。
- en: Throw by value, catch by reference
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按值抛出，按引用捕获
- en: 'In C++, we can literally throw every object. You could successfully do this
    as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，我们实际上可以抛出每一个对象。你可以这样成功做到：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding statement throws an integer object with a value of `42`. But just
    because you can do something, it doesn’t mean it’s a good idea to do so. The goal
    of the exception is to bring context to the error that occurred. Throwing the
    value of `42` doesn’t provide much context, right? What does `42` mean for the
    recipient of your exception? Not much!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语句抛出了一个值为`42`的整数对象。但仅仅因为你能够做某事，并不意味着这样做是个好主意。异常的目标是提供错误发生的上下文。抛出`42`的值并没有提供太多上下文，对吧？对于你的异常接收者来说，`42`意味着什么？并不多！
- en: This statement is fully confirmed by the C++ Core Guidelines project developed
    by some of the key members of the C++ Standards Committee. The C++ Core Guidelines
    are a really useful guide for every C++ developer no matter what level of expertise
    you have. It gathers recommendations and best practices about different features
    in C++.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个说法得到了由C++标准委员会的一些关键成员开发的核心指南项目的充分证实。无论你的专业水平如何，C++核心指南都是每个C++开发者的一个非常有用的指南。它汇集了关于C++不同特性的建议和最佳实践。
- en: Important note
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Make sure to get familiar with the C++ Core Guidelines, which you can find at
    [https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c-core-guidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c-core-guidelines).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 确保熟悉C++核心指南，你可以在[https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c-core-guidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c-core-guidelines)找到它。
- en: 'The C++ Core Guidelines say that we have to make sure that we throw meaningful
    exceptions. If you don’t have a standard defined exception that works for your
    case, you can throw a user-defined type that derives from some of the standard
    exceptions:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: C++核心指南指出，我们必须确保抛出有意义的异常。如果你没有为你的情况定义一个标准的异常，你可以抛出一个从某些标准异常派生的用户定义类型：
- en: '[https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e14-use-purpose-designed-user-defined-types-as-exceptions-not-built-in-types](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e14-use-purpose-designed-user-defined-types-as-exceptions-not-built-in-types)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e14-use-purpose-designed-user-defined-types-as-exceptions-not-built-in-types](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e14-use-purpose-designed-user-defined-types-as-exceptions-not-built-in-types)'
- en: 'The C++ Core Guidelines also suggest throwing our exceptions by value and catching
    them by reference. Of course, even better if we catch by constant reference. Throwing
    by value ensures that the lifetime of the thrown object will be managed by the
    runtime of your system. Otherwise, if you throw a pointer to an object that you
    have allocated on the heap whose responsibility will be to delete this object
    when it is no longer needed, it is quite possible you will end up with leaked
    memory:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: C++核心指南还建议我们按值抛出异常，并按引用捕获它们。当然，如果能按常量引用捕获那就更好了。按值抛出确保抛出的对象的生存期将由你的系统运行时管理。否则，如果你抛出一个指向你已在堆上分配的对象的指针，而这个对象的责任是在不再需要时删除它，那么你最终可能会遇到内存泄漏：
- en: '[https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e15-throw-by-value-catch-exceptions-from-a-hierarchy-by-reference](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e15-throw-by-value-catch-exceptions-from-a-hierarchy-by-reference)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e15-throw-by-value-catch-exceptions-from-a-hierarchy-by-reference](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e15-throw-by-value-catch-exceptions-from-a-hierarchy-by-reference)'
- en: 'Let’s go through an example. We will define a method – `Throw()` – which throws
    by value a `std::system_error` exception with an error code – `bad_file_descriptor`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来分析。我们将定义一个方法——`Throw()`——它通过值抛出一个带有错误代码——`bad_file_descriptor` 的 `std::system_error`
    异常：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This method will be invoked by the `main()` method in which we will catch the
    thrown exception:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将由 `main()` 方法调用，我们将在此捕获抛出的异常：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see in the preceding example, we have defined two `try-catch` blocks
    – one inner and one outer. The reason behind this is that exceptions thrown in
    the `catch` branch can’t be caught by another `catch` branch in the same try-catch
    block. They are propagated out and, therefore, in order to catch them, we need
    an outer try-catch block.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，我们定义了两个 `try-catch` 块——一个内层和一个外层。这样做的原因是，在同一个 `try-catch` 块中抛出的异常不能被另一个
    `catch` 子句捕获。它们会被传播出去，因此，为了捕获它们，我们需要一个外部的 `try-catch` 块。
- en: In marker `{1}`, we invoke the `Throw()` method, which throws an exception.
    But in marker `{2}`, we catch the thrown exception. Actually, we don’t catch `std::system_error`
    directly but we catch its parent class – `std::runtime_error`. Also, you can see
    that we catch this exception by value with `runtime_error e`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在标记 `{1}` 中，我们调用了 `Throw()` 方法，它抛出了一个异常。但在标记 `{2}` 中，我们捕获了这个抛出的异常。实际上，我们没有直接捕获
    `std::system_error`，而是捕获了它的父类——`std::runtime_error`。你也可以看到，我们通过 `runtime_error
    e` 的方式通过值捕获了这个异常。
- en: 'The only action we take once we catch the `runtime_error` exception is to throw
    it away from the inner try-catch block with the following statement:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦捕获到 `runtime_error` 异常，我们采取的唯一行动就是通过以下语句将其从内层 `try-catch` 块中抛出：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Always be careful when you rethrow an existing exception. The upper statement
    *doesn’t rethrow* the exception caught in the `catch` clause but it throws a new
    instance of the `runtime_error` exception, which is a copy of the caught exception,
    instead.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新抛出现有异常时，一定要小心。上面的语句**没有重新抛出**在 `catch` 子句中捕获的异常，而是抛出了一个新的 `runtime_error`
    异常实例，它是捕获到的异常的副本。
- en: Once the new exception is thrown, it is caught by the outer `catch` clause in
    marker `{4}`. As you can see, following the recommendation from the C++ Core Guidelines,
    we catch a constant reference instead of a value to the Standard Library’s base
    exception class – `std::exception` – which is also a base class for `std::runtime_error`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦抛出了新的异常，它就会被标记 `{4}` 中的外部 `catch` 子句捕获。正如你所见，我们遵循了 C++ 核心指南的建议，捕获了一个常量引用而不是标准库的基类异常类——`std::exception`——它也是
    `std::runtime_error` 的基类。
- en: 'In the `catch` clause, we try to downcast it back to its original type – `std::system_error`
    – and print the message from its `std::error_condition`. Let’s see the output
    from the program:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `catch` 子句中，我们尝试将其向下转换为原始类型——`std::system_error`——并打印其 `std::error_condition`
    中的消息。让我们看看程序的输出：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: But surprisingly, we don’t get the expected result. The downcast has failed,
    and when it fails, it generates a standard exception – `std::bad_cast` – which
    is thrown away from the outer `catch` clause. But this exception is not guarded
    by another try-catch block, and therefore, it propagates out of the `main()` method,
    which is de facto the top of the function stack of the program. As we explained
    earlier, if an exception is not caught during its propagation upwind in the function
    stack, then the `std::terminate` function will be called.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 但令人惊讶的是，我们没有得到预期的结果。向下转换失败了，当它失败时，会生成一个标准异常——`std::bad_cast`——这个异常从外部 `catch`
    子句中被抛出。但这个异常没有被另一个 `try-catch` 块保护，因此它传播出了 `main()` 方法，这在事实上是程序函数栈的顶部。正如我们之前解释的，如果在函数栈向上传播过程中没有捕获到异常，那么将会调用
    `std::terminate` 函数。
- en: But why did the cast fail when we tried to downcast to `std::system_error`?
    The reason is that the `Throw()` method throws `std::system_error` and everything
    should work fine. Well, it should, but it doesn’t really. Let’s get deeper into
    this.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么当我们尝试向下转换为 `std::system_error` 时，转换失败了？原因是 `Throw()` 方法抛出了 `std::system_error`，理论上一切应该正常工作。嗯，应该是这样的，但实际上并没有。让我们深入探讨这个问题。
- en: 'The `Throw()` method really throws an instance of `std::system_error` by *value*.
    But the inner `catch` clause catches a *base class exception* also *by value*
    and throws a *copy* of it:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`Throw()` 方法实际上是通过值抛出一个 `std::system_error` 实例。但内层 `catch` 子句通过值捕获了一个基类异常，并抛出了它的一个副本：'
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This leads to a problem because the object we rethrow is no longer an instance
    of `std::system_error`. It has been sliced to its base class – `std::runtime_error`.
    All the information that has been part of the *original* `std::system_error` object
    is no longer part of the newly created *copy* of the `std::runtime_error` – `e`
    type.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了一个问题，因为我们重新抛出的对象不再是`std::system_error`的实例。它已经被裁剪到其基类——`std::runtime_error`。所有原本属于*原始*
    `std::system_error`对象的信息现在不再是新创建的*副本*的`std::runtime_error`——`e`类型的一部分。
- en: Therefore, the downcast to `std::system_error` doesn’t succeed and our program
    terminates.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，向下转换为`std::system_error`失败，我们的程序终止。
- en: To conclude, we can say that these kinds of errors can be successfully prevented
    by following the rules of throwing exceptions by value, catching them by reference,
    and rethrowing the existing exceptions rather than their copy wherever this is
    possible.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们可以通过遵循通过值抛出异常、通过引用捕获异常以及尽可能重新抛出现有异常而不是它们的副本的规则来成功防止这类错误。
- en: try/catch … finally
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: try/catch … finally
- en: You probably noticed that in the C++ language, we have the `try-catch` block,
    but we don’t have the `finally` construct. If you have experience in languages
    such as C# or Java, you will be used to releasing the resource that you have acquired
    using the `finally` clause. But this works only for exceptional cases where the
    `try` clause is preceding the usage of `finally`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在C++语言中，我们有`try-catch`块，但没有`finally`构造。如果你有C#或Java等语言的经验，你将习惯于使用`finally`子句来释放你使用过的资源。但这种方法只适用于异常情况，其中`try`子句在`finally`的使用之前。
- en: 'But how do we do it in C++ without `finally`? Let’s revisit our initial example
    for opening and closing a file using the `open()` and `close()` POSIX functions:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 但在没有`finally`的情况下，我们如何在C++中实现呢？让我们回顾一下使用`open()`和`close()` POSIX函数打开和关闭文件的初始示例：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As we already discussed earlier in the chapter, opening a file using the `open()`
    POSIX method returns the ID of the file descriptor if the function successfully
    opens the file; otherwise, as with many of the POSIX functions, it returns `-1`;
    see marker `{1}`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如同我们在本章前面讨论的那样，使用`open()` POSIX方法打开文件会返回文件描述符的ID，如果函数成功打开文件；否则，就像许多POSIX函数一样，它返回`-1`；见标记
    `{1}`。
- en: Once you have your file opened, it is your responsibility to ensure that *finally*,
    when you finish with it, it will be closed. Therefore, we invoke the `close()`
    method at the end of the `main()` method to ensure that the file will be closed
    (see marker `{3}`) just before we leave `main()`. But how can you be sure that
    some abnormal situation won’t occur, and an exception won’t be thrown before you
    close your file? Actually, the only case in which you can be sure that this won’t
    happen is if exceptions are not supported in your system. But in our test Linux
    environment, this is not the case. Even worse, when working in real code bases,
    it’s hard to be sure that some of the methods you invoke during your normal business
    logic execution won’t throw.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的文件被打开，确保它在最终关闭时的责任就落在了你身上。因此，我们在`main()`方法的末尾调用`close()`方法来确保文件在离开`main()`之前被关闭（见标记
    `{3}`）。但是，你怎么能确保在关闭文件之前不会发生某些异常情况，不会抛出异常呢？实际上，唯一可以确保这种情况不会发生的情况是如果你的系统中不支持异常。但在我们的测试Linux环境中，情况并非如此。更糟糕的是，在实际的代码库中工作，很难确保你在正常业务逻辑执行过程中调用的某些方法不会抛出异常。
- en: Imagine what happens if your program throws before you close your file; see
    marker `{2}`. Effectively, you will *leak* a resource. As a rule of thumb, we
    should never leak resources, no matter whether this will lead to a problem or
    not.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果你的程序在关闭文件之前抛出异常会发生什么；见标记 `{2}`。实际上，你将*泄露*资源。作为一个经验法则，我们永远不应该泄露资源，无论这会不会导致问题。
- en: 'But how can we protect ourselves from leaking resources without having the
    `finally` clause in the language? Let’s have a look into one of the most typical
    C++ programming techniques:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果没有语言中的`finally`子句，我们如何保护自己不泄露资源呢？让我们来看看最典型的C++编程技术之一：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We have reworked our `main()` method in such a way that we just create a file
    (see marker `{2}`) and pass its filename (see marker `{1}`) to a new object of
    the `file_guard` type (see marker `{3}`), which we will look at it just in a moment.
    The `file_guard` object is responsible for opening and closing a file with a specific
    name:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经重新设计了`main()`方法，使其仅创建一个文件（见标记 `{2}`），并将文件名（见标记 `{1}`）传递给一个新的`file_guard`类型对象（见标记
    `{3}`），我们稍后将对其进行探讨。`file_guard`对象负责以特定名称打开和关闭文件：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The class gets in its constructor the file path and the mode in which the file
    should be opened; see marker `{5}`. In the initializer list of the constructor,
    the POSIX `open()` method is invoked. The result, which is the file descriptor
    ID, is assigned to the `_fd` member of the class. If `open()` fails, an exception
    is thrown away from the `file_guard` constructor. We should not care about closing
    the file in this case because we didn’t open it successfully.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 类在其构造函数中获取文件路径和文件应打开的模式；见标记 `{5}`。在构造函数的初始化列表中，调用POSIX的`open()`方法。结果是文件描述符ID，被分配给类的`_fd`成员。如果`open()`失败，异常将从`file_guard`构造函数抛出。在这种情况下，我们不需要担心关闭文件，因为我们没有成功打开它。
- en: In the destructor of the class, we have the reversed operation; see marker `{9}`.
    If the file descriptor is different from `-1`, which means that the file has been
    successfully opened before that, we close it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的析构函数中，我们有相反的操作；见标记 `{9}`。如果文件描述符不是`-1`，这意味着在该之前文件已被成功打开，我们将关闭它。
- en: This C++ programming technique is called **Resource Acquisition Is Initialization**,
    or just **RAII**. It is a resource management technique that acquires the resource
    during the construction of the RAII object and releases it during the destruction
    of that object. Unlike in languages such as Java and C# that use automatic garbage
    collection and whose resource release timing is not entirely clear to the user,
    C++ objects have a precisely defined storage duration and lifetime. Thus, we can
    rely on this characteristic and utilize RAII objects to manage our resources.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这种C++编程技术被称为**资源获取即初始化**，或简称**RAII**。它是一种资源管理技术，在RAII对象的构造过程中获取资源，并在该对象的销毁过程中释放资源。与使用自动垃圾回收且资源释放时机对用户来说并不完全清晰的Java和C#等语言不同，C++对象具有精确定义的存储持续时间和生命周期。因此，我们可以依赖这一特性，并利用RAII对象来管理我们的资源。
- en: Going back to our `main()` method, if the file is opened (see marker `{3}`)
    and something goes wrong before it has been explicitly closed (see marker `{4}`),
    we will be sure that it will be automatically closed once the `file_guard` object
    goes out of scope.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`main()`方法，如果文件已打开（见标记 `{3}`），但在显式关闭之前发生错误，我们可以确信一旦`file_guard`对象超出作用域，它将被自动关闭。
- en: This technique is widely used no matter whether exceptions are available in
    the system or not. You can wrap your resources using RAII and be assured that
    they will be automatically released whenever you leave the scope where the RAII
    object lives.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术无论系统是否有异常处理机制都广泛使用。您可以使用RAII（Resource Acquisition Is Initialization，资源获取即初始化）封装资源，并确保它们将在离开RAII对象的作用域时自动释放。
- en: In our `file_guard` example, we have removed the copy constructor and the copy
    assignment operator and left the move constructor and move operator only, claiming
    that this RAII object is not copyable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`file_guard`示例中，我们移除了拷贝构造函数和拷贝赋值运算符，只留下了移动构造函数和移动运算符，声称这个RAII对象是不可拷贝的。
- en: 'C++ is often questioned about not having the `finally` construct. However,
    the inventor of C++, Bjarne Stroustrup, has explained that RAII is a better substitute:
    [https://www.stroustrup.com/bs_faq2.xhtml#finally](https://www.stroustrup.com/bs_faq2.xhtml#finally).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: C++经常被质疑没有`finally`构造。然而，C++的发明者Bjarne Stroustrup解释说，RAII是一个更好的替代品：[https://www.stroustrup.com/bs_faq2.xhtml#finally](https://www.stroustrup.com/bs_faq2.xhtml#finally)。
- en: Stroustrup argues that in practical code bases, there are many more resource
    acquisitions and releases, and using RAII instead of `finally` results in less
    code. Additionally, it is less susceptible to errors since the RAII wrapper only
    needs to be coded once, and there is no need to remember to release the resource
    manually.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Stroustrup认为，在实际的代码库中，资源获取和释放的操作要多得多，使用RAII而不是`finally`会导致代码更少。此外，它更不容易出错，因为RAII包装器只需要编写一次，而且不需要手动释放资源。
- en: The Standard Library has many examples of RAII objects, such as `std::unique_ptr`,
    `std::lock_guard`, and `std::fstreams`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中有许多RAII对象的示例，例如`std::unique_ptr`、`std::lock_guard`和`std::fstreams`。
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has covered various techniques for error handling when working
    with POSIX APIs in C++. We discussed the use of `errno`, a thread-local variable,
    and the `strerror` function. We also explored how `std::error_code` and `std::error_condition`
    can wrap POSIX errors and how custom error categories enable us to compare errors
    generated by different sources and develop platform-independent error-handling
    code. Furthermore, we delved into exceptions in C++ and how to convert `std::error_code`
    into an exception of the `std::system_error` type.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了在C++中使用POSIX API进行错误处理的各种技术。我们讨论了`errno`的使用，这是一个线程局部变量，以及`strerror`函数。我们还探讨了`std::error_code`和`std::error_condition`如何封装POSIX错误，以及自定义错误类别如何使我们能够比较不同来源生成的错误，并开发平台无关的错误处理代码。此外，我们还深入探讨了C++中的异常，以及如何将`std::error_code`转换为`std::system_error`类型的异常。
- en: We also examined best practices for working with exceptions, such as throwing
    them by value and catching them by reference, to avoid issues such as object slicing.
    Finally, we learned about the RAII technique in C++, which eliminates the need
    for a `finally` construct in the language.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了处理异常的最佳实践，例如通过值抛出异常并通过引用捕获异常，以避免对象切片等问题。最后，我们学习了C++中的RAII技术，它消除了在语言中需要`finally`结构的需要。
- en: In the next chapter, we will explore the topic of concurrency with C++.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨使用C++的并发主题。
- en: Part 2:Advanced Techniques for System Programming
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：系统编程的高级技术
- en: In this part, you will learn about expert-level C++20 features, which will further
    improve both your OS and C++ development expertise. The examples, though still
    practical, become more complex and require some preliminary understanding of the
    subject of system programming.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，你将学习关于C++20高级特性的专业知识，这将进一步提高你的操作系统和C++开发技能。虽然示例仍然实用，但变得更加复杂，需要一些关于系统编程主题的初步了解。
- en: 'This part has the following chapters:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 6*](B20833_06.xhtml#_idTextAnchor086)*, Concurrent System Programming
    with C++*'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B20833_06.xhtml#_idTextAnchor086)*，使用C++进行并发系统编程*'
- en: '[*Chapter 7*](B20833_07.xhtml#_idTextAnchor101)*, Proceeding with Inter-Process
    Communication*'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B20833_07.xhtml#_idTextAnchor101)*，进行进程间通信*'
- en: '[*Chapter 8*](B20833_08.xhtml#_idTextAnchor116)*, Using Clocks, Timers, and
    Signals in Linux*'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B20833_08.xhtml#_idTextAnchor116)*，在Linux中使用时钟、定时器和信号*'
- en: '[*Chapter 9*](B20833_09.xhtml#_idTextAnchor129)*, Understanding the C++ Memory
    Model*'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B20833_09.xhtml#_idTextAnchor129)*，理解C++内存模型*'
- en: '[*Chapter 10*](B20833_10.xhtml#_idTextAnchor147)*, Using Coroutines in C++
    for System Programming*'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B20833_10.xhtml#_idTextAnchor147)*，在系统编程中使用C++协程*'
