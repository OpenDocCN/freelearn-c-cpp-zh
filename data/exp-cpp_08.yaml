- en: Digging into Data Structures and Algorithms in STL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入STL中的数据结构和算法
- en: Mastering data structures is essential for programmers. The way you store your
    data most of the time defines the overall efficiency of the application. Consider
    an email client, for example. You can design an email client that shows the 10
    latest emails and it could have the best UI out there; displaying 10 recent emails
    will work smoothly on almost any device. The user of your email application will
    receive hundreds of thousands of emails, say, in two years of using your application.
    When the user needs to search for an email, that's where your data structure knowledge
    will play a significant role. The way you store the hundreds of thousands of emails
    and the methods (algorithms) you use to sort and search them will be what differentiates
    your program from all the others out there.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握数据结构对程序员至关重要。大多数情况下，数据存储方式定义了应用程序的整体效率。例如，考虑一个电子邮件客户端。您可以设计一个显示最新10封电子邮件的电子邮件客户端，并且它可能具有最佳的用户界面；在几乎任何设备上都可以顺畅地显示最近的10封电子邮件。您的电子邮件应用程序的用户在使用您的应用程序两年后可能会收到数十万封电子邮件。当用户需要搜索电子邮件时，您的数据结构知识将发挥重要作用。您存储数十万封电子邮件的方式以及您用于排序和搜索它们的方法（算法）将是您的程序与其他所有程序的区别所在。
- en: Programmers strive to find the best solutions to daily problems while working
    on projects. Using proven data structures and algorithms can drastically improve
    the work of the programmer. One of the most important features of a good program
    is its speed, which we gain by devising new algorithms or using existing ones.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员在项目中努力寻找每日问题的最佳解决方案。使用经过验证的数据结构和算法可以极大地改善程序员的工作。一个好程序最重要的特性之一是速度，通过设计新的算法或使用现有算法来获得速度。
- en: Finally, C++20 introduces **concepts** for defining **metatypes**—types describing
    other types. This powerful feature of the language makes the data architecting
    complete.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，C++20引入了用于定义**元类型**的**概念**，即描述其他类型的类型。语言的这一强大特性使数据架构完整。
- en: There are plenty of data structures and algorithms covered in the C++ **Standard
    Template Library** (**STL**). We will explore the ways to organize data efficiently
    using data structures by leveraging STL containers. And then we will dive into
    algorithm implementations provided by the STL. It's crucial to understand and
    use concepts in STL containers, because C++20 introduces big improvements in iterators
    by introducing iterator concepts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: C++的**标准模板库**（**STL**）涵盖了大量的数据结构和算法。我们将探索使用STL容器来高效组织数据的方法。然后我们将深入研究STL提供的算法实现。理解并使用STL容器中的概念至关重要，因为C++20通过引入迭代器概念来大幅改进迭代器。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Data structures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据结构
- en: STL containers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STL容器
- en: Concepts and iterators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概念和迭代器
- en: Mastering algorithms
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握算法
- en: Exploring trees and graphs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索树和图
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The g++ compiler with the option `-std=c++2a` is used to compile the examples
    throughout the chapter. You can find the source files used in this chapter in
    the GitHub repository for this book at [https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)
    .
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用带有选项`-std=c++2a`的g++编译器来编译示例。您可以在本书的GitHub存储库中找到本章中使用的源文件[https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)。
- en: Data structures
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构
- en: As a programmer, you are probably familiar with using an array for storing and
    ordering a collection of data. Programmers intensively use data structures other
    than arrays in their projects. Knowing and applying proper data structures may
    play a significant role in program performance. To choose the right data structure,
    you need to get to know them better. An obvious question might arise of whether
    we need to study the zoo of data structures— vectors, linked lists, hash tables,
    graphs, trees, and so on. To answer this question, let's have an imaginary scenario
    where the necessity for a better data structure will become apparent naturally.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，您可能熟悉使用数组来存储和排序数据集。程序员在项目中除了数组之外还会大量使用其他数据结构。了解并应用适当的数据结构可能在程序性能中发挥重要作用。要选择正确的数据结构，您需要更好地了解它们。一个明显的问题可能会出现，即我们是否需要研究数据结构的动物园——向量、链表、哈希表、图、树等等。为了回答这个问题，让我们假设一个想要更好的数据结构的必要性自然而然地显现出来的想象场景。
- en: In the introductory content, we mentioned designing an email client. Let's get
    a general understanding of the basic tasks during its design and implementation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍内容中，我们提到了设计一个电子邮件客户端。让我们对其设计和实现过程中的基本任务有一个一般的了解。
- en: An email client is an application that lists emails received from various senders.
    We can install it on desktop computers or smartphones, or use a browser version.
    The main tasks of an email client application involve sending and receiving emails.
    Now let's suppose that we are designing a simple-enough email client. As usually
    happens in programming books, let's suppose that we use some library that encapsulates
    the job of sending and receiving emails. We'd rather concentrate on designing
    mechanisms specifically for storing and retrieving emails. An email client user
    should be able to view a list of emails that reside in the **Inbox** section of
    the app. We should also take into account the operations that the user might want
    to perform on emails. They can delete them one by one, or many at once. They can
    choose any email selected at random and reply to its sender or forward the email
    to someone else.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件客户端是一个列出来自各个发件人的电子邮件的应用程序。我们可以将其安装在台式电脑或智能手机上，或者使用浏览器版本。电子邮件客户端应用程序的主要任务包括发送和接收电子邮件。现在假设我们正在设计一个足够简单的电子邮件客户端。就像在编程书籍中经常发生的那样，假设我们使用了一些封装了发送和接收电子邮件工作的库。我们更愿意集中精力设计专门用于存储和检索电子邮件的机制。电子邮件客户端用户应该能够查看**收件箱**部分中的电子邮件列表。我们还应该考虑用户可能想要对电子邮件执行的操作。他们可以逐个删除电子邮件，也可以一次删除多封。他们可以选择任意选定的电子邮件并回复给发件人或将电子邮件转发给其他人。
- en: 'We discuss the software design process and best practices in [Chapter 10](069ab9af-21a4-4b8c-bc3f-f7bc0d9e4712.xhtml),
    *Designing Real-World Applications*. For now, let''s sketch a simple struct that
    describes an email object, as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第10章](069ab9af-21a4-4b8c-bc3f-f7bc0d9e4712.xhtml)中讨论了软件设计过程和最佳实践，*设计真实世界应用程序*。现在，让我们草拟一个描述电子邮件对象的简单结构，如下所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first thing that should bother us is storing a collection of emails in
    an easily accessible structure. An array might sound fine. Let''s suppose we store
    all the incoming emails in an array, as shown in the following code block:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该关心的第一件事是将电子邮件集合存储在一个易于访问的结构中。数组听起来可能不错。假设我们将所有收到的电子邮件存储在一个数组中，如下面的代码块所示：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can store 10 emails in any form – it won't affect the application's performance.
    However, it's obvious that, over time, the number of emails will grow. For each
    newly received email, we push an `Email` object with the corresponding fields
    into the `inbox` array. The last element of the array represents the most recently
    received email. So, to show the list of ten recent emails, we need to read and
    return the last ten elements of the array.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以任何形式存储10封电子邮件-这不会影响应用程序的性能。然而，显而易见的是，随着时间的推移，电子邮件的数量将增加。对于每封新收到的电子邮件，我们将`Email`对象与相应的字段推送到`inbox`数组中。数组的最后一个元素表示最近收到的电子邮件。因此，要显示最近的十封电子邮件列表，我们需要读取并返回数组的最后十个元素。
- en: 'Issues arise when we try to manipulate the thousands of emails stored in the
    `inbox` array. What if we want to search for the word `friend` in all the emails?
    We have to scan all the emails in the array and collect the ones containing the
    word `friend` in a separate array. Look at the following pseudocode:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试操作存储在`inbox`数组中的成千上万封电子邮件时，问题就出现了。如果我们想在所有电子邮件中搜索单词`friend`，我们必须扫描数组中的所有电子邮件，并将包含单词`friend`的电子邮件收集到一个单独的数组中。看看下面的伪代码：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Using an array to store all the data is more than enough for small collections.
    The situation changes drastically in real-world applications dealing with bigger
    sets of data. The point of using a specific data structure is to make the application
    run more smoothly. The preceding example shows a simple problem: searching through
    a list of emails to match a particular value. Finding that value in one email
    takes a reasonable amount of time.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组存储所有数据对于小集合来说已经足够了。在处理更大的数据集的真实世界应用程序中，情况会发生巨大变化。使用特定的数据结构的目的是使应用程序运行更加流畅。前面的例子展示了一个简单的问题：在电子邮件列表中搜索匹配特定值。在一封电子邮件中找到该值需要合理的时间。
- en: If we suppose that the subject field of an email might consist of up to ten
    words, then searching for a particular word in an email subject requires comparing
    the word against all the words in the subject. In the *worst case*, there is no
    match. We emphasize the worst case because it's the only case when the lookup
    will require checking each word in the subject. Doing the same for thousands or
    hundreds of thousands of emails will make the user wait unreasonably long.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们假设电子邮件的主题字段可能包含多达十个单词，那么在电子邮件主题中搜索特定单词需要将该单词与主题中的所有单词进行比较。在*最坏的情况*下，没有匹配。我们强调最坏的情况，因为只有在查找需要检查主题中的每个单词时才会出现这种情况。对成千上万甚至数十万封电子邮件做同样的操作将使用户等待时间过长。
- en: 'Choosing the right data structure for the specific problem is crucial in terms
    of application efficiency. For example, let''s suppose we use a hash table to
    map words to email objects. Each word will be mapped to a list of email objects
    that contain that word. This approach will increase the efficiency of the searching
    operation, as shown in the following diagram:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 选择适合特定问题的数据结构对于应用程序的效率至关重要。例如，假设我们使用哈希表将单词映射到电子邮件对象。每个单词将被映射到包含该单词的电子邮件对象列表。这种方法将提高搜索操作的效率，如下图所示：
- en: '![](img/f7318cbc-fefa-41f1-a377-9bf8ebd60b26.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f7318cbc-fefa-41f1-a377-9bf8ebd60b26.png)'
- en: 'The `search()` function will just return the list referred to by the hash table
    key:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`search()`函数将返回哈希表键引用的列表：'
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This approach will just require processing each received email to split it into
    words and update the hash table.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法只需要处理每封接收到的电子邮件，将其拆分为单词并更新哈希表。
- en: For the sake of simplicity, we use `Email` objects as values rather than references.
    Note that it would be better to store pointers to `Email` in the vector.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们使用`Email`对象作为值而不是引用。请注意，最好将指针存储在向量中指向`Email`。
- en: Let's now take a look at different data structures and their applications.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看不同的数据结构及其应用。
- en: Sequential data structures
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顺序数据结构
- en: 'One of the most common data structures that developers use is the dynamically
    growing one-dimensional array, usually referred to as a vector. The STL provides
    a container with the same name: `std::vector`. The key idea behind the vector
    is that it contains items of the same type placed sequentially in memory. For
    example, a vector consisting of 4 byte integers would have the following memory
    layout. Each box represents a four byte space. The indexes of the vector are on
    the right-hand side of the following diagram:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员最常用的数据结构之一是动态增长的一维数组，通常称为向量。STL提供了一个同名的容器：`std::vector`。向量背后的关键思想是它包含相同类型的项目按顺序放置在内存中。例如，由4字节整数组成的向量将具有以下内存布局。向量的索引位于以下图表的右侧：
- en: '![](img/8f1961c0-dcd6-481f-8ae8-3ba43902ba49.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f1961c0-dcd6-481f-8ae8-3ba43902ba49.png)'
- en: The physical structure of the vector allows any of its elements to be accessed
    in real time.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 向量的物理结构允许实时访问其任何元素。
- en: We should differentiate containers with their operations in order to apply them
    properly in specific problems. To do so we usually define the complexity of running
    time of their operations in relation to the number of elements in the container.
    For example, the vector's element access is defined as a constant time operation,
    which means that it takes the same number of instructions to fetch a vector item
    regardless of the vector length.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该根据容器的操作来区分它们，以便在特定问题中正确应用它们。为此，我们通常定义容器中的操作与容器中元素数量的运行时间复杂度的关系。例如，向量的元素访问被定义为常数时间操作，这意味着获取向量项需要相同数量的指令，无论向量长度如何。
- en: Accessing the first element of the vector and accessing the 100^(th) element
    of the vector take the same amount of work, therefore, we call it a constant time
    operation, also known as ***O(1)* operation**.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 访问向量的第一个元素和访问向量的第100个元素需要相同的工作量，因此我们称之为常数时间操作，也称为***O(1)操作***。
- en: 'While the element access is fast in vector, adding new elements is somewhat tricky.
    Whenever we insert a new item at the end of the vector, we should also consider
    the capacity of the vector. It should dynamically grow in size when there is no
    more space allocated for the vector. Take a look at the following `Vector` class
    with its `push_back()` function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然向量中的元素访问速度很快，但添加新元素有些棘手。每当我们在向量的末尾插入新项时，我们还应该考虑向量的容量。当没有为向量分配更多空间时，它应该动态增长。看一下下面的`Vector`类及其`push_back()`函数：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Before diving into the implementation of the `push_back()` function, let''s
    take a look at the following diagram:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入实现`push_back()`函数之前，让我们看一下下面的图表：
- en: '![](img/11cb3eec-b2a8-4166-8fdf-a58cf516bf90.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11cb3eec-b2a8-4166-8fdf-a58cf516bf90.png)'
- en: 'We should allocate a brand-new array, copy all the elements of the old one
    into the new array, and then add the newly inserted element at the next free slot
    at the end of the new array. This is shown in the following code snippet:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该分配一个全新的数组，将旧数组的所有元素复制到新数组中，然后将新插入的元素添加到新数组末尾的下一个空闲槽中。这在下面的代码片段中显示：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The resizing factor can be chosen differently – we set it to `2`, which makes
    the vector grow twice of its size whenever it's full. So we could insist that,
    most of the time, inserting a new item at the end of the vector takes constant
    time. It just adds the item at the free slot and increases its `private size_`
    variable. From time to time, adding a new element will require allocating a new,
    bigger vector and copying the old one into the new one. For cases like this, the
    operation is said to take **amortized** constant time to complete.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 调整因子可以选择不同 - 我们将其设置为`2`，这样每当向量满时，向量的大小就会增长两倍。因此，我们可以坚持认为，大多数情况下，在向量的末尾插入新项需要常数时间。它只是在空闲槽中添加项目并增加其`private
    size_`变量。不时地，添加新元素将需要分配一个新的、更大的向量，并将旧的向量复制到新的向量中。对于这样的情况，该操作被称为**摊销**常数时间完成。
- en: 'We can''t say the same when we add an element at the front of the vector. The
    point is, all the other elements should be moved by one slot to the right in order to
    free up a slot for the new element, as shown in the following diagram:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在向量的前面添加元素时，情况就不一样了。问题在于，所有其他元素都应该向右移动一个位置，以便为新元素腾出一个位置，如下图所示：
- en: '![](img/0f4021af-1ec3-4d9d-85ca-891a7e16e42a.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f4021af-1ec3-4d9d-85ca-891a7e16e42a.png)'
- en: 'Here''s how we would implement it in our `Vector` class:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在`Vector`类中如何实现它的方式：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In cases where you need to insert new elements only at the front of the container,
    choosing a vector is not a good option. That's one of the examples where other
    containers should be considered.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要仅在容器的前面插入新元素的情况下，选择向量并不是一个好的选择。这是其他容器应该被考虑的例子之一。
- en: Node-based data structures
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于节点的数据结构
- en: Node-based data structures don't take contiguous blocks of memory. A node-based
    data structure allocates nodes for its elements without any order – they might
    be spread randomly in memory. We express each item as a node linked to the other
    nodes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 基于节点的数据结构不占用连续的内存块。基于节点的数据结构为其元素分配节点，没有任何顺序 - 它们可能随机分布在内存中。我们将每个项目表示为链接到其他节点的节点。
- en: 'The most popular and introductory node-based data structure is the linked list.
    The following diagram shows the visual structure of a doubly linked list:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最流行和最基础的基于节点的数据结构是链表。下图显示了双向链表的可视结构：
- en: '![](img/de263cb6-41ed-4f47-a59e-1a9e01261f64.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de263cb6-41ed-4f47-a59e-1a9e01261f64.png)'
- en: A linked list is very different from a vector. Some of its operations are faster,
    though it lacks the compactness of a vector.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 链表与向量非常不同。它的一些操作速度更快，尽管它缺乏向量的紧凑性。
- en: 'To keep it short, let''s implement the element insertion at the front of the
    list. We will keep each node as a struct:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，让我们在列表的前面实现元素插入。我们将每个节点都保留为一个结构：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Pay attention to the `next` member – it points to the same struct, this way
    allowing the chaining of nodes together, as shown in the preceding illustration.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`next`成员 - 它指向相同的结构，这样可以允许节点链接在一起，如前面的插图所示。
- en: 'To implement a linked list, all we need is to keep a pointer to its first node,
    usually called the head of the list. Inserting an element at the front of the
    list is simple:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现一个链表，我们只需要保留指向其第一个节点的指针，通常称为链表的头。在列表的前面插入元素很简单：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There are three cases that we should consider when inserting an element into
    a list:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在向列表中插入元素时，我们应该考虑三种情况：
- en: 'Inserting an element at the front of the list, as discussed earlier, takes
    the following steps:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，在列表前面插入元素需要以下步骤：
- en: '![](img/06be3736-adbe-4388-9396-677b0a094a7f.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/06be3736-adbe-4388-9396-677b0a094a7f.png)'
- en: 'Inserting an element at the end of the list is shown in the following diagram:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表末尾插入元素如下图所示：
- en: '![](img/6f88bf92-0a38-448d-a32c-8a92883f53ab.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f88bf92-0a38-448d-a32c-8a92883f53ab.png)'
- en: 'Finally, inserting an element in the middle of the list is done as follows:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，在列表中间插入元素的操作如下所示：
- en: '![](img/75876dd0-13a8-4b23-a1be-68ac50c50dd0.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/75876dd0-13a8-4b23-a1be-68ac50c50dd0.png)'
- en: In the preceding diagrams, inserting an element into a vector is obviously different
    from inserting an element into the list. How would you choose between a vector
    and a list? You should concentrate on the operations and their speed. For example,
    reading any element from the vector takes constant time. We can store a one million
    emails in a vector, and retrieve the one at position 834,000 without any additional
    effort. For linked lists, the operation is linear. So, if you need to store a
    collection of data that will be mostly read, but not written, then using a vector
    is obviously a reasonable choice.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，向向量插入元素显然与向列表插入元素不同。您将如何在向量和列表之间进行选择？您应该专注于操作及其速度。例如，从向量中读取任何元素都需要恒定的时间。我们可以在向量中存储一百万封电子邮件，并在不需要任何额外工作的情况下检索位置为834,000的电子邮件。对于链表，操作是线性的。因此，如果您需要存储的数据集大部分是读取而不是写入，那么显然使用向量是一个合理的选择。
- en: Inserting an element at any position in the list takes a constant-time operation,
    while the vector will strive to insert an element at a random position. Therefore,
    when you need a collection of objects to/from which data can be intensively added/removed,
    the better choice would be a linked list.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表中的任何位置插入元素都是一个常量时间的操作，而向量会努力在随机位置插入元素。因此，当您需要一个可以频繁添加/删除数据的对象集合时，更好的选择将是链表。
- en: We should also take into account the cache memory. Vectors have good data locality.
    Reading the first element of a vector involves copying the first *N* elements
    into the cache. Further reads of vector elements will be even faster. We can't
    say the same for linked lists. To find out the reason, let's move ahead to compare
    the memory layouts of a vector and a linked list.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该考虑缓存内存。向量具有良好的数据局部性。读取向量的第一个元素涉及将前*N*个元素复制到缓存中。进一步读取向量元素将更快。我们不能说链表也是如此。要找出原因，让我们继续比较向量和链表的内存布局。
- en: Containers in memory
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存中的容器
- en: 'As you already know from the previous chapters, an object takes memory space
    on one of the memory segments provided to the process. Most of the time, we are
    interested in the stack or heap memory. An automatic object takes space on the
    stack. The following two declarations both reside on the stack:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从前几章已经知道的那样，对象占用内存空间在进程提供的内存段之一上。大多数情况下，我们对堆栈或堆内存感兴趣。自动对象占用堆栈上的空间。以下两个声明都驻留在堆栈上：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Although `ptr` represents a pointer to an `Email` object, it takes space on
    the stack. It can point to a memory location allocated on the heap, but the pointer
    itself (the variable storing the address of a memory location) resides on the
    stack. This is crucial to understand and remember before going further with vectors
    and lists.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`ptr`表示指向`Email`对象的指针，但它占用堆栈上的空间。它可以指向在堆上分配的内存位置，但指针本身（存储内存位置地址的变量）驻留在堆栈上。在继续使用向量和列表之前，这一点是至关重要的。
- en: 'As we saw earlier in the chapter, implementing a vector involves encapsulating
    a pointer to an inner buffer that represents an array of elements of the specified
    type. When we declare a `Vector` object, it takes the necessary amount of stack
    memory to store its member data. The `Vector` class has the following three members:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面看到的，实现向量涉及封装指向表示指定类型的元素数组的内部缓冲区的指针。当我们声明一个`Vector`对象时，它需要足够的堆栈内存来存储其成员数据。`Vector`类有以下三个成员：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Supposing that an integer takes 4 bytes and a pointer takes 8 bytes, the following
    `Vector` object declaration will take at least 16 bytes of stack memory:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 假设整数占用4个字节，指针占用8个字节，那么以下`Vector`对象声明将至少占用16个字节的堆栈内存：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here''s how we picture the memory layout for the preceding code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们对前面代码的内存布局的想象：
- en: '![](img/5b07753c-2089-4701-a865-3e98d597197f.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b07753c-2089-4701-a865-3e98d597197f.png)'
- en: 'After inserting elements, the size of the vector on the stack will stay the
    same. The heap comes to the scene. The `buffer_` array points to a memory location
    allocated using the `new[]` operator. For example, look at the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 插入元素后，堆栈上的向量大小将保持不变。堆出现了。`buffer_`数组指向使用`new[]`运算符分配的内存位置。例如，看看以下代码：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Each new element that we push to the vector will take space on the heap, as
    shown in the following diagram:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们推送到向量的每个新元素都将占用堆上的空间，如下图所示：
- en: '![](img/ffb6f27e-00ca-4b30-86b7-4cdfd6c1530e.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ffb6f27e-00ca-4b30-86b7-4cdfd6c1530e.png)'
- en: Each newly inserted element resides right after the last element of the `buffer_`
    array. That's why we can say the vector is a cache-friendly container.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 每个新插入的元素都驻留在`buffer_`数组的最后一个元素之后。这就是为什么我们可以说向量是一个友好的缓存容器。
- en: 'Declaring a linked-list object also takes memory space on the stack for its
    data members. If we discuss the simple implementation that stores only the `head_`
    pointer, the following list object declaration will take at least 8 bytes of memory
    (for the `head_` pointer only):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 声明链表对象也会为其数据成员占用堆栈上的内存空间。如果我们讨论的是仅存储`head_`指针的简单实现，那么以下链表对象声明将至少占用8个字节的内存（仅用于`head_`指针）：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following illustration depicts the memory layout for the preceding code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下插图描述了前面代码的内存布局：
- en: '![](img/62daaf10-d88c-4439-a8e8-4bb85feb15e4.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62daaf10-d88c-4439-a8e8-4bb85feb15e4.png)'
- en: 'Inserting a new element creates an object of type `node` on the heap. Take
    a look at the following line:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 插入新元素会在堆上创建一个`node`类型的对象。看看以下行：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here''s how the memory illustration will change after inserting a new element:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在插入新元素后，内存插图将如下所示改变：
- en: '![](img/62c34472-4720-43f8-80c1-71ac1b5ab204.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62c34472-4720-43f8-80c1-71ac1b5ab204.png)'
- en: 'Take care that the node with all its data members resides on the heap. The
    item stores the value that we have inserted. When we insert another element, again
    a new node will be created. This time, the next pointer of the first node will
    point to the newly inserted element. And the newly inserted node''s prev pointer
    will point to the previous node of the list. The following illustration depicts
    the linked list''s memory layout after inserting the second element:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要注意的是，节点及其所有数据成员都驻留在堆上。该项存储我们插入的值。当我们插入另一个元素时，将再次创建一个新节点。这次，第一个节点的下一个指针将指向新插入的元素。而新插入的节点的prev指针将指向列表的前一个节点。下图描述了在插入第二个元素后链表的内存布局：
- en: '![](img/080ab163-ffd0-4b7b-8ff8-2ba3e9dfed60.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/080ab163-ffd0-4b7b-8ff8-2ba3e9dfed60.png)'
- en: 'An interesting thing happens when we allocate some random objects on the heap
    in between inserting elements into the list. For example, the following code inserts
    a node into the list, then allocates space for an integer (not related to the
    list). Finally, it again inserts an element into the list:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在向列表中插入元素之间在堆上分配一些随机对象时，会发生有趣的事情。例如，以下代码将一个节点插入列表，然后为一个整数（与列表无关）分配空间。最后，再次向列表中插入一个元素：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This intermediate random object declaration spoils the order of list elements,
    as shown in the following diagram:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个中间的随机对象声明破坏了列表元素的顺序，如下图所示：
- en: '![](img/bff12ecb-958e-4b6b-95b1-d731f5a627a6.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bff12ecb-958e-4b6b-95b1-d731f5a627a6.png)'
- en: The preceding diagram gives us a hint that the list is not a cache-friendly
    container, because of its structure and the allocation of its elements.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表提示我们，列表不是一个友好的缓存容器，因为它的结构和其元素的分配。
- en: Pay attention to the memory overhead created by incorporating each new node
    into the code. We pay an additional 16 bytes (considering the pointer takes 8
    bytes of memory) for one element. Thus, lists lose the game of optimal memory
    use to vectors.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意通过将每个新节点合并到代码中所创建的内存开销。我们为一个元素额外支付16个字节（考虑到指针占用8个字节的内存）。因此，列表在最佳内存使用方面输给了向量。
- en: We can try to fix the situation by introducing a preallocated buffer in the
    list. Each new node creation will then pass via the **placement new** operator.
    However, it's wiser to choose a data structure that better fits the problem of
    interest.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试通过在列表中引入预分配的缓冲区来解决这个问题。然后每个新节点的创建将通过**placement new**操作符进行。然而，更明智的选择是选择更适合感兴趣问题的数据结构。
- en: In real-world application development, programmers rarely implement their own
    vectors or linked lists. They usually use tested and stable library versions.
    C++ provides standard containers for both vectors and linked lists. Moreover,
    it provides two separate containers for singly and doubly linked lists.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用程序开发中，程序员很少实现自己的向量或链表。他们通常使用经过测试和稳定的库版本。C++为向量和链表提供了标准容器。此外，它为单链表和双链表提供了两个单独的容器。
- en: STL containers
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: STL容器
- en: The STL is a powerful collection of algorithms and containers. Although understanding
    and implementing data structures is a great skill for programmers, you don't have
    to implement them each time you need one in the project. The library providers
    take care of implementing stable and tested data structures and algorithms for
    us. By understanding the inner details of data structures and algorithms, we are
    making better choices of STL containers and algorithms while solving problems.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: STL是一个强大的算法和容器集合。虽然理解和实现数据结构是程序员的一项重要技能，但你不必每次在项目中需要时都要实现它们。库提供者负责为我们实现稳定和经过测试的数据结构和算法。通过理解数据结构和算法的内部细节，我们在解决问题时能够更好地选择STL容器和算法。
- en: 'The vectors and linked lists discussed previously are implemented in the STL
    as `std::vector<T>` and `std::list<T>`, where `T` is the type of each element
    of the collection. Besides the type, containers also take a second default `template`
    parameter as an allocator. The `std::vector`, for example, is declared as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 先前讨论的向量和链表在STL中分别实现为`std::vector<T>`和`std::list<T>`，其中`T`是集合中每个元素的类型。除了类型，容器还以分配器作为第二个默认`template`参数。例如，`std::vector`声明如下：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As introduced in the previous chapter, an allocator handles the efficient allocation/deallocation
    of container elements. The `std::allocator` is the default allocator for all standard
    containers in the STL. A more sophisticated allocator that behaves differently
    based on the memory resource is the `std::pmr::polymorphic_allocator`. The STL
    provides `std::pmr::vector` as an alias template that uses a polymorphic allocator,
    defined as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中介绍过，分配器处理容器元素的高效分配/释放。`std::allocator` 是STL中所有标准容器的默认分配器。一个更复杂的分配器，根据内存资源的不同而表现不同，是`std::pmr::polymorphic_allocator`。STL提供了`std::pmr::vector`作为使用多态分配器的别名模板，定义如下：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let's now take a closer look at `std::vector` and `std::list`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更仔细地看看`std::vector`和`std::list`。
- en: Using std::vector and std::list
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用std::vector和std::list
- en: 'The `std::vector` is defined in the `<vector>` header. Here''s the simplest
    usage example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector`在`<vector>`头文件中定义。以下是最简单的使用示例：'
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `std::vector` grows dynamically. We should consider the growth factor.
    When declaring a vector, it has some default capacity, which will then grow upon
    element insertion. Each time the number of elements exceeds the capacity of the
    vector, it increases its capacity by a given factor (usually, it doubles its capacity).
    If we know the approximate number of elements that we will need in the vector,
    we can optimize its use by initially allocating that capacity for the vector using
    the `reserve()` method. For example, the following code reserves a 10,000-element
    capacity:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector`是动态增长的。我们应该考虑增长因子。在声明一个向量时，它有一些默认容量，然后在插入元素时会增长。每当元素的数量超过向量的容量时，它会以给定的因子增加其容量（通常情况下，它会将其容量加倍）。如果我们知道我们将需要的向量中元素的大致数量，我们可以通过使用`reserve()`方法来为向量最初分配该容量来优化其使用。例如，以下代码保留了一个包含10,000个元素的容量：'
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It forces the vector to allocate space for 10,000 elements, thereby avoiding
    resizing during element insertion (unless we reach the 10,000-element threshold).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 它强制向量为10,000个元素分配空间，从而避免在插入元素时进行调整大小（除非达到10,000个元素的阈值）。
- en: 'On the other hand, if we encounter a scenario where the capacity is much bigger
    than the actual number of elements in the vector, we can shrink the vector to
    free the unused memory. We need to call the `shrink_to_fit()` function, as shown
    in the following example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们遇到容量远大于向量中实际元素数量的情况，我们可以缩小向量以释放未使用的内存。我们需要调用`shrink_to_fit()`函数，如下例所示：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This reduces the capacity to fit the size of the vector.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这减少了容量以适应向量的大小。
- en: 'Accessing vector elements is done the same way we access a regular array, using
    the `operator[]`. However, the `std::vector` provides two options for accessing
    its elements. One of them is considered a safe approach and is done via the `at()`
    function, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 访问向量元素的方式与访问常规数组的方式相同，使用`operator[]`。然而，`std::vector`提供了两种访问其元素的选项。其中一种被认为是安全的方法，通过`at()`函数进行，如下所示：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The difference between `at()` and `operator[]` is that `at()` accesses the
    specified element with bounds checking; that is, the following line throws an
    `std::out_of_range` exception:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`at()`和`operator[]`之间的区别在于，`at()`通过边界检查访问指定的元素；也就是说，以下行会抛出`std::out_of_range`异常：'
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We use the `std::list` almost the same way. These lists mostly have a similar
    public interface. Later in the chapter, we will discuss iterators that allow abstracting
    from specific containers so that we can replace a list with a vector without much
    of a penalty. Before that, let's see the difference between the list's and vector's
    public interfaces.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎以相同的方式使用`std::list`。这些列表大多有相似的公共接口。在本章后面，我们将讨论迭代器，允许从特定容器中抽象出来，这样我们可以用一个向量替换一个列表而几乎没有任何惩罚。在此之前，让我们看看列表和向量的公共接口之间的区别。
- en: 'Besides the standard set of functions that both containers support, such as
    `size()`, `resize()`, `empty()`, `clear()`, `erase()`, and others, the list has
    the `push_front()` function that inserts an element at the front of the list.
    This is done efficiently because the `std::list` represents a doubly linked list.
    As shown in the following code, the `std::list` supports `push_back()` as well:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 除了两个容器都支持的标准函数集，如`size()`、`resize()`、`empty()`、`clear()`、`erase()`等，列表还有`push_front()`函数，它在列表的前面插入一个元素。这样做是有效的，因为`std::list`表示一个双向链表。如下所示，`std::list`也支持`push_back()`：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The list supports additional operations that come in handy in many situations.
    For example, to merge two sorted lists, we use the `merge()` method. It takes
    another list as its argument and moves all of its elements to the current list.
    The list passed as an argument to the `merge()` method becomes empty after the
    operation.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 列表支持许多在许多情况下非常有用的附加操作。例如，要合并两个排序列表，我们使用`merge()`方法。它接受另一个列表作为参数，并将其所有元素移动到当前列表。传递给`merge()`方法的列表在操作后变为空。
- en: The STL also provides a singly linked list, represented by `std::forward_list`.
    To use it, you should include the `<forward_list>` header. As the singly linked
    list node has only one pointer, it's cheaper in terms of memory than the doubly
    linked list.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: STL还提供了一个单向链表，由`std::forward_list`表示。要使用它，应该包含`<forward_list>`头文件。由于单向链表节点只有一个指针，所以在内存方面比双向链表更便宜。
- en: The `splice()` method is somewhat similar to `merge()`, except that it moves
    a portion of the list provided as an argument. By moving, we mean re-pointing
    internal pointers to proper list nodes. This is true for both `merge()` and `splice()`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`splice()`方法与`merge()`有些相似，不同之处在于它移动作为参数提供的列表的一部分。所谓移动，是指重新指向内部指针以指向正确的列表节点。这对于`merge()`和`splice()`都是成立的。'
- en: 'When we use containers for storing and manipulating complex objects, the price
    of copying elements plays a big role in the program''s performance. Consider the
    following struct representing a three-dimensional point:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用容器存储和操作复杂对象时，复制元素的代价在程序性能中起着重要作用。考虑以下表示三维点的结构体：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, look at the following code, which inserts a `Point` object into a vector:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看以下代码，它将一个`Point`对象插入到一个向量中：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A temporary object is constructed and then moved to the vector''s corresponding
    slot. We can represent it visually as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先构造一个临时对象，然后将其移动到向量的相应插槽中。我们可以用以下方式进行可视化表示：
- en: '![](img/d94643e3-cbfa-4816-8059-4ac126c1bbcb.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d94643e3-cbfa-4816-8059-4ac126c1bbcb.png)'
- en: 'Obviously, the vector occupies more space beforehand to delay resize operations
    for as long as possible. When we insert a new element, the vector copies it to
    the next available slot (and will reallocate more space if it''s full). We can
    use that uninitialized space for creating a new element in place. The vector provides
    the `emplace_back()` function for that purpose. Here''s how we can use it:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，向量事先占用更多空间，以尽可能延迟调整大小操作。当我们插入一个新元素时，向量将其复制到下一个可用插槽（如果已满，则重新分配更多空间）。我们可以利用该未初始化空间来创建一个新元素。向量提供了`emplace_back()`函数来实现这一目的。以下是我们如何使用它：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Pay attention to the arguments we passed directly to the function. The following
    illustration depicts the use of `emplace_back()`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们直接传递给函数的参数。以下插图描述了`emplace_back()`的使用：
- en: '![](img/47e01350-abf8-4a83-8eba-70afe1301af7.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/47e01350-abf8-4a83-8eba-70afe1301af7.png)'
- en: The `emplace_back()` constructs the element through `std::allocator_traits::construct()`.
    The latter typically uses the placement of new operator to construct the element
    at already allocated uninitialized space.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`emplace_back()`通过`std::allocator_traits::construct()`构造元素。后者通常使用新操作符的放置来在已分配但未初始化的空间中构造元素。'
- en: The `std::list` also provides an `emplace_front()` method. Both functions return
    a reference to the inserted element. The only requirement is for the type of element
    to be `EmplaceConstructible`. For vectors, the type should also be `MoveInsertable`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::list`还提供了一个`emplace_front()`方法。这两个函数都返回插入的元素的引用。唯一的要求是元素的类型必须是`EmplaceConstructible`。对于向量，类型还应该是`MoveInsertable`。'
- en: Using container adapters
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用容器适配器
- en: You might have encountered descriptions of the stack and the queue as data structures
    (or *containers*, in terms of C++). Technically, they are not data structures,
    but data structure adapters. In STL, `std::stack` and `std::queue` adapt containers
    by providing a special interface to access them. The term *stack* is almost everywhere.
    So far, we have used it to describe a memory segment for objects with automatic
    storage duration. The segment takes the name *stack* because of its allocation/deallocation
    strategy.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经遇到了关于堆栈和队列的描述，它们被称为数据结构（或者在C++术语中称为*容器*）。从技术上讲，它们不是数据结构，而是数据结构适配器。在STL中，`std::stack`和`std::queue`通过提供特殊的接口来访问容器来适配容器。术语*堆栈*几乎无处不在。到目前为止，我们已经用它来描述具有自动存储期限的对象的内存段。该段采用*堆栈*的名称，因为它的分配/释放策略。
- en: 'We say that objects are pushed to the stack each time we declare them, and
    popped out on destruction. The objects are popped in the reverse order in which
    they have been pushed. That''s the reason for calling the memory segment the stack.
    The same **last-in, first-out** (**LIFO**) method applies to the stack adapter.
    The crucial functions provided by `std::stack` are as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说每次声明对象时，对象都会被推送到堆栈上，并在销毁时弹出。对象以它们被推送的相反顺序弹出。这就是称内存段为堆栈的原因。相同的**后进先出**（**LIFO**）方法适用于堆栈适配器。`std::stack`提供的关键函数如下：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `push()` function effectively calls the `push_back()` of the underlying
    container. Usually, the stack is implemented using a vector. We've already discussed
    such a scenario in [Chapter 3](c0982ed5-7e38-4bd3-9c4d-37b0d2f01691.xhtml), *Details
    of Object-Oriented Programming*, when we introduced protected inheritance. `std::stack`
    has two template parameters; one of them is the container. It doesn't matter what
    you choose, but it must have a `push_back()` member function. The default container
    for `std::stack` and `std::queue` is `std::deque`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`push()`函数有效地调用基础容器的`push_back()`。通常，堆栈是使用向量实现的。我们已经在[第3章](c0982ed5-7e38-4bd3-9c4d-37b0d2f01691.xhtml)中讨论过这样的情况，*面向对象编程的细节*，当我们介绍了受保护的继承。`std::stack`有两个模板参数；其中一个是容器。你选择什么并不重要，但它必须有一个`push_back()`成员函数。`std::stack`和`std::queue`的默认容器是`std::deque`。'
- en: '`std::deque` allows fast insertion at its beginning and its end. It is an indexed
    sequential container similar to `std::vector`. The name deque stands for *double-ended
    queue*.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::deque`允许在其开头和结尾快速插入。它是一个类似于`std::vector`的索引顺序容器。deque的名称代表*双端队列*。'
- en: 'Let''s see stack in action:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看堆栈的运行情况：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: A better alternative to the `push()` function is the `emplace()`. It calls the
    `emplace_back()` of the underlying container, therefore, constructs element in
    place.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`push()`函数的一个更好的替代方法是`emplace()`。它调用基础容器的`emplace_back()`，因此在原地构造元素。'
- en: 'To pull the element out, we call the `pop()` function. It doesn''t take any
    arguments and doesn''t return anything, it just removes the top element from the
    stack. To access the top element of the stack, we call the `top()` function. Let''s
    modify the previous example to print all the stack elements before popping them
    out:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要取出元素，我们调用`pop()`函数。它不接受任何参数，也不返回任何内容，只是从堆栈中移除顶部元素。要访问堆栈的顶部元素，我们调用`top()`函数。让我们修改前面的示例，在弹出元素之前打印所有堆栈元素：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `top()` function returns a reference to the top element. It calls the `back()`
    function of the underlying container. Pay attention to the last `top()` function that
    we called on the empty stack. We suggest you check the size of the stack using
    `size()` before calling `top()` on the empty one.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`top()`函数返回对顶部元素的引用。它调用基础容器的`back()`函数。在空堆栈上调用`top()`函数时要注意。我们建议在对空堆栈调用`top()`之前检查堆栈的大小使用`size()`。'
- en: '`queue` is another adapter with slightly different behavior from the stack.
    The logic behind the queue is that it returns the first inserted element first:
    it maintains the **first-in, first-out** (**FIFO**) principle. Look at the following
    diagram:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`queue`是另一个适配器，其行为与堆栈略有不同。队列背后的逻辑是它首先返回插入的第一个元素：它遵循**先进先出**（**FIFO**）原则。看下面的图表：'
- en: '![](img/04d19255-e43e-485b-af2f-6269d220bd0e.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04d19255-e43e-485b-af2f-6269d220bd0e.png)'
- en: 'The formal names for inserting and retrieving operations in a queue are **enqeue**
    and **dequeue**. `std::queue` keeps a consistent approach and provides the `push()`
    and `pop()` functions. To access the first and last elements of the queue, you
    should use `front()` and `back()`. Both return references to elements. Here''s
    a simple usage example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 队列中插入和检索操作的正式名称是**enqeue**和**dequeue**。`std::queue`保持一致的方法，并提供`push()`和`pop()`函数。要访问队列的第一个和最后一个元素，应该使用`front()`和`back()`。两者都返回元素的引用。这里是一个简单的使用示例：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Knowing various containers and adapters is useful when you apply them correctly.
    There isn''t a silver bullet in choosing the right container for all kinds of
    problems. Many compilers use the stack to parse code expressions. For example,
    it''s easy to validate the parentheses in the following expression using the stack:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当你正确应用它们时，了解各种容器和适配器是有用的。在选择所有类型问题的正确容器时，并没有银弹。许多编译器使用堆栈来解析代码表达式。例如，使用堆栈很容易验证以下表达式中的括号：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Try it for practice. Write a small program that validates the preceding expression
    using a stack.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试练习一下。编写一个小程序，使用堆栈验证前面的表达式。
- en: The applications of queues are even wider. We will see one of them in [Chapter
    11](0e28887e-1a43-4510-a8ef-b3ad7531868d.xhtml), *Designing a Strategy Game using
    Design Patterns*, where we design a strategy game.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 队列的应用更加广泛。我们将在[第11章](0e28887e-1a43-4510-a8ef-b3ad7531868d.xhtml)中看到其中之一，*使用设计模式设计策略游戏*，在那里我们设计了一个策略游戏。
- en: Another container adapter is `std::priority_queue`. A priority queue usually
    adapts a balanced, node-based data structure, such as max- or min-heap. We will
    examine trees and graphs toward the end of this chapter and see how the priority
    queue works under the hood.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个容器适配器是`std::priority_queue`。优先队列通常适配平衡的、基于节点的数据结构，例如最大堆或最小堆。我们将在本章末尾讨论树和图，并看看优先队列在内部是如何工作的。
- en: Iterating containers
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代容器
- en: 'The idea of a container that is not iterable is like a car that cannot be driven. After
    all, a container is a collection of items. One of the common ways to iterate over
    container elements is to use the plain old `for` loop:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不可迭代的容器的概念就像一辆无法驾驶的汽车一样。毕竟，容器是物品的集合。迭代容器元素的常见方法之一是使用普通的`for`循环：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Containers provide a different set of operations for element access. For example,
    the vector provides the `operator[]`, whereas the list does not. The `std::list`
    has the `front()` and `back()` methods, which return the first and last elements,
    respectively. The `std::vector`, as already discussed, additionally provides `at()`
    and `operator[]`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 容器提供了一组不同的元素访问操作。例如，向量提供了`operator[]`，而列表则没有。`std::list`有`front()`和`back()`方法，分别返回第一个和最后一个元素。另外，正如前面讨论的，`std::vector`还提供了`at()`和`operator[]`。
- en: 'This means that we can''t use the preceding loop for iterating list elements.
    But we can loop over a list (and vector) with a range-based `for` loop as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们不能使用前面的循环来迭代列表元素。但我们可以使用基于范围的`for`循环来遍历列表（和向量），如下所示：
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It might seem confusing, but the trick is hidden in the range-based `for` implementation.
    It retrieves an iterator pointing to the first element of the container using
    the `std::begin()` function.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来令人困惑，但诀窍隐藏在基于范围的`for`实现中。它使用`std::begin()`函数检索指向容器第一个元素的迭代器。
- en: 'An **iterator** is an object that points to the container element and can be
    advanced to the next element based on the physical structure of the container.
    The following code declares a `vector` iterator and initializes it with an iterator
    pointing to the beginning of the `vector`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**迭代器**是指向容器元素的对象，并且可以根据容器的物理结构前进到下一个元素。以下代码声明了一个`vector`迭代器，并用指向`vector`开头的迭代器进行初始化：'
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Containers provide two member functions, `begin()` and `end()`, returning iterators
    to the beginning and the end of the container, respectively. The following diagram
    shows how we treat the beginning and the end of the container:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 容器提供两个成员函数`begin()`和`end()`，分别返回指向容器开头和结尾的迭代器。以下图表显示了我们如何处理容器的开头和结尾：
- en: '![](img/4a058f5f-c5de-47fb-94e4-a5e25dbf0440.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a058f5f-c5de-47fb-94e4-a5e25dbf0440.png)'
- en: 'The previous code that iterated over the list elements using a range-based
    `for` can be considered something like the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于范围的`for`迭代列表元素的先前代码可以被视为以下内容：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Pay attention to the `*` operator that we used in the previous code to access
    the underlying element by an iterator. We consider an iterator a *clever *pointer
    to the container element.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在先前代码中使用的`*`运算符，通过迭代器访问底层元素。我们认为迭代器是对容器元素的*巧妙*指针。
- en: The `std::begin()` and `std::end()` functions typically call the containers' `begin()`
    and `end()` methods, respectively. However, they are also applicable to regular
    arrays.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::begin()`和`std::end()`函数通常调用容器的`begin()`和`end()`方法，但它们也适用于常规数组。'
- en: 'The container iterator knows exactly how to work with the container elements.
    For example, advancing a vector iterator moves it to the next slot of the array,
    while advancing a list iterator moves it to the next node using the corresponding
    pointer, as illustrated in the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 容器迭代器确切地知道如何处理容器元素。例如，向前推进向量迭代器会将其移动到数组的下一个槽位，而向前推进列表迭代器会使用相应的指针将其移动到下一个节点，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Each container has its own iterator implementation; that''s why list and vector
    iterators have the same interface but behave differently. The behavior of the
    iterator is defined by its *category*. For example, a vector''s iterator is a
    random-access iterator, which means we can randomly access any element using the
    iterator. The following code accesses the fourth element of the vector via its
    iterator by adding `3` to it, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 每个容器都有自己的迭代器实现；这就是为什么列表和向量迭代器有相同的接口但行为不同。迭代器的行为由其*类别*定义。例如，向量的迭代器是随机访问迭代器，这意味着我们可以使用迭代器随机访问任何元素。以下代码通过向量的迭代器访问第四个元素，方法是将`3`添加到迭代器上：
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'There are six iterator categories in STL:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: STL中有六种迭代器类别：
- en: Input
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入
- en: Output (the same as input, but supporting write access)
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出（与输入相同，但支持写访问）
- en: Forward
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前向
- en: Bidirectional
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双向
- en: Random access
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机访问
- en: Contiguous
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连续
- en: The **i****nput iterator** provides read access (by calling the `*` operator) and enables
    forwarding the iterator position using prefix and postfix increment operators.
    An input iterator doesn't support multiple passes, that is, we can use an iterator
    to iterate over the container only once. The **forward iterator**, on the other
    hand, supports multiple passes. Multiple-pass support means we can read the value
    of the element through the iterator more than once.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入迭代器**提供读取访问（通过调用`*`运算符）并使用前缀和后缀递增运算符向前推进迭代器位置。输入迭代器不支持多次遍历，也就是说，我们只能使用迭代器对容器进行一次遍历。另一方面，**前向迭代器**支持多次遍历。多次遍历支持意味着我们可以通过迭代器多次读取元素的值。'
- en: The **output iterator** doesn't provide access to the element, but it allows
    assigning new values to it. A combination of an input iterator and output iterator
    with the multiple passes feature comprises the forward iterator. However, the
    forward iterator supports only increment operations, whereas the **bidirectional
    iterators** support moving the iterator to any position. They support decrementing
    operations. For example, the `std::list` supports bidirectional iterators.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出迭代器**不提供对元素的访问，但它允许为其分配新值。具有多次遍历特性的输入迭代器和输出迭代器的组合构成了前向迭代器。然而，前向迭代器仅支持递增操作，而**双向迭代器**支持将迭代器移动到任何位置。它们支持递减操作。例如，`std::list`支持双向迭代器。'
- en: Finally, the **random access iterator** allows *jumping* through elements by
    adding/subtracting a number to/from the iterator. The iterator will jump to the
    position specified by the arithmetic operation. The `std::vector` provides random
    access iterators.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，**随机访问迭代器**允许通过向迭代器添加/减去一个数字来*跳跃*元素。迭代器将跳转到由算术操作指定的位置。`std::vector`提供了随机访问迭代器。
- en: Each of the categories defines the set of operations that can be applied to
    the iterator. For example, the input iterator can be used to read the value of
    the element and advance to the next element by incrementing the iterator. On the
    other hand, the random access iterator allows incrementing and decrementing the
    iterator with arbitrary values, reading and writing the value of the element,
    and so on.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类别都定义了可以应用于迭代器的操作集。例如，输入迭代器可用于读取元素的值并通过递增迭代器前进到下一个元素。另一方面，随机访问迭代器允许以任意值递增和递减迭代器，读取和写入元素的值等。
- en: A combination of all of the features described thus far in this section falls
    into the **contiguous iterator** category, which also expects the container to
    be a contiguous one. This means that container elements are guaranteed to reside
    right next to the other. An example of a contiguous container is the `std::array`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止在本节中描述的所有特性的组合都属于**连续迭代器**类别，它也期望容器是一个连续的。这意味着容器元素保证紧邻在一起。`std::array`就是一个连续的容器的例子。
- en: Functions such as `distance()` use the information about the iterator to achieve
    the fastest result in execution. For example, the `distance()` function between
    two bidirectional iterators takes a linear time of execution, while the same function
    for random access iterators runs in constant time.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如`distance()`的函数使用迭代器的信息来实现最快的执行结果。例如，两个双向迭代器之间的`distance()`函数需要线性执行时间，而随机访问迭代器的相同函数在常数时间内运行。
- en: 'The following pseudocode demonstrates a sample implementation:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下伪代码演示了一个示例实现：
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Although the pseudocode shown in the preceding example works fine, we should
    consider that checking the category of an iterator at runtime is not an option.
    It is defined at compile time, so we need to use template specialization in order to
    generate the `distance()` function for random access iterators. A better solution
    would be using the `std::is_same` type trait, defined in `<type_traits>`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面示例中显示的伪代码运行良好，但我们应该考虑在运行时检查迭代器的类别不是一个选项。它是在编译时定义的，因此我们需要使用模板特化来生成随机访问迭代器的`distance()`函数。更好的解决方案是使用`<type_traits>`中定义的`std::is_same`类型特征：
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`std::is_same_v` is a helper template for the `std::is_same`, defined as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::is_same_v`是`std::is_same`的辅助模板，定义如下：'
- en: '[PRE40]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The most important quality of iterators is providing loose coupling between
    containers and algorithms:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器最重要的特性是提供了容器和算法之间的松耦合：
- en: '![](img/2d7a6c25-7b1f-4a4d-a3c1-80259c833393.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2d7a6c25-7b1f-4a4d-a3c1-80259c833393.png)'
- en: 'STL is based upon those three concepts: containers, algorithms, and iterators.
    While a vector, a list, or any other container is different, they serve the same
    purpose: storing data.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: STL基于这三个概念：容器、算法和迭代器。虽然向量、列表或任何其他容器都不同，它们都有相同的目的：存储数据。
- en: On the other hand, algorithms are functions that work with data; most of the
    time they work with collections of data. An algorithm definition usually represents
    a generic way of specifying the steps that should be taken to handle container
    elements. For example, a sorting algorithm sorts container elements in ascending
    or descending order.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，算法是处理数据的函数；它们大部分时间都与数据集合一起工作。算法定义通常代表了指定应采取哪些步骤来处理容器元素的通用方式。例如，排序算法按升序或降序对容器元素进行排序。
- en: Vectors are contiguous containers, while lists are node-based containers. Sorting
    them will require a deeper understanding of the particular container's physical
    structure. To properly sort a vector, a separate sort function should be implemented
    for it. The same logic applies to lists.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 向量是连续的容器，而列表是基于节点的容器。对它们进行排序将需要更深入地了解特定容器的物理结构。为了正确地对向量进行排序，应该为它实现一个单独的排序函数。相同的逻辑也适用于列表。
- en: 'Iterators take this multiplicity of implementations to a generic level. They
    provide the library designers the ability to implement just one sorting function,
    which will deal only with iterators, abstracting from the container type. In the
    STL, the `sort()` algorithm (defined in `<algorithm>`) deals with iterators, and
    we can sort both vectors and lists with the same function:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器将这种多样性的实现提升到了一个通用级别。它们为库设计者提供了实现只需处理迭代器的排序函数的能力，抽象出容器类型。在STL中，`sort()`算法（在`<algorithm>`中定义）处理迭代器，我们可以使用相同的函数对向量和列表进行排序：
- en: '[PRE41]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The iterators described in this section are now considered legacy features.
    C++20 introduces a new system of iterators based on **concepts**.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中描述的迭代器现在被认为是遗留特性。C++20引入了基于**概念**的新迭代器系统。
- en: Concepts and iterators
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概念和迭代器
- en: C++20 introduces **concepts** as one of its major features. Along with concepts,
    C++20 has new iterators based on concepts. Although the iterators discussed in
    this chapter up to here are now considered legacy features, lots of lines of code
    have already been written using them. That's why we introduced them first before
    continuing with the new iterator concepts. Now, let's find out what concepts are
    and how to use them.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: C++20将**概念**作为其主要特性之一引入。除了概念，C++20还有基于概念的新迭代器。尽管本章讨论的迭代器现在被认为是遗留特性，但已经有大量的代码使用它们。这就是为什么我们在继续介绍新的迭代器概念之前首先介绍它们的原因。现在，让我们了解一下概念是什么，以及如何使用它们。
- en: Understanding concepts
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解概念
- en: 'Abstraction is essential in computer programming. We introduced classes in
    [Chapter 3](c0982ed5-7e38-4bd3-9c4d-37b0d2f01691.xhtml), *Details of Object-Oriented
    Programming, *as a way to represent data and operations as an abstract entity.
    After that, in [Chapter 4](c0e82f94-f2ed-4f17-98c9-1c3d3b27ae3d.xhtml), *Understanding
    and Designing Templates*, we dove into templates and saw how we can make classes
    even more flexible by reusing them for various aggregate types. Templates not
    only provide abstraction from the specific type, but also incorporate loose coupling
    between the entity and aggregate types. Take, for example, `std::vector`. It provides
    a generic interface to store and manipulate collections of objects. We can easily
    declare three different vectors that will contain three different types of objects,
    as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象在计算机编程中是至关重要的。我们在[第3章](c0982ed5-7e38-4bd3-9c4d-37b0d2f01691.xhtml)中引入了类，*面向对象编程的细节*，作为一种将数据和操作表示为抽象实体的方式。之后，在[第4章](c0e82f94-f2ed-4f17-98c9-1c3d3b27ae3d.xhtml)中，*理解和设计模板*，我们深入研究了模板，并看到如何通过重用它们来使类变得更加灵活，以适用于各种聚合类型。模板不仅提供了对特定类型的抽象，还实现了实体和聚合类型之间的松耦合。例如，`std::vector`。它提供了一个通用接口来存储和操作对象的集合。我们可以轻松地声明三个包含三种不同类型对象的不同向量，如下所示：
- en: '[PRE42]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If not templates, we would have to do something like the following for the
    preceding code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有模板，我们将不得不对前面的代码做如下处理：
- en: '[PRE43]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Although the preceding code is ridiculously unacceptable, we should agree on
    the fact that templates are the basis of generic programming. Concepts introduce
    even more flexibility to generic programming. Now it is possible to set restrictions
    on template parameters, check for constraints, and discover inconsistent behavior
    at compile time. A template class declaration has the following form:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的代码是不可接受的，但我们应该同意模板是泛型编程的基础。概念为泛型编程引入了更多的灵活性。现在可以对模板参数设置限制，检查约束，并在编译时发现不一致的行为。模板类声明的形式如下：
- en: '[PRE44]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Pay attention to the `typename` keyword in the preceding code block. Concepts
    go even further: they allow replacing it with a type description that describes
    the template parameter. Let''s say we want the `Wallet` to work with types that
    can be added together, that is, they should be *addable*. Here''s how using a
    concept will help us achieve that in the code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意前面代码块中的`typename`关键字。概念甚至更进一步：它们允许用描述模板参数的类型描述来替换它。假设我们希望`Wallet`能够处理可以相加的类型，也就是说，它们应该是*可加的*。以下是如何使用概念来帮助我们在代码中实现这一点：
- en: '[PRE45]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'So, now we can create `Wallet` instances by providing types that are addable.
    Whenever the type doesn''t satisfy the constraint, the compiler will throw an
    error. It looks a bit supernatural. The following snippet declares two `Wallet`
    objects:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们可以通过提供可相加的类型来创建`Wallet`实例。每当类型不满足约束时，编译器将抛出错误。这看起来有点超自然。以下代码片段声明了两个`Wallet`对象：
- en: '[PRE46]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `Book` class has no `+` operator, so the construction of `g` will fail because
    of the `template` parameter type restriction.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`Book`类没有`+`运算符，因此由于`template`参数类型限制，`g`的构造将失败。'
- en: 'The declaration of a concept is done using the `concept` keyword and has the
    following form:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`concept`关键字来声明概念，形式如下：
- en: '[PRE47]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As you can see, a concept is also declared using templates. We can refer to
    them as types that describe other types. Concepts rely heavily on **constraints**.
    A constraint is a way to specify requirements for template arguments, and, as
    follows, a concept is a set of constraints. Here''s how we can implement the preceding
    addable concept:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，概念也是使用模板来声明的。我们可以将它们称为描述其他类型的类型。概念在**约束**上有很大的依赖。约束是指定模板参数要求的一种方式，因此概念是一组约束。以下是我们如何实现前面的可加概念：
- en: '[PRE48]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Standard concepts are defined in the `<concepts>` header.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 标准概念在`<concepts>`头文件中定义。
- en: We can also combine several concepts into one by requiring the new concept to
    support the others. To achieve that we use the `&&` operator. Let's see how iterators
    leverage concepts and bring an example of an `incrementable` iterator concept
    that combines other concepts.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过要求新概念支持其他概念来将几个概念合并为一个。为了实现这一点，我们使用`&&`运算符。让我们看看迭代器如何利用概念，并举例说明一个将其他概念结合在一起的`incrementable`迭代器概念。
- en: Using iterators in C++20
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C++20中使用迭代器
- en: 'After the introduction to concepts, it is obvious that iterators are first
    to leverage them to the fullest. Iterators and their categories are now considered
    legacy because, starting from C++20, we use iterator concepts such as **`readable`**
    (which specifies that the type is readable by applying the `*` operator) and `writable`
    (which specifies that a value can be written to an object referenced by the iterator).
    As promised, let''s see how `incrementable` is defined in the `<iterator>` header:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍概念之后，显而易见的是迭代器是首先充分利用它们的。迭代器及其类别现在被认为是遗留的，因为从C++20开始，我们使用迭代器概念，如**`readable`**（指定类型可通过应用`*`运算符进行读取）和`writable`（指定可以向迭代器引用的对象写入值）。正如承诺的那样，让我们看看`incrementable`在`<iterator>`头文件中是如何定义的：
- en: '[PRE49]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: So, the `incrementable` concept requires the type to be `std::regular`. That
    means it should be constructible by default and have a copy constructor and `operator==()`.
    Besides that, the `incrementable` concept requires the type to be `weakly_incrementable`,
    which means the type supports pre- and post-increment operators, except that the
    type is not required to be equality-comparable. That's why the `incrementable`
    joins `std::regular` to require the type to be equality-comparable. Finally, the
    addition `requires` constraint points to the fact that the type should not change
    after an increment, that is, it should be the same type as before. Although `std::same_as` is represented
    as a concept (defined in `<concepts>`), in previous versions we used to use `std::is_same` defined
    in `<type_traits>`. They basically do the same thing, but the C++17 version – `std::is_same_v` –
    was verbose, with additional suffixes.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可递增的概念要求类型为std::regular。这意味着它应该可以通过默认方式构造，并且具有复制构造函数和operator==()。除此之外，可递增的概念要求类型为weakly_incrementable，这意味着该类型支持前置和后置递增运算符，除了不需要该类型是可比较相等的。这就是为什么可递增加入std::regular要求类型是可比较相等的。最后，附加的requires约束指出类型在递增后不应更改，也就是说，它应该与之前的类型相同。尽管std::same_as被表示为一个概念（在<concepts>中定义），在以前的版本中我们使用的是在<type_traits>中定义的std::is_same。它们基本上做同样的事情，但是C++17版本的std::is_same_v很啰嗦，带有额外的后缀。
- en: 'So, instead of iterator categories, we now refer to iterator concepts. Besides
    the ones we introduced earlier, the following concepts should also be taken into
    consideration:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们不再提到迭代器类别，而是提到迭代器概念。除了我们之前介绍的概念，还应该考虑以下概念：
- en: '`input_iterator` specifies that the type allows its referenced values to be
    read and is both pre- and post-**incrementable**.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入迭代器指定该类型允许读取其引用值，并且可以进行前置和后置递增。
- en: '`output_iterator` specifies that values of the type can be written to and the
    type is both pre- and post-**incrementable**.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出迭代器指定该类型的值可以被写入，并且该类型可以进行前置和后置递增。
- en: '`input_or_output_iterator`, the unnecessarily long name aside, specifies that
    the type is **incrementable** and can be dereferenced.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入或输出迭代器，除了名称过长之外，指定该类型是可递增的，并且可以被解引用。
- en: '`forward_iterator` specifies that the type is an `input_iterator` that additionally
    supports equality comparison and multi-pass.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前向迭代器指定该类型是一个输入迭代器，此外还支持相等比较和多遍历。
- en: '`bidirectional_iterator` specifies that the type supports `forward_iterator`
    and additionally supports the backward movement.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双向迭代器指定该类型支持前向迭代器，并且还支持向后移动。
- en: '`random_access_iterator` specifies that the type as a `bidirectional_iterator`,
    supporting advancement in constant time and subscripting.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机访问迭代器指定该类型为双向迭代器，支持常数时间的前进和下标访问。
- en: '`contiguous_iterator` specifies that the type is a `random_access_iterator`,
    referring to elements that are contiguous in memory.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连续迭代器指定该类型是一个随机访问迭代器，指的是内存中连续的元素。
- en: They almost repeat the legacy iterators that we discussed earlier, but now they
    can be used when declaring template parameters so that the compiler will take
    care of the rest.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 它们几乎重复了我们之前讨论的传统迭代器，但现在它们可以在声明模板参数时使用，这样编译器将处理其余部分。
- en: Mastering algorithms
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握算法
- en: As already mentioned, algorithms are functions taking some input, processing
    it, and returning an output. Usually, an algorithm in the context of the STL implies
    a function processing a collection of data. Collections of data are presented
    in the form of containers, such as `std::vector`, `std::list`, and others.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，算法是接受一些输入，处理它，并返回输出的函数。通常，在STL的上下文中，算法意味着处理数据集合的函数。数据集合以容器的形式呈现，例如std::vector、std::list等。
- en: Choosing an efficient algorithm is a common task in a programmer's routine.
    For example, searching a sorted vector using the binary search algorithm will
    be much more efficient than using sequential searching. To compare the efficiency
    of algorithms, a so-called **asymptotic analysis** is performed, which takes into
    consideration the speed of the algorithm with regard to the input data size. This
    means that we shouldn't actually compare two algorithms by applying them to a
    container with ten or a 100 elements.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 选择高效的算法是程序员日常工作中的常见任务。例如，使用二分搜索算法搜索排序后的向量将比使用顺序搜索更有效。为了比较算法的效率，进行所谓的渐近分析，考虑算法速度与输入数据大小的关系。这意味着我们实际上不应该将两个算法应用于一个包含十个或一百个元素的容器进行比较。
- en: The actual difference of algorithms shows itself when applied to *big enough*
    containers, having a one million or even a one billion records. Measuring the
    efficiency of an algorithm is also known as verifying its complexity. You might've
    encountered *O(n)* algorithms or *O(log N)* algorithms. The *O()* function (pronounced *big-oh*)
    defines the complexity of an algorithm.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的实际差异在应用于足够大的容器时才会显现，比如有一百万甚至十亿条记录的容器。衡量算法的效率也被称为验证其复杂性。您可能遇到过O(n)算法或O(log
    N)算法。O()函数（读作big-oh）定义了算法的复杂性。
- en: Let's take a look at the searching algorithms and compare their complexity along
    the way.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看搜索算法，并比较它们的复杂性。
- en: Searching
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索
- en: 'Searching an element in the container is a common task. Let''s implement sequential
    searching of an element in a vector:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器中搜索元素是一个常见的任务。让我们实现在向量中进行顺序搜索元素。
- en: '[PRE50]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This is a simple algorithm that iterates through a vector and returns the index
    at which the element is equal to the value passed as the search key. We name it
    sequential searching because it sequentially scans the vector elements. Its complexity
    is linear: *O(n)*. To measure it, we should somehow define the number of operations
    that the algorithm takes to find the result. Supposing the vector contains *n*
    elements, the following code contains a comment on each line of the search function
    about its operations:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的算法，它遍历向量并返回元素等于作为搜索键传递的值的索引。我们称之为顺序搜索，因为它按顺序扫描向量元素。它的复杂性是线性的：*O(n)*。为了衡量它，我们应该以某种方式定义算法找到结果所需的操作数。假设向量包含
    *n* 个元素，下面的代码在搜索函数的每一行都有关于其操作的注释：
- en: '[PRE51]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We have three copy operations, *n + 1* and *n* (that is, *2n + 1*) comparisons,
    and *n + 1* increment operations. What if the desired element is in the first
    position of the vector? Well, in that case, we would scan only the first element
    of the vector and return from the function.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三种复制操作，*n + 1* 和 *n*（也就是 *2n + 1*）次比较，以及 *n + 1* 次增量操作。如果所需元素在向量的第一个位置怎么办？那么，我们只需要扫描向量的第一个元素并从函数中返回。
- en: 'However, it doesn''t mean that our algorithm is so efficient that it takes
    just one step to perform its task. In order to measure the complexity of an algorithm,
    we should take into consideration the worst-case scenario: the desired element
    either doesn''t exist in the vector or resides in the last position of the vector.
    The following diagram shows the three scenarios for the element that we are about
    to find:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不意味着我们的算法非常高效，只需要一步就能完成任务。为了衡量算法的复杂性，我们应该考虑最坏情况：所需元素要么不存在于向量中，要么位于向量的最后位置。下图显示了我们即将找到的元素的三种情况：
- en: '![](img/89c34b2d-9597-4ea4-ac1a-a32ef5031eb7.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/89c34b2d-9597-4ea4-ac1a-a32ef5031eb7.png)'
- en: We should consider the worst-case scenario only because it covers all the other
    cases as well. If we define the complexity of an algorithm for the worst case,
    we can be sure it won't ever work slower than that.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要考虑最坏情况，因为它也涵盖了所有其他情况。如果我们为最坏情况定义算法的复杂性，我们可以确保它永远不会比那更慢。
- en: 'To find out the complexity of an algorithm, we should find the connection between
    the number of operations and the size of the input. In this case, the size of
    the input is the length of the container. Let''s denote copies as A, comparisons
    as C, and increment operations as I, so that we have 3A + (2n + 1)C + (n + 1)I
    operations. The complexity of the algorithm will be defined as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找出算法的复杂性，我们应该找到操作次数和输入大小之间的关系。在这种情况下，输入的大小是容器的长度。让我们将复制记为A，比较记为C，增量操作记为I，这样我们就有3A
    + (2n + 1)C + (n + 1)I次操作。算法的复杂性将定义如下：
- en: '*O(3A + (2n + 1)C + (n + 1)I)*'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*O(3A + (2n + 1)C + (n + 1)I)*'
- en: 'This then can be simplified in the following way:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以以以下方式简化：
- en: '*O(3A + (2n + 1)C + (n + 1)I) =*'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*O(3A + (2n + 1)C + (n + 1)I) =*'
- en: '*O(3A + 2nC + C + nI + I) = *'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*O(3A + 2nC + C + nI + I) = *'
- en: '*O(n(2C + I) + (3A + C + I)) = *'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*O(n(2C + I) + (3A + C + I)) = *'
- en: '*O(n(2C + I))*'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*O(n(2C + I))*'
- en: Finally, the *O()'s* properties allow us to get rid of the constant coefficients
    and smaller members, because the actual algorithm complexity is related only to
    the size of the input, which is *n*, and we get the final complexity equal to
    *O(n)*. In other words, the sequential searching algorithm has linear time complexity.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*O()*的属性使我们可以摆脱常数系数和较小的成员，因为实际算法的复杂性只与输入的大小有关，即 *n*，我们得到最终复杂性等于 *O(n)*。换句话说，顺序搜索算法具有线性时间复杂性。
- en: 'As already mentioned, the essence of the STL is to connect containers and algorithms
    via iterators. That''s why the sequential search implementation is not considered
    STL-compatible: because it has strict restrictions on input parameters. To make
    it generic, we should consider implementing it using iterators only. To cover
    a wide range of container types, use forward iterators. The following code uses
    operators on the type `Iter`, assuming it''s a forward iterator:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，STL的本质是通过迭代器连接容器和算法。这就是为什么顺序搜索实现不被认为是STL兼容的：因为它对输入参数有严格的限制。为了使其通用，我们应该考虑仅使用迭代器来实现它。为了涵盖各种容器类型，使用前向迭代器。下面的代码使用了`Iter`类型的操作符，假设它是一个前向迭代器：
- en: '[PRE52]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Actually, any type of iterators can be passed to the `search()` function. We
    ensure that we use forward iterators just by applied operations on iterators themselves.
    We use only the increment (move forward), reading (the `*` operator), and strict
    comparisons (`==` and `!=`), which are supported by forward iterators.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，任何类型的迭代器都可以传递给`search()`函数。我们通过对迭代器本身应用操作来确保使用前向迭代器。我们只使用增量（向前移动）、读取（`*`运算符）和严格比较（`==`和`!=`），这些操作都受前向迭代器支持。
- en: Binary search
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二分搜索
- en: 'On the other hand is the binary search algorithm, which is simple to explain.
    At first, it looks for the middle element of the vector and compares the search
    key with it, and if it is equal, then the algorithm is done: it returns the index.
    Otherwise, if the search key is less than the middle element, it proceeds to the
    left of the vector. If the search key is greater than the middle element, the
    algorithm proceeds to the right-hand subvector.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面是二分搜索算法，这个算法很容易解释。首先，它查找向量的中间元素并将搜索键与之进行比较，如果相等，算法就结束了：它返回索引。否则，如果搜索键小于中间元素，算法继续向向量的左侧进行。如果搜索键大于中间元素，算法继续向右侧子向量进行。
- en: 'In order to get the binary search to work correctly for a vector, it should
    be sorted. The very essence of the binary search implies comparing the search
    key with vector elements and proceeding to the left- or right-hand subvectors,
    each of which contains a smaller or greater element compared to the middle element
    of the vector. Take a look at the following diagram, which depicts the binary
    search algorithm in action:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使二分搜索在向量中正确工作，它应该是排序的。二分搜索的核心是将搜索键与向量元素进行比较，并继续到左侧或右侧子向量，每个子向量都包含与向量中间元素相比较的较小或较大的元素。看一下下面的图表，它描述了二分搜索算法的执行过程：
- en: '![](img/c478e0fd-ae7e-4b99-8bec-7c288cd13272.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c478e0fd-ae7e-4b99-8bec-7c288cd13272.png)'
- en: 'The binary search algorithm has an elegant recursive implementation (though
    it''s better to use an iterative implementation) – take a look at it in the following
    code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 二分搜索算法有一个优雅的递归实现（尽管最好使用迭代实现）-在下面的代码中看一下：
- en: '[PRE53]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Pay attention to the middle element calculation. Instead of the `(start + end)
    / 2;`, we used the `start + (end - start) / 2;` technique just to avoid the famous
    bug in binary search implementations (assuming we didn't leave other bugs). The
    point is that for big values of start and end, their sum (*start + end*) will
    produce an integer overflow, which will make the program crash at some point.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 注意中间元素的计算。我们使用了`start + (end - start) / 2;`技术，而不是`(start + end) / 2;`，只是为了避免二分搜索实现中的著名错误（假设我们没有留下其他错误）。关键是对于start和end的大值，它们的和（*start
    + end*）会产生整数溢出，这将导致程序在某个时刻崩溃。
- en: Now let's find the complexity of the binary search. It's obvious that on each
    step of the execution, the source array gets halved so that we deal with the smaller
    or greater half of it in the next step. This means that the worst-case scenario
    is the case when we divide the vector until there is one or no element left. To
    find the number of steps in the algorithm, we should find the number of divisions
    with regard to the size of the vector. If the vector has 10 elements, then we
    divide it and get a subvector of five elements; by dividing it again, we get two-element
    subvector, and finally, dividing it again will bring us to a single element. So,
    for the 10-element vector, the number of divisions is 3\. For the *n*-element
    vector, the number of divisions is *log(n)*, because, on each step, *n* becomes
    *n/2*, which then becomes *n/4*, and so on. The complexity of the binary search
    is *O(logn)* (that is, logarithmic).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们找到二分搜索的复杂度。很明显，在执行的每一步中，源数组都会减半，这意味着我们在下一步中处理它的较小或较大的一半。这意味着最坏情况是将向量分割到只剩下一个或没有元素的情况。为了找到算法的步数，我们应该根据向量的大小找到分割的次数。如果向量有10个元素，那么我们将它分成一个包含五个元素的子向量；再次分割，我们得到一个包含两个元素的子向量，最后，再次分割将带我们到一个单一元素。因此，对于包含10个元素的向量，分割的次数是3。对于包含*n*个元素的向量，分割的次数是*log(n)*，因为在每一步中，*n*变为*n/2*，然后变为*n/4*，依此类推。二分搜索的复杂度是*O(logn)*（即对数）。
- en: 'STL algorithms are defined in the `<algorithm>` header file; where the implementation
    of the binary search resides. The STL implementation returns true if the element
    exists in the container. Take a look at its prototype:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: STL算法定义在`<algorithm>`头文件中；二分搜索的实现也在其中。STL实现如果元素存在于容器中则返回true。看一下它的原型：
- en: '[PRE54]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'STL algorithms don''t work directly with containers, instead, they work with
    iterators. This allows us to abstract from the specific container and to use the
    `binary_search()` with all the containers supporting a forward iterator. The following
    example calls the `binary_search()` function for both vectors and lists:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: STL算法不直接与容器一起工作，而是与迭代器一起工作。这使我们能够抽象出特定的容器，并使用`binary_search()`来支持前向迭代器的所有容器。下面的示例调用了`binary_search()`函数，用于向量和列表：
- en: '[PRE55]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `binary_search()` checks the category of the iterator, and in the case of
    a random access iterator, it uses the full power of the binary search algorithm
    (otherwise, it falls back to sequential search).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`binary_search()`检查迭代器的类别，在随机访问迭代器的情况下，它使用二分搜索算法的全部功能（否则，它将退回到顺序搜索）。'
- en: Sorting
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序
- en: The binary search algorithm is applicable only to sorted containers. Sorting
    is a known and old task for computer programmers, who nowadays rarely write their
    own implementation of a sorting algorithm. You might've used `std::sort()` many
    times without even caring about its implementation. Basically, a sorting algorithm
    takes a collection as an input and returns a new sorted collection (in the order
    defined by the algorithm user).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 二分搜索算法仅适用于排序的容器。对于计算机程序员来说，排序是一个众所周知的古老任务，现在他们很少编写自己的排序算法实现。你可能多次使用了`std::sort()`而不关心它的实现。基本上，排序算法接受一个集合作为输入，并返回一个新的排序集合（按照算法用户定义的顺序）。
- en: 'Of the many sorting algorithms out there, the most popular (or even the fastest
    one) is **quicksort**. The basic idea of any sorting algorithm is to find smaller
    (or greater) elements and exchange them with greater (or smaller) elements until
    the whole collection is sorted. For example, the selection sort logically divides
    the collection into two parts, sorted and unsorted, where the sorted subarray
    is initially empty like so:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在众多的排序算法中，最流行的（甚至是最快的）是**快速排序**。任何排序算法的基本思想都是找到较小（或较大）的元素，并将它们与较大（或较小）的元素交换，直到整个集合排序。例如，选择排序逻辑上将集合分为两部分，已排序和未排序，其中已排序的子数组最初为空，如下所示：
- en: '![](img/303865f2-ae26-44a9-bce2-0f8cefb9cc6f.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/303865f2-ae26-44a9-bce2-0f8cefb9cc6f.png)'
- en: 'The algorithm starts to look for the smallest element in the unsorted subarray
    and put it to the sorted subarray by exchanging it with the first element of the
    unsorted subarray. After the each step, the length of the sorted subarray increases
    by one, whereas the length of the unsorted subarray decreases like so:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 算法开始在未排序的子数组中寻找最小的元素，并通过与未排序的子数组的第一个元素交换将其放入已排序的子数组中。每一步之后，已排序子数组的长度增加了一个，而未排序子数组的长度减少了，如下所示：
- en: '![](img/995dc143-d05a-4a3d-b808-de3d058583c5.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/995dc143-d05a-4a3d-b808-de3d058583c5.png)'
- en: The process continues until the unsorted subarray becomes empty.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程持续进行，直到未排序的子数组变为空。
- en: 'The STL provides the `std::sort()` function, taking two random-access iterators:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: STL提供了`std::sort()`函数，接受两个随机访问迭代器：
- en: '[PRE56]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The sort function can't be applied to `std::list` because it doesn't support
    random access iterators. Instead, you should call the `sort()` member function
    of the list. Though this contradicts the idea of the STL having generic functions,
    it is done for efficiency.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort`函数不能应用于`std::list`，因为它不支持随机访问迭代器。相反，应该调用列表的`sort()`成员函数。尽管这与STL具有通用函数的想法相矛盾，但出于效率考虑而这样做。'
- en: 'The `sort()` function has a third parameter: a comparing function that can
    be used to compare container elements. Let''s suppose we store `Product` objects
    in our vector:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort()`函数有一个第三个参数：一个比较函数，用于比较容器元素。假设我们在向量中存储`Product`对象：'
- en: '[PRE57]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To sort the container properly, its elements must support the less-than operator,
    or `<`. We should define the corresponding operator for our custom type. However,
    we can omit the operator definition if we create a separate comparator function
    for our custom type, as shown in the following block:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确排序容器，其元素必须支持小于运算符，或`<`。我们应该为我们的自定义类型定义相应的运算符。但是，如果我们为我们的自定义类型创建一个单独的比较函数，就可以省略运算符定义，如下面的代码块所示：
- en: '[PRE58]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Passing `ProductComparator` to the `std::sort()` function allows it to compare
    the vector elements without diving into details of the type of its elements, as
    follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 将`ProductComparator`传递给`std::sort()`函数允许它比较向量元素，而无需深入了解其元素的类型，如下所示：
- en: '[PRE59]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'While this is a good technique, it would be more elegant to use lambda functions
    instead, which are anonymous functions just perfect for scenarios like the preceding
    one. Here''s how we can overwrite it:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个不错的技术，但更优雅的做法是使用lambda函数，它们是匿名函数，非常适合前面提到的场景。以下是我们如何覆盖它的方法：
- en: '[PRE60]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The preceding code allows omitting the declaration of `ProductComparator`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码允许省略`ProductComparator`的声明。
- en: Exploring trees and graphs
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索树和图
- en: The binary search algorithm and sorting algorithms combined together lead to
    the idea of having a container that keeps items sorted by default. One such container
    is the `std::set`, based on a balanced tree. Before discussing the balanced tree
    itself, let's take a look at the binary search tree, a perfect candidate for fast
    lookups.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索算法和排序算法结合在一起，引出了默认按排序方式保持项目的容器的想法。其中一个这样的容器是基于平衡树的`std::set`。在讨论平衡树本身之前，让我们先看看二叉搜索树，这是一个快速查找的完美候选者。
- en: 'The idea of the binary search tree is that the values of the left-hand subtree
    of a node are less than the node''s value. By contrast, the values of the right-hand
    subtree of a node are greater than the node''s value. Here''s an example of a
    binary search tree:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树的思想是，节点的左子树的值小于节点的值。相比之下，节点的右子树的值大于节点的值。以下是一个二叉搜索树的示例：
- en: '![](img/9c361b58-ff03-4ab1-bffc-dd29595f2378.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c361b58-ff03-4ab1-bffc-dd29595f2378.png)'
- en: As you can see in the preceding diagram, the element with the value 15 resides
    in the left-hand subtree because it's less than 30 (the root element). On the
    other hand, the element with the value 60 resides in the right-hand subtree because
    it's greater than the root element. The same logic applies to the rest of the
    tree elements.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的图表所示，值为15的元素位于左子树中，因为它小于30（根元素）。另一方面，值为60的元素位于右子树中，因为它大于根元素。相同的逻辑适用于树的其余元素。
- en: 'A binary tree node is represented as a struct containing the item and two pointers
    to each child. Here''s a sample code representation of a tree node:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树节点表示为一个包含项目和指向每个子节点的两个指针的结构。以下是树节点的示例代码表示：
- en: '[PRE61]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Searching, inserting, or removing an element takes *O(logn)* in a fully balanced
    binary search tree. The STL doesn''t provide a separate container for trees, but
    it has similar ones that are based on a tree implementation. For example, the
    `std::set` container is based on a balanced tree that uniquely stores elements
    in sorted order:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在完全平衡的二叉搜索树中，搜索、插入或删除元素需要*O(logn)*的时间。STL没有为树提供单独的容器，但它有基于树实现的类似容器。例如，`std::set`容器是基于平衡树的，可以按排序顺序唯一存储元素：
- en: '[PRE62]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `std::map` is also based on a balanced tree, but this one provides a container
    that maps a key to some value, as follows, for example:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::map`也是基于平衡树，但它提供了一个将键映射到某个值的容器，例如：'
- en: '[PRE63]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As shown in the preceding code, the function `map` `numbers` maps integers to
    strings. So when we tell the map to store the value of `3` as a key and the string
    `three` as a value, it adds a new node to its inner tree with the key equal to
    `3` and the value equal to `three`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，`map` `numbers`函数将整数映射到字符串。因此，当我们告诉地图将`3`的值存储为键，`three`的字符串作为值时，它会向其内部树添加一个新节点，其键等于`3`，值等于`three`。
- en: '`set` and `map` operations are logarithmic, which makes it a very efficient
    data structure in most cases. However, a more efficient data structure comes next.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`和`map`操作是对数的，这使得它在大多数情况下成为非常高效的数据结构。然而，更高效的数据结构接下来就要出现。'
- en: Hash tables
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希表
- en: 'The hash table is the fastest data structure out there. It is based on the
    simple idea of a vector indexing. Imagine a big vector that contains pointers
    to lists:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表是最快的数据结构。它基于一个简单的向量索引的想法。想象一个包含指向列表的指针的大向量：
- en: '[PRE64]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Access to vector elements takes constant time. That''s the main superpower
    of vectors. The hash table allows us to use any type as the key of the container.
    The basic idea of the hash table is to use a well-curated hash function that will
    generate a unique index for the input key. For example, when we use a string as
    a hash table key, the hash table uses a hash function to generate the hash as
    the index value for the underlying vector:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 访问向量元素需要常数时间。这是向量的主要优势。哈希表允许我们使用任何类型作为容器的键。哈希表的基本思想是使用精心策划的哈希函数，为输入键生成唯一的索引。例如，当我们使用字符串作为哈希表键时，哈希表使用哈希函数将哈希作为底层向量的索引值：
- en: '[PRE65]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Here''s how we can illustrate a hash table:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何说明哈希表：
- en: '![](img/5623724b-8217-4b70-8fac-b52b713d8435.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5623724b-8217-4b70-8fac-b52b713d8435.png)'
- en: Accessing a hash table takes constant time because it operates based on the
    vector. Though there could be different keys that will result in the same hash
    value, these collisions are fixed by using a list of values as the vector element
    (as shown in the preceding diagram).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 访问哈希表需要常数时间，因为它是基于向量操作的。虽然可能会有不同的键导致相同的哈希值，但这些冲突通过使用值列表作为向量元素来解决（如前图所示）。
- en: 'The STL supports a hash table named `std::unordered_map`:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: STL支持名为`std::unordered_map`的哈希表：
- en: '[PRE66]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: To generate the hash value for provided keys, the function  `std::unordered_map`
    uses the `std::hash()` function defined in the `<functional>` header. You can
    specify a custom implementation for the hash function. The third `template` parameter
    of the `std::unordered_map` is the hash function, which defaults to `std::hash`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为提供的键生成哈希值，函数`std::unordered_map`使用`<functional>`头文件中定义的`std::hash()`函数。您可以为哈希函数指定自定义实现。`std::unordered_map`的第三个`template`参数是哈希函数，默认为`std::hash`。
- en: Graphs
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图
- en: 'The balancing nature of the binary search tree is based upon many search index
    implementations. For example, database systems use a balanced tree called a B-tree
    for table indexing. The B-tree is not a *binary* tree, but it follows the same
    balancing logic, as shown in the following diagram:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树的平衡性是基于许多搜索索引实现的。例如，数据库系统使用称为B树的平衡树进行表索引。B树不是*二叉*树，但它遵循相同的平衡逻辑，如下图所示：
- en: '![](img/92b32da1-8667-447b-b087-481c79ac0dc4.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](img/92b32da1-8667-447b-b087-481c79ac0dc4.png)'
- en: 'Graphs, on the other hand, represent connected nodes with no proper order:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，图表示没有适当顺序的连接节点：
- en: '![](img/84949559-6f1a-41a6-8b34-746c60392218.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](img/84949559-6f1a-41a6-8b34-746c60392218.png)'
- en: 'Let''s suppose we are building a social network that will eventually beat Facebook
    off the market. The users in the social network can follow each other, which can
    be represented as a graph. For example, if A follows B, B follows C, and C both
    follows B back and follows A at the same time, then we can represent the relationships
    as the following graph:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在构建一个最终将击败Facebook的社交网络。社交网络中的用户可以互相关注，这可以表示为图。例如，如果A关注B，B关注C，C既关注B又同时关注A，那么我们可以将关系表示为以下图：
- en: '![](img/afd3b4ab-05ed-448a-8612-d596cce84d88.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![](img/afd3b4ab-05ed-448a-8612-d596cce84d88.png)'
- en: A node is called a **vertex** in the graph. The link between two nodes is called
    an **edge**. There isn't actually a fixed graph representation, so we should choose
    from several. Let's think of our social network – how would we represent the information
    that user A follows user B?
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，一个节点被称为**顶点**。两个节点之间的链接被称为**边**。实际上并没有固定的图表示，所以我们应该从几种选择中进行选择。让我们想想我们的社交网络
    - 我们如何表示用户A关注用户B的信息？
- en: 'One of the best options here is using a hash table. We can map each user to
    all of the users they follow:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最好的选择之一是使用哈希表。我们可以将每个用户映射到他们关注的所有用户：
- en: '![](img/ff9a742f-9d83-4b1d-b655-77d3f57fe938.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff9a742f-9d83-4b1d-b655-77d3f57fe938.png)'
- en: 'The graph implementation becomes a hybrid container:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图的实现变成了混合容器：
- en: '[PRE67]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: To make an STL-compatible container, let's add an iterator for the graph. Though
    iterating a graph is not a good idea, adding an iterator is not a bad idea.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其成为STL兼容的容器，让我们为图添加一个迭代器。虽然迭代图不是一个好主意，但添加迭代器并不是一个坏主意。
- en: Strings
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: 'Strings are similar to vectors: they store characters, they expose iterators,
    and they are containers. However, they are somewhat different because they specifically
    express one kind of data: strings. The following diagram depicts the string **hello,
    C++** as an array of characters ending with a special **\0** character:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串类似于向量：它们存储字符，公开迭代器，并且它们是容器。但是，它们有些不同，因为它们专门表示一种数据：字符串。下图描述了字符串**hello, C++**作为以特殊**\0**字符结尾的字符数组：
- en: '![](img/c99154de-7f04-4bfe-8ae5-b8ba7ed23ecb.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c99154de-7f04-4bfe-8ae5-b8ba7ed23ecb.png)'
- en: The special **\0** character (also known as the null character) serves as a
    string termination. The compiler reads characters one after the other until it
    encounters the null character.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊的**\0**字符（也称为空字符）用作字符串终止符。编译器会依次读取字符，直到遇到空字符为止。
- en: 'A string is implemented the same way we implemented a vector at the beginning
    of the chapter:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的实现方式与我们在本章开头实现向量的方式相同：
- en: '[PRE68]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: C++ has its powerful `std::string` class, which provides a bunch of functions
    to work with. Besides `std::string` member functions, algorithms defined in `<algorithm>`
    are also applicable to strings.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: C++有其强大的`std::string`类，提供了一堆用于处理的函数。除了`std::string`成员函数外，`<algorithm>`中定义的算法也适用于字符串。
- en: Summary
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Data structures and algorithms are crucial in developing efficient software.
    By understanding and leveraging the data structures discussed in this chapter,
    you will have the full power of C++20 to make your programs run faster. It's not
    a secret that a programmer with strong problem-solving skills is more desired
    in the market. Problem-solving skills are gained first of all by deeply understanding
    the fundamental algorithms and data structures. As you've seen already in this
    chapter, leveraging a binary search algorithm in searching tasks makes the code
    run much faster compared to its sequential alternative. Efficient software saves
    time and provides a better user experience, which eventually makes your software
    an outstanding alternative to existing ones.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构和算法在开发高效软件方面至关重要。通过理解和利用本章讨论的数据结构，您将充分利用C++20的功能，使程序运行更快。程序员具有强大的问题解决能力在市场上更受欢迎，这并不是秘密。首先要通过深入理解基本算法和数据结构来获得问题解决能力。正如您在本章中已经看到的，使用二分搜索算法在搜索任务中使代码运行速度比顺序搜索快得多。高效的软件节省时间并提供更好的用户体验，最终使您的软件成为现有软件的杰出替代品。
- en: In this chapter, we have discussed fundamental data structures and their differences.
    We learned to use them based on problem analysis. For example, applying a linked
    list in problems requiring random lookups is considered time-consuming because
    of the complexity of the linked-list element access operations. In such scenarios,
    using a dynamically growing vector is more appropriate due to its constant-time
    element access. On the contrary, using a vector in problems requiring fast insertions
    at the front of the container is more expensive compared to, for example, the
    list.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了基本数据结构及其区别。我们学会了根据问题分析来使用它们。例如，在需要随机查找的问题中应用链表被认为是耗时的，因为链表元素访问操作的复杂性。在这种情况下，使用动态增长的向量更合适，因为它具有常数时间的元素访问。相反，在需要在容器的前面快速插入的问题中使用向量比如列表更昂贵。
- en: The chapter also introduced algorithms and ways to measure their efficiency.
    We compared several problems to apply better algorithms to solve them more efficiently.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还介绍了算法以及衡量它们效率的方法。我们比较了几个问题，以应用更好的算法更有效地解决它们。
- en: In the next chapter, we are going to discuss functional programming in C++.
    Having studied the essentials of the STL, we are now going to apply functional
    programming techniques on containers.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论C++中的函数式编程。在学习了STL的基本知识后，我们现在将在容器上应用函数式编程技术。
- en: Questions
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Describe the insertion of an element into a dynamically growing vector.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述将元素插入动态增长的向量。
- en: What's the difference between inserting an element at the front of a linked
    list and at the front of a vector?
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在链表的前面插入元素和在向量的前面插入元素有什么区别？
- en: Implement a hybrid data structure that will store its elements in both a vector
    and a list. For each operation, choose the underlying data structure with the
    fastest implementation of the operation.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个混合数据结构，它将元素存储在向量和列表中。对于每个操作，选择具有最快实现该操作的基础数据结构。
- en: How would a binary search tree look if we insert 100 elements in increasing
    order?
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们按顺序插入100个元素，二叉搜索树会是什么样子呢？
- en: What is the difference between the selection sort and insertion sort algorithms?
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择排序和插入排序算法有什么区别？
- en: Implement the sorting algorithm described in the chapter, known as the counting
    sort.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现本章描述的排序算法，即计数排序。
- en: Further reading
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information, refer to the following resources:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参考以下资源：
- en: '*Programming Pearls* by Jon Bentley, available from [https://www.amazon.com/Programming-Pearls-2nd-Jon-Bentley/dp/0201657880/](https://www.amazon.com/Programming-Pearls-2nd-Jon-Bentley/dp/0201657880/)'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Jon Bentley著的* *Programming Pearls* ，可从[https://www.amazon.com/Programming-Pearls-2nd-Jon-Bentley/dp/0201657880/](https://www.amazon.com/Programming-Pearls-2nd-Jon-Bentley/dp/0201657880/)获取。'
- en: '*Data Abstraction and Problem Solving Using C++: Walls and Mirrors* by Frank
    Carrano,and Timothy Henry, available from [https://www.amazon.com/Data-Abstraction-Problem-Solving-Mirrors/dp/0134463978/](https://www.amazon.com/Data-Abstraction-Problem-Solving-Mirrors/dp/0134463978/)'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Data Abstraction and Problem Solving Using C++: Walls and Mirrors* by Frank
    Carrano和Timothy Henry，可从[https://www.amazon.com/Data-Abstraction-Problem-Solving-Mirrors/dp/0134463978/](https://www.amazon.com/Data-Abstraction-Problem-Solving-Mirrors/dp/0134463978/)获取。'
- en: '*Introduction to Algorithms* by Cormen, Leiserson, Rivest, and Stein, available
    from [https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844/](https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844/)'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Cormen, Leiserson, Rivest, and Stein著的* *Introduction to Algorithms* ，可从[https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844/](https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844/)获取。'
- en: '*C++ Data Structures and Algorithms* by Wisnu Anggoro, available from [https://www.packtpub.com/application-development/c-data-structures-and-algorithms](https://www.packtpub.com/application-development/c-data-structures-and-algorithms)'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Wisnu Anggoro著的* *C++ Data Structures and Algorithms* ，可从[https://www.packtpub.com/application-development/c-data-structures-and-algorithms](https://www.packtpub.com/application-development/c-data-structures-and-algorithms)获取。'
