["```cpp\n$ sudo bash\n#\n```", "```cpp\n # cat /sys/power/state\n```", "```cpp\n # echo freeze > /sys/power/state\n```", "```cpp\n$ sudo bash\n```", "```cpp\n$ cat /sys/power/state\n```", "```cpp\n$ sudo bash\n#\n```", "```cpp\n# date '+%s' -d '+1 minute' > /sys/class/rtc/rtc0/wakealarm\n```", "```cpp\n# echo freeze > /sys/power/state\n```", "```cpp\ndate '+%s' -d '+1 minute' > /sys/class/rtc/rtc0/wakealarm\n```", "```cpp\n# echo freeze > /sys/power/state\n```", "```cpp\n$ sudo bash\n#\n```", "```cpp\n# for f in /sys/bus/usb/devices/*/power/control; do echo \"$f\"; cat $f; done\n```", "```cpp\n# echo auto > /sys/bus/usb/devices/1-1.2/power/control\n```", "```cpp\n# cat /sys/bus/usb/devices/1-1.2/power/autosuspend_delay_ms \n```", "```cpp\n# echo 5000 > /sys/bus/usb/devices/1-1.2/power/autosuspend_delay_ms \n```", "```cpp\n# cat /sys/bus/usb/devices/1-1.2/power/runtime_status\n```", "```cpp\n# for f in /sys/bus/usb/devices/*/power/control; do echo \"$f\"; cat $f; done\n```", "```cpp\n# echo auto > /sys/bus/usb/devices/1-1.2/power/control\n```", "```cpp\n# cat /sys/bus/usb/devices/1-1.2/power/autosuspend_delay_ms \n```", "```cpp\n# echo 5000 > /sys/bus/usb/devices/1-1.2/power/autosuspend_delay_ms \n```", "```cpp\n# cat /sys/bus/usb/devices/1-1.2/power/runtime_status\n```", "```cpp\n$ sudo bash\n#\n```", "```cpp\n# cat /sys/devices/system/cpu/*/cpufreq/scaling_cur_freq\n```", "```cpp\n# cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_frequencies\n```", "```cpp\n# cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors\n```", "```cpp\n# cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor \n```", "```cpp\n# echo 1200000 > /sys/devices/system/cpu/cpu0/cpufreq/scaling_min_freq\n```", "```cpp\n# cat /sys/devices/system/cpu/*/cpufreq/scaling_cur_freq\n```", "```cpp\n# echo 600000 > /sys/devices/system/cpu/cpu0/cpufreq/scaling_min_fre\n```", "```cpp\n# echo performance > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor\n# cat /sys/devices/system/cpu/*/cpufreq/scaling_cur_freq\n```", "```cpp\n# echo powersave > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor\n# cat /sys/devices/system/cpu/*/cpufreq/scaling_cur_freq\n```", "```cpp\n# cat /sys/devices/system/cpu/*/cpufreq/scaling_cur_freq\n```", "```cpp\n# cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_frequencies\n```", "```cpp\n# echo 1200000 > /sys/devices/system/cpu/cpu0/cpufreq/scaling_min_freq\n```", "```cpp\necho performance > /sys/devices/system/cpu/cpu0/cpufreq/scaling_g;overnor\n```", "```cpp\n#include <iostream>\n#include <functional>\n\n#include <libudev.h>\n#include <poll.h>\n\nnamespace usb {\n```", "```cpp\nclass Device {\n  struct udev_device *dev{0};\n\n  public:\n    Device(struct udev_device* dev) : dev(dev) {\n    }\n\n    Device(const Device& other) : dev(other.dev) {\n      udev_device_ref(dev);\n    }\n\n    ~Device() {\n        udev_device_unref(dev);\n    }\n\n    std::string action() const { \n        return udev_device_get_action(dev);\n     }\n\n    std::string attr(const char* name) const {\n      const char* val = udev_device_get_sysattr_value(dev,\n             name);\n      return val ? val : \"\";\n    }\n};\n```", "```cpp\nclass Monitor {\n  struct udev_monitor *mon;\n\n  public:\n    Monitor() {\n      struct udev* udev = udev_new();\n      mon = udev_monitor_new_from_netlink(udev, \"udev\");\n      udev_monitor_filter_add_match_subsystem_devtype(\n           mon, \"usb\", NULL);\n      udev_monitor_enable_receiving(mon);\n    }\n\n    Monitor(const Monitor& other) = delete;\n\n    ~Monitor() {\n      udev_monitor_unref(mon);\n    }\n\n    Device wait(std::function<bool(const Device&)> process) {\n      struct pollfd fds[1];\n      fds[0].events = POLLIN;\n      fds[0].fd = udev_monitor_get_fd(mon);\n\n      while (true) {\n          int ret = poll(fds, 1, -1);\n          if (ret < 0) {\n            throw std::system_error(errno, \n                std::system_category(),\n                \"Poll failed\");\n          }\n          if (ret) {\n            Device d(udev_monitor_receive_device(mon));\n            if (process(d)) {\n              return d;\n            };\n          }\n      }\n    }\n};\n};\n```", "```cpp\nint main() {\n  usb::Monitor mon;\n  usb::Device d = mon.wait([](auto& d) {\n    auto id = d.attr(\"idVendor\") + \":\" + \n              d.attr(\"idProduct\");\n    auto produce = d.attr(\"product\");\n    std::cout << \"Check [\" << id << \"] action: \" \n              << d.action() << std::endl;\n    return d.action() == \"bind\" && \n           id == \"8086:0808\";\n  });\n  std::cout << d.attr(\"product\")\n            << \" connected, uses up to \"\n            << d.attr(\"bMaxPower\") << std::endl;\n  return 0;\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\nproject(udev)\nadd_executable(usb udev.cpp)\ntarget_link_libraries(usb udev)\n```", "```cpp\n$cd ~/udev; cmake. && make\n```", "```cpp\nnamespace usb {\n```", "```cpp\n    ~Device() {\n        udev_device_unref(dev);\n    }\n    Device(const Device& other) : dev(other.dev) {\n      udev_device_ref(dev);\n    }\n```", "```cpp\n    std::string action() const { \n        return udev_device_get_action(dev);\n     }\n```", "```cpp\n    std::string attr(const char* name) const {\n      const char* val = udev_device_get_sysattr_value(dev,\n             name);\n      return val ? val : \"\";\n    }\n```", "```cpp\n    Monitor(const Monitor& other) = delete;\n```", "```cpp\n      struct udev* udev = udev_new();\n```", "```cpp\n      udev_monitor_filter_add_match_subsystem_devtype(\n           mon, \"usb\", NULL);\n      udev_monitor_enable_receiving(mon);\n```", "```cpp\nDevice wait(std::function<bool(const Device&)> process) {\n```", "```cpp\n      fds[0].fd = udev_monitor_get_fd(mon);\n```", "```cpp\nint ret = poll(fds, 1, -1);\n```", "```cpp\n          if (ret < 0) {\n            throw std::system_error(errno, \n                std::system_category(),\n                \"Poll failed\");\n          }\n```", "```cpp\n            Device d(udev_monitor_receive_device(mon));\n            if (process(d)) {\n              return d;\n            };\n```", "```cpp\nusb::Device d = mon.wait([](auto& d) {\n```", "```cpp\n    std::cout << \"Check [\" << id << \"] action: \" \n              << d.action() << std::endl;\n```", "```cpp\n    return d.action() == \"bind\" && \n           id == \"8086:0808\";\n```", "```cpp\n  std::cout << d.attr(\"product\")\n            << \" connected, uses up to \"\n            << d.attr(\"bMaxPower\") << std::endl;\n```", "```cpp\n$ sudo bash\n#\n```", "```cpp\n # apt-get install powertop\n```", "```cpp\n # powertop\n```", "```cpp\n# apt-get install powertop\n```"]