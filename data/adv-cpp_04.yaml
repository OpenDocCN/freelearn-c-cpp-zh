- en: 3\. No Leaks Allowed - Exceptions and Resources
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. 不允许泄漏-异常和资源
- en: Learning Objectives
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够：
- en: Develop classes to manage resources
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发管理资源的类
- en: Develop exception-robust code so that the resources do not leak through RAII
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发异常健壮的代码，以防止资源通过RAII泄漏
- en: Implement classes that can transfer resource ownership through move semantics
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现可以通过移动语义传递资源所有权的类
- en: Implement classes that control implicit conversion
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现控制隐式转换的类
- en: In this chapter, you will learn how to use a class to manage resources, protect
    against leaks, and prevent copying a large amount of data.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用类来管理资源，防止泄漏，并防止复制大量数据。
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: In *Chapter 2A*, *No Ducks Allowed – Types, and Deduction*, we briefly touched
    on some concepts, such as smart pointers and move semantics. In this chapter,
    we'll be exploring them further. It turns out that these topics are very closely
    related to resource management and writing robust code (code that will run often
    and for long periods without problems).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第2A章*中，*不允许鸭子-类型和推断*，我们简要涉及了一些概念，如智能指针和移动语义。在本章中，我们将进一步探讨它们。事实证明，这些主题与资源管理和编写健壮的代码（经常运行并长时间运行而没有问题的代码）非常密切相关。
- en: To understand what happens, we are going to explore where variables get placed
    in memory, as well as when and what happens when they go out of scope.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解发生了什么，我们将探讨变量在内存中的放置位置，以及当它们超出范围时发生了什么。
- en: We will look at what the compiler generates as assembler code for what we enter,
    and we will explore how all of this is affected when an exception occurs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看编译器为我们输入的汇编代码生成了什么，并探讨当异常发生时所有这些都受到了什么影响。
- en: Variable Scope and Lifetime
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量范围和生命周期
- en: 'In *Chapter 2B*, *No Ducks Allowed – Templates, and Deduction*, we discussed
    variable scope and lifetimes. Let''s quickly go through their different types:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第2B章*中，*不允许鸭子-模板和推断*，我们讨论了变量范围和生命周期。让我们快速浏览它们的不同类型：
- en: '**Scope**:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围**：'
- en: '`{}`).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{}`）。'
- en: '**Global / file scope**: This applies to variables declared outside a normal
    function or a class, and also to the normal functions.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局/文件范围**：这适用于在普通函数或类之外声明的变量，也适用于普通函数。'
- en: '**Lifetime**:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**寿命**：'
- en: '**Automatic lifetime**: Here, the local variables are created when they are
    declared, and destroyed when they exit the scope that they are in. These are managed
    by the stack.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动寿命**：在这里，局部变量在声明时创建，并在退出其所在范围时销毁。这些由堆栈管理。'
- en: '**Permanent lifetime**: Here, the global and static local variables have a
    permanent lifetime.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**永久寿命**：在这里，全局和静态局部变量具有永久寿命。'
- en: '`new` and `delete operators`). These variables have their memory allocated
    from the heap.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new`和`delete`操作符）。这些变量的内存是从堆中分配的。'
- en: 'We are going to use the following program to get a clarity on the behavior
    of `local variables` – those that have an `automatic lifetime` and those that
    have a `dynamic lifetime`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下程序来澄清`局部变量`的行为-具有`自动寿命`和具有`动态寿命`的变量：
- en: '![](img/C14583_03_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14583_03_01.jpg)'
- en: 'Figure 3.1: Test program for variable scope and lifetime'
  id: totrans-23
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.1：变量范围和生命周期的测试程序
- en: 'When we run the preceding program, the following output is generated:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行上述程序时，将生成以下输出：
- en: '![Figure 3.2: Output from Lifetime test program](img/C14583_03_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2：生命周期测试程序的输出](img/C14583_03_02.jpg)'
- en: 'Figure 3.2: Output from Lifetime test program'
  id: totrans-26
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.2：生命周期测试程序的输出
- en: The hexadecimal numbers (`0xNNNNNNNN`) in the preceding output are the addresses
    of the Int objects that are being constructed or destructed. Our program starts
    by entering at `line 46` with the `main()` function. At this point, the program
    has already done a lot of initialization so that everything is readily available
    for us to use. The figures below that refer to two stacks – **PC Stack** and **Data
    Stack**.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述输出中的十六进制数字（`0xNNNNNNNN`）是正在构造或销毁的Int对象的地址。我们的程序从`第46行`进入`main()`函数开始。此时，程序已经进行了大量初始化，以便我们随时可以使用一切。下面的图表指的是两个堆栈-**PC堆栈**和**数据堆栈**。
- en: 'These are the abstract concepts that help us explain what happens behind the
    scenes. The `PC Stack` (`Program Counter Stack`) is used to remember the values
    of the program counter (a register pointing to the next instruction that needs
    to be run), while the `Data Stack holds` the values or addresses that we are manipulating.
    Although these are two separate stacks, on the real CPU, it will most likely be
    implemented as one stack. Let''s look at the following tables wherein we''ve used
    the abbreviation `OLn` to refer to a line number from the output of the preceding
    program:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是帮助我们解释幕后发生的事情的抽象概念。`PC堆栈`（`程序计数器堆栈`）用于记住程序计数器的值（指向需要运行的下一条指令的寄存器），而`数据堆栈`保存我们正在操作的值或地址。尽管这是两个单独的堆栈，在实际CPU上，它很可能会被实现为一个堆栈。让我们看看以下表格，其中我们使用缩写`OLn`来引用上述程序输出的行号：
- en: '![Figure 3.3: Detailed analysis of the test program’s execution (part 1)](img/C14583_03_03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3：测试程序执行的详细分析（第1部分）](img/C14583_03_03.jpg)'
- en: 'Figure 3.3: Detailed analysis of the test program''s execution (part 1)'
  id: totrans-30
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.3：测试程序执行的详细分析（第1部分）
- en: 'Below is the second part of the detailed analysis of the test program''s execution:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是测试程序执行详细分析的第二部分：
- en: '![Figure 3.4:  Detailed analysis of the test program’s execution (part 2)](img/C14583_03_04.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4：测试程序执行的详细分析（第2部分）](img/C14583_03_04.jpg)'
- en: 'Figure 3.4: Detailed analysis of the test program''s execution (part 2)'
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.4：测试程序执行的详细分析（第2部分）
- en: 'Below is the third part of the detailed analysis of the test program''s execution:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是测试程序执行详细分析的第三部分：
- en: '![Figure 3.5: Detailed analysis of the test program’s execution (part 3)](img/C14583_03_05.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5：测试程序执行的详细分析（第3部分）](img/C14583_03_05.jpg)'
- en: 'Figure 3.5: Detailed analysis of the test program''s execution (part 3)'
  id: totrans-36
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.5：测试程序执行的详细分析（第3部分）
- en: 'From this simple program, we learned some important facts:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个简单的程序中，我们学到了一些重要的事实：
- en: Copy constructors are called when we pass by value (as we did in this case).
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们按值传递时，会调用复制构造函数（就像在这种情况下所做的那样）。
- en: Returning a type causes only one constructor to be called (not two constructors
    – one to create the return object and one for the variable to store the returned
    data) – C++ calls this **copy elision** and it is now mandatory in the standard.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回类型只会调用一个构造函数（不是两个构造函数 - 一个用于创建返回对象，一个用于存储返回的数据） - C++将其称为**复制省略**，现在在标准中是强制性的。
- en: On termination of scope (the closing curly bracket '`}`'), any variable that
    goes out of scope has its destructor called. If that is true, then why was the
    address `0x6000004d0` not shown with a destructor call (`~Int()`)? This leads
    us to the next fact.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在作用域终止时（闭合大括号'`}`'），任何超出作用域的变量都会调用其析构函数。如果这是真的，那么为什么地址`0x6000004d0`没有显示析构函数调用（`~Int()`）？这引出了下一个事实。
- en: The destructor for a `calculate()` method, we leaked some memory.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`calculate()`方法的析构函数中，我们泄漏了一些内存。
- en: The last two facts are important in understanding and solving the problem of
    resource leaks when we forget to free the resources. We will look at resource
    management after we deal with exceptions in C++.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 了解和解决资源泄漏问题的最后两个事实是重要的。在我们处理C++中的异常之后，我们将研究资源管理。
- en: Exceptions in C++
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++中的异常
- en: We have seen how C++ manages the local scope variables with automatic and dynamic
    lifetime. It calls the destructors of variables with an automatic lifetime when
    they go out of scope. We've also seen how raw pointers get destroyed when they
    go out of scope. As it does not clean up the dynamic lifetime variables, we lose
    them. This is a part of the story that builds us towards **Resource Acquisition
    Is Initialization** (**RAII**) later. But, first, we need to understand how exceptions
    change the flow of the program.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了C++如何管理具有自动和动态生命周期的局部作用域变量。当变量超出作用域时，它调用具有自动生命周期的变量的析构函数。我们还看到了原始指针在超出作用域时被销毁。由于它不清理动态生命周期变量，我们会失去它们。这是我们后来构建**资源获取即初始化**（**RAII**）的故事的一部分。但首先，我们需要了解异常如何改变程序的流程。
- en: The Need for Exceptions
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常的必要性
- en: 'In *Chapter 2A*, *No Ducks Allowed – Types and Deduction*, we were introduced
    to enumerations as a way of dealing with magic numbers for the `check_file()`
    function:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第2A章*，*不允许鸭子 - 类型和推断*中，我们介绍了枚举作为处理`check_file()`函数的魔术数字的一种方式：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding function uses a technique known as **status** or **error codes**
    to report the outcome of the operation. This is the approach that's used for C-style
    programming, wherein errors related to the **POSIX API** and **Windows API** are
    handled.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数使用了一种称为**状态**或**错误代码**的技术来报告操作的结果。这是C风格编程中使用的方法，其中与**POSIX API**和**Windows
    API**相关的错误被处理。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '`POSIX` stands for `Potable Operating System Interface`. It is an IEEE standard
    for software compatibility between variants of Unix and other operating systems.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`POSIX`代表`可移植操作系统接口`。这是Unix变体和其他操作系统之间软件兼容性的IEEE标准。'
- en: This means that, the caller of the method must check the return value and take
    the appropriate action for each error type. This approach works well when you
    can reason about the types of errors that the code will generate. This is not
    always true. For example, there may be a problem with the data that is fed to
    the program. This leads to an abnormal state in the program that cannot be handled.
    The part of the code that has the logic to deal with the error is removed from
    the section of code that detects the problem.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，方法的调用者必须检查返回值，并针对每种错误类型采取适当的操作。当您可以推断代码将生成的错误类型时，这种方法效果很好。但并非总是如此。例如，可能存在输入到程序的数据存在问题。这会导致程序中的异常状态无法处理。具有处理错误逻辑的代码部分被从检测问题的代码部分中移除。
- en: While it is possible to write code that deals with such a problem, it increases
    the complications of dealing with all error conditions, thereby making the program
    hard to read, hard to reason about what the function is supposed to do, and thus
    very hard to maintain.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可能编写处理此类问题的代码，但这会增加处理所有错误条件的复杂性，从而使程序难以阅读，难以推断函数应该执行的操作，并因此难以维护。
- en: 'For error handling, exceptions provide the following benefits over error codes:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于错误处理，异常比错误代码提供以下优点：
- en: Error codes can be ignored – exceptions force the error to be dealt with (or
    the program terminates).
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误代码可以被忽略 - 异常强制处理错误（或程序终止）。
- en: Exceptions can flow up the stack to the best method to respond to the error.
    Error codes would require propagation out of each intermediate method.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常可以沿着堆栈流向最佳方法来响应错误。错误代码需要传播到每个中间方法之外。
- en: Exceptions separate the handling of errors from the main program flow, leading
    to easy readability and maintainability of the software.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常将错误处理与主程序流程分离，使软件易于阅读和维护。
- en: Exceptions separate the code that detects the error, from the code that handles
    the error.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常将检测错误的代码与处理错误的代码分离。
- en: Provided you follow the best practices and use exceptions for abnormal conditions,
    there is no (time) overhead in using exceptions. This is because a well-implemented
    compiler will deliver the C++ mantra – you do not pay for what you don't use.
    It may cost some memory and your code may be a little larger, but the running
    time should be unaffected.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 只要遵循最佳实践并将异常用于异常条件，使用异常不会有（时间）开销。这是因为一个实现良好的编译器将提供C++的口号 - 你不为你不使用的东西付费。它可能会消耗一些内存，你的代码可能会变得稍微庞大，但运行时间不应受影响。
- en: 'C++ uses exceptions to deal with runtime anomalies. By using exceptions, we
    can detect an error, throw an exception, and the error propagates back to the
    location where it can be handled. Let''s modify the previous program to introduce
    the `divide()` function and change the calculate() function to call it. We''ll
    also add logging to the `main()` function so that we can explore how the exceptions
    behave:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: C++使用异常来处理运行时异常。通过使用异常，我们可以检测错误，抛出异常，并将错误传播回可以处理它的位置。让我们修改前面的程序，引入`divide()`函数并更改`calculate()`函数以调用它。我们还将在`main()`函数中添加日志记录，以便探索异常的行为方式：
- en: '![Figure 3.6: Modified test program for investigating exceptions](img/C14583_03_06.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6：用于调查异常的修改测试程序](img/C14583_03_06.jpg)'
- en: 'Figure 3.6: Modified test program for investigating exceptions'
  id: totrans-61
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.6：用于调查异常的修改测试程序
- en: 'When we compile and run the preceding program, the following output is generated:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编译并运行前面的程序时，将生成以下输出：
- en: '![Figure 3.7: Output from the test program](img/C14583_03_07.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图3.7：测试程序的输出](img/C14583_03_07.jpg)'
- en: 'Figure 3.7: Output from the test program'
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.7：测试程序的输出
- en: 'In the preceding code, you can see that the annotations are added to the right.
    Now, we remove the comment from the `result2` line in the program, recompile the
    program, and rerun it. The new output that''s generated is shown as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，您可以看到注释已添加到右侧。现在，我们从程序中的`result2`行中删除注释，重新编译程序并重新运行。生成的新输出如下所示：
- en: '![Figure 3.8: Output from the test program – result2](img/C14583_03_08.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8：测试程序的输出 - result2](img/C14583_03_08.jpg)'
- en: 'Figure 3.8: Output from the test program – result2'
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.8：测试程序的输出 - result2
- en: By comparing the outputs, we can see that the first eight lines of each are
    the same. The next two lines of the preceding output are added because the `divide()`
    function is called twice. The last line indicates that an exception was thrown
    and that the program was terminated.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过比较输出，我们可以看到每个输出的前八行是相同的。前面输出的接下来两行是因为`divide()`函数被调用了两次。最后一行指示抛出了异常并且程序被终止。
- en: The second call to the `divide()` function attempted to divide by zero – an
    abnormal operation. This leads to an exception. If an integer is divided by zero,
    then it leads to a floating-point exception. This has to do with the way exceptions
    are generated in a `POSIX` system – it uses something called a signal (we won't
    go into the details of signals here). When an integer is divided by zero, the
    `POSIX` system maps it to the signal called `floating-point error` but is now
    the more generic `arithmetic error`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次调用`divide()`函数尝试除以零 - 这是一种异常操作。这导致异常。如果整数被零除，那么会导致浮点异常。这与在`POSIX`系统中生成异常的方式有关
    - 它使用了称为信号的东西（我们不会在这里详细介绍信号的细节）。当整数被零除时，`POSIX`系统将其映射到称为`浮点错误`的信号，但现在是更通用的`算术错误`。
- en: '**Note**'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**注意**'
- en: According to the C++ standard, if a zero appears as the divisor for either the
    '`/`' operator (divide) or the '`%`' operator (modulus), then the behavior is
    undefined. Most systems will choose to throw an exception.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 根据C++标准，如果零出现为除数，无论是'/'运算符（除法）还是'%'运算符（取模），行为都是未定义的。大多数系统会选择抛出异常。
- en: 'So, we have learned one important fact from the preceding explanation: that
    an unhandled exception will terminate the program (internally, it calls `std::terminate()`).
    We will fix the `undefined behavior`, catch the exception, and see the changes
    in the output.To fix the `undefined behavior`, we need to add `#include <stdexcept>`
    at the top of the file and modify the `divide()` function:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们从前面的解释中学到了一个重要的事实：未处理的异常将终止程序（在内部调用`std::terminate()`）。我们将修复`未定义行为`，捕获异常，并查看输出中的变化。为了修复`未定义行为`，我们需要在文件顶部添加`#include
    <stdexcept>`并修改`divide()`函数：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When we re-compile and run the program, we get the following output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们重新编译并运行程序时，我们得到以下输出：
- en: '![Figure 3.9: Output when we throw an exception](img/C14583_03_09.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图3.9：当我们抛出异常时的输出](img/C14583_03_09.jpg)'
- en: 'Figure 3.9: Output when we throw an exception'
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.9：当我们抛出异常时的输出
- en: As we can see from the preceding output, not much has changed. It's just that
    we don't get a `floating-point exception` (core dumped) – the program still terminates
    but doesn't dump the core. We then added a `try/catch` block into the `main()`
    function to ensure that the exception was no longer unhandled.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中可以看到，没有太多变化。只是我们不再得到`浮点异常`（核心转储）- 程序仍然终止但不会转储核心。然后我们在`main()`函数中添加了一个`try/catch`块，以确保异常不再是未处理的。
- en: '![Figure 3.10: Catching the Exception ](img/C14583_03_10.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图3.10：捕获异常](img/C14583_03_10.jpg)'
- en: 'Figure 3.10: Catching the Exception'
  id: totrans-79
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.10：捕获异常
- en: 'Recompile the program and run it to get the following output:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 重新编译程序并运行以获得以下输出：
- en: '![Figure 3.11: Output from the program that catches the exception](img/C14583_03_11.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11：捕获异常的程序输出](img/C14583_03_11.jpg)'
- en: 'Figure 3.11: Output from the program that catches the exception'
  id: totrans-82
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.11：捕获异常的程序输出
- en: In the preceding output, an exception is thrown on the second line that is annotated
    as "**copy a for call to divide**". Everything that is output after that is a
    result of the exception being handled.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，异常在第二行抛出，注释为“**复制a以调用divide**”。之后的所有输出都是异常处理的结果。
- en: Our code has transferred program control to the `catch()` statement in the `main()`
    function and has executed the destructors for all the variables that had been
    constructed on the stack (from the time the call was made in the `try` clause).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码已将程序控制转移到`main()`函数中的`catch()`语句，并执行了在`try`子句中进行调用时在堆栈上构造的所有变量的析构函数。
- en: Stack Unwinding
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆栈展开
- en: The process of destroying all local function variables, as guaranteed by the
    C++ language is known as **Stack Unwinding**. As the stack unwinds in the presence
    of an exception, C++ uses its well-defined rules to destroy all the objects in
    the scope.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: C++语言所保证的销毁所有本地函数变量的过程被称为**堆栈展开**。在异常出现时，堆栈展开时，C++使用其明确定义的规则来销毁作用域中的所有对象。
- en: When an exception occurs, the function call stack starts searching linearly
    from the current function back to the function that called it, to the one that
    called that, and so on, until an exception handler (expressed by a `catch` block)
    that matches the exception is found.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当异常发生时，函数调用堆栈从当前函数开始线性搜索，直到找到与异常匹配的异常处理程序（由`catch`块表示）。
- en: If an exception handler is found, then the stack unwinding occurs, destroying
    all the local variables for all the functions in the stack. The objects are destroyed
    in the reverse order that they were created. If no handler is found to deal with
    the thrown exception, then the program terminates (usually without warning the
    user).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到异常处理程序，则进行堆栈展开，销毁堆栈中所有函数的本地变量。对象按创建顺序的相反顺序销毁。如果找不到处理抛出异常的处理程序，则程序将终止（通常不会警告用户）。
- en: 'Exercise 1: Implementing exceptions in Fraction and Stack'
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习1：在Fraction和Stack中实现异常
- en: 'In this exercise, we will return to two classes that we worked on in *Chapter
    2A*, *No Ducks Allowed – Types and Deduction* and *Chapter 2B*, *No Ducks Allowed
    – Templates and Deduction* – `Fraction` and `Stack`, both of which can experience
    runtime anomalies. We are going to update their code so that they can raise exceptions
    whenever any problem is detected. Follow these steps to implement this exercise:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将回到*第2A章*和*第2B章*中我们所做的两个类，*不允许鸭子 - 类型和推断*和*不允许鸭子 - 模板和推断* - `Fraction`和`Stack`，它们都可能出现运行时异常。我们将更新它们的代码，以便在检测到任何问题时都能引发异常。按照以下步骤执行此练习：
- en: Open Eclipse and create a new project named **Lesson3** using the files found
    in the **Lesson3** examples folder.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Eclipse，并使用**Lesson3**示例文件夹中的文件创建一个名为**Lesson3**的新项目。
- en: As this is a **CMake-based project**, change the current builder to be **CMake
    Build (portable)**.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这是一个**基于CMake的项目**，因此将当前构建器更改为**CMake Build (portable)**。
- en: Go to the **Project** | **Build All** menu to build all the exercises. By default,
    the console at the bottom of the screen will display the **CMake Console [Lesson3]**.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**项目** | **构建所有**菜单以构建所有练习。默认情况下，屏幕底部的控制台将显示**CMake Console [Lesson3]**。
- en: Configure a new **Launch Configuration**, **L3Exercise1** to run with the name
    **Exercise1**.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置一个新的**启动配置**，**L3Exercise1**，以运行名称为**Exercise1**的项目。
- en: Also, configure a new C/C++ Unit Run Configuration, **L3Ex1Tests**, to run **L3Ex1tests**.
    Set the **Google Tests Runner**.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要配置一个新的C/C++单元运行配置，**L3Ex1Tests**，以运行**L3Ex1tests**。设置**Google Tests Runner**。
- en: 'Click on the **Run** option for the existing **18** tests to run and pass.![Figure
    3.12: Existing tests all pass (Runs: 18)](img/C14583_03_12.jpg)'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**运行**选项，对现有的**18**个测试进行运行和通过。![图3.12：现有测试全部通过（运行次数：18）](img/C14583_03_12.jpg)
- en: 'Figure 3.12: Existing tests all pass (Runs: 18)'
  id: totrans-97
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.12：现有测试全部通过（运行次数：18）
- en: 'Open **Fraction.hpp** in the editor and change the line at the top of the file
    to read like so:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开**Fraction.hpp**，并更改文件顶部的行，使其读起来像这样：
- en: '[PRE2]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Click on the `Fraction` with a zero denominator. The test expects that an exception
    has been thrown:![Figure 3.13: New failing test ThrowsDomainErrorForZeroDenominator](img/C14583_03_13.jpg)'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`Fraction`，其中分母为零。测试期望抛出异常：![图3.13：新的失败测试ThrowsDomainErrorForZeroDenominator](img/C14583_03_13.jpg)
- en: 'Figure 3.13: New failing test ThrowsDomainErrorForZeroDenominator'
  id: totrans-101
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.13：新的失败测试ThrowsDomainErrorForZeroDenominator
- en: 'Click on the failing test name – the `Expected … throws an exception of type
    std::domain_error`" and the next line states "`Actual: it throws nothing`".'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击失败的测试名称 - “预期…抛出std::domain_error类型的异常”，下一行显示“实际：它没有抛出任何异常”。
- en: 'Double-click on the message and it will take you to the following test:![Figure
    3.14: The failing test](img/C14583_03_14.jpg)'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击消息，它将带您到以下测试：![图3.14：失败的测试](img/C14583_03_14.jpg)
- en: 'Figure 3.14: The failing test'
  id: totrans-104
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.14：失败的测试
- en: 'The `ASSERT_THROW()` macro requires two arguments. Since the `Fraction initializer`
    has a comma in it, it is necessary to wrap the whole first argument in an extra
    set of parentheses. The second argument is expected to get a `std::domain_error`
    from this constructor. The internal `try/catch` structure is present to confirm
    that the expected string is captured inside the exception object. If we do not
    want to check this, then we could simply write the test like so:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`ASSERT_THROW()`宏需要两个参数。由于`Fraction初始化器`中有一个逗号，因此需要在第一个参数的外面再加一组括号。第二个参数预期从这个构造函数中获得一个`std::domain_error`。内部的`try/catch`结构用于确认预期的字符串是否被捕获在异常对象中。如果我们不想检查这一点，那么我们可以简单地这样编写测试：'
- en: '[PRE3]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Open the file **Fraction.cpp** in the editor. Insert the following line near
    the top of the file:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开文件**Fraction.cpp**。在文件顶部附近插入以下行：
- en: '[PRE4]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Modify the constructor to throw an exception if it''s been created with a zero
    denominator:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改构造函数，如果使用零分母创建，则抛出异常：
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Click on the **Run** button to re-run the tests. **19** tests now pass.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**运行**按钮重新运行测试。现在有**19**个测试通过。
- en: 'Open **Fraction.hpp** in the editor and change the line near the top of the
    file to read like so:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开**Fraction.hpp**，并更改文件顶部附近的行，使其读起来像这样：
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Click on the `ThrowsRunTimeErrorForZeroDenominator` fails.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`ThrowsRunTimeErrorForZeroDenominator`失败。
- en: 'Click on the failing test name – the `Expected… throws an exception of type
    std::runtime_error`" and the next line states "`Actual: it throws a different
    type`".'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击失败的测试名称 - “预期…抛出std::runtime_error类型的异常”，下一行显示“实际：它抛出了不同类型的异常”。
- en: 'Double-click on the message again to open the failing test:![Figure 3.15: Another
    failing test](img/C14583_03_15.jpg)'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次双击消息以打开失败的测试：![图3.15：另一个失败的测试](img/C14583_03_15.jpg)
- en: 'Figure 3.15: Another failing test'
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.15：另一个失败的测试
- en: This test is verifying that the division assignment operator will throw an exception
    for a divide by zero.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试验证除法赋值运算符对零进行除法时会抛出异常。
- en: Open `operator/=()` function. You'll see that, inside this function, it actually
    uses the constructor for `std::domain_error`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`operator/=()`函数。您会看到，在这个函数内部，它实际上使用了`std::domain_error`的构造函数。
- en: Now modify `operator/=()` to detect this problem before the constructor is called
    so that it throws a `std::runtime_error` with the expected message.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在修改`operator/=()`以在调用构造函数之前检测此问题，以便抛出带有预期消息的`std::runtime_error`。
- en: 'Modify **Fraction.cpp** by adding a domain error that will detect the division
    operator:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加一个将检测除法运算符的域错误来修改**Fraction.cpp**：
- en: '[PRE7]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Click on the **Run** button to re-run the tests. All **20** tests pass.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Run**按钮重新运行测试。所有**20**个测试通过。
- en: 'Open **Stack.hpp** in the editor and change the line near the top of the file
    to read like so:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开**Stack.hpp**并更改文件顶部附近的行，使其读起来像这样：
- en: '[PRE8]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Click on the `FractionTest` to collapse the lists of tests and show the `StackTest`:![Figure
    3.16: pop Stack test fails](img/C14583_03_16.jpg)'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`FractionTest`以折叠测试列表并显示`StackTest`：![图3.16：pop Stack测试失败](img/C14583_03_16.jpg)
- en: 'Figure 3.16: pop Stack test fails'
  id: totrans-127
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.16：pop Stack测试失败
- en: 'Use the `#include <stdexcept>` to the top of the file and then update the `pop()`
    function so that it looks like this:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件顶部使用`#include <stdexcept>`，然后更新`pop()`函数，使其如下所示：
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Click on the **Run** button to re-run the tests. **21** tests now pass.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Run**按钮重新运行测试。现在**21**个测试通过了。
- en: 'Open **Stack.hpp** in the editor and change the line at the top of the file
    to read like so:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开**Stack.hpp**并更改文件顶部的行，使其读起来像这样：
- en: '[PRE10]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Click on the `TopEmptyStackThrowsUnderFlowException`, fails.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`TopEmptyStackThrowsUnderFlowException`，失败。
- en: 'Use the `top()` method so that it looks as follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`top()`方法，使其如下所示：
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Click on the **Run** button to re-run the tests. **22** tests pass.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Run**按钮重新运行测试。**22**个测试通过。
- en: 'Open **Stack.hpp** in the editor and change the line at the top of the file
    to read like so:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开**Stack.hpp**并更改文件顶部的行，使其读起来像这样：
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Click on the `TopEmptyConstStackThrowsUnderFlowException`, fails.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`TopEmptyConstStackThrowsUnderFlowException`，失败。
- en: 'Use the `top()` method so that it looks as follows:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`top()`方法，使其如下所示：
- en: '[PRE13]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Click on the **Run** button to re-run the tests. All **23** tests now pass.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Run**按钮重新运行测试。现在所有**23**个测试都通过了。
- en: In this exercise, we have added run time checking for pre-conditions that are
    part of the normal operation of using our `Fraction` and `Stack` classes. This
    code will only execute to throw an exception when one of the pre-conditions is
    violated, indicating that there's a problem with the data or how our program was
    executed.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们为使用我们的`Fraction`和`Stack`类的正常操作的前提条件添加了运行时检查。当违反前提条件之一时，此代码将仅执行以抛出异常，表明数据或程序执行方式存在问题。
- en: What Happens When an Exception is Thrown?
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当抛出异常时会发生什么？
- en: 'At some point, our program executes the following statement:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时刻，我们的程序执行以下语句：
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: By executing this, we are signaling that an erroneous condition has occurred,
    and that we want it handled. The next thing that happens is a **temporary** object,
    known as the **exception object**, is constructed in an unspecified storage and
    copy-initialized from the expression (which may call the move constructor and
    may be subject to copy elision). The type of the exception object is statically
    determined from the expression with the const and volatile qualifiers removed.
    Array types decay to pointers, while function types are converted into a pointer
    of a function. If the type of expression is malformed or abstract, then a compiler
    error will occur.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行此操作，我们正在发出发生错误的条件，并且我们希望它得到处理。接下来发生的事情是一个**临时**对象，称为**异常对象**，在未指定的存储中构造，并从表达式进行复制初始化（可能调用移动构造函数，并可能受到复制省略的影响）。异常对象的类型从表达式中静态确定，去除const和volatile限定符。数组类型会衰减为指针，而函数类型会转换为函数的指针。如果表达式的类型格式不正确或抽象，则会发生编译器错误。
- en: After the construction of the exception object, the control, along with the
    exception object, is transferred to the exception handler. The exception handler
    that's chosen is the one that has the closest matching type to the exception object
    as the stack unwinds. The exception object exists until the last catch clause
    exits, unless it is rethrown. The type of the expression must have an accessible
    `copy constructor` and a `destructor`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在异常对象构造之后，控制权连同异常对象一起转移到异常处理程序。被选择的异常处理程序是与异常对象最匹配的类型，因为堆栈展开。异常对象存在直到最后一个catch子句退出，除非它被重新抛出。表达式的类型必须具有可访问的`复制构造函数`和`析构函数`。
- en: Throw-by-Value or Throw-by-Pointer
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按值抛出还是按指针抛出
- en: Knowing that a temporary exception object is created, passed around, and then
    destroyed, what type should the throw expression use? A `value` or a `pointer`?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 知道临时异常对象被创建，传递，然后销毁，抛出表达式应该使用什么类型？一个`值`还是一个`指针`？
- en: We haven't talked much about specifying the types in the catch statements yet.
    We will do that shortly. But for now, note that to catch a pointer type (which
    was thrown), the catch pattern also needs to be of a pointer type.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有详细讨论在catch语句中指定类型。我们很快会做到。但是现在，请注意，要捕获指针类型（被抛出的），catch模式也需要是指针类型。
- en: If a pointer to an object is thrown, then the throwing party must ensure that
    what the exception object will point at (as it will be a copy of a pointer) will
    be kept alive until the exception has been handled, even through the `stack unwinding`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果抛出对象的指针，那么抛出方必须确保异常对象将指向的内容（因为它将是指针的副本）在异常处理之前保持活动，即使通过`堆栈展开`也是如此。
- en: The pointer could be to a static variable, a global variable, or memory that's
    been allocated from the heap to ensure that the object being pointed to still
    exists when the exception is handled. Now, we have solved the problem of keeping
    the exception object alive. But when the handler has finished with it, what does
    the catcher do with it?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 指针可以指向静态变量、全局变量或从堆中分配的内存，以确保在处理异常时被指向的对象仍然存在。现在，我们已经解决了保持异常对象存活的问题。但是当处理程序完成后，捕获者该怎么办？
- en: The catcher of the exception isn't aware about the creation of the exception
    object (`global`, `static`, or `heap`) and so it doesn't know whether it should
    delete the received pointer or not. Thus, throwing-by-pointer is not the recommended
    approach of throwing exceptions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 异常的捕获者不知道异常对象的创建（`全局`，`静态`或`堆`），因此不知道是否应该删除接收到的指针。因此，通过指针抛出异常不是推荐的异常抛出方法。
- en: An object that is thrown will be copied to the created temporary exception object
    and handed off to the handler. When the exception has been handled, the temporary
    object will simply be destroyed, and the program will continue. There is no ambiguity
    as to what to do with it. Therefore, the best practice is to throw the `exception
    by value`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 被抛出的对象将被复制到创建的临时异常对象中，并交给处理程序。当异常被处理后，临时对象将被简单地销毁，程序将继续执行。对于如何处理它没有歧义。因此，最佳实践是通过值抛出异常。
- en: Standard Library Exceptions
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标准库异常
- en: 'The C++ Standard Library defines `std::exception` as the base class for all
    the Standard Library exceptions. The standard defines the following first-level
    hierarchy of `exceptions`/`errors` (the number in brackets indicates how many
    exceptions derive from that class):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库将`std::exception`定义为所有标准库异常的基类。标准定义了以下第一级层次的`异常`/`错误`（括号中的数字表示从该类派生的异常数量）：
- en: '![Figure 3.17: Standard Library exception Hierarchy (two levels)](img/C14583_03_17.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图3.17：标准库异常层次结构（两级）](img/C14583_03_17.jpg)'
- en: 'Figure 3.17: Standard Library exception hierarchy (two levels)'
  id: totrans-159
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.17：标准库异常层次结构（两级）
- en: These exceptions are used through the C++ Standard Library including the STL.
    The best practice when creating your own exception class is deriving it from one
    of the standard exceptions. As we will see next, your special exception can be
    caught by a handler for one of the standard exceptions.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这些异常在C++标准库中被使用，包括STL。创建自己的异常类的最佳实践是从标准异常中派生它。接下来我们会看到，你的特殊异常可以被标准异常的处理程序捕获。
- en: Catching Exceptions
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获异常
- en: 'While discussing the need for exceptions, we introduced the idea of throwing
    the exceptions but did not really look at how C++ supports catching the exception.
    The process of exception handling starts with a section of code being wrapped
    in a `try` block to place it under **exception inspection**. The try block is
    followed by one or more catch blocks, which are the exception handlers. When an
    exceptional circumstance occurs while executing the code inside the try block,
    an exception is thrown, and control is transferred to the exception handlers.
    If no exceptions are thrown, then all the exception handlers are skipped, the
    code in the try block completes, and normal execution continues. Let''s express
    these concepts in a code snippet:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论异常的需要时，我们介绍了抛出异常的概念，但并没有真正看看C++如何支持捕获异常。异常处理的过程始于将代码段放在`try`块中以进行**异常检查**。try块后面是一个或多个catch块，它们是异常处理程序。当在try块内执行代码时发生异常情况时，异常被抛出，控制转移到异常处理程序。如果没有抛出异常，那么所有异常处理程序都将被跳过，try块中的代码完成，正常执行继续。让我们在代码片段中表达这些概念：
- en: '[PRE15]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding snippet shows the necessary keywords – `try`, and `catch` and
    introduces the three different types of catch pattern (excluding the default handler):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的片段展示了必要的关键字 - `try`和`catch`，并介绍了三种不同类型的捕获模式（不包括默认处理程序）：
- en: '**Catch exception by value**: This is a costly mechanism as the exception handler
    is processed like any other function. Catch-by-value means that a copy of the
    exception object must be created and then passed to the handler. The creation
    of the second copy slows down the exception handling process. This type can also
    suffer from object slicing where a subclass is thrown, and the catch clause is
    a super class. The catch clause will then only receive a copy of the super-class
    object that loses the attributes of the original exception object. Therefore,
    we should avoid catch-by-value exception handlers.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过值捕获异常**：这是一种昂贵的机制，因为异常处理程序像任何其他函数一样被处理。通过值捕获意味着必须创建异常对象的副本，然后传递给处理程序。第二个副本的创建减慢了异常处理过程。这种类型也可能受到对象切片的影响，其中子类被抛出，而catch子句是超类。然后catch子句只会接收到失去原始异常对象属性的超类对象的副本。因此，我们应避免使用通过值捕获异常处理程序。'
- en: '**Catch exception by pointer**: As discussed when looking at throw-by-value,
    with throw-by-pointer, this style of exception handler can only catch exceptions
    thrown by the pointer. As we only want to throw by value, we should avoid catch-by-pointer
    exception handlers.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过指针捕获异常**：如在讨论通过值抛出时所述，通过指针抛出，这种异常处理程序只能捕获指针抛出的异常。由于我们只想通过值抛出，应避免使用通过指针捕获异常处理程序。'
- en: '`throw-by-value` and `catch-by-reference`.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`通过值抛出`和`通过引用捕获`。'
- en: When there are multiple catch blocks, the exception object type is used to match
    the handlers in the order that they are specified. Once a handler is found to
    match, it is executed, and the remaining exception handlers are ignored. This
    is different to function resolution, where the compiler will find the best match
    to the arguments. Thus, the exception handlers (catch blocks) should be defined
    from the more specific to the more general. For example, the default handler (`catch(...)`)
    should always come last in the definition.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在多个catch块时，异常对象类型用于匹配按指定顺序的处理程序。一旦找到匹配的处理程序，它就会被执行，并且剩余的异常处理程序将被忽略。这与函数解析不同，编译器将找到最佳匹配的参数。因此，异常处理程序（catch块）应该从更具体到更一般的定义。例如，默认处理程序（`catch(...)`）应该始终在定义中的最后一个。
- en: 'Exercise 2: Implementing Exception Handlers'
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习2：实现异常处理程序
- en: 'In this exercise, we will implement a hierarchy of exception handlers to manage
    how exceptions are processed. Follow these steps to implement this exercise:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实现一系列异常处理程序的层次结构，以管理异常的处理方式。按照以下步骤实现这个练习：
- en: Open the `e`. The scope for that variable is only the catch block that it is
    declared in.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`e`。该变量的作用域仅限于它声明的catch块。
- en: Click on the **Launch Configuration** drop down menu and select **New Launch
    Configuration…**. Configure the **L3Exercise2** application from the **Search
    Project** menu to run it with the name **L3Exercise2**.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**启动配置**下拉菜单，然后选择**新启动配置…**。从**搜索项目**菜单配置**L3Exercise2**应用程序以使用名称**L3Exercise2**运行它。
- en: When that is complete, it will be the currently selected **Launch Configuration**.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，它将是当前选择的**启动配置**。
- en: 'Click on the **Run** button. Exercise 2 will run and produce the following
    output:![Figure 3.18: Exercise 2 output – default handler caught the exception](img/C14583_03_18.jpg)'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**运行**按钮。练习2将运行并产生以下输出：![图3.18：练习2输出-默认处理程序捕获了异常](img/C14583_03_18.jpg)
- en: 'Figure 3.18: Exercise 2 output – default handler caught the exception'
  id: totrans-175
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.18：练习2输出-默认处理程序捕获了异常
- en: In the Console window, click on the `CMake` file sets the `-fpermissive` flag
    when it compiles this target.)
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台窗口中，单击`CMake`文件设置`-fpermissive`标志，当它编译此目标时。）
- en: 'In the editor, move the default exception handler, `catch(...)`, to just after
    the `std::domain_error` handler. Click on the **Run** button. Exercise 2 will
    run and produce the following output:![Figure 3.19: std::exception handler has
    been used](img/C14583_03_19.jpg)'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，将默认异常处理程序`catch(...)`移动到`std::domain_error`处理程序后面。点击**运行**按钮。练习2将运行并产生以下输出：![图3.19：已使用std::exception处理程序](img/C14583_03_19.jpg)
- en: 'Figure 3.19: std::exception handler has been used'
  id: totrans-178
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.19：已使用std::exception处理程序
- en: In the editor, move the `std::exception` handler to just after the `std::domain_error`
    handler. Click on the `std::logic_error` handler was executed.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，将`std::exception`处理程序移动到`std::domain_error`处理程序后面。点击`std::logic_error`处理程序按预期执行。
- en: 'In the editor, move the `std:: logic_error` handler to just after the `std::domain_error`
    handler. Click on the `std:: domain_error` handler was executed which is actually
    what we would expect.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在编辑器中，将`std:: logic_error`处理程序移动到`std::domain_error`处理程序后面。点击`std:: domain_error`处理程序被执行，这实际上是我们所期望的。'
- en: Now change the `throw` line to be a `std::logic_error` exception. Click on the
    `std::logic_error` handler was executed as expected.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将`throw`行更改为`std::logic_error`异常。点击`std::logic_error`处理程序按预期执行。
- en: Now change the `throw` line to be a `std::underflow_error` exception. Click
    on the `std::exception` handler as expected. `std::exception` is the base class
    for all Standard Library exceptions.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将`throw`行更改为`std::underflow_error`异常。点击`std::exception`处理程序按预期执行。`std::exception`是所有标准库异常的基类。
- en: In this exercise, we implemented a series of exception handlers and observed
    how the order of exception handlers affects the way an exception is caught and
    how the exception hierarchy can be used.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们实现了一系列异常处理程序，并观察了异常处理程序的顺序如何影响异常的捕获以及异常层次结构如何被使用。
- en: CMake Generator Expressions
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CMake生成器表达式
- en: 'When working with `CMake`, it is sometimes necessary to adjust the value of
    a variable. `CMake` is a build generator system that can generate build files
    for many build tools and compiler tool chains. Because of this flexibility, if
    you want to turn on some feature in the compiler, you only need to apply to it
    to one particular type. This is because the command-line options are different
    between vendors. For example, the command line option for the g++ compiler to
    enable C++17 support is `-std=c++17`, but for `msvc` it is `/std:c++17`. If you
    open the `add_excutable`, then the following line will be after it:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`CMake`时，有时需要调整变量的值。`CMake`是一个构建生成系统，可以为许多构建工具和编译器工具链生成构建文件。由于这种灵活性，如果要在编译器中启用某些功能，只需将其应用于特定类型。这是因为不同供应商之间的命令行选项是不同的。例如，g++编译器启用C++17支持的命令行选项是`-std=c++17`，但对于`msvc`来说是`/std:c++17`。如果打开`add_excutable`，那么以下行将在其后：
- en: '[PRE16]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This uses the `$<CXX_COMPILER_ID:GNU>` variable query to check whether it is
    a GCC compiler. If yes, then it generates a 1 (true), otherwise 0 (false). It
    also uses the `$<condition:true_string>` condition expression to add `-fpermissive`
    to the compiler options for the `target_compile_options` or via one call.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用`$<CXX_COMPILER_ID:GNU>`变量查询来检查它是否是GCC编译器。如果是，则生成1（true），否则生成0（false）。它还使用`$<condition:true_string>`条件表达式将`-fpermissive`添加到`target_compile_options`的编译器选项或通过一个调用。
- en: Note
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on generator expressions, please take a look at the following
    link: [https://cmake.org/cmake/help/v3.15/manual/cmake-generator-expressions.7.html](https://cmake.org/cmake/help/v3.15/manual/cmake-generator-expressions.7.html).'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有关生成器表达式的更多信息，请查看以下链接：[https://cmake.org/cmake/help/v3.15/manual/cmake-generator-expressions.7.html](https://cmake.org/cmake/help/v3.15/manual/cmake-generator-expressions.7.html)。
- en: Exception Usage Guidelines
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常使用指南
- en: 'When using exceptions in your C++ code, remember the following points:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++代码中使用异常时，请记住以下几点：
- en: 'Chant: **Throw by value and catch by reference**'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 口号：**按值抛出，按引用捕获**
- en: '**Do not use exceptions for normal program flow**. If a function meets an abnormal
    condition and is not able meet its (functional) obligations, then and only then
    do you throw an exception. If the function can resolve the abnormal condition
    and fulfil its obligations, then it is not an exception. They are named exceptions
    for a reason and you will not incur any processing overhead if you do not use
    them.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要将异常用于正常程序流**。如果函数遇到异常情况并且无法满足其（功能性）义务，那么只有在这种情况下才抛出异常。如果函数可以解决异常情况并履行其义务，那么这不是异常。它们之所以被称为异常，是有原因的，如果不使用它们，就不会产生任何处理开销。'
- en: '**Do not throw an exception from within a destructor**. Remember that because
    of stack unwinding, local variable destructors will be executed. If a destructor
    is called during the stack unwinding process and throws an exception, then the
    program will terminate.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要在析构函数中抛出异常**。请记住，由于堆栈展开，局部变量的析构函数将被执行。如果在堆栈展开过程中调用了析构函数并抛出了异常，那么程序将终止。'
- en: '**Do not swallow exceptions**. Do not use the default catch handler and do
    nothing about the exception. The exception has been thrown to indicate that there
    is a problem and you should do something about it. Ignoring an exception can lead
    to a failure later that will be hard to troubleshoot. This is because any useful
    information is truly lost with the swallowed exception.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要吞没异常**。不要使用默认的catch处理程序，也不要对异常做任何处理。异常被抛出是为了指示存在问题，你应该对此做些什么。忽视异常可能会导致以后难以排查的故障。这是因为任何有用的信息都真正丢失了。'
- en: '**The exception object is copied from the throw**.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异常对象是从抛出中复制的**。'
- en: Resource Management (in an Exceptional World)
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源管理（在异常世界中）
- en: 'So far, we have looked at local variable scope, and how `automatic` and `dynamic
    lifetime variables` are dealt with when the variable goes out of scope – automatic
    lifetime variables (those placed on the stack) are fully destructed while `dynamic
    lifetime variables` (those allocated to the heap by the programmer) are not destructed:
    we just lose any access to them. We have also seen that, when an exception is
    thrown, the nearest matching handler is found and all the local variables between
    the throw point and the handler will be destructed through the stack unwinding
    process.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看过局部变量作用域，以及当变量超出作用域时如何处理`自动`和`动态生命周期变量` - 自动生命周期变量（放在堆栈上的变量）将被完全析构，而`动态生命周期变量`（由程序员分配到堆上的变量）不会被析构：我们只是失去了对它们的任何访问。我们也看到，当抛出异常时，会找到最近匹配的处理程序，并且在堆栈展开过程中将析构抛出点和处理程序之间的所有局部变量。
- en: We can use this knowledge to write robust resource management classes that will
    relieve us from the need to keep track of resources (dynamic lifetime variables,
    file handles, system handles, and so on) to ensure that they are released (back
    into the wild) when we are done with them. The technique that's utilized to manage
    resources, both under normal operating and under exceptions, is known as **Resource
    Acquisition is Initialization** (**RAII**).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这些知识编写健壮的资源管理类，这些类将使我们不必跟踪资源（动态生命周期变量、文件句柄、系统句柄等），以确保在使用完它们后将它们释放（释放到野外）。在正常操作和异常情况下管理资源的技术被称为**资源获取即初始化**（**RAII**）。
- en: Resource Acquisition Is Initialization
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源获取即初始化
- en: RAII is another good example of a badly named concept (the other is `SFINAE`).
    `RAII`, or `Resource Acquisition is Initialization` describes the behavior of
    a class that's used to manage resources. It may be better if it were named `File`
    class and show how RAII also improves the readability and our ability to reason
    about what a function does.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: RAII是另一个命名不好的概念的好例子（另一个是`SFINAE`）。`RAII`或`Resource Acquisition is Initialization`描述了一个用于管理资源的类的行为。如果它被命名为`File`类并展示了RAII如何提高可读性和我们对函数操作的理解能力，可能会更好。
- en: 'Consider the following code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE17]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This code shows two potential problems with the management of resources:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了资源管理的两个潜在问题：
- en: Most importantly, the occurrence of an exception between the opening and closing
    of a file results in the resource leaking. If this is a system resource, many
    of these can lead to system instability or application performance being adversely
    affected, since it starves for resources.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最重要的是，在打开和关闭文件之间发生异常会导致资源泄漏。如果这是系统资源，许多这样的情况可能导致系统不稳定或应用程序性能受到不利影响，因为它会因资源匮乏而受到影响。
- en: In addition, the management of multiple resources within one method can lead
    to deeply nested clauses because of error handling. This is detrimental to the
    readability of the code and hence its understanding and maintainability. It is
    easy to forget to release a resource, especially when there are multiple exit
    points.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，在一个方法中管理多个资源可能会导致由于错误处理而产生深度嵌套的子句。这对代码的可读性有害，因此也影响了代码的理解和可维护性。很容易忘记释放资源，特别是当有多个退出点时。
- en: So, how can we manage the resource so that we have exception-safe and simpler
    code? This problem is not unique to C++ and different languages manage it differently.
    `Java`, `C#`, and `Python` use a garbage collection approach that sweeps through
    created objects and cleans them up when they are no longer referenced. But C++
    does not have garbage collection, so what is the solution?
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何管理资源，以便有异常安全和更简单的代码？这个问题不仅仅是C++独有的，不同的语言以不同的方式处理它。`Java`、`C#`和`Python`使用垃圾回收方法，在对象创建后清理它们，当它们不再被引用时。但是C++没有垃圾回收，那么解决方案是什么呢？
- en: 'Consider the following class:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下类：
- en: '[PRE18]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This class implements the following characteristics:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类实现了以下特征：
- en: The constructor acquires the resource.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数获取资源。
- en: If the resource is not acquired in the constructor, then an exception is thrown.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果资源没有在构造函数中获取，那么会抛出异常。
- en: When the class is destroyed, the resource is released.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当类被销毁时，资源被释放。
- en: 'If we use this class in the `do_something()` method, it then looks like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`do_something()`方法中使用这个类，那么它看起来像这样：
- en: '[PRE19]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If an exception occurs while doing this, then C++ guarantees that all stack-based
    objects will have their destructors called (`stack unwinding`), thus ensuring
    that the files are closed. This solves the problem of resources leaking with the
    occurrence of an exception as the resources are now automatically cleaned up.
    In addition, this method is extremely easy to read so that we can understand the
    logic flow without having to worry about error handling.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在执行此操作时发生异常，那么C++保证将调用所有基于堆栈的对象的析构函数（`堆栈展开`），从而确保文件被关闭。这解决了在发生异常时资源泄漏的问题，因为现在资源会自动清理。此外，这种方法非常容易阅读，因此我们可以理解逻辑流程，而不必担心错误处理。
- en: This technique uses the lifetime of the `File` objects to acquire and release
    the resource, ensuring that the resources do not leak. The resource is acquired
    during the construction (initialization) of the management class and released
    during the destruction of the management class. It is this behavior of scope-bound
    resources that gives rise to the name `Resource Acquisition Is Initialization`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术利用`File`对象的生命周期来获取和释放资源，确保资源不会泄漏。资源在管理类的构造（初始化）期间获取，并在管理类的销毁期间释放。正是这种作用域绑定资源的行为导致了`Resource
    Acquisition Is Initialization`的名称。
- en: The preceding example deals with managing file handles that are system resources.
    It applies to any resources that are required to be acquired before use, and then
    relinquished when finished. The RAII technique can be applied to a wide range
    of resources – open files, open pipes, allocated heap memory, open sockets, threads
    of execution, database connections, locking of mutexes/critical sections – basically
    any resource that is in short supply in the host system and needs to be managed.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子涉及管理系统资源的文件句柄。它适用于任何在使用前需要获取，然后在完成后放弃的资源。RAII技术可以应用于各种资源 - 打开文件，打开管道，分配的堆内存，打开套接字，执行线程，数据库连接，互斥锁/临界区的锁定
    - 基本上是主机系统中供应不足的任何资源，并且需要进行管理。
- en: 'Exercise 3: Implementing RAII for Memory and File Handles'
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习3：为内存和文件句柄实现RAII
- en: 'In this exercise, we will implement two different classes that will manage
    memory or files using the RAII technique. Follow these steps to implement this
    exercise:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实现两个不同的类，使用RAII技术来管理内存或文件。按照以下步骤来实现这个练习：
- en: Open the **Lesson3** project in Eclipse. Then in the **Project Explorer**, expand
    **Lesson3**, then **Exercise03**, and double click on **Exercise3.cpp** to open
    the file for this exercise into the editor.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse中打开**Lesson3**项目。然后在**Project Explorer**中展开**Lesson3**，然后展开**Exercise03**，双击**Exercise3.cpp**以打开此练习的文件到编辑器中。
- en: Click on the **Launch Configuration** drop down menu and select **New Launch
    Configuration…**. Configure the **L3Exercise3** application from the Search Project
    menu to run it with the name **L3Exercise3**.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Launch Configuration**下拉菜单，选择**New Launch Configuration…**。从搜索项目菜单中配置**L3Exercise3**应用程序以使用名称**L3Exercise3**运行它。
- en: Click on the `main()` function when the `monitor` is destructed, it dumps a
    report of memory that was allocated and released, as well as the files that were
    opened but never closed.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`monitor`被析构时，点击`main()`函数，它会转储分配和释放的内存报告，以及打开但从未关闭的文件。
- en: 'In the editor, type the following into the `File` class:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，输入以下内容到`File`类中：
- en: '[PRE20]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Click on the **Run** button to run Exercise 3 – it still leaks files and memory,
    but the code is correct.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Run**按钮运行Exercise 3 - 它仍然泄漏文件和内存，但代码是正确的。
- en: 'Locate the `LeakFiles()` function and modify it so that it uses the new `File`
    class (like in the preceding code) to prevent file leaks:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到`LeakFiles()`函数，并修改它以使用新的`File`类（就像前面的代码一样）以防止文件泄漏：
- en: '[PRE21]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Click on the `LeakFiles()` correctly, then the output will be as follows:![Figure
    3.21: No file leaks](img/C14583_03_21.jpg)'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确点击`LeakFiles()`，然后输出将如下所示：![图3.21：没有文件泄漏](img/C14583_03_21.jpg)
- en: 'Figure 3.21: No file leaks'
  id: totrans-230
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.21：没有文件泄漏
- en: 'Now in `CharPointer` class:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在`CharPointer`类中：
- en: '[PRE22]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Modify `LeakPointers()` to read like so:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`LeakPointers()`如下所示：
- en: '[PRE23]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Click on the **Run** button to run Exercise 3 – it still has memory leaks, but
    the code is correct.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Run**按钮运行Exercise 3 - 它仍然有内存泄漏，但代码是正确的。
- en: 'Now, add the following destructor to `CharPointer`. Note that the `delete`
    operator uses the array `[]` syntax:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，向`CharPointer`添加以下析构函数。请注意，`delete`操作符使用数组`[]`语法：
- en: '[PRE24]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Click on the **Run** button again to run Exercise 3 – this time, you should
    see that the monitor reports no leaks:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次点击**Run**按钮运行Exercise 3 - 这次，您应该看到监视器报告没有泄漏：
- en: '![Figure 3.22: No leaks – memory or files](img/C14583_03_22.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图3.22：没有泄漏 - 内存或文件](img/C14583_03_22.jpg)'
- en: 'Figure 3.22: No leaks – memory or files'
  id: totrans-240
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.22：没有泄漏 - 内存或文件
- en: The implementation of `File` and `CharPointer` deliver on the `RAII` design
    approach, but there are other considerations when designing these. For example,
    do we want the copy constructor or copy assignment functions? In both cases, it
    could be a problem to just copy the resource from one object to another as this
    could result in two attempts to close a file handle or delete the memory. Typically,
    this would lead to undefined behavior. Next, we will re-visit the special member
    functions in light of implementing a resource management object such as `File`
    or `CharPointer`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`File`和`CharPointer`的实现符合`RAII`设计方法，但在设计这些方法时还有其他考虑因素。例如，我们是否需要复制构造函数或复制赋值函数？在这两种情况下，仅仅从一个对象复制资源到另一个对象可能会导致关闭文件句柄或删除内存的两次尝试。通常，这会导致未定义的行为。接下来，我们将重新审视特殊成员函数，以实现`File`或`CharPointer`等资源管理对象。'
- en: Special Coding Techniques
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特殊编码技术
- en: 'The code for *Exercise 3*, *Implementing RAII for Memory and File Handles*,
    has been specially written so that we can monitor the usage of the memory and
    the file handles and report any leaks on exit. Visit the **monitor.h** and **monitor.cpp**
    files and examine the two techniques that were used to make the monitor possible:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*练习3*的代码，*为内存和文件句柄实现RAII*，已经特别编写，以便我们可以监视内存和文件句柄的使用，并在退出时报告任何泄漏。访问**monitor.h**和**monitor.cpp**文件，并检查用于使监视器可能的两种技术：'
- en: '`SendMessage` if you include `SendMessageA` or `SendMessageW` respectively.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果包括`SendMessageA`或`SendMessageW`，则`SendMessage`
- en: '**Defining our own new handler**: This is an advanced technique and unless
    you write embedded code, it''s unlikely you will need it.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定义我们自己的新处理程序**：这是一种高级技术，除非你编写嵌入式代码，否则你不太可能需要它。'
- en: C++ doesn't Need finally
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C++不需要最终
- en: Other languages (`C#`, `Java`, and `Visual Basic.NET`) that support an exception
    throwing mechanism have a `try/catch/finally` paradigm where the code in the `finally`
    block is called on exit from the try block – either normally or by exception.
    C++ has no `finally` block because it has access to a better mechanism that ensures
    that we cannot forget to release a resource – RAII. Since the resource is represented
    by a local object, the local object's destructor will free the resource.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 其他支持异常抛出机制的语言（`C#`、`Java`和`Visual Basic.NET`）具有`try/catch/finally`范式，其中`finally`块中的代码在退出try块时被调用
    - 无论是正常退出还是异常退出。C++没有`finally`块，因为它有更好的机制，可以确保我们不会忘记释放资源 - RAII。由于资源由本地对象表示，本地对象的析构函数将释放资源。
- en: The added advantage of this design pattern is that if a lot of resources are
    being managed, then the `finally` block is proportionally large. RAII removes
    the need for finally and leads to code that is easier to maintain.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式的附加优势是，如果正在管理大量资源，则`finally`块的大小也相应较大。RAII消除了对finally的需求，并导致更易于维护的代码。
- en: RAII and the STL
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RAII和STL
- en: The Standard Template Library (STL) utilizes RAII in many of its templates and
    classes. For example, the smart pointers that were introduced in C++11, that is
    `std::unique_ptr` and `std::shared_ptr`, help avoid many problems by ensuring
    that memory is deallocated when it has been finished with, or by ensuring that
    the memory is not deallocated if it is used elsewhere. Other examples in the STL
    include `std::string` (memory), `std::vector` (memory), and `std::fstream` (file
    handles).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 标准模板库（STL）在许多模板和类中使用RAII。例如，C++11中引入的智能指针，即`std::unique_ptr`和`std::shared_ptr`，通过确保在使用完毕后释放内存，或者确保在其他地方使用时不释放内存，帮助避免了许多问题。STL中的其他示例包括`std::string`（内存）、`std::vector`（内存）和`std::fstream`（文件句柄）。
- en: Who Owns This Object?
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 谁拥有这个对象？
- en: 'With the preceding implementations of `File` and `CharPointer`, we have tested
    Resource Management with RAII. Let''s explore it further. Firstly, we will define
    a class that has more than just one resource:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面对`File`和`CharPointer`的实现，我们已经测试了使用RAII进行资源管理。让我们进一步探讨。首先，我们将定义一个不仅拥有一个资源的类：
- en: '[PRE25]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The class is used for buffering the writing to the file.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 该类用于缓冲写入文件。
- en: Note
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: This is not usually necessary when using iostream derived classes as they already
    provide buffering.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用iostream派生类时，这通常是不必要的，因为它们已经提供了缓冲。
- en: Each call to the `write()` function will add data into the allocated buffer
    until it reaches the `BufferSize` at which point the data is actually written
    to the file and the buffer is reset.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`write()`函数都会将数据添加到分配的缓冲区，直到达到`BufferSize`，此时数据实际写入文件，并且缓冲区被重置。
- en: But what if we wanted to assign this instance of `BufferedWriter` to another
    instance or copy it? What is the right behavior?
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果我们想要将`BufferedWriter`的这个实例分配给另一个实例或复制它呢？什么是正确的行为？
- en: If we just let the default copy constructor/copy assignment do its their thing
    we get a member-wise copy of the items. This would mean that we have two instances
    of `BufferedWriter` that hold the same handle to the file and the pointer to the
    buffer. When the first instance of the object is destroyed, being the good programmers
    that we are, we will clean up the file by closing it and the memory by deleting
    it. The second instance now has a file handle that is defunct and a pointer to
    memory that we have told the operating system to recover for the next user. Any
    attempt to use these resources, including destroying them, will result in undefined
    behavior and mostly likely a program crash. The default copy constructor/copy-assignment
    operators execute what is known as a shallow copy – that is, it copies all the
    members as they are, bit by bit (but not what they refer to).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只是让默认的复制构造函数/复制赋值做它们的事情，我们会得到项目的成员复制。这意味着我们有两个`BufferedWriter`的实例，它们持有相同的文件句柄和缓冲区指针。当对象的第一个实例被销毁时，作为优秀的程序员，我们将通过关闭文件和删除内存来清理文件。第二个实例现在有一个失效的文件句柄和一个指向我们已告诉操作系统为下一个用户恢复的内存的指针。任何尝试使用这些资源，包括销毁它们，都将导致未定义的行为，很可能是程序崩溃。默认的复制构造函数/复制赋值运算符执行所谓的浅复制
    - 也就是说，它按位复制所有成员（但不是它们所指的内容）。
- en: 'The two resources that we have can be treated differently. Firstly, there should
    only be one class that owns the `m_buffer`. There are two options in dealing with
    this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们拥有的两个资源可以被不同对待。首先，应该只有一个类拥有`m_buffer`。在处理这个问题时有两个选择：
- en: Prevent the copy of the class and hence the memory
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止类的复制，因此也防止内存。
- en: Perform a `deep copy` where the buffer in the second instance has been allocated
    by the constructor and the contents of the first buffer is copied
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行`深复制`，其中第二个实例中的缓冲区是由构造函数分配的，并且复制了第一个缓冲区的内容
- en: 'Secondly, there should only be one class that owns the file handle (`m_file`).
    There are two options in dealing with this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，应该只有一个类拥有文件句柄（`m_file`）。在处理这个问题时有两个选择：
- en: Prevent the copy of the class and hence the file handle
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止类的复制，因此也防止文件句柄的复制
- en: Transfer the `ownership` from the original instance to the second instance and
    mark the original as invalid or empty (whatever that means)
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`所有权`从原始实例转移到第二个实例，并将原始实例标记为无效或空（无论这意味着什么）
- en: It is easy enough to implement a deep copy, but how do we transfer ownership
    of a resource? To answer this question, we need to look at temporary objects and
    value categories again.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 实现深拷贝很容易，但如何转移资源的所有权呢？为了回答这个问题，我们需要再次看看临时对象和值类别。
- en: Temporary Objects
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 临时对象
- en: A temporary object is created to store the intermediate results of an expression
    before the result is deposited into a variable (or just forgotten). An expression
    is any code that returns a value, including passing by value to a function, returning
    a value from a function, implicit conversion, literals, and binary operators.
    Temporary objects are `rvalue expressions` and they have memory, temporarily allocated
    for them as a location, to place the expression result. It is this creation of
    temporaries and copying data between them that caused some performance issues
    prior to C++11\. To address this issue, C++11 introduced `rvalue references` to
    enable what is known as move semantics.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在将结果存储到变量（或者只是忘记）之前，创建临时对象来存储表达式的中间结果。表达式是任何返回值的代码，包括按值传递给函数，从函数返回值，隐式转换，文字和二进制运算符。临时对象是`rvalue表达式`，它们有内存，为它们分配了临时位置，以放置表达式结果。正是这种创建临时对象和在它们之间复制数据导致了C++11之前的一些性能问题。为了解决这个问题，C++11引入了`rvalue引用`，以实现所谓的移动语义。
- en: Move Semantics
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动语义
- en: An `rvalue reference` (denoted by a double ampersand, '`&&`') is a reference
    that is only assigned an `rvalue` that will extend the rvalue's lifetime until
    the `rvalue reference` is done with it. So, `rvalues` can live beyond the expression
    that defined it. With `rvalue references`, we can now implement move semantics
    through the move constructor and move assignment operators. The purpose of move
    semantics is to steal resources from the referenced object and thus avoid the
    expensive copy operations. When the move is complete, the referenced object must
    be left in a stable state. In other words, the object that was moved from must
    be left in a state that will not cause any undefined behavior or a program crash
    when it is destroyed, nor should it affect the resources that were stolen from
    it.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`rvalue引用`（用双`&&`表示）是一个只分配给`rvalue`的引用，它将延长`rvalue`的生命周期，直到`rvalue引用`完成为止。因此，`rvalues`可以在定义它的表达式之外存在。有了`rvalue引用`，我们现在可以通过移动构造函数和移动赋值运算符来实现移动语义。移动语义的目的是从被引用对象中窃取资源，从而避免昂贵的复制操作。当移动完成时，被引用对象必须保持在稳定状态。换句话说，被移动的对象必须保持在一个状态，不会在销毁时引起任何未定义的行为或程序崩溃，也不应该影响从中窃取的资源。
- en: C++11 also introduced a casting operator `std::move()`, that casts an `lvalue`
    to an `rvalue` so that the move constructor or move assignment operator gets called
    to 'move' the resources. The `std::move()` method does not actually move the data.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: C++11还引入了一个转换运算符`std::move()`，它将一个`lvalue`转换为一个`rvalue`，以便调用移动构造函数或移动赋值运算符来'移动'资源。`std::move()`方法实际上并不移动数据。
- en: One unexpected thing to note is that, inside the move constructor and move assignment
    operator, the `rvalue` reference is actually an `lvalue`. This means that if you
    want to ensure move semantics happen within the method then you may need to use
    `std::move()` again on the member variables.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 一个意外的事情要注意的是，在移动构造函数和移动赋值运算符中，`rvalue`引用实际上是一个`lvalue`。这意味着如果你想确保在方法内发生移动语义，那么你可能需要再次在成员变量上使用`std::move()`。
- en: As C++11 introduced move semantics, it also updated the Standard Library to
    take advantage of this new capability. For example, `std::string` and `std::vector`
    have been updated to include move semantics. To get the benefits of move semantics;
    you just need to re-compile your code with the latest C++ compiler.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 随着C++11引入了移动语义，它还更新了标准库以利用这种新的能力。例如，`std::string`和`std::vector`已经更新以包括移动语义。要获得移动语义的好处，你只需要用最新的C++编译器重新编译你的代码。
- en: Implementing a Smart Pointer
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现智能指针
- en: 'A smart pointer is a resource management class that holds a pointer to a resource
    and releases it when it goes out of scope. In this section, we will implement
    a smart pointer, observe its behavior as a copy supporting class, evolve it to
    support move semantics and finally remove its support for copy operations:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 智能指针是一个资源管理类，它在资源超出范围时持有指向资源的指针并释放它。在本节中，我们将实现一个智能指针，观察它作为一个支持复制的类的行为，使其支持移动语义，最后移除其对复制操作的支持：
- en: '[PRE26]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When we run this program, the following output generated:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个程序时，会生成以下输出：
- en: '![Figure 3.23: Smart Pointer Program output](img/C14583_03_23.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图3.23：智能指针程序输出](img/C14583_03_23.jpg)'
- en: 'Figure 3.23: Smart Pointer Program output'
  id: totrans-279
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.23：智能指针程序输出
- en: 'For such a simple program, there is a lot of acquiring and releasing of the
    resource. Let''s pull this apart:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样一个简单的程序，获取和释放资源的操作很多。让我们来分析一下：
- en: The local variable, res, inside `createResource()` is created and initialized
    on the heap (dynamic lifetime), causing the first "`Resource acquired`" message.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`createResource()`内部的局部变量res是在堆上创建并初始化的（动态生命周期），导致第一个“`获取资源`”消息。
- en: It is possible for the compiler to create another temporary to return the value.
    However, the compiler has executed `copy elision` to remove the copy (that is,
    it is able to build the object directly onto a position in the stack allocated
    by the calling function). The compiler has `Return-Value-Optimization` (`RVO`)
    and `Named- Return-Value-Optimization` (`NRVO`) optimizations that it can apply
    and, under C++17 these have been made mandatory in certain circumstances.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译器可能创建另一个临时对象来返回值。然而，编译器已经执行了`复制省略`来删除复制（也就是说，它能够直接在调用函数分配的堆栈位置上构建对象）。编译器有`返回值优化`（`RVO`）和`命名返回值优化`（`NRVO`）优化，它可以应用，并且在C++17中，在某些情况下这些优化已经成为强制性的。
- en: The temporary object is assigned to the `the_res` variable in the `main()` function
    by copy assignment. Since copy assignment is doing a deep copy, another copy of
    the resource is acquired.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 临时对象通过复制赋值分配给`main()`函数中的`the_res`变量。由于复制赋值正在进行深拷贝，因此会获取资源的另一个副本。
- en: When the assignment completes, the temporary object goes out of scope and we
    get the first "Resource released" message.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当赋值完成时，临时对象超出范围，我们得到第一个"资源释放"消息。
- en: When the `main()` function returns, `the_res` goes out of scope, which releases
    the second Resource.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`main()`函数返回时，`the_res`超出范围，释放第二个Resource。
- en: So, if the resource is large, we have a very inefficient method of creating
    the `the_res` local variable in `main()` as we are creating and copying around
    large chunks of memory because of the deep copy in the copy assignment. However,
    we know that when the temporary variable created by `createResource()` is no longer
    needed, then we are going to throw it away and release its resource. It would
    be more efficient in these scenarios to transfer (or move) the resource from the
    temporary to the other instance of the type. Move semantics makes it possible
    to rewrite our `smart_ptr` template to not do the deep copy but transfer the resource.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果资源很大，我们在`main()`中创建`the_res`局部变量的方法非常低效，因为我们正在创建和复制大块内存，这是由于复制赋值中的深拷贝。然而，我们知道当`createResource()`创建的临时变量不再需要时，我们将丢弃它并释放其资源。在这些情况下，将资源从临时变量转移（或移动）到类型的另一个实例中将更有效。移动语义使我们能够重写我们的`smart_ptr`模板，而不是进行深拷贝，而是转移资源。
- en: 'Let''s add move semantics to our `smart_ptr` class:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的`smart_ptr`类添加移动语义：
- en: '[PRE27]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After re-running our program, we get the following output:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行程序后，我们得到以下输出：
- en: '![Figure 3.24: Smart pointer program output using move semantics](img/C14583_03_24.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图3.24：使用移动语义的智能指针程序输出](img/C14583_03_24.jpg)'
- en: 'Figure 3.24: Smart pointer program output using move semantics'
  id: totrans-291
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.24：使用移动语义的智能指针程序输出
- en: 'Now, because move assignment is now available, the compiler uses it on this
    line:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为移动赋值现在可用，编译器在这一行上使用它：
- en: '[PRE28]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`Step 3` is now replaced with move assignment, meaning the deep copy has now
    been removed.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 第3步现在已经被移动赋值所取代，这意味着深拷贝现在已经被移除。
- en: '`Step 4` no longer frees the resource because the line with the comment "//"
    puts into a safe state – it no longer has a resource to free because its ownership
    was transferred.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`第4步`不再释放资源，因为带有注释“//”的行将其置于安全状态——它不再具有要释放的资源，因为其所有权已转移。'
- en: Another point to note with the `move constructor` and `move assignment` is that
    where the arguments were const for their copy versions, they were `non-const`
    for their move versions. This is called the `transfer of ownership`, which means
    that we need to modify the parameter that is passed in.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的地方是`移动构造函数`和`移动赋值`的参数在它们的拷贝版本中是const的，而在它们的移动版本中是`非const`的。这被称为`所有权的转移`，这意味着我们需要修改传入的参数。
- en: 'An alternative implementation of the move constructor may look like the following:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 移动构造函数的另一种实现可能如下所示：
- en: '[PRE29]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Essentially, we are swapping the resource, and the C++ STL has support for swap
    as a template with many specializations. This works because we used member initialization
    to set `m_ptr` to `nullptr`. So, we are swapping a `nullptr` with the value stored
    in `a`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们正在交换资源，C++ STL支持许多特化的模板交换。这是因为我们使用成员初始化将`m_ptr`设置为`nullptr`。因此，我们正在交换`nullptr`和存储在`a`中的值。
- en: 'Now that we have fixed the unnecessary deep copy problem, we can actually remove
    the copy operations from `smart_ptr()` as the transfer of ownership is actually
    what we want. If we were to copy an instance of a non-temporary `smart_ptr` to
    another instance of a non-temporary instance of `smart_ptr`, then we would have
    two objects that would delete the resource when they go out of scope, and this
    is not the desired behavior. To remove the (deep) copy operations we change the
    definition of our member functions, as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解决了不必要的深拷贝问题，我们实际上可以从`smart_ptr()`中删除复制操作，因为实际上我们想要的是所有权的转移。如果我们将非临时`smart_ptr`的实例复制到另一个非临时`smart_ptr`实例中，那么当它们超出范围时会删除资源，这不是期望的行为。为了删除（深）复制操作，我们改变了成员函数的定义，如下所示：
- en: '[PRE30]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The postfix of `= delete` which we looked at in *Chapter 2A*, *No Ducks Allowed
    – Types and Deduction*, tells the compiler that an attempt to access a function
    with that prototype is now not valid code and causes an error.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第2A章*中看到的`= delete`的后缀告诉编译器，尝试访问具有该原型的函数现在不是有效的代码，并导致错误。
- en: STL Smart Pointers
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: STL智能指针
- en: 'Instead of having to write our own `smart_ptr`, the STL provides classes that
    we can use to implement RAII on our objects. The original was `std::auto_ptr()`,
    which was deprecated in C++ 11 and removed in C++ 17\. It was created before `rvalue`
    reference support and caused problems because it implemented move semantics using
    copy. C++ 11 introduced three new templates to manage lifetime and ownership of
    resources:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 与其编写自己的`smart_ptr`，不如使用STL提供的类来实现我们对象的RAII。最初的是`std::auto_ptr()`，它在C++ 11中被弃用，并在C++
    17中被移除。它是在`rvalue`引用支持之前创建的，并且因为它使用复制来实现移动语义而导致问题。C++ 11引入了三个新模板来管理资源的生命周期和所有权：
- en: '`single object` via a pointer and destroys that object when `unique_ptr` goes
    out of scope. It has two versions: for single objects (created using `new`) and
    for array of objects (created using `new[]`). `unique_ptr` is as efficient as
    using the underlying pointer directly.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过指针管理`单个对象`，并在`unique_ptr`超出范围时销毁该对象。它有两个版本：用`new`创建的单个对象和用`new[]`创建的对象数组。`unique_ptr`与直接使用底层指针一样高效。
- en: '**std::shared_ptr**: Retains shared ownership of an object through a pointer.
    It manages the resource through the use of a reference counter. Every copy of
    shared_ptr that''s assigned to shared_ptr updates the reference count. When the
    reference count goes to zero, this means that there are no owners left and the
    resource is released/destroyed.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**std::shared_ptr**：通过指针保留对象的共享所有权。它通过引用计数管理资源。每个分配给shared_ptr的shared_ptr的副本都会更新引用计数。当引用计数变为零时，这意味着没有剩余所有者，资源被释放/销毁。'
- en: '`shared_ptr`, but does not modify the counter. It can be checked to see if
    the resource still exists, but it will not prevent the resource from being destroyed.
    If you determine that the resource still exists, then it can be used to obtain
    a `shared_ptr` to the resource. One use case for it is a scenario where multiple
    `shared_ptrs` end in cyclic references. A cyclic reference would prevent the auto
    releasing of resources. `weak_ptr` is used to break the loop and allow the resources
    to be freed when they should be.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shared_ptr`，但不修改计数器。可以检查资源是否仍然存在，但不会阻止资源被销毁。如果确定资源仍然存在，那么可以用它来获得资源的`shared_ptr`。一个使用场景是多个`shared_ptrs`最终形成循环引用的情况。循环引用会阻止资源的自动释放。`weak_ptr`用于打破循环并允许资源在应该被释放时被释放。'
- en: std::unique_ptr
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: std::unique_ptr
- en: '`std::unique_ptr()` was introduced in C++ 11 to replace `std::auto_ptr()` and
    gives us everything that `smart_ptr` does (and more). We can re-write our `smart_ptr`
    program as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unique_ptr()`在C++ 11中引入，以取代`std::auto_ptr()`，并为我们提供了`smart_ptr`所做的一切（以及更多）。我们可以将我们的`smart_ptr`程序重写如下：'
- en: '[PRE31]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can go one step further than this, because C++ 14 introduced a helper method
    to ensure exception safety when dealing with `unique_ptrs`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步进行，因为C++ 14引入了一个辅助方法，以确保在处理`unique_ptrs`时具有异常安全性：
- en: '[PRE32]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Why is this necessary?* Consider the following function call:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这是必要的？*考虑以下函数调用：'
- en: '[PRE33]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The problem with this is that the compiler is free to order the sequence of
    operations in the argument list in any order it likes. It could call `new T`,
    then `new U`, then `std::unique_ptr<T>()`, and finally `std::unique_ptr<U>()`.
    The problem with this sequence is that if `new U` were to throw an exception,
    then the resource allocated by the call to `new T` has not been placed in a `unique_ptr`
    and will not be cleaned up automatically. The use of `std::make_unique<>()` guarantees
    the order of calls so that the construction of the resource and the construction
    of `unique_ptr` will occur together and not leak resources. The need for `make_unique`
    has been removed in C++17 where the rules around the order of evaluation in these
    circumstances have been tightened. However, it is still probably a good idea to
    use the `make_unique<T>()` approach as any future conversion to a shared_ptr will
    be easier.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于编译器可以自由地以任何顺序对参数列表中的操作进行排序。它可以调用`new T`，然后`new U`，然后`std::unique_ptr<T>()`，最后`std::unique_ptr<U>()`。这个顺序的问题在于，如果`new
    U`抛出异常，那么由调用`new T`分配的资源就没有被放入`unique_ptr`中，并且不会自动清理。使用`std::make_unique<>()`可以保证调用的顺序，以便资源的构建和`unique_ptr`的构建将一起发生，不会泄漏资源。在C++17中，对这些情况下的评估顺序的规则已经得到了加强，因此不再需要`make_unique`。然而，使用`make_unique<T>()`方法仍然可能是一个好主意，因为将来转换为shared_ptr会更容易。
- en: 'The name `unique_ptr` makes the intent of the template clear, that is, it is
    the only owner of the object that it points to. This was not obvious from `auto_ptr`.
    Likewise, `shared_ptr` is clear in that it intends to share the resource. The
    `unique_ptr` template provides access to the following operators:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 名称`unique_ptr`清楚地表明了模板的意图，即它是指向对象的唯一所有者。这在`auto_ptr`中并不明显。同样，`shared_ptr`清楚地表明了它的意图是共享资源。`unique_ptr`模板提供了对以下操作符的访问：
- en: '**T* get()**: Returns the pointer to the hosted resource.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**T* get()**：返回指向托管资源的指针。'
- en: '`true` if the instance manages a resource. (`get() != nullptr`).'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果实例管理资源，则为`true`（`get() != nullptr`）。
- en: '`lvalue` reference to the hosted resource. Same as `*get()`.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对托管资源的`lvalue`引用。与`*get()`相同。
- en: '`get()`.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get()`。'
- en: '`unique_ptr(new [])`, it provides access to the hosted array as if it were
    natively an array. Returns an `lvalue` reference so that the value can be set
    and get.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unique_ptr(new [])`，它提供对托管数组的访问，就像它本来是一个数组一样。返回一个`lvalue`引用，以便可以设置和获取值。'
- en: std::shared_ptr
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: std::shared_ptr
- en: A shared pointer is used when you want to share the ownership of a resource.
    Why would you do this? Several scenarios would lend themselves well to the sharing
    of resources, such as in the case of a GUI program, where you would probably want
    to share the font objects, bitmap objects, and so on. The **GoF flyweight design
    pattern** would be another example.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要共享资源的所有权时，可以使用共享指针。为什么要这样做？有几种情况适合共享资源，比如在GUI程序中，您可能希望共享字体对象、位图对象等。**GoF飞行权重设计模式**就是另一个例子。
- en: '`std::shared_ptr` provides all of the same facilities as `std::unique_ptr`,
    but with more overhead because it now has to track a reference count for the object.
    All of the operators described for `std::unique_ptr` are available for use on
    `std::shared_ptr`. One difference is that the recommended method to create a `std::shared_ptr`
    is to call `std::make_shared<>()`.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::shared_ptr`提供了与`std::unique_ptr`相同的所有功能，但因为现在必须为对象跟踪引用计数，所以有更多的开销。所有在`std::unique_ptr`中描述的操作符都可以用在`std::shared_ptr`上。一个区别是创建`std::shared_ptr`的推荐方法是调用`std::make_shared<>()`。'
- en: 'When writing libraries or factories, the author of the library will not always
    know how a user will want to use the objects that have been created, so the recommendation
    is to return `unique_ptr<T>` from your factory methods. The reason for this is
    that the user can easily convert a `std::unique_ptr` into a `std::shared_ptr`
    by assignment:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写库或工厂时，库的作者并不总是知道用户将如何使用已创建的对象，因此建议从工厂方法返回`unique_ptr<T>`。原因是用户可以通过赋值轻松地将`std::unique_ptr`转换为`std::shared_ptr`：
- en: '[PRE34]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This will transfer ownership and leave `unique_obj` empty.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这将转移所有权并使`unique_obj`为空。
- en: Note
  id: totrans-328
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Once a resource has been made a shared resource, it cannot be reverted into
    a unique object.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦资源被作为共享资源，就不能将其恢复为唯一对象。
- en: std::weak_ptr
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: std::weak_ptr
- en: 'A weak pointer is a variant of a shared pointer, but it doesn''t hold a reference
    count to the resource. So, it does not prevent it from being released when the
    count goes to zero. Consider the following program structure, which may occur
    within a normal graphical user interface (GUI):'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 弱指针是共享指针的一种变体，但它不持有资源的引用计数。因此，当计数降为零时，它不会阻止资源被释放。考虑以下程序结构，它可能出现在正常的图形用户界面（GUI）中：
- en: '[PRE35]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When executed, it outputs the following:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，输出如下：
- en: '![Figure 3.25: Weak pointer program output](img/C14583_03_25.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![图3.25：弱指针程序输出](img/C14583_03_25.jpg)'
- en: 'Figure 3.25: Weak pointer program output'
  id: totrans-335
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.25：弱指针程序输出
- en: 'This shows that the panel and the `textwindow` were not destroyed when the
    app exited. This is because they both held a `shared_ptr` to each other and so
    the reference count for both would not go to zero and trigger the destruction.
    If we depict the structure diagrammatically, then we can see that it has a `shared_ptr`
    cycle:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明当应用程序退出时，面板和`textwindow`都没有被销毁。这是因为它们彼此持有`shared_ptr`，因此两者的引用计数不会降为零并触发销毁。如果我们用图表表示结构，那么我们可以看到它有一个`shared_ptr`循环：
- en: '![Figure 3.26: weak_ptr and shared_ptr cycles](img/C14583_03_26.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![图3.26：弱指针和共享指针循环](img/C14583_03_26.jpg)'
- en: 'Figure 3.26: weak_ptr and shared_ptr cycles'
  id: totrans-338
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.26：弱指针和共享指针循环
- en: Smart Pointers and Calling Functions
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 智能指针和调用函数
- en: 'Now that we can manage our resources, how do we use them? Do we pass around
    the smart pointers? When we have a smart pointer (`unique_ptr` or `shared_ptr`),
    we have four options when calling a function:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以管理我们的资源了，我们如何使用它们？我们传递智能指针吗？当我们有一个智能指针（`unique_ptr`或`shared_ptr`）时，在调用函数时有四个选项：
- en: Pass the smart pointer by value
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过值传递智能指针
- en: Pass the smart pointer by reference
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过引用传递智能指针
- en: Pass the managed resource by pointer
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过指针传递托管资源
- en: Pass the managed resource by reference
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过引用传递托管资源
- en: 'This is not an exhaustive list but are the main ones to consider. The answer
    to how we pass the smart pointer, or its resource, depends on our intent with
    the call to the function:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个详尽的列表，但是主要考虑的。我们如何传递智能指针或其资源的答案取决于我们对函数调用的意图：
- en: Is the intend of the function to just use the resource?
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的意图是仅仅使用资源吗？
- en: Does the function take ownership of the resource?
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数是否接管资源的所有权？
- en: Does the function replace the managed object?
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数是否替换托管对象？
- en: 'If the function is just going to `use the resource`, then it does not even
    need to know that it is being handed a managed resource. It simply needs to use
    it and should be called using the resource by pointer, or resource by reference
    (or even resource by value):'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数只是要`使用资源`，那么它甚至不需要知道它正在使用托管资源。它只需要使用它，并且应该通过指针、引用（甚至值）调用资源：
- en: '[PRE36]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If you want to `pass the ownership` of the resource to the function, then the
    function should be called by smart pointer by value and called using `std::move()`:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将资源的所有权传递给函数，那么函数应该通过智能指针按值调用，并使用`std::move()`调用：
- en: '[PRE37]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When `do_something()` returns, the `res` variable will be empty, and the resource
    is now owned by `do_something()`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 当`do_something()`返回时，`res`变量将为空，资源现在由`do_something()`拥有。
- en: 'If you want to `replace the managed object` (a process known as **reseating**),
    then you pass the smart pointer by reference:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要`替换托管对象`（一个称为**重新安置**的过程），那么你通过引用传递智能指针：
- en: '[PRE38]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following program puts all of this together to demonstrate each scenario
    and how to call the function:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序将所有内容整合在一起，演示了每种情况以及如何调用函数：
- en: '[PRE39]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When we run this program, we receive the following output:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个程序时，我们会收到以下输出：
- en: '![](img/C14583_03_27.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14583_03_27.jpg)'
- en: 'Figure 3.27: Ownership passing Program output'
  id: totrans-360
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.27：所有权传递程序输出
- en: Note
  id: totrans-361
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'The *C++ Core Guidelines* has a whole section on *resource management*, smart
    pointers, and how to use them here: [http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-resource](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-resource).
    We have only touched on the most important that are aspects covered by the guidelines.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '*C++核心指南*有一个完整的部分涉及*资源管理*、智能指针以及如何在这里使用它们：[http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-resource](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-resource)。我们只触及了指南涵盖的最重要的方面。'
- en: 'Exercise 4: Implementing RAII with STL Smart Pointers'
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习4：使用STL智能指针实现RAII
- en: 'In this exercise, we will implement a sensor factory method that returns the
    sensor resource via a `unique_ptr`. We will implement a `unique_ptr` to hold an
    array, and then develop code that converts a `unique_ptr` into a shared pointer
    and then shares it some more. Follow these steps to implement this exercise:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实现一个传感器工厂方法，通过`unique_ptr`返回传感器资源。我们将实现一个`unique_ptr`来持有一个数组，然后开发代码将`unique_ptr`转换为共享指针，然后再分享它。按照以下步骤实现这个练习：
- en: Open the **Lesson3** project in Eclipse. Then in the **Project Explorer**, expand
    **Lesson3**, then **Exercise04**, and double-click on **Exercise4.cpp** to open
    the file for this exercise into the editor.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse中打开**Lesson3**项目。然后在**项目资源管理器**中展开**Lesson3**，然后**Exercise04**，双击**Exercise4.cpp**以将此练习的文件打开到编辑器中。
- en: Click on the **Launch Configuration** drop-down menu and select **New Launch
    Configuration…**. Configure the **L3Exercise4** application from the **Search
    Project** menu so that it runs with the name **L3Exercise4**.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**启动配置**下拉菜单，选择**新启动配置...**。从**搜索项目**菜单中配置**L3Exercise4**应用程序，以便它以名称**L3Exercise4**运行。
- en: 'Click on the **Run** button to run Exercise 4\. This will produce the following
    output:![Figure 3.28: Exercise 4 output](img/C14583_03_28.jpg)'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行**按钮运行练习4。这将产生以下输出：![图3.28：练习4输出](img/C14583_03_28.jpg)
- en: 'Figure 3.28: Exercise 4 output'
  id: totrans-368
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.28：练习4输出
- en: In the editor, examine the code, particularly the factory method, that is, `createSensor(type)`.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，检查代码，特别是工厂方法，即`createSensor(type)`。
- en: '[PRE40]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This creates an empty unique pointer named sensor, and then resets the contained
    pointer with the desired sensor according to the passed in `type`.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为sensor的空unique指针，然后根据传入的`type`重置包含的指针以获取所需的传感器。
- en: 'Open Exercise4.cpp in the editor and change the line near the top of the file
    to read like so:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开Exercise4.cpp，并将文件顶部附近的行更改为以下内容：
- en: '[PRE41]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Click on the `unique_ptr` to a `shared_ptr` and that is not allowed.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`unique_ptr`到`shared_ptr`是不允许的。
- en: 'Locate the line reporting the error and change it to read like so:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到报告错误的行，并将其更改为以下内容：
- en: '[PRE42]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Click on the `light` (a `unique_ptr`) to `light2` (a `shared_ptr`). The problem
    is actually the template method:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`light`（一个`unique_ptr`）到`light2`（一个`shared_ptr`）。问题实际上是模板方法：
- en: '[PRE43]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The first argument is passed by value, which means that a new copy of the `shared_ptr`
    will be created and passed to the method for printing.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是按值传递的，这意味着将创建`shared_ptr`的新副本并传递给方法进行打印。
- en: 'Let''s fix that now by changing the template to pass-by-reference. Click on
    the **Run** button to compile and run the program. The following output is generated:![Figure
    3.31: Corrected printSharedPointer output](img/C14583_03_31.jpg)'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们通过将模板更改为按引用传递来修复这个问题。点击**Run**按钮编译和运行程序。生成以下输出：![图3.31：已更正的printSharedPointer输出](img/C14583_03_31.jpg)
- en: 'Figure 3.31: Corrected printSharedPointer output'
  id: totrans-381
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.31：已更正的printSharedPointer输出
- en: 'Open **Exercise4.cpp** in the editor and change the line near the top of the
    file to read like so:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开**Exercise4.cpp**，并将文件顶部附近的行更改为以下内容：
- en: '[PRE44]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Click on the **Run** button to compile and run the program. The following output
    is generated:![](img/C14583_03_32.jpg)
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Run**按钮编译和运行程序。生成以下输出：![](img/C14583_03_32.jpg)
- en: 'Figure 3.32: Annotated Step 12 output for Exercise 4'
  id: totrans-385
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.32：Exercise 4的注释步骤12输出
- en: Compare the output with the code in the `testSensors()` method. We'll find that
    we can easily assign to an empty `unique_ptr` (`light`) and that we can assign
    from one `shared_ptr` to another (`light3 = light2`) without the need for `std::move()`
    in either case.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将输出与`testSensors()`方法中的代码进行比较。我们会发现可以轻松地将空的`unique_ptr`（`light`）分配给另一个，并且可以在不需要在任何情况下使用`std::move()`的情况下从一个`shared_ptr`分配给另一个（`light3
    = light2`）。
- en: 'Open **Exercise4.cpp** in the editor and change the line near the top of the
    file to read like so:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开**Exercise4.cpp**，并将文件顶部附近的行更改为以下内容：
- en: '[PRE45]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Click on the **Run** button to compile and run the program. The output switches
    to the following:![Figure 3.33: Managing arrays in unique_ptr](img/C14583_03_33.jpg)'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Run**按钮编译和运行程序。输出切换为以下内容：![图3.33：在unique_ptr中管理数组](img/C14583_03_33.jpg)
- en: 'Figure 3.33: Managing arrays in unique_ptr'
  id: totrans-390
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.33：在unique_ptr中管理数组
- en: 'Open the editor and find the `testArrays()` method:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中找到`testArrays()`方法：
- en: '[PRE46]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: There are several things to note in this snippet of code. Firstly, the type
    is declared as `int[]`. We have chosen `int` for this exercise, but it could be
    just about any type. Secondly, when `unique_ptr` (and `shared_ptr` since C++ 17)
    is used to manage an array, `operator[]` is defined. So, we simulate a two-dimensional
    array by calculating a one-dimensional index from the two-dimensional indices'
    `board[i*8+j]`.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中有几点需要注意。首先，类型声明为`int[]`。我们在这个练习中选择了`int`，但它可以是几乎任何类型。其次，当使用`unique_ptr`（自C++
    17以来也是`shared_ptr`）来管理数组时，定义了`operator[]`。因此，我们通过从二维索引的`board[i*8+j]`计算出一维索引来模拟二维数组。
- en: 'Edit the first line of the method and declare the `auto` type:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑方法的第一行并声明`auto`类型：
- en: '[PRE47]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Click on the `make_unique()` call.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`make_unique()`调用。
- en: In this exercise, we implemented a factory function that served up manufactured
    sensors using `unique_ptr` to manage the lifetime of the sensor. We then implemented
    code to change it from a `unique_ptr` and share it to several objects. Finally,
    we developed a `unique_ptr` technique to manage a multi-dimensional array using
    a single-dimensional array.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们实现了一个工厂函数，使用`unique_ptr`来管理传感器的生命周期。然后，我们实现了将其从`unique_ptr`更改为共享到多个对象。最后，我们开发了一种使用单一维数组来管理多维数组的`unique_ptr`技术。
- en: Rule of Zero/Five – A Different Perspective
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 零/五法则-不同的视角
- en: 'When we introduced `BufferedWriter`, it had two resources being managed: memory
    and a file. We then discussed how the default compiler generated copy operations
    that are what are known as shallow copies. We talked about how we could manage
    the resources differently – stop the copy, perform a deep copy, or transfer ownership.
    What we decide to do in these circumstances is known as resource management policy.
    The policy that you choose, impacts how you execute the `Rule of Zero/Five`.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们引入`BufferedWriter`时，它管理了两个资源：内存和文件。然后我们讨论了默认编译器生成的浅拷贝操作。我们谈到了我们可以以不同的方式管理资源-停止复制，执行深拷贝，或者转移所有权。在这些情况下我们决定如何做被称为资源管理策略。您选择的策略将影响您如何执行`零/五法则`。
- en: 'In terms of resource management, a class can manage no resources, manage a
    resource that can be copied but not moved, manage a resource that can be moved
    but not copied, or manage a resource that should be neither copied nor moved.
    The following classes show how these may be expressed:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在资源管理方面，一个类可以管理零个资源，管理可以复制但不能移动的资源，管理可以移动但不能复制的资源，或者管理不应复制也不应移动的资源。以下类显示了如何表达这些类别：
- en: '[PRE48]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Because of the complexity of managing resources in all contexts and under exceptions,
    the best practice is that if a class is responsible for managing a resource, then
    that class is only responsible for managing that resource.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在所有上下文和异常下管理资源的复杂性，最佳实践是，如果一个类负责管理资源，那么该类只负责管理该资源。
- en: 'Activity 1: Implementing Graphics Processing with RAII and Move'
  id: totrans-403
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动1：使用RAII和Move实现图形处理
- en: 'In *Chapter 2A*, *No Ducks Allowed – Types and Deduction*, your team worked
    hard and got the implementation of `Point3d` and `Matrix3d`. Now, your company
    wants to market the library and it needs two major improvements before they can
    do that:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第2A章*，*不允许鸭子-类型和推断*中，您的团队努力工作并实现了`Point3d`和`Matrix3d`。现在，您的公司希望在推出之前对库进行两项重大改进：
- en: The classes must be in a namespace for our company, that is, Advanced C Plus
    Plus Inc. So, the namespace for the graphics will be `accp::gfx`.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公司的类必须在一个命名空间中，即Advanced C Plus Plus Inc.因此，图形的命名空间将是`accp::gfx`。
- en: The storage for the matrices in `Point3d` and `Matrix3d` is an intrinsic part
    of the class and so it is allocated from the stack and not the heap. As an evolution
    in the library matrix support, we need to allocate the memory from the heap. As
    we are working toward implementing larger matrices in a future release, we also
    want to introduce move semantics into our classes.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Point3d`和`Matrix3d`中矩阵的存储是类的固有部分，因此它是从堆栈而不是堆中分配的。作为库矩阵支持的演变，我们需要从堆中分配内存。因为我们正在努力实现更大的矩阵在未来的版本中，我们还希望在我们的类中引入移动语义。'
- en: 'Follow these steps to achieve this:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现这一点：
- en: Starting with our current version of the library (this can be found in the `acpp::gfx`
    namespace.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们当前版本的库开始（可以在`acpp::gfx`命名空间中找到。
- en: Fix all the failing tests because of the change. (Fail could mean a failure
    to compile, not just running the test.)
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修复所有因更改而失败的测试。（失败可能意味着编译失败，而不仅仅是运行测试。）
- en: In `Matrix3d`, switch from declaring the matrix directly in the class to heap
    allocated memory for storage.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Matrix3d`中，从在类中直接声明矩阵切换到堆分配的存储器。
- en: Fix the failing tests by implementing a deep copy implementation of the copy
    constructor and copy assignment operators. Make any other changes necessary to
    adjust to the new internal representations. Note that you should not need to modify
    any tests to get them to pass they only access the public interface which means
    we can change the internal structure without affecting the client.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过实现复制构造函数和复制赋值运算符的深度复制实现来修复失败的测试。进行其他必要的更改以适应新的内部表示。请注意，您不需要修改任何测试来使其通过，因为它们只访问公共接口，这意味着我们可以更改内部结构而不影响客户端。
- en: Trigger another failure by forcing a move constructor to be called in `CreateTranslationMatrix()`
    by using `std::move` in the return statement. Introduce the required move operations
    in the `Matrix3d` class to get the tests to compile and pass.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`CreateTranslationMatrix()`中使用`std::move`强制调用移动构造函数来触发另一个失败。在`Matrix3d`类中引入所需的移动操作以使测试能够编译并通过。
- en: Repeat steps 3 to 4 for `Point3d`.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤3到4，针对`Point3d`。
- en: 'After implementing the preceding steps, the expected output would look unchanged
    from the start:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现上述步骤后，预期的输出看起来与开始时没有变化：
- en: '![Figure 3.34: Activity 1 output after successful conversion to use RAII](img/C14583_03_34.jpg)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![图3.34：成功转换为使用RAII后的活动1输出](img/C14583_03_34.jpg)'
- en: 'Figure 3.34: Activity 1 output after successful conversion to use RAII'
  id: totrans-416
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.34：成功转换为使用RAII后的活动1输出
- en: Note
  id: totrans-417
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found on page: 657.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在第657页找到。
- en: When is a Function Called?
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 何时调用函数？
- en: All the operations that are performed by a C++ program are essentially function
    calls (although the compiler may optimize these into inline sequences of operations).
    However, it may not be obvious that you are making a function call due to `a =
    2 + 5`, you are essentially calling `operator=(&a, operator+(2, 5))`. It is just
    that the language allows us to write the first form, but the second form allows
    us to overload operators and extend these capabilities to user-defined types.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: C++程序执行的所有操作本质上都是函数调用（尽管编译器可能会将这些优化为内联操作序列）。但是，由于`a = 2 + 5`，你可能不会意识到自己在进行函数调用，实际上你在调用`operator=(&a,
    operator+(2, 5))`。只是语言允许我们写第一种形式，但第二种形式允许我们重载运算符并将这些功能扩展到用户定义的类型。
- en: 'The following mechanisms result in calls to a function:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 以下机制会导致对函数的调用：
- en: Explicit call to a function.
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式调用函数。
- en: All operators such as +, -, *, /, %, and so on along with new/delete.
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有运算符，如+，-，*，/，%，以及new/delete。
- en: Declaration of variables – will result in a call to the constructors with arguments
    if the initialization values are present.
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量的声明-如果存在初始化值，则会导致对带有参数的构造函数的调用。
- en: User-defined literals – We have not dealt with these, but essentially, we define
    an overload for the `type operator "" name(argument)`. We can then write things
    such as 10_km, which make our code easier to understand as it carries semantic
    information.
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户定义的字面量-我们还没有处理这些，但基本上，我们为`type operator "" name(argument)`定义了一个重载。然后我们可以写诸如10_km之类的东西，这样可以使我们的代码更容易理解，因为它携带了语义信息。
- en: Casting from one value to another (`static_cast<>`, `const_cast<>`, `reinterpret_cast<>`,
    and `dynamic_cast<>`). Again, we have another operator overload which allows us
    to convert from one type into another.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一个值转换为另一个值（`static_cast<>`，`const_cast<>`，`reinterpret_cast<>`和`dynamic_cast<>`）。再次，我们有另一个运算符重载，允许我们将一种类型转换为另一种类型。
- en: During function overload, it may be necessary to convert one type into another
    so that it matches the function prototype. It can do this by either calling a
    constructor with the right argument type to create a temporary or through a cast
    operator that's called implicitly.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数重载期间，可能需要将一种类型转换为另一种类型，以使其与函数原型匹配。它可以通过调用具有正确参数类型的构造函数来创建临时对象，或者通过隐式调用的转换运算符来实现。
- en: Each and every one of these results in the compiler determine that a function
    must be called. Having determined that a function needs to be called, it must
    find the function that matches the name and arguments. This is what we'll be discussing
    in the next section.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 每一个结果都会让编译器确定必须调用一个函数。确定需要调用一个函数后，必须找到与名称和参数匹配的函数。这是我们将在下一节讨论的内容。
- en: Which Function to Call
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用哪个函数
- en: 'In *Chapter 2A*, *No Ducks Allowed – Types and Deduction*, we saw that function
    overload resolution was performed as follows:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第2A章*，*不允许鸭子 - 类型和推断*中，我们看到函数重载解析是按以下方式执行的：
- en: '![Figure 3.35: Function overload resolution](img/C14583_03_35.jpg)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![图3.35：函数重载解析](img/C14583_03_35.jpg)'
- en: 'Figure 3.35: Function overload resolution'
  id: totrans-432
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.35：函数重载解析
- en: 'What we really did not dig into was the concept of name lookup. At some point
    the compiler will encounter the following call to the `func` function:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正没有深入研究的是名称查找的概念。在某个时刻，编译器将遇到对`func`函数的以下调用：
- en: '[PRE49]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: When this happens, it must associate its name with the declaration that introduced
    it. This process is called **name lookup**. This name lookup is true for all the
    items in the program (variables, namespaces, classes, functions, function templates,
    and templates). For the program to compile, the name lookup process for variables,
    namespaces and classes must produce a single declaration. However, for functions
    and function templates the compiler may associate multiple declarations with the
    same name – mainly through function overloads which may be extended to consider
    additional functions due to **Argument-dependent Lookup** (**ADL**).
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种情况发生时，它必须将其名称与引入它的声明关联起来。这个过程称为**名称查找**。这种名称查找对程序中的所有项目（变量、命名空间、类、函数、函数模板和模板）都适用。为了使程序编译通过，变量、命名空间和类的名称查找过程必须产生一个单一的声明。然而，对于函数和函数模板，编译器可以将多个声明与相同的名称关联起来
    - 主要是通过函数重载，可以通过**参数依赖查找**（**ADL**）考虑到额外的函数。
- en: Identifiers
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标识符
- en: As defined in the C++ standard, an **identifier** is a sequence of uppercase
    and lowercase Latin letters, digits, underscores, and most Unicode characters.
    A valid identifier must begin with a non-digit character and is arbitrarily long
    and case-sensitive. Every character is significant.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 根据C++标准的定义，**标识符**是一系列大写和小写拉丁字母、数字、下划线和大多数Unicode字符。有效的标识符必须以非数字字符开头，长度任意长且区分大小写。每个字符都是有意义的。
- en: Names
  id: totrans-438
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 名称
- en: 'A **name** is used to refer to an entity or to a label. A name is of one of
    the following forms:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '**名称**用于引用实体或标签。名称可以是以下形式之一：'
- en: An identifier
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符
- en: An overloaded operator name in function notation (e.g. operator-, operator delete)
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数符号重载的运算符名称（例如operator-，operator delete）
- en: A template name followed by its argument list (vector<int>)
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板名称后跟其参数列表（vector<int>）
- en: A user-defined conversion function name (operator float)
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户定义的转换函数名称（operator float）
- en: A user-defined literal operator name (operator ""_ms)
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户定义的字面量运算符名称（operator ""_ms）
- en: Every entity and its name is introduced by a declaration while a name for a
    label is introduced by either a **goto** statement or by a labeled statement.
    A name can be used multiple times in one file (or translation unit) to refer to
    different entities depending on the scope. A name may also be used to refer to
    the same entity across multiple files (translation units), or different entities,
    depending upon the linkage. The compiler uses name lookup to associate a declaration
    that introduces a name with an unknown name in the program through **name lookup**.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 每个实体及其名称都是由声明引入的，而标签的名称是由**goto**语句或标记语句引入的。一个名称可以在一个文件（或翻译单元）中多次使用，以依赖于作用域而引用不同的实体。一个名称也可以用来引用跨多个文件（翻译单元）相同的实体，或者根据链接性引用不同的实体。编译器使用名称查找通过**名称查找**将引入名称的声明与程序中的未知名称关联起来。
- en: Name lookup
  id: totrans-446
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 名称查找
- en: 'The name lookup process is one of two and is – selected based on the context:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 名称查找过程是两种之一，并且是根据上下文选择的：
- en: '`::`, or possibly after `::`, followed by the `template` keyword. A qualified
    name may refer to a namespace member, class member or enumerator. The name to
    the left of the `::` operator defines the scope to lookup the name from. If there
    is no name, then the global namespace is used.'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`::`，或者可能在`::`之后，跟着`template`关键字。限定名可以指代命名空间成员、类成员或枚举器。`::`运算符左边的名称定义了要从中查找名称的作用域。如果没有名称，那么就使用全局命名空间。'
- en: '**Unqualified name lookup**: Everything else. In this case, name lookup examines
    the current scope and all enclosing scopes.'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未经限定名称查找**：其他所有情况。在这种情况下，名称查找检查当前作用域和所有封闭作用域。'
- en: If the unqualified name is left of the function-call operator, '`()`' then it
    uses Argument-Dependent Lookup.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未经限定的名称位于函数调用运算符'`()`'的左侧，则使用参数依赖查找。
- en: Argument-Dependent Lookup
  id: totrans-451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖参数的查找
- en: The set of rules for looking up unqualified function names is called `Argument-dependent
    lookup` (known as ADL), or `Koenig lookup` (named after Andrew Koenig, who defined
    it and is a longtime member of the C++ standards committee). Unqualified function
    names can appear as either a function-call expression or as part of an implicit
    function call to an overloaded operator.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 查找未经限定的函数名的规则集称为“参数依赖查找”（简称ADL），或者“Koenig查找”（以Andrew Koenig命名，他定义了它，并且是C++标准委员会的资深成员）。未经限定的函数名可以出现为函数调用表达式，也可以作为对重载运算符的隐式函数调用的一部分。
- en: 'ADL basically says that in addition to the scopes and namespaces considered
    during unqualified name lookup, the "associated namespaces" of all the arguments
    and template parameters are also considered. Consider the following code:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: ADL基本上表示，在未经限定名称查找期间考虑的作用域和命名空间之外，还考虑所有参数和模板参数的“关联命名空间”。考虑以下代码：
- en: '[PRE50]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'When we compile this code and run it, the output is as expected:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编译这段代码并运行它时，输出结果如预期的那样：
- en: '[PRE51]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This is an unusual way to write the program. Typically, it would be written
    like so:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种不寻常的编写程序的方式。通常，它会被这样编写：
- en: '[PRE52]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We are using the strange method of calling `endl()` to show ADL. But there are
    two ADL lookups occurring here.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用调用`endl()`来展示ADL的奇怪方法。但是这里发生了两次ADL查找。
- en: The first function call that undergoes ADL is `std::cout << welcome`, which
    the compiler considers to be `operator<<(std::cout, welcome)`. The name operator,
    <<, is now looked up in the available scopes and the namespace of its arguments
    – `std`. This additional namespace resolves the name to the free method, that
    is, `std::operator<<(ostream& os, string& s)`, that's declared in the string header.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个经历ADL的函数调用是`std::cout << welcome`，编译器认为这是`operator<<(std::cout, welcome)`。现在，操作符<<在可用范围和其参数的命名空间`std`中被查找。这个额外的命名空间将名称解析为自由方法，即在字符串头文件中声明的`std::operator<<(ostream&
    os, string& s)`。
- en: The second call is more obvious `endl(std::cout)`. Again, the compiler can access
    the std namespace to resolve this name lookup and finds the `std::endl` template
    in the header `ostream` (included in `iostream`).
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个调用更明显`endl(std::cout)`。同样，编译器可以访问std命名空间来解析这个名称查找，并在头文件`ostream`（包含在`iostream`中）中找到`std::endl`模板。
- en: Without ADL, the compiler has no way to find either of these functions, because
    they are free functions that are made known to us by the iostream and string packages.
    The magic of the insertion operator (<<) would be lost and it would be tedious
    for the programmer, if we were forced to write `std::operator<<(std::cout, welcome)`.
    It would be even worse if you consider chained insertions. Alternatively, you
    could write "`using namespace std;`". Neither of those options is ideal, and that
    is why we need ADL (Koenig lookup).
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 没有ADL，编译器无法找到这两个函数，因为它们是由iostream和string包提供的自由函数。插入操作符（<<）的魔力将会丢失，如果我们被迫写`std::operator<<(std::cout,
    welcome)`，对程序员来说将会很繁琐。如果考虑到链式插入，情况会更糟。或者，您可以写"`using namespace std;`"。这两种选项都不理想，这就是为什么我们需要ADL（Koenig查找）。
- en: Caveat Emptor
  id: totrans-463
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 买家当心
- en: 'We have seen how ADL makes life easier for the programmer by including namespaces
    related to the function argument types. However, this lookup capability does not
    come without risk which, for the most part we can minimize. Consider the following
    sample code:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到ADL通过包含与函数参数类型相关的命名空间，使程序员的生活更加轻松。然而，这种查找能力并非没有风险，大部分情况下我们可以将风险降到最低。考虑以下示例代码：
- en: '[PRE53]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'When we compile and run the preceding program, we get the expected output:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编译和运行上述程序时，我们得到了预期的输出：
- en: '![Figure 3.36: ADL Sample program output](img/C14583_03_36.jpg)'
  id: totrans-467
  prefs: []
  type: TYPE_IMG
  zh: '![图3.36：ADL示例程序输出](img/C14583_03_36.jpg)'
- en: 'Figure 3.36: ADL Sample program output'
  id: totrans-468
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.36：ADL示例程序输出
- en: 'The C++ standards committee then decides that it should introduce an `is_substring()`
    function that looks like this:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准委员会随后决定引入一个`is_substring()`函数，看起来像这样：
- en: '[PRE54]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If we add this to the top of our file, compile it and re-run it, we now get
    the following output:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将其添加到文件顶部，编译并重新运行，现在我们得到以下输出：
- en: '![Figure 3.37: ADL issue program output](img/C14583_03_37.jpg)'
  id: totrans-472
  prefs: []
  type: TYPE_IMG
  zh: '![图3.37：ADL问题程序输出](img/C14583_03_37.jpg)'
- en: 'Figure 3.37: ADL issue program output'
  id: totrans-473
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.37：ADL问题程序输出
- en: Thanks to ADL, the (next C++ standard) compiler has picked up a different implementation
    as a better fit for the unqualified function call of `is_substring()`. And because
    of implicit conversion of arguments it does not clash which would cause an ambiguity
    and a compiler error. It just silently adopts to the new method which could lead
    to subtle and hard to find bugs if the argument order is different. The compiler
    can only detect type and syntactic differences, not semantic ones.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 由于ADL，（下一个C++标准）编译器选择了不同的实现作为`is_substring()`的未限定函数调用的更好选择。并且由于参数的隐式转换，它不会导致歧义和编译器错误。它只是悄悄地采用了新的方法，这可能会导致细微且难以发现的错误，如果参数顺序不同。编译器只能检测类型和语法差异，而不能检测语义差异。
- en: Note
  id: totrans-475
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: For the purposes of demonstrating how ADL works, we have added our function
    to the std namespace. Namespaces serve a purpose of separating concerns, and to
    add into someone else's namespace, in particular, the `Standard Library namespace`
    (`std`) is not good practice.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示ADL的工作原理，我们已将我们的函数添加到std命名空间中。命名空间有一个分离关注点的目的，特别是添加到别人的命名空间，特别是`标准库命名空间`（`std`）是不好的做法。
- en: So, why caveat emptor (buyer beware)? If you use third-party libraries for your
    development (and that includes the C++ Standard Library), then when you upgrade
    the library, you need to ensure that changes to the interface are not going to
    cause you problems because of ADL.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么要买家注意（买家当心）？如果您在开发中使用第三方库（包括C++标准库），那么当您升级库时，您需要确保接口的更改不会因为ADL而导致问题。
- en: 'Exercise 5: Implementing Templates to Prevent ADL Issues'
  id: totrans-478
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习5：实现模板以防止ADL问题
- en: 'In this exercise, we will demonstrate a breaking change in C++17 STL that can
    potentially cause an issue in the wild. C++11 introduced templates for `std::begin(type)`
    and friends. As a developer, this is an appealing expression of the general interface
    and you may have written you own versions for size(type) and empty(type) already.
    Follow these steps to implement this exercise:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将演示C++17 STL中的一个破坏性变化，这可能会在实际中引起问题。C++11引入了`std::begin(type)`和`std::end(type)`的模板。作为开发人员，这是一种对通用接口的吸引人的表达，您可能已经为size(type)和empty(type)编写了自己的版本。按照以下步骤实现这个练习：
- en: Open the **Lesson3** project in Eclipse. Then in the **Project Explorer**, expand
    **Lesson3**, then **Exercise05**, and double-click on **Exercise5.cpp** to open
    the file for this exercise into the editor.
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse中打开**Lesson3**项目。然后在**Project Explorer**中展开**Lesson3**，然后**Exercise05**，双击**Exercise5.cpp**以将此练习的文件打开到编辑器中。
- en: Click on the **Launch Configuration** drop down menu and select **New Launch
    Configuration…**. Configure the **L3Exercise5** application from the Search Project
    menu so that it runs with the name **L3Exercise5**.
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**Launch Configuration**下拉菜单，选择**New Launch Configuration…**。从搜索项目菜单配置**L3Exercise5**应用程序，以便以**L3Exercise5**的名称运行。
- en: 'Click on the **Run** button to run Exercise 5\. This will produce the following
    output:![Figure 3:38: Successful execution of Exercise 5](img/C14583_03_38.jpg)'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**Run**按钮运行Exercise 5。这将产生以下输出：![图3:38：Exercise 5成功执行](img/C14583_03_38.jpg)
- en: 'Figure 3:38: Successful execution of Exercise 5'
  id: totrans-483
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3:38：练习5的成功执行
- en: 'An examination of the code reveals two helper templates:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码检查发现了两个辅助模板：
- en: '[PRE55]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Unlike all the other exercises, this exercise has been configured to build
    under C++ 14\. Open the **CMakeLists.txt** file under **Lesson3** and locate the
    following line:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与所有其他练习不同，此练习已配置为在C++ 14下构建。打开**Lesson3**下的**CMakeLists.txt**文件，并找到以下行：
- en: '[PRE56]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Change `14` to a `17`.
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`14`改为`17`。
- en: 'Click on the **Run** button to compile the exercise which now fails:![Figure
    3.39: Compilation fails under C++ 17 – ambiguous function call](img/C14583_03_39.jpg)'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**Run**按钮编译练习，现在失败：![图3.39：C++ 17下编译失败-模棱两可的函数调用](img/C14583_03_39.jpg)
- en: 'Figure 3.39: Compilation fails under C++ 17 – ambiguous function call'
  id: totrans-490
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.39：C++ 17下编译失败-模棱两可的函数调用
- en: Because the argument to the `empty()` and `size()` templates was a std::vector,
    the ADL pulled in the newly included STL versions of these templates and broke
    our code.
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为`empty()`和`size()`模板的参数是std::vector，ADL引入了新包含的STL版本的这些模板，破坏了我们的代码。
- en: In the `empty()` and two occurrences of `size()` that are generating the errors
    and insert two colons, "`::`", before them (scope specifier).
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`empty()`和两个生成错误的`size()`出现之前，在它们（作用域限定符）之前插入两个冒号“`::`”。
- en: Click on the `empty()` and `size()` function are now qualified. We could have
    equally specified `std::` scope instead.
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击`empty()`和`size()`函数现在已经有了限定。我们也可以指定`std::`作用域。
- en: In this exercise, we implemented two template functions in the global namespace
    that worked fine if we compiled the program under the C++ 14 standard. However,
    our implementation broke when we compiled under C++17 because the STL library
    changed and we had to change our implementation to ensure that the compiler located
    and used the templates that we wrote.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们在全局命名空间中实现了两个模板函数，如果我们在C++ 14标准下编译程序，它们就可以正常工作。然而，当我们在C++17下编译时，我们的实现就会出问题，因为STL库发生了变化，我们必须改变我们的实现，以确保编译器定位并使用我们编写的模板。
- en: Implicit Conversion
  id: totrans-495
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐式转换
- en: In determining the Candidate Set of Function in *Figure 3.36*, *Function overload
    resolution*, the compiler has to look at all of the available functions that have
    been found during the name lookup and determine whether the argument number and
    types match the call point. In determining whether the type matches, it will also
    examine all the available conversions to determine whether there is a mechanism
    to convert from the type T1 type (the type of the argument passed) to the T2 type
    (the type specified for the function parameter). If it can convert from T1 to
    T2 for all arguments, then it will add the function to the set of candidates.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定*图3.36*中的函数候选集时，编译器必须查看所有在名称查找期间找到的可用函数，并确定参数数量和类型是否匹配调用点。在确定类型是否匹配时，它还将检查所有可用的转换，以确定是否有一种机制可以将类型T1类型（传递的参数类型）转换为T2类型（函数参数指定的类型）。如果它可以将所有参数从T1转换为T2，那么它将把函数添加到候选集中。
- en: 'This transformation from type T1 to type T2 is known as **implicit conversion**
    and occurs when some type, T1, is used in an expression or context that does not
    accept that type but accepts some other type, T2\. This occurs in the following
    contexts:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 从类型T1到类型T2的这种转换被称为**隐式转换**，当某种类型T1在不接受该类型但接受其他类型T2的表达式或上下文中使用时发生。这发生在以下情境中：
- en: T1 is passed as an argument when calling a function declared with T2 as the
    parameter.
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: T1作为参数传递时调用以T2为参数声明的函数。
- en: T1 is used as an operand to an operator that expects T2.
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: T1用作期望T2的运算符的操作数。
- en: T1 is used to initialize a new object of T2 (including return statements).
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: T1用于初始化T2的新对象（包括返回语句）。
- en: T1 is used in a `switch` statement (in which case, T2 is an int).
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: T1在`switch`语句中使用（在这种情况下，T2是int）。
- en: T1 is used in an `if` statement or `do-while` or `while` loop (where T2 is bool).
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: T1在`if`语句或`do-while`或`while`循环中使用（其中T2为bool）。
- en: If an unambiguous conversion sequence from T1 to 2 exists, then the program
    will compile. The conversions between built-in types are usually determined by
    the usual arithmetic conversions.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在从T1到2的明确转换序列，则程序将编译。内置类型之间的转换通常由通常的算术转换确定。
- en: Explicit – Preventing Implicit Conversion
  id: totrans-504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显式-防止隐式转换
- en: 'Implicit conversion is a great feature that, make it possible for a programmer
    to express their intent, and it just works most of the time. However, the compiler''s
    ability to convert one type into another without the programmer providing a hint,
    is not always desirable. Consider the following small program:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式转换是一个很好的特性，使程序员能够表达他们的意图，并且大多数时候都能正常工作。然而，编译器在程序员没有提供提示的情况下将一种类型转换为另一种类型的能力并不总是理想的。考虑以下小程序：
- en: '[PRE57]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'When we compile it and run the preceding program, we get the following output:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编译并运行上述程序时，我们得到以下输出：
- en: '![Figure 3.40: Implicit conversion sample program output](img/C14583_03_40.jpg)'
  id: totrans-508
  prefs: []
  type: TYPE_IMG
  zh: '![图3.40：隐式转换示例程序输出](img/C14583_03_40.jpg)'
- en: 'Figure 3.40: Implicit conversion sample program output'
  id: totrans-509
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.40：隐式转换示例程序输出
- en: 'Well, it may be a little unexpected that this compiled and actually produced
    an output. The `real` variable is of the `Real` type which has a conversion operator
    to float – `operator float()`. The `test()` function takes a `bool` as an argument
    and the `if` condition must result in a `bool` as well. The compiler will convert
    any numeric type into a `boolean` type with a value of false if the value is zero
    or true if the value is not zero. But if this is not the behavior that we want
    we can prevent it by prefixing the declaration of the function with the explicit
    keyword. Let''s say we change the line so that it reads like so:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这可能有点出乎意料，它编译并实际产生了输出。`real`变量是`Real`类型，它有一个到float的转换运算符- `operator float()`。`test()`函数以`bool`作为参数，并且`if`条件也必须产生一个`bool`。如果值为零，则编译器将任何数值类型转换为值为false的`boolean`类型，如果值不为零，则转换为true。但是，如果这不是我们想要的行为，我们可以通过在函数声明前加上explicit关键字来阻止它。假设我们更改行，使其读起来像这样：
- en: '[PRE58]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If we now attempt to compile it, we get two errors:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试编译它，我们会得到两个错误：
- en: '![Figure 3.41: Compile errors because implicit conversion was removed.](img/C14583_03_41.jpg)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
  zh: '![图3.41：因为隐式转换被移除而导致的编译错误。](img/C14583_03_41.jpg)'
- en: 'Figure 3.41: Compile errors because implicit conversion was removed.'
  id: totrans-514
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.41：因为隐式转换被移除而导致的编译错误。
- en: Both are related to not being able to convert the Real type into a bool – first,
    at the call site to `test()` and then in the if condition.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都与无法将Real类型转换为bool有关 - 首先是对`test()`的调用位置，然后是if条件中。
- en: Now, let's introduce a bool conversion operator to fix this problem.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们引入一个bool转换操作符来解决这个问题。
- en: '[PRE59]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We can now build the program again. We will receive the following output:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以再次构建程序。我们将收到以下输出：
- en: '![Figure 3.42: Introducing the bool operator replaces implicit conversion](img/C14583_03_42.jpg)'
  id: totrans-519
  prefs: []
  type: TYPE_IMG
  zh: '![图3.42：引入bool运算符替换隐式转换](img/C14583_03_42.jpg)'
- en: 'Figure 3.42: Introducing the bool operator replaces implicit conversion'
  id: totrans-520
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.42：引入bool运算符替换隐式转换
- en: The `boolean` value is now false, whereas it was true before. This is because
    the implicit conversion of the value that was returned by the float conversion
    was not zero and was then converted into true.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '`boolean`值现在为false，而以前为true。这是因为浮点转换返回的值的隐式转换不为零，然后转换为true。'
- en: Since C++ 11, all constructors (except copy and move constructors) have been
    considered to be conversion constructors. This means that if they are not declared
    with explicit, then they are available for implicit conversion. Likewise, any
    casting operator that is not declared explicit is available for implicit conversion.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 自C++ 11以来，所有构造函数（除了复制和移动构造函数）都被认为是转换构造函数。这意味着如果它们没有声明为显式，则它们可用于隐式转换。同样，任何未声明为显式的转换操作符都可用于隐式转换。
- en: 'The `C++ Core Guidelines` has two rules related to implicit conversion:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '`C++核心指南`有两条与隐式转换相关的规则：'
- en: '**C.46**: By default, declare single-argument constructors as explicit'
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C.46**：默认情况下，将单参数构造函数声明为显式'
- en: '**C.164**: Avoid implicit conversion operators'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C.164**：避免隐式转换操作符'
- en: Contextual Conversion
  id: totrans-526
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上下文转换
- en: 'If we now make one further change to our little program, we can get into what
    is known as contextual conversion. Let''s make the bool operator explicit and
    attempt to compile the program:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在对我们的小程序进行进一步的更改，我们就可以进入所谓的上下文转换。让我们将bool运算符设置为显式，并尝试编译程序：
- en: '[PRE60]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We will receive the following output:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将收到以下输出：
- en: '![Figure 3.43: Compile errors with explicit bool operator](img/C14583_03_43.jpg)'
  id: totrans-530
  prefs: []
  type: TYPE_IMG
  zh: '![图3.43：使用显式bool运算符的编译错误](img/C14583_03_43.jpg)'
- en: 'Figure 3.43: Compile errors with explicit bool operator'
  id: totrans-531
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.43：使用显式bool运算符的编译错误
- en: This time we only have one error at the call site to `test()`, but not for the
    if condition. We can fix this error by using a C-style case (bool) or a C++ `static_cast<bool>(real)`
    (this is the preferred method). When we add the cast, the program compiles and
    runs once more.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们只有一个错误，即对`test()`的调用位置，但对if条件没有错误。我们可以通过使用C风格的转换（bool）或C++ `static_cast<bool>(real)`（这是首选方法）来修复此错误。当我们添加转换时，程序再次编译和运行。
- en: So, if the bool cast is explicit, then why does the condition for the if expression
    not need a cast?
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果bool转换是显式的，那么为什么if表达式的条件不需要转换？
- en: 'The C++ standard allows in certain contexts where the `bool` type is expected
    and the declaration for a bool conversion exists (whether marked explicit or not).
    If this happens, then an implicit conversion is allowed. This is known as **contextually
    converting into bool** and can occur in the following contexts:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准允许在某些情况下，如果期望`bool`类型并且存在bool转换的声明（无论是否标记为显式），则允许隐式转换。这被称为**上下文转换为bool**，并且可以出现在以下上下文中：
- en: The condition (or controlling expression) of `if`, `while`, `for`
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if`、`while`、`for`的条件（或控制表达式）'
- en: 'The operands of the built-in logical operators: `!`(not), `&&` (and) and `||`
    (or)'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置逻辑运算符的操作数：`!`（非）、`&&`（与）和`||`（或）
- en: The first operand of the ternary (or conditional) operator `?:`.
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件（或条件）运算符`?:`的第一个操作数。
- en: 'Exercise 6: Implicit and Explicit Conversions'
  id: totrans-538
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习6：隐式和显式转换
- en: 'In this exercise we will experiment with calling functions, implicit conversions,
    preventing them, and enabling them. Follow these steps to implement this exercise:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将尝试调用函数、隐式转换、阻止它们以及启用它们。按照以下步骤实施这个练习：
- en: Open the **Lesson3** project in Eclipse. Then in the **Project Explorer**, expand
    **Lesson3** then **Exercise06** and double click on **Exercise6.cpp** to open
    the file for this exercise into the editor.
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse中打开**Lesson3**项目。然后在**Project Explorer**中展开**Lesson3**，然后展开**Exercise06**，双击**Exercise6.cpp**以在编辑器中打开此练习的文件。
- en: Click on the **Launch Configuration** drop down menu and select **New Launch
    Configuration…**. Configure the **L3Exercise6** application from the **Search
    Project** menu so that it runs with the name **L3Exercise6**.
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**Launch Configuration**下拉菜单，选择**New Launch Configuration…**。从**Search Project**菜单中配置**L3Exercise6**应用程序，以便以**L3Exercise6**的名称运行。
- en: 'Click on the **Run** button to run Exercise 6\. This will produce the following
    output:![Figure 3.44: Default output from Exercise 6](img/C14583_03_44.jpg)'
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**Run**按钮运行练习6。这将产生以下输出：![图3.44：练习6的默认输出](img/C14583_03_44.jpg)
- en: 'Figure 3.44: Default output from Exercise 6'
  id: totrans-543
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.44：练习6的默认输出
- en: 'In the text editor, change the constructor of `Voltage` to be `explicit`:'
  id: totrans-544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中，将`Voltage`的构造函数更改为`explicit`：
- en: '[PRE61]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Click on the **Run** button to recompile the code – now we get the following
    error:![Figure 3.45: Failed conversion of int to Voltage](img/C14583_03_45.jpg)'
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**Run**按钮重新编译代码 - 现在我们得到以下错误：![图3.45：int转换为Voltage失败](img/C14583_03_45.jpg)
- en: 'Figure 3.45: Failed conversion of int to Voltage'
  id: totrans-547
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.45：int转换为Voltage失败
- en: 'Remove the explicit from the constructor and change the `calculate` function
    to take a reference:'
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从构造函数中删除显式，并将`calculate`函数更改为引用：
- en: '[PRE62]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Click on the **Run** button to recompile the code – now, we get the following
    error:![](img/C14583_03_46.jpg)
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**Run**按钮重新编译代码 - 现在，我们得到以下错误：![](img/C14583_03_46.jpg)
- en: 'Figure 3.46: Failed conversion of int to Voltage&'
  id: totrans-551
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.46：将整数转换为电压&失败
- en: The same line has the problem that we ran previously, but for a different reason.
    So, *implicit conversion only works with value types*.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 同一行出现了我们之前遇到的问题，但原因不同。因此，*隐式转换仅适用于值类型*。
- en: 'Comment out the line generating the error, and then, after the call to `use_float(42)`,
    add the following line:'
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释掉生成错误的行，然后在调用`use_float(42)`之后，添加以下行：
- en: '[PRE63]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Click on the **Run** button to recompile the code – now we get the following
    error:![Figure 3.47: Failed conversion of Voltage to float](img/C14583_03_47.jpg)'
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**Run**按钮重新编译代码-现在我们得到以下错误：![图3.47：电压转换为浮点数失败](img/C14583_03_47.jpg)
- en: 'Figure 3.47: Failed conversion of Voltage to float'
  id: totrans-556
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.47：电压转换为浮点数失败
- en: 'Now, add the following casting operator to the `Voltage` class:'
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将以下转换运算符添加到`Voltage`类中：
- en: '[PRE64]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Click on the **Run** button to recompile the code and run it:![Figure 3.48:
    Successfully converted Voltage to float](img/C14583_03_48.jpg)'
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**Run**按钮重新编译代码并运行它：![图3.48：成功将电压转换为浮点数](img/C14583_03_48.jpg)
- en: 'Figure 3.48: Successfully converted Voltage to float'
  id: totrans-560
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.48：成功将电压转换为浮点数
- en: 'Now, place the `explicit` keyword in front of the cast that we just added and
    click on the **Run** button to recompile the code. Again, we get an error:![Figure
    3.49: Failure to convert Voltage to float](img/C14583_03_49.jpg)'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们刚刚添加的转换前面放置`explicit`关键字，然后单击**Run**按钮重新编译代码。再次出现错误：![图3.49：无法将电压转换为浮点数](img/C14583_03_49.jpg)
- en: 'Figure 3.49: Failure to convert Voltage to float'
  id: totrans-562
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.49：无法将电压转换为浮点数
- en: 'By adding the explicit declaration to the cast, we are preventing the compiler
    from using the conversion operator. Change the line with the error to cast the
    volts variable to a float:'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在转换中添加显式声明，我们可以防止编译器使用转换运算符。将出错的行更改为将电压变量转换为浮点数：
- en: '[PRE65]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Click on the **Run** button to recompile the code and run it.
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**Run**按钮重新编译代码并运行它。
- en: '![Figure 3.50: Conversion of Voltage into float with cast works again](img/C14583_03_50.jpg)'
  id: totrans-566
  prefs: []
  type: TYPE_IMG
  zh: '![图3.50：使用转换将电压转换为浮点数再次成功](img/C14583_03_50.jpg)'
- en: 'Figure 3.50: Conversion of Voltage into float with cast works again'
  id: totrans-567
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.50：使用转换将电压转换为浮点数再次成功
- en: In this exercise, we have seen that implicit conversions can occur between types
    (not references), and that we can control when they happen. Now we know how to
    control these conversions, we can strive to meet the guidelines previously quoted
    `C.46` and `C.164`.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们已经看到了类型（而不是引用）之间可以发生隐式转换，并且我们可以控制它们何时发生。现在我们知道如何控制这些转换，我们可以努力满足先前引用的指南`C.46`和`C.164`。
- en: 'Activity 2: Implementing classes for Date Calculations'
  id: totrans-569
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动2：实现日期计算的类
- en: 'Your team is in charge of developing a library to help with calculations that
    are related to dates. In particular, we want to be able to determine the number
    of days between two dates and given a date, add (or subtract from it) a number
    of days to get a new date. This activity will develop two new types and enhance
    them to ensure that the programmer cannot accidentally have them interact with
    built-in types. Follow these steps to achieve this:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 您的团队负责开发一个库，以帮助处理与日期相关的计算。特别是，我们希望能够确定两个日期之间的天数，并且给定一个日期，添加（或从中减去）一定数量的天数以获得一个新日期。此活动将开发两种新类型并增强它们，以确保程序员不能意外地使它们与内置类型交互。按照以下步骤来实现这一点：
- en: Design and implement a `Date` class that stores the `day`, `month`, and `year`
    as integers.
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计和实现一个`Date`类，将`day`、`month`和`year`作为整数存储。
- en: Add methods to access the internal day, month, and year values.
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加方法来访问内部的天、月和年值。
- en: Define a type, `date_t` to represent the number of days since the `epoch date`
    of 1-Jan-1970.
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个类型`date_t`来表示自1970年1月1日`纪元日期`以来的天数。
- en: Add a method to the `Date` class to convert this into `date_t`.
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`Date`类添加一个方法，将其转换为`date_t`。
- en: Add a method to set the `Date` class from a `date_t` value.
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个方法来从`date_t`值设置`Date`类。
- en: Create a `Days` class that stores the days value.
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个存储天数值的`Days`类。
- en: Add the `addition` operator to `Date` that takes `Days` as an argument.
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Date`添加一个接受`Days`作为参数的`加法`运算符。
- en: Use `explicit` to prevent the addition of numbers.
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`explicit`来防止数字的相加。
- en: Add the `subtraction` operator to return a `Days` value from the `difference`
    of two `Dates`.
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`减法`运算符以从两个`日期`的`差异`返回`Days`值。
- en: 'After following these steps, you should receive the following output:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 在按照这些步骤之后，您应该收到以下输出：
- en: '![Figure 3.51: Output of a successful Date sample application](img/C14583_03_51.jpg)'
  id: totrans-581
  prefs: []
  type: TYPE_IMG
  zh: '![图3.51：成功的日期示例应用程序输出](img/C14583_03_51.jpg)'
- en: 'Figure 3.51: Output of a successful Date sample application'
  id: totrans-582
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.51：成功的日期示例应用程序输出
- en: Note
  id: totrans-583
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 664.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第664页找到。
- en: Summary
  id: totrans-585
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored the lifetime of variables - both automatic and
    dynamic, where they are stored, and when they are destructed. We then used this
    information to develop `RAII` techniques that allow us to almost ignore resource
    management because the automatic variables will clean them up when they are destructed
    even in the presence of an exception. Then, we looked at throwing exceptions and
    catching them so that we can deal with abnormal conditions at the right level.
    From `RAII`, we went into a discussion on the ownership of resources and how `STL`
    smart pointers help us in this area. We discovered that just about everything
    is treated as a function call, thus allowing operator overloading and implicit
    conversions. We discovered the wonderful (or is it awful?) world of `argument-dependent
    lookup` (`ADL`) and how it can potentially trip us up in the future. We now have
    a good understanding of the fundamental features of C++. In the next chapter we
    will start to explore function objects and how they are realized and implemented
    using lambda functions. We will delve further into the offerings of STL and explore
    PIMPLs as we re-visit encapsulation.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了变量的生命周期 - 包括自动变量和动态变量，它们存储在何处，以及它们何时被销毁。然后，我们利用这些信息开发了`RAII`技术，使我们几乎可以忽略资源管理，因为自动变量在被销毁时会清理它们，即使在出现异常的情况下也是如此。然后，我们研究了抛出异常和捕获异常，以便我们可以在正确的级别处理异常情况。从`RAII`开始，我们进入了关于资源所有权的讨论，以及`STL`智能指针如何帮助我们在这个领域。我们发现几乎所有东西都被视为函数调用，从而允许操作符重载和隐式转换。我们发现了“参数相关查找”（`ADL`）的奇妙（或者说糟糕？）世界，以及它如何潜在地在未来使我们陷入困境。我们现在对C++的基本特性有了很好的理解。在下一章中，我们将开始探讨函数对象以及它们如何使用lambda函数实现和实现。我们将进一步深入研究STL的功能，并在重新访问封装时探索PIMPLs。
