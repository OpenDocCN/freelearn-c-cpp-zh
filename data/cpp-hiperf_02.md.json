["```cpp\nstruct Foo {\n  int val() const {    return m_;   }  const int& cref() const {    return m_;   }  int& mref() {    return m_;   }  int m_{};}; \n```", "```cpp\nstruct Foo {\n  auto val() const {    return m_;   }  auto& cref() const {    return m_;   }  auto& mref() {    return m_;   }  int m_{};}; \n```", "```cpp\nauto val() const                // a) auto, deduced type\nauto val() const -> int         // b) auto, trailing type\nint val() const                 // c) explicit type \n```", "```cpp\nauto& cref() const              // a) auto, deduced type\nauto cref() const -> const int& // b) auto, trailing type\nconst int& cref() const         // c) explicit type \n```", "```cpp\nauto& mref()                    // a) auto, deduced type\nauto mref() -> int&             // b) auto, trailing type\nint& mref()                     // c) explicit type \n```", "```cpp\nint val_wrapper() { return val(); }    // Returns int\nint& mref_wrapper() { return mref(); } // Returns int& \n```", "```cpp\nauto val_wrapper() { return val(); }   // Returns int\nauto mref_wrapper() { return mref(); } // Also returns int \n```", "```cpp\ndecltype(auto) val_wrapper() { return val(); }   // Returns int\ndecltype(auto) mref_wrapper() { return mref(); } // Returns int& \n```", "```cpp\nauto i = 0;\nauto x = Foo{};\nauto y = create_object();\nauto z = std::mutex{};     // OK since C++17 \n```", "```cpp\nvoid some_func(const std::string& a, const std::string& b) {\n  const auto& str = a + b;  // a + b returns a temporary\n  // ...\n} // str goes out of scope, temporary will be destroyed \n```", "```cpp\n auto foo = Foo{};\n auto& cref = foo.cref(); // cref is a const reference\n auto& mref = foo.mref(); // mref is a mutable reference \n```", "```cpp\nclass Foo {\npublic:\n  Foo(int* ptr) : ptr_{ptr} {} \n  auto set_ptr_val(int v) const { \n    *ptr_ = v; // Compiles despite function being declared const!\n  }\nprivate:\n  int* ptr_{};\n};\nint main() {\n  auto i = 0;\n  const auto foo = Foo{&i};\n  foo.set_ptr_val(42);\n} \n```", "```cpp\n#include <experimental/propagate_const>\nclass Foo { \npublic: \n  Foo(int* ptr) : ptr_{ptr} {}\n  auto set_ptr(int* p) const { \n    ptr_ = p;  // Will not compile, as expected\n  }\n  auto set_val(int v) const { \n    val_ = v;  // Will not compile, as expected\n  }\n  auto set_ptr_val(int v) const { \n    *ptr_ = v; // Will not compile, const is propagated\n  }\nprivate:\n  std::experimental::propagate_const<int*> ptr_ = nullptr; \n  int val_{}; \n}; \n```", "```cpp\nauto a = Widget{}; \nauto b = a;        // Copy-construction \n```", "```cpp\nauto a = Widget{};\nauto b = Widget{};\nstd::swap(a, b); \n```", "```cpp\nauto a = Widget{}; \nauto b = std::move(a); // Tell the compiler to move the resource into b \n```", "```cpp\nfloats pointed at by the raw pointer ptr_:\n```", "```cpp\nclass Buffer { \npublic: \n  // Constructor \n  Buffer(const std::initializer_list<float>& values)       : size_{values.size()} { \n    ptr_ = new float[values.size()]; \n    std::copy(values.begin(), values.end(), ptr_); \n  }\n  auto begin() const { return ptr_; } \n  auto end() const { return ptr_ + size_; } \n  /* The 5 special functions are defined below */\nprivate: \n  size_t size_{0}; \n  float* ptr_{nullptr};\n}; \n```", "```cpp\n// 1\\. Copy constructor \nBuffer::Buffer(const Buffer& other) : size_{other.size_} { \n  ptr_ = new float[size_]; \n  std::copy(other.ptr_, other.ptr_ + size_, ptr_); \n} \n// 2\\. Copy assignment \nauto& Buffer::operator=(const Buffer& other) {\n  delete [] ptr_;\n  ptr_ = new float[other.size_];\n  size_ = other.size_;\n  std::copy(other.ptr_, other.ptr_ + size_, ptr_);\n  return *this;\n} \n// 3\\. Destructor \nBuffer::~Buffer() { \n  delete [] ptr_; // OK, it is valid to delete a nullptr\n  ptr_ = nullptr;  \n} \n```", "```cpp\nauto func() { \n  // Construct \n  auto b0 = Buffer({0.0f, 0.5f, 1.0f, 1.5f}); \n  // 1\\. Copy-construct \n  auto b1 = b0; \n  // 2\\. Copy-assignment as b0 is already initialized \n  b0 = b1; \n} // 3\\. End of scope, the destructors are automatically invoked \n```", "```cpp\n// 4\\. Move constructor\nBuffer::Buffer(Buffer&& other) noexcept     : size_{other.size_}, ptr_{other.ptr_} {\n  other.ptr_ = nullptr;\n  other.size_ = 0;\n}\n// 5\\. Move assignment\nauto& Buffer::operator=(Buffer&& other) noexcept {\n  ptr_ = other.ptr_;\n  size_ = other.size_;\n  other.ptr_ = nullptr;\n  other.size_ = 0;\n  return *this;\n} \n```", "```cpp\n// The object returned by make_buffer is not tied to a variable\nx = make_buffer();  // move-assigned\n// The variable \"x\" is passed into std::move()\ny = std::move(x);   // move-assigned \n```", "```cpp\nclass Button { \npublic: \n  Button() {} \n  auto set_title(const std::string& s) { \n    title_ = s; \n  } \n  auto set_title(std::string&& s) { \n    title_ = std::move(s); \n  } \n  std::string title_; \n}; \n```", "```cpp\nauto get_ok() {\n  return std::string(\"OK\");\n}\nauto button = Button{}; \n```", "```cpp\n    auto str = std::string{\"OK\"};\n    button.set_title(str);              // copy-assigned \n    ```", "```cpp\n    auto str = std::string{\"OK\"};\n    button.set_title(std::move(str));   // move-assigned \n    ```", "```cpp\n    button.set_title(get_ok());        // move-assigned \n    ```", "```cpp\n    auto str = get_ok();\n    button.set_title(str);             // copy-assigned \n    ```", "```cpp\n    const auto str = get_ok();\n    button.set_title(std::move(str));  // copy-assigned \n    ```", "```cpp\nclass Button {\npublic: \n  Button() {} // Same as before\n\n  // Copy-constructor/copy-assignment \n  Button(const Button&) = default; \n  auto operator=(const Button&) -> Button& = default;\n  // Move-constructor/move-assignment \n  Button(Button&&) noexcept = default; \n  auto operator=(Button&&) noexcept -> Button& = default; \n  // Destructor\n  ~Button() = default; \n  // ...\n}; \n```", "```cpp\nclass Button {\npublic: \n  Button() {} // Same as before\n\n  // Nothing here, the compiler generates everything automatically! \n  // ...\n}; \n```", "```cpp\nclass Button {\npublic: \n  Button() {} \n  ~Button() \n    std::cout << \"destructed\\n\"\n  }\n  // ...\n}; \n```", "```cpp\nstruct Point {\n int x_, y_;\n ~Point() {}     // Empty destructor, don't use!\n};\nauto copy(Point* src, Point* dst) {\n  std::copy(src, src+64, dst);\n} \n```", "```cpp\nstruct Point {\n  int x_, y_;\n};\nauto copy(Point* src, Point* dst) {\n  const auto end = src + 64;\n  for (; src != end; ++src, ++dst) {\n    *dst = *src;\n  }\n} \n```", "```cpp\n xor eax, eax\n.L2:\n mov rdx, QWORD PTR [rdi+rax]\n mov QWORD PTR [rsi+rax], rdx\n add rax, 8\n cmp rax, 512\n jne .L2\n rep ret \n```", "```cpp\nstruct Point { \n  int x_, y_; \n  ~Point() = default; // OK: Use default or no constructor at all\n};\nauto copy(Point* src, Point* dst) {\n  std::copy(src, src+64, dst);\n} \n```", "```cpp\n mov rax, rdi\n mov edx, 512\n mov rdi, rsi\n mov rsi, rax\n jmp memmove \n```", "```cpp\nclass Menu {\npublic:\n  Menu(const std::initializer_list<std::string>& items)       : items_{items} {}\n  auto select(int i) {\n    index_ = i;\n  }\n  auto selected_item() const {\n     return index_ != -1 ? items_[index_] : \"\";\n  }\n  // ...\nprivate:\n  int index_{-1}; // Currently selected item\n  std::vector<std::string> items_; \n}; \n```", "```cpp\nauto a = Menu{\"New\", \"Open\", \"Close\", \"Save\"};\na.select(2);\nauto b = std::move(a);\nauto selected = a.selected_item(); // crash \n```", "```cpp\nMenu(Menu&& other) noexcept { \n  std::swap(items_, other.items_); \n  std::swap(index_, other.index_); \n} \nauto& operator=(Menu&& other) noexcept { \n  std::swap(items_, other.items_); \n  std::swap(index_, other.index_); \n  return *this; \n} \n```", "```cpp\nstruct Foo { \n  auto func() && {} \n}; \nauto a = Foo{}; \na.func();            // Doesn't compile, 'a' is not an rvalue \nstd::move(a).func(); // Compiles \nFoo{}.func();        // Compiles \n```", "```cpp\nauto func() {\n  auto x = X{};\n  // ...\n  return std::move(x);  // Don't, RVO is prevented\n} \n```", "```cpp\nauto func() {\n  auto x = X{};\n  // ...\n  return x;  // OK\n} \n```", "```cpp\n// Argument s is a const reference\nauto str_to_lower(const std::string& s) -> std::string {\n  auto clone = s;\n  for (auto& c: clone) c = std::tolower(c);\n  return clone;\n}\n// Argument s is an rvalue reference\nauto str_to_lower(std ::string&& s) -> std::string {\n  for (auto& c: s) c = std::tolower(c);\n  return s;\n} \n```", "```cpp\nauto str_to_lower(std::string s) -> std::string {\n  for (auto& c: s) c = std::tolower(c);\n  return s;\n} \n```", "```cpp\nauto str = std::string{\"ABC\"};\nstr = str_to_lower(str); \n```", "```cpp\nauto str = std::string{\"ABC\"};\nstr = str_to_lower(std::move(str)); \n```", "```cpp\nclass Widget {\n  std::vector<int> data_{};\n  // ...\npublic:\n  void set_data(std::vector<int> x) { \n    data_ = std::move(x);               \n  }\n}; \n```", "```cpp\nauto v = std::vector<int>{1, 2, 3, 4};\nwidget.set_data(v);                  // Pass an lvalue \n```", "```cpp\nvoid set_data(const std::vector<int>& x) { \n    data_ = x;  // Reuse internal buffer in data_ if possible\n} \n```", "```cpp\nvoid set_data(const std::vector<int>& x) {\n  data_ = x;\n}\nvoid set_data(std::vector<int>&& x) noexcept { \n  data_ = std::move(x);\n} \n```", "```cpp\nclass Widget {\n  std::vector<int> data_;\npublic:\n  Widget(std::vector<int> x)       // By value\n      : data_{std::move(x)} {}     // Move-construct\n  // ...\n}; \n```", "```cpp\nint func(float x, float y) \n```", "```cpp\nstruct Widget {\n  Widget() {\n    // Initialize object\u2026\n    // Check class invariant\n  }\n  ~Widget() {\n    // Check class invariant\n    // Destroy object\u2026\n   }\n   auto some_func() {\n     // Check precondition (including class invariant)\n     // Do the actual work\u2026\n     // Check postcondition (including class invariant)\n   }\n}; \n```", "```cpp\n#ifdef NDEBUG\n#define assert(condition) ((void)0)\n#else\n#define assert(condition) /* implementation defined */\n#endif \n```", "```cpp\nauto load_record(std::uint32_t id) {\n  assert(id != 0);           // Precondition\n  auto record = read(id);    // Read from disk, may throw\n  assert(record.is_valid()); // Postcondition\n  return record;\n} \n```", "```cpp\nauto add(int a, int b) noexcept {\n  return a + b;\n} \n```", "```cpp\nvoid func(std::string& str) {\n  str += f1();  // Could throw\n  str += f2();  // Could throw\n} \n```", "```cpp\nvoid func(std::string& str) {\n  auto tmp = std::string{str};  // Copy\n  tmp += f1();                  // Mutate copy, may throw\n  tmp += f2();                  // Mutate copy, may throw\n  std::swap(tmp, str);          // Swap, never throws\n} \n```", "```cpp\nclass Number { /* ... */ };\nclass Widget {\npublic:\n  Widget(const Number& x, const Number& y) : x_{x}, y_{y} {\n    assert(is_valid());           // Check class invariant\n  }\nprivate:\n  Number x_{};\n  Number y_{};\n  bool is_valid() const {         // Class invariant\n   return x_ != y_;               // x_ and y_ must not be equal\n  }\n}; \n```", "```cpp\nvoid Widget::update(const Number& x, const Number& y) {\n  assert(x != y && is_valid());   // Precondition\n  x_ = x;\n  y_ = y;          \n  assert(is_valid());             // Postcondition\n} \n```", "```cpp\nvoid Widget::update(const Number& x, const Number& y) {\n    assert(x != y && is_valid());     // Precondition\n    auto x_tmp = x;  \n    auto y_tmp = y;  \n    std::swap(x_tmp, x_); \n    std::swap(y_tmp, y_); \n    assert(is_valid());               // Postcondition\n  } \n```", "```cpp\nauto func(std::mutex& m, bool x, bool y) {\n  auto guard = std::scoped_lock{m}; // Lock mutex \n  if (x) { \n    // The guard automatically releases the mutex at early exit\n    return; \n  }\n  if (y) {\n    // The guard automatically releases if an exception is thrown\n    throw std::exception{};\n  }\n  // The guard automatically releases the mutex at function exit\n} \n```", "```cpp\n// Prerequisite \nauto v = std::vector{1, 3, 2, 5, 4}; \n\n// Look for number three \nauto three = 3; \nauto num_threes = std::count(v.begin(), v.end(), three); \n// num_threes is 1 \n\n// Look for numbers which is larger than three \nauto is_above_3 = [](int v) { return v > 3; }; \nauto num_above_3 = std::count_if(v.begin(), v.end(), is_above_3);\n// num_above_3 is 2 \n```", "```cpp\nauto num_3 = std::count(v.begin(), v.end(), 3); \nauto num_above_3 = std::count_if(v.begin(), v.end(), [](int i) { \n  return i > 3; \n}); \n```", "```cpp\nauto count_value_above(const std::vector<int>& v, int x) { \n  auto is_above = [x](int i) { return i > x; }; \n  return std::count_if(v.begin(), v.end(), is_above); \n} \n```", "```cpp\nauto is_above = [&x](int i) { return i > x; }; \n```", "```cpp\nauto func() {\n  auto vals = {1,2,3,4,5,6};\n  auto x = 3;\n  auto is_above = [x](int v) {\n    return v > x;\n  };\n  x = 4;\n  auto count_b = std::count_if(\n    vals.begin(),\n    vals.end(),\n    is_above\n   );  // count_b equals 3 } \n```", "```cpp\nauto func() {\n  auto vals = {1,2,3,4,5,6};\n  auto x = 3;\n  auto is_above = [&x](int v) {\n    return v > x;\n  };\n  x = 4;\n  auto count_b = std::count_if(\n    vals.begin(),\n    vals.end(),\n    is_above\n   );  // count_b equals 2 } \n```", "```cpp\nauto x = 3;auto is_above = [x](int y) { return y > x;};auto test = is_above(5); \n```", "```cpp\nauto x = 3;auto is_above = [&x](int y) { return y > x;};auto test = is_above(5); \n```", "```cpp\nauto x = 3;class IsAbove {\npublic: IsAbove(int x) : x{x} {} auto operator()(int y) const {   return y > x; }private: int x{}; // Value };auto is_above = IsAbove{x};\nauto test = is_above(5); \n```", "```cpp\nauto x = 3;class IsAbove {\npublic: IsAbove(int& x) : x{x} {} auto operator()(int y) const {   return y > x; }private: int& x; // Reference };\nauto is_above = IsAbove{x};\nauto test = is_above(5); \n```", "```cpp\nauto some_func = [numbers = std::list<int>{4,2}]() {\n  for (auto i : numbers)\n    std::cout << i;\n};\nsome_func();  // Output: 42 \n```", "```cpp\nclass SomeFunc {\npublic:\n SomeFunc() : numbers{4, 2} {}\n void operator()() const {\n  for (auto i : numbers)\n    std::cout << i;\n }\nprivate:\n std::list<int> numbers;\n};\nauto some_func = SomeFunc{};\nsome_func(); // Output: 42 \n```", "```cpp\nauto x = 1;\nauto some_func = [&y = x]() {\n  // y is a reference to x\n}; \n```", "```cpp\nauto x = std::make_unique<int>(); \nauto some_func = [x = std::move(x)]() {\n  // Use x here..\n}; \n```", "```cpp\nauto counter_func = [counter = 1]() mutable {\n  std::cout << counter++;\n};\ncounter_func(); // Output: 1\ncounter_func(); // Output: 2\ncounter_func(); // Output: 3 \n```", "```cpp\nauto some_func() {\n  auto v = 7;\n  auto lambda = [v]() mutable {\n    std::cout << v << \" \";\n    ++v;\n  };\n  assert(v == 7);\n  lambda();  lambda();\n  assert(v == 7);\n  std::cout << v;\n} \n```", "```cpp\nauto some_func() {\n  auto v = 7;\n  auto lambda = [&v]() {\n    std::cout << v << \" \";\n    ++v;\n  };\n  assert(v == 7);\n  lambda();\n  lambda();\n  assert(v == 9);\n  std::cout << v;\n} \n```", "```cpp\nclass Lambda {\n public:\n Lambda(int m) : v{m} {}\n auto operator()() {\n   std::cout<< v << \" \";\n   ++v;\n }\nprivate:\n  int v{};\n}; \n```", "```cpp\nclass Lambda {\n public:\n Lambda(int& m) : v{m} {}\n auto operator()() const {\n   std::cout<< v << \" \";\n   ++v;\n }\nprivate:\n int& v;\n}; \n```", "```cpp\nclass Foo { \npublic: \n auto member_function() { \n   auto a = 0; \n   auto b = 1.0f;\n   // Capture all variables by copy \n   auto lambda_0 = [=]() { std::cout << a << b; }; \n   // Capture all variables by reference \n   auto lambda_1 = [&]() { std::cout << a << b; }; \n   // Capture object by reference \n   auto lambda_2 = [this]() { std::cout << m_; }; \n   // Capture object by copy \n   auto lambda_3 = [*this]() { std::cout << m_; }; \n }\nprivate: \n int m_{}; \n}; \n```", "```cpp\nint a, b, c;auto func = [=] { /*...*/ }; \n```", "```cpp\nint a, b, c;auto func = [&] { /*...*/ }; \n```", "```cpp\nint a, b, c;auto func = [=, &c] { /*...*/ }; \n```", "```cpp\nint a, b, c;auto func = [&, c] { /*...*/ }; \n```", "```cpp\nextern void download_webpage(const char* url,\n                              void (*callback)(int, const char*)); \n```", "```cpp\nauto lambda = +[](int result, const char* str) {\n  // Process result and str\n};\ndownload_webpage(\"http://www.packt.com\", lambda); \n```", "```cpp\nauto x = [] {};   // A lambda without captures\nauto y = x;       // Assignable\ndecltype(y) z;    // Default-constructible\nstatic_assert(std::is_same_v<decltype(x), decltype(y)>); // passes\nstatic_assert(std::is_same_v<decltype(x), decltype(z)>); // passes \n```", "```cpp\nstd::function< return_type ( parameter0, parameter1...) > \n```", "```cpp\nauto func = std::function<void(void)>{}; \n```", "```cpp\nauto func = std::function<bool(int, std::string)>{}; \n```", "```cpp\n// Create an unassigned std::function object \nauto func = std::function<void(int)>{}; \n// Assign a lambda without capture to the std::function object \nfunc = [](int v) { std::cout << v; }; \nfunc(12); // Prints 12 \n// Assign a lambda with capture to the same std::function object \nauto forty_two = 42; \nfunc = [forty_two](int v) { std::cout << (v + forty_two); }; \nfunc(12); // Prints 54 \n```", "```cpp\nclass Button {\npublic: \n  Button(std::function<void(void)> click) : handler_{click} {} \n  auto on_click() const { handler_(); } \nprivate: \n  std::function<void(void)> handler_{};\n}; \n```", "```cpp\nauto create_buttons () { \n  auto beep = Button([counter = 0]() mutable {  \n    std::cout << \"Beep:\" << counter << \"! \"; \n    ++counter; \n  }); \n  auto bop = Button([] { std::cout << \"Bop. \"; }); \n  auto silent = Button([] {});\n  return std::vector<Button>{beep, bop, silent}; \n} \n```", "```cpp\nconst auto& buttons = create_buttons();\nfor (const auto& b: buttons) {\n  b.on_click();\n}\nbuttons.front().on_click(); // counter has been incremented\n// Output: \"Beep:0! Bop. Beep:1!\" \n```", "```cpp\nauto lambda = [](int v) { return v * 3; }; \n```", "```cpp\nauto use_lambda() { \n  using T = decltype(lambda);\n  auto fs = std::vector<T>(10'000'000, lambda);\n  auto res = 1;\n  // Start clock\n  for (const auto& f: fs)\n    res = f(res);\n  // Stop clock here\n  return res;\n} \n```", "```cpp\nauto use_std_function() { \n  using T = std::function<int(int)>;\n  auto fs = std::vector<T>(10'000'000, T{lambda});\n  auto res = 1;\n  // Start clock\n  for (const auto& f: fs)\n    res = f(res);\n  // Stop clock here\n  return res;\n} \n```", "```cpp\nauto v = 3; // int\nauto lambda = [v](auto v0, auto v1) {\n  return v + v0*v1;\n}; \n```", "```cpp\nclass Lambda {\npublic:\n  Lambda(int v) : v_{v} {}\n  template <typename T0, typename T1>\n  auto operator()(T0 v0, T1 v1) const { \n    return v_ + v0*v1; \n  }\nprivate:\n  int v_{};\n};\nauto v = 3;\nauto lambda = Lambda{v}; \n```", "```cpp\nauto res_int = lambda(1, 2);\nauto res_float = lambda(1.0f, 2.0f); \n```", "```cpp\nauto lambda_int = [v](int v0, const int v1) { return v + v0*v1; };\nauto lambda_float = [v](float v0, float v1) { return v + v0*v1; };\nauto res_int = lambda_int(1, 2);\nauto res_float = lambda_float(1.0f, 2.0f); \n```", "```cpp\n// Using auto\nauto x = [](auto v) { return v + 1; };\n// Using typename\nauto y = []<typename Val>(Val v) { return v + 1; }; \n```"]