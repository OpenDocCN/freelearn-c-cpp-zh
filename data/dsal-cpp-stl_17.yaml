- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: Creating STL -Compatible Algorithms
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建与STL兼容的算法
- en: This chapter discusses creating versatile and efficient algorithms in C++. Developers
    will learn type-generic programming, understand the function overloading, and
    learn to tailor existing algorithms to specific needs. The chapter will include
    theory, best practices, and hands-on techniques. By the end, we will be equipped
    to develop powerful and adaptable algorithms for various scenarios.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了在C++中创建通用且高效的算法。开发者将学习类型泛型编程，理解函数重载，并学习如何根据特定需求调整现有算法。本章将包括理论、最佳实践和实际技术。到结束时，我们将能够为各种场景开发强大且适应性强的算法。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Template functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板函数
- en: Overloading
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载
- en: Creating generic algorithms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建泛型算法
- en: Customizing existing algorithms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义现有算法
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code in this chapter can be found on GitHub:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
- en: Template functions
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板函数
- en: One of the hallmarks of the C++ **Standard Template Library** (**STL**) is its
    commitment to type-generic programming. This allows algorithms to be written to
    operate on multiple data types, effectively sidestepping the restrictions of traditional
    type-specific functions. C++ achieves this remarkable feat using template functions.
    Let us explore these template functions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: C++ **标准模板库**（**STL**）的一个显著特点是其对类型泛型编程的承诺。这允许算法被编写以操作多种数据类型，有效地绕过了传统类型特定函数的限制。C++通过使用模板函数实现了这一非凡的成就。让我们来探索这些模板函数。
- en: A primer on function templates
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数模板入门
- en: 'At the heart of type-generic programming lies the function template, an incredible
    tool that allows developers to write functions without specifying the exact data
    types they will operate on. Instead of committing to a single type, templates
    let you define a blueprint, making the function adaptable to various types. Here’s
    a simple example: imagine writing a function that swaps the values of two variables.
    With function templates, this `swap` function can cater to integers, floats, strings,
    and even custom types!'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 类型泛型编程的核心是函数模板，这是一个令人难以置信的工具，它允许开发者编写不指定将操作的确切数据类型的函数。而不是对单一类型做出承诺，模板让你定义一个蓝图，使函数能够适应各种类型。这里有一个简单的例子：想象编写一个交换两个变量值的函数。使用函数模板，这个`swap`函数可以适用于整数、浮点数、字符串，甚至自定义类型！
- en: Variadic templates – multiplicity in templates
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变模板 – 模板中的多重性
- en: '**Variadic templates** elevate the power of function templates by allowing
    you to write functions that accept a variable number of template arguments. This
    is especially handy when crafting algorithms that need to operate on different
    numbers of inputs. They become indispensable when you think of functions that
    combine, transform, or process multiple containers or elements simultaneously.
    As you explore the STL, you’ll see many instances where this flexibility becomes
    crucial.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**可变模板**通过允许你编写接受可变数量模板参数的函数，提升了函数模板的能力。这在需要处理不同数量输入的算法中特别有用。当你考虑到需要同时组合、转换或处理多个容器或元素时，它们变得不可或缺。随着你探索STL，你会看到许多这种灵活性变得至关重要的例子。'
- en: SFINAE – fine-tuning template substitution
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SFINAE – 精细调整模板替换
- en: '**Substitution failure is not an error** (**SFINAE**) sounds like a cryptic
    concept, but it is a cornerstone for creating resilient template functions in
    C++. It’s a mechanism that allows the compiler to discard specific template overloads
    based on whether the type substitution leads to a valid result. In essence, it
    is like giving the compiler a set of rules on which template to pick based on
    the specifics of the provided types.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**替换失败不是错误**（**SFINAE**）听起来像是一个晦涩的概念，但它是在C++中创建健壮模板函数的基石。这是一个机制，允许编译器根据类型替换是否导致有效结果来丢弃特定的模板重载。本质上，它就像给编译器一套规则，根据提供类型的具体情况来选择模板。'
- en: Imagine you’re writing a function template that operates on STL containers.
    With SFINAE, you can direct the compiler to pick a particular overload when the
    container is a sequence container and another when it is an associative container.
    The magic here lies in ensuring that the template substitution remains valid.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在编写一个操作STL容器的函数模板。使用SFINAE，你可以指导编译器在容器是序列容器时选择特定的重载版本，而在容器是关联容器时选择另一个版本。这里的魔法在于确保模板替换保持有效。
- en: Harnessing SFINAE with std::enable_if
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用`std::enable_if`与SFINAE结合
- en: The `std::enable_if` utility is a boon when working with SFINAE. It’s a type
    trait that can conditionally remove or add a particular function overload from
    the set of overloads considered during template substitution. Coupling `std::enable_if`
    with type traits allows you to fine-tune your algorithms to cater to specific
    STL container characteristics.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::enable_if`实用工具在与SFINAE一起工作时是一大福音。它是一个类型特性，可以在模板替换过程中有条件地移除或添加特定的函数重载。将`std::enable_if`与类型特性结合使用，可以使你精细调整算法以适应特定的STL容器特性。'
- en: 'Let’s look at an example that demonstrates the concepts of function templates,
    variadic templates, and SFINAE:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个示例，它展示了函数模板、变长模板和SFINAE的概念：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is the example output:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是示例输出：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code demonstrates the concepts of function templates, variadic templates,
    and SFINAE. The `swap` function is a simple function template that swaps two variables
    of any type. The `print` function is a variadic template that prints any number
    of arguments. The `process` functions demonstrate SFINAE with `std::enable_if`,
    where different overloads are chosen based on the type of argument. Finally, the
    `processContainer` functions show how SFINAE can be used to differentiate between
    different STL containers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了函数模板、变长模板和SFINAE的概念。`swap`函数是一个简单的函数模板，可以交换任何类型的两个变量。`print`函数是一个变长模板，可以打印任意数量的参数。`process`函数通过`std::enable_if`展示了SFINAE，根据参数类型选择不同的重载版本。最后，`processContainer`函数展示了如何使用SFINAE来区分不同的STL容器。
- en: Understanding and mastering function templates will be pivotal as you venture
    deeper into creating STL-compatible algorithms. They ensure that your algorithms
    are versatile, adapting to various types and scenarios. But more than just flexibility,
    templates bolster efficiency. By working closely with the type system, your algorithms
    can be optimized for specific types, yielding performance benefits.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入创建与STL兼容的算法时，理解和掌握函数模板将至关重要。它们确保你的算法具有通用性，能够适应各种类型和场景。但不仅仅是灵活性，模板还增强了效率。通过与类型系统紧密合作，你的算法可以针对特定类型进行优化，从而获得性能上的好处。
- en: Function templates, variadic templates, and SFINAE are more than just tools;
    they are the bedrock upon which the STL’s type-generic paradigm stands. By leveraging
    these, you are aligning with the STL’s philosophy and elevating your algorithms’
    adaptability and power.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 函数模板、变长模板和SFINAE不仅仅是工具；它们是STL（标准模板库）类型泛型范式的基础。通过利用这些工具，你与STL的哲学相一致，并提升了你算法的适应性和能力。
- en: As we progress further into the chapter, we’ll review overloading techniques,
    understand the nuances of creating truly generic algorithms, and learn the art
    of customizing existing ones for specific needs. Each step brings us closer to
    mastering the art of crafting exceptional STL-compatible algorithms.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进一步深入本章，我们将回顾重载技术，理解创建真正泛型算法的微妙之处，并学习如何根据特定需求定制现有算法。每一步都让我们更接近掌握制作卓越的STL兼容算法的艺术。
- en: Overloading
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重载
- en: '**Function overloading** is a cornerstone of C++ programming, enabling developers
    to define multiple versions of a function with the same name but different parameters.
    This ability is especially crucial when crafting algorithms that interact with
    the diverse palette of STL containers, each with its unique characteristics and
    requirements. With overloading, you can tailor your algorithms to specific containers
    or situations, ensuring optimal performance and flexibility.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数重载**是C++编程的基石，它使开发者能够定义具有相同名称但参数不同的多个函数版本。这种能力在创建与STL容器交互的算法时尤为重要，因为每个容器都有其独特的特性和要求。通过重载，你可以根据特定容器或情况定制你的算法，确保最佳性能和灵活性。'
- en: Crafting multiple algorithm versions for STL containers
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为STL容器制作多个算法版本
- en: A need to treat specific containers differently based on their inherent properties
    might arise when designing algorithms compatible with STL containers. For instance,
    an algorithm interacting with `std::vector` might have different requirements
    than when dealing with `std::map`. By utilizing function overloading, you can
    design separate versions of the algorithm optimized for each container type, ensuring
    that each interaction is as efficient as possible.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计与 STL 容器兼容的算法时，可能会出现需要根据其固有属性以不同方式处理特定容器的需求。例如，与 `std::vector` 交互的算法可能比处理
    `std::map` 时有不同的要求。通过利用函数重载，你可以为每种容器类型设计算法的单独版本，确保每次交互都尽可能高效。
- en: Function resolution – navigating the intricacies
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数解析 – 探索复杂性
- en: Function overloading comes with challenges, and understanding function resolution
    is pivotal. When multiple overloaded functions are potential candidates for a
    call, the compiler follows a strict set of rules to determine the best match.
    It considers the number of arguments, their types, and their potential type conversions.
    As you overload functions for STL-compatible algorithms, being aware of these
    rules is paramount. It ensures that the correct version of your function gets
    invoked and prevents any unexpected behaviors or ambiguities.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 函数重载伴随着挑战，理解函数解析至关重要。当存在多个重载函数可能成为调用候选时，编译器遵循一系列严格的规则来确定最佳匹配。它考虑了参数的数量、它们的类型以及它们可能的类型转换。在你为
    STL 兼容算法重载函数时，了解这些规则至关重要。它确保了正确版本的函数被调用，并防止了任何意外的行为或歧义。
- en: Overloading with care – clarity and consistency
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谨慎重载 – 清晰和一致性
- en: The power to overload functions can be both a boon and a pitfall. While it allows
    for greater flexibility, it also introduces the risk of cluttering your code base
    with too many function variations, potentially leading to confusion. A golden
    rule when overloading is to maintain clarity and consistency.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 重载函数的能力既是福音也是陷阱。虽然它提供了更大的灵活性，但也引入了在代码库中充斥着过多函数变体的风险，这可能导致混淆。重载时的黄金法则是要保持清晰和一致性。
- en: Ask yourself whether the overloaded version offers a different or optimized
    approach for a particular STL container or scenario. If it doesn’t, perhaps relying
    on a generic version that can cater to multiple scenarios is more prudent. A well-designed
    function signature, combined with meaningful parameter names, can often convey
    the function’s purpose, reducing the need for excessive overloading.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 反问自己，重载版本是否为特定的 STL 容器或场景提供了不同的或优化的方法。如果没有，可能依赖一个能够适应多个场景的通用版本更为谨慎。一个精心设计的函数签名，结合有意义的参数名称，通常可以传达函数的目的，减少过度重载的需要。
- en: Furthermore, ensure that your documentation is precise. Mention the purpose
    of each overloaded version, the scenarios in which it should be used, and how
    it differs from other versions. This not only aids other developers who might
    use or maintain your algorithms but also serves as a valuable reference for your
    future self.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，确保你的文档精确无误。提及每个重载版本的目的、应使用它的场景以及它与其他版本的区别。这不仅有助于可能使用或维护你的算法的其他开发者，也为你未来的自己提供了一个宝贵的参考。
- en: With a firm grasp on overloading, you are now poised to dive further into the
    world of STL-compatible algorithms. The techniques you’ve acquired here lay the
    foundation for creating generic algorithms and customizing existing ones to cater
    to specific needs. The journey ahead is exciting, filled with opportunities to
    design robust, versatile algorithms that seamlessly integrate with the vast expanse
    of STL containers, genuinely exemplifying the essence of C++ programming.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对重载的牢固掌握，你现在已经准备好进一步深入 STL 兼容算法的世界。你在这里获得的技术为创建通用算法和定制现有算法以满足特定需求奠定了基础。前方是一条令人兴奋的旅程，充满了设计出健壮、多功能的算法的机会，这些算法能够无缝地与
    STL 容器的广阔领域集成，真正体现了 C++ 编程的精髓。
- en: Creating generic algorithms
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建通用算法
- en: In this section, we will learn about constructing algorithms that transcend
    type-specific boundaries, a fundamental aspect of advanced C++ programming. This
    approach is crucial for developing robust and versatile software, as it allows
    algorithms to operate seamlessly across a diverse array of data types and structures.
    This section will guide you through the principles and techniques necessary to
    design algorithms that are not just efficient but also adaptable and type-agnostic,
    aligning perfectly with the philosophy of the STL.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习构建超越特定类型边界的算法，这是高级 C++ 编程的一个基本方面。这种方法对于开发健壮和通用的软件至关重要，因为它允许算法在多种数据类型和结构之间无缝运行。本节将指导你了解设计既高效又适应性强、无类型的算法所必需的原则和技术，这与
    STL 的哲学完美契合。
- en: The ability to write generic algorithms is invaluable. It ensures that your
    code is not only reusable across various applications but also capable of handling
    unforeseen future requirements. This versatility is especially important in C++
    programming, where the complexity and diversity of data types can pose significant
    challenges. By focusing on a type-independent approach and embracing tools such
    as iterators, predicates, and functors, you will learn to create algorithms that
    are not constrained by type-specific limitations. This knowledge will empower
    you to write code that is more maintainable, scalable, and aligned with best practices
    in C++ programming. As we work through these concepts, you’ll gain the skills
    to make your algorithms a perfect fit for the STL, enhancing both their utility
    and performance.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 能够编写泛型算法的能力是无价的。它确保了你的代码不仅可以在各种应用程序中重用，而且能够处理未来不可预见的需要。这种通用性在 C++ 编程中尤为重要，因为数据类型的复杂性和多样性可能带来重大挑战。通过关注类型无关的方法，并拥抱诸如迭代器、断言和函数对象（functors）等工具，你将学会创建不受特定类型限制的算法。这种知识将使你能够编写更易于维护、可扩展且符合
    C++ 编程最佳实践的代码。随着我们深入这些概念，你将获得使你的算法完美适应 STL 的技能，从而提高其效用和性能。
- en: Toward a type-independent approach
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向类型无关的方法迈进
- en: As you create generic algorithms, one guiding principle is the type-independent
    approach. The strength of C++ and the STL is their ability to craft algorithms
    that, at their core, do not care about the type they operate on. They focus on
    logic, and the underlying machinery handles the type-specific details, primarily
    templates and iterators.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建泛型算法时，一个指导原则是类型无关的方法。C++ 和 STL 的优势在于它们能够构建核心上不关心操作类型（类型无关）的算法。它们关注逻辑，而底层机制处理特定类型的细节，主要是模板和迭代器。
- en: Embracing iterators – the bridge to generics
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拥抱迭代器——通向泛型的桥梁
- en: In many ways, iterators are the secret sauce behind the generic nature of STL
    algorithms. Think of iterators as bridging the gap between type-specific containers
    and type-agnostic algorithms. When crafting a generic algorithm, you typically
    wouldn’t accept a container as a parameter. Instead, you’d accept iterators, and
    these iterators abstract away the underlying container and its type.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，迭代器是 STL 算法泛型特性的秘密成分。将迭代器视为连接特定类型容器和无类型算法之间的桥梁。在构建泛型算法时，你通常不会接受容器作为参数。相反，你会接受迭代器，这些迭代器抽象出底层容器及其类型。
- en: For example, instead of designing an algorithm specifically for `std::vector<int>`,
    accept iterators as parameters. This makes your algorithm applicable to `std::vector<int>`
    and potentially to any container that provides the required iterator type.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，与其为 `std::vector<int>` 设计特定的算法，不如接受迭代器作为参数。这使得你的算法适用于 `std::vector<int>`，并且可能适用于任何提供所需迭代器类型的容器。
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These examples show how a function that takes iterators as parameters can be
    more versatile than one that takes a reference to a container.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例展示了将迭代器作为参数的函数如何比将容器引用作为参数的函数更灵活。
- en: Predicates – customizing algorithm behavior
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 断言（Predicates）——定制算法行为
- en: But what if you wish to introduce a hint of customization? What if you want
    your generic algorithm to have a configurable behavior? Enter predicates.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你希望引入一点定制化呢？如果你想让你的泛型算法具有可配置的行为呢？这就是断言（predicates）的用武之地。
- en: '**Predicates** are Boolean-valued unary or binary functions (or function objects).
    When passed to an algorithm, they can influence its behavior. For instance, when
    sorting a collection, you can provide a predicate to determine the ordering of
    elements. By harnessing predicates, your algorithms can remain generic but still
    be tailored to specific scenarios without hardcoding any behavior.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**谓词**是布尔值一元或二元函数（或函数对象）。当传递给算法时，它们可以影响其行为。例如，在排序一个集合时，你可以提供一个谓词来确定元素的排序顺序。通过利用谓词，你的算法可以保持通用性，同时仍然可以根据特定场景进行调整，而不需要硬编码任何行为。'
- en: The magic of functors – enhancing flexibility
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数对象的魔法——增强灵活性
- en: While predicates allow customization, functors (or function objects) take this
    to another level. A **functor** is an object that can be called as if it were
    a function. The essential advantage here is statefulness. Unlike simple function
    pointers or lambdas, functors can maintain state, providing a more significant
    degree of flexibility.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当谓词允许自定义时，函数对象（或函数对象）将这一概念提升到了另一个层次。**函数对象**是一个可以像函数一样调用的对象。这里的基本优势是状态性。与简单的函数指针或lambda函数不同，函数对象可以维护状态，提供更大的灵活性。
- en: Imagine designing a generic algorithm that applies a transformation to each
    element in an STL container. By accepting a functor as a parameter, users of your
    algorithm can not only specify the transformation logic but also carry some state
    with it, making for robust and adaptable solutions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 想象设计一个通用的算法，该算法将转换应用于STL容器中的每个元素。通过接受一个函数对象作为参数，你的算法的用户不仅可以指定转换逻辑，还可以携带一些状态，从而提供强大且适应性强的解决方案。
- en: With iterators, predicates, and functors in your toolkit, you’re well-equipped
    to craft generic algorithms that are versatile yet type-agnostic. Always focus
    on the logic, keep the type specifics abstracted away, and provide avenues (such
    as predicates and functors) for users to inject custom behavior.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的工具箱中有迭代器、谓词和函数对象，你将准备好构建通用算法，这些算法既灵活又类型无关。始终关注逻辑，将类型具体化抽象化，并为用户提供途径（如谓词和函数对象）以注入自定义行为。
- en: As you move ahead, remember that the essence of generic programming is adaptability.
    Algorithms should be built to cater to a wide range of scenarios and types. The
    upcoming section will guide you through adapting and extending the already robust
    set of STL algorithms, amplifying the power of your C++ code base.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你继续前进，请记住泛型编程的本质是适应性。算法应该构建以适应广泛的场景和类型。接下来的部分将指导你适应和扩展已经非常健壮的STL算法集，增强你的C++代码库的功能。
- en: Customizing existing algorithms
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义现有算法
- en: The STL provides for adapting and enhancing its already robust set of algorithms.
    This skill is crucial for any proficient C++ programmer, as it allows for the
    fine-tuning of algorithms to meet specific needs without starting from scratch.
    In this section, you will learn how to use design patterns, such as the **decorator
    pattern**, and lambda functions to modify existing algorithms, making them more
    suitable for your unique requirements.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: STL提供了适应和增强其已经非常健壮的算法集的方法。这项技能对于任何熟练的C++程序员来说至关重要，因为它允许对算法进行微调以满足特定需求，而不需要从头开始。在本节中，你将学习如何使用设计模式，例如**装饰器模式**，以及lambda函数来修改现有算法，使它们更适合你的独特需求。
- en: In practical programming scenarios, you often encounter situations where an
    existing STL algorithm *almost* meets your needs but requires some adjustments.
    Knowing how to customize these algorithms, as opposed to creating entirely new
    ones, can save significant time and effort. This section will teach you to leverage
    existing solutions and adapt them creatively, ensuring efficiency and maintainability.
    You will discover how to integrate design patterns to add new behaviors or modify
    existing ones and how to use lambda functions for concise and effective customizations.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际的编程场景中，你经常会遇到现有STL算法几乎满足你的需求但需要一些调整的情况。知道如何自定义这些算法，而不是从头创建新的算法，可以节省大量的时间和精力。本节将教你如何利用现有解决方案并创造性地对其进行调整，确保效率和可维护性。你将发现如何集成设计模式以添加新行为或修改现有行为，以及如何使用lambda函数进行简洁而有效的自定义。
- en: Looking at the decorator pattern in action
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察装饰器模式在实际中的应用
- en: When confronted with an STL algorithm that almost fits the bill but not entirely,
    resisting the urge to reinvent the wheel is crucial. Instead, adapting these algorithms
    using tried and true design patterns can often lead to a more elegant, efficient,
    and maintainable solution.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 面对几乎符合要求但又不完全符合的 STL 算法时，抵制重写轮子的冲动至关重要。相反，通过使用经过验证的设计模式来调整这些算法，通常可以导致更优雅、高效和可维护的解决方案。
- en: One of the most potent design patterns in this context is the decorator pattern.
    It allows you to take an existing algorithm and add or modify behaviors without
    altering its structure. Consider a scenario where you have a sorting algorithm
    and want to add logging capabilities. Instead of rewriting or overloading the
    function, use the decorator pattern to create a new algorithm that calls the original
    sorting function and adds logging on top. The beauty here is in the separation
    of concerns and the ability to chain decorators for multiple additional behaviors.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，最强大的设计模式之一是装饰器模式。它允许你在不改变其结构的情况下，对现有算法添加或修改行为。考虑这样一个场景，你有一个排序算法，并想添加日志记录功能。你不需要重写或重载函数，而是使用装饰器模式创建一个新的算法，该算法调用原始排序函数并在其上方添加日志记录。这里的美丽之处在于关注点分离和能够链式添加多个额外行为的能力。
- en: 'Let’s look at the decorator pattern in action. We will use it to add logging
    to an STL comparison function:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看装饰器模式在实际中的应用。我们将使用它来为一个 STL 比较函数添加日志记录：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is the example output:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, `LoggingCompareDecorator` is a template class that takes a
    comparison function object (`comp`) and adds logging around it. `operator()` is
    overridden to add logging before calling the original comparison function. The
    original sorting algorithm (`std::sort`) is used with the decorated comparison
    function, thereby adding logging to each comparison operation without altering
    the sorting algorithm itself. This demonstrates the decorator pattern by allowing
    additional behavior (logging) to be added to an existing function (`std::less`)
    in a manner that is clean and maintainable and adheres to the separation of concerns
    principle.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`LoggingCompareDecorator` 是一个模板类，它接受一个比较函数对象（`comp`）并在其周围添加日志记录。`operator()`
    被覆盖以在调用原始比较函数之前添加日志。使用装饰后的比较函数（`std::less`）与原始排序算法（`std::sort`）一起使用，从而在不改变排序算法本身的情况下为每个比较操作添加日志记录。这通过允许以干净、可维护的方式将额外行为（日志记录）添加到现有函数中（`std::less`），展示了装饰器模式，并遵循了关注点分离原则。
- en: Harnessing the power of lambda functions
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用 Lambda 函数的力量
- en: Lambda functions are magnificent tools in the C++ arsenal. They enable developers
    to define anonymous functions in place, making code concise and, in many cases,
    more readable. When customizing existing STL algorithms, lambdas can be a game-changer.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 函数是 C++ 工具箱中的神奇工具。它们使开发者能够就地定义匿名函数，使代码更加简洁，在许多情况下，也更容易阅读。当定制现有的 STL 算法时，Lambda
    函数可以成为游戏规则的改变者。
- en: Imagine you’re using the `std::transform` algorithm, which applies a function
    to every element in a container. The beauty of `std::transform` is its flexibility
    in accepting any callable object, including lambdas. So, instead of defining a
    whole new function or functor, you can pass a lambda function directly to tailor
    its behavior to your needs.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在使用 `std::transform` 算法，该算法将函数应用于容器中的每个元素。`std::transform` 的美妙之处在于它接受任何可调用对象的能力，包括
    Lambda。因此，你不需要定义全新的函数或函数对象，可以直接传递一个 Lambda 函数来调整其行为以满足你的需求。
- en: 'Let’s take an example. Suppose you want to square each element in a vector.
    Instead of creating a separate function named `square`, you can pass a lambda,
    as shown in the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个例子。假设你想要将向量中的每个元素平方。你不需要创建一个名为 `square` 的单独函数，你可以传递一个 Lambda，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Lambdas can also capture variables from their surrounding scope, giving you
    the power to use external data in your custom logic. For instance, if you want
    to multiply each element in a vector by a dynamic factor, you can capture that
    factor in a lambda and use it inside:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 函数还可以捕获其周围作用域中的变量，赋予你使用外部数据在自定义逻辑中的能力。例如，如果你想将向量中的每个元素乘以一个动态因子，你可以在 Lambda
    中捕获该因子并在其中使用它：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Lambda functions in C++ offer a succinct and flexible way to define anonymous,
    inline functions, greatly simplifying the code, especially for short, one-time-use
    functions. They enhance readability and maintainability, and when used in conjunction
    with STL algorithms, they allow for concise and powerful custom behaviors without
    the need for verbose function or functor definitions.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中的 lambda 函数提供了一种简洁且灵活的方式来定义匿名、内联函数，极大地简化了代码，特别是对于短时使用的函数。它们增强了可读性和可维护性，并且当与
    STL 算法结合使用时，它们允许在不需要冗长的函数或函数对象定义的情况下实现简洁且强大的自定义行为。
- en: Mixing patterns with lambdas for ultimate customization
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将模式与 lambda 结合以实现终极定制
- en: When you combine the power of design patterns with the flexibility of lambda
    functions, you get a toolset that allows for profound customization of existing
    algorithms. For instance, you could use the **strategy pattern** to define a family
    of algorithms and then employ lambda functions to fine-tune the behavior of each
    strategy. This synergy can lead to highly modular and adaptable code, maximizing
    code reuse and minimizing redundancy.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将设计模式的强大功能与 lambda 函数的灵活性结合起来时，你得到一个工具集，它允许对现有算法进行深刻的定制。例如，你可以使用 **策略模式**
    定义一组算法，然后使用 lambda 函数来微调每个策略的行为。这种协同作用可以导致高度模块化和可适应的代码，最大化代码重用并最小化冗余。
- en: 'Let’s look at an example of using lambdas with the strategy pattern:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个使用策略模式结合 lambda 表达式的示例：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is the example output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, `Strategy` is an abstract base class that defines a family
    of algorithms. `ForEachStrategy` and `TransformStrategy` are concrete strategies
    that implement these algorithms using `std::for_each` and `std::transform`, respectively.
    Both algorithms use lambda functions to define their behavior. The `Context` class
    uses `Strategy` to execute an algorithm, and `Strategy` can be changed at runtime.
    This demonstrates the power of combining design patterns with lambda functions
    to create highly modular and adaptable code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`Strategy` 是一个抽象基类，它定义了一组算法。`ForEachStrategy` 和 `TransformStrategy` 是具体策略，分别使用
    `std::for_each` 和 `std::transform` 实现这些算法。这两个算法都使用 lambda 函数来定义其行为。`Context` 类使用
    `Strategy` 来执行算法，并且 `Strategy` 可以在运行时更改。这展示了将设计模式与 lambda 函数结合以创建高度模块化和可适应代码的强大功能。
- en: Customizing existing algorithms is an art and a science. It requires a deep
    understanding of the existing STL tools, a dash of creativity, and the discipline
    to maintain clarity and efficiency. As you venture forward, always prioritize
    understanding the problem and choosing the right tool for the job. Customize thoughtfully,
    and the STL will reward you with elegant solutions to even the most intricate
    problems.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 定制现有算法是一种艺术和科学。它需要深入理解现有的 STL 工具，一点创造力，以及保持清晰和效率的纪律。随着你继续前进，始终优先考虑理解问题和选择正确的工具。深思熟虑地进行定制，STL
    将以优雅的解决方案回报你，即使是解决最复杂的问题。
- en: Summary
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As we conclude this chapter on creating STL-compatible algorithms, we have learned
    the essential techniques and concepts for crafting versatile and efficient algorithms
    in C++. Starting with the fundamentals of type-generic programming, you have learned
    the art of using function templates, variadic templates, and the subtle yet powerful
    SFINAE principle. These tools enable you to write algorithms that are adaptable
    to a multitude of data types, a hallmark of the STL’s flexibility and power.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章关于创建 STL 兼容算法的讨论时，我们学习了在 C++ 中构建灵活和高效算法的基本技术和概念。从泛型编程的基础开始，你学习了使用函数模板、变长模板以及微妙而强大的
    SFINAE 原则的艺术。这些工具使你能够编写适应多种数据类型的算法，这是 STL 灵活性和强大功能的一个标志。
- en: This chapter has also guided you through the intricacies of function overloading,
    a critical skill for tailoring algorithms to different STL containers and scenarios.
    You’ve learned how to navigate the complexities of function resolution and the
    importance of maintaining clarity and consistency when overloading functions.
    This knowledge ensures that your algorithms are not only versatile but also intuitive
    and efficient in their interaction with various STL components.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还指导你了解了函数重载的复杂性，这是针对不同 STL 容器和场景定制算法的关键技能。你学习了如何导航函数解析的复杂性，以及在使用函数重载时保持清晰和一致性的重要性。这种知识确保了你的算法不仅灵活，而且在与各种
    STL 组件交互时直观且高效。
- en: Looking ahead, the next chapter will uncover the world of type traits and policies,
    exploring how these tools enhance code adaptability and empower metaprogramming.
    You’ll learn about the benefits of using policies in relation to the STL, how
    to build modular components, and the potential challenges you may encounter. This
    chapter will not only deepen your understanding of advanced C++ features but also
    equip you with practical skills for implementing type traits and policies in your
    code, ensuring compatibility and flexibility in your programming.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 展望未来，下一章将揭示类型特性和策略的世界，探讨这些工具如何增强代码的适应性并赋予元编程能力。你将了解使用策略与 STL 相关的好处，如何构建模块化组件，以及你可能遇到的潜在挑战。这一章不仅将加深你对高级
    C++ 特性的理解，还将为你提供在代码中实现类型特性和策略的实用技能，确保你的编程具有兼容性和灵活性。
