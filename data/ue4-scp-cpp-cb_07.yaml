- en: Chapter 7. Communication between Classes and Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。类和接口之间的通信
- en: 'This chapter shows you how to write your own UInterfaces, and demonstrates
    how to take advantage of them within C++ to minimize class coupling and help keep
    your code clean. The following recipes will be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您展示如何编写自己的UInterfaces，并演示如何在C++中利用它们来最小化类耦合并帮助保持代码清晰。本章将涵盖以下内容：
- en: Creating a `UInterface`
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`UInterface`
- en: Implementing a `UInterface` on an object
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对象上实现`UInterface`
- en: Checking if a class implements a `UInterface`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查类是否实现了`UInterface`
- en: Casting to a `UInterface` implemented in native code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地代码中实现`UInterface`的转换
- en: Calling native `UInterface` functions from C++
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从C++调用本地`UInterface`函数
- en: Inheriting `UInterface` from one another
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相互继承`UInterface`
- en: Overriding `UInterface` functions in C++
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C++中重写`UInterface`函数
- en: Exposing `UInterface` methods to Blueprint from a native base class
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从本地基类向蓝图公开`UInterface`方法
- en: Implementing `UInterface` functions in Blueprint
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在蓝图中实现`UInterface`函数
- en: Creating C++ `UInterface` function implementations that can be overridden in
    Blueprint
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建C++ `UInterface`函数实现，可以在蓝图中重写
- en: Calling Blueprint-defined interface functions from C++
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从C++调用蓝图定义的接口函数
- en: Implementing a simple interaction system with UInterfaces
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用UInterfaces实现简单的交互系统
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In your game projects, you will sometimes require a series of potentially disparate
    objects to share a common functionality, but it would be inappropriate to use
    inheritance, because there is no "is-a" relationship between the different objects
    in question. Languages such as C++ tend to use multiple inheritance to solve this
    issue.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的游戏项目中，有时需要一系列潜在不同的对象共享共同的功能，但使用继承是不合适的，因为这些不同对象之间没有“是一个”关系。诸如C++的语言倾向于使用多重继承来解决这个问题。
- en: However, in Unreal, if you wanted functions from both the parent classes to
    be accessible to Blueprint, you would need to make both of them `UCLASS`. This
    is a problem for two reasons. Inheriting from `UClass` twice in the same object
    would break the concept that `UObject` should form a neatly traversable hierarchy.
    It also means that there are two instances of the `UClass` methods on the object,
    and they would have to be explicitly differentiated between within the code. The
    Unreal codebase solves this issue by borrowing a concept from C#—that of an explicit
    Interface type.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在虚幻中，如果您希望从父类中的函数都可以在蓝图中访问，您需要将它们都设置为`UCLASS`。这有两个问题。在同一个对象中两次继承`UClass`会破坏`UObject`应该形成一个整洁的可遍历层次结构的概念。这也意味着对象上有两个`UClass`方法的实例，并且它们在代码中必须明确区分。虚幻代码库通过从C#借用一个概念来解决这个问题——显式接口类型。
- en: The reason for using this approach, instead of composition, is that Components
    are only available on Actors, not on UObjects in general. Interfaces can be applied
    to any `UObject`. Furthermore, it means that we are no longer modeling an "is-a"
    relationship between the object and the component; instead, it would only be able
    to represent "has-a" relationships.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法的原因是，与组合相比，组件只能在Actor上使用，而不能在一般的UObjects上使用。接口可以应用于任何`UObject`。此外，这意味着我们不再对对象和组件之间的“是一个”关系进行建模；相反，它只能表示“有一个”关系。
- en: Creating a UInterface
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个UInterface
- en: UInterfaces are a pair of classes that work together to enable classes to exhibit
    polymorphic behavior among multiple class hierarchies. This recipe shows you the
    basic steps involved in creating a `UInterface` purely in code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: UInterfaces是一对类，它们一起工作，使类能够在多个类层次结构中表现多态行为。本章向您展示了纯粹使用代码创建`UInterface`的基本步骤。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: UInterfaces don't show up inside the main class wizard within Unreal, so we'll
    need to add the class manually using Visual Studio.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: UInterfaces不会出现在虚幻中的主类向导中，因此我们需要使用Visual Studio手动添加类。
- en: Right click on your Source folder inside **Solution Explorer,** and select **Add**
    | **New Item**.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中右键单击**源**文件夹，然后选择**添加** | **新建项**。
- en: Select a `.h` file to start, and name it `MyInterface.h.`
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个`.h`文件开始，命名为`MyInterface.h`。
- en: Make sure you change the directory for the item to be placed in from Intermediate
    to Source/ProjectName.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保将项目中项目的目录更改为Intermediate到Source/ProjectName。
- en: Click on **OK** to create a new header file in your project folder.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**OK**在项目文件夹中创建一个新的头文件。
- en: Repeat the steps in order to create `MyInterface.cpp` as your implementation
    file.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤，以创建`MyInterface.cpp`作为您的实现文件。
- en: 'Add the following code to the header file:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到头文件中：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Implement the class with this code in the `.cpp` file:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`.cpp`文件中使用以下代码实现类：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Compile your project to verify that the code was written without errors.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译您的项目以验证代码是否没有错误地编写。
- en: How it works...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: UInterfaces are implemented as a pair of classes declared in the interface's
    header.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: UInterfaces被实现为接口头文件中声明的一对类。
- en: As always, because we are leveraging Unreal's reflection system, we need to
    include our generated header file. Refer to *Handling events implemented via virtual
    functions* in [Chapter 5](part0070_split_000.html#22O7C1-c0ca69a0411046888a488e5085138121
    "Chapter 5. Handling Events and Delegates"), *Handling Events and Delegates*,
    for more information.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与往常一样，因为我们正在利用虚幻的反射系统，我们需要包含我们生成的头文件。有关更多信息，请参阅[第5章](part0070_split_000.html#22O7C1-c0ca69a0411046888a488e5085138121
    "第5章。处理事件和委托")中关于通过虚拟函数实现的事件处理，处理事件和委托。
- en: As with classes that inherit from `UObject`, which uses `UCLASS`, we need to
    use the `UINTERFACE` macro to declare our new `UInterface`.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与继承自`UObject`的类一样，它使用`UCLASS`，我们需要使用`UINTERFACE`宏来声明我们的新`UInterface`。
- en: The class is tagged `UE4COOKBOOK_API` to help with the exporting of library
    symbols.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该类被标记为`UE4COOKBOOK_API`，以帮助导出库符号。
- en: The base class for the `UObject` portion of the interface is `UInterface`.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UObject`部分的接口的基类是`UInterface`。'
- en: Just like `UCLASS` types, we require a macro to be placed inside the body of
    our class so that the auto-generated code is inserted into it.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像`UCLASS`类型一样，我们需要在类的主体中放置一个宏，以便自动生成的代码被插入其中。
- en: That macro is `GENERATED_BODY()` for UInterfaces. The macro must be placed at
    the very start of the class body.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于UInterfaces，该宏是`GENERATED_BODY()`。该宏必须放在类主体的开头。
- en: The second class is also tagged `UE4COOKBOOK_API`, and is named in a specific
    way.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个类也被标记为`UE4COOKBOOK_API`，并且以特定的方式命名。
- en: Note that the `UInterface`-derived class and the standard class have the same
    name but a different prefix. The `UInterface`-derived class has the prefix `U`,
    and the standard class has the prefix `I`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，`UInterface`派生类和标准类具有相同的名称，但具有不同的前缀。`UInterface`派生类具有前缀`U`，标准类具有前缀`I`。
- en: This is important as this is how the Unreal Header Tool expects the classes
    to be named for the code it generates to work properly.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这很重要，因为这是Unreal Header Tool期望类的命名方式，以使其生成的代码正常工作。
- en: The plain native Interface class requires its own autogenerated content, which
    we include using the `GENERATED_BODY()` macro.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 普通的本机接口类需要其自动生成的内容，我们使用`GENERATED_BODY()`宏包含它。
- en: We declare functions that classes inheriting the interface should implement
    inside `IInterface`.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`IInterface`内声明了类应该在内部实现的函数。
- en: Within the implementation file, we implement the constructor for our `UInterface`,
    as it is declared by the Unreal Header Tool, and requires an implementation.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现文件中，我们实现了我们的`UInterface`的构造函数，因为它是由Unreal Header Tool声明的，并且需要一个实现。
- en: We also create a default implementation for our `GetTestName()` function. Without
    this, the linking phase of compilation will fail. This default implementation
    uses the `unimplemented()` macro, which will issue a debug assert when the line
    of code is executed.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还为我们的`GetTestName()`函数创建了一个默认实现。如果没有这个，编译的链接阶段将失败。这个默认实现使用`unimplemented()`宏，当代码行被执行时会发出调试断言。
- en: See also
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Refer to *Passing payload data with a delegate binding* in [Chapter 5](part0070_split_000.html#22O7C1-c0ca69a0411046888a488e5085138121
    "Chapter 5. Handling Events and Delegates"), *Handling Events and Delegates*;
    the first recipe, in particular, explains some of the principles that we've applied
    here
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考[第5章](part0070_split_000.html#22O7C1-c0ca69a0411046888a488e5085138121 "第5章。处理事件和委托")中的*使用委托绑定传递有效负载数据*，*处理事件和委托*；特别是第一个示例解释了我们在这里应用的一些原则
- en: Implementing a UInterface on an object
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在对象上实现UInterface
- en: Ensure that you've followed the previous recipe in order to have a `UInterface`
    ready to be implemented.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已经按照前面的示例准备好要实现的`UInterface`。
- en: How to do it...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: Create a new `Actor` class using the Unreal Wizard, called `SingleInterfaceActor`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Unreal Wizard创建一个名为`SingleInterfaceActor`的新的`Actor`类。
- en: 'Add `IInterface`—in this case, `IMyInterface`—to the public inheritance list
    for our new `Actor` class:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`IInterface`—在本例中为`IMyInterface`—添加到我们新的`Actor`类的公共继承列表中：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add an `override` declaration to the class for the `IInterface` function(s)
    that we wish to override:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们希望重写的`IInterface`函数在类中添加一个`override`声明：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Implement the overridden function in the implementation file by adding the
    following code:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下代码在实现文件中实现重写的函数：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: C++ uses multiple inheritance for the way it implements interfaces, so we leverage
    that mechanism here with the declaration of our `SingleInterfaceActor` class,
    where we add `public IMyInterface`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C++使用多重继承来实现接口，因此我们在这里利用了这种机制，声明了我们的`SingleInterfaceActor`类，其中添加了`public IMyInterface`。
- en: We inherit from `IInterface` rather than `UInterface` to prevent `SingleInterfaceActor`
    from inheriting two copies of `UObject`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`IInterface`而不是`UInterface`继承，以防止`SingleInterfaceActor`继承两个`UObject`的副本。
- en: Given that the interface declares a `virtual` function, we need to redeclare
    that function with the override specifier if we wish to implement it ourselves.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 鉴于接口声明了一个`virtual`函数，如果我们希望自己实现它，我们需要使用override修饰符重新声明该函数。
- en: In our implementation file, we implement our overridden `virtual` function.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的实现文件中，我们实现了我们重写的`virtual`函数。
- en: Inside our function override, for demonstration purposes, we call the base `IInterface`
    implementation of the function. Alternatively, we could write our own implementation,
    and avoid calling the base class one altogether.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的函数重写中，为了演示目的，我们调用函数的基本`IInterface`实现。或者，我们可以编写自己的实现，并完全避免调用基类的实现。
- en: 'We use `IInterface:: specifier` rather than `Super`, because `Super` refers
    to the `UClass` that is the parent of our class, and IInterfaces aren''t UClasses
    (hence, no `U` prefix).'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '我们使用`IInterface:: specifier`而不是`Super`，因为`Super`指的是我们类的父类`UClass`，而IInterfaces不是UClasses（因此没有`U`前缀）。'
- en: You can implement a second, or multiple, IInterfaces on your object, as needed.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以根据需要在对象上实现第二个或多个IInterfaces。
- en: Checking if a class implements a UInterface
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查类是否实现了UInterface
- en: Follow the first two recipes so that you have a `UInterface` we can check for,
    and a class implementing the interface, which can be tested against.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 按照前两个示例，以便您有一个我们可以检查的`UInterface`，以及实现接口的类，可以对其进行测试。
- en: How to do it...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Inside your Game Mode implementation, add the following code to the `BeginPlay`
    function:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的游戏模式实现中，将以下代码添加到`BeginPlay`函数中：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Given that we are referencing both `ASingleInterfaceActor` and `IMyInterface`,
    we need to `#include` both `MyInterface.h` and `SingleInterfaceActor.h` in our
    Source file.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 鉴于我们引用了`ASingleInterfaceActor`和`IMyInterface`，我们需要在我们的源文件中`#include` `MyInterface.h`和`SingleInterfaceActor.h`。
- en: How it works...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Inside `BeginPlay`, we create an empty `FTransform` function, which has the
    default value of `0` for all translation and rotation components, so we don't
    need to explicitly set any of them.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BeginPlay`中，我们创建一个空的`FTransform`函数，它的默认值是所有平移和旋转分量的`0`，因此我们不需要显式设置任何分量。
- en: We then use the `SpawnActor` function from `UWorld` so that we can create an
    instance of our `SingleActorInterface`, storing the pointer to the instance into
    a temporary variable.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`UWorld`中的`SpawnActor`函数，这样我们就可以创建我们的`SingleActorInterface`的实例，并将指针存储到临时变量中。
- en: We then use `GetClass()` on our instance to get a reference to its associated
    `UClass`. We need a reference to `UClass,` because that object is the one which
    holds all of the reflection data for the object.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`GetClass()`在我们的实例上获取一个引用到其关联的`UClass`。我们需要一个对`UClass`的引用，因为该对象是保存对象的所有反射数据的对象。
- en: Reflection data includes the names and types of all `UPROPERTY` on the object,
    the inheritance hierarchy for the object, and a list of all the interfaces that
    it implements.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反射数据包括对象上所有`UPROPERTY`的名称和类型，对象的继承层次结构，以及它实现的所有接口的列表。
- en: As a result, we can call `ImplementsInterface()` on `UClass`, and it will return
    `true` if the object implements the `UInterface` in question.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们可以在`UClass`上调用`ImplementsInterface()`，如果对象实现了所讨论的`UInterface`，它将返回`true`。
- en: If the object implements the interface, and therefore, returns `true` from `ImplementsInterface`,
    we then print a message to the screen.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果对象实现了接口，因此从`ImplementsInterface`返回`true`，我们就会在屏幕上打印一条消息。
- en: See also
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 5](part0070_split_000.html#22O7C1-c0ca69a0411046888a488e5085138121
    "Chapter 5. Handling Events and Delegates"), *Handling Events and Delegates,*
    has a number of recipes relating to the spawning of actors'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第5章](part0070_split_000.html#22O7C1-c0ca69a0411046888a488e5085138121 "第5章。处理事件和委托"),
    *处理事件和委托*，有许多与生成actor相关的配方'
- en: Casting to a UInterface implemented in native code
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本机代码中实现UInterface的转换
- en: One advantage that UInterfaces provides you with as a developer is the ability
    to treat a collection of heterogeneous objects that implement a common interface
    as a collection of the same object, using `Cast< >` to handle the conversion.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，UInterfaces为您提供的一个优势是，使用`Cast< >`来处理转换，可以将实现共同接口的异构对象集合视为相同对象的集合。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that this won't work if your class implements the interface through
    a Blueprint.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您的类通过Blueprint实现接口，则此方法将无效。
- en: Getting ready
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should have a `UInterface`, and an `Actor` implementing the interface ready
    for this recipe.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该为此配方准备一个`UInterface`和一个实现接口的`Actor`。
- en: Create a new game mode using the wizard within Unreal, or optionally, reuse
    a project and `GameMode` from a previous recipe.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Unreal中的向导创建一个新的游戏模式，或者可选地，重用以前配方中的项目和`GameMode`。
- en: How to do it...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Open your game mode''s declaration, and add a new `UPROPERTY() macro` to it:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开游戏模式的声明，并向其中添加一个新的`UPROPERTY()宏`：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Add `#include "MyInterface.h"` to the header's include section.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头文件的包含部分添加`#include "MyInterface.h"`。
- en: 'Add the following within the game mode''s `BeginPlay` implementation:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在游戏模式的`BeginPlay`实现中添加以下内容：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Set the level's game mode override to your game mode, then drag a few instances
    of your custom Interface-implementing actor into the level.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将级别的游戏模式覆盖设置为您的游戏模式，然后将几个实现自定义接口的actor实例拖放到级别中。
- en: When you play your level, a message should be printed on screen that indicates
    the number of instances of the interface that have been implemented in Actors
    in the level:![How to do it...](img/00110.jpeg)
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您播放级别时，屏幕上应该打印一条消息，指示在级别中实现了接口的实例的数量：![操作步骤...](img/00110.jpeg)
- en: How it works...
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We create an array of pointers to `MyInterface` implementations.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个指向`MyInterface`实现的指针数组。
- en: Inside `BeginPlay`, we use `TActorIterator<AActor>` to get all of the `Actor`
    instances in our level.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BeginPlay`中，我们使用`TActorIterator<AActor>`来获取我们级别中的所有`Actor`实例。
- en: '`TActorIterator` has the following constructor:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TActorIterator`有以下构造函数：'
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`TActorIterator` expects a world to act on as well as a `UClass` instance to
    specify what type of Actors we are interested in.'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TActorIterator`期望一个要操作的世界，以及一个`UClass`实例来指定我们感兴趣的Actor类型。'
- en: '`ActorIterator` is an iterator like the STL iterator type. This means we can
    write a `for` loop of the following form:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ActorIterator`是类似STL迭代器类型的迭代器。这意味着我们可以编写以下形式的`for`循环：'
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Inside the loop, we dereference the iterator to get an `Actor` pointer.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环内，我们取消引用迭代器以获取`Actor`指针。
- en: We then attempt to cast it to our interface; this will return a pointer to the
    interface if it does implement it, else it will return `nullptr`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们尝试将其转换为我们的接口；如果它实现了它，这将返回一个指向接口的指针，否则将返回`nullptr`。
- en: As a result, we can check if the interface pointer is `null`, and if not, we
    can add the interface pointer reference to our array.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们可以检查接口指针是否为`null`，如果不是，我们可以将接口指针引用添加到我们的数组中。
- en: Finally, once we've iterated through all the actors in `TActorIterator`, we
    can display a message on the screen, which displays the count of items that implemented
    the interface.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，一旦我们遍历了`TActorIterator`中的所有actor，我们就可以在屏幕上显示一条消息，显示实现了接口的项目的计数。
- en: Calling native UInterface functions from C++
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从C++调用本机UInterface函数
- en: Follow the previous recipe to get an understanding of casting an `Actor` pointer
    to an Interface pointer.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 按照前一个配方来理解将`Actor`指针转换为接口指针。
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that as this recipe relies on the casting technique used in the previous
    recipe, it will only work with objects that implement the interface using C++
    rather than Blueprint. This is because Blueprint classes are not available at
    compile time, and so, technically, don't inherit the interface.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于此配方依赖于前一个配方中使用的转换技术，因此它只能与使用C++实现接口的对象一起使用，而不能与Blueprint一起使用。这是因为Blueprint类在编译时不可用，因此在技术上不继承该接口。
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: Create a new `Actor` class using the editor wizard. Call it `AntiGravityVolume`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用编辑向导创建一个新的`Actor`类。将其命名为`AntiGravityVolume`。
- en: Add `BoxComponent` to the new `Actor`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`BoxComponent`添加到新的`Actor`中。
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Override the following `Actor` `virtual` functions in the header:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头文件中重写以下`Actor` `virtual`函数：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create an implementation within your source file, as follows:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在源文件中创建一个实现，如下所示：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Initialize the `BoxComponent` in your constructor:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中初始化`BoxComponent`：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Create an interface called `GravityObject`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`GravityObject`的接口。
- en: 'Add the following `virtual` functions to `IGravityObject`:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`IGravityObject`中添加以下`virtual`函数：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create the default implementation of the `virtual` functions inside the `IGravityObject`
    implementation file:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`IGravityObject`实现文件中创建`virtual`函数的默认实现：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Create a subclass of `Actor` called `PhysicsCube`.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PhysicsCube`的`Actor`子类。
- en: 'Add a static mesh:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个静态网格：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Initialize the component in your constructor:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中初始化组件：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To have `PhysicsCube` implement `GravityObject`, first `#include "GravityObject.h"`
    in the header file, then modify the class declaration:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使`PhysicsCube`实现`GravityObject`，首先在头文件中`#include "GravityObject.h"`，然后修改类声明：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Compile your project.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译您的项目。
- en: Create a new level, and place an instance of our gravity volume in the scene.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的关卡，并在场景中放置一个重力体积的实例。
- en: Place an instance of `PhysicsCube` above the gravity volume, then rotate it
    slightly so that it has one corner lower than the others, as shown in the following
    image:![How to do it...](img/00111.jpeg)
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在重力体积上放置一个`PhysicsCube`的实例，然后稍微旋转它，使其有一个角落比其他角落低，如下图所示：![操作步骤...](img/00111.jpeg)
- en: Verify that the gravity is turned off on the object when it enters the volume,
    then turns back on again.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证当对象进入体积时重力被关闭，然后再次打开。
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the gravity volume doesn't need to know anything about your `PhysicsCube`
    actor, just the Gravity Object interface.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，重力体积不需要知道任何关于您的`PhysicsCube` actor的信息，只需要知道重力对象接口。
- en: How it works...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We create a new `Actor` class, and add a box component to give the actor something
    that will collide with the character. Alternatively, you could subclass `AVolume`
    if you wanted to use the BSP functionality to define the volume's shape.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个新的`Actor`类，并添加一个箱子组件，以便给角色添加一个会与角色发生碰撞的物体。或者，如果您想要使用BSP功能来定义体积的形状，您也可以对`AVolume`进行子类化。
- en: '`NotifyActorBeginOverlap` and `NotifyActorEndOverlap` are overridden so that
    we can perform some operation when an object enters or leaves the `AntiGravityVolume`
    area.'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`NotifyActorBeginOverlap`和`NotifyActorEndOverlap`，以便在对象进入或离开`AntiGravityVolume`区域时执行某些操作。
- en: Inside `NotifyActorBeginOverlap` implementation, we attempt to cast the object
    that overlapped us into an `IGravityObject` pointer.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NotifyActorBeginOverlap`实现中，我们尝试将与我们发生重叠的对象转换为`IGravityObject`指针。
- en: This tests if the object in question implements the interface.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个测试是为了检查所讨论的对象是否实现了该接口。
- en: If the pointer is valid, then the object does implement the interface, so it
    is safe to use the interface pointer to call interface methods on the object.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果指针有效，则对象确实实现了接口，因此可以安全地使用接口指针调用对象上的接口方法。
- en: Given that we are inside `NotifyActorBeginOverlap`, we want to disable the gravity
    on the object, so we call `DisableGravity()`.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 鉴于我们在`NotifyActorBeginOverlap`内部，我们希望禁用对象上的重力，因此我们调用`DisableGravity()`。
- en: Inside `NotifyActorEndOverlap`, we perform the same check, but we re-enable
    gravity on the object.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NotifyActorEndOverlap`内部，我们执行相同的检查，但是我们重新启用了对象的重力。
- en: Within the default implementation of `DisableGravity`, we cast our own pointer
    (the `this` pointer) to `AActor`.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DisableGravity`的默认实现中，我们将我们自己的指针（`this`指针）转换为`AActor`。
- en: This allows us to confirm that the interface has been implemented only on the
    `Actor` subclasses as well as to call methods defined in `AActor`.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这使我们能够确认接口仅在`Actor`子类上实现，并调用在`AActor`中定义的方法。
- en: If the pointer is valid, we know we are an `Actor`, so we can use `GetComponents<class
    ComponentType>()` to get a `TArray` of all components of a specific type from
    ourselves.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果指针有效，我们知道我们是一个`Actor`，所以我们可以使用`GetComponents<class ComponentType>()`来从自身获取特定类型的所有组件的`TArray`。
- en: '`GetComponents` is a `template` function. It expects some template parameters:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetComponents`是一个`template`函数。它需要一些模板参数：'
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Since the 2014 version of the standard, C++ supports compile-time deduction
    of template parameters. This means that we don't need to actually specify the
    template parameters when we call the function if the compiler can work them out
    from the normal function parameters that we provide.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自2014年标准以来，C++支持模板参数的编译时推断。这意味着如果编译器可以从我们提供的普通函数参数中推断出模板参数，那么在调用函数时我们不需要实际指定模板参数。
- en: The default implementation of `TArray` is `template<typename T, typename Allocator
    = FDefaultAllocator>` class `TArray;`
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TArray`的默认实现是`template<typename T, typename Allocator = FDefaultAllocator>`类`TArray;`'
- en: This means that we don't need to specify an allocator by default, so we just
    use `TArray<UPrimitiveComponent*>` when we declare the array.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这意味着我们不需要默认情况下指定分配器，因此当我们声明数组时，我们只使用`TArray<UPrimitiveComponent*>`。
- en: When `TArray` is passed into the `GetComponents` function, the compiler knows
    it is actually `TArray<UPrimitiveComponent*, FDefaultAllocator>`, and it is able
    to fill in the template parameters `T` and `AllocatorType` with `UPrimitiveComponent`
    and `FDefaultAllocator`, so neither of those are required as template parameters
    for the function's invocation.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`TArray`传递到`GetComponents`函数中时，编译器知道它实际上是`TArray<UPrimitiveComponent*, FDefaultAllocator>`，并且能够填充模板参数`T`和`AllocatorType`，所以在函数调用时不需要这两个作为模板参数。
- en: '`GetComponents` iterates through the components that `Actor` has, and any components
    that inherit from `typename T` have pointers to them stored inside the `PrimitiveComponents`
    array.'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetComponents`遍历`Actor`拥有的组件，并且从`typename T`继承的任何组件都有指针存储在`PrimitiveComponents`数组中。'
- en: Using a range-based `for` loop, another new feature of C++, we can iterate over
    the components that the function placed into our `TArray` without needing to use
    the traditional `for` loop structure.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用基于范围的`for`循环，这是C++的另一个新特性，我们可以在不需要使用传统的`for`循环结构的情况下迭代函数放入我们的`TArray`中的组件。
- en: Each of the components has `SetEnableGravity(false)` called on them, which disables
    gravity.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对每个组件调用`SetEnableGravity(false)`，这将禁用重力。
- en: Likewise, the `EnableGravity` function iterates over all the primitive components
    contained in the actor, and enables gravity with `SetEnableGravity(true)`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，`EnableGravity`函数遍历了actor中包含的所有primitive组件，并使用`SetEnableGravity(true)`启用了重力。
- en: See also
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Look at [Chapter 4](part0055_split_000.html#1KEEU1-c0ca69a0411046888a488e5085138121
    "Chapter 4. Actors and Components"), *Actors and Components,* for extensive discussions
    on Actors and Components. [Chapter 5,](part0070_split_000.html#22O7C1-c0ca69a0411046888a488e5085138121
    "Chapter 5. Handling Events and Delegates") *Handling Events and Delegates,* discusses
    events such as `NotifyActorOverlap`.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看[第4章](part0055_split_000.html#1KEEU1-c0ca69a0411046888a488e5085138121 "第4章。演员和组件"),
    *Actors and Components,* 详细讨论了演员和组件。[第5章](part0070_split_000.html#22O7C1-c0ca69a0411046888a488e5085138121
    "第5章。处理事件和委托"), *处理事件和委托,* 讨论了诸如`NotifyActorOverlap`之类的事件。
- en: Inheriting UInterface from one another
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相互继承UInterface
- en: Sometimes, you may need to create a `UInterface` that specializes on a more
    general `UInterface`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能需要创建一个更通用的`UInterface`专门用于`UInterface`。
- en: This recipe shows you how to use inheritance with UInterfaces to specialize
    a **Killable** interface with an **Undead** interface that cannot be killed by
    normal means.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方向您展示了如何使用UInterfaces继承来专门化一个**Killable**接口，使其具有无法通过正常手段杀死的**Undead**接口。
- en: How to do it...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: Create a `UINTERFACE`/`IInterface` called `UKillable`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`UKillable`的`UINTERFACE`/`IInterface`。
- en: Add `UINTERFACE(meta=(CannotImplementInterfaceInBlueprint))` to the `UInterface`
    declaration.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`UInterface`声明中添加`UINTERFACE(meta=(CannotImplementInterfaceInBlueprint))`。
- en: 'Add the following functions to the header file:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头文件中添加以下函数：
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Provide default implementations for the interface inside the implementation
    file:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现文件中为接口提供默认实现：
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a new `UINTERFACE`/`IInterface` called `Undead`. Modify them to inherit
    from `UKillable`/`IKillable`:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`UINTERFACE`/`IInterface`称为`Undead`。修改它们继承自`UKillable`/`IKillable`：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Ensure that you include the header defining the `Killable` interface.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您包含了定义`Killable`接口的头文件。
- en: 'Add some overrides and new method declarations to the new interface:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新接口中添加一些重写和新的方法声明：
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create implementations for the functions:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为函数创建实现：
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create two new `Actor` classes in C++: one called `Snail`, and the other called
    `Zombie`.'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在C++中创建两个新的`Actor`类：一个名为`Snail`，另一个名为`Zombie`。
- en: Set the `Snail` class to implement the `IKillable` interface, and add the appropriate
    header file, `#include`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Snail`类设置为实现`IKillable`接口，并添加适当的头文件`#include`。
- en: Likewise, set the `Zombie` class to implement `IUndead`, and `#include "Undead.h"`.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，将`Zombie`类设置为实现`IUndead`，并`#include "Undead.h"`。
- en: Compile your project.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译您的项目。
- en: Launch the editor, and drag an instance of both `Zombie` and `Snail` into your
    level.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动编辑器，将`Zombie`和`Snail`的实例拖入你的关卡中。
- en: Add a reference to each of them in the **Level Blueprints**.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**关卡蓝图**中为它们添加引用。
- en: Call `Die` (Message) on each reference.![How to do it...](img/00112.jpeg)
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个引用上调用`Die`（消息）。![操作步骤...](img/00112.jpeg)
- en: Connect the execution pins of the two message calls, then wire it up to `Event
    BeginPlay`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接两个消息调用的执行引脚，然后将其连接到`Event BeginPlay`。
- en: Run the game, and then verify that the `Zombie` is disdainful of your efforts
    to kill it, but the `Snail` groans and then dies (is removed from the world outliner).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏，然后验证`Zombie`对您的杀死尝试不屑一顾，但`Snail`呻吟着然后死去（从世界大纲中移除）。
- en: '![How to do it...](img/00113.jpeg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](img/00113.jpeg)'
- en: How it works...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: To make it possible to test this recipe in the **Level Blueprints**, we need
    to make the interface functions callable via blueprint, so we need the `BlueprintCallable`
    specifier on our `UFUNCTION`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够在**关卡蓝图**中测试这个配方，我们需要使接口函数可以通过蓝图调用，所以我们需要在我们的`UFUNCTION`上加上`BlueprintCallable`修饰符。
- en: However, in a `UInterface`, the compiler expects the interface to be implementable
    via both C++ and Blueprint by default. This conflicts with `BlueprintCallable`,
    which is merely saying that the function can be invoked from Blueprint, not that
    it can be overridden in it.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，在`UInterface`中，编译器默认期望接口可以通过C++和蓝图实现。这与`BlueprintCallable`冲突，后者仅表示该函数可以从蓝图中调用，而不是可以在其中被重写。
- en: We can resolve the conflict by marking the interface as `CannotImplementInterfaceInBlueprint`.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过将接口标记为`CannotImplementInterfaceInBlueprint`来解决冲突。
- en: This enables the use of `BlueprintCallable` as our `UFUNCTION` specifier rather
    than `BlueprintImplementableEvent` (which has extra overhead due to the extra
    code allowing for the function to be overridden via Blueprint).
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这使得我们可以使用`BlueprintCallable`作为我们的`UFUNCTION`修饰符，而不是`BlueprintImplementableEvent`（由于额外的代码允许通过蓝图重写函数而产生额外的开销）。
- en: We define `IsDead` and `Die` as `virtual` to enable them to be overridden in
    another C++ class which inherits this one.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`IsDead`和`Die`定义为`virtual`，以使它们可以在另一个继承此类的C++类中被重写。
- en: In our default interface implementation, `IsDead` always returns `false`.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的默认接口实现中，`IsDead`总是返回`false`。
- en: The default implementation of `Die` prints a death message to the screen, and
    then destroys the object implementing this interface if it is an `Actor`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`Die`的默认实现在屏幕上打印死亡消息，然后销毁实现此接口的对象（如果它是一个`Actor`）。'
- en: We can now create a second interface called `Undead`, which inherits from `Killable`.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个名为`Undead`的第二个接口，它继承自`Killable`。
- en: We use the `public UKillable`/`public IKillable` in the class declarations to
    express this.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在类声明中使用`public UKillable`/`public IKillable`来表示这一点。
- en: Of course, as a result, we need to include the header file that defines the
    `Killable` interface.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，结果是我们需要包含定义`Killable`接口的头文件。
- en: Our new interface overrides the two functions that `Killable` defines to provide
    more appropriate definitions of `IsDead`/`Die` for `Undead`.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的新接口重写了`Killable`定义的两个函数，以提供更合适的`Undead`的`IsDead`/`Die`定义。
- en: Our overridden definitions have `Undead` already dead by returning `true` from
    `IsDead`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的重写定义已经通过从`IsDead`返回`true`来使`Undead`已经死亡。
- en: When `Die` is called on `Undead`, we simply print a message with `Undead` laughing
    at our feeble attempt to kill it again, and do nothing.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`Die`在`Undead`上调用时，我们只是打印一条消息，`Undead`嘲笑我们试图再次杀死它的微弱尝试，并且什么也不做。
- en: We can also specify default implementations for our `Undead`-specific functions,
    namely `Turn()` and `Banish()`.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以为我们的`Undead`特定函数指定默认实现，即`Turn()`和`Banish()`。
- en: When `Undead` are Turned, they flee, and for demonstration purposes, we print
    a message to the screen.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`Undead`被转化时，它们会逃跑，为了演示目的，我们在屏幕上打印一条消息。
- en: If an `Undead` is Banished, however, they are annihilated and destroyed without
    a trace.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，如果`Undead`被放逐，它们将被消灭并毁灭得无影无踪。
- en: In order to test our implementation, we create two `Actors` that each inherit
    from one of the two interfaces.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试我们的实现，我们创建了两个`Actors`，每个都继承自两个接口中的一个。
- en: After we add an instance of each actor to our level, we use **Level Blueprints**
    to access the level's `BeginPlay` event.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的级别中添加每个角色的一个实例后，我们使用**级别蓝图**来访问级别的`BeginPlay`事件。
- en: When the level begins play, we use a message call to try and call the `Die`
    function on our instances.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当关卡开始播放时，我们使用消息调用来尝试在我们的实例上调用`Die`函数。
- en: The messages that print out are different, and correspond to the two function
    implementations showing that the Zombie's implementation of `Die` is different,
    and has overridden the Snail's.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出来的消息是不同的，并且对应于两个函数实现，显示了Zombie对`Die`的实现是不同的，并且已经覆盖了Snail的实现。
- en: Overriding UInterface functions in C++
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C++中重写UInterface函数
- en: One side effect of UInterfaces allowing inheritance in C++ is that we can override
    default implementations in subclasses as well as in Blueprint. This recipe shows
    you how to do so.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: UInterfaces允许C++中的继承的一个副作用是，我们可以在子类以及蓝图中覆盖默认实现。这个操作步骤向你展示了如何做到这一点。
- en: Getting ready
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Follow the recipe *Calling native UInterface functions from C++* in which a
    Physics Cube is created so that you have the class ready.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 按照*从C++调用本机UInterface函数*的步骤创建一个Physics Cube，以便你已经准备好这个类。
- en: How to do it...
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: Create a new Interface called `Selectable`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Selectable`的新接口。
- en: 'Define the following functions inside `ISelectable`:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ISelectable`中定义以下函数：
- en: '[PRE25]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Provide a default implementation for functions like this:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为这样的函数提供默认实现：
- en: '[PRE26]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Create a class based on `APhysicsCube` called `SelectableCube`.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基于`APhysicsCube`的类，名为`SelectableCube`。
- en: '`#include "Selectable.h"` inside the `SelectableCube` class'' header.'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SelectableCube`类的头文件中包含`#include "Selectable.h"`。
- en: 'Modify the `ASelectableCube` declaration like this:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`ASelectableCube`的声明如下：
- en: '[PRE27]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add the following functions to the header:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下函数添加到头文件中：
- en: '[PRE28]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Implement the functions:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现以下函数：
- en: '[PRE29]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Create a new class, called `NonSelectableCube`, which inherits from `SelectableCube`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`NonSelectableCube`的新类，它继承自`SelectableCube`。
- en: '`NonSelectableCube` should override the functions from `SelectableInterface`:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`NonSelectableCube`应该覆盖`SelectableInterface`中的函数：'
- en: '[PRE30]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The implementation file should be altered to include the following:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现文件应该被修改以包括以下内容：
- en: '[PRE31]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Place an instance of `SelectableCube` into the level at a certain range above
    the ground, and play your game. You should get messages verifying that the actor
    is selectable, and that it has accepted the selection, when the cube hits the
    ground.![How to do it...](img/00114.jpeg)
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`SelectableCube`的实例放置在离地面一定范围的级别中，并播放游戏。当方块触地时，您应该收到验证该角色可选择并已接受选择的消息。![操作步骤...](img/00114.jpeg)
- en: Remove `SelectableCube` and replace it with an instance of `NonSelectableCube`
    to see the alternative messages indicating that this actor isn't selectable, and
    has refused selection.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`SelectableCube`并用`NonSelectableCube`的实例替换，以查看替代消息，指示该角色不可选择，并拒绝选择。
- en: How it works...
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We create three functions inside the `Selectable` interface.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`Selectable`接口中创建了三个函数。
- en: '`IsSelectable` returns a Boolean to indicate if the object is selectable. You
    could avoid this and simply use `TrySelect`, given that it returns a Boolean value
    to indicate success, but, for example, you might want to know if the object inside
    your UI is a valid selection without having to actually try it.'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IsSelectable`返回一个布尔值，表示对象是否可选择。你可以避免这样做，只需使用`TrySelect`，因为它返回一个布尔值来表示成功，但是，例如，你可能想知道你的UI内的对象是否是有效的选择，而不必实际尝试。'
- en: '`TrySelect` actually attempts to select the object. There''s no explicit contract
    forcing users to respect `IsSelectable` when trying to select the object, so `TrySelect`
    is named to communicate that the selection may not always succeed.'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TrySelect`实际上尝试选择对象。没有明确的合同强制用户在尝试选择对象时尊重`IsSelectable`，因此`TrySelect`的命名是为了传达选择可能并不总是成功。'
- en: Lastly, `Deselect` is a function added to allow objects to handle losing the
    player selection. This could involve changing the UI elements, halting sounds
    or other visual effects, or simply removing a selection outline from around the
    unit.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`Deselect`是一个添加的函数，允许对象处理失去玩家选择。这可能涉及更改UI元素，停止声音或其他视觉效果，或者只是从单位周围移除选择轮廓。
- en: The default implementations of the functions return `true` for `IsSelectable`
    (the default is for any object to be selectable), `true` for `TrySelect` (selection
    attempts always succeed), and issues a debug assert if `Deselect` is called without
    being implemented by the class.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数的默认实现返回`true`表示`IsSelectable`（默认情况下，任何对象都是可选择的），返回`true`表示`TrySelect`（选择尝试总是成功），如果在没有被类实现的情况下调用`Deselect`，则会发出调试断言。
- en: You could also implement `Deselect` as a pure `virtual` function if you wish.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果愿意，也可以将`Deselect`实现为纯虚函数。
- en: '`SelectableCube` is a new class inheriting from `PhysicsCube`, but also implementing
    the `ISelectable` interface.'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SelectableCube`是一个新的类，继承自`PhysicsCube`，同时实现了`ISelectable`接口。'
- en: It also overrides `NotifyHit`, a `virtual` function defined in `AActor` that
    triggers when the actor undergoes a **RigidBody** collision.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它还覆盖了`NotifyHit`，这是在`AActor`中定义的一个`virtual`函数，当演员经历**RigidBody**碰撞时触发。
- en: We call the constructor from `PhysicsCube` with the `Super()` constructor call
    inside the implementation of `SelectableCube`. We then add our own implementation,
    which calls `SetNotifyRigidBodyCollision(true)` on our static mesh instance. This
    is necessary, because by default, RigidBodies (such as `PrimitiveComponents` with
    a collision) don't trigger `Hit` events as a performance optimization. As a result,
    our overridden `NotifyHit` function would never be called.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`SelectableCube`的实现中使用`Super()`构造函数调用来调用`PhysicsCube`的构造函数。然后，我们添加我们自己的实现，它在我们的静态网格实例上调用`SetNotifyRigidBodyCollision(true)`。这是必要的，因为默认情况下，刚体（例如具有碰撞的`PrimitiveComponents`）不会触发`Hit`事件，以进行性能优化。因此，我们重写的`NotifyHit`函数将永远不会被调用。
- en: Within the implementation of `NotifyHit`, we call some of the `ISelectable`
    interface functions on ourselves. Given that we know we are an object that inherits
    from `ISelectable`, we don't need to cast to an `ISelectable*` in order to call
    them.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NotifyHit`的实现中，我们在自身上调用了一些`ISelectable`接口函数。鉴于我们知道我们是从`ISelectable`继承的对象，我们无需转换为`ISelectable*`即可调用它们。
- en: We check to see if the object is selectable with `IsSelectable`, and if so,
    we try to actually perform the selection using `TrySelect`.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`IsSelectable`来检查对象是否可选择，如果是，则尝试使用`TrySelect`来实际执行选择。
- en: '`NonSelectableCube` inherits from `SelectableCube`, so we can force the object
    to never be selectable.'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`NonSelectableCube`继承自`SelectableCube`，因此我们可以强制该对象永远不可选择。'
- en: We accomplish this by overriding the `ISelectable` interface functions again.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过再次重写`ISelectable`接口函数来实现这一点。
- en: Within `ANonSelectableCube::IsSelectable()`, we print a message to the screen
    so we can verify that the function is being called, and then return `false` to
    indicate that the object isn't selectable at all.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ANonSelectableCube::IsSelectable()`中，我们在屏幕上打印一条消息，以便我们可以验证该函数是否被调用，然后返回`false`以指示该对象根本不可选择。
- en: In case the user doesn't respect `IsSelectable()`, `ANonSelectableCube::TrySelect()`
    always returns `false` to indicate that the selection wasn't successful.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户不尊重`IsSelectable()`，`ANonSelectableCube::TrySelect()`始终返回`false`，以指示选择不成功。
- en: Given that it is impossible for `NonSelectableCube` to be selected, `Deselect()`
    calls `unimplemented()`, which throws an assert warning that the function was
    not implemented.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 鉴于不可能选择`NonSelectableCube`，`Deselect()`调用`unimplemented()`，这会引发一个断言警告，指出该函数未被实现。
- en: Now, when playing your scene, each time `SelectableCube`/`NonSelectableCube`
    hits another object, causing a RigidBody collision, the actor in question will
    attempt to select itself, and print messages to the screen.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在播放场景时，每当`SelectableCube`/`NonSelectableCube`撞击另一个物体，导致刚体碰撞时，相关的角色将尝试选择自己，并在屏幕上打印消息。
- en: See also
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Refer [Chapter 6](part0079_split_000.html#2BASE1-c0ca69a0411046888a488e5085138121
    "Chapter 6. Input and Collision"), *Input and Collision,* which shows you how
    to **Raycast** from the mouse cursor into the game world to determine what is
    being clicked on, and could be used to extend this recipe to allow the player
    to click on items to select them
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见[第6章](part0079_split_000.html#2BASE1-c0ca69a0411046888a488e5085138121 "第6章.输入和碰撞")，*输入和碰撞*，其中向您展示了如何**从鼠标光标向游戏世界进行射线投射**，并且可以用于扩展此示例以允许玩家点击物品进行选择
- en: Exposing UInterface methods to Blueprint from a native base class
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从本地基类向蓝图公开UInterface方法
- en: Being able to define `UInterface` methods in C++ is great, but they should be
    accessible from Blueprint too. Otherwise, designers or others who are using Blueprint
    won't be able to interact with your `UInterface`. This recipe shows you how to
    make a function from an interface callable within the Blueprint system.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在C++中定义`UInterface`方法非常好，但它们也应该从蓝图中可访问。否则，使用蓝图的设计师或其他人将无法与您的`UInterface`进行交互。本示例向您展示了如何使接口中的函数在蓝图系统中可调用。
- en: How to do it...
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Create a `UInterface` called `UPostBeginPlay`/`IPostBeginPlay`.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`UPostBeginPlay`/`IPostBeginPlay`的`UInterface`。
- en: 'Add the following `virtual` method to `IPostBeginPlay`:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`IPostBeginPlay`添加以下`virtual`方法：
- en: '[PRE32]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Provide an implementation of the function:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供函数的实现：
- en: '[PRE33]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Create a new `Actor` class called `APostBeginPlayTest`.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`APostBeginPlayTest`的新的`Actor`类。
- en: 'Modify the class declaration so that it also inherits `IPostBeginPlay`:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改类声明，使其还继承`IPostBeginPlay`：
- en: '[PRE34]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Compile your project. Inside the editor, drag an instance of `APostBeginPlayTest`
    into your level. With the instance selected, click on **Open Level Blueprint**:![How
    to do it...](img/00115.jpeg)
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译您的项目。在编辑器内，将`APostBeginPlayTest`的实例拖入您的级别中。选择该实例，单击**打开级别蓝图**：![如何做...](img/00115.jpeg)
- en: Inside the Level Blueprint, right-click and **Create a Reference to PostBeginPlayTest1**.![How
    to do it...](img/00116.jpeg)
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在级别蓝图内，右键单击并**创建对PostBeginPlayTest1的引用**。![如何做...](img/00116.jpeg)
- en: Drag away from the blue pin on the right-hand side of your actor reference,
    then search the context menu for `onpost` to see your new interface function available.
    Click on it to insert a call to your native `UInterface` implementation from Blueprint.![How
    to do it...](img/00117.jpeg)
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从actor引用的右侧蓝色引脚拖动，然后在上下文菜单中搜索`onpost`，以查看您的新接口函数是否可用。单击它以在蓝图中插入对本机`UInterface`实现的调用。![如何做...](img/00117.jpeg)
- en: Finally, connect the execution pin (white arrow) from the `BeginPlay` node to
    the execution pin for `OnPostBeginPlay`.![How to do it...](img/00118.jpeg)
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将`BeginPlay`节点的执行引脚（白色箭头）连接到`OnPostBeginPlay`的执行引脚。![如何做...](img/00118.jpeg)
- en: When you play your level, you should see the message **PostBeginPlay called**
    visible on screen for a short amount of time verifying that Blueprint has successfully
    accessed and called through to your native code implementation of the `UInterface`.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您播放级别时，您应该看到屏幕上出现**PostBeginPlay called**的消息，验证蓝图已成功访问并调用了您的`UInterface`的本地代码实现。
- en: How it works...
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `UINTERFACE`/`IInterface` pair function as in other recipes, with the `UInterface`
    containing reflection information and other data, and the `IInterface` functioning
    as the actual interface class that can be inherited from.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UINTERFACE`/`IInterface`对在其他示例中的功能一样，`UInterface`包含反射信息和其他数据，而`IInterface`作为实际的接口类，可以被继承。'
- en: The most significant element that allows the function inside `IInterface` to
    be exposed to Blueprint is the `UFUNCTION` specifier.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许`IInterface`内部函数暴露给蓝图的最重要的元素是`UFUNCTION`修饰符。
- en: '`BlueprintCallable` marks this function as one that can be called from the
    Blueprint system.'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BlueprintCallable`标记此函数可以从蓝图系统中调用。'
- en: Any functions exposed to Blueprint in any way require a `Category` value also.
    This `Category` value specifies the heading under which the function will be listed
    in the context menu.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以任何方式暴露给蓝图的函数也需要一个`Category`值。这个`Category`值指定了函数在上下文菜单中将被列在哪个标题下。
- en: The function must also be marked `virtual`—this is so that a class that implements
    the interface via native code can override the implementations of the functions
    inside it. Without the `virtual` specifier, the Unreal Header Tool will give you
    an error indicating that you have to either add `virtual`, or `BlueprintImplementableEvent`
    as a `UFUNCTION` specifier.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该函数还必须标记为`virtual`，这样通过本地代码实现接口的类可以重写其中的函数实现。如果没有`virtual`修饰符，虚幻头部工具将给出一个错误，指示您必须添加`virtual`或`BlueprintImplementableEvent`作为`UFUNCTION`修饰符。
- en: The reason for this is that without either of those, the interface function
    wouldn't be overridable in C++ (due to the absence of `virtual`), or Blueprint
    (because `BlueprintImplementableEvent` was missing). An interface that can't be
    overridden, but only inherited, has limited utility, so Epic have chosen not to
    support it within UInterfaces.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样做的原因是，如果没有这两者中的任何一个，接口函数将无法在C++中被重写（由于缺少`virtual`），或者在蓝图中（因为缺少`BlueprintImplementableEvent`）。一个不能被重写，只能被继承的接口具有有限的实用性，因此Epic选择不在UInterfaces中支持它。
- en: We then provide a default implementation of the `OnPostBeginPlay` function,
    which uses the `GEngine` pointer to display a debug message confirming that the
    function was invoked.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们提供了`OnPostBeginPlay`函数的默认实现，它使用`GEngine`指针来显示一个调试消息，确认函数被调用。
- en: See also
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Refer to [Chapter 8](part0102_split_000.html#318PC1-c0ca69a0411046888a488e5085138121
    "Chapter 8. Integrating C++ and the Unreal Editor"), *Integrating C++ and the
    Unreal Editor,* for a number of recipes showing how you can integrate your C++
    classes with Blueprint
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关如何将C++类与蓝图集成的多个示例，请参阅[第8章](part0102_split_000.html#318PC1-c0ca69a0411046888a488e5085138121
    "第8章。集成C++和虚幻编辑器")*集成C++和虚幻编辑器*。
- en: Implementing UInterface functions in Blueprint
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在蓝图中实现UInterface函数
- en: One of the key advantages of UInterface in Unreal is the ability for users to
    implement `UInterface` functions in the editor. This means the interface can be
    implemented strictly in Blueprint without needing any C++ code, which is helpful
    to designers.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 虚幻中UInterface的一个关键优势是用户能够在编辑器中实现`UInterface`函数。这意味着接口可以严格在蓝图中实现，而不需要任何C++代码，这对设计师来说是有帮助的。
- en: How to do it...
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a new `UInterface` called `AttackAvoider`.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`AttackAvoider`的新`UInterface`。
- en: 'Add the following function declaration to the header:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下函数声明添加到头文件：
- en: '[PRE35]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Create a new **Blueprint Class** within the Editor:![How to do it...](img/00119.jpeg)
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中创建一个新的**蓝图类**：![如何操作...](img/00119.jpeg)
- en: Base the class on **Actor**:![How to do it...](img/00120.jpeg)
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类基于**Actor**：![如何操作...](img/00120.jpeg)
- en: Open **Class Settings**:![How to do it...](img/00121.jpeg)
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**类设置**：![如何操作...](img/00121.jpeg)
- en: Click on the drop-down menu for **Implement Interface**, and select **AttackAvoider**:![How
    to do it...](img/00122.jpeg)
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**实现接口**的下拉菜单，并选择**AttackAvoider**：![如何操作...](img/00122.jpeg)
- en: '**Compile** your blueprint:![How to do it...](img/00123.jpeg)'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编译**您的蓝图：![如何操作...](img/00123.jpeg)'
- en: Right-click in the Event Graph, and type `event attack`. Within the **Context
    Sensitive** menu, you should see **Event Attack Incoming**. Select it to place
    an event node in your graph:![How to do it...](img/00124.jpeg)
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件图中右键单击，输入`event attack`。在**上下文敏感**菜单中，您应该看到**Event Attack Incoming**。选择它以在图表中放置一个事件节点：![如何操作...](img/00124.jpeg)
- en: Drag out from the execution pin on the new node, and release. Type `print string`
    into the **Context Sensitive** menu to add a **Print String** node.![How to do
    it...](img/00125.jpeg)
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新节点的执行引脚中拖出，并释放。在**上下文敏感**菜单中输入`print string`以添加一个**Print String**节点。![如何操作...](img/00125.jpeg)
- en: You have now implemented a `UInterface` function within Blueprint.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在已经在蓝图中实现了一个`UInterface`函数。
- en: How it works...
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `UINTERFACE`/`IInterface` are created in exactly the same way that we see
    in other recipes in this chapter.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UINTERFACE`/`IInterface`的创建方式与本章其他示例中看到的完全相同。'
- en: 'When we add a function to the interface, however, we use a new `UFUNCTION`
    specifier: `BlueprintImplementableEvent`.'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，当我们向接口添加一个函数时，我们使用一个新的`UFUNCTION`修饰符：`BlueprintImplementableEvent`。
- en: '`BlueprintImplementableEvent` tells the Unreal Header Tool to generate code
    that creates an empty stub function that can be implemented by Blueprint. We do
    not need to provide a default C++ implementation for the function.'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BlueprintImplementableEvent` 告诉虚幻头部工具生成代码，创建一个空的存根函数，可以由蓝图实现。我们不需要为函数提供默认的C++实现。'
- en: We implement the interface inside Blueprint, which exposes the function for
    us in a way that allows us to define its implementation in Blueprint.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在蓝图中实现接口，这样就可以以一种允许我们在蓝图中定义其实现的方式暴露函数。
- en: The autogenerated code created by the header tool forwards the calls to the
    `UInterface` function to our Blueprint implementation.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 头部工具生成的自动生成代码将`UInterface`函数的调用转发到我们的蓝图实现。
- en: See also
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The following recipe shows you how to define a default implementation for your
    `UInterface` function in C++, then optionally override it in Blueprint if necessary
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下示例向您展示了如何在C++中为您的`UInterface`函数定义默认实现，然后在必要时在蓝图中进行覆盖
- en: Creating C++ UInterface function implementations that can be overridden in Blueprint
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建C++ UInterface函数实现，可以在蓝图中被覆盖
- en: Just as with the previous recipe, UInterfaces are useful, but that utility is
    severely limited without their functionality being usable by designers.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前的示例一样，UInterfaces很有用，但如果设计者无法使用其功能，那么其效用将受到严重限制。
- en: The previous recipe shows you how to call C++ `UInterface` functions from Blueprint;
    this recipe will show you how to replace the implementation of a `UInterface`
    function with your own custom Blueprint-only function.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个示例向您展示了如何从蓝图中调用C++ `UInterface`函数；这个示例将向您展示如何用自己的自定义蓝图函数替换`UInterface`函数的实现。
- en: How to do it...
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: Create a new interface called `Wearable` (`IWearable`, `UWearable`).
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Wearable`（`IWearable`，`UWearable`）的新接口。
- en: 'Add the following functions to the header:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头文件中添加以下函数：
- en: '[PRE36]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add the following function implementations in the implementation file:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现文件中添加以下函数实现：
- en: '[PRE37]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Create a new `Actor` class called `Boots` inside the editor.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中创建一个名为`Boots`的新`Actor`类。
- en: Add `#include "Wearable.h"` to the header file for `Boots`.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Boots`的头文件中添加`#include "Wearable.h"`。
- en: 'Modify the class declaration as follows:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改类声明如下：
- en: '[PRE38]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Add the following implementation of the pure `virtual` functions created by
    our Interface:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加我们接口创建的纯`virtual`函数的以下实现：
- en: '[PRE39]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Create a new Blueprint class called `Gloves` based on `Actor`.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基于`Actor`的名为`Gloves`的新蓝图类。
- en: In the class settings, select `Wearable` as the interface that the `Gloves`
    actor will implement.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类设置中，选择`Wearable`作为`Gloves`角色将实现的接口。
- en: Within `Gloves`, override the `OnEquip` function like this:![How to do it...](img/00126.jpeg)
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Gloves`中，像这样重写`OnEquip`函数：![操作步骤...](img/00126.jpeg)
- en: Drag a copy of both `Gloves` and `Boots` into your level for testing purposes.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Gloves`和`Boots`的副本拖到您的级别中进行测试。
- en: Add the following blueprint code to your level:![How to do it...](img/00127.jpeg)
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的级别中添加以下蓝图代码：![操作步骤...](img/00127.jpeg)
- en: Verify that `Boots` performs the default behavior, but `Gloves` performs the
    blueprint-defined behavior.![How to do it...](img/00128.jpeg)
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证`Boots`执行默认行为，但`Gloves`执行蓝图定义的行为。![操作步骤...](img/00128.jpeg)
- en: How it works...
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'This recipe uses two `UFUNCTION` specifiers together: `BlueprintNativeEvent`
    and `BlueprintCallable`.'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个示例同时使用了两个`UFUNCTION`修饰符：`BlueprintNativeEvent`和`BlueprintCallable`。
- en: '`BlueprintCallable` has been shown in previous recipes, and is a way of marking
    your `UFUNCTION` as visible and invokable in the Blueprint Editor.'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BlueprintCallable`在以前的示例中已经展示过，它是一种将`UFUNCTION`标记为在蓝图编辑器中可见和可调用的方法。'
- en: '`BlueprintNativeEvent` signifies a `UFUNCTION` that has a default C++ (native
    code) implementation, but is also overridable in Blueprint. It''s the combination
    of a virtual function along with `BlueprintImplementableEvent`.'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BlueprintNativeEvent`表示一个具有默认C++（本机代码）实现的`UFUNCTION`，但也可以在蓝图中被覆盖。它是虚函数和`BlueprintImplementableEvent`的组合。'
- en: In order for this mechanism to work, the Unreal Header Tool generates the body
    of your functions so that the Blueprint version of the function is called if it
    exists; otherwise, it dispatches the method call through to the native implementation.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这种机制工作，虚幻头部工具生成函数的主体，以便如果存在函数的蓝图版本，则调用该函数的蓝图版本；否则，将方法调用分派到本机实现。
- en: In order to separate your default implementation from the dispatch functionality
    though, UHT defines a new function that takes its name from your declared function,
    but appends `_Implementation` to the end.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将默认实现与分发功能分开，UHT定义了一个新函数，该函数以您声明的函数命名，但在末尾添加了`_Implementation`。
- en: This is why the header file declares `GetStrengthRequirement`, but has no implementation,
    because that is autogenerated.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是为什么头文件声明了`GetStrengthRequirement`，但没有实现，因为那是自动生成的。
- en: It is also why your implementation file defines `GetStrengthRequirement_Implementation`,
    but there is no declaration for it, because it is also autogenerated.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这也是为什么您的实现文件定义了`GetStrengthRequirement_Implementation`，但没有声明它，因为它也是自动生成的。
- en: The `Boots` class implements `IWearable`, but doesn't override the default functionality.
    However, because the `_Implementation` functions are defined as `virtual`, we
    still need to explicitly implement the interface functions, and then call the
    default implementation directly.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Boots`类实现了`IWearable`，但没有覆盖默认功能。但是，因为`_Implementation`函数被定义为`virtual`，我们仍然需要显式实现接口函数，然后直接调用默认实现。'
- en: In contrast, `Gloves` also implements `IWearable`, but has an overridden implementation
    for `OnEquip` defined in Blueprint.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相比之下，`Gloves`也实现了`IWearable`，但在蓝图中为`OnEquip`定义了一个重写的实现。
- en: This can be verified when we use **Level Blueprints** to call `OnEquip` for
    the two actors.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们使用**级别蓝图**调用这两个角色的`OnEquip`时，可以验证这一点。
- en: Calling Blueprint-defined interface functions from C++
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从C++调用蓝图定义的接口函数
- en: 'While the previous recipes have focused on C++ being usable in Blueprint, such
    as being able to call functions from C++ in Blueprint, and override C++ functions
    with Blueprint, this recipe shows you the reverse: calling a Blueprint-defined
    interface function from C++.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然以前的示例侧重于C++在蓝图中的可用性，比如能够从蓝图中调用C++函数，并用蓝图覆盖C++函数，但这个示例展示了相反的情况：从C++调用蓝图定义的接口函数。
- en: How to do it...
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: Create a new `UInterface` called `UTalker`/`ITalker`.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`UTalker`/`ITalker`的新`UInterface`。
- en: 'Add the following `UFUNCTION` implementation:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下`UFUNCTION`实现：
- en: '[PRE40]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Provide a default empty implementation inside the `.cpp` file:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`.cpp`文件中提供一个默认的空实现：
- en: '[PRE41]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Create a new class based on `StaticMeshActor`.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基于`StaticMeshActor`的新类。
- en: 'Add `#include` and modify the class declaration to include the talker interface:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`#include`并修改类声明以包括talker接口：
- en: '[PRE42]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Also, add the following function to the class declaration:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要在类声明中添加以下函数：
- en: '[PRE43]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Within the implementation, add the following to the constructor:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现中，将以下内容添加到构造函数中：
- en: '[PRE44]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Create a new class based on `DefaultPawn` to function as our player character.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基于“DefaultPawn”的新类，作为我们的玩家角色的功能。
- en: 'Add some `UPROPERTY`/`UFUNCTION` to our class header:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的类头文件中添加一些“UPROPERTY”/“UFUNCTION”：
- en: '[PRE45]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Modify the constructor:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改构造函数：
- en: '[PRE46]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Implement `OnTalkOverlap`:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现“OnTalkOverlap”：
- en: '[PRE47]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Create a new `GameMode`, and set `TalkingPawn` as the default pawn class for
    the player.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的“GameMode”，并将“TalkingPawn”设置为玩家的默认pawn类。
- en: Drag an instance of your `ATalkingMesh` class into the level.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的“ATalkingMesh”类的一个实例拖入级别中。
- en: Create a new Blueprint class based on `ATalkingMesh` by right-clicking on it,
    and selecting the appropriate option from the context menu:![How to do it...](img/00129.jpeg)
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键单击它并从上下文菜单中选择适当的选项，基于“ATalkingMesh”创建一个新的蓝图类：![如何做...](img/00129.jpeg)
- en: Name it `MyTalkingMesh`.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为“MyTalkingMesh”。
- en: Inside the blueprint editor, create an implementation for `StartTalking` like
    this:![How to do it...](img/00130.jpeg)
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在蓝图编辑器中，创建一个像这样的“StartTalking”实现：![如何做...](img/00130.jpeg)
- en: Drag a copy of your new Blueprint into the level beside your `ATalkingMesh`
    instance.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的新蓝图的副本拖入级别中，放在您的“ATalkingMesh”实例旁边。
- en: Walk up to the two actors, and verify that your custom Pawn is correctly invoking
    either the default C++ implementation or the Blueprint implementation, as appropriate.![How
    to do it...](img/00131.jpeg)
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 走近这两个演员，并验证您的自定义Pawn是否正确调用了默认的C++实现或蓝图实现。![如何做...](img/00131.jpeg)
- en: How it works...
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As always, we create a new interface, and then add some function definitions
    to the `IInterface` class.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一如既往，我们创建一个新的接口，然后在“IInterface”类中添加一些函数定义。
- en: We use the `BlueprintNativeEvent` specifier to indicate that we want to declare
    a default implementation in C++ that can then be overridden in Blueprint.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用“BlueprintNativeEvent”说明符来指示我们希望在C++中声明一个默认实现，然后可以在蓝图中进行重写。
- en: We create a new class (inheriting from `StaticMeshActor` for convenience), and
    implement the interface on it.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个新的类（从“StaticMeshActor”继承以方便起见），并在其上实现了接口。
- en: In the implementation of the new class constructor, we load a static mesh, and
    set our collision as usual.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新类构造函数的实现中，我们加载了一个静态网格，并像往常一样设置了我们的碰撞。
- en: We then add an implementation for our interface function, which simply prints
    a message to the screen.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们为我们的接口函数添加了一个实现，它只是在屏幕上打印一条消息。
- en: If you were using this in a full-blown project, you could play animations, play
    audio, alter the user interface, and whatever else was necessary to start a conversation
    with your `Talker`.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您在一个完整的项目中使用这个，您可以播放动画，播放音频，修改用户界面，以及其他必要的操作来开始与您的“Talker”对话。
- en: At this point, though, we don't have anything to actually call `StartTalking`
    on our `Talker`.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，此时，我们实际上没有任何东西来调用我们的“Talker”上的“StartTalking”。
- en: The simplest way to implement this is to create a new `Pawn` subclass (again,
    inheriting from `DefaultPawn` for convenience) that can start talking to any `Talker`
    actors that it collides with.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现这一点的最简单方法是创建一个新的“Pawn”子类（再次从“DefaultPawn”继承以方便起见），它可以开始与任何与之发生碰撞的“Talker”演员交谈。
- en: In order for this to work, we create a new `BoxComponent` to establish the radius
    at which we will trigger a conversation.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使其工作，我们创建了一个新的“BoxComponent”来建立我们将触发对话的半径。
- en: As always, it is a `UPROPERTY`, so it won't get garbage collected.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一如既往，这是一个“UPROPERTY”，因此它不会被垃圾回收。
- en: We also create the definition for a function that will get triggered when the
    new `BoxComponent` overlaps another `Actor` in the scene.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还为一个函数创建了定义，当新的“BoxComponent”与场景中的另一个“Actor”重叠时将被触发。
- en: The constructor for our `TalkingPawn` initializes the new `BoxComponent`, and
    sets its extents appropriately.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的“TalkingPawn”的构造函数初始化了新的“BoxComponent”，并适当设置了其范围。
- en: The constructor also binds the `OnTalkOverlap` function as an event handler
    to handle collisions with our `BoxComponent`.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数还将“OnTalkOverlap”函数绑定为事件处理程序，以处理与我们的“BoxComponent”发生碰撞。
- en: It also attaches the box component to our `RootComponent` so that it moves with
    the rest of the player character as the player moves around the level.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它还将盒组件附加到我们的“RootComponent”，以便随着玩家在级别中移动而移动。
- en: Inside `OnTalkOverlap`, we need to check if the other actor, which is overlapping
    our box, implements the `Talker` interface.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“OnTalkOverlap”内部，我们需要检查另一个演员是否实现了与我们的盒子重叠的“Talker”接口。
- en: The most reliable way to do this is with the `ImplementsInterface` function
    in `UClass`. This function uses the class information generated by the Unreal
    Header Tool during compilation, and correctly handles both C++ and Blueprint-implemented
    interfaces.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最可靠的方法是使用“UClass”中的“ImplementsInterface”函数。这个函数使用Unreal Header Tool在编译期间生成的类信息，并正确处理C++和蓝图实现的接口。
- en: If the function returns `true`, we can use a special autogenerated function
    contained in our `IInterface` to invoke the interface method of our choice on
    our instance.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果函数返回“true”，我们可以使用我们的“IInterface”中包含的特殊自动生成的函数来调用我们实例上所选择的接口方法。
- en: This is a static method of the form `<IInterface>::Execute_<FunctionName>`.
    In our instance, our `IInterface` is `ITalker`, and the function is `StartTalking`,
    so the function we want to invoke is `ITalker::Execute_StartTalking()`.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个形式为“<IInterface>::Execute_<FunctionName>”的静态方法。在我们的实例中，我们的“IInterface”是“ITalker”，函数是“StartTalking”，所以我们要调用的函数是“ITalker::Execute_StartTalking()”。
- en: The reason we need this function is that when an interface is implemented in
    Blueprint, the relationship isn't actually established at compile time. C++ is,
    therefore, not aware of the fact that the interface is implemented, and so we
    can't cast the Blueprint class to `IInterface` to call functions directly.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要这个函数的原因是，当一个接口在蓝图中实现时，关系实际上并没有在编译时建立。因此，C++并不知道接口已经实现，因此我们无法将蓝图类转换为“IInterface”以直接调用函数。
- en: The `Execute_` functions take a pointer to the object that implements the interface,
    and call a number of internal methods to invoke the desired function's Blueprint
    implementation.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “Execute_”函数接受实现接口的对象的指针，并调用一些内部方法来调用所需函数的蓝图实现。
- en: When you play the level, and walk around, the custom `Pawn` is constantly receiving
    notifications when it's `BoxComponent` overlaps other objects.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您播放级别并四处走动时，自定义的`Pawn`会不断接收到当其`BoxComponent`与其他对象重叠时的通知。
- en: If they implement the `UTalker`/`ITalker` interface, the pawn then tries to
    invoke `StartTalking` on the `Actor` instance in question, which then prints the
    appropriate message on screen.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它们实现了`UTalker`/`ITalker`接口，Pawn然后尝试在相关的`Actor`实例上调用`StartTalking`，然后在屏幕上打印适当的消息。
- en: Implementing a simple interaction system with UInterfaces
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用UInterfaces实现一个简单的交互系统
- en: This recipe will show you how to combine a number of other recipes in this chapter
    to demonstrate a simple interaction system, and a door with an interactable doorbell
    to cause the door to open.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程将向您展示如何将本章中的一些其他教程组合起来，以演示一个简单的交互系统和一个带有可交互门铃的门，以打开门。
- en: How to do it...
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a new interface, `Interactable`.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的接口`Interactable`。
- en: 'Add the following functions to the `IInteractable` class declaration:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下函数添加到`IInteractable`类声明中：
- en: '[PRE48]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Create default implementations for both functions in the implementation file:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现文件中为两个函数创建默认实现：
- en: '[PRE49]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Create a second interface, `Openable`.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二个接口`Openable`。
- en: 'Add this function to its declaration:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此函数添加到其声明中：
- en: '[PRE50]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As with `Interactable`, create a default implementation for the `Open` function:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与`Interactable`一样，为`Open`函数创建一个默认实现：
- en: '[PRE51]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Create a new class, based on `StaticMeshActor`, called `DoorBell`.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`DoorBell`的新类，基于`StaticMeshActor`。
- en: '`#include "Interactable.h"` in `DoorBell.h`, and add the following functions
    to the class declaration:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DoorBell.h`中`#include "Interactable.h"`，并在类声明中添加以下函数：
- en: '[PRE52]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In the `.cpp` file for `DoorBell`, `#include "Openable.h"`.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DoorBell`的`.cpp`文件中，`#include "Openable.h"`。
- en: 'Load a static mesh for our `DoorBell` in the constructor:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中为我们的`DoorBell`加载一个静态网格：
- en: '[PRE53]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Add the following function implementations to implement the `Interactable`
    interface on our `DoorBell`:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下函数实现添加到我们的`DoorBell`上以实现`Interactable`接口：
- en: '[PRE54]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now create a new `StaticMeshActor`-based class called `Door`.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个基于`StaticMeshActor`的新类，名为`Door`。
- en: '`#include` the Openable and Interactable interfaces into the class header,
    then modify Door''s declaration:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类头文件中`#include` `Openable`和`Interactable`接口，然后修改`Door`的声明：
- en: '[PRE55]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Add the interface functions to `Door`:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将接口函数添加到`Door`上：
- en: '[PRE56]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'As with `DoorBell`, in the `Door` constructor, initialize our mesh component,
    and load a model in:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与`DoorBell`一样，在`Door`构造函数中，初始化我们的网格组件，并加载一个模型：
- en: '[PRE57]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Implement the interface functions:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现接口函数：
- en: '[PRE58]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Create a new `DefaultPawn`-based class called `AInteractingPawn`.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基于`DefaultPawn`的新类，名为`AInteractingPawn`。
- en: 'Add the following functions to the `Pawn` class header:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下函数添加到`Pawn`类头文件中：
- en: '[PRE59]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Inside the implementation file for the `Pawn`, `#include "Interactable.h"`,
    and then provide implementations for both functions from the header:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Pawn`的实现文件中，`#include "Interactable.h"`，然后为头文件中的两个函数提供实现：
- en: '[PRE60]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now, either create a new `GameMode` in C++ or Blueprint, and set `InteractingPawn`
    as our default `Pawn` class.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要么在C++中创建一个新的`GameMode`，要么在蓝图中创建一个新的`GameMode`，并将`InteractingPawn`设置为我们的默认`Pawn`类。
- en: Drag a copy of both `Door` and `Doorbell` into the level:![How to do it...](img/00132.jpeg)
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Door`和`Doorbell`的副本拖到级别中：![如何操作...](img/00132.jpeg)
- en: Use the eyedropper beside doorbell's **Door to Open**, as shown in the following
    screenshot, then click on the door actor instance in your level:![How to do it...](img/00133.jpeg)![How
    to do it...](img/00134.jpeg)
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用眼滴工具在门铃的**Door to Open**旁边，如下图所示，然后单击您级别中的门角色实例：![如何操作...](img/00133.jpeg)![如何操作...](img/00134.jpeg)
- en: Create a new Action binding in the editor called `Interact`**,** and bind it
    to a key of your choice:![How to do it...](img/00135.jpeg)
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中创建一个名为`Interact`的新动作绑定，并将其绑定到您选择的一个键：![如何操作...](img/00135.jpeg)
- en: Play your level, and walk up to the doorbell. Look at it, and press whatever
    key you bound `Interact` with. Verify that the door moves once.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放您的级别，并走到门铃旁。看着它，按下您绑定`Interact`的键。验证门是否移动一次。
- en: You can also interact with the door directly to receive some information about
    it.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以直接与门交互以获取有关它的一些信息。
- en: How it works...
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As in previous recipes, we mark `UFUNCTION` as `BlueprintNativeEvent` and `BlueprintCallable`
    in order to allow the `UInterface` to be implemented in either native code or
    Blueprint, and allow the functions to be called with either method.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与以前的教程一样，我们将`UFUNCTION`标记为`BlueprintNativeEvent`和`BlueprintCallable`，以允许`UInterface`在本地代码或蓝图中实现，并允许使用任一方法调用函数。
- en: We create `DoorBell` based on `StaticMeshActor` for convenience, and have `DoorBell`
    implement the `Interactable` interface.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们基于`StaticMeshActor`创建`DoorBell`以方便起见，并使`DoorBell`实现`Interactable`接口。
- en: Inside the constructor for `DoorBell`, we initialize `HasBeenPushed` and `DoorToOpen`
    to the default safe values.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DoorBell`的构造函数中，我们将`HasBeenPushed`和`DoorToOpen`初始化为默认安全值。
- en: Within the implementation for `CanInteract`, we return the inverse of `HasBeenPushed`
    so that once the button has been pushed it, can't be interacted with.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CanInteract`的实现中，我们返回`HasBeenPushed`的反值，以便一旦按钮被按下，就无法进行交互。
- en: Inside `PerformInteract`, we check if we have a reference to a door object to
    open.
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PerformInteract`中，我们检查是否有一个引用来打开门对象。
- en: If we have a valid reference, we verify that the door actor implements `Openable`,
    then we invoke the `Open` function on our door.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们有一个有效的引用，我们验证门角色是否实现了`Openable`，然后在我们的门上调用`Open`函数。
- en: Within `Door`, we implement both `Interactable` and `Openable`, and override
    the functions from each.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Door`中，我们实现了`Interactable`和`Openable`，并重写了每个函数。
- en: We define the `Door` implementation of `CanInteract` to be the same as the default.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`Door`的`CanInteract`实现定义为与默认值相同。
- en: Within `PerformInteract`, we display a message to the user.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PerformInteract`中，我们向用户显示一条消息。
- en: Inside `Open`, we use `AddActorLocalOffset` to move the door a certain distance
    away. With Timeline in Blueprint or a linear interpolation, we could make this
    transition smooth rather than a teleport.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Open`函数中，我们使用`AddActorLocalOffset`来将门移动到一定的距离。通过蓝图中的时间轴或线性插值，我们可以使这个过渡变得平滑，而不是瞬间移动。
- en: Lastly, we create a new `Pawn` so that the player can actually interact with
    objects.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个新的`Pawn`，以便玩家实际上可以与物体交互。
- en: We create a `TryInteract` function, which we bind to the `Interact` input action
    in the overridden `SetupPlayerInputComponent` function.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个`TryInteract`函数，并将其绑定到重写的`SetupPlayerInputComponent`函数中的`Interact`输入动作。
- en: This means that when the player performs the input that is bound to `Interact`,
    our `TryInteract` function will run.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这意味着当玩家执行与`Interact`绑定的输入时，我们的`TryInteract`函数将运行。
- en: '`TryInteract` gets a reference to `PlayerController`, casting the generic controller
    reference that all Pawns have.'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TryInteract`获取对`PlayerController`的引用，将所有Pawns都具有的通用控制器引用进行转换。'
- en: '`PlayerCameraManager` is retrieved through `PlayerController`, so we can access
    the current location and rotation of the player camera.'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`PlayerController`检索`PlayerCameraManager`，这样我们就可以访问玩家摄像机的当前位置和旋转。
- en: We create start and end points using the camera's location, then 100 units in
    the forward direction away from the camera's location, and pass those into `GetWorld::SweepSingleByObjectType`.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用摄像机的位置创建起始点和结束点，然后在摄像机位置的前方100个单位处，将它们传递给`GetWorld::SweepSingleByObjectType`函数。
- en: This function takes in a number of parameters. `HitResult` is a variable that
    allows the function to return information about any object hit by the trace. `CollisionObjectQueryParams`
    allows us to specify if we are interested in dynamic, static items, or both.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数接受多个参数。`HitResult`是一个变量，允许函数返回有关跟踪到的任何对象的信息。`CollisionObjectQueryParams`允许我们指定我们是否对动态、静态物品或两者都感兴趣。
- en: We accomplish a sphere trace by passing the shape in using the `MakeSphere`
    function.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过使用`MakeSphere`函数来完成一个球体跟踪。
- en: Sphere traces allow for slightly more human error by defining a cylinder to
    check for objects rather than a straight line. Given that the players might not
    look exactly at your object, you can tweak the sphere's radius as appropriate.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 球体跟踪通过定义一个圆柱体来检查物体，而不是一条直线，从而允许稍微有些人为误差。考虑到玩家可能不会完全准确地看着你的物体，你可以根据需要调整球体的半径。
- en: The final parameter, `SweepSingleByObjectType`, is a struct that gives the trace
    a name, lets us specify if we are colliding against complex collision geometry,
    and most importantly, allows us to specify that we want to ignore the object which
    is initiating the trace.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个参数`SweepSingleByObjectType`是一个结构体，它给跟踪一个名称，让我们指定是否与复杂的碰撞几何体发生碰撞，最重要的是，它允许我们指定我们要忽略发起跟踪的对象。
- en: If `HitResult` contains an actor after the trace is done, we check if the actor
    implements our interface, then attempt to call `CanInteract` on it.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`HitResult`在跟踪完成后包含一个actor，我们检查该actor是否实现了我们的接口，然后尝试调用`CanInteract`函数。
- en: If the actor indicates yes, it can be interacted with, so we then tell it to
    actually perform the interaction.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果actor表示可以进行交互，我们就告诉它实际执行交互操作。
