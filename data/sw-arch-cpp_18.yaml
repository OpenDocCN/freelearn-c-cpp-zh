- en: Containers
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 容器
- en: Transitioning from development to production has always been a painful process.
    It involves a lot of documentation, hand-offs, installation, and configuration.
    Since every programming language produces software that behaves slightly differently,
    the deployment of heterogenous applications is always difficult.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发到生产的过渡一直是一个痛苦的过程。它涉及大量文档、交接、安装和配置。由于每种编程语言产生的软件行为略有不同，异构应用程序的部署总是困难的。
- en: Some of these problems have been mitigated by containers. With containers, the
    installation and configuration is mostly standardized. There are several ways
    for how to deal with distribution, but this issue also has some standards to follow.
    This makes containers a great choice for organizations that want to increase the
    cooperation between development and operations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些问题已经通过容器得到缓解。使用容器，安装和配置大多是标准化的。处理分发的方式有几种，但这个问题也有一些标准可遵循。这使得容器成为那些希望增加开发和运维之间合作的组织的绝佳选择。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Building containers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建容器
- en: Testing and integrating containers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试和集成容器
- en: Understanding container orchestration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解容器编排
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The examples listed in this chapter require the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章列出的示例需要以下内容：
- en: Docker 20.10
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 20.10
- en: manifest-tool ([https://github.com/estesp/manifest-tool](https://github.com/estesp/manifest-tool))
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: manifest-tool ([https://github.com/estesp/manifest-tool](https://github.com/estesp/manifest-tool))
- en: Buildah 1.16
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Buildah 1.16
- en: Ansible 2.10
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 2.10
- en: ansible-bender
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ansible-bender
- en: CMake 3.15
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake 3.15
- en: The code present in the chapter has been placed on GitHub at [https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter14](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter14).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码已放在GitHub上，网址为[https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter14](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter14)。
- en: Reintroducing containers
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新介绍容器
- en: Containers are making a lot of buzz recently. One might think they are a brand
    new technology that was not available before. However, that is not the case. Before
    the rise of Docker and Kubernetes, the dominating players in the industry at the
    moment, there were already solutions such as LXC, which offered a lot of similar
    features.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最近容器引起了很多关注。有人可能认为它们是一种以前不可用的全新技术。然而，事实并非如此。在Docker和Kubernetes崛起之前，这两者目前在行业中占主导地位，已经有了诸如LXC之类的解决方案，它们提供了许多类似的功能。
- en: We can trace the origins of separating one execution environment from another
    with the chroot mechanism available in UNIX systems since 1979\. Similar concepts
    were also used in FreeBSD jails and Solaris Zones.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以追溯到自1979年UNIX系统中可用的chroot机制，将一个执行环境与另一个分离的起源。类似的概念也在FreeBSD jails和Solaris
    Zones中使用过。
- en: The main task of the container is to isolate one execution environment from
    another. This isolated environment can have its own configuration, different applications,
    and even different user accounts than the host environment.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的主要任务是将一个执行环境与另一个隔离开。这个隔离的环境可以有自己的配置、不同的应用程序，甚至不同的用户帐户，与主机环境不同。
- en: Even though the containers are isolated from the host, they usually share the
    same operating system kernel. This is the main differentiator from virtualized
    environments. Virtual machines have dedicated virtual resources, which means they
    are separated at the hardware level. Containers are separated at the process level,
    which means there is less overhead to run them.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管容器与主机隔离，它们通常共享相同的操作系统内核。这是与虚拟化环境的主要区别。虚拟机有专用的虚拟资源，这意味着它们在硬件级别上是分离的。容器在进程级别上是分离的，这意味着运行它们的开销更小。
- en: 'The ability to package and run another operating system that is already optimized
    and configured for running your application is a strong advantage of containers.
    Without containers, the build and deploy process usually consists of several steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的一个强大优势是能够打包和运行另一个已经针对运行您的应用程序进行了优化和配置的操作系统。没有容器，构建和部署过程通常包括几个步骤：
- en: The application is built.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用已构建。
- en: The example configuration files are provided.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供示例配置文件。
- en: Installation scripts and associated documentation is prepared.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备安装脚本和相关文档。
- en: The application is packaged for a target operating system (such as Debian or
    Red Hat).
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序已打包为目标操作系统（如Debian或Red Hat）。
- en: The packages are deployed to the target platform.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 软件包部署到目标平台。
- en: Installation scripts prepare the basis for the application to run.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装脚本为应用程序运行准备了基础。
- en: The configuration has to be tweaked to fit the existing system.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置必须进行调整以适应现有系统。
- en: 'When you switch to containers, there is less of a need for a robust installation
    script. The application will only target a single well-known operating system
    – the one present in the container. The same goes for configuration: instead of
    preparing many configurable options, the application is pre-configured for the
    target operating system and distributed alongside it. The deployment process consists
    only of unpacking the container image and running the application process inside
    it.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当您切换到容器时，就不再需要强大的安装脚本。应用程序只会针对一个众所周知的操作系统进行目标设置——容器中存在的操作系统。配置也是一样：应用程序预先配置为目标操作系统并与其一起分发，而不是准备许多可配置选项。部署过程只包括解压容器镜像并在其中运行应用程序进程。
- en: While containers and microservices are often thought to be the same thing, they
    are not. Moreover, containers may mean application containers or operating system
    containers, and only application containers fit well with microservices. The following
    sections will tell you why. We'll describe the different container types that
    you can encounter, show you how they relate to microservices, and explain when
    it's best to use them (and when to avoid them).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然容器和微服务经常被认为是同一件事，但它们并不是。此外，容器可能意味着应用容器或操作系统容器，只有应用容器与微服务配合得很好。接下来的章节将告诉您原因。我们将描述您可能遇到的不同容器类型，向您展示它们与微服务的关系，并解释何时最好使用它们（以及何时避免使用它们）。
- en: Exploring the container types
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索容器类型
- en: Of the containers described so far, operating system containers are fundamentally
    different from the current container trend led by Docker, Kubernetes, and LXD.
    Instead of focusing on recreating an entire operating system with services such
    as syslog and cron, application containers focus on running a single process within
    a container – just the application.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止描述的容器中，操作系统容器与由Docker、Kubernetes和LXD领导的当前容器趋势有根本的不同。应用容器专注于在容器内运行单个进程-即应用程序，而不是专注于重新创建具有诸如syslog和cron等服务的整个操作系统。
- en: Proprietary solutions replace all the usual OS-level services. These solutions
    provide a unified way to manage the applications within a container. For example,
    instead of using syslog to handle logs, the standard output of the process with
    PID 1 is considered as application logs. Instead of using a mechanism such as
    `init.d` or systemd, the application container's lifecycle is handled by the runtime
    application.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 专有解决方案替换了所有通常的操作系统级服务。这些解决方案提供了一种统一的方式来管理容器内的应用程序。例如，不使用syslog来处理日志，而是将PID 1的进程的标准输出视为应用程序日志。不使用`init.d`或systemd等机制，而是由运行时应用程序处理应用容器的生命周期。
- en: Since Docker is at the moment the dominant solution for application containers,
    we will mostly use it as an example throughout this book. To make the picture
    complete, we will present viable alternatives, as they may be better suited to
    your needs. Since the project and specification are open source, these alternatives
    are compatible with Docker and can be used as replacements.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Docker目前是应用容器的主要解决方案，我们将在本书中大多数情况下使用它作为示例。为了使画面完整，我们将提出可行的替代方案，因为它们可能更适合您的需求。由于项目和规范是开源的，这些替代方案与Docker兼容，并且可以用作替代品。
- en: Later in this chapter, we will explain how to use Docker to build, deploy, run,
    and manage application containers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面，我们将解释如何使用Docker来构建、部署、运行和管理应用容器。
- en: The rise of microservices
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务的兴起
- en: The success of Docker coincided with the rise of the adoption of microservices.
    It is no surprise since microservices and application containers fit together
    naturally.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的成功与微服务的采用增长同时出现并不奇怪，因为微服务和应用容器自然地结合在一起。
- en: Without application containers, there was no easy and unified way to package,
    deploy, and maintain microservices. Even though individual companies developed
    some solutions to fix these problems, none was popular enough to approach being
    an industry standard.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 没有应用容器，没有一种简单而统一的方式来打包、部署和维护微服务。尽管一些公司开发了一些解决这些问题的解决方案，但没有一种解决方案足够流行，可以成为行业标准。
- en: Without microservices, the application containers were pretty limited. The software
    architecture focused on building entire systems explicitly configured for the
    given set of services running there. Replacing one service with another required
    a change of the architecture.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 没有微服务，应用容器的功能相当有限。软件架构专注于构建专门为给定的服务集合明确配置的整个系统。用另一个服务替换一个服务需要改变架构。
- en: When brought together, application containers provide a standard way for the
    distribution of microservices. Each microserver comes with its own configuration
    embedded, so operations such as autoscaling or self-healing no longer require
    knowledge about an underlying application.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 应用容器提供了一种标准的分发微服务的方式。每个微服务都带有其自己的嵌入式配置，因此诸如自动扩展或自愈等操作不再需要了解底层应用程序。
- en: You can still use microservices without application containers and you can use
    application containers without hosting microservices in them. For instance, even
    though neither PostgreSQL databases nor Nginx web servers were designed as microservices,
    they are typically used in application containers.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您仍然可以在没有应用容器的情况下使用微服务，也可以在应用容器中托管微服务。例如，尽管PostgreSQL数据库和Nginx Web服务器都不是设计为微服务，但它们通常在应用容器中使用。
- en: Choosing when to use containers
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择何时使用容器
- en: There are several benefits to the container approach. OS containers and application
    containers also have some different use cases in which their strengths lie.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 容器方法有几个好处。操作系统容器和应用容器在其优势所在的一些不同用例中也有所不同。
- en: The benefits of containers
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器的好处
- en: When compared to virtual machines, the other popular way of isolating environments,
    containers require less overhead during runtime. Unlike virtual machines, there
    is no need to run a separate version of an operating system kernel and use the
    hardware or software virtualization techniques. Application containers also do
    not run other operating system services that are typically found in virtual machines
    such as syslog, cron, or init. Additionally, application containers offer smaller
    images as they do not usually have to carry an entire operating system copy. In
    extreme examples, an application container can consist of a single statically
    linked binary.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 与隔离环境的另一种流行方式虚拟机相比，容器在运行时需要更少的开销。与虚拟机不同，不需要运行一个单独的操作系统内核版本，并使用硬件或软件虚拟化技术。应用容器也不运行通常在虚拟机中找到的其他操作系统服务，如syslog、cron或init。此外，应用容器提供更小的镜像，因为它们通常不必携带整个操作系统副本。在极端情况下，应用容器可以由单个静态链接的二进制文件组成。
- en: At this point, you may wonder why to bother with containers at all if there
    is just a single binary inside? There is one particular benefit of having a unified
    and standardized way to build and run containers. As containers have to follow
    specific conventions, it is easier to orchestrate them than regular binaries,
    which can have different expectations regarding logging, configuration, opening
    ports, and so on.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你可能会想，如果里面只有一个单一的二进制文件，为什么还要费心使用容器呢？拥有统一和标准化的构建和运行容器的方式有一个特定的好处。由于容器必须遵循特定的约定，因此比起常规的二进制文件，对它们进行编排更容易，后者可能对日志记录、配置、打开端口等有不同的期望。
- en: Another thing is that containers provide a built-in means of isolation. Each
    container has its own namespace for processes and a namespace for user accounts,
    among others. This means that the process (or processes) from one container has
    no notion of the processes on the host or in the other containers. The sandboxing
    can go even further as you can assign memory and a CPU quota to your containers
    with the same standard user interface (whether it is Docker, Kubernetes, or something
    else).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件事是，容器提供了内置的隔离手段。每个容器都有自己的进程命名空间和用户帐户命名空间，等等。这意味着一个容器中的进程（或进程）对主机上的进程或其他容器中的进程没有概念。沙盒化甚至可以进一步进行，因为你可以为你的容器分配内存和CPU配额，使用相同的标准用户界面（无论是Docker、Kubernetes还是其他什么）。
- en: The standardized runtime also means higher portability. Once a container is
    built, you can typically run it on different operating systems without modifications.
    This also means what runs in operations is very close or identical to what runs
    in development. Issue reproduction is more effortless and so is debugging.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 标准化的运行时也意味着更高的可移植性。一旦容器构建完成，通常可以在不同的操作系统上运行，而无需修改。这也意味着在运行的东西与开发中运行的东西非常接近或相同。问题的再现更加轻松，调试也更加轻松。
- en: The disadvantages of containers
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器的缺点
- en: Since there is a lot of pressure nowadays to move workloads to containers, you
    want to understand all the risks associated with such migration as an architect.
    The benefits are touted everywhere and you probably already understand them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现在有很大的压力要将工作负载迁移到容器中，作为架构师，你需要了解与这种迁移相关的所有风险。利益无处不在，你可能已经理解了它们。
- en: The main obstacle to container adoption is that not all applications can be
    easily migrated to containers. This is especially true of application containers
    that are designed with microservices in mind. If your application is not based
    on microservices architecture, putting it into containers may introduce more problems
    than it will solve.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 容器采用的主要障碍是，并非所有应用程序都能轻松迁移到容器中。特别是那些以微服务为设计目标的应用程序容器。如果你的应用程序不是基于微服务架构的，将其放入容器中可能会带来更多问题。
- en: If your application already scales well, uses TCP/IP-based IPC, and is mostly
    stateless, the move to containers should not be challenging. Otherwise, each of
    these aspects would pose a challenge and prompt a rethink of the existing design.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序已经很好地扩展，使用基于TCP/IP的IPC，并且大部分是无状态的，那么转移到容器应该不会有挑战。否则，这些方面中的每一个都将带来挑战，并促使重新思考现有的设计。
- en: Another problem associated with containers is persistent storage. Ideally, containers
    should have no persistent storage of their own. This makes it possible to take
    advantage of fast startups, easy scaling, and flexible scheduling. The problem
    is that applications providing business value cannot exist without persistent
    storage.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与容器相关的另一个问题是持久存储。理想情况下，容器不应该有自己的持久存储。这样可以利用快速启动、轻松扩展和灵活的调度。问题在于提供业务价值的应用程序不能没有持久存储���
- en: This drawback is usually mitigated by making most containers stateless and relying
    on an external non-containerized component to store the data and the state. Such
    an external component can be either a traditional self-hosted database or a managed
    database from a cloud provider. Going in either direction requires you to reconsider
    the architecture and modify it accordingly.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个缺点通常可以通过使大多数容器无状态，并依赖于一个外部的非容器化组件来存储数据和状态来减轻。这样的外部组件可以是传统的自托管数据库，也可以是来自云提供商的托管数据库。无论选择哪个方向，都需要重新考虑架构并相应地进行修改。
- en: Since application containers follow specific conventions, the application has
    to be modified to follow these conventions. For some applications, it will be
    a low-effort task. For others, such as multiprocess components using in-memory
    **Inter-Process Communication** (**IPC**), it will be complicated.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用程序容器遵循特定的约定，应用程序必须修改以遵循这些约定。对于一些应用程序来说，这将是一个低成本的任务。对于其他一些应用程序，比如使用内存IPC的多进程组件，这将是复杂的。
- en: One point often omitted is that application containers work great as long as
    the applications inside them are native Linux applications. While Windows containers
    are supported, they are neither convenient nor as supported as their Linux counterparts.
    They also require licensed Windows machines running as hosts.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 经常被忽略的一点是，只要容器内的应用程序是本地Linux应用程序，应用程序容器就能很好地工作。虽然支持Windows容器，但它们既不方便也不像它们的Linux对应物那样受支持。它们还需要运行作为主机的经过许可的Windows机器。
- en: It is easier to enjoy the application containers' benefits if you are building
    a new application from scratch and can base your design on this technology. Moving
    an existing application to application containers, especially if it is complicated,
    will require a lot more work and possibly also a revamp of the entire architecture.
    In such a case, we advise you to consider all the benefits and disadvantages extra
    carefully. Making a wrong decision may harm your product's lead time, availability,
    and budget.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从头开始构建一个新的应用程序，并且可以基于这项技术设计，那么很容易享受应用程序容器的好处。将现有的应用程序移植到应用程序容器中，特别是如果它很复杂，将需要更多的工作，可能还需要对整个架构进行改造。在这种情况下，我们建议您特别仔细地考虑所有的利弊。做出错误的决定可能会损害产品的交付时间、可用性和预算。
- en: Building containers
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建容器
- en: Application containers are the focus of this section. While OS containers mostly
    follow system programming principles, application containers bring new challenges
    and patterns. Also, they provide specialized build tools to deal with those challenges.
    The primary tool we will consider is Docker, as it's the current de facto standard
    for building and running application containers. We will also present some alternative
    approaches to building application containers.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序容器是本节的重点。虽然操作系统容器大多遵循系统编程原则，但应用程序容器带来了新的挑战和模式。它们还提供了专门的构建工具来处理这些挑战。我们将考虑的主要工具是Docker，因为它是当前构建和运行应用程序容器的事实标准。我们还将介绍一些构建应用程序容器的替代方法。
- en: Unless otherwise noted, whenever we use the word "containers" from now on, it
    relates to "application containers."
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 除非另有说明，从现在开始，当我们使用“容器”这个词时，它指的是“应用程序容器”。
- en: In this section, we will focus on different approaches to using Docker for building
    and deploying containers.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将专注于使用Docker构建和部署容器的不同方法。
- en: Container images explained
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释容器镜像
- en: Before we describe container images and how to build them, it is vital to understand
    the distinction between containers and container images. There is often confusion
    between the terms, especially during informal conversations.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们描述容器镜像及如何构建它们之前，了解容器和容器镜像之间的区别至关重要。这两个术语经常会引起混淆，尤其是在非正式的对话中。
- en: The difference between a container and a container image is the same as between
    a running process and an executable file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 容器和容器镜像之间的区别与运行中的进程和可执行文件之间的区别相同。
- en: '**Container images are static**: They''re snapshots of a particular filesystem
    and associated metadata. The metadata describes, among other things, what environmental
    variables are set during runtime or which program to run when the container is
    created from the image.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器镜像是静态的**：它们是特定文件系统的快照和相关的元数据。元数据描述了在运行时设置了哪些环境变量，或者在创建容器时运行哪个程序，等等。'
- en: '**Containers are dynamic**: They are running a process contained within the
    container image. We can create containers from the container images and we can
    also create container images by snapshotting a running container. The container
    image build process consists, in fact, of creating several containers, executing
    commands inside them, and snapshotting them after the command finishes.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器是动态的**：它们运行在容器镜像内的一个进程。我们可以从容器镜像创建容器，也可以通过对运行中的容器进行快照来创建容器镜像。事实上，容器镜像构建过程包括创建多个容器，执行其中的命令，并在命令完成后对它们进行快照。'
- en: To distinguish between the data introduced by the container image and the data
    generated during runtime, Docker uses union mount filesystems to create different
    filesystem layers. These layers are also present in the container images. Typically,
    each build step of the container image corresponds to a new layer in the resulting
    container image.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了区分容器镜像引入的数据和运行时生成的数据，Docker使用联合挂载文件系统来创建不同的文件系统层。这些层也存在于容器镜像中。通常，容器镜像的每个构建步骤对应于结果容器镜像中的一个新层。
- en: Using Dockerfiles to build an application
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Dockerfiles构建应用程序
- en: The most common way to build an application container image using Docker is
    to use a Dockerfile. Dockerfile is an imperative language describing the operations
    required to produce the resulting image. Some of the operations create new filesystem
    layers; others operate on metadata.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker构建应用程序容器镜像的最常见方法是使用Dockerfile。Dockerfile是一种描述生成结果镜像所需操作的命令式语言。一些操作会创建新的文件系统层，而其他操作则会操作元数据。
- en: We will not go into details and specifics related to Dockerfiles. Instead, we
    will show different approaches to containerizing a C++ application. For this,
    we need to introduce some syntax and concepts related to Dockerfiles.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细介绍和具体涉及Dockerfiles。相反，我们将展示不同的方法来将C++应用程序容器化。为此，我们需要介绍一些与Dockerfiles相关的语法和概念。
- en: 'Here is an example of a very simple Dockerfile:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的Dockerfile的示例：
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Typically, we can divide a Dockerfile into three parts:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们可以将Dockerfile分为三个部分：
- en: Importing the base image (the `FROM` instruction)
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入基本镜像（`FROM`指令）
- en: Performing operations within the container that will result in a container image
    (the `RUN` instruction)
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器内执行操作，将导致容器镜像（`RUN`指令）
- en: Metadata used during runtime (the `CMD` command)
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时使用的元数据（`CMD`命令）
- en: 'The latter two parts may well be interleaved, and each of them may comprise
    one or more instructions. It is also possible to omit any of the later parts as
    only the base image is mandatory. This does not mean you cannot start with an
    empty filesystem. There is a special base image named `scratch` exactly for this
    purpose. Adding a single statically linked binary to an otherwise empty filesystem
    could look like the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 后两部分可能会交错进行，每个部分可能包含一个或多个指令。也可以省略任何后续部分，因为只有基本镜像是必需的。这并不意味着你不能从空文件系统开始。有一个名为`scratch`的特殊基本镜像就是为了这个目的。在否则空的文件系统中添加一个单独的静态链接二进制文件可能看起来像下面这样：
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the first Dockerfile, the steps we take are the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个Dockerfile中，我们采取的步骤如下：
- en: Import the base Ubuntu Bionic image.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入基本的Ubuntu Bionic镜像。
- en: Run a command inside the container. The results of the command will create a
    new filesystem layer inside the target image. This means the packages installed
    with `apt-get` will be available in all the containers based on this image.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器内运行命令。命令的结果将在目标镜像内创建一个新的文件系统层。这意味着使用`apt-get`安装的软件包将在所有基于此镜像的容器中可用。
- en: Set the runtime metadata. When creating a container based on this image, we
    want to run `GCC` as the default process.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置运行时元数据。在基于此镜像创建容器时，我们希望将`GCC`作为默认进程运行。
- en: To build an image from a Dockerfile, you will use the `docker build` command.
    It takes one required argument, the directory containing the build context, which
    means the Dockerfile itself and other files you want to copy inside the container.
    To build a Dockerfile from a current directory, use `docker build`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Dockerfile构建镜像，您将使用`docker build`命令。它需要一个必需的参数，即包含构建上下文的目录，这意味着Dockerfile本身和您想要复制到容器内的其他文件。要从当前目录构建Dockerfile，请使用`docker
    build`。
- en: This will build an anonymous image, which is not very useful. Most of the time,
    you want to use named images. There is a convention to follow when naming container
    images and that's what we'll cover in the next section.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这将构建一个匿名镜像，这并不是很有用��大多数情况下，您希望使用命名的镜像。在命名容器镜像时有一个惯例要遵循，我们将在下一节中介绍。
- en: Naming and distributing images
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名和分发镜像
- en: 'Each container image in Docker has a distinctive name consisting of three elements:
    the name of the registry, the name of the image, a tag. Container registries are
    object repositories holding container images. The default container registry for
    Docker is `docker.io`. When pulling an image from this registry, we may omit the
    registry name.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Docker中的每个容器镜像都有一个独特的名称，由三个元素组成：注册表的名称，镜像的名称，一个标签。容器注册表是保存容器镜像的对象仓库。Docker的默认容器注册表是`docker.io`。当从这个注册表中拉取镜像时，我们可以省略注册表的名称。
- en: Our previous example with `ubuntu:bionic` has the full name of `docker.io/ubuntu:bionic`.
    In this example, `ubuntu` is the name of the image, while `bionic` is a tag that
    represents a particular version of an image.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的例子中，`ubuntu:bionic`的完整名称是`docker.io/ubuntu:bionic`。在这个例子中，`ubuntu`是镜像的名称，而`bionic`是代表镜像特定版本的标签。
- en: 'When building an application based on containers, you will be interested in
    storing all the registry images. It is possible to host your private registry
    and keep your images there or use a managed solution. Popular managed solutions
    include the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于容器的应用程序构建时，您将有兴趣存储所有的注册表镜像。可以搭建自己的私有注册表并在那里保存镜像，或者使用托管解决方案。流行的托管解决方案包括以下内容：
- en: Docker Hub
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Hub
- en: quay.io
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: quay.io
- en: GitHub
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub
- en: Cloud providers (such as AWS, GCP, or Azure)
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云提供商（如AWS、GCP或Azure）
- en: Docker Hub is still the most popular one, though some public images are migrating
    to quay.io. Both are general-purpose and allow the storage of public and private
    images. GitHub or cloud providers will be mainly attractive to you if you are
    already using a particular platform and want to keep your images close to the
    CI pipeline or the deployment targets. It is also helpful if you want to reduce
    the number of individual services you use.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub仍然是最受欢迎的，尽管一些公共镜像正在迁移到quay.io。两者都是通用的，允许存储公共和私有镜像。如果您已经在使用特定平台并希望将镜像保持接近CI流水线或部署目标，GitHub或云提供商对您来说可能更具吸引力。如果您希望减少使用的个别服务数量，这也是有帮助的。
- en: If none of the solutions appeal to you, hosting your own local registry is also
    very easy and requires you to run a single container.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以上解决方案都不适合您，那么搭建自己的本地注册表也非常简单，只需要运行一个容器。
- en: To build a named image, you need to pass the `-t` argument to the `docker build`
    command. For example, to build an image named `dominicanfair/merchant:v2.0.3`,
    you will use `docker build -t dominicanfair/merchant:v2.0.3 .`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个命名的镜像，您需要向`docker build`命令传递`-t`参数。例如，要构建一个名为`dominicanfair/merchant:v2.0.3`的镜像，您将使用`docker
    build -t dominicanfair/merchant:v2.0.3 .`。
- en: Compiled applications and containers
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已编译的应用程序和容器
- en: 'When building container images for applications in interpreted languages (such
    as Python or JavaScript), the approach is mostly the same:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于解释性语言（如Python或JavaScript）的应用程序构建容器镜像，方法基本上是相同的：
- en: Install dependencies.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装依赖项。
- en: Copy source files to the container image.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将源文件复制到容器镜像中。
- en: Copy the necessary configuration.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制必要的配置。
- en: Set the runtime command.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置运行时命令。
- en: For compiled applications, however, there's an additional step of compiling
    the application first. There are several possible ways to implement this step,
    each of them with their pros and cons.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于已编译的应用程序，还有一个额外的步骤是首先编译应用程序。有几种可能的方法来实现这一步骤，每种方法都有其优缺点。
- en: 'The most obvious approach is to install all the dependencies first, copy the
    source files, and then compile the application as one of the container build steps.
    The major benefit is that we can accurately control the toolchain''s contents
    and configuration and therefore have a portable way to build an application. However,
    the downside is too big to ignore: the resulting container image contains a lot
    of unnecessary files. After all, we will need neither source code nor the toolchain
    during runtime. Due to the way overlay filesystems work, it is impossible to remove
    the files after being introduced in a previous layer. What is more, the source
    code in the container may prove to be a security risk if an attacker manages to
    break into the container.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最明显的方法是首先安装所有的依赖项，复制源文件，然后编译应用程序作为容器构建步骤之一。主要的好处是我们可以准确控制工具链的内容和配置，因此有一种便携的方式来构建应用程序。然而，缺点是太大而无法忽视：生成的容器镜像包含了许多不必要的文件。毕竟，在运行时我们既不需要源代码也不需要工具链。由于叠加文件系统的工作方式，无法在引入到先前层中的文件之后删除这些文件。而且，如果攻击者设法侵入容器，容器中的源代码可能会构成安全风险。
- en: 'Here''s how it can look:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以看起来像这样：
- en: '[PRE2]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Another obvious approach, and the one we discussed earlier, is building the
    application on the host machine and only copying the resulting binaries inside
    the container image. This requires fewer changes to the current build process
    when one is already established. The main drawback is that you have to match the
    same set of libraries on your build machines as you do in your containers. If
    you're running, for example, Ubuntu 20.04 as your host operating system, your
    containers will have to be based on Ubuntu 20.04 as well. Otherwise, you risk
    incompatibilities. With this approach, it is also necessary to configure the toolchain
    independently of the container.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种明显的方法，也是我们之前讨论过的方法，是在主机上构建应用程序，然后只将生成的二进制文件复制到容器映像中。当已经建立了一个构建过程时，这需要对当前构建过程进行较少的更改。主要的缺点是您必须在构建机器上与容器中使用相同的库集。例如，如果您的主机操作系统是
    Ubuntu 20.04，那么您的容器也必须基于 Ubuntu 20.04。否则，您会面临不兼容性的风险。使用这种方法，还需要独立配置工具链而不是容器。
- en: 'Just like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 就像这样：
- en: '[PRE3]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A slightly more complicated approach is to have a multi-stage build. With multi-stage
    builds, one stage may be dedicated to setting up the toolchain and compiling the
    project, while another stage copies the resulting binaries to their target container
    image. This has several benefits over the previous solutions. First of all, the
    Dockerfiles now control both the toolchain and the runtime environment, so every
    step of the build is thoroughly documented. Second of all, it is possible to use
    the image with the toolchain to ensure compatibility between development and the
    **Continuous Integration**/**Continuous Deployment** (**CI/CD**) pipeline. This
    way also makes it easier to distribute upgrades and fixes to the toolchain itself.
    The major downside is that the containerized toolchain may not be as comfortable
    to use as a native one. Also, build tools are not particularly well-suited to
    application containers, which require that there's one process running per container.
    This may lead to unexpected behavior whenever some of the processes crash or are
    forcefully stopped.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一种稍微复杂的方法是采用多阶段构建。使用多阶段构建，一个阶段可能专门用于设置工具链和编译项目，而另一个阶段则将生成的二进制文件复制到目标容器映像中。这比以前的解决方案有几个好处。首先，Dockerfile
    现在控制工具链和运行时环境，因此构建的每一步都有详细记录。其次，可以使用带有工具链的映像来确保开发和持续集成/持续部署（CI/CD）流水线之间的兼容性。这种方式还使得更容易分发工具链本身的升级和修复。主要的缺点是容器化的工具链可能不像本机工具链那样方便使用。此外，构建工具并不特别适合应用容器，后者要求每个容器只运行一个进程。这可能导致一些进程崩溃或被强制停止时出现意外行为。
- en: 'A multi-stage version of the preceding example would look like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例的多阶段版本如下所示：
- en: '[PRE4]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first stage, starting at the first `FROM` command sets up the builder, adds
    the sources, and builds the binaries. Then, the second stage, starting at the
    second `FROM` command, copies the resulting binary from the previous stage without
    copying the toolchain or the sources.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从第一个 `FROM` 命令开始的第一个阶段设置了构建器，添加了源代码并构建了二进制文件。然后，从第二个 `FROM` 命令开始的第二阶段，复制了上一阶段的结果二进制文件，而没有复制工具链或源代码。
- en: Targeting multiple architectures with manifests
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过清单定位多个架构
- en: Application containers with Docker are typically used on x86_64 (also known
    as AMD64) machines. If you are only targeting this platform, you have nothing
    to worry about. However, if you are developing IoT, embedded, or edge applications,
    you may be interested in multi-architecture images.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker 的应用容器通常在 x86_64（也称为 AMD64）机器上使用。如果您只针对这个平台，那就没什么好担心的。但是，如果您正在开发物联网、嵌入式或边缘应用程序，您可能对多架构映像感兴趣。
- en: Since Docker is available on many different CPU architectures, there are several
    ways to approach image management on multiple platforms.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Docker 可用于许多不同的 CPU 架构，有多种方法可以处理多平台上的映像管理。
- en: One way to handle images built for different targets is by using the image tags
    to describe a particular platform. Instead of `merchant:v2.0.3`, we could have
    `merchant:v2.0.3-aarch64`. Although this approach may seem to be the easiest to
    implement, it is, in fact, a bit problematic.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 处理为不同目标构建的映像的一种方法是使用映像标签来描述特定平台。例如，我们可以使用 `merchant:v2.0.3-aarch64` 而不是 `merchant:v2.0.3`。尽管这种方法可能看起来最容易实现，但实际上有点问题。
- en: Not only do you have to change the build process to include the architecture
    in the tagging process. When pulling the images to run them, you will also have
    to take care to manually append the expected suffix everywhere. If you are using
    an orchestrator, you won't be able to share the manifests between the different
    platforms in a straightforward way, as the tags will be platform-specific.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅需要更改构建过程以在标记过程中包含架构。在拉取映像以运行它们时，还必须手动在所有地方添加预期的后缀。如果使用编排器，将无法以直接的方式在��同平台之间共享清单，因为标签将是特定于平台的。
- en: A better way that doesn't require modifying the deployment step is to use `manifest-tool`
    ([https://github.com/estesp/manifest-tool](https://github.com/estesp/manifest-tool)).
    The build process at first looks similar to the one suggested previously. Images
    are built separately on all the supported architectures and pushed to the registry
    with a platform suffix in their tags. After all the images are pushed, `manifest-tool`
    merges the images to provide a single multi-architecture one. This way, each supported
    platform is able to use the exact same tag.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更好的方法，不需要修改部署步骤，是使用 `manifest-tool`（https://github.com/estesp/manifest-tool）。首先，构建过程看起来与之前建议的类似。映像在所有支持的架构上分别构建，并带有标签中的平台后缀推送到注册表。在所有映像都推送后，`manifest-tool`
    合并映像以提供单个多架构映像。这样，每个支持的平台都能使用完全相同的标签。
- en: 'An example configuration for `manifest-tool` is provided here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供了 `manifest-tool` 的示例配置：
- en: '[PRE5]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we have three supported platforms, each with their respective suffix (`hosacpp/merchant:v2.0.3-amd64`,
    `hosacpp/merchant:v2.0.3-arm32`, and `hosacpp/merchant:v2.0.3-arm64`). `Manifest-tool`
    combines the images built for each platform and produces a `hosacpp/merchant:v2.0.3`
    image that we can use everywhere.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有三个支持的平台，每个平台都有其相应的后缀（`hosacpp/merchant:v2.0.3-amd64`，`hosacpp/merchant:v2.0.3-arm32`和`hosacpp/merchant:v2.0.3-arm64`）。`Manifest-tool`将为每个平台构建的镜像合并，并生成一个`hosacpp/merchant:v2.0.3`镜像，我们可以在任何地方使用。
- en: Another possibility is to use Docker's built-in feature called Buildx. With
    Buildx, you can attach several builder instances, each of which targets a required
    architecture. What's interesting is that you don't need to have native machines
    to run the builds; you can also use the QEMU emulation or cross-compilation in
    a multi-stage build. Although it is much more powerful than the previous approach,
    Buildx is also quite complicated. At the time of writing, it requires Docker experimental
    mode and Linux kernel 4.8 or later. It requires you to set up and manage builders
    and not everything behaves in an intuitive way. It's possible it will improve
    and become more stable in the near future.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性是使用Docker内置的名为Buildx的功能。使用Buildx，你可以附加多个构建器实例，每个实例针对所需的架构。有趣的是，你不需要本机机器来运行构建；你还可以在多阶段构建中使用QEMU模拟或交叉编译。尽管它比之前的方法更强大，但Buildx也相当复杂。在撰写本文时，它需要Docker实验模式和Linux内核4.8或更高版本。你需要设置和管理构建器，并且并非所有功能都以直观的方式运行。它可能会在不久的将来改进并变得更加稳定。
- en: 'An example code to prepare the build environment and build a multi-platform
    image may look like the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 准备构建环境并构建多平台镜像的示例代码可能如下所示：
- en: '[PRE6]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, this may be a little confusing if you're used to the regular
    `docker build` command.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，如果你习惯于常规的`docker build`命令，这可能会有点令人困惑。
- en: Alternative ways to build application containers
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建应用程序容器的替代方法
- en: Building container images with Docker requires the Docker daemon to be running.
    The Docker daemon requires root privileges, which may pose security problems in
    some setups. Even though the Docker client that does the building may be run by
    an unprivileged user, it is not always feasible to install the Docker daemon in
    the build environment.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker构建容器镜像需要Docker守护程序运行。Docker守护程序需要root权限，在某些设置中可能会带来安全问题。即使进行构建的Docker客户端可能由非特权用户运行，但在构建环境中安装Docker守护程序并非总是可行。
- en: Buildah
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Buildah
- en: 'Buildah is an alternative tool to build container images that can be configured
    to run without root access. Buildah can work with regular Dockerfiles, which we
    discussed earlier. It also presents its own command-line interface that you can
    use in shell scripts or other automation you find more intuitive. One of the previous
    Dockerfiles rewritten as a shell script using the buildah interface will look
    like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Buildah是一个替代工具，可以配置为在没有root访问权限的情况下运行。Buildah可以使用常规的Dockerfile，我们之前讨论过。它还提供了自己的命令行界面，你可以在shell脚本或其他更直观的自动化中使用。将之前的Dockerfile重写为使用buildah接口的shell脚本之一将如下所示：
- en: '[PRE7]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: One interesting feature of Buildah is that it allows you to mount the container
    image filesystem into your host filesystem. This way, you can use your host's
    commands to interact with the contents of the image. If you have software you
    don't want (or can't due to licensing restrictions) put within the container,
    it's still possible to invoke it outside of the container when using Buildah.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Buildah的一个有趣特性是它允许你将容器镜像文件系统挂载到主机文件系统中。这样，你可以使用主机的命令与镜像的内容进行交互。如果你有一些不想（或者由于许可限制而无法）放入容器中的软件，使用Buildah时仍然可以在容器外部调用它。
- en: Ansible-bender
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ansible-bender
- en: 'Ansible-bender uses Ansible playbooks and Buildah to build container images.
    All of the configuration, including base images and metadata, is passed as a variable
    within the playbook. Here is our previous example converted to Ansible syntax:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible-bender使用Ansible playbooks和Buildah来构建容器镜像。所有配置，包括基本镜像和元数据，都作为playbook中的变量传递。以下是我们之前的示例转换为Ansible语法的示例：
- en: '[PRE8]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you see, the `ansible_bender` variable is responsible for all the configuration
    specific to containers. The tasks presented below are executed inside the container
    based on `base_image`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`ansible_bender`变量负责所有与容器特定配置相关的内容。下面呈现的任务在基于`base_image`的容器内执行。
- en: One thing to note is that Ansible requires a Python interpreter present in the
    base image. This is why we had to change `ubuntu:bionic` used in previous examples
    to `python:3-buster`. `ubuntu:bionic` is an Ubuntu image without a Python interpreter
    preinstalled.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，Ansible需要基本镜像中存在Python解释器。这就是为什么我们不得不将在之前的示例中使用的`ubuntu:bionic`更改为`python:3-buster`。`ubuntu:bionic`是一个没有预安装Python解释器的Ubuntu镜像。
- en: Others
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他
- en: There are also other ways to build container images. You can use Nix to create
    a filesystem image and then put it inside the image using Dockerfile's `COPY`
    instruction, for example. Going further, you can prepare a filesystem image by
    any other means and then import it as a base container image using `docker import`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他构建容器镜像的方法。你可以使用Nix创建文件系统镜像，然后使用Dockerfile的`COPY`指令将其放入镜像中，例如。更进一步，你可以通过任何其他方式准备文件系统镜像，然后使用`docker
    import`将其导入为基本容器镜像。
- en: Choose whichever solution fits your particular needs. Keep in mind that building
    with a Dockerfile using `docker build` is the most popular approach and hence
    it is the best-documented one and the best supported. Going with Buildah is more
    flexible and allows you to better fit creating container images into your build
    process. Finally, `ansible-bender` may be a good solution if you're already heavily
    invested in Ansible and you want to reuse already available modules.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 选择符合你特定需求的解决方案。请记住，使用`docker build`使用Dockerfile进行构建是最流行的方法，因此它是最有文档支持的。使用Buildah更加灵活，可以更好地将创建容器镜像融入到构建过程中。最后，如果你已经在Ansible中投入了大量精力，并且想要重用已有的模块，`ansible-bender`可能是一个不错的解决方案。
- en: Integrating containers with CMake
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将容器与CMake集成
- en: In this section, we'll demonstrate how to create a Docker image by working with
    CMake.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将演示如何通过使用CMake来创建Docker镜像。
- en: Configuring the Dockerfile with CMake
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用CMake配置Dockerfile
- en: 'First, and foremost, we''ll need a Dockerfile. Let''s use yet another CMake
    input file for this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个Dockerfile。让我们使用另一个CMake输入文件来实现这一点：
- en: '[PRE9]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that we're using `PROJECT_BINARY_DIR` to not overwrite any Dockerfiles
    created by other projects in the source tree if our project is part of a bigger
    one.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用`PROJECT_BINARY_DIR`来避免覆盖源树中其他项目创建的Dockerfile，如果我们的项目是更大项目的一部分。
- en: 'Our `Dockerfile.in` file will look as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Dockerfile.in`文件将如下所示：
- en: '[PRE10]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, we specify that we'll take the latest Ubuntu image, install our DEB package
    on it along with its dependencies, and then tidy up. It's important to update
    the package manager cache in the same step as installing the package to avoid
    issues with stale caches due to how layers in Docker work. Cleanup is also performed
    as part of the same `RUN` command (in the same layer) so that the layer size is
    smaller. After installing the package, we make our image run the `customer` microservice
    when it is started. Finally, we tell Docker to expose the port that it will be
    listening on.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们指定我们将使用最新的Ubuntu镜像，在其中安装我们的DEB包及其依赖项，然后进行整理。在安装软件包的同时更新软件包管理器缓存是很重要的，以避免由于Docker层的工作方式而导致的旧缓存问题。清理也作为相同的`RUN`命令的一部分进行（在同一层），以使层大小更小。安装软件包后，我们让我们的镜像在启动时运行`customer`微服务。最后，我们告诉Docker暴露它将监听的端口。
- en: Now, back to our `CMakeLists.txt` file.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到我们的`CMakeLists.txt`文件。
- en: Integrating containers with CMake
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将容器与CMake集成
- en: 'For CMake-based projects, it is possible to include a build step responsible
    for building the containers. For that, we need to tell CMake to find the Docker
    executable and bail out if it doesn''t. We can do this using the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于CMake的项目，可以包含一个负责构建容器的构建步骤。为此，我们需要告诉CMake找到Docker可执行文件，并在找不到时退出。我们可以使用以下方法来实现：
- en: '[PRE11]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let's revisit the example from one of [Chapter 7](7f997c01-2634-4584-be95-0b068f448312.xhtml),
    *Building and Packaging*. There, we built a binary and a Conan package for the
    customer application. Now, we want to package this application as a Debian archive
    and build a Debian container image with a pre-installed package for the customer
    application.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新访问[第7章](7f997c01-2634-4584-be95-0b068f448312.xhtml)中的一个示例，*构建和打包*。在那里，我们为客户应用程序构建了一个二进制文件和一个Conan软件包。现在，我们希望将这个应用程序打包为一个Debian存档，并构建一个预安装软件包的Debian容器镜像，用于客户应用程序。
- en: 'To create our DEB package, we need a helper target. Let''s use CMake''s `add_custom_target`
    functionality for this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们的DEB软件包，我们需要一个辅助目标。让我们使用CMake的`add_custom_target`功能来实现这一点：
- en: '[PRE12]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Our target invokes CPack to create just the one package that's interesting for
    us and omitting the rest. We want the package to be created in the same directory
    as the Dockerfile for convenience. The `VERBATIM` keyword is recommended as, with
    it, CMake will escape problematic characters. If it's not specified, the behavior
    of your scripts may vary across different platforms.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标调用CPack来创建我们感兴趣的一个软件包，并省略其余的软件包。我们希望软件包在与Dockerfile相同的目录中创建，以方便起见。推荐使用`VERBATIM`关键字，因为使用它，CMake将转义有问题的字符。如果未指定，您的脚本的行为可能会因不同平台而异。
- en: 'The `add_dependencies` call will make sure that before CMake builds the `customer-deb`
    target, `libcustomer` is already built. As we now have our helper target, let''s
    use it when creating the container image:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_dependencies`调用将确保在CMake构建`customer-deb`目标之前，`libcustomer`已经构建。现在我们有了辅助目标，让我们在创建容器镜像时使用它：'
- en: '[PRE13]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, we invoke the Docker executable we found earlier in the directory
    containing our Dockerfile and DEB package, to create an image. We also tell Docker
    to tag our image as both the latest and with the version of our project. Finally,
    we ensure the DEB package will be built when we invoke our Docker target.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们调用了我们之前在包含我们的Dockerfile和DEB软件包的目录中找到的Docker可执行文件，以创建一个镜像。我们还告诉Docker将我们的镜像标记为最新版本和我们项目的版本。最后，我们确保在调用我们的Docker目标时将构建DEB软件包。
- en: Building the image is as simple as `make docker` if `make` is the generator
    you chose. If you prefer the full CMake command (for example, to create generator-agnostic
    scripts), the invocation is `cmake --build . --target docker`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择的生成器是`make`，那么构建镜像就像`make docker`一样简单。如果您更喜欢完整的CMake命令（例如，为了创建与生成器无关的脚本），那么调用是`cmake
    --build . --target docker`。
- en: Testing and integrating containers
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和集成容器
- en: Containers fit very well with CI/CD pipelines. Since they mostly require no
    further dependencies other than the container runtime itself, they can be easily
    tested. Worker machines don't have to be provisioned to fulfill the testing needs,
    so adding more nodes is much easier. What is more, all of them are general-purpose
    so that they may act both as builders, test runners, and even deployment executors
    without any prior configuration.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 容器非常适合CI/CD流水线。由于它们大多数情况下除了容器运行时本身不需要其他依赖项，因此它们可以很容易地进行测试。工作机器不必被配置以满足测试需求，因此添加更多节点更容易。而且，它们���是通用的，因此它们可以充当构建者、测试运行者，甚至是部署执行者，而无需任何先前的配置。
- en: Another great benefit of using containers in **CI**/**CD** is the fact that
    they are isolated from one another. This means multiple copies running on the
    same machine should not interfere. That is true unless the tests require some
    resources from the host operating system, such as port forwarding or volume mounting.
    Therefore it's best to design tests so that such resources are not necessary (or
    at least they don't clash). Port randomization is a helpful technique to avoid
    clashes, for example.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在**CI**/**CD**中使用容器的另一个巨大好处是它们彼此隔离。这意味着在同一台机器上运行的多个副本不应该相互干扰。这是真的，除非测试需要一些来自主机操作系统的资源，例如端口转发或卷挂载。因此最好设计测试，使这些资源不是必需的（或者至少它们不会发生冲突）。端口随机化是一种有用的技术，可以避免冲突，例如。
- en: Runtime libraries inside containers
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器内的运行时库
- en: The choice of containers may influence the choice of a toolchain and, therefore,
    C++ language features available to the application. Since containers are typically
    Linux-based, the system compiler available is usually GNU GCC with glibc as a
    standard library. However, some Linux distributions popular with containers, such
    as Alpine Linux, are based on a different standard library, musl.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的选择可能会影响工具链的选择，因此也会影响应用程序可用的C++语言特性。由于容器通常基于Linux，可用的系统编译器通常是带有glibc标准库的GNU
    GCC。然而，一些流行的用于容器的Linux发行版，如Alpine Linux，基于不同的标准库musl。
- en: If you are targeting such a distribution, make sure the code you'll be using,
    whether developed in-house or from third-party providers, is compatible with musl.
    The main advantage of both musl and Alpine Linux is that it results in much smaller
    container images. For example, a Python image built for Debian Buster is around
    330 MB, the slimmed-down Debian version is around 40 MB, while the Alpine version
    is only around 16 MB. Smaller images mean less wasted bandwidth (for uploads and
    downloads) and quicker updates.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的目标是这样的发行版，确保你将要使用的代码，无论是内部开发的还是来自第三方提供者，都与musl兼容。musl和Alpine Linux的主要优势是它们可以生成更小的容器镜像。例如，为Debian
    Buster构建的Python镜像约为330MB，精简版的Debian版本约为40MB，而Alpine版本仅约为16MB。更小的镜像意味着更少的带宽浪费（用于上传和下载）和更快的更新。
- en: Alpine may also introduce some unwanted traits, such as longer build times,
    obscure bugs, or reduced performance. If you want to use it to reduce the size,
    run proper tests to make sure the application behaves without problems.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Alpine可能也会引入一些不需要的特性，比如更长的构建时间、隐晦的错误或性能降低。如果你想使用它来减小大小，务必进行适当的测试，确保应用程序没有问题。
- en: To reduce your images' size even more, you may consider ditching the underlying
    operating system altogether. What we mean by operating system here is all the
    userland tools ordinarily present in a container, such as a shell, package manager,
    and shared libraries. After all, if your application is the only thing that's
    going to be running, everything else is unnecessary.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步减小镜像的大小，你可以考虑放弃底层操作系统。这里所说的操作系统是指通常存在于容器中的所有用户空间工具，如shell、包管理器和共享库。毕竟，如果你的应用是唯一要运行的东西，其他一切都是不必要的。
- en: It is typical for Go or Rust applications to provide a static build that is
    self-sufficient and can form a container image. While this might not be as straightforward
    in C++, it is worth considering.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Go或Rust应用程序通常提供一个自包含的静态构建，可以形成一个容器镜像。虽然在C++中可能不那么直接，但也值得考虑。
- en: There are a few drawbacks related to decreasing the image size as well. First
    of all, if you decide to go with Alpine Linux, keep in mind it is not as popular
    as, say, Ubuntu, Debian, or CentOS. Although it is often a platform of choice
    for container developers, it's very unusual for any other purpose.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 减小镜像大小也有一些缺点。首先，如果你决定使用Alpine Linux，请记住它不像Ubuntu、Debian或CentOS那样受欢迎。尽管它经常是容器开发者的首选平台，但对于其他用途来说非常不寻常。
- en: This means that there might be new compatibility problems, mostly stemming from
    the fact it's not based on the de facto standard glibc implementation. If you
    rely on third-party components, the provider may not offer support for this platform.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着可能会出现新的兼容性问题，主要源自它不是基于事实上的标准glibc实现。如果你依赖第三方组件，提供者可能不会为这个平台提供支持。
- en: If you decide to go down the single statically linked binary inside the container
    image route, there are also some challenges to consider. First of all, you are
    discouraged from statically linking glibc as it makes internal use of dlopen to
    handle **Name Service Switch** (**NSS**) and iconv. If your software relies on
    DNS resolving or character set conversion, you'll have to provide a copy of glibc
    and the relevant libraries anyway.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定采用容器镜像中的单个静态链接二进制文件路线，也有一些挑战需要考虑。首先，你不建议静态链接glibc，因为它内部使用dlopen来处理**Name
    Service Switch**（NSS）和iconv。如果你的软件依赖于DNS解析或字符集转换，你仍然需要提供glibc和相关库的副本。
- en: Another point to consider is that shell and package managers are often used
    for debugging containers that misbehave. When one of your containers is acting
    strangely, you may start another process inside the container and figure out what
    is happening inside by using standard UNIX tools such as `ps`, `ls`, or `cat`.
    To run such an application inside the container, it has to be present in the container
    image first. Some workarounds allow the operator to inject debugging binaries
    inside the running container, but none of them are well-supported at the moment.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的问题是，通常会使用shell和包管理器来调试行为异常的容器。当你的某个容器表现出奇怪的行为时，你可以在容器内启动另一个进程，并通过使用诸如`ps`、`ls`或`cat`等标准UNIX工具来弄清楚容器内部发生了什么。要在容器内运行这样的应用程序，它必须首先存在于容器镜像中。一些解决方法允许操作员在运行的容器内注入调试二进制文件，但目前没有一个得到很好的支持。
- en: Alternative container runtimes
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替代容器运行时
- en: Docker is the most popular way to build and run containers, but since the container
    standard is open, there are also alternative runtimes that you may use. The main
    replacement for Docker that offers a similar user experience is Podman. Together
    with Buildah, described in the previous section, they are tools aimed to replace
    Docker altogether.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是构建和运行容器的最流行方式，但由于容器标准是开放的，也有其他可供选择的运行时。用于替代Docker并提供类似用户体验的主要工具是Podman。与前一节中描述的Buildah一起，它们是旨在完全取代Docker的工具。
- en: The added benefit is that they *don't require an additional daemon running on
    a host machine, as Docker does*. Both also have support (although it is not yet
    mature) for rootless operations, which makes them a better fit for security-critical
    operations. Podman accepts all the commands you would expect the Docker CLI to
    take, so you can simply use it as an alias this way.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的另一个好处是*不需要在主机上运行额外的守护程序，就像Docker一样*。它们两者也都支持（尽管尚不成熟）无根操作，这使它们更适合安全关键操作。Podman接受您期望Docker
    CLI执行的所有命令，因此您可以简单地将其用作别名。
- en: Another approach to containers that aims to provide better security is the **Kata
    Containers** initiative. Kata Containers uses lightweight virtual machines to
    leverage the hardware virtualization required for an additional level of isolation
    between the containers and the host operating system.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种旨在提供更好安全性的容器方法是**Kata Containers**倡议。Kata Containers使用轻量级虚拟机来利用硬件虚拟化，以在容器和主机操作系统之间提供额外的隔离级别。
- en: Cri-O and containerd are also popular runtimes used by Kubernetes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Cri-O和containerd也是Kubernetes使用的流行运行时。
- en: Understanding container orchestration
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解容器编排
- en: Some of the containers' benefits only become apparent when you are using a container
    orchestrator to manage them. An orchestrator keeps track of all the nodes that
    will be running your workload, and it also monitors the health and status of the
    containers spread across these nodes.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一些容器的好处只有在使用容器编排器来管理它们时才会显现出来。编排器会跟踪将运行您的工作负载的所有节点，并监视这些节点上分布的容器的健康和状态。
- en: More advanced features, for example, high availability, require the proper setup
    of the orchestrator, which typically means dedicating at least three machines
    for the control plane and another three machines for worker nodes. The autoscaling
    of nodes, in addition to the autoscaling of containers, also requires the orchestrator
    to have a driver able to control the underlying infrastructure (for example, by
    using the cloud provider's API).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，高可用性等更高级的功能需要正确设置编排器，通常意味着至少要为控制平面专门分配三台机器，另外还需要为工作节点分配三台机器。节点的自动缩放，以及容器的自动缩放，还需要编排器具有能够控制底层基础设施的驱动程序（例如，通过使用云提供商的API）。
- en: Here, we will cover some of the most popular orchestrators that you can choose
    from to base your system on. You will find more practical information on Kubernetes
    in the next chapter, [Chapter 15](https://cdp.packtpub.com/hands_on_software_architecture_with_c__/wp-admin/post.php?post=41&action=edit),
    *Cloud-Native Design*. Here, we give you an overview of the possible choices.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将介绍一些最受欢迎的编排器，您可以选择其中一个作为系统的基础。您将在下一章[Kubernetes](https://cdp.packtpub.com/hands_on_software_architecture_with_c__/wp-admin/post.php?post=41&action=edit)中找到更多关于Kubernetes的实用信息，*云原生设计*。在这里，我们给您一个可能的选择概述。
- en: The presented orchestrators operate on similar objects (services, containers,
    batch jobs) although each may behave differently. The available features and operating
    principles vary between them. What they have in common is that you typically write
    a configuration file that declaratively describes the required resources and then
    you apply this configuration using a dedicated CLI tool. To illustrate the differences
    between the tools, we provide an example configuration specifying a web application
    introduced before (the merchant service) and a popular web server, Nginx, to act
    as a proxy.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 所提供的编排器操作类似的对象（服务、容器、批处理作业），尽管每个对象的行为可能不同。可用的功能和操作原则在它们之间也有所不同。它们的共同之处在于，通常您会编写一个配置文件，以声明方式描述所需的资源，然后使用专用的CLI工具应用此配置。为了说明工具之间的差异，我们提供了一个示例配置，指定了之前介绍的一个Web应用程序（商家服务）和一个流行的Web服务器Nginx作为代理。
- en: Self-hosted solutions
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自托管解决方案
- en: Whether you are running your application on-premises, in a private cloud, or
    in a public cloud, you may want to have tight control over the orchestrator of
    your choice. The following is a collection of self-hosted solutions in this space.
    Keep in mind that most of them are also available as managed services. However,
    going with self-hosted helps you prevent vendor lock-in, which may be desirable
    for your organization.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是在本地运行应用程序，还是在私有云或公共云中运行，您可能希望对所选择的编排器有严格的控制。以下是这个领域中的一些自托管解决方案。请记住，它们中的大多数也可以作为托管服务提供。但是，选择自托管可以帮助您防止供应商锁定，这可能对您的组织是可取的。
- en: Kubernetes
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kubernetes
- en: Kubernetes is probably the best-known orchestrator of all the ones that we mention
    here. It is prevalent, which means there is a lot of documentation and community
    support if you decide to implement it.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes可能是我们在这里提到的所有编排器中最为人所知的。它很普遍，这意味着如果您决定实施它，将会有很多文档和社区支持。
- en: Even though Kubernetes uses the same application container format as Docker,
    this is basically where all the similarities end. It is impossible to use standard
    Docker tools to interact with Kubernetes clusters and resources directly. There
    is a new set of tools and concepts to learn when using Kubernetes.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Kubernetes使用与Docker相同的应用程序容器格式，但基本上这就是所有相似之处的结束。不可能使用标准的Docker工具直接与Kubernetes集群和资源进行交互。在使用Kubernetes时，需要学习一套新的工具和概念。
- en: Whereas with Docker, the container is the main object you will operate on, with
    Kubernetes, the smallest piece of the runtime is called a Pod. A Pod may consist
    of one or more containers that share mount points and networking resources. Pods
    in themselves are rarely of interest as Kubernetes also has higher-order concepts
    such as Replication Controllers, Deployment Controllers, or DaemonSets. Their
    role is to keep track of the pods and ensure the desired number of replicas is
    running on the nodes.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 与Docker不同，容器是您将操作的主要对象，而在Kubernetes中，运行时的最小单元称为Pod。Pod可能由一个或多个共享挂载点和网络资源的容器组成。Pod本身很少引起兴趣，因为Kubernetes还具有更高级的概念，如复制控制器、部署控制器或守护进程集。它们的作用是跟踪Pod并确保节点上运行所需数量的副本。
- en: The networking model in Kubernetes is also very different from Docker. With
    Docker, you can forward ports from a container to make it accessible from different
    machines. With Kubernetes, if you want to access a pod, you typically create a
    Service resource, which may act as a load balancer to handle the traffic to the
    pods that form the service's backend. Services may be used for pod-to-pod communication,
    but they may also be exposed to the internet. Internally, Kubernetes resources
    perform service discovery using DNS names.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中的网络模型也与Docker非常不同。在Docker中，您可以将容器的端口转发，使其可以从不同的机器访问。在Kubernetes中，如果要访问一个pod，通常会创建一个Service资源，它可以作为负载均衡器来处理指向服务后端的流量。服务可以用于pod之间的通信，也可以暴露给互联网。在内部，Kubernetes资源使用DNS名称执行服务发现。
- en: Kubernetes is declarative and eventually consistent. This means that instead
    of directly creating and allocating resources, you only have to provide the description
    of the desired end state and Kubernetes will do the work required to bring the
    cluster to the desired state. Resources are often described using YAML.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes是声明性的，最终一致的。这意味着您不必直接创建和分配资源，只需提供所需最终状态的描述，Kubernetes将完成将集群带到所需状态所需的工作。资源通常使用YAML描述。
- en: Since Kubernetes is highly extensible, there are a lot of associated projects
    developed under the **Cloud Native Computing Foundation** (**CNCF**), which turn
    Kubernetes into a provider-agnostic cloud development platform. We will present
    Kubernetes in more detail in the next chapter, [Chapter 15](27377621-3532-4513-8045-caa00285fdda.xhtml),
    *Cloud Native Design*.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Kubernetes具有高度的可扩展性，因此在**Cloud Native Computing Foundation**（**CNCF**）下开发了许多相关项目，将Kubernetes转变为一个与提供商无关的云开发平台。我们将在下一章[第15章](27377621-3532-4513-8045-caa00285fdda.xhtml)中更详细地介绍Kubernetes，*云原生设计*。
- en: 'Here''s how the resource definition looks for Kubernetes using YAML (`merchant.yaml`):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用YAML（`merchant.yaml`）在Kubernetes中的资源定义方式：
- en: '[PRE14]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To apply this configuration and orchestrate the containers, use `kubectl apply
    -f merchant.yaml`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用此配置并编排容器，请使用`kubectl apply -f merchant.yaml`。
- en: Docker Swarm
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker Swarm
- en: Docker Engine, also required to build and run Docker containers, comes pre-installed
    with its own orchestrator. This orchestrator is Docker Swarm, and its main feature
    is high compatibility with existing Docker tools by using the Docker API.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Docker引擎，也需要构建和运行Docker容器，预装有自己的编排器。这个编排器是Docker Swarm，其主要特点是通过使用Docker API与现有的Docker工具高度兼容。
- en: Docker Swarm uses the concept of Services to manage health checks and autoscaling.
    It supports rolling upgrades of the services natively. Services are able to publish
    their ports, which will then be served by Swarm's load balancer. It supports storing
    configs as objects for runtime customization and has basic secret management built
    in.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Swarm使用服务的概念来管理健康检查和自动扩展。它原生支持服务的滚动升级。服务能够发布它们的端口，然后由Swarm的负载均衡器提供服务。它支持将配置存储为对象以进行运行时自定义，并内置了基本的秘密管理。
- en: Docker Swarm is much simpler and less extensible than Kubernetes. This could
    be an advantage if you do not want to learn about all the details of Kubernetes.
    However, the main disadvantage is a lack of popularity, which means it is harder
    to find relevant material about Docker Swarm.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Swarm比Kubernetes简单得多，可扩展性较差。如果您不想了解Kubernetes的所有细节，这可能是一个优势。然而，主要的缺点是缺乏流行度，这意味着更难找到有关Docker
    Swarm的相关材料。
- en: One of the benefits of using Docker Swarm is that you don't have to learn new
    commands. If you're already used to Docker and Docker Compose, Swarm works with
    the same resources. It allows specific options that extend Docker to handle deployments.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker Swarm的好处之一是您不必学习新的命令。如果您已经习惯了Docker和Docker Compose，Swarm可以使用相同的资源。它允许特定选项扩展Docker以处理部署。
- en: 'Two services orchestrated with Swarm would look like this (`docker-compose.yml`):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Swarm编排的两个服务看起来像这样（`docker-compose.yml`）：
- en: '[PRE15]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To apply the configuration, you run `docker stack deploy --compose-file docker-compose.yml
    dominican`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 应用配置时，您可以运行`docker stack deploy --compose-file docker-compose.yml dominican`。
- en: Nomad
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Nomad
- en: Nomad is different from the previous two solutions, as it is not focused solely
    on containers. It is a general-purpose orchestrator with support for Docker, Podman,
    Qemu Virtual Machines, isolated fork/exec, and several other task drivers. Nomad
    is a solution worth learning about if you want to gain some of the advantages
    of container orchestration without migrating your application to containers.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Nomad与前两种解决方案不同，因为它不仅专注于容器。它是一个通用的编排器，支持Docker、Podman、Qemu虚拟机、隔离的fork/exec和其他几种任务驱动程序。如果您想获得容器编排的一些优势而不将应用迁移到容器中，那么了解Nomad是值得的。
- en: It is relatively easy to set up and integrates well with other HashiCorp products
    such as Consul for service discovery and Vault for secret management. Like Docker
    or Kubernetes, Nomad clients can run locally and connect to the server responsible
    for managing your cluster.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 它相对容易设置，并且与其他HashiCorp产品（如Consul用于服务发现和Vault用于秘密管理）很好地集成。与Docker或Kubernetes一样，Nomad客户端可以在本地运行，并连接到负责管理集群的服务器。
- en: 'There are three job types available in Nomad:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Nomad有三种作业类型可用：
- en: '**Service**: A long-lived task that should not exit without manual intervention
    (for example, a web server or a database).'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**：一个不应该在没有手动干预的情况下退出的长期任务（例如，Web服务器或数据库）。'
- en: '**Batch**: A shorter-lived task that can complete within as little as a few
    minutes. If the batch job returns an exit code indicating an error, it is either
    restarted or rescheduled according to configuration.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**批处理**：一个较短寿命的任务，可以在几分钟内完成。如果批处理作业返回指示错误的退出代码，则根据配置重新启动或重新调度。'
- en: '**System**: A task that it is necessary to run on every node in the cluster
    (for example, logging agent).'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统**：必须在集群中的每个节点上运行的任务（例如，日志代理）。'
- en: Compared to other orchestrators, Nomad is relatively easy to install and maintain.
    It is also extensible when it comes to task drivers or device plugins (used to
    access dedicated hardware such as GPUs or FPGAs). It lacks in community support
    and third-party integrations when compared to Kubernetes. Nomad does not require
    you to redesign the application's architecture to access the provided benefits,
    which is often the case with Kubernetes.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他编排器相比，Nomad在安装和维护方面相对容易。在任务驱动程序或设备插件（用于访问专用硬件，如GPU或FPGA）方面也是可扩展的。与Kubernetes相比，Nomad在社区支持和第三方集成方面欠缺。Nomad不需要您重新设计应用程序的架构以获得提供的好处，而这在Kubernetes中经常发生。
- en: 'To configure the two services with Nomad, we need two configuration files.
    The first one is `nginx.nomad`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Nomad配置这两个服务，我们需要两个配置文件。第一个是`nginx.nomad`：
- en: '[PRE16]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The second describes the merchant application, so it''s called `merchant.nomad`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个描述了商户应用程序，因此被称为`merchant.nomad`：
- en: '[PRE17]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To apply the configuration, you run `nomad job run merchant.nomad && nomad job
    run nginx.nomad`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用配置，您需要运行`nomad job run merchant.nomad && nomad job run nginx.nomad`。
- en: OpenShift
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OpenShift
- en: OpenShift is Red Hat's commercial container platform built on Kubernetes. It
    includes a lot of additional components that are useful in the everyday operations
    of Kubernetes clusters. You get a container registry, a build tool similar to
    Jenkins, Prometheus for monitoring, Istio for service mesh, and Jaeger for tracing.
    It is not fully compatible with Kubernetes so it shouldn't be thought of as a
    drop-in replacement.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift是红帽的基于Kubernetes构建的商业容器平台。它包括许多在Kubernetes集群的日常运营中有用的附加组件。您将获得一个容器注册表，一个类似Jenkins的构建工具，用于监控的Prometheus，用于服务网格的Istio和用于跟踪的Jaeger。它与Kubernetes不完全兼容，因此不应将其视为可直接替换的产品。
- en: It is built on top of existing Red Hat technology such as CoreOS and Red Hat
    Enterprise Linux. You can use it on-premises, within Red Hat Cloud, on one of
    the supported public cloud providers (including AWS, GCP, IBM, and Microsoft Azure),
    or as a hybrid cloud.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 它是建立在现有的红帽技术之上，如CoreOS和红帽企业Linux。您可以在本地使用它，在红帽云中使用它，在受支持的公共云提供商之一（包括AWS、GCP、IBM和Microsoft
    Azure）中使用它，或者作为混合云使用。
- en: There is also an open source community-supported project called OKD, which forms
    the basis of Red Hat's OpenShift. If you do not require commercial support and
    other benefits of OpenShift, you may still use OKD for your Kubernetes workflow.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为OKD的开源社区支持项目，它是红帽OpenShift的基础。如果您不需要商业支持和OpenShift的其他好处，仍然可以在Kubernetes工作流程中使用OKD。
- en: Managed services
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 托管服务
- en: As previously mentioned, some of the aforementioned orchestrators are also available
    as managed services. Kubernetes, for instance, is available as a managed solution
    in multiple public cloud providers. This section will show you some of the different
    approaches to container orchestration, which are not based on any of the solutions
    mentioned above.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，一些前述的编排器也可以作为托管服务提供。例如，Kubernetes可以作为多个公共云提供商的托管解决方案。本节将向您展示一些不基于上述任何解决方案的容器编排的不同方法。
- en: AWS ECS
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AWS ECS
- en: Before Kubernetes released its 1.0 version, Amazon Web Services proposed its
    own container orchestration technology called **Elastic Container Service** (**ECS**).
    ECS provides an orchestrator that monitors, scales, and restarts your services
    when needed.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes发布其1.0版本之前，亚马逊网络服务提出了自己的容器编排技术，称为弹性容器服务（ECS）。ECS提供了一个编排器，可以在需要时监视、扩展和重新启动您的服务。
- en: To run containers in ECS, you need to provide the EC2 instances on which the
    workload will run. You are not billed for the orchestrator's use, but you are
    billed for all the AWS services that you typically use (the underlying EC2 instances,
    for example, or an RDS database).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要在ECS中运行容器，您需要提供工作负载将运行的EC2实例。您不需要为编排器的使用付费，但您需要为通常使用的所有AWS服务付费（例如底层的EC2实例或RDS数据库）。
- en: One of the significant benefits of ECS is its excellent integration with the
    rest of the AWS ecosystem. If you are already familiar with AWS services and invested
    in the platform, you will have less trouble understanding and managing ECS.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ECS的一个重要优势是其与AWS生态系统的出色集成。如果您已经熟悉AWS服务并投资于该平台，您将更容易理解和管理ECS。
- en: If you do not require many of the Kubernetes advanced features and its extensions,
    ECS may be a better choice as it's more straightforward and more comfortable to
    learn.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不需要许多Kubernetes高级功能和其扩展功能，ECS可能是更好的选择，因为它更直接，更容易学习。
- en: AWS Fargate
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AWS Fargate
- en: Another managed orchestrator offered by AWS is Fargate. Unlike ECS, it does
    not require you to provision and pay for the underlying EC2 instances. The only
    components you are focused on are the containers, the network interfaces attached
    to them, and IAM permissions.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: AWS还提供了另一个托管的编排器Fargate。与ECS不同，它不需要您为底层的EC2实例进行配置和付费。您需要关注的唯一组件是容器、与其连接的网络接口和IAM权限。
- en: Fargate requires the least amount of maintenance compared to other solutions
    and is the easiest to learn. Autoscaling and load-balancing are available out
    of the box thanks to the existing AWS products in this space.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他解决方案相比，Fargate需要的维护量最少，也是最容易学习的。由于现有的AWS产品在这一领域已经提供了自动扩展和负载平衡功能。
- en: The main downside here is the premium that you pay for hosting your services
    when compared to ECS. A straight comparison is not possible as ECS requires paying
    for the EC2 instances, while Fargate requires paying for the memory and CPU usage
    independently. This lack of direct control over your cluster may easily lead to
    high costs once your services start to autoscale.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要缺点是与ECS相比，您为托管服务支付的高额费用。直接比较是不可能的，因为ECS需要支付EC2实例的费用，而Fargate需要独立支付内存和CPU使用费用。对集群缺乏直接控制可能会导致一旦服务开始自动扩展就会产生高昂的成本。
- en: Azure Service Fabric
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Azure Service Fabric
- en: The problem with all of the preceding solutions is that they mostly target Docker
    containers, which are first and foremost Linux-centric. Azure Service Fabric,
    on the other hand, is a Windows-first product backed by Microsoft. It enables
    running legacy Windows apps without modifications, which may help you migrate
    your application if it relies on such services.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 所有先前解决方案的问题在于它们大多针对首先是Linux中心的Docker容器。另一方面，Azure Service Fabric是由微软支持的首先是Windows的产品。它可以在不修改的情况下运行传统的Windows应用程序，这可能有助于您迁移应用程序，如果它依赖于这些服务。
- en: As with Kubernetes, Azure Service Fabric is not so much a container orchestrator
    in itself, but rather a platform on top of which you can build your applications.
    One of the building blocks happens to be containers, so it works fine as an orchestrator.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 与Kubernetes一样，Azure Service Fabric本身并不是一个容器编排器，而是一个平台，您可以在其上构建应用程序。其中一个构建块恰好是容器，因此它作为编排器运行良好。
- en: With the recent introduction of Azure Kubernetes Service, the managed Kubernetes
    platform in the Azure cloud, there is less need for using Service Fabric.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Azure Kubernetes Service的最新推出，这是Azure云中的托管Kubernetes平台，使用Service Fabric的需求减少了。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: When you are an architect of modern software, you have to take into account
    modern technologies. Taking them into account doesn't mean following the trends
    blindly; it means being able to objectively assess whether a particular proposition
    makes sense in your case or not.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当您是现代软件的架构师时，您必须考虑现代技术。考虑它们并不意味着盲目地追随潮流；它意味着能够客观地评估特定建议是否在您的情况下有意义。
- en: Both microservices, presented in the previous chapters, and containers, presented
    in this chapter, are worth considering and understanding. Are they worth implementing
    as well? It depends heavily on what type of product you are designing. If you've
    read this far, you are ready to make the decision for yourself.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中介绍的微服务和本章介绍的容器都值得考虑和理解。它们是否值得实施？这在很大程度上取决于您正在设计的产品类型。如果您已经读到这里，那么您已经准备好自己做出决定了。
- en: The next chapter is dedicated to cloud-native design. A very interesting but
    also a complex topic that ties in service-oriented architecture, CI/CD, microservices,
    containers, and cloud services. As it turns out, the great performance of C++
    is a welcome feature for some of the cloud-native building blocks.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章专门讨论云原生设计。这是一个非常有趣但也复杂的主题，涉及面向服务的架构、CI/CD、微服务、容器和云服务。事实证明，C++的出色性能是一些云原生构建块的受欢迎特性。
- en: Questions
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How do application containers differ from operating system containers?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序容器与操作系统容器有何不同？
- en: What are some early examples of sandboxing environments in UNIX systems?
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: UNIX系统中一些早期的沙盒环境示例是什么？
- en: Why are containers a good fit for microservices?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么容器非常适合微服务？
- en: What are the main differences between containers and virtual machines?
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器和虚拟机之间的主要区别是什么？
- en: When are application containers a bad choice?
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序容器何时不是一个好选择？
- en: What are some tools to build multi-platform container images?
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有哪些构建多平台容器映像的工具？
- en: Besides Docker, what are some other container runtimes?
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了Docker，还有哪些其他容器运行时？
- en: What are some popular orchestrators?
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些流行的编排器是什么？
- en: Further reading
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Learning Docker - Second Edition*: [https://www.packtpub.com/product/learning-docker-second-edition/9781786462923](https://www.packtpub.com/product/learning-docker-second-edition/9781786462923)'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习Docker-第二版*：[https://www.packtpub.com/product/learning-docker-second-edition/9781786462923](https://www.packtpub.com/product/learning-docker-second-edition/9781786462923)'
- en: '*Learn OpenShift*: [https://www.packtpub.com/product/learn-openshift/9781788992329](https://www.packtpub.com/product/learn-openshift/9781788992329)'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习OpenShift*：[https://www.packtpub.com/product/learn-openshift/9781788992329](https://www.packtpub.com/product/learn-openshift/9781788992329)'
- en: '*Docker for Developers*: [https://www.packtpub.com/product/docker-for-developers/9781789536058](https://www.packtpub.com/product/docker-for-developers/9781789536058)'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*面向开发人员的Docker*：[https://www.packtpub.com/product/docker-for-developers/9781789536058](https://www.packtpub.com/product/docker-for-developers/9781789536058)'
