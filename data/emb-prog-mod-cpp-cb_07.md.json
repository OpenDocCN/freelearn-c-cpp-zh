["```cpp\n#include <chrono>\n#include <iostream>\n#include <thread>\n\nvoid worker(int index) {\n  for (int i = 0; i < 10; i++) {\n    std::cout << \"Worker \" << index << \" begins\" << std::endl;\n    std::this_thread::sleep_for(std::chrono::milliseconds(50));\n    std::cout << \"Worker \" << index << \" ends\" << std::endl;\n    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n  }\n}\n\nint main() {\n  std::thread worker1(worker, 1);\n  std::thread worker2(worker, 2);\n  worker1.join();\n  worker2.join();\n  std::cout << \"Done\" << std::endl;\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\nproject(threads)\nadd_executable(threads threads.cpp)\n\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR arm)\n\nSET(CMAKE_CXX_FLAGS \"--std=c++11\")\ntarget_link_libraries(threads pthread)\n\nset(CMAKE_CXX_COMPILER /usr/bin/arm-linux-gnueabi-g++)\n```", "```cpp\n std::thread worker1(worker, 1);\n std::thread worker2(worker, 2);\n```", "```cpp\n#include <chrono>\n#include <iostream>\n#include <mutex>\n#include <thread>\n\nstd::mutex m;\n\nvoid worker(int index) {\n  for (int i = 0; i < 10; i++) {\n    {\n std::lock_guard<std::mutex> g(m);\n std::cout << \"Worker \" << index << \" begins\" << std::endl;\n std::this_thread::sleep_for(std::chrono::milliseconds(50));\n std::cout << \"Worker \" << index << \" ends\" << std::endl;\n }\n    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n  }\n}\n\nint main() {\n  std::thread worker1(worker, 1);\n  std::thread worker2(worker, 2);\n  worker1.join();\n  worker2.join();\n  std::cout << \"Done\" << std::endl;\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\nproject(mutex)\nadd_executable(mutex mutex.cpp)\n\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR arm)\n\nSET(CMAKE_CXX_FLAGS \"--std=c++11\")\ntarget_link_libraries(mutex pthread)\n\nset(CMAKE_CXX_COMPILER /usr/bin/arm-linux-gnueabi-g++)\n```", "```cpp\nstd::mutex m;\n```", "```cpp\n    {\n      std::lock_guard<std::mutex> g(m);\n      std::cout << \"Worker \" << index << \" begins\" << std::endl;\n      std::this_thread::sleep_for(std::chrono::milliseconds(50));\n      std::cout << \"Worker \" << index << \" ends\" << std::endl;\n    }\n```", "```cpp\n#include <condition_variable>\n#include <iostream>\n#include <mutex>\n#include <thread>\n#include <vector>\n\nstd::mutex m;\nstd::condition_variable cv;\nstd::vector<int> result;\nint next = 0;\n```", "```cpp\nvoid worker(int index) {\n  for (int i = 0; i < 10; i++) {\n    std::unique_lock<std::mutex> l(m);\n    cv.wait(l, [=]{return next == index; });\n    std::cout << \"worker \" << index << \"\\n\";\n    result.push_back(index);\n    next = next + 1;\n    if (next > 2) { next = 1; };\n    cv.notify_all();\n  }\n}\n```", "```cpp\nint main() {\n  std::thread worker1(worker, 1);\n  std::thread worker2(worker, 2);\n  {\n    std::lock_guard<std::mutex> l(m);\n    next = 1;\n  }\n  std::cout << \"Start\\n\";\n  cv.notify_all();\n  worker1.join();\n  worker2.join();\n  for (int e : result) {\n    std::cout << e << ' ';\n  }\n  std::cout << std::endl;\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\ncmake_minimum_required(VERSION 3.5.1)\nproject(condvar)\nadd_executable(condvar condvar.cpp)\n\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR arm)\n\nSET(CMAKE_CXX_FLAGS \"--std=c++11\")\ntarget_link_libraries(condvar pthread)\n\nset(CMAKE_CXX_COMPILER /usr/bin/arm-linux-gnueabi-g++)\n```", "```cpp\nstd::vector<int> result;\n```", "```cpp\nstd::condition_variable cv;\nint next = 0;\n```", "```cpp\n  {\n    std::lock_guard<std::mutex> l(m);\n    next = 1;\n  }\n```", "```cpp\nstd::unique_lock<std::mutex> l(m);\ncv.wait(l, [=]{return next == index; });\n```", "```cpp\ncv.notify_all();\n```", "```cpp\nnext = next + 1;\nif (next > 2) { next = 1; };\n```", "```cpp\ncv.notify_all();\n```", "```cpp\n worker1.join();\n worker2.join();\n```", "```cpp\n  for (int e : result) {\n    std::cout << e << ' ';\n  }\n```", "```cpp\nstruct Point {\n  int x, y;\n};\n\nPoint p{0, 0};\nint b = 0;\n\np = {10, 10};\nb = 10;\n```", "```cpp\np.x = 10;\np.y = 10;\n```", "```cpp\n#include <atomic>\n#include <chrono>\n#include <iostream>\n#include <thread>\n#include <vector>\n\nstd::atomic<size_t> shared_index{0};\nstd::vector<int> data;\n```", "```cpp\nvoid worker(int index, int timeout) {\n  while(true) {\n  size_t worker_index = shared_index.fetch_add(1);\n  if (worker_index >= data.size()) {\n      break;\n  }\n  std::cout << \"Worker \" << index << \" handles \"\n              << worker_index << std::endl;\n  data[worker_index] = data[worker_index] * 2;\n    std::this_thread::sleep_for(std::chrono::milliseconds(timeout));\n  }\n  }\n```", "```cpp\nint main() {\n  for (int i = 0; i < 10; i++) {\n    data.emplace_back(i);\n  }\n  std::thread worker1(worker, 1, 50);\n  std::thread worker2(worker, 2, 20);\n  worker1.join();\n  worker2.join();\n  std::cout << \"Result: \";\n  for (auto& v : data) {\n    std::cout << v << ' ';\n  }\n  std::cout << std::endl;\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\nproject(atomic)\nadd_executable(atomic atomic.cpp)\n\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR arm)\n\nSET(CMAKE_CXX_FLAGS \"--std=c++11\")\ntarget_link_libraries(atomic pthread)\n\nset(CMAKE_CXX_COMPILER /usr/bin/arm-linux-gnueabi-g++)\n```", "```cpp\nstd::atomic<size_t> shared_index{0};\nstd::vector<int> data;\n```", "```cpp\nsize_t worker_index = shared_index.fetch_add(1);\n```", "```cpp\nif (worker_index >= data.size()) {\n      break;\n}\n```", "```cpp\ndata[worker_index] = data[worker_index] * 2;\n```", "```cpp\nstd::this_thread::sleep_for(std::chrono::milliseconds(timeout));\n```", "```cpp\nfor (int i = 0; i < 10; i++) {\n    data.emplace_back(i);\n}\n```", "```cpp\n std::thread worker1(worker, 1, 50);\n std::thread worker2(worker, 2, 20);\n```", "```cpp\n#include <atomic>\n#include <chrono>\n#include <iostream>\n#include <thread>\n#include <vector>\n\nstd::atomic<bool> running{true};\nstd::atomic<int> counter{0};\n```", "```cpp\nvoid worker() {\n while(running) {\n counter.fetch_add(1, std::memory_order_relaxed);\n }\n }\n```", "```cpp\nint main() {\n  std::thread worker1(worker);\n  std::thread worker2(worker);\n  std::this_thread::sleep_for(std::chrono::seconds(1));\n  running = false;\n  worker1.join();\n  worker2.join();\n  std::cout << \"Counter: \" << counter << std::endl;\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\nproject(memorder)\nadd_executable(memorder memorder.cpp)\n\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR arm)\n\nSET(CMAKE_CXX_FLAGS \"--std=c++11\")\ntarget_link_libraries(memorder pthread)\n\nset(CMAKE_CXX_COMPILER /usr/bin/arm-linux-gnueabi-g++)\n```", "```cpp\nstd::atomic<bool> running{true};\nstd::atomic<int> counter{0};\n```", "```cpp\ncounter.fetch_add(1, std::memory_order_relaxed);\n```", "```cpp\nstd::thread worker1(worker);\nstd::thread worker2(worker);\n```", "```cpp\nrunning = false;\n```", "```cpp\n#include <atomic>\n#include <iostream>\n\nstruct Node {\n  int data;\n  Node* next;\n};\n```", "```cpp\nclass Stack {\n  std::atomic<Node*> head;\n\n  public:\n    Stack() {\n    std::cout << \"Stack is \" <<\n    (head.is_lock_free() ? \"\" : \"not \")\n    << \"lock-free\" << std::endl;\n    }\n\n   void Push(int data) {\n      Node* new_node = new Node{data, nullptr};\n      new_node->next = head.load();\n      while(!std::atomic_compare_exchange_weak(\n                &head,\n                &new_node->next,\n                new_node));\n    }\n    };\n```", "```cpp\nint main() {\n  Stack s;\n  s.Push(1);\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\nproject(lockfree)\nadd_executable(lockfree lockfree.cpp)\n\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR arm)\n\nSET(CMAKE_CXX_FLAGS \"--std=c++11\")\ntarget_link_libraries(lockfree pthread)\n\nset(CMAKE_CXX_COMPILER /usr/bin/arm-linux-gnueabi-g++)\n```", "```cpp\nint data;\nNode* next;\n```", "```cpp\nstd::atomic<Node*> head;\n```", "```cpp\n(head.is_lock_free() ? \"\" : \"not \")\n```", "```cpp\n Node* new_node = new Node{data, nullptr};\n```", "```cpp\nnew_node->next = head.load();\n```", "```cpp\n      while(!std::atomic_compare_exchange_weak(\n                &head,\n                &new_node->next,\n                new_node));\n```", "```cpp\n#include <atomic>\n#include <iostream>\n#include <chrono>\n#include <thread>\n\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <unistd.h>\n\nconst char* kSharedMemPath = \"/sample_point\";\n```", "```cpp\ntemplate<class T>\nclass SharedMem {\n  int fd;\n  T* ptr;\n  const char* name;\n\n  public:\n```", "```cpp\n    SharedMem(const char* name, bool owner=false) {\n      fd = shm_open(name, O_RDWR | O_CREAT, 0600);\n      if (fd == -1) {\n        throw std::runtime_error(\"Failed to open a shared\n        memory region\");\n      }\n      if (ftruncate(fd, sizeof(T)) < 0) {\n        close(fd);\n        throw std::runtime_error(\"Failed to set size of a shared\n        memory region\");\n      };\n      ptr = (T*)mmap(nullptr, sizeof(T), PROT_READ | PROT_WRITE, \n      MAP_SHARED, fd, 0);\n      if (!ptr) {\n        close(fd);\n        throw std::runtime_error(\"Failed to mmap a shared memory\n        region\");\n      }\n      this->name = owner ? name : nullptr;\n      }\n```", "```cpp\n~SharedMem() {\nmunmap(ptr, sizeof(T));\nclose(fd);\nif (name) {\nstd::cout << \"Remove shared mem instance \" << name << std::endl;\nshm_unlink(name);\n}\n}\n\nT& get() const {\nreturn *ptr;\n}\n};\n```", "```cpp\nstruct Payload {\nstd::atomic_bool data_ready;\nstd::atomic_bool data_processed;\nint index;\n};\n```", "```cpp\nvoid producer() {\n  SharedMem<Payload> writer(kSharedMemPath);\n  Payload& pw = writer.get();\nif (!pw.data_ready.is_lock_free()) {\nthrow std::runtime_error(\"Flag is not lock-free\");\n  }\nfor (int i = 0; i < 10; i++) {\npw.data_processed.store(false);\npw.index = i;\n    pw.data_ready.store(true);\nwhile(!pw.data_processed.load());\n}\n}\n```", "```cpp\nvoid consumer() {\nSharedMem<Payload> point_reader(kSharedMemPath, true);\nPayload& pr = point_reader.get();\nif (!pr.data_ready.is_lock_free()) {\nthrow std::runtime_error(\"Flag is not lock-free\");\n}\nfor (int i = 0; i < 10; i++) {\n while(!pr.data_ready.load());\n    pr.data_ready.store(false);\nstd::cout << \"Processing data chunk \" << pr.index << std::endl;\n    pr.data_processed.store(true);\n}\n}\n```", "```cpp\nint main() {\n\nif (fork()) {\n    consumer();\n} else {\n    producer();\n}\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\nproject(shmatomic)\nadd_executable(shmatomic shmatomic.cpp)\n\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR arm)\n\nSET(CMAKE_CXX_FLAGS \"--std=c++11\")\ntarget_link_libraries(shmatomic pthread rt)\n\nset(CMAKE_CXX_COMPILER /usr/bin/arm-linux-gnueabi-g++)\n```", "```cpp\nstruct Payload {\n  std::atomic_bool data_ready;\n  std::atomic_bool data_processed;\n  int index;\n};\n```", "```cpp\nSharedMem<Payload> writer(kSharedMemPath);\n```", "```cpp\nif (!pw.data_ready.is_lock_free()) {\n    throw std::runtime_error(\"Flag is not lock-free\");\n}\n```", "```cpp\npw.index = i;\n```", "```cpp\npw.data_ready.store(true);\nwhile(!pw.data_processed.load());\n```", "```cpp\nSharedMem<Payload> point_reader(kSharedMemPath, true);\n```", "```cpp\nwhile(!pr.data_ready.load());\n```", "```cpp\npr.data_processed.store(true);\n```", "```cpp\n#include <chrono>\n#include <future>\n#include <iostream>\n\nint calculate (int x) {\n  auto start = std::chrono::system_clock::now();\n  std::cout << \"Start calculation\\n\";\n  std::this_thread::sleep_for(std::chrono::seconds(1));\n  auto delta = std::chrono::system_clock::now() - start;\n  auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(delta);\n  std::cout << \"Done in \" << ms.count() << \" ms\\n\";\n  return x*x;\n}\n```", "```cpp\nvoid test(int value, int worktime) {\n  std::cout << \"Request result of calculations for \" << value << std::endl;\n  std::future<int> fut = std::async (calculate, value);\n  std::cout << \"Keep working for \" << worktime << \" ms\" << std::endl;\n  std::this_thread::sleep_for(std::chrono::milliseconds(worktime));\n  auto start = std::chrono::system_clock::now();\n  std::cout << \"Waiting for result\" << std::endl;\n  int result = fut.get();\n  auto delta = std::chrono::system_clock::now() - start;\n  auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(delta);\n\n  std::cout << \"Result is \" << result\n            << \", waited for \" << ms.count() << \" ms\"\n            << std::endl << std::endl;\n}\n\n```", "```cpp\nint main ()\n{\n  test(5, 400);\n  test(8, 1200);\n  return 0;\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\nproject(async)\nadd_executable(async async.cpp)\n\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR arm)\n\nSET(CMAKE_CXX_FLAGS \"--std=c++14\")\ntarget_link_libraries(async pthread -static-libstdc++)\n\nset(CMAKE_CXX_COMPILER /usr/bin/arm-linux-gnueabi-g++)\n```", "```cpp\nstd::this_thread::sleep_for(std::chrono::seconds(1));\n```", "```cpp\nstd::future<int> fut = std::async (calculate, value);\n```", "```cpp\nint result = fut.get();\n```"]