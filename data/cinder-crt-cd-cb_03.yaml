- en: Chapter 3. Using Image Processing Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。使用图像处理技术
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Transforming image contrast and brightness
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整图像的对比度和亮度
- en: Integrating with OpenCV
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与OpenCV集成
- en: Detecting edges
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测边缘
- en: Detecting faces
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测面部
- en: Detecting features in image
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图像中检测特征
- en: Converting images to vector graphics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将图像转换为矢量图形
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'In this chapter, we will show examples of using image processing techniques
    implemented in Cinder and using third-party libraries. In most of the examples,
    we will use the following famous test image widely used to illustrate computer
    vision algorithms and techniques:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将展示使用Cinder中实现图像处理技术的示例，以及使用第三方库的示例。在大多数示例中，我们将使用以下著名的测试图像，该图像广泛用于说明计算机视觉算法和技术：
- en: '![Introduction](img/8703OS_03_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![简介](img/8703OS_03_01.jpg)'
- en: You can download Lenna's image from Wikipedia ([http://en.wikipedia.org/wiki/File:Lenna.png](http://en.wikipedia.org/wiki/File:Lenna.png)).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从维基百科下载Lenna的图像（[http://en.wikipedia.org/wiki/File:Lenna.png](http://en.wikipedia.org/wiki/File:Lenna.png)）。
- en: Transforming image contrast and brightness
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整图像的对比度和亮度
- en: In this recipe we will cover basic image color transformations using the `Surface`
    class for pixel manipulation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将介绍使用`Surface`类进行像素操作的基本图像颜色转换。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To change the values of contrast and brightness we will use `InterfaceGl` covered
    in [Chapter 2](ch02.html "Chapter 2. Preparing for Development"), *Preparing for
    Development in the Setting up GUI for parameters tweaking* recipe. We will need
    a sample image to proceed with; save it in your `assets` folder as `image.png`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改对比度和亮度的值，我们将使用[第2章](ch02.html "第2章。为开发做准备")中介绍的`InterfaceGl`，*在设置GUI以调整参数时做准备*配方。我们需要一个样本图像来继续操作；将其保存到您的`assets`文件夹中，命名为`image.png`。
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will create an application with simple GUI for contrast and brightness manipulation
    on the sample image. Perform the following steps to do so:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个具有简单GUI的应用程序，用于在样本图像上调整对比度和亮度。执行以下步骤：
- en: 'Include necessary headers:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含必要的头文件：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add properties to the main class:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向主类添加属性：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `setup` method an image is loaded for processing and the `Surface` object
    is prepared to store processed image:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法中，加载一张图像进行处理，并准备`Surface`对象以存储处理后的图像：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Set window size to default values:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置窗口大小为默认值：
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add parameter controls to the `InterfaceGl` window:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将参数控制添加到`InterfaceGl`窗口中：
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Implement the `update` method as follows:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式实现`update`方法：
- en: '[PRE5]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Lastly, we will draw the original and processed images by adding the following
    lines of code inside the `draw` method:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将在`draw`方法内部添加以下代码行来绘制原始图像和处理后的图像：
- en: '[PRE6]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: The most important part is inside the `update` method. In step 6 we checked
    if the parameters for contrast and brightness had been changed. If they have,
    we iterate through all the pixels of the original image and store recalculated
    color values in `mImageOutput`. While modifying the brightness is just increasing
    or decreasing each color component, calculating contrast is a little more complicated.
    For each color component we are using the multiplying formula, *color = (color
    - 0.5) * contrast + 0.5*, where contrast is a number between 0.5 and 2\. In the
    GUI we are setting a value between -0.5 and 1.0, which is more natural range;
    it is then recalculated at the beginning of step 6\. While processing the image
    we have to change color value of all pixels, so later in step 6, you can see that
    we iterate through later columns of each row of the pixels using two `while` loops.
    To move to the next row we invoked the `line` method on the `Surface` iterator
    and then the `pixel` method to move to the next pixel of the current row. This
    method is much faster than using, for example, the `getPixel` and `setPixel` methods.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的一部分在`update`方法中。在第6步中，我们检查对比度和亮度的参数是否已更改。如果已更改，我们将遍历原始图像的所有像素，并将重新计算的颜色值存储在`mImageOutput`中。调整亮度只是增加或减少每个颜色组件，而计算对比度则稍微复杂一些。对于每个颜色组件，我们使用乘法公式，*颜色
    = (颜色 - 0.5) * 对比度 + 0.5*，其中对比度是一个介于0.5和2之间的数字。在GUI中，我们设置一个介于-0.5和1.0之间的值，这是一个更自然的范围；然后在第6步的开始进行重新计算。在处理图像时，我们必须更改所有像素的颜色值，因此在第6步的后面，您可以看到我们使用两个`while`循环遍历每行的后续列。为了移动到下一行，我们在`Surface`迭代器上调用`line`方法，然后调用`pixel`方法来移动到当前行的下一个像素。这种方法比使用例如`getPixel`和`setPixel`方法要快得多。
- en: '![How it works...](img/8703OS_03_02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/8703OS_03_02.jpg)'
- en: Our application is rendering the original image on the left-hand side and the
    processed image on the right-hand side, so you can compare the results of color
    adjustment.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序在左侧渲染原始图像，在右侧渲染处理后的图像，因此你可以比较颜色调整的结果。
- en: Integrating with OpenCV
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与OpenCV集成
- en: OpenCV is a very powerful open-source library for computer vision. The library
    is written in C++ so it can be easily integrated in your Cinder application. There
    is a very useful OpenCV Cinder block provided within Cinder package available
    at the GitHub repository ([https://github.com/cinder/Cinder-OpenCV](https://github.com/cinder/Cinder-OpenCV)).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV是一个非常强大的开源计算机视觉库。该库是用C++编写的，因此可以轻松集成到你的Cinder应用程序中。Cinder包中提供了一个非常有用的OpenCV
    Cinder块，可在GitHub仓库中找到（[https://github.com/cinder/Cinder-OpenCV](https://github.com/cinder/Cinder-OpenCV)）。
- en: Getting ready
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you have Xcode up and running with a Cinder project opened.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 确保Xcode正在运行，并且已经打开了一个Cinder项目。
- en: How to do it…
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We will add OpenCV Cinder block to your project, which also illustrates the
    usual way of adding any other Cinder block to your project. Perform the following
    steps to do so:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向你的项目中添加OpenCV Cinder块，这同时也说明了将任何其他Cinder块添加到项目中的通常方法。执行以下步骤：
- en: Add a new group to our Xcode project root and name it `Blocks.` Next, drag the
    `opencv` folder inside the `Blocks` group. Be sure to select the **Create groups
    for any added folders** radio button, as shown in the following screenshot:![How
    to do it…](img/8703OS_03_03.jpg)
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的Xcode项目根目录中添加一个新的组，并将其命名为`Blocks`。然后，将`opencv`文件夹拖到`Blocks`组中。务必选择以下截图所示的**为添加的任何文件夹创建组**单选按钮：![如何操作…](img/8703OS_03_03.jpg)
- en: You will need only the `include` folder inside the `opencv` folder in your project
    structure, so delete any reference to others. The final project structure should
    look like the following screenshot:![How to do it…](img/8703OS_03_04.jpg)
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你只需要项目结构中`opencv`文件夹内的`include`文件夹，因此删除对其他文件夹的任何引用。最终的项目结构应如下截图所示：![如何操作…](img/8703OS_03_04.jpg)
- en: 'Add the paths to the OpenCV library files in the **Other Linker Flags** section
    of your project''s build settings, for example:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目构建设置的**其他链接器标志**部分添加OpenCV库文件的路径，例如：
- en: '[PRE7]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'These paths are shown in the following screenshot:'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些路径如下截图所示：
- en: '![How to do it…](img/8703OS_03_05.jpg)'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/8703OS_03_05.jpg)'
- en: 'Add the paths to the OpenCV Cinder block headers you are going to use in the
    **User Header Search Paths** section of your project''s build settings:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目构建设置的**用户头文件搜索路径**部分添加你将要使用的OpenCV Cinder块头文件的路径：
- en: '[PRE8]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This path is shown in the following screenshot:'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如下截图所示，这是该路径：
- en: '![How to do it…](img/8703OS_03_06.jpg)'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/8703OS_03_06.jpg)'
- en: 'Include OpenCV Cinder block header file:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含OpenCV Cinder块头文件：
- en: '[PRE9]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works…
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'OpenCV Cinder block provides the `toOcv` and `fromOcv` functions for data exchange
    between Cinder and OpenCV. After setting up your project you can use them, as
    shown in the following short example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV Cinder块提供了`toOcv`和`fromOcv`函数，用于Cinder和OpenCV之间的数据交换。在设置好项目后，你可以使用它们，如下面的简短示例所示：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can use the `toOcv` and `fromOcv` functions to convert between Cinder and
    OpenCV types, storing image data such as `Surface` or `Channel` handled through
    the `ImageSourceRef` type; there are also other types, as shown in the following
    table:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`toOcv`和`fromOcv`函数在Cinder和OpenCV类型之间进行转换，存储通过`ImageSourceRef`类型处理的图像数据，如`Surface`或`Channel`；还有其他类型，如下表所示：
- en: '| Cinder types | OpenCV types |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| Cinder类型 | OpenCV类型 |'
- en: '| --- | --- |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ImageSourceRef` | `Mat` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `ImageSourceRef` | `Mat` |'
- en: '| `Color` | `Scalar` |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `Color` | `Scalar` |'
- en: '| `Vec2f` | `Point2f` |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `Vec2f` | `Point2f` |'
- en: '| `Vec2i` | `Point` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `Vec2i` | `Point` |'
- en: '| `Area` | `Rect` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `Area` | `Rect` |'
- en: 'In this example we are linking against the following three files from the OpenCV
    package:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们链接了OpenCV包中的以下三个文件：
- en: '`libopencv_imgproc.a`: This image processing module includes image manipulation
    functions, filters, feature detection, and more'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libopencv_imgproc.a`：此图像处理模块包括图像操作函数、过滤器、特征检测等'
- en: '`libopencv_core.a`: This module provides core functionality and data structures'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libopencv_core.a`：此模块提供核心功能和数据结构'
- en: '`libopencv_objdetect.a`: This module has object detection tools such as cascade
    classifiers'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libopencv_objdetect.a`：此模块包含如级联分类器等目标检测工具'
- en: You can find the documentation on all OpenCV modules at [http://docs.opencv.org/index.html](http://docs.opencv.org/index.html).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://docs.opencv.org/index.html](http://docs.opencv.org/index.html)找到所有OpenCV模块的文档。
- en: There's more…
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: There are some features that are not available in precompiled OpenCV libraries
    packaged in OpenCV Cinder block, but you can always compile your own OpenCV libraries
    and still use exchange functions from OpenCV Cinder block in your project.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenCV Cinder块中打包的预编译OpenCV库中，有一些功能是不可用的，但你可以始终编译自己的OpenCV库，并在你的项目中仍然使用OpenCV
    Cinder块中的交换函数。
- en: Detecting edges
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测边缘
- en: In this recipe, we will demonstrate how to use edge detection function, which
    is one of the image processing functions implemented directly in Cinder.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将演示如何使用边缘检测函数，这是Cinder直接实现的一种图像处理函数。
- en: Getting ready
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you have Xcode up and running with an empty Cinder project opened.
    We will need a sample image to proceed, so save it in your assets folder as `image.png`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 确保Xcode正在运行，并且已经打开了一个空的Cinder项目。我们将需要一个示例图像来继续，所以将其保存到你的资源文件夹中，命名为`image.png`。
- en: How to do it…
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'We will process the sample image with the edge detection function. Perform
    the following steps to do so:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用边缘检测函数处理示例图像。执行以下步骤来完成此操作：
- en: 'Include necessary headers:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含必要的头文件：
- en: '[PRE11]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add two properties to your main class:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向你的主类添加两个属性：
- en: '[PRE12]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Load the source image and set up `Surface` for processed images inside the
    `setup` method:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法中加载源图像并设置处理图像的`Surface`：
- en: '[PRE13]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Use image processing functions:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用图像处理函数：
- en: '[PRE14]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Inside the `draw` method add the following two lines of code for drawing images:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`draw`方法内部添加以下两行代码以绘制图像：
- en: '[PRE15]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works…
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: As you can see, detecting edges in Cinder is pretty easy because of implementation
    of basic image processing functions directly in Cinder, so you don't have to include
    any third-party libraries. In this case we are using the `grayscale` function
    to convert the original image color space to grayscale. It is a commonly used
    feature in image processing because many algorithms work more efficiently on grayscale
    images or are even designed to work only with grayscale source images. The edge
    detection is implemented with the `edgeDetectSobel` function and uses the Sobel
    algorithm. In this case, the first parameter is the source original grayscale
    image and the second parameter, is the output `Surface` object in which the result
    will be stored.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，由于Cinder直接实现了基本的图像处理函数，因此在Cinder中检测边缘非常简单，因此您不需要包含任何第三方库。在这种情况下，我们使用`grayscale`函数将原始图像的颜色空间转换为灰度。这是图像处理中常用的功能，因为许多算法在灰度图像上运行得更有效率，或者甚至是为仅与灰度源图像一起工作而设计的。边缘检测是通过`edgeDetectSobel`函数实现的，并使用Sobel算法。在这种情况下，第一个参数是源原始灰度图像，第二个参数是输出`Surface`对象，结果将存储在其中。
- en: 'Inside the `draw` method we are drawing both images, as shown in the following
    screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在`draw`方法内部，我们绘制了两个图像，如下面的截图所示：
- en: '![How it works…](img/8703OS_03_07.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/8703OS_03_07.jpg)'
- en: There's more…
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: You may find the image processing functions implemented in Cinder insufficient,
    so you can also include to your project, third-party library such as OpenCV. We
    explained how we can use Cinder and OpenCV together in the preceding recipe, *Integrating
    with OpenCV*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现Cinder中实现的图像处理函数不足，因此你也可以将第三方库，如OpenCV，包含到你的项目中。我们在先前的菜谱中解释了如何将Cinder和OpenCV一起使用，*与OpenCV集成*。
- en: 'Other useful functions in the context of edge detection are `Canny` and `findContours`.
    The following is the example of how we can use them:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在边缘检测的上下文中，其他有用的函数是`Canny`和`findContours`。以下是如何使用它们的示例：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After executing the preceding code, the points, which form the contours are
    stored in the `contours` variable.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码后，形成轮廓的点存储在`contours`变量中。
- en: Detecting faces
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测人脸
- en: In this recipe, we will examine how our application can be used to recognize
    human faces. Thanks to the OpenCV library, it is really easy.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将检查我们的应用程序如何被用来识别人脸。多亏了OpenCV库，这真的非常简单。
- en: Getting ready
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be using the OpenCV library, so please refer to the *Integrating with
    OpenCV* recipe for information on how to set up your project. We will need a sample
    image to proceed, so save it in your `assets` folder as `image.png`. Put the Haar
    cascade classifier file for frontal face recognition inside the `assets` directory.
    The cascade file can be found inside the downloaded OpenCV package or in the online
    public repository, located at [https://github.com/Itseez/opencv/blob/master/data/haarcascades/haarcascade_frontalface_alt.xml](https://github.com/Itseez/opencv/blob/master/data/haarcascades/haarcascade_frontalface_alt.xml).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用OpenCV库，因此请参阅*与OpenCV集成*配方以获取有关如何设置项目的信息。我们将需要一个示例图像来继续，所以将其保存到您的`assets`文件夹中作为`image.png`。将用于正面人脸识别的Haar级联分类器文件放入`assets`目录中。级联文件可以在下载的OpenCV包中找到，或者在位于[https://github.com/Itseez/opencv/blob/master/data/haarcascades/haarcascade_frontalface_alt.xml](https://github.com/Itseez/opencv/blob/master/data/haarcascades/haarcascade_frontalface_alt.xml)的在线公共存储库中找到。
- en: How to do it…
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We will create an application that demonstrates the usage of cascade classifier
    from OpenCV with Cinder. Perform the following steps to do so:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个应用程序，演示如何使用Cinder与OpenCV的级联分类器。执行以下步骤：
- en: 'Include necessary headers:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含必要的头文件：
- en: '[PRE17]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add the following members to your main class:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下成员添加到您的主类中：
- en: '[PRE18]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add the following code snippet to the `setup` method:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码片段添加到`setup`方法中：
- en: '[PRE19]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Also add the following code snippet at the end of the `setup` method:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还需要在`setup`方法的末尾添加以下代码片段：
- en: '[PRE20]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'At the end of the `draw` method add the following code snippet:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`draw`方法的末尾添加以下代码片段：
- en: '[PRE21]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works…
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In step 3 we loaded an image file for processing and an XML classifier file,
    which has description of the object features to be recognized. In step 4 we performed
    an image detection by invoking the `detectMultiScale` function on the `mFaceCC`
    object, where we pointed to `cvImage` as an input and stored the result in a vector
    structure, `cvImage` is converted from `mImage` as an 8-bit, single channel image
    (`CV_8UC1`). What we did next was iterating through all the detected faces and
    storing `Rectf` variable, which describes a bounding box around the detected face.
    Finally, in step 5 we drew our original image and all the recognized faces as
    stroked rectangles.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3步中，我们加载了一个图像文件用于处理和一个XML分类器文件，该文件描述了要识别的对象特征。在第4步中，我们通过在`mFaceCC`对象上调用`detectMultiScale`函数执行图像检测，我们将`cvImage`作为输入指向，并将结果存储在一个向量结构中，`cvImage`是从`mImage`转换而来的8位单通道图像（`CV_8UC1`）。我们接下来所做的是遍历所有检测到的人脸并存储`Rectf`变量，该变量描述了检测到的人脸周围的边界框。最后，在第5步中，我们绘制了原始图像和所有识别到的人脸作为描边的矩形。
- en: We are using cascade classifier implemented in OpenCV, which can be trained
    to detect a specific object in the image. More on training and using cascade classifier
    for object detection can be found in the OpenCV documentation, located at [http://docs.opencv.org/modules/objdetect/doc/cascade_classification.html](http://docs.opencv.org/modules/objdetect/doc/cascade_classification.html).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的是OpenCV中实现的级联分类器，它可以训练来检测图像中的特定对象。有关训练和使用级联分类器进行对象检测的更多信息，请参阅位于[http://docs.opencv.org/modules/objdetect/doc/cascade_classification.html](http://docs.opencv.org/modules/objdetect/doc/cascade_classification.html)的OpenCV文档。
- en: '![How it works…](img/8703OS_03_08.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/8703OS_03_08.jpg)'
- en: There's more…
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: You can use a video stream from your camera and process each frame to track
    faces of people in real time. Please refer to the *Capturing from the camera*
    recipe in [Chapter 11](ch11.html "Chapter 11. Sensing and Tracking Input from
    the Camera"), *Sensing and Tracking Input from the Camera*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用来自相机的视频流并处理每一帧以实时跟踪人脸。请参阅[第11章](ch11.html "第11章。从相机获取感应和跟踪输入")中的*从相机捕获*配方，*从相机获取感应和跟踪输入*。
- en: Detecting features in an image
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在图像中检测特征
- en: In this recipe we will use one of the methods of finding characteristic features
    in the image. We will use the SURF algorithm implemented by the OpenCV library.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用图像中查找特征特征的方法之一。我们将使用OpenCV库实现的SURF算法。
- en: Getting ready
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be using the OpenCV library, so please refer to the *Integrating with
    OpenCV* recipe for information on how to set up your project. We will need a sample
    image to proceed, so save it in your `assets` folder as `image.png`, then save
    a copy of the sample image as `image2.png` and perform some transformation on
    it, for example rotation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用OpenCV库，因此请参考*与OpenCV集成*菜谱，了解如何设置您的项目。我们将需要一个样本图像来继续，所以将其保存到您的`assets`文件夹中，命名为`image.png`，然后保存样本图像的副本为`image2.png`，并对它进行一些变换，例如旋转。
- en: How to do it…
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'We will create an application that visualizes matched features between two
    images. Perform the following steps to do so:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个应用程序，用于可视化两张图像之间的匹配特征。执行以下步骤来完成此操作：
- en: 'Add the paths to the OpenCV library files in the **Other Linker Flags** section
    of your project''s build settings, for example:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您项目的构建设置中**其他链接器标志**部分添加OpenCV库文件的路径，例如：
- en: '[PRE22]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Include necessary headers:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含必要的标题：
- en: '[PRE23]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In your main class declaration add the method and properties:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的主类声明中添加方法和属性：
- en: '[PRE24]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Inside the `setup` method load the images and invoke the matching method:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法中加载图像并调用匹配方法：
- en: '[PRE25]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now you have to implement previously declared `matchImages` method:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您必须实现之前声明的`matchImages`方法：
- en: '[PRE26]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The last thing is to visualize the matches, so put the following line of code
    inside the `draw` method:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要可视化匹配，所以将以下代码行放在`draw`方法中：
- en: '[PRE27]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works…
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'Let''s discuss the code under step 5\. First we are converting `image1` and
    `image2` to an OpenCV Mat structure. Then we are converting both images to grayscale.
    Now we can start processing images with SURF, so we are detecting keypoints –
    the characteristic points of the image calculated by this algorithm. We can use
    calculated keypoints from these two images and match them using FLANN, or more
    precisely the `FlannBasedMatcher` class. After filtering out the proper matches
    and storing them in the `good_matches` vector we can visualize them, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论第5步下的代码。首先，我们将`image1`和`image2`转换为OpenCV Mat结构。然后，我们将这两张图像转换为灰度图。现在我们可以开始使用SURF处理图像了，因此我们正在检测关键点——该算法计算出的图像的特征点。我们可以使用这两个图像计算出的关键点，并使用FLANN进行匹配，或者更确切地说，使用`FlannBasedMatcher`类。在过滤掉适当的匹配并将它们存储在`good_matches`向量中后，我们可以按以下方式可视化它们：
- en: '![How it works…](img/8703OS_03_09.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/8703OS_03_09.jpg)'
- en: Please notice that second image is rotated, however the algorithm can still
    find and link the corresponding keypoints.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第二张图像已旋转，然而算法仍然可以找到并链接相应的关键点。
- en: There's more…
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: Detecting characteristic features in the images is crucial for matching pictures
    and is part of more advanced algorithms used in augmented reality applications.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在图像中检测特征对于匹配图片至关重要，也是用于增强现实应用中的更高级算法的一部分。
- en: If images match
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如果图像匹配
- en: It is possible to determine if one of the images is a copy of another or is
    it rotated. You can use a number of matches returned by the `matchImages` method.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能确定一张图像是否是另一张图像的副本，或者是否已旋转。您可以使用`matchImages`方法返回的匹配数量。
- en: Other possibilities
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他可能性
- en: SURF is rather a slow algorithm for real-time matching so you can try the FAST
    algorithm for your project if you need to process frames from the camera at real
    time. The FAST algorithm is also included in the OpenCV library.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: SURF算法对于实时匹配来说相当慢，所以如果您需要实时处理来自摄像机的帧，可以尝试您项目的FAST算法。FAST算法也包含在OpenCV库中。
- en: See also
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The comparison of the OpenCV's feature detection algorithms can be found at
    [http://computer-vision-talks.com/2011/01/comparison-of-the-opencvs-feature-detection-algorithms-2/](http://computer-vision-talks.com/2011/01/comparison-of-the-opencvs-feature-detection-algorithms-2/)
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenCV的特征检测算法比较可以在[http://computer-vision-talks.com/2011/01/comparison-of-the-opencvs-feature-detection-algorithms-2/](http://computer-vision-talks.com/2011/01/comparison-of-the-opencvs-feature-detection-algorithms-2/)找到。
- en: Converting images to vector graphics
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将图像转换为矢量图形
- en: In this recipe, we will try to convert simple, hand-drawn sketches to vector
    graphics using image processing functions from the OpenCV library and Cairo library
    for vector drawing and exporting.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将尝试使用OpenCV库和Cairo库的矢量绘图和导出功能，将简单的手绘草图转换为矢量图形。
- en: Getting started
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门
- en: We will be using the OpenCV library, so please refer to the *Integrating with
    OpenCV* recipe earlier in this chapter for information on how to set up your project.
    You may want to prepare your own drawing to be processed. In this example we are
    using a photo of some simple geometric shapes sketched on paper.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 OpenCV 库，因此请参考本章前面的 *与 OpenCV 集成* 菜谱，获取有关如何设置你的项目的信息。你可能想准备自己的绘图以便处理。在这个例子中，我们使用了一张在纸上绘制的简单几何形状的照片。
- en: '![Getting started](img/8703OS_03_10.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![入门](img/8703OS_03_10.jpg)'
- en: How to do it…
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'We will create an application to illustrate the conversion to vector shapes.
    Perform the following steps to do so:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个应用程序来展示矢量形状的转换。执行以下步骤：
- en: 'Include necessary headers:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含必要的头文件：
- en: '[PRE28]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add the following declarations to your main class:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主类中添加以下声明：
- en: '[PRE29]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Load your drawing and set default values inside the `setup` method:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `setup` 方法中加载你的绘图并设置默认值：
- en: '[PRE30]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'At the end of the `setup` method add the following code snippet:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `setup` 方法的末尾添加以下代码片段：
- en: '[PRE31]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add implementation for the `renderDrawing` method:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `renderDrawing` 方法的实现：
- en: '[PRE32]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Implement your `draw` method as follows:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式实现你的 `draw` 方法：
- en: '[PRE33]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Inside the `keyDown` method insert the following code snippet:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `keyDown` 方法中插入以下代码片段：
- en: '[PRE34]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works…
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The key part is implemented in step 4 where we are detecting edges in the image
    and then finding contours. We are drawing vector representation of processed shapes
    in step 5, inside the `renderDrawing` method. For drawing vector graphics we are
    using the Cairo library, which is also able to save results into a file in several
    vector formats. As you can see in the following screenshot, there is an original
    image in the upper-left corner and just under it is the preview of the detected
    contours. The vector version of our simple hand-drawn image is on the right-hand
    side:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 关键部分在步骤 4 中实现，我们在图像中检测边缘然后找到轮廓。我们在 `renderDrawing` 方法中步骤 5 内绘制处理形状的矢量表示。为了绘制矢量图形，我们使用
    Cairo 库，它还能将结果保存为多种矢量格式。如图所示，在屏幕左上角是原始图像，其下方是检测到的轮廓预览。我们简单手绘图像的矢量版本在右侧：
- en: '![How it works…](img/8703OS_03_11.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/8703OS_03_11.jpg)'
- en: 'Each shape is a filled path with black color. Paths consist of points calculated
    in step 4\. The following is the visualization with highlighted points:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 每个形状都是一个黑色填充路径。路径由步骤 4 中计算出的点组成。以下是对突出显示的点的可视化：
- en: '![How it works…](img/8703OS_03_12.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/8703OS_03_12.jpg)'
- en: 'You can save a vector graphic as a file by pressing the *S* key. The file will
    be saved in the same folder as application executable under the name `output.svg`.
    SVG is only one of the following available exporting options:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过按 *S* 键将矢量图形保存为文件。文件将保存在应用程序可执行文件相同的文件夹下，命名为 `output.svg`。SVG 只是以下可用导出选项之一：
- en: '| Method | Usage |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 用法 |'
- en: '| --- | --- |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `SurfaceSvg` | Preparing context for SVG file rendering |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `SurfaceSvg` | 准备 SVG 文件渲染的上下文 |'
- en: '| `SurfacePdf` | Preparing context for PDF file rendering |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `SurfacePdf` | 准备 PDF 文件渲染的上下文 |'
- en: '| `SurfacePs` | Preparing context for PostScript file rendering |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `SurfacePs` | 准备 PostScript 文件渲染的上下文 |'
- en: '| `SurfaceEps` | Preparing context for Illustrator EPS file rendering |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `SurfaceEps` | 准备 Illustrator EPS 文件渲染的上下文 |'
- en: 'The exported graphics look as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 导出的图形如下所示：
- en: '![How it works…](img/8703OS_03_13.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/8703OS_03_13.jpg)'
- en: See also
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '**Cairo**: [http://cairographics.org/](http://cairographics.org/)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cairo**: [http://cairographics.org/](http://cairographics.org/)'
