- en: Deep Dive into Lambdas
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解Lambda
- en: Congratulations! You've just mastered the power of pure functions! It's now
    time to move on to the next level—pure functions on steroids, or the legendary
    lambdas. They've been around for longer than objects, they have a mathematical
    theory around them (if you like that sort of thing), and they're very powerful,
    as we'll discover in this chapter and the next.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚掌握了纯函数的力量！现在是时候进入下一个级别——纯函数的超级版本，或者传说中的lambda。它们存在的时间比对象更长，它们有一个围绕它们的数学理论（如果你喜欢这种东西的话），并且它们非常强大，正如我们将在本章和下一章中发现的那样。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the concept and history of lambdas
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解lambda的概念和历史
- en: How to write lambdas in C++
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在C++中编写lambda
- en: How pure functions compare to lambdas
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯函数与lambda的比较
- en: How to use lambdas with classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在类中使用lambda
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need a C++ compiler that supports C++ 17\. The code can be found in
    the GitHub repository ([https://github.com/PacktPublishing/Hands-On-Functional-Programming-with-Cpp](https://github.com/PacktPublishing/Hands-On-Functional-Programming-with-Cpp))
    in the `Chapter03` folder. A `makefile` file is provided to make it easier for
    you to compile and run the code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要一个支持C++ 17的C++编译器。代码可以在GitHub存储库（[https://github.com/PacktPublishing/Hands-On-Functional-Programming-with-Cpp](https://github.com/PacktPublishing/Hands-On-Functional-Programming-with-Cpp)）的`Chapter03`文件夹中找到。提供了一个`makefile`文件，以便您更轻松地编译和运行代码。
- en: What is a lambda?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是lambda？
- en: The year was 1936\. A 33-year old mathematician, Alonzo Church, published his
    research on the foundations of mathematics. In doing so, he created the so-called
    **lambda calculus**, which was a model for the recently created field of computation.
    In collaboration with Alan Turing, he would then go on to prove that the lambda
    calculus is equivalent to a Turing machine. The relevance of this discovery is
    fundamental to programming—it means that we can write any program for a modern
    computer by using lambdas and by taking advantage of lambda calculus. That explains
    why it's called **lambda**—mathematicians have long preferred single Greek letters
    for every notation. But what exactly is it?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那年是1936年。33岁的数学家阿隆佐·邱奇发表了他关于数学基础的研究。在这样做的过程中，他创造了所谓的**lambda演算**，这是最近创建的计算领域的模型。在与艾伦·图灵合作后，他随后证明了lambda演算等价于图灵机。这一发现的相关性对编程至关重要——这意味着我们可以通过使用lambda和利用lambda演算来为现代计算机编写任何程序。这就解释了为什么它被称为**lambda**——数学家们长期以来更喜欢用单个希腊字母来表示每个符号。但它到底是什么？
- en: 'If you ignore all the mathematical notations, a lambda is just a **pure function**
    that can be applied to variables or values. Let''s take a look at an example.
    We will learn how to write lambdas in C++, but, for now, I will use the Groovy
    syntax since it''s the simplest syntax that I know:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忽略所有的数学符号，lambda只是一个可以应用于变量或值的**纯函数**。让我们看一个例子。我们将学习如何在C++中编写lambda，但是现在我将使用Groovy语法，因为这是我知道的最简单的语法：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`add` is a lambda. As you can see, it''s a function that has two parameters
    and returns their sum. Since Groovy has optional types, I don''t have to specify
    the type of the argument. Additionally, I don''t need to use a `return` statement
    to return the sum; it will automatically return the value of the last statement.
    In C++, we can''t skip types or the `return` statements, as we''ll discover in
    the next section.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`是一个lambda。正如你所看到的，它是一个具有两个参数并返回它们的和的函数。由于Groovy具有可选类型，我不必指定参数的类型。此外，我不需要使用`return`语句来返回总和；它将自动返回最后一个语句的值。在C++中，我们不能跳过类型或`return`语句，我们将在下一节中发现。'
- en: 'For now, let''s take a look at another property of a lambda, that is, the ability
    to capture values from the context:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下lambda的另一个属性，即从上下文中捕获值的能力：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, `first` is not a parameter to the function, but a variable
    defined in the context. The lambda *captures* the value of the variable and uses
    it inside its body. We can use this property of lambdas to simplify the code or
    to gradually refactor toward immutability.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`first`不是函数的参数，而是在上下文中定义的变量。lambda *捕获*变量的值并在其主体内使用它。我们可以利用lambda的这个属性来简化代码或逐渐重构向不可变性。
- en: We'll explore how to use lambdas in future chapters; for now, let's demonstrate
    how to write them in C++, how to ensure they are immutable, and how to capture
    values from the context.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在未来的章节中探讨如何使用lambda；现在，让我们演示如何在C++中编写它们，如何确保它们是不可变的，以及如何从上下文中捕获值。
- en: Lambdas in C++
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++中的lambda
- en: 'We explored how to write lambdas in Groovy. So, can we use their power in C++?
    Well, since C++ 11, a specific syntax was introduced. Let''s take a look at how
    our `add` lambda would look in C++:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了如何在Groovy中编写lambda。那么，我们可以在C++中使用它们的功能吗？自C++ 11以来，引入了特定的语法。让我们看看我们的`add`
    lambda在C++中会是什么样子：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s unpack the syntax as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式解释语法：
- en: Our lambda starts with `[]`. This block specifies the variables we capture from
    the context, and we'll see how to use it in a moment. Since we don't capture anything,
    the block is empty.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的lambda以`[]`开始。这个块指定了我们从上下文中捕获的变量，我们将看到如何在一会儿使用它。由于我们没有捕获任何东西，这个块是空的。
- en: Next, we have the parameter list, `(int first, int second)`, as in any other
    C++ function.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们有参数列表，`(int first, int second)`，就像任何其他C++函数一样。
- en: Finally, we write the body of the lambda, using a return statement: `{ return
    first + second; }`.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们编写lambda的主体，使用return语句：`{ return first + second; }`。
- en: The syntax has a bit more ceremony than in Groovy, but it feels like C++ and
    that's a good thing; uniformity helps us to remember things.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 语法比Groovy有点更加正式，但感觉像C++，这是一件好事；统一性有助于我们记住事情。
- en: 'Alternatively, we can use the arrow syntax, as shown in the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用箭头语法，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The arrow syntax is a staple of lambdas since Alonzo Church used the notation
    in his lambda calculus. In addition to this, C++ requires the return type specification
    before the lambda body, which may provide clarity in situations where type casts
    are involved.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头语法是lambda的标志，自从Alonzo Church在他的lambda演算中使用这种符号以来。除此之外，C++要求在lambda主体之前指定返回类型，这可能在涉及类型转换的情况下提供了清晰度。
- en: Due to its history, the arrow syntax is present, in one way or another, in all
    functional programming languages. It's rarely useful in C++; however, it's useful
    to know if you want to get used to functional programming in general.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于历史原因，箭头语法以某种方式存在于所有函数式编程语言中。在C++中很少有用，但是如果你想要习惯函数式编程，了解它是很有用的。
- en: It's now time to explore how to capture variables from the context. As we mentioned
    previously, it's all in the `[]` block.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候探索如何从上下文中捕获变量了。正如我们之前提到的，这都在`[]`块中。
- en: Capturing variables
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获变量
- en: 'So, what if we wanted to capture the variable? In Groovy, we just used the
    variable inside the lambda scope. This won''t work in C++, because we need to
    specify what variables we are capturing and how we are capturing them. So, if
    we just use the `first` variable inside our `add` lambda, we will get a compilation
    error as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们想要捕获变量呢？在Groovy中，我们只需在lambda范围内使用变量。这在C++中行不通，因为我们需要指定我们要捕获的变量以及捕获它们的方式。因此，如果我们只在`add`
    lambda中使用`first`变量，我们将得到以下编译错误：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In order to capture variables in C++, we need to use a capture specifier inside
    the `[]` block. There are multiple ways of doing this, depending on what you want.
    The most intuitive way is to write the name of the variable we''re capturing directly.
    In our case, since we are trying to capture the first variable, we just need to
    add `[first]` before the lambda parameters:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在C++中捕获变量，我们需要在`[]`块内使用捕获说明符。有多种方法可以做到这一点，具体取决于你的需求。最直观的方法是直接写出我们要捕获的变量的名称。在我们的情况下，由于我们要捕获第一个变量，我们只需要在lambda参数前添加`[first]`：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we will see, this means that the `first` variable is captured by a value.
    Since C++ gives a lot of control to programmers, we expect it to provide specific
    syntax for capturing variables by reference. Now, let's explore the capture syntax
    in more details.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，这意味着`first`变量是按值捕获的。由于C++给程序员提供了很多控制权，我们期望它提供特定的语法来按引用捕获变量。现在，让我们更详细地探讨捕获语法。
- en: Capturing variables by value and by reference
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按值和按引用捕获变量
- en: 'We know that the specifier for capturing a variable by value is just writing
    the name of the variable, that is, `[first]`. This means that the variable is
    copied, so we''re wasting a few bytes of memory. The solution is to capture the
    variable by reference. The syntax for the capture specifier is very intuitive—we
    can just use the name of the variable as a `[&first]` reference:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道按值捕获变量的说明符只是写变量的名称，即`[first]`。这意味着变量被复制，因此我们浪费了一些内存。解决方案是通过引用捕获变量。捕获说明符的语法非常直观——我们可以将变量名作为`[&first]`引用：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'I know what you''re thinking: can the lambda now modify the value of the `first`
    variable since it''s passed by reference? Spoiler alert—yes, it can. We''ll revisit
    immutability, pure functions, and lambdas in the next section. For now, there''s
    more syntax to learn. For example, if we want to capture multiple variables from
    the context, do we have to write them all in the capture specifier? As it turns
    out, there are shortcuts to help you avoid this.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你在想什么：lambda现在可以修改`first`变量的值吗，因为它是按引用传递的？剧透警告——是的，它可以。我们将在下一节重新讨论不可变性、纯函数和lambda。现在，还有更多的语法要学习。例如，如果我们想要从上下文中捕获多个变量，我们是否必须在捕获说明符中写出它们所有？事实证明，有一些快捷方式可以帮助你避免这种情况。
- en: Capturing multiple values
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获多个值
- en: 'So, what if we want to capture multiple values? Let''s explore what our lambda
    would look like if we added five captured values:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们想要捕获多个值呢？让我们探索一下如果我们添加了五个捕获的值，我们的lambda会是什么样子：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Our current syntax is a bit redundant, isn''t it? We could use a default capture
    specifier instead. Fortunately, the language designers thought the same way; notice
    the `[&]` syntax before the lambda parameters:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的语法有点多余，不是吗？我们可以使用默认捕获说明符。幸运的是，语言设计者也是这么想的；注意lambda参数前的`[&]`语法：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `[&]` syntax is telling the compiler to capture all the specified variables
    from the context by reference. This is the *default capture by reference* specifier.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`[&]`语法告诉编译器从上下文中引用所有指定的变量。这是*默认按引用捕获*说明符。'
- en: 'If we want to copy their values instead, we need to use the *default capture
    by value* specifier, which you''ll have to remember because this is the only place
    where it''s used like this. Notice the `[=]` syntax before the lambda parameters:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要复制它们的值，我们需要使用*默认按值捕获*说明符，你需要记住这是唯一使用这种方式的地方。注意lambda参数前的`[=]`语法：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `[=]` syntax tells the compiler that all the variables will be captured
    by copying their values. At least, this is the default. If, for some reason, you''d
    like all variables except `first` to be passed by value, then you just combine
    the default with a variable specifier:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`[=]`语法告诉编译器所有变量都将通过复制它们的值来捕获。至少，默认情况下是这样。如果出于某种原因，你想要除了`first`之外的所有变量都通过值传递，那么你只需将默认与变量说明符结合起来：'
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We know now how to capture variables by value and by reference, and how to use
    default specifiers. This leaves us with one important type of variable—pointers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道了如何按值和按引用捕获变量，以及如何使用默认说明符。这使我们留下了一个重要类型的变量——指针。
- en: Capturing pointer values
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获指针值
- en: 'Pointers are just simple values. If we want to capture a pointer variable by
    value, we could just write its name, as shown in the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 指针只是简单的值。如果我们想要按值捕获指针变量，我们可以像下面的代码中那样写它的名称：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we want to capture the pointer variable by reference, the capture syntax
    is the same as for capturing any other type of variable:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要按引用捕获指针变量，捕获语法与捕获任何其他类型的变量相同：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The default specifiers work exactly as you''d expect; that is, `[=]` captures
    pointer variables by value:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的限定符的工作方式正如你所期望的那样；也就是说，`[=]`通过值来捕获指针变量：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In comparison, `[&]` captures pointer variables by reference, as shown in the
    following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`[&]`通过引用来捕获指针变量，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We'll explore what effects capturing variables by reference can have on immutability.
    But first, since there are multiple ways of capturing variables for a lambda,
    we need to check which one we prefer and when to use each of them.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨通过引用捕获变量对不可变性可能产生的影响。但首先，由于有多种捕获lambda变量的方式，我们需要检查我们更喜欢哪一种，以及何时使用它们。
- en: What capture should we use?
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们应该使用什么捕获？
- en: 'We''ve seen a few options for capturing values, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一些捕获值的选项，如下所示：
- en: Name the variable to capture it by value; for example, `[aVariable]`
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名变量以通过值来捕获它；例如，`[aVariable]`
- en: Name the variable and precede it with the reference specifier to capture it
    by reference; for example, `[&aVariable]`
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名变量并在前面加上引用限定符以通过引用来捕获它；例如，`[&aVariable]`
- en: Use the default value specifier to capture all the used variables by value;
    the syntax is `[=]`
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用默认值限定符通过值来捕获所有使用的变量；语法是`[=]`
- en: Use the default reference specifier to capture all the used variables by reference;
    the syntax is `[&]`
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用默认引用限定符通过引用来捕获所有使用的变量；语法是`[&]`
- en: In practice, I find that using the default value specifier is the best version
    for most situations. This is probably influenced by my preference for very small
    lambdas that don't mutate their captured values. I believe that simplicity is
    very important; when you have multiple options, it's very easy to make the syntax
    more complex than necessary. Think through each context and use the simplest syntax
    that works; my advice is to start from `[=]` and to only change it if required.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我发现使用默认值限定符是大多数情况下最好的版本。这可能受到我偏好不改变捕获值的非常小的lambda的影响。我相信简单性非常重要；当你有多个选项时，很容易使语法比必要的更复杂。仔细考虑每个上下文，并使用最简单的语法；我的建议是从`[=]`开始，只有在需要时才进行更改。
- en: We've explored how to write lambdas in C++. What we haven't mentioned is how
    they are implemented. The current standard implements lambdas as a C++ object
    with an unknown type, created on the stack. Like any C++ object, it has a class
    behind it, with a constructor, a destructor, and the captured variables stored
    as data members. We can pass a lambda to a `function<>` object, in which case
    the `function<>` object will store a copy of the lambda. Moreover, *lambdas use
    lazy evaluation*, unlike `function<>` objects.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了如何在C++中编写lambda。我们还没有提到它们是如何实现的。当前的标准将lambda实现为一个在堆栈上创建的具有未知类型的C++对象。就像任何C++对象一样，它背后有一个类，有一个构造函数，一个析构函数，以及捕获的变量作为数据成员存储。我们可以将lambda传递给`function<>`对象，这样`function<>`对象将存储lambda的副本。此外，*lambda使用延迟评估*，不同于`function<>`对象。
- en: Lambdas appear to be an easier way to write pure functions; so, what's the relationship
    between lambdas and pure functions?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda似乎是编写纯函数的一种更简单的方法；那么，lambda和纯函数之间的关系是什么？
- en: Lambdas and pure functions
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda和纯函数
- en: 'We learned in [Chapter 2](79295589-e861-4722-96a5-d131b429aac0.xhtml), *Understanding
    Pure Functions*, that pure functions have three characteristics:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](79295589-e861-4722-96a5-d131b429aac0.xhtml)中学到，纯函数具有三个特征：
- en: They always return the same values for the same argument values
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们总是对相同的参数值返回相同的值
- en: They don't have side effects
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们没有副作用
- en: They don't change the values of their parameters
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不改变其参数的值
- en: We also discovered that we need to pay attention to immutability when writing
    pure functions. This is easy, as long as we remember where to place the `const`
    keyword.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还发现在编写纯函数时需要注意不可变性。只要我们记得在哪里放置`const`关键字，这很容易。
- en: So, how do lambdas deal with immutability? Do we have to do anything special
    or do they just work?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，lambda如何处理不可变性？我们需要做一些特殊的事情吗，还是它们只是工作？
- en: Lambda immutability and pass by value arguments
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda的不可变性和通过值传递的参数
- en: 'Let''s start with a very simple lambda, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个非常简单的lambda开始，如下所示：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we''re passing the argument by value, so we don''t expect any change
    in the value after calling the lambda:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过值传递参数，所以我们在调用lambda后不希望值发生任何改变：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Since we copy the value, we''re probably using a few extra bytes of memory
    and an additional assignment. We can add a `const` keyword to make things clearer:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们复制了值，我们可能使用了一些额外的内存字节和额外的赋值。我们可以添加一个`const`关键字来使事情更清晰：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Due to the `const` specifier, the compiler will give an error if the lambda
    tries to change `value`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`const`限定符，如果lambda尝试改变`value`，编译器将会报错。
- en: But we're still passing the argument by value; how about passing by reference?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们仍然通过值传递参数；那么通过引用传递呢？
- en: Lambda immutability and pass by reference arguments
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda的不可变性和通过引用传递的参数
- en: 'Let''s explore the effect on the input parameter when we call this lambda:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨当我们调用这个lambda时对输入参数的影响：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As it turns out, it''s relatively close to what you''d expect:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，这与你所期望的相当接近：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, the lambda changes the value of the argument. That''s not good enough,
    so let''s make it immutable, as shown in the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，lambda改变了参数的值。这还不够好，所以让我们使其不可变，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Once again, the compiler will help us with an error message if the lambda tries
    to change `value`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会再次通过错误消息帮助我们，如果lambda尝试改变`value`。
- en: Well, that's better; but what about pointers?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，这样更好了；但指针呢？
- en: Lambda immutability and pointer arguments
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda的不可变性和指针参数
- en: 'Just like we saw in [Chapter 2](79295589-e861-4722-96a5-d131b429aac0.xhtml),
    *Understanding Pure Functions*, there are two questions regarding pointer arguments,
    as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在[第2章](79295589-e861-4722-96a5-d131b429aac0.xhtml)中看到的那样，关于指针参数有两个问题，如下所示：
- en: Can the lambda change the pointer address?
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lambda能改变指针地址吗？
- en: Can the lambda change the pointed value?
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lambda能改变指向的值吗？
- en: 'Once again, if we pass in the pointer by value, there''s no change in the address:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果我们按值传递指针，地址不会改变：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Passing the pointer by reference changes that though:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引用传递指针会改变这一点：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'So, once again, we need to use a well-placed `const` keyword to protect ourselves
    from this change:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要再次使用适当的`const`关键字来保护自己免受这种变化的影响：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s also make the value immutable. As expected, we need another `const` keyword:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也使值不可变。如预期的那样，我们需要另一个`const`关键字：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: While this works, I suggest that you favor a simpler way to pass the `[](const
    int& value)` value—that is, just dereference the pointer and pass an actual value
    to the lambda, which will make the parameter syntax easier to understand and more
    reusable.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样可以工作，但我建议您更倾向于使用更简单的方式传递`[](const int& value)`值，也就是说，只需对指针进行解引用并将实际值传递给lambda表达式，这将使参数语法更容易理解和更可重用。
- en: So, no surprises! We can use the same syntax we use for pure functions to ensure
    immutability.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，毫不意外！我们可以使用与纯函数相同的语法来确保不可变性。
- en: But can lambdas call mutable functions, such as I/O, for example?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 但是lambda表达式能调用可变函数吗，比如I/O呢？
- en: Lambdas and I/O
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda表达式和I/O
- en: 'What better way to test lambdas and I/O than the `Hello, world` program:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 测试lambda表达式和I/O的更好方法是`Hello, world`程序：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Obviously, lambdas aren't protected from calling mutable functions. This is
    no surprise, given that we learned the same thing about pure functions. This means
    that, similar to pure functions, programmers need to pay extra attention to separate
    I/O, which is fundamentally mutable, from the rest of the code, which can be immutable.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，lambda表达式无法防止调用可变函数。这并不奇怪，因为我们对纯函数也学到了同样的事情。这意味着，类似于纯函数，程序员需要特别注意将I/O与其余可能是不可变的代码分开。
- en: Since we're trying to get the compiler to help us with enforcing immutability,
    can we do that for captured values?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们试图让编译器帮助我们强制实施不可变性，我们能为捕获的值做到这一点吗？
- en: Lambda immutability and capturing values
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda表达式的不可变性和捕获值
- en: 'We''ve discovered that lambdas can capture variables from the context, both
    by value and by reference. So, does this mean we can mutate their value? Let''s
    check it out, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经发现lambda表达式可以从上下文中捕获变量，无论是按值还是按引用。那么，这是否意味着我们可以改变它们的值呢？让我们来看看：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code immediately gives you a compilation error—*cannot assign to a variable
    captured by copy*. This is an improvement from passing parameters by value; that
    is, there is no need to use the `const` keyword—it just works as expected.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码立即给出了一个编译错误——*无法对按值捕获的变量赋值*。这比按值传递参数要好，也就是说，不需要使用`const`关键字——它可以按预期工作。
- en: Immutability for values captured by reference
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按引用捕获的值的不可变性
- en: 'So, what about values captured by reference? Well, we can just use the default
    reference specifier, `[&]`, and check the value of the variable before and after
    the call to our `increment` lambda:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，通过引用捕获的值呢？好吧，我们可以使用默认的引用说明符`[&]`，并在调用我们的`increment` lambda之前和之后检查变量的值：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As expected, the `value` changes. So, how do we protect against this mutation?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`value`发生了变化。那么，我们如何防止这种变化呢？
- en: 'Unfortunately, there''s no easy way to do this. C++ assumes that if you capture
    variables by reference, you want to modify them. While it''s possible, it requires
    a bit more syntactic sugar. Specifically, we need to capture its cast to a `const` type,
    instead of the variable:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有简单的方法可以做到这一点。C++假设如果您通过引用捕获变量，您想要修改它们。虽然这是可能的，但它需要更多的语法糖。具体来说，我们需要捕获其转换为`const`类型的内容，而不是变量本身：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Given the choice, I prefer using simpler syntax. So, I'd rather use the capture
    by value syntax unless I really need to optimize performance.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以选择，我更喜欢使用更简单的语法。因此，除非我真的需要优化性能，我宁愿使用按值捕获的语法。
- en: We've explored how to make lambdas immutable when capturing value types. But
    can we ensure immutability when capturing pointer types?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了如何在捕获值类型时使lambda表达式不可变。但是在捕获指针类型时，我们能确保不可变性吗？
- en: Immutability for pointers captured by value
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按值捕获的指针的不可变性
- en: 'Things get interesting when we use pointers. If we capture them by value, we
    can''t modify the address:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用指针时，事情变得有趣起来。如果我们按值捕获它们，就无法修改地址：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'However, we can still modify the pointed value, as shown in the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们仍然可以修改指向的值，就像下面的代码所示：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Constraining immutability requires a variable of the `const int*` type:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 限制不可变性需要一个`const int*`类型的变量：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'However, there''s a much easier solution—that is, just capture the value of
    the pointer instead:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个更简单的解决方案，那就是只捕获指针的值：
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Immutability for pointers captured by reference
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按引用捕获的指针的不可变性
- en: 'Capturing pointers by reference allows you to change the memory address as
    well:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引用捕获指针允许您改变内存地址：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We could use the same trick as before to enforce the constant nature of the
    memory address:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用与之前相同的技巧来强制内存地址的常量性：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'However, this is getting quite complicated. The only reason to do this is due
    to the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这变得相当复杂。这样做的唯一原因是由于以下原因：
- en: We want to avoid copying 64 bits at most
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望避免最多复制64位
- en: The compiler doesn't optimize it for us
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器不会为我们进行优化
- en: It's simpler to stick to the values that are passed by value instead, that is,
    unless you want to do pointer arithmetic in your lambda.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最好还是坚持使用按值传递的值，除非您想在lambda表达式中进行指针运算。
- en: You now know how lambdas work with immutability. But, in our C++ code, we're
    used to classes. So, what is the relationship between lambdas and classes? Can
    we use them together?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道了lambda表达式在不可变性方面的工作原理。但是，在我们的C++代码中，我们习惯于类。那么，lambda表达式和类之间有什么关系呢？我们能将它们结合使用吗？
- en: Lambdas and classes
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda表达式和类
- en: So far, we have learned how to write lambdas in C++. All the examples use lambda
    expressions outside classes, either as variables or as part of the `main()` function.
    However, most of our C++ code lives in classes. This begs the question—how can
    we use lambdas in classes?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何在C++中编写lambda表达式。所有的例子都是在类外部使用lambda表达式，要么作为变量，要么作为`main()`函数的一部分。然而，我们的大部分C++代码都存在于类中。这就引出了一个问题——我们如何在类中使用lambda表达式呢？
- en: 'To explore this question, we need an example of a simple class. Let''s use
    a class that represents basic imaginary numbers:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探讨这个问题，我们需要一个简单类的例子。让我们使用一个表示基本虚数的类：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We want to use our new-found lambda superpowers to write a simple `toString`
    function, as shown in the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要利用我们新发现的lambda超能力来编写一个简单的`toString`函数，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: So, what options do we have?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们有哪些选择呢？
- en: Well, lambdas are simple variables so they can be a data member. Alternatively,
    they can be `static` variables. Perhaps we can even convert class functions to
    lambdas. Let's explore these ideas next.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，lambda是简单的变量，所以它们可以成为数据成员。或者，它们可以是`static`变量。也许我们甚至可以将类函数转换为lambda。让我们接下来探讨这些想法。
- en: Lambdas as data members
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda作为数据成员
- en: 'Let''s first try to write it as a member variable, as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先尝试将其写为成员变量，如下所示：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Unfortunately, this results in a compilation error. We need to specify the
    type of the lambda variable if we want to have it as a non-static data member.
    To make this work, let''s wrap our lambda into a `function` type, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这导致编译错误。如果我们想将其作为非静态数据成员，我们需要指定lambda变量的类型。为了使其工作，让我们将我们的lambda包装成`function`类型，如下所示：
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The function type has a special syntax, allowing us to define lambda types.
    The `function<string()>` notation means the function returns a `string` value
    and receives no parameters.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 函数类型有一个特殊的语法，允许我们定义lambda类型。`function<string()>`表示函数返回一个`string`值并且不接收任何参数。
- en: 'However, this still doesn''t work. We receive another error because we haven''t
    captured the variables that we''re using. We can use any of the captures that
    we''ve learned about so far. Alternatively, we can capture `this` instead:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这仍然不起作用。我们收到另一个错误，因为我们没有捕获正在使用的变量。我们可以使用到目前为止学到的任何捕获。或者，我们可以捕获`this`：
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is, therefore, how we can write a lambda as part of a class while capturing
    the data members of the class. Capturing `this` is a useful shortcut when refactoring
    existing code. However, I would avoid it in more permanent situations. It's best
    to capture the required variables directly rather than the whole pointer.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就是我们可以将lambda作为类的一部分编写，同时捕获类的数据成员。在重构现有代码时，捕获`this`是一个有用的快捷方式。但是，在更持久的情况下，我会避免使用它。最好直接捕获所需的变量，而不是整个指针。
- en: Lambdas as static variables
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda作为静态变量
- en: 'We could also define our lambda as a `static` variable. We can''t capture the
    values any more, so we need to pass in a parameter, but we can still access the
    `real` and `imaginary` private data members:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将我们的lambda定义为`static`变量。我们不能再捕获值了，所以我们需要传入一个参数，但我们仍然可以访问`real`和`imaginary`私有数据成员：
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Converting a static function to a lambda
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将静态函数转换为lambda
- en: 'Sometimes, we need to convert a `static` function to a lambda variable. This
    is very easy in C++, as shown in the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要将`static`函数转换为lambda变量。在C++中，这非常容易，如下面的代码所示：
- en: '[PRE41]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can simply assign a function from a class to a variable, as you can see
    in this line from the preceding code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地将一个来自类的函数分配给一个变量，就像在前面的代码中所示的那样：
- en: '[PRE42]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We can then use the variable in the same way that we would use the function.
    As we'll discover, this is a very powerful concept because it allows us to compose
    functions even when they are defined inside a class.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以像使用函数一样使用变量。正如我们将要发现的那样，这是一个非常强大的概念，因为它允许我们在类内部定义函数时组合函数。
- en: Lambdas and coupling
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda和耦合
- en: We have many options when it comes to interaction between lambdas and classes.
    They can become both overwhelming and they can make design decisions more difficult.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在lambda和类之间的交互方面，我们有很多选择。它们既可以变得令人不知所措，也可以使设计决策变得更加困难。
- en: While it's good to know the options since they help when going through difficult
    refactorings, I've found, through practice, that it's best to follow one simple
    principle when it comes to lambdas; that is, to choose the option that reduces
    the coupling area between your lambda and the rest of the code.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然了解选项是好的，因为它们有助于进行困难的重构，但通过实践，我发现在使用lambda时最好遵循一个简单的原则；也就是说，选择减少lambda与代码其余部分之间耦合区域的选项是最好的。
- en: 'For example, we''ve seen that we can write our lambda as a `static` variable
    in a class:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们已经看到我们可以将我们的lambda写成类中的`static`变量：
- en: '[PRE43]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This lambda has a coupling area as large as the `ImaginaryNumber` class. However,
    it only needs two values: the real and the imaginary part. We could easily rewrite
    it as a pure function, as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个lambda的耦合区域与`ImaginaryNumber`类一样大。但它只需要两个值：实部和虚部。我们可以很容易地将它重写为一个纯函数，如下所示：
- en: '[PRE44]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If, for some reason, you decide to change the representation of the imaginary
    number by adding members or methods, removing members or methods, splitting it
    into multiple classes, or changing data member types, this lambda will not need
    to be changed. Of course, it takes two parameters instead of one, but the parameter
    type no longer matters, as long as `to_string` works for them. In other words,
    this is a polymorphic function that leaves your options for representing the data
    structure open.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因，您决定通过添加成员或方法、删除成员或方法、将其拆分为多个类或更改数据成员类型来更改虚数的表示，这个lambda将不需要更改。当然，它需要两个参数而不是一个，但参数类型不再重要，只要`to_string`对它们有效。换句话说，这是一个多态函数，它让您对表示数据结构的选项保持开放。
- en: But we'll discuss more about how to use lambdas for design in the following
    chapters.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们将在接下来的章节中更多地讨论如何在设计中使用lambda。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'You''ve just obtained lambda superpowers! Not only can you write simple lambdas
    in C++, but you also know the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚获得了lambda超能力！你不仅可以在C++中编写简单的lambda，还知道以下内容：
- en: How to capture variables from the context
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从上下文中捕获变量
- en: How to specify the default capture type—by reference or by value
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何指定默认捕获类型——按引用或按值
- en: How to write immutable lambdas even when capturing values
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在捕获值时编写不可变的lambda
- en: How to use lambdas in classes
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在类中使用lambda
- en: We've also touched on the design principle of low coupling and how lambdas can
    help with this. We'll keep mentioning this principle in the following chapters.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提到了低耦合设计原则以及lambda如何帮助实现这一点。在接下来的章节中，我们将继续提到这一原则。
- en: Would you believe me if I told you that lambdas are even more powerful than
    what we've seen so far? Well, we'll discover that we can grow from simple to complex
    lambdas through functional composition.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我告诉你，lambda甚至比我们目前所见到的更强大，你会相信吗？好吧，我们将发现通过函数组合，我们可以从简单的lambda发展到复杂的lambda。
- en: Questions
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the simplest lambda you can write?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能写出最简单的lambda吗？
- en: How can you write a lambda that concatenates two string values passed as parameters?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何编写一个将作为参数传递的两个字符串值连接起来的lambda？
- en: What happens if one of the values is a variable that's captured by value?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果其中一个值是被值捕获的变量会发生什么？
- en: What happens if one of the values is a variable that's captured by reference?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果其中一个值是被引用捕获的变量会发生什么？
- en: What happens if one of the values is a pointer that's captured by value?
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果其中一个值是被值捕获的指针会发生什么？
- en: What happens if one of the values is a pointer that's captured by reference?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果其中一个值是被引用捕获的指针会发生什么？
- en: What happens if both values are captured by value using the default capture
    specifier?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果两个值都使用默认捕获说明符被值捕获会发生什么？
- en: What happens if both values are captured by reference using the default capture
    specifier?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果两个值都使用默认捕获说明符被引用捕获会发生什么？
- en: How can you write the same lambda as a data member in a class that has the two
    string values as data members?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在一个类的数据成员中写入与两个字符串值作为数据成员相同的lambda？
- en: How can you write the same lambda as a `static` variable in the same class?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在同一个类中将相同的lambda写为静态变量？
