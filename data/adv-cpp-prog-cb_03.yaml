- en: Implementing Move Semantics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现移动语义
- en: In this chapter, we will learn some advanced C++ move semantics. We will first
    discuss the Big Five, which is an idiom that simply encourages programmers to
    explicitly define the destruction and move/copy semantics of a class. Next, we
    will learn how to define a move constructor and move assignment operator; the
    different combinations of move semantics (including move-only and non-copyable);
    non-movable classes; and how to implement these classes and why they are important.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习一些高级的C++移动语义。我们将首先讨论大五，这是一种鼓励程序员显式定义类的销毁和移动/复制语义的习语。接下来，我们将学习如何定义移动构造函数和移动赋值运算符；移动语义的不同组合（包括仅移动和不可复制）；不可移动的类；以及如何实现这些类以及它们的重要性。
- en: This chapter will also discuss some common pitfalls such as why a `const &&`
    move makes no sense, and how to overcome l-value versus r-value reference types.
    The recipes in this chapter are important because once you enable C++11 or higher,
    move semantics is enabled, which changes how C++ fundamentally handles classes
    in numerous situations. The recipes in this chapter provide the foundation for
    writing efficient code in C++ that behaves as intended.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还将讨论一些常见的陷阱，比如为什么`const &&`移动毫无意义，以及如何克服左值与右值引用类型。本章的示例非常重要，因为一旦启用C++11或更高版本，移动语义就会启用，这会改变C++在许多情况下处理类的方式。本章的示例为在C++中编写高效的代码提供了基础，使其行为符合预期。
- en: 'The recipes in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例如下：
- en: Using compiler-generated special class member functions and the Big Five
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用编译器生成的特殊类成员函数和大五
- en: Making your class movable
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使您的类可移动
- en: Moving only types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅移动类型
- en: Implementing the `noexcept` move constructor
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`noexcept`移动构造函数
- en: Learning to be wary of `const &&`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学会谨慎使用`const &&`
- en: Referencing qualified member functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用限定的成员函数
- en: Exploring objects that cannot be moved or copied
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索无法移动或复制的对象
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To compile and run the examples in this chapter, you must have administrative
    access to a computer running Ubuntu 18.04 with a functional internet connection.
    Before running these examples, you must install the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和运行本章中的示例，您必须具有管理权限的计算机运行Ubuntu 18.04，并具有正常的互联网连接。在运行这些示例之前，您必须安装以下内容：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If this is installed on any operating system other than Ubuntu 18.04, then GCC
    7.4 or higher and CMake 3.6 or higher will be required.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是安装在Ubuntu 18.04以外的任何操作系统上，则需要GCC 7.4或更高版本和CMake 3.6或更高版本。
- en: Using compiler-generated special class member functions and the Big Five
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用编译器生成的特殊类成员函数和大五
- en: When using C++11 or higher, the compiler will auto-generate certain functions
    for your C++ classes if you do not explicitly provide them in the class definition.
    In this recipe, we will explore how this works, which functions the compiler will
    create for you, and how this affects your program's performance and validity.
    In general, the goal of this recipe is to make the case that every class should,
    at a minimum, have the Big Five defined to ensure your class is explicit about
    how you wish to manage resources.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用C++11或更高版本时，如果您没有在类定义中显式提供它们，编译器将为您的C++类自动生成某些函数。在本示例中，我们将探讨这是如何工作的，编译器将为您创建哪些函数，以及这如何影响您程序的性能和有效性。总的来说，本示例的目标是证明每个类应该至少定义大五，以确保您的类明确地说明了您希望如何管理资源。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher, and run the following in a Terminal
    window:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保满足所有的技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有编译和执行本示例中的示例所需的适当工具。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'You need to perform the following steps to try this recipe:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要执行以下步骤来尝试这个示例：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端运行以下命令以下载源代码：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To compile the source code, run the following:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译源代码，请运行以下命令：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译完成后，您可以通过运行以下命令来执行本示例中的每个示例：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本示例中所教授的课程的关系。
- en: How it works...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we will explore the difference between a move and copy and
    how this relates to the Big Five, which is a reference to five functions that
    all classes should explicitly define. To start, let''s first look at a simple
    example of a class that outputs an integer value in its constructor:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将探讨移动和复制之间的区别，以及这与大五的关系，大五是指所有类都应该显式定义的五个函数。首先，让我们先看一个简单的例子，一个在其构造函数中输出整数值的类：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding example, the class will output to `stdout` when the class is
    destructed. The class also has an integer member variable that is initialized
    on construction. The problem with the preceding example is that the implicit copy
    and move semantics are suppressed because we defined the class's destructor.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，当类被销毁时，它将输出到`stdout`。该类还有一个在构造时初始化的整数成员变量。前面示例的问题在于，我们定义了类的析构函数，因此隐式的复制和移动语义被抑制了。
- en: 'The Big Five are the following functions, which every class should define if
    at least one of these functions are defined (that is, if you define one, you must
    define them all):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 大五是以下函数，每个类都应该定义这些函数中的至少一个（也就是说，如果你定义了一个，你必须定义它们全部）：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As shown, the Big Five includes the destructor, move constructor, move assignment
    operator, copy constructor, and copy assignment operator. The author of these
    classes need not implement these functions but instead should—at a minimum—*define*
    the functions, explicitly stating how deletions, copying, and moving should take
    place (if at all). This ensures that if one of these functions is defined, the
    rest of the class''s move, copy, and destruction semantics are correct, as in
    this example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，Big Five包括析构函数、移动构造函数、移动赋值运算符、复制构造函数和复制赋值运算符。这些类的作者不需要实现这些函数，而是应该至少*定义*这些函数，明确说明删除、复制和移动应该如何进行（如果有的话）。这确保了如果这些函数中的一个被定义，类的其余移动、复制和销毁语义是正确的，就像这个例子中一样：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding example, the class is marked as `virtual` by defining a virtual
    destructor (meaning the class is capable of participating in runtime polymorphism).
    No implementation is needed (by setting the destructor to `default`), but the
    definition itself is explicit, which tells the compiler that we want the class
    to support virtual functions. This tells the user of the class that a pointer
    to this class can be used to delete an instance of any class that derives from
    it. It also tells the user that inheritance will leverage runtime polymorphism
    and not composition. This class also states that copies and moves are both allowed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，通过定义虚拟析构函数（意味着该类能够参与运行时多态），将类标记为`virtual`。不需要实现（通过将析构函数设置为`default`），但定义本身是显式的，告诉编译器我们希望该类支持虚拟函数。这告诉类的用户，可以使用该类的指针来删除从它派生的任何类的实例。它还告诉用户，继承将利用运行时多态而不是组合。该类还声明允许复制和移动。
- en: 'Let''s look at another example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding example, copies are explicitly deleted (which is the same as
    defining a move constructor without defining copy semantics). This defines a move-only
    class, which means that the class can only be moved; it cannot be copied. An example
    of such a class in the standard library is `std::unique_ptr`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，复制被明确删除（这与定义移动构造函数但未定义复制语义相同）。这定义了一个仅移动的类，这意味着该类只能被移动；它不能被复制。标准库中的一个这样的类的例子是`std::unique_ptr`。
- en: 'The next class implements the opposite:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个类实现了相反的功能：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding example, we have explicitly defined a copy-only class.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们明确定义了一个仅复制的类。
- en: There are many different combinations of the Big Five. The point of this recipe
    is to show that explicitly defining these five functions ensures that the author
    of the class is explicit about the intent of the class itself. This is with respect
    to how it should operate and how a user should use the class. Being explicit ensures
    the author of the class doesn't intend for one type of behavior, but instead gets
    another because of how the compiler will implicitly construct the class based
    on the compiler's implementation and how the C++ specification was defined.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的Big Five的组合。这个教程的重点是显示明确定义这五个函数可以确保类的作者对类本身的意图是明确的。这涉及到它应该如何操作以及用户应该如何使用类。明确确保类的作者并不打算获得一种类型的行为，而是因为编译器将根据编译器的实现和C++规范的定义隐式构造类，而获得另一种类型的行为。
- en: Making your class movable
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使您的类可移动
- en: 'In C++11 or higher, objects can either be copied or moved, which can be used
    to dictate how your object''s resources are managed. The big difference between
    a copy and a move is simple: a copy creates a copy of the resources an object
    manages, while a move transfers the resources from one object to another.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11或更高版本中，对象可以被复制或移动，这可以用来决定对象的资源是如何管理的。复制和移动之间的主要区别很简单：复制会创建对象管理的资源的副本，而移动会将资源从一个对象转移到另一个对象。
- en: In this recipe, we will explain how to make a class movable, including how to
    properly add move constructors and move assignment operators. We will also explain
    some of the subtle details of a movable class and how to use them in your code.
    This recipe is important because, in a lot of cases, moving an object instead
    of copying an object increases the performance and reduces the memory consumption
    of your programs. However, the use of movable objects could introduce some instabilities
    if they are not used properly.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将解释如何使一个类可移动，包括如何正确添加移动构造函数和移动赋值运算符。我们还将解释可移动类的一些微妙细节以及如何在代码中使用它们。这个教程很重要，因为在很多情况下，移动对象而不是复制对象可以提高程序的性能并减少内存消耗。然而，如果不正确使用可移动对象，可能会引入一些不稳定性。
- en: Getting ready
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有编译和执行本教程中示例所需的适当工具。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'You need to perform the following steps to try this recipe:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要执行以下步骤来尝试这个教程：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端中，运行以下命令来下载源代码：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To compile the source code, run the following:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦源代码编译完成，您可以通过运行以下命令来执行本教程中的每个示例：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本教程所教授的课程的关系。
- en: How it works...
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In this recipe, we will learn how to make a class movable. To start, let''s
    examine a basic class definition:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何使一个类可移动。首先，让我们来看一个基本的类定义：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding example, we create a simple class with a private integer member
    that is initialized. We then define a default constructor and a destructor that
    outputs to `stdout` when an instance of the class is destroyed. By default, this
    class is movable, but the move operation mimics a copy (in other words, there
    is no difference between a move or a copy with this simple example).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个简单的类，它有一个私有的整数成员，被初始化。然后我们定义了一个默认构造函数和一个析构函数，当类的实例被销毁时，它会输出到`stdout`。默认情况下，这个类是可移动的，但移动操作模拟了一个复制（换句话说，这个简单的例子中移动和复制没有区别）。
- en: 'To really make this class movable, we need to add both a move constructor and
    a move assignment operator as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正使这个类可移动，我们需要添加移动构造函数和移动赋值运算符，如下所示：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once we add these two functions, we will be able to use the following to move
    our class from one instance to another:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们添加了这两个函数，我们就能够使用以下方法将我们的类从一个实例移动到另一个实例：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To support this, in the preceding class, we will not only add the move constructor
    and assignment operator, but we will also implement a default constructor to provide
    a valid moved-from state to our example class, as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这一点，在前面的类中，我们不仅添加了移动构造函数和赋值运算符，还实现了一个默认构造函数，为我们的示例类提供了一个有效的移动状态，如下所示：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As shown, the class now has a default constructor and an explicit constructor
    that takes an integer argument. The default constructor initializes the integer
    memory variable, which represents our moved-from or invalid state:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，该类现在有一个默认构造函数和一个显式构造函数，它接受一个整数参数。默认构造函数初始化整数内存变量，表示我们的移动来源或无效状态：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As shown in the preceding example, we output the value of our integer member
    variable when the class is destroyed, but in this case, we first check to make
    sure the integer variable is valid:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，当类被销毁时，我们输出整数成员变量的值，但在这种情况下，我们首先检查整数变量是否有效：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Finally, we implement the move constructor and assignment operators. The move
    constructor simply calls the move assignment operator to prevent the need for
    duplication (as they perform the same action). The move assignment operator first
    checks to make sure that we are not moving to ourselves. This is because doing
    so would lead to corruption as the user would expect the class to still contain
    a valid integer but in fact, the internal integer would inadvertently be set to
    `0`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现了移动构造函数和赋值运算符。移动构造函数简单地调用移动赋值运算符，以防止重复（因为它们执行相同的操作）。移动赋值运算符首先检查我们是否在将自己移动。这是因为这样做会导致损坏，因为用户期望类仍然包含一个有效的整数，但实际上，内部整数会无意中被设置为`0`。
- en: We then exchange the integer value and set the original to `0`. This is because,
    once again, a move is not a copy. A move transfers the value from one instance
    to another. In this case, the instance being moved to starts as `0` and is given
    a valid integer, while the instance being moved from starts with a valid integer
    and is set to `0` after the move, resulting in only `1` instance containing a
    valid integer.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们交换整数值并将原始值设置为`0`。这是因为，再一次强调，移动不是复制。移动将值从一个实例转移到另一个实例。在这种情况下，被移动到的实例开始为`0`，并被赋予一个有效的整数，而被移出的实例开始有一个有效的整数，移动后被设置为`0`，导致只有`1`个实例包含一个有效的整数。
- en: It should also be noted that we have to define the copy constructor and assignment
    operator. This is because, by default, if you provide a move constructor and assignment
    operator, C++ will automatically delete the copy constructor and assignment operator
    if they are not explicitly defined.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 还应该注意，我们必须定义复制构造函数和赋值运算符。这是因为，默认情况下，如果你提供了移动构造函数和赋值运算符，C++会自动删除复制构造函数和赋值运算符，如果它们没有被显式定义的话。
- en: 'In this example, we will compare a move versus a copy, so we define the copy
    constructor and assignment operator to ensure they are not implicitly deleted.
    In general, it is best practice to define your destructor, the move constructor,
    and assignment operator as well as the copy constructor and assignment operator
    for every class you define. This ensures that the copy/move semantics for every
    class you write are explicit and intentional:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将比较移动和复制，因此我们定义了复制构造函数和赋值运算符，以确保它们不会被隐式删除。一般来说，最好的做法是为你定义的每个类定义析构函数、移动构造函数和赋值运算符，以及复制构造函数和赋值运算符。这确保了你编写的每个类的复制/移动语义都是明确和有意义的：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When the preceding code is executed, we get the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行上述代码时，我们得到了以下结果：
- en: '![](img/bc7cc97b-8542-42e5-9ada-0634f0017fbc.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc7cc97b-8542-42e5-9ada-0634f0017fbc.png)'
- en: 'In our main function, we run two different tests:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主函数中，我们运行了两个不同的测试：
- en: The first test creates two instances of our class and copies the contents of
    one instance to the other.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个测试创建了我们类的两个实例，并将一个实例的内容复制到另一个实例。
- en: The second test creates two instances of our class and then moves the contents
    of one instance to the other.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个测试创建了我们类的两个实例，然后将一个实例的内容移动到另一个实例。
- en: When this example is executed, we see the first test's output was written to
    twice. This is because the first instance of our class is given a copy of the
    second instance of our class, which has a valid integer value. The second test's
    output is only written to once because we are transferring the valid state of
    one instance to the other, resulting in only one instance having a valid state
    at any given moment.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行这个例子时，我们看到第一个测试的输出被写了两次。这是因为我们的类的第一个实例得到了第二个实例的一个副本，而第二个实例有一个有效的整数值。第二个测试的输出只被写了一次，因为我们正在将一个实例的有效状态转移到另一个实例，导致在任何给定时刻只有一个实例具有有效状态。
- en: 'There are some notable instances worth mentioning here:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些值得一提的例子：
- en: Move constructors and assignment operators should never throw exceptions. Specifically,
    a move operation transfers the valid state of an instance of a type to another
    instance of that type. At no point should this operation fail as no state is being
    created or destroyed. It is simply being transferred. Also, it is oftentimes difficult
    to *undo* a move operation part of the way through the move. For these reasons,
    these functions should always be labeled as `noexcept` (refer to [https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-move-noexcept](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-move-noexcept)).
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动构造函数和赋值运算符不应该抛出异常。具体来说，移动操作将一个类型的实例的有效状态转移到该类型的另一个实例。在任何时候，这个操作都不应该失败，因为没有状态被创建或销毁。它只是被转移。此外，往往很难*撤消*移动操作。因此，这些函数应该始终被标记为`noexcept`（参考[https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-move-noexcept](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-move-noexcept)）。
- en: Move constructors and assignment operators do not include `const` types in their
    function signature because the instance being moved from cannot be `const` since
    its internal state is being transferred, which implicitly assumes a write is occurring.
    More importantly, if you label a move constructor or assignment operator as `const`,
    it is possible that a copy would occur instead.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动构造函数和赋值运算符在其函数签名中不包括`const`类型，因为被移动的实例不能是`const`，因为其内部状态正在被转移，这暗示着写操作正在发生。更重要的是，如果将移动构造函数或赋值运算符标记为`const`，则可能会发生复制。
- en: Unless you intend to create a copy, a move should be used instead, especially
    for large objects. Just like passing `const T&` as a function argument to prevent
    a copy from occurring, when a function is called, a move should be used in place
    of a copy when a resource is being moved into another variable instead of being
    copied.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非您打算创建一个副本，否则应该使用移动，特别是对于大型对象。就像将`const T&`作为函数参数传递以防止发生复制一样，当调用函数时，当资源被移动到另一个变量而不是被复制时，应该使用移动代替复制。
- en: The compiler will automatically generate move operations instead of copy operations
    when possible. For example, if you create an object in a function, configure the
    object, and then return the object, a move will be automatically performed by
    the compiler.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器在可能的情况下会自动生成移动操作而不是复制操作。例如，如果您在函数中创建一个对象，配置该对象，然后返回该对象，编译器将自动执行移动操作。
- en: Now that you know how to make your classes movable, in the next recipe, we will
    learn what a move-only type is, and why you might want to use them in your applications.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何使您的类可移动了，在下一个食谱中，我们将学习什么是只可移动类型，以及为什么您可能希望在应用程序中使用它们。
- en: Move-only types
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只可移动类型
- en: In this recipe, we will learn how to make a class move-only. A great example
    of the difference between a copy and a move is the difference between `std::unique_ptr`
    and `std::shared_ptr`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何使一个类成为只可移动的。一个很好的例子是`std::unique_ptr`和`std::shared_ptr`之间的区别。
- en: The point of `std::unique_ptr` is to enforce a single owner for dynamically
    allocated types while `std::shared_ptr` allows for multiple owners of dynamically
    allocated types. Both allow the user to move the contents of a pointer type from
    one instantiation to another, but only `std::shared_ptr` allows the user to make
    a copy of the pointer (as copying the pointer would create more than one owner).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unique_ptr`的目的是强制动态分配类型的单一所有者，而`std::shared_ptr`允许动态分配类型的多个所有者。两者都允许用户将指针类型的内容从一个实例移动到另一个实例，但只有`std::shared_ptr`允许用户复制指针（因为复制指针会创建多个所有者）。'
- en: In this recipe, we will use these two classes to show how to make a move-only
    class and to show why this type of class is used so heavily in C++ (as most of
    the time we wish to move and not copy).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用这两个类来展示如何制作一个只可移动的类，并展示为什么这种类型的类在C++中被如此广泛地使用（因为大多数时候我们希望移动而不是复制）。
- en: Getting ready
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有正确的工具来编译和执行本食谱中的示例。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'You need to perform the following steps to try this recipe:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要执行以下步骤来尝试这个食谱：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端运行以下命令以下载源代码：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To compile the source code, run the following:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦源代码编译完成，您可以通过运行以下命令来执行本食谱中的每个示例：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍每个示例，并解释每个示例程序的作用以及它与本食谱中所教授的课程的关系。
- en: How it works...
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'A move-only class is a class that can be moved but cannot be copied. To explore
    this type of class, let''s wrap `std::unique_ptr`, which itself is a move-only
    class, in the following example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 只可移动类是一种可以移动但不能复制的类。为了探索这种类型的类，让我们在以下示例中包装`std::unique_ptr`，它本身是一个只可移动的类：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding class stores `std::unique_ptr` as a member variable and, on construction,
    instantiates the memory variable with an integer value. On destruction, the class
    checks to make sure `std::unique_ptr` is valid and if so, outputs the value to
    `stdout`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类将`std::unique_ptr`作为成员变量存储，并在构造时用整数值实例化内存变量。在销毁时，类会检查`std::unique_ptr`是否有效，如果有效，则将值输出到`stdout`。
- en: 'At first glance, we might wonder why we must check for validity as `std::unique_ptr`
    is always constructed. The reason `std::unique_ptr` could become invalid is during
    a move. Since we are creating a move-only class (and not a non-copyable, non-movable
    class), we implement the move constructor and move assignment operator, which
    moves `std::unique_ptr`. `std::unique_ptr`, on moving, will transfer the contents
    of its internal pointer from one class to another, resulting in the class being
    moved from storing an invalid pointer (that is, `nullptr`). In other words, even
    though this class cannot be null-constructed, it can still store `nullptr` if
    it is moved, as in the following example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，我们可能会想知道为什么我们必须检查 `std::unique_ptr` 的有效性，因为 `std::unique_ptr` 总是被构造。`std::unique_ptr`
    可能变得无效的原因是在移动期间。由于我们正在创建一个只能移动的类（而不是一个不可复制、不可移动的类），我们实现了移动构造函数和移动赋值运算符，它们移动 `std::unique_ptr`。`std::unique_ptr`
    在移动时将其内部指针的内容从一个类转移到另一个类，导致该类从存储无效指针（即 `nullptr`）移动。换句话说，即使这个类不能被空构造，如果它被移动，它仍然可以存储
    `nullptr`，就像下面的例子一样：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As shown in the preceding example, only one class outputs to `stdout` as only
    one instance is valid. Like `std::unique_ptr`, a move-only class ensures that
    you always have a 1:1 relationship between the total number of resources being
    created and the total number of actual instantiations occurring.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的例子所示，只有一个类输出到 `stdout`，因为只有一个实例是有效的。与 `std::unique_ptr` 一样，只能移动的类确保你总是有一个资源被创建的总数与实际发生的实例化总数之间的
    1:1 关系。
- en: 'It should be noted that since we are using `std::unique_ptr`, our class becomes
    a move-only class whether we like it or not. For example, attempting to add a
    copy constructor or copy assignment operator to enable the ability to copy will
    result in a compilation error:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，由于我们使用了 `std::unique_ptr`，我们的类无论我们是否喜欢，都变成了一个只能移动的类。例如，尝试添加复制构造函数或复制赋值运算符以启用复制功能将导致编译错误：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In other words, every class that includes a move-only class as a member also
    becomes a move-only class itself. Although this might seem undesirable, you must
    first ask yourself: do you really need a class to be copyable? The likely answer
    is no. In fact, in most cases, even before C++11, most—if not all—of the classes
    that we work with should be move-only. The ability of a class to be copied when
    it should be moved can lead to wasted resources, corruption, and so on, which
    is one of the reasons move semantics were added to the specification. Move semantics
    allow us to define how we want the resources we allocate to be handled, and it
    provides us with a way to enforce the desired semantics at compile time.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，每个包含只能移动的类作为成员的类也会成为只能移动的类。尽管这可能看起来不太理想，但你首先必须问自己：你真的需要一个可复制的类吗？很可能答案是否定的。实际上，在大多数情况下，即使在
    C++11 之前，我们使用的大多数类（如果不是全部）都应该是只能移动的。当一个类应该被移动而被复制时，会导致资源浪费、损坏等问题，这也是为什么在规范中添加了移动语义的原因之一。移动语义允许我们定义我们希望分配的资源如何处理，并且它为我们提供了一种在编译时强制执行所需语义的方法。
- en: 'You might wonder how the preceding example would be converted to allow for
    copying. The following example leverages a shared pointer to accomplish this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道前面的例子如何转换以允许复制。以下示例利用了 shared pointer 来实现这一点：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding class uses `std::shared_ptr` instead of `std::unique_ptr`. Under
    the hood, `std::shared_ptr` keeps track of the number of copies that are made
    and only deletes the pointer it stored when the total number of copies is `0`.
    In fact, you can query the total number of copies using the `use_count()` function.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类使用了 `std::shared_ptr` 而不是 `std::unique_ptr`。在内部，`std::shared_ptr` 跟踪被创建的副本数量，并且只有在总副本数为
    `0` 时才删除它存储的指针。实际上，你可以使用 `use_count()` 函数查询总副本数。
- en: 'Next, we define the move constructor, move assignment operator, copy constructor,
    and copy assignment operator, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义移动构造函数，移动赋值运算符，复制构造函数和复制赋值运算符，如下所示：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'These definitions could have also been written using the `=` default syntax
    as these implementations are the same thing. Finally, we test this class using
    the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义也可以使用 `=` 默认语法来编写，因为这些实现是相同的。最后，我们使用以下方式测试这个类：
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If we execute the preceding code, we get the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行前面的代码，我们会得到以下结果：
- en: '![](img/80128ca4-0b35-4b29-b649-c871a64b025f.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80128ca4-0b35-4b29-b649-c871a64b025f.png)'
- en: In the preceding tests, we first create a copy of our class and output the total
    number of copies to see that two copies were in fact created. The second test
    performs `std::move()` instead of a copy, which results in only one copy being
    created as expected.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试中，我们首先创建了一个类的副本，并输出了总副本数，以查看实际上创建了两个副本。第二个测试执行了 `std::move()` 而不是复制，结果只创建了一个预期中的副本。
- en: Implementing the noexcept move constructor
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 noexcept 移动构造函数
- en: In this recipe, we will learn how to ensure a move constructor and a move assignment
    operator never throw an exception. The C++ specification doesn't prevent a move
    constructor from throwing (as it was determined that such a requirement would
    simply be too difficult to enforce, as too many legitimate examples exist even
    in the standard library). However, ensuring that exceptions are not thrown should
    be possible in most cases. Specifically, a move usually doesn't create resources
    but instead transfers resources and as a result, strong exception guarantees should
    be possible. A good example of a move that does create a resource is `std::list`,
    which must provide a valid `end()` iterator even on a move.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将学习如何确保移动构造函数和移动赋值运算符永远不会抛出异常。C++ 规范并不阻止移动构造函数抛出异常（因为确定这样的要求实际上太难以强制执行，即使在标准库中也存在太多合法的例子）。然而，在大多数情况下，确保不会抛出异常应该是可能的。具体来说，移动通常不会创建资源，而是转移资源，因此应该可能提供强异常保证。一个创建资源的好例子是
    `std::list`，即使在移动时也必须提供有效的 `end()` 迭代器。
- en: Getting ready
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有编译和执行本文示例所需的适当工具。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'You need to perform the following steps to try this recipe:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要执行以下步骤来尝试这个示例：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端中运行以下命令来下载源代码：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To compile the source code, run the following:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦源代码编译完成，您可以通过运行以下命令来执行本文中每个示例：
- en: '[PRE34]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍每个示例，并解释每个示例程序的作用以及它与本文所教授的课程的关系。
- en: How it works...
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'As stated before, a move should not throw an exception to ensure strong exception
    guarantees (that is, the act of moving an object doesn''t possibly corrupt the
    object), and in most cases, this is possible because a move (unlike a copy) doesn''t
    create resources, it transfers them. The best way to ensure that your move constructors
    and move assignment operators do not throw is to only transfer member variables
    using `std::move()`, as in the following example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，移动不应该抛出异常，以确保强异常保证（即，移动对象的行为不会破坏对象），在大多数情况下，这是可能的，因为移动（不像复制）不会创建资源，而是转移资源。确保您的移动构造函数和移动赋值操作符不会抛出异常的最佳方法是只使用`std::move()`来转移成员变量，就像以下示例中所示的那样：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Assuming that the member variable you are moving doesn''t throw, your class
    will not either. Using this simple technique will ensure that your move constructors
    and operators never throw. But what if this operation cannot be used? Let''s explore
    this issue with the following example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您移动的成员变量不会抛出异常，那么您的类也不会。使用这种简单的技术将确保您的移动构造函数和操作符永远不会抛出异常。但如果这个操作不能使用怎么办？让我们通过以下示例来探讨这个问题：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the preceding example, we create a class with a vector as the member variable.
    The vector can either be initialized as empty by default, or it can be initialized
    with a single element. On destruction, if the vector has a value, we output the
    value to `stdout`. We implement the `move` constructor and operator as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个具有向量作为成员变量的类。向量可以通过默认方式初始化为空，或者可以初始化为单个元素。在销毁时，如果向量有值，我们将该值输出到`stdout`。我们实现`move`构造函数和操作符如下：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As shown, the move operator is transferring the single element from one instance
    to the other (not the best way to implement a move, but this implementation can
    demonstrate the point without being overly complicated). If the vector is empty,
    this operation will throw, as in the following example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，移动操作符将单个元素从一个实例转移到另一个实例（这不是实现移动的最佳方式，但这种实现可以演示要点而不会过于复杂）。如果向量为空，这个操作将抛出异常，就像下面的例子一样：
- en: '[PRE38]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Finally, we attempt to move an instance of this class in two different tests.
    In the first test, both instances are default constructed, which results in empty
    classes, while the second test constructs the vector with a single element, which
    results in a valid move. In this case, we were able to prevent the move from throwing,
    but it should be noted that the resulting classes did not actually perform the
    move, resulting in both objects not containing the state that was desired. This
    is why move constructors should never throw. Even if we didn't catch the exception,
    it would be extremely difficult to assert the state of the program after the throw
    occurred. Did the move occur? What state is each instance in? In most cases, this
    type of error should lead to `std::terminate()` being called as the program enters
    a corrupt state.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们尝试在两个不同的测试中移动这个类的一个实例。在第一个测试中，两个实例都是默认构造的，这导致空的类，而第二个测试构造了一个带有单个元素的向量，这导致有效的移动。在这种情况下，我们能够防止移动抛出异常，但应该注意的是，结果类实际上并没有执行移动，导致两个对象都不包含所需的状态。这就是为什么移动构造函数不应该抛出异常。即使我们没有捕获异常，也很难断言抛出异常后程序的状态。移动是否发生？每个实例处于什么状态？在大多数情况下，这种类型的错误应该导致调用`std::terminate()`，因为程序进入了一个损坏的状态。
- en: A copy is different because the original class is left intact. The copy is invalid
    and the programmer can handle this case gracefully, as the original state of the
    instance being copied is unaffected (hence we mark it `const`).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 复制不同，因为原始类保持不变。复制是无效的，程序员可以优雅地处理这种情况，因为被复制的实例的原始状态不受影响（因此我们将其标记为`const`）。
- en: Since, however, the instance being moved from is writable, both instances are
    in a corrupt state and there isn't a good way to know how to handle the program
    moving forward, as we don't know whether the original instance was left in a state
    that can be properly handled.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于被移动的实例是可写的，两个实例都处于损坏状态，没有很好的方法来知道如何处理程序的继续运行，因为我们不知道原始实例是否处于可以正确处理的状态。
- en: Learning to be wary of const&&
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学会谨慎使用const&&
- en: In this recipe, we will learn why a move constructor or operator should never
    be marked `const` (and why a copy constructor/operator is always marked as `const`).
    This is important because it gets to the heart of the difference between a move
    and a copy. Move semantics in C++ is one of its most powerful features and understanding
    why it is so important and what it is actually doing is critical to writing good
    C++ code.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习为什么移动构造函数或操作符不应标记为`const`（以及为什么复制构造函数/操作符总是标记为`const`）。这很重要，因为它涉及到移动和复制之间的区别。C++中的移动语义是其最强大的特性之一，了解为什么它如此重要以及它实际上在做什么对于编写良好的C++代码至关重要。
- en: Getting ready
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有适当的工具来编译和执行本食谱中的示例。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'You need to perform the following steps to try this recipe:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要执行以下步骤来尝试这个食谱：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端中运行以下命令来下载源代码：
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To compile the source code, run the following:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦源代码编译完成，您可以通过运行以下命令来执行本食谱中的每个示例：
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本食谱中所教授的课程的关系。
- en: How it works...
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'In this recipe, we will learn why a `const&&` constructor or operator doesn''t
    make sense and will result in unexpected behavior. A move transfers resources,
    which is why it is marked as non-`const`. This is because a transfer assumes that
    both instances are written to (one instance receives the resource while the other
    has the resource taken away). A copy creates resources, which is why they are
    not always marked as `noexcept` (creating resources absolutely could throw) and
    they are marked `const` (because the original instance is being copied, not modified).
    A `const&&` constructor is claiming to be a move that doesn''t transfer, which
    must be a copy (if you are not writing to the original instance, you are not moving—you
    are copying), as in this example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习为什么`const&&`构造函数或操作符没有意义，并将导致意外行为。移动会转移资源，这就是为什么它标记为非`const`。这是因为转移假定两个实例都被写入（一个实例接收资源，而另一个实例被取走资源）。复制会创建资源，这就是为什么它们并不总是标记为`noexcept`（创建资源绝对可能会抛出异常），并且它们被标记为`const`（因为原始实例被复制，而不是修改）。`const&&`构造函数声称是一个不转移的移动，这必须是一个复制（如果您没有写入原始实例，您不是在移动—您在复制），就像这个例子中一样：
- en: '[PRE43]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the preceding example, we create a class that implements default move and
    copy constructors/operators. The only difference is that we add output to `stdout`
    to tell us whether a copy is being performed or a move is being performed.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个实现默认移动和复制构造函数/操作符的类。唯一的区别是我们向`stdout`添加了输出，告诉我们是执行了复制还是移动。
- en: We then create two instances of our class with the instance being moved from
    being marked as `const`. We then perform the move and what is output is a copy.
    This is because even though we asked for a move, the compiler used a copy. We
    could implement a `const &&` move constructor/operator but there would be no way
    to write the move as a move, since we marked the object being moved from as `const`,
    so we cannot take its resources. Such a move would, in fact, be implemented as
    a copy, no different than what the compiler did for us automatically.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建了两个类的实例，实例被移动，从被标记为`const`。然后我们执行移动，输出的是一个复制。这是因为即使我们要求移动，编译器也使用了复制。我们可以实现一个`const
    &&`移动构造函数/操作符，但没有办法将移动写成移动，因为我们标记了被移动的对象为`const`，所以我们无法获取它的资源。这样的移动实际上会被实现为一个复制，与编译器自动为我们做的没有区别。
- en: In the next recipe, we will learn how to add qualifiers to our member functions.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个食谱中，我们将学习如何向我们的成员函数添加限定符。
- en: Referencing qualified member functions
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用限定成员函数
- en: In this recipe, we will learn about what a reference qualified member function
    is. Although this aspect of the C++ language is less used and understood, it is
    important because it provides the programmer with the ability to handle how resources
    are operated on, based on whether or not the class is in an l-value or r-value
    state when a function is called.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习什么是引用限定的成员函数。尽管C++语言的这一方面使用和理解较少，但它很重要，因为它为程序员提供了根据类在调用函数时处于l-value还是r-value状态来处理资源操作的能力。
- en: Getting ready
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE44]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有适当的工具来编译和执行本食谱中的示例。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'You need to perform the following steps to try this recipe:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要执行以下步骤来尝试这个食谱：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端中运行以下命令来下载源代码：
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To compile the source code, run the following:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE46]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译后，您可以通过运行以下命令来执行本文中每个示例：
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本文所教授的课程的关系。
- en: How it works...
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In this example, we will look at what a reference qualified member function
    is. To explain what a reference-qualified member function is, let''s look at the
    following example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将看看什么是引用限定的成员函数。为了解释什么是引用限定的成员函数，让我们看下面的例子：
- en: '[PRE48]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In this example, we have implemented a `foo()` function, but we have two different
    versions. The first version has `&` at the end while the second has `&&` at the
    end. Which `foo()` function gets executed is dictated by whether or not the instance
    is an l-value or an r-value, as in the following example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们实现了一个 `foo()` 函数，但是我们有两个不同的版本。第一个版本在末尾有 `&`，而第二个版本在末尾有 `&&`。`foo()`
    函数的执行取决于实例是 l-value 还是 r-value，就像下面的例子中一样：
- en: '[PRE49]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This results in the following when executed:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时会得到以下结果：
- en: '![](img/19571c4b-ebb1-4680-a183-82571ec2416c.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/19571c4b-ebb1-4680-a183-82571ec2416c.png)'
- en: As shown in the preceding example, the first execution of `foo()` is an l-value,
    as the l-value version of `foo()` is executed (that is, the function with `&`
    at the end). The last two executions of `foo()` are r-values as the r-value versions
    of `foo()` are executed.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，`foo()` 的第一次执行是一个 l-value，因为执行了 `foo()` 的 l-value 版本（即末尾带有 `&` 的函数）。`foo()`
    的最后两次执行是 r-value，因为执行了 `foo()` 的 r-value 版本。
- en: Reference-qualified member functions can be used to ensure that the function
    is only called in the right context. Another reason to use these types of functions
    is to ensure that the function is only called when an l-value or r-value reference
    exists.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 参考限定成员函数可用于确保函数仅在正确的上下文中调用。使用这些类型的函数的另一个原因是确保只有当存在 l-value 或 r-value 引用时才调用该函数。
- en: For example, you might not want to allow `foo()` to be called as an r-value
    as this type of invocation doesn't ensure that an instance of the class actually
    has a lifetime outside of the call itself, as demonstrated in the preceding example.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可能不希望允许 `foo()` 作为 r-value 被调用，因为这种类型的调用并不能确保类的实例在调用本身之外实际上具有生命周期，就像前面的例子中所示的那样。
- en: In the next recipe, we will learn how to make a class that can neither be moved
    nor copied, and explain why you might do such a thing.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将学习如何创建一个既不能移动也不能复制的类，并解释为什么要这样做。
- en: Exploring objects that cannot be moved or copied
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索不能移动或复制的对象
- en: In this recipe, we will learn about how to create an object that we cannot move
    or copy and why you might want to create such a class. Copying a class requires
    the ability to copy the contents of a class, which in some cases, could be impossible
    (for example, making a copy of a memory pool is not simple). Moving a class assumes
    that the class is allowed to exist in a potentially invalid state (for example, `std::unique_ptr`,
    when moved, takes on a `nullptr` value, which is invalid). Such cases may also
    be undesirable (you now have to check for validity). A non-movable class that
    we cannot copy can overcome these types of issues.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们将学习如何创建一个既不能移动也不能复制的对象，以及为什么要创建这样一个类。复制一个类需要能够复制类的内容，在某些情况下可能是不可能的（例如，复制内存池并不简单）。移动一个类假设该类被允许存在于潜在的无效状态（例如，`std::unique_ptr`
    移动时会取得一个 `nullptr` 值，这是无效的）。这样的情况也可能是不希望发生的（现在必须检查有效性）。一个既不能移动也不能复制的类可以克服这些问题。
- en: Getting ready
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保满足所有技术要求，包括安装 Ubuntu 18.04 或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE50]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有正确的工具来编译和执行本文中的示例。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'You need to perform the following steps to try this recipe:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要执行以下步骤来尝试这个示例：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端中运行以下命令以下载源代码：
- en: '[PRE51]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To compile the source code, run the following:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE52]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译后，您可以通过运行以下命令来执行本文中每个示例：
- en: '[PRE53]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本文所教授的课程的关系。
- en: How it works...
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Move-only classes prevent a class from being copied, which in some cases, can
    be a performance improvement. Move-only classes also ensure a 1:1 relationship
    between resources that are created versus the resources that are allocated, as
    copies cannot exist. Moving a class, however, can result in a class becoming invalid,
    as in this example:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 仅移动类可以阻止类被复制，在某些情况下，这可能是性能的提升。仅移动类还确保了创建的资源与分配的资源之间的1:1关系，因为副本是不存在的。然而，移动类可能导致类变为无效，就像这个例子中一样：
- en: '[PRE54]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If we run the preceding code, we get the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上述代码，我们会得到以下结果：
- en: '![](img/f6a0a4c9-5084-4fae-8a30-69fb5fff3ce5.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6a0a4c9-5084-4fae-8a30-69fb5fff3ce5.png)'
- en: In the preceding example, we create a class that can be moved, which stores `std::unique_ptr`.
    In the destructor of the class, we dereference the class and output its value.
    We don't check the validity of `std::unique_ptr` because we wrote a constructor
    that forces a valid `std::unique_ptr`, forgetting that a move can undo this explicit
    validity. The result is that, when a move is performed, we get a segmentation
    fault.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们创建了一个可以移动的类，它存储了`std::unique_ptr`。在类的析构函数中，我们对类进行了解引用并输出了它的值。我们没有检查`std::unique_ptr`的有效性，因为我们编写了一个强制有效`std::unique_ptr`的构造函数，忘记了移动可能会撤消这种显式的有效性。结果是，当执行移动操作时，我们会得到一个分段错误。
- en: 'To overcome this, we need a reminder that we made this assumption, as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这一点，我们需要提醒自己做出了以下假设：
- en: '[PRE55]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The preceding class explicitly deletes both the copy and move operations, and
    this is our desired intent. Now, if we accidentally move this class, we get the
    following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类明确删除了复制和移动操作，这是我们期望的意图。现在，如果我们意外地移动这个类，我们会得到以下结果：
- en: '[PRE56]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This error tells us that it is assumed that the class is valid and therefore
    does not support moving. We either need to properly support moving (which means
    we must maintain support for invalid `std::unique_ptr`) or we need to remove the
    `move` operation. As shown, a class that cannot be moved or copied can ensure
    that our code works as intended, providing the compiler with a mechanism to warn
    us when we are doing something with our class that we didn't intend.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误告诉我们，假设这个类是有效的，因此不支持移动。我们要么需要正确地支持移动（这意味着我们必须维护对无效的`std::unique_ptr`的支持），要么我们需要删除`move`操作。正如所示，一个不能被移动或复制的类可以确保我们的代码按预期工作，为编译器提供一种机制，当我们对类做了我们不打算做的事情时，它会警告我们。
