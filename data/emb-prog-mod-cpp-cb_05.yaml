- en: Debugging, Logging, and Profiling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试、日志记录和性能分析
- en: Debugging and profiling is an important part of the development workflow for
    any type of application. In the case of an embedded environment, these tasks require
    special attention from developers. Embedded applications run on a system that
    might be very different from a developer's workstation, and that often has limited
    resources and user interface capabilities.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 调试和性能分析是任何类型应用程序开发工作流程中的重要部分。在嵌入式环境中，这些任务需要开发人员特别注意。嵌入式应用程序在可能与开发人员工作站非常不同的系统上运行，并且通常具有有限的资源和用户界面功能。
- en: Developers should plan in advance how they are going to debug their application
    during the development phase, and how they are going to determine the root causes
    of, as well as fix, the issues in the production environment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员应该提前计划如何在开发阶段调试他们的应用程序，以及如何确定生产环境中问题的根本原因，并加以修复。
- en: Often, the solution is to use an emulator for a target device along with an
    interactive debugger that is provided by the embedded system vendor. For more
    complex systems, however, complete and accurate emulation is hardly feasible,
    and remote debugging is the most viable solution.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，解决方案是使用目标设备的仿真器以及嵌入式系统供应商提供的交互式调试器。然而，对于更复杂的系统，完整和准确的仿真几乎是不可行的，远程调试是最可行的解决方案。
- en: In many cases, using an interactive debugger is not possible or not practical
    at all. Hardware states can change in a few milliseconds after a program stops
    on a breakpoint, and a developer has insufficient time to analyze it. In such
    cases, developers have to use extensive logging for root cause analysis.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，使用交互式调试器是不可能或根本不切实际的。程序在断点停止后几毫秒内硬件状态可能会发生变化，开发人员没有足够的时间来分析它。在这种情况下，开发人员必须使用广泛的日志记录进行根本原因分析。
- en: 'In this chapter, we will focus on debugging approaches for the more powerful
    systems based on **SoC** (short for **System On a Chip**) and running Linux OS.
    We will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点介绍基于**SoC**（**片上系统**）和运行Linux操作系统的更强大系统的调试方法。我们将涵盖以下主题：
- en: Running your applications in the **GDB** (short for** GNU Project Debugger) **
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**GDB**（GNU项目调试器的缩写）中运行您的应用程序
- en: Working with breakpoints
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用断点
- en: Working with core dumps
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理核心转储
- en: Using gdbserver for debugging
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用gdbserver进行调试
- en: Adding debug logging
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加调试日志
- en: Working with debug and release builds
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用调试和发布版本
- en: These basic debugging techniques will help significantly while working with
    the recipes in this book as well as in your work on embedded applications of any
    kind.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基本的调试技术将在本书中以及在您处理任何类型嵌入式应用程序的工作中有很大帮助。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will learn how to debug embedded applications in the **ARM**
    (short for** Acorn RISC Machines**) platform emulator. At this point, you should
    already have two systems configured in a virtualized Linux environment running
    on your laptop or desktop:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何在**ARM**（**Acorn RISC Machines**的缩写）平台仿真器中调试嵌入式应用程序。此时，您应该已经在笔记本电脑或台式电脑上运行的虚拟化Linux环境中配置了两个系统：
- en: Ubuntu Linux in a Docker container as a build system
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu Linux作为构建系统在Docker容器中
- en: Debian Linux in a **QEMU** (short for **Quick EMUlato**) ARM emulator as a target
    system
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Debian Linux作为目标系统在**QEMU**（**快速仿真器**）ARM仿真器中
- en: To learn the theory of cross-compilation and set up the development environment,
    please refer to the recipes in [Chapter 2](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml), *Setting
    Up the Environment*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解交叉编译的理论并设置开发环境，请参考[第2章](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml)中的示例，*设置环境*。
- en: Running your applications in the GDB
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在GDB中运行您的应用程序
- en: In this recipe, we will learn how to run a sample application in a debugger
    on a target system, as well as try out some basic debugging techniques.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何在目标系统上使用调试器运行一个示例应用程序，以及尝试一些基本的调试技术。
- en: GDBis an open source and widely used interactive debugger. Unlike most of the
    debuggers that come as part of **Integrated Development Environment** (**IDE**)
    products, the GDB is a standalone, command-line debugger. This means that it does
    not depend on any particular IDE. As you can see in the example, you can use a
    plain text editor to work on the code of your application, while still being able
    to debug it interactively, use breakpoints, view the content of variables and
    stack traces, and much more.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: GDB是一个开源且广泛使用的交互式调试器。与大多数作为**集成开发环境**（**IDE**）产品的一部分提供的调试器不同，GDB是一个独立的命令行调试器。这意味着它不依赖于任何特定的IDE。正如您在示例中所看到的，您可以使用纯文本编辑器来处理应用程序的代码，同时仍然能够进行交互式调试，使用断点，查看变量和堆栈跟踪的内容，以及更多。
- en: The user interface of the GDB is minimalist. You run with it in the same way
    as you work with a Linux console— by typing in commands and analyzing their output.
    This simplicity makes it extremely suitable for embedded projects. It can run
    on a system that does not have a graphical subsystem. It is especially handy if
    the target system can only be accessed over a serial connection or ssh shell.
    Since it does not have a fancy user interface, it can work on systems with limited
    resources.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: GDB的用户界面是极简的。您可以像在Linux控制台上工作一样运行它——通过输入命令并分析它们的输出。这种简单性使其非常适合嵌入式项目。它可以在没有图形子系统的系统上运行。如果目标系统只能通过串行连接或ssh
    shell访问，它尤其方便。由于它没有花哨的用户界面，它可以在资源有限的系统上运行。
- en: In this recipe, we will use an artificial sample application that crashes with
    an exception. It does not log any useful information and the exception message
    is too vague to determine the root cause of the crash. We will use the GDB to
    determine the root cause of the issue.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用一个人工样本应用程序，它会因异常而崩溃。它不会记录任何有用的信息，异常消息太模糊，无法确定崩溃的根本原因。我们将使用GDB来确定问题的根本原因。
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We are now going to create a simple application that crashes under specific
    conditions:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建一个在特定条件下崩溃的简单应用程序：
- en: In your working directory, `~/test`, create a subdirectory called `loop`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的工作目录`~/test`中，创建一个名为`loop`的子目录。
- en: Use your favorite text editor to create a `loop.cpp` file in the `loop` subdirectory.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器在`loop`子目录中创建一个名为`loop.cpp`的文件。
- en: 'Let''s put some code into the `loop.cpp` file. We start with includes:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将一些代码放入`loop.cpp`文件中。我们从包含开始：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we define three functions that our program will consist of. The first
    one is `runner`:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们定义程序将包含的三个函数。第一个是`runner`：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The second function is `delay_ms`:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个函数是`delay_ms`：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And finally, we add the entry-point function, `main`:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加入口函数`main`：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a file called `CMakeLists.txt` in the `loop` subdirectory with the following
    content:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`loop`子目录中创建一个名为`CMakeLists.txt`的文件，并包含以下内容：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, switch to the build system terminal and change the current directory to
    `/mnt/loop` by running the following command.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，切换到构建系统终端，并通过运行以下命令将当前目录更改为`/mnt/loop`。
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Build the application as follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式构建应用程序：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Switch back to your native environment, find the `loop` output file in the
    `loop` subdirectory, and copy it over ssh to the target system. Use the user account.
    Switch to the target system terminal. Log in using the user credentials if needed.
    Now, run the `loop` executable binary using `gdb`:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换回您的本机环境，在`loop`子目录中找到`loop`输出文件，并通过ssh将其复制到目标系统。使用用户帐户。切换到目标系统终端。根据需要使用用户凭据登录。现在，使用`gdb`运行`loop`可执行二进制文件：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The debugger has been started and shows the command-line prompt (`gdb`). To
    run the application, type the `run` command:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调试器已启动，并显示命令行提示（`gdb`）。要运行应用程序，请键入`run`命令：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can see that the application terminated abnormally due to the runtime exception.
    The exception message, `Time limit exceeded`, gives us a clue, but does not indicate
    under what specific conditions it happened. Let''s try to establish this. Firstly,
    let''s check the stack trace of the crashing application:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以看到应用程序由于运行时异常而异常终止。异常消息`Time limit exceeded`给了我们一个线索，但并没有指出发生异常的具体条件。让我们试着确定这一点。首先，让我们检查崩溃应用程序的堆栈跟踪：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This shows seven stack frames from the top-level function, `main`, down to
    the library function, `__GI_abort`, which actually terminates the application.
    As we can see, only frames `7` and `6` belong to our application, since only they
    are defined in `loop.cpp`. Let''s take a close look at `frame 6`, since this is
    the function that throws the exception:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这显示了从顶级函数`main`到库函数`__GI_abort`的七个堆栈帧，后者实际上终止了应用程序。正如我们所看到的，只有帧`7`和`6`属于我们的应用程序，因为只有它们在`loop.cpp`中定义。让我们仔细看一下`frame
    6`，因为这是抛出异常的函数：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run the `list` command to see the nearby code:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`list`命令来查看附近的代码：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As we can see, the exception is thrown if the value of the delta variable exceeds
    the value of the limit variable. But what are what are these values?. These are
    the values of variable ‘delta’ and ‘limit Run the `info locals` command to figure
    this out:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们所看到的，如果delta变量的值超过limit变量的值，就会抛出异常。但是这些值是什么？运行`info locals`命令来找出这一点：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We cannot see the value of the limit variable here. Use the `info args` command to
    see it:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们无法在这里看到限制变量的值。使用`info args`命令来查看它：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, we can see that the limit is `10`, and the delta `11`. The crash happens
    when the function is called with the `fn` parameter set to the `delay_ms` function and
    the value of the `value` parameter set to `7`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以看到限制是`10`，而delta是`11`。当使用`fn`参数设置为`delay_ms`函数，并且`value`参数的值设置为`7`时，崩溃发生。
- en: How it works...
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The application is intentionally created to crash under certain conditions and
    does not provide enough information to be able to nail down to these conditions.
    The application consists of two major functions – `runner` and `delay_ms`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序是故意创建的，在某些条件下会崩溃，并且没有提供足够的信息来确定这些条件。该应用程序由两个主要函数组成——`runner`和`delay_ms`。
- en: The `runner` function accepts three parameters—the time limit, the function
    of one parameter, and the function parameter value. It runs the function provided
    as a parameter, passing it the value, and measures the elapsed time. If the time
    exceeds the time limit, it throws an exception.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`runner`函数接受三个参数——时间限制、一个参数的函数和函数参数值。它运行作为参数提供的函数，传递值，并测量经过的时间。如果时间超过时间限制，它会抛出异常。'
- en: The `delay_ms` function performs a delay. However, it is implemented incorrectly
    and considers each millisecond as consisting of 1,100 microseconds instead of
    1,000.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`delay_ms`函数执行延迟。但是，它的实现是错误的，它将每毫秒视为由1100微秒而不是1000微秒组成。'
- en: The `main` function runs the runner in the `loop` directory, providing fixing
    values of 10 milliseconds as a time limit and `delay_ms` as a function to run,
    but increasing values of the `value` parameter. At some point, the `delay_ms`
    function exceeds the time limit and the app crashes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数在`loop`目录中运行runner，提供10毫秒作为时间限制的修复值和`delay_ms`作为要运行的函数，但增加`value`参数的值。在某个时候，`delay_ms`函数超过了时间限制，应用程序崩溃了。'
- en: 'First, we build the application for the ARM platform and transfer it to the
    emulator to run:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为ARM平台构建应用程序，并将其传输到模拟器上运行：
- en: '![](img/52c9bbb6-e17c-4961-a4da-0e45d3a73859.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/52c9bbb6-e17c-4961-a4da-0e45d3a73859.png)'
- en: 'It is important to pass the `-g` parameter to the compiler. This parameter
    instructs the compiler to add debug symbols to the resulting binary. We add it
    to the `CMAKE_CXX_FLAGS` parameter in the `CMakeLists.txt` file, as shown here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要向编译器传递`-g`参数。此参数指示编译器向生成的二进制文件添加调试符号。我们将其添加到`CMakeLists.txt`文件中的`CMAKE_CXX_FLAGS`参数中，如下所示：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we run the debugger and pass the application executable name as its parameter:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们运行调试器，并将应用程序可执行文件名作为其参数：
- en: '![](img/e3b7393c-2d4c-4b8d-a1dd-1f5ea2c2ced8.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3b7393c-2d4c-4b8d-a1dd-1f5ea2c2ced8.png)'
- en: 'The application does not run immediately. We start it using the `run` GDB command and
    observe it crashing shortly afterward:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序不会立即运行。我们使用`run` GDB命令启动它，并观察它在短时间内崩溃：
- en: '![](img/66aacaec-d965-40bc-bac7-e0de3e630951.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66aacaec-d965-40bc-bac7-e0de3e630951.png)'
- en: 'Next, we use the `backtrace` command to review the stack trace:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`backtrace`命令来查看堆栈跟踪：
- en: '![](img/b394f587-a045-48f3-8c60-299f1cbb9fc7.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b394f587-a045-48f3-8c60-299f1cbb9fc7.png)'
- en: 'An analysis of the stack trace shows that `frame 6` should give us more information
    to reveal the root cause. By way of the next steps, we switch to `frame 6` and
    review the relevant fragment of code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对堆栈跟踪的分析显示`frame 6`应该给我们更多信息来揭示根本原因。通过接下来的步骤，我们切换到`frame 6`并审查相关的代码片段：
- en: '![](img/ee18e675-c717-4500-8d75-c88fd036ad38.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee18e675-c717-4500-8d75-c88fd036ad38.png)'
- en: 'Next, we analyze the values of local variables and function parameters to determine
    how they are related to the time limit:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们分析本地变量和函数参数的值，以确定它们与时间限制的关系：
- en: '![](img/a37ff8ac-9ac1-4185-9e4c-d641e7c05ff4.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a37ff8ac-9ac1-4185-9e4c-d641e7c05ff4.png)'
- en: We ascertain that the crash occurs when the value passed to `delay_ms` reaches
    `7`, not `11`, as would be expected in the case of correct implementation of the
    delay.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确定当传递给`delay_ms`的值达到`7`时发生崩溃，而不是预期的`11`，这在正确实现延迟的情况下是预期的。
- en: There's more...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'GDB commands often accept multiple parameters to fine-tune their behavior.
    Learn more about each command using the `help` GDB command. For example, here
    is the output of the `help bt` command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: GDB命令通常接受多个参数来微调它们的行为。使用`help`命令来了解每个命令的更多信息。例如，这是`help bt`命令的输出：
- en: '![](img/96d294ad-4432-4294-bd38-b8480c1ccec6.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/96d294ad-4432-4294-bd38-b8480c1ccec6.png)'
- en: This displays information on the `bt` command that is used to review and analyze
    stack traces. Similarly, you can get information regarding all the other commands
    supported by the GDB.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了用于审查和分析堆栈跟踪的`bt`命令的信息。类似地，您可以获取关于GDB支持的所有其他命令的信息。
- en: Working with breakpoints
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用断点
- en: In this recipe, we will learn more advanced debugging techniques when working
    with the GDB. We will use the same sample application and use breakpoints to find
    the dependency of the actual delay on the value of the `delay_ms` parameter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将学习在使用GDB时更高级的调试技术。我们将使用相同的示例应用程序，并使用断点来找到实际延迟与`delay_ms`参数值的依赖关系。
- en: Working with breakpoints in the GDB is similar to working with breakpoints in
    debuggers integrated into IDE, the only difference being that instead of using
    the built-in editor to navigate the source code, developers have to learn to use
    line numbers, filenames, or function names explicitly.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在GDB中使用断点与在集成IDE中使用断点类似，唯一的区别是开发人员不是使用内置编辑器来导航源代码，而是要学会显式使用行号、文件名或函数名。
- en: This is less convenient than click-and-run debuggers, but the flexibility allows
    developers to create powerful debugging scenarios. In this recipe, we will learn
    how to use breakpoints in the GDB.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这比点击运行调试器不太方便，但是灵活性使开发人员能够创建强大的调试场景。在这个教程中，我们将学习如何在GDB中使用断点。
- en: How to do it...
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'In this recipe, we will use the same environment and the same test application
    as in the first recipe. Refer to steps 1 to 9 of the *Running your applications in
    the GDB* recipe to build the application and copy it over to the target system:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将使用与第一个教程相同的环境和相同的测试应用程序。参考第1到9步的*在GDB中运行您的应用程序*教程来构建应用程序并将其复制到目标系统上：
- en: 'We want to debug our `runner` function. Let''s take a look at its content.
    In the gdb shell, run the program as follows:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要调试我们的`runner`函数。让我们看一下它的内容。在gdb shell中，运行以下程序：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We want to see how the delta changes on each iteration. Let''s set a breakpoint
    at the line:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要看到每次迭代中`delta`的变化。让我们在该行设置一个断点：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Use the `break 14` command to set a breakpoint on line 14:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`break 14`命令在第14行设置一个断点：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, run the program:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行程序：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Check the value of `delta`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`delta`的值：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Continue execution of the program by typing `continue`, or just `c`:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续执行程序，输入`continue`或者`c`：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Check the value of `delta` again:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次检查`delta`的值：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As we expected, the value of `delta` increases on each iteration, since `delay_ms`
    takes more and more time.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们预期的那样，`delta`的值在每次迭代中都会增加，因为`delay_ms`需要越来越多的时间。
- en: 'Running `print delta` each time is not convenient. Let''s automate it using
    the command named `command`:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次运行`print delta`都不方便。让我们使用名为`command`的命令来自动化它：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run `c` again. Now, the value of `delta` is displayed after each stop:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行`c`。现在，每次停止后都会显示`delta`的值：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'However, the output is too verbose. Let''s silence the GDB output by typing `command`
    again and writing the following instructions. Now, run the `c` or `continue` command several
    times to see the difference:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，输出太冗长了。让我们通过再次输入`command`并编写以下指令来使GDB输出静音。现在，运行`c`或`continue`命令几次以查看差异：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can make the output even more concise by using the `printf` command, as
    shown here:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`printf`命令使输出更加简洁，如下所示：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, we can see two values, the calculated delay and the expected delay, and
    can see how they diverge over time.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到两个值，计算出的延迟和预期的延迟，并且可以看到它们随时间的变化而发散。
- en: How it works...
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we want to set a breakpoint to debug the `runner` function.
    Since the GDB does not have a built-in editor, we need to know the line number
    to set the breakpoint. Though we can get it directly from a text editor, another
    way is to look at the relevant code snippet in the GDB. We use the `gdb` command
    list with two parameters – function names, to display lines of code between the
    first line of the function runner and the first line of the `delay_ms` function. This
    efficiently shows the content of the function runner:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们想要设置一个断点来调试`runner`函数。由于GDB没有内置编辑器，我们需要知道设置断点的行号。虽然我们可以直接从文本编辑器中获取它，但另一种方法是在GDB中查看相关代码片段。我们使用带有两个参数的`gdb`命令列表
    - 函数名称，以显示`runner`函数的第一行和`delay_ms`函数的第一行之间的代码行。这有效地显示了函数`runner`的内容：
- en: '![](img/482a8b75-c389-4e61-b14d-de3f5cd496b9.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/482a8b75-c389-4e61-b14d-de3f5cd496b9.png)'
- en: 'At *step 4*, set the breakpoint at line `14` using the `break 14` command and
    run the program. The execution stops at the breakpoint:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*，使用`break 14`命令在第14行设置断点，并运行程序。执行将在断点处停止：
- en: '![](img/c22a841e-1537-4806-b134-47c6733547bc.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c22a841e-1537-4806-b134-47c6733547bc.png)'
- en: 'We check the value of the `delta` variable using the `print` command and continue
    execution of the program using the `continue` command, and since the `runner`
    function is invoked in the loop, it stops at the same breakpoint again:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`print`命令检查`delta`变量的值，并使用`continue`命令继续执行程序，由于在循环中调用了`runner`函数，它再次停在相同的断点处：
- en: '![](img/3e1b1f31-812a-4201-8a63-1866a3febe7a.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e1b1f31-812a-4201-8a63-1866a3febe7a.png)'
- en: 'Next, we try a more advanced technique. We define a set of GDB commands to
    be executed when the breakpoint is triggered. We start with a simple `print` command.
    Now, every time we continue execution, we can see the value of the `delta` variable:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们尝试更高级的技术。我们定义一组GDB命令，以在触发断点时执行。我们从一个简单的`print`命令开始。现在，每次我们继续执行，我们都可以看到`delta`变量的值：
- en: '![](img/55443211-11e7-43c4-a6c2-6a135a946c64.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/55443211-11e7-43c4-a6c2-6a135a946c64.png)'
- en: 'Next, we disable the auxiliary GDB output using the `silent` command to make
    the output more concise:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`silent`命令禁用辅助GDB输出，以使输出更加简洁：
- en: '![](img/7175eb69-bc52-4946-b777-6277cae952a9.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7175eb69-bc52-4946-b777-6277cae952a9.png)'
- en: 'Finally, we use the `printf` command to format messages with the two most interesting
    variables:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`printf`命令格式化具有两个最有趣变量的消息：
- en: '![](img/7b3fe1fb-b927-4590-9e68-2172dde5d955.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b3fe1fb-b927-4590-9e68-2172dde5d955.png)'
- en: As you can see, the GDB provides lots of flexibility for developers to make
    debugging comfortable, even lacking the graphical interface.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，GDB为开发人员提供了很多灵活性，使得即使缺乏图形界面，调试也变得更加舒适。
- en: There's more...
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It is important to remember that the optimization options, `-O2` and `-O3`,
    may result in some lines of code being eliminated by the compiler completely.
    If you set breakpoints to such lines, these breakpoints are never triggered. To
    avoid such situations, turn off the compiler optimizations for the debug builds.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，优化选项`-O2`和`-O3`可能导致编译器完全消除一些代码行。如果将断点设置为这些行，这些断点将永远不会触发。为避免这种情况，关闭调试构建的编译器优化。
- en: Working with core dumps
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理核心转储
- en: In the first recipe, we learned how to nail down the root cause of a crashing
    application using an interactive command-line debugger. However, there are situations
    when applications crash in the production environment, and it is impossible or
    impractical to reproduce the same issue running the application under the GDB
    on a test system.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '在第一个教程中，我们学习了如何使用交互式命令行调试器确定崩溃应用程序的根本原因。但是，在生产环境中，应用程序崩溃时，有时无法或不切实际地在测试系统上重现相同的问题，从GDB中运行应用程序。 '
- en: Linux provides a mechanism to help with the analysis of crashing applications
    even when they are not run from the GDB directly. When an application is terminated
    abnormally, the operating system saves the image of its memory into a file named
    `core`. In this recipe, we will learn how to configure Linux to generate core
    dumps for crashing applications, and how to use the GDB for their analysis.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Linux提供了一种机制，可帮助分析崩溃的应用程序，即使它们不是直接从GDB中运行的。当应用程序异常终止时，操作系统将其内存映像保存到名为`core`的文件中。在本教程中，我们将学习如何配置Linux以生成崩溃应用程序的核心转储，以及如何使用GDB进行分析。
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We are going to identify the root cause of a crash in an application that was
    not run in the GDB:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将确定一个应用程序崩溃的根本原因，该应用程序未在GDB中运行：
- en: In this recipe, we will use the same environment and the same test application
    as in the first recipe. Refer to *steps 1* to *7* of the first recipe to build
    the application and copy it over to the target system.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本教程中，我们将使用与第一个教程中相同的环境和相同的测试应用程序。请参阅第一个教程的*步骤1*至*7*，构建应用程序并将其复制到目标系统。
- en: 'Firstly, we need to enable the generation of core dumps for crashing applications.
    This feature is turned off by default in most Linux distribution. Run the `ulimit
    -c` command to check the current status:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要启用生成崩溃应用程序的核心转储。在大多数Linux发行版中，默认情况下关闭此功能。运行`ulimit -c`命令检查当前状态：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The value reported by the preceding command is the maximum size of core dumps
    to generate. Zero means no core dumps. To increase the limit, we need to get superuser
    privileges first. Run the `su -` command. When prompted for a `Password`, type
    `root`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前一个命令报告的值是要生成的核心转储的最大大小。零表示没有核心转储。要增加限制，我们需要首先获得超级用户权限。运行`su -`命令。提示输入`Password`时，输入`root`：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Run the `ulimit -c unlimited` command to allow core dumps of any size:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`ulimit -c unlimited`命令允许任意大小的核心转储：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, exit the root shell by pressing *Ctrl *+ *D* or by running the `logout`
    command.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过按*Ctrl* + *D*或运行`logout`命令退出root shell。
- en: 'Preceding commands changed the core dump limit for the superuser only. To apply
    it to the current user, run the same command again in the user shell:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的命令仅为超级用户更改了核心转储限制。要将其应用于当前用户，请在用户shell中再次运行相同的命令：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Make sure that the limit was changed:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保限制已更改：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, run the application as usual:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，像往常一样运行应用程序：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It will crash with an exception. Run the `ls` command to check whether a core
    file was created in the current directory:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将以异常崩溃。运行`ls`命令检查当前目录中是否创建了核心文件：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, run `gdb`, passing the executable and the `core` files as parameters:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行`gdb`，传递可执行文件和`core`文件作为参数：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the GDB shell, run the `bt` command to see the stack trace:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GDB shell中，运行`bt`命令查看堆栈跟踪：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can see the same stack trace as for the application running from inside
    `gdb`. However, in this case, we see the stack trace of the core dump.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以看到与从`gdb`内部运行的应用程序相同的堆栈跟踪。但是，在这种情况下，我们看到了核心转储的堆栈跟踪。
- en: At this point, we can use the same debugging techniques as in the first recipe
    to narrow down the cause of the crash.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以使用与第一个教程中相同的调试技术来缩小崩溃原因。
- en: How it works...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Core dump functionality is a standard feature of Linux and other Unix-like operating
    systems. However, the creation of core files in every case is not practical. Since
    core files are snapshots of process memory, they can account for megabytes or
    even gigabytes on a filesystem. In many cases, this is not acceptable.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 核心转储功能是Linux和其他类Unix操作系统的标准功能。然而，在每种情况下都创建核心文件并不实际。由于核心文件是进程内存的快照，它们可能在文件系统上占用几兆甚至几十几个G的空间。在许多情况下，这是不可接受的。
- en: Developers need to explicitly specify the maximum size of the core files that
    are allowed to be generated by the operating system. This limit, among other limits,
    can be set using the `ulimit` command.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员需要明确指定操作系统允许生成的核心文件的最大大小。这个限制，以及其他限制，可以使用`ulimit`命令来设置。
- en: We run `ulimit` twice to remove the limit first for the superuser root, and
    then for the ordinary user/developer. The two-stage process is needed because
    the ordinary user limit cannot exceed the superuser limit.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行`ulimit`两次，首先为超级用户root移除限制，然后为普通用户/开发人员移除限制。需要两阶段的过程，因为普通用户的限制不能超过超级用户的限制。
- en: After we have removed the limit for the core file size, we run our test application
    without the GDB. It crashes, as expected. After the crash, we can see that a new
    file called `core` was created in the current directory.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们移除了核心文件大小的限制后，我们在没有GDB的情况下运行我们的测试应用程序。预期地，它崩溃了。崩溃后，我们可以看到当前目录中创建了一个名为`core`的新文件。
- en: 'When we run our application, it crashes. Normally, we would not be able to
    track the root cause of the crash. However, since we enabled core dumps, a file
    named `core` was automatically created for us by the operating system:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行我们的应用程序时，它崩溃了。通常情况下，我们无法追踪崩溃的根本原因。然而，由于我们启用了核心转储，操作系统自动为我们创建了一个名为`core`的文件：
- en: '![](img/a897ffd1-0aa8-4f4d-b1d3-a9e2941e9e77.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a897ffd1-0aa8-4f4d-b1d3-a9e2941e9e77.png)'
- en: A core file is a binary dump of all process memory, but it is difficult to analyze
    it without additional tools. Thankfully, the GDB provides the necessary support.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 核心文件是所有进程内存的二进制转储，但没有额外的工具很难分析它。幸运的是，GDB提供了必要的支持。
- en: 'We run the GDB passing two parameters – the path to the executable, and the
    path to the core file. In this mode, we do not run the application from inside
    the GDB. We already have its state frozen at the moment of the crash in the core
    dump. The GDB uses the executable to bind memory addressed within the `core` file
    to functions and variable names:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行GDB传递两个参数——可执行文件的路径和核心文件的路径。在这种模式下，我们不从GDB内部运行应用程序。我们已经在核心转储中冻结了应用程序在崩溃时的状态。GDB使用可执行文件将`core`文件中的内存地址绑定到函数和变量名：
- en: '![](img/8f81cb30-8138-4cd4-8688-2db1c3152d52.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f81cb30-8138-4cd4-8688-2db1c3152d52.png)'
- en: 'As a result, you can analyze the crashed application in an interactive debugger,
    even when the application was not run from the debugger. When we invoke the `bt`
    command, the GDB displays the stack trace at the moment of the crash:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使应用程序未从调试器中运行，您也可以在交互式调试器中分析崩溃的应用程序。当我们调用`bt`命令时，GDB会显示崩溃时的堆栈跟踪：
- en: '![](img/56155e9f-ad93-4de6-b78e-4511160d4840.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/56155e9f-ad93-4de6-b78e-4511160d4840.png)'
- en: This way, we can nail down the root cause of an application crashing even if,
    initially, it was not run in a debugger.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，即使最初没有在调试器中运行，我们也可以找出应用程序崩溃的根本原因。
- en: There's more...
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Analyzing core dumps using the GDB is a widely used and effective practice for
    embedded applications. However, to use the full capabilities of the GDB, the application
    should be built with debug symbol support.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GDB分析核心转储是嵌入式应用程序的广泛使用和有效实践。然而，要使用GDB的全部功能，应用程序应该构建时支持调试符号。
- en: In most cases, however, embedded applications are deployed and run without debug
    symbols to reduce the binary size. In this case, an analysis of core dumps becomes
    harder and may require some knowledge of assembly language for the particular
    architecture and of the internals of data structure implementations.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在大多数情况下，嵌入式应用程序会在没有调试符号的情况下部署和运行，以减小二进制文件的大小。在这种情况下，对核心转储的分析变得更加困难，可能需要一些特定架构的汇编语言和数据结构实现的内部知识。
- en: Using gdbserver for debugging
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用gdbserver进行调试
- en: The environment for embedded development normally involves two systems— a build
    system and a target system, or an emulator. Although the command-line interface
    of the GDB makes it a good choice even for low-performance embedded systems, in
    many cases, interactive debugging on the target system is impractical because
    of the high latency of remote communication.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式开发的环境通常涉及两个系统——构建系统和目标系统，或者模拟器。尽管GDB的命令行界面使其成为低性能嵌入式系统的不错选择，但在许多情况下，由于远程通信的高延迟，目标系统上的交互式调试是不切实际的。
- en: In such situations, developers can use remote debugging support provided by
    the GDB. In this setup, an embedded application is launched on the target system
    using gdbserver. Developers run the GDB on a build system and connect to gdbserver
    over the network.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，开发人员可以使用GDB提供的远程调试支持。在这种设置中，嵌入式应用程序使用gdbserver在目标系统上启动。开发人员在构建系统上运行GDB，并通过网络连接到gdbserver。
- en: In this recipe, we will learn how to start debugging an application using the
    GDB and gdbserver.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何使用GDB和gdbserver开始调试应用程序。
- en: Getting ready...
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪...
- en: Follow the *Connecting to the embedded system* recipe of [Chapter 2](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml), *Setting
    Up the Environment*,to have the `hello` application available on the target system.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 按照[第2章](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml)的*连接到嵌入式系统*配方，*设置环境*，在目标系统上有`hello`应用程序可用。
- en: How to do it...
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will use the same application we used in the preceding recipes, but now
    we will run the GDB and applications in different environments:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用前面的示例中使用的相同应用程序，但现在我们将在不同的环境中运行GDB和应用程序：
- en: Switch to the target system window and type *Ctrl* + *D* to log out from the
    existing user session.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到目标系统窗口，然后输入*Ctrl* + *D*以注销当前用户会话。
- en: Log in as `user`, using the `user` password.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以`user`身份登录，使用`user`密码。
- en: 'Run the `hello` application under `gdbserver`:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`gdbserver`下运行`hello`应用程序：
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Switch to the build system terminal and change the directory to `/mnt`:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到构建系统终端，并将目录更改为`/mnt`：
- en: '[PRE36]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Run `gdb`, passing the application binary as a parameter:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`gdb`，将应用程序二进制文件作为参数传递：
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Configure a remote connection by typing the following command in the GDB command
    line:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在GDB命令行中输入以下命令来配置远程连接：
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, type the `continue` command:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，键入`continue`命令：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The program now runs and we can see its output and debug it as if it were run
    locally.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在程序正在运行，我们可以看到它的输出并像在本地运行一样对其进行调试。
- en: How it works...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: First, we log in to our target system as root and install gdbserver, unless
    it is already installed. Once installation is complete, we log in again with user
    credentials and run gdbserver, passing the name of the application to debug, the
    IP address, and the port to listen to for incoming connections as its parameters.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们以root用户身份登录到目标系统并安装gdbserver，除非它已经安装。安装完成后，我们再次使用用户凭据登录并运行gdbserver，将要调试的应用程序的名称、IP地址和要监听的端口作为其参数传递。
- en: Then, we switch to our build system and run the GDB there. However, instead
    of running the application in the GDB directly, we instruct the GDB to initiate
    a connection to a remote host using the provided IP address and port. After that,
    all commands you type at the GDB prompt will be transferred to gdbserver and executed
    there.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们切换到我们的构建系统并在那里运行GDB。但是，我们不直接在GDB中运行应用程序，而是指示GDB使用提供的IP地址和端口建立与远程主机的连接。之后，您在GDB提示符处键入的所有命令都将传输到gdbserver并在那里执行。
- en: Adding debug logging
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加调试日志
- en: Logging and diagnostics are an important aspect of any embedded project. In
    many cases, using an interactive debugger is not possible or not practical. Hardware
    state can change in a few milliseconds after a program stops on a breakpoint,
    and a developer has insufficient time to analyze it. Collecting detailed log data
    and using tools for their analysis and visualization is a better approach for
    high-performance, multithreaded, time-sensitive embedded systems.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录和诊断是任何嵌入式项目的重要方面。在许多情况下，使用交互式调试器是不可能或不切实际的。在程序停在断点后，硬件状态可能在几毫秒内发生变化，开发人员没有足够的时间来分析它。收集详细的日志数据并使用工具进行分析和可视化是高性能、多线程、时间敏感的嵌入式系统的更好方法。
- en: Logging itself introduces certain delays. Firstly, it takes time to format the
    log messages and put them into the log stream. Secondly, the log stream should
    be reliably stored in persistent storage, such as a flash card or a disk drive,
    or sent to the remote system.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录本身会引入一定的延迟。首先，需要时间来格式化日志消息并将其放入日志流中。其次，日志流应可靠地存储在持久存储器中，例如闪存卡或磁盘驱动器，或者发送到远程系统。
- en: In this recipe, we will learn how to use logging instead of interactive debugging
    to find the root causes of issues. We will use a system of different log levels
    to minimize the delays introduced by logging.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何使用日志记录而不是交互式调试来查找问题的根本原因。我们将使用不同日志级别的系统来最小化日志记录引入的延迟。
- en: How to do it...
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will modify our application to output information that is useful for root
    cause analysis:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改我们的应用程序以输出对根本原因分析有用的信息：
- en: Go to your work directory, `~/test`, and make a copy of the `loop` project directory. Name
    the copy `loop2`. Change directory to `loop2`.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到您的工作目录`~/test`，并复制`loop`项目目录。将副本命名为`loop2`。切换到`loop2`目录。
- en: Use your text editor to open the `loop.cpp` file.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用文本编辑器打开`loop.cpp`文件。
- en: 'Add one more `include`:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`include`：
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Modify the `runner` function by adding calls to the `syslog` function, as highlighted
    in the following code snippet:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在以下代码片段中突出显示的方式修改`runner`函数，添加对`syslog`函数的调用：
- en: '[PRE41]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Similarly, update the `main` function to initialize and finalize `syslog`:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，更新`main`函数以初始化和完成`syslog`：
- en: '[PRE42]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Switch to the build system terminal. Go to the `/mnt/loop2` directory and run
    the program:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到构建系统终端。转到`/mnt/loop2`目录并运行程序：
- en: '[PRE43]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Copy the resulting `binary` file loop to the target system and run it:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将生成的`binary`文件复制到目标系统并运行它：
- en: '[PRE44]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The debug output is verbose and gives more context to find the root cause of
    the issue.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 调试输出冗长，并提供更多上下文以找到问题的根本原因。
- en: How it works...
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In this recipe, we added logging using the standard logging tool, `syslog`.
    Firstly, we initialized our logging by using a call to `openlog`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们使用标准日志记录工具`syslog`添加了日志记录。首先，我们通过调用`openlog`来初始化我们的日志记录：
- en: '[PRE45]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, we added logging to the `runner` function. There are different logging
    levels that facilitate the filtering of log messages, from most severe to least
    severe. We log the `delta` value, which indicates how long the function that the
    runner invokes actually runs for, using the `LOG_DEBUG` level:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将日志记录添加到`runner`函数中。有不同的日志记录级别，可以方便地过滤日志消息，从最严重到最不严重。我们使用`LOG_DEBUG`级别记录`delta`值，该值表示`runner`调用的函数实际运行的时间有多长：
- en: '[PRE46]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This level is used to log detailed information that is helpful for application
    debugging but might prove to be too verbose when running applications in production.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 此级别用于记录对应用程序调试有用的详细信息，但在生产环境中运行应用程序时可能会过于冗长。
- en: 'If the delta, however, exceeds the limit, we log this situation using the `LOG_ERR` level
    to indicate that this situation should not normally happen and that it is an error:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果`delta`超过限制，我们将使用`LOG_ERR`级别记录此情况，以指示通常不应发生此情况并且这是一个错误：
- en: '[PRE47]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Before returning from the application, we close the logging to make sure that
    all the log messages are properly saved:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在从应用程序返回之前，我们关闭日志记录以确保所有日志消息都得到适当保存：
- en: '[PRE48]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'When we run the application on the target system, we can see our log messages
    on the screen:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在目标系统上运行应用程序时，我们可以在屏幕上看到我们的日志消息：
- en: '![](img/fee9835c-ae1e-48c7-ac4c-7d5061ab539c.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fee9835c-ae1e-48c7-ac4c-7d5061ab539c.png)'
- en: 'Since we use standard Linux logging, we can find the messages in the system
    logs as well:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用标准的Linux日志记录，我们也可以在系统日志中找到消息：
- en: '![](img/2aafea69-e7e5-4925-a431-9efec515aca3.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2aafea69-e7e5-4925-a431-9efec515aca3.png)'
- en: As you can see, logging is not hard to implement, but it is extremely helpful
    in finding the root causes of various issues in your application during debugging
    and normal operation.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，记录并不难实现，但在调试和正常操作期间，它对于找出应用程序中各种问题的根本原因非常有帮助。
- en: There's more...
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are a number of logging libraries and frameworks that may be more suitable
    for particular tasks than the standard logger; for example, *Boost.Log*, at [https://theboostcpplibraries.com/boost.log](https://theboostcpplibraries.com/boost.log),
    and *spdlog*, at [https://github.com/gabime/spdlog](https://github.com/gabime/spdlog).
    They provide a more convenient C++ interface compared to the generic C interface
    of `syslog`. When starting work on your project, check existing logging libraries
    and pick the one that best suits your requirements.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多日志记录库和框架，可能比标准记录器更适合特定任务；例如，*Boost.Log*，网址为[https://theboostcpplibraries.com/boost.log](https://theboostcpplibraries.com/boost.log)，以及*spdlog*，网址为[https://github.com/gabime/spdlog](https://github.com/gabime/spdlog)。它们提供了比`syslog`的通用C接口更方便的C++接口。在开始项目工作时，请检查现有的日志记录库，并选择最适合您要求的库。
- en: Working with debug and release builds
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用调试和发布构建
- en: As we learned in the preceding recipe, logging has costs associated with it.
    It introduces delays to format log messages and writes them to persistent storage
    or a remote system.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的食谱中所学到的，记录会带来相关成本。它会延迟格式化日志消息并将其写入持久存储或远程系统。
- en: Using log levels helps to reduce the overhead by skipping the writing of some
    messages to the log file. However, the message is usually being formatted before
    passing to a `log` function. For example, in the case of a system error, a developer
    wants to add an error code reported by the system to the log message. Although
    string formatting is generally less expensive than writing data to a file, it
    might still be an issue for highly-loaded systems or systems with limited resources.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 使用日志级别有助于通过跳过将一些消息写入日志文件来减少开销。但是，在将消息传递给`log`函数之前，消息通常会被格式化。例如，在系统错误的情况下，开发人员希望将系统报告的错误代码添加到日志消息中。尽管字符串格式化通常比将数据写入文件要便宜，但对于负载高的系统或资源有限的系统来说，这可能仍然是一个问题。
- en: Debug symbols added by a compiler do not add runtime overhead. However, they
    increase the size of the resulting binary. Moreover, performance optimizations
    made by the compiler can make interactive debugging difficult.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器添加的调试符号不会增加运行时开销。但是，它们会增加生成二进制文件的大小。此外，编译器进行的性能优化可能会使交互式调试变得困难。
- en: In this recipe, we will learn how to avoid runtime overheads by separating debug
    and release builds and using the C pre-processor macros.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何通过分离调试和发布构建并使用C预处理器宏来避免运行时开销。
- en: How to do it...
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We are going to modify build rules of the application we used in the preceding
    recipes to have two build targets—debug and release:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改我们在前面的食谱中使用的应用程序的构建规则，以拥有两个构建目标——调试和发布：
- en: Go to your work directory, `~/test`, and make a copy of the `loop2` project
    directory. Name the copy `loop3`. Change directory to `loop3`.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到您的工作目录`~/test`，并复制`loop2`项目目录。将副本命名为`loop3`。切换到`loop3`目录。
- en: 'Use your text editor to open the `CMakeLists.txt` file. Replace the following
    line:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用文本编辑器打开`CMakeLists.txt`文件。替换以下行：
- en: '[PRE49]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The preceding line needs to be replaced with the following lines:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的行需要替换为以下行：
- en: '[PRE50]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Use your text editor to open the `loop.cpp` file. Modify the file by adding
    the highlighted lines:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用文本编辑器打开`loop.cpp`文件。通过添加突出显示的行来修改文件：
- en: '[PRE51]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Switch to the build system terminal. Go to the `/mnt/loop3` directory and run
    the following code:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到构建系统终端。转到`/mnt/loop3`目录并运行以下代码：
- en: '[PRE52]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Copy the resulting `loop` binary file to the target system and run it:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将生成的`loop`二进制文件复制到目标系统并运行它：
- en: '[PRE53]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As you can see, the application does not generate any debug output. Let''s
    now check its size using the `ls -l` command:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，该应用程序不会生成任何调试输出。现在让我们使用`ls -l`命令检查其大小：
- en: '[PRE54]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The size of the resulting binary is 24 KB. Now, let''s build the `Debug` build
    and effect a comparison as shown here:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成的二进制文件的大小为24 KB。现在，让我们构建`Debug`构建并进行如下比较：
- en: '[PRE55]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Check the size of the executable file:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查可执行文件的大小：
- en: '[PRE56]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The size of the executable is now 80 KB. It is more than three times bigger
    than the release build. Run it the same way as before:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可执行文件的大小现在是80 KB。它比发布构建大三倍以上。像以前一样运行它：
- en: '[PRE57]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As you can see, the output is now different.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，输出现在不同了。
- en: How it works...
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We start with the copy of the project we used for the *Adding debug logging*
    recipe and create two distinct build configurations:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从用于*添加调试日志*食谱的项目副本开始，并创建两个不同的构建配置：
- en: '**Debug**: A configuration with interactive debugging and debug logging support'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试**：具有交互式调试和调试日志支持的配置'
- en: '**Release**: A highly optimized configuration that has all debug support disabled
    at compile time'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布**：高度优化的配置，在编译时禁用了所有调试支持'
- en: To implement it, we utilize the functionality provided by `CMake`. It supports
    different built types out of the box. We only need to define compile options for
    release and debug builds separately.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现它，我们利用了`CMake`提供的功能。它支持开箱即用的不同构建类型。我们只需要分别为发布和调试构建定义编译选项。
- en: 'The only build flag we define for the release build is the C++ standard to
    use. We explicitly require the code to conform to the C++11 standard:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为发布构建定义的唯一构建标志是要使用的C++标准。我们明确要求代码符合C++11标准：
- en: '[PRE58]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: For the debug build, we reuse the same flags as for the release build, referencing
    them as `${CMAKE_CXX_FLAGS_RELEASE}`, and adding two more options. `-g` instructs
    the compiler to add debug symbols to the target executable binary, and `-DDEBUG`
    defines a pre-processor macro, `DEBUG`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 对于调试构建，我们重用与发布构建相同的标志，将其引用为`${CMAKE_CXX_FLAGS_RELEASE}`，并添加两个选项。`-g`指示编译器向目标可执行二进制文件添加调试符号，而`-DDEBUG`定义了一个预处理宏`DEBUG`。
- en: We use the `DEBUG` macro in the code of `loop.cpp` to select between two different
    implementations of the `LOG_DEBUG` macro.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`loop.cpp`的代码中使用`DEBUG`宏来选择`LOG_DEBUG`宏的两种不同实现。
- en: If `DEBUG` is defined, `LOG_DEBUG` is expanded to the call of the `fprintf`
    function, which performs actual logging in the standard error channel. If, however,
    `DEBUG` is not defined, `LOG_DEBUG` is expanded to the empty string. This means
    that in this case, `LOG_DEBUG` does not produce any code, and hence does not add
    any runtime overhead.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义了`DEBUG`，`LOG_DEBUG`会扩展为调用`fprintf`函数，该函数在标准错误通道中执行实际的日志记录。然而，如果未定义`DEBUG`，`LOG_DEBUG`会扩展为空字符串。这意味着在这种情况下，`LOG_DEBUG`不会产生任何代码，因此不会增加任何运行时开销。
- en: We use `LOG_DEBUG` in the body of the runner function to log values of the actual
    delay and the limit. Note that there is no `if` around `LOG_DEBUG` – the decision
    to format and log data or do nothing is done not by our program when it runs,
    but by the code pre-processor when we build the application.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在运行函数的主体中使用`LOG_DEBUG`来记录实际延迟和限制的值。请注意，`LOG_DEBUG`周围没有`if` - 格式化和记录数据或不执行任何操作的决定不是由我们的程序在运行时做出的，而是由代码预处理器在构建应用程序时做出的。
- en: 'To select a build type, we invoke `cmake`, passing the name of the build type
    as a command-line parameter:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择构建类型，我们调用`cmake`，将构建类型的名称作为命令行参数传递：
- en: '[PRE59]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '`CMake` only generates a `Make` file to actually build the application we require
    in order to invoke `make`. We can combine these two commands in a single command
    line:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMake`只生成一个`Make`文件来实际构建我们需要调用`make`的应用程序。我们可以将这两个命令合并成一个单独的命令行：'
- en: '[PRE60]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'When we build and run our application for the first time, we select the release
    build. As a result, we do not see any debug output:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次构建和运行应用程序时，我们选择发布版本。因此，我们看不到任何调试输出：
- en: '![](img/55077ea0-cd5e-411c-82f1-286108dc17f0.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/55077ea0-cd5e-411c-82f1-286108dc17f0.png)'
- en: 'After that, we rebuild our application using the debug build type and see a
    different result when running it:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用调试构建类型重新构建我们的应用程序，并在运行时看到不同的结果：
- en: '![](img/719acbab-871a-4922-88e4-07915e394e61.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/719acbab-871a-4922-88e4-07915e394e61.png)'
- en: With debug and release builds, you can have sufficient information for comfortable
    debugging, but be sure that the production build won't have any unnecessary overhead.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调试和发布构建，您可以获得足够的信息进行舒适的调试，但请确保生产构建不会有任何不必要的开销。
- en: There's more...
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When switching between release and debug builds in a complex project, make sure
    that all the files were rebuilt properly. The easiest way to do this is by removing
    all the previous build files. When using `make`, this can be done by invoking
    the `make clean` command.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂项目中切换发布和调试构建时，请确保所有文件都已正确重建。最简单的方法是删除所有先前的构建文件。在使用`make`时，可以通过调用`make clean`命令来完成。
- en: 'It can be added as part of the command line along with `cmake` and `make`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以作为命令行的一部分与`cmake`和`make`一起添加：
- en: '[PRE61]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Combining all three commands into one line makes this more convenient for developers.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有三个命令合并成一行对开发人员更加方便。
