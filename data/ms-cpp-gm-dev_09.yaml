- en: Artificial Intelligence
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人工智能
- en: Most games are built on the concept of competing to win. This form of competition
    can take many forms. Since the earliest video games, players have found themselves
    competing against the machine. The inclusion of thinking, reacting, and challenging
    computer opponents makes games feel alive and connected to the player. In this
    chapter, we are going to learn how to add thinking to our games with the inclusion
    of artificial intelligence.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数游戏都建立在竞争取胜的概念上。这种形式的竞争可以采取多种形式。自最早的视频游戏以来，玩家们发现自己在与机器竞争。思考、反应和挑战计算机对手的加入使游戏感觉生动并与玩家联系在一起。在本章中，我们将学习如何通过引入人工智能来为我们的游戏增加思考。
- en: 'The following is covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下内容：
- en: What is game AI?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是游戏人工智能？
- en: Making decisions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 做决定
- en: Motion and pathfinding techniques
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运动和寻路技术
- en: What is game AI?
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是游戏人工智能？
- en: Often misunderstood, defining what game artificial intelligence is and, for
    that matter, what game AI is not is a very challenging endeavor. With such an
    encompassing field as AI, it would be very easy to fill many volumes of books
    on the subject. Given we only have a chapter to discuss the concept and implementation,
    in this section we are going to do our best to develop a reasonable definition
    of what game AI is and what it is not.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 往往被误解的游戏人工智能的定义，以及游戏人工智能不是一项非常具有挑战性的任务。在AI这样一个广泛的领域中，很容易在这个主题上填满许多卷的书。鉴于我们只有一个章节来讨论这个概念和实施，在本节中，我们将尽力发展一个合理的游戏人工智能的定义以及它不是什么。
- en: Defining game AI
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义游戏人工智能
- en: As mentioned, defining exactly what game AI is can be a difficult task, but
    I am going to do my best to describe what I feel is a concise interpretation when
    it comes to electronic video games. When a designer creates a game world, they
    do so by sculpting a vision and defining some common rules for interaction in
    that world. Typically, players will experience this world through the observation
    of the world's elements. Interactions, such as with the world's NPCs, opponents,
    and environments, and through narrative aspects, give the player a sense of immersion
    in the game's world. These interactions can take many shapes and forms. In games,
    players constantly have some interaction with the world through inanimate objects,
    but it's the interactions with other people that really stands out. It's what
    makes the game feel more immersive, more tangible, and more alive.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，确切地定义游戏人工智能是一项艰巨的任务，但我将尽力描述我认为是关于电子视频游戏的简明解释。当设计师创建游戏世界时，他们通过塑造愿景和定义一些常见的互动规则来实现。通常，玩家将通过观察世界的元素来体验这个世界。与世界的NPC、对手和环境的互动，以及通过叙事方面，给玩家一种沉浸在游戏世界中的感觉。这些互动可以采取许多形式。在游戏中，玩家不断通过与无生命的物体互动来体验世界，但与其他人的互动才是真正突出的。这使得游戏感觉更具沉浸感、更具触感和更有生命力。
- en: The sensation of something in the game world feeling alive generally comes through
    the observations of the game world and objects, such as an NPC making decisions.
    This is a great flag in the search to find a definition for game AI. In a broader
    sense, AI can be thought of as the application of this perceived decision-making.
    Commonly, this perception of decision-making comes in the form of an autonomous
    AI agent, for example, the common NPC. These decisions might include anything
    from movement, dialog choices, or even changes to the environment that might convey
    the experience the developer is attempting to create. This again is another flag
    for me when defining game AI. In essence, it is about the experience the developer
    is trying to create. To that end, game AI is more about an approximation of getting
    a desired effect, not necessarily a perfect scientific interpretation.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏世界中某物感觉活灵活现通常是通过对游戏世界和物体的观察来实现的，比如NPC做出决定。这是寻找游戏人工智能定义的一个重要标志。在更广泛的意义上，人工智能可以被认为是这种感知决策的应用。通常，这种决策的感知以自主的人工智能代理的形式出现，例如常见的NPC。这些决定可能包括从移动、对话选择，甚至对环境的改变，这些改变可能传达开发者试图创造的体验。这再次是我在定义游戏人工智能时的另一个标志。本质上，这是关于开发者试图创造的体验。因此，游戏人工智能更多地是关于近似实现期望效果，而不一定是完美的科学解释。
- en: It is important that when developers are setting out to create an AI experience,
    they do it with the key aspects of the player's fun and immersion in mind. No
    one wants to play against the perfect opponent. We want to perceive intelligence
    on the other end of the interaction, we just don't want it to be smarter. This
    is where developing game AI and the field of general AI development starts to
    become at odds. We will dive deeper into this diversion in the next section, but
    for now, let's look at some uses of AI in game development.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者着手创建人工智能体验时，重要的是要牢记玩家的乐趣和沉浸感。没有人想要与完美的对手对战。我们希望在互动的另一端感知到智能，只是不希望它更聪明。这就是游戏人工智能的开发和通用人工智能发展领域开始产生分歧的地方。我们将在下一节深入探讨这种分歧，但现在让我们看看游戏开发中人工智能的一些用途。
- en: Conversations
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对话
- en: Games that have some sort of interaction through dialog tend to give a sense
    of immersion in a world through how the characters' connect with the player and
    how the player becomes invested in their story. This, however, has been a challenge,
    and is often implemented, as we looked at in the last chapter, through dialog
    trees. This dialog tree approach, while solid in some situations, can easily grow
    in complexity.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对话进行某种形式的互动的游戏往往通过角色与玩家的连接以及玩家对他们故事的投入来给人一种沉浸在世界中的感觉。然而，这是一个挑战，通常是通过对话树来实现的，正如我们在上一章中所看到的。这种对话树的方法，在某些情况下是可靠的，但很容易变得复杂。
- en: Another issue with completely scripted conversations is, as the conversation
    continues over time, the player is quickly taken out of the illusion that this
    is an intelligent interaction. It makes the interaction feel constrained and in
    turn makes the world also feel constraining. One way to battle this issue is to
    introduce AI into the conversations. You could have scripted interactions augmented
    with decision-making algorithms to give a feeling of deeper intelligence in the
    responses. On the extreme side of this concept, you could employ a method of parsing
    player input and custom generating responses on the fly. An approach such as this
    would likely include what is referred to as **Natural Language Processing** (**NLP**).
    By utilizing something akin to a chatbot, designers and engineers can create worlds
    populated by agents that think when responding to user interactions. While this
    might sound extremely tempting, the field of Natural Language Processing is still
    considered to be in its infancy. With APIs powered by cloud computing, such as
    Microsoft's Cognitive Services APIs, the processes of creating the infrastructure
    to support NLP is getting easier. However, proper implementation and training
    of the language models can be quite time-consuming.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 完全脚本化对话的另一个问题是，随着对话随着时间的推移而继续，玩家很快就会摆脱这是一种智能互动的幻觉。这使得互动感觉受限，反过来也使得世界感觉受限。解决这个问题的一种方法是在对话中引入人工智能。您可以使用决策算法来增强脚本化的互动，从而在回应中给人一种更深层次的智能感。在这个概念的极端方面，您可以采用一种解析玩家输入并动态生成回应的方法。这样的方法可能包括所谓的**自然语言处理**（**NLP**）。通过利用类似于聊天机器人的东西，设计师和工程师可以创建由在用户互动时思考的代理人所居住的世界。虽然这听起来可能非常诱人，但自然语言处理领域仍被认为处于起步阶段。借助云计算提供动力的API，如微软的认知服务API，创建支持NLP的基础设施的过程变得更加容易。然而，适当的实施和语言模型的培训可能非常耗时。
- en: Competitive opponents
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 竞争对手
- en: A lot of games include the concept of enemies or competitive opponents for players
    to interact with. I would, in fact, say this is what most folks would think of
    as an example of game AI. How these opponents interact with the player, their
    environment, and other AI-controlled opponents is all part of their AI design.
    Often, this AI design will include concepts of decision-making, such as behavior
    trees, feedback loops, states, and other patterns. They will also often include
    other AI components such as motion algorithms and pathfinding techniques, both
    of which we will cover in more depth later in the chapter. Creating fun yet challenging
    opponents is not an easy task. As I stated earlier, no one wants to play a game
    where they feel they have no chance of winning. Having an AI that is constantly
    quicker and smarter than the player should not be the goal of designing an opponent
    AI; you should instead focus on giving the user a competitive AI that could potentially
    scale to meet the growing skill of the player. It's in this light where advanced
    techniques, such as using machine learning to build adaptive AI, are starting
    to gain traction. Although these techniques are still in their exploratory phases,
    the day of tailored AI opponents could soon be near.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 许多游戏包括敌人或竞争对手的概念，供玩家进行互动。事实上，我会说这是大多数人会认为是游戏人工智能的一个例子。这些对手如何与玩家、他们的环境和其他由AI控制的对手互动，都是他们的人工智能设计的一部分。通常，这种人工智能设计将包括决策制定的概念，如行为树、反馈循环、状态和其他模式。它们通常还会包括其他人工智能组件，如运动算法和路径规划技术，我们稍后将更深入地介绍。创建有趣而具有挑战性的对手并不是一件容易的事。正如我之前所说，没有人想玩一个他们觉得没有赢的机会的游戏。拥有一个比玩家更快更聪明的人工智能不应该是设计对手人工智能的目标；相反，您应该专注于给用户一个有竞争力的人工智能，可能能够适应玩家不断增长的技能。正是在这种情况下，像使用机器学习来构建自适应人工智能这样的高级技术开始引起关注。尽管这些技术仍处于探索阶段，但定制人工智能对手的日子可能很快就会到来。
- en: Motion and pathfinding
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运动和路径规划
- en: Arguably, just as common as using AI for opponents is the concept of utilizing
    AI for motion and pathfinding. Using AI in motion includes the implementation
    of algorithms to handle the autonomous movement of game elements. Ideas such as
    steering, pursuit, and avoid are all concepts you can express in AI algorithms.
    Motion AI is also commonly implemented to handle simple collision avoidance. Pathfinding
    is the concept of using AI to find the most efficient or effective route when
    moving a game object from one location to the next. Algorithms such as **Dijkstra**
    and **A*** have been around since the sixties and have provided a staple for pathfinding
    AI development. We will dive deeper into motion and pathfinding algorithms and
    techniques later in this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，与使用人工智能作为对手一样常见的是利用人工智能进行运动和路径规划的概念。在运动中使用人工智能包括实施算法来处理游戏元素的自主移动。诸如转向、追逐和躲避等概念都可以在人工智能算法中表达。运动人工智能也常常用于处理简单的碰撞回避。路径规划是使用人工智能在将游戏对象从一个位置移动到另一个位置时找到最有效或最有效的路线的概念。自六十年代以来，**Dijkstra**和**A***等算法一直存在，并为路径规划人工智能的发展提供了支柱。我们将在本章后面更深入地探讨运动和路径规划算法和技术。
- en: What game AI is not
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏人工智能不是什么
- en: Artificial intelligence, as a field of study, is very large, and really does
    include a lot more than what games use. As of late, discussions around AI in the
    developer space have become more expansive, with more and more developers looking
    for ways to leverage AI technologies lies in their projects. For this reason,
    I thought it would be important to touch on some of the more commonly known use
    cases for AI outside of the realms of game development.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能作为一个研究领域非常广泛，实际上包括的远不止游戏使用的内容。最近，围绕开发者空间中的人工智能的讨论变得更加广泛，越来越多的开发者寻求在其项目中利用人工智能技术的方法。因此，我认为重要的是要提及游戏开发领域之外一些更常见的人工智能用例。
- en: 'One of the hottest areas for AI outside of the game development is machine
    learning. **Machine learning** (**ML**) is probably best described by Arthur Lee
    Samuel, when he coined the term machine learning: *A computers ability to learn
    how to achieve an outcome or prediction without being explicitly programmed to
    do so.* Within the field of data analytics, machine learning is used as a method
    to devise complex models and algorithms that help forecast outcomes for a given
    problem. This is also known as predictive analytics. These analytical models allow
    researchers and data scientists to create reliable, repeatable computations and
    results and discover other insights through historical relationships and trends
    in the data. As mentioned in the previous section, the idea of tailored AI that
    learns from your play style and adapts is a very appealing concept. However, it
    can be a slippery slope; if the AI becomes too smart, then the game''s fun level
    can and will quickly drop. A good example of how ML is being used in gameplay
    is in the Forza racing game series. Here, racing AI avatars are processed in a
    cloud computing powered machine learning implementation to tailor the competitive
    level of the AI racers you encounter to your current ability level.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: AI领域中最热门的领域之一是机器学习。**机器学习**（**ML**）可能最好由Arthur Lee Samuel描述，当他创造了机器学习这个术语时：*计算机学习如何在没有明确编程的情况下实现结果或预测的能力。*在数据分析领域，机器学习被用作一种方法来设计复杂的模型和算法，帮助预测给定问题的结果。这也被称为预测性分析。这些分析模型允许研究人员和数据科学家创建可靠、可重复的计算和结果，并通过数据中的历史关系和趋势发现其他见解。正如前一节中提到的，定制AI从您的游戏风格中学习并适应的想法是非常吸引人的概念。然而，这可能是一个很棘手的问题；如果AI变得太聪明，那么游戏的乐趣水平就会迅速下降。机器学习在游戏中的使用的一个很好的例子是Forza赛车游戏系列。在这里，赛车AI头像通过云计算驱动的机器学习实现来调整您遇到的AI赛车手的竞争水平，以适应您当前的能力水平。
- en: Another growing use for AI outside of game development field is its implementation
    in data mining scenarios. While this area of AI is still in its early stages,
    its use in understanding user and customer data is extremely appealing to a lot
    of business sectors. The boundaries of this AI use case and its potential overlap
    with game development concepts have yet to be defined. However, some of the core
    components of data mining for understanding how players interact with a game and
    its various components can easily be seen as beneficial to game developers. Knowing
    exactly how players interact with elements such as the game GUI will allow developers
    to create better experiences for each user.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: AI在游戏开发领域之外的另一个不断增长的用途是其在数据挖掘场景中的应用。虽然这一领域的AI仍处于早期阶段，但其在理解用户和客户数据方面的应用对许多商业部门非常有吸引力。这种AI用例的边界及其与游戏开发概念的潜在重叠尚未被定义。然而，一些数据挖掘的核心组件，用于理解玩家如何与游戏及其各个组件进行交互，很容易被视为对游戏开发者有益。准确了解玩家如何与游戏GUI等元素进行交互，将使开发者能够为每个用户创造更好的体验。
- en: The last use case for AI outside of game development that I want to address
    is probably one of the most recognized uses when the average person thinks of
    AI, and that's the use of AI in the study of cognitive processing. In academic
    interpretations of AI, cognitive processing is the process of developing scientifically
    provable models for these processes. This can basically be summarized as the modeling
    of human intelligence in AI processes. While this approach is very important for
    scientific research, the current use cases for game development are still too
    far abstracted to be considered useful. That being said, the use of bots and NLP
    is starting to creep its way into game development, as mentioned.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要讨论的AI在游戏开发领域之外的最后一个用例可能是当普通人想到AI时最为认可的用途之一，那就是在认知处理研究中使用AI。在AI的学术解释中，认知处理是开发科学上可证明的这些过程的模型。这基本上可以概括为在AI过程中对人类智能进行建模。虽然这种方法对科学研究非常重要，但目前对游戏开发的用例来说还太过抽象，无法被认为是有用的。也就是说，机器人和自然语言处理的使用开始渗入游戏开发，正如前面提到的。
- en: Often, the specific goals of academic and research AI differ completely from
    game AI goals. This is because of inherent differences, such as the implementations
    and techniques used in each being completely different. More often, game AI solutions
    will favor a simplistic approach, allowing easy changes and tuning, whereas the
    research approach will more than likely opt for the most scientifically complete
    implementation. In the next sections, we will look at a few of these simpler game
    development implementations and discuss their use cases and theory.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 学术和研究AI的具体目标往往与游戏AI的目标完全不同。这是因为两者之间的实现和技术的固有差异完全不同。更多时候，游戏AI解决方案会倾向于简化方法，以便进行简单的更改和调整，而研究方法很可能会选择最科学完整的实现。在接下来的几节中，我们将看一些这些更简单的游戏开发实现，并讨论它们的用例和理论。
- en: Making decisions
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做决定
- en: More often, the goal of AI is to give the appearance of human intelligence.
    One of the key aspects to the perception of intelligence is the idea that the
    AI agent is making decisions. Having choice over certain actions, even if scripted,
    gives the player a feeling of a thinking world, populated by thinking entities.
    In the next section, we will cover some of the more well-known decision-making
    techniques in game AI.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: AI的目标更多地是给人类智能的外观。智能感知的关键方面之一是AI代理做出决策的想法。即使是脚本化的，对某些行动有选择权，给玩家一种思考世界的感觉，由思考实体构成。在下一节中，我们将介绍游戏AI中一些更为知名的决策制定技术。
- en: AI state machines
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AI状态机
- en: If you have been following through the book chapter by chapter, you may have
    noticed the use of the state pattern more than a few times. This pattern is a
    very powerful pattern, hence its common use throughout our various component designs.
    In the realm of artificial intelligence, the state pattern is again a shining
    star. The use of the state machine, specifically the **FSM** (**finite-state machine**),
    allows for the detailed representation of the code's execution flow. It is a perfect
    fit for the implementation of AI in games, allowing the design of powerful interactions
    without complex code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在按章节跟着这本书，你可能已经注意到状态模式的使用不止一次。这种模式是一个非常强大的模式，因此在我们各种组件设计中经常使用。在人工智能领域，状态模式再次成为一颗耀眼的明星。状态机的使用，特别是有限状态机（FSM），允许对代码的执行流程进行详细的表示。它非常适合在游戏中实现AI，允许设计强大的交互而不需要复杂的代码。
- en: I am not going to spend much time on the concept and theory of finite-state
    machine implementation, since we have covered it ad nauseam. Instead, we are going
    to look at an example of its implementation in an AI script. If you do need a
    refresher on the pattern, review the [Chapter 5](9379b574-a962-466b-9efe-d21b410c51c0.xhtml), *Building
    Gameplay Systems*, section on understanding states.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我不打算花太多时间来讨论有限状态机实现的概念和理论，因为我们已经详细覆盖了。相反，我们将看一个在AI脚本中实现它的例子。如果你需要对这种模式进行复习，请查看[第5章](9379b574-a962-466b-9efe-d21b410c51c0.xhtml)中关于理解状态的部分。
- en: 'The following is a diagram depicting the simple brain of an enemy. In this
    example, each state represents an action, such as search or attack:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个描述敌人简单大脑的图表。在这个例子中，每个状态代表一个动作，比如搜索或攻击：
- en: '![](img/b5527c00-1545-4e52-bce6-e5ed22d608fa.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5527c00-1545-4e52-bce6-e5ed22d608fa.png)'
- en: While this is a simple example, it does provide useful AI for many situations.
    We can implement this inside a game project using C++, as we have seen in the
    *Screen* example and elsewhere. However, if you have read through the previous
    chapter, you would have seen how we can implement logic such as this in a script.
    This, of course, allows us the flexibility of scripting, such as not having to
    rebuild the project to adjust the elements of the code. This is very beneficial
    for AI, so in this chapter I will be showing the example code using Lua scripts
    that can be implemented using the steps described in the previous chapter.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个简单的例子，但它确实为许多情况提供了有用的AI。我们可以在C++中实现这个项目，就像我们在*Screen*示例和其他地方看到的那样。然而，如果你已经阅读了前一章，你会看到我们可以在脚本中实现这样的逻辑。当然，这使我们能够灵活地进行脚本编写，比如不必重新构建项目来调整代码的元素。这对于AI来说非常有益，因此在本章中，我将展示使用Lua脚本的示例代码，这可以使用前一章中描述的步骤来实现。
- en: 'A possible implementation of this AI design in a Lua script could look something
    similar to the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在Lua脚本中，这种AI设计的可能实现可能看起来类似于以下内容：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This should look familiar to the NPC dialog example from the last chapter. Here,
    to complete the system, we would first load the script into an instance of an
    AI agent or NPC, and then call the `currentState` variable's currently-assigned
    function in the `Update` loop of the game code itself. With this code implementation,
    we have an effective way of building basic AI interactions. This technique has
    been around since the early days of game development. In fact, this would be a
    very similar implementation to the ghost opponents AI in the arcade classic, PAC-MAN.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该看起来很熟悉，就像上一章中的NPC对话示例。在这里，为了完成系统，我们首先会将脚本加载到AI代理或NPC的实例中，然后在游戏代码的`Update`循环中调用`currentState`变量当前分配的函数。通过这种代码实现，我们有了一种有效的构建基本AI交互的方法。这种技术自游戏开发的早期就存在。事实上，这与街机经典游戏《吃豆人》中的幽灵对手AI的实现非常相似。
- en: 'We can also expand on this simple FSM implementation and add a stack-based
    FSM into the solution. This is, again, much the same as the implementation example
    we saw in [Chapter 5](9379b574-a962-466b-9efe-d21b410c51c0.xhtml), *Building Gameplay
    Systems*, so I am not going to go through all the details about the theory of
    stack-based FSM. The basic principle of the stack-based FSM is that we can add
    to and remove our objects from the stack in a first in, last out order. The term
    commonly used for adding items to a stack is called pushing, and the removal of
    an object from the stack is called popping. So, for a state example, the stack
    would look something like the following diagram during the different functions:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以扩展这种简单的FSM实现，并将基于堆栈的FSM添加到解决方案中。这与[第5章](9379b574-a962-466b-9efe-d21b410c51c0.xhtml)中看到的实现示例非常相似，因此我不会详细介绍关于基于堆栈的FSM理论的所有细节。基于堆栈的FSM的基本原则是，我们可以按照先进后出的顺序向堆栈添加和移除对象。向堆栈添加项目的常用术语称为推送，从堆栈中移除对象的操作称为弹出。因此，对于状态示例，在不同的函数期间，堆栈可能看起来类似于以下图表：
- en: '![](img/8f905652-25f7-47ee-b792-c05b26056e84.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f905652-25f7-47ee-b792-c05b26056e84.png)'
- en: One of the major advantages of using a stack-based FSM is that you can now use
    the stack to control the current state. Each state can pop itself from the stack,
    allowing the execution of the next state. We can also implement the concept of
    *on entry* and *on exit*, allowing us to have states within states. We can do
    things such as set up and clean up in each state, giving us much more flexibility
    in our AI state system.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于堆栈的FSM的一个主要优势是，现在可以使用堆栈来控制当前状态。每个状态可以从堆栈中弹出自己，允许执行下一个状态。我们还可以实现“进入”和“退出”的概念，使我们能够在状态内部有更多的状态。我们可以在每个状态中进行设置和清理等操作，使我们的AI状态系统更加灵活。
- en: 'Implementing our states for a stack-based FSM in a Lua script might look something
    similar to the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在Lua脚本中实现基于堆栈的有限状态机（FSM）的状态可能看起来类似于以下内容：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, in our C++ code, we would add the rest of the architecture needed to
    power the state-based FSM. Here, we would create a vector or array object that
    would hold pointers to the state objects loaded in from the Lua script. We would
    then call the functions for `OnEnter`, `OnExit`, and `Update` for the state object
    currently occupying the last element in the array. As seen before, we could handle
    this by simply creating an enum and switching cases to handle the state flow.
    We could also go the route of creating a `StateList` class that would implement
    the required functions to wrap up the FSM. This `StateList` class, for our example,
    could look like the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的C++代码中，我们将添加其余的架构，以支持基于状态的FSM。在这里，我们将创建一个向量或数组对象，该对象将保存从Lua脚本中加载的状态对象的指针。然后，我们将调用`OnEnter`、`OnExit`和`Update`函数，用于当前占据数组中最后一个元素的状态对象。如前所述，我们可以通过简单创建一个枚举并切换案例来处理状态流。我们也可以创建一个`StateList`类，该类将实现包装FSM所需函数。对于我们的示例，这个`StateList`类可能如下所示：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Whichever way you choose to implement the state-based FSM, you will still get
    the added benefit of having the stack control in place. As you can see, the state
    pattern, when used in AI development, gives us a great, flexible starting point
    for creating AI interactions. Next, we will look at some other techniques to introduce
    decision-making into your AI design.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择以哪种方式实现基于状态的FSM，你仍然会获得堆栈控制的额外好处。正如你所看到的，状态模式在AI开发中使用时，为我们创建AI交互提供了一个伟大而灵活的起点。接下来，我们将看一些其他技术，介绍如何将决策引入到你的AI设计中。
- en: Decision trees
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 决策树
- en: 'A decision tree is a flowchart-like structure comprised of branches and leaves.
    Each branch of the tree is a conditional, where a decision is made. Each leaf
    is the action for the choice made in the conditional. At the farthest extents
    of the tree, the leaves are the actual commands that control the AI agent. Using
    a decision tree structure allows for easier design and understanding of the flow
    of the AI implementation. A simple AI brain implemented in a decision tree would
    look something similar to the following diagram:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 决策树是一种类似流程图的结构，由分支和叶子组成。树的每个分支都是一个条件，用于做出决策。每个叶子是在条件中做出的选择的动作。在树的最远端，叶子是控制AI代理的实际命令。使用决策树结构可以更容易地设计和理解AI实现的流程。在决策树中实现的简单AI大脑可能看起来类似于以下图表：
- en: '![](img/f564e89d-5d08-456f-8ce9-0844c823035f.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f564e89d-5d08-456f-8ce9-0844c823035f.png)'
- en: You might be thinking to yourself that this looks and sounds very much like
    the dialog trees we implemented in [Chapter 8](64a8360e-3372-4e98-bade-cab6ec948ea7.xhtml),
    *Advanced Gameplay Systems*. That is because they are! Just like in the case of
    working with dialog and choices, using a tree structure is a great way to script
    out the flow of an AI interaction. The decision trees can be extremely deep, with
    branches and nodes calling sub-trees which perform particular functions. This
    gives the designer the ability to use an extensive library of different decisions
    that can be chained together to provide a convincing depth of AI interaction.
    You can even go as far as developing branches that can be ordered by their overall
    desirability based on the current task, which could then fall back to other decisions,
    should the desired one fail. This resiliency and flexibility is where tree structures
    really stand out.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想到，这看起来和听起来非常像我们在[第8章](64a8360e-3372-4e98-bade-cab6ec948ea7.xhtml)中实现的对话树，*高级游戏系统*。那是因为它们就是！就像在处理对话和选择的情况下一样，使用树结构是脚本化AI交互流程的一种绝佳方式。决策树可以非常深，具有调用执行特定功能的子树的分支和节点。这使设计师能够使用大量不同的决策库，这些决策可以链接在一起，提供令人信服的AI交互深度。你甚至可以发展出可以根据当前任务的整体可取性排序的分支，然后在所需的分支失败时回退到其他决策。这种弹性和灵活性正是树结构的优势所在。
- en: Those familiar with data structures in C++ are probably already thinking about
    how this tree structure can be implemented in code. Maybe Lists are coming to
    mind. There are many different ways to implement a decision tree. We could define
    the tree in an external format, such as XML. We could implement it along with
    the structure and architecture with a mix of C++ and a scripting language such
    as Lua, but since I really want to drill home the understanding of the tree design,
    we are going put the entire implementation in Lua. A great example of how this
    can be accomplished is demonstrated by David Young in the book *Learning Game
    AI Programming with Lua*, so we are going to base our simple example on David's
    more detailed example.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉C++数据结构的人可能已经在考虑如何在代码中实现这种树结构。也许列表已经浮现在脑海中。有许多不同的实现决策树的方法。我们可以将树定义为外部格式，比如XML。我们可以使用C++和Lua等脚本语言的混合来实现它的结构和架构，但由于我真的想要深入理解树设计，我们将把整个实现放在Lua中。这可以通过David
    Young在书籍*使用Lua学习游戏AI编程*中演示的一个很好的例子来完成，所以我们将以David更详细的例子为基础，构建我们的简单示例。
- en: 'To start with, let''s look at the structure of the tree object. In the `DecisionTree.lua`
    file, we could have something like the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下树对象的结构。在`DecisionTree.lua`文件中，我们可以有以下代码：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, in our tree structure, we implement an update loop, which evaluates the
    root branch within the tree and processes the resulting action. Once the action
    has been created, processed, and finished, the decision tree will reevaluate itself
    starting again from the root branch to determine the next action to be executed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的树结构中，我们实现了一个更新循环，该循环评估树中的根分支并处理结果动作。一旦动作被创建、处理和完成，决策树将重新评估自身，从根分支重新开始确定下一个要执行的动作。
- en: 'Next up is the branch object. In our implementation, the branches will consist
    of a conditional that will determine which element will be executed next. It is
    the responsibility of the conditional evaluation to return a value that ranges
    from one to the maximum number of children in the branch. This will denote which
    element should be executed next. Our decision branch Lua class object will have
    basic functions for adding additional children as well as setting the conditional
    function used during the branch''s calculation. In the `DecisionBranch.lua` file,
    we could have an implementation that looks similar to the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是分支对象。在我们的实现中，分支将包括一个条件，该条件将确定接下来执行哪个元素。条件评估的责任是返回一个值，该值范围从分支中的子级的最大数量。这将表示应该执行哪个元素。我们的决策分支Lua类对象将具有基本函数，用于添加额外的子级以及在分支计算期间使用的设置条件函数。在`DecisionBranch.lua`文件中，我们可以有一个类似以下的实现：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As pointed out by David in his example, since leaves are simply actions, we
    can include each leaf action in the branches themselves. This allows us to get
    the needed functionality without the need for an additional structure in the code.
    With the use of the `type_ variable`, we can determine whether a child of the
    branch is another branch or an action that needs to be executed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如大卫在他的例子中指出的那样，由于叶子只是动作，我们可以将每个叶子动作包含在分支中。这使我们能够在代码中获得所需的功能，而无需额外的结构。通过使用`type_变量`，我们可以确定分支的子级是另一个分支还是需要执行的动作。
- en: For the evaluation of the branch itself, we execute the conditional and then
    use the returned value to determine the next step in the tree. It should be noted
    that every branch within the tree must eventually end with an action. If the tree
    has any leaves that do not end in actions, the tree is malformed and will not
    evaluate properly.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于分支本身的评估，我们执行条件，然后使用返回的值来确定树中的下一步。值得注意的是，树中的每个分支最终都必须以一个动作结束。如果树中有任何不以动作结束的叶子，那么树就是畸形的，将无法正确评估。
- en: 'Staying in the `DecisionBranch.lua` file, the code to evaluate the branch would
    look something like the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 留在`DecisionBranch.lua`文件中，评估分支的代码看起来类似以下内容：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now that we have the tree data structure in place, we can go ahead and build
    one for use. To do this, we first create a new instance of the decision tree,
    create each branch needed in the tree, connect the conditional branches, and finally
    add the action leaves. In the `AILogic.lua` file, we could have something similar
    to the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了树数据结构，我们可以继续构建一个供使用的树。为此，我们首先创建决策树的新实例，创建树中所需的每个分支，连接条件分支，最后添加动作叶子。在`AILogic.lua`文件中，我们可以有类似以下的内容：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With the decision tree in place, we could now call this script and load the
    tree into an AI agent object. We could make changes on the fly, add more decisions
    and actions, and even add in other AI techniques to augment the decisions. While
    a decision tree allows developers and designers to create easy to understand and
    read AI structures, it does have its drawbacks. One of the most notable drawbacks
    is its modeling of complicated logical conditions, where you need to account for
    each possible outcome of the condition. Also, with the larger number of branch
    possibilities, a tree will also start to have the need to be balanced. If this
    balancing does not occur, parts of the tree will need to be replicated, quickly
    increasing the complexity of the tree structure and leading to more bug-prone
    code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有了决策树，我们现在可以调用此脚本并将树加载到AI代理对象中。我们可以随时进行更改，添加更多决策和动作，甚至添加其他AI技术来增强决策。虽然决策树允许开发人员和设计师创建易于理解和阅读的AI结构，但它也有缺点。最显着的缺点之一是其对复杂逻辑条件的建模，其中您需要考虑条件的每种可能结果。此外，随着更多分支可能性的增加，树也将开始需要平衡。如果不进行平衡，树的部分将需要复制，迅速增加树结构的复杂性，并导致更容易出现错误的代码。
- en: Feedback loops
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反馈循环
- en: The last topic in AI decision-making I want to briefly touch on is the concept
    of feedback loops. A feedback loop is a situation where a certain output value
    of a system is fed or given back to the system which, in turn, influences the
    state of the system, affecting its subsequent value. Ideally, in video games,
    especially in AI interactions, every loop should be a stable feedback loop. A
    simple definition of a stable feedback loop is a situation where the output of
    the system is used to reverse the circumstances that caused the feedback value
    in the first place, making the feedback system move to the convergence of a stable
    state. This keeps your AI feedback from causing a runaway effect with a negative
    or positive feedback loop taking place.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我想简要谈一下AI决策中的最后一个主题，即反馈循环的概念。反馈循环是指系统的某个输出值被反馈或返回给系统，进而影响系统的状态，影响其后续值。理想情况下，在视频游戏中，特别是在AI交互中，每个循环都应该是一个稳定的反馈循环。稳定反馈循环的简单定义是系统的输出用于扭转导致反馈值的情况，使反馈系统移动到稳定状态的收敛。这可以防止您的AI反馈引起负面或正面反馈循环的失控效应。
- en: 'To help you understand what a feedback loop really is, let''s take an example
    most commonly seen in video games, stamina. Stamina is seen in many scenarios
    such as a character''s ability to sprint or run, or a character''s ability to
    climb. In our example, we will look at the example of a boxing match. The following
    is a diagram showing the feedback loop we want to implement:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您真正理解反馈循环是什么，让我们以视频游戏中最常见的例子来说明，即耐力。耐力在许多场景中都有体现，比如角色奔跑或奔跑的能力，或者角色攀爬的能力。在我们的例子中，我们将看一下拳击比赛的例子。以下是一个显示我们想要实现的反馈循环的图表：
- en: '![](img/3a09fb51-5a12-447c-8e09-6f492d48f86b.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3a09fb51-5a12-447c-8e09-6f492d48f86b.png)'
- en: As stated previously, we need to make sure the stamina feedback loop for our
    boxing example is stable. This means that when we reach a predefined low level
    of stamina, we need to switch the loop to defending, allowing us to recover stamina.
    If we reach a predefined replenished level, we do the opposite and switch to attacking
    to reduce the stamina level. This switching allows us to keep the loop stable
    and is referred to as an oscillating feedback loop.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们需要确保拳击示例中的耐力反馈循环是稳定的。 这意味着当我们达到预定义的低耐力水平时，我们需要将循环切换到防守，以便我们恢复耐力。 如果达到预定义的恢复水平，我们则相反地切换到进攻以降低耐力水平。
    这种切换允许我们保持循环稳定，并被称为振荡反馈循环。
- en: 'To implement this in code is surprisingly simple:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中实现这一点是令人惊讶地简单：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That is it, honestly. It is not complicated to code the implementation of this
    technique. We did skip over a few things, like how to handle reducing and increasing
    stamina. Considering this is in an AI system, we want it to appear more realistic,
    so it wouldn't be great to just increase these values statically. Finding a good
    random value to put in place here could give it a more realistic feel. Ultimately,
    this is an easy to implement technique which provides a nice way to vary outcomes
    and provides a more unique interaction with AI components.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，老实说。 编写这种技术的实现并不复杂。 我们确实跳过了一些事情，比如如何处理减少和增加耐力。 考虑到这是一个AI系统，我们希望它看起来更真实，因此静态地增加这些值并不是很好。
    在这里放置一个好的随机值可以使其更具真实感。 最终，这是一种易于实现的技术，可以提供一种很好的方式来改变结果，并为AI组件提供更独特的交互。
- en: Motion and pathfinding techniques
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运动和路径规划技术
- en: AI agents and other non-player characters quite often need to move around the
    game world. Implementing this movement so that it appears in a lifelike fashion
    is a challenging process. In the next section, we will look at how we can implement
    algorithms and techniques to add AI agent movement and pathfinding to our game
    development projects.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: AI代理和其他非玩家角色经常需要在游戏世界中移动。 实现这种移动，使其看起来像是真实的，是一个具有挑战性的过程。 在下一节中，我们将看看如何实现算法和技术，以将AI代理的移动和路径规划添加到我们的游戏开发项目中。
- en: Motion algorithms and techniques
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运动算法和技术
- en: Using motion algorithms to control an AI agent's movements throughout a level
    or game world is a very common use case for AI algorithms in video games. These
    algorithms can implement behaviors to give the impression of a thinking and reacting
    AI agent, and they can also perform other tasks such as simple object avoidance.
    In the next section, we are going to look at a few of these motion techniques.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用运动算法来控制AI代理在关卡或游戏世界中的移动是视频游戏中AI算法的一个非常常见的用例。 这些算法可以实现行为，给人以思考和反应的AI代理的印象，它们还可以执行其他任务，如简单的物体避让。
    在下一节中，我们将看一些这些运动技术。
- en: Steering behaviors
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转向行为
- en: Steering behaviors are a subset of motion algorithms comprised of various techniques
    for controlling the movement of the AI agent based on external and internal variables.
    In our example engine, we have already incorporated a 3D physics calculation library—refer
    back to [Chapter 5](9379b574-a962-466b-9efe-d21b410c51c0.xhtml), *Building Gameplay
    Systems*, for a refresher—and we already have a concept for an NPC class to act
    as our AI agent. This means we have a large part of the needed framework to create
    a Newtonian physics-based steering system, also known as a steering-based locomotion
    system. The steering-based locomotion system is comprised of a few different classifications
    for adding forces to an AI agent. These include the classifications of seeking,
    fleeing, evasion, wandering, pursuit, and a few more. The completely detailed
    implementations of these algorithms would take up chapters on their own, so instead
    we will focus on the high-level concepts and use cases for each algorithm. To
    help you out on the implementation side, I have included the `OpenSteer` library
    in the example engine. `OpenSteer` will handle the details of the calculations,
    making it easier for our engine and our AI Lua scripts to easily use these algorithms
    to control the agents' movements.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 转向行为是由各种技术组成的运动算法的子集，用于基于外部和内部变量控制AI代理的移动。 在我们的示例引擎中，我们已经整合了一个3D物理计算库-请参阅[第5章](9379b574-a962-466b-9efe-d21b410c51c0.xhtml)，“构建游戏系统”，进行复习-我们已经有了一个NPC类的概念，作为我们的AI代理。
    这意味着我们已经拥有了创建基于牛顿物理的转向系统所需框架的大部分内容，也称为基于转向的运动系统。 基于转向的运动系统由几个不同的分类组成，用于向AI代理添加力。
    这些包括寻找、逃避、规避、徘徊、追逐等分类。 这些算法的完全详细实现将占据自己的章节，因此我们将专注于每个算法的高级概念和用例。 为了帮助您在实现方面，我在示例引擎中包含了`OpenSteer`库。
    `OpenSteer`将处理计算的细节，使我们的引擎和我们的AI Lua脚本更容易使用这些算法来控制代理的移动。
- en: 'Following is a screenshot of an `OpenSteer` library program running a seek
    and evade algorithm:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是运行寻找和逃避算法的`OpenSteer`库程序的屏幕截图：
- en: '![](img/43b0b05a-2f94-4307-b446-e3279bd3c877.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43b0b05a-2f94-4307-b446-e3279bd3c877.png)'
- en: Seek
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找
- en: 'Let''s start with the seek algorithm. The seek algorithm''s goal is to steer
    the AI agent towards a specific position in the game space. This behavior applies
    force so that the current heading and the desired heading will align towards the
    target destination point. The following diagram describes this process:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从寻找算法开始。 寻找算法的目标是引导AI代理朝向游戏空间中的特定位置。 这种行为施加力，使当前航向和期望的航向朝向目标目的地对齐。 以下图表描述了这个过程：
- en: '![](img/f1d19952-67a0-4381-b46c-cda9dfd4ce6b.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1d19952-67a0-4381-b46c-cda9dfd4ce6b.png)'
- en: 'The **Desired Heading** is really a vector in the direction from the character
    to the target. The length of the **Desired Heading** could be set as a value,
    such as the character''s current speed. The steering vector or **Seek Path** is
    the difference between this desired heading and the character''s current heading.
    The equation for this can be simplified to something like the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**期望航向**实际上是一个从角色到目标的方向向量。**期望航向**的长度可以设置为一个值，比如角色当前的速度。转向向量或**寻找路径**是期望航向与角色当前航向的差。这个方程可以简化为以下形式：'
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'An interesting side effect of the seek algorithm is that if an AI agent continues
    to seek, it will eventually pass through the target, and then flip its direction
    to approach the target again. This produces a motion path that looks a bit like
    a moth buzzing around a light bulb. To use `OpenSteer` to calculate the steering
    force, you call the `steerForSeek` function, passing a 3-point vector to describe
    the target''s position:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找算法的一个有趣的副作用是，如果AI代理继续寻找，它最终会穿过目标，然后改变方向再次接近目标。这会产生一种看起来有点像蛾子围绕灯泡飞舞的运动路径。要使用`OpenSteer`来计算转向力，你需要调用`steerForSeek`函数，传递一个3点向量来描述目标的位置：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Flee
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '![](img/cc201d75-cfb0-4d7f-be36-63174f2b835b.png)'
- en: 'The flee steering behavior is simply the inverse of seek. Instead of working
    to align the heading to a specific target, the flee algorithm steers the AI agent''s
    heading to be aligned away from the target point. The desired heading, as such,
    points in the opposite direction. The following diagram shows this process:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/cc201d75-cfb0-4d7f-be36-63174f2b835b.png)'
- en: '![](img/248bf05a-120d-4975-97c3-1368cf84ca4d.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: 逃避
- en: 'To use `OpenSteer` to calculate the steering force for a fleeing AI agent,
    you call the `steerForFlee` function, passing a 3-point vector to describe the
    target''s position:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`OpenSteer`来计算逃避AI代理的转向力，你需要调用`steerForEvasion`函数，传递一个对象作为我们要逃避的目标，以及一个浮点值来指定在计算要施加的力时要使用的未来最大时间量：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Pursuit
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 追逐
- en: 'The pursuit steering behavior is very similar to the seek behavior, but the
    difference here is that the target point is actually a moving object or player.
    The following diagram illustrates this behavior:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 追逐转向行为与寻找行为非常相似，但这里的区别在于目标点实际上是一个移动的对象或玩家。下图说明了这个行为：
- en: '![](img/cc201d75-cfb0-4d7f-be36-63174f2b835b.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: 逃避
- en: In order to create effective pursuit behavior, we will need to do some predicting
    when it comes to the target's future position. One approach that we can take is
    to use a prediction method that we can revaluate in each update loop. In our simple
    predictor, we are going to make the assumption that our target will not turn during
    this update loop. While this assumption will more often be wrong, the predictor
    result will only be used for a fraction of a second (1/30). Which means that if
    a target does veer away, a quick correction based on the target changing direction
    will be calculated in the next simulation step. Also with this assumption, the
    position of a target that is X units of time in the future can be calculated by
    scaling its velocity by X and adding that offset to its current position. Then
    it is literally a matter of applying the seek steering behavior to the predicted
    target location to achieve the pursuit behavior.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建有效的追逐行为，我们需要对目标的未来位置进行一些预测。我们可以采取的一种方法是使用一个预测方法，在每次更新循环中重新评估。在我们简单的预测器中，我们将假设我们的目标在此更新循环中不会转向。虽然这种假设更容易出错，但预测结果只会在一小部分时间（1/30）内使用。这意味着，如果目标确实改变方向，下一个模拟步骤中将根据目标改变方向进行快速修正。同时，根据这个假设，可以通过将目标的速度乘以X并将该偏移添加到其当前位置来计算X单位时间内的目标位置。然后，只需将寻找转向行为应用于预测的目标位置，就可以实现追逐行为。
- en: 'To use `OpenSteer` to calculate the steering force for a pursuing AI agent,
    you call the `steerForPursuit` function, passing an object to use as the target
    we are pursuing:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`OpenSteer`来计算追逐AI代理的转向力，你需要调用`steerForPursuit`函数，传递一个对象作为我们要追逐的目标：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Evasion
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`OpenSteer`来计算逃避AI代理的转向力，你需要调用`steerForFlee`函数，传递一个3点向量来描述目标的位置：
- en: 'Much like flee is the opposite of seek, evasion is the opposite of pursuit.
    This means that instead of steering the AI agent toward the target''s calculated
    future position, we are instead fleeing from the target''s current position. The
    following diagram illustrates this behavior:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 逃避就像逃离是寻找的反向，逃避是追逐的反向。这意味着，我们不是朝着目标的计算未来位置驾驶AI代理，而是从目标的当前位置逃离。下图说明了这个行为：
- en: '![](img/d565e6ae-e0fc-4f4e-8276-c69a6bd33bc3.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d565e6ae-e0fc-4f4e-8276-c69a6bd33bc3.png)'
- en: When using evasion steering behavior, the AI agent will head away from the predicted
    point of interception. This can often result in a less than natural behavior,
    as most truly fleeing entities will likely have a random evasion pattern. One
    way to achieve a more natural effect would be to modify the force applied with
    another behavior, such as the wandering behavior we will touch on next.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用逃避转向行为时，AI代理将远离预测的相遇点。这通常会导致不太自然的行为，因为大多数真正逃离的实体可能会有一个随机的逃避模式。实现更自然效果的一种方法是修改施加的力与另一个行为，比如我们接下来将要介绍的漫游行为。
- en: 'To use `OpenSteer` to calculate the steering force for an evading AI agent,
    you call the `steerforEvasion` function, passing an object to use as the target
    we are evading, as well as a float value to specify the maximum amount of time
    in the future to use when calculating the force to apply:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 逃避行为就是寻找行为的反向。这意味着，AI代理不是朝着特定目标对齐航向，而是朝着目标点的相反方向对齐航向。下图说明了这个过程：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Wandering
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 漫游
- en: As I mentioned previously, sometimes it's better to have some fluctuation in
    a behavior by adding another behavior to modify the force. The wandering behavior
    is a great example of a modifying behavior. The wandering behavior basically returns
    a tangent steering force in relation to the agent's forward vector. It should
    be noted that, since the wandering behavior is meant to add some deviation to
    an agent's movement, it should not be used as a steering force all by itself.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，有时通过添加另一个行为来修改力来使行为有一些波动会更好。漫游行为是一个很好的修改行为的例子。漫游行为基本上返回一个与代理的前向矢量相关的切线转向力。值得注意的是，由于漫游行为旨在为代理的移动增加一些偏差，它不应该单独用作转向力。
- en: 'To use `OpenSteer` to calculate a wandering steering force for an AI agent,
    you call the `steerForWander` function, passing a float value to specify the time
    step between wanders. The time step value allows the wander rate to be consistent
    when frame times vary:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`OpenSteer`来为AI代理计算漫游转向力，你可以调用`steerForWander`函数，并传递一个浮点值来指定漫游之间的时间步长。时间步长值允许在帧时间变化时保持漫游速率一致：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: While that is all the time we can dedicate to AI steering behaviors in this
    book, we have only really begun to scratch the surface of what is available. Concepts
    like flocking and simple object avoidance are unfortunately outside of the scope
    of this chapter, but are fully supported by the `OpenSteer` library. If you are
    interested in learning more about these behaviors, I highly recommend reading
    through the `OpenSteer` documentation.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这本书中我们只能花这么多时间来研究AI转向行为，但我们只是开始了解可用的内容。像群集和简单的物体避让这样的概念不幸地超出了本章的范围，但是`OpenSteer`库完全支持这些概念。如果你有兴趣了解更多关于这些行为的内容，我强烈建议阅读`OpenSteer`文档。
- en: Search algorithms and pathfinding techniques
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索算法和路径规划技术
- en: In a lot of cases in games, we often need to find a path from one location to
    the next. Another very common need for AI in game development, and the last one
    we will touch on in this chapter, is the use of search algorithms to find optimal
    paths for moving around AI agents.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多游戏中，我们经常需要找到从一个位置到另一个位置的路径。游戏开发中人工智能的另一个非常常见的需求，也是本章将要涉及的最后一个需求，是使用搜索算法来寻找AI代理周围移动的最佳路径。
- en: 'For example, here we are going to focus on graph search algorithms. Graph search
    algorithms, as their name suggests, work with graphs as their source of data input.
    In our example of a map, the graph is a set of locations and the connections between
    them. These are often referred to as nodes and edges respectively. The following
    is an example of what very basic graph data might look like:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里我们将专注于图搜索算法。图搜索算法，顾名思义，使用图作为其数据输入的来源。在我们的地图示例中，图是一组位置和它们之间的连接。它们通常分别被称为节点和边。以下是一个非常基本的图数据可能看起来像的示例：
- en: '![](img/d09f3fab-ad19-4a00-ac89-5e885b73a3a2.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d09f3fab-ad19-4a00-ac89-5e885b73a3a2.png)'
- en: The output from these graph search algorithms can be used to develop the path
    needed to be taken by the AI agent. This path is made up of the graph's nodes
    and edges. It should be noted that the algorithms will tell your AI where to move,
    but it won't provide the how. These algorithms are not like the steer-force algorithms
    from earlier in the chapter, as they won't move the AI agent. However, combined
    with the steering algorithms, these pathfinding algorithms will create great overall
    AI behavior.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图搜索算法的输出可以用来制定AI代理需要采取的路径。这条路径由图的节点和边组成。值得注意的是，这些算法会告诉你的AI去哪里移动，但不会提供如何移动。这些算法不像本章前面的转向力算法，它们不会移动AI代理。然而，结合转向算法，这些路径规划算法将创建出色的整体AI行为。
- en: Now that we have a basic understanding of how graphs represent the map and the
    points we want to find paths between, let's look at some of the most common algorithms
    used.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对图是如何表示地图以及我们想要找到路径的点有了基本的了解，让我们来看一些最常用的算法。
- en: Breadth first
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广度优先
- en: 'The breadth first search is the simplest of search algorithms. It explores
    all directions equally. So how does it explore? Well, in all of these search algorithms,
    the key idea is to keep track of an expanding area, referred to as the frontier.
    The breadth first algorithm expands this frontier by moving out from the starting
    point and checking its neighbors first, then its neighbor''s neighbors, and so
    on. The following is a diagram showing how this expansion takes place on a grid.
    The numbers denote the order the grid square was visited:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先搜索是最简单的搜索算法。它平等地探索所有方向。那么它是如何探索的呢？在所有这些搜索算法中，关键思想是跟踪一个不断扩展的区域，称为前沿。广度优先算法通过从起点向外移动并首先检查其邻居，然后是邻居的邻居，依此类推来扩展这个前沿。以下是一个显示这种扩展在网格上发生的图表。数字表示网格方格被访问的顺序：
- en: '![](img/b90ad766-5e37-42ba-b7ff-2f12df3882f0.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b90ad766-5e37-42ba-b7ff-2f12df3882f0.png)'
- en: 'A simple example of how we can implement this in C++ follows. I have left out
    a few sections of code for the sake of space in the book. The full implementation
    can be found in the `Chapter09` example project, in the source code repository:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何在C++中实现这一点的一个简单示例。出于篇幅考虑，我省略了一些代码部分。完整的实现可以在源代码库的`Chapter09`示例项目中找到：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you may have noticed from the source code, one trick with this algorithm
    is we need to avoid doubling back and processing a node more than once. In this
    simple example, we implement an array of Boolean values of visited nodes. If we
    don't mark visited vertices in this example, we create an endless loop process.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从源代码中你可能已经注意到，这个算法的一个技巧是我们需要避免重复处理节点并多次处理一个节点。在这个简单的例子中，我们实现了一个布尔值数组来标记已访问的节点。如果我们不在这个例子中标记已访问的顶点，我们就会创建一个无限循环过程。
- en: This is an incredibly useful algorithm, not only for regular pathfinding but
    also for procedural map generation, flow field pathfinding, distance maps, and
    other types of map analysis.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常有用的算法，不仅适用于常规路径规划，还适用于程序地图生成、流场路径规划、距离图和其他类型的地图分析。
- en: Dijkstra's algorithm
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dijkstra算法
- en: 'In some cases, we will need to find the shortest path when each step can have
    different costs associated. For example, in the *Civilization* game series, moving
    through different land types requires different amounts of turns per movement.
    In cases like this, we can implement the Dijkstra''s algorithm, also known as
    a **Uniform Cost Search**. This algorithm lets us prioritize which paths to explore.
    Instead of exploring all possible paths equally, it favors the lower cost paths.
    In order to accomplish the prioritization of paths, we need to track movement
    costs. In essence, we want to take the movement costs into account when deciding
    how to evaluate each location. In this algorithm, we are going to need what is
    known as a priority queue or heap. Using a heap instead of a regular queue changes
    the way the frontier expands. The following is an excerpt of the example code
    that demonstrates the Dijkstra''s algorithm in C++, and I have again skipped over
    a few pieces for the sake of space. You can find the full Dijkstra example in
    the `Chapter09` folder of the source repository:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，当每一步都可能有不同的成本时，我们需要找到最短的路径。例如，在*文明*游戏系列中，穿越不同的地形类型需要不同数量的回合。在这种情况下，我们可以实现Dijkstra算法，也称为**统一成本搜索**。这个算法让我们可以优先考虑要探索的路径。它不是平等地探索所有可能的路径，而是偏向于成本较低的路径。为了实现路径的优先级，我们需要跟踪移动成本。实质上，我们希望在决定如何评估每个位置时考虑移动成本。在这个算法中，我们需要所谓的优先队列或堆。使用堆而不是常规队列会改变前沿的扩展方式。以下是C++中演示Dijkstra算法的示例代码摘录，为了节省空间，我再次省略了一些部分。您可以在源代码库的`Chapter09`文件夹中找到完整的Dijkstra示例：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This algorithm is great when finding the shortest path using different costs,
    but it does waste time exploring in all directions. Next, we will look at another
    algorithm that lets us find the shortest path to a single destination.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法在使用不同成本找到最短路径时非常好，但它确实浪费时间在所有方向上探索。接下来，我们将看看另一个算法，它让我们找到通往单一目的地的最短路径。
- en: A*
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: A*
- en: Arguably one of the best and most popular techniques used in pathfinding is
    the **A*** algorithm. A* is a modification of Dijkstra's algorithm that is optimized
    for a single destination. Where Dijkstra's algorithm can find paths to all locations,
    A* finds paths to one location. It prioritizes paths that seem to be leading closer
    to the goal. The implementation is very similar to the Dijkstra implementation,
    but the difference is in the use of a heuristic search function to augment the
    algorithm. This heuristic search is used to estimate the distance to the goal.
    What this amounts to is that A* uses the sum of a Dijkstra search and a heuristic
    search to calculate the fastest path to a certain point.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在路径规划中，可以说最好和最流行的技术之一是**A***算法。A*是Dijkstra算法的一种优化，适用于单一目的地。Dijkstra算法可以找到到所有位置的路径，而A*找到到一个位置的路径。它优先考虑似乎更接近目标的路径。实现非常类似于Dijkstra实现，但不同之处在于使用启发式搜索函数来增强算法。这种启发式搜索用于估计到目标的距离。这意味着A*使用Dijkstra搜索和启发式搜索的总和来计算到某一点的最快路径。
- en: 'The following is a great example of a pseudo-code implementation explaining
    the A* algorithm''s process, courtesy of Wikipedia ([https://en.wikipedia.org/wiki/A*_search_algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm)):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是维基百科提供的A*算法过程的伪代码示例，非常出色（[https://en.wikipedia.org/wiki/A*_search_algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm)）：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That wraps up our quick look at some of the more common pathfinding techniques.
    While we did see some implementation in this section, if you are looking for a
    great starting point for your production games, I would highly recommend looking
    at some of the open source libraries available. These are extremely valuable learning
    resources and provide proven implementation techniques you can build on.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们对一些常见路径规划技术的快速介绍。虽然在本节中我们看到了一些实现，但如果您正在寻找生产游戏的绝佳起点，我强烈建议您查看一些开源库。这些是非常有价值的学习资源，并提供了经过验证的实现技术，您可以在此基础上构建。
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered a large field of study in a short period of time.
    We developed a base definition of what game AI really is and, for that matter,
    what it is not. In this chapter, we also looked at expanding the decision-making
    functions with the inclusion of AI techniques. We covered how an AI agents' movements
    can be controlled through the use of steering forces and behavior. Finally, we
    capped off the chapter by looking at the use of pathfinding algorithms to create
    paths from point to point for our AI agents. While we did cover a fair amount
    in this chapter, there is still much more to be uncovered in the world of game
    AI. I implore you to continue your journey. In the next chapter, we will look
    at how we can add multiplayer and other network functionalities to our example
    game engine.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们在短时间内涵盖了一个广泛的研究领域。我们对游戏AI的真正定义进行了基本界定，以及它不是什么。在本章中，我们还探讨了如何通过包括AI技术来扩展决策功能。我们讨论了如何通过使用转向力和行为来控制AI代理的移动。最后，我们通过查看路径规划算法的使用来为我们的AI代理创建从一个点到另一个点的路径来结束了本章。虽然我们在本章中涵盖了相当多的内容，但在游戏AI的世界中仍有许多未被发掘的内容。我恳请您继续您的旅程。在下一章中，我们将看看如何将多人游戏和其他网络功能添加到我们的示例游戏引擎中。
