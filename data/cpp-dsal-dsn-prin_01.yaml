- en: 1\. Lists, Stacks, and Queues
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. 列表、栈和队列
- en: Learning Objectives
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够：
- en: Describe the importance of using the right data structure in any application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述在任何应用程序中使用正确数据结构的重要性
- en: Implement various built-in data structures, depending on the problem, to make
    application development easier
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据问题实现各种内置数据结构，以使应用程序开发更加简单
- en: Implement a custom linear data structure suited for given situations if the
    ones provided by C++ are not good enough for the use case
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果C++提供的数据结构不适合用例，实现适合特定情况的自定义线性数据结构
- en: Analyze real-life problems where different types of linear data structures are
    helpful and decide which one will be the most suitable for a given use case
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析现实生活中的问题，不同类型的线性数据结构如何有帮助，并决定哪种对于给定的用例最合适
- en: This chapter describes the importance of using the right data structures in
    any application. We will learn how to use some of the most common data structures
    in C++, as well as built-in and custom containers, using these structures.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了在任何应用程序中使用正确数据结构的重要性。我们将学习如何在C++中使用一些最常见的数据结构，以及使用这些结构的内置和自定义容器。
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: The management of data is one of the most important considerations to bear in
    mind while designing any application. The purpose of any application is to get
    some data as input, process or operate on it, and then provide suitable data as
    output. For example, let's consider a hospital management system. Here, we could
    have data about different doctors, patients, and archival records, among other
    things. The hospital management system should allow us to perform various operations,
    such as admit patients, and update the joining and leaving of doctors of different
    specialties. While the user-facing interface would present information in a format
    that is relevant to the hospital administrators, internally, the system would
    manage different records and lists of items.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计任何应用程序时，数据管理是需要牢记的最重要考虑因素之一。任何应用程序的目的都是获取一些数据作为输入，对其进行处理或操作，然后提供合适的数据作为输出。例如，让我们考虑一个医院管理系统。在这里，我们可能有关于不同医生、患者和档案记录等的数据。医院管理系统应该允许我们执行各种操作，比如接收患者，并更新不同专业医生的加入和离开情况。虽然用户界面会以对医院管理员相关的格式呈现信息，但在内部，系统会管理不同的记录和项目列表。
- en: A programmer has at their disposal several structures to hold any data in the
    memory. The choice of the right structure for holding data, also known as a **data
    structure**, is crucial for ensuring reliability, performance, and enabling the
    required functionalities in the application. Besides the right data structures,
    the right choice of algorithms to access and manipulate the data is also necessary
    for the optimal behavior of the application. This book shall equip you with the
    ability to implement the right data structures and algorithms for your application
    design, in order to enable you to develop well-optimized and scalable applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员可以使用多种结构来保存内存中的任何数据。选择正确的数据结构对于确保可靠性、性能和在应用程序中实现所需功能至关重要。除了正确的数据结构，还需要选择正确的算法来访问和操作数据，以实现应用程序的最佳行为。本书将使您能够为应用程序设计实现正确的数据结构和算法，从而使您能够开发出经过优化和可扩展的应用程序。
- en: This chapter introduces basic and commonly used linear data structures provided
    in C++. We will look at their individual designs, pros, and cons. We will also
    implement said structures with the help of exercises. Understanding these data
    structures will help you to manage data in any application in a more performant,
    standardized, readable, and maintainable way.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了C++中提供的基本和常用的线性数据结构。我们将研究它们的设计、优缺点。我们还将通过练习来实现这些结构。了解这些数据结构将帮助您以更高效、标准化、可读和可维护的方式管理任何应用程序中的数据。
- en: Linear data structures can be broadly categorized as contiguous or linked structures.
    Let's understand the differences between the two.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 线性数据结构可以广泛地分为连续或链式结构。让我们了解一下两者之间的区别。
- en: Contiguous Versus Linked Data Structures
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连续与链式数据结构
- en: Before processing the data in any application, we must decide how we want to
    store data. The answer to that question depends on what kind of operations we
    want to perform on the data and the frequency of the operations. We should choose
    the implementation that gives us the best performance in terms of latency, memory,
    or any other parameter, without affecting the correctness of the application.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理任何应用程序中的数据之前，我们必须决定如何存储数据。对这个问题的答案取决于我们想要对数据执行什么样的操作以及操作的频率。我们应该选择能够在延迟、内存或任何其他参数方面给我们最佳性能的实现，而不影响应用程序的正确性。
- en: A useful metric for determining the type of data structure to be used is algorithmic
    complexity, also called **time complexity**. Time complexity indicates the relative
    amount of time required, in proportion to the size of the data, to perform a certain
    operation. Thus, time complexity shows how the time will vary if we change the
    size of the dataset. The time complexity of different operations on any data type
    is dependent on how the data is stored inside it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 确定要使用的数据结构类型的一个有用的度量标准是算法复杂度，也称为时间复杂度。时间复杂度表示执行某个操作所需的时间相对于数据大小的比例。因此，时间复杂度显示了如果我们改变数据集的大小，时间将如何变化。对于任何数据类型上的不同操作的时间复杂度取决于数据在其中的存储方式。
- en: 'Data structures can be divided into two types: contiguous and linked data structures.
    We shall take a closer look at both of them in the following sections.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构可以分为两种类型：连续和链式数据结构。我们将在接下来的章节中更仔细地看看它们。
- en: Contiguous Data Structures
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连续数据结构
- en: 'As mentioned earlier, **contiguous data structures** store all the elements
    in a single chunk of memory. The following diagram shows how data is stored in
    contiguous data structures:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，**连续数据结构**将所有元素存储在单个内存块中。下图显示了连续数据结构中数据的存储方式：
- en: '![](img/C14498_01_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14498_01_01.jpg)'
- en: 'Figure 1.1: Diagrammatic representation of contiguous data structures'
  id: totrans-20
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.1：连续数据结构的图示表示
- en: 'In the preceding diagram, consider the larger rectangle to be the single memory
    chunk in which all the elements are stored, while the smaller rectangles represent
    the memory allocated for each element. An important thing to note here is that
    all the elements are of the same type. Hence, all of them require the same amount
    of memory, which is indicated by `sizeof(type)`. The address of the first element
    is also known as the `BA + sizeof(type)` location, and the one after that is present
    in `BA + 2 * sizeof(type)`, and so on. Therefore, to access any element at index
    `i`, we can get it with the generic formula: `BA + i * sizeof(type)`.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，考虑较大的矩形是存储所有元素的单个内存块，而较小的矩形表示为每个元素分配的内存。这里需要注意的一点是，所有元素都是相同类型的。因此，它们都需要相同数量的内存，这由`sizeof(type)`表示。第一个元素的地址也被称为`BA
    + sizeof(type)`位置，其后的元素位于`BA + 2 * sizeof(type)`，依此类推。因此，要访问索引`i`处的任何元素，我们可以使用通用公式获取：`BA
    + i * sizeof(type)`。
- en: In this case, we can always access any element using the formula instantly,
    regardless of the size of the array. Hence, the access time is always constant.
    This is indicated by *O(1)* in the Big-O notation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以立即使用公式访问任何元素，而不管数组的大小如何。因此，访问时间始终是恒定的。这在大O符号中用*O(1)*表示。
- en: 'The two main types of arrays are static and dynamic. A static array has a lifetime
    only inside its declaration block, but a dynamic array provides better flexibility
    since the programmer can determine when it should be allocated and when it should
    be deallocated. We can choose either of them depending on the requirement. Both
    have the same performance for different operations. Since this array was introduced
    in C, it is also known as a C-style array. Here is how these arrays are declared:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的两种主要类型是静态和动态。静态数组仅在其声明块内存在，但动态数组提供了更好的灵活性，因为程序员可以确定何时应该分配它，何时应该释放它。根据需求，我们可以选择其中之一。对于不同的操作，它们的性能是相同的。由于这个数组是在C中引入的，它也被称为C风格数组。以下是这些数组的声明方式：
- en: A static array is declared as `int arr[size];`.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态数组声明为`int arr[size];`。
- en: A dynamic array in C is declared as `int* arr = (int*)malloc(size * sizeof(int));`.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C中声明动态数组为`int* arr = (int*)malloc(size * sizeof(int));`。
- en: A dynamic array is declared in C++ as `int* arr = new int[size];`.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++中声明动态数组为`int* arr = new int[size];`。
- en: A static array is aggregated, which means that it is allocated on the stack,
    and hence gets deallocated when the flow goes out of the function. On the other
    hand, a dynamic array is allocated on a heap and stays there until the memory
    is freed manually.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 静态数组是聚合的，这意味着它是在堆栈上分配的，因此在流程离开函数时被释放。另一方面，动态数组是在堆上分配的，并且会一直保留在那里，直到手动释放内存。
- en: Since all the elements are present next to each other, when one of the elements
    is accessed, a few elements next to it are also brought into the cache. Hence,
    if you want to access those elements, it is a very fast operation as the data
    is already present in the cache. This property is also known as cache locality.
    Although it doesn't affect the asymptotic time complexity of any operations, while
    traversing an array, it can give an impressive advantage for contiguous data in
    practice. Since traversing requires going through all the elements sequentially,
    after fetching the first element, the next few elements can be retrieved directly
    from the cache. Hence, the array is said to have good cache locality.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有元素都是相邻的，当访问其中一个元素时，它旁边的几个元素也会被带入缓存。因此，如果要访问这些元素，这是一个非常快速的操作，因为数据已经存在于缓存中。这个属性也被称为缓存局部性。虽然它不会影响任何操作的渐近时间复杂度，但在遍历数组时，对于实际上连续的数据，它可以提供令人印象深刻的优势。由于遍历需要顺序地遍历所有元素，获取第一个元素后，接下来的几个元素可以直接从缓存中检索。因此，该数组被认为具有良好的缓存局部性。
- en: Linked Data Structures
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链接数据结构
- en: 'Linked data structures hold the data in multiple chunks of memory, also known
    as nodes, which may be placed at different places in the memory. The following
    diagram shows how data is stored in linked data structures:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 链接数据结构将数据存储在多个内存块中，也称为节点，这些节点可以放置在内存的不同位置。下图显示了链接数据结构中数据的存储方式：
- en: '![](img/C14498_01_02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14498_01_02.jpg)'
- en: 'Figure 1.2: Linked data structures'
  id: totrans-32
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.2：链接数据结构
- en: In the basic structure of a linked list, each node contains the data to be stored
    in that node and a pointer to the next node. The last node contains a `NULL` pointer
    to indicate the end of the list. To reach any element, we must start from the
    beginning of the linked list, that is, the head, and then follow the next pointer
    until we reach the intended element. So, to reach the element present at index
    `i`, we need to traverse through the linked list and iterate `i` times. Hence,
    we can say that the complexity of accessing elements is *O(n)*; that is, the time
    varies proportionally with the number of nodes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在链表的基本结构中，每个节点包含要存储在该节点中的数据和指向下一个节点的指针。最后一个节点包含一个`NULL`指针，表示列表的结尾。要访问任何元素，我们必须从链表的开头，即头部开始，然后沿着下一个指针继续，直到达到预期的元素。因此，要到达索引`i`处的元素，我们需要遍历链表并迭代`i`次。因此，我们可以说访问元素的复杂度是*O(n)*；也就是说，时间与节点数成比例变化。
- en: 'If we want to insert or delete any element, and if we have a pointer to that
    element, the operation is really small and quite fast for a linked list compared
    to arrays. Let''s take a look at how the insertion of an element works in a linked
    list. The following diagram illustrates a case where we are inserting an element
    between two elements in a linked list:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要插入或删除任何元素，并且我们有指向该元素的指针，与数组相比，对于链表来说，这个操作是非常小且相当快的。让我们看看在链表中如何插入一个元素。下图说明了在链表中插入两个元素之间的情况：
- en: '![](img/C14498_01_03.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14498_01_03.jpg)'
- en: 'Figure 1.3: Inserting an element into a linked list'
  id: totrans-36
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.3：向链表中插入一个元素
- en: For insertion, once we've constructed the new node to be inserted, we just need
    to rearrange the links so that the next pointer of the preceding element *(i =
    1)* points to the new element *(i = 2)* instead of its current element *(i = 3)*,
    and the next pointer of the new element *(i = 2)* points to the current element's
    next element *(i = 3)*. In this way, the new node becomes part of the linked list.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于插入，一旦我们构造了要插入的新节点，我们只需要重新排列链接，使得前一个元素的下一个指针*(i = 1)*指向新元素*(i = 2)*，而不是当前元素的当前元素*(i
    = 3)*，并且新元素*(i = 2)*的下一个指针指向当前元素的下一个元素*(i = 3)*。这样，新节点就成为链表的一部分。
- en: Similarly, if we want to remove any element, we just need to rearrange the links
    so that the element to be deleted is no longer connected to any of the list elements.
    Then, we can deallocate that element or take any other appropriate action on it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们想要删除任何元素，我们只需要重新排列链接，使得要删除的元素不再连接到任何列表元素。然后，我们可以释放该元素或对其采取任何其他适当的操作。
- en: A linked list can't provide cache locality at all since the elements are not
    stored contiguously in memory. Hence, there's no way to bring the next element
    into the cache without actually visiting it with the pointer stored in the current
    element. So, although, in theory, it has the same time complexity for traversal
    as an array, in practice, it gives poor performance.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于链表中的元素不是连续存储在内存中的，所以链表根本无法提供缓存局部性。因此，没有办法将下一个元素带入缓存，而不是通过当前元素中存储的指针实际访问它。因此，尽管在理论上，它的遍历时间复杂度与数组相同，但在实践中，它的性能很差。
- en: The following section provides a summary of the comparison of contiguous and
    linked data structures.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分提供了关于连续和链式数据结构的比较总结。
- en: Comparison
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较
- en: 'The following table briefly summarizes the important differences between linked
    and contiguous data structures in general:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格简要总结了链式和连续数据结构之间的重要区别：
- en: '![](img/C14498_01_04.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14498_01_04.jpg)'
- en: 'Figure 1.4: Table comparing contiguous and linked data structures'
  id: totrans-44
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.4：比较连续和链式数据结构的表
- en: 'The following table contains a summary of the performance of arrays and linked
    lists regarding various parameters:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格包含了关于数组和链表在各种参数方面的性能总结：
- en: '![](img/C14498_01_05.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14498_01_05.jpg)'
- en: 'Figure 1.5: Table showing time complexities of some operations for arrays and
    linked lists'
  id: totrans-47
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.5：显示数组和链表某些操作的时间复杂度的表
- en: For any application, we can choose either data structure or a combination of
    both, based on the requirements and the frequencies of the different operations.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何应用程序，我们可以根据要求和不同操作的频率选择数据结构或两者的组合。
- en: Arrays and linked lists are very common and are extensively used in any application
    to store data. Hence, the implementation of these data structures must be as bug-free
    and as efficient as possible. To avoid reinventing the code, C++ provides various
    structures, such as `std::array`, `std::vector`, and `std::list`. We will see
    some of them in more detail in upcoming sections.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 数组和链表是非常常见的，广泛用于任何应用程序中存储数据。因此，这些数据结构的实现必须尽可能无缺陷和高效。为了避免重新编写代码，C++提供了各种结构，如`std::array`、`std::vector`和`std::list`。我们将在接下来的章节中更详细地看到其中一些。
- en: Limitations of C-style Arrays
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C风格数组的限制
- en: 'Though C-style arrays do the job, they are not commonly used. There are a number
    of limitations that indicate the necessity of better solutions. Some of the major
    limitations among those are as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然C风格的数组可以完成任务，但它们并不常用。有许多限制表明需要更好的解决方案。其中一些主要限制如下：
- en: Memory allocation and deallocation have to be handled manually. A failure to
    deallocate can cause a memory leak, which is when a memory address becomes inaccessible.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存分配和释放必须手动处理。未能释放可能导致内存泄漏，即内存地址变得不可访问。
- en: The `operator[]` function does not check whether the argument is larger than
    the size of an array. This may lead to segmentation faults or memory corruption
    if used incorrectly.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator[]`函数不会检查参数是否大于数组的大小。如果使用不正确，这可能导致分段错误或内存损坏。'
- en: The syntax for nested arrays gets very complicated and leads to unreadable code.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套数组的语法变得非常复杂，导致代码难以阅读。
- en: Deep copying is not available as a default function. It has to be implemented
    manually.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下不提供深拷贝功能，必须手动实现。
- en: To avoid these issues, C++ provides a very thin wrapper over a C-style array
    called `std::array`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些问题，C++提供了一个非常薄的包装器，称为`std::array`，覆盖了C风格数组。
- en: std::array
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: std::array
- en: '`std::array` automates the allocation and deallocation of memory. `std::array`
    is a templatized class that takes two parameters – the type of the elements and
    the size of the array.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::array`自动分配和释放内存。`std::array`是一个带有两个参数的模板类——元素的类型和数组的大小。'
- en: 'In the following example, we will declare `std::array` of `int` of size `10`,
    set the value of any of the elements, and then print that value to make sure it
    works:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们将声明大小为`10`的`int`类型的`std::array`，设置任何一个元素的值，然后打印该值以确保它能正常工作：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This example would produce the following output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将产生以下输出：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we can see, `std::array` provides `operator[]`, which is same as the C-style
    array, to avoid the cost of checking whether the index is less than the size of
    the array. Additionally, it also provides a function called `at(index)`, which
    throws an exception if the argument is not valid. In this way, we can handle the
    exception in an appropriate manner. So, if we have a piece of code where we will
    be accessing an element with a bit of uncertainty, such as an array index being
    dependent on user input, we can always catch the error using exception handling,
    as demonstrated in the following example.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`std::array`提供了`operator[]`，与C风格数组相同，以避免检查索引是否小于数组的大小的成本。此外，它还提供了一个名为`at(index)`的函数，如果参数无效，则会抛出异常。通过这种方式，我们可以适当地处理异常。因此，如果我们有一段代码，其中将访问一个具有一定不确定性的元素，例如依赖于用户输入的数组索引，我们总是可以使用异常处理来捕获错误，就像以下示例中演示的那样。
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Apart from that, passing `std::array` to another function is similar to passing
    any built-in data type. We can pass it by value or reference, with or without
    `const`. Additionally, the syntax doesn''t involve any pointer-related operations
    or referencing and de-referencing operations. Hence, the readability is much better
    compared to C-style arrays, even for multidimensional arrays. The following example
    demonstrates how to pass an array by value:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，将`std::array`传递给另一个函数类似于传递任何内置数据类型。我们可以按值或引用传递它，可以使用`const`也可以不使用。此外，语法不涉及任何指针相关操作或引用和解引用操作。因此，与C风格数组相比，即使是多维数组，可读性要好得多。以下示例演示了如何按值传递数组：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This example would produce the following output:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将产生以下输出：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can''t pass an array of any other size for this function, because the size
    of the array is a part of the data type of the function parameter. So, for example,
    if we pass `std::array<int, 10>`, the compiler will return an error saying that
    it can''t match the function parameter, nor can it convert from one to the other.
    However, if we want to have a generic function that can work with `std::array`
    of any size, we can make the size of the array templatized for that function,
    and it will generate code for all the required sizes of the array. So, the signature
    will look like the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能将任何其他大小的数组传递给这个函数，因为数组的大小是函数参数数据类型的一部分。因此，例如，如果我们传递`std::array<int, 10>`，编译器将返回一个错误，说它无法匹配函数参数，也无法从一个类型转换为另一个类型。然而，如果我们想要一个通用函数，可以处理任何大小的`std::array`，我们可以使该函数的数组大小成为模板化，并且它将为所需大小的数组生成代码。因此，签名将如下所示：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Apart from readability, while passing `std::array`, it copies all the elements
    into a new array by default. Hence, an automatic deep copy is performed. If we
    don't want that feature, we can always use other types, such as reference and
    `const` reference. Thus, it provides greater flexibility for programmers.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可读性之外，在传递`std::array`时，默认情况下会将所有元素复制到一个新数组中。因此，会执行自动深复制。如果我们不想要这个特性，我们总是可以使用其他类型，比如引用和`const`引用。因此，它为程序员提供了更大的灵活性。
- en: In practice, for most operations, `std::array` provides similar performance
    as a C-style array, since it is just a thin wrapper to reduce the effort of programmers
    and make the code safer. `std::array` provides two different functions to access
    array elements – `operator[]` and `at()`. `operator[]`, is similar to C-style
    arrays, and doesn't perform any check on the index. However, the `at()` function
    provides a check on the index, and throws an exception if the index is out of
    range. Due to this, it is a bit slower in practice.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，对于大多数操作，`std::array`提供与C风格数组类似的性能，因为它只是一个薄包装器，减少了程序员的工作量并使代码更安全。`std::array`提供两个不同的函数来访问数组元素——`operator[]`和`at()`。`operator[]`类似于C风格数组，并且不对索引进行任何检查。然而，`at()`函数对索引进行检查，如果索引超出范围，则抛出异常。因此，在实践中它会慢一些。
- en: 'As mentioned earlier, iterating over an array is a very common operation. `std::array`
    provides a really nice interface with the help of a range for loops and iterators.
    So, the code for printing all the elements in an array looks like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，迭代数组是一个非常常见的操作。`std::array`通过范围循环和迭代器提供了一个非常好的接口。因此，打印数组中所有元素的代码如下所示：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This example would show the following output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将显示以下输出：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding example, when we demonstrated printing out all of the elements,
    we iterated using an index variable, where we had to make sure that it was correctly
    used according to the size of the array. Hence, it is more prone to human error
    compared to this example.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，当我们演示打印所有元素时，我们使用了一个索引变量进行迭代，我们必须确保它根据数组的大小正确使用。因此，与这个示例相比，它更容易出现人为错误。
- en: The reason we can iterate over `std::array` using a range-based loop is due
    to iterators. `std::array` has member functions called `begin()` and `end()`,
    returning a way to access the first and last elements. To move from one element
    to the next element, it also provides arithmetic operators, such as the increment
    operator (`++`) and the addition operator (`+`). Hence, a range-based `for` loop
    starts at `begin()` and ends at `end()`, advancing step by step using the increment
    operator (`++`). The iterators provide a unified interface across all of the dynamically
    iterable STL containers, such as `std::array`, `std::vector`, `std::map`, `std::set`,
    and `std::list`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用范围循环迭代`std::array`是因为迭代器。`std::array`有名为`begin()`和`end()`的成员函数，返回访问第一个和最后一个元素的方法。为了从一个元素移动到下一个元素，它还提供了算术运算符，比如递增运算符(`++`)和加法运算符(`+`)。因此，范围循环从`begin()`开始，到`end()`结束，使用递增运算符(`++`)逐步前进。迭代器为所有动态可迭代的STL容器提供了统一的接口，比如`std::array`、`std::vector`、`std::map`、`std::set`和`std::list`。
- en: Apart from iterating, all the functions for which we need to specify a position
    inside the container are based on iterators; for example, insertion at a specific
    position, deletion of elements in a range or at a specific position, and other
    similar functions. This makes the code more reusable, maintainable, and readable.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 除了迭代之外，所有需要在容器内指定位置的函数都基于迭代器；例如，在特定位置插入、在范围内或特定位置删除元素以及其他类似的函数。这使得代码更具可重用性、可维护性和可读性。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: For all functions in C++ that specify a range with the help of iterators, the
    `start()` iterator is usually inclusive, and the `end()` iterator is usually exclusive,
    unless specified otherwise.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于C++中使用迭代器指定范围的所有函数，`start()`迭代器通常是包含的，而`end()`迭代器通常是排除的，除非另有说明。
- en: 'Hence, the `array::begin()` function returns an iterator that points to the
    first element, but `array::end()` returns an iterator just after the last element.
    So, a range-based loop can be written as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`array::begin()`函数返回一个指向第一个元素的迭代器，但`array::end()`返回一个指向最后一个元素之后的迭代器。因此，可以编写基于范围的循环如下：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There are some other forms of iterators, such as `const_iterator` and `reverse_iterator`,
    which are also quite useful. `const_iterator` is a `const` version of the normal
    iterator. If the array is declared to be a `const`, its functions that are related
    to iterators, such as `begin()` and `end()`, return `const_iterator`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他形式的迭代器，比如`const_iterator`和`reverse_iterator`，它们也非常有用。`const_iterator`是正常迭代器的`const`版本。如果数组被声明为`const`，与迭代器相关的函数（如`begin()`和`end()`）会返回`const_iterator`。
- en: '`reverse_iterator` allows us to traverse the array in the reverse direction.
    So, its functions, such as the increment operator (`++`) and `advance`, are inverses
    of such operations for normal iterators.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`reverse_iterator`允许我们以相反的方向遍历数组。因此，它的函数，如增量运算符（`++`）和`advance`，是正常迭代器的逆操作。'
- en: 'Besides the `operator[]` and `at()` functions, `std::array` also provides other
    accessors, as shown in the following table:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`operator[]`和`at()`函数外，`std::array`还提供了其他访问器，如下表所示：
- en: '![](img/C14498_01_06.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14498_01_06.jpg)'
- en: 'Figure 1.6: Table showing some accessors for std::array'
  id: totrans-88
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.6：显示`std::array`的一些访问器
- en: 'The following snippet demonstrates how these functions are used:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段演示了这些函数的使用：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Another useful functionality provided by `std::array` is the relational operator
    for deep comparison and the copy-assignment operator for deep copy. All size operators
    (`<`, `>`, `<=`, `>=`, `==`, `!=`) are defined for `std::array` to compare two
    arrays, provided the same operators are also provided for the underlying type
    of `std::array`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::array`提供的另一个有用功能是用于深度比较的关系运算符和用于深度复制的复制赋值运算符。所有大小运算符（`<`，`>`，`<=`，`>=`，`==`，`!=`）都被定义用于比较两个数组，前提是相同的运算符也被提供给`std::array`的基础类型。'
- en: C-style arrays also support all the relational operators, but these operators
    don't actually compare the elements inside the array; in fact, they just compare
    the pointers. Therefore, just the address of the elements is compared as integers
    instead of a deep comparison of the arrays. This is also known as a **shallow
    comparison**, and it is not of much practical use. Similarly, assignment also
    doesn't create a copy of the assigned data. Instead, it just makes a new pointer
    that points to the same data.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: C风格数组也支持所有关系运算符，但这些运算符实际上并不比较数组内部的元素；事实上，它们只是比较指针。因此，只是将元素的地址作为整数进行比较，而不是对数组进行深度比较。这也被称为**浅比较**，并且并不太实用。同样，赋值也不会创建分配数据的副本。相反，它只是创建一个指向相同数据的新指针。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Relational operators work for `std::array` of the same size only. This is because
    the size of the array is a part of the data type itself, and it doesn't allow
    values of two different data types to be compared.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 关系运算符仅适用于相同大小的`std::array`。这是因为数组的大小是数据类型本身的一部分，它不允许比较两种不同数据类型的值。
- en: In the following example, we shall see how to wrap a C-style array, whose size
    is defined by the user.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们将看到如何包装由用户定义大小的C风格数组。
- en: 'Exercise 1: Implementing a Dynamic Sized Array'
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习1：实现动态大小数组
- en: Let's write a small application to manage the student records in a school. The
    number of students in a class and their details will be given as an input. Write
    an array-like container to manage the data, which can also support dynamic sizing.
    We'll also implement some utility functions to merge different classes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个小型应用程序来管理学校中学生的记录。班级中的学生数量和他们的详细信息将作为输入给出。编写一个类似数组的容器来管理数据，该容器还可以支持动态大小。我们还将实现一些实用函数来合并不同的班级。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成练习：
- en: 'First, include the required headers:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，包括所需的头文件：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s write a basic templated structure called `dynamic_array`, as well
    as primary data members:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个名为`dynamic_array`的基本模板结构，以及主要数据成员：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, let''s add a constructor that takes the size of the array and copies it:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个接受数组大小并复制它的构造函数：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let''s add `operator[]` and `function()` in the `public` accessor to support
    the access of data directly, in a similar way to `std::array`:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`public`访问器中添加`operator[]`和`function()`来支持直接访问数据，类似于`std::array`：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let''s add a function called `size()` to return the size of the array,
    as well as a destructor to avoid memory leaks:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个名为`size()`的函数来返回数组的大小，以及一个析构函数来避免内存泄漏：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, let''s add iterator functions to support range-based loops to iterate
    over `dynamic_array`:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加迭代器函数来支持基于范围的循环，以便遍历`dynamic_array`：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let''s add a function to append one array to another using the `+` operator.
    Let''s keep it as a `friend` function for better usability:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个函数，使用`+`运算符将一个数组追加到另一个数组中。让我们将其保持为`friend`函数以提高可用性：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let''s add a `to_string` function that takes a separator as a parameter
    with the default value as "`,`":'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个名为`to_string`的函数，它接受一个分隔符作为参数，默认值为“`,`”：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let''s add a `struct` for students. We''ll just keep the name and the
    standard (that is, the grade/class in which the student is studying) for simplicity,
    and also add `operator<<` to print it properly:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为学生添加一个“struct”。我们将只保留姓名和标准（即学生所在的年级/班级）以简化，并添加“operator<<”以正确打印它：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let''s add a `main` function to use this array:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个“main”函数来使用这个数组：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Execute the preceding code with three students – `Raj(8)`, `Rahul(10)`, and
    `Viraj(6)` as input. The output looks like the following in the console:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用三个学生“Raj(8)”，“Rahul(10)”，和“Viraj(6)”作为输入执行上述代码。在控制台中输出如下：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Most of the functions mentioned here have a similar implementation to that of
    `std::array`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提到的大多数函数都有类似于“std::array”的实现。
- en: Now that we have seen various containers, we shall learn how to implement a
    container that can accept any kind of data and store it in a common form in the
    following exercise.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了各种容器，接下来我们将学习如何实现一个容器，它可以接受任何类型的数据并以通用形式存储在下一个练习中。
- en: 'Exercise 2: A General-Purpose and Fast Data Storage Container Builder'
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习2：通用且快速的数据存储容器构建器
- en: 'In this exercise, we will write a function that takes any number of elements
    of any type, which can, in turn, be converted into a common type. The function
    should also return a container having all the elements converted into that common
    type, and it should also be fast to traverse:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一个函数，该函数接受任意数量的任意类型的元素，这些元素可以转换为一个通用类型。该函数还应返回一个包含所有元素转换为该通用类型的容器，并且遍历速度应该很快：
- en: 'Let''s begin by including the required libraries:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先包括所需的库：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'First, we''ll try to build the signature of the function. Since the return
    type is a container that is fast to traverse, we''ll go ahead with `std::array`.
    To allow any number of parameters, we''ll use variadic templates:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将尝试构建函数的签名。由于返回类型是一个快速遍历的容器，我们将使用“std::array”。为了允许任意数量的参数，我们将使用可变模板：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Considering the requirement that the container should be fast to traverse for
    the return type, we can choose an array or a vector. Since the number of elements
    is known at the compile time based on the number of parameters to the function,
    we can go ahead with `std::array`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到返回类型的容器应该是快速遍历的要求，我们可以选择数组或向量。由于元素的数量在编译时基于函数的参数数量是已知的，我们可以继续使用“std::array”。
- en: 'Now, we must provide the type of the elements and the number of elements for
    `std::array`. We can use the `std::common_type` template to find out what the
    type of elements inside `std::array` will be. Since this is dependent on arguments,
    we''ll provide the return type of the function as a trailing type:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须为“std::array”提供元素的类型和元素的数量。我们可以使用“std::common_type”模板来找出“std::array”内部元素的类型。由于这取决于参数，我们将函数的返回类型作为尾随类型提供：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As shown in the preceding code, we now need to figure out two things – the
    number of elements, and how to create the array with `commonType`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前面的代码所示，我们现在需要弄清楚两件事——元素的数量，以及如何使用“commonType”创建数组：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let''s write the `main` function to see how our function works:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写“main”函数来看看我们的函数如何工作：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Running the code should give the following output:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码应该得到以下输出：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As we can see, all final output is in the form of float, since everything can
    be converted to float.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，所有最终输出都是浮点数形式，因为一切都可以转换为浮点数。
- en: 'To test this further, we can add the following inside the `main` function and
    test the output:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了进一步测试，我们可以在“main”函数中添加以下内容并测试输出：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With this modification, we should get an error saying that all the types can't
    be converted to a common type. The exact error message should mention that template
    deduction has failed. This is because there is no single type in which we can
    convert both the string and number.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种修改，我们应该会得到一个错误，说所有类型都无法转换为通用类型。确切的错误消息应该提到模板推导失败。这是因为没有单一类型可以将字符串和数字都转换为。
- en: Builder functions, such as the one we have created in this exercise, can be
    used when you are not sure about the type of data, yet you need to optimize efficiency.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 构建器函数，比如我们在这个练习中创建的函数，可以在你不确定数据类型但需要优化效率时使用。
- en: There are a lot of useful features and utility functions that `std::array` doesn't
    provide. One major reason for this is to maintain similar or better performance
    and memory requirements compared to C-style arrays.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: “std::array”没有提供许多有用的功能和实用函数。其中一个主要原因是为了保持与C风格数组相比类似或更好的性能和内存需求。
- en: For more advanced features and flexibility, C++ provides another structure called
    `std::vector`. We will examine how this works in the next section.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更高级的功能和灵活性，C++提供了另一个称为“std::vector”的结构。我们将在下一节中看看它是如何工作的。
- en: std::vector
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: std::vector
- en: 'As we saw earlier, `std::array` is a really good improvement over C-style arrays.
    But there are some limitations of `std::array`, where it lacks functions for some
    frequent use cases while writing applications. Here are some of the major drawbacks
    of `std::array`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，“std::array”相对于C风格数组是一个真正的改进。但是“std::array”也有一些局限性，在某些常见的应用程序编写用例中缺乏函数。以下是“std::array”的一些主要缺点：
- en: The size of `std::array` must be constant and provided at compile time, and
    fixed. So, we can't change it at runtime.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “std::array”的大小必须是常量且在编译时提供，并且是固定的。因此，我们无法在运行时更改它。
- en: Due to size limitations, we can't insert or remove elements from the array.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于大小限制，我们无法向数组中插入或删除元素。
- en: No custom allocation is possible for `std::array`. It always uses stack memory.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “std::array”不允许自定义分配。它总是使用堆栈内存。
- en: In the majority of real-life applications, data is quite dynamic and not a fixed
    size. For instance, in our earlier example of a hospital management system, we
    can have more doctors joining the hospital, we can have more patients in emergencies,
    and so on. Hence, knowing the size of the data in advance is not always possible.
    So, `std::array` is not always the best choice and we need something with dynamic
    size.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数现实生活应用中，数据是非常动态的，而不是固定大小的。例如，在我们之前的医院管理系统示例中，我们可能会有更多的医生加入医院，我们可能会有更多的急诊病人等。因此，提前知道数据的大小并不总是可能的。因此，`std::array`并不总是最佳选择，我们需要一些具有动态大小的东西。
- en: Now, we'll take a look at how `std::vector` provides a solution to these problems.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看一下`std::vector`如何解决这些问题。
- en: std::vector – Variable Length Array
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: std::vector - 变长数组
- en: As the title suggests, `std::vector` solves one of the most prominent problems
    of arrays – fixed size. `std::vector` does not require us to provide its length
    during initialization.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如标题所示，`std::vector`解决了数组的一个最突出的问题 - 固定大小。在初始化时，`std::vector`不需要我们提供其长度。
- en: 'Here are some of the ways in which we can initialize a vector:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些初始化向量的方法：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As we can see from the first initialization, providing the size is not mandatory.
    If we don't specify the size explicitly, and if we don't infer it by specifying
    its elements, the vector is initialized with the capacity of elements depending
    on the compiler implementation. The term "size" refers to the number of elements
    actually present in the vector, which may differ from its capacity. So, for the
    first initialization, the size will be zero, but the capacity could be some small
    number or zero.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从第一个初始化中看到的，提供大小并不是强制的。如果我们没有明确指定大小，并且没有通过指定元素来推断大小，向量将根据编译器的实现初始化元素的容量。术语“大小”指的是向量中实际存在的元素数量，这可能与其容量不同。因此，对于第一次初始化，大小将为零，但容量可能是一些小数字或零。
- en: 'We can insert elements inside the vector using the `push_back` or `insert`
    functions. `push_back` will insert elements at the end. `insert` takes the iterator
    as the first parameter for the position, and it can be used to insert the element
    in any location. `push_back` is a very frequently used function for vectors because
    of its performance. The pseudocode of the algorithm for `push_back` would be as
    follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`push_back`或`insert`函数在向量中插入元素。`push_back`会在末尾插入元素。`insert`以迭代器作为第一个参数表示位置，可以用来在任何位置插入元素。`push_back`是向量中非常常用的函数，因为它的性能很好。`push_back`的伪代码如下：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The actual implementation might differ a bit, but the logic remains the same.
    As we can see, if there's enough space, it only takes *O(1)* time to insert something
    at the back. However, if there's not enough space, it will have to copy/move all
    the elements, which will take *O(n)* time. Most of the implementations double
    the size of the vector every time we run out of capacity. Hence, the *O(n)* time
    operation is done after n elements. So, on average, it just takes one extra step,
    making its average time complexity closer to *O(1)*. This, in practice, provides
    pretty good performance, and, hence, it is a highly used container.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的实现可能会有所不同，但逻辑是相同的。正如我们所看到的，如果有足够的空间，向后插入元素只需要*O(1)*的时间。但是，如果没有足够的空间，它将不得不复制/移动所有元素，这将需要*O(n)*的时间。大多数实现在容量不足时会将向量的大小加倍。因此，*O(n)*的时间操作是在n个元素之后进行的。因此，平均而言，它只需要额外的一步，使其平均时间复杂度更接近*O(1)*。实际上，这提供了相当不错的性能，因此它是一个被广泛使用的容器。
- en: For the `insert` function, you don't have any option other than to shift the
    elements that come after the given iterator to the right. The `insert` function
    does that for us. It also takes care of reallocation whenever it is required.
    Due to the need to shift the elements, it takes *O(n)* time. The following examples
    demonstrate how to implement vector insertion functions.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`insert`函数，除了将给定迭代器后面的元素向右移动之外，没有其他选项。`insert`函数会为我们完成这些操作。它还会在需要时进行重新分配。由于需要移动元素，它的时间复杂度为*O(n)*。以下示例演示了如何实现向量插入函数。
- en: 'Consider a vector with the first five natural numbers:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个包含前五个自然数的向量：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Vector doesn't have a `push_front` function. It has the generic `insert` function,
    which takes the iterator as an argument for the position.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 向量没有`push_front`函数。它有通用的`insert`函数，它以迭代器作为参数表示位置。
- en: 'The generic `insert` function can be used to insert an element at the front,
    as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通用的`insert`函数可以用来在前面插入元素，如下所示：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s take a look a few more examples of the `push_back` and `insert` functions:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些`push_back`和`insert`函数的更多示例：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As shown in the preceding code, `push_back` inserts an element at the end. Additionally,
    the `insert` function takes the insertion position as a parameter. It takes it
    in the form of an iterator. So, the `begin()` function allows us to insert an
    element at the beginning.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，`push_back`在末尾插入元素。此外，`insert`函数以插入位置作为参数。它以迭代器的形式接受。因此，`begin()`函数允许我们在开头插入元素。
- en: Now that we have learned about the normal insertion functions, let's take a
    look at some better alternatives, available for vectors, compared to the `push_back`
    and `insert` functions. One of the drawbacks of `push_back` and `insert` is that
    they first construct the element, and then either copy or move the element to
    its new location inside the vector's buffer. This operation can be optimized by
    calling a constructor for the new element at the new location itself, which can
    be done by the `emplace_back` and `emplace` functions. It is recommended that
    you use these functions instead of normal insertion functions for better performance.
    Since we are constructing the element in place, we just need to pass the constructor
    parameters, instead of the constructed value itself. Then, the function will take
    care of forwarding the arguments to the constructor at the appropriate location.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了常规插入函数，让我们来看一些更好的替代方案，与`push_back`和`insert`函数相比，这些替代方案对于向量来说更好。`push_back`和`insert`的一个缺点是它们首先构造元素，然后将元素复制或移动到向量缓冲区内的新位置。这个操作可以通过在新位置本身调用构造函数来优化，这可以通过`emplace_back`和`emplace`函数来实现。建议您使用这些函数而不是普通的插入函数以获得更好的性能。由于我们是就地构造元素，我们只需要传递构造函数参数，而不是构造的值本身。然后，函数将负责将参数转发到适当位置的构造函数。
- en: '`std::vector` also provides `pop_back` and `erase` functions to remove elements
    from it. `pop_back` removes the last element from the vector, effectively reducing
    the size by one. `erase` has two overloads – to remove the single element provided
    by the iterator pointing to it, and to remove a range of elements provided by
    the iterator, where the range is defined by defining the first element to be removed
    (inclusive) and the last element to be removed (exclusive). The C++ standard doesn''t
    require these functions to reduce the capacity of the vector. It depends entirely
    on the compiler implementation. `pop_back` doesn''t require any rearranging of
    elements, and hence can be completed very quickly. Its complexity is *O(1)*. However,
    `erase` requires the shifting of the elements, and hence takes *O(n)* time. In
    the following exercise, we shall see how these functions are implemented.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector`还提供了`pop_back`和`erase`函数来从中删除元素。`pop_back`从向量中删除最后一个元素，有效地减小了大小。`erase`有两种重载方式
    - 通过指向单个元素的迭代器来删除该元素，以及通过迭代器提供的元素范围来删除元素，其中范围由定义要删除的第一个元素（包括）和要删除的最后一个元素（不包括）来定义。C++标准不要求这些函数减少向量的容量。这完全取决于编译器的实现。`pop_back`不需要对元素进行重新排列，因此可以非常快速地完成。它的复杂度是*O(1)*。然而，`erase`需要对元素进行移动，因此需要*O(n)*的时间。在接下来的练习中，我们将看到这些函数是如何实现的。'
- en: 'Now, let''s take a look at the example about removing elements from a vector
    in different ways:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一个关于不同方式从向量中删除元素的示例：
- en: 'Consider a vector with 10 elements – `{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '考虑一个有10个元素的向量 - `{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}`:'
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, let''s take a look at some other useful functions:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一些其他有用的函数：
- en: '`clear()`: This function simply empties the vector by removing all of the elements.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear()`: 这个函数通过删除所有元素来简单地清空向量。'
- en: '`reserve(capacity)`: This function is used to specify the capacity of the vector.
    If the value specified as the parameter is greater than the current capacity,
    it reallocates memory and the new capacity will be equal to the parameter. However,
    for all other cases, it will not affect the vector''s capacity. This function
    doesn''t modify the size of the vector.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reserve(capacity)`: 这个函数用于指定向量的容量。如果指定的参数值大于当前容量，它将重新分配内存，新的容量将等于参数。然而，对于所有其他情况，它不会影响向量的容量。这个函数不会修改向量的大小。'
- en: '`shrink_to_fit()`: This function can be used to free up the extra space. After
    calling this function, size and capacity become equal. This function can be used
    when we are not expecting a further increase in the size of the vector.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shrink_to_fit()`: 这个函数可以用来释放额外的空间。调用这个函数后，大小和容量变得相等。当我们不希望向量的大小进一步增加时，可以使用这个函数。'
- en: Allocators for std::vector
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: std::vector的分配器
- en: '`std::vector` resolves the drawback of `std::array` regarding custom allocators
    by allowing us to pass an allocator as a template parameter after the type of
    data.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector`通过允许我们在数据类型之后将分配器作为模板参数传递来解决了`std::array`关于自定义分配器的缺点。'
- en: To use custom allocators, we follow certain concepts and interfaces. Since a
    vector uses allocator functions for most of its behaviors related to memory access,
    we need to provide those functions as part of the allocator – `allocate`, `deallocate`,
    `construct`, and `destroy`. This allocator will have to take care of memory allocation,
    deallocation, and handling so as not to corrupt any data. For advanced applications,
    where relying on automatic memory management, mechanisms can be too costly, and
    where the application has got its own memory pool or similar resource that must
    be used instead of default heap memory, a customer allocator is very handy.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用自定义分配器，我们遵循一些概念和接口。由于向量使用分配器函数来处理与内存访问相关的大部分行为，我们需要将这些函数作为分配器的一部分提供 - `allocate`、`deallocate`、`construct`和`destroy`。这个分配器将负责内存分配、释放和处理，以免损坏任何数据。对于高级应用程序，其中依赖自动内存管理机制可能太昂贵，而应用程序拥有自己的内存池或类似资源必须使用而不是默认的堆内存时，自定义分配器非常方便。
- en: Therefore, `std::vector` is a really good alternative to `std::array` and provides
    a lot more flexibility in terms of its size, growth, and other aspects. Asymptotically,
    all the similar functions of an array have the same time complexity as a vector.
    We usually pay extra performance cost only for the extra features, which is quite
    reasonable. For an average case, the performance of a vector is not very far from
    an array. Hence, in practice, `std::vector` is one of the most commonly used STL
    containers in C++ because of its flexibility and performance.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`std::vector`是`std::array`的一个非常好的替代品，并在大小、增长和其他方面提供了更多的灵活性。从渐近的角度来看，数组的所有类似函数的时间复杂度与向量相同。我们通常只为额外的功能付出额外的性能成本，这是相当合理的。在平均情况下，向量的性能与数组的性能相差不大。因此，在实践中，由于其灵活性和性能，`std::vector`是C++中最常用的STL容器之一。
- en: std::forward_list
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: std::forward_list
- en: So far, we've only seen array-like structures, but, as we saw, insertion and
    deletion in the middle of the data structures are very inefficient operations
    for contiguous data structures. And that's where linked-list-like structures come
    into the picture. A lot of applications require frequent insertion and deletion
    in the middle of a data structure. For example, any browser with multiple tabs
    can have an extra tab added at any point in time and at any location. Similarly,
    any music player will have a list of songs that you can play in a loop, and you
    can also insert any songs in the middle. In such cases, we can use a linked-list
    structure for good performance. We'll see the use case of a music player in *Activity
    1*, *Implementing a Song Playlist*. Now, let's explore what kind of containers
    C++ provides us with.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了类似数组的结构，但是，正如我们所看到的，对于连续数据结构来说，在数据结构的中间进行插入和删除是非常低效的操作。这就是链表结构的作用所在。许多应用程序需要在数据结构的中间频繁进行插入和删除。例如，任何具有多个选项卡的浏览器都可以在任何时间点和任何位置添加额外的选项卡。同样，任何音乐播放器都会有一个可以循环播放的歌曲列表，并且您还可以在其中插入任何歌曲。在这种情况下，我们可以使用链表结构来获得良好的性能。我们将在*Activity
    1*中看到音乐播放器的用例，*实现歌曲播放列表*。现在，让我们探索C++为我们提供了哪些类型的容器。
- en: The basic structure of a linked list requires us to have a pointer and to manage
    memory allocation and deallocation manually using the `new` and `delete` operators.
    Although it is not difficult, it can lead to bugs that are difficult to trace.
    Hence, just like `std::array` provides a thin wrapper over C-style arrays, `std::forward_list`
    provides a thin wrapper over a basic linked list.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 链表的基本结构要求我们使用指针，并手动使用`new`和`delete`运算符来管理内存分配和释放。虽然这并不困难，但可能会导致难以追踪的错误。因此，就像`std::array`提供了对C风格数组的薄包装一样，`std::forward_list`提供了对基本链表的薄包装。
- en: The purpose of `std::forward_list` is to provide some additional functionality
    without compromising performance compared to a basic linked list. To maintain
    performance, it doesn't provide functions to get the size of the list or to get
    any element but the first one directly. Hence, it has a function called `front()`
    to get the reference to the first element, but nothing like `back()` to access
    the last element. It does provide functions for common operations, such as insertion,
    deletion, reverse, and splice. These functions don't affect the memory requirements
    or performance over basic linked lists.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::forward_list`的目的是在不影响性能的情况下提供一些额外的功能，与基本链表相比。为了保持性能，它不提供获取列表大小或直接获取除第一个元素之外的任何元素的函数。因此，它有一个名为`front()`的函数，用于获取对第一个元素的引用，但没有像`back()`那样访问最后一个元素的函数。它确实提供了常见操作的函数，如插入、删除、反转和拼接。这些函数不会影响基本链表的内存需求或性能。'
- en: Additionally, just like `std::vector`, `std::forward_list` can also take a custom
    allocator as the second template parameter if required. Hence, we can easily use
    it for advanced applications that benefit from custom memory management.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，就像`std::vector`一样，如果需要，`std::forward_list`也可以接受自定义分配器作为第二个模板参数。因此，我们可以轻松地将其用于受益于自定义内存管理的高级应用程序。
- en: Inserting and Deleting Elements in forward_list
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在`forward_list`中插入和删除元素
- en: '`std:: forward_list` provides the `push_front` and `insert_after` functions,
    which can be used to insert an element in a linked list. Both of these are slightly
    different compared to insertion functions for vectors. `push_front` is useful
    for inserting an element at the front. Since `forward_list` doesn''t have direct
    access to the last element, it doesn''t provide a `push_back` function. For insertion
    at a specific location, we use `insert_after` instead of `insert`. This is because
    inserting an element in a linked list requires updating the next pointer of the
    element, after which we want to insert a new element. If we provide just the iterator,
    where we want to insert a new element, we can''t get access to the previous element
    quickly, since traversing backward is not allowed in `forward_list`.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::forward_list`提供了`push_front`和`insert_after`函数，可用于在链表中插入元素。这两个函数与向量的插入函数略有不同。`push_front`用于在前面插入元素。由于`forward_list`无法直接访问最后一个元素，因此它不提供`push_back`函数。对于特定位置的插入，我们使用`insert_after`而不是`insert`。这是因为在链表中插入元素需要更新元素的下一个指针，然后我们想要插入一个新元素。如果我们只提供要插入新元素的迭代器，我们无法快速访问前一个元素，因为在`forward_list`中不允许向后遍历。'
- en: Since this is a pointer-based mechanism, we don't really need to shift the elements
    during insertion. Hence, both of the insertion functions are quite a bit faster
    compared to any array-based structures. Both the functions just modify the pointers
    to insert a new element at the intended position. This operation is not dependent
    on the size of the list and therefore has a time complexity of *O(1)*. We shall
    take a look at the implementation of these functions in the following exercise.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是基于指针的机制，因此在插入期间我们实际上不需要移动元素。因此，这两个插入函数与任何基于数组的结构相比要快得多。这两个函数只是修改指针以在预期位置插入新元素。这个操作不依赖于列表的大小，因此时间复杂度为*O(1)*。我们将在接下来的练习中看一下这些函数的实现。
- en: 'Now, let''s see how we can insert elements in a linked list:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在链表中插入元素：
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`forward_list` also provides `emplace_front` and `emplace_after`, which is
    similar to `emplace` for a vector. Both of these functions do the same thing as
    insertion functions, but more efficiently by avoiding extra copying and moving.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`forward_list`还提供了`emplace_front`和`emplace_after`，类似于向量的`emplace`。这两个函数都与插入函数做相同的事情，但通过避免额外的复制和移动来更有效地执行。'
- en: '`forward_list` also has `pop_front` and `erase_after` functions for the deletion
    of elements. `pop_front`, as the name suggests, removes the first element. Since
    it doesn''t require any shifting, the operation is quite fast in practice and
    has a time complexity of *O(1)*. `erase_after` has two overloads – to remove a
    single element (by taking an iterator to its previous element), and to remove
    multiple elements in a range (by taking an iterator to the element before the
    first element of the range and another iterator to the last element).'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`forward_list`还具有`pop_front`和`erase_after`函数用于删除元素。`pop_front`如其名称所示，删除第一个元素。由于不需要任何移动，实际上操作非常快，时间复杂度为*O(1)*。`erase_after`有两个重载
    - 通过取其前一个元素的迭代器来删除单个元素，以及通过取范围的第一个元素之前的迭代器和最后一个元素的另一个迭代器来删除多个元素。'
- en: The time complexity of the `erase_after` function is linear to the number of
    elements that are erased because the deletion of elements can't be done via deallocating
    just a single chunk of memory. Since all the nodes are scattered across random
    locations in memory, the function needs to deallocate each of them separately.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`erase_after`函数的时间复杂度与被删除的元素数量成正比，因为无法通过释放单个内存块来删除元素。由于所有节点都分散在内存中的随机位置，函数需要分别释放每个节点。'
- en: 'Now, let''s see how we can remove the elements from the list:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何从列表中删除元素：
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Let's explore what other operations we can do with `forward_list` in the following
    section.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中探讨`forward_list`可以进行的其他操作。
- en: Other Operations on forward_list
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: forward_list上的其他操作
- en: Apart from the `erase` functions to delete elements based on its position determined
    by iterators, `forward_list` also provides the `remove` and `remove_if` functions
    to remove elements based on their values. The `remove` function takes a single
    parameter – the value of the elements to be removed. It removes all the elements
    that match the given element based on the equality operator defined for the type
    of the value. Without the equality operator, the compiler doesn't allow us to
    call that function and throws a compilation error. Since `remove` only deletes
    the elements based on the equality operator, it is not possible to use it for
    deletion based on other conditions, since we can't change the equality operator
    after defining it once. For a conditional removal, `forward_list` provides the
    `remove_if` function. It takes a predicate as a parameter, which is a function
    taking an element of the value type as a parameter, and a Boolean as the return
    value. So, all the elements for which the predicate returns true are removed from
    the list. With the latest C++ versions, we can easily specify the predicate with
    lambdas as well. The following exercise should help you to understand how to implement
    these functions.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 除了根据迭代器确定位置来删除元素的`erase`函数外，`forward_list`还提供了`remove`和`remove_if`函数来根据其值删除元素。`remove`函数接受一个参数
    - 要删除的元素的值。它会删除所有与给定元素匹配的元素，基于该值类型定义的相等运算符。如果没有相等运算符，编译器将不允许我们调用该函数，并抛出编译错误。由于`remove`仅根据相等运算符删除元素，因此无法根据其他条件使用它进行删除，因为我们无法在定义一次后更改相等运算符。对于条件删除，`forward_list`提供了`remove_if`函数。它接受一个谓词作为参数，该谓词是一个接受值类型元素作为参数并返回布尔值的函数。因此，谓词返回true的所有元素都将从列表中删除。使用最新的C++版本，我们也可以使用lambda轻松指定谓词。以下练习应该帮助你了解如何实现这些函数。
- en: 'Exercise 3: Conditional Removal of Elements from a Linked List Using remove_if'
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习3：使用remove_if条件删除链表中的元素
- en: In this exercise, we'll use the sample information of a few Indian citizens
    during the elections and remove ineligible citizens, based on their age, from
    the electoral roll. For simplicity, we'll just store the names and ages of the
    citizens.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用印度选民的样本信息，并根据他们的年龄从选民名单中删除不合格的公民。为简单起见，我们只存储公民的姓名和年龄。
- en: 'We shall store the data in a linked list and remove the required elements using
    `remove_if`, which provides a way to remove elements that meet a certain condition,
    instead of defining the positions of the elements to be removed:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在链表中存储数据，并使用`remove_if`删除所需的元素，该函数提供了一种删除满足特定条件的元素的方法，而不是定义要删除的元素的位置：
- en: 'Let''s first include the required headers and add the `struct citizen`:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先包含所需的头文件并添加`struct citizen`：
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, let''s write a `main` function and initialize a few citizens in a `std::forward_list`.
    We''ll also make a copy of it to avoid having to initialize it again:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个`main`函数，并在`std::forward_list`中初始化一些公民。我们还将对其进行复制，以避免再次初始化：
- en: '[PRE37]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, let''s remove all of the ineligible citizens from the list:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们从列表中删除所有不合格的公民：
- en: '[PRE38]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `remove_if` function removes all the elements for which the given predicate
    is true. Here, we've provided a lambda since the condition is very simple. If
    it were a complicated condition, we could also write a normal function that takes
    one parameter of the underlying type of list and returns a Boolean value.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove_if`函数会删除所有满足给定条件的元素。在这里，我们提供了一个lambda，因为条件非常简单。如果条件很复杂，我们也可以编写一个接受链表底层类型的参数并返回布尔值的普通函数。'
- en: 'Now, let''s find out who''ll be eligible for voting next year:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们找出明年有资格投票的人：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, we are only keeping those citizens with an age of 17.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们只保留那些年龄为17岁的公民。
- en: 'Run the exercise. You should get an output like this:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行练习。你应该会得到这样的输出：
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `remove_if` function has a time complexity of *O(n)* since it simply traverses
    the list once while removing all the elements as required. If we want to remove
    the elements with specific values, we can use another version of `remove`, which
    simply takes one parameter of the object and removes all the objects from the
    list matching the given value. It also requires us to implement the `==` operator
    for the given type.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove_if`函数的时间复杂度为*O(n)*，因为它只需遍历列表一次，同时根据需要删除所有元素。如果我们想要删除具有特定值的元素，我们可以使用`remove`的另一个版本，它只需要一个对象的参数，并删除列表中与给定值匹配的所有对象。它还要求我们为给定类型实现`==`运算符。'
- en: '`forward_list` also provides a `sort` function to sort the data. All the array-related
    structures can be sorted by a generic function, `std::sort(first iterator, last
    iterator)`. However, it can''t be used by linked list-based structures because
    we can''t access any data randomly. This also makes the iterators provided by
    `forward_list` different from the ones for an array or a vector. We''ll take a
    look at this in more detail in the next section. The `sort` function that is provided
    as part of `forward_list` has two overloads – `sort` based on the less than operator
    (`<`), and `sort` based on a comparator provided as a parameter. The default `sort`
    function uses `std::less<value_type>` for comparison. It simply returns `true`
    if the first parameter is less than the second one, and hence, requires us to
    define the less than operator (`<`) for custom-defined types.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`forward_list`还提供了一个`sort`函数来对数据进行排序。所有与数组相关的结构都可以通过通用函数`std::sort(first iterator,
    last iterator)`进行排序。然而，它不能被链表结构使用，因为我们无法随机访问任何数据。这也使得`forward_list`提供的迭代器与数组或向量的迭代器不同。我们将在下一节中更详细地看一下这一点。`forward_list`提供的`sort`函数有两个重载版本
    - 基于小于运算符（`<`）的`sort`，以及基于作为参数提供的比较器的`sort`。默认的`sort`函数使用`std::less<value_type>`进行比较。如果第一个参数小于第二个参数，则简单地返回`true`，因此，需要我们为自定义类型定义小于运算符（`<`）。'
- en: 'In addition to this, if we want to compare it based on some other parameters,
    we can use the parametric overload, which takes a binary predicate. Both the overloads
    have a linearathmic time complexity – *O(n × log n)*. The following example demonstrates
    both overloads of `sort`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们想要基于其他参数进行比较，我们可以使用参数化重载，它接受一个二元谓词。这两个重载的时间复杂度都是线性对数级的 - *O(n × log n)*。以下示例演示了`sort`的两个重载：
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, `greater<int>` is a predicate provided in the standard itself, which is
    a wrapper over the greater than operator (`>`) to sort the elements into descending
    order, as we can see from the values of the list..
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`greater<int>`是标准库中提供的一个谓词，它是对大于运算符（`>`）的包装器，用于将元素按降序排序，正如我们从列表的值中所看到的。
- en: Other functions provided in `forward_list` are `reverse` and `unique`. The `reverse`
    function simply reverses the order of the elements, in a time duration that is
    linear to the number of elements present in the list, that is, with a time complexity
    of *O(n)*. The `unique` function keeps only the unique elements in the list and
    removes all the repetitive valued functions except the first one. Since it is
    dependent on the equality of the elements, it has two overloads – the first takes
    no parameters and uses the equality operator for the value type, while the second
    takes a binary predicate with two parameters of the value type. The `unique` function
    was built to be linear in time complexity. Hence, it doesn't compare each element
    with every other element. Instead, it only compares consecutive elements for equality
    and removes the latter one if it is the same as the former one based on the default
    or custom binary predicate. Hence, to remove all of the unique elements from the
    list using the `unique` function, we need to sort the elements before calling
    the function. With the help of a given predicate, `unique` will compare all the
    elements with their neighboring elements and remove the latter elements if the
    predicate returns `true`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`forward_list`中提供的其他函数包括`reverse`和`unique`。`reverse`函数简单地颠倒元素的顺序，其时间复杂度与列表中元素的数量成正比，即时间复杂度为*O(n)*。`unique`函数仅保留列表中的唯一元素，并删除除第一个元素外的所有重复值函数。由于它依赖于元素的相等性，它有两个重载版本
    - 第一个不带参数，使用值类型的相等运算符，而第二个带有两个值类型参数的二元谓词。`unique`函数的时间复杂度是线性的。因此，它不会将每个元素与其他每个元素进行比较。相反，它只会比较连续的元素是否相等，并根据默认或自定义的二元谓词删除后一个元素。因此，要使用`unique`函数从列表中删除所有唯一元素，我们需要在调用函数之前对元素进行排序。借助给定的谓词，`unique`将比较所有元素与其相邻元素，并在谓词返回`true`时删除后一个元素。'
- en: 'Let''s now see how we can use the `reverse`, `sort`, and `unique` functions
    for lists:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用`reverse`、`sort`和`unique`函数来操作列表：
- en: '[PRE42]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The following example will remove elements if they are not greater than the
    previously valid element by at least 2:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将删除元素，如果它们与之前的有效元素相比至少相差2：
- en: '[PRE43]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Before calling the `unique` function, the programmer must make sure that the
    data is already sorted. Hence, we are calling the `sort` function right before
    it. The `unique` function compares the element with the previous element that
    has already met the condition. Additionally, it always keeps the first element
    of the original list. Hence, there's always an element to compare with.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`unique`函数之前，程序员必须确保数据已经排序。因此，在调用`unique`函数之前，我们会先调用`sort`函数。`unique`函数将元素与已满足条件的前一个元素进行比较。此外，它始终保留原始列表的第一个元素。因此，总是有一个元素可以进行比较。
- en: In the next section, we will take a look at how the `forward_list` iterator
    is different from the vector/array iterators.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看一看`forward_list`迭代器与向量/数组迭代器的不同之处。
- en: Iterators
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器
- en: As you may have noticed in some of the examples for arrays and vectors, we add
    numbers to the iterators. Iterators are like pointers, but they also provide a
    common interface for STL containers. The operations on these iterators are strictly
    based on the type of iterators, which is dependent on the container. Iterators
    for vectors and arrays are the most flexible in terms of functionality. We can
    access any element from the container directly, based on its position, using `operator[]`
    because of the contiguous nature of the data. This iterator is also known as a
    random access iterator. However, for `forward_list`, there is no direct way to
    traverse back, or even go from one node to its preceding node, without starting
    from the beginning. Hence, the only arithmetic operator allowed for this is increment.
    This iterator is also known as a forward iterator.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的，在一些数组和向量的例子中，我们向迭代器添加数字。迭代器类似于指针，但它们还为STL容器提供了一个公共接口。这些迭代器上的操作严格基于迭代器的类型，这取决于容器。对于向量和数组的迭代器在功能上是最灵活的。我们可以根据位置直接访问容器中的任何元素，使用`operator[]`，因为数据的连续性。这个迭代器也被称为随机访问迭代器。然而，对于`forward_list`，没有直接的方法可以向后遍历，甚至从一个节点到其前一个节点，而不是从头开始。因此，这个迭代器允许的唯一算术运算符是增量。这个迭代器也被称为前向迭代器。
- en: There are other utility functions that we can use, such as `advance`, `next`,
    and `prev`, depending on the type of iterators. `next` and `prev` take an iterator
    and a distance value, and then return the iterator pointing to the element that
    is at the given distance from the given iterator. This works as expected provided
    that the given iterator supports the operation. For example, if we try to use
    the `prev` function with a `forward` iterator, it will throw a compilation error,
    since this iterator is a forward iterator and can only move forward. The time
    taken by these functions depends on the type of iterators used. All of them are
    constant time functions for random access iterators, since addition and subtraction
    are constant-time operations. For the rest of the iterators, all of them are linear
    to the distance that needs to be traversed forward or backward. We shall use these
    iterators in the following exercise.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他实用函数可以使用，比如`advance`、`next`和`prev`，取决于迭代器的类型。`next`和`prev`接受一个迭代器和一个距离值，然后返回指向距离给定迭代器给定距离的元素的迭代器。这在给定迭代器支持该操作的情况下可以正常工作。例如，如果我们尝试使用`prev`函数与`forward`迭代器，它将抛出编译错误，因为这个迭代器是一个前向迭代器，只能向前移动。这些函数所花费的时间取决于所使用的迭代器的类型。对于随机访问迭代器，所有这些都是常数时间函数，因为加法和减法都是常数时间操作。对于其余的迭代器，所有这些都是线性的，需要向前或向后遍历的距离。我们将在接下来的练习中使用这些迭代器。
- en: 'Exercise 4: Exploring Different Types of Iterators'
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习4：探索不同类型的迭代器
- en: 'Let''s say that we have a list of the winners of the Singapore F1 Grand Prix
    from the last few years. With the help of vector iterators, we''ll discover how
    we can retrieve useful information from this data. After that, we''ll try to do
    the same thing with `forward_list`, and see how it differs from vector iterators:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们有一份新加坡F1大奖赛近年来的获奖者名单。借助向量迭代器的帮助，我们将发现如何从这些数据中检索有用的信息。之后，我们将尝试使用`forward_list`做同样的事情，并看看它与向量迭代器有何不同：
- en: 'Let''s first include the headers:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先包含头文件：
- en: '[PRE44]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s write a vector with a list of winners:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们写一个包含获奖者名单的向量：
- en: '[PRE45]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s try the same with the `forward_list` iterators and see how they differ
    from vector iterators:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试使用`forward_list`迭代器做同样的事情，并看看它们与向量迭代器有何不同：
- en: '[PRE46]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Running this exercise should produce the following output:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行这个练习应该产生以下输出：
- en: '[PRE47]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, let''s see what happens if we add a number to this iterator by putting
    the following line inside the `main` function at the end:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看如果我们在`main`函数的末尾放入以下行会发生什么：
- en: '[PRE48]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We''ll get an error message similar to this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到类似于这样的错误消息：
- en: '[PRE49]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The various iterators we have explored in this exercise are quite useful for
    easily fetching any data from your dataset.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个练习中探索的各种迭代器对于轻松获取数据集中的任何数据非常有用。
- en: As we have seen, `std::array` is a thin wrapper over a C-style array, and `std::forward_list`
    is nothing but a thin wrapper over a singly linked list. It provides a simple
    and less error-prone interface without compromising on performance or memory.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，`std::array`是C风格数组的一个薄包装器，`std::forward_list`只是一个薄包装器，它提供了一个简单且不易出错的接口，而不会影响性能或内存。
- en: Apart from that, since we can access any element immediately in the vector,
    the addition and subtraction operations on the vector iterator are *O(1)*. On
    the other hand, `forward_list` only supports access to an element by traversing
    to it. Hence, its iterators' addition operation is *O(n)*, where n is the number
    of steps we are advancing.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，由于我们可以立即访问向量中的任何元素，因此向量迭代器的加法和减法操作为*O(1)*。另一方面，`forward_list`只支持通过遍历访问元素。因此，它的迭代器的加法操作为*O(n)*，其中n是我们正在前进的步数。
- en: In the following exercise, we shall make a custom container that works in a
    similar way to `std::forward_list`, but with some improvements. We shall define
    many functions that are equivalent to `forward_list` functions. It should also
    help you understand how these functions work under the hood.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，我们将制作一个自定义容器，其工作方式类似于`std::forward_list`，但具有一些改进。我们将定义许多等效于`forward_list`函数的函数。这也应该帮助您了解这些函数在底层是如何工作的。
- en: 'Exercise 5: Building a Basic Custom Container'
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习5：构建基本自定义容器
- en: 'In this exercise, we''re going to implement an `std::forward_list` equivalent
    container with some improvements. We''ll start with a basic implementation called
    `singly_ll`, and gradually keep on improving:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实现一个带有一些改进的`std::forward_list`等效容器。我们将从一个名为`singly_ll`的基本实现开始，并逐渐不断改进：
- en: 'Let''s add the required headers and then start with the basic implementation
    of `singly_ll` with a single node:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加所需的头文件，然后从一个单节点开始基本实现`singly_ll`：
- en: '[PRE50]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, we''ll implement the actual `singly_ll` class, which wraps the node around
    for better interfacing:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将实现实际的`singly_ll`类，它将节点包装起来以便更好地进行接口设计。
- en: '[PRE51]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, let''s add `push_front` and `pop_front`, just like in `forward_list`:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加`push_front`和`pop_front`，就像在`forward_list`中一样：
- en: '[PRE52]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s now implement a basic iterator for our `singly_ll` class, with constructors
    and accessors:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们为我们的`singly_ll`类实现一个基本的迭代器，包括构造函数和访问器：
- en: '[PRE53]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let''s add the `operator++` functions for pre- and post-increments:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为前置和后置递增添加`operator++`函数：
- en: '[PRE54]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s add equality operations as `friend` functions:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加等式操作作为`friend`函数：
- en: '[PRE55]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let''s jump back to our linked list class. Now that we''ve got our iterator
    class, let''s implement the `begin` and `end` functions to ease the traversal.
    We''ll also add `const` versions for both:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到我们的链表类。现在我们已经有了迭代器类，让我们实现`begin`和`end`函数来方便遍历。我们还将为两者添加`const`版本：
- en: '[PRE56]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let''s implement a default constructor, a copy constructor for deep copying,
    and a constructor with `initializer_list`:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们实现一个默认构造函数，一个用于深度复制的复制构造函数，以及一个带有`initializer_list`的构造函数：
- en: '[PRE57]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let''s write a `main` function to use the preceding functions:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写一个`main`函数来使用前面的函数：
- en: '[PRE58]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Running this exercise should produce the following output:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行这个练习应该产生以下输出：
- en: '[PRE59]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As we can see in the preceding example, we are able to initialize our list using
    `std::initializer_list`. We can call the `push`, `pop_front`, and `back` functions.
    As we can see, `sll2.pop_back` only removed the element from `sll2`, and not `sll`.
    `sll` is still intact with all five elements. Hence, we can perform a deep copy
    as well.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的例子中看到的，我们能够使用`std::initializer_list`初始化我们的列表。我们可以调用`push`、`pop_front`和`back`函数。正如我们所看到的，`sll2.pop_back`只从`sll2`中删除了元素，而不是`sll`。`sll`仍然保持完整，有五个元素。因此，我们也可以执行深度复制。
- en: 'Activity 1: Implementing a Song Playlist'
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动1：实现歌曲播放列表
- en: In this activity, we'll look at some applications for which a doubly-linked
    list is not enough or not convenient. We will build a tweaked version that fits
    the application. We often encounter cases where we have to customize default implementations,
    such as when looping songs in a music player or in games where multiple players
    take a turn one by one in a circle.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将看一些双向链表不足或不方便的应用。我们将构建一个适合应用的调整版本。我们经常遇到需要自定义默认实现的情况，比如在音乐播放器中循环播放歌曲或者在游戏中多个玩家依次在圈内轮流。
- en: These applications have one common property – we traverse the elements of the
    sequence in a circular fashion. Thus, the node after the last node will be the
    first node while traversing the list. This is called a circular linked list.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应用有一个共同的特点——我们以循环方式遍历序列的元素。因此，在遍历列表时，最后一个节点之后的节点将是第一个节点。这就是所谓的循环链表。
- en: 'We''ll take the use case of a music player. It should have following functions
    supported:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以音乐播放器的用例为例。它应该支持以下功能：
- en: Create a playlist using multiple songs.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用多首歌曲创建一个播放列表。
- en: Add songs to the playlist.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向播放列表添加歌曲。
- en: Remove a song from the playlist.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从播放列表中删除一首歌曲。
- en: Play songs in a loop (for this activity, we will print all the songs once).
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环播放歌曲（对于这个活动，我们将打印所有歌曲一次）。
- en: Note
  id: totrans-281
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: You can refer to *Exercise 5*, *Building a Basic Custom Container* where we
    built a container from scratch supporting similar functions.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考*练习5*，*构建基本自定义容器*，我们在那里从头开始构建了一个支持类似功能的容器。
- en: 'Here are the steps to solve the problem:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 解决问题的步骤如下：
- en: First, design a basic structure that supports circular data representation.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，设计一个支持循环数据表示的基本结构。
- en: After that, implement the `insert` and `erase` functions in the structure to
    support various operations.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，在结构中实现`insert`和`erase`函数，以支持各种操作。
- en: We have to write a custom iterator. This is a bit tricky. The important thing
    is to make sure that we are able to traverse the container using a range-based
    approach for a loop. Hence, `begin()` and `end()` should return different addresses,
    although the structure is circular.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须编写一个自定义迭代器。这有点棘手。重要的是要确保我们能够使用基于范围的方法来遍历容器。因此，`begin()`和`end()`应该返回不同的地址，尽管结构是循环的。
- en: After building the container, build a wrapper over it, which will store different
    songs in the playlist and perform relevant operations, such as `next`, `previous`,
    `print all`, `insert`, and `remove`.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建容器后，再构建一个包装器，它将在播放列表中存储不同的歌曲并执行相关操作，比如`next`、`previous`、`print all`、`insert`和`remove`。
- en: Note
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 476.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第476页找到。
- en: '`std::forward_list` has several limitations. `std::list` presents a much more
    flexible implementation of lists and helps overcome some of the shortcomings of
    `forward_list`.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::forward_list`有一些限制。`std::list`提供了更灵活的列表实现，并帮助克服了`forward_list`的一些缺点。'
- en: std::list
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: std::list
- en: As seen in the previous section, `std::forward_list` is just a nice and thin
    wrapper over the basic linked list. It doesn't provide functions to insert elements
    at the end, traverse backward, or get the size of the list, among other useful
    operations. The functionality is limited to save memory and to retain fast performance.
    Apart from that, the iterators of `forward_list` can support very few operations.
    In most practical situations in any application, functions such as those for inserting
    something at the end and getting the size of the container are very useful and
    frequently used. Hence, `std::forward_list` is not always the desired container,
    where fast insertion is required. To overcome these limitations of `std::forward_list`,
    C++ provides `std::list`, which has several additional features owing to the fact
    that it is a bidirectional linked list, also known as a doubly-linked list. However,
    note that this comes at the cost of additional memory requirements.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的部分所示，`std::forward_list`只是一个基本链表的简单包装。它不提供在末尾插入元素、向后遍历或获取列表大小等有用操作。功能受限是为了节省内存并保持快速性能。除此之外，`forward_list`的迭代器只支持很少的操作。在任何应用的实际情况中，像在容器末尾插入东西和获取容器大小这样的函数是非常有用且经常使用的。因此，当需要快速插入时，`std::forward_list`并不总是理想的容器。为了克服`std::forward_list`的这些限制，C++提供了`std::list`，它由于是双向链表，也被称为双向链表，因此具有几个额外的特性。但是，请注意，这是以额外的内存需求为代价的。
- en: 'The plain version of a doubly-linked list looks something like this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 双向链表的普通版本看起来像这样：
- en: '[PRE60]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As you can see, it has one extra pointer to point to the previous element. Thus,
    it provides us with a way in which to traverse backward, and we can also store
    the size and the last element to support fast `push_back` and `size` operations.
    Also, just like `forward_list`, it can also support customer allocator as a template
    parameter.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，它有一个额外的指针指向前一个元素。因此，它为我们提供了一种向后遍历的方式，我们还可以存储大小和最后一个元素以支持快速的`push_back`和`size`操作。而且，就像`forward_list`一样，它也可以支持客户分配器作为模板参数。
- en: Common Functions for std::list
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`std::list`的常用函数'
- en: Most of the functions for `std::list` are either the same or similar to the
    functions of `std::forward_list`, with a few tweaks. One of the tweaks is that
    function names ending with `_after` have their equivalents without `_after`. Therefore,
    `insert_after` and `emplace_after` become simply `insert` and `emplace`. This
    is because, with the `std::list` iterator, we can also traverse backward, and
    hence there's no need to provide the iterator of the previous element. Instead,
    we can provide the iterator of the exact element at which we want to perform the
    operation. Apart from that, `std::list` also provides fast operations for `push_back`,
    `emplace_back`, and `pop_back`. The following exercise demonstrates the use of
    insertion and deletion functions for `std::list`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::list`的大多数函数要么与`std::forward_list`的函数相同，要么类似，只是有一些调整。其中一个调整是以`_after`结尾的函数有没有`_after`的等价函数。因此，`insert_after`和`emplace_after`变成了简单的`insert`和`emplace`。这是因为，使用`std::list`迭代器，我们也可以向后遍历，因此不需要提供前一个元素的迭代器。相反，我们可以提供我们想要执行操作的确切元素的迭代器。除此之外，`std::list`还提供了`push_back`、`emplace_back`和`pop_back`的快速操作。以下练习演示了`std::list`的插入和删除函数的使用。'
- en: 'Exercise 6: Insertion and Deletion Functions for std::list'
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习6：`std::list`的插入和删除函数
- en: 'In this exercise, we shall create a simple list of integers using `std::list`
    and explore various ways in which we can insert and delete elements from it:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用`std::list`创建一个简单的整数列表，并探索各种插入和删除元素的方法：
- en: 'First of all, let''s include the required headers:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们包含所需的头文件：
- en: '[PRE61]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, initialize a list with a few elements and experiment on it with various
    insertion functions:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，用一些元素初始化一个列表，并用各种插入函数进行实验：
- en: '[PRE62]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As you can see, the `push_back` function inserts an element at the end. The
    `insert` function inserts `0` after the first element, which is indicated by `next(list1.begin())`.
    After that, we are inserting `7` after the last element, which is indicated by
    `list1.end()`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`push_back`函数在末尾插入一个元素。`insert`函数在第一个元素后插入`0`，这由`next(list1.begin())`表示。之后，我们在最后一个元素后插入`7`，这由`list1.end()`表示。
- en: 'Now, let''s take a look at the remove function, `pop_back`, which was not present
    in `forward_list`:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们来看看`pop_back`这个删除函数，它在`forward_list`中不存在：
- en: '[PRE63]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Running this exercise should give the following output:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行这个练习应该会得到以下输出：
- en: '[PRE64]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Here, we are removing the last element that we just inserted.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在删除刚刚插入的最后一个元素。
- en: Note
  id: totrans-310
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Although `push_front`, `insert`, `pop_front`, and `erase` have the same time
    complexity as equivalent functions for `forward_list`, these are slightly more
    expensive for `std::list`. The reason for this is that there are two pointers
    in each node of a list instead of just one, as in the case of `forward_list`.
    So, we have to maintain the validity of the value of both the pointers. Hence,
    when we are repointing these variables, we need to make almost double the effort
    compared to singly linked lists.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`push_front`、`insert`、`pop_front`和`erase`的时间复杂度与`forward_list`的等价函数相同，但对于`std::list`来说，这些函数稍微昂贵一些。原因是列表中每个节点有两个指针，而不是`forward_list`中的一个。因此，我们需要维护这些指针的有效性。因此，在重新指向这些变量时，我们需要付出几乎是单向链表的两倍的努力。
- en: 'Earlier, we saw an insertion for a singly-linked list. Let''s now demonstrate
    what pointer manipulation looks like for a doubly-linked list in the following
    diagram:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们看到了单向链表的插入。现在让我们在下图中演示双向链表的指针操作是什么样子的：
- en: '![](img/C14498_01_07.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14498_01_07.jpg)'
- en: 'Figure 1.7: Inserting an element in a doubly linked list'
  id: totrans-314
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.7：在双向链表中插入元素
- en: As you can see, the number of operations is constant even in the case of `std::list`;
    however, compared to `forward_list`, we have to fix both the `prev` and `next`
    pointers in order to maintain a doubly-linked list, and this costs us almost double
    in terms of memory and performance compared to `forward_list`. A similar idea
    applies to other functions as well.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，即使在`std::list`的情况下，操作的数量也是恒定的；然而，与`forward_list`相比，为了维护双向链表，我们必须修复`prev`和`next`指针，这在内存和性能方面几乎是双倍的成本。其他函数也适用类似的想法。
- en: Other functions such as `remove`, `remove_if`, `sort`, `unique`, and `reverse`
    provide similar functionalities as compared to their equivalent functions for
    `std::forward_list`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 其他函数，如`remove`、`remove_if`、`sort`、`unique`和`reverse`，提供了与它们在`std::forward_list`中等效函数相似的功能。
- en: Bidirectional Iterators
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 双向迭代器
- en: In the *Iterators* section, we saw the difference between the flexibility of
    array-based random access iterators and `forward_list`-based forward iterators.
    The flexibility of `std::list::iterator` lies between both of them. It is more
    flexible compared to forward iterators, since it can allow us to traverse backward.
    Hence, `std::list` also supports functions for reverse traversal by exposing reverse
    iterators where the operations are inverted. Having said that, it is not as flexible
    as random access iterators. Although we can advance in either direction by any
    number of moves, since these moves have to be done by traversing the elements
    one by one instead of jumping directly to the desired element, the time complexity
    is still linear, and not a constant, as in the case of random access iterators.
    Since these iterators can move in either direction, they are known as bidirectional
    iterators.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在*迭代器*部分，我们看到了基于数组的随机访问迭代器和`forward_list`的前向迭代器之间的灵活性差异。`std::list::iterator`的灵活性介于两者之间。与前向迭代器相比，它更灵活，因为它允许我们向后遍历。因此，`std::list`还支持通过暴露反向迭代器来进行反向遍历的函数，其中操作是反转的。话虽如此，它不像随机访问迭代器那样灵活。虽然我们可以向任何方向移动任意数量的步骤，但由于这些步骤必须逐个遍历元素而不是直接跳转到所需的元素，因此时间复杂度仍然是线性的，而不是常数，就像随机访问迭代器的情况一样。由于这些迭代器可以向任何方向移动，它们被称为双向迭代器。
- en: Iterator Invalidation for Different Containers
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不同容器的迭代器失效
- en: So far, we've seen that iterators provide us with a uniform way of accessing,
    traversing, inserting, and deleting elements from any container. But there are
    some cases when iterators become invalid after modifying the container, because
    the iterators are implemented based on pointers, which are bound to memory addresses.
    So, if the memory address of any node or element changes because of modification
    in the container, it invalidates the iterator, and using it regardless can lead
    to undefined behavior.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到迭代器为我们提供了一种统一的方式来访问、遍历、插入和删除任何容器中的元素。但是在某些情况下，迭代器在修改容器后会变为无效，因为迭代器是基于指针实现的，而指针绑定到内存地址。因此，如果由于容器的修改而改变了任何节点或元素的内存地址，迭代器就会失效，而不管如何使用它都可能导致未定义的行为。
- en: For example, a very basic example would be `vector::push_back`, which simply
    adds a new element at the end. However, as we saw earlier, in some cases, it also
    requires the movement of all the elements to a new buffer. Hence, all iterators,
    pointers, and even the references to any of the existing elements will be invalidated.
    Similarly, if the `vector::insert` function leads to reallocation, all the elements
    will need to be moved. Hence, all the iterators, pointers, and references are
    invalidated. If not, the function will invalidate all the iterators pointing to
    the element that is on the right side of the insertion position, since these elements
    will be shifted during the process.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个非常基本的例子是`vector::push_back`，它只是在末尾添加一个新元素。然而，正如我们之前所看到的，在某些情况下，它也需要将所有元素移动到一个新的缓冲区。因此，所有迭代器、指针，甚至对任何现有元素的引用都将失效。同样，如果`vector::insert`函数导致重新分配，所有元素都将需要移动。因此，所有迭代器、指针和引用都将失效。如果不是这样，该函数将使指向插入位置右侧元素的所有迭代器失效，因为这些元素在过程中将被移动。
- en: 'Unlike vectors, linked list-based iterators are safer for insertion and deletion
    operations because the elements will not be shifted or moved. Hence, none of the
    insertion functions for `std::list` or `forward_list` affect the validity of the
    iterators. An exception is that deletion-related operations invalidate iterators
    of the elements that are deleted, which is obvious and reasonable. It doesn''t
    affect the validity of the iterators of the rest of the elements. The following
    example shows iterator invalidation for different iterators:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 与向量不同，基于链表的迭代器对于插入和删除操作更安全，因为元素不会被移动或移位。因此，`std::list`或`forward_list`的所有插入函数都不会影响迭代器的有效性。一个例外是与删除相关的操作会使被删除的元素的迭代器失效，这是显而易见和合理的。它不会影响其余元素的迭代器的有效性。以下示例显示了不同迭代器的失效：
- en: '[PRE65]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`it4` is invalid now, since it comes after the insertion position. Accessing
    it will lead to undefined behavior:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`it4`现在无效，因为它位于插入位置之后。访问它将导致未定义的行为：'
- en: '[PRE66]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: As we saw, `std::list` is much more flexible compared to `std::forward_list`.
    A lot of operations, such as `size`, `push_back`, and `pop_back`, are provided,
    which operate with a time complexity of *O(1)*. Hence, `std::list` is used more
    frequently compared to `std::forward_list`. `forward_list` is a better alternative
    if we have very strict constraints of memory and performance, and if we are sure
    that we don't want to traverse backward. So, in most cases, `std::list` is a safer
    choice.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，与`std::forward_list`相比，`std::list`更加灵活。许多操作，如`size`、`push_back`和`pop_back`，都具有*O(1)*的时间复杂度。因此，与`std::forward_list`相比，`std::list`更常用。如果我们对内存和性能有非常严格的限制，并且确定不需要向后遍历，那么`forward_list`是一个更好的选择。因此，在大多数情况下，`std::list`是一个更安全的选择。
- en: 'Activity 2: Simulating a Card Game'
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动2：模拟一场纸牌游戏
- en: In this activity, we'll analyze a given situation and try to come up with the
    most suitable data structure to achieve the best performance.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将分析一个给定的情况，并尝试找到最适合的数据结构，以实现最佳性能。
- en: We'll try to simulate a card game. There are 4 players in the game, and each
    starts with 13 random cards. Then, we'll try to pick one card from each player's
    hand randomly. That way, we'll have 4 cards for comparison. After that, we'll
    remove the matching cards from those 4 cards. The remaining cards, if any, will
    be drawn back by the players who put them out. If there are multiple matching
    pairs out of which only one can be removed, we can choose either one. If there
    are no matching pairs, players can shuffle their own set of cards.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试模拟一场纸牌游戏。游戏中有4名玩家，每个玩家从13张随机牌开始。然后，我们将尝试从每个玩家手中随机抽取一张牌。这样，我们将有4张牌进行比较。之后，我们将从这4张牌中移除匹配的牌。剩下的牌（如果有的话）将由放出的玩家重新抽取。如果有多个匹配对，但只能移除一个，我们可以选择任意一个。如果没有匹配对，玩家可以洗牌。
- en: Now, we need to continue this process over and over until at least one of them
    is out of cards. The first one to get rid of all their cards wins the game. Then,
    we shall print the winner at the end.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一遍又一遍地继续这个过程，直到其中至少有一名玩家没有牌。第一个摆脱所有牌的人赢得比赛。然后，我们将在最后打印获胜者。
- en: 'Perform the following steps to solve the activity:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来解决这个活动：
- en: First, determine which container would be the most suitable to store the cards
    of each player. We should have four containers that have a set of cards – one
    for each player.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先确定哪种容器最适合存储每个玩家的牌。我们应该有四个包含一组牌的容器 - 每个玩家一个。
- en: Write a function to initialize and shuffle the cards.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数来初始化和洗牌。
- en: Write a function to randomly deal all the cards among the four players.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数，将所有的牌随机分配给四名玩家。
- en: Write a matching function. This function will pick a card from each player and
    compare it as required by the rules of the game. Then, it will remove the necessary
    cards. We have to choose the card wisely so that removing it would be faster.
    This parameter should also be considered while deciding on the container.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个匹配函数。这个函数将从每个玩家那里抽取一张牌，并按照游戏规则进行比较。然后，它将移除必要的牌。我们必须明智地选择牌，以便更快地移除它。在决定容器时，也应考虑这个参数。
- en: Now, let's write a function, to see whether we have a winner.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个函数，看看是否有获胜者。
- en: Finally, we'll write the core logic of the game. This will simply call the matching
    function until we have a winner based on the function written in the previous
    step.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将编写游戏的核心逻辑。这将简单地调用匹配函数，直到根据上一步中编写的函数找到获胜者。
- en: Note
  id: totrans-338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 482.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第482页找到。
- en: std::deque – Special Version of std::vector
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: std::deque - std::vector的特殊版本
- en: So far, we have seen array-based and linked list-based containers. `std::deque`
    mixes both of them and combines each of their advantages to a certain extent.
    As we have seen, although vector is a variable-length array, some of its functions,
    such as `push_front` and `pop_front`, are very costly operations. `std::deque`
    can help us overcome that. Deque is short for double-ended queue.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了基于数组和链表的容器。`std::deque`将它们两者结合起来，并在一定程度上结合了它们各自的优点。正如我们所见，尽管向量是一个可变长度的数组，但它的一些函数，比如`push_front`和`pop_front`，是非常昂贵的操作。`std::deque`可以帮助我们克服这一点。Deque是双端队列的缩写。
- en: The Structure of Deque
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Deque的结构
- en: The C++ standard only defines the behavior of the containers and not the implementation.
    The containers we have seen so far are simple enough for us to predict their implementation.
    However, deque is slightly more complicated than that. Therefore, we'll first
    take a look at its requirements, and then we will try to dive into a little bit
    of implementation.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准只定义了容器的行为，而没有实现。到目前为止，我们所见过的容器对于我们来说足够简单，可以预测它们的实现。然而，deque比这要复杂一些。因此，我们将首先看一下它的要求，然后再尝试深入一点的实现。
- en: 'The C++ standard guarantees the following time complexities for different operations
    of deque:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准保证deque的不同操作的时间复杂度如下：
- en: '*O(1)* for `push_front`, `pop_front`, `push_back`, and `pop_back`'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '* O(1) * 对于`push_front`、`pop_front`、`push_back`和`pop_back`'
- en: '*O(1)* for random access to all the elements'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '* O(1) * 对于所有元素的随机访问'
- en: Maximum of *N/2* steps in the case of insertion or deletion in the middle, where
    *N* = the size of the deque
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在插入或删除中，最多 * N/2 * 步骤，其中 * N * = deque的大小
- en: Looking at the requirements, we can say that the container should be able to
    grow in either direction very fast, and still be able to provide random access
    to all the elements. Thus, the structure has to be somewhat like a vector, but
    still expandable from the front as well as the back. The requirement for insertion
    and deletion gives a slight hint that we will be shifting the elements because
    we are only allowed to take up to *N/2* steps. And that also validates our previous
    assumption regarding behavior that is similar to vector. Since the container can
    grow in either direction quickly, we don't necessarily have to shift the elements
    toward the right every time. Instead, we can shift the elements toward the nearest
    end. That will give us a time complexity of a maximum of *N/2* steps, since the
    nearest end can't be more than *N/2* nodes away from any insertion point inside
    the container.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 从要求来看，我们可以说这个容器应该能够快速地向任一方向扩展，并且仍然能够提供对所有元素的随机访问。因此，这个结构必须有点像一个向量，但仍然可以从前面和后面扩展。插入和删除的要求略微暗示了我们将移动元素，因为我们只能走
    * N/2 * 步。这也验证了我们之前关于行为类似于向量的假设。由于容器可以快速向任一方向扩展，我们不一定每次都要将元素向右移动。相反，我们可以将元素移向最近的端点。这将给我们一个最多
    * N/2 * 步的时间复杂度，因为最近的端点不能比容器内的任何插入点更远超过 * N/2 * 个节点。
- en: Now, let's focus on random access and insertion at the front. The structure
    can't be stored in a single chunk of memory. Rather, we can have multiple chunks
    of memory of the same size. In this way, based on the index and size of the chunks
    (or the number of elements per chunk), we can decide which chunk's indexed element
    we want. That helps us to achieve random access in *O(1)* time only if we store
    pointers to all the memory chunks in a contiguous location. Hence, the structure
    can be assumed to be similar to a vector of arrays.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专注于随机访问和在前端插入。这种结构无法存储在单个内存块中。相反，我们可以有多个相同大小的内存块。通过这种方式，根据块的索引和大小（或每块元素的数量），我们可以决定我们想要哪个块的索引元素。这有助于我们在*O(1)*时间内实现随机访问，只要我们将所有内存块的指针存储在连续的位置上。因此，该结构可以被假定为类似于数组的向量。
- en: When we want to insert something at the front, and we don't have enough space
    in the first memory chunk, we have to allocate another chunk and insert its address
    in the vector of pointers at the front. That might require reallocation of the
    vector of pointers, but the actual data will not be moved. To optimize that reallocation,
    instead of starting from the first chunk, we can start the insertion from the
    middle chunk of the vector. In that way, we are safe up to a certain number of
    front insertions. We can follow the same while reallocating the vector of pointers.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要在前面插入一些东西时，如果第一个内存块中没有足够的空间，我们必须分配另一个块，并将其地址插入到指针向量的前面。这可能需要重新分配指针向量，但实际数据不会被移动。为了优化该重新分配，我们可以从向量的中间块开始插入，而不是从第一个块开始。这样，我们可以在一定数量的前端插入中保持安全。在重新分配指针向量时，我们可以采取相同的方法。
- en: Note
  id: totrans-351
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Since the deque is not as simple as the other containers discussed in this chapter,
    the actual implementation might differ or might have a lot more optimizations
    than we discussed, but the basic idea remains the same. And that is, we need multiple
    chunks of contiguous memory to implement such a container.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 由于deque不像本章讨论的其他容器那样简单，实际的实现可能会有所不同，或者可能有比我们讨论的更多的优化，但基本思想仍然是一样的。也就是说，我们需要多个连续内存块来实现这样一个容器。
- en: The functions and operations supported by deque are more of a combination of
    functions supported by vectors and lists; hence, we have `push_front`, `push_back`,
    `insert`, `emplace_front`, `emplace_back`, `emplace`, `pop_front`, `pop_back`,
    and `erase`, among others. We also have the vector's functions, such as `shrink_to_fit`,
    to optimize the capacity, but we don't have a function called `capacity` since
    this is highly dependent on the implementation, and is, therefore, not expected
    to be exposed. And, as you might expect, it provides random access iterators just
    like a vector.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: deque支持的函数和操作更多地是向量和列表支持的函数的组合；因此，我们有`push_front`，`push_back`，`insert`，`emplace_front`，`emplace_back`，`emplace`，`pop_front`，`pop_back`和`erase`等。我们还有向量的函数，比如`shrink_to_fit`，以优化容量，但我们没有一个叫做`capacity`的函数，因为这高度依赖于实现，因此不会被暴露。正如你所期望的，它提供了与向量一样的随机访问迭代器。
- en: 'Let''s take a look at how we can use different insertion and deletion operations
    on deque:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在deque上使用不同的插入和删除操作：
- en: '[PRE67]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Such a structure may be used in cases such as boarding queues for flights.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的结构可以用于飞行登机队列等情况。
- en: The only thing that differs among the containers is the performance and memory
    requirements. Deque will provide very good performance for both insertion and
    deletion at the front as well as the end. Insertion and deletion in the middle
    is also a bit faster than for a vector on average, although, asymptotically, it
    is the same as that of a vector.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 容器之间唯一不同的是性能和内存需求。对于插入和删除，deque在前端和末尾都提供非常好的性能。在中间插入和删除的速度也比向量平均快一点，尽管在渐近意义上，它与向量相同。
- en: Apart from that, deque also allows us to have customer allocators just like
    a vector. We can specify it as a second template parameter while initializing
    it. One thing to note here is that the allocator is part of the type and not part
    of the object. This means we can't compare two objects of two deques or two vectors
    where each has a different kind of allocator. Similarly, we can't have other operations,
    such as an assignment or copy constructor, with objects of different types of
    allocators.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，deque还允许我们像向量一样拥有自定义分配器。我们可以在初始化时将其指定为第二个模板参数。这里需要注意的一点是，分配器是类型的一部分，而不是对象的一部分。这意味着我们不能比较两个具有不同类型分配器的deque或两个向量的对象。同样，我们不能对具有不同类型分配器的对象进行其他操作，比如赋值或复制构造函数。
- en: As we saw, `std::deque` has a slightly more complex structure compared to other
    containers we examined before that. It is, in fact, the only container that provides
    efficient random access along with fast `push_front` and `push_back` functions.
    Deque is used as an underlying container for others, as we'll see in the upcoming
    section.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`std::deque`与我们之前讨论过的其他容器相比具有稍微复杂的结构。事实上，它是唯一一个既提供高效的随机访问又提供快速的`push_front`和`push_back`函数的容器。Deque被用作其他容器的底层容器，我们将在接下来的部分中看到。
- en: Container Adaptors
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器适配器
- en: The containers that we've seen until now are built from scratch. In this section,
    we'll look at the containers that are built on top of other containers. There
    are multiple reasons to provide a wrapper over existing containers, such as providing
    more semantic meaning to the code, restricting someone from accidentally using
    unintended functions just because they are available, and to provide specific
    interfaces.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的容器都是从头开始构建的。在本节中，我们将看看建立在其他容器之上的容器。提供对现有容器的包装有多种原因，比如为代码提供更多的语义含义，防止某人意外使用不期望的函数，以及提供特定的接口。
- en: One such specific use case is the **stack** data structure. The stack follows
    the **LIFO** (**Last In First Out**) structure for accessing and processing data.
    In terms of functions, it can insert and delete only at one end of the container
    and can't update or even access any element except at the mutating end. This end
    is called the top of the stack. We can easily use any other container, such as
    a vector or deque too, since it can meet these requirements by default. However,
    there are some fundamental problems in doing that.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 一个这样的特定用例是**栈**数据结构。栈遵循**LIFO**（后进先出）结构来访问和处理数据。在功能方面，它只能在容器的一端插入和删除，并且不能更新或甚至访问除了变异端之外的任何元素。这一端被称为栈顶。我们也可以轻松地使用任何其他容器，比如vector或deque，因为它默认可以满足这些要求。然而，这样做会有一些根本性的问题。
- en: 'The following example shows two implementations of the stack:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了栈的两种实现：
- en: '[PRE68]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: As we can see in this example, the first block of the stack using deque provides
    a semantic meaning only by the name of the variable. The functions operating on
    the data still don't force the programmer to add code that shouldn't be allowed,
    such as `push_front`. Also, the `push_back` and `pop_back` functions expose unnecessary
    details, which should be known by default since it is a stack.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这个例子中所看到的，使用deque的栈的第一个块仅通过变量的名称提供了语义上的含义。操作数据的函数仍然不会强迫程序员添加不应该被允许的代码，比如`push_front`。此外，`push_back`和`pop_back`函数暴露了不必要的细节，这些细节应该默认情况下就应该知道，因为它是一个栈。
- en: In comparison to this, if we look at the second version, it looks much more
    accurate in indicating what it does. And, most importantly, it doesn't allow anyone
    to do anything that was unintended, even accidentally.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相比，如果我们看第二个版本，它看起来更准确地指示了它的功能。而且，最重要的是，它不允许任何人做任何意外的事情。
- en: 'The second version of the stack is nothing but a wrapper over the previous
    container, deque, by providing a nice and restricted interface to the user. This
    is called a container adaptor. There are three container adaptors provided by
    C++: `std::stack`, `std::queue`, and `std::priority_queue`. Let''s now take a
    brief look at each of them.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 栈的第二个版本只是通过为用户提供一个良好且受限的接口来包装前一个容器deque。这被称为容器适配器。C++提供了三个容器适配器：`std::stack`、`std::queue`和`std::priority_queue`。现在让我们简要地看一下它们各自。
- en: std::stack
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: std::stack
- en: As explained earlier, adaptors simply reuse other containers, such as deque,
    vector, or any other container for that matter. `std::stack`, by default, adapts
    `std::deque` as its underlying container. It provides an interface that is only
    relevant to the stack – `empty`, `size`, `top`, `push`, `pop`, and `emplace`.
    Here, `push` simply calls the `push_back` function for the underlying container,
    and `pop` simply calls the `pop_back` function. `top` calls the `back` function
    from the underlying container to get the last element, which is the top of the
    stack. Thus, it restricts the user operations to LIFO since it only allows us
    to update values at one end of the underlying container.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，适配器简单地重用其他容器，比如deque、vector或其他任何容器。`std::stack`默认适配`std::deque`作为其底层容器。它提供了一个仅与stack相关的接口——`empty`、`size`、`top`、`push`、`pop`和`emplace`。在这里，`push`只是调用底层容器的`push_back`函数，而`pop`只是调用`pop_back`函数。`top`调用底层容器的`back`函数来获取最后一个元素，也就是栈顶。因此，它限制了用户操作为LIFO，因为它只允许我们在底层容器的一端更新值。
- en: 'Here, we are using deque as an underlying container, and not a vector. The
    reason behind it is that deque doesn''t require you to shift all the elements
    during reallocation, unlike vector. Hence, it is more efficient to use deque compared
    to vector. However, if, for some scenario, any other container is more likely
    to give better performance, stack gives us the facility to provide a container
    as a template parameter. So, we can build a stack using a vector or list as well,
    as shown here:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用deque作为底层容器，而不是vector。其背后的原因是deque在重新分配时不需要您移动所有元素，而vector需要。因此，与vector相比，使用deque更有效率。然而，如果在某种情况下，任何其他容器更可能提供更好的性能，stack允许我们将容器作为模板参数提供。因此，我们可以使用vector或list构建一个stack，就像这里所示：
- en: '[PRE69]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: All the operations of a stack have a time complexity of *O(1)*. There is usually
    no overhead of forwarding the call to the underlying container as everything can
    be inlined by the compiler with optimizations.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 栈的所有操作的时间复杂度都是*O(1)*。通常不会有将调用转发到底层容器的开销，因为编译器可以通过优化将所有内容内联化。
- en: std::queue
  id: totrans-373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: std::queue
- en: Just like `std::stack`, we have another container adapter to deal with the frequent
    scenario of `std::queue`. It almost has the same set of functions as a stack,
    but the meaning and behavior are different in order to follow FIFO instead of
    LIFO. For `std::queue`, `push` means `push_back`, just like a stack, but `pop`
    is `pop_front`. Instead of `pop`, since queue should be exposing both the ends
    for reading, it has `front` and `back` functions.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`std::stack`一样，我们还有另一个容器适配器来处理频繁的`std::queue`场景。它几乎具有与栈相同的一组函数，但意义和行为不同，以遵循FIFO而不是LIFO。对于`std::queue`，`push`意味着`push_back`，就像栈一样，但`pop`是`pop_front`。而不是`pop`，因为队列应该暴露两端以供读取，它有`front`和`back`函数。
- en: 'Here''s a small example of the usage of `std::queue`:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`std::queue`的一个小例子：
- en: '[PRE70]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: As shown in this example, first, we are inserting `1`, `2`, and `3` in that
    order. After that, we are popping one element off the queue. Since `1` was pushed
    first, it is removed from the queue first. Then, the next push inserts `4` at
    the back of the queue.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如本例所示，首先，我们按顺序插入`1`、`2`和`3`。然后，我们从队列中弹出一个元素。由于`1`被先推入，所以它首先从队列中移除。然后，下一个推入将`4`插入到队列的末尾。
- en: '`std::queue` also uses `std::deque` as an underlying container for the same
    reason as stack, and it also has a time complexity of *O(1)* for all the methods
    shown here.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::queue`也出于与stack相同的原因使用`std::deque`作为底层容器，它的所有方法的时间复杂度也都是*O(1)*。'
- en: std::priority_queue
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: std::priority_queue
- en: Priority queue provides a very useful structure called **heap** via its interface.
    A heap data structure is known for fast access to the minimum (or maximum) element
    from the container. Getting the min/max element is an operation with a time complexity
    of *O(1)*. Insertion has *O(log n)* time complexity, while deletion can only be
    performed for the min/max element, which always stays on the top.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 优先队列通过其接口提供了一个非常有用的结构称为**堆**。堆数据结构以快速访问容器中的最小（或最大）元素而闻名。获取最小/最大元素是一个时间复杂度为*O(1)*的操作。插入的时间复杂度为*O(log
    n)*，而删除只能针对最小/最大元素进行，它总是位于顶部。
- en: An important thing to note here is that we can only have either the min or max
    function made available quickly, and not both of them. This is decided by the
    comparator provided to the container. Unlike stack and queue, a priority queue
    is based on a vector by default, but we can change it if required. Also, by default,
    the comparator is `std::less`. Since this is a heap, the resultant container is
    a max heap. This means that the maximum element will be on top by default.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一点是，我们只能快速获得最小值或最大值函数中的一个，而不是两者都有。这是由提供给容器的比较器决定的。与栈和队列不同，优先队列默认基于向量，但如果需要，我们可以更改它。此外，默认情况下，比较器是`std::less`。由于这是一个堆，结果容器是一个最大堆。这意味着默认情况下最大元素将位于顶部。
- en: Here, since insertion needs to make sure that we can access the top element
    (min or max depending on the comparator) instantly, it is not simply forwarding
    the call to the underlying container. Instead, it is implementing the algorithm
    for heapifying the data by bubbling it up to the top as required using the comparator.
    This operation takes a time duration that is logarithmic in proportion to the
    size of the container, hence the time complexity of *O(log n)*. The invariant
    also needs to be maintained while initializing it with multiple elements. Here,
    however, the `priority_queue` constructor does not simply call the insertion function
    for each element; instead, it applies different heapification algorithms to do
    it faster in *O(n)*.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，由于插入需要确保我们可以立即访问顶部元素（根据比较器是最小值还是最大值），它不仅仅是将调用转发给底层容器。相反，它通过使用比较器实现了堆化数据的算法，根据需要将其冒泡到顶部。这个操作的时间复杂度与容器的大小成对数比例，因此时间复杂度为*O(log
    n)*。在初始化时也需要保持不变。然而，在这里，`priority_queue`构造函数不仅仅是为每个元素调用插入函数；相反，它应用不同的堆化算法以在*O(n)*的时间内更快地完成。
- en: Iterators for Adaptors
  id: totrans-383
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 适配器的迭代器
- en: All the adaptors that we have seen so far expose functionality only as required
    to fulfill its semantic meaning. Logically thinking, traversing through stack,
    queue, and priority queue doesn't make sense. At any point, we should only be
    able to see the front element. Hence, STL doesn't provide iterators for that.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们所见过的所有适配器都只暴露出满足其语义意义所需的功能。从逻辑上讲，遍历栈、队列和优先队列是没有意义的。在任何时候，我们只能看到前面的元素。因此，STL不为此提供迭代器。
- en: Benchmarking
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基准测试
- en: As we have seen that different containers have a variety of pros and cons, no
    one container is the perfect choice for every situation. Sometimes, multiple containers
    may give a similar performance on average for the given scenario. In such cases,
    benchmarking is our friend. This is a process of determining the better approach
    based on statistical data.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，不同的容器有各种优缺点，没有一个容器是每种情况的完美选择。有时，多个容器可能在给定情况下平均表现出类似的性能。在这种情况下，基准测试是我们的朋友。这是一个根据统计数据确定更好方法的过程。
- en: Consider a scenario where we want to store data in contiguous memory, access
    it, and operate on it using various functions. We can say that we should either
    use `std::vector` or `std::deque`. But we are not sure which among these will
    be the best. At first glance, both of them seem to give good performance for the
    situation. Among different operations, such as access, insertion, `push_back`,
    and modifying a specific element, some are in favor of `std::vector` and some
    of are in favor of `std::deque`. So, how should we proceed?
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一个情景，我们想要在连续的内存中存储数据，访问它，并使用各种函数对其进行操作。我们可以说我们应该使用`std::vector`或`std::deque`中的一个。但我们不确定其中哪一个是最好的。乍一看，它们两个似乎都对这种情况有良好的性能。在不同的操作中，比如访问、插入、`push_back`和修改特定元素，有些对`std::vector`有利，有些对`std::deque`有利。那么，我们应该如何继续？
- en: The idea is to create a small prototype of the actual model and implement it
    using both `std::vector` and `std::deque`. And then, measure the performance of
    both over the prototype. Based on the result of the performance testing, we can
    choose the one that gives better results overall.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是创建一个实际模型的小型原型，并使用`std::vector`和`std::deque`来实现它。然后，测量原型的性能。根据性能测试的结果，我们可以选择总体表现更好的那个。
- en: The simplest way to do that is to measure the time required to perform different
    operations for both and compare them. However, the same operation may take different
    amounts of time during different runs, since there are other factors that come
    into the picture, such as OS scheduling, cache, and interrupts, among others.
    These parameters can cause our results to deviate quite heavily, because, to perform
    any operation once, is a matter of a few hundred nanoseconds. To overcome that,
    we can perform the operation multiple times (by that, we mean a few million times)
    until we get a considerable time difference between both the measurements.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是测量执行不同操作所需的时间，并比较它们。然而，同样的操作在不同运行时可能需要不同的时间，因为还有其他因素会影响，比如操作系统调度、缓存和中断等。这些参数可能会导致我们的结果相差很大，因为执行任何操作一次只需要几百纳秒。为了克服这一点，我们可以多次执行操作（也就是说，几百万次），直到我们在两次测量之间得到了相当大的时间差异。
- en: There are some benchmarking tools that we can use, such as quic[k-bench.com](http://k-bench.com),
    which provide us with an easy way to run benchmarks. You can try running the operations
    mentioned earlier on vector and deque to quickly compare the performance differences.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些基准测试工具可以使用，比如[quic[k-bench.com](http://k-bench.com)]，它们为我们提供了一个简单的方法来运行基准测试。您可以尝试在向量和双端队列上快速比较性能差异。
- en: 'Activity 3: Simulating a Queue for a Shared Printer in an Office'
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动3：模拟办公室中共享打印机的队列
- en: In this activity, we'll simulate a queue for a shared printer in an office.
    In any corporate office, usually, the printer is shared across the whole floor
    in the printer room. All the computers in this room are connected to the same
    printer. But a printer can do only one printing job at any point in time, and
    it also takes some time to complete any job. In the meantime, some other user
    can send another print request. In such a case, a printer needs to store all the
    pending jobs somewhere so that it can take them up once its current task is done.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将模拟办公室中共享打印机的队列。在任何公司办公室中，通常打印机是在打印机房间整个楼层共享的。这个房间里的所有计算机都连接到同一台打印机。但是一台打印机一次只能做一项打印工作，而且完成任何工作也需要一些时间。与此同时，其他用户可以发送另一个打印请求。在这种情况下，打印机需要将所有待处理的作业存储在某个地方，以便在当前任务完成后可以处理它们。
- en: 'Perform the following steps to solve the activity:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来解决这个活动：
- en: Create a class called `Job` (comprising an ID for the job, the name of the user
    who submitted it, and the number of pages).
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Job`的类（包括作业的ID、提交作业的用户的名称和页数）。
- en: Create a class called `Printer`. This will provide an interface to add new jobs
    and process all the jobs added so far.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Printer`的类。这将提供一个接口来添加新的作业并处理到目前为止添加的所有作业。
- en: To implement the `printer` class, it will need to store all the pending jobs.
    We'll implement a very basic strategy – first come, first served. Whoever submits
    the job first will be the first to get the job done.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现`printer`类，它将需要存储所有待处理的作业。我们将实现一个非常基本的策略 - 先来先服务。谁先提交作业，谁就会第一个完成作业。
- en: Finally, simulate a scenario where multiple people are adding jobs to the printer,
    and the printer is processing them one by one.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，模拟多人向打印机添加作业，并且打印机逐个处理它们的情景。
- en: Note
  id: totrans-398
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 487.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第487页找到。
- en: Summary
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how we should go about designing an application
    based on its requirements by choosing the way we want to store the data. We explained
    different types of operations that we can perform on data, which can be used as
    parameters for comparison between multiple data structures, based on the frequency
    of those operations. We learned that container adaptors provide a very useful
    way to indicate our intentions in the code. We saw that using more restrictive
    containers provided as adaptors, instead of using primary containers providing
    more functionality, is more effective in terms of maintainability, and also reduces
    human errors. We explained various data structures – `std::array`, `std::vector`,
    `std::list`, and `std::forward_list`, which are very frequent in any application
    development process, in detail and their interfaces provided by C++ by default.
    This helps us to write efficient code without reinventing the whole cycle and
    making the process a lot faster.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了根据需求设计应用程序的方法，选择我们想要存储数据的方式。我们解释了可以对数据执行的不同类型的操作，这些操作可以用作多个数据结构之间比较的参数，基于这些操作的频率。我们了解到容器适配器为我们在代码中指示我们的意图提供了一种非常有用的方式。我们看到，使用更为限制的容器适配器，而不是使用提供更多功能的主要容器，从可维护性的角度来看更有效，并且还可以减少人为错误。我们详细解释了各种数据结构
    - `std::array`、`std::vector`、`std::list`和`std::forward_list`，这些数据结构在任何应用程序开发过程中都非常频繁，并且它们的接口是由C++默认提供的。这帮助我们编写高效的代码，而不需要重新发明整个周期，使整个过程更快。
- en: In this chapter, all the structures we saw are linear in a logical manner, that
    is, we can either go forward or backward from any element. In the next chapter,
    we'll explore problems that can't be solved easily with these structures and implement
    new types of structures to solve those problems.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到的所有结构在逻辑上都是线性的，也就是说，我们可以从任何元素向前或向后移动。在下一章中，我们将探讨无法轻松解决这些结构的问题，并实现新类型的结构来解决这些问题。
