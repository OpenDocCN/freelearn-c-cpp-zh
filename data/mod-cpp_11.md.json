["```cpp\n        std::vector<int> v1 { 1, 2, 3, 4, 5 };\n```", "```cpp\n        int arr[] = { 1, 2, 3, 4, 5 }; \n        std::vector<int> v2(arr, arr + 5); // { 1, 2, 3, 4, 5 }\n```", "```cpp\n        std::list<int> l{ 1, 2, 3, 4, 5 }; \n        std::vector<int> v3(l.begin(), l.end()); //{ 1, 2, 3, 4, 5 }\n```", "```cpp\n        std::vector<int> v4(5, 1); // {1, 1, 1, 1, 1}\n```", "```cpp\n        std::vector<int> v1{ 1, 2, 3, 4, 5 };\n        v1.push_back(6); // v1 = { 1, 2, 3, 4, 5, 6 }\n```", "```cpp\n        v1.pop_back();\n```", "```cpp\n        int arr[] = { 1, 2, 3, 4, 5 };\n        std::vector<int> v2;\n        v2.insert(v2.begin(), arr, arr + 5); // v2 = { 1, 2, 3, 4, 5 }\n```", "```cpp\n        struct foo\n        {\n          int a;\n          double b;\n          std::string c;\n\n          foo(int a, double b, std::string const & c) :\n            a(a), b(b), c(c) {}\n        };\n\n        std::vector<foo> v3;\n        v3.emplace_back(1, 1.0, \"one\"s); \n        // v3 = { foo{1, 1.0, \"one\"} }\n```", "```cpp\n        v3.emplace(v3.begin(), 2, 2.0, \"two\"s);\n        // v3 = { foo{2, 2.0, \"two\"}, foo{1, 1.0, \"one\"} }\n```", "```cpp\n        std::vector<int> v1{ 1, 2, 3, 4, 5 };\n        std::vector<int> v2{ 10, 20, 30 };\n        v2 = v1; // v1 = { 1, 2, 3, 4, 5 }\n```", "```cpp\n        int arr[] = { 1, 2, 3, 4, 5 };\n        std::vector<int> v3;\n        v3.assign(arr, arr + 5); // v3 = { 1, 2, 3, 4, 5 }\n```", "```cpp\n        std::vector<int> v4{ 1, 2, 3, 4, 5 };\n        std::vector<int> v5{ 10, 20, 30 };\n        v4.swap(v5); // v4 = { 10, 20, 30 }, v5 = { 1, 2, 3, 4, 5 }\n```", "```cpp\n        std::vector<int> v6{ 1, 2, 3, 4, 5 };\n        v6.clear(); // v6 = { }\n```", "```cpp\n        std::vector<int> v7{ 1, 2, 3, 4, 5 };\n        v7.erase(v7.begin() + 2, v7.begin() + 4); // v7 = { 1, 2, 5 }\n```", "```cpp\n        void process(int const * const arr, int const size) \n        { /* do something */ }\n\n        std::vector<int> v{ 1, 2, 3, 4, 5 };\n        process(v.data(), static_cast<int>(v.size()));\n```", "```cpp\n        process(&v[0], static_cast<int>(v.size()));\n```", "```cpp\n        process(&v.front(), static_cast<int>(v.size()));\n```", "```cpp\n        process(&*v.begin(), static_cast<int>(v.size()));\n```", "```cpp\n    std::vector<int> v{ 1, 2, 3, 4, 5 };\n    std::vector<int>().swap(v); // v.size = 0, v.capacity = 0\n```", "```cpp\n        std::bitset<8> b1; // [0,0,0,0,0,0,0,0]\n```", "```cpp\n        std::bitset<8> b2{ 10 }; // [0,0,0,0,1,0,1,0]\n```", "```cpp\n        std::bitset<8> b3{ \"1010\"s }; // [0,0,0,0,1,0,1,0]\n```", "```cpp\n        std::bitset<8> b4 \n          { \"ooooxoxo\"s, 0, std::string::npos, 'o', 'x' }; \n          // [0,0,0,0,1,0,1,0]\n```", "```cpp\n        std::bitset<8> bs{ 10 };\n        std::cout << \"has \" << bs.count() << \" 1s\" << std::endl;\n```", "```cpp\n        if (bs.any()) std::cout << \"has some 1s\" << std::endl;\n```", "```cpp\n        if (bs.all()) std::cout << \"has only 1s\" << std::endl;\n```", "```cpp\n        if (bs.none()) std::cout << \"has no 1s\" << std::endl;\n```", "```cpp\n        if (!bs.test(0)) std::cout << \"even\" << std::endl;\n```", "```cpp\n        if(!bs[0]) std::cout << \"even\" << std::endl;\n```", "```cpp\n        std::bitset<8> b1{ 42 }; // [0,0,1,0,1,0,1,0]\n        std::bitset<8> b2{ 11 }; // [0,0,0,0,1,0,1,1]\n        auto b3 = b1 | b2;       // [0,0,1,0,1,0,1,1]\n        auto b4 = b1 & b2;       // [0,0,0,0,1,0,1,0]\n        auto b5 = b1 ^ b2;       // [1,1,0,1,1,1,1,0]\n        auto b6 = ~b1;           // [1,1,0,1,0,1,0,1]\n```", "```cpp\n        auto b7 = b1 << 2;       // [1,0,1,0,1,0,0,0]\n        auto b8 = b1 >> 2;       // [0,0,0,0,1,0,1,0]\n```", "```cpp\n        b1.flip();               // [1,1,0,1,0,1,0,1]\n        b1.flip(0);              // [1,1,0,1,0,1,0,0]\n```", "```cpp\n        b1.set(0, true);         // [1,1,0,1,0,1,0,1]\n        b1.set(0, false);        // [1,1,0,1,0,1,0,0]\n```", "```cpp\n        b1.reset(2);             // [1,1,0,1,0,0,0,0]\n```", "```cpp\n        std::bitset<8> bs{ 42 };\n        auto n1 = bs.to_ulong();  // n1 = 42UL\n        auto n2 = bs.to_ullong(); // n2 = 42ULL\n```", "```cpp\n        auto s1 = bs.to_string();         // s1 = \"00101010\"\n        auto s2 = bs.to_string('o', 'x'); // s2 = \"ooxoxoxo\"\n```", "```cpp\n    #define BORDER_NONE   0x00\n    #define BORDER_LEFT   0x01\n    #define BORDER_TOP    0x02\n    #define BORDER_RIGHT  0x04\n    #define BORDER_BOTTOM 0x08\n\n    void apply_style(unsigned int const style)\n    {\n      if (style & BORDER_BOTTOM) { /* do something */ }\n    }\n\n    // initialize with no flags\n    unsigned int style = BORDER_NONE;\n    // set a flag\n    style = BORDER_BOTTOM;\n    // add more flags\n    style |= BORDER_LEFT | BORDER_RIGHT | BORDER_TOP;\n    // remove some flags\n    style &= ~BORDER_LEFT;\n    style &= ~BORDER_RIGHT;\n    // test if a flag is set\n    if ((style & BORDER_BOTTOM) == BORDER_BOTTOM) {}\n    // pass the flags as argument to a function\n    apply_style(style);\n```", "```cpp\n    struct border_flags\n    {\n      static const int left = 0;\n      static const int top = 1;\n      static const int right = 2;\n      static const int bottom = 3;\n    };\n\n    // initialize with no flags\n    std::bitset<4> style;\n    // set a flag\n    style.set(border_flags::bottom);\n    // set more flags\n    style\n      .set(border_flags::left)\n      .set(border_flags::top)\n      .set(border_flags::right);\n    // remove some flags\n    style[border_flags::left] = 0;\n    style.reset(border_flags::right);\n    // test if a flag is set\n    if (style.test(border_flags::bottom)) {}\n    // pass the flags as argument to a function\n    apply_style(style.to_ulong());\n```", "```cpp\n    template <size_t N>\n    std::vector<unsigned long> bitset_to_vectorulong(std::bitset<N> bs)\n    {\n      auto result = std::vector<unsigned long> {};\n      auto const size = 8 * sizeof(unsigned long);\n      auto const mask = std::bitset<N>{ static_cast<unsigned long>(-1)};\n\n      auto totalbits = 0;\n      while (totalbits < N)\n      {\n        auto value = (bs & mask).to_ulong();\n        result.push_back(value);\n        bs >>= size;\n        totalbits += size;\n      }\n\n      return result;\n    }\n\n    std::bitset<128> bs =\n           (std::bitset<128>(0xFEDC) << 96) |\n           (std::bitset<128>(0xBA98) << 64) |\n           (std::bitset<128>(0x7654) << 32) |\n           std::bitset<128>(0x3210);\n\n    std::cout << bs << std::endl;\n\n    auto result = bitset_to_vectorulong(bs);\n    for (auto const v : result) \n      std::cout << std::hex << v << std::endl;\n```", "```cpp\n        std::vector<bool> bv; // []\n```", "```cpp\n        bv.push_back(true);  // [1]\n        bv.push_back(true);  // [1, 1]\n        bv.push_back(false); // [1, 1, 0]\n        bv.push_back(false); // [1, 1, 0, 0]\n        bv.push_back(true);  // [1, 1, 0, 0, 1]\n```", "```cpp\n        bv[3] = true;        // [1, 1, 0, 1, 1]\n```", "```cpp\n        auto count_of_ones = std::count(bv.cbegin(), bv.cend(), true);\n```", "```cpp\n        bv.erase(bv.begin() + 2); // [1, 1, 1, 1]\n```", "```cpp\n        std::vector<bool> bv;\n        bv.resize(10);\n        auto& bit = bv[0];      // error\n```", "```cpp\n        auto& bit = *bv.begin(); // error\n```", "```cpp\n    class bitvector\n    {\n      std::vector<bool> bv;\n    public:\n      bitvector(std::vector<bool> const & bv) : bv(bv) {}\n      bool operator[](size_t const i) { return bv[i]; }\n\n      inline bool any() const {\n        for (auto b : bv) if (b) return true;\n          return false;\n      }\n\n      inline bool all() const {\n        for (auto b : bv) if (!b) return false;\n          return true;\n      }\n\n      inline bool none() const { return !any(); }\n\n      inline size_t count() const {\n        return std::count(bv.cbegin(), bv.cend(), true);\n      }\n\n      inline size_t size() const { return bv.size(); }\n\n      inline bitvector & add(bool const value) {\n        bv.push_back(value);\n        return *this;\n      }\n\n      inline bitvector & remove(size_t const index) {\n        if (index >= bv.size())\n          throw std::out_of_range(\"Index out of range\");\n        bv.erase(bv.begin() + index);\n        return *this;\n      }\n\n      inline bitvector & set(bool const value = true) {\n        for (size_t i = 0; i < bv.size(); ++i)\n          bv[i] = value;\n        return *this;\n      }\n\n      inline bitvector& set(size_t const index, bool const value = true) {\n        if (index >= bv.size())\n          throw std::out_of_range(\"Index out of range\");\n        bv[index] = value;\n        return *this;\n      }\n\n      inline bitvector & reset() {\n        for (size_t i = 0; i < bv.size(); ++i) bv[i] = false;\n        return *this;\n      }\n\n      inline bitvector & reset(size_t const index) {\n        if (index >= bv.size())\n          throw std::out_of_range(\"Index out of range\");\n        bv[index] = false;\n        return *this;\n      }\n\n      inline bitvector & flip() {\n        bv.flip();\n        return *this;\n      }\n\n      std::vector<bool>& data() { return bv; }\n    };\n```", "```cpp\n    bitvector bv;\n    bv.add(true).add(true).add(false); // [1, 1, 0]\n    bv.add(false);                     // [1, 1, 0, 0]\n    bv.add(true);                      // [1, 1, 0, 0, 1]\n\n    if (bv.any()) std::cout << \"has some 1s\" << std::endl;\n    if (bv.all()) std::cout << \"has only 1s\" << std::endl;\n    if (bv.none()) std::cout << \"has no 1s\" << std::endl;\n    std::cout << \"has \" << bv.count() << \" 1s\" << std::endl;\n\n    bv.set(2, true);                   // [1, 1, 1, 0, 1]\n    bv.set();                          // [1, 1, 1, 1, 1]\n\n    bv.reset(0);                       // [0, 1, 1, 1, 1]\n    bv.reset();                        // [0, 0, 0, 0, 0]\n\n    bv.flip();                         // [1, 1, 1, 1, 1]\n```", "```cpp\n        std::vector<int> v{ 1, 1, 2, 3, 5, 8, 13 };\n\n        auto it = std::find(v.cbegin(), v.cend(), 3);\n        if (it != v.cend()) std::cout << *it << std::endl;\n```", "```cpp\n        std::vector<int> v{ 1, 1, 2, 3, 5, 8, 13 };\n\n        auto it = std::find_if(v.cbegin(), v.cend(), \n                               [](int const n) {return n > 10; });\n        if (it != v.cend()) std::cout << *it << std::endl;\n```", "```cpp\n        std::vector<int> v{ 1, 1, 2, 3, 5, 8, 13 };\n\n        auto it = std::find_if_not(v.cbegin(), v.cend(), \n                            [](int const n) {return n % 2 == 1; });\n        if (it != v.cend()) std::cout << *it << std::endl;\n```", "```cpp\n        std::vector<int> v{ 1, 1, 2, 3, 5, 8, 13 };\n        std::vector<int> p{ 5, 7, 11 };\n\n        auto it = std::find_first_of(v.cbegin(), v.cend(),\n                                     p.cbegin(), p.cend());\n        if (it != v.cend()) \n          std::cout << \"found \" << *it\n                    << \" at index \" << std::distance(v.cbegin(), it)\n                    << std::endl;\n```", "```cpp\n        std::vector<int> v1{ 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1 };\n        std::vector<int> v2{ 1, 0, 1 };\n\n        auto it = std::find_end(v1.cbegin(), v1.cend(),\n                                v2.cbegin(), v2.cend());\n        if (it != v1.cend())\n          std::cout << \"found at index \"\n                    << std::distance(v1.cbegin(), it) << std::endl;\n```", "```cpp\n        auto text = \"The quick brown fox jumps over the lazy dog\"s;\n        auto word = \"over\"s;\n\n        auto it = std::search(text.cbegin(), text.cend(),\n                              word.cbegin(), word.cend());\n\n        if (it != text.cend())\n          std::cout << \"found \" << word\n                    << \" at index \" \n                    << std::distance(text.cbegin(), it) << std::endl;\n```", "```cpp\n        auto text = \"The quick brown fox jumps over the lazy dog\"s;\n        auto word = \"over\"s;\n\n        auto it = std::search(\n          text.cbegin(), text.cend(),\n          std::make_boyer_moore_searcher(word.cbegin(), word.cend()));\n\n        if (it != text.cend())\n          std::cout << \"found \" << word\n                    << \" at index \" \n                    << std::distance(text.cbegin(), it) << std::endl;\n```", "```cpp\n        std::vector<int> v{ 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1 };\n\n        auto it = std::search_n(v.cbegin(), v.cend(), 2, 0);\n        if (it != v.cend())\n          std::cout << \"found at index \" \n                    << std::distance(v.cbegin(), it) << std::endl;\n```", "```cpp\n        std::vector<int> v{ 1, 1, 2, 3, 5, 8, 13 };\n\n        auto it = std::adjacent_find(v.cbegin(), v.cend());\n        if (it != v.cend())\n          std::cout << \"found at index \" \n                    << std::distance(v.cbegin(), it) << std::endl;\n\n       auto it = std::adjacent_find(\n         v.cbegin(), v.cend(),\n         [](int const a, int const b) {\n           return IsPrime(a) && IsPrime(b); });\n\n        if (it != v.cend())\n          std::cout << \"found at index \" \n                    << std::distance(v.cbegin(), it) << std::endl;\n```", "```cpp\n        std::vector<int> v{ 1, 1, 2, 3, 5, 8, 13 };\n\n        auto success = std::binary_search(v.cbegin(), v.cend(), 8);\n        if (success) std::cout << \"found\" << std::endl;\n```", "```cpp\n        std::vector<int> v{ 1, 1, 2, 3, 5, 8, 13 };\n\n        auto it = std::lower_bound(v.cbegin(), v.cend(), 1);\n        if (it != v.cend())\n          std::cout << \"lower bound at \"\n                    << std::distance(v.cbegin(), it) << std::endl;\n```", "```cpp\n        std::vector<int> v{ 1, 1, 2, 3, 5, 8, 13 };\n\n        auto it = std::upper_bound(v.cbegin(), v.cend(), 1);\n        if (it != v.cend())\n          std::cout << \"upper bound at \"\n                    << std::distance(v.cbegin(), it) << std::endl;\n```", "```cpp\n        std::vector<int> v{ 1, 1, 2, 3, 5, 8, 13 };\n\n        auto bounds = std::equal_range(v.cbegin(), v.cend(), 1);\n        std::cout << \"range between indexes \"\n                  << std::distance(v.cbegin(), bounds.first)\n                  << \" and \"\n                  << std::distance(v.cbegin(), bounds.second)\n                  << std::endl;\n```", "```cpp\n    template<class ForwardIterator, class Searcher>\n    ForwardIterator search(ForwardIterator first, ForwardIterator last,\n                           const Searcher& searcher );\n```", "```cpp\n        std::vector<int> v{3, 13, 5, 8, 1, 2, 1};\n\n        std::sort(v.begin(), v.end());\n        // v = {1, 1, 2, 3, 5, 8, 13}\n\n        std::sort(v.begin(), v.end(), std::greater<>());\n        // v = {13, 8, 5, 3, 2, 1 ,1}\n```", "```cpp\n        struct Task\n        {\n          int priority;\n          std::string name;\n        };\n\n        bool operator<(Task const & lhs, Task const & rhs) {\n          return lhs.priority < rhs.priority;\n        }\n\n        bool operator>(Task const & lhs, Task const & rhs) {\n          return lhs.priority > rhs.priority;\n        }\n\n        std::vector<Task> v{ \n          { 10, \"Task 1\"s }, { 40, \"Task 2\"s }, { 25, \"Task 3\"s },\n          { 10, \"Task 4\"s }, { 80, \"Task 5\"s }, { 10, \"Task 6\"s },\n        };\n\n        std::stable_sort(v.begin(), v.end());\n        // {{ 10, \"Task 1\" },{ 10, \"Task 4\" },{ 10, \"Task 6\" },\n        //  { 25, \"Task 3\" },{ 40, \"Task 2\" },{ 80, \"Task 5\" }}\n\n        std::stable_sort(v.begin(), v.end(), std::greater<>());\n        // {{ 80, \"Task 5\" },{ 40, \"Task 2\" },{ 25, \"Task 3\" },\n        //  { 10, \"Task 1\" },{ 10, \"Task 4\" },{ 10, \"Task 6\" }}\n```", "```cpp\n        std::vector<int> v{ 3, 13, 5, 8, 1, 2, 1 };\n\n        std::partial_sort(v.begin(), v.begin() + 4, v.end());\n        // v = {1, 1, 2, 3, ?, ?, ?}\n\n        std::partial_sort(v.begin(), v.begin() + 4, v.end(),\n                          std::greater<>());\n        // v = {13, 8, 5, 3, ?, ?, ?}\n```", "```cpp\n        std::vector<int> v{ 3, 13, 5, 8, 1, 2, 1 };\n        std::vector<int> vc(v.size());\n\n        std::partial_sort_copy(v.begin(), v.end(), \n                               vc.begin(), vc.end());\n        // v = {3, 13, 5, 8, 1, 2, 1}\n        // vc = {1, 1, 2, 3, 5, 8, 13}\n\n        std::partial_sort_copy(v.begin(), v.end(), \n                               vc.begin(), vc.end(), std::greater<>());\n        // vc = {13, 8, 5, 3, 2, 1, 1}\n```", "```cpp\n        std::vector<int> v{ 3, 13, 5, 8, 1, 2, 1 };\n\n        std::nth_element(v.begin(), v.begin() + 3, v.end());\n        // v = {1, 1, 2, 3, 5, 8, 13}\n\n        std::nth_element(v.begin(), v.begin() + 3, v.end(),\n                         std::greater<>());\n        // v = {13, 8, 5, 3, 2, 1, 1}\n```", "```cpp\n        std::vector<int> v { 1, 1, 2, 3, 5, 8, 13 };\n\n        auto sorted = std::is_sorted(v.cbegin(), v.cend());\n        sorted = std::is_sorted(v.cbegin(), v.cend(), \n                                std::greater<>());\n```", "```cpp\n        std::vector<int> v{ 3, 13, 5, 8, 1, 2, 1 };\n\n        auto it = std::is_sorted_until(v.cbegin(), v.cend());\n        auto length = std::distance(v.cbegin(), it);\n```", "```cpp\n        std::vector<int> v(5);\n        std::fill(v.begin(), v.end(), 42);\n        // v = {42, 42, 42, 42, 42}\n```", "```cpp\n        std::vector<int> v(10);\n        std::fill_n(v.begin(), 5, 42);\n        // v = {42, 42, 42, 42, 42, 0, 0, 0, 0, 0}\n```", "```cpp\n        std::random_device rd{};\n        std::mt19937 mt{ rd() };\n        std::uniform_int_distribution<> ud{1, 10};\n        std::vector<int> v(5);\n        std::generate(v.begin(), v.end(), \n                      [&ud, &mt] {return ud(mt); }); \n```", "```cpp\n        std::vector<int> v(5);\n        auto i = 1;\n        std::generate_n(v.begin(), v.size(), [&i] { return i*i++; });\n        // v = {1, 4, 9, 16, 25}\n```", "```cpp\n        std::vector<int> v(5);\n        std::iota(v.begin(), v.end(), 1);\n        // v = {1, 2, 3, 4, 5}\n```", "```cpp\n    std::vector<int> v1{ 1, 2, 3, 4, 4, 5 };\n    std::vector<int> v2{ 2, 3, 3, 4, 6, 8 };\n    std::vector<int> v3;\n```", "```cpp\n        std::set_union(v1.cbegin(), v1.cend(),\n                       v2.cbegin(), v2.cend(),\n                       std::back_inserter(v3));\n        // v3 = {1, 2, 3, 3, 4, 4, 5, 6, 8}\n```", "```cpp\n        std::merge(v1.cbegin(), v1.cend(),\n                   v2.cbegin(), v2.cend(),\n                   std::back_inserter(v3));\n        // v3 = {1, 2, 2, 3, 3, 3, 4, 4, 4, 5, 6, 8}\n```", "```cpp\n        std::set_intersection(v1.cbegin(), v1.cend(),\n                              v2.cbegin(), v2.cend(),\n                              std::back_inserter(v3));\n        // v3 = {2, 3, 4}\n```", "```cpp\n        std::set_difference(v1.cbegin(), v1.cend(),\n                            v2.cbegin(), v2.cend(),\n                            std::back_inserter(v3));\n        // v3 = {1, 4, 5}\n```", "```cpp\n        std::set_symmetric_difference(v1.cbegin(), v1.cend(),\n                                      v2.cbegin(), v2.cend(),\n                                      std::back_inserter(v3));\n        // v3 = {1, 3, 4, 5, 6, 8}\n```", "```cpp\n        std::vector<int> v1{ 1, 2, 3, 4, 4, 5 };\n        std::vector<int> v2{ 2, 3, 3, 4, 6, 8 };\n        std::vector<int> v3{ 1, 2, 4 };\n        std::vector<int> v4{ };\n\n        auto i1 = std::includes(v1.cbegin(), v1.cend(), \n                                v2.cbegin(), v2.cend()); // i1 = false\n        auto i2 = std::includes(v1.cbegin(), v1.cend(), \n                                v3.cbegin(), v3.cend()); // i2 = true\n        auto i3 = std::includes(v1.cbegin(), v1.cend(), \n                                v4.cbegin(), v4.cend()); // i3 = true\n```", "```cpp\n    struct Task\n    {\n      int priority;\n      std::string name;\n    };\n\n    bool operator<(Task const & lhs, Task const & rhs) {\n      return lhs.priority < rhs.priority;\n    } \n\n    bool operator>(Task const & lhs, Task const & rhs) {\n      return lhs.priority > rhs.priority;\n    }\n\n    std::vector<Task> v1{\n      { 10, \"Task 1.1\"s },\n      { 20, \"Task 1.2\"s },\n      { 20, \"Task 1.3\"s },\n      { 20, \"Task 1.4\"s },\n      { 30, \"Task 1.5\"s },\n      { 50, \"Task 1.6\"s },\n    };\n\n    std::vector<Task> v2{\n      { 20, \"Task 2.1\"s },\n      { 30, \"Task 2.2\"s },\n      { 30, \"Task 2.3\"s },\n      { 30, \"Task 2.4\"s },\n      { 40, \"Task 2.5\"s },\n      { 50, \"Task 2.6\"s },\n    };\n```", "```cpp\n        std::vector<Task> v3;\n        std::set_union(v1.cbegin(), v1.cend(),\n                       v2.cbegin(), v2.cend(),\n                       std::back_inserter(v3));\n        // v3 = {{10, \"Task 1.1\"},{20, \"Task 1.2\"},{20, \"Task 1.3\"},\n        //       {20, \"Task 1.4\"},{30, \"Task 1.5\"},{30, \"Task 2.3\"},\n        //       {30, \"Task 2.4\"},{40, \"Task 2.5\"},{50, \"Task 1.6\"}}\n```", "```cpp\n        std::vector<Task> v4;\n        std::merge(v1.cbegin(), v1.cend(),\n                   v2.cbegin(), v2.cend(),\n                   std::back_inserter(v4));\n        // v4 = {{10, \"Task 1.1\"},{20, \"Task 1.2\"},{20, \"Task 1.3\"},\n        //       {20, \"Task 1.4\"},{20, \"Task 2.1\"},{30, \"Task 1.5\"},\n        //       {30, \"Task 2.2\"},{30, \"Task 2.3\"},{30, \"Task 2.4\"},\n        //       {40, \"Task 2.5\"},{50, \"Task 1.6\"},{50, \"Task 2.6\"}}\n```", "```cpp\n        std::vector<Task> v5;\n        std::set_intersection(v1.cbegin(), v1.cend(),\n                              v2.cbegin(), v2.cend(),\n                              std::back_inserter(v5));\n        // v5 = {{20, \"Task 1.2\"},{30, \"Task 1.5\"},{50, \"Task 1.6\"}}\n```", "```cpp\n        std::vector<Task> v6;\n        std::set_difference(v1.cbegin(), v1.cend(),\n                            v2.cbegin(), v2.cend(),\n                            std::back_inserter(v6));\n        // v6 = {{10, \"Task 1.1\"},{20, \"Task 1.3\"},{20, \"Task 1.4\"}}\n```", "```cpp\n        std::vector<Task> v7;\n        std::set_symmetric_difference(v1.cbegin(), v1.cend(),\n                                      v2.cbegin(), v2.cend(),\n                                      std::back_inserter(v7));\n        // v7 = {{10, \"Task 1.1\"},{20, \"Task 1.3\"},{20, \"Task 1.4\"}\n        //       {30, \"Task 2.3\"},{30, \"Task 2.4\"},{40, \"Task 2.5\"}}\n```", "```cpp\n        std::vector<int> v{ 1,2,3,4,5 };\n        std::fill_n(std::back_inserter(v), 3, 0);\n        // v={1,2,3,4,5,0,0,0}\n```", "```cpp\n        std::list<int> l{ 1,2,3,4,5 };\n        std::fill_n(std::front_inserter(l), 3, 0);\n        // l={0,0,0,1,2,3,4,5}\n```", "```cpp\n        std::vector<int> v{ 1,2,3,4,5 };\n        std::fill_n(std::inserter(v, v.begin()), 3, 0);\n        // v={0,0,0,1,2,3,4,5}\n\n        std::list<int> l{ 1,2,3,4,5 };\n        auto it = l.begin();\n        std::advance(it, 3);\n        std::fill_n(std::inserter(l, it), 3, 0);\n        // l={1,2,3,0,0,0,4,5}\n```", "```cpp\n    template<class C>\n    class back_insert_iterator {\n    public:\n      typedef back_insert_iterator<C> T;\n      typedef typename C::value_type V;\n\n      explicit back_insert_iterator( C& c ) :container( &c ) { }\n\n      T& operator=( const V& val ) { \n        container->push_back( val );\n        return *this;\n      }\n\n      T& operator*() { return *this; }\n\n      T& operator++() { return *this; }\n\n      T& operator++( int ) { return *this; }\n      protected:\n      C* container;\n    };\n```", "```cpp\n    std::vector<int> v{ 1,2,3,4,5 };\n    std::fill_n(std::inserter(v, v.begin()), 3, 0);\n    // v={0,0,0,1,2,3,4,5}\n```", "```cpp\n    T& operator=(const V& v)\n    {  \n      iter = container->insert(iter, v);\n      ++iter;\n      return (*this);\n    }\n```", "```cpp\n    std::vector<int> v{ 1,2,3,4,5 };\n    *std::back_inserter(v) = 6; // v = {1,2,3,4,5,6}\n\n    std::back_insert_iterator<std::vector<int>> it(v);\n    *it = 7;                    // v = {1,2,3,4,5,6,7}\n```", "```cpp\n    template <typename Type, size_t const SIZE>\n    class dummy_array\n    {\n      Type data[SIZE] = {};\n    public:\n      Type& operator[](size_t const index)\n      {\n        if (index < SIZE) return data[index];\n        throw std::out_of_range(\"index out of range\");\n      }\n\n     Type const & operator[](size_t const index) const\n     {\n       if (index < SIZE) return data[index];\n       throw std::out_of_range(\"index out of range\");\n     }\n\n      size_t size() const { return SIZE; }\n    };\n```", "```cpp\n        template <typename T, size_t const Size>\n        class dummy_array_iterator\n        {\n        public:\n          typedef dummy_array_iterator            self_type;\n          typedef T                               value_type;\n          typedef T&                              reference;\n          typedef T*                              pointer;\n          typedef std::random_access_iterator_tag iterator_category;\n          typedef ptrdiff_t                       difference_type;\n        };\n```", "```cpp\n        private:\n           pointer ptr = nullptr;\n           size_t index = 0;\n```", "```cpp\n        private:\n          bool compatible(self_type const & other) const\n          {\n            return ptr == other.ptr;\n          }\n```", "```cpp\n        public:\n           explicit dummy_array_iterator(pointer ptr, \n                                         size_t const index) \n             : ptr(ptr), index(index) { }\n```", "```cpp\n        dummy_array_iterator(dummy_array_iterator const & o) \n           = default;\n        dummy_array_iterator& operator=(dummy_array_iterator const & o) \n           = default;\n        ~dummy_array_iterator() = default;\n\n        self_type & operator++ ()\n        {\n           if (index >= Size) \n             throw std::out_of_range(\"Iterator cannot be incremented past \n                                      the end of range.\");\n          ++index;\n          return *this;\n        }\n\n        self_type operator++ (int)\n        {\n          self_type tmp = *this;\n          ++*this;\n          return tmp;\n        }\n```", "```cpp\n        bool operator== (self_type const & other) const\n        {\n          assert(compatible(other));\n          return index == other.index;\n        }\n\n        bool operator!= (self_type const & other) const\n        {\n          return !(*this == other);\n        }\n\n        reference operator* () const\n        {\n          if (ptr == nullptr)\n            throw std::bad_function_call();\n          return *(ptr + index);\n        }\n\n        reference operator-> () const\n        {\n          if (ptr == nullptr)\n            throw std::bad_function_call();\n          return *(ptr + index);\n        }\n```", "```cpp\n        dummy_array_iterator() = default;\n```", "```cpp\n        self_type & operator--()\n        {\n          if (index <= 0) \n            throw std::out_of_range(\"Iterator cannot be decremented \n                                     past the end of range.\");\n          --index;\n          return *this;\n        }\n\n        self_type operator--(int)\n        {\n          self_type tmp = *this;\n          --*this;\n          return tmp;\n        }\n```", "```cpp\n        self_type operator+(difference_type offset) const\n        {\n          self_type tmp = *this;\n          return tmp += offset;\n        }\n\n        self_type operator-(difference_type offset) const\n        {\n          self_type tmp = *this;\n          return tmp -= offset;\n        }\n\n        difference_type operator-(self_type const & other) const\n        {\n          assert(compatible(other));\n          return (index - other.index);\n        }\n\n        bool operator<(self_type const & other) const\n        {\n          assert(compatible(other));\n          return index < other.index;\n        }\n\n        bool operator>(self_type const & other) const\n        {\n          return other < *this;\n        }\n\n        bool operator<=(self_type const & other) const\n        {\n          return !(other < *this);\n        }\n\n        bool operator>=(self_type const & other) const\n        {\n          return !(*this < other);\n        }\n\n        self_type & operator+=(difference_type const offset)\n        {\n          if (index + offset < 0 || index + offset > Size)\n            throw std::out_of_range(\"Iterator cannot be incremented \n                                     past the end of range.\");\n          index += offset;\n          return *this;\n        }\n\n        self_type & operator-=(difference_type const offset)\n        {\n          return *this += -offset;\n        }\n\n        value_type & operator[](difference_type const offset)\n        {\n          return (*(*this + offset));\n        }\n\n        value_type const & operator[](difference_type const offset) const\n        {\n          return (*(*this + offset));\n        }\n```", "```cpp\n        public:\n           typedef dummy_array_iterator<Type, SIZE> \n                   iterator;\n           typedef dummy_array_iterator<Type const, SIZE> \n                   constant_iterator;\n```", "```cpp\n        iterator begin() \n        {\n          return iterator(data, 0);\n        }\n\n        iterator end()\n        {\n          return iterator(data, SIZE);\n        }\n\n        constant_iterator begin() const\n        {\n          return constant_iterator(data, 0);\n        }\n\n        constant_iterator end() const\n        {\n          return constant_iterator(data, SIZE);\n        }\n```", "```cpp\n    dummy_array<int, 3> a;\n    a[0] = 10;\n    a[1] = 20;\n    a[2] = 30;\n\n    std::transform(a.begin(), a.end(), a.begin(), \n                   [](int const e) {return e * 2; });\n\n    for (auto&& e : a) std::cout << e << std::endl;\n\n    auto lp = [](dummy_array<int, 3> const & ca)\n    {\n      for (auto const & e : ca) \n        std::cout << e << std::endl;\n    };\n\n    lp(a);\n\n    dummy_array<std::unique_ptr<Tag>, 3> ta;\n    ta[0] = std::make_unique<Tag>(1, \"Tag 1\");\n    ta[1] = std::make_unique<Tag>(2, \"Tag 2\");\n    ta[2] = std::make_unique<Tag>(3, \"Tag 3\");\n\n    for (auto it = ta.begin(); it != ta.end(); ++it)\n      std::cout << it->id << \" \" << it->name << std::endl;\n```", "```cpp\n        std::vector<int> v1{ 1, 2, 3, 4, 5 };\n        auto sv1 = std::size(v1);  // sv1 = 5\n        auto ev1 = std::empty(v1); // ev1 = false\n        auto dv1 = std::data(v1);  // dv1 = v1.data()\n        for (auto i = std::begin(v1); i != std::end(v1); ++i)\n          std::cout << *i << std::endl;\n\n        std::vector<int> v2;\n        std::copy(std::cbegin(v1), std::cend(v1),\n                  std::back_inserter(v2));\n```", "```cpp\n        int a[5] = { 1, 2, 3, 4, 5 };\n        auto pos = std::find_if(std::crbegin(a), std::crend(a), \n                                [](int const n) {return n % 2 == 0; });\n        auto sa = std::size(a);  // sa = 5\n        auto ea = std::empty(a); // ea = false\n        auto da = std::data(a);  // da = a\n```", "```cpp\n        dummy_array<std::string, 5> sa;\n        dummy_array<int, 5> sb;\n        sa[0] = \"1\"s;\n        sa[1] = \"2\"s;\n        sa[2] = \"3\"s;\n        sa[3] = \"4\"s;\n        sa[4] = \"5\"s;\n\n        std::transform(\n          std::begin(sa), std::end(sa), \n          std::begin(sb), \n          [](std::string const & s) {return std::stoi(s); });\n        // sb = [1, 2, 3, 4, 5]\n\n        auto sa_size = std::size(sa); // sa_size = 5\n```", "```cpp\n        template <typename F, typename C>\n        void process(F&& f, C const & c)\n        {\n          std::for_each(std::begin(c), std::end(c), \n                        std::forward<F>(f));\n        }\n\n        auto l = [](auto const e) {std::cout << e << std::endl; };\n\n        process(l, v1); // std::vector<int>\n        process(l, a);  // int[5]\n        process(l, sa); // dummy_array<std::string, 5>\n```", "```cpp\n    template<class C>\n    constexpr auto inline begin(C& c) -> decltype(c.begin())\n    {\n      return c.begin();\n    }\n    template<class C>\n    constexpr auto inline end(C& c) -> decltype(c.end())\n    {\n      return c.end();\n    }\n\n    template<class T, std::size_t N>\n    constexpr T* inline begin(T (&array)[N])\n    {\n      return array;\n    }\n\n    template<class T, std::size_t N>\n    constexpr T* inline begin(T (&array)[N])\n    {\n      return array+N;\n    }\n```", "```cpp\n        template <class C> \n        constexpr auto data(C& c) -> decltype(c.data())\n        {\n          return c.data();\n        }\n\n        template <class C> \n        constexpr auto data(const C& c) -> decltype(c.data())\n        {\n          return c.data();\n        }\n\n        template <class T, std::size_t N>\n        constexpr T* data(T (&array)[N]) noexcept\n        {\n          return array;\n        }\n\n        template <class E> \n        constexpr const E* data(std::initializer_list<E> il) noexcept\n        {\n          return il.begin();\n        }\n```", "```cpp\n        template <class C> \n        constexpr auto size(const C& c) -> decltype(c.size())\n        {\n          return c.size();\n        }\n\n        template <class T, std::size_t N>\n        constexpr std::size_t size(const T (&array)[N]) noexcept\n        {\n          return N;\n        }\n```", "```cpp\n        template <class C> \n        constexpr auto empty(const C& c) -> decltype(c.empty())\n        {\n          return c.empty();\n        }\n\n        template <class T, std::size_t N> \n        constexpr bool empty(const T (&array)[N]) noexcept\n        {\n          return false;\n        }\n\n        template <class E> \n        constexpr bool empty(std::initializer_list<E> il) noexcept\n        {\n          return il.size() == 0;\n        }\n```"]