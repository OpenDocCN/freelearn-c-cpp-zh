- en: A Comprehensive Look at Memory Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存管理的全面视角
- en: In this chapter, we will step the reader through how to properly and safely
    perform C++-style memory management, while also adhering to the C++ Core Guidelines
    whenever possible, leveraging additions to the C++ standard template library in
    C++11, C++14, and C++17 to increase the safety, reliability, and stability of
    the reader's system program. We will start by first introducing the `new()` and
    `delete()` functions, and how they may be used to allocate type-safe memory, including
    aligned memory. Next, this chapter will discuss the safety issues with using `new()`
    and `delete()` directly and how these safety concern may be handled using smart
    pointers, including their impact on C++ Core Guideline compliance. How to perform
    memory mapping and permissions will also be discussed, with the chapter concluding
    with a brief discussion on fragmentation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将逐步指导读者如何正确和安全地执行C++风格的内存管理，同时尽可能遵守C++核心指南，利用C++11、C++14和C++17对C++标准模板库的增强，以增加读者系统程序的安全性、可靠性和稳定性。我们将首先介绍`new()`和`delete()`函数，以及它们如何用于分配类型安全的内存，包括对齐内存。接下来，本章将讨论使用`new()`和`delete()`直接的安全问题，以及如何使用智能指针来处理这些安全问题，包括它们对C++核心指南合规性的影响。还将讨论如何执行内存映射和权限，并在章节结束时简要讨论碎片化问题。
- en: Technical requirements
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to compile and execute the examples in this chapter, the reader must
    have the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编译和执行本章中的示例，读者必须具备以下条件：
- en: A Linux-based system capable of compiling and executing C++17 (for example,
    Ubuntu 17.10+)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个能够编译和执行C++17的基于Linux的系统（例如，Ubuntu 17.10+）
- en: GCC 7+
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCC 7+
- en: CMake 3.6+
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake 3.6+
- en: An internet connection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网连接
- en: To download all of the code in this chapter, including the examples, and code
    snippets, please visit: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter07](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter07).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载本章中的所有代码，包括示例和代码片段，请访问：[https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter07](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter07)。
- en: Learning about the new and delete functions
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习关于new和delete函数
- en: In this section, the reader will learn how to allocate and deallocate memory
    using C++17. You will learn how to use `new()` and `delete()` instead of `malloc()`/`free()`
    to increase the type-safety of allocations and deallocations. Various versions
    of these functions will be explained, including array, aligned, and placement-style
    allocations.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，读者将学习如何使用C++17分配和释放内存。您将学习如何使用`new()`和`delete()`而不是`malloc()`/`free()`来增加分配和释放的类型安全性。将解释这些函数的各个版本，包括数组、对齐和放置式分配。
- en: The basics for writing a program
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写程序的基础知识
- en: 'When writing a program, including system programming, there are a few different
    types of memory that can be leveraged by the author:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写程序时，包括系统编程，作者可以利用几种不同类型的内存：
- en: Global memory
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局内存
- en: Stack memory
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈内存
- en: Heap memory
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆内存
- en: 'Global memory exists in the program itself, is allocated by the OS''s loader, and
    generally exists in two different locations (assuming ELF binaries):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 全局内存存在于程序本身中，由操作系统的加载器分配，并且通常存在于两个不同的位置（假设是ELF二进制文件）：
- en: '`.bss`: zero-initialized (or uninitialized) memory'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.bss`: 零初始化（或未初始化）内存'
- en: '`.data`: value-initialized memory'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.data`: value-initialized memory'
- en: 'Consider the following example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Although used a lot in system programming, global memory is usually discouraged
    in favor of stack memory and dynamic memory. Special care should be taken when
    using value-initialized global memory, as this form of memory usage increases
    the size of the program on disk, resulting in a larger storage impact, as well
    as long load times, while the zero-initialized memory is provided by the OS-loader
    during linking.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在系统编程中经常使用，但全局内存通常不鼓励使用，而是推荐使用堆栈内存和动态内存。在使用值初始化的全局内存时需要特别小心，因为这种内存使用会增加程序在磁盘上的大小，导致更大的存储影响，以及长时间的加载时间，而零初始化的内存是由操作系统加载器在链接期间提供的。
- en: '**Stack memory** is the memory that is allocated on the stack:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**堆栈内存**是在堆栈上分配的内存：'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As shown in this example, `stack_mem` is allocated on the stack instead of globally
    because it exists in the `main()` function. Stack memory is bound to the scope
    in which it was created—in this case, the `main()` function. Besides being scoped,
    another advantage of stack memory is that when the memory's scope is complete,
    the memory will be released automatically for you. Care should be taken when using
    stack memory as this memory is limited in size.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如本例所示，`stack_mem`是在堆栈上分配而不是全局分配，因为它存在于`main()`函数中。堆栈内存绑定到创建它的作用域——在这种情况下是`main()`函数。除了有作用域之外，堆栈内存的另一个优点是，当内存的作用域完成时，内存将自动释放。在使用堆栈内存时需要小心，因为这种内存的大小是有限的。
- en: It should be noted that the total size of the stack is entirely system-dependent
    and can vary widely. Unless you know the size of the stack, it should be assumed
    to be small, and used with caution as there is no simple way to determine when
    the stack runs out. Unlike dynamic memory allocation, which usually returns an
    error of some kind when memory is not available, on most systems when the stack
    runs out, your program will simply crash.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 应注意，堆栈的总大小完全取决于系统，并且可能差异很大。除非知道堆栈的大小，否则应假定它很小，并小心使用，因为没有简单的方法来确定堆栈何时耗尽。与通常在内存不可用时返回某种错误的动态内存分配不同，在大多数系统上，当堆栈耗尽时，程序将简单崩溃。
- en: 'For example, on our test system, when attempting to allocate an integer array
    of `268435456` on the stack as shown in the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的测试系统上，尝试在堆栈上分配一个整数数组`268435456`，如下所示的代码：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This results in a segmentation fault as the `stack_mem` variable exceeds the
    total size of the stack.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致分段错误，因为`stack_mem`变量超出了堆栈的总大小。
- en: 'The third form of memory and the main topic of this chapter is dynamic memory
    (also called **heap memory**). Like the stack, each program is given a pool of
    heap memory by the OS, which often can grow based on demand. Unlike the stack,
    and even global memory, heap memory allocations can be quite large if the physical
    system and OS can support it. In addition, unlike stack and global memory, heap
    memory is slow to allocate and any memory that is allocated on-demand by the user
    must also be released back to the heap by the user when complete. In C++, the
    fundamental method for allocating heap memory is through the use of the `new()`
    and `delete()` operator functions, as shown here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 内存的第三种形式，也是本章的主题，是动态内存（也称为**堆内存**）。与堆栈一样，每个程序都会被操作系统分配一块堆内存池，这个池通常可以根据需求增长。与堆栈甚至全局内存不同，堆内存分配可以非常大，如果物理系统和操作系统支持的话。此外，与堆栈和全局内存不同，堆内存的分配速度较慢，用户按需分配的任何内存在完成时也必须由用户释放回堆。在C++中，分配堆内存的基本方法是通过使用`new()`和`delete()`运算符函数，如下所示：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this simple example, an integer (whose size is architecture-dependent, but
    assumed to be `4` bytes here) is allocated on the heap using the new operator.
    The address of the newly-allocated memory is outputted to `stdout`, and then the
    memory is released back to the heap using the `delete()` operator. In addition
    to single objects, arrays can also be allocated/deallocated using the `new()`/`delete()`
    operators, as shown here:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，使用new运算符在堆上分配了一个整数（其大小取决于体系结构，但在这里假定为`4`字节）。新分配的内存的地址被输出到`stdout`，然后使用`delete()`运算符将内存释放回堆。除了单个对象，也可以使用`new()`/`delete()`运算符分配/释放数组，如下所示：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this example, an array of integers is allocated a size of `42`. Note that,
    unlike `malloc()` in standard C, the new operator automatically calculates the
    total number of bytes needed for an object or array of objects. Assuming that
    an integer is `4` bytes, in this example, the new operator allocates `42 * sizeof(int)
    == 42 * 4 == 11088` bytes. In addition to the use of `new[]()` to allocate an
    array, the `delete []()` operator is used instead of the `delete` operator. The
    delete operator calls the destructor for a single object while the `delete []()`
    operator calls the destructor for each object in the array:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，分配了一个大小为`42`的整数数组。请注意，与标准C中的`malloc()`不同，new运算符会自动计算对象或对象数组所需的总字节数。假设一个整数是`4`字节，在这个例子中，new运算符分配了`42
    * sizeof(int) == 42 * 4 == 11088`字节。除了使用`new[]()`来分配数组外，还使用了`delete[]()`运算符，而不是`delete`运算符。delete运算符调用单个对象的析构函数，而`delete[]()`运算符调用数组中每个对象的析构函数。
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It's important to note that some systems may use different pools to allocate
    single objects versus arrays of objects versus aligned objects, and more. Care
    should be taken to ensure that the deallocation routine matches the allocation
    routine. For example, if `new []()` is used, `delete []()` should always be used
    instead of `delete()`. If a mismatch occurs, systems that share the same pools
    will function without issue, but a crash could occur on systems that do not share
    these pools as you would be attempting to release memory to a pool to which the
    memory did not originally belong. The easiest way to prevent these types of errors
    is to use `std::unique_ptr{}` and `std::shared_ptr{}`, which will be discussed
    in the *Understanding smart pointers and ownership* section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，一些系统可能使用不同的池来分配单个对象、对象数组、对齐对象等。需要注意确保释放内存的例程与分配内存的例程匹配。例如，如果使用`new[]()`，应该始终使用`delete[]()`而不是`delete()`。如果发生不匹配，共享相同池的系统将正常运行，但在不共享这些池的系统上可能会崩溃，因为您会尝试释放内存到原本不属于的池中。预防这些类型的错误的最简单方法是使用`std::unique_ptr{}`和`std::shared_ptr{}`，这将在*理解智能指针和所有权*部分讨论。
- en: Aligning memory
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对齐内存
- en: 'When programming systems, often allocating aligned memory (that is, memory
    that is divisible by a specific alignment) is required. Specifically, when memory
    is allocated, the resulting address that points to said allocated memory can be
    any value. When programming systems, however, this can often be problematic as
    some APIs and physical devices require memory to be allocated with a certain minimum
    granularity. Consider the following example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程系统时，通常需要分配对齐内存（即，可以被特定对齐方式整除的内存）。具体来说，当分配内存时，指向所分配内存的地址可以是任何值。然而，在编程系统时，这通常会有问题，因为一些API和物理设备要求内存以一定的最小粒度进行分配。考虑以下例子：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Aligned memory may be allocated using all three memory types:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用所有三种内存类型来分配对齐内存：
- en: Globally
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局
- en: On the stack
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在堆栈上
- en: Dynamically
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态地
- en: 'To allocate aligned memory globally using C++, use the `alignas()` specifier:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要在C++中全局分配对齐内存，使用`alignas()`说明符：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this example, an integer array of size `42` is allocated globally, and the
    `alignas()` specifier is used to align the array to a 4k page boundary. The array''s
    address is then outputted, and as shown, the address is divisible by a 4k page
    (that is, the first 12 bits are zero). To allocate aligned memory on the stack,
    you can also use the `alignas()` specifier:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，全局分配了一个大小为`42`的整数数组，并使用`alignas()`说明符将数组对齐到4k页边界。然后输出数组的地址，如所示，该地址可以被4k页整除（即，前12位为零）。要在堆栈上分配对齐内存，也可以使用`alignas()`说明符：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Instead of the array being allocated globally, the array is moved into the
    `main` function''s scope and is therefore allocated using the stack when the `main`
    function executes, and automatically released when the `main` function completes.
    This type of allocation should be used with care as the compiler has to add code
    to the program''s executable to move the stack pointer in order to align this
    memory. As a result, aligned allocations on the stack indirectly allocate additional,
    unusable memory to ensure the pointer is aligned (shown on Intel''s x86_64 using
    GCC 7.3):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 数组不是全局分配的，而是移动到`main`函数的作用域中，因此在`main`函数执行时使用堆栈分配，并在`main`函数完成时自动释放。这种类型的分配应该谨慎使用，因为编译器必须向程序的可执行文件中添加代码，以移动堆栈指针以对齐内存。因此，堆栈上的对齐分配间接分配了额外的不可用内存，以确保指针对齐（在Intel的x86_64上使用GCC
    7.3显示）：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As can be seen, the stack pointer (that is, the RSP register in this case),
    is moved to align the integer array. If this type of allocation is done a lot,
    or the alignment is high (say a 2 MB alignment), stack space could run out quickly.
    Another way to allocate aligned memory (regardless of the type) is to manually
    calculate an aligned position within an existing character buffer:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，堆栈指针（即本例中的RSP寄存器）被移动以对齐整数数组。如果这种类型的分配频繁进行，或者对齐要求很高（比如2MB对齐），堆栈空间可能很快用完。无论类型如何，另一种分配对齐内存的方法是在现有字符缓冲区内手动计算对齐位置：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this example, a character buffer of ample size is allocated on the stack.
    The character buffer''s address is then converted into an unsigned integer pointer
    type, an operation that is discouraged by the C++ Core Guidelines as `reinterpret_cast()`
    should be avoided, and then arithmetic on the character buffer''s pointer is performed
    to locate a page-aligned address inside the buffer, another operation that is
    discouraged by the C++ Core Guidelines as pointer arithmetic should be avoided
    as well. Both the original and resulting pointers are outputted to `stdout`, and
    as shown, the calculated pointer is aligned to a 4k page boundary within the character
    buffer. To see how this algorithm works, see the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，堆栈上分配了一个足够大的字符缓冲区。然后将字符缓冲区的地址转换为无符号整数指针类型，这是C++核心指南所不鼓励的操作，然后对字符缓冲区的指针进行算术运算，以定位缓冲区内的页面对齐地址，这也是C++核心指南所不鼓励的操作，因为应该避免指针算术。原始指针和结果指针都输出到`stdout`，如所示，计算出的指针在字符缓冲区内对齐到4k页面边界。要了解这个算法是如何工作的，请参见以下内容：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This type of process works, and has been used for years, but should be avoided
    as there are better ways to accomplish this same task using `alignas()` without
    the need for type-casting and pointer arithmetic that is prone to error and discouraged
    by the C++ Core Guidelines.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的处理方式有效，并且已经使用了多年，但应该避免使用，因为有更好的方法可以使用`alignas()`来完成相同的任务，而无需进行类型转换和指针算术，这种方法容易出错，并且被C++核心指南所不鼓励。
- en: 'Finally, the third way to allocate aligned memory is to use dynamic allocations.
    Prior to C++17, this was done using `posix_memalign()` or the newer C11 `aligned_alloc()`,
    as shown here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，分配对齐内存的第三种方法是使用动态分配。在C++17之前，可以使用`posix_memalign()`或更新的C11 `aligned_alloc()`来实现，如下所示：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `posix_memalign()` API is a bit clunky. First, a pointer must be declared*,*
    the alignment and size (which must be manually calculated) are provided, and then
    the function returns 0 upon success. Finally, `reinterpret_cast()` is needed to
    tell the `posix_memalign()` function that the provided pointer is `void **` and
    not `int**`. Since the `posix_memalign()` function is a C-style function, `free()`
    is used to release the memory.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`posix_memalign()` API有点笨拙。首先，必须声明一个指针，然后提供对齐和大小（必须手动计算），最后，函数在成功时返回0。最后，需要使用`reinterpret_cast()`来告诉`posix_memalign()`函数提供的指针是`void
    **`而不是`int**`。由于`posix_memalign()`函数是C风格的函数，所以使用`free()`来释放内存。'
- en: 'Another way to allocate aligned memory is to use the relatively new `aligned_alloc()`
    function, which provides a less clunky, more portable implementation:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种分配对齐内存的方法是使用相对较新的`aligned_alloc()`函数，它提供了一个更简洁、更便携的实现方式：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As shown, `aligned_alloc()` functions like a regular `malloc()` but with an
    additional alignment parameter. This API still suffers from the same size issue
    as `malloc()` and `posix_memalign()`, where the total size of the array must be
    manually calculated.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，`aligned_alloc()`的功能类似于常规的`malloc()`，但具有额外的对齐参数。这个API仍然存在与`malloc()`和`posix_memalign()`相同的大小问题，其中数组的总大小必须手动计算。
- en: 'To solve these issues, C++17 added aligned allocation versions of the `new()`
    and `delete()` operators that leverage `alignas()` as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，C++17添加了`new()`和`delete()`运算符的对齐分配版本，利用了`alignas()`，如下所示：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this example, we allocate a single integer using `alignas()` and the `new()`
    and `delete()` operators. To accomplish this, we create a new type, called `aligned_int`,
    that leverages `alignas()` in the type definition. The following can also be used
    to allocate an aligned array:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`alignas()`和`new()`和`delete()`运算符来分配一个单个整数。为了实现这一点，我们创建了一个新类型，称为`aligned_int`，它在类型定义中利用了`alignas()`。以下内容也可以用来分配一个对齐的数组：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The same aligned integer type is used, with the only difference being the use
    of `new []()` and `delete []()` instead of `new()` and `delete()`. Unlike the
    C APIs shown in the preceding code, `new()` and `delete()`, including the aligned
    versions added to C++17, automatically calculate the total number of bytes that
    need to be allocated for you, removing potential errors.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的对齐整数类型，唯一的区别是使用`new []()`和`delete []()`而不是`new()`和`delete()`。与前面代码中显示的C
    API不同，`new()`和`delete()`，包括C++17中添加的对齐版本，会自动计算需要分配的总字节数，从而消除了潜在的错误。
- en: nothrow
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: nothrow
- en: 'The `new()` and `delete()` operators are allowed to throw exceptions. In fact,
    if an allocation fails, the default new operator throws `std::bad_alloc` instead
    of returning `nullptr`. In some situations, often seen when programming systems,
    an exception on an invalid allocation is unwanted, and for this reason, a `nothrow`
    version has been provided:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`new()`和`delete()`运算符允许抛出异常。实际上，如果分配失败，默认的new运算符会抛出`std::bad_alloc`，而不是返回`nullptr`。在某些情况下，通常在编程系统中经常见到，不希望在无效的分配上抛出异常，因此提供了`nothrow`版本。'
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Specifically, `new (std::nothrow)` is used instead of `new()`, which tells
    C++ that you would like `nullptr` to be returned on an invalid allocation instead
    of `new()` throwing `std::bad_alloc`. The array version was also provided as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，使用`new (std::nothrow)`代替`new()`，告诉C++在无效分配时希望返回`nullptr`，而不是`new()`抛出`std::bad_alloc`。数组版本也提供如下：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And as one might expect, the aligned allocation versions of these functions
    were also provided for single-object allocations:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如人们所期望的那样，这些函数的对齐分配版本也适用于单个对象的分配：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There''s also array-style allocations:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 还有数组样式的分配：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It should be noted that `nullptr` is only returned for types provided by C++.
    For user-defined types, if an exception is thrown during construction, the `nothrow`
    version of `new()`, which is marked `nothrow`, will call `std::terminate` and
    abort:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，`nullptr`仅对C++提供的类型返回。对于用户定义的类型，如果在构造过程中抛出异常，标记为`nothrow`的`new()`版本将调用`std::terminate`并中止：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To overcome this issue, class-specific `new` and `delete` operators may be used
    (a topic to be explained in the *Overloading* section).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，可以使用特定于类的`new`和`delete`运算符（在*重载*部分进行解释）。
- en: Placement of new
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 放置new
- en: 'In addition to aligned allocations and `nothrow` specifiers, C++ also provides
    the ability to allocate memory from an existing, user-controlled buffer, a situation
    that can often be seen while programming systems. For example, suppose you have
    mapped a buffer from a physical device. Now suppose you wish to allocate from
    this buffer an integer, the `new()` placement operator may be used to accomplish
    this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对齐分配和`nothrow`指定符，C++还提供了从现有的、用户控制的缓冲区分配内存的能力，这种情况在编程系统中经常见到。例如，假设您已经从物理设备映射了一个缓冲区。现在假设您希望从这个缓冲区分配一个整数，可以使用`new()`放置运算符来实现：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this example, we leverage the `new()` placement operator to allocate memory
    from an existing user-controlled buffer. The `new()` placement operator provides
    the object to be allocated with the address that is provided, and then, as usual,
    calls the object''s constructor. It should be noted that the `delete()` operator
    is not needed in this case because the memory to the object being allocated is
    user-defined, in which case there is no heap memory to return to the heap when
    complete. Furthermore, the `new()` placement operator doesn''t manage the memory
    provided to a set of objects, a task that must be performed by the user. To demonstrate
    this, see the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们利用`new()`放置运算符从现有的用户控制的缓冲区分配内存。`new()`放置运算符提供了要分配的对象的地址，然后像往常一样调用对象的构造函数。应该注意，在这种情况下不需要`delete()`运算符，因为分配给对象的内存是用户定义的，因此在完成时没有堆内存需要返回到堆中。此外，`new()`放置运算符不管理提供给一组对象的内存，这是用户必须执行的任务。为了证明这一点，可以参考以下内容：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this example, the `new()` placement is used twice. As shown, the address
    that is provided is the same since we have not manually advanced the address provided
    to the `new()` placement, demonstrating that C++ doesn''t automatically manage
    user-defined memory when the `new()` placement is used. Typically, this type of
    example would lead to undefined behavior if executed (in this case it doesn''t
    since we are not actually using the newly allocated memory). For these reasons,
    the `new()` placement should be used with special care. In addition to single
    allocations, array allocations are also provided:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`new()`放置被使用了两次。如图所示，提供的地址是相同的，因为我们没有手动提前提供给`new()`放置的地址，这表明当使用`new()`放置时，C++不会自动管理用户定义的内存。通常，这种类型的例子如果执行会导致未定义的行为（在这种情况下并不会，因为我们实际上并没有使用新分配的内存）。因此，`new()`放置应该特别小心使用。除了单个分配外，还提供了数组分配：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Since C++ doesn''t manage `new()` placement allocations, aligned allocations
    must be provided by the user as well. The alignment algorithm provided in the
    preceding code could be used to provide aligned allocations from a user-defined
    buffer, the memory that is already aligned (for example, when interfacing with
    a physical device via `mmap()`) could be used, or `alignas()` could also be used,
    as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C++不管理`new()`放置分配，用户还必须提供对齐分配。在前面的代码中提供的对齐算法可以用于从用户定义的缓冲区提供对齐分配，也可以使用已经对齐的内存（例如，通过`mmap()`与物理设备进行接口），或者也可以使用`alignas()`，如下所示：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this example, since the buffer is aligned using `alignas()`, the resulting
    new placement allocation is also aligned when this buffer is provided. This same
    type of allocation also works for array allocation:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，由于使用`alignas()`对缓冲区进行了对齐，因此当提供该缓冲区时，得到的新的放置分配也是对齐的。这种类型的分配对于数组分配也是适用的：
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Overloading
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重载
- en: 'Often when programming systems, the default allocation scheme provided by C++
    is undesirable. Examples include (but are not limited to):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程系统时，C++提供的默认分配方案通常是不理想的。例如（但不限于）：
- en: Custom memory layouts
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义内存布局
- en: Fragmentation
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碎片化
- en: Performance optimizations
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能优化
- en: Debugging and statistics
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试和统计
- en: 'One way to overcome these issues is to leverage C++ allocators, a complex topic
    that will be discussed in [Chapter 9](2a64ae97-dad4-479a-bd9f-9df2cb634b74.xhtml),
    *A Hands-On Approach to Allocators*. Another, more heavy-handed, way to achieve
    this is to leverage the `new()` and `delete()` operators'' user-defined overloads:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 克服这些问题的一种方法是利用C++分配器，这是一个复杂的话题，将在[第9章](2a64ae97-dad4-479a-bd9f-9df2cb634b74.xhtml)中讨论，*分配器的实践方法*。另一种更严厉的方法是利用`new()`和`delete()`运算符的用户定义重载：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, a custom `new()` and `delete()` operator overload is provided.
    Instead of your program using the default allocation scheme provided by the `new()`
    and `delete()` functions, your user-defined versions will be used instead.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，提供了自定义的`new()`和`delete()`运算符重载。你的程序将使用`new()`和`delete()`函数提供的默认分配方案，而是使用你定义的版本。
- en: These overloads affect all allocations, including those used by the C++ library,
    so care should be taken when leveraging these overloads as infinite cyclic recursions
    could occur if an allocation is performed inside these functions. For example,
    data structures such as `std::vector` and `std::list`, or debugging functions
    such as `std::cout` and `std::cerr` cannot be used as these facilities use the
    `new()` and `delete()` operators to allocate memory.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这些重载会影响所有的分配，包括C++库使用的分配，因此在利用这些重载时需要小心，因为如果在这些函数内执行分配，可能会发生无限循环递归。例如，像`std::vector`和`std::list`这样的数据结构，或者像`std::cout`和`std::cerr`这样的调试函数都不能使用，因为这些设施使用`new()`和`delete()`运算符来分配内存。
- en: 'In addition to the single-object `new()` and `delete()` operators, all of the
    other operators may also be overloaded, including the array allocation versions:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 除了单个对象的`new()`和`delete()`运算符外，所有其他运算符也可以进行重载，包括数组分配版本：
- en: '[PRE27]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Debugging and statistics are a common reason to overload the `new()` and `delete()`
    operators, providing useful information about the types of allocations that are
    occurring. For example, suppose you wish to record the total number of allocations
    larger than, or equal to, a page:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 调试和统计是重载`new()`和`delete()`运算符的常见原因，提供有关正在发生的分配类型的有用信息。例如，假设你希望记录大于或等于一页的总分配数：
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As shown, no allocations larger than a page were performed by our program,
    including allocations made by the C++ library. Let''s see what happens if we allocate
    a page as shown here:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，我们的程序没有执行大于一页的分配，包括由C++库进行的分配。让我们看看如果我们按照这里所示的方式分配一页会发生什么：
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We get a single allocation larger than, or equal to, a page, as expected. This
    type of use of `new()` and `delete()` overloaded can be extremely useful for debugging
    memory leaks, locating allocation optimizations, and more. It should be noted
    however that care should be taken when writing these types of overloads. If you
    accidentally allocate memory (for example, when using a C++ data structure such
    as `std::vector{}`, or when using `std::cout`), you could end up in an infinite
    loop, or adding to statistics you might be trying to record.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们得到了一个大于或等于一页的单个分配。这种使用重载的`new()`和`delete()`的方式对于调试内存泄漏、定位分配优化等非常有用。然而，需要注意的是，在编写这些类型的重载时需要小心。如果你意外地分配内存（例如，在使用C++数据结构如`std::vector{}`时，或者在使用`std::cout`时），你可能会陷入无限循环，或者增加你可能正在记录的统计数据。
- en: 'In addition to global operator `new` and `delete` operator overloads, class-specific
    versions are also provided:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 除了全局运算符`new`和`delete`运算符重载外，还提供了特定于类的版本：
- en: '[PRE30]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When class-specific operators are used, the only allocations that are directed
    to your overloads are allocations for the specific class or classes that you provide
    overloads for. As shown in the preceding example, the allocations made by `std::cout`
    are not directed to our class-specific overloads, preventing infinite recursion.
    The only allocation and deallocation that uses overload are the ones for `myclass`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用特定于类的运算符时，只有为特定类或类提供重载的分配才会被指向你的重载。如前面的例子所示，`std::cout`所做的分配不会指向我们特定于类的重载，从而防止无限递归。唯一使用重载的分配和释放是`myclass`的分配和释放。
- en: 'As expected, all of the global operators also exist for the class-specific
    operators, including versions such as aligned allocations:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，所有全局运算符也存在于特定于类的运算符中，包括对齐分配的版本：
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Understanding smart pointers and ownership
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解智能指针和所有权
- en: In this section, the reader will learn how to use smart pointers to increase
    the safety, reliability, and stability of their program, while also adhering to
    the C++ Core Guidelines.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，读者将学习如何使用智能指针来增加程序的安全性、可靠性和稳定性，同时也遵循C++核心准则。
- en: The std::unique_ptr{} pointer
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::unique_ptr{}指针
- en: 'It should be clear by now that C++ provides an extensive set of APIs for allocating
    and deallocating dynamic memory. It should also be clear that whether you are
    using `malloc()`/`free()` or `new()`/`delete()`, errors are not only possible
    but likely in large applications. For example, you might forget to release memory
    back to the heap:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该清楚了，C++提供了一套广泛的API来分配和释放动态内存。同时也应该清楚，无论你使用`malloc()`/`free()`还是`new()`/`delete()`，在大型应用程序中错误不仅可能而且很可能发生。例如，你可能会忘记将内存释放回堆：
- en: '[PRE32]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Or you could use `delete` instead of `delete []` when allocating an array:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在分配数组时，你可以使用`delete`而不是`delete []`：
- en: '[PRE33]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To overcome this, C++11 introduced the concept of pointer ownership with two
    classes:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这一点，C++11引入了指针所有权的概念，使用了两个类：
- en: '`std::unique_ptr{}`: Defines a pointer uniquely owned by a single entity. Copying
    this pointer is not allowed and is explicitly prevented by the compiler, and deallocations
    are automatically handled by C++.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unique_ptr{}`：定义了一个由单个实体独有拥有的指针。不允许复制该指针，并且由C++自动处理内存释放。'
- en: '`std::shared_ptr{}`: Defines a pointer that may be owned by one or more entities.
    Copying this pointer is allowed, and deallocation only occurs when all of the
    owners have released their ownership.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::shared_ptr{}`: 定义一个可能由一个或多个实体拥有的指针。允许复制此指针，并且只有在所有所有者释放所有权时才会释放内存。'
- en: 'The C++ Core Guidelines, in general, discourage any dynamic allocations that
    are not performed by these two classes. For most cases where `new` and `delete`
    would normally be used, `std::unique_ptr{}` should be used instead. Consider the
    following example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，C++核心指南不鼓励不是由这两个类执行的任何动态分配。在大多数情况下，通常会使用`new`和`delete`的地方，应该改用`std::unique_ptr{}`。考虑以下例子：
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To create both `std::unique_ptr{}` and `std::shared_ptr`, C++ provides the
    following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建`std::unique_ptr{}`和`std::shared_ptr`，C++提供了以下内容：
- en: '`std::make_unique()`: Creates `std::unique_ptr{}`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::make_unique()`: 创建`std::unique_ptr{}`'
- en: '`std::make_shared()`: Creates `std::shared_ptr{}`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::make_shared()`: 创建`std::shared_ptr{}`'
- en: 'If you plan to provide C++ Core Guideline compliance, get used to these functions.
    As shown, to create `std::unique_ptr{}`, you must provide the object type you
    plan to allocate, and the object''s initial value, as a template argument. Also,
    as shown, there is no need to manually call the `delete()` operator, as this is
    done for you. To demonstrate this, see the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划遵守C++核心指南，请熟悉这些函数。如上所示，要创建`std::unique_ptr{}`，必须提供要分配的对象类型以及对象的初始值作为模板参数。此外，如上所示，无需手动调用`delete()`运算符，因为这是由系统自动完成的。为了证明这一点，看下面的例子：
- en: '[PRE35]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Using `std::unique_ptr{}` in this example, both memory leaks and memory API
    mismatching have been prevented. In addition, this smart allocation and deallocation
    is scoped. Consider the following example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中使用`std::unique_ptr{}`，防止了内存泄漏和内存API不匹配。此外，这种智能分配和释放是有范围的。考虑以下例子：
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`myclass1` is stored as a member variable of `myclass2`. In the `main` function,
    `myclass2` is created and destroyed immediately, and as a result, when `myclass2`
    is destroyed, `myclass1` is also released back to the heap.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`myclass1`作为`myclass2`的成员变量存储。在`main`函数中，创建并立即销毁`myclass2`，结果是当销毁`myclass2`时，`myclass1`也会被释放回堆。'
- en: '`std::unique_ptr{}` accepts a pointer to previously-allocated memory (for example,
    via the `new()` operator), and then, on destruction, releases the memory it was
    given via the `delete()` operator by default. If the memory provided to `std::unique_ptr{}`
    is allocated using `new[]()` instead of `new()`, the `[]` version of `std::unique_ptr{}`
    should be used to ensure it releases the allocated memory using `delete[]()` instead
    of `delete()`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unique_ptr{}`接受指向先前分配的内存的指针（例如通过`new()`运算符），然后在销毁时默认释放通过`delete()`运算符给出的内存。如果提供给`std::unique_ptr{}`的内存是使用`new[]()`而不是`new()`分配的，则应该使用`[]`版本的`std::unique_ptr{}`，以确保它使用`delete[]()`而不是`delete()`释放分配的内存：'
- en: '[PRE37]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The more C++-Core-Guideline-compliant method for allocating and deallocating
    an array using `std::unique_ptr{}` is to use the array version of `std::make_unique()`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`std::unique_ptr{}`分配和释放数组的更符合C++核心指南的方法是使用`std::make_unique()`的数组版本：
- en: '[PRE38]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Instead of manually allocating the array, `std::make_unique()` allocates the
    array for you. The difference between a single-object allocation and an array
    allocation with `std::make_unique()` is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::make_unique()`代替手动分配数组。使用`std::make_unique()`进行单个对象分配和数组分配的区别如下：'
- en: '`std::make_unique<type>(args)`: To perform a single-object allocation, the
    type is provided as the template argument, and the object''s constructor arguments
    are provided as the arguments to `std::make_unique()`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::make_unique<type>(args)`: 要执行单个对象分配，需要将类型作为模板参数提供，并将对象的构造函数参数作为参数提供给`std::make_unique()`'
- en: '`std::make_unique<type[]>(size)`: To perform an array allocation, the array
    type is provided as the template argument, and the size of the array is provided
    as the argument to `std::make_unique()`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::make_unique<type[]>(size)`: 要执行数组分配，需要将数组类型作为模板参数提供，并将数组的大小作为参数提供给`std::make_unique()`'
- en: 'In some cases, the memory provided to `std::unique_ptr{}` cannot be released
    using `delete()` or `delete[]()` (for example, a `mmap()` buffer, placement `new()`,
    and more). To support these types of scenarios, `std::unique_ptr{}` accepts custom
    deleters:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，提供给`std::unique_ptr{}`的内存无法使用`delete()`或`delete[]()`释放（例如`mmap()`缓冲区，放置`new()`等）。为支持这些类型的情况，`std::unique_ptr{}`接受自定义删除器：
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the preceding example, a `deleter` class is created, and a functor (that
    is, `operator ()`) is provided, which performs the custom deletion. When it's
    time to release the allocated memory, the functor is called by `std::unique_ptr{}`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，创建了一个`deleter`类，并提供了一个函数对象（即`operator ()`），用于执行自定义删除。当需要释放分配的内存时，`std::unique_ptr{}`会调用这个函数对象。
- en: 'One disadvantage of `std::unqiue_ptr{}` in C++17 is that the alignment versions
    of the `new` and `delete` operators were not extended to `std::unique_ptr{}` (or
    `std::shared_pointer{}`). Since there is no alignment version for `std::unique_ptr{}`,
    if aligned memory is required, it must be allocated manually (hopefully an issue
    that will be resolved in future versions of C++ as this allocation style is typically
    discouraged by the C++ Core Guidelines):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: C++17中`std::unique_ptr{}`的一个缺点是，`new`和`delete`运算符的对齐版本没有扩展到`std::unique_ptr{}`（或`std::shared_pointer{}`）。由于`std::unique_ptr{}`没有对齐版本，如果需要对齐内存，必须手动分配（希望这个问题在未来的C++版本中得到解决，因为这种分配方式通常是C++核心指南所不鼓励的）：
- en: '[PRE40]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Like a normal C++-style pointer, `*` and `->` may be used to dereference at
    `std::unique_ptr{}`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与普通的C++风格指针一样，`*`和`->`可以用于解引用`std::unique_ptr{}`：
- en: '[PRE41]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To get `std::unique_ptr{}` to release its allocation, the pointer needs to
    lose scope, causing the destructor of `std::unique_ptr{}` to be called, which
    in turn releases the allocation back to the heap. `std::unique_ptr{}` also provides
    the `reset()` function, which explicitly tells the pointer to release its memory
    on demand, without having to lose scope:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要使`std::unique_ptr{}`释放其分配，指针需要失去作用域，导致调用`std::unique_ptr{}`的析构函数，从而将分配释放回堆。`std::unique_ptr{}`还提供了`reset()`函数，它明确告诉指针在需要时释放其内存，而无需失去作用域：
- en: '[PRE42]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this example, `std::unique_ptr{}` is reset, and as a result, the pointer
    it is storing is equivalent to `nullptr`. `std::unique_ptr{}` does not check to
    ensure that the pointer is valid when it is dereferenced using operators such
    as `->` and `*`. For this reason, the `reset()` function should be used with care,
    and used only when needed (for example, when the order in which allocations are
    released matters).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`std::unique_ptr{}`被重置，因此它存储的指针等同于`nullptr`。`std::unique_ptr{}`在使用`->`和`*`等运算符对其进行解引用时不会检查指针是否有效。因此，应谨慎使用`reset()`函数，并且仅在需要时使用（例如，释放分配的顺序很重要时）。
- en: 'Here are a couple of ways `std::unique_ptr{}` could be invalid (but this is
    not an exhaustive list):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`std::unique_ptr{}`可能无效的几种方式（但这不是详尽列表）：
- en: It was originally created using `nullptr`
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最初是使用`nullptr`创建的
- en: '`reset()` or `release()` was called'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用了`reset()`或`release()`
- en: 'To check whether `std::unique_ptr{}` is valid, to ensure a null dereference
    doesn''t accidentally occur, the Boolean operator may be used:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查`std::unique_ptr{}`是否有效，以确保不会意外发生空指针解引用，可以使用布尔运算符：
- en: '[PRE43]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As shown in this example, once `reset()` is called on `std::unique_ptr{}`, it
    becomes invalid (that is, its equal to `nullptr`), and the Boolean operator returns
    `false`, preventing a `nullptr` dereference.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如本例所示，一旦在`std::unique_ptr{}`上调用`reset()`，它就变得无效（即等于`nullptr`），布尔运算符返回`false`，防止`nullptr`解引用。
- en: 'If `std::unique_ptr{}` is created using the array syntax, the subscript operator
    may be used to access a specific element in the array, similar to using the subscript
    operator for a standard C array, or `std::array{}`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用数组语法创建`std::unique_ptr{}`，则可以使用下标运算符来访问数组中的特定元素，类似于使用下标运算符访问标准C数组或`std::array{}`：
- en: '[PRE44]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the preceding example, an integer array is allocated a size of `42`, and
    the first element in the array is outputted to `stdout`, which contains the value
    of `0` since `std::make_unique()` uses value initialization to zero-initialize
    all allocations.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，分配了大小为`42`的整数数组，并将数组中的第一个元素输出到`stdout`，其中包含值`0`，因为`std::make_unique()`使用值初始化来对所有分配进行零初始化。
- en: It should be noted that even though the C++ Core Guidelines encourage the use
    of `std::unique_ptr{}` instead of manually allocating and deallocating C-style
    arrays, the guidelines do not encourage the use of the subscript operator to access
    the array since doing so performs unsafe pointer arithmetic, and could potentially
    lead to a `nullptr` dereference. Instead, a newly-allocated array using `std::unique_ptr{}`
    should be provided to `gsl::span` prior to being accessed.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，尽管C++核心指南鼓励使用`std::unique_ptr{}`而不是手动分配和释放C风格数组，但指南不鼓励使用下标运算符来访问数组，因为这样做会执行不安全的指针算术，并可能导致`nullptr`解引用。相反，应该在访问之前将使用`std::unique_ptr{}`新分配的数组提供给`gsl::span`。
- en: 'One limitation of C++17 with respect to `std::unique_ptr{}` is the inability
    to directly add one to an IO stream such as `std::cout`. With C++17, the best
    way to output the address of `std::unique_ptr{}` is to use the `get()` function,
    which returns the address of the pointer. Another way to accomplish this is to
    create a user-defined overload:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`std::unique_ptr{}`，C++17的一个限制是无法直接将其添加到诸如`std::cout`之类的IO流。在C++17中，输出`std::unique_ptr{}`的地址的最佳方法是使用`get()`函数，该函数返回指针的地址。另一种实现这一点的方法是创建用户定义的重载：
- en: '[PRE45]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The std::shared_ptr pointer
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::shared_ptr指针
- en: In most cases, `std::unique_ptr{}` should be used to allocate dynamic memory.
    In some use cases, however, `std::unique_ptr{}` is incapable of properly representing
    pointer ownership. Pointer ownership refers to who owns a pointer, or in other
    words, who is responsible for allocating, and more importantly, deallocating a
    pointer. In most cases, a single entity within a program is responsible for this
    task. There are, however, some use cases where more than one entity must claim
    responsibility for deallocating a pointer.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，应该使用`std::unique_ptr{}`来分配动态内存。然而，在某些用例中，`std::unique_ptr{}`无法正确表示指针所有权。指针所有权指的是谁拥有指针，或者换句话说，谁负责分配，更重要的是，释放指针。在大多数情况下，程序中的单个实体负责此任务。然而，有一些用例需要多个实体来声明释放指针的责任。
- en: 'The most common scenario where more than one entity must claim ownership over
    a variable involves threading. Suppose you have two threads:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的情况是多个实体必须声明对变量的所有权，涉及线程。假设您有两个线程：
- en: 'Thread #1 creates a pointer (and thus owns it)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程＃1创建指针（因此拥有它）
- en: 'Thread #2 uses the pointer from thread #1'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程＃2使用来自线程＃1的指针
- en: 'In this example, the second thread owns the pointer just as much as the first
    thread that created the pointer and provided it in the first place. The following
    example demonstrates this scenario:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，第二个线程拥有指针，就像创建指针并在第一次提供它的第一个线程一样。以下示例演示了这种情况：
- en: '[PRE46]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this example, the first thread is created, which creates a pointer to `myclass`.
    It then creates the second thread and passes the newly-created pointer to this
    second thread. Both threads perform a set of actions on the pointer, and then
    complete. The problem is that the first thread doesn't have as much work to perform
    as the second thread, so it completes quickly, releasing the pointer before the
    second thread has a chance to complete, since in this scenario we have explicitly
    stated that `thread1` is the owner of the pointer and `thread2` is simply a user
    of the pointer.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，首先创建了第一个线程，它创建了一个指向`myclass`的指针。然后创建第二个线程，并将新创建的指针传递给这个第二个线程。两个线程对指针执行一系列操作，然后完成。问题在于，第一个线程没有第二个线程那么多的工作要做，所以它很快就完成了，释放了指针，而第二个线程还没有完成的机会，因为在这种情况下，我们明确声明`thread1`是指针的所有者，而`thread2`只是指针的使用者。
- en: 'To overcome this issue, C++ provides a second smart pointer, called `std::shared_ptr{}`,
    that is capable of assigning ownership to more than one entity. The syntax for
    `std::shared_ptr{}` is almost identical to `std::unique_ptr{}`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，C++提供了第二个智能指针，称为`std::shared_ptr{}`，它能够将所有权分配给多个实体。`std::shared_ptr{}`的语法几乎与`std::unique_ptr{}`相同。
- en: '[PRE47]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Internally, `std::shared_ptr{}` maintains the managed object in a separate object
    that is shared between all copies of the original `std::shared_ptr{}`. This managed
    object stores a count of the total number of `std::shared_ptr{}` copies. Each
    time a copy is created, the count inside the managed object increases. When `std::shared_ptr{}`
    needs access to the pointer itself, it must use its pointer to the managed object
    to ask for the pointer (that is, `std::shared_ptr{}` doesn't store the pointer
    itself, but rather stores a pointer to a managed object that stores the pointer).
    Each time `std::shared_ptr{}` is destroyed, the managed object's count is decreased,
    and when the count reaches `0`, the pointer is finally released back to the heap.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`std::shared_ptr{}`将托管对象保存在一个单独的对象中，该对象在所有原始`std::shared_ptr{}`的副本之间共享。这个托管对象存储了`std::shared_ptr{}`副本的总数。每次创建一个副本，托管对象内的计数就会增加。当`std::shared_ptr{}`需要访问指针本身时，它必须使用指向托管对象的指针来请求指针（也就是说，`std::shared_ptr{}`并不存储指针本身，而是存储指向存储指针的托管对象的指针）。每次销毁`std::shared_ptr{}`时，托管对象的计数都会减少，当计数达到0时，指针最终会被释放回堆。
- en: 'Using this pattern, `std::shared_ptr{}` is capable of providing ownership of
    a single pointer to multiple entities. The following rewrites the preceding example
    using `std::shared_ptr{}` instead of `std::unique_ptr{}`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种模式，`std::shared_ptr{}`能够将单个指针的所有权提供给多个实体。以下是使用`std::shared_ptr{}`而不是`std::unique_ptr{}`重写前面的示例：
- en: '[PRE48]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As shown in this example, `thread2` is given a copy of the original `std::shared_ptr{}`,
    creating in effect two copies that point to a single managed object. When `thread1`
    completes, `thread2` still maintains a reference to the managed object and as
    a result, the pointer remains intact. It's not until the second thread completes
    that the managed object's reference count reaches 0 and the pointer is released
    back to the heap.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这个例子所示，`thread2`得到了原始`std::shared_ptr{}`的一个副本，实际上创建了指向单个托管对象的两个副本。当`thread1`完成时，`thread2`仍然保持对托管对象的引用，因此指针保持完好。直到第二个线程完成，托管对象的引用计数达到0，指针才会被释放回堆。
- en: 'It should be noted that there are some disadvantages to `std::shared_ptr{}`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，`std::shared_ptr{}`也存在一些缺点：
- en: '**Memory footprint**: Since `std::shared_ptr{}` maintains a pointer to a managed
    object, `std::shared_ptr{}` could result in two mallocs instead of one (some implementations
    are capable of allocating a single, larger chunk of memory and using it for both
    the pointer and the managed object). Regardless of the implementation, the amount
    of memory that is needed by `std::shared_ptr{}` is larger than that of `std::unique_ptr{}`,
    which is often the same size sd a regular C-style pointer.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存占用：由于`std::shared_ptr{}`保持对托管对象的指针，`std::shared_ptr{}`可能会导致两次malloc而不是一次（一些实现能够分配单个更大的内存块，并将其用于指针和托管对象）。无论实现方式如何，`std::shared_ptr{}`所需的内存量都大于`std::unique_ptr{}`，通常与常规C风格指针的大小相同。
- en: '**Performance**: All access to the pointer must first be redirected to the
    managed object since `std::shared_ptr{}` does not actually have a copy of the
    pointer itself (just a pointer to the managed object). As a result, additional
    function calls (that is, pointer dereferences) are required.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能：所有对指针的访问都必须首先重定向到托管对象，因为`std::shared_ptr{}`实际上并没有指针本身的副本（只有指向托管对象的指针）。因此，需要额外的函数调用（即指针解引用）。
- en: '**Memory leaks**: There is a tradeoff between `std::unique_ptr{}` and `std::shared_ptr{}`,
    and neither provides the perfect solution for managing memory in a way that prevents
    possible `nullptr` dereferences while at the same time preventing memory leaks.
    As demonstrated, the use of `std::unique_ptr{}` in some situations could result
    in a `nullptr` dereference. On the other hand, `std::shared_ptr{}` could result
    in a memory leak if the number of copies of `std::shared_ptr{}` never reaches
    0\. Although these problems with smart pointers exist, the use of `new()`/`delete()`
    manually doesn''t address these issues (and almost certainly makes them worse),
    and in general, if the right smart pointer type is used in the right scenario,
    these types of issues can be alleviated.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存泄漏：在管理内存的方式上，`std::unique_ptr{}`和`std::shared_ptr{}`之间存在权衡，两者都不能提供完美的解决方案，既能防止可能的`nullptr`解引用，又能防止内存泄漏。正如所示，在某些情况下使用`std::unique_ptr{}`可能会导致`nullptr`解引用。另一方面，`std::shared_ptr{}`可能会导致内存泄漏，如果`std::shared_ptr{}`的副本数量从未达到0。尽管存在这些智能指针的问题，手动使用`new()`/`delete()`并不能解决这些问题（几乎肯定会使问题变得更糟），通常情况下，如果在正确的场景中使用正确的智能指针类型，这些问题可以得到缓解。
- en: '**Cyclic references**: It is possible to create cyclic references with `std::shared_ptr{}`.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环引用：使用`std::shared_ptr{}`可以创建循环引用。
- en: 'Like `std::unique_ptr{}`, `std::shared_ptr{}` provides a `reset()` function:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与`std::unique_ptr{}`一样，`std::shared_ptr{}`提供了一个`reset()`函数：
- en: '[PRE49]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In this example, two copies of `std::shared_ptr{}` are created. We first output
    the address of these pointers to `stdout`, and as expected, the address is valid,
    and they are the same (as they both point to the same managed object). Next, we
    release using the `reset()` function, the second pointer and then output the address
    of the pointers again. The second time around, the first `std::shared_ptr{}` still
    points to a valid pointer, while the second points to `nullptr`, since it no longer
    has a reference to the original managed object. The pointer is eventually released
    back to the heap when the `main()` function completes.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，创建了两个`std::shared_ptr{}`的副本。我们首先将这些指针的地址输出到`stdout`，如预期的那样，地址是有效的，它们是相同的（因为它们都指向同一个托管对象）。接下来，使用`reset()`函数释放第二个指针，然后再次输出指针的地址。第二次，第一个`std::shared_ptr{}`仍然指向有效指针，而第二个指向`nullptr`，因为它不再引用原始托管对象。当`main()`函数完成时，指针最终将被释放到堆上。
- en: 'One issue with the C++17 version of `std::shared_ptr{}` is a lack of an array
    version, similar to `std::unique_ptr{}`. That is, there is no `std::shared_ptr<type[]>`
    version of `std::shared_ptr{}`, similar to the `std::unique_ptr<type[]>{}` API. 
    As a result, there is no way to allocate an array using `std::make_shared()`, and
    there is no subscript operator to access each element in the array. Instead, you
    must do the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: C++17版本的`std::shared_ptr{}`的一个问题是缺乏类似`std::unique_ptr{}`的数组版本。也就是说，没有`std::shared_ptr<type[]>`版本的`std::shared_ptr{}`，类似于`std::unique_ptr<type[]>{}`的API。因此，无法使用`std::make_shared()`来分配数组，并且没有下标运算符来访问数组中的每个元素。相反，必须执行以下操作：
- en: '[PRE50]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'C++ also provides a method for determining how many copies of `std::shared_ptr{}`
    exist (which essentially just asks the managed object for its reference count):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: C++还提供了一种确定`std::shared_ptr{}`存在多少个副本的方法（实质上只是询问托管对象的引用计数）：
- en: '[PRE51]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This example is similar to the preceding `reset()` example, but adds a call
    to the `use_count()` function that reports the total number of copies of `std::shared_ptr{}`.
    As shown, when two copies of `std::shared_ptr{}` are created, `use_count()` reports
    `2`. When `reset()` is run, `use_count()` reduces to `1`, and eventually when
    `main()` completes, this count will reduce to `0` and the pointer will be released
    to the heap. It should be noted that this function should be used with caution
    in multithreaded environments as races can occur with respect to the reported
    count.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例与前面的`reset()`示例类似，但增加了对`use_count()`函数的调用，该函数报告`std::shared_ptr{}`的总副本数。如示例所示，当创建两个`std::shared_ptr{}`的副本时，`use_count()`报告`2`。当运行`reset()`时，`use_count()`减少为`1`，最终当`main()`完成时，此计数将减少为`0`，指针将被释放到堆上。应该注意，在多线程环境中应谨慎使用此函数，因为可能会发生关于报告的计数的竞争。
- en: 'Similar to `std::unique_ptr{}`, a Boolean operator is provided to `std::shared_ptr{}` to
    check whether the pointer is valid. Unlike `std::unique_ptr{}`, the Boolean operator
    doesn''t determine whether the managed object has been released (as there might
    be a copy of `std::shared_ptr{}` lying around somewhere). Instead, the Boolean operator
    reports whether or not `std::shared_ptr{}` is maintaining a reference to the managed
    object. If `std::shared_ptr{}` is valid, it has a reference to the managed object
    (and thus access to the allocated pointer), and the Boolean operator reports `true`.
    If `std::shared_ptr{}` is invalid, it no longer maintains a reference to the managed
    object (and thus doesn''t have access to the allocated pointer), returning `nullptr`
    when `get()` is called, and the Boolean operator reports `false`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 与`std::unique_ptr{}`类似，`std::shared_ptr{}`也提供了一个布尔运算符来检查指针是否有效。与`std::unique_ptr{}`不同，布尔运算符不确定托管对象是否已被释放（因为可能有一个`std::shared_ptr{}`的副本在某个地方）。相反，布尔运算符报告`std::shared_ptr{}`是否在维护对托管对象的引用。如果`std::shared_ptr{}`有效，则它引用托管对象（因此可以访问分配的指针），布尔运算符报告`true`。如果`std::shared_ptr{}`无效，则不再维护对托管对象的引用（因此无法访问分配的指针），调用`get()`时返回`nullptr`，布尔运算符报告`false`：
- en: '[PRE52]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As shown in the preceding example, when the `reset()` function is called, the
    pointer is no longer valid, as the smart pointer's internally-managed object is
    now pointing to `nullptr`, and thus, the Boolean operator returns `false`. Since
    there are no other copies of `std::shared_ptr{}` (that is, the managed object's
    count is `0`), the allocated pointer is also released back to the heap.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，当调用`reset()`函数时，指针将不再有效，因为智能指针内部管理的对象现在指向`nullptr`，因此布尔运算符返回`false`。由于没有其他`std::shared_ptr{}`的副本（即，托管对象的计数为`0`），分配的指针也将被释放到堆上。
- en: 'Like `std::unique_pt{}r`, both the `*` and `->` operators are provided to dereference `std::shared_ptr{}`
    (but no subscript operator since arrays are not supported):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 与`std::unique_ptr{}`一样，`std::shared_ptr{}`提供了`*`和`->`运算符来取消引用`std::shared_ptr{}`（但不提供下标运算符，因为不支持数组）：
- en: '[PRE53]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, one issue with `std::shared_ptr{}` is that of cyclic references. The
    following example does the best job of describing the issue:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`std::shared_ptr{}`的一个问题是循环引用。以下示例最好地描述了这个问题：
- en: '[PRE54]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In this example, two classes are created—`myclass1` and `myclass2`. Both `myclass1`
    and `myclass2` maintain `std::shared_ptr{}` references to each other (that is,
    for whatever reason, both classes claim ownership over the other). When the pointers
    are destroyed, no memory is released back to the heap because none of the destructors
    is ever called. To understand why, we need to break down the number of copies
    that are made, and where they exist.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，创建了两个类——`myclass1`和`myclass2`。`myclass1`和`myclass2`都维护对彼此的`std::shared_ptr{}`引用（也就是说，出于某种原因，两个类都声称拥有对另一个类的所有权）。当指针被销毁时，没有内存被释放到堆上，因为没有一个析构函数被调用。要理解原因，我们需要分解所做的副本数量以及它们存在的位置。
- en: The original `std::shared_ptr{}` for `ptr1` and `ptr2` are both created in the
    `main()` function, when means the `#1` and `#2` managed objects both have a `use_count()`
    of `1` upon creation. Next, `ptr1` is given a copy of `std::shared_ptr{}` for
    `ptr2`, and vice version, meaning the `#1` and `#2` managed objects now both have
    a `use_count()` of `2`. When `main()` completes, the `std::shared_ptr{}` for `ptr2`
    in the `main()` function (not `std::shared_ptr{}` in `ptr1`) is destroyed, but
    since there is still a `std::shared_ptr{}` copy of `ptr2` in `ptr1`, the pointer
    itself is not released. Next, `ptr1`  in `main()` is destroyed, but since the
    copy of `ptr2` still exists in one of the copies of `ptr1`, `ptr1` itself is not
    released, and thus, we have created a copy of `ptr1` and `ptr2` that point to
    each other, but with no copies of these pointers left in the code itself to release
    this memory, and thus memory is permanently deleted.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`ptr1`和`ptr2`的原始`std::shared_ptr{}`都是在`main()`函数中创建的，这意味着`#1`和`#2`管理的对象在创建时都有`use_count()`为`1`。接下来，`ptr1`得到了`ptr2`的`std::shared_ptr{}`的副本，反之亦然，这意味着`#1`和`#2`管理的对象现在都有`use_count()`为`2`。当`main()`完成时，`main()`函数中的`ptr2`的`std::shared_ptr{}`被销毁（而不是`ptr1`中的`std::shared_ptr{}`），但由于`ptr1`中仍然有`ptr2`的`std::shared_ptr{}`的副本，指针本身并没有被释放。接下来，`main()`中的`ptr1`被销毁，但由于`ptr1`的副本仍然存在于`ptr1`的一个副本中，`ptr1`本身也没有被释放，因此，我们创建了一个指向彼此的`ptr1`和`ptr2`的副本，但代码本身没有剩余的这些指针的副本来释放这个内存，因此内存被永久删除。'
- en: 'To solve this, `std::shared_ptr{}` provides a version of itself called `std::weak_ptr{}`.
    It has all the same properties of `std::shared_ptr{}`, but doesn''t increment
    the reference counter of the managed object. Although the `get()` function could
    be used instead to store a raw pointer, `std::weak_ptr{}` still maintains a connection
    with the managed object, providing a means to determine whether the managed object
    has been destroyed, something you cannot do with a raw pointer. To demonstrate
    this, the preceding example has been converted to use `std::weak_ptr{}` in `myclass1`
    and `myclass2` instead of `std::shared_ptr{}`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，`std::shared_ptr{}`提供了一个称为`std::weak_ptr{}`的版本。它具有`std::shared_ptr{}`的所有属性，但不会增加托管对象的引用计数。虽然`get()`函数可以用来存储原始指针，但`std::weak_ptr{}`仍然与托管对象保持连接，提供了一种确定托管对象是否已被销毁的方法，这是使用原始指针无法做到的。为了证明这一点，前面的例子已经被转换为在`myclass1`和`myclass2`中使用`std::weak_ptr{}`而不是`std::shared_ptr{}`：
- en: '[PRE55]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As shown in this example, even though a cyclic reference still exists, the
    allocated pointers are released back to the heap when `main()` completes. Finally,
    it should be noted that it is possible to convert `std::unique_ptr` to `std::shared_ptr`
    using the following syntax:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本例所示，即使存在循环引用，当`main()`完成时，分配的指针也会被释放回堆。最后，应该注意，可以使用以下语法将`std::unique_ptr`转换为`std::shared_ptr`：
- en: '[PRE56]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Since `std::unique_ptr` is being moved, it no longer owns the pointer, and instead `std::shared_ptr`
    now owns the pointer. Moving from `std::shared_ptr` to `std::unqiue_ptr` is not
    allowed.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`std::unique_ptr`被移动，它不再拥有指针，而是`std::shared_ptr`现在拥有指针。从`std::shared_ptr`移动到`std::unqiue_ptr`是不允许的。
- en: Learning about mapping and permissions
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习映射和权限
- en: In this section, the reader will learn how to map memory using C++ patterns.
    You will learn how to map memory (a common system-programming technique), while
    doing so using C++ patterns.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，读者将学习如何使用C++模式映射内存。您将学习如何映射内存（一种常见的系统编程技术），同时使用C++模式进行操作。
- en: The basics
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础知识
- en: '`malloc()`/`free()`, `new()`/`delete()`, and `std::unique_ptr{}`/`std::shared_ptr{}`
    are not the only methods for allocating memory on a POSIX system. C++-style allocators
    are another, more complicated, method for allocating memory that will be discussed
    in greater detail in [Chapter 9](2a64ae97-dad4-479a-bd9f-9df2cb634b74.xhtml),
    *A Hands-On Approach to Allocators*. A more direct, POSIX style for allocating
    memory is to use `mmap()`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`malloc()`/`free()`、`new()`/`delete()`和`std::unique_ptr{}`/`std::shared_ptr{}`并不是在POSIX系统上分配内存的唯一方法。C++风格的分配器是另一种更复杂的分配内存的方法，将在[第9章](2a64ae97-dad4-479a-bd9f-9df2cb634b74.xhtml)中更详细地讨论，*分配器的实践方法*。一种更直接的、POSIX风格的分配内存的方法是使用`mmap()`：'
- en: '[PRE57]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `mmap()` function may be used to map memory from different sources into
    a program. For example, if you want to make device memory into your application,
    you would use `mmap()`. If `MAP_ANONYMOUS` is passed to `mmap()`, it can be used
    to allocate memory the same way you would allocate memory using `malloc()` and
    `free()`. In the preceding example, `mmap()` is used to allocate a 4k page of
    memory that is marked read/write. The use of `MAP_PRIVATE` tells `mmap()` that
    you do not intend to share this memory with other applications (for example, for
    interprocess communication). Mapping memory this way compared to `malloc()`/`free()`
    has some advantages and disadvantages.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`mmap()`函数可以用来将来自不同来源的内存映射到程序中。例如，如果要将设备内存映射到应用程序中，可以使用`mmap()`。如果将`MAP_ANONYMOUS`传递给`mmap()`，它可以用来分配内存，就像使用`malloc()`和`free()`分配内存一样。在前面的例子中，`mmap()`用于分配一个标记为读/写的4k页面的内存。使用`MAP_PRIVATE`告诉`mmap()`您不打算与其他应用程序共享此内存（例如，用于进程间通信）。与使用`malloc()`/`free()`分配内存相比，以这种方式映射内存有一些优点和缺点。'
- en: '**Advantages**:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**：'
- en: '**Fragmentation**: Allocating memory using `MAP_ANONYMOUS` usually maps memory
    in sizes that are multiples of a page size, or, worst case, a power of two. The
    is because `mmap()` is asking the OS kernel for a block memory, and that memory
    must be mapped into the application, which can only be done in blocks no smaller
    than a page. As a result, fragmentation of this memory is far less likely that
    multiple, random memory allocations usually made using `malloc()`.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**碎片化**：使用`MAP_ANONYMOUS`分配内存通常会将内存映射为页面大小的倍数，或者在最坏的情况下，是2的幂。这是因为`mmap()`正在向操作系统内核请求一个内存块，而该内存必须映射到应用程序中，这只能以不小于一个页面的块来完成。因此，与通常使用`malloc()`进行多次随机内存分配相比，这种内存的碎片化可能性要小得多。'
- en: '**Permissions**: When using `mmap()`, you can state the permissions you wish
    to apply to the newly-allocated memory. This is especially useful if you need
    memory with special permissions, such as read/execute memory.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**权限**：在使用`mmap()`时，您可以指定要应用于新分配内存的权限。如果您需要具有特殊权限的内存，例如读/执行内存，这将非常有用。'
- en: '**Shared memory**: The memory allocated using `mmap()` can also be shared by
    another application instead of being allocated privately for a specific application,
    as with `malloc()`.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共享内存**：使用`mmap()`分配的内存也可以被另一个应用程序共享，而不是为特定应用程序私有分配，就像使用`malloc()`一样。'
- en: '**Disadvantages**:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**：'
- en: '**Performance**: `malloc()`/`free()` allocate and deallocate to a block of
    memory that is managed by the C library inside the application itself. If more
    memory is needed, the C library will call into the OS, using functions such as `brk()` or
    even `mmap()`, to get more memory from the OS. When free is called, the released
    memory is provided back to the memory being managed by the C library, and in a
    lot of cases is never actually provided back to the OS. For this reason, `malloc()`/`free()`
    can quickly allocate memory for the application because no OS-specific calls are
    being made (unless of course the C library runs out of memory). `mmap()`, on the
    other hand, has to call into the OS on every single allocation. For this reason,
    it does not perform as well as `malloc()`/`free()` since an OS call can be expensive.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：`malloc()`/`free()`分配和释放由应用程序内部的C库管理的内存块。如果需要更多内存，C库将调用操作系统，使用诸如`brk()`甚至`mmap()`的函数，从操作系统获取更多内存。调用free时，释放的内存将返回到由C库管理的内存中，并且在许多情况下实际上从未返回到操作系统。因此，`malloc()`/`free()`可以快速为应用程序分配内存，因为不会进行任何特定于操作系统的调用（除非当然C库耗尽内存）。另一方面，`mmap()`必须在每次分配时调用操作系统。因此，它的性能不如`malloc()`/`free()`，因为操作系统调用可能很昂贵。'
- en: '**Granularity**: For the same reason that `mmap()` reduces fragmentation, it
    also reduces granularity. Every single allocation made by `mmap()` is at least
    a page in size, even if the requested memory is only a byte.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粒度**：与`mmap()`减少碎片化的原因相同，它也减少了粒度。`mmap()`进行的每次分配至少是一个页面大小，即使请求的内存只有一个字节。'
- en: 'To demonstrate the potential waste of `mmap()`, see the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示`mmap()`的潜在浪费，请参阅以下内容：
- en: '[PRE58]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In this example, 42 bytes are allocated twice, but the resulting addresses are
    a 4k page apart. This is because allocations made by `mmap()` must be at least
    a page in size, even though the requested amount was only 42 bytes. The reason
    that `malloc()`/`free()` does not have this waste is that these functions request
    large chunks of memory at a time from the OS, and then manage this memory using
    various different allocation schemes internally within the C library. For more
    information on how this is done, there is a very good explanation within `newlib`
    on the topic: [https://sourceware.org/git/?p=newlib-cygwin.git;a=blob;f=newlib/libc/stdlib/malloc.c.](https://sourceware.org/git/?p=newlib-cygwin.git;a=blob;f=newlib/libc/stdlib/malloc.c;h=f5ac2920888563013663454758cce102e40b69ad;hb=HEAD)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，分配了42字节两次，但生成的地址相隔4k页。这是因为由`mmap()`进行的分配必须至少是一个页面大小，即使请求的数量仅为42字节。`malloc()`/`free()`没有这种浪费的原因是这些函数一次从操作系统请求大块内存，然后在C库内部使用各种不同的分配方案管理这些内存。有关如何执行此操作的更多信息，在`newlib`中有一个关于此主题的非常好的解释：[https://sourceware.org/git/?p=newlib-cygwin.git;a=blob;f=newlib/libc/stdlib/malloc.c.](https://sourceware.org/git/?p=newlib-cygwin.git;a=blob;f=newlib/libc/stdlib/malloc.c;h=f5ac2920888563013663454758cce102e40b69ad;hb=HEAD)
- en: Permissions
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 权限
- en: '`mmap()` may be used to allocate memory with special parameters. For example,
    suppose you need to allocate memory that has read/execute permissions instead
    of the read/write permissions that are typically associated with `malloc()`/`free()`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`mmap()`可用于使用特殊参数分配内存。例如，假设您需要分配具有读/执行权限而不是通常与`malloc()`/`free()`相关联的读/写权限的内存：'
- en: '[PRE59]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As shown, allocating memory with read/execute permissions is the same as allocating
    memory with read/write permissions substituting `PROT_WRITE` with `PROT_EXEC`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，使用读/执行权限分配内存与使用读/写权限分配内存相同，将`PROT_WRITE`替换为`PROT_EXEC`。
- en: On systems that support read/write or read/execute (also known as W^E, which
    states that write is mutually exclusive with execute), write and execute permissions
    should not be used together at the same time. Specifically, in the event of malicious
    use of your program, preventing executable memory from also having write permissions
    can prevent a number of known cyber attacks.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持读/写或读/执行（也称为W^E，表示写与执行互斥）的系统上，不应同时使用写和执行权限。特别是在程序被恶意使用的情况下，防止可执行内存同时具有写权限可以防止许多已知的网络攻击。
- en: The problem with allocating memory as read/execute and not read/write/execute
    is that there is no easy way to place executable code into your newly-allocated
    buffer as the memory was marked as read/execute only. The same is true if you
    wish to allocate read-only memory. Once again, since write permissions were never
    added, there is no way to add data to read-only memory as it doesn't have write
    permissions.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 将内存分配为只读/执行而不是读/写/执行的问题在于，没有简单的方法将可执行代码放入新分配的缓冲区中，因为内存被标记为只读/执行。如果您希望分配只读内存也是如此。再次，由于从未添加写权限，因此无法向只读内存添加数据，因为它没有写权限。
- en: To make the situation worse, some operating systems prevent applications from
    allocating read/write/execute memory as they attempt to enforce W^E permissions.
    To overcome this issue, while still providing a means to set the desired permissions,
    POSIX provides `mprotect()`, which allows you to change the permissions of memory
    that has already been allocated. Although this may be used with memory that is
    managed by `malloc()`/`free()`, it should instead be used with `mmap()` memory
    permissions that can only be enforced at the page level on most architectures. `malloc()`/`free()`
    allocate from a large buffer that is shared among all of the program's allocations,
    while `mmap()` only allocates memory with page granularity, and therefore is not
    shared by other allocations.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，一些操作系统阻止应用程序分配读/写/执行内存，因为它们试图强制执行W^E权限。为了克服这个问题，同时仍然提供设置所需权限的手段，POSIX提供了`mprotect()`，它允许您更改已经分配的内存的权限。尽管这可能与由`malloc()`/`free()`管理的内存一起使用，但它应该与`mmap()`一起使用，因为大多数体系结构上的页面级别上只能强制执行内存权限。`malloc()`/`free()`从一个大缓冲区中分配，该缓冲区在程序的所有分配之间共享，而`mmap()`只分配页面粒度的内存，因此不会被其他分配共享。
- en: 'The following shows an example of how to use `mprotect`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何使用`mprotect`的示例：
- en: '[PRE60]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this example, `mmap()` is used to allocate a buffer the size of a 4k page
    with read/write permissions. Once the memory is allocated, `mprotect()` is used
    to change the permissions of the memory to read-only. Finally, `munmap()` is used
    to release the memory back to the operating system.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`mmap()`用于分配一个大小为4k页面的缓冲区，并具有读/写权限。分配内存后，`mprotect()`用于将内存的权限更改为只读。最后，`munmap()`用于将内存释放回操作系统。
- en: Smart pointers and mmap()
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能指针和mmap()
- en: 'With respect to C++, the biggest issue with `mmap()` and `munmap()` is that
    they suffer from a lot of the same disadvantages as `malloc()`/`free()`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 就C++而言，`mmap()`和`munmap()`的最大问题是它们遭受了与`malloc()`/`free()`相同的许多缺点：
- en: '**Memory leaks**: Since `mmap()` and `munmap()` must be executed manually,
    it''s possible the user could forget to call `munmap()` when the memory is no
    longer needed, or a complex logic bug could result in `munmap()` not being called
    at the right time.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存泄漏**：由于`mmap()`和`munmap()`必须手动执行，用户可能会忘记在不再需要内存时调用`munmap()`，或者复杂的逻辑错误可能导致在正确的时间不调用`munmap()`。'
- en: '**Memory mismatch**: It''s possible that the users of `mmap()` could call `free()`
    instead of `munmap()` by accident, resulting in a mismatch that is almost certain
    to generate instability because memory from `mmap()` is coming from the OS kernel,
    while `free()` is expecting memory from application heap.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存不匹配**：`mmap()`的用户可能会错误地调用`free()`而不是`munmap()`，这几乎肯定会导致不稳定，因为来自`mmap()`的内存来自操作系统内核，而`free()`期望来自应用程序堆的内存。'
- en: 'To overcome this, `mmap()` should be wrapped with `std::unique_ptr{}`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这个问题，`mmap()`应该用`std::unique_ptr{}`包装：
- en: '[PRE61]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In this example, the main function calls `mmap_unique()` instead of `std::make_unqiue()`,
    as `std::make_unique()` allocates memory using `new()`/`delete()`, and we wish
    to use `mmap()`/`munmap()` instead. The first part of the `mmap_unique()` function
    allocates memory using `mmap()` the same way as our previous examples. In this
    case, permissions were set to read/write, but they could have also been changed
    using `mprotect()` to provide read-only or read/execute if desired. If the call
    to `mmap()` fails, `std::bad_alloc()` is thrown, just like the C++ library.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，主函数调用`mmap_unique()`而不是`std::make_unqiue()`，因为`std::make_unique()`使用`new()`/`delete()`分配内存，而我们希望使用`mmap()`/`munmap()`。`mmap_unique()`函数的第一部分使用`mmap()`分配内存的方式与我们之前的例子相同。在这种情况下，权限被设置为读/写，但也可以使用`mprotect()`进行更改，以提供只读或读/执行权限。如果`mmap()`调用失败，就像C++库一样，会抛出`std::bad_alloc()`。
- en: The next line in this example uses the `new()` placement operator, as discussed
    earlier in in the *Placement new* section. The goal of this call is to create
    an object whose constructor has been called to initialize the  `T` type as required.
    In the case of this example, this is setting an integer to `42`, but if a class
    were used instead of an integer, the classes constructor would be called with
    whatever arguments were passed to `mmap_unique()`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中的下一行使用了`new()`放置运算符，如前面在*放置new*部分中讨论的。这个调用的目标是创建一个对象，其构造函数已被调用以初始化所需的`T`类型。在这个例子中，这是将一个整数设置为`42`，但如果使用的是类而不是整数，类的构造函数将被调用，并传递给`mmap_unique()`的任何参数。
- en: The next step is to create a custom deleter for our `std::unqiue_ptr{}`. This
    is done because by default, `std::unqiue_ptr{}` will call the `delete()` operator
    instead of `munmap()`. The custom deleter takes a single argument that is the
    size of the original allocation. This is needed because `munmap()` needs to know
    the size of the original allocation, unlike `delete()` and `free()`, which just
    take a pointer.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为我们的`std::unqiue_ptr{}`创建自定义删除器。这是因为默认情况下，`std::unqiue_ptr{}`将调用`delete()`运算符而不是`munmap()`。自定义删除器接受一个参数，即原始分配的大小。这是因为`munmap()`需要知道原始分配的大小，而`delete()`和`free()`只需要一个指针。
- en: Finally, `std::unique_ptr{}` is created with the newly-created object and custom
    deleter. From this point on, all of the memory that was allocated using `mmap()`
    can be accessed using the standard `std::unique_ptr{}` interface, and treated
    as a normal allocation. When the pointer is no longer needed, and `std::unique_ptr{}`
    is out of scope, the pointer will be released back to the OS kernel by calling
    `munmap()` as expected.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用新创建的对象和自定义删除器创建了`std::unique_ptr{}`。从这一点开始，使用`mmap()`分配的所有内存都可以使用标准的`std::unique_ptr{}`接口访问，并被视为正常分配。当指针不再需要，并且`std::unique_ptr{}`超出范围时，将调用`munmap()`将指针释放回操作系统内核。
- en: Shared memory
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享内存
- en: 'In addition to allocating memory, `mmap()` may be used to allocate shared memory,
    typically for interprocess communications. To demonstrate this, we start by defining
    a shared memory name, `"/shm"`, and our read, write, and execute permissions:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 除了分配内存外，`mmap（）`还可用于分配共享内存，通常用于进程间通信。为了演示这一点，我们首先定义一个共享内存名称`"/shm"`，以及我们的读取、写入和执行权限：
- en: '[PRE62]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Next, we must define our custom deleter, which uses `munmap()` instead of `free()`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须定义我们的自定义删除器，它使用`munmap（）`而不是`free（）`：
- en: '[PRE63]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In this example, we build off of the previous example, but instead of having
    a single `mmap_unique()` function, we now have a server and a client version.
    Although typically shared memory would be used for interprocess communication,
    in this example, we share memory in the same application to keep things simple.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们基于之前的例子，但现在不再只有一个`mmap_unique（）`函数，而是有一个服务器版本和一个客户端版本。尽管通常共享内存会用于进程间通信，在这个例子中，我们在同一个应用程序中共享内存，以保持简单。
- en: 'The `main` function creates both a server and a client-shared pointer. The
    server version creates shared memory using the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数创建了一个服务器和一个客户端共享指针。服务器版本使用以下方式创建共享内存：'
- en: '[PRE64]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This function is similar to the `mmap_unique()` function in the previous example,
    but opens a handle to a shared memory file instead of allocating memory using
    `MAP*_*ANONYMOUS`. To open the shared memory file, we use the `POSIX shm_open()`
    function. This function is similar to the `open()` function. The first parameter
    is the name of the shared memory file. The second parameter defines how the file
    is opened, while the third parameter provides the mode. `shm_open()` is used to
    open the shared memory file, and the file descriptor is checked to make sure the
    allocation succeeded (that is, the file descriptor is not `-1`).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数类似于之前例子中的`mmap_unique（）`函数，但是打开了一个共享内存文件的句柄，而不是使用`MAP*_*ANONYMOUS`来分配内存。为了打开共享内存文件，我们使用`POSIX
    shm_open（）`函数。这个函数类似于`open（）`函数。第一个参数是共享内存文件的名称。第二个参数定义了文件的打开方式，而第三个参数提供了模式。`shm_open（）`用于打开共享内存文件，并检查文件描述符以确保分配成功（即文件描述符不是`-1`）。
- en: Next, the file descriptor is truncated. This ensures that the size of the shared
    memory file is equal to the size of the memory we wish to share. In this case,
    we wish to share a single `T` type, so we need to get the size of `T`. Once the
    shared memory file has been properly sized, we need to map in the shared memory
    using `mmap()`. The call to `mmap()` is the same as our previous examples, with
    the exception that `MAP_SHARED` is used.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，文件描述符被截断。这确保了共享内存文件的大小等于我们希望共享的内存大小。在这种情况下，我们希望共享一个单一的`T`类型，所以我们需要获取`T`的大小。一旦共享内存文件的大小被正确调整，我们需要使用`mmap（）`映射共享内存。对`mmap（）`的调用与我们之前的示例相同，唯一的区别是使用了`MAP_SHARED`。
- en: Finally, like the previous example, we leverage the `new()` placement operator
    to create the newly-allocated type in shared memory, we create the custom deleter,
    and then finally, we return `std::unique_ptr{}` for this shared memory.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，就像之前的例子一样，我们利用`new()`放置运算符在共享内存中创建新分配的类型，我们创建自定义删除器，然后最后，我们返回`std::unique_ptr{}`以用于这个共享内存。
- en: 'To connect to this shared memory (which could be done from another application),
    we need to use the client version of the `mmap_unique()` function:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到这个共享内存（可以从另一个应用程序中完成），我们需要使用`mmap_unique（）`函数的客户端版本：
- en: '[PRE65]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The server and client versions of these functions look similar, but there are
    differences. First and foremost, the shared memory file is opened without `O_CREAT`.
    This is because the server creates the shared memory file, while the client connects
    to the shared memory file, so there is no need to pass `O_CREAT` in the client
    version. Finally, the signature of the client version of this function doesn''t
    take any arguments like the server version. This is because the server version
    uses the `new()` placement to initialize the shared memory, which doesn''t need
    to be done a second time. Instead of using the new placement, `static_cast()`
    is used to convert `void *` to the proper type prior to delivering the pointer
    to the newly created `std::unique_ptr{}`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的服务器和客户端版本看起来相似，但也有区别。首先，共享内存文件是在没有`O_CREAT`的情况下打开的。这是因为服务器创建共享内存文件，而客户端连接到共享内存文件，因此在客户端版本中不需要传递`O_CREAT`。最后，这个函数的客户端版本的签名不像服务器版本那样带有任何参数。这是因为服务器版本使用`new()`放置来初始化共享内存，不需要再次执行。而不是使用新的放置，`static_cast()`被用来将`void
    *`转换为适当的类型，然后将指针传递给新创建的`std::unique_ptr{}`：
- en: '[PRE66]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The result of this example is that memory is shared between a server and a client,
    wrapping the shared memory in `std::unique_ptr{}`. Furthermore, as shown in the
    example, the memory is properly shared, as can be seen by `42` being printed for
    both the server and client version of the pointer. Although we use this for an
    integer type, this type of shared memory can be used with any complex type as
    needed (although care should be taken when attempting to share classes, especially
    those that leverage inheritance and contain `vTable`).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的结果是，内存在服务器和客户端之间共享，将共享内存包装在`std::unique_ptr{}`中。此外，正如例子中所示，内存被正确共享，可以看到服务器和客户端版本的指针都打印出`42`。尽管我们用于整数类型，但这种类型的共享内存可以根据需要与任何复杂类型一起使用（尽管在尝试共享类时应该小心，特别是那些利用继承并包含`vTable`的类）。
- en: Learning importance of memory fragmentation
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习内存碎片化的重要性
- en: No chapter on memory management would be complete without a brief discussion
    of fragmentation. Memory fragmentation refers to a process in which memory is
    broken up into chunks, often spread out, almost always resulting in the allocator's
    inability to allocate memory for an application, ultimately resulting in `std::bad_alloc()`
    being thrown in C++. When programming systems, fragmentation should always be
    a concern as it can dramatically impact the stability and reliability of your
    program, especially on resource-constrained systems, such as embedded and mobile
    applications. In this section, the reader will get a brief introduction to fragmentation,
    and how it affects the programs they create.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 没有关于内存管理的章节是完整的，而没有对碎片的简要讨论。内存碎片指的是一种将内存分割成块的过程，通常是分散的，几乎总是导致分配器无法为应用程序分配内存，最终导致在C++中抛出`std::bad_alloc()`。在编程系统时，碎片应该始终是一个关注点，因为它可能会极大地影响程序的稳定性和可靠性，特别是在资源受限的系统上，比如嵌入式和移动应用程序。在本节中，读者将简要介绍碎片，以及它如何影响他们创建的程序。
- en: There are two types of fragmentation—external and internal fragmentation.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的碎片——外部碎片和内部碎片。
- en: External  fragmentation
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部碎片
- en: 'External fragmentation refers to the process by which memory is allocated and
    deallocated in different sized chunks, ultimately leading to large amounts of
    unusable, unallocatable memory. To demonstrate this, suppose we have five allocations:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 外部碎片指的是内存分配和释放的过程，以不同大小的块进行，最终导致大量不可用的未分配内存。为了证明这一点，假设我们有五次分配：
- en: '![](img/9fc89297-46e9-493a-994f-e7b8b2386dcf.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9fc89297-46e9-493a-994f-e7b8b2386dcf.png)'
- en: 'All five allocations succeed, and all of the memory is allocated. Now, let''s
    suppose that the second and fourth allocations are released back to the heap:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 所有五次分配都成功了，所有内存都被分配了。现在，假设第二次和第四次分配被释放回堆：
- en: '![](img/02d7340a-fdc8-4d25-9506-74b811a03676.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/02d7340a-fdc8-4d25-9506-74b811a03676.png)'
- en: 'By releasing memory back to the heap, memory is now available for allocation
    again. The problem is that this memory is spread out due to the original 1, 3,
    and 5 allocations. Now let''s suppose we want to make a final allocation:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将内存释放回堆，内存现在可以再次用于分配。问题在于，由于最初的1、3和5次分配，这些内存是分散的。现在假设我们想进行最后一次分配：
- en: '![](img/bdfab869-a161-4d4f-ae94-adc506cc324c.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bdfab869-a161-4d4f-ae94-adc506cc324c.png)'
- en: The final allocation fails, even though there is enough free memory for the
    allocation, because the free memory is spread out – in other words, the free memory
    is fragmented.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的分配失败了，即使有足够的空闲内存进行分配，因为空闲内存是分散的——换句话说，空闲内存是碎片化的。
- en: External fragmentation, in the general case, is an extremely difficult problem
    to solve, and this problem has been studied for years, with operating systems
    implementing various approaches over time. In [Chapter 9](2a64ae97-dad4-479a-bd9f-9df2cb634b74.xhtml),
    *A Hands-On Approach to Allocators*, we will discuss how C++ allocators can be
    used to address some external fragmentation issues in your program using various
    different custom allocator patterns.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在一般情况下，外部碎片是一个极其难以解决的问题，这个问题已经研究了多年，操作系统随着时间的推移实施了各种不同的方法。在[第9章](2a64ae97-dad4-479a-bd9f-9df2cb634b74.xhtml)中，《分配器的实践方法》，我们将讨论如何使用C++分配器来解决程序中一些外部碎片问题，使用各种不同的自定义分配器模式。
- en: Internal fragmentation
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部碎片
- en: 'Internal fragmentation refers to memory being wasted during an allocation.
    For example, when we allocate an integer using `mmap()`, as we did in the preceding
    examples, `mmap()` allocates an entire page for the integer, wasting nearly 4k
    of memory in the process. This is known as internal fragmentation:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 内部碎片指的是在分配过程中浪费的内存。例如，当我们使用`mmap()`分配一个整数时，就像我们在前面的例子中所做的那样，`mmap()`为整数分配了整个页面，从而在过程中浪费了将近4k的内存。这就是所谓的内部碎片：
- en: '![](img/5e7d70c8-4671-46ec-8946-83c569822fd1.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5e7d70c8-4671-46ec-8946-83c569822fd1.png)'
- en: Like external fragmentation, the lost memory from internal fragmentation cannot
    be used for other allocations. In fact, the view of memory at a high level would
    look just like that of external fragmentation. The difference is that external
    fragmentation continuously takes large chunks of free, unallocated memory and
    breaks it up into smaller and smaller fragmented memory, which at some point becomes
    too small to be allocated in the future. Internal fragmentation would appear the
    same, but in some cases, even larger, unusable blocks of memory would appear fragmented
    throughout all of the memory. This unusable memory is not unusable because it
    isn't large enough for a given allocation, but instead because the unusable memory
    has been claimed by a smaller, previous allocation that simply doesn't use all
    of the memory that it was given.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 与外部碎片一样，内部碎片的丢失内存也不能用于其他分配。事实上，从高层次上看，内存的视图看起来就像外部碎片一样。不同之处在于，外部碎片不断地将大块的空闲未分配内存分割成越来越小的碎片内存，最终变得太小而无法在将来分配。内部碎片看起来也是一样的，但在某些情况下，甚至更大的不可用内存块会出现在整个内存中。这些不可用的内存不是因为它对于给定的分配来说不够大，而是因为不可用的内存已经被较小的先前分配所占用，而这些分配根本没有使用它所获得的所有内存。
- en: It should be noted that when solving fragmentation issues, often the solution
    is to optimize for one type of fragmentation over another, with each choice having
    its advantages and disadvantages.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，在解决碎片问题时，通常的解决方案是优化一种类型的碎片而不是另一种，每种选择都有其优点和缺点。
- en: Internal over external fragmentation
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部碎片和外部碎片
- en: Allocators used by `malloc()` and `free()` often favor optimizing for internal
    fragmentation over external fragmentation. The goal is to provide an allocator
    with as little waste as possible and then leverage various different allocation
    patterns to reduce the likelihood of external fragmentation as much as possible.
    These types of allocators are preferred for applications as they minimize the
    memory requirements of a single application on any given operating system, leaving
    the additional memory for other applications. Furthermore, if external fragmentation
    prevents an allocation from occurring, the application always asks the OS for
    more memory (until the OS runs dry).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`malloc()`和`free()`使用的分配器通常更倾向于优化内部碎片而不是外部碎片。目标是提供一个尽可能少浪费的分配器，然后利用各种不同的分配模式来尽可能减少外部碎片的可能性。这些类型的分配器被应用程序所青睐，因为它们最小化了在任何给定操作系统上单个应用程序的内存需求，为其他应用程序留下了额外的内存。此外，如果外部碎片化阻止了分配的发生，应用程序总是向操作系统请求更多的内存（直到操作系统用尽）。'
- en: External over internal fragmentation
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部碎片优于内部碎片
- en: Operating systems tend to optimize for external fragmentation over internal
    fragmentation. This reason for this is that operating systems generally can only
    allocate memory at the page granularity, meaning internal fragmentation in a lot
    of cases is unavoidable. Furthermore, if external fragmentation is allowed to
    occur over time, it would result in the operating system eventually crashing if
    given enough time to execute. For this reason, operating systems use allocation
    patterns such as the buddy allocator pattern, which optimize for external fragmentation,
    even at the expense of large amounts of internal fragmentation.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统倾向于优化外部碎片而不是内部碎片。这是因为操作系统通常只能以页面粒度分配内存，这意味着在许多情况下内部碎片是不可避免的。此外，如果允许外部碎片随时间发生，最终会导致操作系统崩溃。因此，操作系统使用分配模式，如伙伴分配器模式，它优化外部碎片，即使以牺牲大量内部碎片为代价。
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned various ways to allocate memory using `new()` and
    `delete()` and `malloc()` and `free()`, including aligned memory and C-style arrays.
    We looked at the difference between global memory (memory in the global space),
    stack memory (or scoped memory), and dynamically-allocated memory (memory that
    is allocated using `new()` and `delete()`). The safety concerns of `new()` and
    `delete()` were also discussed, and we demonstrated how C++ smart pointers, including
    `std::shared_ptr{}` and `std::unique_ptr{}`, may be used to prevent common instability
    issues in programs, and how they provide C++ Core Guidance support. We concluded
    this chapter with a quick review of fragmentation and how it can affect system
    programs.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了使用`new()`、`delete()`、`malloc()`和`free()`来分配内存的各种方法，包括对齐内存和C风格数组。我们研究了全局内存（全局空间中的内存）、堆栈内存（或作用域内存）和动态分配内存（使用`new()`和`delete()`分配的内存）之间的区别。还讨论了`new()`和`delete()`的安全性问题，并演示了C++智能指针，包括`std::shared_ptr{}`和`std::unique_ptr{}`，如何防止程序中常见的不稳定性问题，以及它们如何提供C++核心指导支持。我们通过快速回顾碎片化以及它如何影响系统程序来结束本章。
- en: In the next chapter, we will cover file inputer and output including read and
    writing to a file, and the filesystem APIs that were added by C++17.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将涵盖文件输入和输出，包括读写文件以及C++17添加的文件系统API。
- en: Questions
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between `new()` and `new[]()`?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`new()`和`new[]()`之间有什么区别？'
- en: Can `delete()` be safely used to release memory back to heap that was allocated
    using `new[]()`?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`delete()`可以安全地用于释放使用`new[]()`分配的内存吗？'
- en: What is the difference between global memory and static memory?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 全局内存和静态内存之间有什么区别？
- en: How does one allocate aligned memory using `new()`?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用`new()`分配对齐内存？
- en: Can `std::make_shared()` be used to allocate an array?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::make_shared()`可以用来分配数组吗？'
- en: When should `std::shared_ptr{}` be used instead of `std::unique_ptr{}`?
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下应该使用`std::shared_ptr{}`而不是`std::unique_ptr{}`？
- en: Can `mmap()` be used to allocate read/execute memory?
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mmap()`可以用来分配读/执行内存吗？'
- en: What is the difference between internal and external fragmentation?
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内部碎片和外部碎片之间有什么区别？
- en: Further reading
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)'
- en: '[https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)'
