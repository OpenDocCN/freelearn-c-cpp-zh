- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Promises and Futures
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 承诺和未来
- en: In previous chapters, we learned the foundations of managing and synchronizing
    thread execution using C++. We also mentioned in [*Chapter 3*](B22219_03.xhtml#_idTextAnchor051)
    that to return values from a thread, we could use promises and futures. Now it’s
    time to learn how to do that and much more using these features in C++.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了使用C++管理和同步线程执行的基础知识。我们还在[*第3章*](B22219_03.xhtml#_idTextAnchor051)中提到，要从线程返回值，我们可以使用承诺和未来。现在，是时候学习如何使用这些C++特性来完成这一操作以及更多内容了。
- en: '**Futures** and **promises** are essential blocks for achieving asynchronous
    programming. They define a way to manage the result of a task that will be completed
    in the future, usually in a separate thread.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**Futures**和**promises**是实现异步编程的基本块。它们定义了一种管理未来将完成的任务结果的方式，通常是在一个单独的线程中。'
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: What are promises and futures?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承诺和未来是什么？
- en: What are shared futures and how are they different from regular futures?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享未来是什么？它们与常规未来有何不同？
- en: What are packaged tasks and when do we use them?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包裹任务是什么？我们何时使用它们？
- en: How do we check future statuses and errors?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何检查未来的状态和错误？
- en: What are the benefits and drawbacks of using promises and futures?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用承诺和未来的好处和缺点是什么？
- en: Examples of real-life scenarios and solutions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真实场景和解决方案的示例
- en: So, let’s get started!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧！
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Promises and futures have been available since C++11, but some examples implemented
    in this chapter use features from C++20, such as **std::jthread** , so the code
    shown in this chapter can be compiled by compilers supporting C++20.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺和未来自C++11以来就可用，但本章中的一些示例使用了C++20的特性，例如**std::jthread**，因此本章中显示的代码可以由支持C++20的编译器编译。
- en: Please check the *Technical requirements* section in [*Chapter 3*](B22219_03.xhtml#_idTextAnchor051)
    for guidance on how to install GCC 13 and Clang 8 compilers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[*第3章*](B22219_03.xhtml#_idTextAnchor051)中的*技术要求*部分，了解如何安装GCC 13和Clang 8编译器。
- en: 'You can find all the complete code in the following GitHub repository:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下GitHub仓库中找到所有完整的代码：
- en: '[https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP](https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP](https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP)'
- en: 'The examples for this chapter are located under the **Chapter_06** folder.
    All source code files can be compiled using CMake as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例位于**Chapter_06**文件夹下。所有源代码文件都可以使用以下方式使用CMake编译：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Executable binaries will be generated under the **bin** directory.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行二进制文件将在**bin**目录下生成。
- en: Exploring promises and futures
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索承诺和未来
- en: A **future** is an object that represents some undetermined result that will
    be completed sometime in the future. A **promise** is the provider of that result.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**future**是一个表示未来某个不确定结果的物体，该结果将在未来某个时间完成。**promise**是提供该结果的一方。'
- en: Promises and futures have been part of the C++ standard since version C++11
    and are available by including the **<future>** header file, promises via the
    class **std::promise** and futures via the class **std::future** .
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺和未来自C++11版本起就是C++标准的一部分，可以通过包含**<future>**头文件来使用，承诺通过**std::promise**类，未来通过**std::future**类。
- en: The **std::promise** and **std::future** pair implements a one-shot producer-consumer
    channel with the promise as the producer and the future as the consumer. The consumer
    ( **std::future** ) can block until the result of the producer ( **std::promise**
    ) is available.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**std::promise**和**std::future**对实现了一个单次生产者-消费者通道，其中承诺是生产者，未来是消费者。消费者（**std::future**）可以阻塞，直到生产者（**std::promise**）的结果可用。'
- en: '![Figure 6.1 – Promise-future communication channel](img/B22219_06_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 承诺-未来通信通道](img/B22219_06_01.jpg)'
- en: Figure 6.1 – Promise-future communication channel
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 承诺-未来通信通道
- en: Many modern programming languages provide similar asynchronous approaches, such
    as Python (with the **asyncio** library), Scala (in the **scala.concurrent** library),
    JavaScript (in its core library), Rust (in its **Standard Library** ( **std**
    ) or crates such as **promising_future** ), Swift (in the Combine framework),
    and Kotlin, among others.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代编程语言提供了类似的异步方法，例如Python（使用**asyncio**库）、Scala（在**scala.concurrent**库中）、JavaScript（在其核心库中）、Rust（在其**标准库**（**std**）或如**promising_future**这样的crate中）、Swift（在Combine框架中），以及Kotlin等。
- en: The basic principle behind achieving asynchronous execution using promises and
    futures is that a function we want to run to generate a result is executed in
    the background, using a new thread or the current one, and a future object is
    used by the initial thread to retrieve the result computed by the function. This
    result value will be stored when the function finishes, so meanwhile, the future
    will be used as a placeholder. The asynchronous function will use a promise object
    to store the result in the future with no need for explicit synchronization mechanisms
    between the initial thread and the background one. When the value is needed by
    the initial thread, it will be retrieved from the future object. If the value
    is still not ready, the initial thread execution will be blocked until the future
    becomes ready.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用承诺（promises）和未来（futures）实现异步执行的基本原理是，我们想要运行的函数在后台执行，使用新线程或当前线程，而初始线程使用未来对象来检索函数计算出的结果。这个结果值将在函数完成后存储，因此同时，未来对象将用作占位符。异步函数将使用承诺对象将结果存储在未来的对象中，无需在初始线程和后台线程之间进行显式的同步机制。当初始线程需要该值时，它将从未来对象中检索。如果该值尚未准备好，初始线程的执行将被阻塞，直到未来对象准备好。
- en: With this idea, making a function run asynchronously becomes easy. We only need
    to be aware that the function can run on a separate thread, so we need to avoid
    data races, but result communication and synchronization between threads is managed
    by the promise-future pair.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个想法，使函数异步运行变得容易。我们只需要意识到该函数可以在单独的线程上运行，因此我们需要避免数据竞争，但结果通信和线程间的同步由承诺-未来对管理。
- en: Using promises and futures improves responsiveness by offloading computations
    and provides a structured approach to handling asynchronous operations compared
    to threads and callbacks, as we will explore in this chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用承诺和未来通过卸载计算提高了响应性，并且与线程和回调相比，提供了一种处理异步操作的结构化方法，我们将在本章中探讨。
- en: Let’s now learn about these two objects.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在了解这两个对象。
- en: Promises
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 承诺（Promises）
- en: Promises are defined in the **<future>** header as **std::promise** .
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺在**<future>**头文件中定义为**std::promise**。
- en: With a promise, we get an agreement that the result will be available at some
    time in the future. This way, we can let the background task do its work and compute
    the result. Meanwhile the main thread will also proceed with its task and, when
    the result is needed, request it. At that time, the result might already be ready.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用承诺，我们得到一个协议，即结果将在未来的某个时间点可用。这样，我们可以让后台任务执行其工作并计算结果。同时，主线程也将继续其任务，当需要结果时，请求它。那时，结果可能已经准备好了。
- en: Also, promises can communicate if an exception was raised instead of returning
    a valid value and, they will make sure that its lifetime persists until the thread
    finishes and writes the result to it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果抛出异常而不是返回有效值，承诺可以通信，并且它们将确保其生命周期持续到线程完成并将结果写入它。
- en: Therefore, a promise is a facility to store a result (a value or an exception)
    that is later acquired asynchronously via a future. A promise object is only intended
    to be used once and cannot be modified afterward.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，承诺是一种存储结果（值或异常）的设施，该结果稍后可以通过未来异步获取。承诺对象仅打算使用一次，之后不能修改。
- en: 'Apart from a result, each promise also holds a shared state. The shared state
    is a memory area that stores the completion status, synchronization mechanisms,
    and a pointer to the result. It ensures proper communication and synchronization
    between a promise and a future by enabling the promise to store either a result
    or an exception, signal when it’s complete, and allowing the future to access
    the result, blocking if the promise is not yet ready. The promise can update its
    shared state using the following operations:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了结果外，每个承诺还持有共享状态。共享状态是一个内存区域，用于存储完成状态、同步机制以及指向结果的指针。它通过允许承诺存储结果或异常、在完成时发出信号以及允许未来对象访问结果（如果承诺尚未准备好则阻塞）来确保承诺和未来之间的适当通信和同步。承诺可以使用以下操作更新其共享状态：
- en: '**Make ready** : The promise stores the result in the shared state and makes
    the state of the promise to become ready unblocking any thread waiting on a future
    associated with the promise. Remember that the result can be a value (or even
    void) or an exception.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准备就绪**：承诺将结果存储在共享状态中，并将承诺的状态变为就绪，从而解除任何等待与承诺相关的未来对象的线程的阻塞。记住，结果可以是值（甚至可以是空值）或异常。'
- en: '**Release** : The promise releases its reference to the shared state, which
    will be destroyed if this is the last reference. This memory release mechanism
    is like the one used by shared pointers and their control blocks. This operation
    does not block unless the shared state was created by **std::async** and is not
    yet in the ready status (we will learn about this in the next chapter).'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**释放**：承诺释放其对共享状态的引用，如果这是最后一个引用，则该引用将被销毁。这种内存释放机制类似于共享指针及其控制块所使用的机制。除非共享状态是由**std::async**创建且尚未处于就绪状态（我们将在下一章中学习这一点），否则此操作不会阻塞。'
- en: '**Abandon** : The promise stores an exception of type **std::future_error**
    with error code **std::future_errc::broken_promise** , making the shared state
    ready and then releasing it.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**放弃**：承诺存储了一个类型为**std::future_error**的异常，错误代码为**std::future_errc::broken_promise**，使共享状态准备好然后释放它。'
- en: A **std::promise** object can be constructed using its default constructor or
    using a custom allocator. In both cases, a new promise will be created with an
    empty shared state. Promises can also be constructed using the move constructor;
    thus, the new promise will have the shared state owned by the other promise. The
    initial promise will remain with no shared state.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用其默认构造函数或使用自定义分配器来构造**std::promise**对象。在这两种情况下，都会创建一个新的承诺，其共享状态为空。承诺也可以使用移动构造函数来构造；因此，新的承诺将拥有其他承诺的共享状态。初始承诺将保持没有共享状态。
- en: Moving a promise is useful in scenarios related to resource management, optimization
    by avoiding extra copies, and keeping correct ownership semantics; for example,
    it’s useful when a promise needs to be completed in another thread, stored in
    a container, returned to the caller of an API call, or sent to a callback handler.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 移动承诺在资源管理、通过避免额外复制进行优化以及保持正确的所有权语义的场景中很有用；例如，当承诺需要在另一个线程中完成、存储在容器中、返回到API调用的调用者或发送到回调处理程序时很有用。
- en: Promises cannot be copied (their copy-constructor or copy-assignment operator
    is deleted), avoiding two promise objects sharing the same shared state and in
    risk of data races when results are stored in the shared state.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺不能被复制（它们的复制构造函数或复制赋值运算符被删除），避免了两个承诺对象共享相同的共享状态，并在存储在共享状态中的结果时存在数据竞争的风险。
- en: As promises can be moved, they can also be swapped. The **std::swap** function
    from the **Standard Template Library** ( **STL** ) has a template specialization
    for promises.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于承诺可以被移动，它们也可以被交换。来自**标准模板库**（**STL**）的**std::swap**函数为承诺提供了模板特化。
- en: When a promise object is deleted, the associated future will still have access
    to the shared state. If deletion happens after the promise sets the value, the
    shared state will be in release mode, thus the future can access the result and
    use it. However, if the promise was deleted before setting the result value, the
    shared state will be moved to abandoned, and the future will obtain **std::future_errc::broken_promise**
    when trying to get the result.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当删除承诺对象时，相关的future仍然可以访问共享状态。如果删除发生在承诺设置值之后，共享状态将处于释放模式，因此future可以访问结果并使用它。然而，如果承诺在设置结果值之前被删除，共享状态将移动到放弃状态，并且future在尝试获取结果时将获得**std::future_errc::broken_promise**。
- en: 'A value can be set by using the **std::promise** function **set_value()** and
    an exception by using the **set_exception()** function. The result is stored atomically
    in the promise’s shared state, making its state ready. Let’s see an example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用**std::promise**函数的**set_value()**来设置一个值，通过使用**set_exception()**函数来设置一个异常。结果以原子方式存储在承诺的共享状态中，使其状态准备好。让我们看一个例子：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the previous example, the **prom** promise is created and moved into the
    **threadFunc** lambda function as a parameter. As the promise is non-copyable,
    we need to use pass-by-value together with moving the promise into the parameter
    to avoid copies.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，创建了**prom**承诺并将其移动到**threadFunc** lambda 函数作为参数。由于承诺是不可复制的，我们需要使用按值传递并移动承诺到参数中，以避免复制。
- en: Inside the lambda function, the **func()** function is called, and its result
    is stored in the promise using **set_value()** . If **func()** throws an exception,
    it’s captured and stored into the promise using **set_exception()** . As we will
    learn later, this result (value or exception) can be extracted in the calling
    thread by using a future.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在lambda函数内部，调用**func()**函数，并将结果存储在承诺中使用**set_value()**。如果**func()**抛出异常，它将被捕获并使用**set_exception()**存储到承诺中。正如我们稍后将要学习的，这个结果（值或异常）可以通过使用future在调用线程中提取。
- en: 'In C++14, we can also use generalized lambda capture to pass the promise into
    the lambda capture:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++14 中，我们还可以使用泛化 lambda 捕获将承诺传递到 lambda 捕获中：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Therefore, **prm = std::move(prom)** is moving the external promise, **prom**
    , into the lambda’s internal promise, **prm** . By default, parameters are captured
    as constants, so we need to specify the lambda as mutable to allow **prm** to
    be modified.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，**prm = std::move(prom)** 是将外部承诺 **prom** 移动到 lambda 的内部承诺 **prm** 中。默认情况下，参数被捕获为常量，所以我们需要将
    lambda 声明为可变的，以便允许 **prm** 被修改。
- en: '**set_value()** can throw a **std::future_error** exception if the promise
    has no shared state (error code set to **no_state** ) or the shared state has
    already a stored result (error code set to **promise_already_satisfied** ).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**set_value()** 如果承诺没有共享状态（错误代码设置为 **no_state** ）或者共享状态已经存储了结果（错误代码设置为 **promise_already_satisfied**
    ），则可以抛出 **std::future_error** 异常。'
- en: '**set_value()** can also be used without specifying a value. In that case,
    it simply makes the state ready. That can be used as a barrier, as we will see
    later in this chapter after introducing futures.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**set_value()** 也可以不指定值使用。在这种情况下，它只是使状态准备好。这可以用作屏障，正如我们将在介绍 future 后在本章后面看到的那样。'
- en: '*Figure 6* *.2* shows a diagram representing the different shared state transitions.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6.2* 显示了一个表示不同共享状态转换的图。'
- en: '![Figure 6.2 – Promise shared state transitions diagram](img/B22219_06_02.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – Promise 共享状态转换图](img/B22219_06_02.jpg)'
- en: Figure 6.2 – Promise shared state transitions diagram
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – Promise 共享状态转换图
- en: There are two other functions to set the value of a promise, **set_value_at_thread_exit**
    and **set_exception_at_thread_exit** . As before, the result is stored immediately,
    but using these new functions, the state is not made ready yet. The state becomes
    ready when the thread exits after all thread-local variables have been destroyed.
    This is useful when we want threads to manage resources that need to be cleaned
    up before exiting, even if an exception happens, or if we want to provide accurate
    log activity or monitor when threads exit.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有另外两个函数可以设置承诺的值，**set_value_at_thread_exit** 和 **set_exception_at_thread_exit**
    。与之前一样，结果立即被存储，但使用这些新函数，状态不会立即准备好。状态在所有线程局部变量被销毁后，线程退出时才变为准备好。这在我们需要线程管理在退出前需要清理的资源时很有用，即使发生异常，或者如果我们想在线程退出时提供准确的日志活动或监控。
- en: In terms of exceptions thrown or synchronization mechanisms to avoid data races,
    both functions behave as **set_value()** and **set_exception()** .
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在抛出异常或同步机制以避免数据竞争方面，这两个函数的行为与 **set_value()** 和 **set_exception()** 相同。
- en: Now that we know how to store a result in a promise, let’s learn about the other
    member of the duo, the future.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何在承诺中存储结果，让我们来了解这对中的另一个成员，future。
- en: Futures
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Futures
- en: Futures are defined in the **<future>** header file as **std::future** .
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Future 定义在 **<future>** 头文件中，作为 **std::future**。
- en: As we saw earlier, a future is the consumer side of the communication channel.
    It provides access to the result stored by the promise.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所看到的，future 是通信通道的消费者端。它提供了访问承诺存储的结果的权限。
- en: 'A **std::future** object must be created from a **std::promise** object by
    calling **get_future()** , or through a **std::packaged_task** object (more details
    later in this chapter) or a call to the **std::async** function (in [*Chapter
    7*](B22219_07.xhtml#_idTextAnchor143) ):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 **std::future** 对象必须通过调用 **get_future()** 从 **std::promise** 对象创建，或者通过 **std::packaged_task**
    对象（本章后面将详细介绍）或调用 **std::async** 函数（在 [*第 7 章*](B22219_07.xhtml#_idTextAnchor143)
    ）：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Like promises, futures can be moved but not copied for the same reasons. To
    reference the same shared state from multiple futures, we need to use shared futures
    (explained in the next section, *Shared futures* ).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与承诺一样，future 可以移动但不能复制，原因相同。为了从多个 future 中引用相同的共享状态，我们需要使用共享 future（在下一节 *共享
    future* 中解释）。
- en: 'The **get()** method can be used to retrieve the result. If the shared state
    is still not ready, this call will block by internally calling **wait()** . When
    the shared state becomes ready, the result value is returned. If an exception
    was stored in the shared state, that exception will be rethrown:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**get()** 方法可以用来检索结果。如果共享状态仍然没有准备好，这个调用将通过内部调用 **wait()** 来阻塞。当共享状态准备好时，返回结果值。如果共享状态中存储了异常，那么这个异常将被重新抛出：'
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, the result is retrieved from the **fut** future by
    using the **get()** function. If the result is a value, it will be printed with
    a line starting with **Result from thread** . On the other hand, if an exception
    were thrown and stored into the promise, it would be rethrown and captured in
    the caller thread, and a line starting with **Exception** would be printed out.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，结果是通过使用**get()**函数从**fut**未来检索的。如果结果是值，它将以以**Result from thread**开头的行打印出来。另一方面，如果抛出了异常并将其存储到承诺中，它将被重新抛出并在调用线程中被捕获，并打印出以**Exception**开头的行。
- en: After calling the **get()** method, **valid()** will return **false** . If for
    some reason **get()** is called when **valid()** is **false** , the behavior is
    undefined, but the C++ standard recommends that a **std::future_error** exception
    is thrown with the **std::future_errc::no_state** error code. Futures in which
    the **valid()** function returns **false** can still be moved.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 调用**get()**方法后，**valid()**将返回**false**。如果由于某种原因在**valid()**为**false**时调用**get()**，行为是未定义的，但C++标准建议抛出一个带有**std::future_errc::no_state**错误代码的**std::future_error**异常。当**valid()**函数返回**false**时，未来仍然可以被移动。
- en: When a future is destroyed, it releases its shared state reference. If that
    were the last reference, the shared state would be destroyed. These actions will
    not block unless in a specific case when using **std::async** , which we will
    learn about in [*Chapter 7*](B22219_07.xhtml#_idTextAnchor143) .
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个未来被销毁时，它释放其共享状态引用。如果那是最后一个引用，共享状态将被销毁。除非在特定情况下使用**std::async**，否则这些操作不会阻塞，我们将在[*第7章*](B22219_07.xhtml#_idTextAnchor143)中学习到这一点。
- en: Future errors and error codes
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未来错误和错误代码
- en: As we have seen in the preceding examples, some functions that deal with asynchronous
    execution and shared states can throw **std::future_error** exceptions.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的例子中看到的那样，一些处理异步执行和共享状态的功能可以抛出**std::future_error**异常。
- en: This exception class is inherited from **std::logic_error** , which in turn
    is inherited from **std::exception** , defined in the **<stdexcept>** and **<exception>**
    header files, respectively.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个异常类是从**std::logic_error**继承的，它反过来又是从**std::exception**继承的，分别定义在**<stdexcept>**和**<exception>**头文件中。
- en: As with any other exception defined in the STL, the error code can be checked
    by using its **code()** function or an explanatory string by using its **what()**
    function.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与STL中定义的任何其他异常一样，可以通过其**code()**函数或通过其**what()**函数使用解释性字符串来检查错误代码。
- en: 'Error codes reported by futures are defined by **std::future_errorc** , a scoped
    enumeration ( **enum** class). The C++ standard defines the following error codes,
    but the implementation may define additional ones:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 未来报告的错误代码由**std::future_errorc**定义，这是一个范围枚举（**enum class**）。C++标准定义了以下错误代码，但实现可能定义额外的代码：
- en: '**broken_promise** : Reported when a promise is deleted before setting the
    result, so the shared state is released before being valid.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**broken_promise**：当在设置结果之前删除承诺时报告，因此共享状态在有效之前被释放。'
- en: '**future_already_retrieved** : Occurring when **std::promise::get_future()**
    is called more than once.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**future_already_retrieved**：当**std::promise::get_future()**被多次调用时发生。'
- en: '**promise_already_satisfied** : Reported by **std::promise:: set_value()**
    if the shared state already has a stored result.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**promise_already_satisfied**：当**std::promise::set_value()**报告共享状态已经有一个存储的结果时。'
- en: '**no_state** : Reported when some methods are used but there is no shared state
    as the promise was created by using the default constructor or moved from. As
    we will see later in this chapter, this happens when calling some packaged tasks
    ( **std::packaged_task** ) methods, such as **get_future()** , **make_ready_at_thread_exit()**
    , or **reset()** , when their shared state has not been created, or when using
    **std::future::get()** with a not-yet-ready future ( **std::future::valid()**
    returns **false** ).'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**no_state**：当使用某些方法但没有共享状态（因为是通过使用默认构造函数或移动创建的承诺）时报告。正如我们将在本章后面看到的那样，当调用某些包装任务（**std::packaged_task**）方法，例如**get_future()**、**make_ready_at_thread_exit()**或**reset()**，并且它们的共享状态尚未创建，或者当使用**std::future::get()**与尚未准备好的未来（**std::future::valid()**返回**false**）时，这种情况会发生。'
- en: Waiting for results
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 等待结果
- en: '**std::future** also provides functions to block the thread and wait for a
    result to be available. These functions are **wait()** , **wait_for()** , and
    **wait_until()** . The **wait()** function will block indefinitely until the result
    is ready, **wait_for()** for a period, and **wait_until()** until a specific time
    has been reached. All will return as soon as the result is available within those
    waiting periods.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**std::future** 还提供了阻塞线程并等待结果可用的函数。这些函数是 **wait()**、**wait_for()** 和 **wait_until()**。**wait()**
    函数将在结果准备好之前无限期地阻塞，**wait_for()** 在一段时间后，**wait_until()** 在达到特定时间后。所有这些函数都会在等待期间内结果可用时立即返回。'
- en: These functions must be called only when **valid()** is **true** . Otherwise,
    the behavior is undefined but encouraged by the C++ standard to throw a **std::future_error**
    exception with the **std::future_errc::no_state** error code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数必须在 **valid()** 为 **true** 时调用。否则，行为是未定义的，但根据 C++ 标准建议抛出一个带有 **std::future_errc::no_state**
    错误代码的 **std::future_error** 异常。
- en: As commented previously, using **std::promise::set_value()** without specifying
    a value sets the shared state as ready. This together with **std::future::wait()**
    can be used to implement a barrier and stop a thread from progressing until it
    is signaled. The following example shows this mechanism in action.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用 **std::promise::set_value()** 而不指定值将共享状态设置为就绪。这可以与 **std::future::wait()**
    一起使用来实现一个屏障，并阻止线程在接收到信号之前继续执行。以下示例展示了这一机制的实际应用。
- en: 'Let’s start by adding the required header files:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加所需的头文件：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Inside the **main()** function, the program will start by creating two promises,
    **numbers_promise** and **letters_promise** , and their corresponding futures,
    **numbers_ready** and **letters_ready** :'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **main()** 函数内部，程序将首先创建两个承诺，**numbers_promise** 和 **letters_promise**，以及它们对应的未来，**numbers_ready**
    和 **letters_ready**：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, the **input_data_thread** emulates two I/O thread operations running
    in sequence, one copying numbers into a vector and another inserting letters into
    a set:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，**input_data_thread** 模拟了两个按顺序运行的 I/O 线程操作，一个将数字复制到一个向量中，另一个将字母插入到一个集合中：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: While this is happening, the main thread stops its execution by using **numbers_ready.wait()**
    , waiting for the counterpart promise, **numbers_promise** , to be ready. Once
    all numbers are read, **input_data_thread** will call **numbers_promise.set_value()**
    , waking up the main thread and continuing its execution.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个操作正在进行时，主线程通过使用 **numbers_ready.wait()** 停止其执行，等待对应的承诺 **numbers_promise**
    准备就绪。一旦所有数字都被读取，**input_data_thread** 将调用 **numbers_promise.set_value()**，唤醒主线程并继续其执行。
- en: 'Numbers will then be sorted and printed if letters have not already been read
    by using the **wait_for()** function from the **letters_ready** future and checking
    whether it timed out:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字母尚未通过使用 **letters_ready** 未来的 **wait_for()** 函数读取，并且检查是否超时，那么数字将被排序并打印：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This section of the code shows how the main thread can do some work. Meanwhile,
    **input_data_thread** continues processing incoming data. Then, the main thread
    will wait again by calling **letters_ready.wait()** .
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了主线程可以执行一些工作。同时，**input_data_thread** 继续处理传入的数据。然后，主线程将再次通过调用 **letters_ready.wait()**
    等待。
- en: 'Finally, when all letters are added to the set, the main thread will wake up
    by being signaled again by using **letters_promise.set_value()** , and numbers
    (if not yet printed) and letters will be printed in order:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当所有字母都添加到集合中时，主线程将通过再次使用 **letters_promise.set_value()** 被信号唤醒，并且数字（如果尚未打印）和字母将按顺序打印：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we have seen in the previous example, a future status object is returned
    by the wait functions. Next, let’s learn what these objects are.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的例子中看到的，等待函数会返回一个未来状态对象。接下来，让我们学习这些对象是什么。
- en: Future status
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未来状态
- en: '**wait_for()** and **wait_until()** return a **std::future_status** object.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**wait_for()** 和 **wait_until()** 返回一个 **std::future_status** 对象。'
- en: 'A future can be in any of the following statuses:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 未来可以处于以下任何一种状态：
- en: '**Ready** : The shared state is **ready** , indicating that the result can
    be retrieved.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ready**：共享状态是 **Ready**，表示结果可以被检索。'
- en: '**Deferred** : The shared state contains a **deferred** function, meaning that
    the result will only be computed when explicitly requested. We will learn more
    about deferred functions in the next chapter when introducing **std::async** .'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Deferred**：共享状态包含一个 **deferred** 函数，这意味着结果只有在明确请求时才会被计算。我们将在介绍 **std::async**
    时学习更多关于延迟函数的内容。'
- en: '**Timeout** : The specified **timeout period** passed before the shared state
    could become ready.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超时**：在共享状态准备好之前，指定的 **超时周期** 已经过去。'
- en: Next, we will learn how to share a promise result among multiple futures by
    using shared futures.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何通过使用共享未来在多个未来之间共享承诺结果。
- en: Shared futures
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享未来
- en: As we saw earlier, **std::future** is only moveable, thus only one future object
    can refer to a particular asynchronous result. On the other hand, **std::shared_future**
    is copyable, so several shared future objects can refer to the same shared state.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前看到的，**std::future** 只能移动，因此只有一个未来对象可以引用特定的异步结果。另一方面，**std::shared_future**
    是可复制的，因此多个共享未来对象可以引用相同的共享状态。
- en: Therefore, **std::shared_future** allows thread-safe access from different threads
    to the same shared state. Shared futures can be useful for sharing the result
    of a computationally intensive task among multiple consumers or interested parties,
    reducing redundant computation. Also, they can be used to notify events or as
    a synchronization mechanism where multiple threads must wait for the completion
    of a single task. Later in this chapter, we will learn how to chain asynchronous
    operations by using shared futures.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，**std::shared_future** 允许从不同的线程安全访问相同的共享状态。共享未来对于在多个消费者或感兴趣方之间共享计算密集型任务的结果非常有用，可以减少冗余计算。此外，它们可以用作通知事件或作为同步机制，其中多个线程必须等待单个任务的完成。在本章的后面部分，我们将学习如何使用共享未来链式异步操作。
- en: The interface of **std:;shared_object** is the same as the one for **std::future**
    , so everything explained about waiting and getter functions applies here.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**std::shared_object** 的接口与 **std::future** 的接口相同，因此关于等待和获取函数的所有解释都适用于此处。'
- en: 'A shared object can be created by using the **std::future::share()** function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用 **std::future::share()** 函数创建共享对象：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That invalidates the original future (its **valid()** function will return **false**
    ).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使原始未来失效（其 **valid()** 函数将返回 **false**）。
- en: 'The following example shows how to send the same result to many threads at
    the same time:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了如何同时将相同的结果发送到多个线程：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We start by creating a promise, **prom** , getting the future, **fut** , from
    it, and finally, getting a shared future, **shared_fut** , by calling **share()**
    .
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个承诺 **prom**，从它获取未来 **fut**，最后通过调用 **share()** 获取共享未来 **shared_fut**。
- en: 'Then, five threads are created and added to a vector, each one having a shared
    future instance and an index. All these threads will be waiting for the promise,
    **prom** , to be ready by calling **shared_future.get()** . When a value is set
    in the promise shared state, the value will be accessible by all the threads.
    The output of running the previous program is the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建了五个线程并将它们添加到一个向量中，每个线程都有一个共享未来实例和一个索引。所有这些线程都将通过调用 **shared_future.get()**
    等待承诺 **prom** 准备就绪。当在共享状态中设置值时，该值将可以通过所有线程访问。运行前一个程序的输出如下：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Therefore, shared futures can also be used to signal multiple threads at the
    same time.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，共享未来也可以用来同时向多个线程发出信号。
- en: Packaged tasks
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打包的任务
- en: 'A **packaged task** , or **std::packaged_task** , also defined in the **<future>**
    header file, is a class template that wraps a callable object to be invoked asynchronously.
    Its result is stored in a shared state, which is accessible through a **std::future**
    object. To create a **std::packaged_task** object, we need to define as the template
    parameter the function signature that represents the task that will be called
    and pass the desired function as its constructor argument. Here are some examples:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**打包的任务**，或 **std::packaged_task**，也在 **<future>** 头文件中定义，是一个模板类，它封装了一个将被异步调用的可调用对象。其结果存储在共享状态中，可以通过
    **std::future** 对象访问。要创建 **std::packaged_task** 对象，我们需要定义模板参数，该参数表示将要调用的任务的功能签名，并将所需的函数作为其构造函数参数传递。以下是一些示例：'
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding example, **task1** is created by using a function and executed
    by using a thread. On the other hand, **task2** is created by using a lambda function
    and executed by invoking its method **operator()** . Finally, **task3** is created
    by using a forwarding call wrapper by using **std::bind** .
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，**task1** 是通过使用函数创建并通过使用线程执行。另一方面，**task2** 是通过使用lambda函数创建并通过调用其方法
    **operator()** 执行。最后，**task3** 是通过使用 **std::bind** 的转发调用包装器创建。
- en: 'To retrieve the future associated with a task, just call **get_future()** from
    its **packaged_task** object:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索与任务关联的未来，只需从其 **packaged_task** 对象中调用 **get_future()**：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As with promises and futures, packaged tasks can be constructed with no shared
    state by using the default constructor, the move constructor, or allocators. Packaged
    tasks are thus move-only and non-copyable. Also, assignment operators and the
    swap function have similar behaviors as promises and futures.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与承诺和未来一样，可以通过使用默认构造函数、移动构造函数或分配器来使用没有共享状态的包装任务。因此，包装任务是移动-only 和不可复制的。此外，赋值运算符和交换函数的行为与承诺和未来类似。
- en: The destructor of packaged tasks behaves like the promise destructors; if the
    shared state is released before being valid, a **std::future_error** exception
    will be thrown with the **std::future_errc::broken_promise** error code. As with
    futures, packaged tasks define a **valid()** that function returns **true** if
    a **std::packaged_task** object has a shared state.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 包装任务的析构函数的行为类似于承诺的析构函数；如果在有效之前释放了共享状态，将抛出一个带有 **std::future_errc::broken_promise**
    错误代码的 **std::future_error** 异常。与未来一样，包装任务定义了一个 **valid()** 函数，如果 **std::packaged_task**
    对象有一个共享状态，该函数返回 **true**。
- en: As with promises, **get_future()** can only be called once. If this function
    is called more than once, a **std::future_error** exception with the **future_already_retrieved**
    code will be thrown. If the packaged tasks were created from the default constructor,
    thus with no shared state, the error code will be **no_state** .
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 与承诺一样，**get_future()** 只能调用一次。如果这个函数被多次调用，将会抛出一个带有 **future_already_retrieved**
    代码的 **std::future_error** 异常。如果包装的任务是从默认构造函数创建的，因此没有共享状态，错误代码将是 **no_state** 。
- en: 'As seen in the previous example, the stored callable object can be invoked
    by using **operator()** :'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个示例所示，存储的可调用对象可以通过使用 **operator()** 来调用：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Sometimes, it’s interesting to make the result ready only when the thread that
    runs the packaged task exits and all its **thread-local** objects are destroyed.
    This is achieved by using the **make_ready_at_thread_exit()** function. Even if
    the result is not ready until the thread exits, it is computed right away as usual.
    Therefore, its computation is not deferred.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，只有在运行包装任务的线程退出并且所有其 **thread-local** 对象都被销毁时才使结果就绪是很有趣的。这是通过使用 **make_ready_at_thread_exit()**
    函数实现的。即使结果直到线程退出才就绪，它也会立即计算，因此其计算不会被延迟。
- en: 'As an example, let’s define the following function:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们定义以下函数：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This function creates a packaged task called **task** that sets its Boolean
    argument to **true** . A future called **result** is also created from this task.
    When the task is executed by calling **make_ready_at_thread_exit()** , its **done**
    argument is set to **true** but the future result is still not marked as ready.
    When the **task_func** function exits, the **result** future is moved to the passed-by
    reference. At this point, the thread exits, and the **result** future will be
    set as ready.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数创建了一个名为 **task** 的包装任务，将其布尔参数设置为 **true**。从这个任务中也创建了一个名为 **result** 的未来对象。当通过调用
    **make_ready_at_thread_exit()** 执行任务时，其 **done** 参数被设置为 **true**，但未来结果仍然没有被标记为就绪。当
    **task_func** 函数退出时，**result** 未来对象被移动到通过引用传递的位置。此时，线程退出，**result** 未来对象将被设置为就绪。
- en: 'Therefore, say we call this task from the main thread by using the following
    code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们使用以下代码从主线程调用此任务：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The program will show the following output:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将显示以下输出：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**make_ready_at_thread_exit()** will throw **std::future_error** exceptions
    if there is no shared state (the **no_state** error code) or the task has already
    been invoked (the **promise_already_satisfied** error code).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**make_ready_at_thread_exit()** 如果没有共享状态（**no_state** 错误代码）或任务已经被调用（**promise_already_satisfied**
    错误代码），将抛出 **std::future_error** 异常。'
- en: A packaged task state can also be reset by calling **reset()** . This function
    will abandon the current state and construct a new shared state. Obviously, if
    there is no state when calling **reset()** , an exception with the **no_state**
    error code will be thrown. After resetting, a new future must be acquired by calling
    **get_future()** .
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 包装任务的状态也可以通过调用 **reset()** 来重置。这个函数将放弃当前状态并构建一个新的共享状态。显然，如果在调用 **reset()** 时没有状态，将抛出一个带有
    **no_state** 错误代码的异常。重置后，必须通过调用 **get_future()** 来获取一个新的未来对象。
- en: 'The following example prints the first 10 power-of-two numbers. Each number
    is computed by calling the same **packaged_task** object. In each loop iteration,
    **packaged_task** is reset, and a new future object is retrieved:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例打印了前 10 个 2 的幂次方数。每个数字都是通过调用相同的 **packaged_task** 对象来计算的。在每次循环迭代中，**packaged_task**
    被重置，并检索一个新的未来对象：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is the output when executing the preceding code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前述代码的输出如下：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we will learn in the next chapter, **std::async** provides a simpler way
    to achieve the same result. The only advantage of **std::packaged_task** is the
    ability to specify in exactly which thread the task will run.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在下一章中学习的，**std::async**提供了一种更简单的方法来实现相同的结果。**std::packaged_task**的唯一优点是能够指定任务将在哪个线程上运行。
- en: Now that we know how to use promises, futures, and packaged tasks, it’s time
    to understand not only the upsides of this approach but also what downsides can
    arise.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何使用承诺、未来和打包任务，是时候了解这种方法的优点以及可能出现的缺点了。
- en: The benefits and drawbacks of promises and futures
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 承诺和未来的利弊
- en: There are advantages as well as some disadvantages of using promises and futures.
    Here are the main points.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用承诺和未来的优点以及一些缺点。以下是主要观点。
- en: Benefits
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优点
- en: As high-level abstractions for managing asynchronous operations, writing and
    reasoning about concurrent code by using promises and futures is simplified and
    less error-prone.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 作为管理异步操作的高级抽象，通过使用承诺（promises）和未来（futures）来编写和推理并发代码被简化了，并且错误更少。
- en: Futures and promises enable concurrent execution of tasks, allowing the program
    to use multiple CPU cores efficiently. This can lead to improved performance and
    reduced execution time for computationally intensive tasks.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 未来和承诺允许任务并发执行，使程序能够有效地使用多个CPU核心。这可以提高计算密集型任务的性能并减少执行时间。
- en: Also, they facilitate asynchronous programming by decoupling the initiation
    of an operation from its completion. As we will see later, this is particularly
    useful for I/O-bound tasks, such as network requests or file operations, where
    the program can continue executing other tasks while waiting for the asynchronous
    operation to complete. As a result, they can return a value but also an exception,
    allowing exception propagation from the asynchronous tasks to the caller code
    section that waits for their completion, which allows for a cleaner way for error
    handling and recovery.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它们通过将操作的启动与其完成解耦，简化了异步编程。正如我们稍后将会看到的，这对于I/O密集型任务特别有用，例如网络请求或文件操作，在这些任务中，程序可以在等待异步操作完成的同时继续执行其他任务。因此，它们不仅可以返回一个值，还可以返回一个异常，允许异常从异步任务传播到等待其完成的调用代码部分，这允许更干净的错误处理和恢复方式。
- en: As we have also mentioned, they also provide a mechanism for synchronizing the
    completion of tasks and retrieving their results. This helps in coordinating parallel
    tasks and managing dependencies between them.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，它们还提供了一种同步任务完成和检索其结果的方法。这有助于协调并行任务并管理它们之间的依赖关系。
- en: Drawbacks
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺点
- en: Unfortunately, not everything is positive news; there are also some areas that
    are impacted.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，并非所有消息都是积极的；也有一些领域受到了影响。
- en: For example, asynchronous programming with futures and promises can introduce
    complexity when dealing with dependencies between tasks or managing the life cycle
    of asynchronous operations. Also, potential deadlocks can happen if there are
    circular dependencies.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用未来和承诺进行异步编程在处理任务之间的依赖关系或管理异步操作的生命周期时可能会引入复杂性。如果存在循环依赖关系，还可能发生潜在的死锁。
- en: Likewise, using futures and promises may introduce some performance overhead
    due to the synchronization mechanisms happening under the hood, involved in coordinating
    asynchronous tasks and managing shared states.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，由于底层的同步机制，使用未来和承诺可能会引入一些性能开销，这些机制涉及协调异步任务和管理共享状态。
- en: As with other concurrent or asynchronous solutions, debugging code that uses
    futures and promises can be more challenging compared to synchronous code, as
    the flow of execution may be non-linear and involve multiple threads.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他并发或异步解决方案一样，与同步代码相比，使用未来和承诺的代码调试可能更具挑战性，因为执行流程可能是非线性的，并涉及多个线程。
- en: Now it’s time to tackle real-life scenarios by implementing some examples.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候通过实现一些示例来解决真实场景了。
- en: Examples of real-life scenarios and solutions
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 真实场景和解决方案的示例
- en: 'Now that we’ve learned about some new building blocks of creating asynchronous
    programs, let’s build solutions for some real-life scenarios. In this section,
    we will learn how to do the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了创建异步程序的一些新构建块，让我们为一些真实场景构建解决方案。在本节中，我们将学习如何执行以下操作：
- en: Cancel asynchronous operation
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消异步操作
- en: Return combined results
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回组合结果
- en: Chain asynchronous operations and create a pipeline
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接异步操作并创建管道
- en: Create a thread-safe **single-producer-single-consumer** ( **SPSC** ) task queue
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个线程安全的 **单生产者单消费者**（**SPSC**）任务队列
- en: Canceling asynchronous operations
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取消异步操作
- en: As we saw earlier, futures offer the ability to check for completion or timeout
    before waiting for the result. That can be done by checking the **std::future_status**
    object returned by the **std::future** , **wait_for()** , or **wait_until()**
    function.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，未来（futures）提供了在等待结果之前检查完成或超时的能力。这可以通过检查 **std::future**、**wait_for()**
    或 **wait_until()** 函数返回的 **std::future_status** 对象来实现。
- en: By combining futures with mechanisms such as cancellation flags (by means of
    **std::atomic_bool** ) or timeouts, we can gracefully terminate long-running tasks
    if necessary. Timeout cancellation can be implemented by simply using the **wait_for()**
    and **wait_until()** functions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合使用未来（futures）和机制，如取消标志（通过 **std::atomic_bool** 实现）或超时，我们可以在必要时优雅地终止长时间运行的任务。超时取消可以通过简单地使用
    **wait_for()** 和 **wait_until()** 函数来实现。
- en: Canceling a task by using a cancellation flag or token can be implemented by
    passing a reference to a cancellation flag defined as **std::atomic_bool** , where
    the caller thread sets its value to **true** to request the task cancellation,
    and the worker thread periodically checks this flag and whether it’s set. If it
    is set, it exits gracefully and performs any cleanup work to be done.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传递定义为 **std::atomic_bool** 的取消标志或令牌的引用，可以使用取消标志或令牌来取消任务。调用线程将此值设置为 **true**
    以请求任务取消，而工作线程将定期检查此标志是否已设置。如果已设置，它将优雅地退出并执行任何需要完成的清理工作。
- en: 'Let’s first define a long-running task function:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义一个长时间运行的任务函数：
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The **long_running_task** function accepts as arguments a period in milliseconds
    ( **ms** ) to run the task and a reference to an atomic Boolean value ( **cancellation_token**
    ) representing the cancellation token. The function will periodically check whether
    the cancellation token is set to **true** . When the running period passes or
    the cancellation token is set to **true** , the thread will exit.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**long_running_task** 函数接受两个参数：一个表示运行任务的毫秒数（**ms**）和一个表示取消令牌的原子布尔值引用（**cancellation_token**）。该函数将定期检查取消令牌是否设置为
    **true**。当运行周期结束或取消令牌设置为 **true** 时，线程将退出。'
- en: 'In the main thread, we can use two **packaged task objects** to execute this
    function, that is, **task1** lasting for 500 ms and running in thread **t1** ,
    and **task2** running for one second in thread **t2** . Both share the same cancellation
    token:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在主线程中，我们可以使用两个 **包装任务对象**来执行此函数，即 **task1** 持续时间为 500 毫秒，在线程 **t1** 中运行，而 **task2**
    在线程 **t2** 中运行一秒钟。它们共享相同的取消令牌：
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: After both tasks have started, the main thread sleeps for 600 ms. When it wakes
    up, it sets the cancellation token to **true** . At that time, **task1** was already
    finished, but **task2** was still running. Thus, **task2** is being cancelled.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个任务启动后，主线程休眠 600 毫秒。当它醒来时，它将取消令牌设置为 **true**。那时，**task1** 已经完成，但 **task2**
    仍在运行。因此，**task2** 被取消。
- en: 'This explanation aligns with the obtained output:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解释与获得的输出一致：
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Next, let’s see how to combine several asynchronous computation results into
    a single future.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何将几个异步计算结果组合成一个单独的未来（future）。
- en: Returning combined results
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回组合结果
- en: Another common approach in asynchronous programming is to decompose complex
    tasks into smaller independent subtasks using multiple promises and futures. Each
    subtask can be launched in a separate thread and its result stored in a corresponding
    promise. The main thread can then use the futures to wait for all subtasks to
    finish and combine their results to obtain the outcome.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程中的另一种常见方法是使用多个承诺（promises）和未来（futures）将复杂任务分解为更小的独立子任务。每个子任务可以在单独的线程中启动，其结果存储在相应的承诺中。然后，主线程可以使用未来（futures）等待所有子任务完成，并将它们的结果组合起来以获得结果。
- en: This approach is useful to achieve parallel processing of multiple independent
    tasks, allowing the efficient utilization of multiple cores for faster computations.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法对于实现多个独立任务的并行处理非常有用，允许高效地利用多个核心以实现更快的计算。
- en: Let’s see an example of a task that emulates a value computation and an I/O
    operation. We want that task to return a tuple with both results, the computed
    value as an **int** value, and the information read from the file as a **string**
    object. So, we define the **combineFunc** function that accepts as an argument
    a **combineProm** promise holding a tuple with the result types.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个模拟值计算和 I/O 操作的任务示例。我们希望这个任务返回一个包含两个结果的元组，即作为 **int** 值的计算值，以及从文件中读取的信息作为
    **string** 对象。因此，我们定义了 **combineFunc** 函数，它接受一个 **combineProm** 承诺作为参数，该承诺包含一个包含结果类型的元组。
- en: 'This function will create two threads, **computeThread** and **fetchData**
    , with their respective promises, **computeProm** and **fetchProm** , and futures,
    **computeFut** and **fetchFut** :'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将创建两个线程，**computeThread** 和 **fetchData**，以及它们各自的承诺 **computeProm** 和 **fetchProm**，以及未来
    **computeFut** 和 **fetchFut**：
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As we can see, both threads will execute asynchronously and independently, generating
    a result and storing it in their respective promises.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，两个线程将异步且独立地执行，生成一个结果并将其存储在它们各自的承诺中。
- en: 'The combined promise is set by calling the **get()** function on each future
    and combining their result into a tuple that is used to set the value of the combined
    promise by calling its **set_value()** function, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在各个未来上调用 **get()** 函数并将它们的结果组合成一个元组，然后通过调用其 **set_value()** 函数来设置组合承诺的值，从而设置组合承诺：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The **combineFunc** task can be called as usual by using a thread and setting
    up the **combineProm** promise and its **combineFut** future. Calling the **get()**
    function on this future will return a tuple:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**combineFunc** 任务可以通过使用线程并设置 **combineProm** 承诺及其 **combineFut** 未来来像往常一样调用。在这个未来上调用
    **get()** 函数将返回一个元组：'
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Running this example will show the following result:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此示例将显示以下结果：
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, let’s continue by learning how to create a pipeline using promises and
    futures.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续学习如何使用承诺和未来创建管道。
- en: Chaining asynchronous operations
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接异步操作
- en: Promises and futures can be chained together to perform multiple asynchronous
    operations sequentially. We can create a pipeline where one future’s result becomes
    the input for the next operation’s promise. This allows for composing complex
    asynchronous workflows where the output of one task feeds into the next.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺和未来可以连接在一起以顺序执行多个异步操作。我们可以创建一个管道，其中一个未来的结果成为下一个操作承诺的输入。这允许我们组合复杂的异步工作流程，其中一个任务的输出馈入下一个任务。
- en: Also, we can allow branching in the pipeline and keep some tasks switched off
    until needed. This can be done by using futures with deferred execution, which
    is useful in scenarios where the computation cost is high, but the result may
    not always be needed. Thus, we can use futures to initiate the computation asynchronously
    and retrieve the result only when required. As futures with deferred status can
    only be created by using **std::async** , we will leave that for the next chapter.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以在管道中允许分支，并在需要之前保持一些任务处于关闭状态。这可以通过使用延迟执行的未来来实现，这在计算成本高但结果不一定总是需要的情况下很有用。因此，我们可以使用未来异步启动计算，并在需要时才检索结果。由于只有使用
    **std::async** 才能创建具有延迟状态的未来，我们将将其留到下一章。
- en: 'In this section, we will focus on creating the following task graph:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将专注于创建以下任务图：
- en: '![Figure 6.3 – A pipeline example](img/B22219_06_03.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – 管道示例](img/B22219_06_03.jpg)'
- en: Figure 6.3 – A pipeline example
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 管道示例
- en: 'We start by defining a template class called **Task** that accepts a callable
    as a template argument, defining the function to execute. This class will also
    allow us to create tasks that share a future with dependent ones. These will use
    the shared futures to wait for the predecessor tasks to signal them about their
    completion by calling **set_value()** in the associated promise before running
    their own task:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个名为 **Task** 的模板类，它接受一个可调用对象作为模板参数，用于定义要执行的功能。这个类还将允许我们创建与依赖任务共享未来的任务。这些任务将使用共享的未来来等待前驱任务通过在关联的承诺中调用
    **set_value()** 来通知它们完成，然后再运行它们自己的任务：
- en: '[PRE28]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Let’s describe step by step how this **Task** class is implemented.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地描述这个 **Task** 类是如何实现的。
- en: 'There are two constructors: one to initialize an object of type **Task** that
    has no dependencies with other tasks and another templated constructor to initialize
    a task with a variable number of dependent tasks. Both initialize an identifier
    ( **id_** ), the function to call to perform the task ( **func_** ), a Boolean
    variable indicating whether the task has dependencies or not ( **has_dependency_**
    ), and a shared future, **fut_** , to share with tasks that will depend on this
    one. This **fut_** future is retrieved from the **prom_** promise used to signal
    the task completion. The templated constructor also calls the **add_dependencies**
    function forwarding the futures passed as arguments, which will be stored in the
    **deps_** vector.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个构造函数：一个用于初始化一个没有与其他任务依赖关系的**Task**类型对象，另一个是模板化的构造函数，用于初始化一个具有可变数量依赖任务的任务。两者都初始化了一个标识符（**id_**），调用以执行任务的函数（**func_**），一个表示任务是否有依赖的布尔变量（**has_dependency_**），以及一个与将依赖于此任务的共享未来，**fut_**，共享的共享未来。这个**fut_**未来是从用于表示任务完成的**prom_**承诺中检索的。模板化构造函数还会调用**add_dependencies**函数，将作为参数传递的未来转发，这些未来将被存储在**deps_**向量中。
- en: The **get_dependency()** function just returns the shared future used by dependent
    tasks to wait for the completion of the current task.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**get_dependency()**函数仅返回依赖任务使用的共享未来，以等待当前任务的完成。'
- en: Finally, **operator()** waits for the completion of previous tasks by calling
    **wait_completion()** , which checks whether each shared future stored in the
    **deps_** vector is valid and waiting until the result is ready by calling **get()**
    . Once all shared futures are ready, meaning that all previous tasks are complete,
    the **func_** function is invoked, running the task, and the **prom_** promise
    is then set to ready by calling **set_value()** , triggering the dependent tasks.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，**operator()**通过调用**wait_completion()**等待先前任务的完成，该函数检查存储在**deps_**向量中的每个共享未来是否有效并等待通过调用**get()**结果就绪，一旦所有共享未来都就绪，意味着所有先前任务都已完成，**func_**函数被调用，运行任务，然后通过调用**set_value()**将**prom_**承诺设置为就绪，从而触发依赖任务。
- en: 'In the main thread, we define the pipeline as follows, creating a graph like
    the one shown in *Figure 6* *.3* :'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在主线程中，我们定义管道如下，创建一个类似于*图6* *.3* 中所示的图：
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we need to start the pipeline by triggering all tasks and calling their
    **operator()** . As **task1** has no dependencies, it will start running straight
    away. All other tasks will be waiting for their predecessor tasks to complete
    their work:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要通过触发所有任务并调用它们的**operator()**来启动管道。由于**task1**没有依赖，它将立即开始运行。所有其他任务都将等待其前驱任务完成工作：
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, we need to wait for the pipeline to finish the execution of all tasks.
    We can achieve that by simply waiting for the shared future returned by the last
    task, **task5** , to be ready:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要等待管道完成所有任务的执行。我们可以通过简单地等待最后一个任务，**task5**，返回的共享未来就绪来实现这一点：
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here is the output of running this example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是运行此示例的输出：
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There are some issues that can occur with this approach that we must be aware
    of. First, the dependency graph must be a **directed acyclic graph** ( **DAG**
    ), therefore without cycles or loops between dependent tasks. Otherwise, a deadlock
    will occur, as a task might be waiting for a task happening in the future and
    not yet started. Also, we need enough threads to run all the tasks concurrently
    or launch the tasks orderly; otherwise, it can also lead to a deadlock with threads
    waiting on the completion of tasks that have still not launched.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法可能会出现一些问题，我们必须注意。首先，依赖图必须是一个**有向无环图**（**DAG**），因此没有依赖任务之间的循环或循环。否则，可能会发生死锁，因为一个任务可能会等待一个未来发生但尚未启动的任务。此外，我们需要足够的线程来并发运行所有任务或有序启动任务；否则，也可能导致线程等待尚未启动的任务的完成，从而导致死锁。
- en: One common use case of this approach can be found in **MapReduce** algorithms
    where large datasets are processed in parallel across multiple nodes, and futures
    and threads can be used to execute map and reduce tasks concurrently, allowing
    efficient distributed data processing.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个常见用例可以在**MapReduce**算法中找到，其中大型数据集在多个节点上并行处理，可以使用未来和线程来并发执行映射和归约任务，从而实现高效的分布式数据处理。
- en: Thread-safe SPSC task queue
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全的SPSC任务队列
- en: In this last example, we will show how to use promises and futures to create
    an SPSC queue.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后一个例子中，我们将展示如何使用承诺和未来创建一个SPSC队列。
- en: The producer thread creates a promise for each item it wants to add to the queue.
    The consumer thread waits for a future obtained from an empty queue slot. Once
    the producer finishes adding an item, it sets the value on the corresponding promise,
    notifying the waiting consumer. This allows for efficient data exchange between
    threads while maintaining thread safety.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 生产者线程为要添加到队列中的每个项目创建一个承诺。消费者线程等待从空队列槽中获取的未来对象。一旦生产者完成添加项目，它就在相应的承诺上设置值，通知等待的消费者。这允许在保持线程安全的同时在线程之间进行高效的数据交换。
- en: 'Let’s first define the thread-safe queue class:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义线程安全的队列类：
- en: '[PRE33]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this example, we simply use a mutex to have mutual exclusion over all the
    queue data structures when pushing or popping elements. We want to keep this example
    simple and focus on the promise and future interactions. A better approach could
    be to use a vector or circular array and control the access to individual elements
    within the queue with mutexes.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们简单地使用互斥锁来在推送或弹出元素时对所有队列数据结构进行互斥访问。我们希望保持这个例子简单，并专注于承诺和未来对象的交互。更好的方法可能是使用向量或循环数组，并使用互斥锁控制队列中各个元素的访问。
- en: The queue also uses a condition variable, **cond_var_** , to wait if the queue
    is empty when trying to pop an element and to notify one waiting thread when an
    element is pushed. Elements are moved in and out of the queue by moving them.
    This is needed as the queue will store futures, and as we learned earlier, futures
    are movable but non-copiable.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 队列还使用一个条件变量，**cond_var_**，在尝试弹出元素时如果队列为空则等待，并在元素被推入时通知一个等待的线程。元素通过移动来在队列中进出。这是必需的，因为队列将存储未来对象，正如我们之前所学的，未来对象是可移动的但不可复制的。
- en: 'The thread-safe queue will be used to define a task queue that will store futures,
    as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用线程安全的队列来定义一个任务队列，该队列将存储未来对象，如下所示：
- en: '[PRE34]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, we define a function, **producer** , that accepts a reference to the
    queue, and a value, **val** , that will be produced. This function just creates
    a promise, retrieves a future from the promise, and pushes that future into the
    queue. Then, we simulate a task running and producing the value, **val** , by
    making the thread wait for a random number of milliseconds. Finally, the value
    is stored in the promise:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义一个函数，**producer**，它接受队列的引用和一个将要生产的值，**val**。这个函数只是创建一个承诺，从承诺中检索一个未来对象，并将该未来对象推入队列。然后，我们通过使线程等待一个随机的毫秒数来模拟一个正在运行的任务并产生值，**val**。最后，该值存储在承诺中：
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'At the other end of the communication channel, the **consumer** function accepts
    a reference to the same queue. Again, we simulate a task running on the consumer
    side by waiting for a random number of milliseconds. Then, a future is popped
    out of the queue and its result is retrieved, being the value, **val** , or an
    exception if something went wrong:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在通信通道的另一端，**消费者**函数接受对同一队列的引用。同样，我们通过等待一个随机的毫秒数来模拟消费者端正在运行的任务。然后，从队列中弹出一个未来对象并检索其结果，该结果为值，**val**，或者如果发生错误则为异常：
- en: '[PRE36]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'For this example, we will use these constants:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将使用以下常量：
- en: '[PRE37]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the main thread, two threads are started; the first runs the producer function
    **producerFunc** , which pushes some futures into the queue, while the second
    thread runs the consumer function **consumerFunc** , which consumes elements from
    the queue:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在主线程中，启动了两个线程；第一个运行生产者函数**producerFunc**，它将一些未来对象推入队列，而第二个线程运行消费者函数**consumerFunc**，它从队列中消费元素：
- en: '[PRE38]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here is sample output of executing this code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是执行此代码的示例输出：
- en: '[PRE39]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: With a producer-consumer queue like this one, the consumer and producer are
    decoupled, and their threads communicate asynchronously, allowing both the producer
    and consumer to do extra work while the other side generates or processes the
    values.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的生产者-消费者队列，消费者和生产者是解耦的，它们的线程以异步方式通信，允许生产者和消费者在另一边生成或处理值时执行额外的工作。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about promises and futures, how to use them to execute
    asynchronous code in separate threads, and also how to run callables using packaged
    tasks. These objects and mechanisms constitute and implement the key concepts
    of asynchronous programming used by many programming languages, including C++.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了关于承诺和未来的知识，如何使用它们在单独的线程中执行异步代码，以及如何使用包装任务运行可调用对象。这些对象和机制构成了许多编程语言（包括C++）使用的异步编程的关键概念。
- en: We also now understand why promises, futures, and packaged tasks cannot be copied,
    and thus how to share futures by using shared future objects.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在也理解了为什么承诺、未来和包装任务不能被复制，以及如何通过使用共享未来对象来共享未来。
- en: Finally, we have shown how to use futures, promises, and packaged tasks to tackle
    real-life problems.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们展示了如何使用未来、承诺和包装任务来解决现实生活中的问题。
- en: If you want to explore promises and futures deeper, it is worth mentioning some
    third-party open source libraries, especially **Boost.Thread** and **Facebook
    Folly** . These libraries include additional functionality, including callbacks,
    executors, and combinators.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更深入地探索承诺和未来，值得提一下一些第三方开源库，特别是**Boost.Thread**和**Facebook Folly**。这些库包括额外的功能，包括回调、执行器和组合器。
- en: In the next chapter, we will learn a simpler way to asynchronously invoke callables
    by using **std::async** .
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习一种更简单的方法，通过使用**std::async**来异步调用可调用对象。
- en: Further reading
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Boost futures and promises: [https://theboostcpplibraries.com/boost.thread-futures-and-promises](https://theboostcpplibraries.com/boost.thread-futures-and-promises)'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost的未来和承诺：[https://theboostcpplibraries.com/boost.thread-futures-and-promises](https://theboostcpplibraries.com/boost.thread-futures-and-promises)
- en: 'Facebook Folly open source library: [https://github.com/facebook/folly](https://github.com/facebook/folly)'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Facebook Folly开源库：[https://github.com/facebook/folly](https://github.com/facebook/folly)
- en: 'Futures for C++11 at Facebook: [https://engineering.fb.com/2015/06/19/developer-tools/futures-for-c-11-at-facebook](https://engineering.fb.com/2015/06/19/developer-tools/futures-for-c-11-at-facebook)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Facebook的C++11未来：[https://engineering.fb.com/2015/06/19/developer-tools/futures-for-c-11-at-facebook](https://engineering.fb.com/2015/06/19/developer-tools/futures-for-c-11-at-facebook)
- en: '*‘Futures and Promises’ – How Instagram leverages it for better resource* *utilization*
    : [https://scaleyourapp.com/futures-and-promises-and-how-instagram-leverages-it/](https://scaleyourapp.com/futures-and-promises-and-how-instagram-leverages-it/)'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*‘Futures and Promises’ – 如何Instagram利用它来提高资源* *利用率*：[https://scaleyourapp.com/futures-and-promises-and-how-instagram-leverages-it/](https://scaleyourapp.com/futures-and-promises-and-how-instagram-leverages-it/)'
- en: 'SeaStar: Open source C++ framework for high-performance server applications:
    [https://seastar.io](https://seastar.io)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SeaStar：高性能服务器应用的C++开源框架：[https://seastar.io](https://seastar.io)
