- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Building an Online Checkers Game
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建在线国际象棋游戏
- en: In this chapter, we will delve into the captivating realm of creating an online
    multiplayer checkers game. We will apply the knowledge and skills we have acquired
    throughout this book to develop an engaging and interactive gaming experience.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨创建在线多人国际象棋游戏的迷人领域。我们将应用本书中获得的全部知识和技能，来开发一个引人入胜且互动性强的游戏体验。
- en: Checkers, a classic board game enjoyed by players of all ages, provides the
    perfect canvas to explore the complexity of online multiplayer game development.
    We will learn how to leverage the power of the Godot Engine and its versatile
    features to create a seamless multiplayer experience that will have players strategizing,
    competing, and enjoying the game together.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 棋盘游戏“国际象棋”，一种深受各个年龄段玩家喜爱的经典棋类游戏，为探索在线多人游戏开发的复杂性提供了完美的画布。我们将学习如何利用 Godot 引擎的强大功能和其多变的特性来创建无缝的多人游戏体验，让玩家在游戏中制定策略、竞争并共同享受游戏。
- en: To facilitate the synchronization of the game state across multiple players,
    we will introduce a powerful tool called the `MultiplayerSynchronizer` node. This
    node will play a crucial role in updating the positions of the checkers pieces
    across the boards of all connected players. By using this node, we can ensure
    that each player’s game view remains consistent and up to date, enhancing the
    overall multiplayer experience.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了促进游戏状态在多个玩家之间的同步，我们将介绍一个名为 `MultiplayerSynchronizer` 的强大工具节点。这个节点将在更新所有连接玩家棋盘上棋子位置方面发挥关键作用。通过使用这个节点，我们可以确保每个玩家的游戏视图保持一致并更新，从而提升整体的多人游戏体验。
- en: Throughout this chapter, we will cover essential concepts, such as client-server
    architecture, game synchronization, and player interactions, which are fundamental
    to the development of any multiplayer game. By understanding these concepts and
    applying them to our checkers game, we will create a robust and engaging multiplayer
    experience that will captivate players from around the world. The following diagram
    showcases the final project, where players are playing against each other online!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖一些基本概念，如客户端-服务器架构、游戏同步和玩家交互，这些对于任何多人游戏开发都是基础。通过理解这些概念并将它们应用于我们的国际象棋游戏，我们将创建一个强大且引人入胜的多人游戏体验，吸引全球各地的玩家。以下图表展示了最终项目，其中玩家正在在线相互对战！
- en: '![Figure 6.1 – Player 1’s game instance view and Player 2’s game instance view
    during the Black Team’s turn](img/Figure_06.01_B18527.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 黑队回合期间玩家 1 的游戏实例视图和玩家 2 的游戏实例视图](img/Figure_06.01_B18527.jpg)'
- en: Figure 6.1 – Player 1’s game instance view and Player 2’s game instance view
    during the Black Team’s turn
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 黑队回合期间玩家 1 的游戏实例视图和玩家 2 的游戏实例视图
- en: In addition to the technical aspects, we will also focus on creating an intuitive
    user experience that allows players to seamlessly navigate the game and interact
    with the checkers pieces. A well-designed interface is crucial in enhancing the
    player experience and ensuring a smooth and enjoyable gameplay session. Using
    some visual cues, we will ensure that players know the current game state intuitively.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 除了技术方面，我们还将专注于创建直观的用户体验，使玩家能够无缝地导航游戏并与棋子进行交互。一个精心设计的界面对于提升玩家体验和确保流畅且愉快的游戏体验至关重要。通过使用一些视觉提示，我们将确保玩家能够直观地了解当前的游戏状态。
- en: As we progress, we will explore strategies to manage player interactions, such
    as handling player turns and validating moves. These features are vital in maintaining
    fairness and ensuring that the game follows the established rules of checkers.
    By incorporating these elements, we will create an authentic and immersive checkers
    experience that will engage players for hours on end.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们不断前进，我们将探讨管理玩家交互的策略，例如处理玩家回合和验证走法。这些功能对于保持游戏的公平性并确保游戏遵循国际象棋的既定规则至关重要。通过整合这些元素，我们将创造一个真实且沉浸式的国际象棋体验，让玩家可以连续数小时地参与其中。
- en: By the end of this chapter, you will have gained valuable insights into the
    intricacies of online multiplayer game development. You will have the knowledge
    and skills necessary to create your own multiplayer games, with the ability to
    synchronize game states, handle player interactions, and deliver an immersive
    multiplayer experience.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将深入了解在线多人游戏开发的复杂性。你将拥有创建自己多人游戏所需的知识和技能，包括同步游戏状态、处理玩家交互以及提供沉浸式的多人游戏体验。
- en: So, get ready to embark on this exciting journey as we delve into the world
    of online multiplayer checkers game development. To do so, we will learn about
    the `MultiplayerSynchronizer` node and RPC functions, as they will be our key
    allies in synchronizing the players’ boards. Let’s begin this chapter and unlock
    the immense potential of multiplayer game development together.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，准备好开始这段激动人心的旅程吧，我们将深入探索在线多人跳棋游戏开发的世界。为此，我们将学习`MultiplayerSynchronizer`节点和RPC函数，因为它们将是我们在同步玩家棋盘时的关键盟友。让我们开始这一章，共同发掘多人游戏开发的巨大潜力。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing the Checkers project
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Checkers项目
- en: Serializing players’ turns
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化玩家回合
- en: Deserializing the opponent’s turn
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反序列化对手的回合
- en: Managing win and lose conditions
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理胜负条件
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we’ll be working with the fourth folder of our Godot Engine
    project repository, which you can access through the following link: [https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将处理Godot Engine项目仓库的第四个文件夹，您可以通过以下链接访问：[https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0)。
- en: Another requirement you will need to accomplish before following with our project
    import is to download Godot Engine version 4.0, as this is the version we will
    use throughout the whole book.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续我们的项目导入之前，你需要完成的一个要求是下载Godot Engine版本4.0，因为这是我们将在整本书中使用的版本。
- en: After opening your Godot Engine 4.0, open the project using the project manager.
    Then, navigate to the `06.building-online-checkers` folder. Here, you’ll find
    all the files we used to build this chapter’s project. You can test the game opening
    and playing the `res://06.building-online-checkers/CheckersGame.tscn` scene.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Godot Engine 4.0后，使用项目管理器打开项目。然后，导航到`06.building-online-checkers`文件夹。在这里，您可以找到我们构建本章项目所使用的所有文件。您可以测试游戏，打开并播放`res://06.building-online-checkers/CheckersGame.tscn`场景。
- en: This scene showcases most of the features of our game. In this chapter, we are
    also going to implement the lobby system we have worked with throughout the book.
    On top of that, we will turn some local features into online multiplayer features
    as well.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个场景展示了我们游戏的大部分功能。在这一章中，我们还将实现我们在整本书中一直在使用的游戏大厅系统。除此之外，我们还将把一些本地功能转变为在线多人功能。
- en: So, stay tuned.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，请保持关注。
- en: Introducing the Checkers project
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Checkers项目
- en: Welcome, respected network engineer of our esteemed fictional indie development
    studio! As we embark on this chapter, let us take a moment to familiarize ourselves
    with the existing Checkers project. Currently, the project is designed for local
    multiplayers, allowing players to engage in thrilling matches offline. This understanding
    will serve as a solid foundation as we explore the path toward transforming our
    Checkers game into a captivating online multiplayer experience.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到我们尊敬的虚构独立开发工作室的网络工程师！随着我们进入这一章，让我们花一点时间熟悉现有的Checkers项目。目前，该项目是为本地多人设计的，允许玩家进行离线的激动人心的比赛。这种理解将为我们探索将Checkers游戏转变为吸引人的在线多人体验的道路提供一个坚实的基础。
- en: In this endeavor, our goal is to seamlessly transition the existing local multiplayer
    functionality into an online environment, without encountering significant obstacles
    along the way. By leveraging our existing knowledge and skills, we can effectively
    adapt the game to support online multiplayer, thus expanding its reach and providing
    players with the opportunity to compete with opponents from around the globe.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个努力中，我们的目标是无缝地将现有的本地多人功能过渡到在线环境中，沿途不遇到重大障碍。通过利用我们现有的知识和技能，我们可以有效地调整游戏以支持在线多人，从而扩大其影响力，并为玩家提供与全球对手竞争的机会。
- en: Throughout this section, we will unravel our Checkers project’s inner workings,
    gaining valuable insights into its structure and mechanics. Armed with this understanding,
    we will be better equipped to navigate the porting process with confidence and
    efficiency.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将揭示Checkers项目的内部运作，获得对其结构和机制的有价值见解。有了这种理解，我们将更有信心和效率地导航移植过程。
- en: As the designated network engineer, you play a pivotal role in this endeavor.
    Your expertise and problem-solving abilities will be put to the test. With careful
    consideration and strategic implementation, we can minimize any potential challenges
    and ensure a seamless transition to the online multiplayer realm.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 作为指定的网络工程师，你在这一事业中扮演着关键角色。你的专业知识和解决问题的能力将受到考验。通过仔细考虑和战略性的实施，我们可以最大限度地减少任何潜在挑战，并确保顺利过渡到在线多人领域。
- en: Together, we will examine the project’s architecture, dissect its components,
    and identify the necessary modifications required to facilitate online multiplayer
    functionality. By applying our knowledge of networking concepts and programming
    techniques, we will construct a robust foundation upon which the online multiplayer
    features will thrive.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一起，我们将检查项目的架构，剖析其组件，并确定实现在线多人功能所需的必要修改。通过应用我们对网络概念和编程技术的了解，我们将构建一个坚实的基础，在线多人功能将在此之上蓬勃发展。
- en: Remember, you are an integral part of this process; as a network engineer, it
    is your job to implement all online multiplayer code, so you play a fundamental
    role here. Your skills will contribute to the realization of our vision – a thrilling
    online multiplayer Checkers game that captivates players across the digital landscape.
    So, let us embark on this journey. In the upcoming sections, we will understand
    the ins and outs of our local Checkers game.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你是这个过程中的一个重要部分；作为一名网络工程师，你的工作是实现所有在线多人代码，因此你在其中扮演着基本角色。你的技能将有助于我们愿景的实现——一款令人兴奋的在线多人棋盘游戏，吸引着数字世界各地的玩家。因此，让我们开始这段旅程。在接下来的章节中，我们将了解我们本地棋盘游戏的方方面面。
- en: Understanding the Checkers Piece scene
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解棋盘游戏棋子场景
- en: The **Piece** implements the functionality of a checkers game piece in our checkers’
    game. It allows players to interact with the Piece by selecting or deselecting
    it, keeping track of its selected state. In the following screenshot, we can see
    the SceneTree structure’s Piece.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**棋子**在我们的棋盘游戏中实现了棋子游戏的功能。它允许玩家通过选择或取消选择棋子与之交互，并跟踪其选择状态。在下面的屏幕截图中，我们可以看到场景树结构的棋子。'
- en: '![Figure 6.2 – The Piece scene node hierarchy](img/Figure_06.02_B18527.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – 棋子场景节点层次结构](img/Figure_06.02_B18527.jpg)'
- en: Figure 6.2 – The Piece scene node hierarchy
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 棋子场景节点层次结构
- en: To enhance the player experience and decision-making during their turns, we
    utilize visual cues provided by the `EnabledColorRect` and `SelectedColorRect`
    nodes. `EnabledColorRect` becomes visible when the Piece is capable of making
    a valid move within a player’s turn. Conversely, `SelectedColorRect` becomes visible
    when a player chooses this specific Piece over others, allowing for clear differentiation
    between them.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增强玩家在回合中的体验和决策，我们利用 `EnabledColorRect` 和 `SelectedColorRect` 节点提供的视觉提示。当棋子在玩家的回合内能够进行有效移动时，`EnabledColorRect`
    变得可见。相反，当玩家选择这个特定的棋子而不是其他棋子时，`SelectedColorRect` 变得可见，从而在它们之间实现清晰的区分。
- en: The `Sprite2D` node is responsible for displaying the current texture of the
    Piece. Depending on the player’s team and whether the Piece has been promoted
    to a king piece, the texture can represent either a white piece, a black piece,
    or their respective king versions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sprite2D` 节点负责显示棋子的当前纹理。根据玩家的队伍以及棋子是否被提升为国王棋子，纹理可以代表白色棋子、黑色棋子或它们各自的国王版本。'
- en: The `SelectionArea2D` node plays a crucial role in detecting player input. By
    using the `input_event` signal, we establish communication between the player’s
    clicks and the Piece. This enables us to toggle the Piece’s selection state, determining
    whether it is currently selected or deselected.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`SelectionArea2D` 节点在检测玩家输入中起着至关重要的作用。通过使用 `input_event` 信号，我们建立了玩家点击与棋子之间的通信。这使得我们能够切换棋子的选择状态，确定它当前是否被选中或取消选中。'
- en: Let’s take a look at its code to understand how each of these nodes plays a
    role in this whole logic.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它的代码，以了解每个节点如何在这个整体逻辑中发挥作用。
- en: 'Overall, this code forms a crucial component of the online multiplayer checkers
    game, providing the necessary functionality to interact with and manage the behavior
    of individual checkers pieces within the game:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，这段代码构成了在线多人棋盘游戏的一个关键组成部分，提供了与游戏内单个棋子交互和管理其行为的必要功能：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We start by defining some variables to store information about the Piece’s
    team – whether it’s a king, and its texture. It also has references to some child
    nodes in the scene and a variable to track whether the Piece is currently selected.
    Signals are defined to indicate when the Piece is selected or deselected. Next,
    we will declare the setter function we stated in the `_is_king` variable:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一些变量来存储有关 Pieces 队伍的信息——它是否是国王，以及其纹理。它还有一些场景中的子节点的引用和一个变量来跟踪 Pieces 是否当前被选中。定义了信号以指示
    Pieces 被选中或取消选中。接下来，我们将声明我们在 `_is_king` 变量中提到的设置函数：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When this variable is set to a new value, the code checks whether the node
    is part of the scene tree. If not, it waits until the node is ready, this prevents
    any errors when changing the variable’s value through the inspector. If the variable
    is set to `true`, it updates the visual appearance of the game piece to represent
    a king, using a specific texture. This allows for dynamic visual changes in the
    game piece when it becomes a king. After that, we have a signal callback from
    the `Area2D` node’s `input_event` signal:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个变量被设置为新的值时，代码会检查节点是否是场景树的一部分。如果不是，它会等待节点准备好，这可以防止通过检查器更改变量值时出现任何错误。如果变量被设置为
    `true`，它会更新游戏 Pieces 的视觉外观以表示国王，使用特定的纹理。这允许在 Pieces 成为国王时进行动态的视觉变化。之后，我们有来自 `Area2D`
    节点的 `input_event` 信号的信号回调：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It listens for left mouse button clicks and, when detected, calls the `select()`
    method, which, as we will see next, performs the procedures related to selecting
    the Piece. This code enables interaction within the game when the player clicks
    the left mouse button while hovering over the Piece’s `Area2D`. Here, we have
    the code for the `select()` method:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 它监听左鼠标按钮点击，并在检测到点击时调用 `select()` 方法，正如我们接下来将要看到的，这个方法执行与选中 Pieces 相关的程序。这段代码在玩家在
    Pieces 的 `Area2D` 上悬停并点击左鼠标按钮时启用游戏内的交互。这里，我们有 `select()` 方法的代码：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this function, we define what happens when the Piece is selected. It ensures
    that any previously selected objects are deselected, marks the current object
    as selected, shows a visual indicator, updates a variable to reflect the selection
    status, and emits the `selected` signal to notify other parts of the game about
    the selection event. This code is fundamental for managing and conveying the selected
    state of Pieces in the game. Then, we also have the opposite function, `deselect()`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们定义了当 Pieces 被选中时会发生什么。它确保任何之前选中的对象被取消选中，标记当前对象为选中状态，显示一个可视指示器，更新一个变量以反映选中状态，并发出
    `selected` 信号来通知游戏的其他部分关于选中事件。这段代码对于管理和传达游戏中 Pieces 的选中状态至关重要。然后，我们还有相反的函数，`deselect()`：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we define what happens when an object is deselected. The code removes
    the object from the `"selected"` group, hides the visual indicator of selection,
    updates the `is_selected` variable to reflect the deselection status, and emits
    the `deselected` signal to notify other parts of the game about the deselection
    event. Now, it’s time to enable the change in selection states; without that,
    the Piece shouldn’t be selectable. This helps to prevent players from selecting
    Pieces from the opponent’s team:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了当对象被取消选中时会发生什么。代码将对象从 `"selected"` 组中移除，隐藏选中状态的可视指示器，更新 `is_selected`
    变量以反映取消选中状态，并发出 `deselected` 信号来通知游戏的其他部分关于取消选中事件。现在，是时候启用选择状态的变化了；没有这个，Pieces
    不应该被选中。这有助于防止玩家从对手的队伍中选中 Pieces：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this part, we make the `Area2D` responsive to input events, and we also
    make a visual indicator visible on the screen. This is important to allow players
    to interact with and manipulate Pieces in the game when they are in an enabled
    state. Now, let’s see its counterpart, the `disable()` method:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们使 `Area2D` 对输入事件做出响应，并在屏幕上显示一个可视指示器。这对于允许玩家在启用状态下与游戏中的 Pieces 交互和操作非常重要。现在，让我们看看它的对应方法，即
    `disable()` 方法：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It’s essentially the opposite of the previous method. We make the `Area2D` non-responsive
    to input events, effectively making it non-interactive. On top of that, we hide
    the visual indicator on the screen that represents the Piece’s availability, visually
    representing the Piece’s disabled state. This is useful for controlling when and
    how players can interact with Pieces in the game.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是前一种方法的相反。我们使 `Area2D` 对输入事件无响应，从而使其不可交互。除此之外，我们还隐藏了表示 Pieces 可用性的屏幕上的可视指示器，直观地表示
    Pieces 的禁用状态。这对于控制玩家何时以及如何与游戏中的 Pieces 交互非常有用。
- en: In the upcoming section, we are going to see how the FreeCell scene works. It’s
    a scene we use to highlight the available free cells that a selected Piece can
    move to.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将看到 FreeCell 场景是如何工作的。这是一个我们用来突出显示所选棋子可以移动到的可用空单元格的场景。
- en: Comprehending the FreeCell scene
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 FreeCell 场景
- en: In our game project, we have a concept called **FreeCell**, which represents
    a valid cell that a Piece can move to. Think of it as a designated area where
    the Piece is allowed to go. Each time the player selects a Piece with valid movement,
    we visually indicate the available cells by showing them in green. These cells
    are actually instances of the FreeCell scene, which we dynamically create and
    display on the game board.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏项目中，有一个称为 **FreeCell** 的概念，它代表一个棋子可以移动到的有效单元格。把它想象成一个棋子被允许进入的指定区域。每次玩家选择一个具有有效移动的棋子时，我们通过将它们显示为绿色来视觉上指示可用的单元格。这些单元格实际上是
    FreeCell 场景的实例，我们动态地在游戏板上创建和显示这些实例。
- en: To provide a clear example, imagine a scenario where a king Piece is selected.
    In the following diagram, you can see that all the cells where this king Piece
    can move to are highlighted in green. Each of these highlighted cells is an instance
    of the FreeCell scene, which allows the player to quickly identify the possible
    movement options for the selected Piece.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一个清晰的例子，想象一下选择了一个国王棋子的场景。在下面的图中，你可以看到所有这个国王棋子可以移动到的单元格都被高亮显示为绿色。这些被高亮的单元格都是
    FreeCell 场景的实例，允许玩家快速识别所选棋子的可能移动选项。
- en: '![Figure 6.3 – Free cells available to the selected king piece](img/Figure_06.03_B18527.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 6.3 – Free cells available to the selected king piece](img/Figure_06.03_B18527.jpg)'
- en: Figure 6.3 – Free cells available to the selected king piece
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 可供所选国王棋子使用的 FreeCell
- en: By using the FreeCell concept, we enhance the player’s experience by visually
    communicating the valid movement possibilities. This empowers them to make informed
    decisions and strategize their next move effectively. It’s a powerful tool that
    adds clarity and depth to the gameplay mechanics.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 FreeCell 概念，我们通过视觉传达有效的移动可能性来增强玩家的体验。这使他们能够做出明智的决定并有效地策略性地规划下一步。这是一个强大的工具，它为游戏机制增添了清晰度和深度。
- en: The FreeCell scene is an essential component of our game, composed of three
    distinct nodes. The main node is an `Area2D`, which serves as the foundation for
    the FreeCell. It encompasses two child nodes – a `CollisionShape2D` and a `ColorRect`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: FreeCell 场景是我们游戏的一个基本组成部分，由三个不同的节点组成。主要节点是一个 `Area2D`，它是 FreeCell 的基础。它包括两个子节点
    – 一个 `CollisionShape2D` 和一个 `ColorRect`。
- en: The `CollisionShape2D` node is responsible for defining the shape and boundaries
    of the FreeCell. It ensures that the cell can properly interact with other game
    objects, such as Pieces or other elements within the game world. As we are about
    to see, `CollisionShape2D` also defines the boundaries in which the `Area2D` detects
    mouse inputs, which is fundamental for the FreeCell’s behavior.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`CollisionShape2D` 节点负责定义 FreeCell 的形状和边界。它确保单元格可以正确地与其他游戏对象（如棋子或游戏世界中的其他元素）交互。正如我们即将看到的，`CollisionShape2D`
    还定义了 `Area2D` 检测鼠标输入的边界，这对于 FreeCell 的行为是基本的。'
- en: The `ColorRect` node, conversely, controls the visual representation of the
    FreeCell. It determines the color and appearance of the cell, providing a visual
    indicator to distinguish it from other elements on the game board.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`ColorRect` 节点相反地控制着 FreeCell 的视觉表示。它决定了单元格的颜色和外观，为游戏板上的其他元素提供了一个视觉指示器，以便将其区分开来。'
- en: '![Figure 6.4 – The FreeCell scene node hierarchy'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.4 – The FreeCell scene node hierarchy'
- en: '](img/Figure_06.04_B18527.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_06.04_B18527.jpg]'
- en: Figure 6.4 – The FreeCell scene node hierarchy
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – FreeCell 场景节点层次结构
- en: 'To better understand the functionality and behavior of the FreeCell, let’s
    explore its accompanying script. By examining the script code, we will gain insights
    into how the FreeCell operates and interacts with other game elements, ultimately
    contributing to the overall game logic and mechanics:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解 FreeCell 的功能和行为，让我们探索其伴随的脚本。通过检查脚本代码，我们将深入了解 FreeCell 如何运作以及它与其他游戏元素的交互，最终有助于整体游戏逻辑和机制。
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code allows the cell, represented by `Area2D`, to respond to right mouse
    button events within its area. When a cell is selected, it emits a signal with
    the position of the cell. This signal can be used to inform other objects or scripts
    about the selection and provide them with the cell’s position for further processing.
    We’ll use this in the `CheckerBoard` script to map the FreeCell’s position into
    the board’s cell.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码允许由`Area2D`表示的单元格在其区域内响应用户右键鼠标事件。当单元格被选中时，它发出一个包含单元格位置的信号。这个信号可以用来通知其他对象或脚本关于选择的信息，并为它们提供单元格的位置以进行进一步处理。我们将在`CheckerBoard`脚本中使用这个功能，将FreeCell的位置映射到棋盘的单元格上。
- en: In the upcoming section, we will introduce the game board, an essential component
    of our game. We will then shift our focus to the core of this chapter, which involves
    implementing methods that we will turn into RPCs. These RPCs will enable the game
    to work seamlessly in an online environment, allowing players to interact with
    each other and synchronize their actions over the network.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍游戏棋盘，这是我们游戏的一个基本组成部分。然后，我们将把注意力转向本章的核心内容，即实现我们将将其转换为RPC的方法。这些RPC将使游戏能够在在线环境中无缝运行，允许玩家之间互动并同步他们的网络动作。
- en: By leveraging the power of RPCs, we will create a dynamic and engaging multiplayer
    experience for our players. Let’s dive into the details and explore how these
    methods will bring our game to life in an online setting.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用RPC的力量，我们将为玩家创造一个动态和吸引人的多人游戏体验。让我们深入了解细节，并探索这些方法如何使我们的游戏在在线环境中栩栩如生。
- en: Introducing the CheckerBoard scene
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍CheckerBoard场景
- en: In this section, let’s delve into the primary role of the game board, as this
    will serve as a foundation for our upcoming sections. By understanding the key
    responsibilities of the board, we can naturally identify the specific areas we
    will be focusing on in the subsequent sections. This understanding will pave the
    way for a clear and structured approach as we continue exploring our checker’s
    development process.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们深入探讨游戏棋盘的主要作用，因为这将为我们的后续章节奠定基础。通过理解棋盘的关键职责，我们可以自然地识别出我们在后续章节中将关注的特定领域。这种理解将为我们在继续探索棋盘的开发过程时提供一个清晰和结构化的方法。
- en: The primary role of our game board is to manage the relationship between the
    black and white pieces in the game. To achieve this, the board utilizes the built-in
    `TileMap` functions to map the pieces onto cartesian coordinates. Additionally,
    it employs a hash map to associate the content of each cell on the board.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏棋盘的主要作用是管理游戏中的黑白棋子之间的关系。为了实现这一点，棋盘利用内置的`TileMap`函数将棋子映射到笛卡尔坐标系上。此外，它还使用哈希表将棋盘上每个单元格的内容关联起来。
- en: This means that we can access the content of a specific cell by providing its
    corresponding `Vector2i` coordinate. For example, by using the `meta_board[Vector2i(0,3)]`
    expression, we can retrieve the contents of the cell located in the first column
    and fourth row of the board. The result of this access will either be `null`,
    indicating that the cell is free, or it will return the Piece that is currently
    mapped to that particular cell. This mechanism allows for efficient retrieval
    and manipulation of the contents on the board, enabling seamless gameplay and
    interaction with the pieces.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以通过提供相应的`Vector2i`坐标来访问特定单元格的内容。例如，通过使用`meta_board[Vector2i(0,3)]`表达式，我们可以检索位于棋盘第一列第四行的单元格内容。这次访问的结果将是`null`，表示该单元格是空的，或者它将返回当前映射到该特定单元格的棋子。这种机制允许高效地检索和操作棋盘上的内容，从而实现流畅的游戏和与棋子的交互。
- en: The CheckerBoard plays a vital role in our game by overseeing various aspects
    of gameplay. Firstly, it manages the available movements for each cell on the
    board, taking into account the current team in play and whether a Piece has been
    promoted to a king. This ensures that players can only make valid moves based
    on the rules of the game.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: CheckerBoard在我们的游戏中扮演着至关重要的角色，它监督游戏的各种方面。首先，它管理棋盘上每个单元格的可用移动，考虑到当前在场的队伍以及是否有棋子被提升为国王。这确保了玩家只能根据游戏规则进行有效移动。
- en: The CheckerBoard is also responsible for controlling the turns in the game.
    It enables and disables the Pieces according to the active team, allowing only
    the team in play to make moves during their turn. This mechanism ensures fair
    gameplay and maintains the flow of the game.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: CheckerBoard 还负责控制游戏中的回合。它根据活跃的队伍启用和禁用棋子，允许在回合中仅允许正在进行的队伍进行移动。这种机制确保了公平的游戏和维持游戏的流畅性。
- en: Furthermore, the CheckerBoard keeps track of the number of Pieces each team
    possesses at the end of each turn. This count is crucial, as it determines the
    win-lose condition of the game. If a team has no remaining Pieces on the board,
    the CheckerBoard triggers the appropriate `win` condition, declaring the opposing
    team as the winner.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，CheckerBoard 会跟踪每个队伍在每个回合结束时拥有的棋子数量。这个计数至关重要，因为它决定了游戏的胜负条件。如果一个队伍在棋盘上没有剩余的棋子，CheckerBoard
    将触发适当的 `win` 条件，宣布对方队伍为胜者。
- en: 'By managing the cell movements, regulating turns, and monitoring the Piece
    count, the CheckerBoard maintains the game’s rules and progression. Its role is
    fundamental to providing clear conditions for victory or defeat. Let’s take a
    look at the CheckerBoard scene structure:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过管理单元格移动、调节回合和监控棋子数量，CheckerBoard 维护游戏的规则和进展。它的作用对于提供明确的胜负条件至关重要。让我们看看 CheckerBoard
    场景结构：
- en: '![Figure 6.5 – The CheckerBoard scene node hierarchy](img/Figure_06.05_B18527.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – CheckerBoard 场景节点层次结构](img/Figure_06.05_B18527.jpg)'
- en: Figure 6.5 – The CheckerBoard scene node hierarchy
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – CheckerBoard 场景节点层次结构
- en: It’s important to note that the CheckerBoard is implemented as `TileMap`, a
    useful class in our game. We use specific methods provided by the `TileMap` class,
    such as `map_to_local()`, `local_to_map()`, and `get_used_cells()`, to establish
    our cell-mapping functionality. The `map_to_local()` method will help us map the
    game to cell positions in `TileMap`, while `local_to_map()` will help us convert
    the Pieces’ positions to cells in the map. This will help us abstract the game
    in terms of rows and columns instead of floating-point numbers. As for the `get_used_cells()`
    method, it will help us access only the cells that have a tile set to them and
    avoid dealing with blank cells in `TileMap`. This will be useful when we create
    a matrix of the cells’ contents.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，CheckerBoard 是作为 `TileMap` 实现的，这是我们在游戏中使用的一个有用的类。我们使用 `TileMap` 类提供的特定方法，例如
    `map_to_local()`、`local_to_map()` 和 `get_used_cells()`，来建立我们的单元格映射功能。`map_to_local()`
    方法将帮助我们将游戏映射到 `TileMap` 中的单元格位置，而 `local_to_map()` 将帮助我们将棋子的位置转换为地图中的单元格。这将帮助我们以行和列的形式抽象游戏，而不是使用浮点数。至于
    `get_used_cells()` 方法，它将帮助我们访问仅设置了瓦片的单元格，并避免在 `TileMap` 中处理空白单元格。这在我们创建单元格内容的矩阵时将非常有用。
- en: 'In the `CheckerBoard` class, we’ll focus on understanding the significance
    of the `meta_board` `create_meta_board()` and `map_pieces()` methods within the
    `CheckerBoard` class:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `CheckerBoard` 类中，我们将关注理解 `meta_board`、`create_meta_board()` 和 `map_pieces()`
    方法在 `CheckerBoard` 类中的重要性：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `create_meta_board()` method is responsible for setting up the `meta_board`
    Dictionary. This Dictionary acts as a data structure that maps cell coordinates
    to their corresponding contents. By leveraging the `TileMap` methods mentioned
    earlier, the `create_meta_board()` method populates `meta_board` with the appropriate
    cell coordinates and initializes them with null values, indicating empty cells.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_meta_board()` 方法负责设置 `meta_board` 字典。这个字典充当一个数据结构，将单元格坐标映射到它们对应的内 容。通过利用前面提到的
    `TileMap` 方法，`create_meta_board()` 方法用适当的单元格坐标填充 `meta_board`，并将它们初始化为空值，表示空白单元格。'
- en: Conversely, the `map_pieces()` method performs an essential role in updating
    the `meta_board` to reflect the current state of the game. This method iterates
    over all the Pieces on the provided team, which is passed as a reference to either
    the `BlackTeam` node or the `WhiteTeam` node. Then, it converts the Pieces’ positions
    using the `TileMap.local_to_map()` method and maps each Piece to its respective
    cell coordinate in `meta_board`. This ensures that `meta_board` accurately represents
    the placement of Pieces on the visual board.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`map_pieces()` 方法在更新 `meta_board` 以反映游戏当前状态方面发挥着至关重要的作用。该方法遍历提供的队伍上的所有棋子，该队伍作为引用传递给
    `BlackTeam` 节点或 `WhiteTeam` 节点。然后，它使用 `TileMap.local_to_map()` 方法转换棋子的位置，并将每个棋子映射到
    `meta_board` 中相应的单元格坐标。这确保 `meta_board` 准确地表示视觉棋盘上棋子的放置。
- en: Lastly, the code establishes a connection between the `Piece.selected` signal
    and the `_on_piece_selected()` callback function. By connecting this signal, we
    bind the current Piece to the callback function as its argument. This enables
    us to conveniently access the `Piece` node whenever the player selects it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码在`Piece.selected`信号和`_on_piece_selected()`回调函数之间建立了一个连接。通过连接这个信号，我们将当前棋子绑定到回调函数作为其参数。这使得我们能够在玩家选择它时方便地访问`Piece`节点。
- en: This connection ensures that when the Piece emits the selected signal, the associated
    callback function, `_on_piece_selected()`, will be invoked and provided with the
    `Piece` node as its argument. This mechanism allows us to perform specific actions
    or access properties of the `Piece` node, in response to the player’s selection.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个连接确保了当棋子发出选择信号时，相关的回调函数`_on_piece_selected()`将被调用，并提供了`Piece`节点作为其参数。这种机制允许我们根据玩家的选择执行特定操作或访问`Piece`节点的属性。
- en: By establishing this connection, we create a seamless interaction between the
    `Piece` node and the corresponding callback function, enhancing the flexibility
    and responsiveness of our game.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过建立这个连接，我们在`Piece`节点和相应的回调函数之间创建了一个无缝的交互，增强了游戏的灵活性和响应性。
- en: There are some auxiliary functions that help us calculate available cells and
    coordinate the Piece’s movement; feel free to check them out and understand how
    we check for available cells, how we capture cells, and other gameplay features.
    In the next section, we will explore a different aspect of our checkers development
    journey.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些辅助函数帮助我们计算可用单元格并协调棋子的移动；请随意查看它们，了解我们是如何检查可用单元格的，我们是如何捕获单元格的，以及其他游戏玩法特性。在下一节中，我们将探索我们跳棋开发旅程的不同方面。
- en: We will focus on how we can package and transmit all the pertinent information
    about a player’s turn across the network, ensuring that other players are promptly
    updated with the current state of the game board.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将关注我们如何打包和传输有关玩家回合的所有相关信息，确保其他玩家能够及时更新游戏板当前的状态。
- en: By understanding this process, we will be able to establish efficient communication
    between players, facilitating a seamless multiplayer experience. This functionality
    is essential for maintaining synchronization and enabling real-time gameplay in
    our online multiplayer game. Stay tuned as we dive into the intricacies of transmitting
    and updating the game state across the network.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解这个过程，我们将能够建立玩家之间的有效通信，促进无缝的多玩家体验。这种功能对于保持同步和实现在线多人游戏中的实时游戏至关重要。请继续关注，我们将深入了解在网络中传输和更新游戏状态的所有细节。
- en: Serializing players’ turns
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化玩家回合
- en: In [*Chapter 2*](B18527_02.xhtml#_idTextAnchor037), *Sending and Receiving Data*,
    we explored an essential technique to recreate the game state across multiple
    players in a network. By serializing the relevant data and transmitting it in
    small portions, we ensure efficient utilization of network bandwidth while maintaining
    synchronization among peers.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第二章*](B18527_02.xhtml#_idTextAnchor037) *发送和接收数据*中，我们探讨了在网络中跨多个玩家重新创建游戏状态的基本技术。通过序列化相关数据并以小部分传输，我们确保了网络带宽的有效利用，同时保持了玩家之间的同步。
- en: Developing an understanding of what information is crucial to replicate the
    game state among players involves mastering the concept of abstraction in game
    development. In our case, this primarily revolves around `meta_board`, which is
    an abstraction of the relevant metadata of our game, such as the positional data
    and king state of the Pieces and the empty cells in the board.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 理解在玩家之间复制游戏状态所需的关键信息，涉及掌握游戏开发中的抽象概念。在我们的案例中，这主要围绕`meta_board`，它是我们游戏相关元数据（如棋子的位置数据和棋王状态以及棋盘中的空单元格）的抽象。
- en: Additionally, we need to consider the availability of Pieces, depending on the
    players’ turn. Fortunately, most other elements of the game can be managed locally
    without requiring network synchronization.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们需要考虑棋子的可用性，这取决于玩家的回合。幸运的是，游戏中的大多数其他元素可以在本地管理，无需网络同步。
- en: To simplify the process of synchronizing node properties across networked peers,
    I would like to introduce you to `MultiplayerSynchronizer`. This powerful node
    takes on the responsibility of automatically synchronizing properties across peers,
    relieving us from the tedious task of manual synchronization.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化在网络节点之间同步属性的过程，我想向您介绍`MultiplayerSynchronizer`。这个强大的节点承担了自动同步节点属性的责任，使我们免去了手动同步的繁琐任务。
- en: With `MultiplayerSynchronizer` in place, we can focus on developing the game’s
    logic and let the node handle the efficient transmission of data among players.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MultiplayerSynchronizer`就位后，我们可以专注于开发游戏逻辑，让节点处理玩家之间数据的高效传输。
- en: Working with MultiplayerSynchronizer
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与MultiplayerSynchronizer一起工作
- en: '`MultiplayerSynchronizer` plays a vital role by allowing us to effortlessly
    sync and share the state of nodes across multiple players, without writing any
    additional code. To begin utilizing this functionality, we will add a `MultiplayerSynchronizer`
    node to the Piece’s scene. This will ensure consistency in the game state of each
    player. Let’s dive into the process of integrating the `MultiplayerSynchronizer`
    and harnessing its capabilities.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`MultiplayerSynchronizer`通过允许我们轻松同步和共享多个玩家之间节点的状态，发挥着至关重要的作用，而无需编写任何额外的代码。为了开始利用这一功能，我们将向Piece的场景添加一个`MultiplayerSynchronizer`节点。这将确保每个玩家的游戏状态一致性。让我们深入了解集成`MultiplayerSynchronizer`并利用其功能的过程。'
- en: Setting up MultiplayerSynchronizer in the Piece scene
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Piece场景中设置MultiplayerSynchronizer
- en: 'Open the `res://06.building-online-checkers/Piece.tscn` scene and add a `MultiplayerSynchronizer`
    as a child of the `Piece` node. Then, we’ll set up the properties we want to synchronize:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`res://06.building-online-checkers/Piece.tscn`场景，并将`MultiplayerSynchronizer`作为`Piece`节点的子节点添加。然后，我们将设置我们想要同步的属性：
- en: With the `MultiplayerSychronizer` node selected, in the bottom panel on the
    **Replication** tab, click the **Add property to** **sync** button.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择`MultiplayerSychronizer`节点后，在**复制**选项卡的底部面板中，点击**添加属性以同步**按钮。
- en: '![Figure 6.6 – The Replication menu from the MultiplayerSynchronizer node](img/Figure_06.06_B18527.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图6.6 – MultiplayerSynchronizer节点的复制菜单](img/Figure_06.06_B18527.jpg)'
- en: Figure 6.6 – The Replication menu from the MultiplayerSynchronizer node
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 – MultiplayerSynchronizer节点的复制菜单
- en: From the pop-up menu, select the **Piece** node.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从弹出菜单中选择**Piece**节点。
- en: "![Figure 6.7 – Selecting the Piece node from the Pick a \uFEFFnode to \uFEFF\
    synchronize pop-up menu](img/Figure_06.07_B18527.jpg)"
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图6.7 – 从选择要同步的节点弹出菜单中选择Piece节点](img/Figure_06.07_B18527.jpg)'
- en: Figure 6.7 – Selecting the Piece node from the Pick a node to synchronize pop-up
    menu
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 – 从选择要同步的节点弹出菜单中选择Piece节点
- en: After selecting the **Piece** node, another pop-up menu will appear, asking
    you to select the property you want to sync. From there, select the **position**
    property.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择**Piece**节点后，将出现另一个弹出菜单，要求您选择要同步的属性。从那里，选择**位置**属性。
- en: '![Figure 6.8 – Choosing the position property from the Select Property pop-up
    menu](img/Figure_06.08_B18527.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图6.8 – 从选择属性弹出菜单中选择位置属性](img/Figure_06.08_B18527.jpg)'
- en: Figure 6.8 – Choosing the position property from the Select Property pop-up
    menu
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 – 从选择属性弹出菜单中选择位置属性
- en: And that’s it. With that, as soon as the players are connected to the same network,
    they will automatically sync their Pieces’ positions on the board. However, we
    still have an issue as this only updates the visual representation of the Piece,
    and we still need to update its data in `meta_board`. Now comes the fun part.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。有了这个，一旦玩家连接到同一网络，他们就会自动同步棋盘上Piece的位置。然而，我们仍然有一个问题，因为这只会更新Piece的视觉表示，我们仍然需要更新其在`meta_board`中的数据。现在到了有趣的部分。
- en: In the next section, we will start to understand the methods in the CheckerBoard
    that we need to turn into RPCs, keeping players on the same page.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将开始了解CheckerBoard中我们需要转换为RPC的方法，以保持玩家在同一个页面上。
- en: Updating and syncing the CheckerBoard
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新和同步CheckerBoard
- en: A core issue when developing any application is that we have limited resources.
    In the case of transmitting data over a network, we are talking about bandwidth.
    Games are a special case because everything should happen in real time, so we
    can’t risk heavy data transmission that hurts network performance.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发任何应用程序时，一个核心问题是我们资源有限。在通过网络传输数据的情况下，我们谈论的是带宽。游戏是一个特殊情况，因为所有事情都应该实时发生，所以我们不能冒险进行会损害网络性能的大量数据传输。
- en: To turn this in our favor, we need to pass data in the most abstract and lightweight
    way we can. In our case, we have our `meta_board` as a means to represent the
    game’s current state. By using `Vector2i` coordinates, we can access and change
    the game states. And that’s how we are going to keep players updated. In the next
    section, we are going to work with the `CheckerBoard.update_cells()` method, which
    is the core of our update system.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这一优势转化为我们的优势，我们需要以最抽象和轻量级的方式传递数据。在我们的例子中，我们的 `meta_board` 是表示游戏当前状态的一种手段。通过使用
    `Vector2i` 坐标，我们可以访问和更改游戏状态。这就是我们将如何保持玩家更新的。在下一节中，我们将处理 `CheckerBoard.update_cells()`
    方法，这是我们更新系统的核心。
- en: Using coordinates to update the board
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用坐标更新棋盘
- en: Since `meta_board` is a Dictionary, we can access and set the values of its
    keys using Godot Engine’s built-in types. For instance, if we want to change the
    content of the cell in the third row second column to `null`, we can write `meta_board[Vectori(1,
    2)] =` `null`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `meta_board` 是一个字典，我们可以使用 Godot 引擎内置的类型来访问和设置其键的值。例如，如果我们想将第三行第二列单元格的内容更改为
    `null`，我们可以编写 `meta_board[Vector2i(1, 2)] = null`。
- en: 'When Pieces perform a move, we just need to know the content of the previous
    and new cell of this movement, so that we can update it. And that’s exactly what
    the `update_cells()` method does. Let’s take a look at it:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当棋子进行移动时，我们只需要知道这个移动的先前单元格和新单元格的内容，这样我们就可以更新它。这正是 `update_cells()` 方法所做的事情。让我们看看它：
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since this is the very core of our update system, we need to turn it into an
    RPC function and call it as such.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是我们更新系统的核心，我们需要将其转换为 RPC 函数并按此方式调用。
- en: 'For that, let’s make the appropriate changes in our script:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，让我们在我们的脚本中进行适当的更改：
- en: 'Add the `@rpc` annotation to this method, using the `any_peer` and `call_local`
    options. We use these because we want every player to update others about changes
    in their board, and we also want their own board to update itself, hence the `call_local`
    option:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `any_peer` 和 `call_local` 选项将 `@rpc` 注解添加到这个方法中。我们使用这些选项是因为我们希望每个玩家都能更新其他玩家的棋盘变化，并且我们也希望他们的棋盘自己更新，因此有
    `call_local` 选项：
- en: '[PRE10]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the `move_selected_piece()` method, change the `update_cells(current_cell,
    target_cell)` line to an RPC call instead. This will make the call of this method
    both local and remote on other peers as well:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `move_selected_piece()` 方法中，将 `update_cells(current_cell, target_cell)` 行更改为
    RPC 调用。这将使这个方法在其它对等机上也是本地和远程调用：
- en: '[PRE11]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With that, every time the CheckerBoard moves a Piece, it updates its `meta_board`
    data on all peers on the network.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，每当 CheckerBoard 移动一个棋子时，它就会在网络上所有对等机上更新其 `meta_board` 数据。
- en: Note that there’s another method that we can turn into an RPC as well. Every
    player should update `Piece.is_king` of a Piece that reached their opponent’s
    king row. For that, we have the `crown()`method that `move_selected_piece()` calls
    at the bottom of its logic.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还可以将另一个方法转换为 RPC。每个玩家都应该更新到达对手王行的棋子的 `Piece.is_king`。为此，我们在 `move_selected_piece()`
    逻辑的底部调用了 `crown()` 方法。
- en: 'Let’s do the same thing we did with `update_cells()` with the `crown()` method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用与 `update_cells()` 相同的方式做同样的事情：
- en: 'First, we add the `@rpc` annotation to it with the `any_peer` and `call_local`
    options:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用 `@rpc` 注解并添加 `any_peer` 和 `call_local` 选项：
- en: '[PRE12]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we change the `crown(target_cell)` call to its `rpc()` version:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将 `crown(target_cell)` 调用更改为它的 `rpc()` 版本：
- en: '[PRE13]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With that, when a Piece reaches the king row, all players’ CheckerBoards update
    their king state, be it an opponent Piece or an ally Piece.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当一个棋子到达王行时，所有玩家的 CheckerBoard 都会更新他们的王状态，无论是对手的棋子还是盟友的棋子。
- en: Our work isn’t done yet. In the next section, we will see how we update the
    `meta_board` content when players perform a capturing movement, meaning we need
    to remove a Piece from the board.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工作还没有完成。在下一节中，我们将看到当玩家执行捕获动作时如何更新 `meta_board` 内容，这意味着我们需要从棋盘上移除一个棋子。
- en: Removing a Piece from the board
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从棋盘上移除棋子
- en: When a player makes a move that ends up capturing an opponent Piece, we should
    update the game board accordingly. This means that on top of updating the cells
    involved in the movement, we should also update the cell where the captured Piece
    was, setting its content to null – in other words, turning it into a free cell.
    That’s what the `remove_piece()` method does.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家移动棋子并最终捕获对手的棋子时，我们应该相应地更新游戏板。这意味着除了更新移动涉及的单元格外，我们还应该更新捕获的棋子所在的单元格，将其内容设置为
    `null` - 也就是说，将其变成一个空单元格。这正是 `remove_piece()` 方法所做的事情。
- en: 'Let’s take a look at its code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它的代码：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Since this behavior impacts both players, we need to turn this method into an
    RPC as well so that every time a player captures a Piece, they update their opponent
    with this sad fact.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种行为影响双方玩家，我们需要将此方法也转换为RPC，以便每次玩家捕获一个棋子时，他们都会更新对手这个令人难过的事实。
- en: 'Let’s make the appropriate changes so that this feature is compliant with our
    online multiplayer demands:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做出适当的更改，以确保这个功能符合我们的在线多人游戏需求：
- en: 'Add the `@rpc` annotation to the `remove_piece()` method with the `any_peer`
    and `call_local` options:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`@rpc`注解添加到`remove_piece()`方法上，并使用`any_peer`和`call_local`选项：
- en: '[PRE15]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the `capture_piece()` method, update the `remove_piece(cell)` line to its
    `rpc()` version:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`capture_piece()`方法中，将`remove_piece(cell)`行更新为其`rpc()`版本：
- en: '[PRE16]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, every time a player captures a cell, it calls the `remove_piece()` method
    both locally and remotely on all connected peers!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次玩家捕获一个单元格时，它都会在所有连接的玩家上本地和远程调用`remove_piece()`方法！
- en: With that, we have our players turn properly serialized and ready to be passed
    through the network to other peers, with good performance and little data usage,
    leaving a good bandwidth for us if we so desire. For instance, we can add a chat
    feature using a new RPC channel if we want to in the future.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就有了玩家回合的正确序列化，并准备好通过网络传递给其他玩家，具有良好的性能和低数据使用，如果我们愿意，还可以留下良好的带宽。例如，如果我们想在将来添加聊天功能，我们可以使用新的RPC通道。
- en: In this section, we learned about the importance of abstracting relevant data
    for our network communication and how to turn local functionalities into remote
    functionalities, while maintaining all their logic and overall structure. Here,
    we saw the relevance of the `call_local` RPC option as well as the simplicity
    of turning a method call into an RPC call with the `rpc()` method.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了抽象相关数据对于我们的网络通信的重要性，以及如何将本地功能转换为远程功能，同时保持所有逻辑和整体结构。在这里，我们看到了`call_local`
    RPC选项的相关性，以及使用`rpc()`方法将方法调用转换为RPC调用的简单性。
- en: In the next section, we will see how we manage the turn logic. This is an important
    feature to handle because there we will need to actively add a layer of network
    verification to properly handle the turns. The logic of a local turn shift and
    a remote turn shift is very distinct.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何管理回合逻辑。这是一个重要的功能，因为在那里我们需要积极添加一层网络验证来正确处理回合。本地回合转换和远程回合转换的逻辑非常不同。
- en: Handling remote turn shifts
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理远程回合转换
- en: One of the most important aspects of playing a game online is to maintain players’
    autonomy and authority over their resources – in this case, their team’s Pieces.
    Godot Engine offers an interesting system where a SceneTree can structure its
    nodes’ hierarchies with distinct Multiplayer Authorities.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在线玩游戏的最重要的方面之一是保持玩家对其资源的自主权和控制权——在这种情况下，是他们团队的棋子。Godot引擎提供了一个有趣的系统，其中SceneTree可以使用不同的多玩家权限来结构化其节点的层次结构。
- en: To set up a node and its children’s Multiplayer Authority, recursively, we can
    use `set_multiplayer_authority()` and pass the respective peer’s ID as an argument.
    In our case, we are going to change the `BlackTeam` and `WhiteTeam` nodes’ Multiplayer
    Authority to match their respective players’ peer IDs.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了递归地设置节点及其子节点的多玩家权限，我们可以使用`set_multiplayer_authority()`并传递相应的玩家ID作为参数。在我们的例子中，我们将更改`BlackTeam`和`WhiteTeam`节点多玩家权限以匹配它们各自玩家的玩家ID。
- en: This will be done by the server, so to keep the application simple, we are going
    to allow clients and server to share the same script, and we will check which
    one is running the server instance by using `is_multiplayer_authority()` on the
    CheckerBoard. We should only run this logic if the game is running in a network
    and there are peers connected. For that, we can check whether `multiplayer.get_peers().size()`
    is greater than `0`, meaning there are peers connected. Let’s see this in practice,
    shall we?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这将由服务器来完成，为了保持应用程序简单，我们将允许客户端和服务器共享相同的脚本，并且我们将通过在CheckerBoard上使用`is_multiplayer_authority()`来检查哪个正在运行服务器实例。只有在游戏在网络中运行并且有连接的玩家时，我们才应该运行这个逻辑。为此，我们可以检查`multiplayer.get_peers().size()`是否大于`0`，这意味着有玩家连接。让我们看看实际操作吧，好吗？
- en: Setting up players’ teams
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置玩家团队
- en: The first thing we need to understand to handle players’ turn shifts is that
    each one of the nodes that represent the team – in other words, the `BlackTeam`
    and the `WhiteTeam` nodes – should have its respective players’ peer IDs set as
    their Multiplayer Authorities.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理玩家轮次转换，我们首先需要理解的是，代表团队的每个节点——换句话说，`BlackTeam`和`WhiteTeam`节点——应该将其各自的玩家同伴ID设置为它们的多人权限。
- en: 'In that sense, we need to create a method in the `CheckerBoard` class that
    receives the team and the peer ID as arguments. Remember, we can’t pass objects
    as arguments in this method because it needs to work in the network. So, we need
    to abstract teams as an `enum` that we can pass around through RPCs, and then
    all peers will be able to understand the message and access the correct team node
    at their end. Let’s dive into the action and create a method called `setup_team()`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个意义上，我们需要在`CheckerBoard`类中创建一个方法，该方法接收团队和同伴ID作为参数。记住，我们无法在这个方法中传递对象作为参数，因为它需要在网络中工作。因此，我们需要将团队抽象为一个`enum`，我们可以通过RPC传递它，然后所有同伴都将能够理解消息并在他们的端点访问正确的团队节点。让我们深入行动，创建一个名为`setup_team()`的方法：
- en: 'Add the `@rpc("authority", "call_local")` decorator before the `setup_team()`
    function definition. The `authority` option indicates that this RPC can only be
    called by the Multiplayer Authority; remember that the authority of the CheckerBoard
    will still be the server. The `call_local` argument specifies that the function
    should also be executed locally on the calling peers:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup_team()`函数定义之前添加`@rpc("authority", "call_local")`装饰器。`authority`选项表示只能由多人权限调用此RPC；记住，CheckerBoard的权限仍然是服务器。`call_local`参数指定该函数还应在本地调用者上执行：
- en: '[PRE17]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Inside the function, check whether the value of `team` is equal to `Teams.BLACK`;
    if this is the case, call the `set_multiplayer_authority()` method on the `black_team`
    object and pass `peer_id` as an argument. This effectively designates the specified
    peer as the authority for `BlackTeam` and all its children – in other words, the
    black Pieces:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数内部，检查`team`的值是否等于`Teams.BLACK`；如果是这样，在`black_team`对象上调用`set_multiplayer_authority()`方法，并传递`peer_id`作为参数。这实际上指定了指定的同伴为`BlackTeam`及其所有子节点——换句话说，黑棋——的权限：
- en: '[PRE18]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Otherwise, call the `set_multiplayer_authority()` method on the `white_team`
    object and pass `peer_id` as an argument:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，在`white_team`对象上调用`set_multiplayer_authority()`方法，并传递`peer_id`作为参数：
- en: '[PRE19]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This method sets up the Multiplayer Authority of a team node based on the received
    team, `black_team` or `white_team`, using the provided `peer_id`. This ensures
    that the Multiplayer Authority for each team is correctly established, allowing
    the game logic to be synchronized across networked peers. Since the server calls
    this method on all peers, both players and the server will sync their team nodes
    accordingly.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法根据接收到的团队，`black_team`或`white_team`，使用提供的`peer_id`设置团队节点的多人权限。这确保了每个团队的多人权限都得到正确建立，允许游戏逻辑在网络同伴之间同步。由于服务器在所有同伴上调用此方法，玩家和服务器都将相应地同步他们的团队节点。
- en: 'Now, to ensure that this mechanism will be established among all peers, we
    are going to add the following lines of code right inside the `_ready()` callback:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了确保这种机制将在所有同伴之间建立，我们将在`_ready()`回调内部直接添加以下代码行：
- en: 'Inside the `_ready()` callback, check whether there are peers connected in
    the multiplayer session by checking whether the size of `multiplayer.get_peers()`
    array is greater than `0`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`_ready()`回调内部，通过检查`multiplayer.get_peers()`数组的大小是否大于`0`来检查多人会话中是否有同伴连接：
- en: '[PRE20]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If this is the case, check whether the current node is the Multiplayer Authority
    by using the `is_multiplayer_authority()` function. This ensures that we will
    only call the following logic in the server peer:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是这样，使用`is_multiplayer_authority()`函数检查当前节点是否是多人权限。这确保我们只会在服务器同伴中调用以下逻辑：
- en: '[PRE21]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, make an RPC using the `rpc()` method, with the `"setup_team "` , `Teams.BLACK`,
    and `multiplayer.get_peers()[0]` arguments. This will call the `setup_team()`
    method on all connected peers, telling them to set the BlackTeam’s Multiplayer
    Authority using the first peer ID in the list of connected peers. So, the first
    player connected in the session will be responsible for the black Pieces:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`rpc()`方法，传递`"setup_team"`、`Teams.BLACK`和`multiplayer.get_peers()[0]`参数进行RPC调用。这将调用所有连接同伴的`setup_team()`方法，告诉他们使用连接同伴列表中的第一个同伴ID设置BlackTeam的多人权限。因此，在会话中首先连接的玩家将负责黑棋：
- en: '[PRE22]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Right below the previous line, we are going to do the same thing but use `Teams.WHITE`
    and the connected peers’ list second index, meaning the second player that connected
    to the session:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一行下面，我们将做同样的事情，但使用`Teams.WHITE`和连接节点的第二个索引，即第二个连接到会话的玩家：
- en: '[PRE23]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With that, we have our team setup in place. Note that, since the server has
    both team nodes’ Multiplayer Authorities assigned to each of the players in the
    match, the server itself can’t perform any movement in the board’s Pieces.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如此一来，我们的团队设置已经到位。请注意，由于服务器已经将团队节点多玩家权限分配给了比赛中每位玩家，因此服务器本身无法在棋盘的棋子中进行任何移动。
- en: Talking about that prevention mechanism, how does it work? How does the CheckerBoard
    prevent players from interacting with Pieces, especially with their opponent Pieces?
    In the next section, we are going to see how we can detect which player is assigned
    to which team and only re-enable their appropriate team Pieces.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 说到那个预防机制，它是如何工作的？跳棋棋盘是如何防止玩家与棋子互动的，尤其是与他们的对手棋子的？在下一节中，我们将看到我们如何检测哪个玩家被分配到哪个团队，并且只重新启用他们适当的团队棋子。
- en: Enabling and disabling team pieces
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用和禁用团队棋子
- en: In our game, when players end a turn, we disable all their pieces using the
    `disable_pieces()` method. In turn shifts, we make sure to disable both teams’
    Pieces, and we also check whether there’s a winner from the past turn; if not,
    we start the procedure to re-enable players’ Pieces based on the turn’s team.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，当玩家结束回合时，我们使用`disable_pieces()`方法禁用所有他们的棋子。在回合转换时，我们确保禁用两队的棋子，并检查上一回合是否有赢家；如果没有，我们根据回合的团队开始重新启用玩家棋子的程序。
- en: All of that happens in the `toggle_turn()` method, but as it is, it won’t work
    in an online multiplayer scenario because, currently, the method performs only
    local logic. So, let’s turn it into a method that will work for our improved online
    multiplayer checkers game.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都在`toggle_turn()`方法中发生，但就目前而言，它无法在线多人场景中工作，因为目前该方法仅执行本地逻辑。所以，让我们将其转换为一个适用于我们改进的在线多人跳棋游戏的方法。
- en: 'However, before that, let’s see how the code is right now so we can already
    pick where we will need to make adjustments:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在那之前，让我们看看代码目前的状况，这样我们就可以提前确定我们需要在哪里进行调整：
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This function is responsible for managing the turn-based logic of a game. It
    first clears the available cells for movements and then disables the pieces of
    both teams. Then, it checks whether there is a winner and, if so, emits a signal
    to the `CheckersGame` script’s `_on_checker_board_player_won()` method, indicating
    the winning team. If there is no winner, it switches the turn to the other team
    and enables the pieces of the corresponding team.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数负责管理游戏的回合逻辑。它首先清除可移动的可用单元格，然后禁用两队的棋子。然后，它检查是否有赢家，如果有，则向`CheckersGame`脚本的`_on_checker_board_player_won()`方法发出信号，指示获胜的团队。如果没有赢家，则将回合切换到另一队并启用相应团队的棋子。
- en: 'Can you point out where we need to make the necessary changes in order to make
    it work in our online version of the game? Remember that the game should work
    both locally and remotely, so we need to maintain the overall outcome of this
    method. Let’s begin the process:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你能指出我们需要在哪里进行必要的更改，以便使其在我们的游戏在线版本中工作吗？请记住，游戏应该本地和远程都能工作，因此我们需要保持此方法的整体结果。让我们开始这个过程：
- en: 'Decorate the `toggle_turn()` method with the `@rpc` annotation, using the `any_peer`
    and the `call_local` options. This indicates that any peer can call this method
    remotely in the multiplayer session, but they should also call it locally. This
    ensures that even if we are playing the game without joining a multiplayer session,
    we can call this method locally, using the `rpc()` method, and everything will
    still work:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`@rpc`注解装饰`toggle_turn()`方法，使用`any_peer`和`call_local`选项。这表示任何节点都可以在多人会话中远程调用此方法，但他们也应该本地调用它。这确保了即使我们没有加入多人会话玩游戏，我们也可以使用`rpc()`方法本地调用此方法，一切仍然会正常工作：
- en: '[PRE25]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Inside that, check whether the `current_turn` is `Teams.BLACK`; we are going
    to move `enable_pieces(white_team)` inside yet another check. This time, we are
    going to check whether we don’t have any peers connected, meaning we are playing
    the game alone or locally:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，检查`current_turn`是否为`Teams.BLACK`；我们将`enable_pieces(white_team)`移动到另一个检查中。这次，我们将检查是否没有连接的节点，这意味着我们是在单独或本地玩游戏：
- en: '[PRE26]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we are not playing the game locally, we need to check whether the current
    player is the WhiteTeam’s Multiplayer Authority, using the `multiplayer.get_unique_id()`
    method; if so, we can enable the **WhiteTeam** Pieces. And that’s how we ensure
    that only the correct player will have their Pieces re-enabled:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们不在本地玩游戏，我们需要检查当前玩家是否是WhiteTeam的多玩家权限，使用`multiplayer.get_unique_id()`方法；如果是，我们可以启用**WhiteTeam**的棋子。这就是我们确保只有正确的玩家才能重新启用他们的棋子的方法：
- en: '[PRE27]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We are going to do the same thing, but inside the `else` statement, which handles
    whether the `current_turn` was from `Teams.WHITE`:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要执行相同的事情，但是在`else`语句内部，这个语句处理的是`current_turn`是否来自`Teams.WHITE`：
- en: '[PRE28]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'With that, every time we call the `toggle_turn()` method, we are going to check
    whether the peer has authority over the current Pieces in play, and we only allow
    them to select the Pieces from their team. Now, we still need to make a small
    change in order for this to be compliant with our network requirements. In the
    `_free_cell_selected()` callback, let’s change the line that makes a direct call
    to the `toggle_turn()` method, making it a remote call using the `rpc()` method:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每次我们调用`toggle_turn()`方法时，我们都会检查对等方是否有权控制当前正在进行的`Pieces`，并且我们只允许他们从他们的队伍中选择`Pieces`。现在，我们还需要进行一个小改动，以便使其符合我们的网络要求。在`_free_cell_selected()`回调中，让我们更改直接调用`toggle_turn()`方法的行，改为使用`rpc()`方法进行远程调用：
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that the `can_capture()` method is responsible for checking whether there’s
    any enemy Piece around `selected_piece`, which can lead to a capture move. If
    this is the case, we call the `capture_pieces()` method, which will perform the
    capture movement on all possible enemy Pieces in the selected direction. Otherwise,
    if there’s no capture movement available, we perform a simple movement calling
    the `move_selected_piece()` method, passing around `free_cell` as an argument.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`can_capture()`方法负责检查在`selected_piece`周围是否有任何敌方棋子，这可能导致捕获移动。如果是这种情况，我们调用`capture_pieces()`方法，它将在选定的方向上对所有可能的敌方棋子执行捕获移动。否则，如果没有可用的捕获移动，我们将执行简单的移动，调用`move_selected_piece()`方法，并将`free_cell`作为参数传递。
- en: Now, every time a player selectes an available free cell to perform a move with
    a Piece, they will make a remote procedure call to `toggle_turn()`, telling all
    the connected peers to properly disable and re-enable their respective Pieces.
    Awesome, isn’t it?
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当玩家选择一个可用的空闲单元格来移动棋子时，他们将对`toggle_turn()`进行远程过程调用，告诉所有连接的对等方正确地禁用和重新启用他们各自的棋子。太棒了，不是吗？
- en: At this point, we have all the core mechanisms of our game in place, and we
    can play an online match with other players connected to our network. There’s
    only one thing missing. We still need to communicate over the network when a player
    wins a match and allow players to play again.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将游戏的所有核心机制都设置好了，我们可以与其他连接到我们网络的玩家进行在线比赛。唯一缺少的是，当玩家赢得比赛时，我们仍然需要在网络上进行通信，并允许玩家再次进行游戏。
- en: In the next section, we are going to create a simple mechanism to allow players
    to rematch after one of them won the match for good.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将创建一个简单的机制，允许玩家在其中一个玩家赢得比赛后进行重赛。
- en: Managing win and lose conditions
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理胜负条件
- en: Excellent! We have successfully completed the development of the CheckerBoard
    scene, and our game’s core functionalities are now in place. The next step is
    to transition the logic of the CheckersGame scene from local to remote gameplay.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们已经成功完成了CheckerBoard场景的开发，现在我们的游戏核心功能已经就绪。下一步是将CheckersGame场景的逻辑从本地游戏转变为远程游戏。
- en: To begin, let’s open the `res://06.building-online-checkers/CheckersGame.tscn`
    file and familiarize ourselves with its structure.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们打开`res://06.building-online-checkers/CheckersGame.tscn`文件，熟悉其结构。
- en: '![Figure 6.9 – The CheckersGame’s scene node hierarchy](img/Figure_06.09_B18527.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图6.9 – CheckersGame的场景节点层次结构](img/Figure_06.09_B18527.jpg)'
- en: Figure 6.9 – The CheckersGame’s scene node hierarchy
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 – CheckersGame的场景节点层次结构
- en: Take note that the CheckerBoard’s `player_won` signal is connected to the `CheckersGame._on_checker_board_player_won()`
    callback. This callback is responsible for handling situations when a player’s
    team has no remaining pieces on the board. Now, let’s proceed by opening the script
    for CheckersGame.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，CheckerBoard的`player_won`信号连接到`CheckersGame._on_checker_board_player_won()`回调。这个回调负责处理玩家队伍在棋盘上没有剩余棋子的情况。现在，让我们打开CheckersGame的脚本继续操作。
- en: 'We will be working on all the methods within the script, ensuring they are
    properly adjusted for online multiplayer functionality:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将处理脚本中的所有方法，确保它们适合在线多人游戏功能进行适当调整：
- en: First of all, let’s add the `@rpc` annotation to the `update_winner()` method
    with the `any_peer` and `call_local` options.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们给 `update_winner()` 方法添加 `@rpc` 注解，并使用 `any_peer` 和 `call_local` 选项。
- en: '[PRE30]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, we are going to do the same thing with the `rematch()` method. This one
    is called by RematchButton’s `pressed` method:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将对 `rematch()` 方法做同样的处理。这个方法是由重赛按钮的 `pressed` 方法调用的：
- en: '[PRE31]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we need to call these methods remotely, using the `rpc()` method instead
    of directly calling them in `CheckersGame`. Let’s do that in `_on_checker_board_player_won()`,
    turning the `update_winner(winner)` into `rpc("update_winner", winner)` instead.
    This is the method that the CheckerBoard’s `player_won signals` is connected to:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要使用 `rpc()` 方法远程调用这些方法，而不是直接在 `CheckersGame` 中调用它们。让我们在 `_on_checker_board_player_won()`
    中这样做，将 `update_winner(winner)` 转换为 `rpc("update_winner", winner)`。这是 CheckerBoard
    的 `player_won signals` 连接到的方法：
- en: '[PRE32]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Lastly, we do the same thing with `_on_rematch_button_pressed()`, turning the
    `rematch()` call into `rpc("rematch")`. This is the method that`pressed` signal
    of **RematchButton** connects to, so when players press the button, this is what
    should happen:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们对 `_on_rematch_button_pressed()` 也进行同样的操作，将 `rematch()` 调用转换为 `rpc("rematch")`。这是
    `RematchButton` 的 `pressed` 信号连接到的方法，因此当玩家按下按钮时，应该发生以下操作：
- en: '[PRE33]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With the adjustments we’ve made, our game is now fully equipped to run smoothly,
    whether it’s played locally or remotely. When a player successfully captures their
    opponent’s pieces, the game will transition all peers into a rematch state, where
    any peer can initiate a new match and start a fresh game. This ensures that players
    have the option to engage in continuous gameplay sessions without the need to
    exit and restart the game manually.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 经过我们做出的调整，我们的游戏现在已经完全准备好，无论是本地还是远程玩都能流畅运行。当一名玩家成功捕获对手的棋子时，游戏将把所有玩家过渡到重赛状态，任何玩家都可以发起新的比赛并开始新的游戏。这确保了玩家可以选择参与连续的游戏会话，而无需手动退出和重新启动游戏。
- en: '![Figure 6.10 – The CheckersGame rematch screen](img/Figure_06.10_B18527.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.10 – CheckersGame 重赛屏幕](img/Figure_06.10_B18527.jpg)'
- en: Figure 6.10 – The CheckersGame rematch screen
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 – CheckersGame 重赛屏幕
- en: Our game is finally working! We have a fully functional checkers game that players
    can play online and challenge each other playing multiple matches.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏终于可以工作了！我们有一个完全功能齐全的国际象棋游戏，玩家可以在线玩并挑战彼此进行多轮比赛。
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: To recap, in this chapter, we introduced the `MultiplayerSynchronizer` node
    to synchronize properties across a network, established the concept of abstraction
    for effective data transmission, utilized the `@rpc` annotations to enable multiplayer
    functionality, and learned how to assign and manage Multiplayer Authority to ensure
    player autonomy and resource protection.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，在本章中，我们介绍了 `MultiplayerSynchronizer` 节点以在网络中同步属性，建立了有效数据传输的抽象概念，利用 `@rpc`
    注解启用多人游戏功能，并学习了如何分配和管理多人权限以确保玩家自主权和资源保护。
- en: In the upcoming chapter, we will see how to develop an online Pong game. There,
    we will cover the modifications necessary to turn the local game into an online
    multiplayer one, setting up online multiplayer paddles, syncing remote objects
    in real time, and coordinating the paddle’s position. For that, will use the `MultiplayerSynchronizer`
    node with a bit more depth than we did in this chapter. Also, we will talk about
    the importance of maintaining a shared game world for players in action-based
    games, which is very different from turn-based games.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何开发在线乒乓球游戏。在那里，我们将介绍将本地游戏转换为在线多人游戏所需的修改，设置在线多人游戏拍子，实时同步远程对象，以及协调拍子的位置。为此，我们将使用比本章更深入的
    `MultiplayerSynchronizer` 节点。此外，我们还将讨论在动作游戏中维护共享游戏世界对玩家的重要性，这与回合制游戏非常不同。
