- en: '18'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '18'
- en: Using Gameplay Framework Classes in Multiplayer
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在多人游戏中使用游戏框架类
- en: In the previous chapter, we covered **remote procedure calls** (**RPCs**), which
    allow the server and the clients to execute remote functions on each other. We
    also covered enumerations and array index wrapping, which allow you to iterate
    an array in both directions and loop around when you go beyond its limits.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了**远程过程调用**（**RPCs**），它允许服务器和客户端在对方上执行远程函数。我们还介绍了枚举和数组索引包装，这允许你以两个方向迭代数组，并在超出其限制时循环。
- en: In this chapter, we’re going to look at the most common gameplay framework classes
    and see where their instances exist in a multiplayer environment. This is important
    to understand so that you know which instances can be accessed in a specific game
    instance. An example of this is that only the server should be able to access
    the game mode instance because you don’t want clients to be able to modify the
    rules of the game.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨最常见的一些游戏框架类，并查看它们的实例在多人环境中的位置。了解这一点很重要，这样你才知道在特定的游戏实例中可以访问哪些实例。例如，只有服务器应该能够访问游戏模式实例，因为你不希望客户端能够修改游戏规则。
- en: We’ll also cover the game state and player state classes, which, as their names
    imply, store information about the state of the game and each player, respectively.
    Finally, toward the end of this chapter, we’ll cover some new concepts in the
    game mode, as well as some useful built-in functionality.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将介绍游戏状态和玩家状态类，正如其名称所暗示的，分别存储有关游戏状态和每个玩家状态的信息。最后，在本章末尾，我们将介绍游戏模式中的某些新概念，以及一些有用的内置功能。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Accessing Gameplay Framework instances in multiplayer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多人游戏中访问游戏框架实例
- en: Using Game Mode, Player State, and Game State
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用游戏模式、玩家状态和游戏状态
- en: By the end of this chapter, you’ll understand where the instances of the most
    important Gameplay Framework classes exist in multiplayer, as well as how the
    game state and player state store information that can be accessed by any client.
    You’ll also know how to make the most out of the Game Mode class and other useful
    built-in functionality.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解最重要的游戏框架类实例在多人游戏中的位置，以及游戏状态和玩家状态如何存储任何客户端都可以访问的信息。你还将了解如何充分利用游戏模式类和其他有用的内置功能。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter has the following technical requirements:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有以下技术要求：
- en: Unreal Engine 5 installed
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装 Unreal Engine 5
- en: Visual Studio 2019 installed
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装 Visual Studio 2019
- en: 'The project for this chapter can be found in the `Chapter18` folder of the
    code bundle for this book, which can be downloaded here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目可以在本书代码包的`Chapter18`文件夹中找到，该代码包可以在此处下载：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition)。
- en: In the next section, we will learn how to access the gameplay framework instances
    in multiplayer.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何在多人游戏中访问游戏框架实例。
- en: Accessing Gameplay Framework Instances in Multiplayer
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在多人游戏中访问游戏框架实例
- en: 'Unreal Engine comes with a set of built-in classes (the Gameplay Framework)
    that provide the common functionality that most games require, such as a way to
    define the game rules (game mode), a way to control a character (the player controller
    and pawn/character class), and so on. When an instance of a gameplay framework
    class is created in a multiplayer environment, we need to know if it exists on
    the server, the clients, or the owning client. With that in mind, an instance
    of the gameplay framework class will always fall into one of the following categories:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal Engine 随带一套内置类（游戏框架），它提供了大多数游戏所需的基本功能，例如定义游戏规则（游戏模式）的方法、控制角色（玩家控制器和兵/角色类）的方法等。当在多人环境中创建游戏框架类的实例时，我们需要知道它是否存在于服务器、客户端或拥有客户端。考虑到这一点，游戏框架类的实例将始终属于以下类别之一：
- en: '**Server Only**: The instance will only exist on the server.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅服务器**：实例仅存在于服务器上。'
- en: '**Server and Clients**: The instance will exist on the server and the clients.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器和客户端**：实例将存在于服务器和客户端上。'
- en: '**Server and Owning Client**: The instance will exist on the server and the
    owning client.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器和拥有客户端**: 实例将存在于服务器和拥有客户端上。'
- en: '**Owning Client Only**: The instance will only exist on the owning client.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅客户端拥有**: 实例仅存在于拥有客户端上。'
- en: 'Take a look at the following diagram, which shows each category and where the
    most common classes in the gameplay framework fall into:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下图表，它显示了每个类别以及游戏框架中最常见的类属于哪个类别：
- en: '![Figure 18.1 – The most common gameplay framework classes divided into categories
    ](img/Figure_18.01_B18531.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.1 – 最常见的游戏框架类按类别划分](img/Figure_18.01_B18531.jpg)'
- en: Figure 18.1 – The most common gameplay framework classes divided into categories
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.1 – 最常见的游戏框架类按类别划分
- en: 'Let’s look at each class in the preceding diagram in more detail:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地查看前面图中的每个类别：
- en: '`Game Mode` class defines the rules of the game and its instance can only be
    accessed by the server. If a client tries to access it, the instance will always
    be invalid, to prevent clients from changing the game rules.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Game Mode` 类定义了游戏的规则，其实例只能由服务器访问。如果客户端尝试访问它，实例始终无效，以防止客户端更改游戏规则。'
- en: '**Game State (Server and Clients)**: The Game State class stores the state
    of the game and its instance can be accessed both by the server and the clients.
    The game state will be covered in greater depth in the next topic.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏状态（服务器和客户端）**: 游戏状态类存储游戏的状态，其实例可以被服务器和客户端访问。游戏状态将在下一主题中更深入地介绍。'
- en: '**Player State (Server and Clients)**: The Player State class stores the state
    of a player and its instance can be accessed both by the server and the clients.
    The player state will be covered in greater depth in the next topic.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玩家状态（服务器和客户端）**: 玩家状态类存储玩家的状态，其实例可以被服务器和客户端访问。玩家状态将在下一主题中更深入地介绍。'
- en: '`Pawn` class is the visual representation of a player and its instance can
    be accessed by the server and the clients.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pawn` 类是玩家的视觉表示，其实例可以被服务器和客户端访问。'
- en: '`Player Controller` class represents the intent of a player, which is relayed
    to the currently possessed pawn, and its instance can only be accessed on the
    server and the owning client. For security reasons, clients can’t access other
    clients’ player controllers, so they should use the server to communicate. If
    a client calls the `UGameplayStatics::GetPlayerController` function with an index
    other than `0` (which would return its player controller), the returned instance
    will always be invalid. This means that the server is the only place that has
    access to all of the player controllers. You can find out whether a player controller
    instance is in its owning client by calling the `AController::IsLocalController`
    function.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Player Controller` 类代表玩家的意图，该意图被传递到当前拥有的 `Pawn`，其实例只能在服务器和拥有客户端上访问。出于安全原因，客户端不能访问其他客户端的玩家控制器，因此它们应该使用服务器进行通信。如果客户端调用
    `UGameplayStatics::GetPlayerController` 函数的索引不是 `0`（这将返回其玩家控制器），则返回的实例始终无效。这意味着服务器是唯一可以访问所有玩家控制器的地方。您可以通过调用
    `AController::IsLocalController` 函数来找出玩家控制器实例是否在其拥有客户端上。'
- en: '**HUD (Owning Client Only)**: The HUD class is used as an immediate mode to
    draw basic shapes and text on the screen. Since it’s used for the UI, its instance
    is only available on the owning client, because the server and the other clients
    don’t need to know about it.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HUD（仅客户端拥有）**: HUD 类用作立即模式在屏幕上绘制基本形状和文本。由于它用于 UI，其实例仅在拥有客户端上可用，因为服务器和其他客户端不需要了解它。'
- en: '**UMG Widgets (Owning Client Only)**: The UMG widget classes are used to display
    complex UI on the screen. Since it’s used for the UI, its instance is only available
    on the owning client, because the server and the other clients don’t need to know
    about it.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UMG 小部件（仅客户端拥有）**: UMG 小部件类用于在屏幕上显示复杂的 UI。由于它用于 UI，其实例仅在拥有客户端上可用，因为服务器和其他客户端不需要了解它。'
- en: 'To help you understand these concepts, we will use *Dota 2* as an example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您理解这些概念，我们将以 *Dota 2* 为例：
- en: The game mode defines that there are different phases of the game (pre-game
    for hero picking, the actual game, and the post-game phase with the winner) and
    that the end goal is to destroy the other team’s ancient. Since the game mode
    is a class that is critical to gameplay, clients can’t be allowed to access it.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏模式定义了游戏的不同阶段（英雄选择前的预游戏阶段、实际游戏和带有胜利者的后游戏阶段）以及最终目标是摧毁另一队的古墓。由于游戏模式是一个对游戏至关重要的类，因此不允许客户端访问它。
- en: The game state stores the elapsed time, whether it’s day or night, the score
    of each team, and so on, so the server and the clients need to be able to access
    it.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏状态存储了经过的时间、是白天还是夜晚、每个队伍的分数等，因此服务器和客户端需要能够访问它。
- en: The player state stores the name, the hero selected, and the kill/death/assist
    ratio of a player, so the server and the clients need to be able to access it.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家状态存储了玩家的姓名、所选的英雄以及玩家的击杀/死亡/助攻比率，因此服务器和客户端需要能够访问它。
- en: The pawn would be the hero, the courier, the illusions, and so on, controlled
    by the player, so the server and the clients need to be able to access it.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兵棋将是英雄、信使、幻象等，由玩家控制，因此服务器和客户端需要能够访问它。
- en: The player controller is what relays the input information to the controlled
    pawn, so only the server and the owning client need to be able to access it.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家控制器是将输入信息传递给受控兵棋的信息中继器，因此只有服务器和拥有客户端需要能够访问它。
- en: The UI classes (`HUD` and `User Widget`) display all of the information on the
    owning client, so it only needs to be accessed there.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI类（`HUD`和`User Widget`）在拥有客户端上显示所有信息，因此它只需要在那里访问。
- en: In the next exercise, you will display the instance values of the most common
    gameplay framework classes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，你将显示最常见的游戏框架类的实例值。
- en: Exercise 18.01 – Displaying the Gameplay Framework instance values
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习18.01 – 显示游戏框架实例值
- en: 'In this exercise, we’re going to create a new C++ project that uses the **Third
    Person** template, and we’re going to add the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个新的使用**第三人称**模板的C++项目，并且我们将添加以下内容：
- en: On the owning client, the player controller creates and adds a simple UMG widget
    to the viewport that displays the name of the menu instance.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在拥有客户端上，玩家控制器创建并添加一个简单的UMG小部件到视图中，显示菜单实例的名称。
- en: On the `Tick` function, the character displays the value of its instance (as
    a pawn), as well as whether it has a valid instance for the game mode, game state,
    player state, player controller, and HUD.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Tick`函数中，角色显示其实例（作为兵棋）的值，以及它是否有有效的游戏模式、游戏状态、玩家状态、玩家控制器和HUD实例。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: Create a new `GFInstances` (as in Gameplay Framework Instances) and save it
    to a location of your liking. Once the project has been created, it should open
    the editor as well as the Visual Studio solution.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`GFInstances`（如游戏框架实例）并将其保存到你喜欢的位置。一旦项目创建完成，它应该会打开编辑器以及Visual Studio解决方案。
- en: In the editor, create a new `C++` class called `GFInstancePlayerController`
    that derives from `PlayerController`. Wait for the compilation to end, close the
    editor, and go back to Visual Studio.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，创建一个新的名为`GFInstancePlayerController`的`C++`类，它从`PlayerController`派生。等待编译结束，关闭编辑器，然后回到Visual
    Studio。
- en: 'Open the `GFInstancesCharacter.h` file and declare the protected override for
    the `Tick` function:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GFInstancesCharacter.h`文件并声明`Tick`函数的受保护重写：
- en: '[PRE0]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Open the `GFInstancesCharacter.cpp` file and implement the `Tick` function:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GFInstancesCharacter.cpp`文件并实现`Tick`函数：
- en: '[PRE1]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Get the instances for the game mode, game state, player controller, and HUD:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取游戏模式、游戏状态、玩家控制器和HUD的实例：
- en: '[PRE2]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code snippet, we stored the instances for the game mode, game
    state, player controller, and HUD in separate variables so that we can check whether
    they are valid.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们将游戏模式、游戏状态、玩家控制器和HUD的实例存储在不同的变量中，以便我们可以检查它们是否有效。
- en: 'Create a string for each gameplay framework class:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个游戏框架类创建一个字符串：
- en: '[PRE3]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we have created strings to store the name of the pawn and checked whether
    the other gameplay framework instances are valid.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了字符串来存储兵棋的名称，并检查了其他游戏框架实例是否有效。
- en: 'Display each string on the screen:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕上显示每个字符串：
- en: '[PRE4]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code snippet, we have printed the strings that indicate the
    name of the pawn and whether the other gameplay framework instances are valid.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们打印了指示兵棋名称以及其他游戏框架实例是否有效的字符串。
- en: 'Before we can move on to the `AGFInstancesPlayerController` class, we need
    to tell Unreal Engine that we want to use the UMG functionality so that we can
    use the `UUserWidget` class. To do this, we need to open `GFInstances.Build.cs`
    and add `UMG` to the `PublicDependencyModuleNames` string array, like so:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们可以继续到`AGFInstancesPlayerController`类之前，我们需要告诉Unreal Engine我们想要使用UMG功能，这样我们就可以使用`UUserWidget`类。为此，我们需要打开`GFInstances.Build.cs`并将`UMG`添加到`PublicDependencyModuleNames`字符串数组中，如下所示：
- en: '[PRE5]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you try to compile and get errors from adding the new module, then clean
    and recompile your project. If that doesn’t work, try restarting your IDE.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试编译并从添加新模块中获取错误，那么清理并重新编译你的项目。如果这不起作用，尝试重新启动你的IDE。
- en: 'Open `GFInstancesPlayerController.h` and add the protected variables to create
    the UMG widget:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GFInstancesPlayerController.h`并添加受保护变量以创建UMG小部件：
- en: '[PRE6]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Declare the protected override for the `BeginPlay` function:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`BeginPlay`函数的受保护覆盖：
- en: '[PRE7]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Open `GFInstancesPlayerController.cpp` and include `UserWidget.h`:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GFInstancesPlayerController.cpp`并包含`UserWidget.h`：
- en: '[PRE8]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Implement the `BeginPlay` function:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现的`BeginPlay`函数：
- en: '[PRE9]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create the widget and add it to the viewport if it’s a local controller and
    the `MenuClass` variable is valid:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是本地控制器且`MenuClass`变量有效，则创建小部件并将其添加到视图中：
- en: '[PRE10]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Compile and run the code.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行代码。
- en: In the `Content` folder, create a new folder called `UI`, and open it.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content`文件夹中，创建一个名为`UI`的新文件夹，并打开它。
- en: Create a new widget blueprint called `WBP_Menu` and open it.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的小部件蓝图`WBP_Menu`并打开它。
- en: Add a `Canvas Panel` to the **Hierarchy** panel.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中添加一个`Canvas Panel`。
- en: Add a `Name` to the **canvas panel** and set it to be a variable.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给**画布面板**添加一个`Name`，并将其设置为变量。
- en: Change the text block `true`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本块`true`更改。
- en: 'Go to the `Event Construct` in the following manner:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以以下方式前往`Event Construct`：
- en: '![Figure 18.2 – The Event Construct that displays the name of the WBP_Menu
    instance ](img/Figure_18.02_B18531.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图18.2 – 显示WBP_Menu实例名称的事件构造](img/Figure_18.02_B18531.jpg)'
- en: Figure 18.2 – The Event Construct that displays the name of the WBP_Menu instance
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.2 – 显示WBP_Menu实例名称的事件构造
- en: Save and close `WBP_Menu`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭`WBP_Menu`。
- en: Go to the `Content` folder and create a blueprint called `BP_PlayerController`
    that derives from `GFInstancesPlayerController`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`Content`文件夹，创建一个名为`BP_PlayerController`的蓝图，它继承自`GFInstancesPlayerController`。
- en: Open `BP_PlayerController` and set `Menu Class` to use `WBP_Menu`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BP_PlayerController`并将`Menu Class`设置为使用`WBP_Menu`。
- en: Save and close `BP_PlayerController`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭`BP_PlayerController`。
- en: Create a blueprint called `BP_GameMode` that derives from `GFInstancesGameMode`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`BP_GameMode`的蓝图，它继承自`GFInstancesGameMode`。
- en: Open `BP_GameMode` and set `Player Controller Class` to use `BP_PlayerController`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BP_GameMode`并将`Player Controller Class`设置为使用`BP_PlayerController`。
- en: Save and close `BP_GameMode`.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭`BP_GameMode`。
- en: Go to **World Settings**, set **GameMode Override** to **None**, and save the
    map.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**世界设置**，将**游戏模式覆盖**设置为**无**，并保存地图。
- en: Go to **Project Settings** and pick **Maps & Modes** from the left panel, which
    can be found in the **Project** category.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**项目设置**，从左侧面板中选择**地图和模式**，它位于**项目**类别中。
- en: Set the `Default` Game Mode to use `BP_GameMode`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`默认`游戏模式设置为使用`BP_GameMode`。
- en: Close **Project Settings**.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭**项目设置**。
- en: Finally, you can test the project.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以测试项目。
- en: Go to `2`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`2`。
- en: Set the window sizes to `800x600` and play using **New Editor Window (PIE)**.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将窗口大小设置为`800x600`，并使用**新编辑器窗口（PIE）**进行游戏。
- en: 'You should get the following output:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 18.3 – Expected result on the Server and Client 1 windows ](img/Figure_18.03_B18531.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图18.3 – 服务器和客户端1窗口上的预期结果](img/Figure_18.03_B18531.jpg)'
- en: Figure 18.3 – Expected result on the Server and Client 1 windows
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.3 – 服务器和客户端1窗口上的预期结果
- en: Now that you’ve completed this exercise, you’ll notice that each character displays
    its name, as well as if the instances for the game mode, game state, player state,
    player controller, and HUD are valid. It also displays the instance name of the
    `WBP_Menu` UMG widget in the top-left corner of the screen.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了这个练习，你会注意到每个角色都会显示其名称，以及游戏模式、游戏状态、玩家状态、玩家控制器和HUD实例是否有效。它还会在屏幕左上角显示`WBP_Menu`
    UMG小部件的实例名称。
- en: Now, let’s analyze the values that are displayed in the Server and Client 1
    windows.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们分析在服务器和客户端1窗口中显示的值。
- en: Note
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The two figures for the Server and Client 1 window will have two text blocks
    that say `Server Character` and `Client 1 Character`. These were added to the
    original screenshot to help you understand which character is which.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器和客户端1窗口的两个图将有两个文本块，分别写着`Server Character`和`Client 1 Character`。这些文本块被添加到原始截图中以帮助您理解哪个角色是哪个。
- en: Output for the Server window
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器窗口输出
- en: 'Have a look at the following output of the `Server` window from the previous
    exercise:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下输出，这是之前练习中的`Server`窗口：
- en: '![Figure 18.4 – The Server window ](img/Figure_18.04_B18531.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图18.4 – 服务器窗口](img/Figure_18.04_B18531.jpg)'
- en: Figure 18.4 – The Server window
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.4 – 服务器窗口
- en: In the preceding screenshot, you have the values for `Server Character` and
    `Client 1 Character`. The `WBP_Menu` UMG widget is displayed in the top-left corner
    and is only created for the player controller of `Server Character` since it’s
    the only player controller in this window that controls a character.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图上，你可以看到 `服务器角色` 和 `Client 1 角色` 的值。`WBP_Menu` UMG 小部件显示在左上角，并且只为 `服务器角色`
    的玩家控制器创建，因为它是这个窗口中唯一控制角色的玩家控制器。
- en: First, let’s analyze the values for `Server Character`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们分析 `服务器角色` 的值。
- en: Server Character
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器角色
- en: 'This is the character that the listen server is controlling. The values that
    are displayed on this character are as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是监听服务器正在控制的角色。显示在这个角色上的值如下：
- en: '**Game Mode = Valid** because the game mode instance only exists in the server,
    which is the case here'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏模式 = Valid** 因为游戏模式实例仅存在于服务器，而这在这里正是如此'
- en: '**Game State = Valid** because the game state instance exists on the clients
    and the server, which is the case here'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏状态 = Valid** 因为游戏状态实例存在于客户端和服务器，而这在这里正是如此'
- en: '**Player State = Valid** because the player state instance exists on the clients
    and the server, which is the case here'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玩家状态 = Valid** 因为玩家状态实例存在于客户端和服务器，而这在这里正是如此'
- en: '**Pawn = BP_ThirdPersonCharacter_C_0** because pawn instances exist on the
    clients and the server, which is the case here'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NPC = BP_ThirdPersonCharacter_C_0** 因为 NPC 实例存在于客户端和服务器，而这在这里正是如此'
- en: '**Player Controller = Valid** because player controller instances exist on
    the owning client and the server, which is the case here'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玩家控制器 = Valid** 因为玩家控制器实例存在于拥有客户端和服务器，而这在这里正是如此'
- en: '**HUD = Valid** because HUD instances only exist on the owning client, which
    is the case here'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HUD = Valid** 因为 HUD 实例仅存在于拥有客户端，而这里正是如此'
- en: Next, we are going to look at `Client 1 Character` in the same window.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看同一窗口中的 `Client 1 角色`。
- en: Client 1 Character
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Client 1 角色
- en: 'This is the character that `Client 1` is controlling. The values that are displayed
    on this character are as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Client 1` 正在控制的角色。显示在这个角色上的值如下：
- en: '**Game Mode = Valid** because the game mode instance only exists in the server,
    which is the case here'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏模式 = Valid** 因为游戏模式实例仅存在于服务器，而这在这里正是如此'
- en: '**Game State = Valid** because the game state instance exists on the clients
    and the server, which is the case here'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏状态 = Valid** 因为游戏状态实例存在于客户端和服务器，而这在这里正是如此'
- en: '**Player State = Valid** because the player state instance exists on the clients
    and the server, which is the case here'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玩家状态 = Valid** 因为玩家状态实例存在于客户端和服务器，而这在这里正是如此'
- en: '**Pawn = BP_ThirdPersonCharacter_C_1** because pawn instances exist on the
    clients and the server, which is the case here'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NPC = BP_ThirdPersonCharacter_C_1** 因为 NPC 实例存在于客户端和服务器，而这在这里正是如此'
- en: '**Player Controller = Valid** because player controller instances exist on
    the owning client and the server, which is the case here'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玩家控制器 = Valid** 因为玩家控制器实例存在于拥有客户端和服务器，而这在这里正是如此'
- en: '**HUD = Invalid** because HUD instances only exist on the owning client, which
    is not the case here'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HUD = Invalid** 因为 HUD 实例仅存在于拥有客户端，而这在这里并不适用'
- en: Output for the Client 1 window
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Client 1 窗口的输出
- en: 'Have a look at the following output of the `Client 1` window from the previous
    exercise:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下来自上一个练习的 `Client 1` 窗口的输出：
- en: '![Figure 18.5 – The Client 1 window ](img/Figure_18.05_B18531.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.5 – Client 1 窗口](img/Figure_18.05_B18531.jpg)'
- en: Figure 18.5 – The Client 1 window
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.5 – Client 1 窗口
- en: In the preceding screenshot, you have the values for `Client 1 Character` and
    `Server Character`. The `WBP_Menu` UMG widget is displayed in the top-left corner
    and is only created for the player controller of `Client 1 Character` since it’s
    the only player controller in this window that controls a character.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图上，你可以看到 `Client 1 角色` 和 `服务器角色` 的值。`WBP_Menu` UMG 小部件显示在左上角，并且只为 `Client
    1 角色` 的玩家控制器创建，因为它是这个窗口中唯一控制角色的玩家控制器。
- en: First, let’s analyze the values for `Client 1 Character`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们分析 `Client 1 角色` 的值。
- en: Client 1 Character
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Client 1 角色
- en: 'This is the character that `Client 1` is controlling. The values that are displayed
    on this character are as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Client 1` 正在控制的角色。显示在这个角色上的值如下：
- en: '**Game Mode = Invalid** because the game mode instance only exists in the server,
    which is not the case here'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏模式 = Invalid** 因为游戏模式实例仅存在于服务器，而这在这里并不适用'
- en: '**Game State = Valid** because the game state instance exists on the server
    and the clients, which is the case here'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏状态 = 有效** 因为游戏状态实例存在于服务器和客户端上，这里就是这种情况'
- en: '**Player State = Valid** because the player state instance exists on the server
    and the clients, which is the case here'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玩家状态 = 有效** 因为玩家状态实例存在于服务器和客户端上，这里就是这种情况'
- en: '**Pawn = BP_ThirdPersonCharacter_C_0** because pawn instances exist on the
    server and the clients, which is the case here'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**兵 = BP_ThirdPersonCharacter_C_0** 因为兵实例存在于服务器和客户端上，这里就是这种情况'
- en: '**Player Controller = Valid** because player controller instances exist on
    the server and the owning client, which is the case here'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玩家控制器 = 有效** 因为玩家控制器实例存在于服务器和拥有客户端上，这里就是这种情况'
- en: '**HUD = Valid** because HUD instances only exist on the owning client, which
    is the case here'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HUD = 有效** 因为HUD实例仅存在于拥有客户端上，这里就是这种情况'
- en: Next, we are going to look at `Server Character` in the same window.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在同一窗口中查看`服务器角色`。
- en: Server Character
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器角色
- en: 'This is the character that the listen server controls. The values that are
    displayed on this character are as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是监听服务器所控制的角色。显示在此角色上的值如下：
- en: '**Game Mode = Invalid** because the game mode instance only exists in the server,
    which is not the case here'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏模式 = 无效** 因为游戏模式实例仅存在于服务器上，这里不是这种情况'
- en: '**Game State = Valid** because the game state instance exists on the server
    and the clients, which is the case here'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏状态 = 有效** 因为游戏状态实例存在于服务器和客户端上，这里就是这种情况'
- en: '**Player State = Valid** because the player state instance exists on the server
    and the clients, which is the case here'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玩家状态 = 有效** 因为玩家状态实例存在于服务器和客户端上，这里就是这种情况'
- en: '**Pawn = BP_ThirdPersonCharacter_C_1** because pawn instances exist on the
    server and the clients, which is the case here'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**兵 = BP_ThirdPersonCharacter_C_1** 因为兵实例存在于服务器和客户端上，这里就是这种情况'
- en: '**Player Controller = Invalid** because player controller instances exist on
    the server and the owning client, which is not the case here'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玩家控制器 = 无效** 因为玩家控制器实例存在于服务器和拥有客户端上，这里不是这种情况'
- en: '**HUD = Invalid** because HUD instances only exist on the owning client, which
    is not the case here'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HUD = 无效** 因为HUD实例仅存在于拥有客户端上，这里不是这种情况'
- en: By completing this exercise, you should have a better understanding of where
    each instance of the gameplay framework class exists and where it doesn’t. In
    the next section, we’re going to cover the player state and game state classes,
    as well as some additional concepts regarding the game mode and useful built-in
    functionalities.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你应该对游戏框架类中的每个实例存在于哪里以及不存在于哪里有更好的理解。在下一节中，我们将介绍玩家状态和游戏状态类，以及与游戏模式相关的额外概念和有用的内置功能。
- en: Using Game Mode, Player State, and Game State
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用游戏模式、玩家状态和游戏状态
- en: So far, we’ve covered most of the important classes in the gameplay framework,
    including the game mode, player controller, and the pawn. In this section, we’re
    going to cover the player state, game state, and some additional concepts regarding
    the game mode, as well as some useful built-in functionalities.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了游戏框架中的大多数重要类，包括游戏模式、玩家控制器和兵。在本节中，我们将介绍玩家状态、游戏状态以及与游戏模式相关的一些额外概念，以及一些有用的内置功能。
- en: Game mode
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏模式
- en: We’ve already talked about the game mode and how it works, but there are a few
    concepts that are useful to know about. Let’s take a look.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过游戏模式及其工作原理，但还有一些概念是值得了解的。让我们来看看。
- en: Constructor
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数
- en: 'To set the default class values, you can use a constructor like so:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置默认类值，你可以使用如下构造函数：
- en: '[PRE11]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code lets you specify which classes to use when spawning pawns,
    player controllers, player states, and game states when we are using this game
    mode.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码允许你在使用此游戏模式时指定在生成兵、玩家控制器、玩家状态和游戏状态时要使用的类。
- en: Getting the game mode instance
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取游戏模式实例
- en: 'If you want to access the game mode instance, you need to get it from the `GetWorld`
    function by using the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要访问游戏模式实例，你需要通过以下代码从`GetWorld`函数中获取它：
- en: '[PRE12]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code allows you to access the current game mode instance, but
    you have to make sure that you are calling it on the server since this will be
    invalid on the clients due to security reasons.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码允许你访问当前的游戏模式实例，但你必须确保你在服务器上调用它，因为由于安全原因，在客户端上这将无效。
- en: Match states
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比赛状态
- en: 'So far, we’ve only been using the `AGameModeBase` class, which is the most
    basic game mode class in the framework. Although it’s more than enough for certain
    types of games, there will be cases where you will require a bit more functionality.
    An example of this would be if we wanted to do a lobby system, where the match
    only starts if all the players have marked that they are ready. This example wouldn’t
    be possible to do with just the built-in function of the `AGameModeBase` class.
    For these cases, it’s better to use the `AGameMode` class instead, which is a
    child class of `AGameModeBase` that adds support for match states. The way match
    states work is by using a state machine that can only be in one of the following
    states at a given time:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用了 `AGameModeBase` 类，这是框架中最基本的游戏模式类。虽然它对于某些类型的游戏来说已经足够，但仍然会有需要更多功能的情况。一个例子是如果我们想要实现一个大厅系统，只有当所有玩家都标记为已准备好时，比赛才会开始。仅使用
    `AGameModeBase` 类的内置函数是无法实现这个例子的。对于这些情况，最好使用 `AGameMode` 类，它是 `AGameModeBase`
    的子类，增加了对比赛状态的支持。比赛状态的工作方式是通过使用只能处于以下状态之一的状态机：
- en: '`EnteringMap`: This is the starting state when the world is still loading and
    the actors aren’t ticking yet. It will transition to the `WaitingToStart` state
    once the world finishes loading.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EnteringMap`：这是世界仍在加载且演员尚未计时时的起始状态。一旦世界加载完成，它将转换到 `WaitingToStart` 状态。'
- en: '`WaitingToStart`: This state is set when the world has finished loading and
    the actors are ticking, although the pawns for the players won’t be spawned because
    the game hasn’t started yet. When the state machine enters this state, it will
    call the `HandleMatchIsWaitingToStart` function. The state machine will transition
    to the `InProgress` state if the `ReadyToStartMatch` function returns `true` or
    if the `StartMatch` function is called somewhere in the code.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WaitingToStart`：当世界加载完成且演员正在计时，但玩家的兵种尚未生成，因为游戏尚未开始时，此状态被设置。当状态机进入此状态时，它将调用
    `HandleMatchIsWaitingToStart` 函数。如果 `ReadyToStartMatch` 函数返回 `true` 或在代码的某处调用了
    `StartMatch` 函数，状态机将转换到 `InProgress` 状态。'
- en: '`InProgress`: This state is where the actual game takes place. When the state
    machine enters this state, it will spawn the pawns for the players, call `BeginPlay`
    on all of the actors in the world, and call the `HandleMatchHasStarted` function.
    The state machine will transition to the `WaitingPostMatch` state if the `ReadyToEndMatch`
    function returns `true` or if the `EndMatch` function is called somewhere in the
    code.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InProgress`：这是实际游戏发生的状态。当状态机进入此状态时，它将为玩家生成兵种，在世界上所有演员上调用 `BeginPlay`，并调用 `HandleMatchHasStarted`
    函数。如果 `ReadyToEndMatch` 函数返回 `true` 或在代码的某处调用了 `EndMatch` 函数，状态机将转换到 `WaitingPostMatch`
    状态。'
- en: '`WaitingPostMatch`: This state is set when the match ends. When the state machine
    enters this state, it will call the `HandleMatchHasEnded` function. In this state,
    actors still tick, but new players cannot join. It will transition to the `LeavingMap`
    state when it starts unloading the world.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WaitingPostMatch`：当比赛结束时设置此状态。当状态机进入此状态时，它将调用 `HandleMatchHasEnded` 函数。在此状态下，演员仍在计时，但新玩家无法加入。当开始卸载世界时，它将转换到
    `LeavingMap` 状态。'
- en: '`LeavingMap`: This state is set while it’s unloading the world. When the state
    machine enters this state, it will call the `HandleLeavingMap` function. The state
    machine will transition to the `EnteringMap` state when it starts loading the
    new level.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LeavingMap`：在卸载世界时设置此状态。当状态机进入此状态时，它将调用 `HandleLeavingMap` 函数。当开始加载新关卡时，状态机将转换到
    `EnteringMap` 状态。'
- en: '`Aborted`: This is a failed state that can only be set by calling the `AbortMatch`
    function, which is used to flag that something went wrong that prevented the match
    from happening.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Aborted`：这是一个失败状态，只能通过调用 `AbortMatch` 函数来设置，该函数用于标记发生了某些错误，阻止比赛进行。'
- en: 'To help you understand these concepts better, we can use *Dota 2* again as
    an example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您更好地理解这些概念，我们可以再次使用 *Dota 2* 作为例子：
- en: '`EnteringMap`: The state machine will be in this state when the map is loading.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EnteringMap`：当地图正在加载时，状态机将处于此状态。'
- en: '`WaitingToStart`: The state machine will be in this state once the map is loaded
    and the players are picking their heroes. The `ReadyToStartMatch` function will
    check whether all the players have selected their heroes; if they have, then the
    match can start.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WaitingToStart`：一旦地图加载完成且玩家正在选择他们的英雄，状态机将处于此状态。`ReadyToStartMatch` 函数将检查所有玩家是否已选择他们的英雄；如果是，则比赛可以开始。'
- en: '`InProgress`: The state machine will be in this state when the game is underway.
    The players control their heroes to farm and fight other players. The `ReadyToEndMatch`
    function will constantly check the health of each ancient to see whether one of
    them was destroyed; if it was, then the match ends.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InProgress`：当游戏进行时，状态机将处于此状态。玩家控制他们的英雄进行耕作和与其他玩家战斗。`ReadyToEndMatch`函数将不断检查每个古人的健康状态，以查看是否有一个被摧毁；如果是，则比赛结束。'
- en: '`WaitingPostMatch`: The state machine will be in this state when the game has
    ended and you can see the destroyed ancient, as well as a message that displays
    the name of the winning team.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WaitingPostMatch`：当游戏结束时，状态机将处于此状态，你可以看到被摧毁的古人和显示获胜队伍名称的消息。'
- en: '`LeavingMap`: The state machine will be in this state when it’s unloading the
    map.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LeavingMap`：当卸载地图时，状态机将处于此状态。'
- en: '`Aborted`: The state machine will be in this state if one of the players failed
    to connect in the initial stage, therefore aborting the whole match.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Aborted`：如果玩家在初始阶段未能连接，状态机将处于此状态，因此整个比赛将被取消。'
- en: Respawning the player
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 玩家重生
- en: When the player dies and you want to respawn it, you typically have two options.
    The first option is to reuse the same pawn instance, manually reset its state
    back to the defaults, and teleport it to the respawn location. The second option
    is to destroy the current pawn instance and spawn a new one, which will already
    have its state reset. If you prefer the latter option, then the `AGameModeBase::RestartPlayer`
    function handles the logic of spawning a new pawn instance for a certain player
    controller for you and places it on a player start.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家死亡并且你想让他重生时，你通常有两个选择。第一个选择是重用相同的兵实例，手动将其状态重置为默认值，并将其传送到重生位置。第二个选择是销毁当前的兵实例并创建一个新的，这个新的实例的状态已经被重置。如果你更喜欢后者，那么`AGameModeBase::RestartPlayer`函数会为你处理为特定玩家控制器创建新的兵实例的逻辑，并将其放置在玩家起始位置。
- en: One important thing to take into consideration is that the function only spawns
    a new pawn instance if the player controller doesn’t already possess a pawn, so
    make sure to destroy the controlled pawn before calling `RestartPlayer`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一个需要考虑的重要事项是，该函数仅在玩家控制器尚未拥有兵的情况下才会创建新的兵实例，所以确保在调用`RestartPlayer`之前销毁受控的兵。
- en: 'Take a look at the following example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下示例：
- en: '[PRE13]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding code, we have the `OnDeath` function, which takes the player
    controller of the player that died, destroys its controlled pawn, and calls the
    `RestartPlayer` function to spawn a new instance. By default, the new pawn instance
    will spawn in the player start actor that was used when the player spawned for
    the first time. Alternatively, you can tell the game mode that you want to spawn
    on a random player start. To accomplish that, all you need to do is override the
    `AGameModeBase::ShouldSpawnAtStartSpot` function and force it to `return false`,
    like so:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有`OnDeath`函数，它接受已死亡玩家的玩家控制器，销毁其控制的兵，并调用`RestartPlayer`函数来创建一个新的实例。默认情况下，新的兵实例将在玩家第一次出生时使用的玩家起始演员处重生。或者，你可以告诉游戏模式你想要在随机的玩家起始位置重生。为了实现这一点，你需要重写`AGameModeBase::ShouldSpawnAtStartSpot`函数并强制它返回`false`，如下所示：
- en: '[PRE14]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding code will make the game mode use a random player start instead
    of always using the first one that was used.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将使游戏模式使用随机的玩家起始位置，而不是总是使用第一次使用的第一个位置。
- en: Note
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information about the game mode, please visit [https://docs.unrealengine.com/en-US/Gameplay/Framework/GameMode/#gamemodes](https://docs.unrealengine.com/en-US/Gameplay/Framework/GameMode/#gamemodes)
    and [https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameMode/index.xhtml](https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameMode/index.xhtml).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于游戏模式的信息，请访问[https://docs.unrealengine.com/en-US/Gameplay/Framework/GameMode/#gamemodes](https://docs.unrealengine.com/en-US/Gameplay/Framework/GameMode/#gamemodes)和[https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameMode/index.xhtml](https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameMode/index.xhtml)。
- en: Player state
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩家状态
- en: The player state class stores the information that other clients need to know
    about a specific player (such as their current score, kills/deaths/assists, and
    so on) since they can’t access its player controller. The most widely used built-in
    functions are `GetPlayerName()`, `GetScore` and `GetPingInMilliseconds()`, which
    give you the name, score, and ping of the player, respectively.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家状态类存储了其他客户端需要了解的特定玩家的信息（例如他们的当前分数、击杀/死亡/助攻等），因为他们无法访问其玩家控制器。最广泛使用的内置函数是 `GetPlayerName()`、`GetScore`
    和 `GetPingInMilliseconds()`，分别提供玩家的名字、分数和延迟。
- en: 'A good example of how to use the player state is a scoreboard entry on a multiplayer
    shooter such as *Call Of Duty*, because every client needs to know the name, kills/deaths/assists,
    and ping for that player. The player state instance can be accessed in various
    ways, so let’s take a look at the most common ones:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用玩家状态的一个好例子是在多人射击游戏（如 *使命召唤*）的得分板上，因为每个客户端都需要知道该玩家的名字、击杀/死亡/助攻数和延迟。玩家状态实例可以通过多种方式访问，让我们看看最常见的方法：
- en: AController::PlayerState
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AController::PlayerState
- en: 'This variable contains the player state associated with the controller and
    can only be accessed by the server and the owning client. The following example
    shows how to use the variable:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量包含与控制器关联的玩家状态，并且只能由服务器和拥有该客户端访问。以下示例展示了如何使用这个变量：
- en: '[PRE15]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: AController::GetPlayerState()
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AController::GetPlayerState()
- en: 'This function returns the player state associated with the controller and can
    only be accessed by the server and the owning client. This function also has a
    template version so that you can cast it to your own custom player state class.
    The following example shows how to use the default and template versions of this
    function:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数返回与控制器关联的玩家状态，并且只能由服务器和拥有该客户端访问。此函数还有一个模板版本，以便您可以将其转换为自定义的玩家状态类。以下示例展示了如何使用此函数的默认和模板版本：
- en: '[PRE16]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: APawn::GetPlayerState()
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: APawn::GetPlayerState()
- en: 'This function returns the player state associated with the controller that
    is possessing the pawn and can be accessed by the server and the clients. This
    function also has a template version so that you can cast it to your own custom
    player state class. The following example shows how to use the default and template
    versions of this function:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数返回拥有兵器的控制器关联的玩家状态，并且可以由服务器和客户端访问。此函数还有一个模板版本，以便您可以将其转换为自定义的玩家状态类。以下示例展示了如何使用此函数的默认和模板版本：
- en: '[PRE17]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: AGameState::PlayerArray
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AGameState::PlayerArray
- en: 'This variable in the game state (covered in the next section) stores the player
    state instances for each player and can be accessed on the server and the clients.
    The following example shows how to use this variable:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏状态中的这个变量（在下一节中介绍）存储了每个玩家的玩家状态实例，并且可以在服务器和客户端上访问。以下示例展示了如何使用这个变量：
- en: '[PRE18]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To help you understand these concepts better, we will use *Dota 2* again as
    an example. The player state would have at least the following variables:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您更好地理解这些概念，我们将再次使用 *Dota 2* 作为示例。玩家状态至少包含以下变量：
- en: '**Name**: The name of the player'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名字**：玩家的名字'
- en: '**Hero**: The selected hero'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**英雄**：所选的英雄'
- en: '**Health**: The health of the hero'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生命值**：英雄的生命值'
- en: '**Mana**: The mana of the hero'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**魔法值**：英雄的魔法值'
- en: '**Stats**: The hero stats'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统计数据**：英雄的统计数据'
- en: '**Level**: The level the hero is currently in'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**等级**：英雄当前所在的等级'
- en: '**Kill/Death/Assist**: The kill/death/assist ratio for the player'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**击杀/死亡/助攻**：玩家的击杀/死亡/助攻比率'
- en: Note
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information about the player state, please visit [https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/APlayerState/index.xhtml](https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/APlayerState/index.xhtml).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于玩家状态的信息，请访问 [https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/APlayerState/index.xhtml](https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/APlayerState/index.xhtml)。
- en: Game State
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏状态
- en: The game state class stores the information that other clients need to know
    about the game (such as the match’s elapsed time and the score required to win
    the game) since they can’t access the game mode. The most widely used variable
    is `PlayerArray`, which is an array that provides the player state of every connected
    client. A good example of how to use the game state is a scoreboard on a multiplayer
    shooter such as *Call Of Duty* because every client needs to know how many kills
    are required to win, as well as the names, kills/deaths/assists, and pings for
    every connected player.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏状态类存储了其他客户端需要了解的游戏信息（例如比赛的已过时间和赢得比赛所需的分数），因为这些客户端无法访问游戏模式。最常用的变量是`PlayerArray`，它是一个提供每个已连接客户端玩家状态的数组。使用游戏状态的一个好例子是多玩家射击游戏如*使命召唤*的计分板，因为每个客户端都需要知道赢得比赛所需的击杀数，以及每个已连接玩家的名字、击杀/死亡/助攻和ping值。
- en: The game state instance can be accessed in various ways. Let’s take a look.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏状态实例可以通过多种方式访问。让我们看看。
- en: UWorld::GetGameState()
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UWorld::GetGameState()
- en: 'This function returns the game state associated with the world and can be accessed
    on the server and the clients. This function also has a template version so that
    you can cast it to your own custom game state class. The following example shows
    how to use the default and template versions of this function:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回与世界关联的游戏状态，可以在服务器和客户端上访问。此函数还有一个模板版本，以便您可以将其转换为您的自定义游戏状态类。以下示例展示了如何使用此函数的默认和模板版本：
- en: '[PRE19]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: AGameModeBase::GameState
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AGameModeBase::GameState
- en: 'This variable contains the game state associated with the game mode and can
    only be accessed on the server. The following example shows how to use the variable:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此变量包含与游戏模式关联的游戏状态，并且只能在服务器上访问。以下示例展示了如何使用此变量：
- en: '[PRE20]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: AGameModeBase::GetGameState()
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AGameModeBase::GetGameState()
- en: 'This function returns the game state associated with the game mode and can
    only be accessed on the server. This function also has a template version so that
    you can cast it to your own custom game state class. The following example shows
    how to use the default and template versions of this function:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回与游戏模式关联的游戏状态，并且只能在服务器上访问。此函数还有一个模板版本，以便您可以将其转换为您的自定义游戏状态类。以下示例展示了如何使用此函数的默认和模板版本：
- en: '[PRE21]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To help you understand these concepts better, we will use *Dota 2* again as
    an example. The game state will have the following variables:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您更好地理解这些概念，我们将再次以*Dota 2*为例。游戏状态将包含以下变量：
- en: '**Elapsed Time**: How long the match has been going on for'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已过时间**：比赛进行了多长时间'
- en: '**Radiant Kills**: How many Dire heroes the Radiant team has killed'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**辐射击杀数**：辐射队杀死了多少个暗影英雄'
- en: '**Dire Kills**: How many Radiant heroes the Dire team has killed'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**暗影击杀数**：暗影队杀死了多少个辐射英雄'
- en: '**Day/Night Timer**: Used to determine whether it is day or night'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**昼夜计时器**：用于确定是白天还是夜晚'
- en: Note
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information about the game state, please visit [https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameState/index.xhtml](https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameState/index.xhtml).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于游戏状态的信息，请访问[https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameState/index.xhtml](https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameState/index.xhtml)。
- en: Useful built-in functionality
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有用的内置功能
- en: UE5 comes with a lot of functionality built in. Let’s look at some examples
    that are useful to know about when developing a game.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: UE5内置了许多功能。让我们看看在开发游戏时需要了解的一些示例。
- en: void AActor::EndPlay(const EEndPlayReason::Type EndPlayReason)
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: void AActor::EndPlay(const EEndPlayReason::Type EndPlayReason)
- en: 'This function is called when the actor has stopped playing, which is the opposite
    of the `BeginPlay` function. This function has a parameter called `EndPlayReason`,
    which tells you why the actor stopped playing (if it was destroyed, if you stopped
    `PIE`, and so on). Take a look at the following example, which prints to the screen
    that the actor has stopped playing:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当演员停止播放时，会调用此函数，这是`BeginPlay`函数的相反。此函数有一个名为`EndPlayReason`的参数，它告诉您演员停止播放的原因（如果是被销毁，如果是停止`PIE`，等等）。看看以下示例，它会在屏幕上打印出演员已停止播放的信息：
- en: '[PRE22]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: void ACharacter::Landed(const FHitResult& Hit)
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: void ACharacter::Landed(const FHitResult& Hit)
- en: 'This function is called when a player lands on a surface after being in the
    air. Take a look at the following example, which plays a sound when a player lands
    on a surface:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家从空中落地时，会调用此函数。看看以下示例，当玩家落地时会播放声音：
- en: '[PRE23]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: bool UWorld::ServerTravel(const FString& FURL, bool bAbsolute, bool bShouldSkipGameNotify)
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: bool UWorld::ServerTravel(const FString& FURL, bool bAbsolute, bool bShouldSkipGameNotify)
- en: This function will make the server load a new map and bring all of the connected
    clients along with it. This is different from using other methods that load maps,
    such as the `UGameplayStatics::OpenLevel` function, because it won’t bring the
    clients along; it will just load the map on the server and disconnect the clients.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将使服务器加载新地图，并带所有连接的客户端一起。这与使用其他加载地图的方法不同，例如 `UGameplayStatics::OpenLevel`
    函数，因为它不会带客户端一起；它只会加载服务器上的地图并断开客户端连接。
- en: 'Take a look at the following example, which gets the current map name and uses
    server travel to reload it and bring along the connected clients:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 请看以下示例，它获取当前地图名称并使用服务器旅行来重新加载它并带连接的客户端：
- en: '[PRE24]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: void TArray::Sort(const PREDICATE_CLASS& Predicate)
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: void TArray::Sort(const PREDICATE_CLASS& Predicate)
- en: 'The `TArray` data structure comes with the `Sort` function, which allows you
    to sort the values of an array by using a lambda function that returns whether
    the `A` value should be ordered first, followed by the `B` value. Take a look
    at the following example, which sorts an integer array from the smallest value
    to the highest:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`TArray` 数据结构自带 `Sort` 函数，允许你使用返回 `A` 值是否应排在 `B` 值之前的 lambda 函数来对数组中的值进行排序。请看以下示例，它将整数数组从小到大排序：'
- en: '[PRE25]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding code will sort the `SortTest` array’s values of [43, 1, 23, 8]
    from smallest to highest – that is, [1, 8, 23, 43].
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将 `SortTest` 数组的值 [43, 1, 23, 8] 从最小到最大排序——即 [1, 8, 23, 43]。
- en: void AActor::FellOutOfWorld(const UDamageType& DmgType)
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: void AActor::FellOutOfWorld(const UDamageType& DmgType)
- en: 'In Unreal Engine, there is a concept called `Z` (set in the `Z` value, it will
    call the `FellOutOfWorld` function, which, by default, destroys the actor. Take
    a look at the following example, which prints to the screen that the actor fell
    out of the world:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unreal Engine 中，有一个称为 `Z`（在 `Z` 值中设置，将调用 `FellOutOfWorld` 函数，默认情况下，将销毁演员）的概念。请看以下示例，它将打印到屏幕上演员已从世界中掉落：
- en: '[PRE26]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: URotatingMovementComponent
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: URotatingMovementComponent
- en: 'This component rotates the owning actor along time with a certain rate on each
    axis, defined in the `RotationRate` variable. To use it, you need to include the
    following header:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件以每轴一定的速率随时间旋转拥有演员。要使用它，你需要包含以下头文件：
- en: '[PRE27]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You must also declare the component variable:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你还必须声明组件变量：
- en: '[PRE28]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, you must initialize it in the actor constructor, like so:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你必须在演员构造函数中初始化它，如下所示：
- en: '[PRE29]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding code, `RotationRate` is set to rotate `90` degrees per second
    on the `Yaw` axis.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`RotationRate` 设置为每秒在 `Yaw` 轴上旋转 `90` 度。
- en: Exercise 18.02 – Making a simple multiplayer pickup game
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 18.02 – 制作一个简单的多人拾取游戏
- en: 'In this exercise, we’re going to create a new C++ project that uses the **Third
    Person** template. The following will happen:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个新的 C++ 项目，使用 **第三人称** 模板。以下将发生：
- en: On the owning client, the player controller will create and add to the viewport
    a UMG widget that, for each player, displays the score, sorted from highest to
    lowest, and how many pickups it has collected.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在拥有客户端上，玩家控制器将为每个玩家创建并添加到视图中一个 UMG 小部件，显示分数，从高到低排序，以及收集了多少拾取物。
- en: Create a simple pickup actor class that gives 10 points to the player that picked
    it up. The pickup will also rotate 90 degrees per second on the `Yaw` axis.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的拾取演员类，给拾取它的玩家加 10 分。拾取物也将以每秒 90 度的速率在 `Yaw` 轴上旋转。
- en: Set the `Kill Z` to `-500` and make the player respawn and lose 10 points every
    time they fall from the world.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `Kill Z` 设置为 `-500` 并使玩家在每次从世界中掉落时重生并失去 10 分。
- en: The game will end when there are no more pickups available. Once the game ends,
    all characters will be destroyed and after 5 seconds, the server will do a server
    travel call to reload the same map and bring along the connected clients.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当没有更多拾取物可用时，游戏将结束。一旦游戏结束，所有角色将被销毁，5 秒后，服务器将进行服务器旅行调用以重新加载相同的地图并带连接的客户端。
- en: 'Follow these steps to complete the C++ part of this exercise:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习的 C++ 部分：
- en: Create a new `Pickups` and save it to a location of your liking.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `Pickups` 并将其保存到你喜欢的位置。
- en: Once the project has been created, it should open the editor, as well as the
    Visual Studio solution.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦项目创建完成，就应该打开编辑器以及 Visual Studio 解决方案。
- en: Now, let’s create the new C++ classes we’re going to use.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们将要使用的新 C++ 类。
- en: Create a `Pickup` class that derives from `Actor`.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个从 `Actor` 继承的 `Pickup` 类：
- en: Create a `PickupsGameState` class that derives from `GameState`.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个从 `GameState` 继承的 `PickupsGameState` 类：
- en: Create a `PickupsPlayerState` class that derives from `PlayerState`.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个从 `PlayerState` 继承的 `PickupsPlayerState` 类：
- en: Create a `PickupsPlayerController` class that derives from `PlayerController`.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个从 `PlayerController` 继承的 `PickupsPlayerController` 类：
- en: Close the editor and open Visual Studio.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭编辑器并打开 Visual Studio。
- en: 'Next, we’re going to work on the `PickupsGameState` class:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将处理 `PickupsGameState` 类：
- en: 'Open `PickupsGameState.h` and declare the protected replicated integer variable,
    `PickupsRemaining`, which tells all clients how many pickups remain in the level:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `PickupsGameState.h` 并声明受保护的复制整数变量 `PickupsRemaining`，它告诉所有客户端在关卡中剩余多少拾取物：
- en: '[PRE30]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Declare the protected override for the `BeginPlay` function:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明 `BeginPlay` 函数的受保护覆盖：
- en: '[PRE31]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Declare the protected `GetPlayerStatesOrderedByScore` function:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明受保护的 `GetPlayerStatesOrderedByScore` 函数：
- en: '[PRE32]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Implement the public `RemovePickup` function, which removes one pickup from
    the `PickupsRemaining` variable:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现公共的 `RemovePickup` 函数，该函数从 `PickupsRemaining` 变量中移除一个拾取物：
- en: '[PRE33]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Implement the public `HasPickups` function, which returns whether any pickups
    remain:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现公共的 `HasPickups` 函数，该函数返回是否还有拾取物剩余：
- en: '[PRE34]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Open `PickupsGameState.cpp` and include `Pickup.h`, `GameplayStatics.h`, `UnrealNetwork.h`,
    and `PlayerState.h`:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `PickupsGameState.cpp` 并包含 `Pickup.h`、`GameplayStatics.h`、`UnrealNetwork.h`
    和 `PlayerState.h`：
- en: '[PRE35]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Implement the `GetLifetimeReplicatedProps` function and make the `PickupRemaining`
    variable replicate to all clients:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现公共的 `GetLifetimeReplicatedProps` 函数，并使 `PickupRemaining` 变量对所有客户端进行复制：
- en: '[PRE36]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Implement the `BeginPlay` override function and set the value of `PickupsRemaining`
    by getting all the pickups in the world:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现覆盖的 `BeginPlay` 函数，并通过获取世界中的所有拾取物来设置 `PickupsRemaining` 的值：
- en: '[PRE37]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Implement the `GetPlayerStatesOrderedByScore` function, which duplicates the
    `PlayerArray` variable and sorts it so that the players with the highest scores
    show up first:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现公共的 `GetPlayerStatesOrderedByScore` 函数，该函数复制 `PlayerArray` 变量并对其进行排序，以便得分最高的玩家首先出现：
- en: '[PRE38]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, let’s work on the `PickupsPlayerState` class. Follow these steps:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们处理 `PickupsPlayerState` 类。按照以下步骤操作：
- en: 'Open `PickupsPlayerState.h` and declare the protected replicated integer variable,
    `Pickups`, which indicates how many pickups a player has collected:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `PickupsPlayerState.h` 并声明受保护的复制整数变量 `Pickups`，该变量指示玩家收集了多少拾取物：
- en: '[PRE39]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Implement the public `AddPickup` function, which adds one pickup to the `Pickups`
    variable:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现公共的 `AddPickup` 函数，该函数将一个拾取物添加到 `Pickups` 变量中：
- en: '[PRE40]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Open `PickupsPlayerState.cpp` and include `UnrealNetwork.h`:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `PickupsPlayerState.cpp` 并包含 `UnrealNetwork.h`：
- en: '[PRE41]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Implement the `GetLifetimeReplicatedProps` function and make the `Pickups`
    variable replicate to all clients:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现公共的 `GetLifetimeReplicatedProps` 函数，并使 `Pickups` 变量对所有客户端进行复制：
- en: '[PRE42]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Next, let’s work on the `PickupsPlayerController` class.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们处理 `PickupsPlayerController` 类。
- en: 'Open `PickupsPlayerController.h` and declare the protected `ScoreboardMenuClass`
    variable, which will set the UMG widget class we want to use for our scoreboard:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `PickupsPlayerController.h` 并声明受保护的 `ScoreboardMenuClass` 变量，该变量将设置我们用于计分板的
    UMG 小部件类：
- en: '[PRE43]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Declare the protected `ScoreboardMenu` variable, which stores the scoreboard
    UMG widget instance we will create on the `BeginPlay` function:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明受保护的 `ScoreboardMenu` 变量，该变量存储我们将在 `BeginPlay` 函数上创建的计分板 UMG 小部件实例：
- en: '[PRE44]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Declare the protected override for the `BeginPlay` function:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明 `BeginPlay` 函数的受保护覆盖：
- en: '[PRE45]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Open `PickupsPlayerController.cpp` and include `UserWidget.h`:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `PickupsPlayerController.cpp` 并包含 `UserWidget.h`：
- en: '[PRE46]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Implement the `BeginPlay` override function, which, for the owning client,
    creates and adds the scoreboard UMG widget to the viewport:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现覆盖的 `BeginPlay` 函数，对于拥有客户端，它会在视图中创建并添加计分板 UMG 小部件：
- en: '[PRE47]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, let’s edit the `PickupsGameMode` class:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编辑 `PickupsGameMode` 类：
- en: 'Open `PickupsGameMode.h` and replace the `#include` statement for `GameModeBase.h`
    with `GameMode.h`:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `PickupsGameMode.h` 并将 `#include` 语句 `GameModeBase.h` 替换为 `GameMode.h`：
- en: '[PRE48]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Make the class derive from `AGameMode` instead of `AGameModeBase`:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类从 `AGameModeBase` 继承改为 `AGameMode`：
- en: '[PRE49]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Declare the protected game state variable, `MyGameState`, which holds the instance
    of the `APickupsGameState` class:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明受保护的游戏状态变量 `MyGameState`，它持有 `APickupsGameState` 类的实例：
- en: '[PRE50]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Move the constructor to the protected area and delete the public area.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将构造函数移动到受保护区域并删除公共区域。
- en: 'Declare the protected override for the `BeginPlay` function:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明 `BeginPlay` 函数的受保护覆盖：
- en: '[PRE51]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Declare the protected override for the `ShouldSpawnAtStartSpot` function:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`ShouldSpawnAtStartSpot`函数的受保护重写：
- en: '[PRE52]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Declare the protected overrides for the match state functions of the game mode:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明游戏模式匹配状态函数的受保护重写：
- en: '[PRE53]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Declare the protected `RestartMap` function:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明受保护的`RestartMap`函数：
- en: '[PRE54]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Open `PickupsGameMode.cpp` and include `GameplayStatics.h` and `PickupGameState.h`:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`PickupsGameMode.cpp`并包含`GameplayStatics.h`和`PickupGameState.h`：
- en: '[PRE55]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Implement the `BeginPlay` override function, which stores the `APickupGameState`
    instance:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现重写`BeginPlay`函数，该函数存储`APickupGameState`实例：
- en: '[PRE56]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Implement the `ShouldSpawnAtStartSpot` override function, which indicates that
    we want the players to respawn on a random player start and not always on the
    same one:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现重写`ShouldSpawnAtStartSpot`函数，该函数指示我们希望玩家在随机的玩家起始点重生，而不是总是在同一个点上：
- en: '[PRE57]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Implement the `HandleMatchHasStarted` override function, which prints to the
    screen, informing players that the game has started:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现重写`HandleMatchHasStarted`函数，该函数将打印到屏幕上，通知玩家游戏已经开始：
- en: '[PRE58]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Implement the `HandleMatchHasEnded` override function, which prints to the
    screen, informing players that the game has ended, destroys all characters, and
    schedules a timer to restart the map:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现重写`HandleMatchHasEnded`函数，该函数打印到屏幕上，通知玩家游戏已经结束，销毁所有角色，并安排定时器重新启动地图：
- en: '[PRE59]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Implement the `ReadyToStartMatch_Implementation` override function, which indicates
    that the match can start straight away:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现重写`ReadyToStartMatch_Implementation`函数，该函数指示比赛可以立即开始：
- en: '[PRE60]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Implement the `ReadyToEndMatch_Implementation` override function, which indicates
    that the match ends when the game state has no more pickups remaining:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现重写`ReadyToEndMatch_Implementation`函数，该函数指示当游戏状态中不再有拾取物品时，比赛结束：
- en: '[PRE61]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Implement the `RestartMap` function, which performs a server travel to the
    same level and brings all clients along:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现重写`RestartMap`函数，该函数执行服务器旅行到同一关卡，并将所有客户端一起带来：
- en: '[PRE62]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, let’s edit the `PickupsCharacter` class. Follow these steps:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编辑`PickupsCharacter`类。按照以下步骤操作：
- en: 'Open `PickupsCharacter.h` and declare the protected sound variables for falling
    and landing:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`PickupsCharacter.h`并声明受保护的掉落和着陆声音变量：
- en: '[PRE63]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Declare the protected override functions:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明受保护的函数重写：
- en: '[PRE64]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Declare the public functions that add scores and pickups to the player state:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明添加分数和拾取物品到玩家状态的公共函数：
- en: '[PRE65]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Declare the public client RPC that plays a sound on the owning client:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明在拥有客户端上播放声音的公共客户端RPC：
- en: '[PRE66]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Open `PickupsCharacter.cpp` and include `PickupsPlayerState.h`, `GameMode.h`,
    `PlayerState.h`, and `GameplayStatics.h`:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`PickupsCharacter.cpp`并包含`PickupsPlayerState.h`、`GameMode.h`、`PlayerState.h`和`GameplayStatics.h`：
- en: '[PRE67]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Implement the `EndPlay` override function, which plays the fall sound if the
    character was destroyed:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现重写`EndPlay`函数，如果角色被销毁，则播放掉落声音：
- en: '[PRE68]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Implement the `Landed` override function, which plays the landed sound:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现重写`Landed`函数，该函数播放着陆声音：
- en: '[PRE69]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Implement the `FellOutOfWorld` override function, which stores the controller,
    removes `10` points from the score, destroys the character, and tells the game
    mode to restart the player using the previous controller:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现重写`FellOutOfWorld`函数，该函数存储控制器，从分数中减去`10`分，销毁角色，并告诉游戏模式使用之前的控制器重新启动玩家：
- en: '[PRE70]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Implement the `AddScore` function, which adds a certain amount to the `score`
    in the player state:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现重写`AddScore`函数，该函数将一定数量的分数添加到玩家状态中的`score`：
- en: '[PRE71]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Implement the `AddPickup` function, which adds a pickup to the `Pickup` variable
    in our custom player state:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现重写`AddPickup`函数，该函数将拾取物品添加到我们自定义玩家状态中的`Pickup`变量：
- en: '[PRE72]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Implement the `ClientPlaySound2D_Implementation` function, which plays a sound
    on the owning client:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现重写`ClientPlaySound2D_Implementation`函数，该函数在拥有客户端上播放声音：
- en: '[PRE73]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now, let’s work on the `Pickup` class. Follow these steps:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专注于`Pickup`类。按照以下步骤操作：
- en: Open `Pickup.h` and clear all existing functions and delete the public areas.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Pickup.h`并清除所有现有函数并删除公共区域。
- en: 'Declare the protected `Static Mesh` component called `Mesh`:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明名为`Mesh`的受保护`Static Mesh`组件：
- en: '[PRE74]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Declare the protected rotating movement component called `RotatingMovement`:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明名为`RotatingMovement`的受保护旋转运动组件：
- en: '[PRE75]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Declare the protected `PickupSound` variable:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明受保护的`PickupSound`变量：
- en: '[PRE76]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Declare the protected constructor and `BeginPlay` override:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明受保护的构造函数和`BeginPlay`重写：
- en: '[PRE77]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Declare the protected `OnBeginOverlap` function:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明受保护的`OnBeginOverlap`函数：
- en: '[PRE78]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Open `Pickup.cpp` and include `PickupsCharacter.h`, `PickupsGameState.h`, and
    `RotatingMovementComponent.h` after `Pickup.h`:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Pickup.cpp`并在`Pickup.h`之后包含`PickupsCharacter.h`、`PickupsGameState.h`和`RotatingMovementComponent.h`：
- en: '[PRE79]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'In the constructor, initialize the `Mesh` component so that it overlaps everything
    and make it the root component:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，初始化`Mesh`组件，使其覆盖一切，并使其成为根组件：
- en: '[PRE80]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Still in the constructor, initialize the rotating movement component so that
    it rotates `90` degrees per second on the `Yaw` axis:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在构造函数中，初始化旋转运动组件，使其在`Yaw`轴上每秒旋转`90`度：
- en: '[PRE81]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'To finalize the constructor, enable replication and disable the `Tick` function:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成构造函数，启用复制并禁用`Tick`函数：
- en: '[PRE82]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'At the end of the `BeginPlay` function, bind the begin overlap event of `Mesh`
    to the `OnBeginOverlap` function:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BeginPlay`函数的末尾，将`Mesh`的`BeginOverlap`事件绑定到`OnBeginOverlap`函数：
- en: '[PRE83]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Delete the definition for the `Tick` function.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`Tick`函数的定义。
- en: 'Implement the `OnBeginOverlap` function, which checks whether the character
    is valid and has authority, removes the pickup from the game state, plays the
    pickup sound on the owning client, and adds `10` points and the pickup to the
    character. Once all of that is done, the pickup will destroy itself:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`OnBeginOverlap`函数，该函数检查角色是否有效并具有权限，从游戏状态中删除拾取物，在拥有客户端上播放拾取物声音，并将`10`分和拾取物添加到角色。完成所有这些后，拾取物将自行销毁：
- en: '[PRE84]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Open `Pickups.Build.cs` and add the `UMG` module to `PublicDependencyModuleNames`,
    like so:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Pickups.Build.cs`，并将`UMG`模块添加到`PublicDependencyModuleNames`中，如下所示：
- en: '[PRE85]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: If you try to compile and get errors from adding the new module, then clean
    and recompile your project. If that doesn’t work, try restarting your IDE.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试编译并从添加新模块中获取错误，那么清理并重新编译你的项目。如果那样做不起作用，尝试重启你的IDE。
- en: Compile and run the code until the editor loads.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行代码，直到编辑器加载。
- en: Once it’s loaded, we’re going to import some assets and create some blueprints
    that derive from the C++ classes we’ve just created.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载，我们将导入一些资产并创建一些从我们刚刚创建的C++类派生的蓝图。
- en: 'First, let’s import the sound files:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们导入声音文件：
- en: In the `Content\Sounds` folder.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content\Sounds`文件夹中。
- en: Import `Pickup.wav`, `Footstep.wav`, `Jump.wav`, `Land.wav`, and `Fall.wav`
    from the `Exercise18.02\Assets` folder.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Exercise18.02\Assets`文件夹导入`Pickup.wav`、`Footstep.wav`、`Jump.wav`、`Land.wav`和`Fall.wav`。
- en: Save the new files.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存新文件。
- en: Next, we will add the `Play Sound` anim notifies to some of the character’s
    animations.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向角色的某些动画中添加`Play Sound`动画通知。
- en: Open the `MM_Jump` animation, located in `Content\Characters\Mannequins\Animations\Manny`,
    and add a `Play Sound` anim notify at frame `0` using the `Jump` sound.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于`Content\Characters\Mannequins\Animations\Manny`中的`MM_Jump`动画，并在帧`0`使用`Jump`声音添加一个`Play
    Sound`动画通知。
- en: Save and close `MM_Jump`.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭`MM_Jump`。
- en: Open the `MF_Run_Fwd` animation, located in `Content\Characters\Mannequins\Animations\Quinn`,
    and add `Play Sound` anim notifies using the `Footstep` sound at `0.24`, `0.56`,
    `0.82`, `1.12`, `1.38`, and `1.70` seconds.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于`Content\Characters\Mannequins\Animations\Quinn`中的`MF_Run_Fwd`动画，并在`0.24`、`0.56`、`0.82`、`1.12`、`1.38`和`1.70`秒使用`Footstep`声音添加`Play
    Sound`动画通知。
- en: Save and close `MF_Run_Fwd`.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭`MF_Run_Fwd`。
- en: Open the `MF_Walk_Fwd` animation, located in `Content\Characters\Mannequins\Animations\Quinn`,
    and add two `Play Sound` anim notifies using the `Footstep` sound at `0.33, 0.72,
    1.23,` and `1.7` seconds.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于`Content\Characters\Mannequins\Animations\Quinn`中的`MF_Walk_Fwd`动画，并在`0.33`、`0.72`、`1.23`和`1.7`秒使用`Footstep`声音添加两个`Play
    Sound`动画通知。
- en: Save and close `MF_Walk_Fwd`.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭`MF_Walk_Fwd`。
- en: 'Now, let’s set the sounds to use on the character blueprint:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们设置在角色蓝图上使用的声音：
- en: Open the `BP_ThirdPersonCharacter` blueprint, located in `Content\ThirdPerson\Blueprints`,
    and set `Fall Sound` and `Land Sound` so that they use the `Fall` and `Land` sounds,
    respectively.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于`Content\ThirdPerson\Blueprints`中的`BP_ThirdPersonCharacter`蓝图，并将`Fall Sound`和`Land
    Sound`设置为分别使用`Fall`和`Land`声音。
- en: Save and close `BP_ThirdPersonCharacter`.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭`BP_ThirdPersonCharacter`。
- en: Now, let’s create the blueprint for the pickup.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建拾取物的蓝图。
- en: Create and open the `Content\Blueprints` folder.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并打开`Content\Blueprints`文件夹。
- en: Create a new blueprint called `BP_Pickup` that derives from the `Pickup` class
    and open it.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`BP_Pickup`的新蓝图，它从`Pickup`类派生，并打开它。
- en: 'Configure the `Static Mesh` component in the following way:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按以下方式配置`Static Mesh`组件：
- en: '`(X=0.5, Y=0.5, Z=0.5)`'
  id: totrans-415
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(X=0.5, Y=0.5, Z=0.5)`'
- en: '`Engine\BasicShapes\Cube`'
  id: totrans-416
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Engine\BasicShapes\Cube`'
- en: '`Engine\EngineMaterials\CubeMaterial`'
  id: totrans-417
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Engine\EngineMaterials\CubeMaterial`'
- en: Note
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To display the Engine content, you need to click on the dropdown for the static
    mesh, click on the cog icon next to the filter box, and make sure that the `true`.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示引擎内容，需要点击静态网格的下拉菜单，点击过滤器框旁边的齿轮图标，并确保`true`。
- en: Set the `Pickup Sound` variable to use the `Pickup` sound.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Pickup Sound`变量设置为使用`Pickup`声音。
- en: Save and close `BP_Pickup`.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭`BP_Pickup`。
- en: 'Now, let’s create the scoreboard UMG widgets. Follow these steps:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建得分板UMG小部件。按照以下步骤操作：
- en: Create and go to the `Content\UI` folder.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并转到`Content\UI`文件夹。
- en: 'Create a new widget blueprint called `WBP_Scoreboard_Header`:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的小部件蓝图，命名为`WBP_Scoreboard_Header`：
- en: Add a `true`, `true`, `Player Name`, and `green`.
  id: totrans-425
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加`true`、`true`、`Player Name`和`green`。
- en: Add a text block called `true`, `= 500`, `= 1.0, 0.0`, `true`, `Score`, and
    `green`.
  id: totrans-426
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个名为`true`、`= 500`、`= 1.0, 0.0`、`true`、`Score`和`green`的文本块。
- en: Add a text block called `true`, `= 650`, `= 1.0, 0.0`, `true`, `Pickups`, and
    `green`.
  id: totrans-427
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个名为`true`、`= 650`、`= 1.0, 0.0`、`true`、`Pickups`和`green`的文本块。
- en: Save and close `WBP_Scoreboard_Header`.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭`WBP_Scoreboard_Header`。
- en: Go back to `WBP_Scoreboard_Header`, rename it to `WBP_Scoreboard_Entry`, and
    open it.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到`WBP_Scoreboard_Header`，将其重命名为`WBP_Scoreboard_Entry`，并打开它。
- en: Change the color of all of the text blocks to `white` instead of `green`.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有文本块的色彩改为`white`而不是`green`。
- en: 'Go to the `Player State` variable with the following configuration:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下配置转到`Player State`变量：
- en: '![Figure 18.6 – Creating the Player State variable ](img/Figure_18.06_B18531.jpg)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![图18.6 – 创建Player State变量](img/Figure_18.06_B18531.jpg)'
- en: Figure 18.6 – Creating the Player State variable
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.6 – 创建Player State变量
- en: 'Go back to the `Name` with `Player Name` and bind it to the `GetPlayerName`
    function from the dropdown, like so:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到带有`Player Name`的`Name`并绑定到下拉菜单中的`GetPlayerName`函数，如下所示：
- en: '![Figure 18.7 – Binding the player name function ](img/Figure_18.07_B18531.jpg)'
  id: totrans-435
  prefs: []
  type: TYPE_IMG
  zh: '![图18.7 – 绑定玩家名称函数](img/Figure_18.07_B18531.jpg)'
- en: Figure 18.7 – Binding the player name function
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.7 – 绑定玩家名称函数
- en: 'Create a text block called `Score` with `Score` and bind it to the `Score`
    variable from the dropdown, like so:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Score`的文本块，内容为`Score`，并将其绑定到下拉菜单中的`Score`变量，如下所示：
- en: '![Figure 18.8 – Binding the player score function ](img/Figure_18.08_B18531.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![图18.8 – 绑定玩家得分函数](img/Figure_18.08_B18531.jpg)'
- en: Figure 18.8 – Binding the player score function
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.8 – 绑定玩家得分函数
- en: 'Create a text block called `Pickups` with `Pickups` and bind it to the `Pickups`
    variable from the dropdown, like so:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Pickups`的文本块，内容为`Pickups`，并将其绑定到下拉菜单中的`Pickups`变量，如下所示：
- en: '![Figure 18.9 – Binding the pickups count function ](img/Figure_18.09_B18531.jpg)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
  zh: '![图18.9 – 绑定拾取计数函数](img/Figure_18.09_B18531.jpg)'
- en: Figure 18.9 – Binding the pickups count function
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.9 – 绑定拾取计数函数
- en: 'Create a pure function called `Get Typeface` that does the following:'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个纯函数，名为`Get Typeface`，执行以下操作：
- en: '![Figure 18.10 – Determining whether the entry should be displayed in Bold
    or Regular ](img/Figure_18.10_B18531.jpg)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
  zh: '![图18.10 – 确定条目是否应以粗体或常规显示](img/Figure_18.10_B18531.jpg)'
- en: Figure 18.10 – Determining whether the entry should be displayed in Bold or
    Regular
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.10 – 确定条目是否应以粗体或常规显示
- en: In the preceding code, we used a `Select` node, which can be created by dragging
    a wire from the return value and releasing it on an empty space, and then typed
    `Select` on the filter. From there, we picked the `Select` node from the list.
    Here, we are using the `Select` node to pick the name of the typeface we’re going
    to use, so it should return `Regular` if the player state’s pawn is not the same
    as the pawn that owns the widget and `Bold` if it is. We do this to highlight
    the player’s state entry in bold so that the player knows what their entry is.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了`Select`节点，可以通过从返回值拖动一根线并在空白处释放它来创建，然后在过滤器上键入`Select`。从那里，我们从列表中选择了`Select`节点。在这里，我们使用`Select`节点来选择我们将要使用的字体名称，因此如果玩家状态的角色与拥有小部件的角色不同，则应返回`Regular`，如果相同，则返回`Bold`。我们这样做是为了以粗体突出显示玩家的状态条目，以便玩家知道他们的条目是什么。
- en: 'Implement `Event Construct` in the following way:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以以下方式实现`Event Construct`：
- en: '![Figure 18.11 – The Event Graph that sets the text for the name, score, and
    pickups count ](img/Figure_18.11_B18531.jpg)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![图18.11 – 设置名称、得分和拾取计数文本的事件图](img/Figure_18.11_B18531.jpg)'
- en: Figure 18.11 – The Event Graph that sets the text for the name, score, and pickups
    count
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.11 – 设置名称、得分和拾取计数文本的事件图
- en: In the preceding code, we set the font for `Name`, `Score`, and `Pickups` to
    use the `Bold` typeface to highlight which scoreboard entry is relative to the
    player of the current client. For the remainder of the players, use the `Regular`
    typeface. If you can’t find the **Roboto** font, then pick **Show Engine Content**
    from the dropdown options.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将 `Name`、`Score` 和 `Pickups` 的字体设置为使用 `Bold` 字体类型以突出显示与当前客户端玩家相关的计分板条目。对于其余玩家，使用
    `Regular` 字体类型。如果您找不到 `Roboto` 字体，则从下拉选项中选择 **Show Engine Content**。
- en: Save and close `WBP_Scoreboard_Entry`.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭 `WBP_Scoreboard_Entry`。
- en: Open `WBP_Scoreboard` and add a **Canvas Panel** to the **Hierarchy** panel.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `WBP_Scoreboard` 并将 **Canvas Panel** 添加到 **Hierarchy** 面板。
- en: Go to the `Game State` of the `Pickups Game State` type.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `Pickups Game State` 类型的 `Game State`。
- en: Go back to the `Scoreboard` to the canvas panel with `true`.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到带有 `true` 的 `Scoreboard` 画布面板。
- en: Add a text block to `Scoreboard` called `PickupsRemaining` with `Text` set to
    `100 Pickup(s) Remaining`.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Scoreboard` 中添加一个名为 `PickupsRemaining` 的文本块，将 `Text` 设置为 `100 Pickup(s) Remaining`。
- en: 'Add a vertical box to `PlayerStates` with `Is Variable` set to `true` and a
    top padding of `50`. You should have the following:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PlayerStates` 中添加一个垂直框，将 `Is Variable` 设置为 `true` 并设置顶部填充为 `50`。你应该有以下内容：
- en: '![Figure 18.12 – The WBP_Scoreboard widget hierarchy ](img/Figure_18.12_B18531.jpg)'
  id: totrans-457
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.12 – WBP_Scoreboard 小部件层次结构](img/Figure_18.12_B18531.jpg)'
- en: Figure 18.12 – The WBP_Scoreboard widget hierarchy
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.12 – WBP_Scoreboard 小部件层次结构
- en: 'Bind the `Text` value for the `PickupsRemaining` text block with the following
    function:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `PickupsRemaining` 文本块的 `Text` 值绑定到以下函数：
- en: '![Figure 18.13 – Displaying the number of pickups remaining in the world ](img/Figure_18.13_B18531.jpg)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.13 – 显示世界剩余拾取物品的数量](img/Figure_18.13_B18531.jpg)'
- en: Figure 18.13 – Displaying the number of pickups remaining in the world
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.13 – 显示世界剩余拾取物品的数量
- en: 'Go to `Add Scoreboard Header` that adds an instance of `WBP_Scoreboard_Header`
    to `Player States`, as shown in the following screenshot:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `Add Scoreboard Header`，它将 `WBP_Scoreboard_Header` 的实例添加到 `Player States`
    中，如下截图所示：
- en: '![Figure 18.14 – The Add Scoreboard Header event ](img/Figure_18.14_B18531.jpg)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.14 – 添加计分板标题事件](img/Figure_18.14_B18531.jpg)'
- en: Figure 18.14 – The Add Scoreboard Header event
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.14 – 添加计分板标题事件
- en: 'Create a new event called `Add Scoreboard Entries`. This goes through all of
    the player states ordered by score and adds an instance of `WBP_Scoreboard_Entry`
    to `Player States`, as demonstrated in the following screenshot:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Add Scoreboard Entries` 的新事件。该事件按分数顺序遍历所有玩家状态，并将 `WBP_Scoreboard_Entry`
    的实例添加到 `Player States` 中，如下截图所示：
- en: '![Figure 18.15 – The Add Scoreboard Entries event ](img/Figure_18.15_B18531.jpg)'
  id: totrans-466
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.15 – 添加计分板条目事件](img/Figure_18.15_B18531.jpg)'
- en: Figure 18.15 – The Add Scoreboard Entries event
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.15 – 添加计分板条目事件
- en: 'Create a new event called `Update Scoreboard`. This event clears the widgets
    in `Player States` and calls `Add Scoreboard Header` and `Add Scoreboard Entries`,
    as shown in the following screenshot:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Update Scoreboard` 的新事件。该事件清除 `Player States` 中的小部件，并调用 `Add Scoreboard
    Header` 和 `Add Scoreboard Entries`，如下截图所示：
- en: '![Figure 18.16 – The Update Scoreboard event ](img/Figure_18.16_B18531.jpg)'
  id: totrans-469
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.16 – 更新计分板事件](img/Figure_18.16_B18531.jpg)'
- en: Figure 18.16 – The Update Scoreboard event
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.16 – 更新计分板事件
- en: 'Implement `Event Construct` in the following way:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按以下方式实现 `Event Construct`：
- en: '![Figure 18.17 – Event Construct ](img/Figure_18.17_B18531.jpg)'
  id: totrans-472
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.17 – 事件构造](img/Figure_18.17_B18531.jpg)'
- en: Figure 18.17 – Event Construct
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.17 – 事件构造
- en: In the preceding code, we get the game state instance, update the scoreboard,
    and schedule a timer to automatically call the `Update Scoreboard` event every
    `0.5` seconds.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们获取游戏状态实例，更新计分板，并安排定时器每 `0.5` 秒自动调用 `Update Scoreboard` 事件。
- en: Save and close `WBP_Scoreboard`.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭 `WBP_Scoreboard`。
- en: 'Now, let’s create the blueprint for the player controller. Follow these steps:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建玩家控制器的蓝图。按照以下步骤操作：
- en: Go to `Content\Blueprints` and create a new blueprint called `BP_PlayerController`
    that derives from the `PickupsPlayerController` class.
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `Content\Blueprints` 并创建一个名为 `BP_PlayerController` 的新蓝图，它从 `PickupsPlayerController`
    类派生。
- en: Open the new blueprint and set `Scoreboard Menu` to use `WBP_Scoreboard`.
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新蓝图并将 `Scoreboard Menu` 设置为使用 `WBP_Scoreboard`。
- en: Save and close `BP_PlayerController`.
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭 `BP_PlayerController`。
- en: Next, let’s create the blueprint for the game mode.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建游戏模式的蓝图。
- en: 'Create a new blueprint called `BP_GameMode` that derives from the `PickupsGameMode`
    class, open it, and change the following variables:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的蓝图，名为`BP_GameMode`，它从`PickupsGameMode`类派生，打开它，并更改以下变量：
- en: '`PickupsGameState`'
  id: totrans-482
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PickupsGameState`'
- en: '`BP_PlayerController`'
  id: totrans-483
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BP_PlayerController`'
- en: '`PickupsPlayerState`'
  id: totrans-484
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PickupsPlayerState`'
- en: Save and close `BP_GameMode`.
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭`BP_GameMode`。
- en: Next, let’s configure **Project Settings** so that it uses the new game mode.
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们配置**项目设置**，以便它使用新的游戏模式。
- en: Go to **Project Settings** and pick **Maps & Modes** from the left panel, which
    is in the **Project** category.
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**项目设置**，从左侧面板中选择**地图和模式**，它位于**项目**类别下。
- en: Set `BP_GameMode`.
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`BP_GameMode`。
- en: Close **Project Settings**.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭**项目设置**。
- en: 'Now, let’s modify the main level. Follow these steps:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修改主级别。按照以下步骤操作：
- en: Make sure you have `ThirdPersonMap` opened, located in `Content\ThirdPerson\Maps`.
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你已经打开了`ThirdPersonMap`，位于`Content\ThirdPerson\Maps`。
- en: Add some cube actors to act as platforms. Make sure they have gaps between them
    to force the player to jump on them and possibly fall from the level.
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些立方体演员作为平台。确保它们之间有间隙，迫使玩家跳上去，并可能从级别上掉落。
- en: Add a couple of player start actors spread throughout the map.
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在地图上添加几个玩家起点演员。
- en: Add at least 50 instances of `BP_Pickup` and spread them across the entire map.
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至少添加50个`BP_Pickup`实例，并将它们分布在整个地图上。
- en: 'Here is an example of a possible way of configuring the map:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是一个配置地图的可能方式的示例：
- en: '![Figure 18.18 – An example of a map configuration ](img/Figure_18.18_B18531.jpg)'
  id: totrans-496
  prefs: []
  type: TYPE_IMG
  zh: '![图18.18 – 地图配置的示例](img/Figure_18.18_B18531.jpg)'
- en: Figure 18.18 – An example of a map configuration
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.18 – 地图配置的示例
- en: Go to **World Settings**, set **GameMode Override** to **None**, and save everything.
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**世界设置**，将**游戏模式覆盖**设置为**无**，并保存一切。
- en: Go to `2`.
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`2`。
- en: Set the window sizes to `800x600` and play using **New Editor Window (PIE).**
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将窗口大小设置为`800x600`，并使用**新编辑器窗口（PIE）**进行游戏。
- en: 'You should get the following output:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 18.19 – The listen Server and Client 1 picking up cubes in the world
    ](img/Figure_18.19_B18531.jpg)'
  id: totrans-502
  prefs: []
  type: TYPE_IMG
  zh: '![图18.19 – 监听服务器和客户端1在世界中拾取方块](img/Figure_18.19_B18531.jpg)'
- en: Figure 18.19 – The listen Server and Client 1 picking up cubes in the world
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.19 – 监听服务器和客户端1在世界中拾取方块
- en: By completing this exercise, you can play on each client. You’ll notice that
    the characters can collect pickups and gain **10** points just by overlapping
    with them. If a character falls from the level, they will respawn on a random
    player start and lose **10** points.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你可以在每个客户端上玩游戏。你会注意到角色可以通过与它们重叠来收集拾取物并获得**10**分。如果一个角色从级别上掉落，它们将在随机的玩家起点重生并失去**10**分。
- en: Once all the pickups have been collected, the game will end, and after **5**
    seconds, it will perform a server travel to reload the same level and bring all
    the clients with it. You will also see that the UI displays how many pickups are
    remaining in the level, as well as the scoreboard with information about the name,
    score, and pickups for each player.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦收集了所有拾取物，游戏将结束，之后**5**秒，它将执行服务器旅行以重新加载同一级别并将所有客户端一起带来。你还会看到UI显示级别中剩余的拾取物数量，以及包含每个玩家的姓名、分数和拾取物的计分板。
- en: In the next activity, you’re going to add a scoreboard, kill limit, the concept
    of death/respawning, and the ability for the characters to pick up weapons, ammo,
    armor, and health in our multiplayer FPS game.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个活动中，你将添加计分板、死亡/重生概念以及角色在多人FPS游戏中拾取武器、弹药、装甲和健康的能力。
- en: Activity 18.01 – Adding death, respawning, a scoreboard, kill limit, and pickups
    to the multiplayer FPS game
  id: totrans-507
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动编号18.01 – 向多人FPS游戏添加死亡、重生、计分板、死亡限制和拾取物
- en: In this activity, you’ll add the concept of death/respawning and the ability
    for a character to collect pickups to our multiplayer FPS game. We’ll also add
    a scoreboard and a kill limit to the game so that it has an end goal.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你将添加死亡/重生概念以及角色收集拾取物的能力到我们的多人FPS游戏中。我们还将添加计分板和死亡限制，以便游戏有一个最终目标。
- en: 'Follow these steps to complete this activity:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此活动：
- en: Open the `MultiplayerFPS` project from *Activity 17.01 – Adding weapons and
    ammo to the multiplayer FPS game*. Compile the code and run the editor.
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从*活动17.01 – 向多人FPS游戏添加武器和弹药*中打开`MultiplayerFPS`项目。编译代码并运行编辑器。
- en: Create a C++ class called `FPSGameState`, which derives from the `GameState`
    class, and has a kill limit variable and a function that returns the player states
    ordered by kills.
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `FPSGameState` 的 C++ 类，它继承自 `GameState` 类，并具有一个击杀限制变量和一个返回按击杀数排序的玩家状态的函数。
- en: Create a C++ class called `FPSPlayerState`, which derives from the `PlayerState`
    class, and stores the number of kills and deaths of a player.
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `FPSPlayerState` 的 C++ 类，它继承自 `PlayerState` 类，并存储玩家的击杀数和死亡数。
- en: Create a C++ class called `PlayerMenu`, which derives from the `UserWidget`
    class, and has some `BlueprintImplementableEvent` functions to toggle the scoreboard
    visibility, set the scoreboard visibility, and notify when a player was killed.
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `PlayerMenu` 的 C++ 类，它继承自 `UserWidget` 类，并具有一些 `BlueprintImplementableEvent`
    函数来切换计分板可见性、设置计分板可见性，并在玩家被击杀时通知。
- en: Create a C++ class called `FPSPlayerController`, which derives from `APlayerController`,
    that creates the `PlayerMenu` UMG widget instance on the owning client.
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `FPSPlayerController` 的 C++ 类，它继承自 `APlayerController`，在拥有客户端上创建 `PlayerMenu`
    UMG 小部件实例。
- en: Create a C++ class called `Pickup`, which derives from the `Actor` class, and
    has a static mesh that rotates 90 degrees per second on the `Yaw` axis and can
    be picked up by the player on overlap. Once picked up, it plays a pickup sound
    and disables collision and visibility. After a certain amount of time, it will
    make it visible and able to collide again.
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Pickup` 的 C++ 类，它继承自 `Actor` 类，并具有一个静态网格，该网格在 `Yaw` 轴上每秒旋转 90 度，并且可以在重叠时被玩家拾取。一旦拾取，它将播放拾取声音并禁用碰撞和可见性。经过一段时间后，它将使其可见并能够再次碰撞。
- en: Create a C++ class called `AmmoPickup`, which derives from the `Pickup` class,
    and adds a certain amount of an ammo type to the player.
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `AmmoPickup` 的 C++ 类，它继承自 `Pickup` 类，并为玩家添加一定类型的弹药。
- en: Create a C++ class called `ArmorPickup`, which derives from the `Pickup` class,
    and adds a certain amount of armor to the player.
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `ArmorPickup` 的 C++ 类，它继承自 `Pickup` 类，并为玩家添加一定量的护甲。
- en: Create a C++ class called `HealthPickup`, which derives from the `Pickup` class,
    and adds a certain amount of health to the player.
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `HealthPickup` 的 C++ 类，它继承自 `Pickup` 类，并为玩家添加一定量的生命值。
- en: Create a C++ class called `WeaponPickup`, which derives from the `Pickup` class,
    and adds a certain weapon type to the player. If the player already has the weapon,
    it will add a certain amount of ammo.
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `WeaponPickup` 的 C++ 类，它继承自 `Pickup` 类，并为玩家添加一定类型的武器。如果玩家已经拥有该武器，则添加一定量的弹药。
- en: 'Edit the `FPSCharacter` class so that it does the following:'
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `FPSCharacter` 类，使其执行以下操作：
- en: After the character is damaged, it checks whether it’s dead. If it’s dead, it
    registers the kill for the killer character and the death of the player and respawn
    it. If the character is not dead, then it plays the pain sound on the owning client.
  id: totrans-521
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在角色受损后，它检查角色是否死亡。如果已死亡，则注册杀手角色的击杀和玩家的死亡，并重新生成玩家。如果角色未死亡，则在拥有客户端上播放疼痛声音。
- en: When the character dies and executes the `EndPlay` function, it should destroy
    all of its weapon instances.
  id: totrans-522
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当角色死亡并执行 `EndPlay` 函数时，它应该销毁其所有武器实例。
- en: If the character falls from the world, it will register the death of the player
    and respawn it.
  id: totrans-523
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果角色从世界中坠落，它将注册玩家的死亡并重新生成。
- en: If the player presses the *Tab* key, it will toggle the visibility of the scoreboard
    menu.
  id: totrans-524
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家按下 *Tab* 键，它将切换计分板菜单的可见性。
- en: 'Edit the `MultiplayerFPSGameModeBase` class so that it does the following:'
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `MultiplayerFPSGameModeBase` 类，使其执行以下操作：
- en: Uses the `GameMode` class instead of `GameModeBase`
  id: totrans-526
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `GameMode` 类而不是 `GameModeBase`。
- en: Stores the number of kills necessary to win the game.
  id: totrans-527
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储赢得游戏所需的击杀数。
- en: Uses our custom player controller, player state, and game state classes.
  id: totrans-528
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我们自定义的玩家控制器、玩家状态和游戏状态类。
- en: Makes it implement the match state functions so that the match starts immediately
    and ends if there is a player that has the required number of kills.
  id: totrans-529
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使其实现比赛状态函数，以便比赛立即开始，并在有玩家达到所需击杀数时结束。
- en: When the match ends, it will perform a server travel to the same level after
    `5` seconds.
  id: totrans-530
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当比赛结束时，它将在 `5` 秒后执行服务器旅行到同一级别。
- en: Handles when a player dies by adding the kill (when killed by another player)
    and the death to the respective player state, as well as respawn the player on
    a random player start.
  id: totrans-531
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理玩家死亡的情况，通过向相应的玩家状态添加击杀（当被其他玩家击杀时）和死亡，并在随机玩家起点重新生成玩家。
- en: Import `AmmoPickup.wav` from `Activity18.01\Assets` into `Content\Pickups\Ammo`.
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `AmmoPickup.wav` 从 `Activity18.01\Assets` 导入到 `Content\Pickups\Ammo` 中。
- en: 'Create `BP_PistolBullets_Pickup` from `AmmoPickup`, place it in `Content\Pickups\Ammo`,
    and configure it with the following values:'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `AmmoPickup` 创建 `BP_PistolBullets_Pickup`，将其放置在 `Content\Pickups\Ammo` 中，并配置以下值：
- en: '`(X=0.5, Y=0.5, Z=0.5)`'
  id: totrans-534
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(X=0.5, Y=0.5, Z=0.5)`'
- en: '`Engine\BasicShapes\Cube`'
  id: totrans-535
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Engine\BasicShapes\Cube`'
- en: '`Content\Weapon\Pistol\MI_Pistol`'
  id: totrans-536
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Weapon\Pistol\MI_Pistol`'
- en: '`Pistol Bullets`'
  id: totrans-537
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pistol Bullets`'
- en: '`25`'
  id: totrans-538
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`25`'
- en: '`Content\Pickup\Ammo\AmmoPickup`'
  id: totrans-539
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Pickup\Ammo\AmmoPickup`'
- en: 'Create `BP_MachineGunBullets_Pickup` from `AmmoPickup`, place it in `Content\Pickups\Ammo`,
    and configure it with the following values:'
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `AmmoPickup` 创建 `BP_MachineGunBullets_Pickup`，将其放置在 `Content\Pickups\Ammo`
    中，并配置以下值：
- en: '`(X=0.5, Y=0.5, Z=0.5)`'
  id: totrans-541
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(X=0.5, Y=0.5, Z=0.5)`'
- en: '`Engine\BasicShapes\Cube`'
  id: totrans-542
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Engine\BasicShapes\Cube`'
- en: '`Content\Weapon\MachineGun\MI_MachineGun`'
  id: totrans-543
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Weapon\MachineGun\MI_MachineGun`'
- en: '`Machine Gun Bullets`'
  id: totrans-544
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Machine Gun Bullets`'
- en: '`50`'
  id: totrans-545
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`50`'
- en: '`Content\Pickup\Ammo\AmmoPickup`'
  id: totrans-546
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Pickup\Ammo\AmmoPickup`'
- en: 'Create `BP_Slugs_Pickup` from `AmmoPickup`, place it in `Content\Pickups\Ammo`,
    and configure it with the following values:'
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `AmmoPickup` 创建 `BP_Slugs_Pickup`，将其放置在 `Content\Pickups\Ammo` 中，并配置以下值：
- en: '`(X=0.5, Y=0.5, Z=0.5)`'
  id: totrans-548
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(X=0.5, Y=0.5, Z=0.5)`'
- en: '`Engine\BasicShapes\Cube`'
  id: totrans-549
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Engine\BasicShapes\Cube`'
- en: '`Content\Weapon\Railgun\MI_Railgun`'
  id: totrans-550
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Weapon\Railgun\MI_Railgun`'
- en: '`Slugs`'
  id: totrans-551
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Slugs`'
- en: '`5`'
  id: totrans-552
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`5`'
- en: '`Content\Pickup\Ammo\AmmoPickup`'
  id: totrans-553
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Pickup\Ammo\AmmoPickup`'
- en: Import `ArmorPickup.wav` from `Activity18.01\Assets` into `Content\Pickups\Armor`.
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `ArmorPickup.wav` 从 `Activity18.01\Assets` 导入到 `Content\Pickups\Armor` 中。
- en: Create the `M_Armor` material in `Content\Pickups\Armor`, which has `Base Color`
    set to `blue` and `Metallic` set to `1`.
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Content\Pickups\Armor` 中创建 `M_Armor` 材质，将 `Base Color` 设置为 `蓝色`，将 `Metallic`
    设置为 `1`。
- en: 'Create `BP_Armor_Pickup` from `ArmorPickup`, place it in `Content\Pickups\Armor`,
    and configure it with the following values:'
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `ArmorPickup` 创建 `BP_Armor_Pickup`，将其放置在 `Content\Pickups\Armor` 中，并配置以下值：
- en: '`(X=1.0, Y=1.5, Z=1.0)`'
  id: totrans-557
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(X=1.0, Y=1.5, Z=1.0)`'
- en: '`Engine\BasicShapes\Cube`'
  id: totrans-558
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Engine\BasicShapes\Cube`'
- en: '`Content\Pickup\Armor\M_Armor`'
  id: totrans-559
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Pickup\Armor\M_Armor`'
- en: '`50`'
  id: totrans-560
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`50`'
- en: '`Content\Pickup\Armor\ArmorPickup`'
  id: totrans-561
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Pickup\Armor\ArmorPickup`'
- en: Import `HealthPickup.wav` from `Activity18.01\Assets` into `Content\Pickups\Health`.
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `HealthPickup.wav` 从 `Activity18.01\Assets` 导入到 `Content\Pickups\Health` 中。
- en: Create the `M_Health` material in `Content\Pickups\Health`, which has `Base
    Color` set to `green` and `Metallic`/`Roughness` set to `0.5`.
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Content\Pickups\Health` 中创建 `M_Health` 材质，将 `Base Color` 设置为 `绿色`，将 `Metallic`/`Roughness`
    设置为 `0.5`。
- en: 'Create `BP_Health_Pickup` from `HealthPickup`, place it in `Content\Pickups\Health`,
    and configure it with the following values:'
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `HealthPickup` 创建 `BP_Health_Pickup`，将其放置在 `Content\Pickups\Health` 中，并配置以下值：
- en: '`Engine\BasicShapes\Sphere`'
  id: totrans-565
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Engine\BasicShapes\Sphere`'
- en: '`Content\Pickup\Health\M_Health`'
  id: totrans-566
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Pickup\Health\M_Health`'
- en: '`50`'
  id: totrans-567
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`50`'
- en: '`Content\Pickup\Health\HealthPickup`'
  id: totrans-568
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Pickup\Health\HealthPickup`'
- en: Import `WeaponPickup.wav` from `Activity18.01\Assets` into `Content\Pickups\Weapon`.
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `WeaponPickup.wav` 从 `Activity18.01\Assets` 导入到 `Content\Pickups\Weapon` 中。
- en: 'Create `BP_Pistol_Pickup` from `WeaponPickup`, place it in `Content\Pickups\Weapon`,
    and configure it with the following values:'
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `WeaponPickup` 创建 `BP_Pistol_Pickup`，将其放置在 `Content\Pickups\Weapon` 中，并配置以下值：
- en: '`Content\Pickup\Weapon\SM_Weapon`'
  id: totrans-571
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Pickup\Weapon\SM_Weapon`'
- en: '`Content\Weapon\Pistol\MI_Pistol`'
  id: totrans-572
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Weapon\Pistol\MI_Pistol`'
- en: '`Pistol`'
  id: totrans-573
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pistol`'
- en: '`25`'
  id: totrans-574
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`25`'
- en: '`Content\Pickup\Weapon\WeaponPickup`'
  id: totrans-575
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Pickup\Weapon\WeaponPickup`'
- en: 'Create `BP_MachineGun_Pickup` from `WeaponPickup`, place it in `Content\Pickups\Weapon`,
    and configure it with the following values:'
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `WeaponPickup` 创建 `BP_MachineGun_Pickup`，将其放置在 `Content\Pickups\Weapon` 中，并配置以下值：
- en: '`Content\Pickup\Weapon\SM_Weapon`'
  id: totrans-577
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Pickup\Weapon\SM_Weapon`'
- en: '`Content\Weapon\MachineGun\MI_MachineGun`'
  id: totrans-578
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Weapon\MachineGun\MI_MachineGun`'
- en: '`Machine Gun`'
  id: totrans-579
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Machine Gun`'
- en: '`50`'
  id: totrans-580
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`50`'
- en: '`Content\Pickup\Weapon\WeaponPickup`'
  id: totrans-581
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Pickup\Weapon\WeaponPickup`'
- en: 'Create `BP_Railgun_Pickup` from `WeaponPickup`, place it in `Content\Pickups\Weapon`,
    and configure it with the following values:'
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `WeaponPickup` 创建 `BP_Railgun_Pickup`，将其放置在 `Content\Pickups\Weapon` 中，并配置以下值：
- en: '`Content\Pickup\Weapon\SM_Weapon`'
  id: totrans-583
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Pickup\Weapon\SM_Weapon`'
- en: '`Content\Weapon\Railgun\MI_Railgun`'
  id: totrans-584
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Weapon\Railgun\MI_Railgun`'
- en: '`Railgun`'
  id: totrans-585
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Railgun`'
- en: '`5`'
  id: totrans-586
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`5`'
- en: '`Content\Pickup\Weapon\WeaponPickup`'
  id: totrans-587
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Pickup\Weapon\WeaponPickup`'
- en: Import `Land.wav` and `Pain.wav` from `Activity18.01\Assets` into `Content\Player\Sounds`.
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Land.wav` 和 `Pain.wav` 从 `Activity18.01\Assets` 导入到 `Content\Player\Sounds`
    中。
- en: Edit `BP_Player` so that it uses the `Pain` and `Land` sounds, as well as deletes
    all of the nodes that create and add the `WBP_HUD` instance to the viewport in
    the `Begin Play` event.
  id: totrans-589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `BP_Player`，使其使用 `Pain` 和 `Land` 声音，并在 `Begin Play` 事件中删除创建和添加 `WBP_HUD`
    实例到视口的节点。
- en: Create a UMG widget called `WBP_Scoreboard_Entry` in `Content\UI` that displays
    the name, kills, deaths, and ping of `FPSPlayerState`.
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Content\UI` 中创建一个名为 `WBP_Scoreboard_Entry` 的 UMG 小部件，用于显示 `FPSPlayerState`
    的名称、击杀数、死亡数和 ping。
- en: Create a UMG widget called `WBP_Scoreboard_Header` that displays the headers
    for the name, kills, deaths, and ping.
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `WBP_Scoreboard_Header` 的 UMG 小部件，用于显示名称、击杀数、死亡数和 ping 的标题。
- en: Create a UMG widget called `WBP_Scoreboard` that displays the kill limit from
    the game state, a vertical box that has `WBP_Scoreboard_Header` as the first entry,
    and then add a `WBP_Scoreboard_Entry` for each `FPSPlayerState` in the game state
    instance. The vertical box will update every `0.5` seconds, through a timer, by
    clearing its children and adding them again.
  id: totrans-592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `WBP_Scoreboard` 的 UMG 小部件，用于显示游戏状态中的击杀限制，一个包含 `WBP_Scoreboard_Header`
    作为第一个条目的垂直框，然后为游戏状态实例中的每个 `FPSPlayerState` 添加一个 `WBP_Scoreboard_Entry`。垂直框将通过计时器每
    `0.5` 秒更新一次，通过清除其子项并重新添加它们来实现。
- en: Edit `WBP_HUD` so that it adds a new text block called `Killed` that starts
    with `Visibility` set to `Hidden`. When the player kills someone, it will make
    the text block visible, display the name of the killed player, and hide after
    `1` second.
  id: totrans-593
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `WBP_HUD`，以便添加一个名为 `Killed` 的新文本块，其 `Visibility` 设置为 `Hidden`。当玩家击杀某人时，它将使文本块可见，显示被击杀玩家的名称，并在
    `1` 秒后隐藏。
- en: Create a new blueprint called `WBP_PlayerMenu` from `PlayerMenu` and place it
    in `Content\UI`. Use a widget switcher with an instance of `WBP_HUD` to index
    `0` and an instance of `WBP_Scoreboard` to index `1`. In the event graph, make
    sure that you override the `Toggle Scoreboard`, `Set Scoreboard Visibility`, and
    `Notify Kill` events that were set as `BlueprintImplementableEvent` in C++. The
    `Toggle Scoreboard` event toggles the widget switcher’s active index between `0`
    and `1`, the `Set Scoreboard Visibility` event sets the widget switcher’s active
    index to `0` or `1`, and the `Notify Kill` event tells the `WBP_HUD` instance
    to set the text and hide it after 1 second.
  id: totrans-594
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `PlayerMenu` 创建一个名为 `WBP_PlayerMenu` 的新蓝图，并将其放置在 `Content\UI` 中。使用一个带有 `WBP_HUD`
    实例的 widget switcher，将其索引设置为 `0`，并使用一个带有 `WBP_Scoreboard` 实例的 widget switcher，将其索引设置为
    `1`。在事件图中，确保覆盖了在 C++ 中设置为 `BlueprintImplementableEvent` 的 `Toggle Scoreboard`、`Set
    Scoreboard Visibility` 和 `Notify Kill` 事件。`Toggle Scoreboard` 事件在 `0` 和 `1` 之间切换
    widget switcher 的活动索引，`Set Scoreboard Visibility` 事件将 widget switcher 的活动索引设置为
    `0` 或 `1`，而 `Notify Kill` 事件告诉 `WBP_HUD` 实例设置文本并在 1 秒后隐藏它。
- en: Create `BP_PlayerController` from `FPSPlayerController`, place it in the `Content`
    folder, and set the `PlayerMenuClass` variable to use `WBP_PlayerMenu`.
  id: totrans-595
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `FPSPlayerController` 创建 `BP_PlayerController`，将其放置在 `Content` 文件夹中，并将 `PlayerMenuClass`
    变量设置为使用 `WBP_PlayerMenu`。
- en: Edit `BP_GameMode` and set `Player Controller Class` to use `BP_PlayerController`.
  id: totrans-596
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `BP_GameMode` 并将 `Player Controller Class` 设置为使用 `BP_PlayerController`。
- en: Create the input action `IA_Scoreboard` to toggle the scoreboard with the *Tab*
    key and update `IMC_Player`.
  id: totrans-597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为 `IA_Scoreboard` 的输入操作，使用 *Tab* 键切换计分板，并更新 `IMC_Player`。
- en: Edit the `DM-Test` level so that you have at least three new player starts placed
    in different locations. Then, place an instance of every different pickup.
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `DM-Test` 级别，确保至少有三个新玩家起点放置在不同的位置。然后，放置每个不同拾取物的实例。
- en: In `-500`.
  id: totrans-599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `-500`。
- en: '**Expected output**:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '**预期输出**:'
- en: '![Figure 18.20 – The expected output of the activity ](img/Figure_18.20_B18531.jpg)'
  id: totrans-601
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.20 – 活动的预期输出](img/Figure_18.20_B18531.jpg)'
- en: Figure 18.20 – The expected output of the activity
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.20 – 活动的预期输出
- en: The result should be a project where each client’s character can use and switch
    between three different weapons. If a character kills another, it should register
    the kill and the death, as well as respawn the character that died at a random
    player start. You should have a scoreboard that displays the name, kill count,
    death count, and ping for each player. A character can fall from the level, which
    should only count as a death, and respawn at a random player start. The character
    should also be able to pick up the different pickups in the level to get ammo,
    armor, health, and weapons. The game should end when the kill limit has been reached
    by showing the scoreboard and server travel to the same level after 5 seconds.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该是一个项目，其中每个客户端的角色都可以使用并切换到三种不同的武器。如果一个角色击杀了另一个角色，它应该记录击杀和死亡，并在随机玩家起点复活被击杀的角色。你应该有一个显示每个玩家的名称、击杀数、死亡数和
    ping 的计分板。一个角色可以从关卡中坠落，这应该只算作一次死亡，并在随机玩家起点复活。角色还应该能够拾取关卡中的不同拾取物以获得弹药、护甲、生命值和武器。当达到击杀限制时，游戏应该通过显示计分板并在
    5 秒后将服务器移动到同一关卡来结束。
- en: Note
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found on GitHub here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在GitHub上找到：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions)。
- en: Summary
  id: totrans-606
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned that the instances of the gameplay framework classes
    exist in some specific game instances, but not in others. You also learned about
    the purpose of the game state and player state classes, as well as new concepts
    for the game mode and some useful built-in functionalities.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解到游戏框架类实例存在于某些特定的游戏实例中，而不是所有实例中。你还学习了游戏状态和玩家状态类的作用，以及游戏模式的新概念和一些有用的内置功能。
- en: At the end of this chapter, you made a basic but functional multiplayer shooter
    that can be used as a foundation to build upon. You added new weapons, ammo types,
    fire modes, pickups, and so on to make it more feature-complete and fun.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的结尾，你创建了一个基本但功能齐全的多人射击游戏，可以作为构建的基础。你添加了新的武器、弹药类型、射击模式、拾取物等，使其功能更完善，游戏性更强。
- en: Having completed this book, you should now have a better understanding of how
    to use UE5 to make games come to life. We’ve covered a lot of topics in this book,
    ranging from the simple to more advanced. You started by learning how to create
    projects using the different templates and how to use Blueprints to create actors
    and components. Then, you learned how to create a fully functioning **Third Person**
    template from scratch by importing the required assets and setting up the Animation
    Blueprint, Blend Space, game mode, and character, as well as defining and handling
    the inputs.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这本书后，你应该现在对如何使用UE5使游戏栩栩如生有了更好的理解。我们在本书中涵盖了众多主题，从简单到更高级。你从学习如何使用不同的模板创建项目开始，然后学习了如何使用蓝图创建演员和组件。接着，你学习了如何从头开始创建一个完全功能的**第三人称**模板，包括导入所需的资产、设置动画蓝图、混合空间、游戏模式和角色，以及定义和处理输入。
- en: Then, you moved on to your first project – a simple stealth game that uses game
    physics and collisions, projectile movement components, actor components, interfaces,
    blueprint function libraries, UMG, sounds, and particle effects. Following this,
    you learned how to create a simple side-scrolling game by using AI, Anim Montages,
    and Destructible Meshes. Finally, you learned how to create a first-person multiplayer
    shooter by using the Server-Client architecture, variable replication, and RPCs,
    as well as how the Player State, Game State, and Game Mode classes work.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你开始了你的第一个项目——一个简单的潜行游戏，它使用了游戏物理和碰撞、弹道运动组件、演员组件、接口、蓝图功能库、UMG、声音和粒子效果。在此之后，你学习了如何通过使用AI、动画蒙太奇和可破坏网格来创建一个简单的横向卷轴游戏。最后，你学习了如何通过使用服务器-客户端架构、变量复制和RPCs来创建一个第一人称多人射击游戏，以及玩家状态、游戏状态和游戏模式类的工作原理。
- en: By working on various projects that use different parts of Unreal Engine, you
    now have a strong understanding of how UE5 works. Although this is the end of
    this book, this is just the beginning of your journey into the world of game development
    using UE5.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 通过参与使用不同部分Unreal Engine的多个项目，你现在对UE5的工作原理有了深刻的理解。尽管这本书的内容到此结束，但这只是你进入使用UE5进行游戏开发世界的旅程的开始。
