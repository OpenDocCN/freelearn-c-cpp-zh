["```cpp\ntemplate <typename Iter>\nstd::string bytes_to_hexstr(Iter begin, Iter end, \n                            bool const uppercase = false)\n{\n   std::ostringstream oss;\n   if(uppercase) oss.setf(std::ios_base::uppercase);\n   for (; begin != end; ++begin)\n     oss << std::hex << std::setw(2) << std::setfill('0') \n         << static_cast<int>(*begin);\n   return oss.str();\n}\n\ntemplate <typename C>\nstd::string bytes_to_hexstr(C const & c, bool const uppercase = false)\n{\n   return bytes_to_hexstr(std::cbegin(c), std::cend(c), uppercase);\n}\n```", "```cpp\nint main()\n{\n   std::vector<unsigned char> v{ 0xBA, 0xAD, 0xF0, 0x0D };\n   std::array<unsigned char, 6> a{ {1,2,3,4,5,6} };\n   unsigned char buf[5] = {0x11, 0x22, 0x33, 0x44, 0x55};\n\n   assert(bytes_to_hexstr(v, true) == \"BAADF00D\");\n   assert(bytes_to_hexstr(a, true) == \"010203040506\");\n   assert(bytes_to_hexstr(buf, true) == \"1122334455\");\n\n   assert(bytes_to_hexstr(v) == \"baadf00d\");\n   assert(bytes_to_hexstr(a) == \"010203040506\");\n   assert(bytes_to_hexstr(buf) == \"1122334455\");\n}\n```", "```cpp\nunsigned char hexchar_to_int(char const ch)\n{\n   if (ch >= '0' && ch <= '9') return ch - '0';\n   if (ch >= 'A' && ch <= 'F') return ch - 'A' + 10;\n   if (ch >= 'a' && ch <= 'f') return ch - 'a' + 10;\n      throw std::invalid_argument(\"Invalid hexadecimal character\");\n}\n\nstd::vector<unsigned char> hexstr_to_bytes(std::string_view str)\n{\n   std::vector<unsigned char> result;\n   for (size_t i = 0; i < str.size(); i += 2) \n   {\n      result.push_back(\n         (hexchar_to_int(str[i]) << 4) | hexchar_to_int(str[i+1]));\n   }\n   return result;\n}\n```", "```cpp\nint main()\n{\n   std::vector<unsigned char> expected{ 0xBA, 0xAD, 0xF0, 0x0D, 0x42 };\n   assert(hexstr_to_bytes(\"BAADF00D42\") == expected);\n   assert(hexstr_to_bytes(\"BaaDf00d42\") == expected);\n}\n```", "```cpp\ntemplate <class Elem>\nusing tstring = std::basic_string<Elem, std::char_traits<Elem>, \n                                  std::allocator<Elem>>;\ntemplate <class Elem>\nusing tstringstream = std::basic_stringstream<\n   Elem, std::char_traits<Elem>, std::allocator<Elem>>;\n\ntemplate <class Elem>\ntstring<Elem> capitalize(tstring<Elem> const & text)\n{\n   tstringstream<Elem> result;\n   bool newWord = true;\n   for (auto const ch : text)\n   {\n      newWord = newWord || std::ispunct(ch) || std::isspace(ch);\n      if (std::isalpha(ch))\n      {\n         if (newWord)\n         {\n            result << static_cast<Elem>(std::toupper(ch));\n            newWord = false;\n         }\n         else\n            result << static_cast<Elem>(std::tolower(ch));\n      }\n      else result << ch;\n   }\n   return result.str();\n}\n```", "```cpp\nint main()\n{\n   using namespace std::string_literals;\n   assert(\"The C++ Challenger\"s ==\n          capitalize(\"the c++ challenger\"s));\n   assert(\"This Is An Example, Should Work!\"s == \n          capitalize(\"THIS IS an ExamplE, should wORk!\"s));\n}\n```", "```cpp\ntemplate <typename Iter>\nstd::string join_strings(Iter begin, Iter end, \n                         char const * const separator)\n{\n   std::ostringstream os;\n   std::copy(begin, end-1, \n             std::ostream_iterator<std::string>(os, separator));\n   os << *(end-1);\n   return os.str();\n}\n\ntemplate <typename C>\nstd::string join_strings(C const & c, char const * const separator)\n{\n   if (c.size() == 0) return std::string{};\n   return join_strings(std::begin(c), std::end(c), separator);\n}\n\nint main()\n{\n   using namespace std::string_literals;\n   std::vector<std::string> v1{ \"this\",\"is\",\"an\",\"example\" };\n   std::vector<std::string> v2{ \"example\" };\n   std::vector<std::string> v3{ };\n\n   assert(join_strings(v1, \" \") == \"this is an example\"s);\n   assert(join_strings(v2, \" \") == \"example\"s);\n   assert(join_strings(v3, \" \") == \"\"s);\n}\n```", "```cpp\ntemplate <class Elem>\nusing tstring = std::basic_string<Elem, std::char_traits<Elem>, \n                                  std::allocator<Elem>>;\n\ntemplate <class Elem>\nusing tstringstream = std::basic_stringstream<\n   Elem, std::char_traits<Elem>, std::allocator<Elem>>;\ntemplate<typename Elem>\ninline std::vector<tstring<Elem>> split(tstring<Elem> text, \n                                        Elem const delimiter)\n{\n   auto sstr = tstringstream<Elem>{ text };\n   auto tokens = std::vector<tstring<Elem>>{};\n   auto token = tstring<Elem>{};\n   while (std::getline(sstr, token, delimiter))\n   {\n      if (!token.empty()) tokens.push_back(token);\n   }\n   return tokens;\n}\n\ntemplate<typename Elem>\ninline std::vector<tstring<Elem>> split(tstring<Elem> text, \n                                        tstring<Elem> const & delimiters)\n{\n   auto tokens = std::vector<tstring<Elem>>{};\n   size_t pos, prev_pos = 0;\n   while ((pos = text.find_first_of(delimiters, prev_pos)) != \n   std::string::npos)\n   {\n      if (pos > prev_pos)\n      tokens.push_back(text.substr(prev_pos, pos - prev_pos));\n      prev_pos = pos + 1;\n   }\n   if (prev_pos < text.length())\n   tokens.push_back(text.substr(prev_pos, std::string::npos));\n   return tokens;\n}\n```", "```cpp\nint main()\n{\n   using namespace std::string_literals;\n   std::vector<std::string> expected{\"this\", \"is\", \"a\", \"sample\"};\n   assert(expected == split(\"this is a sample\"s, ' '));\n   assert(expected == split(\"this,is a.sample!!\"s, \",.! \"s));\n}\n```", "```cpp\nstd::string longest_palindrome(std::string_view str)\n{\n   size_t const len = str.size();\n   size_t longestBegin = 0;\n   size_t maxLen = 1;\n\n   std::vector<bool> table(len * len, false);\n   for (size_t i = 0; i < len; i++)\n      table[i*len + i] = true;\n\n   for (size_t i = 0; i < len - 1; i++)\n   {\n      if (str[i] == str[i + 1]) \n      {\n         table[i*len + i + 1] = true;\n         if (maxLen < 2)\n         {\n            longestBegin = i;\n            maxLen = 2;\n         }\n      }\n   }\n\n   for (size_t k = 3; k <= len; k++)\n   {\n      for (size_t i = 0; i < len - k + 1; i++)\n      {\n         size_t j = i + k - 1;\n         if (str[i] == str[j] && table[(i + 1)*len + j - 1])\n         {\n            table[i*len +j] = true;\n            if (maxLen < k)\n            {\n               longestBegin = i;\n               maxLen = k;\n            }\n         }\n      }\n   }\n   return std::string(str.substr(longestBegin, maxLen));\n}\n```", "```cpp\nint main()\n{\n   using namespace std::string_literals;\n   assert(longest_palindrome(\"sahararahnide\") == \"hararah\");\n   assert(longest_palindrome(\"level\") == \"level\");\n   assert(longest_palindrome(\"s\") == \"s\");\n}\n```", "```cpp\nbool validate_license_plate_format(std::string_view str)\n{\n   std::regex rx(R\"([A-Z]{3}-[A-Z]{2} \\d{3,4})\");\n   return std::regex_match(str.data(), rx);\n}\n\nint main()\n{\n   assert(validate_license_plate_format(\"ABC-DE 123\"));\n   assert(validate_license_plate_format(\"ABC-DE 1234\"));\n   assert(!validate_license_plate_format(\"ABC-DE 12345\"));\n   assert(!validate_license_plate_format(\"abc-de 1234\"));\n}\n```", "```cpp\nstd::vector<std::string> extract_license_plate_numbers(\n                            std::string const & str)\n{\n   std::regex rx(R\"(([A-Z]{3}-[A-Z]{2} \\d{3,4})*)\");\n   std::smatch match;\n   std::vector<std::string> results;\n\n   for(auto i = std::sregex_iterator(std::cbegin(str), std::cend(str), rx); \n       i != std::sregex_iterator(); ++i) \n   {\n      if((*i)[1].matched)\n      results.push_back(i->str());\n   }\n   return results;\n}\n\nint main()\n{\n   std::vector<std::string> expected {\n      \"AAA-AA 123\", \"ABC-DE 1234\", \"XYZ-WW 0001\"};\n   std::string text(\"AAA-AA 123qwe-ty 1234 ABC-DE 123456..XYZ-WW 0001\");\n   assert(expected == extract_license_plate_numbers(text));\n}\n```", "```cpp\nstruct uri_parts\n{\n   std::string                protocol;\n   std::string                domain;\n   std::optional<int>         port;\n   std::optional<std::string> path;\n   std::optional<std::string> query;\n   std::optional<std::string> fragment;\n};\n```", "```cpp\nstd::optional<uri_parts> parse_uri(std::string uri)\n{\n   std::regex rx(R\"(^(\\w+):\\/\\/([\\w.-]+)(:(\\d+))?([\\w\\/\\.]+)?(\\?([\\w=&]*)(#?(\\w+))?)?$)\");\n   auto matches = std::smatch{};\n   if (std::regex_match(uri, matches, rx))\n   {\n      if (matches[1].matched && matches[2].matched)\n      {\n         uri_parts parts;\n         parts.protocol = matches[1].str();\n         parts.domain = matches[2].str();\n         if (matches[4].matched)\n            parts.port = std::stoi(matches[4]);\n         if (matches[5].matched)\n            parts.path = matches[5];\n         if (matches[7].matched)\n            parts.query = matches[7];\n         if (matches[9].matched)\n            parts.fragment = matches[9];\n         return parts;\n      }\n   }\n   return {};\n}\n```", "```cpp\nint main()\n{\n   auto p1 = parse_uri(\"https://packt.com\");\n   assert(p1.has_value());\n   assert(p1->protocol == \"https\");\n   assert(p1->domain == \"packt.com\");\n   assert(!p1->port.has_value());\n   assert(!p1->path.has_value());\n   assert(!p1->query.has_value());\n   assert(!p1->fragment.has_value());\n\n   auto p2 = parse_uri(\"https://bbc.com:80/en/index.html?lite=true#ui\");\n   assert(p2.has_value());\n   assert(p2->protocol == \"https\");\n   assert(p2->domain == \"bbc.com\");\n   assert(p2->port == 80);\n   assert(p2->path.value() == \"/en/index.html\");\n   assert(p2->query.value() == \"lite=true\");\n   assert(p2->fragment.value() == \"ui\");\n}\n```", "```cpp\nstd::string transform_date(std::string_view text)\n{\n   auto rx = std::regex{ R\"((\\d{1,2})(\\.|-|/)(\\d{1,2})(\\.|-|/)(\\d{4}))\" };\n   return std::regex_replace(text.data(), rx, R\"($5-$3-$1)\");\n}\n\nint main()\n{\n   using namespace std::string_literals;\n   assert(transform_date(\"today is 01.12.2017!\"s) == \n          \"today is 2017-12-01!\"s);\n}\n```"]