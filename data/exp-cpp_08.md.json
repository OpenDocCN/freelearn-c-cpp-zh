["```cpp\nstruct Email\n{\n  std::string subject;\n  std::string body;\n  std::string from;\n  std::chrono::time_point datetime;\n};\n```", "```cpp\n// let's suppose a million emails is the max for anyone\nconst int MAX_EMAILS = 1'000'000; \nEmail inbox[MAX_EMAILS];\n```", "```cpp\nstd::vector<Email> search(const std::string& word) {\n  std::vector<Email> search_results;  \n  for (all-million-emails) {\n    if (inbox[i].subject.contains(word)) {\n      search_results.push_back(inbox[i]);\n    }\n  }\n  return search_results;\n}\n```", "```cpp\nstd::vector<Email> search(const std::string& word) {\n  return table[word];\n}\n```", "```cpp\ntemplate <typename T>\nclass Vector\n{\npublic:\n  Vector() : buffer_{nullptr}, capacity_{2}, size_{0}\n  {\n    buffer_ = new T[capacity_]; // initializing an empty array\n  }\n  ~Vector() { delete [] buffer_; }\n  // code omitted for brevity\n\npublic:\n  void push_back(const T& item)\n {\n if (size_ == capacity_) {\n // resize\n }\n buffer_[size_++] = item;\n }\n  // code omitted for brevity\n};\n```", "```cpp\ntemplate <typename T>\nclass Vector\n{\npublic:\n  // code omitted for brevity\n  void push_back(const T& item)\n  {\n    if (size_ == capacity_) {\n capacity_ *= 2; // increase the capacity of the vector twice\n T* temp_buffer = new T[capacity_];\n      // copy elements of the old into the new\n for (int ix = 0; ix < size_; ++ix) {\n temp_buffer[ix] = buffer_[ix];\n }\n delete [] buffer_; // free the old array\n buffer_ = temp_buffer; // point the buffer_ to the new array\n }\n    buffer_[size_++] = item;\n  }\n  // code omitted for brevity\n};\n```", "```cpp\n// code omitted for brevity\nvoid push_front(const T& item)\n{\n  if (size_ == capacity_) {\n    // resizing code omitted for brevity\n  }\n  // shifting all the elements to the right\n for (int ix = size_ - 1; ix > 0; --ix) {\n buffer_[ix] = buffer[ix - 1];\n }\n  // adding item at the front buffer_[0] = item;\n  size_++;\n}\n```", "```cpp\ntemplate <typename T>\nstruct node \n{\n  node(const T& it) : item{it}, next{nullptr}, prev{nullptr} {}\n  T item;\n  node<T>* next;\n  node<T>* prev;\n};\n```", "```cpp\ntemplate <typename T>\nclass LinkedList \n{\n  // code omitted for brevity\npublic:\n  void push_front(const T& item) \n {\n node<T>* new_node = new node<T>{item};\n if (head_ != nullptr) {\n new_node->next = head_->next;\n if (head_->next != nullptr) {\n head_->next->prev = new_node;\n }\n }\n new_node->next = head_;\n head_ = new_node;\n }\nprivate:\n  node<T>* head_; \n};\n```", "```cpp\nstruct Email \n{\n  // code omitted for brevity\n};\n\nint main() {\n  Email obj;\n  Email* ptr;\n}\n```", "```cpp\ntemplate <typename T>\nclass Vector\n{\npublic:\n  // code omitted for brevity\n\nprivate:\n  int capacity_;\n  int size_;\n  T* buffer_;\n};\n```", "```cpp\nint main()\n{\n  Vector<int> v;\n}\n```", "```cpp\n// we continue the code from previous listing\nv.push_back(17);\nv.push_back(21);\nv.push_back(74);\n```", "```cpp\nint main()\n{\n  LinkedList<int> list;\n}\n```", "```cpp\nlist.push_back(19);\n```", "```cpp\nint main()\n{\n  LinkedList<int> list;\n  list.push_back(19);\n  int* random = new int(129);\n  list.push_back(22);\n}\n```", "```cpp\ntemplate <typename T, typename Allocator = std::allocator<T> >\nclass vector;\n```", "```cpp\nnamespace pmr {\n  template <typename T>\n  using vector = std::vector<T, std::pmr::polymorphic_allocator<T>>;\n}\n```", "```cpp\n#include <vector>\n\nint main()\n{\n  std::vector<int> vec;\n  vec.push_back(4);\n  vec.push_back(2);\n  for (const auto& elem : vec) {\n    std::cout << elem;\n  }\n}\n```", "```cpp\nstd::vector<int> vec;\nvec.reserve(10000);\n```", "```cpp\nvec.shrink_to_fit();\n```", "```cpp\nstd::cout << vec.at(2);\n// is the same as\nstd::cout << vec[2];\n// which is the same as\nstd::cout << vec.data()[2];\n```", "```cpp\ntry {\n  vec.at(999999);\n} catch (std::out_of_range& e) { }\n```", "```cpp\nstd::list<double> lst;\nlst.push_back(4.2);\nlst.push_front(3.14);\n// the list contains: \"3.14 -> 4.2\"\n```", "```cpp\nstruct Point\n{\n  float x;\n  float y;\n  float z;\n\n  Point(float px, float py, float pz)\n    : x(px), y(py), z(pz)\n  {}\n\n  Point(Point&& p)\n    : x(p.x), y(p.y), z(p.z)\n  {}\n};\n```", "```cpp\nstd::vector<Point> points;\npoints.push_back(Point(1.1, 2.2, 3.3));\n```", "```cpp\npoints.emplace_back(1.1, 2.2, 3.3);\n```", "```cpp\nvoid push(const value_type& value);\nvoid push(value_type&& value);\n```", "```cpp\n#include <stack>\n\nint main()\n{\n  std::stack<int> st;\n  st.push(1); // stack contains: 1\n  st.push(2); // stack contains: 2 1\n  st.push(3); // stack contains: 3 2 1\n}\n```", "```cpp\n#include <stack>\n\nint main()\n{\n  std::stack<int> st;\n  st.push(1);\n  st.push(2);\n  st.push(3);\n  std::cout << st.top(); // prints 3\n  st.pop();\n  std::cout << st.top(); // prints 2\n  st.pop();\n  std::cout << st.top(); // prints 1\n  st.pop();\n  std::cout << st.top(); // crashes application\n}\n```", "```cpp\n#include <queue>\n\nint main()\n{\n std::queue<char> q;\n  q.push('a');\n  q.push('b');\n  q.push('c');\n  std::cout << q.front(); // prints 'a'\n  std::cout << q.back(); // prints 'c'\n  q.pop();\n  std::cout << q.front(); // prints 'b'\n}\n```", "```cpp\nint r = (a + b) + (((x * y) - (a / b)) / 4);\n```", "```cpp\nstd::vector<int> vec{1, 2, 3, 4, 5};\nfor (int ix = 0; ix < vec.size(); ++ix) {\n  std::cout << vec[ix];\n}\n```", "```cpp\nstd::list<double> lst{1.1, 2.2, 3.3, 4.2};\nfor (auto& elem : lst) {\n  std::cout << elem;\n} \n```", "```cpp\nstd::vector<int> vec{1, 2, 3, 4};\nstd::vector<int>::iterator it{vec.begin()};\n```", "```cpp\nauto it_begin = std::begin(lst);\nauto it_end = std::end(lst);\nfor ( ; it_begin != it_end; ++it_begin) {\n  std::cout << *it_begin;\n}\n```", "```cpp\nstd::vector<int> vec;\nvec.push_back(4);\nvec.push_back(2);\nstd::vector<int>::iterator it = vec.begin();\nstd::cout << *it; // 4\nit++;\nstd::cout << *it; // 2\n\nstd::list<int> lst;\nlst.push_back(4);\nlst.push_back(2);\nstd::list<int>::iterator lit = lst.begin();\nstd::cout << *lit; // 4\nlit++;\nstd::cout << *lit; // 2\n```", "```cpp\nauto it = vec.begin();\nstd::cout << *(it + 3);\n```", "```cpp\ntemplate <typename Iter>\nstd::size_type distance(Iter first, Iter second) {\n  if (Iter is a random_access_iterator) {\n    return second - first; \n  }\n  std::size_type count = 0;\n  for ( ; first != last; ++count, first++) {}\n  return count;\n}\n```", "```cpp\n#include <iterator>\n#include <type_traits>\n\ntemplate <typename Iter>\ntypename std::iterator_traits<Iter>::difference_type distance(Iter first, Iter last)\n{\n  using category = std::iterator_traits<Iter>::iterator_category;\n  if constexpr (std::is_same_v<category, std::random_access_iterator_tag>) {\n    return last - first;\n  }\n  typename std::iterator_traits<Iter>::difference_type count;\n  for (; first != last; ++count, first++) {}\n  return count;\n}\n```", "```cpp\ntemplate <class T, class U>\ninline constexpr bool is_same_v = is_same<T, U>::value;\n```", "```cpp\n#include <algorithm>\n#include <vector>\n#include <list>\n...\nstd::vector<int> vec;\n// insert elements into the vector\nstd::list<int> lst;\n// insert elements into the list\n\nstd::sort(vec.begin(), vec.end());\nstd::sort(lst.begin(), lst.end());\n```", "```cpp\nstd::vector<int> ivec;\nstd::vector<Person> persons;\nstd::vector<std::vector<double>> float_matrix;\n```", "```cpp\nstd::int_vector ivec;\nstd::custom_vector persons; // supposing the custom_vector stores void* \nstd::double_vector_vector float_matrix;\n```", "```cpp\ntemplate <typename T>\nclass Wallet\n{\n  // the body of the class using the T type\n};\n```", "```cpp\ntemplate <addable T>\nclass Wallet\n{\n  // the body of the class using addable T's\n};\n```", "```cpp\nclass Book \n{\n  // doesn't have an operator+\n  // the body is omitted for brevity\n};\n\nconstexpr bool operator+(const Money& a, const Money& b) { \n  return Money{a.value_ + b.value_}; \n}\n\nclass Money\n{\n  friend constexpr bool operator+(const Money&, const Money&);\n  // code omitted for brevity\nprivate:\n  double value_;\n};\n\nWallet<Money> w; // works fine\nWallet<Book> g; // compile error\n```", "```cpp\ntemplate <*parameter-list*>\nconcept *name-of-the-concept* = *constraint-expression*;\n```", "```cpp\ntemplate <typename T>\nconcept addable = requires (T obj) { obj + obj; }\n```", "```cpp\ntemplate <typename T>\nconcept incrementable = std::regular<T> && std::weakly_incrementable<T>\n            && requires (T t) { {t++} -> std::same_as<T>; };\n```", "```cpp\ntemplate <typename T>\nint search(const std::vector<T>& vec, const T& item)\n{\n  for (int ix = 0; ix < vec.size(); ++ix) {\n    if (vec[ix] == item) {\n      return ix;\n    }\n  }\n  return -1; // not found\n}\n```", "```cpp\ntemplate <typename T>\nint search(const std::vector<T>& vec, const T& item)\n{\n  for (int ix = 0;           // 1 copy\n       ix < vec.size;        // n + 1 comparisons \n       ++ix)                 // n + 1 increments\n  {  \n    if (vec[ix] == item) {   // n comparisons\n      return ix;             // 1 copy\n    }\n  }\n  return -1;                 // 1 copy\n}\n```", "```cpp\ntemplate <typename Iter, typename T>\nint search(Iter first, Iter last, const T& elem)\n{\n  for (std::size_t count = 0; first != last; first++, ++count) {\n    if (*first == elem) return count;\n  }\n  return -1;\n}\n...\nstd::vector<int> vec{4, 5, 6, 7, 8};\nstd::list<double> lst{1.1, 2.2, 3.3, 4.4};\n\nstd::cout << search(vec.begin(), vec.end(), 5);\nstd::cout << search(lst.begin(), lst.end(), 5.5);\n```", "```cpp\ntemplate <typename T>\nstd::size_t binsearch(const std::vector<T>& vec, const T& item, int start, int end)\n{\n  if (start > end) return -1;\n  int mid = start + (end - start) / 2;\n  if (vec[mid] == item) {\n    return mid; // found\n  }\n  if (vec[mid] > item) {\n    return binsearch(vec, item, start, mid - 1);\n  }\n  return binsearch(vec, item, mid + 1, end);\n}\n```", "```cpp\ntemplate <typename Iter, typename T>\nbool binary_search(Iter start, Iter end, const T& elem);\n```", "```cpp\n#include <vector>\n#include <list>\n#include <algorithm>\n...\nstd::vector<int> vec{1, 2, 3, 4, 5};\nstd::list<int> lst{1, 2, 3, 4};\nbinary_search(vec.begin(), vec.end(), 8);\nbinary_search(lst.begin(), lst.end(), 3);\n```", "```cpp\n#include <vector>\n#include <algorithm>\n...\nstd::vector<int> vec{4, 7, -1, 2, 0, 5};\nstd::sort(vec.begin(), vec.end());\n// -1, 0, 2, 4, 5, 7\n```", "```cpp\nstruct Product\n{\n  int price;\n  bool available;\n  std::string title;\n};\n\nstd::vector<Product> products;\nproducts.push_back({5, false, \"Product 1\"});\nproducts.push_back({12, true, \"Product 2\"});\n```", "```cpp\nclass ProductComparator\n{\npublic:\n bool operator()(const Product& a, const Product& b) {\n return a.price > b.price;\n }\n};\n```", "```cpp\nstd::sort(products.begin(), products.end(), ProductComparator{});\n```", "```cpp\nstd::sort(products.begin(), products.end(), \n  [](const Product& a, const Product& b) { return a.price > b.price; })\n```", "```cpp\ntemplate <typename T>\nstruct tree_node\n{\n  T item;\n  tree_node<T>* left;\n  tree_node<T>* right;\n};\n```", "```cpp\n#include <set>\n...\nstd::set<int> s{1, 5, 2, 4, 4, 4, 3};\n// s has {1, 2, 3, 4, 5}\n```", "```cpp\n#include <map>\n...\nstd::map<int, std::string> numbers;\nnumbers[3] = \"three\";\nnumbers[4] = \"four\";\n...\n```", "```cpp\nstd::vector<std::list<T> > hash_table;\n```", "```cpp\ntemplate <typename T>\nint hash(const T& key)\n{\n  // generate and return and efficient\n  // hash value from key based on the key's type\n}\n\ntemplate <typename T, typename U>\nvoid insert_into_hashtable(const T& key, const U& value)\n{\n  int index = hash(key);\n  hash_table[index].push_back(value); // insert into the list\n}\n```", "```cpp\n#include <unordered_map>\n...\nstd::unordered_map<std::string, std::string> hashtable;\nhashtable[\"key1\"] = \"value 1\";\nhashtable[\"key2\"] = \"value 2\";\n...\n```", "```cpp\n#include <list>\n#include <unordered_map>\n\ntemplate <typename T>\nclass Graph\n{\npublic: \n  Graph();\n  ~Graph();\n  // copy, move constructors and assignment operators omitted for brevity\n\npublic:\n  void insert_edge(const T& source, const T& target);\n  void remove_edge(const T& source, const T& target);\n\n  bool connected(const T& source, const T& target);\n\nprivate:\n  std::unordered_map<T, std::list<T> > hashtable_;\n};\n```", "```cpp\nclass my_string\n{\npublic:\n my_string();\n // code omitted for brevity\n\npublic:\n void insert(char ch);\n // code omitted for brevity\n\nprivate:\n char* buffer_;\n int size_;\n int capacity_;\n};\n```"]