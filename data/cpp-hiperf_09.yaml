- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Essential Utilities
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本实用程序
- en: This chapter will introduce some essential classes from the C++ **Utility library**.
    Some of the metaprogramming techniques presented in the previous chapter will
    be used in order to work effectively with collections that contain elements of
    different types.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍C++**实用库**中的一些基本类。在处理包含不同类型元素的集合时，将使用前一章介绍的一些元编程技术以便有效地工作。
- en: 'C++ containers are homogenous, meaning that they can only store elements of
    one single type. A `std::vector<int>` stores a collection of integers and all
    objects stored in a `std::list<Boat>` are of type `Boat`. But sometimes, we need
    to keep track of a collection of elements of different types. I will refer to
    these collections as **heterogenous collections**. In a heterogeneous collection,
    the elements may have different types. The following figure shows an example of
    a homogenous collection of `int`s and a heterogenous collection with elements
    of different types:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: C++容器是同类的，意味着它们只能存储单一类型的元素。`std::vector<int>`存储一组整数，`std::list<Boat>`中存储的所有对象都是`Boat`类型。但有时，我们需要跟踪不同类型的元素集合。我将这些集合称为**异类集合**。在异类集合中，元素可能具有不同的类型。下图显示了一个整数的同类集合的示例和一个具有不同类型元素的异类集合的示例：
- en: '![](img/B15619_09_01.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_09_01.png)'
- en: 'Figure 9.1: Homogenous and heterogenous collections'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：同类和异类集合
- en: 'This chapter will cover a set of useful templates from the C++ Utility library
    that can be used to store multiple values of various types. The chapter is divided
    into four sections:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖C++实用库中一组有用的模板，这些模板可用于存储各种类型的多个值。本章分为四个部分：
- en: Representing optional values with `std::optional`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::optional`表示可选值
- en: Fixed size collections using `std::pair`, `std::tuple`, and `std::tie()`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::pair`、`std::tuple`和`std::tie()`来固定大小的集合
- en: Dynamically sized collections using the standard containers with elements of
    type `std::any` and `std::variant`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准容器存储具有`std::any`和`std::variant`类型的元素的动态大小集合
- en: Some real-world examples that demonstrate the usefulness of `std::tuple` and
    `std::tie()`, together with the metaprogramming concepts we covered in *Chapter
    8*, *Compile-Time Programming*
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些真实世界的例子展示了`std::tuple`和`std::tie()`的有用性，以及我们在*第8章*中涵盖的元编程概念
- en: Let's begin by exploring `std::optional` and some of its important use cases.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先探索`std::optional`及其一些重要的用例。
- en: Representing optional values with std::optional
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用std::optional表示可选值
- en: Although quite a minor feature from C++17, `std::optional` is a nice addition
    to the standard library. It simplifies a common case that couldn't be expressed
    in a clean and straightforward way prior to `std::optional`. In a nutshell, it
    is a small wrapper for any type where the wrapped type can be either initialized or
    uninitialized.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在C++17中是一个相当次要的特性，`std::optional`是标准库的一个不错的补充。它简化了一个以前无法以清晰和直接的方式表达的常见情况。简而言之，它是任何类型的一个小包装器，其中包装的类型可以是*初始化*或*未初始化*。
- en: To put it in C++ lingo, `std::optional` is a* stack-allocated container with
    a max size of one*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 用C++术语来说，`std::optional`是一个*最大大小为一的栈分配容器*。
- en: Optional return values
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选返回值
- en: 'Before the introduction of `std::optional`, there was no clear way to define
    functions that may not return a defined value, such as the intersection point
    of two line segments. With the introduction of `std::optional`, such optional
    return values can be clearly expressed. What follows is an implementation of a
    function that returns an optional intersection between two lines:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入`std::optional`之前，没有明确的方法来定义可能不返回定义值的函数，例如两条线段的交点。引入`std::optional`后，这样的可选返回值可以得到清晰的表达。接下来是一个返回两条线之间的可选交点的函数的实现：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The syntax of `std::optional` resembles that of a pointer; the value is accessed
    by `operator*()` or `operator->()`. Trying to access the value of an empty optional
    using `operator*()` or `operator->()` is undefined behavior. It''s also possible
    to access the value using the `value()` member function, which instead will throw
    an `std::bad_optional_access` exception if the optional contains no value. What
    follows is a simple example of a returned `std::optional`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::optional`的语法类似于指针；值通过`operator*()`或`operator->()`访问。尝试使用`operator*()`或`operator->()`访问空的可选值的值是未定义行为。还可以使用`value()`成员函数访问值，如果可选值不包含值，则会抛出`std::bad_optional_access`异常。接下来是一个返回的简单`std::optional`的示例：'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The object held by a `std::optional`  is always stack allocated, and the memory
    overhead for wrapping a type into a `std::optional`  is the size of a bool (usually
    one byte), plus possible padding.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::optional`持有的对象始终是栈分配的，将类型包装到`std::optional`的内存开销是一个布尔值的大小（通常为一个字节），加上可能的填充。'
- en: Optional member variables
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选成员变量
- en: 'Let''s say we have a class that represents a human head. The head can have
    a hat of some sort, or no hat at all. By using `std::optional` to represent the
    hat member variable, the implementation is as expressive as it can be:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个表示人头的类。头部可以戴一顶帽子，也可以不戴帽子。通过使用`std::optional`来表示帽子成员变量，实现就可以尽可能地表达出来：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Without `std::optional`, representing an optional member variable would rely
    on, for example, a pointer or an extra `bool` member variable. Both have disadvantages
    such as allocating on the heap, or accidentally accessing an optional considered
    empty without a warning.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有`std::optional`，表示可选成员变量将依赖于例如指针或额外的`bool`成员变量。两者都有缺点，例如在堆上分配，或者在没有警告的情况下意外访问被认为是空的可选。
- en: Avoiding empty states in enums
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免枚举中的空状态
- en: 'A pattern that can be seen in old C++ code bases is *empty states* or *null
    states* in `enum`s. Here is an example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧的C++代码库中可以看到的一个模式是`enum`中的*空状态*或*空状态*。这是一个例子：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding `enum`, `none` is a so-called null state. The reason for adding
    the `none` value in the `Color` `enum` is to make it possible to represent an
    optional color, for example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`enum`中，`none`是所谓的空状态。在`Color`的`enum`中添加`none`值的原因是为了表示可选颜色，例如：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: However, with this design, there is no way to represent a non-optional color,
    which makes it necessary for *all* code to handle the extra null state `none`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用这种设计，没有办法表示非可选颜色，这使得*所有*代码都必须处理额外的空状态`none`。
- en: 'A better alternative is to avoid the extra null state, and instead represent
    an optional color with the type `std::optional<Color>`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的替代方案是避免额外的空状态，而是用类型`std::optional<Color>`表示可选颜色：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This clearly indicates that we might not get a color back. But we also know
    that once we have a `Color` object, there is no way it can be null:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这清楚地表明我们可能无法得到一个颜色。但我们也知道一旦有了`Color`对象，它就不可能为空：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When implementing `set_color()`, we know that the client has passed a valid
    color.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现`set_color()`时，我们知道客户端传递了有效的颜色。
- en: Sorting and comparing std::optional
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序和比较std::optional
- en: 'The `std::optional` is equally comparable and sortable using the rules shown
    in the following table:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::optional`同样可以使用下表中显示的规则进行比较和排序：'
- en: '| Two *empty* optional values are considered equal. | An empty optional is
    considered *less* than a non-empty. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 两个*空*可选值被认为是相等的。| 空的可选值被认为*小于*非空的可选值。|'
- en: '|'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Therefore, if you sort a container of `std::optional<T>`, the empty optional
    values will end up at the beginning of the container, whereas the non-empty optionals
    will be sorted as usual, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果对`std::optional<T>`的容器进行排序，空的可选值将出现在容器的开头，而非空的可选值将像通常一样排序，如下所示：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you are in the habit of representing optional values using pointers, designing
    APIs using out parameters, or adding special null states in enums, it's time to
    add `std::optional` to your toolbox, as it provides an efficient and safe alternative
    to these anti-patterns.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您习惯使用指针表示可选值，设计使用输出参数的API，或在枚举中添加特殊的空状态，那么现在是时候将`std::optional`添加到您的工具箱中了，因为它提供了这些反模式的高效且安全的替代方案。
- en: Let's continue by exploring collections of a fixed size that can hold elements
    of different types.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探讨可以容纳不同类型元素的固定大小集合。
- en: Fixed size heterogenous collections
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 固定大小异构集合
- en: 'The C++ Utility library includes two class templates that can be used for storing
    multiple values of different types: `std::pair` and `std::tuple`. They are both
    collections with a fixed size. Just like `std::array`, it''s not possible to add
    more values dynamically at runtime.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: C++实用库包括两个可以用于存储不同类型的多个值的类模板：`std::pair`和`std::tuple`。它们都是固定大小的集合。就像`std::array`一样，在运行时动态添加更多值是不可能的。
- en: The big difference between `std::pair` and `std::tuple` is that `std::pair`
    can only hold two values, whereas `std::tuple` can be instantiated with an arbitrary
    size at compile time. We will begin with a brief introduction to `std::pair` before
    moving on to `std::tuple`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::pair`和`std::tuple`之间的主要区别在于`std::pair`只能容纳两个值，而`std::tuple`可以在编译时用任意大小进行实例化。我们将从简要介绍`std::pair`开始，然后转向`std::tuple`。'
- en: Using std::pair
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用std::pair
- en: 'The class template `std::pair` lives in the `<utility>` header and has been
    available in C++ since the introduction of the standard template library. It is
    used in the standard library where algorithms need to return two values, such
    as `std::minmax()`, which can return both the smallest and the greatest value
    of an initializer list:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板`std::pair`位于`<utility>`头文件中，并且自从标准模板库引入以来就一直可用于C++。它在标准库中用于算法需要返回两个值的情况，比如`std::minmax()`，它可以返回初始化列表的最小值和最大值：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding example shows that the elements of a `std::pair` can be accessed
    through the members `first` and `second`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子显示了可以通过成员`first`和`second`访问`std::pair`的元素。
- en: Here, the `std::pair` holds values of the same type, so, it would have been
    possible to return an array here as well. But what makes `std::pair` even more
    interesting is that it can hold values of *different* types. This is the reason
    why we consider this a heterogeneous collection, despite the fact that it can
    only hold two values.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`std::pair`保存相同类型的值，因此也可以在这里返回一个数组。但是`std::pair`更有趣的地方在于它可以保存*不同*类型的值。这就是为什么我们认为这是一个异构集合的原因，尽管它只能容纳两个值。
- en: 'An example from the standard library where `std::pair` holds different values
    is the associative container `std::map`. The value type of `std::map` is a pair
    that consists of the key and the element that the key is associated with:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中`std::pair`保存不同值的一个例子是关联容器`std::map`。`std::map`的值类型是一个由键和与键关联的元素组成的对：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The requirement to explicitly name the `std::pair` type has decreased, and
    in modern C++, it''s common to use initializer lists and structured bindings to
    hide the fact that we are dealing with values of `std::pair`. The following example
    expresses the same thing but without mentioning the underlying `std::pair` explicitly:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 显式命名`std::pair`类型的要求已经减少，在现代C++中，使用初始化列表和结构化绑定来隐藏我们正在处理`std::pair`值的事实是很常见的。下面的例子表达了相同的事情，但没有明确提到底层的`std::pair`：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will talk more about structured binding later in this chapter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面更多地讨论结构化绑定。
- en: As the name suggests, `std::pair` can only hold two values. C++11 introduced
    a new utility class called `std::tuple`, which is a generalization of `std::pair`
    that can hold an arbitrary number of elements.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，`std::pair`只能容纳两个值。C++11引入了一个名为`std::tuple`的新实用类，它是`std::pair`的泛化，可以容纳任意数量的元素。
- en: The std::tuple
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: std::tuple
- en: The `std::tuple` can be used as a fixed-size heterogeneous collection that can
    be declared to be of any size. In contrast to `std::vector`, for example, its
    size cannot change at runtime; you cannot add or remove elements.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::tuple`可以用作固定大小的异构集合，可以声明为任意大小。与`std::vector`相比，它的大小在运行时不能改变；您不能添加或删除元素。'
- en: 'A tuple can be constructed with its member types explicitly specified like
    this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 元组可以这样构造，其成员类型明确指定：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Or, we can initialize it using class template argument deduction, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用类模板参数推导进行初始化，如下所示：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will make the compiler generate a class, which can roughly be viewed like
    this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使编译器生成一个类，大致可以看作是这样的：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As with many other classes in the C++ standard library, `std::tuple` also has
    a corresponding `std::make_tuple()` function, which deduces the types automatically
    from the parameters:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 与C++标准库中的许多其他类一样，`std::tuple`也有一个对应的`std::make_tuple()`函数，它可以从参数中自动推断类型：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: But as stated earlier, from C++17 and onward, many of these `std::make_` functions
    are superfluous, since C++17 classes can deduce these types from the constructor.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如前面所述，从C++17开始，许多这些`std::make_`函数都是多余的，因为C++17类可以从构造函数中推断出这些类型。
- en: Accessing the members of a tuple
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问元组的成员
- en: 'The individual elements of `std::tuple` can be accessed using the free function
    template `std::get<Index>()`. You may wonder why the members can''t be accessed
    like a regular container with the `at(size_t index)` member function. The reason
    is that a member function such as `at()` is only allowed to return one type, whereas
    a tuple consists of different types at different indices. Instead, the function
    template `std::get()` is used with the index as a template parameter:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用自由函数模板`std::get<Index>()`访问`std::tuple`的各个元素。你可能会想为什么不能像常规容器一样使用`at(size_t
    index)`成员函数访问成员。原因是`at()`这样的成员函数只允许返回一个类型，而元组在不同索引处包含不同类型。相反，使用带有索引的函数模板`std::get()`作为模板参数：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can imagine the `std::get()` function being implemented something like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象`std::get()`函数的实现类似于这样：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This means that when we create and access a tuple as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当我们创建和访问元组时：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'the compiler roughly generates the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器大致生成以下代码：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that this example can merely be thought of as a simplistic way to imagine
    what the compiler generates when constructing `std::tuple`; the interior of `std::tuple`
    is very complex. Still, it is important to understand that a `std::tuple` class
    is basically a simple struct whose members can be accessed by a compile-time index.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个例子只能被认为是一种简单的想象，用来想象编译器在构造`std::tuple`时生成的内容；`std::tuple`的内部非常复杂。然而，重要的是要理解，`std::tuple`类基本上是一个简单的结构，其成员可以通过编译时索引访问。
- en: 'The `std::get()` function template can also use the typename as a parameter.
    It is used like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::get()`函数模板也可以使用typename作为参数。它的使用方式如下：'
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is only possible if the specified type is contained once in the tuple.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当指定的类型在元组中包含一次时才可能。
- en: Iterating std::tuple members
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代std::tuple成员
- en: 'From a programmer''s perspective, it may seem that `std::tuple` can be iterated
    with a regular range-based `for`-loop, just like any other container, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从程序员的角度来看，似乎`std::tuple`可以像任何其他容器一样使用常规的基于范围的`for`循环进行迭代，如下所示：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The reason this is not possible is that the type of `const auto& v` is only
    evaluated once, and since `std::tuple` contains elements of different types, this
    code simply does not compile.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这不可能的原因是`const auto& v`的类型只被评估一次，而由于`std::tuple`包含不同类型的元素，这段代码根本无法编译。
- en: The same goes for regular algorithms, as iterators don't mutate the type pointed
    to; therefore, `std::tuple` does not provide a `begin()` or `end()` member function,
    nor does it provide a subscript operator, `[]`, for accessing the values. So,
    we need to come up with some other way to unroll the tuple.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于常规算法也是一样，因为迭代器不会改变指向的类型；因此，`std::tuple`不提供`begin()`或`end()`成员函数，也不提供用于访问值的下标运算符`[]`。因此，我们需要想出其他方法来展开元组。
- en: Unrolling the tuple
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展开元组
- en: 'As tuples cannot be iterated as usual, what we need to do is use metaprogramming
    to unroll the loop. From the previous example, we want the compiler to generate
    something like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于元组不能像通常那样进行迭代，我们需要使用元编程来展开循环。从前面的例子中，我们希望编译器生成类似于这样的东西：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, we iterate every index of the tuple, which means we need the
    number of types/values contained in the tuple. Then, since the tuple contains
    different types, we need to write a meta-function that generates a new function
    for every type in the tuple.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们迭代元组的每个索引，这意味着我们需要知道元组中包含的类型/值的数量。然后，由于元组包含不同类型，我们需要编写一个生成元组中每种类型的新函数的元函数。
- en: 'If we start with a function that generates the call for a specific index, it
    will look like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从一个为特定索引生成调用的函数开始，它会看起来像这样：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can then combine it with a generic lambda, as you learned in *Chapter 2,*
    *Essential C++ Techniques**:*
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以将其与通用lambda结合使用，就像你在*第2章* *Essential C++ Techniques*中学到的那样：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With the function `tuple_at()` in place, we can then move on to the actual
    iteration. The first thing we need is the number of values in the tuple as a compile-time
    constant. Fortunately, this value can be obtained by the type trait `std::tuple_size_v<Tuple>`.
    Using `if constexpr`, we can then unfold the iteration by creating a similar function,
    which takes different actions, depending on the index:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`tuple_at()`函数，我们就可以继续进行实际的迭代。我们首先需要的是元组中值的数量作为编译时常量。幸运的是，这个值可以通过类型特征`std::tuple_size_v<Tuple>`获得。使用`if
    constexpr`，我们可以通过创建一个类似的函数来展开迭代，根据索引采取不同的操作：
- en: If the index is equal to the tuple size, it generates an empty function
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果索引等于元组大小，它会生成一个空函数
- en: Otherwise, it executes the lambda at the passed index and generates a new function
    with 1 added to the index
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，它会在传递的索引处执行lambda，并生成一个索引增加1的新函数
- en: 'This is how the code will look:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将如下所示：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As you can see, the default index is set to zero so that we don''t have to
    specify it when iterating. This `tuple_for_each()` function can then be called
    like this, with the lambda directly in place:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，默认索引设置为零，这样在迭代时就不必指定它。然后可以像这样调用`tuple_for_each()`函数，直接放在lambda的位置：
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Quite nice; syntactically, it looks pretty similar to the `std::for_each()`
    algorithm.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 相当不错；从语法上看，它看起来与`std::for_each()`算法非常相似。
- en: Implementing other algorithms for tuples
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为元组实现其他算法
- en: 'Expanding upon `tuple_for_each()`, different algorithms iterating a tuple can
    be implemented in a similar manner. Here is an example of how `std::any_of()`
    for tuples is implemented:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tuple_for_each()`的基础上，可以以类似的方式实现迭代元组的不同算法。以下是`std::any_of()`为元组实现的示例：
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It can be used like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以这样使用：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The function template `tuple_any_of()` iterates through every type in the tuple
    and generates a lambda function for the element at the current index, which it
    then compares with `44`. In this case, `has_44` will evaluate to `true`, as the
    last element, a `double` value, is `44`. If we add an element of a type that is
    not comparable with `44`, such as `std::string`, we will get a compilation error.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 函数模板`tuple_any_of()`遍历元组中的每种类型，并为当前索引处的元素生成一个lambda函数，然后将其与`44`进行比较。在这种情况下，`has_44`将评估为`true`，因为最后一个元素，即`double`值，是`44`。如果我们添加一个与`44`不可比较的类型的元素，比如`std::string`，我们将得到一个编译错误。
- en: Accessing tuple elements
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问元组元素
- en: 'Prior to C++17, there were two standard ways of accessing elements of a `std::tuple`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17之前，有两种标准方法可以访问`std::tuple`的元素：
- en: For accessing single elements, the function `std::get<N>(tuple)` was used.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了访问单个元素，使用了函数`std::get<N>(tuple)`。
- en: For accessing multiple elements, the function `std::tie()` was used.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了访问多个元素，使用了函数`std::tie()`。
- en: 'Although they both worked, the syntax for performing such a simple task was
    very verbose, as shown in the following example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们都起作用，但执行这样一个简单任务的语法非常冗长，如下例所示：
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In order to be able to perform this common task elegantly, structured bindings
    were introduced in C++17.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够优雅地执行这个常见任务，C++17引入了结构化绑定。
- en: Structured bindings
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结构化绑定
- en: 'Using structured bindings, multiple variables can be initialized at once using
    `auto` and a bracket declaration list. As with the `auto` keyword in general,
    you can apply control over whether the variables should be mutable references,
    forward references, const references, or values by using the corresponding modifier.
    In the following example, a structured binding of `const` references is being
    constructed:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用结构化绑定，可以使用`auto`和括号声明列表一次初始化多个变量。与一般情况下的`auto`关键字一样，可以通过使用相应的修饰符来控制变量是否应该是可变引用、前向引用、const引用或值。在下面的示例中，正在构造`const`引用的结构化绑定：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Structured bindings can also be used to extract the individual members of a
    tuple in a `for`-loop, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化绑定也可以用于在`for`循环中提取元组的各个成员，如下所示：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here''s a quick tip. If you want to return multiple arguments with named variables
    instead of tuple indices, it is possible to return a struct defined inside a function
    and use automatic return type deduction:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个快速提示。如果你想要返回具有命名变量的多个参数，而不是元组索引，可以在函数内部定义一个结构体并使用自动返回类型推导：
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Structured bindings also work with structs, so, we might capture the individual
    data members directly as follows, even if it is a struct:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化绑定也适用于结构体，因此，我们可以直接捕获各个数据成员，如下所示，即使它是一个结构体：
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this case, we can choose arbitrary names for our identifiers since it's the
    order of the data members of `Planet` that is relevant, just like when returning
    a tuple.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以选择任意名称作为标识符，因为`Planet`的数据成员的顺序是相关的，就像返回元组时一样。
- en: Now, we will look at another use case for `std::tuple` and `std::tie()` when
    handling an arbitrary number of function arguments.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看看在处理任意数量的函数参数时，`std::tuple`和`std::tie()`的另一个用例。
- en: The variadic template parameter pack
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可变模板参数包
- en: The **variadic** **template parameter pack** enables programmers to create template
    functions that can accept any number of arguments.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**可变模板参数包**使程序员能够创建可以接受任意数量参数的模板函数。'
- en: An example of a function with a variadic number of arguments
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 具有可变数量参数的函数示例
- en: 'If we were to create a function that makes a string out of any number of arguments
    without variadic template parameter packs, we would need to use C-style variadic
    arguments (just like `printf()` does) or create a separate function for every
    number of arguments:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要创建一个将任意数量的参数转换为字符串的函数，而不使用可变模板参数包，我们需要使用C风格的可变参数（就像`printf()`一样）或为每个参数数量创建一个单独的函数：
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is the intended use of our function:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们函数的预期用法：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If we require a large number of arguments, this becomes tedious, but with a
    parameter pack, we can implement this as a function that accepts an arbitrary
    number of arguments.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要大量的参数，这变得很繁琐，但是使用参数包，我们可以将其实现为一个接受任意数量参数的函数。
- en: How to construct a variadic parameter pack
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 如何构造可变参数包
- en: 'The parameter pack is identified by putting three dots in front of the typename
    and three dots after the variadic argument expands the pack, with a comma in-between:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 参数包通过在类型名称前面放置三个点和在可变参数后面放置三个点来识别，用逗号分隔扩展包：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here''s the syntactic explanation:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个语法解释：
- en: '`Ts` is a list of types'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ts`是类型列表'
- en: '`<typename ...Ts>` indicates that the function deals with a list'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<typename ...Ts>`表示函数处理一个列表'
- en: '`values...` expands the pack such that a comma is added between every value'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values...`扩展包，使得每个值之间都添加了逗号。'
- en: 'To put it into code, consider this `expand_pack()` function template:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 将其转化为代码，考虑这个`expand_pack()`函数模板：
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s call the preceding function like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们这样调用前面的函数：
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In this case, the compiler will generate a function similar to this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，编译器将生成一个类似于这样的函数：
- en: '[PRE40]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This is what the individual parameter pack parts expand to:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是各个参数包部分扩展到的内容：
- en: '| Expression: | Expands to: |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 表达式： | 扩展为： |'
- en: '| `template <typename... Ts>` | `template <typename T0, typename T1>` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `template <typename... Ts>` | `template <typename T0, typename T1>` |'
- en: '| `expand_pack(const Ts& ...values)` | `expand_pack(const T0& v0, const T1&
    v1)` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `expand_pack(const Ts& ...values)` | `expand_pack(const T0& v0, const T1&
    v1)` |'
- en: '| `std::tie(values...)` | `std::tie(v0, v1)` |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `std::tie(values...)` | `std::tie(v0, v1)` |'
- en: 'Table 9.1: Expanding expressions'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.1：扩展表达式
- en: Now, let's see how we can create a `make_string()` function with a variadic
    parameter pack.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何创建一个带有可变参数包的`make_string()`函数。
- en: 'Going further with the initial `make_string()` function, in order to create
    a string out of every parameter, we need to iterate the pack. There is no way
    to directly iterate a parameter pack, but a simple workaround would be to make
    a tuple out of it and then iterate it with the `tuple_for_each()` function template,
    as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步扩展初始的`make_string()`函数，为了从每个参数创建一个字符串，我们需要迭代参数包。没有直接迭代参数包的方法，但一个简单的解决方法是将其转换为元组，然后使用`tuple_for_each()`函数模板进行迭代，如下所示：
- en: '[PRE41]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The parameter pack is converted into a `std::tuple` with `std::tie()` and then
    iterated using `tuple_for_each()`. To recap, the reason we need to use `std::tuple`
    to handle the parameters are because we want to support an arbitrary number of
    parameters of various types. If we only had to support parameters of one specific
    type, we could instead have used a `std::array` with a range-based `for`-loop,
    like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 参数包被转换为`std::tuple`，然后使用`tuple_for_each()`进行迭代。回顾一下，我们需要使用`std::tuple`来处理参数的原因是因为我们希望支持各种类型的任意数量的参数。如果我们只需要支持特定类型的参数，我们可以使用带有范围`for`循环的`std::array`，如下所示：
- en: '[PRE42]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you have seen, `std::tuple` is a heterogenous collection with a fixed size
    and fixed element positions—more or less like a regular struct but without named
    member variables.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，`std::tuple`是一个具有固定大小和固定元素位置的异构集合，更或多或少类似于常规结构，但没有命名的成员变量。
- en: How can we expand upon this to create a dynamically sized collection (such as
    `std::vector` and `std::list`) but with the ability to store elements of mixed
    types? We'll look at a solution to this in the following section.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何扩展这个以创建一个动态大小的集合（例如`std::vector`和`std::list`），但具有存储混合类型元素的能力？我们将在下一节中看到这个问题的解决方案。
- en: Dynamically sized heterogenous collections
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态大小的异构集合
- en: We started this chapter by noting that the dynamically sized containers offered
    by C++ are homogenous, meaning that we can only store elements of one single type.
    But sometimes, we need to keep track of a collection that's dynamic in size that
    contains elements of different types. To be able to do that, we will use containers
    that contain elements of type `std::any` or `std::variant`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章开始时指出，C++提供的动态大小容器是同质的，这意味着我们只能存储单一类型的元素。但有时，我们需要跟踪一个大小动态的集合，其中包含不同类型的元素。为了能够做到这一点，我们将使用包含`std::any`或`std::variant`类型元素的容器。
- en: 'The simplest solution is to use `std::any` as the base type. The `std::any`
    object can store any type of value in it:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的解决方案是使用`std::any`作为基本类型。`std::any`对象可以存储其中的任何类型的值：
- en: '[PRE43]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: It has some drawbacks, though. First, every time a value in it is accessed,
    the type must be tested for at runtime. In other words, we completely lose the
    type information of the stored value at compile time. Rather, we have to rely
    on runtime type checks for the information. Secondly, it allocates the object
    on the heap rather than the stack, which can have significant performance implications.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它也有一些缺点。首先，每次访问其中的值时，必须在运行时测试类型。换句话说，我们在编译时完全失去了存储值的类型信息。相反，我们必须依赖运行时类型检查来获取信息。其次，它在堆上分配对象而不是栈上，这可能会对性能产生重大影响。
- en: 'If we want to iterate our container, we need to explicitly say this to every
    `std::any` object: *if you are an int, do this, and if you are a char pointer,
    do that*. This is not desirable as it requires repeated source code, and it is
    also less efficient than using other alternatives, which we will cover later in
    this chapter.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要迭代我们的容器，我们需要明确告诉每个`std::any`对象：*如果你是一个int，就这样做，如果你是一个char指针，就那样做*。这是不可取的，因为它需要重复的源代码，并且比使用其他替代方案效率低，我们将在本章后面介绍。
- en: 'The following example compiles; the type is explicitly tested for and casted
    upon:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例已编译；类型已明确测试并转换：
- en: '[PRE44]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We simply cannot print it with a regular stream operator since the `std::any`
    object has no idea of how to access its stored value. Therefore, the following
    code does not compile; the compiler does not know what''s stored in `std::any`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法使用常规流操作符打印它，因为`std::any`对象不知道如何访问其存储的值。因此，以下代码不会编译；编译器不知道`std::any`中存储了什么：
- en: '[PRE45]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We usually don't need the full flexibility of types that `std::any` offers,
    and in many cases, we are better off using the `std::variant`, which we will cover
    next.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们不需要`std::any`提供的类型的完全灵活性，在许多情况下，我们最好使用`std::variant`，接下来我们将介绍。
- en: The std::variant
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: std::variant
- en: If we don't need the ability to store *any* type in the container, but instead
    we want to concentrate on a fixed set of types declared at container initialization,
    then `std::variant` is a better choice.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不需要在容器中存储*任何*类型，而是想要集中在容器初始化时声明的固定类型集合上，那么`std::variant`是更好的选择。
- en: 'The `std::variant` has two main advantages over `std::any`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::variant`相对于`std::any`有两个主要优势：'
- en: It does not store its contained type on the heap (unlike `std::any`)
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不会将其包含的类型存储在堆上（不像`std::any`）
- en: It can be invoked with a generic lambda, meaning you don't explicitly have to
    know its currently contained type (more about this in the later sections of this
    chapter)
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以通过通用lambda调用，这意味着您不必明确知道其当前包含的类型（本章后面将更多介绍）
- en: 'The `std::variant` works in a somewhat similar manner to a tuple, except that
    it only stores one object at a time. The contained type and value are the type
    and value we assigned it last. The following image illustrates the difference
    between a `std::tuple` and a `std::variant` when they''ve been instantiated with
    the same types:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::variant`的工作方式与元组有些类似，只是它一次只存储一个对象。包含的类型和值是我们最后分配的类型和值。以下图示了在使用相同类型实例化`std::tuple`和`std::variant`时它们之间的区别：'
- en: '![](img/B15619_09_02.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_09_02.png)'
- en: 'Figure 9.2: Tuple of types versus variant of types'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：类型元组与类型变体
- en: 'Here''s an example of using a `std::variant`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`std::variant`的示例：
- en: '[PRE46]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We are using `std::holds_alternative<T>()` to check whether the variant currently
    holds a given type. You can see that the type changes when we assign the variant
    new values.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`std::holds_alternative<T>()`来检查变体当前是否持有给定类型。您可以看到，当我们为变体分配新值时，类型会发生变化。
- en: 'Apart from storing the actual value, a `std::variant` also keeps track of the
    currently held alternative by using an index that''s usually of size `std::size_t`.
    This means that the total size of a `std::variant` is typically the size of the
    biggest alternative, plus the size of the index. We can verify this by using the
    `sizeof` operator for our types:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 除了存储实际值外，`std::variant`还通过使用通常为`std::size_t`大小的索引来跟踪当前持有的备用。这意味着`std::variant`的总大小通常是最大备用的大小加上索引的大小。我们可以通过使用`sizeof`运算符来验证我们的类型：
- en: '[PRE47]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Compiling and running this code using Clang 10.0 with libc++ generates the
    following output:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有libc++的Clang 10.0编译和运行此代码将生成以下输出：
- en: '[PRE48]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As you can see, the size of the `VariantType` is the sum of `std::string` and
    `std::size_t`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`VariantType`的大小是`std::string`和`std::size_t`的总和。
- en: Exception safety of std::variant
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: std::variant的异常安全性
- en: 'When a new value is assigned to a `std::variant` object, it is placed in the
    same location as the currently held value of the variant. If, for some reason,
    the construction or assignment of the new value fails and throws an exception,
    the old value may not be restored. Instead, the variant can become **valueless**.
    You can check whether a variant object is valueless by using the member function
    `valueless_by_exception()`. This can be demonstrated when trying to construct
    an object using the `emplace()` member function:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当向`std::variant`对象分配新值时，它被放置在变体当前持有值的相同位置。如果由于某种原因，新值的构造或分配失败并引发异常，则可能不会恢复旧值。相反，变体可以变为**无值**。您可以使用成员函数`valueless_by_exception()`来检查变体对象是否无值。这可以在尝试使用`emplace()`成员函数构造对象时进行演示：
- en: '[PRE49]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The initial `double` value 1.0 may or may not be gone after the exception has
    been thrown and caught. The operation is not guaranteed to be rolled back, which
    we usually can expect from standard library containers. In other words, `std::variant`
    doesn't provide a strong exception safety guarantee, and the reason for this is
    performance overhead since it would require `std::variant` to use heap allocations.
    This behavior of `std::variant` is a useful feature rather than a shortcoming,
    because it means that you can safely use `std::variant` in code with real-time
    requirements.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在异常被抛出并捕获后，初始的`double`值1.0可能存在，也可能不存在。操作不能保证回滚，这通常是我们可以从标准库容器中期望的。换句话说，`std::variant`不提供强异常安全性保证的原因是性能开销，因为这将要求`std::variant`使用堆分配。`std::variant`的这种行为是一个有用的特性，而不是一个缺点，因为这意味着您可以在具有实时要求的代码中安全地使用`std::variant`。
- en: If you instead want a heap allocating version but with a strong exception safety
    guarantee and a "never-empty" guarantee, `boost::variant` offers this functionality.
    If you are interested in the challenges of implementing such a type, [https://www.boost.org/doc/libs/1_74_0/doc/html/variant/design.html](https://www.boost.org/doc/libs/1_74_0/doc/html/variant/design.html)
    offers an interesting read.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望使用堆分配版本，但具有强异常安全性保证和“永不为空”的保证，`boost::variant`提供了这种功能。如果您对实现这种类型的挑战感兴趣，[https://www.boost.org/doc/libs/1_74_0/doc/html/variant/design.html](https://www.boost.org/doc/libs/1_74_0/doc/html/variant/design.html)提供了一个有趣的阅读。
- en: Visiting variants
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问变体
- en: 'When accessing variables in the `std::variant`, we use the global function
    `std::visit()`. As you might have guessed, we have to use our main companion when
    dealing with heterogeneous types: the generic lambda:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 访问`std::variant`中的变量时，我们使用全局函数`std::visit()`。正如你可能已经猜到的那样，当处理异构类型时，我们必须使用我们的主要伴侣：通用lambda：
- en: '[PRE50]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'When invoking `std::visit()` with the generic lambda and the variant `var`
    in the example, the compiler will conceptually transform the lambda into a regular
    class with `operator()` overloads for every type in the variant. This will look
    something similar to this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中使用通用lambda和变体`var`调用`std::visit()`时，编译器会将lambda概念上转换为一个常规类，该类对变体中的每种类型进行`operator()`重载。这将看起来类似于这样：
- en: '[PRE51]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `std::visit()` function is then expanded to an `if...else` chain using `std::holds_alternative<T>()`,
    or a jump table using the index of the `std::variant`, to generate the correct
    call to `std::get<T>()`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`std::visit()`函数扩展为使用`std::holds_alternative<T>()`的`if...else`链，或使用`std::variant`的索引生成正确的调用`std::get<T>()`的跳转表。
- en: In the previous example, we passed the value in our generic lambda directly
    to `std::cout`, regardless of the currently held alternative. But what if we want
    to do different things, depending on what type we are visiting? A pattern that
    may be used for this situation is to define a variadic class template that will
    inherit from a set of lambdas. We then need to define this for each type that
    we are visiting. Sounds complicated, doesn't it? This may seem a bit magic at
    first and also puts our metaprogramming skills to the test, but once we have the
    variadic class template in place, it's easy to use.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们直接将通用lambda中的值传递给`std::cout`，而不考虑当前持有的备用。但是，如果我们想要根据正在访问的类型执行不同的操作怎么办？在这种情况下可能使用的一种模式是定义一个可变类模板，该模板将继承一组lambda。然后，我们需要为要访问的每种类型定义这个。听起来有点复杂，不是吗？这一开始可能看起来有点神奇，也考验了我们的元编程技能，但是一旦我们有了可变类模板，使用起来就很容易了。
- en: 'We will begin with the variadic class template. Here is how it looks:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从可变类模板开始。以下是它的外观：
- en: '[PRE52]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If you are on a C++17 compiler you also need to add an explicit deduction guide,
    but it''s not needed as of C++20:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是C++17编译器，还需要添加一个显式的推导指南，但在C++20中不需要：
- en: '[PRE53]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'That''s it. The template class `Overloaded` will inherit from all lambdas that
    we will instantiate the template with, and the function call operator, `operator()()`,
    will be overloaded once by each lambda. It''s now possible to create a stateless
    object that only contains multiple overloads of the call operator:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。模板类`Overloaded`将继承我们将使用模板实例化的所有lambda，并且函数调用运算符`operator()()`将被每个lambda重载一次。现在可以创建一个只包含调用运算符的多个重载的无状态对象：
- en: '[PRE54]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We can test it using different arguments and verify that the correct overload
    is being called:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用不同的参数进行测试，并验证是否调用了正确的重载：
- en: '[PRE55]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, we can use this with `std::visit()` and without the need of having the
    `Overloaded` object stored in an lvalue. Here is how it finally looks:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在不需要将`Overloaded`对象存储在左值中的情况下使用`std::visit()`。最终的效果如下：
- en: '[PRE56]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: So, once we have the `Overloaded` template in place, we can use this convenient
    way of specifying a set of lambdas for different types of arguments. In the next
    section, we will start using `std::variant` together with standard containers.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦我们有了`Overloaded`模板，我们就可以使用这种方便的方式来指定一组不同类型参数的lambda。在下一节中，我们将开始使用`std::variant`和标准容器。
- en: Heterogenous collections using variant
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用变体的异构集合
- en: 'Now that we have a variant that can store any type of a provided list, we can
    expand upon this to a heterogeneous collection. We do this by simply creating
    a `std::vector` of our variant:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个可以存储所提供列表中任何类型的变体，我们可以将其扩展为异构集合。我们只需创建一个我们的变体的`std::vector`：
- en: '[PRE57]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We can now push elements of different types to our vector:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以向向量中推送不同类型的元素：
- en: '[PRE58]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The vector will now look like this in memory, where every element in the vector
    contains the size of the variant, which in this case is `sizeof(std::size_t) +
    sizeof(std::string)`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，向内存中的向量看起来是这样的，其中向量中的每个元素都包含变体的大小，本例中为`sizeof(std::size_t) + sizeof(std::string)`：
- en: '![](img/B15619_09_03.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_09_03.png)'
- en: 'Figure 9.3: Vector of variants'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：变体的向量
- en: 'Of course, we can also `pop_back()` or modify the container in any other way
    the container allows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以使用`pop_back()`或以容器允许的任何其他方式修改容器：
- en: '[PRE59]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Accessing the values in our variant container
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问我们的变体容器中的值
- en: 'Now that we have the boilerplate for a heterogeneous collection that''s dynamic
    in size, let''s see how we can use it like a regular `std::vector`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个大小动态的异构集合的样板，让我们看看如何像常规的`std::vector`一样使用它：
- en: '**Construct a heterogeneous container of variants**: Here, we construct a `std::vector`
    with different types. Note that the initializer list contains different types:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**构造异构变体容器**：在这里，我们构造了一个包含不同类型的`std::vector`。请注意，初始化列表包含不同的类型：'
- en: '[PRE60]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '**Print the content by iterating with a regular for-loop**: To iterate the
    container with a regular `for`-loop, we utilize `std::visit()` and a generic lambda.
    The global function `std::visit()` takes care of the type conversion. The example
    prints each value to `std::cout`, independent of the type:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用常规for循环迭代打印内容**：要使用常规`for`循环迭代容器，我们利用`std::visit()`和一个通用lambda。全局函数`std::visit()`负责类型转换。该示例将每个值打印到`std::cout`，而不考虑类型：'
- en: '[PRE61]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '**Inspect what types are in the container**: Here, we inspect each element
    of the container by type. This is achieved by using the global function `std::holds_alternative<type>`,
    which returns `true` if the variant currently holds the type asked for. The following
    example counts the number of Booleans currently contained in the container:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**检查容器中的类型**：在这里，我们通过类型检查容器的每个元素。这是通过使用全局函数`std::holds_alternative<type>`实现的，该函数在变体当前持有所要求的类型时返回`true`。以下示例计算当前容器中包含的布尔值的数量：'
- en: '[PRE62]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '**Find content by both contained type and value**: In this example, we''re
    inspecting the container both for type and value by combining `std::holds_alternative()`
    and `std::get()`. This example checks whether the container contains a `std::string`
    with the value `"needle"`:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过包含的类型和值查找内容**：在此示例中，我们通过结合`std::holds_alternative()`和`std::get()`来检查容器的类型和值。此示例检查容器是否包含值为`"needle"`的`std::string`：'
- en: '[PRE63]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Global function std::get()
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局函数std::get()
- en: 'The global function template `std::get()` can be used for `std::tuple`, `std::pair`,
    `std::variant`, and `std::array`. There are two ways to instantiate `std::get()`,
    with an index or with a type:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 全局函数模板`std::get()`可用于`std::tuple`、`std::pair`、`std::variant`和`std::array`。有两种实例化`std::get()`的方式，一种是使用索引，一种是使用类型：
- en: '`std::get<Index>()`: When `std::get()` is used with an index, as in `std::get<1>(v)`,
    it returns the value at the corresponding index in a `std::tuple`, `std::pair`,
    or `std::array`.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::get<Index>()`: 当`std::get()`与索引一起使用时，如`std::get<1>(v)`，它返回`std::tuple`、`std::pair`或`std::array`中相应索引处的值。'
- en: '`std::get<Type>()`: When `std::get()` is used with a type, as in `std::get<int>(v)`,
    the corresponding value in a `std::tuple`, `std::pair` or `std::variant` is returned.
    In the case of `std::variant`, a `std::bad_variant_access` exception is thrown
    if the variant doesn''t currently hold that type. Note that if `v` is a `std::tuple`
    and `Type` is contained more than once, you have to use the index to access the
    type.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::get<Type>()`: 当`std::get()`与类型一起使用时，如`std::get<int>(v)`，返回`std::tuple`、`std::pair`或`std::variant`中的相应值。对于`std::variant`，如果变体当前不持有该类型，则会抛出`std::bad_variant_access`异常。请注意，如果`v`是`std::tuple`，并且`Type`包含多次，则必须使用索引来访问该类型。'
- en: Having discussed the essential templates from the Utility library, let's look
    at some real-world applications of what we have covered in this chapter.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了实用程序库中的基本模板之后，让我们看一些实际应用，以了解本章涵盖的内容在实践中的应用。
- en: Some real-world examples
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些实际示例
- en: We will end this chapter by examining two examples where `std::tuple`, `std::tie()`,
    and some template metaprogramming can help us to write clean and efficient code
    in practice.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过检查两个示例来结束本章，其中`std::tuple`、`std::tie()`和一些模板元编程可以帮助我们编写清晰和高效的代码。
- en: 'Example 1: projections and comparison operators'
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例1：投影和比较运算符
- en: 'The need to implement comparison operators for classes dramatically decreased
    with C++20, but there are still cases where we need to provide a custom comparison
    function when we want to sort objects in some custom order for a specific scenario.
    Consider the following class:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++20中，需要为类实现比较运算符的情况大大减少，但仍然有一些情况下，我们需要为特定场景中的对象提供自定义比较函数。考虑以下类：
- en: '[PRE64]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Say that we want to sort the players by their attributes: the primary sort
    order `level_` and the secondary sort order `score_`. It''s not uncommon to see
    code like this when implementing comparison and sorting:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想按照他们的属性对玩家进行排序：首要排序顺序是`level_`，次要排序顺序是`score_`。在实现比较和排序时，看到这样的代码并不罕见：
- en: '[PRE65]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Writing comparison operators in this style using nested `if-else` blocks quickly
    becomes error-prone when the number of attributes increases. What we really want
    to express is that we are comparing a *projection* of `Player` attributes (in
    this case, a strict subset). The `std::tuple` can help us rewrite this code in
    a cleaner way without the need for `if-else` statements.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当属性数量增加时，使用嵌套的`if-else`块编写这种风格的比较运算符很容易出错。我们真正想表达的是我们正在比较`Player`属性的*投影*（在这种情况下是一个严格的子集）。`std::tuple`可以帮助我们以更清晰的方式重写这段代码，而不需要`if-else`语句。
- en: 'Let''s use `std::tie()`, which creates a `std::tuple` holding references to
    the lvalues we pass to it. The following code creates two projections, `p1` and
    `p2`, and compares them using the `<` operator:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`std::tie()`，它创建一个包含我们传递给它的lvalue引用的`std::tuple`。以下代码创建了两个投影，`p1`和`p2`，并使用`<`运算符进行比较：
- en: '[PRE66]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This is very clean and easy to read compared to the initial version using `if-else`
    statements. But is this really efficient? It seems like we need to create temporary
    objects just to compare two players. When running this in a microbenchmark and
    also inspecting the generated code, there is really no overhead at all to using
    `std::tie()`; in fact, the version using `std::tie()` was, in this example, slightly
    faster than the version using `if-else` statements.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用`if-else`语句的初始版本相比，这非常清晰易读。但这真的有效吗？看起来我们需要创建临时对象来比较两个玩家。在微基准测试中运行这个代码并检查生成的代码时，使用`std::tie()`实际上没有任何开销；事实上，在这个例子中，使用`std::tie()`的版本比使用`if-else`语句的版本稍微快一些。
- en: 'Using the ranges algorithms, we can do the sorting by providing the projection
    as an argument to `std::ranges::sort()`, which makes the code even cleaner:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用范围算法，我们可以通过将投影作为参数提供给`std::ranges::sort()`来进行排序，使代码更加清晰：
- en: '[PRE67]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This is an example of how `std::tuple` can be used in contexts where a full
    struct with named members is not needed, without sacrificing any clarity in the
    code.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`std::tuple`在不需要完整的具有命名成员的结构的情况下使用的一个例子，而不会在代码中牺牲任何清晰度。
- en: 'Example 2: reflection'
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例2：反射
- en: The term **reflection** refers to the ability to inspect a class without knowing
    anything about its contents. In contrast to many other programming languages,
    C++ does not have built-in reflection, which means we have to write the reflection
    functionality ourselves. Reflection is planned to be included in future versions
    of the C++ standard; hopefully, we will see this feature in C++23.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**反射**指的是在不知道类的内容的情况下检查类的能力。与许多其他编程语言不同，C++没有内置的反射，这意味着我们必须自己编写反射功能。反射计划包括在未来版本的C++标准中；希望我们能在C++23中看到这个功能。
- en: In this example, we are going to limit the reflection to give classes the ability
    to iterate their members, just like we can iterate the members of a tuple. By
    using reflection, we can create generic functions for serialization or logging
    that automatically work with any class. This reduces large amounts of boilerplate
    code, which is traditionally required for classes in C++.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将限制反射，使类能够迭代它们的成员，就像我们可以迭代元组的成员一样。通过使用反射，我们可以创建用于序列化或记录的通用函数，这些函数可以自动适用于任何类。这减少了在C++中传统上需要的大量样板代码。
- en: Making a class reflect its members
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使一个类反映其成员
- en: 'Since we need to implement all the reflection functionality ourselves, we will
    start by exposing the member variables via a function called `reflect()`. We will
    continue to use the `Player` class that was introduced in the previous section.
    Here is how it looks when we add the `reflect()` member function and a constructor:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要自己实现所有的反射功能，我们将从通过一个名为`reflect()`的函数公开成员变量开始。我们将继续使用在上一节中介绍的`Player`类。在这里，我们添加`reflect()`成员函数和一个构造函数的样子如下：
- en: '[PRE68]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `reflect()` member function returns a tuple of references to the member
    variables by invoking `std::tie()`. We can now start using the `reflect()` function,
    but first, a note about alternatives to using handcrafted reflection.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`reflect()`成员函数通过调用`std::tie()`返回成员变量的引用的元组。我们现在可以开始使用`reflect()`函数，但首先，关于使用手工制作的反射的替代方案的说明。'
- en: C++ libraries that simplify reflection
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简化反射的C++库
- en: There have been quite a few attempts in the C++ library world to simplify the
    creation of reflection. One example is the metaprogramming library *Boost Hana*
    by Louis Dionne, which gives classes reflection capabilities via a simple macro.
    Recently, *Boost* has also added *Precise and Flat Reflection* by Anthony Polukhin,
    which *automatically* reflects public content of classes, as long as all members
    are simple types.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++库世界中已经有了相当多的尝试来简化反射的创建。一个例子是Louis Dionne的元编程库*Boost Hana*，它通过一个简单的宏为类提供了反射能力。最近，*Boost*还添加了*Precise
    and Flat Reflection*，由Anthony Polukhin编写，它*自动*反映类的公共内容，只要所有成员都是简单类型。
- en: However, for clarity, in this example, we will only use our own `reflect()`
    member function.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了清晰起见，在这个例子中，我们只会使用我们自己的`reflect()`成员函数。
- en: Using reflection
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用反射
- en: Now that the `Player` class has the ability to reflect its member variables,
    we can automate the creation of bulk functionality, which would otherwise require
    us to retype every member variable. As you may already know, C++ automatically
    can generate constructors, destructors, and comparison operators, but other operators
    must be implemented by the programmer. One such function is the `operator<<()`,
    which outputs its contents to a stream in order to store them in a file, or more
    commonly, log them in an application log.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Player`类具有反射其成员变量的能力，我们可以自动创建大量功能，否则需要我们重新输入每个成员变量。正如您可能已经知道的，C++可以自动生成构造函数、析构函数和比较运算符，但其他运算符必须由程序员实现。其中一个这样的函数是`operator<<()`，它将其内容输出到流中以便将其存储在文件中，或更常见的是在应用程序日志中记录它们。
- en: 'By overloading `operator<<()` and using the `tuple_for_each()` function template
    we implemented earlier in this chapter, we can simplify the creation of `std::ostream`
    output for a class, like this:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重载`operator<<()`并使用我们在本章前面实现的`tuple_for_each()`函数模板，我们可以简化为类创建`std::ostream`输出的过程，如下所示：
- en: '[PRE69]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, the class can be used with any `std::ostream` type, like this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，该类可以与任何`std::ostream`类型一起使用，如下所示：
- en: '[PRE70]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: By reflecting our class members via a tuple, we only have to update our reflect
    function when members are added/removed from our class, instead of updating every
    function and iterating all member variables.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 通过通过元组反射我们的类成员，我们只需要在类中添加/删除成员时更新我们的反射函数，而不是更新每个函数并迭代所有成员变量。
- en: Conditionally overloading global functions
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有条件地重载全局函数
- en: Now that we have a mechanism to write bulk functions using reflection rather
    than manually typing each variable, we still need to type the simplified bulk
    functions for every type. What if we wanted these functions to be generated for
    every type that can be reflected?
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了一个使用反射而不是手动输入每个变量来编写大量函数的机制，但我们仍然需要为每种类型输入简化的大量函数。如果我们希望这些函数为每种可以反射的类型生成呢？
- en: We can conditionally enable `operator<<()` for all classes that have a `reflect()`
    member function by using a constraint.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用约束条件来有条件地为所有具有`reflect()`成员函数的类启用`operator<<()`。
- en: 'First, we need to create a new concept that refers to the `reflect()` member
    function:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个指向`reflect()`成员函数的新概念：
- en: '[PRE71]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Of course, this concept only checks whether a class has a member function named
    `reflect()`; it doesn''t always return a tuple. In general, we should be skeptical
    about weak concepts that only use a single member function like this, but it serves
    the purpose of the example. Anyway, we can now overload `operator<<()` in the
    global namespace, giving all reflectable classes the ability to be compared and
    printed to a `std::ostream`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个概念只是检查一个类是否有一个名为`reflect()`的成员函数；它并不总是返回一个元组。总的来说，我们应该对这种只使用单个成员函数的弱概念持怀疑态度，但它对于例子来说是有用的。无论如何，我们现在可以在全局命名空间中重载`operator<<()`，使所有可反射的类都能够被比较并打印到`std::ostream`中：
- en: '[PRE72]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The preceding function template will only be instantiated for types that contain
    the `reflect()` member function, and will therefore not collide with any other
    overload.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数模板只会为包含`reflect()`成员函数的类型实例化，并因此不会与任何其他重载发生冲突。
- en: Testing reflection capabilities
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试反射能力
- en: 'Now, we have everything in place:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备就绪：
- en: The `Player` class we will test has a `reflect()` member function returning
    a tuple of references to its members
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将测试的`Player`类有一个`reflect()`成员函数，返回对其成员的引用的元组
- en: The global `std::ostream& operator<<()` is overloaded for reflectable types
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局`std::ostream& operator<<()`已经重载了可反射类型
- en: 'Here is a simple test that verifies this functionality:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单的测试，用于验证这个功能：
- en: '[PRE73]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: These examples have demonstrated the usefulness of small but essential utilities
    such as `std::tie()` and `std::tuple` when combined with a little bit of metaprogramming.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子展示了`std::tie()`和`std::tuple`等小而重要的实用工具与一点元编程结合时的用处。
- en: Summary
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter you have learned how to use `std::optional` to represent optional
    values in your code. You have also seen how to combine `std::pair`, `std::tuple`,
    `std::any`, and `std::variant` together with standard containers and metaprogramming
    to store and iterate over elements of different types. You also learned that `std::tie()`
    is a conceptually simple yet powerful tool that can be used for projection and
    reflection.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学会了如何使用`std::optional`来表示代码中的可选值。您还看到了如何将`std::pair`、`std::tuple`、`std::any`和`std::variant`与标准容器和元编程结合在一起，以存储和迭代不同类型的元素。您还了解到`std::tie()`是一个概念上简单但功能强大的工具，可用于投影和反射。
- en: In the next chapter, you will find out how to further expand your C++ toolbox
    to create libraries by learning how to construct hidden proxy objects.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将了解如何进一步扩展您的C++工具箱，通过学习如何构建隐藏的代理对象来创建库。
