- en: Designing Microservices
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 设计微服务
- en: With the increasing popularity of microservices, we would like to dedicate to
    them an entire chapter of this book. When discussing architecture, you will probably
    at some point hear, "Should we use microservices for that?" This chapter will
    show you how to migrate an existing application to a microservices architecture
    and how to build a new application that leverages microservices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着微服务的日益流行，我们希望在本书的一个整章中专门讨论它们。在讨论架构时，你可能会听到，“我们应该使用微服务吗？”本章将向您展示如何将现有应用程序迁移到微服务架构，以及如何构建利用微服务的新应用程序。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Diving into microservices
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入微服务
- en: Building microservices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建微服务
- en: Observing microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察微服务
- en: Connecting microservices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接微服务
- en: Scaling microservices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展微服务
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Most of the examples presented in this chapter do not require any specific software.
    For the `redis-cpp` library, check [https://github.com/tdv/redis-cpp](https://github.com/tdv/redis-cpp).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中介绍的大多数示例不需要任何特定的软件。对于`redis-cpp`库，请查看[https://github.com/tdv/redis-cpp](https://github.com/tdv/redis-cpp)。
- en: The code present in the chapter has been placed on GitHub at [https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter13](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter13).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码已放置在GitHub上[https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter13](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter13)。
- en: Diving into microservices
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入微服务
- en: While microservices are not tied to any particular programming language or technology,
    a common choice when implementing microservices has been the Go language. That
    does not mean that other languages are not suitable for microservices development
    – quite the contrary. The low computational and memory overhead of C++ makes it
    an ideal candidate for microservices.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然微服务不受任何特定的编程语言或技术的限制，但在实现微服务时常见的选择是Go语言。这并不意味着其他语言不适合微服务开发-恰恰相反。C++的低计算和内存开销使其成为微服务的理想选择。
- en: But first, we will start with a detailed view of some of the pros and cons of
    microservices. After that, we'll focus on design patterns that are often associated
    with microservices (as opposed to the general design patterns covered in [Chapter
    4](ce968eab-d44c-46ae-8cfb-96076a13e348.xhtml), *Architectural and System Design*).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们将从微服务的一些优缺点的详细视图开始。之后，我们将专注于通常与微服务相关的设计模式（而不是[第4章](ce968eab-d44c-46ae-8cfb-96076a13e348.xhtml)中涵盖的一般设计模式，*架构和系统设计*）。
- en: The benefits of microservices
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务的好处
- en: You may often hear about microservices in superlatives. It is true that they
    can bring some benefits and here are some of them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能经常听到有关微服务的赞美之词。它们确实带来了一些好处，以下是其中一些。
- en: Modularity
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块化
- en: Since the entire application is split into many relatively small modules, it
    is easier to understand what each microservice does. The natural consequence of
    this understanding is that it is also easier to test individual microservices.
    Testing is also aided by the fact that each microservice typically has a limited
    scope. After all, it's easier to test just the calendar application than to test
    the entire **Personal Information Management** (**PIM**) suite.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于整个应用程序被分割成许多相对较小的模块，更容易理解每个微服务的功能。这种理解的自然结果是，测试单个微服务也更容易。测试也受到每个微服务通常具有有限范围的事实的帮助。毕竟，测试日历应用程序比测试整个**个人信息管理**（**PIM**）套件更容易。
- en: This modularity, however, comes at some cost. Your teams may have a much better
    understanding of individual microservices, but at the same time they may find
    it harder to grasp how the entire application is composed. While it shouldn't
    be necessary to learn all the internal details of the microservices that form
    an application, the sheer number of relationships between components presents
    a cognitive challenge. It's good practice to use microservices contracts when
    using this architectural approach.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种模块化也是有代价的。你的团队可能对单个微服务有更好的理解，但同时可能会发现更难理解整个应用程序是如何组成的。虽然不应该需要了解构成应用程序的微服务的所有内部细节，但组件之间的关系数量之多构成了认知挑战。在使用这种架构方法时，使用微服务契约是一个良好的实践。
- en: Scalability
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可扩展性
- en: It is easier to scale applications that are limited in scope. One reason for
    that is that there are fewer potential bottlenecks.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 更容易扩展范围有限的应用程序。其中一个原因是潜在的瓶颈较少。
- en: Scaling smaller pieces of a workflow is also more cost-effective. Imagine a
    monolithic application responsible for managing a trade fair. Once the system
    starts showing performance issues, the only way to scale is to bring in a bigger
    machine for the monolith to run on. This is called vertical scaling.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放工作流程的较小部分也更具成本效益。想象一下，一个负责管理贸易展会的单片应用程序。一旦系统开始出现性能问题，唯一的扩展方式就是为单体引入更大的机器来运行。这被称为垂直扩展。
- en: With microservices, the first advantage is that you can scale horizontally,
    that is, bring in more machines instead of a bigger machine (which is usually
    cheaper). The second advantage comes from the fact that you only need to scale
    those parts of the application that are having performance issues. This also contributes
    to money saved on infrastructure.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务，第一个优势是你可以水平扩展，也就是说，引入更多的机器而不是更大的机器（通常更便宜）。第二个优势来自于你只需要扩展那些出现性能问题的应用程序部分。这也有助于节省基础设施成本。
- en: Flexibility
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 灵活性
- en: Microservices, when properly designed, are less susceptible to vendor lock-in.
    When you decide you want to switch one of the third-party components, you don't
    have to do the entire painful migration all at once. Microservices design takes
    into account that you need to use interfaces, so the only part that requires modification
    is the interface between your microservice and the third-party component.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当正确设计时，微服务不太容易受到供应商锁定的影响。当您决定要更换第三方组件中的一个时，您不必一次性进行整个痛苦的迁移。微服务设计考虑到您需要使用接口，因此唯一需要修改的部分是您的微服务与第三方组件之间的接口。
- en: The components may also migrate one by one, some still using the software from
    the old provider. This means you can separate the risk of introducing breaking
    changes in many places at once. What's more, you can combine this with the canary
    deployments pattern to manage risk with even more granularity.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 组件也可以逐个迁移，有些仍在使用旧提供商的软件。这意味着您可以将在多个地方引入破坏性变化的风险分开。而且，您可以将这与金丝雀部署模式结合起来，以更精细地管理风险。
- en: This flexibility is not related just to single services. It may also mean different
    databases, different queueing and messaging solutions, or even entirely different
    cloud platforms. While different cloud platforms typically offer different services
    and APIs to use them, with a microservices architecture, you can start migrating
    your workload piece by piece and test it independently on a new platform.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活性不仅仅与单个服务有关。它也可能意味着不同的数据库、不同的排队和消息传递解决方案，甚至完全不同的云平台。虽然不同的云平台通常提供不同的服务和API来使用它们，但是在微服务架构中，您可以逐步开始迁移工作负载，并在新平台上独立测试它。
- en: When rewrites are necessary due to performance issues, scalability, or available
    dependencies, it is much faster to rewrite a microservice than a monolith.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当由于性能问题、可扩展性或可用依赖性而需要重写时，重写微服务要比重写单体应用程序快得多。
- en: Integration with legacy systems
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与传统系统集成
- en: Microservices are not necessarily an all-or-nothing approach. If your application
    is well-tested and migration to microservices may create a lot of risks, there's
    no pressure to dismantle the working solution altogether. It is even better to
    split only the parts that require further development and introduce them as microservices
    that the original monolith will use.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务不一定是一刀切的方法。如果您的应用程序经过了充分测试，并且迁移到微服务可能会带来很多风险，那么就没有必要完全拆除正在运行的解决方案。最好只拆分需要进一步开发的部分，并将它们作为原始单体应用程序将使用的微服务引入。
- en: By following this approach, you will gain the benefits of the agile release
    cycle associated with microservices, while at the same time avoiding creating
    a new architecture from scratch and basically rebuilding an entire application.
    If something is already working well, it's better to focus on how to add new features
    without breaking the good parts, rather than starting from scratch. Be careful
    here, as starting from scratch is often used as an ego boost!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这种方法，您将获得与微服务相关的敏捷发布周期的好处，同时避免从头开始创建新架构并基本上重建整个应用程序。如果某些东西已经运行良好，最好专注于如何在不破坏良好部分的情况下添加新功能，而不是从头开始。在这里要小心，因为从头开始通常被用作自我提升！
- en: Distributed development
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分布式开发
- en: The times of development teams being small and colocated are long gone. Remote
    work and distributed development are a fact even in traditional office-based companies.
    Giants such as IBM, Microsoft, and Intel have people from different locations
    working together on a single project.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 开发团队规模小且共同办公的时代已经一去不复返。远程工作和分布式开发即使在传统的办公公司中也是事实。像IBM、微软和英特尔这样的巨头公司有来自不同地点的人们一起在一个项目上工作。
- en: Microservices allow for smaller and more agile teams, which makes distributed
    development much easier. When it's no longer necessary to facilitate communication
    between a group of 20 or more people, it's also easier to build self-organized
    teams that require less external management.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务允许更小更灵活的团队，这使得分布式开发变得更加容易。当不再需要促进20人或更多人之间的沟通时，也更容易构建需要较少外部管理的自组织团队。
- en: Disadvantages of microservices
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务的缺点
- en: Even if you think you may need microservices due to their benefits, keep in
    mind that they also have some serious drawbacks. In short, they are definitely
    not for everyone. Larger companies can generally offset these drawbacks, but smaller
    companies often don't have this luxury.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您认为由于其好处，您可能需要微服务，也要记住它们也有一些严重的缺点。简而言之，它们绝对不适合每个人。大公司通常可以抵消这些缺点，但较小的公司通常没有这种奢侈。
- en: Reliance on a mature DevOps approach
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖成熟的DevOps方法
- en: Building and testing microservices should be much faster than performing similar
    operations on big, monolithic applications. But in order to achieve agile development,
    this building and testing would need to be performed much more often.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和测试微服务应该比在大型单片应用上执行类似操作要快得多。但为了实现敏捷开发，这种构建和测试需要更频繁地进行。
- en: While it may be sensible to deploy the application manually when you are dealing
    with a monolith, the same approach will lead to a lot of problems if applied to
    microservices.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在处理单体应用程序时手动部署应用程序可能是明智的，但是如果应用于微服务，同样的方法将导致许多问题。
- en: In order to embrace the microservices in your development, you have to ensure
    that your team has a DevOps mindset and understands the requirements of both building
    and running the microservice. It's not enough to simply hand the code to someone
    else and forget about it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在开发中采用微服务，您必须确保您的团队具有DevOps思维，并了解构建和运行微服务的要求。仅仅将代码交给其他人然后忘记它是不够的。
- en: The DevOps mindset will help your team to automate as much as possible. Developing
    microservices without a continuous integration/continuous delivery pipeline is
    probably one of the worst possible ideas in software architecture. Such an approach
    will bring all the other disadvantages of microservices without enabling most
    of the benefits.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps思维将帮助您的团队尽可能自动化。在软件架构中，开发微服务而没有持续集成/持续交付流水线可能是最糟糕的想法之一。这种方法将带来微服务的所有其他缺点，而又无法实现大部分的好处。
- en: Harder to debug
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试更困难
- en: Microservices require introducing observability. Without it, when something
    breaks, you're never sure where to start looking for the potential root cause.
    Observability is a way to deduce the state of your application without the need
    to run a debugger or log to the machines your workload is running on.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务需要引入可观察性。没有它，当出现问题时，你永远不确定从哪里开始寻找潜在的根本原因。可观察性是一种推断应用程序状态的方式，而无需运行调试器或记录工作负载所在的机器。
- en: A combination of log aggregation, application metrics, monitoring, and distributed
    tracing is a prerequisite to manage microservices-based architecture. This is
    especially true once you consider that autoscaling and self-healing may even prevent
    you from accessing individual services if they start crashing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 日志聚合、应用程序指标、监控和分布式跟踪的组合是管理基于微服务的架构的先决条件。一旦考虑到自动扩展和自愈，甚至可能阻止您访问个别服务（如果它们开始崩溃），这一点尤其重要。
- en: Additional overhead
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 额外开销
- en: Microservices should be lean and agile. And that's usually true. However, microservices-based
    architecture usually requires additional overhead. The first layer of overhead
    is related to the additional interfaces used for microservices communication.
    RPC libraries and API providers and consumers have to be multiplied not only by
    the number of microservices but also by the number of their replicas. Then there
    are auxiliary services, such as databases, message queues, and so on. Those services
    also include observability facilities that usually consist of both storage facilities
    and individual collectors that gather data.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务应该是精益和敏捷的。通常情况下是这样的。然而，基于微服务的架构通常需要额外的开销。首层开销与微服务通信使用的额外接口有关。RPC库和API提供者和消费者不仅要按微服务的数量增加，还要按其副本的数量增加。然后还有辅助服务，如数据库、消息队列等。这些服务还包括通常由存储设施和收集数据的个体收集器组成的可观察性设施。
- en: The costs that you optimize with better scaling may be outweighed by the costs
    required to run the entire fleet of services that don't bring immediate business
    value. What's more, it may be hard for you to justify these costs (both in terms
    of infrastructure and development overhead) to the stakeholders.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更好的扩展优化的成本可能会被运行整个服务群所需的成本所抵消，而这些服务并没有带来即时的业务价值。而且，你可能很难向利益相关者证明这些成本（无论是基础设施还是开发开销）。
- en: Design patterns for microservices
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务的设计模式
- en: A lot of general design patterns apply to microservices as well. There are also
    some design patterns that are typically associated with microservices. The patterns
    presented here are useful for both greenfield projects as well as migration from
    monolithic applications.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 许多通用设计模式也适用于微服务。还有一些设计模式通常与微服务相关联。这里介绍的模式对于绿地项目和从单块应用程序迁移都很有用。
- en: Decomposition patterns
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分解模式
- en: These patterns relate to the ways in which microservices are decomposed. We
    want to ensure the architecture is stable and the services are loosely coupled.
    We also want to make sure that services are cohesive and testable. Finally, we
    want autonomous teams to fully own one or more services.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式涉及微服务的分解方式。我们希望确保架构稳定，服务之间松耦合。我们还希望确保服务具有内聚性和可测试性。最后，我们希望自治团队完全拥有一个或多个服务。
- en: Decomposition by business capability
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 按业务能力分解
- en: One of the decomposition patterns requires decomposition by business capability.
    Business capability relates to what a business does in order to produce value.
    Examples of business capabilities are merchant management and customer management.
    Business capabilities are often organized in a hierarchy.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种分解模式要求按业务能力进行分解。业务能力涉及业务为产生价值而做的事情。业务能力的例子包括商家管理和客户管理。业务能力通常以层次结构组织。
- en: The main challenge when applying this pattern is to correctly identify the business
    capabilities. This requires an understanding of the business itself and may benefit
    from cooperation with a business analyst.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 应用这种模式的主要挑战是正确识别业务能力。这需要对业务本身有一定的了解，并可能受益于与业务分析师的合作。
- en: Decomposition by subdomain
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 按子域分解
- en: A different decomposition pattern is related to the **Domain-Driven Design**
    (**DDD**) approach. To define services, it is necessary to identify DDD subdomains.
    Just like business capability, identifying subdomains requires knowledge of the
    business context.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种分解模式与**领域驱动设计**（**DDD**）方法有关。要定义服务，需要识别DDD子域。就像业务能力一样，识别子域需要了解业务背景。
- en: The main difference between the two approaches is that with decomposing by business
    capability, the focus is more on the organization of the business (its structure),
    whereas with decomposing by subdomain, the focus is on the problems that the business
    tries to solve.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法的主要区别在于，按业务能力分解更多关注业务的组织（其结构），而按子域分解更关注业务试图解决的问题。
- en: Database per service pattern
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 每个服务一个数据库模式
- en: Storing and handling data is a complex issue in every software architecture.
    Wrong choices may impact scalability, performance, or maintenance costs. With
    microservices, there's an added complexity coming from the fact that we want the
    microservices to be loosely coupled.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 存储和处理数据在每种软件架构中都是一个复杂的问题。错误的选择可能会影响可伸缩性、性能或维护成本。对于微服务来说，由于我们希望微服务之间松耦合，这增加了额外的复杂性。
- en: This leads to a design pattern where each microservice connects to its own database
    so it is independent of any changes introduced by the other services. While this
    pattern adds some overhead, its additional benefit is that you can optimize the
    schema and indexes for each microservice individually.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了一种设计模式，每个微服务连接到自己的数据库，因此独立于其他服务引入的任何更改。虽然这种模式增加了一些开销，但其额外的好处是你可以为每个微服务单独优化架构和索引。
- en: Since databases tend to be pretty huge pieces of infrastructure, this approach
    may not be feasible, so sharing a database between microservices is an understandable
    trade-off.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据库往往是相当庞大的基础设施，这种方法可能不可行，因此在微服务之间共享数据库是可以理解的权衡。
- en: Deployment strategies
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署策略
- en: With microservices running on multiple hosts, you will probably wonder which
    is the better way to allocate resources. Let's compare the two possible approaches.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个主机上运行微服务时，您可能会想知道分配资源的更好方式是哪种。让我们比较两种可能的方法。
- en: Single service per host
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 每个主机单个服务
- en: Using this pattern, we allow each host to only serve a particular type of microservice.
    The main benefit is that you can tweak the machine to better fit the desired workload
    and services are well isolated. When you provide extra-large memory or fast storage,
    you'll be sure that it is used only for the microservice that needs it. The service
    is also unable to consume more resources than provisioned.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种模式，我们允许每个主机只为特定类型的微服务提供服务。主要好处是你可以调整机器以更好地适应所需的工作负载，并且服务是良好隔离的。当你提供额外大的内存或快速存储时，你可以确保它只用于需要它的微服务。服务也无法消耗比所分配的资源更多的资源。
- en: The downside of this approach is that some of the hosts may be under-utilized.
    One possible workaround is to use the smallest possible machines that still satisfy
    the microservice requirements and scale them when necessary. This workaround,
    however, does not solve the issue of additional overhead on the host itself.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是一些主机可能被低效利用。一个可能的解决方法是在必要时使用尽可能小的机器来满足微服务的要求，并在必要时对其进行扩展。然而，这种解决方法并不能解决主机本身的额外开销问题。
- en: Multiple services per host
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 每个主机多个服务
- en: An opposite approach is hosting multiple services per host. This helps to optimize
    the utilization of the machines but it also comes with some drawbacks. First of
    all, different microservices may require different optimizations, so hosting them
    on a single host will still be impossible. What's more, with this approach, you
    lose control of the host allocation, so the problems in one microservice may cause
    outages in a colocated microservice even if the latter would be otherwise unaffected.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 相反的方法是在一个主机上托管多个服务。这有助于优化机器的利用率，但也带来一些缺点。首先，不同的微服务可能需要不同的优化，因此在单个主机上托管它们仍然是不可能的。此外，使用这种方法，您失去了对主机分配的控制，因此一个微服务中的问题可能会导致共存的另一个微服务中断，即使后者在其他情况下不受影响。
- en: Another problem is the dependency conflict between the microservices. When the
    microservices are not isolated from one another, the deployment has to take into
    account different possible dependencies. This model is also less secure.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是微服务之间的依赖冲突。当微服务彼此不隔离时，部署必须考虑不同的可能依赖关系。这种模型也不太安全。
- en: Observability patterns
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可观察性模式
- en: In the previous section, we mentioned that microservices come at a price. This
    price includes the requirement to introduce observability or risk losing the ability
    to debug your applications. Here are some patterns related to observability.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们提到微服务是有代价的。这个代价包括引入可观察性的要求，否则就会失去调试应用程序的能力。以下是一些与可观察性相关的模式。
- en: Log aggregation
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 日志聚合
- en: Microservices use logging just like monolithic applications. Instead of storing
    the logs locally, the logs are aggregated and forwarded to a central facility.
    This way, the logs are available even if the service itself is down. Storing logs
    in a centralized manner also helps correlate data coming from different microservices.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务像单片应用程序一样使用日志记录。日志不是存储在本地，而是被聚合并转发到一个中央设施。这样，即使服务本身宕机，日志也是可用的。以集中的方式存储日志还有助于关联来自不同微服务的数据。
- en: Application metrics
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 应用程序指标
- en: To make decisions based on data, you first need some data to act on. Collecting
    application metrics helps to understand the application behavior as used by the
    actual users, and not in synthetic tests. The approaches to collect those metrics
    are push (where an application actively calls the performance monitoring service)
    and pull (where the performance monitoring service regularly checks the configured
    endpoints).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要基于数据做出决策，首先需要一些数据来采取行动。收集应用程序指标有助于了解实际用户使用的应用程序行为，而不是合成测试中的行为。收集这些指标的方法有推送（应用程序主动调用性能监控服务）和拉取（性能监控服务定期检查配置的端点）。
- en: Distributed tracing
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分布式跟踪
- en: Distributed tracing helps not only to investigate performance issues but also
    to gain better insight into the application behavior under real-world traffic.
    Unlike logging, which collects pieces of information from a single point, tracing
    is concerned with the entire life cycle of a single transaction, starting at the
    point where it originates from a user action.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式跟踪不仅有助于调查性能问题，还有助于更好地了解应用程序在真实流量下的行为。与日志记录不同，日志跟踪关注的是单个事务的整个生命周期，从它起源于用户操作的地方开始。
- en: Health check APIs
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 健康检查API
- en: Since microservices are often targets of automation, they need to have the ability
    to communicate their internal state. Even if the process is present in the system,
    it doesn't mean the application is operational. The same goes for an open network
    port; the application may be listening, but it is not yet able to respond. Health
    check APIs provide a way for external services to determine whether the application
    is ready to process the workload. Self-healing and autoscaling use health checks
    to determine when an intervention is needed. The base premise is that a given
    endpoint (such as `/health`) returns an HTTP code `200` when the application behaves
    as expected and a different code (or does not return at all) if any problem is
    found.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务经常是自动化的目标，它们需要能够传达其内部状态。即使进程存在于系统中，也不意味着应用程序正在运行。对于开放的网络端口也是如此；应用程序可能正在监听，但还不能响应。健康检查API提供了一种外部服务确定应用程序是否准备处理工作负载的方法。自愈和自动扩展使用健康检查来确定何时需要干预。基本前提是给定的端点（例如`/health`）在应用程序表现如预期时返回HTTP代码`200`，如果发现任何问题，则返回不同的代码（或根本不返回）。
- en: Now that all the pros, cons, and patterns are known to you, we'll show you how
    you can split the monolithic application and turn it into microservices part by
    part. The presented approaches are not limited to just microservices; they may
    be useful in other cases as well, including monolithic applications.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了所有的优缺点和模式，我们将向你展示如何将单片应用程序分割并逐步转换为微服务。所提出的方法不仅限于微服务；它们在其他情况下也可能有用，包括单片应用程序。
- en: Building microservices
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建微服务
- en: There are a lot of opinions concerning monolithic applications. Some architects
    believe that monoliths are inherently evil because they don't scale well, are
    tightly coupled, and are hard to maintain. There are others who claim that the
    performance benefits coming from monoliths counterbalance their shortcomings.
    It's a fact that tightly coupled components require much less overhead in terms
    of networking, processing power, and memory than their loosely coupled counterparts.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 关于单片应用程序有很多不同的观点。一些架构师认为单片应用程序本质上是邪恶的，因为它们不易扩展，耦合度高，难以维护。还有一些人声称，单片应用程序带来的性能优势可以抵消它们的缺点。紧密耦合的组件在网络、处理能力和内存方面需要的开销要少得多。
- en: As each application has unique business requirements and operates in a unique
    environment when it comes to stakeholders, there is no universal rule regarding
    which approach is better suited. Even more confusing is the fact that after the
    initial migration from monoliths to microservices, some companies started consolidating
    microservices into macroservices. This was because the burden of maintaining thousands
    of separate software instances proved to be too big to handle.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个应用程序都有独特的业务需求，并在利益相关者的独特环境中运行，因此没有关于哪种方法更适合的通用规则。更令人困惑的是，在从单片应用程序迁移到微服务后，一些公司开始将微服务合并成宏服务。这是因为维护成千上万个单独的软件实例的负担太大，无法处理。
- en: The choice of one architecture over another should always come from the business
    requirements and careful analysis of different alternatives. Putting ideology
    before pragmatism usually results in a lot of waste within an organization. When
    a team tries to adhere to a given approach at all costs, without considering different
    solutions or diverse external opinions, that team is no longer fulfilling its
    obligations to deliver the right tools for the right job.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一种架构而不是另一种架构应该始终来自业务需求和对不同替代方案的仔细分析。将意识形态置于实用主义之前通常会导致组织内的大量浪费。当一个团队试图不顾一切地坚持某种方法，而不考虑不同的解决方案或不同的外部意见时，该团队就不再履行为工作提供正确工具的义务。
- en: If you are developing or maintaining a monolith, you may consider improving
    its scalability. The techniques presented in this section aim to solve this problem
    while also making your application easier to migrate to microservices if you decide
    so.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在开发或维护一个单片应用程序，你可能会考虑提高其可扩展性。本节介绍的技术旨在解决这个问题，同时使您的应用程序更容易迁移到微服务，如果您决定这样做的话。
- en: 'The three primary causes of bottlenecks are as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 瓶颈的三个主要原因如下：
- en: Memory
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存
- en: Storage
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储
- en: Computing
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算
- en: We will show you how to approach each of them to develop scalable solutions
    based on microservices.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向您展示如何处理每个问题，以开发基于微服务的可扩展解决方案。
- en: Outsourcing memory management
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外包内存管理
- en: One of the ways to help microservices scale is to outsource some of their tasks.
    One such task that may hinder scaling efforts is memory management and caching
    data.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助微服务扩展的一种方法是外包它们的一些任务。可能会妨碍扩展努力的一个任务是内存管理和缓存数据。
- en: For a single monolithic application, storing cached data directly in the process
    memory is not a problem as the process will be the only one accessing the cache
    anyway. But with several replicas of a process, this approach starts to show some
    problems.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单个单片应用程序，直接将缓存数据存储在进程内存中并不是问题，因为进程将是唯一访问缓存的进程。但是，对于一个进程的多个副本，这种方法开始显示一些问题。
- en: What if one replica has already computed a piece of a workload and stored it
    in a local cache? The other replica is unaware of this fact and has to compute
    it again. This way, your application wastes both computational time (as the same
    task has to be performed multiple times) and memory (as the results are also stored
    with each replica separately).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个副本已经计算了一部分工作负载并将其存储在本地缓存中，另一个副本并不知道这一事实，必须重新计算。这样，您的应用程序既浪费了计算时间（因为同样的任务必须执行多次），又浪费了内存（因为结果也分别存储在每个副本中）。
- en: To mitigate such challenges, consider switching to an external in-memory store
    rather than managing the cache internally within an application. Another benefit
    of using an external solution is that the life cycle of your cache is no longer
    tied to the life cycle of your application. You can restart and deploy new versions
    of your application and the values already stored in the cache are preserved.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了缓解这些挑战，考虑切换到外部内存存储，而不是在应用程序内部管理缓存。使用外部解决方案的另一个好处是，缓存的生命周期不再与应用程序的生命周期绑定。您可以重新启动和部署应用程序的新版本，缓存中已经存储的值将被保留。
- en: This may also result in shorter startup times as your application no longer
    needs to perform the computing during startup. Two popular solutions for in-memory
    cache are Memcached and Redis.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能还会导致启动时间更短，因为您的应用程序在启动时不再需要执行计算。内存缓存的两种流行解决方案是Memcached和Redis。
- en: Memcached
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Memcached
- en: Memcached, released in 2003, is the older product of the two. It's a general-purpose,
    distributed key-value store. The original goal of the project was to offload databases
    used in web applications by storing the cached values in memory. Memcached is
    distributed by design. Since version 1.5.18, it is possible to restart the Memcached
    server without losing the contents of the cache. This is possible through the
    use of RAM disk as a temporary storage space.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Memcached于2003年发布，是这两者中较老的产品。它是一个通用的、分布式的键值存储。该项目的最初目标是通过将缓存值存储在内存中来卸载Web应用程序中使用的数据库。Memcached是通过设计进行分布的。自版本1.5.18以来，可以在不丢失缓存内容的情况下重新启动Memcached服务器。这是通过使用RAM磁盘作为临时存储空间实现的。
- en: It uses a simple API that can be operated via telnet or netcat or using bindings
    for many popular programming languages. There aren't any bindings specifically
    for C++, but it's possible to use the C/C++ `libmemcached` library.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用一个简单的API，可以通过telnet或netcat操作，也可以使用许多流行的编程语言的绑定。虽然没有专门针对C++的绑定，但可以使用C/C++的`libmemcached`库。
- en: Redis
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Redis
- en: Redis is a newer project than Memcached with the initial version released in
    2009\. Since then, Redis has replaced the usage of Memcached in many cases. Just
    like Memcached, it is a distributed, general-purpose, in-memory key-value store.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Redis是比Memcached更新的项目，最初版本于2009年发布。自那时起，Redis已经在许多情况下取代了Memcached的使用。与Memcached一样，它是一个分布式的、通用的、内存中的键值存储。
- en: 'Unlike Memcached, Redis also features optional data durability. While Memcached
    operates on keys and values being simple strings, Redis also supports other data
    types, such as the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与Memcached不同，Redis还具有可选的数据持久性。虽然Memcached操作的是简单字符串的键和值，但Redis还支持其他数据类型，例如以下内容：
- en: Lists of strings
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串列表
- en: Sets of strings
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串集
- en: Sorted sets of strings
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串的排序集
- en: Hash tables where keys and values are strings
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键和值都是字符串的哈希表
- en: Geospatial data (since Redis 3.2)
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地理空间数据（自Redis 3.2起）
- en: HyperLogLogs
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HyperLogLogs
- en: The design of Redis makes it a great choice for caching session data, caching
    web pages, and implementing leaderboards. Apart from that, it may also be used
    for message queueing. The popular distributed task queue library for Python, Celery,
    uses Redis as one of the possible brokers, along with RabbitMQ and Apache SQS.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Redis的设计使其成为缓存会话数据、缓存网页和实现排行榜的绝佳选择。除此之外，它还可以用于消息队列。Python的流行分布式任务队列库Celery使用Redis作为可能的代理之一，还有RabbitMQ和Apache
    SQS。
- en: Microsoft, Amazon, Google, and Alibaba all offer Redis-based managed services
    as part of their cloud platforms.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 微软、亚马逊、谷歌和阿里巴巴都在其云平台中提供基于Redis的托管服务。
- en: There are many implementations of a Redis client in C++. Two interesting ones
    are the `redis-cpp` library ([https://github.com/tdv/redis-cpp](https://github.com/tdv/redis-cpp))
    written using C++17 and QRedisClient ([https://github.com/uglide/qredisclient](https://github.com/uglide/qredisclient))
    using the Qt toolkit.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: C++中有许多Redis客户端的实现。两个有趣的实现是使用C++17编写的`redis-cpp`库（[https://github.com/tdv/redis-cpp](https://github.com/tdv/redis-cpp)）和使用Qt工具包的QRedisClient（[https://github.com/uglide/qredisclient](https://github.com/uglide/qredisclient)）。
- en: 'The following example of `redis-cpp` usage taken from the official documentation
    illustrates how to use it to set and get some data in the store:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从官方文档中摘取的`redis-cpp`用法示例，说明了如何在存储中设置和获取一些数据：
- en: '[PRE0]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, the library handles processing different data types. The example
    sets the value to a list of strings.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，该库处理不同数据类型的处理。该示例将值设置为字符串列表。
- en: Which in-memory cache is better?
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 哪种内存缓存更好？
- en: For most applications, Redis would be a better choice nowadays. It has a better
    user community, a lot of different implementations, and is well-supported. Other
    than that, it features snapshots, replication, transactions, and the pub/sub model.
    It is possible to embed Lua scripts with Redis and the support for geospatial
    data makes it a great choice for geo-enabled web and mobile applications.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数应用程序，Redis现在可能是一个更好的选择。它拥有更好的用户社区、许多不同的实现，并得到了良好的支持。除此之外，它还具有快照、复制、事务和发布/订阅模型。可以在Redis中嵌入Lua脚本，并且对地理空间数据的支持使其成为地理启用的Web和移动应用程序的绝佳选择。
- en: However, if your main goal is to cache the results of database queries in web
    applications, Memcached is a simpler solution with much less overhead. This means
    it should use the resources better as it doesn't have to store type metadata or
    perform conversions between different types.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您的主要目标是在Web应用程序中缓存数据库查询的结果，那么Memcached是一个更简单的解决方案，开销更小。这意味着它应该更好地利用资源，因为它不必存储类型元数据或在不同类型之间执行转换。
- en: Outsourcing storage
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外包存储
- en: Another possible limitation when introducing and scaling microservices is storage.
    Traditionally, local block devices have been used for storing objects that don't
    belong to the database (such as static PDF files, documents, or images). Even
    nowadays, block storage is still very popular with both local block devices and
    network filesystems such as NFS or CIFS.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 引入和扩展微服务时的另一个可能的限制是存储。传统上，本地块设备用于存储不属于数据库的对象（如静态PDF文件、文档或图像）。即使在今天，块存储仍然非常受欢迎，包括本地块设备和网络文件系统，如NFS或CIFS。
- en: 'While NFS and CIFS are the domain of **Network-Attached Storage** (**NAS**),
    there are also protocols related to a concept operating on a different level:
    **Storage Area Network** (**SAN**). Some of the popular ones are iSCSI, **Network
    Block Device** (**NBD**), ATA over Ethernet, Fibre Channel Protocol, and Fibre
    Channel over Ethernet.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然NFS和CIFS属于网络附加存储（NAS）的领域，但也有与在不同级别上运行的概念相关的协议：存储区域网络（SAN）。一些流行的协议包括iSCSI、网络块设备（NBD）、以太网上的ATA、光纤通道协议和以太网上的光纤通道。
- en: 'A different approach features clustered filesystems designed for distributed
    computing: GlusterFS, CephFS, or Lustre. All of these, however, operate as block
    devices exposing the same POSIX file API to the user.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是针对分布式计算设计的集群文件系统：GlusterFS、CephFS或Lustre。然而，所有这些都作为块设备运行，向用户公开相同的POSIX文件API。
- en: A fresh point of view on storage has been proposed as part of Amazon Web Services.
    Amazon **Simple Storage Service** (**S3**) is object storage. An API provides
    access to objects stored in buckets. This is different from the traditional filesystem
    as there is no distinction between files, directories, or inodes. There are buckets
    and keys that point to objects and objects are binary data stored by the service.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 作为亚马逊网络服务的一部分，提出了存储的新观点。亚马逊简单存储服务（S3）是对象存储。API提供对存储在存储桶中的对象的访问。这与传统文件系统不同，因为文件、目录或索引节点之间没有区别。有存储桶和指向对象的键，对象是由服务存储的二进制数据。
- en: Outsourcing computing
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外包计算
- en: One of the principles of microservices is that a process should only be responsible
    for doing a single piece of the workflow. A natural step while migrating from
    monoliths to microservices would be to define possible long-running tasks and
    split them into individual processes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的原则之一是一个进程只负责执行工作流的一部分。从单体架构迁移到微服务的一个自然步骤将是定义可能的长时间运行的任务，并将它们拆分为单独的进程。
- en: This is the concept behind task queues. Task queues handle the entire life cycle
    of managing tasks. Instead of implementing threading or multiprocessing on your
    own, with task queues, you delegate the task to be performed, which is then asynchronously
    handled by the task queue. The task may be performed on the same machine as the
    originating process but it may also run on a machine with dedicated requirements.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是任务队列背后的概念。任务队列处理管理任务的整个生命周期。与自己实现线程或多进程不同，使用任务队列，您将任务委托给异步处理任务的任务队列。任务可能在与发起进程相同的机器上执行，但也可能在具有专门要求的机器上运行。
- en: The tasks and their results are asynchronous, so there is no blocking in the
    main process. Examples of popular task queues in web development are Celery for
    Python, Sidekiq for Ruby, Kue for Node.js, and Machinery for Go. All of them can
    be used with Redis as a broker. Unfortunately, there aren't any similar mature
    solutions available for C++.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 任务及其结果是异步的，因此在主进程中没有阻塞。Web开发中流行的任务队列示例包括Python的Celery、Ruby的Sidekiq、Node.js的Kue和Go的Machinery。所有这些都可以与Redis一起使用作为代理。不幸的是，对于C++，目前没有类似成熟的解决方案。
- en: If you are seriously considering taking this route, one possible approach would
    be to implement a task queue directly in Redis. Redis and its API provide the
    necessary primitives to support such a behavior. Another possible approach is
    to use one of the existing task queues, such as Celery, and invoke them by directly
    calling Redis. This, however, is not advised, as it depends on the implementation
    details of the task queue rather than the documented public API. Yet another approach
    is to interface the task queue using bindings provided by SWIG or similar methods.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您认真考虑采用这种方法，一个可能的方法是直接在Redis中实现任务队列。Redis及其API提供了支持这种行为所需的基本操作。另一种可能的方法是使用现有的任务队列之一，例如Celery，并通过直接调用Redis来调用它们。然而，这并不被建议，因为它依赖于任务队列的实现细节，而不是文档化的公共API。另一种方法是使用SWIG或类似方法提供的绑定来接口任务队列。
- en: Observing microservices
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察微服务
- en: Each microservice you build needs to follow the general architectural design
    patterns. The main distinction between microservices and traditional applications
    is the need for implementing observability for the former.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您构建的每个微服务都需要遵循一般的架构设计模式。微服务和传统应用程序之间的主要区别在于前者需要实现可观察性。
- en: This section focuses on some approaches to observability. We describe here several
    open source solutions that you might find useful when designing your system.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 本节重点介绍了一些可观察性的方法。我们在这里描述了几种开源解决方案，当您设计系统时可能会发现有用。
- en: Logging
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录
- en: Logging is a topic that should be familiar to you even if you've never designed
    microservices. Logs (or log files) store the information about the events happening
    in a system. The system may mean your application, the operating system your application
    runs on, or the cloud platform you use for deployment. Each of these components
    may provide logs.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 记录是一个即使您从未设计过微服务也应该熟悉的主题。日志（或日志文件）存储有关系统中发生事件的信息。系统可能指的是您的应用程序、您的应用程序运行的操作系统，或者您用于部署的云平台。这些组件中的每一个都可能提供日志。
- en: Logs are stored as separate files because they provide a permanent record of
    all the events taking place. When the system becomes unresponsive, we want to
    query the logs and figure out the possible root cause of the outage.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 日志被存储为单独的文件，因为它们提供了所有事件的永久记录。当系统变得无响应时，我们希望查询日志，并找出停机的可能根本原因。
- en: This means that logs also provide an audit trail. Because the events are recorded
    in chronological order, we are able to understand the state of the system by examining
    the recorded historical state.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着日志也提供审计跟踪。因为事件是按时间顺序记录的，我们能够通过检查记录的历史状态来了解系统的状态。
- en: To help with debugging, logs are usually human-readable. There are binary formats
    for logs, but such formats are rather rare when using files to store the logs.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助调试，日志通常是人类可读的。虽然日志也有二进制格式，但在使用文件存储日志时，这样的格式相当罕见。
- en: Logging with microservices
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用微服务记录
- en: This approach to logging itself doesn't differ much from the traditional approach.
    Rather than using text files to store the logs locally, microservices usually
    print logs to `stdout`. A unified logging layer is then used to retrieve the logs
    and process them. To implement logging, you need a logging library that you can
    configure to suit your needs.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这种日志记录方法本身与传统方法并没有太大区别。微服务通常不使用文本文件来存储日志，而是通常将日志打印到`stdout`。然后使用统一的日志层来检索和处理日志。要实现日志记录，您需要一个日志库，可以根据您的需求进行配置。
- en: Logging in C++ with spdlog
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用spdlog在C++中记录日志
- en: One of the popular and fast logging libraries for C++ is `spdlog`. It's built
    using C++11 and can be used either as a header-only library or as a static library
    (which reduces compile time).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: C++中一种流行且快速的日志库是`spdlog`。它使用C++11构建，可以作为仅头文件库或静态库使用（可减少编译时间）。
- en: 'Some interesting features of `spdlog` include the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`spdlog`的一些有趣特性包括以下内容：'
- en: Formatting
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化
- en: 'Multiple sinks:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个输出端：
- en: Rotating files
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轮换文件
- en: Console
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制台
- en: Syslog
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Syslog
- en: Custom (implemented as a single function)
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义（实现为单个函数）
- en: Multi-threaded and single-threaded versions
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多线程和单线程版本
- en: Optional asynchronous mode
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的异步模式
- en: One feature that might be missing from `spdlog` is the direct support for Logstash
    or Fluentd. If you want to use one of these aggregators, it is still possible
    to configure `spdlog` with file sink output and use Filebeat or Fluent Bit to
    forward the file contents to the appropriate aggregator.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`spdlog`可能缺少的一个功能是直接支持Logstash或Fluentd。如果要使用这些聚合器之一，仍然可以配置`spdlog`以使用文件输出，并使用Filebeat或Fluent
    Bit将文件内容转发到适当的聚合器。'
- en: Unified logging layer
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 统一日志层
- en: Most of the time, we won't be able to control all of the microservices that
    we use. Some of them will use one logging library, while others would use a different
    one. On top of that, the formats will be entirely different and so will their
    rotation policies. To make things worse, there are still operating system events
    that we want to correlate with application events. This is where the unified logging
    layer comes into play.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，我们无法控制所有使用的微服务。其中一些将使用一个日志库，而其他人将使用不同的日志库。更糟糕的是，格式将完全不同，它们的轮换策略也将不同。更糟糕的是，我们仍然希望将操作系统事件与应用程序事件相关联。这就是统一日志层发挥作用的地方。
- en: One of the unified logging layer’s purposes is to collect logs from different
    sources. Such unified logging layer tools provide many integrations and understand
    different logging formats and transports (such as file, HTTP, and TCP).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 统一日志层的目的之一是从不同来源收集日志。这种统一日志层工具提供了许多集成，并理解不同的日志格式和传输方式（如文件、HTTP和TCP）。
- en: The unified logging layer is also capable of filtering the logs. We may want
    filtering to satisfy compliance, anonymize the personal details of our customers,
    or protect the implementation details of our services.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 统一日志层还能够过滤日志。我们可能需要过滤以满足合规性，匿名化客户的个人信息，或保护我们服务的实现细节。
- en: To make it easier to query the logs at a later time, the unified logging layer
    can also perform translation between formats. Even if the different services that
    you use store the logs in JSON, CSV, and the Apache format, the unified logging
    layer solution is able to translate them all to JSON to give them structure.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易在以后查询日志，统一日志层还可以在不同格式之间进行转换。即使您使用的不同服务将日志存储为JSON、CSV和Apache格式，统一的日志层解决方案也能够将它们全部转换为JSON以赋予它们结构。
- en: The final task of the unified logging layer is forwarding the logs to their
    next destination. Depending on the complexity of the system, the next destination
    may be a storage facility or another filtering, translation, and forwarding facility.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 统一日志层的最终任务是将日志转发到它们的下一个目的地。根据系统的复杂性，下一个目的地可能是存储设施或另一个过滤、转换和转发设施。
- en: Here are some interesting components that let you build the unified logging
    layer.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些有趣的组件，可以帮助您构建统一的日志层。
- en: Logstash
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Logstash
- en: Logstash is one of the most popular unified logging layer solutions. Currently,
    it is owned by Elastic, the company behind Elasticsearch. If you've heard of the
    ELK stack (now known as the Elastic Stack), Logstash is the "L" in the acronym.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Logstash是最受欢迎的统一日志层解决方案之一。目前，它由Elastic公司拥有，该公司是Elasticsearch背后的公司。如果您听说过ELK堆栈（现在称为Elastic
    Stack），Logstash是该首字母缩写中的“L”。
- en: Logstash was written in Ruby and then has been ported to JRuby. This unfortunately
    means that it is rather resource-intensive. For this reason, it is not advisable
    to run Logstash on each machine. Rather, it is meant to be used mainly as a log
    forwarder with lightweight Filebeat deployed to each machine and performing just
    the collection.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Logstash最初是用Ruby编写的，然后被移植到了JRuby。不幸的是，这意味着它需要相当多的资源。因此，不建议在每台机器上运行Logstash。相反，它主要用作轻量级的日志转发器，每台机器部署轻量级的Filebeat来执行收集。
- en: Filebeat
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Filebeat
- en: Filebeat is part of the Beats family of products. Their aim is to provide a
    lightweight alternative to Logstash that may be used directly with the application.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Filebeat是Beats系列产品的一部分。它的目标是提供一个轻量级的Logstash替代方案，可以直接与应用程序一起使用。
- en: This way, Beats provide low overhead that scales well, whereas a centralized
    Logstash installation performs all the heavy lifting, including translation, filtering,
    and forwarding.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，Beats提供了低开销，而集中式Logstash安装执行所有繁重的工作，包括转换、过滤和转发。
- en: 'Apart from Filebeat, the other products from the Beats family are as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Filebeat之外，Beats系列的其他产品如下：
- en: Metricbeat for performance
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于性能的Metricbeat
- en: Packetbeat for network data
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于网络数据的Packetbeat
- en: Auditbeat for audit data
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于审计数据的Auditbeat
- en: Heartbeat for uptime monitoring
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于运行时间监控的心跳
- en: Fluentd
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Fluentd
- en: Fluentd is the main competitor of Logstash. It is also the tool of choice of
    some cloud providers.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Fluentd是Logstash的主要竞争对手。它也是一些云提供商的首选工具。
- en: Thanks to its modular approach with the use of plugins, you can find plugins
    for data sources (such as Ruby applications, Docker containers, SNMP, or MQTT
    protocols), data outputs (such as Elastic Stack, SQL Database, Sentry, Datadog,
    or Slack), and several other kinds of filters and middleware.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其使用插件的模块化方法，您可以找到用于数据源（如Ruby应用程序、Docker容器、SNMP或MQTT协议）、数据输出（如Elastic Stack、SQL数据库、Sentry、Datadog或Slack）以及其他各种过滤器和中间件的插件。
- en: Fluentd should be lighter on resources than Logstash, but it is still not a
    perfect solution for running at scale. The counterpart to Filebeat that works
    with Fluentd is called Fluent Bit.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Fluentd应该比Logstash占用更少的资源，但仍然不是一个适合大规模运行的完美解决方案。与与Fluentd配合使用的Filebeat的对应物称为Fluent
    Bit。
- en: Fluent Bit
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Fluent Bit
- en: Fluent Bit is written in C and provides a faster and lighter solution that plugs
    into Fluentd. As a log processor and forwarder, it also features many integrations
    for inputs and outputs.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Fluent Bit是用C编写的，提供了一个更快、更轻的解决方案，可以插入到Fluentd中。作为日志处理器和转发器，它还具有许多输入和输出的集成。
- en: Besides log collection, Fluent Bit can also monitor CPU and memory metrics on
    Linux systems. It might be used together with Fluentd or it can forward directly
    to Elasticsearch or InfluxDB.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 除了日志收集，Fluent Bit还可以监视Linux系统上的CPU和内存指标。它可以与Fluentd一起使用，也可以直接转发到Elasticsearch或InfluxDB。
- en: Vector
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Vector
- en: While Logstash and Fluentd are stable, mature, and tried solutions, there are
    also newer propositions in the unified logging layer space.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Logstash和Fluentd是稳定、成熟和经过验证的解决方案，但在统一日志层空间中也有一些更新的提议。
- en: One of them is Vector, which aims to handle all of the observability data in
    a single tool. To differentiate from the competition, it focuses on performance
    and correctness. This is also reflected in the choice of technology. Vector uses
    Rust for the engine and Lua for scripting (as opposed to the custom domain-specific
    languages used by Logstash and Fluentd).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 其中之一是Vector，旨在通过单一工具处理所有可观察性数据。为了与竞争对手区分，它专注于性能和正确性。这也体现在技术选择上。Vector使用Rust作为引擎，Lua作为脚本语言（而不是Logstash和Fluentd使用的自定义领域特定语言）。
- en: At the moment of writing, it hasn't yet reached a stable 1.0 version, so at
    this point, it shouldn't be considered production-ready.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，它尚未达到稳定的1.0版本，因此在这一点上，不应将其视为生产就绪。
- en: Log aggregation
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日志聚合
- en: 'Log aggregation solves another problem that arises from too much data: how
    to store and access the logs. While the unified logging layer makes logs available
    even in the event of machine outage, it is the task of log aggregation to help
    us quickly find the information that we are looking for.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 日志聚合解决了由于过多数据而产生的另一个问题：如何存储和访问日志。统一的日志层使日志即使在机器故障时也可用，而日志聚合的任务是帮助我们快速找到我们正在寻找的信息。
- en: The two possible products that allow storing, indexing, and querying huge amounts
    of data are Elasticsearch and Loki.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 允许存储、索引和查询大量数据的两种可能产品是Elasticsearch和Loki。
- en: Elasticsearch
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Elasticsearch
- en: Elasticsearch is the most popular solution for self-hosted log aggregation.
    This is the "E" in the (former) ELK Stack. It features a great search engine based
    on Apache Lucene.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch是自托管日志聚合的最流行解决方案。这是（以前的）ELK Stack中的“E”。它具有基于Apache Lucene的出色搜索引擎。
- en: As the de facto standard in its niche, Elasticsearch has a lot of integrations
    and has great support both from the community and as a commercial service. Some
    cloud providers offer Elasticsearch as a managed service, which makes it easier
    to introduce Elasticsearch in your application. Other than that, Elastic, the
    company that makes Elasticsearch, offers a hosted solution that is not tied to
    any particular cloud provider.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 作为其领域的事实标准，Elasticsearch具有许多集成，并且在社区和商业服务方面得到了很好的支持。一些云提供商提供Elasticsearch作为托管服务，这使得在应用程序中引入Elasticsearch变得更容易。除此之外，制造Elasticsearch的Elastic公司还提供了一个不与任何特定云提供商绑定的托管解决方案。
- en: Loki
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Loki
- en: Loki aims to address some of the shortcomings found in Elasticsearch. The focus
    area for Loki is horizontal scalability and high availability. It’s built from
    the ground up as a cloud-native solution.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Loki旨在解决Elasticsearch中发现的一些缺点。Loki的重点领域是水平扩展性和高可用性。它是从头开始构建的云原生解决方案。
- en: The design choices for Loki are inspired by both Prometheus and Grafana. This
    shouldn't be a surprise since it is developed by the team responsible for Grafana.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Loki的设计选择受到Prometheus和Grafana的启发。这并不奇怪，因为它是由负责Grafana的团队开发的。
- en: While Loki should be a stable solution, it is not as popular as Elasticsearch,
    which means some integrations might be missing and the documentation and community
    support won't be on the same level as for Elasticsearch. Both Fluentd and Vector
    have plugins that support Loki for log aggregation.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Loki应该是一个稳定的解决方案，但它并不像Elasticsearch那样受欢迎，这意味着可能会缺少一些集成，文档和社区支持也不会像Elasticsearch那样。Fluentd和Vector都有支持Loki进行日志聚合的插件。
- en: Log visualization
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日志可视化
- en: The last piece of the logging stack we want to consider is log visualization.
    This helps us to query and analyze the logs. It presents the data in an accessible
    way so it can be inspected by all the interested parties, such as operators, developers,
    QA, or business.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想考虑的日志堆栈的最后一部分是日志可视化。这有助于我们查询和分析日志。它以一种易于访问的方式呈现数据，因此所有感兴趣的方都可以检查，如运营商、开发人员、QA或业务。
- en: Log visualization tools allow us to create dashboards that make it even easier
    to read the data we are interested in. With that, we are able to explore the events,
    search for correlations, and find outlying data from a simple user interface.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 日志可视化工具使我们能够创建仪表板，使我们更容易阅读我们感兴趣的数据。有了这个，我们能够探索事件，寻找相关性，并从简单的用户界面中找到异常数据。
- en: There are two major products dedicated to log visualization.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个专门用于日志可视化的主要产品。
- en: Kibana
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Kibana
- en: Kibana is the final element of the ELK Stack. It provides a simpler query language
    on top of Elasticsearch. Even though you can query and visualize different types
    of data with Kibana, it is mostly focused on logs.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Kibana是ELK Stack的最后一个元素。它在Elasticsearch之上提供了一个更简单的查询语言。尽管您可以使用Kibana查询和可视化不同类型的数据，但它主要专注于日志。
- en: Like the rest of the ELK Stack, it is currently the de facto standard when it
    comes to visualizing logs.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 与ELK Stack的其他部分一样，它目前是可视化日志的事实标准。
- en: Grafana
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Grafana
- en: Grafana is another data visualization tool. Until recently, it was mostly focused
    on time-series data from performance metrics. However, with the introduction of
    Loki, it may now also be used for logs.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Grafana是另一个数据可视化工具。直到最近，它主要专注于性能指标的时间序列数据。然而，随着Loki的引入，它现在也可以用于日志。
- en: One of its strengths is that it’s built with pluggable backends in mind, so
    it’s easy to switch the storage to fit your needs.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 它的一个优点是它是以可插拔后端为目标构建的，因此很容易切换存储以适应您的需求。
- en: Monitoring
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控
- en: Monitoring is the process of collecting performance-related metrics from the
    system. When paired with alerting, monitoring helps us understand when our system
    behaves as expected and when an incident happens.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 监控是从系统中收集与性能相关的指标的过程。与警报配对时，监控帮助我们了解系统何时表现如预期，以及何时发生故障。
- en: 'The three types of metrics that would interest us the most are as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最感兴趣的三种类型的指标如下：
- en: Availability, which lets us know which of our resources are up and running,
    and which of them have crashed or became unresponsive.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性，让我们知道我们的资源中哪些是正常运行的，哪些已经崩溃或变得无响应。
- en: Resource utilization gives us insight into how the workload fits into the system.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源利用率让我们了解工作负载如何适应系统。
- en: Performance, which shows us where and how to improve service quality.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能，它向我们展示了在哪里以及���何改进服务质量。
- en: The two models of monitoring are push and pull. In the former, each monitored
    object (a machine, an application, and a network device) pushes data to the central
    point periodically. In the latter, the objects present the data at the configured
    endpoints and the monitoring agent scrapes the data regularly.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 监控的两种模型是推送和拉取。在前者中，每个受监视的对象（机器、应用程序和网络设备）定期将数据推送到中心点。在后者中，对象在配置的端点呈现数据，监控代理定期抓取数据。
- en: The pull model makes it easier to scale. This way, multiple objects won't be
    clogging the monitoring agent connection. Instead, multiple agents may collect
    the data whenever ready, thus better utilizing the available resources.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 拉取模型使得扩展更容易。这样，多个对象不会阻塞监控代理连接。相反，多个代理可以在准备好时收集数据，从而更好地利用可用资源。
- en: Two monitoring solutions that feature C++ client libraries are Prometheus and
    InfluxDB. Prometheus is an example of a pull-based model and it focuses on collecting
    and storing time-series data. InfluxDB by default uses a push model. Besides monitoring,
    it is also popular for the Internet of Things, sensor networks, and home automation.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 两个具有C++客户端库的监控解决方案是Prometheus和InfluxDB。Prometheus是一个拉取模型的例子，它专注于收集和存储时间序列数据。InfluxDB默认使用推送模型。除了监控，它还在物联网、传感器网络和家庭自动化方面很受欢迎。
- en: Both Prometheus and InfluxDB are typically used with Grafana for visualizing
    data and managing dashboards. Both have alerting built-in, but they can also integrate
    with the external alerting system through Grafana.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus和InfluxDB通常与Grafana一起用于可视化数据和管理仪表板。两者都内置了警报功能，但也可以通过Grafana与外部警报系统集成。
- en: Tracing
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪
- en: Traces provide information that is generally lower-level to that of event logs.
    Another important distinction is that traces store the ID of every single transaction
    so it is easy to visualize the entire workflow. This ID is commonly known as the
    trace ID, transaction ID, or correlation ID.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪提供的信息通常比事件日志更低级。另一个重要的区别是，跟踪存储每个事务的ID，因此很容易可视化整个工作流程。这个ID通常被称为跟踪ID、事务ID或相关ID。
- en: 'Unlike event logs, traces are not meant to be human-readable. They are processed
    by a tracer. When implementing tracing, it is necessary to use a tracing solution
    that integrates with all the possible elements of the system: frontend applications,
    backend applications, and databases. This way, tracing helps to pinpoint the exact
    cause of lagging performance.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 与事件日志不同，跟踪不是为了人类可读。它们由跟踪器处理。在实施跟踪时，有必要使用一个能够与系统的所有可能元素集成的跟踪解决方案：前端应用程序、后端应用程序和数据库。这样，跟踪有助于准确定位性能滞后的确切原因。
- en: OpenTracing
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OpenTracing
- en: One of the standards in distributed tracing is OpenTracing. This standard was
    proposed by the authors of Jaeger, one of the open-source tracers.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式跟踪中的一个标准是OpenTracing。这个标准是由Jaeger的作者提出的，Jaeger是一个开源的跟踪器。
- en: 'OpenTracing supports many different tracers apart from Jaeger and it supports
    many different programming languages. The most important ones include the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTracing支持许多不同的跟踪器，除了Jaeger，它还支持许多不同的编程语言。最重要的包括以下内容：
- en: Go
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go
- en: C++
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++
- en: C#
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#
- en: Java
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java
- en: JavaScript
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript
- en: Objective-C
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Objective-C
- en: PHP
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP
- en: Python
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python
- en: Ruby
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby
- en: The most important feature of OpenTracing is that it is vendor-neutral. This
    means that once we instrument our application, we won’t need to modify the entire
    codebase to switch to a different tracer. This way, it prevents vendor lock-in.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTracing最重要的特性是它是供应商中立的。这意味着一旦我们对应用程序进行了仪器化，我们就不需要修改整个代码库来切换到不同的跟踪器。这样，它可以防止供应商锁定。
- en: Jaeger
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Jaeger
- en: Jaeger is a tracer that can be used with various backends, including Elasticsearch,
    Cassandra, and Kafka.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Jaeger是一个跟踪器，可以与包括Elasticsearch、Cassandra和Kafka在内的各种后端一起使用。
- en: It is natively compatible with OpenTracing, which shouldn't be a surprise. Since
    it is a Cloud Native Computing Foundation-graduated project, it has great community
    support, which also translates to good integration with other services and frameworks.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 它与OpenTracing兼容，这并不奇怪。由于它是一个Cloud Native Computing Foundation毕业的项目，它有很好的社区支持，这也意味着它与其他服务和框架的集成很好。
- en: OpenZipkin
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OpenZipkin
- en: OpenZipkin is the main competitor for Jaeger. It has been on the market for
    a longer time. Although this should mean it is a more mature solution, its popularity
    is fading when compared to Jaeger. Particularly, the C++ in OpenZipkin isn't actively
    maintained, which may cause future problems with maintenance.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: OpenZipkin是Jaeger的主要竞争对手。它已经在市场上存在了更长的时间。尽���这应该意味着它是一个更成熟的解决方案，但与Jaeger相比，它的受欢迎程度正在下降。特别是，OpenZipkin中的C++并没有得到积极的维护，这可能会导致未来的维护问题。
- en: Integrated observability solutions
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成的可观察性解决方案
- en: If you don't want to build the observability layer on your own, there are some
    popular commercial solutions that you might consider. They all operate in a software-as-a-service
    model. We won't go into a detailed comparison here, as their offerings may change
    drastically after the writing of this book.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想自己构建可观察性层，那么有一些受欢迎的商业解决方案可能会考虑。它们都以软件即服务模式运行。我们不会在这里进行详细的比较，因为它们的提供可能在本书编写后发生重大变化。
- en: 'These services are as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务如下：
- en: Datadog
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Datadog
- en: Splunk
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Splunk
- en: Honeycomb
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Honeycomb
- en: In this section, you have seen implementing observability in Microservices.
    Next, we'll move on to learn how to connect microservices.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您已经看到了在微服务中实现可观察性。接下来，我们将继续学习如何连接微服务。
- en: Connecting microservices
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接微服务
- en: Microservices are so useful because they can be connected in many different
    ways with other services, thus creating new value. However, as there is no standard
    for microservices, there is not a single way to connect to them.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务非常有用，因为它们可以以许多不同的方式与其他服务连接，从而创造新的价值。然而，由于微服务没有标准，因此连接它们的方法也没有统一的方式。
- en: This means that most of the time when we want to use a particular microservice,
    we have to learn how to interact with it. The good news is that although it is
    possible to implement any communication method in microservices, there are a few
    popular approaches that most microservices follow.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着大多数情况下，当我们想要使用特定的微服务时，我们必须学会如何与其交互。好消息是，尽管在微服务中可以实现任何通信方法，但有一些流行的方法是大多数微服务遵循的。
- en: How to connect microservices is just one of the relevant questions when designing
    architecture around them. The other is what to connect with and where. This is
    where service discovery comes into play. With service discovery, we let the microservices
    use automated means of discovering and connecting to other services within our
    application.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计围绕微服务的架构时，如何连接微服务只是一个相关问题之一。另一个问题是连接到什么以及在哪里连接。这就是服务发现发挥作用的地方。通过服务发现，我们让微服务使用自动化手段发现和连接应用程序中的其他服务。
- en: These three questions, how, what, and where, will be our next topic. We will
    introduce some of the most popular methods of communication and discovery used
    by modern microservices.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个问题，如何、什么和在哪里，将是我们接下来的话题。我们将介绍一些现代微服务使用的最流行的通信和发现方法。
- en: Application programming interfaces (APIs)
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序编程接口（API）
- en: Just like software libraries, microservices often expose APIs. These APIs make
    it possible to communicate with the microservices. Since the typical manner of
    communication utilizes computer networking, the most popular form of an API is
    the web API.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 就像软件库一样，微服务通常会暴露API。这些API使得与微服务进行通信成为可能。由于典型的通信方式利用计算机网络，API的最流行形式是Web API。
- en: In the previous chapter, we already covered some possible approaches with web
    services. Nowadays, microservices typically use web services based on **REpresentational
    State Transfer** (**REST**).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们已经涵盖了一些可能的网络服务方法。如今，微服务通常使用基于**表述状态转移**（**REST**）的网络服务。
- en: Remote procedure calls
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 远程过程调用
- en: While web APIs such as REST allow easy debugging and great interoperability,
    there's a lot of overhead related to data translation and using HTTP for transport.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然诸如REST之类的Web API允许轻松调试和良好的互操作性，但与数据转换和使用HTTP进行传输相关的开销很大。
- en: This overhead may be too much for some microservices, which is the reason for
    lightweight **Remote Procedure Calls** (**RPCs**).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这种开销对一些微服务来说可能太大了，这就是轻量级**远程过程调用**（**RPCs**）的原因。
- en: Apache Thrift
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Apache Thrift
- en: Apache Thrift is an interface description language and binary communication
    protocol. It is used as an RPC method that allows creating distributed and scalable
    services built in a variety of languages.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Thrift是一种接口描述语言和二进制通信协议。它用作一种RPC方法，允许创建用多种语言构建的分布式和可扩展服务。
- en: It supports several binary protocols and transport methods. Native data types
    are used for each programming language, so it is easy to introduce even in an
    existing codebase.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 它支持多种二进制协议和传输方法。每种编程语言都使用本机数据类型，因此即使在现有代码库中也很容易引入。
- en: gRPC
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: gRPC
- en: If you really care about performance, often you'll find that text-based solutions
    don't work for you. REST, however elegant and easily understandable, may turn
    out to be too slow for your needs. If that's the case, you should try to build
    your API around binary protocols. One of them, which is growing in popularity,
    is gRPC.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您真的关心性能，通常会发现基于文本的解决方案不适合您。然而，REST虽然优雅且易于理解，但可能对您的需求来说太慢了。如果是这种情况，您应该尝试围绕二进制协议构建您的API。其中一种日益流行的协议是gRPC。
- en: gRPC, as its name suggests, is an RPC system that was initially developed by
    Google. It uses HTTP/2 for transport, and Protocol Buffers as an **Interface Description
    Language** (**IDL**) for interoperability between multiple programming languages,
    and for data serialization. It's possible to use alternative technologies for
    this, for example, FlatBuffers. gRPC can be used both synchronously and in an
    asynchronous manner and allows creating both simple services and streaming ones.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC，顾名思义，是最初由Google开发的RPC系统。它使用HTTP/2进行传输，并使用协议缓冲区作为多种编程语言之间的**接口描述语言**（**IDL**）以及数据序列化的可互操作性。也可以使用替代技术，例如FlatBuffers。gRPC可以同步和异步使用，并允许创建简单服务和流式服务。
- en: 'Assuming you''ve decided to use `protobufs`, our Greeter service definition
    can look like this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已决定使用`protobufs`，我们的Greeter服务定义可以如下所示：
- en: '[PRE1]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Using the `protoc` compiler, you can create data access code from this definition.
    Assuming you want to have a synchronous server for our Greeter, you can create
    the service in the following way:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`protoc`编译器，您可以从此定义创建数据访问代码。假设您想为我们的Greeter创建一个同步服务器，可以按以下方式创建服务：
- en: '[PRE2]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, you have to build and run the server for it:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您必须构建并运行服务器：
- en: '[PRE3]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Simple as that. Let''s now take a look at a client to consume this service:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这么简单。现在让我们来看一个用于消费此服务的客户端：
- en: '[PRE4]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This was a simple, synchronous example. To make it work asynchronously, you'll
    need to add tags and `CompletionQueue`, as described on gRPC's website.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的同步示例。要使其异步工作，您需要添加标签和`CompletionQueue`，如gRPC网站上所述。
- en: One interesting feature of gRPC is that it is available for mobile applications
    on Android and iOS. This means that if you use gRPC internally, you don't have
    to provide an additional server to translate the traffic from your mobile applications.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC的一个有趣特性是它适用于Android和iOS上的移动应用程序。这意味着如果您在内部使用gRPC，则无需提供额外的服务器来转换来自移动应用程序的流量。
- en: In this section, you learned the most popular methods of communication and discovery
    utilized by microservices. Next, we'll see how microservices can be scaled.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您了解了微服务使用的最流行的通信和发现方法。接下来，我们将看到如何扩展微服务。
- en: Scaling microservices
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展微服务
- en: One of the significant benefits of microservices is that they scale more efficiently
    than monoliths. Given the same hardware infrastructure, you could theoretically
    be able to get more performance out of microservices than monoliths.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的一个重要好处是它们比单体应用程序更有效地扩展。在相同的硬件基础设施下，您理论上可以从微服务中获得比单体应用程序更高的性能。
- en: In practice, the benefits are not that straightforward. Microservices and related
    helpers also provide overhead that for smaller-scale applications may be less
    performant than an optimal monolith.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，好处并不那么直接。微服务及其相关辅助工具也会提供开销，对于规模较小的应用程序，可能不如最佳单体应用程序高效。
- en: Remember that even if something looks good "on paper," it doesn't mean it will
    fly. If you want to base your architectural decisions on scalability or performance,
    it is better to prepare calculations and experiments. This way, you'll act based
    on data, not just emotion.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，即使某些东西在“纸上”看起来不错，也不意味着它会成功。如果您想基于可扩展性或性能做出架构决策，最好准备计算和实验。这样，您将根据数据而不仅仅是情感行事。
- en: Scaling a single service per host deployment
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个主机部署单个服务的扩展
- en: For a single service per host deployment, scaling a microservice requires adding
    or removing additional machines that host the microservice. If your application
    is running on a cloud architecture (public or private), many providers offer a
    concept known as autoscaling groups.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个主机部署的单个服务，扩展微服务需要添加或删除承载微服务的额外机器。如果您的应用程序在云架构（公共或私有）上运行，许多提供商提供称为自动缩放组的概念。
- en: Autoscaling groups define a base virtual machine image that will run on all
    grouped instances. Whenever a critical threshold is reached (for example, 80%
    CPU use), a new instance is created and added to the group. Since autoscaling
    groups run behind a load balancer, the increasing traffic then gets split between
    both the existing and the new instances, thus reducing the mean load on each one.
    When the spike in traffic subsides, the scaling controller shuts down the excess
    machines to keep the costs low.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 自动缩放组定义了将在所有分组实例上运行的基本虚拟机映像。每当达到临界阈值（例如80%的CPU使用）时，将创建一个新实例并将其添加到组中。由于自动缩放组在负载均衡器后运行，因此增加的流量将在现有实例和新实例之间分配，从而降低每个实例的平均负载。当流量激增后，扩展控制器会关闭多余的机器，以保持成本低廉。
- en: Different metrics can act as triggers for the scaling event. The CPU load is
    one of the easiest to use, but it may not be the most accurate one. Other metrics,
    such as the number of messages in a queue, may better fit your application.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的指标可以作为扩展事件的触发器。CPU负载是最容易使用的指标之一，但可能不是最准确的指标。其他指标，例如队列中的消息数量，可能更适合您的应用程序。
- en: 'Here''s an excerpt from a Terraform configuration for a scaler policy:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个用于缩放策略的Terraform配置摘录：
- en: '[PRE5]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It means that at any given time, there will be at least three instances running
    and at most five instances. The scaler will trigger once the CPU load hits at
    least an 80% average for all the group instances. When that happens, a new instance
    is spun up. The metrics from the new machine will only be collected after it has
    been running for at least 60 seconds (the cooldown period).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在任何给定时间，至少会有三个实例运行，最多为五个实例。一旦CPU负载达到所有组实例的平均80%，扩展器将触发。发生这种情况时，将会启动一个新实例。新机器的指标只有在其运行至少60秒后才会被收集（冷却期）。
- en: Scaling multiple services per host deployment
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个主机部署多个服务的扩展
- en: This mode of scaling is also suitable for multiple services per host deployment.
    As you can probably imagine, this isn't the most efficient method. Scaling an
    entire set of services based only on a reduced throughput of a single one is similar
    to scaling monoliths.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这种扩展模式也适用于每个主机部署多个服务。您可能可以想象，这并不是最有效的方法。仅基于单个服务的减少吞吐量来扩展整套服务类似于扩展单体应用程序。
- en: If you're using this pattern, a better way to scale your microservices is to
    use an orchestrator. If you don't want to use containers, Nomad is a great choice
    that works with a lot of different execution drivers. For containerized workloads,
    either Docker Swarm or Kubernetes will help you. Orchestrators are a topic that
    we'll come back to in the next two chapters.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用此模式，扩展微服务的更好方法是使用编排器。如果您不想使用容器，Nomad是一个与许多不同执行驱动程序兼容的绝佳选择。对于容器化工作负载，Docker
    Swarm或Kubernetes都会帮助您。编排器是我们将在接下来的两章中回顾的一个主题。
- en: Summary
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Microservices are a great new trend in software architecture. They could be
    a good fit provided you make sure you know about the hazards and prepare for them.
    This chapter explained the common design and migration patterns that help to introduce
    microservices. We've also covered advanced topics such as observability and connectivity
    that are crucial when establishing microservices-based architectures.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是软件架构中的一个伟大新趋势。只要确保您了解危险并为其做好准备，它们可能会很合适。本章解释了帮助引入微服务的常见设计和迁移模式。我们还涵盖了诸如可观察性和连接性之类的高级主题，在建立基于微服务的架构时至关重要。
- en: By now, you should be able to design and decompose applications into individual
    microservices. Each microservice is then capable of processing a single piece
    of workload.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该能够将应用程序设计和分解为单独的微服务。然后，每个微服务都能够处理一部分工作负载。
- en: While microservices are valid on their own, they're especially popular in combination
    with containers. Containers are the subject of the next chapter.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然微服务本身是有效的，但它们在与容器结合使用时尤其受欢迎。容器是下一章的主题。
- en: Questions
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why do microservices help you better use the system resources?
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么微服务能帮助您更好地利用系统资源？
- en: How can microservices and monoliths coexist (in an evolving system)?
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微服务和单体架构如何共存（在不断发展的系统中）？
- en: Which types of teams benefit the most from microservices?
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种类型的团队最能从微服务中受益？
- en: Why is it necessary to have a mature DevOps approach when introducing microservices?
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引入微服务时为什么需要成熟的DevOps方法？
- en: What is a unified logging layer?
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 统一的日志记录层是什么？
- en: How do logging and tracing differ?
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 日志记录和跟踪有何不同？
- en: Why may REST not be the best choice for connecting microservices?
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么REST可能不是连接微服务的最佳选择？
- en: What are the deployment strategies for microservices? What are the benefits
    of each of them?
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微服务的部署策略是什么？每种策略的好处是什么？
- en: Further reading
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Mastering Distributed Tracing*: [https://www.packtpub.com/product/mastering-distributed-tracing/9781788628464](https://www.packtpub.com/product/mastering-distributed-tracing/9781788628464)'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*掌握分布式跟踪*：[https://www.packtpub.com/product/mastering-distributed-tracing/9781788628464](https://www.packtpub.com/product/mastering-distributed-tracing/9781788628464)'
- en: '*Hands-On Microservices with Kubernetes*: [https://www.packtpub.com/product/hands-on-microservices-with-kubernetes/9781789805468](https://www.packtpub.com/product/hands-on-microservices-with-kubernetes/9781789805468)'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Kubernetes进行微服务实践*：[https://www.packtpub.com/product/hands-on-microservices-with-kubernetes/9781789805468](https://www.packtpub.com/product/hands-on-microservices-with-kubernetes/9781789805468)'
- en: '*Microservices* by Martin Fowler: [https://martinfowler.com/articles/microservices.html](https://martinfowler.com/articles/microservices.html)'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Martin Fowler的微服务*：[https://martinfowler.com/articles/microservices.html](https://martinfowler.com/articles/microservices.html)'
- en: 'Microservice architecture: [https://microservices.io/](https://microservices.io/)'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构：[https://microservices.io/](https://microservices.io/)
