- en: Chapter 7. Audio Adrenaline
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。音频肾上腺素
- en: This is the final chapter on the 2D game that we have been working on. Although
    our Robo Racer 2D game is almost complete, there is one element that we have yet
    to include to make it a complete game. Unless you like silent movies, you have
    probably noticed that we don't have any audio in this game. Most games depend
    on audio, and ours is no exception. In this chapter, we will cover audio and a
    few other housekeeping items.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关于我们一直在工作的2D游戏的最后一章。尽管我们的Robo Racer 2D游戏几乎完成，但我们还没有包括一个元素来使其成为一个完整的游戏。除非你喜欢无声电影，否则你可能已经注意到我们在这个游戏中没有任何音频。大多数游戏都依赖于音频，我们的也不例外。在本章中，我们将介绍音频以及一些其他维护事项。
- en: '**Audio formats**: It is important to understand how audio is represented in
    computers and how it is used in games. We will discuss sample rates and bits and
    help you understand how audio works.'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**音频格式**：了解音频在计算机中的表示方式以及它在游戏中的应用方式非常重要。我们将讨论采样率和比特数，并帮助你理解音频是如何工作的。'
- en: '**Audio engine**: We need some kind of audio engine to integrate audio into
    our game. We will discuss FMOD, a very popular engine that allows you to easily
    integrate audio using C++.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**音频引擎**：我们需要某种音频引擎来将音频集成到我们的游戏中。我们将讨论FMOD，这是一个非常流行的引擎，它允许你使用C++轻松集成音频。'
- en: '**SFX**: Sound effects play a huge role in most games and, we will add sound
    effects to our game to bring it to life.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**音效**：音效在大多数游戏中扮演着巨大的角色，我们将为我们的游戏添加音效，使其栩栩如生。'
- en: '**Music**: Most games utilize some kind of music. Music is handled in a different
    way than sound effects, and you will learn the differences between the two.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**音乐**：大多数游戏都使用某种形式的音乐。音乐的处理方式与音效不同，你将学习这两者之间的区别。'
- en: '**Final housekeeping**: On a final note, for our game, we have left the game
    shutdown for this chapter. We have not been good programmers in that we have not
    properly released the objects in our game. We will learn why it is important to
    do so, and how to do it.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最后的维护**：最后一点，对于我们的游戏，我们在这个章节中保留了游戏关闭。我们并不是很好的程序员，因为我们没有正确释放游戏中的对象。我们将学习为什么这样做很重要，以及如何做到这一点。'
- en: Bits and bytes
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比特和字节
- en: Audio is inherently an analog experience. Sound is created as compressed waves
    travel through the air and interact with our ear drums. Until recently, the techniques
    used to reproduce audio were also strictly audio as well. For example, a microphone
    records sound similarly to how our ears do by capturing changes in air pressure
    and converting them to electrical impulses. Speakers do the reverse by converting
    the electrical signals back into waves of air pressure.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 音频本质上是一种模拟体验。声音是通过压缩波在空气中传播并与我们的耳膜相互作用而创造的。直到最近，用于重现音频的技术也是严格属于音频领域的。例如，麦克风记录声音的方式与我们的耳朵相似，通过捕捉空气压力的变化并将其转换为电脉冲。扬声器通过将电信号转换回空气压力的波来实现相反的过程。
- en: Computers, on the other hand, are digital. Computers convert audio samples into
    bits and bytes by taking samples of the audio. To keep it simple, let's consider
    a system where the current frequency of the sound wave (that is, how fast the
    wave is moving) is captured as a 16 bit (2 byte) number. It turns out that a 16
    bit number can capture numbers in a range from 0 to 65,536\. Each sample of the
    sound wave must be encoded as a number in this range. Also, as we actually capture
    two samples each time (for stereo sound), we need 4 bytes to capture each sample.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，计算机是数字的。计算机通过采样音频将音频样本转换为比特和字节。为了简化，让我们考虑一个系统，其中声音波的当前频率（即波移动的速度）被捕获为一个16位（2字节）的数字。结果是，16位数字可以捕获从0到65,536的数字范围。每个声音波的样本都必须编码在这个范围内。此外，由于我们实际上每次捕获两个样本（用于立体声），我们需要4个字节来捕获每个样本。
- en: The next important factor is how often you sample the sound. The range of audio
    frequencies run roughly from 20 to 20,000 Hz (*Hz = cycles per second*). A very
    smart person named Nyquist figured out that we have to sample audio at twice the
    frequency to accurately capture the wave. This means that we have to capture at
    least 40,000 samples each second to accurately capture a sound. Conversely, we
    have to play the sound back at the same frequency. This is why audio on compact
    discs are sampled at 44,100 Hz.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个重要因素是您多久采样一次声音。音频频率的范围大致从20赫兹到20,000赫兹（*Hz = 每秒周期数*）。一位名叫尼奎斯特的非常聪明的人发现，为了准确捕捉波形，我们必须以两倍于音频频率的频率采样。这意味着我们每秒至少需要捕捉40,000个样本才能准确捕捉声音。相反，我们必须以相同的频率播放声音。这就是为什么光盘上的音频采样频率为44,100赫兹。
- en: You should be able to see by now that it is going to take a lot of disk space
    and a lot of memory to work with sound. A one minute piece of audio will take
    about 10 MB of storage! This means that the same audio would require 10 MB of
    memory if we were to load the entire audio file at once.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能够看出，处理声音需要大量的磁盘空间和内存。一分钟的音频文件大约需要10 MB的存储空间！这意味着，如果我们一次性加载整个音频文件，相同的音频将需要10
    MB的内存。
- en: You may wonder how modern games function at all. The music scores of some games
    are measured in hours, not minutes. Similarly, there may be hundreds or even thousands
    of sound effects, not to mention voice, which is also recorded as audio.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道现代游戏是如何运作的。有些游戏的配乐时长以小时计算，而不是分钟。同样，可能会有数百甚至数千个音效，更不用说录音的语音，这些都以音频的形式记录。
- en: A sound by any other name
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 音效的别称
- en: 'There are many formats that audio files can be stored in. We will deal with
    two common formats that are used in games: WAV files and MP3 files. A WAV file
    stores the audio data in an uncompressed format.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 音频文件可以存储在许多格式中。我们将处理两种在游戏中常用的常见格式：WAV文件和MP3文件。WAV文件以未压缩的格式存储音频数据。
- en: Although WAV files can be used for all of your audio, they are typically used
    for sound effects. Sound effects are typically very short, often less than 1 second.
    This means that the size of the file is going to be relatively small because the
    audio file is very short.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然WAV文件可以用于所有音频，但它们通常用于音效。音效通常非常短，通常不到1秒。这意味着文件的大小将会相对较小，因为音频文件非常短。
- en: While sound effects are often saved as WAV files, music, typically, is not.
    This is because the length of music tends to be much longer than the length of
    sound effects. Loading a music file into memory that is three-to-five minutes
    long would take an exorbitant amount of memory.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然音效通常以WAV文件保存，但音乐通常不是。这是因为音乐的长度往往比音效长得多。将一个三到五分钟长的音乐文件加载到内存中会消耗大量的内存。
- en: There are two main techniques that are used to deal with larger audio files.
    First, data compression can be used to make the audio files smaller. One of the
    most common audio formats that provides data compression is the MP3 format. Using
    mathematical trickery, MP3 files store the sound data in less space without sacrificing
    any sound quality.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 处理较大音频文件的主要技术有两种。首先，可以使用数据压缩来减小音频文件的大小。提供数据压缩的最常见音频格式之一是MP3格式。通过数学技巧，MP3文件在不牺牲任何音质的情况下，将声音数据存储在更小的空间中。
- en: The second technique that is used to handle large files is streaming. Instead
    of loading the entire sound file into memory, the file is sent a piece at a time
    as a continuous stream of data, which is then played in the game.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 处理大文件的第二种技术是流式传输。不是将整个声音文件一次性加载到内存中，而是将文件分批次作为连续的数据流发送，然后在游戏中播放。
- en: There are some limitations to streaming. First, the transfer of data from a
    hard drive or another storage device is much slower that the transfer of data
    from memory. Streamed audio can suffer from lag, which is the amount of time that
    it takes for a sound to play from the time that the sound was triggered to play
    in code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 流式传输有一些局限性。首先，从硬盘或另一个存储设备传输数据比从内存中传输数据慢得多。流式音频可能会出现延迟，这是从触发播放到声音实际播放所需的时间。
- en: Lag is more critical for sound effects than it is for music. This is because
    a particular sound effect often coincides with something that just happened in
    the game. It would be disconcerting if the sound of a bullet occurred a half second
    after the bullet was fired! Music, on the other hand, often starts and runs for
    several minutes. A small lag in the start of the music can often be overlooked.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于音效来说，延迟比音乐更重要。这是因为特定的音效通常与游戏中刚刚发生的事情相吻合。如果子弹发射后半秒才听到子弹的声音，那会让人感到不安！另一方面，音乐通常开始后持续几分钟。音乐开始时的轻微延迟通常可以忽略不计。
- en: Making noise
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制造噪音
- en: Going into a full-blown course on creating sounds and music is, of course, beyond
    the scope of this book. However, I did want to give you a few resources to get
    you started.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 进入一个关于创建声音和音乐的全面课程，当然超出了本书的范围。然而，我确实想给你提供一些资源，帮助你开始学习。
- en: The first question you may ask is where to find sounds. There are literally
    thousands of sites on the Web that provide sounds and music that can be used in
    games. Many charge a fee, while a few offer free audio.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问的第一个问题是哪里可以找到声音。实际上，有成千上万的网站提供可以在游戏中使用的声音和音乐。许多网站收费，而一些网站提供免费音频。
- en: One thing to keep in mind is that *royalty-free* doesn't necessarily mean free.
    Royalty-free audio means that once you obtain a license to use the audio, you
    won't have to pay any additional fees to use the music.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一点是，*免版税*并不一定意味着免费。免版税音频意味着一旦你获得使用音频的许可，你就不必为使用音乐支付任何额外费用。
- en: 'So, here''s my big tip. Every site that I have found charges a small fee for
    both sound effects and music. But there is one way that I have found to obtain
    sounds for free using the **Unity Asset Store**. Go to [http://unity3d.com](http://unity3d.com)
    and install the free version of Unity. Once you have started Unity, perform the
    following steps:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这里是我的大贴士。我找到的每个网站都为音效和音乐收取一小笔费用。但有一种方法，我找到了免费获取声音的方法，那就是使用**Unity资产商店**。前往[http://unity3d.com](http://unity3d.com)并安装免费的Unity版本。一旦你启动了Unity，执行以下步骤：
- en: Create a new project by clicking **Create New Project** tab from the **Unity
    Project Wizard**. Click **Browse** and navigate to or create a folder to store
    your project in. Then click **Select Folder**.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**Unity项目向导**中的**创建新项目**标签创建一个新的项目。点击**浏览**并导航到或创建一个文件夹来存储你的项目。然后点击**选择文件夹**。
- en: Once Unity loads the project, click **Window** and then **Asset Store** from
    the menu.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦Unity加载了项目，点击**窗口**然后从菜单中选择**资产商店**。
- en: When the **Asset Store** window appears, enter a relevant search term (for example,
    music or SFX) in the **Search Asset Store** text box and press *Enter*.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当**资产商店**窗口出现时，在**搜索资产商店**文本框中输入相关搜索词（例如，音乐或SFX），然后按*Enter*键。
- en: Browse the results for free assets. Click on any listing for more details. If
    you find something that you like, click the **Download** link.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览免费资产的结果。点击任何列表以获取更多详细信息。如果你找到了你喜欢的东西，点击**下载**链接。
- en: Once Unity has downloaded the asset, the **Importing Package** screen will appear
    titled. Click the **Import** button.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦Unity下载了资产，将出现名为**导入包**的屏幕。点击**导入**按钮。
- en: You can now exit Unity and navigate to the folder where you created the new
    project. Then navigate inside the `Assets` folder. From here, it depends on the
    structure of the package that you imported, but if you browse around, you should
    be able to locate the audio files.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以退出Unity并导航到你创建新项目的文件夹。然后导航到`Assets`文件夹。从这里，取决于你导入的包的结构，但如果你四处浏览，你应该能够找到音频文件。
- en: Tip
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In fact, we are using a musical piece titled Jolly Bot provided by Robson Cozendey
    ([www.cozendey.com](http://www.cozendey.com)). We also found a great SFX package
    from.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上，我们正在使用Robson Cozendey提供的名为Jolly Bot的音乐作品。[www.cozendey.com](http://www.cozendey.com)。我们还找到了一个很棒的SFX包。
- en: You can now copy the audio files into your project!
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以将音频文件复制到你的项目中！
- en: Tip
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As you browse around for audio files, you will run across some files with the
    `ogg` extension. This is a common audio format similar to MP3\. However, the engine
    that we will use does not support ogg files, so you will need to convert them
    to MP3 files. Audacity, which is described next, will allow you to convert audio
    files from one format to another.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在浏览音频文件时，你可能会遇到一些带有`ogg`扩展名的文件。这是一种类似于MP3的常见音频格式。然而，我们将使用的引擎不支持ogg文件，因此你需要将它们转换为MP3文件。接下来要介绍的Audacity将允许你将音频文件从一种格式转换为另一种格式。
- en: You may find that you want to edit or mix your audio files. Or, you may need
    to convert your audio files from one format to another. The best free tool that
    I found to work with audio is **Audacity**, and you can download it at [http://audacity.sourceforge.net/](http://audacity.sourceforge.net/).
    Audacity is a full-featured audio mixer that will allow you to play, edit, and
    convert audio files.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现你想编辑或混合你的音频文件。或者，你可能需要将你的音频文件从一种格式转换为另一种格式。我发现最适合处理音频的免费工具是**Audacity**，你可以在[http://audacity.sourceforge.net/](http://audacity.sourceforge.net/)下载它。Audacity是一个功能齐全的音频混音器，它将允许你播放、编辑和转换音频文件。
- en: Tip
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To export files to the MP3 format, you will need a copy of **LAME** installed
    on your system. You can download LAME from [http://lame.buanzo.org/#lamewindl](http://lame.buanzo.org/#lamewindl).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要将文件导出为MP3格式，你需要在你的系统上安装一份**LAME**。你可以在[http://lame.buanzo.org/#lamewindl](http://lame.buanzo.org/#lamewindl)下载LAME。
- en: Revving up your engine
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高你的引擎
- en: Now that you have a better understanding of how audio works in your computer,
    it's time to write some code to bring audio into your game. We generally don't
    work with audio directly. Instead, there are audio engines that do all of the
    hard work for us, and one of the most popular ones is **FMOD**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经更好地理解了计算机中音频的工作方式，是时候编写一些代码将音频引入你的游戏了。我们通常不直接处理音频。相反，有音频引擎为我们做所有艰苦的工作，其中最受欢迎的一个是**FMOD**。
- en: 'FMOD is a C and C++ API that allows us to load, manage, and play audio sources.
    FMOD is free to use for student and independent projects, so it is the perfect
    audio engine for our game. To use FMOD, you will have to go to the FMOD website,
    download the appropriate version of the API, and install it on your system:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: FMOD是一个C和C++ API，它允许我们加载、管理和播放音频源。FMOD对学生和独立项目免费使用，因此它是我们游戏的完美音频引擎。要使用FMOD，你必须访问FMOD网站，下载适当的API版本，并将其安装到你的系统上：
- en: To download FMOD, go to [http://www.FMOD.org/download/](http://www.FMOD.org/download/).
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要下载FMOD，请访问[http://www.FMOD.org/download/](http://www.FMOD.org/download/)。
- en: There several downloads to choose from. Scroll down to the **FMOD Ex Programmer's
    API,** and click the **Download** button for Windows.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有几个下载选项可供选择。向下滚动到**FMOD Ex程序员API**，然后点击Windows的**下载**按钮。
- en: You will have to locate the exe file that you just downloaded and install it.
    Make a note of the folder that FMOD is installed in.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你必须找到你刚刚下载的exe文件并安装它。记下FMOD安装的文件夹。
- en: Once you have downloaded FMOD, you will have to incorporate it into the game
    project. Start by opening the `RoboRacer2D` project.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载FMOD后，你必须将其集成到游戏项目中。首先打开`RoboRacer2D`项目。
- en: Tip
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: I'm sure that you would like to see the full documentation for the **FMOD API**.
    If you installed FMOD in the default location, you will find the documentation
    at `C:\Program Files (x86)\FMOD SoundSystem\FMOD Programmers API Windows\documentation`.
    The main documentation is found in the file fmodex.chm.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你很想看到**FMOD API**的完整文档。如果你在默认位置安装了FMOD，你将在`C:\Program Files (x86)\FMOD SoundSystem\FMOD
    Programmers API Windows\documentation`找到文档。主要文档位于文件fmodex.chm中。
- en: 'Now, it''s time to set up our game to use FMOD. Similar to most third-party
    libraries, there are three steps to hooking things up:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候设置我们的游戏以使用FMOD了。类似于大多数第三方库，连接东西有三个步骤：
- en: Accessing the `.dll` file.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问`.dll`文件。
- en: Linking to the library.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接到库。
- en: Point to the include files.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指向包含文件。
- en: Let' walk through this process.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步来。
- en: Accessing the FMOD .dll file
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问FMOD .dll文件
- en: 'There are several `.dll` files that are included with FMOD, and it is important
    to use the correct file. The following table summarizes the dll files that come
    with FMOD and their associated library file:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: FMOD包含几个`.dll`文件，使用正确的文件很重要。以下表格总结了随FMOD提供的dll文件及其相关的库文件：
- en: '| Dll | Description | Library |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| Dll | 描述 | 库 |'
- en: '| --- | --- | --- |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `fmodex.dll` | 32 bit FMOD API | `fmodex_vc.lib` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `fmodex.dll` | 32位FMOD API | `fmodex_vc.lib` |'
- en: '| `fmodexL.dll` | 32 bit FMOD API with debug logging | `fmodexL_vc.lib` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `fmodexL.dll` | 32位带调试日志的FMOD API | `fmodexL_vc.lib` |'
- en: '| `fmodex64.dll` | 64 bit FMOD API | `fmodex64_vc.lib` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `fmodex64.dll` | 64位FMOD API | `fmodex64_vc.lib` |'
- en: '| `fmodexL64.dll` | 64 bit FMOD API with debug logging | `fmodexL64_vc.lib`
    |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `fmodexL64.dll` | 64位带调试日志的FMOD API | `fmodexL64_vc.lib` |'
- en: It's up to you to decide whether or not to use the 32-bit or 64-bit versions
    of the library. The debug versions of the library write logging information out
    to a file. You can find more information in the documentation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由你决定是否使用库的32位或64位版本。库的调试版本会将日志信息写入文件。你可以在文档中找到更多信息。
- en: 'We are going to use the 32-bit file in our game. There are several places where
    we can place the file, but the simplest method is to simply copy the `.dll` file
    into our project:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在游戏中使用32位文件。我们可以将文件放置在几个地方，但最简单的方法是将`.dll`文件直接复制到我们的项目中：
- en: Navigate to `C:\Program Files (x86)\FMOD SoundSystem\FMOD Programmers API Windows\api`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`C:\Program Files (x86)\FMOD SoundSystem\FMOD Programmers API Windows\api`。
- en: Tip
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The preceding path assumes that you used the default install location. You may
    have to modify the path if you chose another location.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的路径假设你使用了默认的安装位置。如果你选择了另一个位置，你可能需要修改路径。
- en: Copy `fmodex.dll` to the project folder that contains the `RoboRacer2D` source
    code.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`fmodex.dll`复制到包含`RoboRacer2D`源代码的项目文件夹中。
- en: Linking to the library
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接到库
- en: 'The next step is to tell Visual Studio that we want to access the FMOD library.
    This is done by adding the library to the project properties:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是告诉Visual Studio我们想要访问FMOD库。这是通过将库添加到项目属性中完成的：
- en: Right-click on the project and choose **Properties**.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击项目并选择**属性**。
- en: Open the **Linker** branch under **Configuration Properties** and click on **Input**.![Linking
    to the library](img/8199OS_07_01.jpg)
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**配置属性**下的**链接器**分支中打开，然后点击**输入**。[链接到库](img/8199OS_07_01.jpg)
- en: Click in the **Addition Dependencies** entry, then click the drop-down arrow
    and choose **<Edit…>**.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**添加依赖项**条目中点击，然后点击下拉箭头并选择**<编辑…**>。
- en: Add `fmodex_vc.lib` to the list of dependencies.![Linking to the library](img/8199OS_07_02.jpg)
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`fmodex_vc.lib`添加到依赖项列表中。[链接到库](img/8199OS_07_02.jpg)
- en: Click **OK** to close the `Additional Dependencies` window.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**关闭`附加依赖项`窗口。
- en: Click **OK** to close the `Property Pages` window.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**关闭`属性页`窗口。
- en: 'Now, we have to tell Visual Studio where to find the library:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须告诉Visual Studio在哪里可以找到库：
- en: Right-click on the project and choose **Properties**.![Linking to the library](img/8199OS_07_03.jpg)
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击项目并选择**属性**。[链接到库](img/8199OS_07_03.jpg)
- en: Open the **Linker** branch under **Configuration Properties** and click on **General**.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**配置属性**下的**链接器**分支中打开，然后点击**常规**。
- en: Click in the **Additional Library Directories** entry, then click the drop-down
    arrow and choose **<Edit…>**:![Linking to the library](img/8199OS_07_04.jpg)
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**附加库目录**条目中点击，然后点击下拉箭头并选择**<编辑…**>：[链接到库](img/8199OS_07_04.jpg)
- en: Click on the **New Line** icon, and then click the ellipses (**…**) that appear.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**新行**图标，然后点击出现的省略号（**…**）。
- en: Navigate to `C:\Program Files (x86)\FMOD SoundSystem\FMOD Programmers API Windows\api\lib`
    and click **Select Folder**.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`C:\Program Files (x86)\FMOD SoundSystem\FMOD Programmers API Windows\api\lib`并点击**选择文件夹**。
- en: Click on **OK** to close the **Additional Library Directories** window.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**关闭`附加库目录`窗口。
- en: Click on **OK** to close the **Property Pages** window.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**关闭`属性页`窗口。
- en: Point to the include files
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指向包含文件
- en: Whenever you use third-party code, you generally have to include C++ header
    files in your code. Sometimes, we just copy the relevant header files into the
    project folder (for example, this is what we did with `SOIL.h`).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时使用第三方代码，通常你都必须在代码中包含C++头文件。有时，我们只是将相关的头文件复制到项目文件夹中（例如，这就是我们处理`SOIL.h`的方式）。
- en: 'With larger code bases, such as FMOD, we point Visual Studio to the location
    where the header files are installed:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像FMOD这样的大型代码库，我们将Visual Studio指向头文件安装的位置：
- en: Right-click on the project and choose **Properties**.![Point to the include
    files](img/8199OS_07_05.jpg)
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击项目并选择**属性**。[指向包含文件](img/8199OS_07_05.jpg)
- en: Open the **C/C++** branch under **Configuration Properties** and click on **General**.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**配置属性**下的**C/C++**分支中打开，然后点击**常规**。
- en: Click on the **Additional Include Directories** entry, then click the drop-down
    arrow, and choose **<Edit…>**.![Point to the include files](img/8199OS_07_06.jpg)
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**附加包含目录**条目，然后点击下拉箭头，选择**<编辑…**>。[指向包含文件](img/8199OS_07_06.jpg)
- en: Click the **New Line** icon, and then click the ellipses (**…**) that appear.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**新行**图标，然后点击出现的省略号（**…**）。
- en: Navigate to `C:\Program Files (x86)\FMOD SoundSystem\FMOD Programmers API Windows\api\inc`
    and click **Select Folder**.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`C:\Program Files (x86)\FMOD SoundSystem\FMOD Programmers API Windows\api\inc`并点击**选择文件夹**。
- en: Click **OK** to close the **Additional Include Directories** window.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**关闭`附加包含目录`窗口。
- en: Click **OK** to close the **Property Pages** window.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**关闭`属性页`窗口。
- en: 'The final step is to include the header files into our program. Open `RoboRacer2D.cpp`
    and add the following line to include the header file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将头文件包含到我们的程序中。打开`RoboRacer2D.cpp`并将以下行添加到包含头文件：
- en: '[PRE0]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You are finally ready to use our audio engine!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你终于准备好使用我们的音频引擎了！
- en: Initializing FMOD
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化FMOD
- en: The first code that we need to add is the code that will initialize the audio
    engine. Just like we must initialize OpenGL, the code will set up FMOD and check
    to see if there are any errors along the way.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加的第一段代码是初始化音频引擎的代码。就像我们必须初始化OpenGL一样，这段代码将设置FMOD并检查过程中是否有任何错误。
- en: 'Open `RoboRacer2D.cpp` and add the following code to the variable declarations
    area:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`RoboRacer2D.cpp`并将以下代码添加到变量声明区域：
- en: '[PRE1]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then add the following function:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后添加以下函数：
- en: '[PRE2]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This function creates the FMOD system and initializes it:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数创建FMOD系统并初始化它：
- en: First, we define a variable to catch FMOD error codes
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个变量来捕获FMOD错误代码
- en: The `System_Create` call creates the engine and stores the results in `audiomgr`
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System_Create` 调用创建引擎并将结果存储在 `audiomgr`'
- en: We then initialize FMOD with 50 virtual channels, normal mode, and
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们用50个虚拟通道、正常模式初始化FMOD，
- en: 'Finally, we need call the `InitAudio` function. Modify the `GameLoop` function,
    adding the highlighted line:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要调用`InitAudio`函数。修改`GameLoop`函数，添加高亮行：
- en: '[PRE3]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Virtual channels
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟通道
- en: The most significant feature that FMOD provides for us is **virtual channels**.
    Each sound that you play has to have its own channel to play on. The number of
    physical channels to play audio varies from device to device. Early sound cards
    could only handle two to four channels of sound at a time. Modern sound cards
    may be able to handle eight, sixteen, or even more.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: FMOD为我们提供的最重要的功能是**虚拟通道**。每个播放的声音都必须有自己的通道来播放。播放音频的物理通道数量因设备而异。早期的声卡一次只能处理两到四个声道的声音。现代声卡可能能够处理八个、十六个甚至更多的声道。
- en: It used to be up to the developer to make sure that the number of sounds playing
    at any one time did not exceed the number of channels on the hardware. If the
    game triggered a new sound and no channel was available, then the sound wouldn't
    play. This led to choppy, unpredictable audio.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，确保在任何时候播放的声音数量不超过硬件通道数量是由开发者负责的。如果游戏触发了一个新的声音，但没有可用通道，那么声音就不会播放。这导致了音频的断断续续和不可预测。
- en: Fortunately, FMOD handles all of this for us. FMOD uses virtual channels, and
    allows you to decide how many virtual channels you want to use. Behind the scenes,
    FMOD decides which virtual channels need to be assigned to a hardware channel
    at any given time.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，FMOD为我们处理了所有这些。FMOD使用虚拟通道，并允许你决定想要使用多少虚拟通道。在幕后，FMOD决定在任何给定时间需要分配给硬件通道的虚拟通道。
- en: In our code example, we initialized FMOD with 50 virtual channels. This is actually
    way more that we will use in this game, but it wouldn't be outrageous for a full
    game. When considering how many virtual channels to assign, you should think about
    how many audio sources will be loaded at any particular time. These sounds won't
    all be playing at one time, just available to play.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码示例中，我们用50个虚拟通道初始化了FMOD。这实际上比我们在这个游戏中会用到的要多得多，但对于一个完整游戏来说这并不夸张。在考虑分配多少虚拟通道时，你应该考虑在任何特定时间将加载多少音频源。这些声音不会同时播放，只是可供播放。
- en: Channel priority
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通道优先级
- en: FMOD can't make your hardware play more simultaneous sounds than it has physical
    sound channels, so you may wonder why you would ever assign more virtual channels
    than there are hardware channels.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: FMOD无法使你的硬件播放比物理声道更多的同时声音，因此你可能想知道为什么你总是会分配比硬件通道更多的虚拟通道。
- en: The first answer to this question is that you really don't know how many hardware
    channels will be available on the system where a player is actually playing your
    game. The use of virtual channels takes this concern away from you.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的第一个答案是，你实际上不知道玩家实际在系统中玩游戏时会有多少硬件通道可用。虚拟通道的使用消除了你的这个担忧。
- en: The second answer is that virtual channels allow you to design your audio as
    if you really had 50 (or 100) channels available to you. FMOD then takes care
    of managing those channels behind the scenes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个答案是，虚拟通道允许你设计你的音频，就像你真的有50（或100）个通道可用一样。然后FMOD在幕后负责管理这些通道。
- en: So, what happens if your game needs to play a ninth sound and there are only
    eight physical channels? FMOD uses a priority system to decide which of the current
    eight channels is no longer needed. For example, channel seven may be assigned
    to a sound effect that is no longer playing. FMOD then assigns channel seven to
    the new sound that wants to play.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果你的游戏需要播放第九个声音，而只有八个物理通道会发生什么？FMOD使用优先级系统来决定当前八个通道中哪一个不再需要。例如，第七个通道可能被分配给一个不再播放的声音效果。然后FMOD将第七个通道分配给想要播放的新声音。
- en: 'If all physical channels are actually playing a sound right now and FMOD needs
    to play a new sound, then it chooses the channel with the lowest priority, stops
    playing the sound on that channel, and plays the new sound. Factors that determine
    priority include:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有物理通道现在都在播放声音，而FMOD需要播放一个新的声音，那么它将选择优先级最低的通道，停止在该通道上播放声音，并播放新的声音。决定优先级的因素包括：
- en: How long ago the sound was triggered
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声音被触发的时间有多久
- en: Whether a sound is set to loop continuously
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声音是否被设置为连续循环
- en: The priority assigned by the programmer using the `Channel:setPriority` or `Sound::setDefaults`
    functions
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序员使用 `Channel:setPriority` 或 `Sound::setDefaults` 函数分配的优先级
- en: In 3D sound, how far away the sound is
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在3D声音中，声音距离的远近
- en: The current volume of the sound
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声音的当前音量
- en: So, you can still end up with sounds that drop out if your sound design exceeds
    the number of simultaneous, physical channels. But FMOD does its best to limit
    the impact this will have.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您的声音设计超过了同时物理通道的数量，您最终可能会得到丢失的声音。但FMOD会尽力限制这种影响。
- en: Bleeps and bloops
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 喇叭声和嘟嘟声
- en: Imagine watching a move that has no sound. As the main character runs down the
    alley, there are no footsteps. There is no swishing sound as his arms rub his
    jacket. There is no screech as a car comes to a halt just before hitting him.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下观看一个没有声音的电影。当主要角色沿着小巷跑时，没有脚步声。当他手臂摩擦夹克时，没有摩擦声。当一辆车在他即将撞到他之前停下来时，没有尖叫声。
- en: A movie without sound would be pretty boring, and so would most games. Sounds
    bring games to life. The best sound design is one where the player doesn't actually
    realize there is a sound design. This means crafting sound effects and music in
    a way that complement the game without being obnoxious.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 没有声音的电影会相当无聊，大多数游戏也是如此。声音让游戏栩栩如生。最好的声音设计是玩家实际上并没有意识到有声音设计。这意味着以补充游戏而不令人讨厌的方式制作音效和音乐。
- en: Sound effects
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 音效
- en: Sound effects generally correspond to some event or action that is happening
    in the game. A particular sound often corresponds to something that the player
    can see, but sound effects may also occur for something that the player cannot
    see, perhaps just round the corner.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 音效通常对应于游戏中发生的一些事件或动作。特定的声音通常对应于玩家可以看到的东西，但音效也可能发生在玩家看不到的地方，比如在角落附近。
- en: 'Let''s add our first sound effects to the game. We''ll keep it simple and add
    the following sounds:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向游戏中添加第一个音效。我们将保持简单，并添加以下声音：
- en: A rolling sound as Robo moves across the screen
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当Robo在屏幕上移动时发出的滚动声音
- en: A sound when Robo jumps up or jumps down
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当Robo跳起或跳下时发出的声音
- en: A happy sound when he collides with an oil can
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当他与油罐碰撞时发出的欢快声音
- en: A not-so-happy sound when he collides with a water bottle
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当他与水瓶碰撞时发出的不太愉快的声音
- en: Setting up the sounds
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置声音
- en: 'We''ll start by setting up some variables to act as pointers to our sounds.
    Open `RoboRacer2D.cpp` and add the following code in the variable declarations
    section:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先设置一些变量作为指向我们的声音的指针。打开 `RoboRacer2D.cpp` 并在变量声明部分添加以下代码：
- en: '[PRE4]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have three pointers to sound and one pointer to a channel. We only need one
    channel pointer because only one sound (`sfxMovement`) will be a looping sound.
    Looping sounds need a persistent channel pointer while one-shot sounds do not.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个指向声音的指针和一个指向通道的指针。我们只需要一个通道指针，因为只有一个声音（`sfxMovement`）将是循环声音。循环声音需要一个持久的通道指针，而一次性声音则不需要。
- en: 'Next, we will load these sounds. Add the following function to `RoboRacer2D.cpp`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将加载这些声音。将以下函数添加到 `RoboRacer2D.cpp`：
- en: '[PRE5]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can download these sounds from the book's website or you can replace them
    with your own. Just be sure that you are using very short sounds for oil, water,
    and jump because they are intended to play quickly.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从本书的网站下载这些声音，或者您可以用自己的声音替换它们。只需确保您使用非常短的声音来模拟油、水和跳跃，因为它们旨在快速播放。
- en: This function loads our three sound effects files into the audio system.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将我们的三个音效文件加载到音频系统中。
- en: The `createSound` function allocates memory for the sound and sets the FMOD
    properties for the sound.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createSound` 函数为声音分配内存并设置声音的FMOD属性。'
- en: '`FMOD_DEFAULT` sets up the following FMOD properties:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FMOD_DEFAULT` 设置以下FMOD属性：'
- en: '`FMOD_LOOP_OFF`: The sound plays once and does not loop'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FMOD_LOOP_OFF`：声音播放一次，不会循环'
- en: '`FMOD_2D`: This is a 2D sound'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FMOD_2D`：这是一个2D声音'
- en: '`FMOD_HARDWARE`: This uses the hardware features of the device to handle audio'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FMOD_HARDWARE`：这使用设备的硬件功能来处理音频'
- en: The result variable catches return value. In production games, you would test
    this each time to make sure that the sound had successfully loaded (we leave those
    error checks off here to save space).
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果变量捕获返回值。在生产游戏中，你每次都会测试这个功能，以确保声音已成功加载（我们在这里省略了那些错误检查，以节省空间）。
- en: Notice that we call `playSound` on the movement SFX. We are going to start this
    sound, assign it to the next free hardware channel (`FMOD_CHANNEL_FREE`), but
    tell FMOD to immediately pause it (thus the `true` parameter). When we want to
    play the sound, we will play it, and when we want it to stop, we will pause it.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意我们在移动SFX上调用`playSound`。我们将开始这个声音，将其分配给下一个空闲的硬件通道（`FMOD_CHANNEL_FREE`），但告诉FMOD立即暂停它（因此`true`参数）。当我们想要播放声音时，我们将播放它，当我们想要停止它时，我们将暂停它。
- en: We will call `playSound` on the other SFX as needed. As they are not looping
    sounds, we do not have to manage their paused state.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将根据需要调用其他SFX的`playSound`。由于它们不是循环声音，我们不需要管理它们的暂停状态。
- en: Notice that we set `sfxJump`, `sfxOilcan`, and `sfxWater` to use the `FMOD_DEFAULT`
    settings. However, we will need `sfxMovement` to loop, so we had to set its setting
    flags individually.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将`sfxJump`、`sfxOilcan`和`sfxWater`设置为使用`FMOD_DEFAULT`设置。然而，我们需要`sfxMovement`循环，因此我们必须单独设置其设置标志。
- en: 'There are several flags that you can use to set the properties of a sound,
    and you can use the OR operator (`|`) to combine flags:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个标志可以用来设置声音的属性，并且可以使用OR运算符（`|`）来组合标志：
- en: '`FMOD_HARDWARE`: This uses the device hardware to handle the audio.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FMOD_HARDWARE`：这使用设备硬件来处理音频。'
- en: '`FMOD_SOFTWARE`: This uses FMOD''s software emulation to handle the audio (slower,
    but could give access to features not supported by the device).'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FMOD_SOFTWARE`：这使用FMOD的软件模拟来处理音频（较慢，但可能可以访问设备不支持的功能）。'
- en: '`FMOD_2D`: This is a 2D sound. This is the format we will use for this game!'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FMOD_2D`：这是一个2D声音。这是我们将在游戏中使用的格式！'
- en: '`FMOD_3D`: This is a 3D sound. 3D sounds can be placed in 3D space and appear
    to have both distance (for example, the sound gets softer as it is further away)
    and position (left, right, in front of, behind).'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FMOD_3D`：这是一个3D声音。3D声音可以放置在3D空间中，并似乎具有距离（例如，声音随着距离的增加而变弱）和位置（左、右、前面、后面）。'
- en: '`FMOD_LOOP_OFF`: The sound plays once and does not loop.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FMOD_LOOP_OFF`：声音播放一次且不循环。'
- en: '`FMOD_LOOP_NORMAL`: The sound plays and then starts over again, looping indefinitely.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FMOD_LOOP_NORMAL`：声音播放后重新开始，无限循环。'
- en: There are many other flags that can be set. Take a look at the FMOD documentation
    for additional details.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他可以设置的标志。请查看FMOD文档以获取更多详细信息。
- en: 'Now that we have a function to load our sounds, we have to wire it into the
    initialization for the game. Modify the `GameLoop` function, adding the following
    highlighted line:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了加载我们的声音的函数，我们必须将其连接到游戏的初始化中。修改`GameLoop`函数，添加以下突出显示的行：
- en: '[PRE6]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Playing sounds
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 播放声音
- en: Now, we need to trigger the sound effects at the appropriate time. Let's start
    with Robo's movement SFX. Basically, we want to play this sound any time Robo
    is actually moving.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在适当的时间触发音效。让我们从Robo的移动音效开始。基本上，我们希望在Robo实际移动时播放这个声音。
- en: 'We are going to modify the `CM_STOP`, `CM_LEFT`, and `CM_RIGHT` cases in the
    `ProcessInput` function. Update the code inserting the highlighted lines indicated
    as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改`ProcessInput`函数中的`CM_STOP`、`CM_LEFT`和`CM_RIGHT`情况。通过插入以下突出显示的行来更新代码：
- en: '[PRE7]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Remember, we already loaded `sfxMovement` and assigned it to a virtual channel
    (`chMovement`), then told it to start playing as a paused sound. Actually, in
    FMOD, you pause and play the channel, not the sound. So, all we have to do now
    is call `chMovement->setPaused(true)` when Robo is moving and `chMovement->setPaused(false)`
    when he is not moving.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们已加载`sfxMovement`并将其分配给一个虚拟通道（`chMovement`），然后告诉它以暂停状态开始播放。实际上，在FMOD中，我们暂停和播放通道，而不是声音。因此，我们现在只需在Robo移动时调用`chMovement->setPaused(true)`，在他不移动时调用`chMovement->setPaused(false)`。
- en: 'Now, we need to handle the oil and water pickups. These can both be handled
    in the `CheckCollisions` function. Modify `CheckCollisions` by adding the following
    highlighted lines of code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要处理油和水收集。这两个都可以在`CheckCollisions`函数中处理。通过添加以下突出显示的代码行来修改`CheckCollisions`：
- en: '[PRE8]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, we will add a sound effect for Robo when he jumps up or jumps down.
    These changes will be applied to the `CM_UP` and `CM_DOWN` cases in the `ProcessInput`
    function. Modify the existing code with the following highlighted lines:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将为Robo跳跃或下落时添加音效。这些更改将应用于`ProcessInput`函数中的`CM_UP`和`CM_DOWN`情况。使用以下突出显示的行修改现有代码：
- en: '[PRE9]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'These sound effects are one-shot sounds. When they are done playing, we don''t
    need to worry about them any more until it is time to play them again. For this
    type of sound, we create a channel (`FMOD::channel* channel`), then call `playSound`
    using:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这些音效是单次声音。当它们播放完毕后，我们不需要再担心它们，直到再次播放它们的时候。对于这种类型的音效，我们创建一个通道（`FMOD::channel*
    channel`），然后使用以下方式调用 `playSound`：
- en: '`FMOD_CHANNEL_FREE`: This lets FMOD pick the next available hardware sound
    channel.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FMOD_CHANNEL_FREE`：这允许FMOD选择下一个可用的硬件声音通道。'
- en: 'Sound pointer: `sfxWater` for the water bottle, `sfxOilcan` for the oil, and
    `sfxJump` for the jump SFX.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音效指针：`sfxWater` 用于水瓶，`sfxOilcan` 用于油，`sfxJump` 用于跳跃音效。
- en: '`false`: Don''t pause the sound!'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`false`：不要暂停声音！'
- en: '`&channel`: This is the virtual channel handle. Notice that this is just a
    local variable. We don''t need to store this anywhere for one-shot SFX.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&channel`：这是虚拟通道句柄。请注意，这只是一个局部变量。对于一次性音效，我们不需要将其存储在任何地方。'
- en: That's it! If you play the game now, the four SFX should trigger according to
    our design.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！如果你现在玩游戏，四个音效应该会根据我们的设计触发。
- en: UI feedback
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UI反馈
- en: So far, we created sound effects to respond to events and actions in the game.
    Sound effects are also used to provide feedback from the user interface. For example,
    when the player clicks a button, there should be some kind of audio that plays
    so that the player immediately knows that the click was registered.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了音效来响应当前游戏中的事件和动作。音效也用于从用户界面提供反馈。例如，当玩家点击按钮时，应该播放某种音频，以便玩家立即知道点击已被注册。
- en: 'Fortunately, we already trap each time the user has clicked a UI button, so
    it''s easy to trigger a sound each time it happens. Let''s start by adding a new
    sound pointer. In `RoboRacer2D.cpp`, add the following line to the variable declarations:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们已经捕捉到每次用户点击UI按钮的情况，所以每次发生时触发声音很容易。让我们首先添加一个新的声音指针。在 `RoboRacer2D.cpp`
    中，将以下行添加到变量声明中：
- en: '[PRE10]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then add the following code to `LoadAudio`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在 `LoadAudio` 中添加以下代码：
- en: '[PRE11]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, add the following highlighted lines of code to the `CM_UI` case in
    `ProcessInput`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将以下高亮显示的代码行添加到 `ProcessInput` 中的 `CM_UI` 情况：
- en: '[PRE12]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: At this point, when you run the game you will now hear an SFX each time a button
    is clicked.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，当你运行游戏时，每次点击按钮你都会听到一个音效。
- en: The sound of music
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音乐的声音
- en: We now turn to the audio soundtrack for our game. Just like a movie soundtrack,
    the music that is played during a game sets the tone for the game. Many games
    have huge, orchestrated productions, while others have synthesized or 8-bit music.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在转向我们游戏的音频音轨。就像电影配乐一样，在游戏中播放的音乐为游戏设定了基调。许多游戏有巨大的、编排精良的制作，而其他游戏则有合成或8位音乐。
- en: As we have already discussed, music files are handled in a different manner
    from sound effects. This is because sound effects are usually very short sounds
    that can be best stored as wav files. Music files tend to be much longer, and
    are stored as MP3 files because the data can be compressed, taking less storage
    and less memory.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经讨论过的，音乐文件和音效的处理方式不同。这是因为音效通常是很短的声音，最好以wav文件的形式存储。音乐文件通常要长得多，并以MP3文件的形式存储，因为数据可以被压缩，占用更少的存储空间和内存。
- en: We are going to add a single music track to our game. To keep things simple,
    we will tell the track to loop so that it runs continuously throughout the game.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向我们的游戏添加一条单独的音乐音轨。为了使事情简单，我们将告诉音轨循环播放，以便它在整个游戏中持续运行。
- en: 'We will start by adding a sound pointer. Open `RoboRacer2D.cpp` and add the
    following line of code to the variable declarations:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先添加一个声音指针。打开 `RoboRacer2D.cpp` 并在变量声明中添加以下代码行：
- en: '[PRE13]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, go to the `LoadAudio` function and add the following line:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，转到 `LoadAudio` 函数并添加以下行：
- en: '[PRE14]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that we use `createStream` instead of `createSound` to load our music
    file. As music is so much longer than sound effects, music is streamed from storage
    rather than loaded directly into memory.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用 `createStream` 而不是 `createSound` 来加载我们的音乐文件。由于音乐比音效长得多，音乐是从存储中流式传输的，而不是直接加载到内存中。
- en: We want the sound track to start when the game starts, so we start playing the
    music in right after it is loaded using `playSound`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望音轨在游戏开始时启动，所以我们在加载后立即使用 `playSound` 开始播放音乐。
- en: That's all there is to it! Our game is now enhanced by a vibrant soundscape.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么多了！我们的游戏现在通过生动的声音景观得到了增强。
- en: Cleaning up the house
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打扫房子
- en: We have a pretty complete game. Sure, it's not going to set any records or make
    anyone rich, but if this is your first game, then congratulations!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个相当完整的游戏。当然，它不会打破任何记录或使任何人致富，但如果这是你的第一个游戏，那么恭喜你！
- en: 'We have been remiss in one area: good programming dictates that any time we
    create an object, we delete it when we are done using it. Up to now, you may be
    wondering if we were ever going to do this! Well, now is the time.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在某个方面有所疏忽：良好的编程实践要求我们每次创建一个对象后，在使用完毕时都应将其删除。到目前为止，你可能想知道我们是否真的会这样做！好吧，现在就是时候了。
- en: We made a placeholder for all of these operations in the `EndGame` function.
    Now, we will add the necessary code to properly release our resources.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`EndGame`函数中为所有这些操作留了一个占位符。现在，我们将添加必要的代码来正确释放我们的资源。
- en: Release sprites
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 释放精灵
- en: 'Let''s start by clearing out our sprites. It is important to remember that
    when we remove any resource, we need to make sure that it is also releasing its
    own resources. This is the purpose of the class destructor. Let''s use the `Sprite`
    class as an example. Open `Sprite.cpp` and you should see a destructor defined
    using the following code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从清理我们的精灵开始。重要的是要记住，当我们移除任何资源时，我们需要确保它也释放了自己的资源。这就是类析构函数的目的。让我们以`Sprite`类为例。打开`Sprite.cpp`，你应该会看到使用以下代码定义的析构函数：
- en: '[PRE15]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We first want to release all of the textures in the `m_textures` array. Then
    we use `delete[]` to release the `m_textures` array. It is also good programming
    practice to set the variable to `NULL` once an object has been deleted.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先想要释放`m_textures`数组中的所有纹理。然后我们使用`delete[]`来释放`m_textures`数组。一旦对象被删除，将变量设置为`NULL`也是良好的编程实践。
- en: 'The `Sprite` destructor will be called when we call `delete` on a sprite object.
    So, the first thing we need to add to `EndGame` is a `delete` operation for each
    sprite that was created for our game. Add the following lines of code to the `EndGame`
    function:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在精灵对象上调用`delete`时，将调用`Sprite`析构函数。因此，我们需要首先在`EndGame`中添加对为我们的游戏创建的每个精灵的`delete`操作。在`EndGame`函数中添加以下代码行：
- en: '[PRE16]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Tip
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you look closely, you will notice that we did not delete the player object.
    This is because player was only used as a pointer to sprites that had already
    been created. Put another way, we never used player to create a new Sprite. A
    good rule of thumb is that there should be exactly one delete for every new.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，你会注意到我们没有删除玩家对象。这是因为玩家仅用作指向已创建精灵的指针。换句话说，我们从未使用玩家来创建新的精灵。一个很好的经验法则是，对于每个新创建的对象，应该恰好有一个删除操作。
- en: Release input
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 释放输入
- en: 'Our next system to shut down is the input system. First, let''s complete the
    `Input` destructor. Add the highlighted code to the destructor in the `Input`
    class:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要关闭的系统是输入系统。首先，让我们完成`Input`析构函数。在`Input`类的析构函数中添加以下高亮代码：
- en: '[PRE17]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We have to delete the `uiElements` array, which was an array of pointers to
    the sprites that were part of the input system. Note that we did not delete the
    actual sprites here because they were not created by the input system.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须删除`uiElements`数组，这是一个指向输入系统中的精灵的指针数组。请注意，我们在这里没有删除实际的精灵，因为它们不是由输入系统创建的。
- en: 'Now, add the following line of code to `EndGame`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`EndGame`中添加以下代码行：
- en: '[PRE18]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Releasing fonts
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 释放字体
- en: 'Add this line to release the display lists we used to store our fonts:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下行以释放我们用于存储字体的显示列表：
- en: '[PRE19]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Releasing audio
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 释放音频
- en: 'Our final cleanup is the audio system. Add the following lines of code to `EndGame`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的清理工作是音频系统。在`EndGame`中添加以下代码行：
- en: '[PRE20]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Congratulations! Your house is all cleaned up.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你的房子已经全部清理干净了。
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: We covered a lot of material in this chapter, and in the process, we completed
    our 2D game. You learned a little about how audio is represented in the computer.
    Then we installed the FMOD API and learned how to integrate it into our project.
    Finally, we used FMOD to set up and play sound effects and music in our game.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中涵盖了大量的内容，在这个过程中，我们完成了我们的2D游戏。你了解了一些关于计算机中音频表示的知识。然后我们安装了FMOD API，并学习了如何将其集成到我们的项目中。最后，我们使用FMOD在游戏中设置和播放音效和音乐。
- en: This chapter completes our discussion of game programming in 2D. As you should
    now be aware, there is a lot more to completing a game than using the OpenGL library.
    Remember, OpenGL is a rendering library. We had to write our own class to handle
    input and we used a third-party class to handle audio.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 本章完成了我们对2D游戏编程的讨论。你应该现在已经清楚，完成一个游戏不仅仅使用OpenGL库。记住，OpenGL是一个渲染库。我们必须编写自己的类来处理输入，并使用第三方类来处理音频。
- en: In the next chapter, we begin our foray into the world of 3D programming!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们开始探索3D编程的世界！
