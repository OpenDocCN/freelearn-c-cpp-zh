- en: '*Chapter 7*: Model View Programming'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：模型视图编程'
- en: '**Model/View programming** is used to separate data from Views in Qt to handle
    datasets. The **Model/View (M/V)** architecture differentiates the functionalities
    that give freedom to the developers to modify and present the information on the
    **User Interface** (**UI**) in multiple ways. We will discuss each component of
    the architecture,the related convenience classes offered by Qt, and how to use
    them with practical examples. Throughout this chapter, we will be discussing the
    Model View pattern and understand the underlying core concepts.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 模型/视图编程用于在Qt中处理数据集时将数据与视图分离。**模型/视图（M/V）**架构区分了功能，使开发人员可以以多种方式修改和呈现**用户界面（UI）**上的信息。我们将讨论架构的每个组件，Qt提供的相关便利类，以及如何使用实际示例。在本章中，我们将讨论模型视图模式并了解基本核心概念。
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Fundamentals of the M/V architecture
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M/V架构的基本原理
- en: Using Models and Views
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模型和视图
- en: Creating custom Models and delegates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义模型和委托
- en: Displaying information using M/V in Qt Widgets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Qt小部件中使用M/V显示信息
- en: Displaying information using M/V in QML
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在QML中使用M/V显示信息
- en: Using C++ Models with QML
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C++模型与QML
- en: By the end of this chapter, you will be able to create a data model and display
    information on a customized UI. You will be able to write your custom models and
    delegates. You will also learn to represent the information in a UI through Qt
    Widgets and QML.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够创建数据模型并在自定义UI上显示信息。您将能够编写自定义模型和委托。您还将学会通过Qt小部件和QML在UI中表示信息。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The technical requirements for this chapter include the minimum versions of
    Qt 6.0.0 and Qt Creator 4.14.0 installed on one of the latest desktop platforms,
    such as Windows 10, Ubuntu 20.04, or macOS 10.14.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求包括在最新的桌面平台之一（如Windows 10、Ubuntu 20.04或macOS 10.14）上安装Qt 6.0.0和Qt Creator
    4.14.0的最低版本。
- en: 'All the code used in this chapter can be downloaded from the following GitHub
    link: [https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter07](https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter07).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有代码都可以从以下GitHub链接下载：[https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter07](https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter07)。
- en: Important note
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The screenshots used in this chapter are taken on the Windows platform. You
    will see similar screens based on the underlying platform on your machine.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的屏幕截图是在Windows平台上获取的。您将在您的机器上基于底层平台看到类似的屏幕。
- en: Understanding the M/V architecture
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解M/V架构
- en: 'Traditionally, the **Model-View-Controller** (**MVC**) design pattern is often
    used when building UIs. As the name suggests, it consists of three terms: Model,
    View, and Controller. The **Model** is an independent component with a dynamic
    data structure and logic, the **View** is the visual element, and the **Controller**
    decides how the UI responds to the user inputs. Before MVC came into existence,
    developers used to put these components together. It is not always possible to
    decouple the Controller from other components although developers want to keep
    them as distinct from each other as possible. MVC design decouples the components
    to increase flexibility and reuse. The following figure illustrates the components
    of a traditional MVC pattern:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，在构建UI时经常使用**模型-视图-控制器（MVC）**设计模式。顾名思义，它由三个术语组成：模型、视图和控制器。**模型**是具有动态数据结构和逻辑的独立组件，**视图**是视觉元素，**控制器**决定UI如何响应用户输入。在MVC出现之前，开发人员通常将这些组件放在一起。虽然开发人员希望将控制器与其他组件分离，但并不总是可能。MVC设计将组件解耦以增加灵活性和重用。以下图示了传统MVC模式的组件：
- en: '![Figure 7.1 – Traditional MVC design pattern'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1 – 传统MVC设计模式'
- en: '](img/Figure_7.1_B16231.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.1_B16231.jpg)'
- en: Figure 7.1 – Traditional MVC design pattern
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 传统MVC设计模式
- en: 'In the MVC pattern, a user sees the View and interacts with a Controller. The
    Controller sends data to the Model and the Model updates the View. If the View
    and the Controller components are combined, then it results in the M/V architecture.
    It provides a more versatile architecture. It is based on the same principle but
    makes the implementation much simpler. The modified architecture allows us to
    display the same data in several different Views. The developer can implement
    new types of Views without changing the underlying data structures. To bring this
    flexibility to our handling of the user inputs, Qt introduced the concept of **delegate**.
    Instead of having a Controller, the View receives the data that is updated via
    a delegate. It has two primary purposes:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在MVC模式中，用户看到视图并与控制器交互。控制器将数据发送到模型，模型更新视图。如果视图和控制器组件合并，则会得到M/V架构。它提供了更灵活的架构。它基于相同的原则，但使实现变得更简单。修改后的架构允许我们在多个不同的视图中显示相同的数据。开发人员可以实现新类型的视图而不更改底层数据结构。为了将这种灵活性带入我们对用户输入的处理中，Qt引入了**委托**的概念。视图接收通过委托更新的数据，而不是通过控制器。它有两个主要目的：
- en: To help the View render each value
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了帮助视图呈现每个值
- en: To help the View when the user wants to make some changes
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了帮助视图在用户想要进行一些更改时
- en: So, in a certain way, the Controller has combined with the View and the View
    also performs some of the Controller's work through the delegate. The benefit
    of having a delegate is that it provides the means by which data elements are
    rendered and modified.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在某种程度上，控制器已与视图合并，并且视图还通过委托执行了一些控制器的工作。拥有委托的好处在于它提供了渲染和修改数据元素的手段。
- en: 'Let''s understand the M/V implementation and its components with a diagram:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过图表了解M/V的实现和其组件：
- en: '![Figure 7.2 – The Qt Model-View-Delegate Framework'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2 – Qt模型-视图-委托框架'
- en: '](img/Figure_7.2_B16231.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.2_B16231.jpg)'
- en: Figure 7.2 – The Qt Model-View-Delegate Framework
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 - Qt模型-视图-委托框架
- en: As illustrated in *Figure 7.2*, the M/V components are separated into the three
    sections of **Model**, **View**, and **Delegate**. The **Model** interacts with
    a database and works as an interface for the architecture's other components.
    The purpose of the communication is determined by the data source and the model's
    implementation. The **View** attains the references to items of data known as
    a **model index**. The View can retrieve the individual item data from the data
    model by using this model index. In standard Views, a delegate renders the items
    of data. When an item is modified, the **Delegate** notifies the Model by using
    the model index.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图7.2*所示，M/V组件分为**模型**、**视图**和**委托**三个部分。**模型**与数据库交互，并作为架构其他组件的接口。通信的目的由数据源和模型的实现确定。**视图**获取称为**模型索引**的数据项的引用。视图可以通过使用这个模型索引从数据模型中检索单个数据项。在标准视图中，委托渲染数据项。当数据项被修改时，**委托**使用模型索引通知模型。
- en: '*Figure 7.3* illustrates how a Model delivers data to the View, which is displayed
    on the individual delegates:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.3*说明了模型如何向视图提供数据，并在单个委托上显示：'
- en: '![Figure 7.3 – Model-View-Delegate implementation illustration'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.3 - 模型-视图-委托实现示意图'
- en: '](img/Figure_7.3_B16231.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.3_B16231.jpg)'
- en: Figure 7.3 – Model-View-Delegate implementation illustration
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 - 模型-视图-委托实现示意图
- en: The Qt framework provides a set of standard classes that implement the M/V architecture
    to manage the relationship between data and how the user sees it. By decoupling
    the functionalities, the architecture provides flexibility to customize the presentation
    of data and allows the combining of an extensive range of data sources with the
    Views.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Qt框架提供了一组标准类，实现了M/V架构，用于管理数据与用户视图之间的关系。通过解耦功能，该架构提供了灵活性，可以定制数据的呈现方式，并允许将广泛的数据源与视图结合起来。
- en: The Model, View, and Delegate use a **signal and slot mechanism** to communicate
    with each other. The Model emits a signal to notify about the data change that
    occurred in the data source. When a user interacts with the View, then a signal
    from the View is emitted to notify about the user action. The Delegate emits a
    signal to notify the Model and View about the edited state.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 模型、视图和委托使用**信号和槽机制**进行通信。模型发出信号通知数据源中发生的数据更改。当用户与视图交互时，视图发出信号通知用户操作。委托发出信号通知模型和视图有关编辑状态的变化。
- en: Now, you have learned the fundamentals of the M/V architecture. The following
    sections explain how to use the M/V pattern in Qt. We will start with the standard
    classes provided by the Qt framework and then we will discuss the use of M/V in
    Qt Widgets. You will learn how to create new components as per the M/V architecture.
    Let's go ahead!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经了解了M/V架构的基础知识。接下来的部分将解释如何在Qt中使用M/V模式。我们将从Qt框架提供的标准类开始，然后讨论在Qt部件中使用M/V。您将学习如何根据M/V架构创建新组件。让我们开始吧！
- en: Model
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型
- en: M/V removes the data consistency challenges that may happen with the standard
    widgets. It makes it easier to use more than one View for the same data, as one
    Model can be passed to multiple Views. Qt provides several abstract classes for
    M/V implementation with common interfaces and certain feature implementations.
    You can subclass the abstract classes and add the intended functionalities expected
    by other components.In the M/V implementation, the model provides a standard interface
    used by the View and delegate to access the data.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: M/V消除了标准部件可能出现的数据一致性挑战。它使得可以更容易地为相同数据使用多个视图，因为一个模型可以传递给多个视图。Qt提供了几个M/V实现的抽象类，具有共同的接口和特定的功能实现。您可以对抽象类进行子类化，并添加其他组件期望的功能。在M/V实现中，模型提供了供视图和委托访问数据的标准接口。
- en: 'Qt offers some ready-made Model classes such as `QStandardItemModel`, `QFileSystemModel`,
    and `QSqlTableModel`. `QAbstractItemModel` is the standard interface defined by
    Qt. The subclasses of `QAbstractItemModel` represent the data in a hierarchical
    structure. *Figure 7.4* illustrates the hierarchy of Model classes:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Qt提供了一些现成的模型类，如`QStandardItemModel`、`QFileSystemModel`和`QSqlTableModel`。`QAbstractItemModel`是Qt定义的标准接口。`QAbstractItemModel`的子类表示分层结构中的数据。*图7.4*说明了模型类的层次结构：
- en: '![Figure 7.4 – The hierarchy of Model classes in the Qt'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.4 - Qt中模型类的层次结构'
- en: '](img/Figure_7.4_B16231.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.4_B16231.jpg)'
- en: Figure 7.4 – The hierarchy of Model classes in the Qt
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 - Qt中模型类的层次结构
- en: Views use this approach to access individual data items in the Model, but they
    are not restricted in the way that they present this information to the user.
    The data passed through a Model can be held in a data structure or a database,
    or some other application component. All item Models are based on the `QAbstractItemModel`
    class.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 视图使用这种方法访问模型中的单个数据项，但在呈现信息给用户的方式上并没有受到限制。通过模型传递的数据可以保存在数据结构或数据库中，也可以是其他应用程序组件。所有的项模型都是基于`QAbstractItemModel`类的。
- en: '*Figure 7.5* shows how data is arranged in different types of Models:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.5*显示了不同类型的模型中数据的排列方式：'
- en: '![Figure 7.5 – Different types of models and arrangements of data'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5 - 不同类型的模型和数据排列方式'
- en: '](img/Figure_7.5_B16231.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.5_B16231.jpg)'
- en: Figure 7.5 – Different types of models and arrangements of data
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 - 不同类型的模型和数据排列方式
- en: The data is represented through Models either in a tabular representation in
    the form of rows and columns, or using a hierarchical representation of the data.
    In the M/V pattern, widgets do not store data behind the individual cells. They
    directly use the data. You may have to create a wrapper to make your data compatible
    with the `QAbstractItemModel` interface. Views use this interface to read and
    write the data. Any class that is derived from `QAbstractItemModel` is known as
    a Model. It provides an interface to handle Views that represent data in the forms
    of lists, tables, and trees. To implement a custom Model for a list or a table-like
    data structure, you can derive from `QAbstractListModel` and `QAbstractTableModel`
    to use the available features. The subclasses provide Models that are suitable
    for specialized lists and tables.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 数据通过模型以表格形式表示，以行和列的形式表示，或者使用数据的分层表示。在M/V模式中，小部件不会在单元格后面存储数据。它们直接使用数据。您可能需要创建一个包装器，使您的数据与`QAbstractItemModel`接口兼容。视图使用此接口来读取和写入数据。任何从`QAbstractItemModel`派生的类都称为模型。它提供了一个处理以列表、表格和树形式表示数据的视图的接口。要为列表或类似表格的数据结构实现自定义模型，可以从`QAbstractListModel`和`QAbstractTableModel`派生以使用可用的功能。子类提供了适用于特定列表和表格的模型。
- en: 'The Qt framework provides two standard types of Models. They are as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Qt框架提供了两种标准类型的模型。它们如下：
- en: '`QStandardItemModel`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QStandardItemModel`'
- en: '`QFileSystemModel`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QFileSystemModel`'
- en: The `QStandardItemModel` is a multi-purpose Model where custom data can be stored.
    Each element refers to an item. It can be used to display a variety of data structures
    needed by lists, tables, and tree Views. It provides a traditional item-based
    approach to dealing with the Model. `QStandardItem` provides the items used in
    a `QStandardItemModel`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`QStandardItemModel`是一个多用途模型，可以存储自定义数据。每个元素都指代一个项目。它可以用于显示列表、表格和树形视图所需的各种数据结构。它提供了一种传统的基于项目的处理模型。`QStandardItem`提供了在`QStandardItemModel`中使用的项目。'
- en: '`QFileSystemModel` is a Model that keeps information about the contents of
    a directory. It simply represents files and directories on the local filing system
    and doesn''t hold any items of data. It provides a ready-to-use Model to create
    a sample application and you can manipulate the data using Model indexes. Now,
    let''s discuss what a delegate is.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`QFileSystemModel`是一个保持目录内容信息的模型。它简单地表示本地文件系统上的文件和目录，并不保存任何数据项。它提供了一个现成的模型，用于创建一个示例应用程序，并且可以使用模型索引来操作数据。现在，让我们讨论一下委托是什么。'
- en: Delegate
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 委托
- en: Delegates provide control over the presentation of items displayed in the View.
    The M/V pattern, unlike the MVC pattern, does not have an entirely different component
    for handling user interaction. The View is primarily in charge of displaying the
    Model data to the user and allowing them to interact with it. To add some flexibility
    to how the user action is obtained, the delegates handle the interactions. It
    empowers certain widgets to be used as editors for editable items in the Model.
    Delegates are used to provide interaction capabilities and rendering individual
    fields in the Views. The `QAbstractItemDelegate` class defines the basic interface
    for managing delegates. There are a few ready-made delegate classes provided by
    Qt to use with built-in widgets to modify a particular data type.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 委托提供对视图中显示的项目呈现的控制。M/V模式与MVC模式不同，它没有一个完全不同的组件来处理用户交互。视图主要负责将模型数据显示给用户，并允许用户与其交互。为了增加用户操作的灵活性，委托处理这些交互。它赋予了某些小部件作为模型中可编辑项目的编辑器。委托用于提供交互功能并渲染视图中的单个字段。`QAbstractItemDelegate`类定义了管理委托的基本接口。Qt提供了一些现成的委托类，可用于与内置小部件一起使用以修改特定的数据类型。
- en: 'To understand it better, we will have a look at the hierarchy of delegate classes
    in the Qt framework (see *Figure 7.6*):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，我们将看一下Qt框架中委托类的层次结构（见*图7.6*）：
- en: '![Figure 7.6 – The hierarchy of delegate classes in the Qt framework'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.6 - Qt框架中委托类的层次结构'
- en: '](img/Figure_7.6_B16231.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.6_B16231.jpg)'
- en: Figure 7.6 – The hierarchy of delegate classes in the Qt framework
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 - Qt框架中委托类的层次结构
- en: As we can see in the preceding diagram, `QAbstractItemDelegate` is the abstract
    base class for delegates. The default delegate implementation is provided by `QStyledItemDelegate`.
    Qt's standard Views use it as the default delegate. Other options for painting
    and creating editors for items in Views are `QStyledItemDelegate` and `QItemDelegate`.
    You can use `QItemDelegate` to customize display features and editor widgets for
    an item. The difference between these two classes is that, unlike `QItemDelegate`,
    `QStyledItemDelegate` uses the current style to paint its items. `QStyledItemDelegate`
    can handle the most common data types such as `int` and `QString`. It is recommended
    to subclass `QStyledItemDelegate` while creating new delegates or while working
    with Qt Style Sheets. By writing a custom delegate, you can use a custom data
    type or customize the rendering.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的图表中所看到的，`QAbstractItemDelegate`是委托的抽象基类。`QStyledItemDelegate`提供了默认的委托实现。Qt的标准视图将其用作默认委托。用于在视图中绘制和创建编辑器的其他选项是`QStyledItemDelegate`和`QItemDelegate`。您可以使用`QItemDelegate`来自定义项目的显示特性和编辑器小部件。这两个类之间的区别在于，与`QItemDelegate`不同，`QStyledItemDelegate`使用当前样式来绘制其项目。`QStyledItemDelegate`可以处理最常见的数据类型，如`int`和`QString`。在创建新委托或使用Qt样式表时，建议从`QStyledItemDelegate`派生子类。通过编写自定义委托，您可以使用自定义数据类型或自定义渲染。
- en: In this section, we discussed the different types of Models and delegates. Let's
    discuss the View classes provided by Qt Widgets.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了不同类型的模型和委托。让我们讨论一下Qt Widgets提供的视图类。
- en: Views in Qt Widgets
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Qt Widgets中的视图
- en: Several convenience classes are derived from the standard View classes to implement
    the M/V pattern. Examples of such convenience classes are `QListWidget`, `QTableWidget`,
    and `QTreeWidget`. As per the Qt documentation, these classes are less adaptable
    than View classes, and they can't be used for random Models. Based on your project
    requirements, you have to choose suitable widget classes for implementing the
    M/V pattern.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个便利类是从标准View类派生出来实现M/V模式的。这些便利类的示例包括`QListWidget`、`QTableWidget`和`QTreeWidget`。根据Qt文档，这些类比View类更不灵活，不能用于随机模型。根据项目要求，您必须选择适合实现M/V模式的小部件类。
- en: 'If you want to use an item-based interface and take advantage of the M/V pattern,
    then it is recommended to use the following View classes with `QStandardItemModel`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用基于项目的界面并利用M/V模式，建议使用以下View类与`QStandardItemModel`一起使用：
- en: '`QListView` displays a list of items.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QListView`显示项目列表。'
- en: '`QTableView` displays data from a Model in a table.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QTableView`在表格中显示模型数据。'
- en: '`QTreeView` shows Model items of data in a hierarchical list.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QTreeView`以分层列表显示模型数据项。'
- en: 'The hierarchy of View classes in the Qt framework is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Qt框架中View类的层次结构如下：
- en: '![Figure 7.7 – The hierarchy of View classes in the Qt framework'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.7 - Qt框架中View类的层次结构'
- en: '](img/Figure_7.7_B16231.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.7_B16231.jpg)'
- en: Figure 7.7 – The hierarchy of View classes in the Qt framework
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 - Qt框架中View类的层次结构
- en: '`QAbstractItemView` is the abstract base class of the aforementioned classes.
    These classes can be derived to have specialized Views, even though they provide
    ready-to-use implementations. The most appropriate Views to use for `QFileSystemModel`
    are `QListView` and `QTreeView`. Each of these Views has its unique way of representing
    the data items. For example, `QTreeView` displays a tree hierarchy as a horizontal
    series of lists. All these Views must have a Model associated with them. There
    are several predefined Models provided by Qt. You can add your own customized
    Model if the ready-made Models don''t meet your criteria.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`QAbstractItemView`是上述类的抽象基类。尽管这些类提供了可直接使用的实现，但这些类可以派生为具有专门视图，最适合用于`QFileSystemModel`的视图是`QListView`和`QTreeView`。每个视图都必须与模型相关联。Qt提供了几个预定义的模型。如果现成的模型不符合您的标准，您可以添加自定义模型。'
- en: Unlike the View classes (for which the class name ends with `View`), the convenience
    widgets (for which the class name ends with `Widget`) do not need to be backed
    by a Model and can be used directly. The main advantage of using convenience widgets
    is that they require the least amount of effort to work with them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 与View类不同（类名以`View`结尾），便利小部件（类名以`Widget`结尾）不需要由模型支持，可以直接使用。使用便利小部件的主要优势是，它们需要的工作量最少。
- en: 'Let''s look at the different View classes in the Qt Widgets module and which
    readymade Models can be used with them:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Qt Widgets模块中的不同View类以及可以与它们一起使用的现成模型：
- en: '![Figure 7.8 – Different types of Qt widgets used as the View in the M/V pattern'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.8 - 在M/V模式中用作View的不同类型的Qt小部件'
- en: '](img/Figure_7.8_B16231.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.8_B16231.jpg)'
- en: Figure 7.8 – Different types of Qt widgets used as the View in the M/V pattern
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 - 在M/V模式中用作View的不同类型的Qt小部件
- en: The delegate is used to display individual field data in `QListView`, `QTableView`,
    or `QTreeView`. When a user starts interacting with an item, the delegate provides
    an editor widget for editing to take place.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 委托用于在`QListView`、`QTableView`或`QTreeView`中显示单个字段数据。当用户开始与项目交互时，委托提供一个编辑器小部件进行编辑。
- en: 'You can find a comparative overview of the aforementioned classes and learn
    about the uses of the corresponding widgets at the following link:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接找到上述类的比较概述，并了解相应小部件的用途：
- en: '[https://doc.qt.io/qt-6/modelview.html](https://doc.qt.io/qt-6/modelview.html)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://doc.qt.io/qt-6/modelview.html](https://doc.qt.io/qt-6/modelview.html)'
- en: In this section, you learned about the M/V architecture and got familiar with
    the terms used. Let's implement M/V with a simple GUI application using Qt Widgets.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您了解了M/V架构并熟悉了所使用的术语。让我们使用Qt Widgets创建一个简单的GUI应用程序来实现M/V。
- en: Creating a simple Qt Widgets application using the M/V pattern
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用M/V模式创建一个简单的Qt Widgets应用程序
- en: It is time for us to create a simple example using *Qt Widgets*. The example
    in this section illustrates how a predefined `QFileSystemModel` is used in association
    with the built-in `QListView` and `QTreeView` widgets. Delegation is automatically
    taken care of when the Views are double-clicked.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候使用*Qt Widgets*创建一个简单的示例了。本节中的示例演示了如何将预定义的`QFileSystemModel`与内置的`QListView`和`QTreeView`小部件关联使用。当双击视图时，委托会自动处理。
- en: 'Follow these steps to create a simple application that implements the M/V pattern:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个实现M/V模式的简单应用程序：
- en: Create a new project using Qt Creator, selecting the **Qt Widgets** template
    from the project creation wizard. It will generate a project with a predefined
    project skeleton.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Qt Creator创建一个新项目，从项目创建向导中选择**Qt Widgets**模板。它将生成一个带有预定义项目骨架的项目。
- en: Once the application skeleton is created, open the `.ui` form and add `QListView`
    and `QTreeView` to the form. You may add two labels to distinguish the Views as
    shown here:![](img/Figure_7.9_B16231.jpg)
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建应用程序骨架后，打开`.ui`表单并将`QListView`和`QTreeView`添加到表单中。您可以添加两个标签以区分视图，如下所示：![](img/Figure_7.9_B16231.jpg)
- en: Figure 7.9 – Create a UI with QListView and QTreeView using Qt Designer
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 - 使用Qt Designer创建一个带有QListView和QTreeView的UI
- en: 'Open the `mainwindow.cpp` file and add the following contents:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`mainwindow.cpp`文件并添加以下内容：
- en: '[PRE0]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding C++ implementation, we have used a predefined `QFileSystemModel`
    as the Model for the Views.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的C++实现中，我们使用了预定义的`QFileSystemModel`作为View的模型。
- en: Next, hit the **Run** button in the left pane. You will see a window as shown
    in *Figure 7.10* once you hit the **Run** button:![Figure 7.10 – Output of the
    sample application showing QListView and QTreeView
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击左侧窗格中的**运行**按钮。一旦您点击**运行**按钮，您将看到一个窗口，如*图7.10*所示：
- en: '](img/Figure_7.10_B16231.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.10_B16231.jpg)'
- en: Figure 7.10 – Output of the sample application showing QListView and QTreeView
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 - 显示QListView和QTreeView的示例应用程序的输出
- en: 'Let''s modify the existing application to use a custom Model derived from `QAbstractItemModel`.
    In the following example, we have created a simple `ContactListModel` custom class
    derived from `QAbstractItemModel`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们修改现有的应用程序，使用从`QAbstractItemModel`派生的自定义模型。在以下示例中，我们创建了一个简单的`ContactListModel`自定义类，它是从`QAbstractItemModel`派生的：
- en: '[PRE1]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, modify the UI form to implement a `QTableView` and set the contact list
    Model to it as shown in the following snippet:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，修改UI表单以实现`QTableView`，并将联系人列表模型设置为以下代码段所示：
- en: '[PRE2]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can add `QStringListModel` to the `QListView` to use a simple list Model:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以将`QStringListModel`添加到`QListView`中以使用简单的列表模型：
- en: '[PRE3]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, hit the **Run** button in the left pane. You will see a window as shown
    in *Figure 7.11*:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击左侧窗格中的**运行**按钮。一旦您点击**运行**按钮，您将看到一个窗口，如*图7.11*所示：
- en: '![Figure 7.11 – Output of the application using custom models in QListView
    and QTableView'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.11 - 使用自定义模型在QListView和QTableView中的应用程序输出'
- en: '](img/Figure_7.11_B16231.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.11_B16231.jpg)'
- en: Figure 7.11 – Output of the application using custom models in QListView and
    QTableView
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 - 使用自定义模型在QListView和QTableView中的应用程序输出
- en: Congratulations! You have learned how to use M/V for your Qt widgets project.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经学会了如何在Qt小部件项目中使用M/V。
- en: Important note
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: For more implementations of convenience classes such as `QTableWidget` or `QtTreeWidget`,
    explore the relevant examples on the Qt Creator welcome screen and this chapter's
    source code.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于方便类的实现，例如`QTableWidget`或`QtTreeWidget`，请在Qt Creator欢迎屏幕和本章的源代码中探索相关示例。
- en: 'You can also create your own custom delegate class. To create a custom delegate,
    you need to subclass `QAbstractItemDelegate` or any of the convenience classes
    such as `QStyledItemDelegate` or `QItemDelegate`. A custom delegate class may
    look like the following code snippet:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以创建自己的自定义委托类。要创建自定义委托，您需要对`QAbstractItemDelegate`或任何方便类（如`QStyledItemDelegate`或`QItemDelegate`）进行子类化。自定义委托类可能如下面的代码片段所示：
- en: '[PRE4]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You have to override the virtual methods and add respective logic as per your
    project needs. You can learn more about the custom delegates and examples at the
    following link:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须重写虚拟方法，并根据项目需求添加相应的逻辑。您可以在以下链接了解有关自定义委托和示例的更多信息：
- en: '[https://doc.qt.io/qt-6/model-View-programming.html](https://doc.qt.io/qt-6/model-View-programming.html)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://doc.qt.io/qt-6/model-View-programming.html](https://doc.qt.io/qt-6/model-View-programming.html)'
- en: In this section, we learned how to create a GUI application that uses the M/V
    pattern. In the next section, we will discuss how it is implemented in QML.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何创建使用M/V模式的GUI应用程序。在下一节中，我们将讨论它在QML中的实现方式。
- en: Understanding Models and Views in QML
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解QML中的模型和视图
- en: Just like Qt Widgets, Qt Quick also implements Models, Views, and delegates
    to display data. The implementation modularizes the visualization of data to empower
    developers to manage that data. You can change one View with another with minimal
    changes to the data.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与Qt小部件一样，Qt Quick也实现了模型、视图和委托来显示数据。该实现将数据的可视化模块化，使开发人员能够管理数据。您可以通过最小的更改来将一个视图更改为另一个视图。
- en: To visualize data, bind the View's `model` property to a Model and the `delegate`
    property to a component or another compatible type.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要可视化数据，将视图的`model`属性绑定到模型，将`delegate`属性绑定到组件或其他兼容类型。
- en: Let's discuss the QML types available for implementing the M/V pattern in a
    Qt Quick application.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论在Qt Quick应用程序中实现M/V模式的可用QML类型。
- en: Views in Qt Quick
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Qt Quick中的视图
- en: Views are containers that display data and are used for collections of items.
    These containers are feature-rich and can be customized to meet specific style
    or behavior requirements.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 视图是显示数据的容器，用于项目集合。这些容器功能丰富，可以根据特定的样式或行为要求进行定制。
- en: 'There is a set of standard Views provided in the basic set of Qt Quick graphical
    types:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt Quick图形类型的基本集中提供了一组标准视图：
- en: '`ListView`: Lays out items in a horizontal or vertical list'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListView`：以水平或垂直列表方式布置项目'
- en: '`GridView`: Lays out items in a grid manner'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GridView`：以网格方式布置项目'
- en: '`TableView`: Lays out items in a tabular form'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TableView`：以表格形式布置项目'
- en: '`PathView`: Lays out items on a path'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PathView`：在路径上布置项目'
- en: '`ListView`, `GridView`, and `TableView` inherit from the `Flickable` QML type.
    `PathView` inherits `Item`. The `TreeView` QML type is obsolete. Let''s have a
    look at the inheritance of these QML types:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView`、`GridView`和`TableView`继承自`Flickable` QML类型。`PathView`继承自`Item`。`TreeView`
    QML类型已经过时。让我们看一下这些QML类型的继承关系：'
- en: '![Figure 7.12 – The hierarchy of View classes in Qt Quick'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.12 - Qt Quick中视图类的层次结构'
- en: '](img/Figure_7.12_B16231.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.12_B16231.jpg)'
- en: Figure 7.12 – The hierarchy of View classes in Qt Quick
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12 - Qt Quick中视图类的层次结构
- en: The properties and behaviors are different for each QML type. They are used
    based on the GUI requirement. If you would like to know more about QML types,
    you can refer to their respective documentation. Let's explore Models in Qt Quick
    in the next section.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 每种QML类型的属性和行为都不同。它们根据GUI需求使用。如果您想了解更多关于QML类型的信息，可以参考它们各自的文档。让我们在下一节中探索Qt Quick中的模型。
- en: Models in Qt Quick
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Qt Quick中的模型
- en: Qt provides several convenience QML types to implement the M/V pattern. The
    modules provide very simple Models without requiring the creation of custom Model
    classes in C++. Examples of such convenience classes are `ListModel`, `TableModel`,
    and `XmlListModel`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Qt提供了几种方便的QML类型来实现M/V模式。这些模块提供了非常简单的模型，而无需在C++中创建自定义模型类。这些方便类的示例包括`ListModel`、`TableModel`和`XmlListModel`。
- en: 'The `QtQml.Models` module provides the following QML types for defining data
    Models:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`QtQml.Models` 模块提供以下用于定义数据模型的 QML 类型：'
- en: '`ListModel` defines a free-form list data source.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListModel` 定义了一个自由形式的列表数据源。'
- en: '`ListElement` defines a data item in a `ListModel`.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListElement` 定义了 `ListModel` 中的数据项。'
- en: '`DelegateModel` encapsulates a Model and delegate.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DelegateModel` 封装了一个模型和委托。'
- en: '`DelegateModelGroup` encapsulates a filtered set of visual data items.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DelegateModelGroup` 封装了一组经过筛选的可视数据项目。'
- en: '`ItemSelectionModel` inherits `QItemSelectionModel` and it keeps track of a
    View''s selected items.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ItemSelectionModel` 继承自 `QItemSelectionModel`，它跟踪视图的选定项目。'
- en: '`ObjectModel` defines a set of items to be used as a Model.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ObjectModel` 定义了一组要用作模型的项目。'
- en: '`Instantiator` dynamically instantiates objects.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Instantiator` 动态实例化对象。'
- en: '`Package` describes a collection of named items.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Package` 描述了一组命名的项目。'
- en: 'To use the aforementioned QML types in your Qt Quick application, import the
    module with the following line:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的 Qt Quick 应用程序中使用上述 QML 类型，请使用以下行导入模块：
- en: '`import QtQml.Models`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`import QtQml.Models`'
- en: 'Let''s discuss the readymade Models available in Qt Quick. `ListModel` is a
    simple container of `ListElement` definitions that contain data roles. It is used
    with `ListView`. `Qt.labs.qmlmodels` provides experimental QML types for models.
    These Models can be used for quick prototyping and displaying very simple data.
    The `TableModel` type stores JavaScript/JSON objects as data for a table Model
    and uses it with `TableView`. You can use these experimental types by importing
    the module as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论在 Qt Quick 中可用的现成模型。`ListModel` 是包含包含数据角色的 `ListElement` 定义的简单容器。它与 `ListView`
    一起使用。`Qt.labs.qmlmodels` 提供了用于模型的实验性 QML 类型。这些模型可用于快速原型设计和显示非常简单的数据。`TableModel`
    类型将 JavaScript/JSON 对象作为表模型的数据进行存储，并与 `TableView` 一起使用。您可以通过以下方式导入这些实验性类型：
- en: '`import Qt.labs.qmlmodels`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`import Qt.labs.qmlmodels`'
- en: 'If you want to create a Model from XML data, then you can use `XmlListModel`.
    It can be used as a Model with Views such as `ListView`, `PathView`, and `GridView`.
    To use this Model, you have to import the module as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想从 XML 数据创建模型，那么可以使用 `XmlListModel`。它可以与 `ListView`、`PathView` 和 `GridView`
    等视图一起使用作为模型。要使用此模型，您必须按照以下方式导入模块：
- en: '`import QtQuick.XmlListModel`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`import QtQuick.XmlListModel`'
- en: You can use `ListModel` and `XmlListModel` with `TableView` to create one column
    in `TableView`. To handle multiple rows and columns, you can use `TableModel`
    or you can create a custom C++ Model by subclassing `QAbstractItemModel`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `ListModel` 和 `XmlListModel` 与 `TableView` 一起创建 `TableView` 中的一列。要处理多行和多列，您可以使用
    `TableModel` 或者通过子类化 `QAbstractItemModel` 创建自定义的 C++ 模型。
- en: 'You can also use `Repeater` with Models. An integer can be used as a Model
    that defines the number of items. In that case, the Model does not have any data
    roles. Let''s create a simple example that uses `ListView` and a `Text` item as
    delegate components:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `Repeater` 与 Models。整数可以用作定义项目数量的模型。在这种情况下，模型没有任何数据角色。让我们创建一个简单的示例，使用
    `ListView` 和 `Text` 项目作为委托组件：
- en: '[PRE5]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding example, we have used an `Text` as a delegate without using
    a component.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了 `Text` 作为委托，而没有使用组件。
- en: Now, let's explore how to use `ListModel` with `ListView`. `ListModel` is a
    simple hierarchy of types specified in QML. The available roles are specified
    by the `ListElement` properties. Let's create a simple application using `ListModel`
    with `ListView`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探讨如何将 `ListModel` 与 `ListView` 一起使用。`ListModel` 是在 QML 中指定的一组简单的类型层次结构。可用的角色由
    `ListElement` 属性指定。让我们使用 `ListModel` 与 `ListView` 创建一个简单的应用程序。
- en: 'Let''s say you want to create a simple address book application. You may need
    a few fields for a contact. In the following code snippet, we have used a `ListModel`
    that contains the names, phone numbers, and email addresses of some contacts:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想创建一个简单的通讯录应用程序。您可能需要一些用于联系人的字段。在以下代码片段中，我们使用了一个包含一些联系人的姓名、电话号码和电子邮件地址的 `ListModel`：
- en: '[PRE6]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We have now created the Model. Next, we have to display it using a delegate.
    So, let''s modify the delegate component we created earlier with three `Text`
    elements. Based on your need you can create complex delegate types with icons,
    texts, or custom types. You can add a highlighted item and update the background
    based on focus. You need to provide a delegate to a View to visually represent
    an item in a list:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经创建了模型。接下来，我们必须使用委托来显示它。因此，让我们修改之前创建的委托组件，使用三个 `Text` 元素。根据您的需求，您可以创建具有图标、文本或自定义类型的复杂委托类型。您可以添加一个突出显示的项目，并根据焦点更新背景。您需要为视图提供一个委托，以在列表中直观地表示一个项目：
- en: '[PRE7]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding example, we used `ListElement` with `ListModel`. The View displays
    each item as per the template defined by the delegate. Items in a Model can be
    accessed through the `index` property or through the item's properties.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了 `ListElement` 与 `ListModel`。视图根据委托定义的模板显示每个项目。可以通过 `index` 属性或项目的属性访问模型中的项目。
- en: 'You can learn more about different types of Models and how to manipulate Model
    data at the following link:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接中了解有关不同类型的模型以及如何操作模型数据的更多信息：
- en: '[https://doc.qt.io/qt-6/qtquick-modelviewsdata-modelview.html](https://doc.qt.io/qt-6/qtquick-modelviewsdata-modelview.html)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://doc.qt.io/qt-6/qtquick-modelviewsdata-modelview.html](https://doc.qt.io/qt-6/qtquick-modelviewsdata-modelview.html)'
- en: In this section, you learned about M/V in QML. You can experiment with the custom
    Models and delegates and create a personalized View. Have a look at your phone
    book or recent call list on your cellphone and try to implement it. In the next
    section, you will learn how to integrate the QML frontend with a C++ Model.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您了解了 QML 中的 M/V。您可以尝试使用自定义模型和委托，并创建个性化的视图。看一看您手机上的电话簿或最近的通话列表，并尝试实现它。在下一节中，您将学习如何将
    QML 前端与 C++ 模型集成。
- en: Using C++ Models with QML
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 C++ 模型与 QML
- en: So far, we have discussed how to use Models and Views in Qt Widgets and QML.
    But in most modern applications, you will require Models written in C++ and a
    frontend written in QML. Qt allows us to define Models in C++ and then access
    them inside QML. This is convenient for exposing existing C++ data Models or otherwise
    complex datasets to QML. Native C++ is always the right choice for complex logical
    operations. It can outperform logic written in QML with JavaScript.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了如何在Qt Widgets和QML中使用模型和视图。但在大多数现代应用程序中，您将需要在C++中编写模型，并在QML中编写前端。Qt允许我们在C++中定义模型，然后在QML中访问它们。这对于将现有的C++数据模型或其他复杂数据集暴露给QML非常方便。对于复杂的逻辑操作，原生C++始终是正确的选择。它可以优于使用JavaScript编写的QML中的逻辑。
- en: There are many reasons why you should create a C++ Model. C++ is type-safe and
    compiled into object code. It increases the stability of your application and
    reduces the number of bugs. It is flexible and can offer more features than the
    QML types. You can integrate with your existing code or with a third-party library
    that is written in C++.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多原因您应该创建一个C++模型。C++是类型安全的，并且编译为对象代码。它增加了应用程序的稳定性并减少了错误的数量。它灵活，并且可以提供比QML类型更多的功能。您可以与现有代码或使用C++编写的第三方库集成。
- en: 'You can define a C++ Model using the following classes:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下类定义C++模型：
- en: '`QStringList`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QStringList`'
- en: '`QVariantList`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QVariantList`'
- en: '`QObjectList`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QObjectList`'
- en: '`QAbstractItemModel`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QAbstractItemModel`'
- en: The first three classes are beneficial for exposing simpler datasets. `QAbstractItemModel`
    offers a more flexible solution to create complex Models. `QStringList` contains
    a list of `QString` instances and provides the contents of the list via the `modelData`
    role. Similarly, `QVariantList` contains a list of `QVariant` types and provides
    the contents of the list via the `modelData` role. If a `QVariantList` changes,
    then you must reset the Model. `QObjectList` embeds a list of `QObject*` that
    provides the properties of the objects in the list as roles. The `QObject*` is
    accessible as the `modelData` property. For convenience, the properties of the
    object can be accessed directly in the delegate's context.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个类有助于暴露更简单的数据集。`QAbstractItemModel`提供了一个更灵活的解决方案来创建复杂的模型。`QStringList`包含`QString`实例的列表，并通过`modelData`角色提供列表的内容。类似地，`QVariantList`包含`QVariant`类型的列表，并通过`modelData`角色提供列表的内容。如果`QVariantList`发生变化，则必须重置模型。`QObjectList`嵌入了一个`QObject*`列表，该列表提供了列表中对象的属性作为角色。`QObject*`可以作为`modelData`属性访问。为了方便起见，可以直接在委托的上下文中访问对象的属性。
- en: Qt also provides C++ classes to handle SQL data Model such as `QSqlQueryModel`,
    `QSqlTableModel`, and `QSqlRelationalTableModel`. `QSqlQueryModel` offers a read-only
    Model based on an SQL query. These classes reduce the need to run SQL queries
    for basic SQL operations such as insert, create, or update. These classes are
    derived from `QAbstractTableModel` and make it easy to present data from a database
    in a View class.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Qt还提供了处理SQL数据模型的C++类，例如`QSqlQueryModel`、`QSqlTableModel`和`QSqlRelationalTableModel`。`QSqlQueryModel`提供了基于SQL查询的只读模型。这些类减少了运行SQL查询以进行基本的SQL操作（如插入、创建或更新）的需要。这些类是从`QAbstractTableModel`派生的，使得在View类中轻松呈现来自数据库的数据变得容易。
- en: 'You can learn more about different types of C++ Models by visiting the following
    link:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问以下链接了解有关不同类型的C++模型的更多信息：
- en: '[https://doc.qt.io/qt-6/qtquick-modelviewsdata-cppmodels.html](https://doc.qt.io/qt-6/qtquick-modelviewsdata-cppmodels.html)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://doc.qt.io/qt-6/qtquick-modelviewsdata-cppmodels.html](https://doc.qt.io/qt-6/qtquick-modelviewsdata-cppmodels.html)'
- en: In this section, we discussed C++ Models and why to use them. Now, you can fetch
    data from a C++ backend and present it in a UI developed in QML. In the next section,
    we will create a simple Qt Quick application using the aforementioned concept
    and explain how to use them inside QML.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了C++模型以及为什么要使用它们。现在，您可以从C++后端获取数据，并在QML中开发的UI中呈现它。在下一节中，我们将使用上述概念创建一个简单的Qt
    Quick应用程序，并解释如何在QML中使用它们。
- en: Creating a simple M/V application with Qt Quick
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Qt Quick创建一个简单的M/V应用程序
- en: In earlier sections, we discussed Qt's Model-View-Delegate framework. You learned
    how to create a custom Model and delegate and how to use a C++ Model. But you
    must be wondering how to integrate with our QML frontend. In this section, we
    will create a C++ Model and expose it to the QML engine. We will also discuss
    how to register a custom Model as a QML type.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们讨论了Qt的模型-视图-委托框架。您学会了如何创建自定义模型和委托，以及如何使用C++模型。但您一定想知道如何与我们的QML前端集成。在本节中，我们将创建一个C++模型并将其暴露给QML引擎。我们还将讨论如何将自定义模型注册为QML类型。
- en: 'Let''s create an application that fetches a Model from the C++ code and displays
    it in a Qt Quick-based application:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个应用程序，从C++代码中获取模型并在基于Qt Quick的应用程序中显示它：
- en: '[PRE8]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code snippet, we have created a simple Model based on `QStringList`.
    The string list contains four different strings. We have exposed the Model to
    the QML engine using `setContextProperty()`. Now, let''s use the Model inside
    our QML file:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们创建了一个基于`QStringList`的简单模型。字符串列表包含四个不同的字符串。我们使用`setContextProperty()`将模型暴露给QML引擎。现在，让我们在QML文件中使用该模型：
- en: '[PRE9]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding example uses `QQmlContext::setContextProperty()` to set Model
    values directly in a QML component. An alternative to this is to register the
    C++ Model class as a QML type as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例使用`QQmlContext::setContextProperty()`在QML组件中直接设置模型值。另一种方法是将C++模型类注册为QML类型，如下所示：
- en: '`qmlRegisterType<MyModel>("MyModel",1,0,"MyModel");`'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`qmlRegisterType<MyModel>("MyModel",1,0,"MyModel");`'
- en: 'The preceding line will allow the Model classes to be created directly as QML
    types within QML files. The first field is the C++ class name, then comes the
    desired package name, then the version number, and the last parameter is the type
    name in QML. You can import it into your QML file with the following line:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 上述行将允许直接在QML文件中将模型类创建为QML类型。第一个字段是C++类名，然后是所需的包名称，然后是版本号，最后一个参数是QML中的类型名称。您可以使用以下行将其导入到QML文件中：
- en: '`Import MyModel 1.0`'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`Import MyModel 1.0`'
- en: 'Let''s create an instance of `MyModel` inside our QML file as shown here:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的QML文件中创建一个`MyModel`的实例，如下所示：
- en: '[PRE10]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can also use Models with `QQuickView` using `setInitialProperties()` as
    shown in the following code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`setInitialProperties()`在`QQuickView`中使用模型，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code snippet, we used `QQuickView` to create a UI and passed
    a custom C++ Model to the QML environment.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用了`QQuickView`来创建一个UI，并将自定义的C++模型传递给了QML环境。
- en: In this section, we learned how to integrate a simple C++ Model with QML. You
    can add signals and properties to extend the functionalities of your custom classes.
    Next, let's summarize our learnings in this chapter.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何将简单的C++模型与QML集成。您可以添加信号和属性来扩展自定义类的功能。接下来，让我们总结一下本章的学习成果。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took a look at the core concepts of the Model-View-Delegate
    pattern in Qt. We explained how it is different from the traditional MVC pattern.
    We discussed different ways of using M/V and the convenience classes available
    in Qt. We learned how to apply the M/V concept in Qt Widgets as well as in Qt
    Quick. We discussed how to integrate a C++ Model with QML Views. We also created
    a few examples and implemented the concepts in our Qt application. You can now
    create your own Model, delegate, and Views. I hope you have understood the importance
    of the framework and the solid reasons for using it to meet your requirements.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入了解了Qt中的Model-View-Delegate模式的核心概念。我们解释了它与传统MVC模式的不同之处。我们讨论了在Qt中使用M/V的不同方式以及Qt中提供的便利类。我们学习了如何在Qt
    Widgets和Qt Quick中应用M/V概念。我们讨论了如何将C++模型集成到QML视图中。我们还创建了一些示例，并在我们的Qt应用程序中实现了这些概念。您现在可以创建自己的模型、委托和视图。我希望您已经理解了这个框架的重要性，以及使用它满足您需求的充分理由。
- en: In [*Chapter 8*](B16231_08_Final_ASB_ePub.xhtml#_idTextAnchor176), *Graphics
    and Animations*, we will learn about the graphics framework and how to add animations
    to your Qt Quick project.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第8章*](B16231_08_Final_ASB_ePub.xhtml#_idTextAnchor176)，*图形和动画*中，我们将学习关于图形框架以及如何将动画添加到您的Qt
    Quick项目。
