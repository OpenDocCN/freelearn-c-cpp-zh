["```cpp\n        auto i = 42;          // int \n        auto d = 42.5;        // double \n        auto s = \"text\";      // char const * \n        auto v = { 1, 2, 3 }; // std::initializer_list<int> \n```", "```cpp\n        auto b  = new char[10]{ 0 };            // char* \n        auto s1 = std::string {\"text\"};         // std::string\n        auto v1 = std::vector<int> { 1, 2, 3 }; // std::vector<int>\n        auto p  = std::make_shared<int>(42);    // std::shared_ptr<int>\n```", "```cpp\n        auto upper = [](char const c) {return toupper(c); };\n```", "```cpp\n        auto add = [](auto const a, auto const b) {return a + b;};\n```", "```cpp\n        template <typename F, typename T> \n        auto apply(F&& f, T value) \n        { \n          return f(value); \n        }\n```", "```cpp\n        auto v = std::vector<int>{ 1, 2, 3 }; \n        int size1 = v.size();       \n        // implicit conversion, possible loss of data \n        auto size2 = v.size(); \n        auto size3 = int{ v.size() };  // ill-formed (warning in gcc/clang, error in VC++)\n```", "```cpp\n        std::map<int, std::string> m; \n        for (std::map<int,std::string>::const_iterator it = m.cbegin();\n          it != m.cend(); ++it) \n        { /*...*/ } \n\n        for (auto it = m.cbegin(); it != m.cend(); ++it)\n        { /*...*/ }\n```", "```cpp\n        class foo { \n          int x_; \n        public: \n          foo(int const x = 0) :x_{ x } {} \n          int& get() { return x_; } \n        }; \n\n        foo f(42); \n        auto x = f.get(); \n        x = 100; \n        std::cout << f.get() << std::endl; // prints 42\n```", "```cpp\n        auto ai = std::atomic<int>(42); // error\n```", "```cpp\n        auto l1 = long long{ 42 }; // error \n        auto l2 = llong{ 42 };     // OK \n        auto l3 = 42LL;            // OK\n```", "```cpp\n    // C++11 \n    auto func1(int const i) -> int \n    { return 2*i; } \n\n    // C++14 \n    auto func2(int const i) \n    { return 2*i; }\n```", "```cpp\n    class foo \n    { \n      int x_; \n    public: \n      foo(int const x = 0) :x_{ x } {} \n      int& get() { return x_; } \n    }; \n\n    auto proxy_get(foo& f) { return f.get(); } \n\n    auto f = foo{ 42 }; \n    auto& x = proxy_get(f); // cannot convert from 'int' to 'int &'\n```", "```cpp\n    decltype(auto) proxy_get(foo& f) { return f.get(); } \n    auto f = foo{ 42 }; \n    decltype(auto) x = proxy_get(f);\n```", "```cpp\n    auto ladd = [] (auto const a, auto const b) { return a + b; }; \n    struct \n    { \n       template<typename T, typename U> \n       auto operator () (T const a, U const b) const { return a+b; } \n    } L;\n```", "```cpp\n    auto i = ladd(40, 2);            // 42 \n    auto s = ladd(\"forty\"s, \"two\"s); // \"fortytwo\"s\n```", "```cpp\n        using byte    = unsigned char; \n        using pbyte   = unsigned char *; \n        using array_t = int[10]; \n        using fn      = void(byte, double); \n\n        void func(byte b, double d) { /*...*/ } \n\n        byte b {42}; \n        pbyte pb = new byte[10] {0}; \n        array_t a{0,1,2,3,4,5,6,7,8,9}; \n        fn* f = func;\n```", "```cpp\n        template <class T> \n        class custom_allocator { /* ... */}; \n\n        template <typename T> \n        using vec_t = std::vector<T, custom_allocator<T>>; \n\n        vec_t<int>           vi; \n        vec_t<std::string>   vs; \n```", "```cpp\n    typedef unsigned char   byte; \n    typedef unsigned char * pbyte; \n    typedef int             array_t[10]; \n    typedef void(*fn)(byte, double); \n\n    template<typename T> \n    class foo { \n      typedef T value_type; \n    }; \n\n    typedef std::vector<int> vint_t;\n```", "```cpp\n    std::string s1(\"test\");   // direct initialization \n    std::string s2 = \"test\";  // copy initialization\n```", "```cpp\n    T object {other};   // direct list initialization \n    T object = {other}; // copy list initialization\n```", "```cpp\n        std::vector<int> v { 1, 2, 3 };\n        std::map<int, std::string> m { {1, \"one\"}, { 2, \"two\" }};\n```", "```cpp\n        int* arr2 = new int[3]{ 1, 2, 3 };    \n```", "```cpp\n        int arr1[3] { 1, 2, 3 }; \n```", "```cpp\n        int i { 42 };\n        double d { 1.2 };    \n```", "```cpp\n        class foo\n        {\n          int a_;\n          double b_;\n        public:\n          foo():a_(0), b_(0) {}\n          foo(int a, double b = 0.0):a_(a), b_(b) {}\n        }; \n\n        foo f1{}; \n        foo f2{ 42, 1.2 }; \n        foo f3{ 42 };\n```", "```cpp\n        struct bar { int a_; double b_;};\n        bar b{ 42, 1.2 };\n```", "```cpp\n        int a = 42; \n        double b = 1.2;\n```", "```cpp\n        class foo \n        { \n          int a_; \n        public: \n          foo(int a):a_(a) {} \n        }; \n        foo f1 = 42;\n```", "```cpp\n        foo f1;           // default initialization \n        foo f2(42, 1.2); \n        foo f3(42); \n        foo f4();         // function declaration\n```", "```cpp\n        bar b = {42, 1.2}; \n        int a[] = {1, 2, 3, 4, 5};\n```", "```cpp\n    class foo \n    { \n      int a_; \n      int b_; \n    public: \n      foo() :a_(0), b_(0) {} \n\n      foo(int a, int b = 0) :a_(a), b_(b) {} \n      foo(std::initializer_list<int> l) {} \n    }; \n\n    foo f{ 1, 2 }; // calls constructor with initializer_list<int>\n```", "```cpp\n    void func(int const a, int const b, int const c) \n    { \n      std::cout << a << b << c << std::endl; \n    } \n\n    void func(std::initializer_list<int> const l) \n    { \n      for (auto const & e : l) \n        std::cout << e << std::endl; \n    } \n\n    func({ 1,2,3 }); // calls second overload\n```", "```cpp\n    std::vector<int> v {5};\n```", "```cpp\n    std::vector<int> v (5);\n```", "```cpp\n    int i{ 1.2 };           // error \n\n    double d = 47 / 13; \n    float f1{ d };          // error \n    float f2{47/13};        // OK\n```", "```cpp\n    int i{ static_cast<int>(1.2) }; \n\n    double d = 47 / 13; \n    float f1{ static_cast<float>(d) };\n```", "```cpp\nauto a = {42};   // std::initializer_list<int>\nauto b {42};     // std::initializer_list<int>\nauto c = {4, 2}; // std::initializer_list<int>\nauto d {4, 2};   // std::initializer_list<int>\n```", "```cpp\nauto a = {42};   // std::initializer_list<int>\nauto b {42};     // int\nauto c = {4, 2}; // std::initializer_list<int>\nauto d {4, 2};   // error, too many\n```", "```cpp\n    struct Control \n    { \n      const int DefaultHeigh = 14;                  // [1] \n      const int DefaultWidth = 80;                  // [2] \n\n      TextVAligment valign = TextVAligment::Middle; // [3] \n      TextHAligment halign = TextHAligment::Left;   // [4] \n\n      std::string text; \n\n      Control(std::string const & t) : text(t)       // [5] \n      {} \n\n      Control(std::string const & t, \n        TextVerticalAligment const va, \n        TextHorizontalAligment const ha):  \n      text(t), valign(va), halign(ha)                 // [6] \n      {} \n    };\n```", "```cpp\n    struct Point \n    { \n      double X, Y; \n      Point(double const x = 0.0, double const y = 0.0) : X(x), Y(y)  {} \n    };\n```", "```cpp\n    struct foo \n    { \n      foo()  \n      { std::cout << \"default constructor\" << std::endl; } \n      foo(std::string const & text)  \n      { std::cout << \"constructor '\" << text << \"'\" << std::endl; } \n      foo(foo const & other)\n      { std::cout << \"copy constructor\" << std::endl; } \n      foo(foo&& other)  \n      { std::cout << \"move constructor\" << std::endl; }; \n      foo& operator=(foo const & other)  \n      { std::cout << \"assignment\" << std::endl; return *this; } \n      foo& operator=(foo&& other)  \n      { std::cout << \"move assignment\" << std::endl; return *this;} \n      ~foo()  \n      { std::cout << \"destructor\" << std::endl; } \n    }; \n\n    struct bar \n    { \n      foo f; \n\n      bar(foo const & value) \n      { \n        f = value; \n      } \n    }; \n\n    foo f; \n    bar b(f);\n```", "```cpp\ndefault constructor \ndefault constructor \nassignment \ndestructor \ndestructor\n```", "```cpp\n    bar(foo const & value) : f(value) { }\n```", "```cpp\ndefault constructor \ncopy constructor \ndestructor \ndestructor\n```", "```cpp\n    enum class TextFlow { LeftToRight, RightToLeft }; \n\n    struct Control \n    { \n      const int DefaultHeight = 20; \n      const int DefaultWidth = 100; \n\n      TextFlow textFlow = TextFlow::LeftToRight; \n      std::string text; \n\n      Control(std::string t) : text(t) \n      {} \n    };\n```", "```cpp\n    struct bar \n    { \n      foo f{\"default value\"}; \n\n      bar() : f{\"constructor initializer\"} \n      { \n      } \n    }; \n\n    bar b;\n```", "```cpp\nconstructor\nconstructor initializer\ndestructor\n```", "```cpp\n        struct alignas(4) foo \n        { \n          char a; \n          char b; \n        }; \n        struct bar \n        { \n          alignas(2) char a; \n          alignas(8) int  b; \n        }; \n        alignas(8)   int a; \n        alignas(256) long b[4];\n```", "```cpp\n        auto align = alignof(foo);\n```", "```cpp\n    struct foo1    // size = 1, alignment = 1 \n    { \n      char a; \n    }; \n\n    struct foo2    // size = 2, alignment = 1 \n    { \n      char a; \n      char b; \n    }; \n\n    struct foo3    // size = 8, alignment = 4 \n    { \n      char a; \n      int  b; \n    };\n```", "```cpp\n    struct foo3_ \n    { \n      char a;        // 1 byte \n      char _pad0[3]; // 3 bytes padding to put b on a 4-byte boundary \n      int  b;        // 4 bytes \n    };\n```", "```cpp\n    struct foo4 \n    { \n      int a; \n      char b; \n      float c; \n      double d; \n      bool e; \n    };\n```", "```cpp\n    struct foo4_ \n    { \n      int a;         // 4 bytes \n      char b;        // 1 byte \n      char _pad0[3]; // 3 bytes padding to put c on a 8-byte boundary  \n      float c;       // 4 bytes \n      char _pad1[4]; // 4 bytes padding to put d on a 8-byte boundary \n      double d;      // 8 bytes \n      bool e;        // 1 byte \n      char _pad2[7]; // 7 bytes padding to make sizeof struct multiple of 8 \n    };\n```", "```cpp\n    struct alignas(4) foo \n    { \n      char a; \n      char b; \n    };\n```", "```cpp\n    struct foo \n    { \n      char a; \n      char b; \n      char _pad0[2]; \n    };\n```", "```cpp\n    struct alignas(4) foo \n    { \n      alignas(2) char a; \n      alignas(8) int  b; \n    };\n```", "```cpp\n    struct foo \n    { \n      char a; \n      char _pad0[7]; \n      int b; \n      char _pad1[4]; \n    };\n```", "```cpp\n    alignas(8)   int a;   \n    alignas(256) long b[4]; \n\n    printf(\"%pn\", &a); // eg. 0000006C0D9EF908 \n    printf(\"%pn\", &b); // eg. 0000006C0D9EFA00\n```", "```cpp\n        enum class Status { Unknown, Created, Connected };\n        Status s = Status::Created;\n```", "```cpp\n        enum Status {Unknown, Created, Connected};\n        enum Codes {OK, Failure, Unknown};   // error \n        auto status = Status::Created;       // error\n```", "```cpp\n        enum Codes { OK, Failure }; \n        void include_offset(int pixels) {/*...*/} \n        include_offset(Failure);\n```", "```cpp\n        enum class Status { Unknown, Created, Connected }; \n        enum class Codes { OK, Failure, Unknown }; // OK \n        Codes code = Codes::Unknown;               // OK\n```", "```cpp\n        enum class Codes : unsigned int; \n\n        void print_code(Codes const code) {} \n\n        enum class Codes : unsigned int \n        {  \n           OK = 0,  \n           Failure = 1,  \n           Unknown = 0xFFFF0000U \n        };\n```", "```cpp\n        Codes c1 = Codes::OK;                       // OK \n        int c2 = Codes::Failure;                    // error \n        int c3 = static_cast<int>(Codes::Failure);  // OK\n```", "```cpp\n        class Base \n        { \n          virtual void foo() = 0;\n          virtual void bar() {} \n          virtual void foobar() = 0; \n        };\n\n        void Base::foobar() {}\n\n        class Derived1 : public Base \n        { \n          virtual void foo() override = 0;\n          virtual void bar() override {}\n          virtual void foobar() override {} \n        }; \n\n        class Derived2 : public Derived1 \n        { \n          virtual void foo() override {} \n        };\n```", "```cpp\n        class Derived2 : public Derived1 \n        { \n          virtual void foo() final {} \n        };\n```", "```cpp\n        class Derived4 final : public Derived1 \n        { \n          virtual void foo() override {} \n        };\n```", "```cpp\n    class Base \n    { \n    public: \n      virtual void foo() {}\n      virtual void bar() {}\n    }; \n\n    class Derived1 : public Base \n    { \n    public:    \n      void foo() override {}\n      // for readability use the virtual keyword    \n\n      virtual void bar(char const c) override {}\n      // error, no Base::bar(char const) \n    };\n```", "```cpp\n    class Derived2 : public Derived1 \n    { \n      virtual void foo() final {} \n    }; \n\n    class Derived3 : public Derived2 \n    { \n      virtual void foo() override {} // error \n    };\n```", "```cpp\n    class Derived4 final : public Derived1 \n    { \n      virtual void foo() override {} \n    };\n\n    class Derived5 : public Derived4 // error \n    { \n    };\n```", "```cpp\n    class foo \n    { \n      int final = 0; \n      void override() {} \n    };\n```", "```cpp\n    for ( range_declaration : range_expression ) loop_statement\n```", "```cpp\n    std::vector<int> getRates() \n    { \n      return std::vector<int> {1, 1, 2, 3, 5, 8, 13}; \n    } \n\n    std::multimap<int, bool> getRates2() \n    { \n      return std::multimap<int, bool> { \n        { 1, true }, \n        { 1, true }, \n        { 2, false }, \n        { 3, true }, \n        { 5, true }, \n        { 8, false }, \n        { 13, true } \n      }; \n    }\n```", "```cpp\n        auto rates = getRates();\n        for (int rate : rates) \n          std::cout << rate << std::endl; \n        for (int& rate : rates) \n          rate *= 2;\n```", "```cpp\n        for (auto&& rate : getRates()) \n          std::cout << rate << std::endl; \n\n        for (auto & rate : rates) \n          rate *= 2; \n\n        for (auto const & rate : rates) \n          std::cout << rate << std::endl;\n```", "```cpp\n        for (auto&& [rate, flag] : getRates2()) \n          std::cout << rate << std::endl;\n```", "```cpp\n    { \n      auto && __range = range_expression; \n      for (auto __begin = begin_expr, __end = end_expr; \n      __begin != __end; ++__begin) { \n        range_declaration = *__begin; \n        loop_statement \n      } \n    }\n```", "```cpp\n    { \n      auto && __range = range_expression; \n      auto __begin = begin_expr; \n      auto __end = end_expr; \n      for (; __begin != __end; ++__begin) { \n        range_declaration = *__begin; \n        loop_statement \n      } \n    }\n```", "```cpp\n    template <typename T, size_t const Size> \n    class dummy_array \n    { \n      T data[Size] = {}; \n\n    public: \n      T const & GetAt(size_t const index) const \n      { \n        if (index < Size) return data[index]; \n        throw std::out_of_range(\"index out of range\"); \n      } \n\n      void SetAt(size_t const index, T const & value) \n      { \n        if (index < Size) data[index] = value; \n        else throw std::out_of_range(\"index out of range\"); \n      } \n\n      size_t GetSize() const { return Size; } \n    };\n```", "```cpp\n    dummy_array<int, 3> arr; \n    arr.SetAt(0, 1); \n    arr.SetAt(1, 2); \n    arr.SetAt(2, 3); \n\n    for(auto&& e : arr) \n    {  \n      std::cout << e << std::endl; \n    }\n```", "```cpp\n        template <typename T, typename C, size_t const Size> \n        class dummy_array_iterator_type \n        { \n        public: \n          dummy_array_iterator_type(C& collection,  \n                                    size_t const index) : \n          index(index), collection(collection) \n          { } \n\n        bool operator!= (dummy_array_iterator_type const & other) const \n        { \n          return index != other.index; \n        } \n\n        T const & operator* () const \n        { \n          return collection.GetAt(index); \n        } \n\n        dummy_array_iterator_type const & operator++ () \n        { \n          ++index; \n          return *this; \n        } \n\n        private: \n          size_t   index; \n          C&       collection; \n        };\n```", "```cpp\n        template <typename T, size_t const Size> \n        using dummy_array_iterator =  \n           dummy_array_iterator_type< \n             T, dummy_array<T, Size>, Size>; \n\n        template <typename T, size_t const Size> \n        using dummy_array_const_iterator =  \n           dummy_array_iterator_type< \n             T, dummy_array<T, Size> const, Size>;\n```", "```cpp\n        template <typename T, size_t const Size> \n        inline dummy_array_iterator<T, Size> begin(\n          dummy_array<T, Size>& collection) \n        { \n          return dummy_array_iterator<T, Size>(collection, 0); \n        } \n\n        template <typename T, size_t const Size> \n        inline dummy_array_iterator<T, Size> end(\n          dummy_array<T, Size>& collection) \n        { \n          return dummy_array_iterator<T, Size>(\n            collection, collection.GetSize()); \n        } \n\n        template <typename T, size_t const Size> \n        inline dummy_array_const_iterator<T, Size> begin( \n          dummy_array<T, Size> const & collection) \n        { \n          return dummy_array_const_iterator<T, Size>( \n            collection, 0); \n        } \n\n        template <typename T, size_t const Size> \n        inline dummy_array_const_iterator<T, Size> end( \n          dummy_array<T, Size> const & collection) \n        { \n          return dummy_array_const_iterator<T, Size>( \n            collection, collection.GetSize()); \n        }\n```", "```cpp\n    template <typename T, const size_t Size> \n    void print_dummy_array(dummy_array<T, Size> const & arr) \n    { \n      for (auto && e : arr) \n      { \n        std::cout << e << std::endl; \n      } \n    }\n```", "```cpp\n    struct handle_t \n    { \n      explicit handle_t(int const h) : handle(h) {} \n\n      explicit operator bool() const { return handle != 0; }; \n    private: \n      int handle; \n    };\n```", "```cpp\n    struct foo \n    { \n      foo()\n      { std::cout << \"foo\" << std::endl; }\n      foo(int const a)\n      { std::cout << \"foo(a)\" << std::endl; }\n      foo(int const a, double const b)\n      { std::cout << \"foo(a, b)\" << std::endl; } \n\n      operator bool() const { return true; } \n    };\n```", "```cpp\n    foo f1;              // foo \n    foo f2 {};           // foo \n\n    foo f3(1);           // foo(a) \n    foo f4 = 1;          // foo(a) \n    foo f5 { 1 };        // foo(a) \n    foo f6 = { 1 };      // foo(a) \n\n    foo f7(1, 2.0);      // foo(a, b) \n    foo f8 { 1, 2.0 };   // foo(a, b) \n    foo f9 = { 1, 2.0 }; // foo(a, b)\n```", "```cpp\n    foo(std::initializer_list<int> l)  \n    { std::cout << \"foo(l)\" << std::endl; }\n```", "```cpp\n    void bar(foo const f) \n    { \n    } \n\n    bar({});             // foo() \n    bar(1);              // foo(a) \n    bar({ 1, 2.0 });     // foo(a, b)\n```", "```cpp\n    bool flag = f1; \n    if(f2) {} \n    std::cout << f3 + f4 << std::endl; \n    if(f5 == f6) {}\n```", "```cpp\n    class string_buffer \n    { \n    public: \n      string_buffer() {} \n\n      string_buffer(size_t const size) {} \n\n      string_buffer(char const * const ptr) {} \n\n      size_t size() const { return ...; } \n      operator bool() const { return ...; } \n      operator char * const () const { return ...; } \n    };\n```", "```cpp\n    std::shared_ptr<char> str; \n    string_buffer sb1;             // empty buffer \n    string_buffer sb2(20);         // buffer of 20 characters \n    string_buffer sb3(str.get());   \n    // buffer initialized from input parameter\n```", "```cpp\n    enum ItemSizes {DefaultHeight, Large, MaxSize}; \n\n    string_buffer b4 = 'a'; \n    string_buffer b5 = MaxSize;\n```", "```cpp\n    class string_buffer \n    { \n    public: \n      explicit string_buffer() {} \n\n      explicit string_buffer(size_t const size) {} \n\n      explicit string_buffer(char const * const ptr) {} \n\n      explicit operator bool() const { return ...; } \n      explicit operator char * const () const { return ...; } \n    };\n```", "```cpp\n    string_buffer b4 = string_buffer('a'); \n    string_buffer b5 = static_cast<string_buffer>(MaxSize); \n    string_buffer b6 = string_buffer{ \"a\" };\n```", "```cpp\n    string_buffer b7{ 'a' }; \n    string_buffer b8('a');\n```", "```cpp\n    std::cout << b1 + b2 << std::endl; \n    if(b1 == b2) {}\n```", "```cpp\n    std::cout << static_cast<bool>(b1) + static_cast<bool>(b2);\n    if(static_cast<bool>(b1) == static_cast<bool>(b2)) {}\n```", "```cpp\n    // file1.cpp \n    namespace \n    { \n      void print(std::string message) \n      { \n        std::cout << \"[file1] \" << message << std::endl; \n      } \n    } \n\n    void file1_run() \n    { \n      print(\"run\"); \n    } \n\n    // file2.cpp \n    namespace \n    { \n      void print(std::string message) \n      { \n        std::cout << \"[file2] \" << message << std::endl; \n      } \n    } \n\n    void file2_run() \n    { \n      print(\"run\"); \n    }\n```", "```cpp\n    // file1.cpp \n    namespace _unique_name_ {} \n    using namespace _unique_name_; \n    namespace _unique_name_ \n    { \n      void print(std::string message) \n      { \n        std::cout << \"[file1] \" << message << std::endl; \n      } \n    } \n\n    void file1_run() \n    { \n      print(\"run\"); \n    }\n```", "```cpp\n    template <int const& Size> \n    class test {}; \n\n    static int Size1 = 10; \n\n    namespace \n    { \n      int Size2 = 10; \n    } \n\n    test<Size1> t1; \n    test<Size2> t2;\n```", "```cpp\n    namespace modernlib \n    { \n      #ifndef LIB_VERSION_2 \n      inline namespace version_1 \n      { \n        template<typename T> \n        int test(T value) { return 1; } \n      } \n      #endif \n\n      #ifdef LIB_VERSION_2 \n      inline namespace version_2 \n      { \n        template<typename T> \n        int test(T value) { return 2; } \n      } \n      #endif \n    }\n```", "```cpp\n    namespace modernlib \n    { \n      template<typename T> \n      int test(T value) { return 1; } \n    }\n```", "```cpp\n    auto x = modernlib::test(42);\n```", "```cpp\n    struct foo { int a; }; \n\n    namespace modernlib \n    { \n      template<> \n      int test(foo value) { return value.a; } \n    } \n\n    auto y = modernlib::test(foo{ 42 });\n```", "```cpp\n    namespace modernlib \n    { \n      namespace version_1 \n      { \n        template<typename T> \n        int test(T value) { return 1; } \n      } \n\n      #ifndef LIB_VERSION_2 \n      using namespace version_1; \n      #endif \n\n      namespace version_2  \n      { \n        template<typename T> \n        int test(T value) { return 2; } \n      } \n\n      #ifdef LIB_VERSION_2 \n      using namespace version_2; \n      #endif \n    }\n```", "```cpp\n    #define LIB_VERSION_2 \n\n    #include \"modernlib.h\" \n\n    struct foo { int a; }; \n\n    namespace modernlib \n    { \n      namespace version_2  \n      { \n        template<> \n        int test(foo value) { return value.a; } \n      } \n    }\n```", "```cpp\n        std::tuple<int, std::string, double> find() \n        { \n          return std::make_tuple(1, \"marius\", 1234.5); \n        }\n```", "```cpp\n        auto [id, name, score] = find();\n```", "```cpp\n        if (auto [id, name, score] = find(); score > 1000) \n        { \n          std::cout << name << std::endl; \n        }\n```", "```cpp\n    std::map<int, std::string> m; \n\n    auto result = m.insert({ 1, \"one\" }); \n    std::cout << \"inserted = \" << result.second << std::endl \n              << \"value = \" << result.first->second << std::endl;\n```", "```cpp\n    std::map<int, std::string> m; \n    std::map<int, std::string>::iterator it; \n    bool inserted; \n\n    std::tie(it, inserted) = m.insert({ 1, \"one\" }); \n    std::cout << \"inserted = \" << inserted << std::endl \n              << \"value = \" << it->second << std::endl; \n\n    std::tie(it, inserted) = m.insert({ 1, \"two\" }); \n    std::cout << \"inserted = \" << inserted << std::endl \n              << \"value = \" << it->second << std::endl;\n```", "```cpp\n    std::map<int, std::string> m; \n    { \n      auto[it, inserted] = m.insert({ 1, \"one\" }); \n      std::cout << \"inserted = \" << inserted << std::endl \n                << \"value = \" << it->second << std::endl; \n    } \n\n    { \n      auto[it, inserted] = m.insert({ 1, \"two\" }); \n      std::cout << \"inserted = \" << inserted << std::endl \n                << \"value = \" << it->second << std::endl; \n    }\n```", "```cpp\n    if(auto [it, inserted] = m.insert({ 1, \"two\" }); inserted)\n    { std::cout << it->second << std::endl; }\n```"]