- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Learning Modern Core Language Features
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习现代核心语言特性
- en: 'The C++ language has gone through a major transformation in the past decades
    with the development and release of C++11 and then, later, with its newer versions:
    C++14, C++17, C++20, and C++23\. These new standards have introduced new concepts,
    simplified and extended existing syntax and semantics, and transformed the way
    we write code overall. C++11 looks and feels like a new language compared to what
    we previously knew, and code written using these new standards is called modern
    C++ code. This introductory chapter will touch on some of the language features
    introduced, starting with C++11, that help you with many coding routines. However,
    the core of the language expands way beyond the topics addressed in this chapter,
    and many other features are discussed in the other chapters of the book.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: C++语言在过去几十年中经历了重大变革，随着C++11的发布以及随后更新的版本：C++14、C++17、C++20和C++23，这些新标准引入了新的概念，简化并扩展了现有的语法和语义，并彻底改变了我们编写代码的方式。与之前所知相比，C++11看起来和感觉上像是一种全新的语言，使用这些新标准编写的代码被称为现代C++代码。本入门章节将涉及一些引入的语言特性，从C++11开始，这些特性有助于你处理许多编码常规。然而，语言的核心内容远远超出了本章所讨论的主题，书中其他章节还讨论了许多其他特性。
- en: 'The recipes included in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含的食谱如下：
- en: Using `auto` whenever possible
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能使用`auto`
- en: Creating type aliases and alias templates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建类型别名和别名模板
- en: Understanding uniform initialization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解统一初始化
- en: Understanding the various forms of non-static member initialization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解非静态成员初始化的各种形式
- en: Controlling and querying object alignment
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制和查询对象对齐
- en: Using scoped enumerations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用范围枚举
- en: Using `override` and `final` for virtual methods
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`override`和`final`关键字为虚方法
- en: Using range-based for loops to iterate on a range
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于范围的for循环遍历范围
- en: Enabling range-based for loops for custom types
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为自定义类型启用基于范围的for循环
- en: Using explicit constructors and conversion operators to avoid implicit conversion
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用显式构造函数和转换运算符来避免隐式转换
- en: Using unnamed namespaces instead of static globals
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用无名命名空间而不是静态全局变量
- en: Using inline namespaces for symbol versioning
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内联命名空间进行符号版本控制
- en: Using structured bindings to handle multi-return values
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用结构化绑定来处理多返回值
- en: Simplifying code with class template argument deduction
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类模板参数推导简化代码
- en: Using the subscript operator to access elements in a collection
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用下标运算符访问集合中的元素
- en: Let’s start by learning about automatic type deduction.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从学习自动类型推导开始。
- en: Using auto whenever possible
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尽可能使用`auto`
- en: Automatic type deduction is one of the most important and widely used features
    in modern C++. The new C++ standards have made it possible to use `auto` as a
    placeholder for types in various contexts, letting the compiler deduce the actual
    type. In C++11, `auto` can be used to declare local variables and for the return
    type of a function with a trailing return type. In C++14, `auto` can be used for
    the return type of a function without specifying a trailing type and for parameter
    declarations in lambda expressions. In C++17, it can be used to declare structured
    bindings, which are discussed at the end of the chapter. In C++20, it can be used
    to simplify function template syntax with so-called abbreviated function templates.
    In C++23, it can be used to perform an explicit cast to a prvalue copy. Future
    standard versions are likely to expand the use of `auto` to even more cases. The
    use of `auto` as introduced in C++11 and C++14 has several important benefits,
    all of which will be discussed in the *How it works...* section. Developers should
    be aware of them and aim to use `auto` whenever possible. An actual term was coined
    for this by Andrei Alexandrescu and promoted by Herb Sutter—**almost always auto**
    (**AAA**) ([https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/](https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/)).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 自动类型推导是现代 C++ 中最重要且最广泛使用的特性之一。新的 C++ 标准使得在多种上下文中使用 `auto` 作为类型的占位符成为可能，让编译器推导出实际类型。在
    C++11 中，`auto` 可以用来声明局部变量以及具有尾随返回类型的函数的返回类型。在 C++14 中，`auto` 可以用来声明没有指定尾随类型的函数返回类型以及
    lambda 表达式中的参数声明。在 C++17 中，它可以用来声明结构化绑定，这在章节末尾有讨论。在 C++20 中，它可以用来简化函数模板语法，所谓的缩写函数模板。在
    C++23 中，它可以用来执行对 prvalue 复制的显式转换。未来的标准版本可能会将 `auto` 的使用扩展到更多的情况。C++11 和 C++14
    中引入的 `auto` 的使用有几个重要的好处，所有这些都会在 *它是如何工作的...* 部分讨论。开发者应该意识到它们，并尽可能使用 `auto`。安德烈·亚历山德鲁斯库（Andrei
    Alexandrescu）提出了一个实际术语，并由 Herb Sutter 推广——**几乎总是 auto** （**AAA**） ([https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/](https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/))。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Consider using `auto` as a placeholder for the actual type in the following
    situations:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下考虑使用 `auto` 作为实际类型的占位符：
- en: 'To declare local variables with the form `auto name = expression` when you
    do not want to commit to a specific type:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `auto name = expression` 形式声明局部变量，当你不想承诺一个特定类型时：
- en: '[PRE0]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To declare local variables with the `auto name = type-id { expression }` form
    when you need to commit to a specific type:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `auto name = type-id { expression }` 形式声明局部变量，当你需要承诺一个特定类型时：
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To declare named lambda functions, with the form `auto name = lambda-expression`,
    unless the lambda needs to be passed or returned to a function:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `auto name = lambda-expression` 形式声明命名 lambda 函数，除非 lambda 需要传递或返回给函数：
- en: '[PRE2]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To declare lambda parameters and return values:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明 lambda 参数和返回值：
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To declare a function return type when you don’t want to commit to a specific
    type:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不想承诺一个特定类型时声明函数返回类型：
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `auto` specifier is basically a placeholder for an actual type. When using
    `auto`, the compiler deduces the actual type from the following instances:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`auto` 说明符基本上是一个实际类型的占位符。当使用 `auto` 时，编译器从以下实例推导出实际类型：'
- en: From the type of expression used to initialize a variable, when `auto` is used
    to declare variables.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从初始化变量的表达式类型，当使用 `auto` 声明变量时。
- en: From the trailing return type or the return expression type of a function, when
    `auto` is used as a placeholder for the return type of a function.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从函数的尾随返回类型或返回表达式类型，当 `auto` 用作函数返回类型的占位符时。
- en: In some cases, it is necessary to commit to a specific type. For instance, in
    the first example, the compiler deduces the type of `s` to be `char const *`.
    If the intention was to have a `std::string`, then the type must be specified
    explicitly. Similarly, the type of `v` was deduced as `std::initializer_list<int>`
    because it is bound to `auto` and not a specific type; in this case, the rules
    say the deduced type is `std::initializer_list<T>`, with `T` being `int` in our
    case. However, the intention could be to have a `std::vector<int>`. In such cases,
    the type must be specified explicitly on the right side of the assignment.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，有必要承诺一个特定的类型。例如，在第一个例子中，编译器推断出`s`的类型为`char const *`。如果意图是使用`std::string`，则必须显式指定类型。同样，`v`的类型被推断为`std::initializer_list<int>`，因为它绑定到`auto`而不是特定类型；在这种情况下，规则说明推断的类型是`std::initializer_list<T>`，其中`T`在我们的例子中是`int`。然而，意图可能是拥有一个`std::vector<int>`。在这种情况下，必须在赋值右侧显式指定类型。
- en: 'There are some important benefits of using the `auto` specifier instead of
    actual types; the following is a list of, perhaps, the most important ones:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`auto`指定符而不是实际类型有一些重要的好处；以下是一些可能最重要的好处：
- en: It is not possible to leave a variable uninitialized. This is a common mistake
    that developers make when declaring variables and specifying the actual type.
    However, this is not possible with `auto`, which requires an initialization of
    the variable in order to deduce the type. Initializing variables with a defined
    value is important because uninitialized variables incur undefined behavior.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法留下未初始化的变量。这是开发者在声明变量并指定实际类型时常见的错误。然而，使用`auto`是不可能的，因为它需要初始化变量以推断类型。使用定义的值初始化变量很重要，因为未初始化的变量会导致未定义的行为。
- en: 'Using `auto` ensures that you always use the intended type and that implicit
    conversion will not occur. Consider the following example where we retrieve the
    size of a vector for a local variable. In the first case, the type of the variable
    is `int`, although the `size()` method returns `size_t`. This means an implicit
    conversion from `size_t` to `int` will occur. However, using `auto` for the type
    will deduce the correct type—that is, `size_t`:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`auto`确保你始终使用预期的类型，并且不会发生隐式转换。考虑以下示例，其中我们检索局部变量的向量大小。在第一种情况下，变量的类型是`int`，尽管`size()`方法返回`size_t`。这意味着将从`size_t`到`int`发生隐式转换。然而，使用`auto`来推断类型将得出正确的类型——即`size_t`：
- en: '[PRE5]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using `auto` promotes good object-oriented practices, such as preferring interfaces
    over implementations. This is important in **object-oriented programming** (**OOP**)
    because it provides the flexibility to change between different implementations,
    modularity of the code, and better testability because it’s easy to mock objects.
    The fewer the number of types specified, the more generic the code is and more
    open to future changes, which is a fundamental principle of OOP.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`auto`可以促进良好的面向对象实践，例如优先选择接口而非实现。这在**面向对象编程**（**OOP**）中非常重要，因为它提供了在不同实现之间进行更改的灵活性，代码的模块化，以及更好的可测试性，因为模拟对象很容易。指定的类型数量越少，代码越通用，对未来变化的开放性也越大，这是面向对象编程的基本原则。
- en: 'It means less typing (in general) and less concern for actual types that we
    don’t care about anyway. It is very often the case that even though we explicitly
    specify the type, we don’t actually care about it. A very common case is with
    iterators, but there are many more. When you want to iterate over a range, you
    don’t care about the actual type of the iterator. You are only interested in the
    iterator itself; so using `auto` saves time spent typing (possibly long) names
    and helps you focus on actual code and not type names. In the following example,
    in the first `for` loop, we explicitly use the type of the iterator. It is a lot
    of text to type; the long statements can actually make the code less readable,
    and you also need to know the type name, which you actually don’t care about.
    The second loop with the `auto` specifier looks simpler and saves you from typing
    and caring about actual types:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它意味着（通常）更少的输入和更少的对实际类型（我们实际上并不关心的类型）的关注。我们经常遇到的情况是，即使我们明确指定了类型，我们实际上并不关心它。一个非常常见的例子是与迭代器相关，但还有更多。当你想要遍历一个范围时，你并不关心迭代器的实际类型。你只对迭代器本身感兴趣；因此使用
    `auto` 可以节省输入（可能很长的）名称的时间，并帮助你专注于实际的代码而不是类型名称。在下面的例子中，在第一个 `for` 循环中，我们明确使用了迭代器的类型。这需要输入很多文本；长语句实际上可能使代码更难以阅读，而且你还需要知道类型名称，而你实际上并不关心。带有
    `auto` 指示符的第二个循环看起来更简单，可以节省你输入和关注实际类型的时间：
- en: '[PRE6]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Declaring variables with `auto` provides a consistent coding style, with the
    type always on the right-hand side. If you allocate objects dynamically, you need
    to write the type both on the left and right side of the assignment, for example,
    `int* p = new int(42)`. With `auto`, the type is specified only once on the right
    side.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `auto` 声明变量提供了一种一致的编码风格，类型始终位于右侧。如果你动态分配对象，你需要在赋值语句的左右两侧都写上类型，例如，`int* p
    = new int(42)`。使用 `auto`，类型仅在右侧指定一次。
- en: 'However, there are some gotchas when using `auto`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在使用 `auto` 时也有一些需要注意的问题：
- en: 'The `auto` specifier is only a placeholder for the type, not for the `const`/`volatile`
    and reference specifiers. If you need a `const`/`volatile` and/or a reference
    type, then you need to specify them explicitly. In the following example, the
    `get()` member function of `foo` returns a reference to `int`; when the variable
    `x` is initialized from the return value, the type deduced by the compiler is
    `int`, not `int&`. Therefore, any change made to `x` will not propagate to `foo.x_`.
    In order to do so, we should use `auto&`:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auto` 指示符仅是类型的占位符，而不是 `const`/`volatile` 和引用指定符。如果你需要一个 `const`/`volatile`
    和/或引用类型，那么你需要明确指定它们。在下面的例子中，`foo` 的 `get()` 成员函数返回 `int` 的引用；当变量 `x` 从返回值初始化时，编译器推断出的类型是
    `int`，而不是 `int&`。因此，对 `x` 的任何更改都不会传播到 `foo.x_`。为了做到这一点，我们应该使用 `auto&`：'
- en: '[PRE7]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It is not possible to use `auto` for types that are not moveable:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于不可移动的类型，无法使用 `auto`。
- en: '[PRE8]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It is not possible to use `auto` for multi-word types, such as `long long`,
    `long double`, or `struct foo`. However, in the first case, the possible workarounds
    are to use literals or type aliases; also, with Clang and GCC (but not MSVC) it’s
    possible to put the type name in parentheses, `(long long){ 42 }`. As for the
    second case, using `struct`/`class` in that form is only supported in C++ for
    C compatibility and should be avoided anyway:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于多词类型，如 `long long`、`long double` 或 `struct foo`，无法使用 `auto`。然而，在第一种情况下，可能的解决方案是使用字面量或类型别名；此外，在
    Clang 和 GCC（但不是 MSVC）中，可以将类型名称放在括号中，例如 `(long long){ 42 }`。至于第二种情况，以那种形式使用 `struct`/`class`
    只在 C++ 中支持与 C 的兼容性，并且应该避免使用：
- en: '[PRE9]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you use the `auto` specifier but still need to know the type, you can do
    so in most IDEs by putting the cursor over a variable, for instance. If you leave
    the IDE, however, that is not possible anymore, and the only way to know the actual
    type is to deduce it yourself from the initialization expression, which could
    mean searching through the code for function return types.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用了 `auto` 指示符但仍然需要知道类型，你可以在大多数 IDE 中通过将光标放在变量上来实现，例如。然而，如果你离开 IDE，那就不再可能了，唯一知道实际类型的方法是自己从初始化表达式中推断出来，这可能意味着在代码中搜索函数返回类型。
- en: 'The `auto` can be used to specify the return type from a function. In C++11,
    this requires a trailing return type in the function declaration. In C++14, this
    has been relaxed, and the type of the return value is deduced by the compiler
    from the `return` expression. If there are multiple return values, they should
    have the same type:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`auto`可以用来指定函数的返回类型。在 C++11 中，这需要在函数声明中有一个尾随返回类型。在 C++14 中，这已经放宽，编译器会从`return`表达式推断返回值的类型。如果有多个返回值，它们应该具有相同的类型：'
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As mentioned earlier, `auto` does not retain `const`/`volatile` and reference
    qualifiers. This leads to problems with `auto` as a placeholder for the return
    type from a function. To explain this, let’s consider the preceding example with
    `foo.get()`. This time, we have a wrapper function called `proxy_get()` that takes
    a reference to a `foo`, calls `get()`, and returns the value returned by `get()`,
    which is an `int&`. However, the compiler will deduce the return type of `proxy_get()`
    as being `int`, not `int&`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`auto`不会保留`const`/`volatile`和引用限定符。这导致`auto`作为函数返回类型占位符时出现问题。为了解释这一点，让我们考虑前面的例子`foo.get()`。这次，我们有一个名为`proxy_get()`的包装函数，它接受一个`foo`的引用，调用`get()`，并返回`get()`返回的值，该值是一个`int&`。然而，编译器将推断`proxy_get()`的返回类型为`int`，而不是`int&`。
- en: 'Trying to assign that value to an `int&` fails with an error:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将那个值赋给一个`int&`会失败并报错：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To fix this, we need to actually return `auto&`. However, there is a problem
    with templates and perfect forwarding the return type without knowing whether
    it is a value or a reference. The solution to this problem in C++14 is `decltype(auto)`,
    which will correctly deduce the type:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要实际返回`auto&`。然而，模板和完美前向传递返回类型时不知道它是值还是引用存在一个问题。C++14 中解决这个问题的方法是`decltype(auto)`，它将正确推断类型：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `decltype` specifier is used to inspect the declared type of an entity or
    an expression. It’s mostly useful when declaring types is cumbersome or if they
    can’t be declared at all with the standard notation. Examples of this include
    declaring lambda types and types that depend on template parameters.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`decltype`说明符用于检查实体或表达式的声明类型。它主要用于在声明类型比较繁琐或根本无法使用标准符号声明时。这类例子包括声明 lambda 类型以及依赖于模板参数的类型。'
- en: 'The last important case where `auto` can be used is with lambdas. As of C++14,
    both lambda return types and lambda parameter types can be `auto`. Such a lambda
    is called a *generic lambda* because the closure type defined by the lambda has
    a templated call operator. The following shows a generic lambda that takes two
    `auto` parameters and returns the result of applying `operator+` to the actual
    types:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`auto`可以使用的最后一个重要情况是与 lambda 一起。截至 C++14，lambda 返回类型和 lambda 参数类型都可以是`auto`。这样的
    lambda 被称为*泛型 lambda*，因为 lambda 定义的闭包类型有一个模板调用操作符。以下是一个泛型 lambda 的示例，它接受两个`auto`参数，并返回将`operator+`应用于实际类型的操作结果：'
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The compiler-generated function object has the following form, where the call
    operator is a function template:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器生成的函数对象具有以下形式，其中调用操作符是一个函数模板：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This lambda can be used to add anything for which the `operator+` is defined,
    as shown in the following snippet:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 lambda 可以用于添加任何定义了`operator+`的操作数的值，如下面的代码片段所示：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example, we used the `ladd` lambda to add two integers and concatenate
    them to `std::string` objects (using the C++14 user-defined literal `operator
    ""s`).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`ladd` lambda 函数来添加两个整数并将它们连接到`std::string`对象（使用 C++14 的用户定义字面量`operator
    ""s`）。
- en: See also
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Creating type aliases and alias templates*, to learn about aliases for types'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建类型别名和别名模板*，了解类型别名的使用'
- en: '*Understanding uniform initialization*, to see how brace-initialization works'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*理解统一初始化*，了解花括号初始化是如何工作的'
- en: Creating type aliases and alias templates
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建类型别名和别名模板
- en: In C++, it is possible to create synonyms that can be used instead of a type
    name. This is achieved by creating a `typedef` declaration. This is useful in
    several cases, such as creating shorter or more meaningful names for a type or
    names for function pointers. However, `typedef` declarations cannot be used with
    templates to create template type aliases. An `std::vector<T>`, for instance,
    is not a type (`std::vector<int>` is a type), but a sort of family of all types
    that can be created when the type placeholder `T` is replaced with an actual type.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，可以创建同义词，这些同义词可以用来代替类型名称。这是通过创建typedef声明来实现的。这在几种情况下很有用，例如为类型创建更短或更有意义的名称，或者为函数指针创建名称。然而，typedef声明不能与模板一起使用来创建模板类型别名。例如，`std::vector<T>`不是一个类型（`std::vector<int>`是一个类型），而是一系列类型，当类型占位符`T`被实际类型替换时可以创建。
- en: In C++11, a type alias is a name for another already declared type, and an alias
    template is a name for another already declared template. Both of these types
    of aliases are introduced with a new `using` syntax.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11中，类型别名是已声明类型的名称，别名模板是已声明模板的名称。这两种类型的别名都是通过新的using语法引入的。
- en: How to do it...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Create type aliases with the form `using identifier = type-id`, as in the following
    examples:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建具有形式`using identifier = type-id`的类型别名，如下面的示例所示：
- en: '[PRE16]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create alias templates with the form `template<template-params-list> identifier
    = type-id`, as in the following examples:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建具有形式`template<template-params-list> identifier = type-id`的别名模板，如下面的示例所示：
- en: '[PRE17]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For consistency and readability, you should do the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持一致性和可读性，你应该做以下事情：
- en: Not mix `typedef` and `using` declarations when creating aliases
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建别名时不要混合使用typedef和using声明
- en: Prefer the `using` syntax to create names of function pointer types
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建函数指针类型的名称时，优先使用using语法
- en: How it works...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A `typedef` declaration introduces a synonym (an alias, in other words) for
    a type. It does not introduce another type (like a `class`, `struct`, `union`,
    or `enum` declaration). Type names introduced with a `typedef` declaration follow
    the same hiding rules as identifier names. They can also be redeclared, but only
    to refer to the same type (therefore, you can have valid multiple `typedef` declarations
    that introduce the same type name synonym in a translation unit, as long as it
    is a synonym for the same type). The following are typical examples of `typedef`
    declarations:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: typedef声明引入了一个类型的同义词（换句话说，别名）。它不会引入另一个类型（如`class`、`struct`、`union`或`enum`声明）。使用typedef声明引入的类型名称遵循与标识符名称相同的隐藏规则。它们也可以重新声明，但只能引用相同的类型（因此，你可以在翻译单元中拥有有效的多个typedef声明，引入相同的类型名称同义词，只要它是相同类型的同义词）。以下是一些典型的typedef声明示例：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A type alias declaration is equivalent to a `typedef` declaration. It can appear
    in a block scope, class scope, or namespace scope. According to C++11 standard
    (paragraph 9.2.4, document version N4917):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 类型别名声明与typedef声明等价。它可以出现在块作用域、类作用域或命名空间作用域中。根据C++11标准（第9.2.4段，文档版本N4917）：
- en: A typedef-name can also be introduced by an alias declaration. The identifier
    following the using keyword becomes a typedef-name and the optional attribute-specifier-seq
    following the identifier appertains to that typedef-name. It has the same semantics
    as if it were introduced by the typedef specifier. In particular, it does not
    define a new type and it shall not appear in the type-id.
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可以通过别名声明来引入typedef名称。使用using关键字之后的标识符成为typedef名称，标识符之后的可选属性说明符序列属于该typedef名称。它具有与使用typedef说明符引入相同的语义。特别是，它不会定义一个新的类型，并且它不应出现在类型标识符中。
- en: An alias declaration is, however, more readable and clearer about the actual
    type that is aliased when it comes to creating aliases for array types and function
    pointer types. In the examples from the *How to do it...* section, it is easily
    understandable that `array_t` is a name for the type array of 10 integers, while
    `fn` is a name for a function type that takes two parameters of the type `byte`
    and `double` and returns `void`. This is also consistent with the syntax for declaring
    `std::function` objects (for example, `std::function<void(byte, double)> f`).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当创建数组类型和函数指针类型的别名时，别名声明在可读性和对实际别名的清晰度方面更为出色。在*如何实现...*部分的示例中，很容易理解`array_t`是10个整数的数组类型的名称，而`fn`是接受两个类型为`byte`和`double`的参数并返回`void`的函数类型的名称。这也与声明`std::function`对象的语法一致（例如，`std::function<void(byte,
    double)> f`）。
- en: 'It is important to take note of the following things:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下事项非常重要：
- en: Alias templates cannot be partially or explicitly specialized.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 别名模板不能部分或显式地特化。
- en: Alias templates are never deduced by template argument deduction when deducing
    a template parameter.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 别名模板在推导模板参数时永远不会通过模板参数推导进行推导。
- en: The type produced when specializing an alias template is not allowed to directly
    or indirectly make use of its own type.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当特化别名模板时产生的类型不允许直接或间接地使用其自身的类型。
- en: The driving purpose of the new syntax is to define alias templates. These are
    templates that, when specialized, are equivalent to the result of substituting
    the template arguments of the alias template for the template parameters in the
    type-id.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 新语法的驱动目的是定义别名模板。这些模板在特化时，等价于将别名模板的模板参数替换为类型-id 中的模板参数的结果。
- en: See also
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Simplifying code with class template argument deduction*, to learn how to
    use class templates without explicitly specifying template arguments'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用类模板参数推导简化代码*，学习如何在不显式指定模板参数的情况下使用类模板'
- en: Understanding uniform initialization
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解统一初始化
- en: Brace-initialization is a uniform method for initializing data in C++11\. For
    this reason, it is also called *uniform initialization*. It is arguably one of
    the most important features of C++11 that developers should understand and use.
    It removes previous distinctions between initializing fundamental types, aggregate
    and non-aggregate types, and arrays and standard containers.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号初始化是 C++11 中初始化数据的统一方法。因此，它也被称为 *统一初始化*。这可能是 C++11 中开发者应该理解和使用的最重要的特性之一。它消除了初始化基本类型、聚合和非聚合类型、数组和标准容器之间的区别。
- en: Getting ready
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To continue with this recipe, you need to be familiar with direct initialization,
    which initializes an object from an explicit set of constructor arguments, and
    copy initialization, which initializes an object from another object. The following
    is a simple example of both types of initializations:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要继续这个配方，你需要熟悉直接初始化，即从一组显式的构造函数参数初始化对象，以及复制初始化，即从一个对象初始化另一个对象。以下是对这两种初始化的简单示例：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With these in mind, let’s explore how to perform uniform initialization.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些考虑的基础上，让我们探索如何执行统一初始化。
- en: How to do it...
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To uniformly initialize objects regardless of their type, use the brace-initialization
    form `{}`, which can be used for both direct initialization and copy initialization.
    When used with brace-initialization, these are called direct-list and copy-list-initialization:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要统一初始化对象，无论其类型如何，都使用大括号初始化形式 `{}`，它可以用于直接初始化和复制初始化。当与大括号初始化一起使用时，这些被称为直接列表和复制列表初始化：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Examples of uniform initialization are as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 统一初始化的例子如下：
- en: 'Standard containers:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准容器：
- en: '[PRE21]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Dynamically allocated arrays:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态分配的数组：
- en: '[PRE22]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Arrays:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组：
- en: '[PRE23]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Built-in types:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置类型：
- en: '[PRE24]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'User-defined types:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户定义的类型：
- en: '[PRE25]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'User-defined **Plain Old Data** (**POD**) types:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户定义的 **纯旧数据** （**POD**）类型：
- en: '[PRE26]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works...
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Before C++11, objects required different types of initialization based on their
    type:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++11 之前，对象根据其类型需要不同类型的初始化：
- en: 'Fundamental types could be initialized using assignment:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本类型可以使用赋值进行初始化：
- en: '[PRE27]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Class objects could also be initialized using an assignment from a single value
    if they had a conversion constructor (prior to C++11, a constructor with a single
    parameter was called a *conversion constructor*):'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类对象有一个转换构造函数（在 C++11 之前，只有一个参数的构造函数被称为 *转换构造函数*），它们也可以使用单个值的赋值进行初始化：
- en: '[PRE28]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Non-aggregate classes could be initialized with parentheses (the functional
    form) when arguments were provided and only without any parentheses when default
    initialization was performed (a call to the default constructor). In the next
    example, `foo` is the structure defined in the *How to do it...* section:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非聚合类可以在提供参数时使用括号（函数形式）进行初始化，而在执行默认初始化（调用默认构造函数）时则无需任何括号。在下一个例子中，`foo` 是在 *如何做...*
    部分定义的结构：
- en: '[PRE29]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Aggregate and POD types could be initialized with brace-initialization. In
    the following example, `bar` is the structure defined in the *How to do it...*
    section:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合和 POD 类型可以使用大括号初始化。在以下示例中，`bar` 是在 *如何做...* 部分定义的结构：
- en: '[PRE30]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: A **Plain Old Data** (**POD**) type is a type that is both trivial (has special
    members that are compiler-provided or explicitly defaulted and occupy a contiguous
    memory area) and has a standard layout (a class that does not contain language
    features, such as virtual functions, which are incompatible with the C language,
    and all members have the same access control). The concept of POD types has been
    deprecated in C++20 in favor of trivial and standard layout types.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**纯数据**（**POD**）类型是一种既是平凡（具有编译器提供的或显式默认的特殊成员，并占用连续的内存区域）又具有标准布局（不包含与 C 语言不兼容的语言功能，如虚函数，并且所有成员具有相同的访问控制）的类型。POD
    类型的概念在 C++20 中已被弃用，以支持平凡和标准布局类型。'
- en: Apart from the different methods of initializing the data, there are also some
    limitations. For instance, the only way to initialize a standard container (apart
    from copy constructing) is to first declare an object and then insert elements
    into it; `std::vector` was an exception because it is possible to assign values
    from an array that can be initialized prior using aggregate initialization. On
    the other hand, however, dynamically allocated aggregates could not be initialized
    directly.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 除了不同的数据初始化方法外，还有一些限制。例如，初始化标准容器（除了复制构造之外）的唯一方法是在其中声明一个对象，然后向其中插入元素；`std::vector`
    是一个例外，因为它可以从可以预先使用聚合初始化的数组中分配值。然而，另一方面，动态分配的聚合不能直接初始化。
- en: All the examples in the *How to do it...* section use direct initialization,
    but copy initialization is also possible with brace-initialization. These two
    forms, direct and copy initialization, may be equivalent in most cases, but copy
    initialization is less permissive because it does not consider explicit constructors
    in its implicit conversion sequence, which must produce an object directly from
    the initializer, whereas direct initialization expects an implicit conversion
    from the initializer to an argument of the constructor. Dynamically allocated
    arrays can only be initialized using direct initialization.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*“如何做...”* 部分中的所有示例都使用直接初始化，但也可以使用花括号初始化进行复制初始化。这两种形式，直接和复制初始化，在大多数情况下可能是等效的，但复制初始化的限制较少，因为它在其隐式转换序列中不考虑显式构造函数，而必须直接从初始化器生成对象，而直接初始化则期望从初始化器到构造函数参数的隐式转换。动态分配的数组只能使用直接初始化。'
- en: Of the classes shown in the preceding examples, `foo` is the one class that
    has both a default constructor and a constructor with parameters. To use the default
    constructor to perform default initialization, we need to use empty braces—that
    is, `{}`. To use the constructor with parameters, we need to provide the values
    for all the arguments in braces `{}`. Unlike non-aggregate types, where default
    initialization means invoking the default constructor, for aggregate types, default
    initialization means initializing with zeros.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面示例中显示的类中，`foo` 是唯一一个既有默认构造函数又有参数构造函数的类。要使用默认构造函数进行默认初始化，我们需要使用空花括号——即 `{}`。要使用参数构造函数，我们需要在花括号
    `{}` 中提供所有参数的值。与非聚合类型不同，其中默认初始化意味着调用默认构造函数，对于聚合类型，默认初始化意味着使用零进行初始化。
- en: Initialization of standard containers, such as the vector and the map, also
    shown previously, is possible because all standard containers have an additional
    constructor in C++11 that takes an argument of the type `std::initializer_list<T>`.
    This is basically a lightweight proxy over an array of elements of the type `T
    const`. These constructors then initialize the internal data from the values in
    the initializer list.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，标准容器（如向量 map）的初始化也是可能的，因为所有标准容器在 C++11 中都有一个额外的构造函数，它接受类型为 `std::initializer_list<T>`
    的参数。这基本上是一个轻量级代理，覆盖了类型 `T const` 的元素数组。然后这些构造函数从初始化列表中的值初始化内部数据。
- en: 'The way initialization using `std::initializer_list` works is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `std::initializer_list` 进行初始化的方式如下：
- en: The compiler resolves the types of the elements in the initialization list (all
    the elements must have the same type).
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器解析初始化列表中元素的类型（所有元素必须具有相同的类型）。
- en: The compiler creates an array with the elements in the initializer list.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器创建一个包含初始化列表中元素的数组。
- en: The compiler creates an `std::initializer_list<T>` object to wrap the previously
    created array.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器创建一个 `std::initializer_list<T>` 对象来包装之前创建的数组。
- en: The `std::initializer_list<T>` object is passed as an argument to the constructor.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::initializer_list<T>` 对象作为参数传递给构造函数。'
- en: 'An initializer list always takes precedence over other constructors where brace-initialization
    is used. If such a constructor exists for a class, it will be called when brace-initialization
    is performed:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化器列表始终优先于使用花括号初始化的其他构造函数。如果此类存在此类构造函数，则在执行花括号初始化时将被调用：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The precedence rule applies to any function, not just constructors. In the
    following example, two overloads of the same function exist. Calling the function
    with an initializer list resolves a call to the overload with an `std::initializer_list`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 优先级规则适用于任何函数，而不仅仅是构造函数。在以下示例中，存在同一函数的两个重载。使用初始化器列表调用函数将解析为具有`std::initializer_list`的重载：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'However, this has the potential to lead to bugs. Let’s take, for example, the
    `std::vector` type. Among the constructors of the vector, there is one that has
    a single argument, representing the initial number of elements to be allocated,
    and another one that has an `std::initializer_list` as an argument. If the intention
    is to create a vector with a preallocated size, using brace-initialization will
    not work, as the constructor with the `std::initializer_list` will be the best
    overload to be called:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这可能导致错误。以`std::vector`类型为例。在向量的构造函数中，有一个只有一个参数的构造函数，表示要分配的初始元素数量，还有一个参数为`std::initializer_list`的构造函数。如果目的是创建具有预分配大小的向量，使用花括号初始化将不起作用，因为具有`std::initializer_list`的构造函数将是最佳重载以被调用：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The preceding code does not create a vector with five elements but, instead,
    a vector with one element with a value of `5`. To be able to actually create a
    vector with five elements, initialization with the parentheses form must be used:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码并没有创建一个包含五个元素的向量，而是一个包含一个值为`5`的元素的向量。要实际创建一个包含五个元素的向量，必须使用括号形式进行初始化：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Another thing to note is that brace-initialization does not allow narrowing
    conversion. According to the C++ standard (refer to paragraph 9.4.5 of the standard,
    document version N4917), a narrowing conversion is an implicit conversion:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意的是，花括号初始化不允许缩窄转换。根据C++标准（参考标准第9.4.5段，文档版本N4917），缩窄转换是一种隐式转换：
- en: — From a floating-point type to an integer type.
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从浮点类型到整数类型。
- en: ''
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: — From long double to double or float, or from double to float, except where
    the source is a constant expression and the actual value after conversion is within
    the range of values that can be represented (even if it cannot be represented
    exactly).
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从`long double`到`double`或`float`，或从`double`到`float`，除非源是常量表达式，并且转换后的实际值在可以表示的值范围内（即使不能精确表示）。
- en: ''
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: — From an integer type or unscoped enumeration type to a floating-point type,
    except where the source is a constant expression and the actual value after conversion
    will fit into the target type and will produce the original value when converted
    to its original type.
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从整数类型或无范围枚举类型到浮点类型，除非源是常量表达式，并且转换后的实际值可以适合目标类型，并且在转换回原始类型时将产生原始值。
- en: ''
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: — From an integer type or unscoped enumeration type to an integer type that
    cannot represent all the values of the original type, except where the source
    is a constant expression and the actual value after conversion will fit into the
    target type and will produce the original value when converted to its original
    type.
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从整数类型或无范围枚举类型到无法表示原始类型所有值的整数类型，除非源是常量表达式，并且转换后的实际值可以适合目标类型，并且在转换回原始类型时将产生原始值。
- en: 'The following declarations trigger compiler errors because they require a narrowing
    conversion:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下声明会触发编译器错误，因为它们需要缩窄转换：
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To fix this error, an explicit conversion must be done:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复此错误，必须进行显式转换：
- en: '[PRE36]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: A brace-initialization list is not an expression and does not have a type. Therefore,
    `decltype` cannot be used on a brace-init-list, and template type deductions cannot
    deduce the type that matches a brace-init-list.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 花括号初始化列表不是一个表达式，也没有类型。因此，不能在花括号初始化列表上使用`decltype`，模板类型推导也不能推导出与花括号初始化列表匹配的类型。
- en: 'Let’s consider one more example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再考虑一个例子：
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The preceding declaration is, despite the above, correct because an implicit
    conversion from `int` to `float` exists. The expression `47/13` is first evaluated
    to integer value `3`, which is then assigned to the variable `f2` of the type
    `float`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，前面的声明是正确的，因为存在从`int`到`float`的隐式转换。表达式`47/13`首先被评估为整数值`3`，然后将其赋值给类型为`float`的变量`f2`。
- en: There’s more...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The following example shows several examples of direct-list-initialization
    and copy-list-initialization. In C++11, the deduced type of all these expressions
    is `std::initializer_list<int>`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了直接列表初始化和复制列表初始化的几个例子。在 C++11 中，所有这些表达式的推导类型是 `std::initializer_list<int>`：
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'C++17 has changed the rules for list initialization, differentiating between
    direct- and copy-list-initialization. The new rules for type deduction are as
    follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: C++17 改变了列表初始化的规则，区分了直接列表初始化和复制列表初始化。类型推导的新规则如下：
- en: For copy-list-initialization, auto deduction will deduce an `std::initializer_list<T>`
    if all the elements in the list have the same type, or be ill-formed.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于复制列表初始化，如果列表中的所有元素都具有相同的类型，则自动推导将推导出 `std::initializer_list<T>`；否则是不合法的。
- en: For direct-list-initialization, auto deduction will deduce a `T` if the list
    has a single element, or be ill-formed if there is more than one element.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于直接列表初始化，如果列表只有一个元素，则自动推导将推导出 `T`；如果有多个元素，则是不合法的。
- en: 'Based on these new rules, the previous examples would change as follows (the
    deduced type is mentioned in the comments):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些新规则，前面的例子将如下改变（推导类型在注释中提及）：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this case, `a` and `c` are deduced as `std::initializer_list<int>`, `b` is
    deduced as an `int`, and `d`, which uses direct initialization and has more than
    one value in the brace-init-list, triggers a compiler error.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`a` 和 `c` 被推导为 `std::initializer_list<int>`，`b` 被推导为 `int`，而 `d` 使用直接初始化并且花括号初始化列表中有多个值，这会触发编译器错误。
- en: See also
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using auto whenever possible*, to understand how automatic type deduction
    works in C++'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*尽可能使用 auto*，以了解 C++ 中自动类型推导的工作原理'
- en: '*Understanding the various forms of non-static member initialization*, to learn
    how to best perform initialization of class members'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*理解非静态成员的多种初始化形式*，以了解如何最佳地执行类成员的初始化'
- en: Understanding the various forms of non-static member initialization
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解非静态成员的多种初始化形式
- en: Constructors are places where non-static class member initialization is done.
    Many developers prefer assignments in the constructor body. Aside from the several
    exceptional cases when that is actually necessary, initialization of non-static
    members should be done in the constructor’s initializer list or, as of C++11,
    using default member initialization when they are declared in the class. Prior
    to C++11, constants and non-constant non-static data members of a class had to
    be initialized in the constructor. Initialization on declaration in a class was
    only possible for static constants. As we will see here, this limitation was removed
    in C++11, which allows the initialization of non-statics in the class declaration.
    This initialization is called *default member initialization* and is explained
    in the following sections.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是执行非静态类成员初始化的地方。许多开发者更喜欢在构造函数体中使用赋值。除了实际需要的那几个例外情况，非静态成员的初始化应该在构造函数的初始化列表中完成，或者从
    C++11 开始，当它们在类中声明时，可以使用默认成员初始化。在 C++11 之前，类的常量和非常量非静态数据成员必须在构造函数中初始化。在类中声明初始化仅适用于静态常量。正如我们将在这里看到的，这种限制在
    C++11 被移除，允许在类声明中初始化非静态成员。这种初始化被称为 *默认成员初始化*，将在以下章节中解释。
- en: This recipe will explore the ways non-static member initialization should be
    done. Using the appropriate initialization method for each member leads not only
    to more efficient code but also to better organized and more readable code.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将探讨非静态成员初始化应该如何进行。为每个成员使用适当的初始化方法不仅会使代码更高效，而且会使代码组织得更好，更易于阅读。
- en: How to do it...
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To initialize non-static members of a class, you should:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化类的非静态成员，你应该：
- en: Use default member initialization for constants, both static and non-static
    (see `[1]` and `[2]` in the following code).
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用默认成员初始化为常量，包括静态和非静态（参见以下代码中的 `[1]` 和 `[2]`）。
- en: Use default member initialization to provide default values for members of classes
    with multiple constructors that would use a common initializer for those members
    (see `[3]` and `[4]` in the following code).
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用默认成员初始化为具有多个构造函数的类成员提供默认值（参见以下代码中的 `[3]` 和 `[4]`）。
- en: Use the constructor initializer list to initialize members that don’t have default
    values but depend on constructor parameters (see `[5]` and `[6]` in the following
    code).
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用构造函数初始化列表来初始化没有默认值但依赖于构造函数参数的成员（参见以下代码中的 `[5]` 和 `[6]`）。
- en: Use assignment in constructors when the other options are not possible (examples
    include initializing data members with the pointer `this`, checking constructor
    parameter values, and throwing exceptions prior to initializing members with those
    values or self-references to two non-static data members).
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当其他选项不可用时，请在构造函数中使用赋值操作（例如，使用指针 `this` 初始化数据成员，检查构造函数参数值，以及在用这些值或两个非静态数据成员的自我引用初始化成员之前抛出异常）。
- en: 'The following example shows these forms of initialization:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了这些初始化形式：
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How it works...
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Non-static data members are supposed to be initialized in the constructor’s
    initializer list, as shown in the following example:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 非静态数据成员应该在构造函数的初始化列表中进行初始化，如下面的示例所示：
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Many developers, however, do not use the initializer list and prefer assignments
    in the constructor’s body, or even mix assignments and the initializer list. That
    could be for several reasons—for large classes with many members, the constructor
    assignments may be easier to read than long initializer lists, perhaps split into
    many lines, or it could be because these developers are familiar with other programming
    languages that don’t have an initializer list.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，许多开发者并不使用初始化列表，而是偏好构造函数体中的赋值操作，甚至混合使用赋值和初始化列表。这可能由几个原因造成——对于具有许多成员的大类，构造函数中的赋值可能比长初始化列表更容易阅读，也许分散在多行中，或者可能是因为这些开发者熟悉没有初始化列表的其他编程语言。
- en: It is important to note that the order in which non-static data members are
    initialized is the order in which they were declared in the class definition,
    not the order of their initialization in a constructor initializer list. Conversely,
    the order in which non-static data members are destroyed is the reversed order
    of construction.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，非静态数据成员的初始化顺序是它们在类定义中声明的顺序，而不是在构造函数初始化列表中初始化的顺序。相反，非静态数据成员的销毁顺序是构造顺序的反向。
- en: 'Using assignments in the constructor is not efficient, as this can create temporary
    objects that are later discarded. If not initialized in the initializer list,
    non-static members are initialized via their default constructor and then, when
    assigned a value in the constructor’s body, the assignment operator is invoked.
    This can lead to inefficient work if the default constructor allocates a resource
    (such as memory or a file) and that has to be deallocated and reallocated in the
    assignment operator. This is exemplified in the following snippet:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中使用赋值操作不是高效的，因为这可能会创建后来被丢弃的临时对象。如果不在初始化列表中初始化，非静态成员将通过它们的默认构造函数进行初始化，然后在构造函数体中分配值时，将调用赋值运算符。如果默认构造函数分配了资源（如内存或文件），并且需要在赋值运算符中重新分配和释放，这可能会导致低效的工作。这在下述代码片段中得到了体现：
- en: '[PRE42]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The preceding code produces the following output, showing how the data member
    `f` is first default initialized and then assigned a new value:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码产生以下输出，显示了数据成员 `f` 首先通过默认初始化，然后被分配了一个新值：
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If you want to track which object was created and destroyed, you can slightly
    change the `foo` class above and print the value of the `this` pointer for each
    of the special member functions. You can do this as a follow-up exercise.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想跟踪哪个对象被创建和销毁，你可以稍微修改上面的 `foo` 类，并打印每个特殊成员函数的 `this` 指针的值。你可以将此作为后续练习来完成。
- en: 'Changing the initialization from the assignment in the constructor body to
    the initializer list replaces the calls to the default constructor, plus the assignment
    operator, with a call to the copy constructor:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 将构造函数体中的赋值操作更改为初始化列表，将替换对默认构造函数和赋值运算符的调用，改为调用拷贝构造函数：
- en: '[PRE44]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Adding the preceding line of code produces the following output:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 添加上述代码行会产生以下输出：
- en: '[PRE45]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'For those reasons, at least for types other than the built-in types (such as
    `bool`, `char`, `int`, `float`, `double`, or pointers), you should prefer the
    constructor initializer list. However, to be consistent with your initialization
    style, you should always prefer the constructor initializer list when possible.
    There are several situations when using the initializer list is not possible;
    these include the following cases (but the list could be expanded for other cases):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，至少对于除内置类型（如 `bool`、`char`、`int`、`float`、`double` 或指针）之外的类型，你应该优先选择构造函数的初始化列表。然而，为了保持初始化风格的一致性，在可能的情况下，你应该始终优先选择构造函数的初始化列表。存在一些情况下使用初始化列表是不可能的；以下是一些情况（但列表可以扩展到其他情况）：
- en: If a member has to be initialized with a pointer or reference to the object
    that contains it, using the `this` pointer in the initialization list may trigger
    a warning with some compilers that it should be used before the object is constructed.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个成员必须使用指向包含它的对象的指针或引用进行初始化，在初始化列表中使用 `this` 指针可能会在某些编译器上触发警告，表明它应该在对象构造之前使用。
- en: If you have two data members that must contain references to each other.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有两个数据成员必须相互包含对方的引用。
- en: If you want to test an input parameter and throw an exception before initializing
    a non-static data member with the value of the parameter.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想在初始化非静态数据成员之前测试输入参数并抛出异常。
- en: 'Starting with C++11, non-static data members can be initialized when declared
    in the class. This is called *default member initialization* because it is supposed
    to represent initialization with default values. Default member initialization
    is intended for constants and members that are not initialized based on constructor
    parameters (in other words, members whose value does not depend on the way the
    object is constructed):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C++11 开始，非静态数据成员可以在类中声明时进行初始化。这被称为 *默认成员初始化*，因为它表示使用默认值进行初始化。默认成员初始化旨在用于常量和那些不基于构造函数参数初始化的成员（换句话说，成员的值不依赖于对象的构造方式）：
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the preceding example, `DefaultHeight` and `DefaultWidth` are both constants;
    therefore, the values do not depend on the way the object is constructed, so they
    are initialized when declared. The `textFlow` object is a non-constant, non-static
    data member whose value also does not depend on the way the object is initialized
    (it could be changed via another member function); therefore, it is also initialized
    using default member initialization when it is declared. `text`, conversely, is
    also a non-constant non-static data member, but its initial value depends on the
    way the object is constructed.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`DefaultHeight` 和 `DefaultWidth` 都是常量；因此，它们的值不依赖于对象的构造方式，所以它们在声明时进行初始化。`textFlow`
    对象是一个非常量、非静态数据成员，其值也不依赖于对象的初始化方式（它可以通过另一个成员函数进行更改）；因此，它在声明时也使用默认成员初始化进行初始化。相反，`text`
    也是一个非常量、非静态数据成员，但它的初始值依赖于对象的构造方式。
- en: Therefore, it is initialized in the constructor’s initializer list using a value
    passed as an argument to the constructor.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它使用传递给构造函数的参数值在构造函数的初始化列表中进行初始化。
- en: 'If a data member is initialized both with the default member initialization
    and constructor initializer list, the latter takes precedence and the default
    value is discarded. To exemplify this, let’s again consider the `foo` class mentioned
    earlier and the following `bar` class, which uses it:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个数据成员同时使用默认成员初始化和构造函数初始化列表进行初始化，后者具有优先级，并且默认值会被丢弃。为了说明这一点，让我们再次考虑前面提到的 `foo`
    类和下面的 `bar` 类，它使用了 `foo` 类：
- en: '[PRE47]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In this case, the output differs as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，输出如下不同：
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The reason for the different behavior is that the value from the default initializer
    list is discarded, and the object is not initialized twice.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 不同行为的原因是默认初始化列表中的值被丢弃，对象不会被初始化两次。
- en: See also
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Understanding uniform initialization*, to see how brace-initialization works'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*理解统一初始化*，了解花括号初始化是如何工作的'
- en: Controlling and querying object alignment
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制和查询对象对齐
- en: C++11 provides standardized methods for specifying and querying the alignment
    requirements of a type (something that was previously possible only through compiler-specific
    methods). Controlling the alignment is important in order to boost performance
    on different processors and enable the use of some instructions that only work
    with data on particular alignments.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 提供了指定和查询类型对齐要求的标准方法（这之前只能通过编译器特定的方法实现）。控制对齐对于提高不同处理器的性能和允许使用一些仅在特定对齐上工作的指令非常重要。
- en: For example, Intel **Streaming SIMD Extensions** (**SSE**) and Intel SSE2, which
    are a set of processor instructions that can greatly increase performance when
    the same operations are to be applied on multiple data objects, require 16 bytes
    of alignment of data. Conversely, for **Intel Advanced Vector Extensions** (or
    **Intel AVX**), which expands most integer processor commands to 256 bits, it
    is highly recommended to use 32-byte alignment. This recipe explores the `alignas`
    specifier for controlling the alignment requirements and the `alignof` operator,
    which retrieves the alignment requirements of a type.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Intel **流式单指令多数据扩展**（**SSE**）和 Intel SSE2，它们是一组处理器指令，当要对多个数据对象应用相同的操作时，可以大大提高性能，需要数据对齐
    16 字节。相反，对于 **Intel 高级向量扩展**（或 **Intel AVX**），它将大多数整数处理器指令扩展到 256 位，强烈建议使用 32
    字节对齐。本食谱探讨了用于控制对齐要求的 `alignas` 指定符和用于检索类型对齐要求的 `alignof` 操作符。
- en: Getting ready
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should be familiar with what data alignment is and the way the compiler
    performs default data alignment. However, basic information about the latter is
    provided in the *How it works...* section.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该熟悉数据对齐是什么以及编译器如何执行默认数据对齐。然而，有关后者的基本信息在 *它是如何工作的...* 部分提供。
- en: How to do it...
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To control the alignment of a type (both at the class level or data member
    level) or an object, use the `alignas` specifier:'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要控制类型（在类级别或数据成员级别）或对象的对齐，请使用 `alignas` 指定符：
- en: '[PRE49]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To query the alignment of a type, use the `alignof` operator:'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要查询类型的对齐，请使用 `alignof` 操作符：
- en: '[PRE50]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How it works...
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Processors do not access memory one byte at a time but in larger chunks of powers
    of two (2, 4, 8, 16, 32, and so on). Owing to this, it is important that compilers
    align data in memory so that it can be easily accessed by the processor. Should
    this data be misaligned, the compiler has to do extra work to access data; it
    has to read multiple chunks of data, shift and discard unnecessary bytes, and
    combine the rest.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器不是逐字节访问内存，而是以 2 的幂次方（2、4、8、16、32 等）的更大块来访问。因此，编译器在内存中对齐数据以便处理器可以轻松访问是很重要的。如果数据未对齐，编译器必须做额外的工作来访问数据；它必须读取多个数据块，移位并丢弃不必要的字节，然后组合剩余的部分。
- en: 'C++ compilers align variables based on the size of their data type. The standard
    only specifies the sizes of `char`, `signed char`, `unsigned char`, `char8_t`
    (introduced in C++20), and `std::byte` (introduced in C++17), which must be 1\.
    It also requires that the size of `short` must be at least 16 bits, the size of
    `long` must be at least 32 bits, and the size of `long long` must be at least
    64 bits. It also requires that 1 == `sizeof(char)` <= `sizeof(short)` <= `sizeof(int)`
    <= `sizeof(long)` <= `sizeof(long long)`. Therefore, the size of most types is
    compiler-specific and may depend on the platform. Typically, these are 1 byte
    for `bool` and `char`, 2 bytes for `short`, 4 bytes for `int`, `long`, and `float`,
    8 bytes for `double` and `long long`, and so on. When it comes to structures or
    unions, the alignment must match the size of the largest member in order to avoid
    performance issues. To exemplify this, let’s consider the following data structures:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 编译器根据数据类型的大小来对变量进行对齐。标准仅指定了 `char`、`signed char`、`unsigned char`、`char8_t`（在
    C++20 中引入）和 `std::byte`（在 C++17 中引入）的大小，这些大小必须是 1。它还要求 `short` 的大小至少为 16 位，`long`
    的大小至少为 32 位，`long long` 的大小至少为 64 位。它还要求 1 == `sizeof(char)` <= `sizeof(short)`
    <= `sizeof(int)` <= `sizeof(long)` <= `sizeof(long long)`。因此，大多数类型的大小是编译器特定的，并且可能取决于平台。通常，这些大小是
    `bool` 和 `char` 为 1 字节，`short` 为 2 字节，`int`、`long` 和 `float` 为 4 字节，`double` 和
    `long long` 为 8 字节，等等。当涉及到结构体或联合体时，对齐必须与最大成员的大小相匹配，以避免性能问题。为了举例说明，让我们考虑以下数据结构：
- en: '[PRE51]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`foo1` and `foo2` are different sizes, but the alignment is the same—that is,
    1—because all data members are of the type `char`, which has a size of 1 byte.
    In the structure `foo3`, the second member is an integer, whose size is 4\. As
    a result, the alignment of members of this structure is done at addresses that
    are multiples of 4\. To achieve this, the compiler introduces padding bytes.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`foo1` 和 `foo2` 的大小不同，但它们的对齐方式相同——即 1——因为所有数据成员都是 `char` 类型，其大小为 1 字节。在结构 `foo3`
    中，第二个成员是一个整数，其大小为 4。因此，该结构的成员对齐是在地址为 4 的倍数的地方进行的。为了实现这一点，编译器引入了填充字节。'
- en: 'The structure `foo3` is actually transformed into the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 结构 `foo3` 实际上被转换成以下形式：
- en: '[PRE52]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Similarly, the following structure has a size of 32 bytes and an alignment
    of 8; this is because the largest member is a `double` whose size is 8\. This
    structure, however, requires padding in several places to make sure that all the
    members can be accessed at addresses that are multiples of 8:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，以下结构的大小为32字节，对齐为8；这是因为最大的成员是一个大小为8的`double`。然而，这个结构需要在几个地方进行填充，以确保所有成员都可以在地址为8的倍数的位置访问：
- en: '[PRE53]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The equivalent structure that’s created by the compiler is as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器创建的等效结构如下：
- en: '[PRE54]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In C++11, specifying the alignment of an object or type is done using the `alignas`
    specifier. This can take either an expression (an integral constant expression
    that evaluates to `0` or a valid value for an alignment), a type-id, or a parameter
    pack. The `alignas` specifier can be applied to the declaration of a variable
    or a class data member that does not represent a bit field, or to the declaration
    of a class, union, or enumeration.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11中，指定对象或类型的对齐是通过使用`alignas`指定符来完成的。这可以是一个表达式（一个求值为`0`或对齐有效值的整型常量表达式）、一个类型标识符或参数包。`alignas`指定符可以应用于变量或类的数据成员的声明，这些成员不表示位字段，或者可以应用于类、联合或枚举的声明。
- en: The type or object on which an `alignas` specification is applied will have
    the alignment requirement equal to the largest, greater than zero, expression
    of all `alignas` specifications used in the declaration.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明中使用的所有`alignas`指定符中，应用于类型或对象的`alignas`指定将对齐要求等于所有`alignas`指定符中最大的、大于零的表达式。
- en: 'There are several restrictions when using the `alignas` specifier:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`alignas`指定符时有一些限制：
- en: The only valid alignments are the powers of two (1, 2, 4, 8, 16, 32, and so
    on). Any other values are illegal, and the program is considered ill-formed; that
    doesn’t necessarily have to produce an error, as the compiler may choose to ignore
    the specification.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有2的幂（1、2、4、8、16、32等等）是有效的对齐方式。任何其他值都是非法的，程序被认为是无效的；这并不一定必须产生错误，因为编译器可以选择忽略该指定。
- en: An alignment of 0 is always ignored.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0的对齐始终被忽略。
- en: If the largest `alignas` on a declaration is smaller than the natural alignment
    without any `alignas` specifier, then the program is also considered ill-formed.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果声明中最大的`alignas`值小于没有任何`alignas`指定符的自然对齐，则程序也被认为是无效的。
- en: 'In the following example, the `alignas` specifier has been applied to a class
    declaration. The natural alignment without the `alignas` specifier would have
    been 1, but with `alignas(4)`, it becomes 4:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，`alignas`指定符已被应用于类声明。如果没有`alignas`指定符的自然对齐将是1，但使用`alignas(4)`后变为4：
- en: '[PRE55]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In other words, the compiler transforms the preceding class into the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，编译器将前面的类转换为以下形式：
- en: '[PRE56]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `alignas` specifier can be applied both to the class declaration and the
    member data declarations. In this case, the strictest (that is, largest) value
    wins. In the following example, member `a` has a natural size of 1 and requires
    an alignment of 2; member `b` has a natural size of 4 and requires an alignment
    of 8, so the strictest alignment would be 8\. The alignment requirement of the
    entire class is 4, which is weaker (that is, smaller) than the strictest required
    alignment, and therefore, it will be ignored, although the compiler will produce
    a warning:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`alignas`指定符可以同时应用于类声明和成员数据声明。在这种情况下，最严格的（即，最大的）值获胜。在下面的示例中，成员`a`的自然大小为1，需要2的对齐；成员`b`的自然大小为4，需要8的对齐，因此最严格的对齐将是8。整个类的对齐要求是4，这比最严格要求的对齐更弱（即，更小），因此它将被忽略，尽管编译器将生成一个警告：'
- en: '[PRE57]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The result is a structure that looks like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个看起来像这样的结构：
- en: '[PRE58]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `alignas` specifier can also be applied to variables. In the following
    example, variable `a`, which is an integer, is required to be placed in memory
    at a multiple of 8\. The next variable, the array of 4 longs, is required to be
    placed in memory at a multiple of 256\. As a result, the compiler will introduce
    up to 244 bytes of padding between the two variables (depending on where in memory,
    at an address multiple of 8, variable `a` is located):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`alignas`指定符也可以应用于变量。在下面的示例中，整数变量`a`必须放置在内存的8的倍数位置。下一个变量，即4个长整型的数组，必须放置在内存的256的倍数位置。因此，编译器将在两个变量之间引入多达244字节的填充（取决于内存中的位置，在地址为8的倍数的位置，变量`a`被放置）：'
- en: '[PRE59]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Looking at the addresses, we can see that the address of `a` is indeed a multiple
    of 8, and that the address of `b` is a multiple of 256 (hexadecimal 100).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看地址，我们可以看到 `a` 的地址确实是 8 的倍数，而 `b` 的地址是 256（十六进制 100）的倍数。
- en: 'To query the alignment of a type, we use the `alignof` operator. Unlike `sizeof`,
    this operator can only be applied to types, not to variables or class data members.
    The types it can be applied to are complete types, array types, or reference types.
    For arrays, the value that’s returned is the alignment of the element type; for
    references, the value that’s returned is the alignment of the referenced type.
    Here are several examples:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要查询类型的对齐，我们使用 `alignof` 操作符。与 `sizeof` 不同，此操作符只能应用于类型，不能应用于变量或类数据成员。它可以应用于完整类型、数组类型或引用类型。对于数组，返回的值是元素类型的对齐方式；对于引用，返回的值是引用类型的对齐方式。以下是一些示例：
- en: '| **Expression** | **Evaluation** |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** | **评估** |'
- en: '| `alignof(char)` | 1, because the natural alignment of `char` is 1 |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `alignof(char)` | 1，因为 `char` 的自然对齐方式为 1 |'
- en: '| `alignof(int)` | 4, because the natural alignment of `int` is 4 |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `alignof(int)` | 4，因为 `int` 的自然对齐方式为 4 |'
- en: '| `alignof(int*)` | 4 on 32-bit and 8 on 64-bit, the alignment for pointers
    |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `alignof(int*)` | 32 位系统上的对齐方式为 4，64 位系统上的对齐方式为 8，这是指针的对齐方式|'
- en: '| `alignof(int[4])` | 4, because the natural alignment of the element type
    is 4 |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `alignof(int[4])` | 4，因为元素类型的自然对齐方式为 4 |'
- en: '| `alignof(foo&)` | 8, because the specified alignment for the class `foo`,
    which is the reference type (as shown in the previous example), was 8 |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `alignof(foo&)` | 8，因为类 `foo` 的指定对齐方式为 8，这是一个引用类型（如前一个示例所示）|'
- en: 'Table 1.1: Examples of alignof expressions and their evaluated value'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.1：alignof 表达式的示例及其评估值
- en: The `alignas` specifier is useful if you wish to force an alignment for a data
    type (taking into consideration the restriction mentioned previously) so that
    variables of that type can be accessed and copied efficiently. This means optimizing
    CPU reads and writes and avoiding unnecessary invalidation from cache lines.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想强制对数据类型进行对齐（考虑前面提到的限制），`alignas` 指示符非常有用，以便可以有效地访问和复制该类型的变量。这意味着优化 CPU 读取和写入，并避免缓存行不必要的无效化。
- en: This can be highly important in some categories of applications where performance
    is key, such as games or trading applications. Conversely, the `alignof` operator
    retries the minimum alignment requirement of a specified type.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些类别中的应用中，性能至关重要，例如游戏或交易应用，这可以非常重要。相反，`alignof` 操作符尝试指定类型的最低对齐要求。
- en: See also
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Creating type aliases and alias templates*, to learn about aliases for types'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建类型别名和别名模板*，以了解类型别名'
- en: Using scoped enumerations
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用范围枚举
- en: Enumeration is a basic type in C++ that defines a collection of values, always
    of an integral underlying type. Their named values, which are constant, are called
    enumerators. Enumerations declared with the keyword `enum` are called *unscoped
    enumerations*, while enumerations declared with `enum class` or `enum struct`
    are called *scoped enumerations*. The latter ones were introduced in C++11 and
    are intended to solve several problems with unscoped enumerations, which are explained
    in this recipe.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举是 C++ 中的一个基本类型，它定义了一组值，这些值始终具有一个整型基础类型。它们的命名值，这些值是常量，被称为枚举符。使用关键字 `enum` 声明的枚举称为
    *无范围枚举*，而使用 `enum class` 或 `enum struct` 声明的枚举称为 *范围枚举*。后者是在 C++11 中引入的，旨在解决无范围枚举的几个问题，这些问题在本食谱中进行了说明。
- en: How to do it...
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'When working with enumerations, you should:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理枚举时，你应该：
- en: Prefer to use scoped enumerations instead of unscoped ones
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更倾向于使用范围枚举而不是无范围枚举
- en: 'Declare scoped enumerations using `enum class` or `enum struct`:'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `enum class` 或 `enum struct` 声明范围枚举：
- en: '[PRE60]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `enum class` and `enum struct` declarations are equivalent, and throughout
    this recipe and the rest of this book, we will use `enum class`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum class` 和 `enum struct` 声明是等效的，在这份食谱和本书的其余部分，我们将使用 `enum class`。'
- en: 'Because scope enumerations are restricted namespaces, the C++20 standard allows
    us to associate them with a `using` directive. You can do the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 由于范围枚举是受限命名空间，C++20 标准允许我们使用 `using` 指令将它们关联起来。你可以这样做：
- en: 'Introduce a scoped enumeration identifier in the local scope with a `using`
    directive, as follows:'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `using` 指令在局部作用域中引入范围枚举标识符，如下所示：
- en: '[PRE61]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Introduce all the identifiers of a scoped enumeration in the local scope with
    a `using` directive, as follows:'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `using` 指令在局部作用域中引入范围枚举的所有标识符，如下所示：
- en: '[PRE62]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Use a `using enum` directive to introduce the enum identifiers in a `switch`
    statement to simplify your code:'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`using enum`指令在`switch`语句中引入枚举标识符，以简化你的代码：
- en: '[PRE63]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Converting a scoped enumeration to its underlying type is sometimes necessary,
    especially in the context of using old-style APIs that take integers as arguments.
    In C++23, you can convert to the underlying type of a scoped enumeration by using
    the `std::to_underlying()` utility function:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用旧式API（这些API接受整数作为参数）的上下文中，有时需要将范围枚举转换为它的基础类型。在C++23中，你可以通过使用`std::to_underlying()`实用函数将范围枚举转换为它的基础类型：
- en: '[PRE64]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: How it works...
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Unscoped enumerations have several issues that create problems for developers:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 无范围枚举存在一些问题，这些问题会给开发者带来麻烦：
- en: 'They export their enumerators to the surrounding scope (for which reason, they
    are called unscoped enumerations), and that has the following two drawbacks:'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们将枚举符导出到周围作用域（这就是为什么它们被称为无范围枚举），这有两个缺点：
- en: It can lead to name clashes if two enumerations in the same namespace have enumerators
    with the same name
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果同一命名空间中的两个枚举具有相同名称的枚举符，可能会导致名称冲突
- en: 'It’s not possible to use an enumerator using its fully qualified name:'
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用完全限定名称使用枚举符是不可能的：
- en: '[PRE65]'
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Prior to C++ 11, they could not specify the underlying type, which is required
    to be an integral type. This type must not be larger than `int`, unless the enumerator
    value cannot fit a signed or unsigned integer. Owing to this, forward declaration
    of enumerations was not possible. The reason for this was that the size of the
    enumeration was not known. This was because the underlying type was not known
    until the values of the enumerators were defined so that the compiler could pick
    the appropriate integer type. This has been fixed in C++11.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C++11之前，它们不能指定基础类型，基础类型必须是整型。除非枚举值无法适应有符号或无符号整数，否则此类型不得大于`int`。因此，枚举的前向声明是不可能的。原因在于枚举的大小是未知的。这是因为直到枚举符的值被定义，基础类型才未知，以便编译器选择适当的整型类型。这在C++11中得到了修复。
- en: 'Values of enumerators implicitly convert to `int`. This means you can intentionally
    or accidentally mix enumerations that have a certain meaning and integers (which
    may not even be related to the meaning of the enumeration) and the compiler will
    not be able to warn you:'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举符的值隐式转换为`int`。这意味着你可以故意或意外地将具有特定意义的枚举和整数（可能甚至与枚举的意义无关）混合，编译器将无法警告你：
- en: '[PRE66]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The scoped enumerations are basically strongly typed enumerations that behave
    differently than the unscoped enumerations:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 范围枚举基本上是强类型枚举，其行为与无范围枚举不同：
- en: 'They do not export their enumerators to the surrounding scope. The two enumerations
    shown earlier would change to the following, no longer generating a name collision
    and making it possible to fully qualify the names of the enumerators:'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不会将枚举符导出到周围作用域。前面显示的两个枚举将变为以下内容，不再生成名称冲突，并使得完全限定枚举符的名称成为可能：
- en: '[PRE67]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You can specify the underlying type. The same rules for underlying types of
    unscoped enumerations apply to scoped enumerations too, except that the user can
    explicitly specify the underlying type. This also solves the problem with forward
    declarations, since the underlying type can be known before the definition is
    available:'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以指定基础类型。无范围枚举的基础类型的相同规则也适用于范围枚举，除了用户可以显式指定基础类型。这也解决了关于前向声明的問題，因为基础类型可以在定义可用之前就已知：
- en: '[PRE68]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Values of scoped enumerations no longer convert implicitly to `int`. Assigning
    the value of an `enum class` to an integer variable would trigger a compiler error
    unless an explicit cast is specified:'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围枚举的值不再隐式转换为`int`。将`enum class`的值赋给整数变量将触发编译器错误，除非指定了显式转换：
- en: '[PRE69]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'However, the scoped enumerations have a drawback: they are restricted namespaces.
    They do not export the identifiers in the outer scope, which can be inconvenient
    at times, for instance, if you are writing a `switch` and you need to repeat the
    enumeration name for each case label, as in the following example:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，范围枚举有一个缺点：它们是受限命名空间。它们不会导出外部作用域中的标识符，这在某些情况下可能不方便，例如，当你编写一个`switch`语句并且需要为每个情况标签重复枚举名称时，如下面的示例所示：
- en: '[PRE70]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In C++20, this can be simplified with the help of a `using` directive with
    the name of the scoped enumeration. The preceding code can be simplified as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++20中，可以通过使用具有范围枚举名称的`using`指令来简化这一点。前面的代码可以简化如下：
- en: '[PRE71]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The effect of this `using` directive is that all the enumerator identifiers
    are introduced in the local scope, making it possible to refer to them with the
    unqualified form. It is also possible to bring only a particular enum identifier
    to the local scope with a `using` directive with the qualified identifier name,
    such as `using` `Status::Connected`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `using` 指令的效果是，所有枚举标识符都引入到局部作用域中，使得可以使用未限定形式引用它们。也可以使用具有限定标识符名称的 `using` 指令仅将特定的枚举标识符引入局部作用域，例如
    `using Status::Connected`。
- en: The C++23 version of the standard adds a couple of utility functions for working
    with scoped enumerations. The first of these is `std::to_underlying()`, available
    in the `<utility>` header. What it does is convert an enumeration to its underlying
    type.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: C++23 标准版本添加了一些用于处理作用域枚举的实用函数。其中第一个是 `std::to_underlying()`，可在 `<utility>` 头文件中找到。它的作用是将枚举转换为它的底层类型。
- en: 'Its purpose is to work with APIs (legacy or not) that don’t use scoped enumerations.
    Let’s look at an example. Consider the following function, `old_api()`, which
    takes an integer argument, which it interprets as flags controlling user rights,
    into the system:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 它的目的是与不使用作用域枚举的 API（无论是遗留的还是新的）一起工作。让我们看看以下函数 `old_api()` 的例子，它接受一个整数参数，将其解释为控制用户权限的系统标志：
- en: '[PRE72]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This function can be invoked as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数可以按以下方式调用：
- en: '[PRE73]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Conversely, a newer part of the system defines the following scoped enumeration
    for the user rights:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，系统的较新部分为用户权限定义了以下作用域枚举：
- en: '[PRE74]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'However, invoking the `old_api()` function with enumerations from `user_rights`
    is not possible, and a `static_cast` must be used:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用来自 `user_rights` 的枚举调用 `old_api()` 函数是不可能的，必须使用 `static_cast`：
- en: '[PRE75]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'To avoid these static casts, C++23 provides the function `std::to_underlying()`,
    which can be used as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些静态转换，C++23 提供了函数 `std::to_underlying()`，可以使用如下方式：
- en: '[PRE76]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The other utility introduced in C++23 is a type trait called `is_scoped_enum<T>`,
    available in the `<type_traits>` header. This contains a member constant called
    `value`, which is equal to `true` if the template type parameter `T` is a scoped
    enumeration type, or `false` otherwise. There is also a helper variable template,
    `is_scoped_enum_v<T>`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: C++23 中引入的其他实用工具是一个名为 `is_scoped_enum<T>` 的类型特质，可在 `<type_traits>` 头文件中找到。它包含一个名为
    `value` 的成员常量，如果模板类型参数 `T` 是作用域枚举类型，则等于 `true`，否则为 `false`。还有一个辅助变量模板，`is_scoped_enum_v<T>`。
- en: 'The purpose of this type trait is to identify whether an enumeration is scoped
    or not in order to apply different behavior, depending on the type of the enumeration.
    Here is a simple example:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 此类型特质的目的是确定枚举是否具有作用域，以便根据枚举的类型应用不同的行为。以下是一个简单的示例：
- en: '[PRE77]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The first line will print 0 because `A` is an unscoped enum, while the second
    line will print `1` because `B` is a scoped enum.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将打印 0，因为 `A` 是无作用域枚举，而第二行将打印 `1`，因为 `B` 是作用域枚举。
- en: See also
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Chapter 9*, *Creating compile-time constant expressions*, to learn how to
    work with compile-time constants'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第9章*，*创建编译时常量表达式*，了解如何处理编译时常量'
- en: Using override and final for virtual methods
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `override` 和 `final` 为虚方法
- en: Unlike other similar programming languages, C++ does not have a specific syntax
    for declaring interfaces (which are basically classes with pure virtual methods
    only) and also has some deficiencies related to how virtual methods are declared.
    In C++, the virtual methods are introduced with the `virtual` keyword. However,
    the keyword `virtual` is optional for declaring overrides in derived classes,
    which can lead to confusion when dealing with large classes or hierarchies. You
    may need to navigate throughout the hierarchy up to the base to figure out whether
    a function is virtual or not. Conversely, sometimes, it is useful to make sure
    that a virtual function or even a derived class can no longer be overridden or
    derived further. In this recipe, we will see how to use the C++11 special identifiers
    `override` and `final` to declare virtual functions or classes.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他类似的编程语言不同，C++ 没有用于声明接口（基本上是只有纯虚方法的类）的特定语法，并且还有一些与如何声明虚方法相关的缺陷。在 C++ 中，虚方法是通过
    `virtual` 关键字引入的。然而，对于派生类中的重写声明，`virtual` 关键字是可选的，这可能导致在处理大型类或层次结构时产生混淆。您可能需要在整个层次结构中导航到基类，以确定一个函数是否是虚的。相反，有时确保虚函数或派生类不能再被重写或进一步派生是有用的。在这个菜谱中，我们将看到如何使用
    C++11 特殊标识符 `override` 和 `final` 来声明虚函数或类。
- en: Getting ready
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: You should be familiar with inheritance and polymorphism in C++ and concepts
    such as abstract classes, pure specifiers, and virtual and overridden methods.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该熟悉C++中的继承和多态，以及抽象类、纯指定符、虚拟和覆盖方法等概念。
- en: How to do it...
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'To ensure the correct declaration of virtual methods both in base and derived
    classes, also ensuring that you increase readability, do the following:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保在基类和派生类中正确声明虚拟方法，同时确保提高可读性，请执行以下操作：
- en: Aim to use the `virtual` keyword when declaring virtual functions in derived
    classes that are supposed to override virtual functions from a base class.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在派生类中声明虚拟函数时，旨在使用`virtual`关键字，这些虚拟函数应该覆盖基类中的虚拟函数。
- en: 'Always use the `override` special identifier after the declarator part of a
    virtual function’s declaration or definition:'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在虚拟函数的声明或定义的声明部分之后始终使用`override`特殊标识符：
- en: '[PRE78]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The declarator is the part of the type of a function that excludes the return
    type.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 声明符是函数类型的一部分，不包括返回类型。
- en: 'To ensure that functions cannot be overridden further or that classes cannot
    be derived any more, use the `final` special identifier, like this:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保函数不能进一步覆盖或类不能再派生，使用`final`特殊标识符，如下所示：
- en: 'After the declarator part of a virtual function declaration or definition to
    prevent further overrides in a derived class:'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在虚拟函数声明或定义的声明部分之后，以防止在派生类中进一步覆盖：
- en: '[PRE79]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'After the name of a class in the declaration of the class to prevent further
    derivations of the class:'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类声明的类名之后，以防止进一步派生该类：
- en: '[PRE80]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: How it works...
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The way `override` works is very simple; in a virtual function declaration or
    definition, it ensures that the function actually overrides a base class function;
    otherwise, the compiler will trigger an error.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`override`的工作方式非常简单；在虚拟函数的声明或定义中，它确保函数实际上覆盖了基类函数；否则，编译器将触发错误。'
- en: It should be noted that both the `override` and `final` special identifiers
    are special identifiers that have a meaning only in a member function declaration
    or definition. They are not reserved keywords and can still be used elsewhere
    in a program as user-defined identifiers.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，`override`和`final`特殊标识符都是仅在成员函数声明或定义中有意义的特殊标识符。它们不是保留关键字，并且仍然可以在程序的其他地方作为用户定义的标识符使用。
- en: 'Using the `override` special identifier helps the compiler detect situations
    where a virtual method does not override another one, as shown in the following
    example:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`override`特殊标识符有助于编译器检测虚拟方法没有覆盖另一个方法的情况，如下面的示例所示：
- en: '[PRE81]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Without the presence of the `override` specifier, the virtual `bar(char const)`
    method of the `Derived1` class would not be an overridden method but, instead,
    an overload of the `bar()` from `Base`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有`override`指定符的存在，`Derived1`类的虚拟`bar(char const)`方法将不会是一个覆盖方法，而是一个从`Base`类重载的`bar()`方法。
- en: 'The other special identifier, `final`, is used in a member function declaration
    or definition to indicate that the function is virtual and cannot be overridden
    in a derived class. If a derived class attempts to override the virtual function,
    the compiler triggers an error:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个特殊标识符`final`用于成员函数的声明或定义中，以指示该函数是虚拟的，并且在派生类中不能被覆盖。如果派生类尝试覆盖虚拟函数，编译器将触发错误：
- en: '[PRE82]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The `final` specifier can also be used in a class declaration to indicate that
    it cannot be derived:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`final`指定符也可以在类声明中使用，以指示它不能被派生：'
- en: '[PRE83]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Since both `override` and `final` have this special meaning when used in the
    defined context and are not, in fact, reserved keywords, you can still use them
    anywhere else in the C++ code. This ensures that existing code written before
    C++11 does not break because of the use of these names for identifiers:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`override`和`final`在定义的上下文中具有这种特殊含义，并且实际上不是保留关键字，因此您仍然可以在C++代码的任何其他地方使用它们。这确保了在C++11之前编写的现有代码不会因为使用这些名称作为标识符而中断：
- en: '[PRE84]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Although the recommendation given earlier suggested using both `virtual` and
    `override` in the declaration of an overridden virtual method, the `virtual` keyword
    is optional and can be omitted to shorten the declaration. The presence of the
    `override` specifier should be enough to indicate to the reader that the method
    is virtual. This is rather a matter of personal preference and does not affect
    the semantics.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管之前给出的建议建议在重写虚拟方法的声明中使用`virtual`和`override`，但`virtual`关键字是可选的，可以省略以缩短声明。存在`override`指定符应该足以向读者表明该方法虚拟。这更多的是个人偏好的问题，不会影响语义。
- en: See also
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Chapter 10*, *Static polymorphism with the curiously recurring template pattern*,
    to learn how the CRTP pattern helps with implementing polymorphism at compile
    time'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第10章*，*使用curiously recurring template pattern实现静态多态*，了解CRTP模式如何帮助在编译时实现多态'
- en: Using range-based for loops to iterate on a range
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基于范围的for循环遍历范围
- en: Many programming languages support a variant of a `for` loop called `for each`—that
    is, repeating a group of statements over the elements of a collection. C++ did
    not have core language support for this until C++11\. The closest feature was
    the general-purpose algorithm from the standard library called `std::for_each`,
    which applies a function to all the elements in a range. C++11 brought language
    support for `for each` that’s actually called *range-based for loops*. The new
    C++17 standard provides several improvements to the original language feature.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编程语言支持一种名为`for each`的`for`循环变体——即，重复一组语句遍历集合中的元素。C++直到C++11之前都没有对这种功能提供核心语言支持。最接近的功能是标准库中的通用算法`std::for_each`，它将一个函数应用于范围中的所有元素。C++11引入了对`for
    each`的语言支持，实际上称为基于范围的for循环。新的C++17标准为原始语言特性提供了几个改进。
- en: Getting ready
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In C++11, a range-based for loop has the following general syntax:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11中，基于范围的for循环具有以下通用语法：
- en: '[PRE85]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'In C++20, an initialization statement (which must end with a semicolon) can
    be present before the range declaration. Therefore, the general form becomes the
    following:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++20中，初始化语句（必须以分号结束）可以在范围声明之前存在。因此，一般形式变为以下内容：
- en: '[PRE86]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'To exemplify the various ways of using range-based for loops, we will use the
    following functions, which return sequences of elements:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明使用基于范围的for循环的各种方式，我们将使用以下函数，它们返回元素序列：
- en: '[PRE87]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: In the next section, we’ll look at the various ways we can use range-based for
    loops.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨我们可以使用基于范围的for循环的各种方式。
- en: How to do it...
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Range-based for loops can be used in various ways:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 基于范围的for循环可以用各种方式使用：
- en: 'By committing to a specific type for the elements of the sequence:'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过为序列的元素指定特定类型：
- en: '[PRE88]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'By not specifying a type and letting the compiler deduce it:'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过不指定类型，让编译器推断它：
- en: '[PRE89]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'By using structured bindings and decomposition declaration in C++17:'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在C++17中使用结构化绑定和分解声明：
- en: '[PRE90]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: How it works...
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The expression for the range-based for loops shown earlier in the *How to do
    it...* section is basically syntactic sugar, as the compiler transforms it into
    something else. Before C++17, the code generated by the compiler used to be the
    following:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在*如何做到这一点...*部分之前显示的基于范围的for循环的表达式基本上是语法糖，因为编译器将其转换为其他内容。在C++17之前，编译器生成的代码通常是以下内容：
- en: '[PRE91]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'What `begin_expr` and `end_expr` are in this code depends on the type of the
    range:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`begin_expr`和`end_expr`在这个代码中的含义取决于范围类型：'
- en: 'For C-like arrays: `__range` and `__range + __bound` (where `__bound` is the
    number of elements in the array).'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于C样式的数组：`__range`和`__range + __bound`（其中`__bound`是数组中元素的数量）。
- en: 'For a class type with `begin` and `end` members (regardless of their type and
    accessibility): `__range.begin()` and `__range.end()`.'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于具有`begin`和`end`成员的类类型（无论其类型和可访问性）：`__range.begin()`和`__range.end()`。
- en: For others, it is `begin(__range)` and `end(__range)`, which are determined
    via argument-dependent lookup.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于其他情况，它是`begin(__range)`和`end(__range)`，这些是通过参数依赖查找确定的。
- en: It is important to note that if a class contains any members (function, data
    member, or enumerators) called `begin` or `end`, regardless of their type and
    accessibility, they will be picked for `begin_expr` and `end_expr`. Therefore,
    such a class type cannot be used in range-based for loops.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，如果一个类包含任何名为`begin`或`end`的成员（函数、数据成员或枚举器），无论其类型和可访问性如何，它们将被用于`begin_expr`和`end_expr`。因此，这种类类型不能用于基于范围的for循环。
- en: 'In C++17, the code generated by the compiler is slightly different:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17中，编译器生成的代码略有不同：
- en: '[PRE92]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The new standard has removed the constraint that the `begin` expression and
    the `end` expression must be the same type. The end expression does not need to
    be an actual iterator, but it has to be able to be compared for inequality with
    an iterator. A benefit of this is that the range can be delimited by a predicate.
    Conversely, the `end` expression is only evaluated once, and not every time the
    loop is iterated, which could potentially increase performance.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 新标准已经取消了 `begin` 表达式和 `end` 表达式必须是相同类型的约束。`end` 表达式不需要是一个实际的迭代器，但它必须能够与迭代器进行比较。这个好处是范围可以通过谓词来界定。相反，`end`
    表达式只计算一次，而不是每次循环迭代时都计算，这可能会提高性能。
- en: 'As mentioned in the previous section, in C++20, an initialization statement
    can be present before the range declaration. This has the effect that the compiler-generated
    code for a range-based for loop has the following form:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在C++20中，范围声明之前可以有一个初始化语句。这导致编译器为基于范围的for循环生成的代码具有以下形式：
- en: '[PRE93]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The initialization statement can be an empty statement, an expression statement,
    a simple declaration, or, starting with C++23, an alias declaration. An example
    is shown in the following snippet:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化语句可以是一个空语句、表达式语句、简单声明，或者从C++23开始，是一个别名声明。以下是一个示例：
- en: '[PRE94]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Prior to C++23, this was helpful to avoid undefined behavior with temporaries
    in range expressions. The lifetime of a temporary returned by the `range-expression`
    is extended until the end of the loop. However, the lifetime of temporaries within
    the `range-expression` is not extended if they will be destroyed at the end of
    `range-expression`.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++23之前，这有助于避免范围表达式中的临时变量引起的未定义行为。`range-expression` 返回的临时变量的生命周期被扩展到循环结束。然而，如果它们将在
    `range-expression` 结束时被销毁，则不会扩展 `range-expression` 内部临时变量的生命周期。
- en: 'We will explain this with the help of the following snippet:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下代码片段来解释这一点：
- en: '[PRE95]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Since `make_item()` returns by value, we have a temporary within `range-expression`.
    This introduces undefined behavior, which can be avoided with an initialization
    statement, as follows:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `make_item()` 通过值返回，我们在 `range-expression` 中有一个临时变量。这引入了未定义的行为，可以通过以下初始化语句避免：
- en: '[PRE96]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: This problem no longer manifests in C++23, because this version of the standard
    also extends the lifetime of all the temporaries within the `range-expression`
    until the end of the loop.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++23中，这个问题不再出现，因为该版本的规范还扩展了 `range-expression` 中所有临时变量的生命周期，直到循环结束。
- en: See also
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Enabling range-based for loops for custom types*, to see how to make it possible
    for user-defined types to be used with range-based for loops'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为自定义类型启用基于范围的for循环*，了解如何使用户定义的类型能够与基于范围的for循环一起使用'
- en: '*Chapter 12*, *Iterating over collections with the ranges library*, to learn
    about the fundamentals of the C++20 ranges library'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第12章*，*使用范围库遍历集合*，了解C++20范围库的基本知识'
- en: '*Chapter 12*, *Creating your own range view*, to see how to extend the C++20
    range library’s capabilities with user-defined range adaptors'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第12章*，*创建自己的范围视图*，了解如何通过用户定义的范围适配器扩展C++20范围库的功能'
- en: Enabling range-based for loops for custom types
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为自定义类型启用基于范围的for循环
- en: As we saw in the preceding recipe, range-based for loops, known as `for each`
    in other programming languages, allow you to iterate over the elements of a range,
    providing a simplified syntax over the standard `for` loops and making the code
    more readable in many situations. However, range-based for loops do not work out
    of the box with any type representing a range, but require the presence of `begin()`
    and `end()` functions (for non-array types), either as a member or free function.
    In this recipe, we will learn how to enable a custom type to be used in range-based
    for loops.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的配方中看到的，基于范围的for循环，在其他编程语言中称为 `for each`，允许您遍历范围中的元素，提供了一种比标准 `for` 循环更简化的语法，并在许多情况下使代码更易于阅读。然而，基于范围的for循环并不与任何表示范围的类型直接工作，而是需要存在
    `begin()` 和 `end()` 函数（对于非数组类型），无论是作为成员函数还是自由函数。在本配方中，我们将学习如何使自定义类型能够在基于范围的for循环中使用。
- en: Getting ready
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: It is recommended that you read the *Using range-based for loops to iterate
    on a range* recipe before continuing with this one if you need to understand how
    range-based for loops work, as well as what code the compiler generates for such
    a loop.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要了解基于范围的for循环如何工作，以及编译器为这种循环生成的代码，建议在继续阅读本部分之前先阅读 *使用基于范围的for循环遍历范围* 的配方。
- en: 'To show how we can enable range-based for loops for custom types representing
    sequences, we will use the following implementation of a simple array:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示我们如何为表示序列的自定义类型启用基于范围的for循环，我们将使用以下简单数组的实现：
- en: '[PRE97]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The purpose of this recipe is to enable writing code like the following:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的目的是使编写如下代码成为可能：
- en: '[PRE98]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The steps necessary to make all this possible are described in detail in the
    following section.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 实现所有这些所需步骤的详细描述将在以下章节中介绍。
- en: How to do it...
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To enable a custom type to be used in range-based `for` loops, you need to
    do the following:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 要使自定义类型能够用于基于范围的 `for` 循环，你需要做以下事情：
- en: 'Create mutable and constant iterators for the type, which must implement the
    following operators:'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为该类型创建可变和常量迭代器，这些迭代器必须实现以下运算符：
- en: '`operator++` (both the prefix and the postfix version) for incrementing the
    iterator'
  id: totrans-405
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator++`（前缀和后缀版本）用于递增迭代器'
- en: '`operator*` for dereferencing the iterator and accessing the actual element
    being pointed to by the iterator'
  id: totrans-406
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator*` 用于解引用迭代器并访问迭代器所指向的实际元素'
- en: '`operator!=` for comparing the iterator with another iterator for inequality'
  id: totrans-407
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator!=` 用于比较迭代器与另一个迭代器以进行不等性比较'
- en: Provide free `begin()` and `end()` functions for the type.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为该类型提供免费的 `begin()` 和 `end()` 函数。
- en: 'Given the earlier example of a simple range, we need to provide the following:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 给定前面的简单范围示例，我们需要提供以下内容：
- en: 'The following minimal implementation of an iterator class:'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是一个迭代器类的最小实现：
- en: '[PRE99]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Alias templates for mutable and constant iterators:'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变和常量迭代器的别名模板：
- en: '[PRE100]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Free `begin()` and `end()` functions that return the respective begin and end
    iterators, with overloads for both alias templates:'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供免费的 `begin()` 和 `end()` 函数，这些函数返回相应的开始和结束迭代器，并为这两个别名模板提供重载：
- en: '[PRE101]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: How it works...
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: Having this implementation available, the range-based for loop shown earlier
    compiles and executes as expected. When performing an argument-dependent lookup,
    the compiler will identify the two `begin()` and `end()` functions that we wrote
    (which take a reference to a `dummy_array`), and therefore, the code it generates
    becomes valid.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在此实现可用的情况下，前面展示的基于范围的for循环将按预期编译和执行。在执行参数依赖查找时，编译器将识别我们编写的两个 `begin()` 和 `end()`
    函数（它们接受对 `dummy_array` 的引用），因此，它生成的代码是有效的。
- en: In the preceding example, we have defined one iterator class template and two
    alias templates, called `dummy_array_iterator` and `dummy_array_const_iterator`.
    The `begin()` and `end()` functions both have two overloads for these two types
    of iterators.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们定义了一个迭代器类模板和两个别名模板，分别称为 `dummy_array_iterator` 和 `dummy_array_const_iterator`。`begin()`
    和 `end()` 函数都有这两种迭代器类型的两个重载。
- en: 'This is necessary so that the container we have considered can be used in range-based
    for loops with both constant and non-constant instances:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有必要的，这样我们考虑的容器就可以在基于范围的for循环中与常量和非常量实例一起使用：
- en: '[PRE102]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: A possible alternative to enable range-based for loops for the simple range
    class we considered for this recipe is to provide the member `begin()` and `end()`
    functions. In general, that will make sense only if you own and can modify the
    source code. Conversely, the solution shown in this recipe works in all cases
    and should be preferred to other alternatives.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使简单范围类能够使用基于范围的for循环，我们考虑的一个可能的替代方案是提供成员函数 `begin()` 和 `end()`。一般来说，这只有在你可以拥有并修改源代码的情况下才有意义。相反，本食谱中展示的解决方案适用于所有情况，并且应该优先于其他替代方案。
- en: See also
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Creating type aliases and alias templates*, to learn about aliases for types'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建类型别名和别名模板*，了解类型别名的知识'
- en: '*Chapter 12*, *Iterating over collections with the ranges library*, to learn
    about the fundamentals of the C++20 ranges library'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第12章*，*使用ranges库遍历集合*，了解C++20 ranges库的基本知识'
- en: Using explicit constructors and conversion operators to avoid implicit conversion
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用显式构造函数和转换运算符来避免隐式转换
- en: Before C++11, a constructor with a single parameter was considered a converting
    constructor (because it takes a value of another type and creates a new instance
    of the class out of it). With C++11, every constructor without the `explicit`
    specifier is considered a converting constructor. This is important because such
    a constructor defines an implicit conversion from the type or types of its arguments
    to the type of the class. Classes can also define converting operators that convert
    the type of the class to another specified type. All of these are useful in some
    cases but can create problems in other cases. In this recipe, we will learn how
    to use explicit constructors and conversion operators.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11之前，只有一个参数的构造函数被认为是转换构造函数（因为它接受另一个类型的值并从中创建一个新的类实例）。从C++11开始，每个没有`explicit`指定符的构造函数都被认为是转换构造函数。这很重要，因为这样的构造函数定义了从其参数类型或类型到类类型的隐式转换。类还可以定义将类类型转换为另一个指定类型的转换运算符。所有这些在某些情况下都是有用的，但在其他情况下可能会造成问题。在这个食谱中，我们将学习如何使用显式构造函数和转换运算符。
- en: Getting ready
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you need to be familiar with converting constructors and converting
    operators. In this recipe, you will learn how to write explicit constructors and
    conversion operators to avoid implicit conversions to and from a type. The use
    of explicit constructors and conversion operators (called *user-defined conversion
    functions*) enables the compiler to yield errors—which, in some cases, are coding
    errors—and allow developers to spot those errors quickly and fix them.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，你需要熟悉构造函数和转换运算符的转换。在这个食谱中，你将学习如何编写显式构造函数和转换运算符以避免隐式转换到或从某个类型。显式构造函数和转换运算符（称为*用户定义的转换函数*）的使用使得编译器能够产生错误——在某些情况下，这些错误是编码错误——并允许开发者快速发现这些错误并修复它们。
- en: How to do it...
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: To declare explicit constructors and explicit conversion operators (regardless
    of whether they are functions or function templates), use the `explicit` specifier
    in the declaration.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明显式构造函数和显式转换运算符（无论它们是函数还是函数模板），在声明中使用`explicit`指定符。
- en: 'The following example shows both an explicit constructor and an explicit converting
    operator:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了显式构造函数和显式转换运算符：
- en: '[PRE103]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: How it works...
  id: totrans-433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To understand why explicit constructors are necessary and how they work, we
    will first look at converting constructors. The following class, `foo`, has three
    constructors: a default constructor (without parameters), a constructor that takes
    an `int`, and a constructor that takes two parameters, an `int` and a `double`.
    They don’t do anything except print a message. As of C++11, these are all considered
    converting constructors. The class also has a conversion operator that converts
    a value of the `foo` type to a `bool`:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解显式构造函数的必要性以及它们是如何工作的，我们首先将查看转换构造函数。以下名为`foo`的类有三个构造函数：一个不带参数的默认构造函数、一个接受`int`的构造函数和一个接受两个参数（一个`int`和一个`double`）的构造函数。它们除了打印一条消息外不做任何事情。截至C++11，这些都被认为是转换构造函数。该类还有一个转换运算符，它将`foo`类型的值转换为`bool`：
- en: '[PRE104]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Based on this, the following definitions of objects are possible (note that
    the comments represent the console’s output):'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，以下对象的定义是可能的（注意，注释代表控制台的输出）：
- en: '[PRE105]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The variables `f1` and `f2` invoke the default constructor. `f3`, `f4`, `f5`,
    and `f6` invoke the constructor that takes an `int`. Note that all the definitions
    of these objects are equivalent, even if they look different (`f3` is initialized
    using the functional form, `f4` and `f6` are copy initialized, and `f5` is directly
    initialized using brace-init-list). Similarly, `f7`, `f8`, and `f9` invoke the
    constructor with two parameters.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`f1`和`f2`调用默认构造函数。`f3`、`f4`、`f5`和`f6`调用接受`int`的构造函数。请注意，所有这些对象的定义都是等效的，尽管它们看起来不同（`f3`使用函数形式初始化，`f4`和`f6`是复制初始化，而`f5`直接使用花括号初始化列表初始化）。同样，`f7`、`f8`和`f9`调用具有两个参数的构造函数。
- en: In this case, `f5` and `f6` will `print foo(l)`, while `f8` and `f9` will generate
    compiler errors (although compilers may have options to ignore some warnings,
    such as `-Wno-narrowing` for GCC) because all the elements of the initializer
    list should be integers.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`f5`和`f6`将`print foo(l)`，而`f8`和`f9`将生成编译器错误（尽管编译器可能有选项忽略一些警告，例如GCC的`-Wno-narrowing`），因为初始化列表中的所有元素都应该为整数。
- en: 'It may be important to note that if `foo` defines a constructor that takes
    a `std::initializer_list`, then all the initializations using `{}` would resolve
    to that constructor:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 可能需要注意，如果`foo`定义了一个接受`std::initializer_list`的构造函数，那么所有使用`{}`的初始化都将解析为该构造函数：
- en: '[PRE106]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'These may all look right, but the implicit conversion constructors enable scenarios
    where the implicit conversion may not be what we wanted. First, let’s look at
    some correct examples:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可能看起来都是正确的，但隐式转换构造函数允许出现隐式转换可能不是我们想要的情况。首先，让我们看看一些正确的例子：
- en: '[PRE107]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The conversion operator to `bool` from the `foo` class also enables us to use
    `foo` objects where Boolean values are expected. Here is an example:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '`foo`类到`bool`的转换运算符也使我们能够在期望布尔值的地方使用`foo`对象。以下是一个例子：'
- en: '[PRE108]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The first two are examples where `foo` is expected to be used as a Boolean.
    However, the last two, one with addition and one with a test for equality, are
    probably incorrect, as we most likely expect to add `foo` objects and test `foo`
    objects for equality, not the Booleans they implicitly convert to.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个例子是`foo`被期望用作布尔值的例子。然而，最后两个，一个用于加法和一个用于测试相等性，可能是不正确的，因为我们最可能期望添加`foo`对象并测试`foo`对象是否相等，而不是它们隐式转换成的布尔值。
- en: Perhaps a more realistic example to understand where problems could arise would
    be to consider a string buffer implementation. This would be a class that contains
    an internal buffer of characters.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 可能一个更现实的例子来理解可能出现问题的场景是考虑一个字符串缓冲区实现。这将是一个包含字符内部缓冲区的类。
- en: 'This class provides several conversion constructors: a default constructor,
    a constructor that takes a `size_t` parameter representing the size of the buffer
    to pre-allocate, and a constructor that takes a pointer to `char`, which should
    be used to allocate and initialize the internal buffer. Succinctly, the implementation
    of the string buffer that we use for this exemplification looks like this:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 本类提供了几个转换构造函数：一个默认构造函数，一个接受一个表示预分配缓冲区大小的`size_t`参数的构造函数，以及一个接受`char`指针的构造函数，该指针应用于分配和初始化内部缓冲区。简而言之，我们用于本例的字符串缓冲区实现看起来如下：
- en: '[PRE109]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Based on this definition, we could construct the following objects:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个定义，我们可以构造以下对象：
- en: '[PRE110]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The object `b1` is created using the default constructor and, thus, has an
    empty buffer; `b2` is initialized using the constructor with a single parameter,
    where the value of the parameter represents the size in terms of the characters
    of the internal buffer; and `b3` is initialized with an existing buffer, which
    is used to define the size of the internal buffer and copy its value into the
    internal buffer. However, the same definition also enables the following object
    definitions:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 对象`b1`使用默认构造函数创建，因此具有空缓冲区；`b2`使用单参数构造函数进行初始化，其中参数的值表示内部缓冲区的字符大小；`b3`使用现有的缓冲区进行初始化，该缓冲区用于定义内部缓冲区的大小并将值复制到内部缓冲区。然而，相同的定义也允许以下对象定义：
- en: '[PRE111]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: In this case, `b4` is initialized with a `char`. Since an implicit conversion
    to `size_t` exists, the constructor with a single parameter will be called. The
    intention here is not necessarily clear; perhaps it should have been `"a"` instead
    of `'a'`, in which case the third constructor would have been called.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`b4`使用一个`char`进行初始化。由于存在到`size_t`的隐式转换，将调用单参数的构造函数。这里的意图不一定清楚；也许它应该是`"a"`而不是`'a'`，在这种情况下，将调用第三个构造函数。
- en: However, `b5` is most likely an error, because `MaxSize` is an enumerator representing
    an `ItemSizes` and should have nothing to do with a string buffer size. These
    erroneous situations are not flagged by the compiler in any way. The implicit
    conversion of unscoped enums to `int` is a good argument for preferring to use
    scoped enums (declared with enum class), which do not have this implicit conversion.
    If `ItemSizes` was a scoped enum, the situation described here would not appear.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`b5`很可能是错误，因为`MaxSize`是一个表示`ItemSizes`的枚举器，应该与字符串缓冲区大小无关。这些错误情况在编译器中没有任何标记。未限定的枚举到`int`的隐式转换是倾向于使用限定的枚举（使用`enum
    class`声明的）的一个很好的论据，因为它们没有这种隐式转换。如果`ItemSizes`是一个限定的枚举，那么这里描述的情况就不会出现。
- en: 'When using the `explicit` specifier in the declaration of a constructor, that
    constructor becomes an explicit constructor and no longer allows implicit constructions
    of objects of a `class` type. To exemplify this, we will slightly change the `string_buffer`
    class to declare all constructors as `explicit`:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '当在构造函数的声明中使用 `explicit` 指定时，该构造函数成为显式构造函数，不再允许对 `class` 类型的对象进行隐式构造。为了说明这一点，我们将稍微修改
    `string_buffer` 类以声明所有构造函数为 `explicit`:'
- en: '[PRE112]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The change here is minimal, but the definitions of `b4` and `b5` in the earlier
    example no longer work and are incorrect. This is because the implicit conversions
    from `char` or `int` to `size_t` are no longer available during overload resolution
    to figure out what constructor should be called. The result is compiler errors
    for both `b4` and `b5`. Note that `b1`, `b2`, and `b3` are still valid definitions,
    even if the constructors are explicit.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的变化很小，但之前示例中 `b4` 和 `b5` 的定义不再有效且是错误的。这是因为重载解析期间不再可用从 `char` 或 `int` 到 `size_t`
    的隐式转换来确定应该调用哪个构造函数。结果是 `b4` 和 `b5` 都会出现编译错误。请注意，即使构造函数是显式的，`b1`、`b2` 和 `b3` 仍然是有效的定义。
- en: 'The only way to fix the problem, in this case, is to provide an explicit cast
    from `char` or `int` to `string_buffer`:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，解决问题的唯一方法是从 `char` 或 `int` 显式转换为 `string_buffer`:'
- en: '[PRE113]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: With explicit constructors, the compiler is able to immediately flag erroneous
    situations and developers can react accordingly, either fixing the initialization
    with a correct value or providing an explicit cast.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 使用显式构造函数，编译器能够立即标记出错误情况，开发者可以相应地做出反应，要么使用正确的值修复初始化，要么提供显式转换。
- en: This is only the case when initialization is done with copy initialization and
    not when using functional or universal initialization.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅在用复制初始化进行初始化时才成立，而不是在使用函数式或通用初始化时。
- en: 'The following definitions are still possible (but wrong) with explicit constructors:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 以下定义仍然可能（但错误）使用显式构造函数：
- en: '[PRE114]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Similar to constructors, conversion operators can be declared explicit (as
    shown earlier). In this case, the implicit conversions from the object type to
    the type specified by the conversion operator are no longer possible and require
    an explicit cast. Considering `b1` and `b2`, which are the `string_buffer` objects
    we defined earlier, the following is no longer possible with an explicit `operator
    bool` conversion:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 与构造函数类似，转换运算符可以被声明为显式（如前所述）。在这种情况下，从对象类型到转换运算符指定的类型的隐式转换不再可能，需要显式转换。考虑到 `b1`
    和 `b2`，它们是我们之前定义的 `string_buffer` 对象，以下使用显式 `operator bool` 转换将不再可能：
- en: '[PRE115]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Instead, they require explicit conversion to `bool`:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '相反，它们需要显式转换为 `bool`:'
- en: '[PRE116]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The addition of two `bool` values does not make much sense. The preceding example
    is intended only to show how an explicit cast is required in order to make the
    statement compile. The error issued by the compiler when there is no explicit
    static cast should help you figure out that the expression itself is wrong and
    something else was probably intended.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 `bool` 值相加没有太多意义。前面的示例仅用于说明为了使语句编译，需要显式转换。当没有显式静态转换时，编译器发出的错误可以帮助你确定表达式本身是错误的，可能原本意图是其他内容。
- en: See also
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Understanding uniform initialization*, to see how brace-initialization works'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*理解统一初始化*，以了解花括号初始化是如何工作的'
- en: Using unnamed namespaces instead of static globals
  id: totrans-472
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用无名命名空间而不是静态全局变量
- en: The larger a program, the greater the chance that you could run into name collisions
    when your program is linked to multiple translation units. Functions or variables
    that are declared in a source file, intended to be local to the translation unit,
    may collide with other similar functions or variables declared in another translation
    unit.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 程序越大，当你的程序链接到多个翻译单元时遇到名称冲突的可能性就越大。在源文件中声明的函数或变量，目的是在翻译单元内部局部使用，可能与另一个翻译单元中声明的其他类似函数或变量冲突。
- en: That is because all the symbols that are not declared static have external linkage,
    and their names must be unique throughout the program. The typical C solution
    for this problem is to declare those symbols as static, changing their linkage
    from external to internal and, therefore, making them local to a translation unit.
    An alternative is to prefix the names with the name of the module or library they
    belong to. In this recipe, we will look at the C++ solution for this problem.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为所有未声明为静态的符号都具有外部链接，并且它们的名称必须在整个程序中是唯一的。C语言解决这个问题的典型方法是将这些符号声明为静态，将它们的链接从外部更改为内部，因此使它们成为翻译单元的本地符号。另一种选择是在名称前加上它们所属的模块或库的名称。在本菜谱中，我们将探讨C++解决这个问题的方法。
- en: Getting ready
  id: totrans-475
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will discuss concepts such as global functions and static
    functions, as well as variables, namespaces, and translation units. We expect
    that you have a basic understanding of these concepts. Apart from these, it is
    required that you understand the difference between internal and external linkage;
    this is key for this recipe.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将讨论诸如全局函数和静态函数、变量、命名空间和翻译单元等概念。我们期望你已经对这些概念有基本的了解。除此之外，你还必须理解内部链接和外部链接之间的区别；这对于本菜谱至关重要。
- en: How to do it...
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'When you are in a situation where you need to declare global symbols as static
    to avoid linkage problems, you should prefer to use unnamed namespaces:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处于需要将全局符号声明为静态以避免链接问题的情境时，你应该优先使用无名的命名空间：
- en: Declare a namespace without a name in your source file.
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的源文件中声明一个无名的命名空间。
- en: Put the definition of the global function or variable in the unnamed namespace
    without making it `static`.
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将全局函数或变量的定义放在无名的命名空间中，而不将其声明为 `static`。
- en: 'The following example shows two functions called `print()` in two different
    translation units; each of them is defined in an unnamed namespace:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了在两个不同的翻译单元中调用名为 `print()` 的两个函数；每个函数都在一个无名的命名空间中定义：
- en: '[PRE117]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: How it works...
  id: totrans-483
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When a function is declared in a translation unit, it has an external linkage.
    This means two functions with the same name from two different translation units
    would generate a linkage error because it is not possible to have two symbols
    with the same name. The way this problem is solved in C, and sometimesin C++ also,
    is to declare the function or variable as static and change its linkage from external
    to internal. In this case, its name is no longer exported outside the translation
    unit, and the linkage problem is avoided.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数在翻译单元中声明时，它具有外部链接。这意味着来自两个不同翻译单元的两个具有相同名称的函数将生成链接错误，因为不可能有两个具有相同名称的符号。在C语言中解决这个问题，有时在C++中也是如此，是将函数或变量声明为静态，并将它的链接从外部更改为内部。在这种情况下，它的名称不再导出至翻译单元之外，从而避免了链接问题。
- en: 'The proper solution in C++ is to use unnamed namespaces. When you define a
    namespace like the ones shown previously, the compiler transforms it into the
    following:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，正确的解决方案是使用无名的命名空间。当你定义一个类似于前面展示的命名空间时，编译器将其转换成以下形式：
- en: '[PRE118]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: First of all, it declares a namespace with a unique name (what the name is and
    how it generates that name is a compiler implementation detail and should not
    be a concern). At this point, the namespace is empty, and the purpose of this
    line is to basically establish the namespace. Second, a `using` directive brings
    everything from the `_unique_name_` namespace into the current namespace. Third,
    the namespace, with the compiler-generated name, is defined as it was in the original
    source code (when it had no name).
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它声明了一个具有唯一名称的命名空间（名称是什么以及它是如何生成该名称的是编译器实现细节，不应成为关注点）。在这个时候，命名空间是空的，这一行的目的是基本建立命名空间。其次，一个
    `using` 指令将 `_unique_name_` 命名空间中的所有内容引入当前命名空间。第三，具有编译器生成的名称的命名空间被定义为它原始源代码中的样子（当它没有名称时）。
- en: By defining the translation unit local `print()` functions in an unnamed namespace,
    they have local visibility only, yet their external linkage no longer produces
    linkage errors, since they now have external unique names.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在无名的命名空间中定义翻译单元本地的 `print()` 函数，它们只有本地可见性，但它们的链接外部性不再产生链接错误，因为它们现在具有外部唯一名称。
- en: 'Unnamed namespaces also work in a perhaps more obscure situation involving
    templates. Prior to C++11, template non-type arguments could not be names with
    internal linkage, so using static variables was not possible. Conversely, symbols
    in an unnamed namespace have external linkage and could be used as template arguments.
    Although this linkage restriction for template non-type arguments was lifted in
    C++11, it is still present in the latest version of the VC++ compiler. This problem
    is shown in the following example:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 无名命名空间在涉及模板的某些更不明显的情况下也有效。在C++11之前，模板的非类型参数不能具有内部链接的名称，因此使用静态变量是不可能的。相反，无名命名空间中的符号具有外部链接，可以用作模板参数。尽管模板非类型参数的这种链接限制在C++11中被取消，但在最新的VC++编译器版本中仍然存在。以下示例展示了这个问题：
- en: '[PRE119]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: See also
  id: totrans-491
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using inline namespaces for symbol versioning*, to learn how to version your
    source code using inline namespaces and conditional compilation'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用内联命名空间进行符号版本化*，了解如何使用内联命名空间和条件编译来对源代码进行版本控制'
- en: Using inline namespaces for symbol versioning
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内联命名空间进行符号版本化
- en: The C++11 standard has introduced a new type of namespace called *inline namespaces*,
    which are basically a mechanism that makes declarations from a nested namespace
    look and act like they were part of the surrounding namespace. Inline namespaces
    are declared using the `inline` keyword in the namespace declaration (unnamed
    namespaces can also be inlined). This is a helpful feature for library versioning,
    and in this recipe, we will learn how inline namespaces can be used for versioning
    symbols. From this recipe, you will learn how to version your source code using
    inline namespaces and conditional compilation.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: C++11标准引入了一种新的命名空间类型，称为*内联命名空间*，它基本上是一种机制，使得嵌套命名空间中的声明看起来和表现得像它们是周围命名空间的一部分。内联命名空间使用命名空间声明中的`inline`关键字来声明（无名命名空间也可以内联）。这是一个有助于库版本化的特性，在本食谱中，我们将学习如何使用内联命名空间进行符号版本化。通过本食谱，你将学习如何使用内联命名空间和条件编译来对源代码进行版本控制。
- en: Getting ready
  id: totrans-495
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will discuss namespaces and nested namespaces, templates
    and template specializations, and conditional compilation using preprocessor macros.
    Familiarity with these concepts is required in order to proceed with this recipe.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将讨论命名空间和嵌套命名空间、模板和模板特化，以及使用预处理器宏进行条件编译。为了继续本食谱，对这些概念的了解是必要的。
- en: How to do it...
  id: totrans-497
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To provide multiple versions of a library and let the user decide what version
    to use, do the following:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供库的多个版本并让用户决定使用哪个版本，请执行以下操作：
- en: Define the content of the library inside a namespace.
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命名空间内定义库的内容。
- en: Define each version of the library or parts of it inside an inner inline namespace.
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内部内联命名空间内定义库的每个版本或其部分。
- en: Use preprocessor macros and `#if` directives to enable a particular version
    of the library.
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用预处理器宏和`#if`指令来启用库的特定版本。
- en: 'The following example shows a library that has two versions that clients can
    use:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了一个库有两个版本，客户端可以使用：
- en: '[PRE120]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: How it works...
  id: totrans-504
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A member of an inline namespace is treated as if it were a member of the surrounding
    namespace. Such a member can be partially specialized, explicitly instantiated,
    or explicitly specialized. This is a transitive property, which means that if
    a namespace, `A`, contains an inline namespace, `B`, that contains an inline namespace,
    `C`, then the members of `C` appear as they were members of both `B` and `A` and
    the members of `B` appear as they were members of `A`.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 内联命名空间的一个成员被视为周围命名空间的一个成员。这样的成员可以是部分特化的、显式实例化的或显式特化的。这是一个传递属性，这意味着如果命名空间`A`包含一个内联命名空间`B`，而`B`又包含一个内联命名空间`C`，那么`C`的成员将作为`B`和`A`的成员出现，而`B`的成员将作为`A`的成员出现。
- en: 'To better understand why inline namespaces are helpful, let’s consider the
    case of developing a library that evolves over time from a first version to a
    second version (and further on). This library defines all its types and functions
    under a namespace called `modernlib`. In the first version, this library could
    look like this:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解内联命名空间为什么有用，让我们考虑一个案例，即开发一个随着时间的推移从第一个版本到第二个版本（以及更进一步的）演变的库。这个库在其名为`modernlib`的命名空间下定义了所有其类型和函数。在第一个版本中，这个库可能看起来像这样：
- en: '[PRE121]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'A client of the library can make the following call and get back the value
    `1`:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 库的客户端可以执行以下调用并返回值`1`：
- en: '[PRE122]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'However, the client might decide to specialize the template function `test()`
    as follows:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，客户端可能会决定如下特化模板函数 `test()`：
- en: '[PRE123]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: In this case, the value of `y` is no longer `1` but `42` instead because the
    user-specialized function gets called.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`y` 的值不再是 `1`，而是 `42`，因为调用了用户特定的函数。
- en: Everything is working correctly so far, but as a library developer, you decide
    to create a second version of the library, yet still ship both the first and the
    second version and let the user control what to use with a macro. In this second
    version, you provide a new implementation of the `test()` function that no longer
    returns `1` but `2` instead.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切正常，但作为库的开发者，你决定创建库的第二个版本，同时仍然提供第一个和第二个版本，并让用户通过宏来控制使用哪个版本。在这个第二个版本中，你提供了一个新的
    `test()` 函数实现，它不再返回 `1`，而是返回 `2`。
- en: 'To be able to provide both the first and second implementations, you put them
    in nested namespaces called `version_1` and `version_2` and conditionally compile
    the library using preprocessor macros:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够提供第一个和第二个实现，你将它们放在名为 `version_1` 和 `version_2` 的嵌套命名空间中，并使用预处理器宏条件编译库：
- en: '[PRE124]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Suddenly, the client code breaks, regardless of whether it uses the first or
    second version of the library. This is because the test function is now inside
    a nested namespace, and the specialization for `foo` is done in the `modernlib`
    namespace, when it should actually be done in `modernlib::version_1` or `modernlib::version_2`.
    This is because the specialization of a template is required to be done in the
    same namespace where the template was declared.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 突然之间，客户端代码崩溃了，无论它使用库的第一个版本还是第二个版本。这是因为测试函数现在位于嵌套命名空间内部，而 `foo` 的特化是在 `modernlib`
    命名空间中完成的，而实际上它应该在 `modernlib::version_1` 或 `modernlib::version_2` 中完成。这是因为模板的特化必须在声明模板的同一命名空间中完成。
- en: 'In this case, the client needs to change the code, like this:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，客户端需要更改代码，如下所示：
- en: '[PRE125]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: This is a problem because the library leaks implementation details, and the
    client needs to be aware of those in order to do template specialization. These
    internal details are hidden with inline namespaces in the manner shown in the
    *How to do it...* section of this recipe. With that definition of the `modernlib`
    library, the client code with the specialization of the `test()` function in the
    `modernlib` namespace is no longer broken, because either `version_1::test()`
    or `version_2::test()` (depending on what version the client actually uses) acts
    as if it is part of the enclosing `modernlib` namespace when template specialization
    is done. The details of the implementation are now hidden to the client, who only
    sees the surrounding namespace, `modernlib`.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个问题，因为库泄露了实现细节，客户端需要了解这些细节才能进行模板特化。这些内部细节在 *如何做...* 部分的示例中以内联命名空间的方式被隐藏起来。根据对
    `modernlib` 库的定义，具有在 `modernlib` 命名空间中特化 `test()` 函数的客户端代码不再崩溃，因为 `version_1::test()`
    或 `version_2::test()`（取决于客户端实际使用的版本）在模板特化时表现得像它是封装的 `modernlib` 命名空间的一部分。现在，实现细节对客户端是隐藏的，客户端只能看到周围的命名空间
    `modernlib`。
- en: However, you should keep in mind that the namespace `std` is reserved for the
    standard and should never be inlined. Also, a namespace should not be defined
    inline if it was not inline in its first definition.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你应该记住，命名空间 `std` 是为标准保留的，永远不应该内联。此外，如果一个命名空间在其第一次定义时不是内联的，那么它也不应该内联定义。
- en: See also
  id: totrans-521
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using unnamed namespaces instead of static globals*, to explore anonymous
    namespaces and learn how they help'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用未命名的命名空间而不是静态全局变量*，探索匿名命名空间并了解它们如何帮助'
- en: '*Chapter 4*, *Conditionally compiling your source code*, to learn the various
    options for performing conditional compilation'
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第4章*，*条件编译源代码*，了解执行条件编译的各种选项'
- en: Using structured bindings to handle multi-return values
  id: totrans-524
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用结构化绑定来处理多返回值
- en: Returning multiple values from a function is very common, yet there is no first-class
    solution in C++ to make it possible in a straightforward way. Developers have
    to choose between returning multiple values through reference parameters to a
    function, defining a structure to contain the multiple values, or returning a
    `std::pair` or `std::tuple`. The first two use named variables, which gives them
    the advantage that they clearly indicate the meaning of the return value, but
    have the disadvantage that they have to be explicitly defined. `std::pair` has
    its members called `first` and `second`, while `std::tuple` has unnamed members
    that can only be retrieved with a function call but can be copied to named variables,
    using `std::tie()`. None of these solutions are ideal.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 从函数中返回多个值是非常常见的，但在 C++ 中没有第一类解决方案可以使其以简单的方式实现。开发者必须在通过函数的引用参数返回多个值、定义一个包含多个值的结构或返回
    `std::pair` 或 `std::tuple` 之间进行选择。前两种使用命名变量，这给了它们一个优势，即它们可以清楚地指示返回值的含义，但缺点是它们必须被显式定义。`std::pair`
    的成员称为 `first` 和 `second`，而 `std::tuple` 有未命名的成员，只能通过函数调用检索，但可以使用 `std::tie()`
    复制到命名变量。这些解决方案都不是理想的。
- en: C++17 extends the semantic use of `std::tie()` to a first-class core language
    feature that enables unpacking the values of a tuple into named variables. This
    feature is called *structured bindings*.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: C++17 将 `std::tie()` 的语义使用扩展为第一类核心语言特性，该特性允许将元组的值解包到命名变量中。这个特性被称为 *结构化绑定*。
- en: Getting ready
  id: totrans-527
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you should be familiar with the standard utility types `std::pair`
    and `std::tuple` and the utility function `std::tie()`.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，你应该熟悉标准实用类型 `std::pair` 和 `std::tuple` 以及实用函数 `std::tie()`。
- en: How to do it...
  id: totrans-529
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'To return multiple values from a function using a compiler that supports C++17,
    you should do the following:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用支持 C++17 的编译器从函数中返回多个值，你应该做以下操作：
- en: 'Use an `std::tuple` for the return type:'
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `std::tuple` 作为返回类型：
- en: '[PRE126]'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Use structured bindings to unpack the values of the tuple into named objects:'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用结构化绑定将元组的值解包到命名对象中：
- en: '[PRE127]'
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Use structure bindings to bind the returned values to the variables inside
    an `if` statement or `switch` statement:'
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用结构绑定将返回的值绑定到 `if` 语句或 `switch` 语句内部的变量：
- en: '[PRE128]'
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: How it works...
  id: totrans-537
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Structured bindings (sometimes referred to as *decomposition declaration*) are
    a language feature that works just like `std::tie()`, except that we don’t have
    to define named variables for each value that needs to be unpacked explicitly
    with `std::tie()`. With structured bindings, we define all the named variables
    in a single definition using the `auto` specifier so that the compiler can infer
    the correct type for each variable.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化绑定（有时被称为 *分解声明*）是一种语言特性，它的工作方式与 `std::tie()` 类似，除了我们不需要为每个需要使用 `std::tie()`
    显式解包的值定义命名变量。使用结构绑定，我们使用 `auto` 说明符在单个定义中定义所有命名变量，以便编译器可以推断每个变量的正确类型。
- en: 'To exemplify this, let’s consider the case of inserting items into a `std::map`.
    The `insert` method returns a `std::pair`, containing an iterator for the inserted
    element or the element that prevented the insertion, and a Boolean indicating
    whether the insertion was successful or not. The following code is very explicit,
    and the use of `second` or `first->second` makes the code harder to read because
    you need to constantly figure out what they represent:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，让我们考虑将项目插入到 `std::map` 的情况。`insert` 方法返回一个 `std::pair`，包含插入元素或阻止插入的元素的迭代器，以及一个布尔值，指示插入是否成功。以下代码非常明确，使用
    `second` 或 `first->second` 使得代码更难阅读，因为你需要不断弄清楚它们代表什么：
- en: '[PRE129]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'The preceding code can be made more readable with the use of `std::tie`, which
    unpacks tuples into individual objects (and works with `std::pair` because `std::tuple`
    has a converting assignment from `std::pair`):'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码可以通过使用 `std::tie` 来提高可读性，它将元组解包成单个对象（并且与 `std::pair` 一起工作，因为 `std::tuple`
    从 `std::pair` 有转换赋值）：
- en: '[PRE130]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: The code is not necessarily simpler because it requires defining the objects
    that the pair is unpacked to in advance. Similarly, the more elements the tuple
    has, the more objects you need to define, but using named objects makes the code
    easier to read.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 代码不一定更简单，因为它需要提前定义对偶解包到的对象。同样，元组包含的元素越多，你需要定义的对象就越多，但使用命名对象可以使代码更容易阅读。
- en: 'C++17 structured bindings elevate unpacking tuple elements into named objects
    to the rank of a language feature; there is no requirement for the use of `std::tie()`,
    and objects are initialized when declared:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: C++17 结构化绑定将解包元组元素到命名对象提升为语言特性的级别；不需要使用 `std::tie()`，并且对象在声明时被初始化：
- en: '[PRE131]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The use of multiple blocks in the preceding example is necessary because variables
    cannot be redeclared in the same block, and structured bindings imply a declaration
    using the `auto` specifier. Therefore, if you need to make multiple calls, as
    in the preceding example, and use structured bindings, you must either use different
    variable names or multiple blocks. An alternative to that is to avoid structured
    bindings and use `std::tie()`, because it can be called multiple times with the
    same variables, so you only need to declare them once.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中使用多个块是必要的，因为变量不能在同一个块中重新声明，而结构化绑定意味着使用 `auto` 指示符进行声明。因此，如果您需要多次调用，如前面的示例所示，并使用结构化绑定，您必须使用不同的变量名或多个块。另一个选择是避免使用结构化绑定并使用
    `std::tie()`，因为它可以用相同的变量多次调用，因此您只需声明一次。
- en: 'In C++17, it is also possible to declare variables in `if` and `switch` statements
    in the form `if(init; condition)` and `switch(init; condition)`, respectively.
    This could be combined with structured bindings to produce simpler code. Let’s
    look at an example:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++17 中，也可以分别以 `if(init; condition)` 和 `switch(init; condition)` 的形式在 `if`
    和 `switch` 语句中声明变量。这可以与结构化绑定结合，以生成更简单的代码。让我们来看一个示例：
- en: '[PRE132]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: There’s more...
  id: totrans-549
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Although we focused on binding names to the elements of tuples, structured
    bindings can be used in a broader scope because they also support binding to array
    elements or data members of a class. If you want to bind to the elements of an
    array, you must provide a name for every element of the array; otherwise, the
    declaration is ill-formed. The following is an example of binding to array elements:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们专注于将名称绑定到元组的元素上，但结构化绑定可以在更广泛的范围内使用，因为它们还支持绑定到数组元素或类的数据成员。如果您想绑定到数组的元素上，您必须为每个数组元素提供一个名称；否则，声明是不合法的。以下是一个绑定到数组元素的示例：
- en: '[PRE133]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: In this example, `arr` is an array with two elements. We first bind `a` and
    `b` to its elements, and then we bind the `x` and `y` references to its elements.
    Changes that are made to the elements of the array are not visible through the
    variables `a` and `b`, but they are through the `x` and `y` references, as shown
    in the comments that print these values to the console. This happens because when
    we do the first binding, a copy of the array is created, and `a` and `b` are bound
    to the elements of the copy.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`arr` 是一个包含两个元素的数组。我们首先将 `a` 和 `b` 绑定到其元素上，然后将 `x` 和 `y` 引用绑定到其元素上。对数组元素所做的更改通过变量
    `a` 和 `b` 是不可见的，但通过 `x` 和 `y` 引用是可见的，如注释中打印到控制台这些值的示例所示。这是因为当我们进行第一次绑定时，会创建数组的副本，`a`
    和 `b` 被绑定到副本的元素上。
- en: 'As we already mentioned, it’s also possible to bind to data members of a class.
    The following restrictions apply:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，也可以绑定到类的数据成员上。以下有一些限制：
- en: Binding is possible only for non-static members of the class.
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定仅适用于类的非静态成员。
- en: The class cannot have anonymous union members.
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类不能有匿名联合成员。
- en: The number of identifiers must match the number of non-static members of the
    class.
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符的数量必须与类的非静态成员的数量匹配。
- en: 'The binding of identifiers occurs in the order of the declaration of the data
    members, which can include bitfields. An example is shown here:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符的绑定按照数据成员声明的顺序进行，这可以包括位域。以下是一个示例：
- en: '[PRE134]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Again, changes to the `foo` object are not visible to the variables `i` and
    `n` but are to `ri` and `rn`. This is because each identifier in the structure
    binding becomes the name of an lvalue that refers to a data member of the class
    (just like with an array, it refers to an element of the array). However, the
    reference type of an identifier is the corresponding data member (or array element).
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，对 `foo` 对象的更改对变量 `i` 和 `n` 是不可见的，但对 `ri` 和 `rn` 是可见的。这是因为结构绑定中的每个标识符都成为指向类数据成员（就像数组一样，它指向数组的元素）的
    lvalue 的名称。然而，标识符的引用类型是对应的数据成员（或数组元素）。
- en: 'The new C++20 standard has introduced a series of improvements to structure
    bindings, including the following:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 C++20 标准引入了一系列对结构化绑定的改进，包括以下内容：
- en: The possibility to include the `static` or `thread_local` storage-class specifiers
    in the declaration of the structure bindings.
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在结构绑定声明中包含 `static` 或 `thread_local` 存储类指定符的可能性。
- en: The use of the `[[maybe_unused]]` attribute for the declaration of a structured
    binding. Some compilers, such as Clang and GCC, had already supported this feature.
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `[[maybe_unused]]` 属性声明结构化绑定。一些编译器，如Clang和GCC，已经支持此功能。
- en: The possibility to capture structure binding identifiers in lambdas. All identifiers,
    including those bound to bitfields, can be captured by value. Conversely, all
    identifiers except for those bound to bitfields can also be captured by reference.
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在lambda中捕获结构绑定标识符的可能性。所有标识符，包括绑定到位字段的标识符，都可以按值捕获。相反，除了绑定到位字段的标识符之外的所有标识符也可以按引用捕获。
- en: 'These changes enable us to write the following:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改使我们能够编写以下内容：
- en: '[PRE135]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: These examples show the various ways structured bindings can be captured in
    lambdas in C++20.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例展示了在C++20中结构化绑定可以以各种方式在lambda中捕获的各种方法。
- en: Sometimes, we need to bind variables that we don’t use. In C++26, it will be
    possible to ignore a variable by using an underscore (`_`) instead of a name.
    Although not supported by any compiler at the time of writing, this feature has
    been included in C++26.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要绑定我们不使用的变量。在C++26中，将可以使用下划线（`_`）而不是名称来忽略一个变量。尽管在撰写本文时没有任何编译器支持此功能，但该功能已被包含在C++26中。
- en: '[PRE136]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Here, `_` is a placeholder for a variable that is bound to the `id` member of
    the `foo` object. It is used to indicate that this value is not used and will
    be ignored in this context.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`_` 是一个占位符，用于绑定到 `foo` 对象的 `id` 成员。它用于表示此值在此上下文中未使用且将被忽略。
- en: The use of a `_` placeholder is not limited to structured bindings. It can be
    used as an identifier for non-static class members, structured bindings, and lambda
    captures. You can use an underscore to redefine an existing declaration in the
    same scope, therefore making it possible to ignore multiple variables. However,
    a program is considered ill-formed if the variable named `_` is used after a redeclaration.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `_` 占位符不仅限于结构化绑定。它可以用作非静态类成员、结构化绑定和lambda捕获的标识符。您可以使用下划线重新定义同一作用域中已存在的声明，因此可以忽略多个变量。然而，如果变量名为
    `_` 在重新声明之后使用，则程序被认为是格式不正确的。
- en: See also
  id: totrans-571
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using auto whenever possible*, to understand how automatic type deduction
    works in C++'
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*尽可能使用auto*，了解C++中自动类型推导的工作原理'
- en: '*Chapter 3*, *Using lambdas with standard algorithms*, to learn how lambdas
    can be used with standard library general-purpose algorithms'
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第三章*，*使用标准算法中的lambda*，了解lambda如何与标准库通用算法一起使用'
- en: '*Chapter 4*, *Providing metadata to the compiler with attributes*, to learn
    about providing hints to the compiler with the use of standard attributes'
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第四章*，*使用属性向编译器提供元数据*，了解如何使用标准属性向编译器提供提示'
- en: Simplifying code with class template argument deduction
  id: totrans-575
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类模板参数推导简化代码
- en: Templates are ubiquitous in C++, but having to specify template arguments all
    the time can be annoying. There are cases when the compiler can actually infer
    the template arguments from the context. This feature, available in C++17, is
    called *class template argument deduction* and enables the compiler to deduce
    the missing template arguments from the type of the initializer. In this recipe,
    we will learn how to take advantage of this feature.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 模板在C++中无处不在，但总是需要指定模板参数可能会很烦人。有些情况下，编译器实际上可以从上下文中推断模板参数。此功能在C++17中可用，称为*类模板参数推导*，它使编译器能够从初始化器的类型推断缺失的模板参数。在本食谱中，我们将学习如何利用此功能。
- en: How to do it...
  id: totrans-577
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'In C++17, you can skip specifying template arguments and let the compiler deduce
    them in the following cases:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17中，您可以在以下情况下省略指定模板参数，让编译器推断它们：
- en: 'When you declare a variable or a variable template and initialize it:'
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您声明一个变量或变量模板并对其进行初始化时：
- en: '[PRE137]'
  id: totrans-580
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'When you create an object using a new expression:'
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您使用new表达式创建对象时：
- en: '[PRE138]'
  id: totrans-582
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'When you perform function-like cast expressions:'
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您执行函数式类型转换表达式时：
- en: '[PRE139]'
  id: totrans-584
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: How it works...
  id: totrans-585
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Prior to C++17, you had to specify all the template arguments when initializing
    variables, because all of them must be known in order to instantiate the class
    template, such as in the following example:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17之前，您必须在初始化变量时指定所有模板参数，因为所有这些都必须已知才能实例化类模板，例如以下示例：
- en: '[PRE140]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The problem of explicitly specifying template arguments could have been avoided
    with a function template, such as `std::make_pair()`, which benefits from function
    template argument deduction and allows us to write code such as the following:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数模板，例如`std::make_pair()`，可以避免显式指定模板参数的问题，它受益于函数模板参数推导，并允许我们编写如下代码：
- en: '[PRE141]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'In the case of the `foo` class template shown here, we can write the following
    `make_foo()` function template to enable the same behavior:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里展示的`foo`类模板的情况下，我们可以编写以下`make_foo()`函数模板来启用相同的行为：
- en: '[PRE142]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'In C++17, this is no longer necessary in the cases listed in the *How it works...*
    section. Let’s take the following declaration as an example:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17中，在*如何工作...*部分列出的情况下，这不再必要。以下是一个示例声明：
- en: '[PRE143]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: In this context, `std::pair` is not a type, but it acts as a placeholder for
    a type that activates class template argument deduction. When the compiler encounters
    it during the declaration of a variable with initialization or a function-style
    cast, it builds a set of deduction guides. These deduction guides are fictional
    constructors of a hypothetical class type.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，`std::pair`不是一个类型，但它作为一个类型占位符，激活了类模板参数推导。当编译器在声明带有初始化或函数式转换的变量时遇到它，它将构建一个推导指南集。这些推导指南是假设类类型的虚构构造函数。
- en: As a user, you can complement this set with user-defined deduction rules. This
    set is used to perform template argument deduction and overload resolution.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 作为用户，你可以通过用户定义的推导规则来补充这个集合。这个集合用于执行模板参数推导和重载解析。
- en: 'In the case of `std::pair`, the compiler will build a set of deduction guides
    that includes the following fictional function templates (but not only these):'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 在`std::pair`的情况下，编译器将构建一个包含以下虚构函数模板的推导指南集（但不仅限于此）：
- en: '[PRE144]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: These compiler-generated deduction guides are created from the constructors
    of the class template, and if none are present, then a deduction guide is created
    for a hypothetical default constructor. In addition, in all cases, a deduction
    guide for a hypothetical copy constructor is always created.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 这些由编译器生成的推导指南是从类模板的构造函数中创建的，如果没有提供，则创建一个假设默认构造函数的推导指南。此外，在所有情况下，都会创建一个假设复制构造函数的推导指南。
- en: The user-defined deduction guides are function signatures with a trailing return
    type and without the `auto` keyword (since they represent hypothetical constructors
    that don’t have a return value). They must be defined in the namespace of the
    class template they apply to.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的推导指南是具有尾随返回类型且不带`auto`关键字的函数签名（因为它们代表没有返回值的假设构造函数）。它们必须在应用于该类模板的命名空间中定义。
- en: 'To understand how this works, let’s consider the same example with the `std::pair`
    object:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解它是如何工作的，让我们考虑与`std::pair`对象相同的示例：
- en: '[PRE145]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'The type that the compiler deduces is `std::pair<int, char const*>`. If we
    want to instruct the compiler to deduce `std::string` instead of `char const*`,
    then we need several user-defined deduction rules, as shown here:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器推导出的类型是`std::pair<int, char const*>`。如果我们想指示编译器推导出`std::string`而不是`char const*`，那么我们需要几个用户定义的推导规则，如下所示：
- en: '[PRE146]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'These will enable us to perform the following declarations, where the type
    of the string `"demo"` is always deduced to be `std::string`:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将使我们能够执行以下声明，其中字符串`"demo"`的类型始终推导为`std::string`：
- en: '[PRE147]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: As you can see from this example, deduction guides do not have to be function
    templates.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 如此示例所示，推导指南不必是函数模板。
- en: 'It is important to note that class template argument deduction does not occur
    if the template argument list is present, regardless of the number of specified
    arguments. Examples of this are shown here:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，如果存在模板参数列表，则不会发生类模板参数推导，无论指定了多少个参数。以下是一些示例：
- en: '[PRE148]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Because both these declarations specify a template argument list, they are invalid
    and produce compiler errors.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个声明都指定了模板参数列表，它们是无效的，并产生编译器错误。
- en: 'There are some known cases where class template argument deduction does not
    work:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些已知的情况，其中类模板参数推导不起作用：
- en: Aggregate templates, where you could write a user-defined deduction guide to
    circumvent the problem.
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合模板，其中你可以编写用户定义的推导指南来规避这个问题。
- en: '[PRE149]'
  id: totrans-612
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Type aliases, as shown in the following example (for GCC, this actually works
    when compiling with `-std=c++20`):'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型别名，如下面的示例所示（对于GCC，在编译时使用`-std=c++20`实际上可以工作）：
- en: '[PRE150]'
  id: totrans-614
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Inherited constructors, because deduction guides, whether implicit or user-defined,
    are not inherited when constructors are inherited:'
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承构造函数，因为推导指南（无论是隐式还是用户定义的）在继承构造函数时不会被继承：
- en: '[PRE151]'
  id: totrans-616
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: This latter limitation has been removed in C++23, where deduction guides are
    inherited when constructors are inherited.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 这种限制在C++23中被移除，因为在继承构造函数时，推导指南也会被继承。
- en: See also
  id: totrans-618
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Understanding uniform initialization*, to see how brace-initialization works'
  id: totrans-619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*理解统一初始化*，以了解花括号初始化是如何工作的'
- en: Using the subscript operator to access elements in a collection
  id: totrans-620
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用下标运算符访问集合中的元素
- en: Accessing elements of an array is a basic feature not just in C++ but also in
    any programming language that supports arrays. The syntax is also the same across
    many programming languages. In C++, the subscript operator used for this purpose,
    `[]`, can be overloaded to provide access to data in a class. Typically, this
    is the case for classes that model containers. In this recipe, we’ll see how to
    leverage this operator and what changes C++23 brings.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 访问数组元素是C++以及任何支持数组的编程语言的基本功能。语法在许多编程语言中也是相同的。在C++中，用于此目的的下标运算符`[]`可以被重载以提供对类中数据的访问。通常，这是对容器进行建模的类的情况。在本食谱中，我们将看到如何利用此运算符以及C++23带来了哪些变化。
- en: How to do it…
  id: totrans-622
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'To provide random access to elements in a container, overload the subscript
    operator as follows:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供对容器中元素的随机访问，以下是如何重载下标运算符：
- en: 'For one-dimensional containers, you can overload the subscript operator with
    one argument, regardless of the version of the standard:'
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于一维容器，你可以使用一个参数重载下标运算符，无论标准版本如何：
- en: '[PRE152]'
  id: totrans-625
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'For multidimensional containers, in C++23, you can overload the subscript operator
    with multiple arguments:'
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于多维容器，在C++23中，你可以使用多个参数重载下标运算符：
- en: '[PRE153]'
  id: totrans-627
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: How it works…
  id: totrans-628
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The subscript operator is used to access elements in an array. However, it
    is possible to overload it as a member function in classes typically modeling
    containers (or collections in general) to access its elements. Standard containers
    such as `std::vector`, `std::set`, and `std::map` provide overloads for the subscript
    operator for this purpose. Therefore, you can write code as follows:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 下标运算符用于访问数组中的元素。然而，它也可以作为类中通常建模容器（或一般集合）的成员函数重载，以访问其元素。标准容器如`std::vector`、`std::set`和`std::map`为此目的提供了下标运算符的重载。因此，你可以编写如下代码：
- en: '[PRE154]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: In the previous section, we saw how the subscript operator can be overloaded.
    There are typically two overloads, one that is constant and one that is mutable.
    The const-qualified overload returns a reference to a constant object, while the
    mutable overload returns a reference.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了下标运算符可以如何重载。通常有两种重载方式，一种是常量重载，另一种是可变重载。常量重载返回一个指向常量对象的引用，而可变重载返回一个引用。
- en: 'The major problem with the subscript operator was that, prior to C++23, it
    could only have one parameter. Therefore, it could not be used to provide access
    to elements of a multidimensional container. As a result, developers usually resorted
    to using the call operator for this purpose. An example is shown in the following
    snippet:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 下标运算符的主要问题是，在C++23之前，它只能有一个参数。因此，它不能用来提供对多维容器元素的访问。因此，开发者通常求助于使用调用运算符来达到这个目的。以下是一个示例片段：
- en: '[PRE155]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'To help with this, and allow a more consistent approach, C++11 made it possible
    to use the subscript operator with the syntax `[{expr1, expr2, …}]`. A modified
    implementation of the `matrix` class that leverages this syntax is shown next:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助解决这个问题，并允许更一致的方法，C++11使得可以使用下标运算符的语法`[{expr1, expr2, …}]`。下面展示了一个利用此语法的`matrix`类的修改实现：
- en: '[PRE156]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'However, the syntax is rather cumbersome and was probably rarely used in practice.
    For this reason, the C++23 standard makes it possible to overload the subscript
    operator using multiple parameters. A modified `matrix` class is shown here:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，语法相当繁琐，在实践中可能很少使用。因此，C++23标准使得使用多个参数重载下标运算符成为可能。这里展示了一个修改后的`matrix`类：
- en: '[PRE157]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: This makes the calling syntax consistent with accessing one-dimensional containers.
    This is used by `std::mdspan` to provide element access. This is a new C++23 class
    that represents a non-owning view into a contiguous sequence (such as an array),
    but it reinterprets the sequence as a multidimensional array.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得调用语法与访问一维容器保持一致。`std::mdspan` 使用它来提供元素访问。这是一个新的 C++23 类，它表示对连续序列（如数组）的非拥有视图，但它将序列重新解释为多维数组。
- en: 'The `matrix` class shown previously can actually be replaced with an `mdspan`
    view over an array, as shown in the following snippet:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 之前显示的 `matrix` 类实际上可以用数组上的 `mdspan` 视图替换，如下面的代码片段所示：
- en: '[PRE158]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: See also
  id: totrans-641
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Chapter 5*, *Writing your own random-access iterator*, to see how you can
    write an iterator for accessing the elements of a container'
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第五章*，*编写自己的随机访问迭代器*，了解您如何编写用于访问容器元素的迭代器'
- en: '*Chapter 6*, *Using std::mdspan for multidimensional views of sequences of
    objects*, to learn more about the `std::mdspan` class'
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第六章*，*使用 std::mdspan 对对象序列进行多维视图*，了解 `std::mdspan` 类的更多信息'
- en: Learn more on Discord
  id: totrans-644
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://discord.gg/7xRaTCeEhx](Chapter_01.xhtml)'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.gg/7xRaTCeEhx](Chapter_01.xhtml)'
- en: '![](img/QR_Code2659294082093549796.png)'
  id: totrans-647
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code2659294082093549796.png)'
