- en: Language Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言特性
- en: Problems
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Here are the problem-solving sections for this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章的问题解决部分。
- en: 15\. IPv4 data type
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15. IPv4数据类型
- en: Write a class that represents an IPv4 address. Implement the functions required
    to be able to read and write such addresses from or to the console. The user should
    be able to input values in dotted form, such as `127.0.0.1` or `168.192.0.100`.
    This is also the form in which IPv4 addresses should be formatted to an output
    stream.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个表示IPv4地址的类。实现所需的函数，以便能够从控制台读取和写入这些地址。用户应该能够以点分形式输入值，例如`127.0.0.1`或`168.192.0.100`。这也是IPv4地址应该格式化为输出流的形式。
- en: 16\. Enumerating IPv4 addresses in a range
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16. 在范围内枚举IPv4地址
- en: Write a program that allows the user to input two IPv4 addresses representing
    a range and list all the addresses in that range. Extend the structure defined
    for the previous problem to implement the requested functionality.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，允许用户输入表示范围的两个IPv4地址，并列出该范围内的所有地址。扩展为前一个问题定义的结构以实现所请求的功能。
- en: 17\. Creating a 2D array with basic operations
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17. 创建具有基本操作的2D数组
- en: Write a class template that represents a two-dimensional array container with
    methods for element access (`at()` and `data()`), capacity querying, iterators,
    filling, and swapping. It should be possible to move objects of this type.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个表示具有元素访问（`at()`和`data()`）、容量查询、迭代器、填充和交换方法的二维数组容器的类模板。应该可以移动此类型的对象。
- en: 18\. Minimum function with any number of arguments
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 18. 具有任意数量参数的最小函数
- en: Write a function template that can take any number of arguments and returns
    the minimum value of them all, using `operator <` for comparison. Write a variant
    of this function template that can be parameterized with a binary comparison function
    to use instead of `operator <`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数模板，可以接受任意数量的参数，并使用`operator <`进行比较返回它们所有的最小值。编写此函数模板的变体，可以使用二进制比较函数进行参数化，而不是使用`operator
    <`。
- en: 19\. Adding a range of values to a container
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 19. 将一系列值添加到容器中
- en: Write a general-purpose function that can add any number of elements to the
    end of a container that has a method `push_back(T&& value)`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个通用函数，可以将任意数量的元素添加到具有`push_back(T&& value)`方法的容器的末尾。
- en: 20\. Container any, all, none
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 20. 容器任何、全部、无
- en: 'Write a set of general-purpose functions that enable checking whether any,
    all, or none of the specified arguments are present in a given container. These
    functions should make it possible to write code as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一组通用函数，使其能够检查给定容器中是否存在任何、全部或任何指定参数。这些函数应该使得能够编写以下代码成为可能：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 21\. System handle wrapper
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 21. 系统句柄包装器
- en: Consider an operating system handle, such as a file handle. Write a wrapper
    that handles the acquisition and release of the handle, as well as other operations
    such as verifying the validity of the handle and moving handle ownership from
    one object to another.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个操作系统句柄，例如文件句柄。编写一个包装器，处理句柄的获取和释放，以及其他操作，如验证句柄的有效性和从一个对象移动句柄所有权。
- en: 22\. Literals of various temperature scales
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 22. 各种温度标度的文字
- en: Write a small library that enables expressing temperatures in the three most
    used scales, Celsius, Fahrenheit, and Kelvin, and converting between them. The
    library must enable you to write temperature literals in all these scales, such
    as `36.5_deg` for Celsius, `97.7_f` for Fahrenheit, and `309.65_K` for Kelvin;
    perform operations with these values; and convert between them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个小型库，使得能够以三种最常用的标度（摄氏度、华氏度和开尔文）表示温度，并在它们之间进行转换。该库必须使您能够以所有这些标度编写温度文字，例如`36.5_deg`表示摄氏度，`97.7_f`表示华氏度，`309.65_K`表示开尔文；对这些值执行操作；并在它们之间进行转换。
- en: Solutions
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: Here are the solutions for the above problem-solving sections.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述问题解决部分的解决方案。
- en: 15\. IPv4 data type
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15. IPv4数据类型
- en: 'The problem requires writing a class to represent an IPv4 address. This is
    a 32-bit value, usually represented in decimal dotted format, such as `168.192.0.100`*;* each
    part of it is an 8-bit value, ranging from 0 to 255\. For easy representation
    and handling, we can use four `unsigned char` to store the address value. Such
    a value could be constructed either from four `unsigned char` or from an `unsigned
    long`. In order to be able to read a value directly from the console (or any other
    input stream) and be able to write the value to the console (or any other output
    stream), we have to overload `operator>>` and `operator<<`. The following listing
    shows a minimal implementation that can meet the requested functionality:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 该问题要求编写一个类来表示IPv4地址。这是一个32位值，通常以十进制点格式表示，例如`168.192.0.100`；它的每个部分都是一个8位值，范围从0到255。为了方便表示和处理，我们可以使用四个`unsigned
    char`来存储地址值。这样的值可以从四个`unsigned char`或从一个`unsigned long`构造。为了能够直接从控制台（或任何其他输入流）读取值，并能够将值写入控制台（或任何其他输出流），我们必须重载`operator>>`和`operator<<`。以下清单显示了可以满足所请求功能的最小实现：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `ipv4` class can be used as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`ipv4`类可以如下使用：'
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 16\. Enumerating IPv4 addresses in a range
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16. 在范围内枚举IPv4地址
- en: 'To be able to enumerate IPv4 addresses in a given range, it should first be
    possible to compare IPv4 values. Therefore, we should implement at least `operator<`,
    but the following listing contains implementation for all comparison operators:
    `==`, `!=`, `<`, `>`, `<=`, and `>=`. Also, in order to increment an IPv4 value,
    implementations for both the prefix and postfix `operator++` are provided. The
    following code is an extension of the IPv4 class from the previous problem:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在给定范围内枚举IPv4地址，首先应该能够比较IPv4值。因此，我们应该至少实现`operator<`，但以下清单包含所有比较运算符的实现：`==`、`!=`、`<`、`>`、`<=`和`>=`。此外，为了增加IPv4值，提供了前缀和后缀`operator++`的实现。以下代码是前一个问题中IPv4类的扩展：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With these changes to the `ipv4` class from the previous problem, we can write
    the following program:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对前一个问题中的`ipv4`类进行这些更改，我们可以编写以下程序：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 17\. Creating a 2D array with basic operations
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17. 创建具有基本操作的2D数组
- en: 'Before looking at how we could define such a structure, let''s consider several
    test cases for it. The following snippet shows all the functionality that was
    requested:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在看如何定义这样的结构之前，让我们考虑一下它的几个测试用例。以下片段显示了所有请求的功能：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that for element access, we are using `operator()`, such as in `a(i,j)`,
    and not `operator[]`, such as in `a[i][j]`, because only the former can take multiple
    arguments (one for the index on each dimension). The latter can only have a single
    argument, and in order to enable expressions like `a[i][j]`, it has to return
    an intermediate type (one that basically represents a row) that in turn overloads
    `operator[]` to return a single element.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于元素访问，我们使用`operator()`，比如`a(i,j)`，而不是`operator[]`，比如`a[i][j]`，因为只有前者可以接受多个参数（每个维度的索引）。后者只能有一个参数，并且为了使表达式`a[i][j]`有效，它必须返回一个中间类型（基本上表示一行），然后再重载`operator[]`以返回单个元素。
- en: 'There are already standard containers that store either fixed or variable-length
    sequences of elements. This two-dimensional array class should be just an adapter
    for such a container. In choosing between `std::array` and `std::vector`, we should
    consider two things:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 已经有存储固定或可变长度元素序列的标准容器。这个二维数组类应该只是这样一个容器的适配器。在选择`std::array`和`std::vector`之间，我们应该考虑两件事：
- en: The `array2d` class should have move semantics to be able to move objects
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array2d`类应该具有移动语义，以便能够移动对象'
- en: It should be possible to list initialize an object of this type
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该可以使用列表初始化此类型的对象
- en: The `std::array` container is movable only if the elements it holds are move-constructible
    and move-assignable. On the other hand, it cannot be constructed from an `std::initializer_list`.
    Therefore, the more viable option remains an `std::vector`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::array`容器只有在其持有的元素是可移动构造和可移动分配时才可移动。另一方面，它不能从`std::initializer_list`构造。因此，更可行的选择仍然是`std::vector`。'
- en: Internally, this adapter container can store its data either in a vector of
    vectors (each row is a `vector<T>` with `C` elements, and the 2D array has `R`
    such elements stored in a `vector<vector<T>>`) or single vector of `R![](img/2f9ae4c1-380b-4377-84dd-a28429c062c5.png)C`
    elements of type `T`. In the latter case, the element on row `i` and column `j`
    is found at index `i * C + j`. This approach has a smaller memory footprint, stores
    all data in a single contiguous chunk, and is also simpler to implement. For these
    reasons, it is the preferred solution.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，此适配器容器可以将其数据存储在向量的向量中（每行是一个具有`C`个元素的`vector<T>`，而2D数组中有`R`个这样的元素存储在`vector<vector<T>>`中）或者类型为`T`的`R![](img/2f9ae4c1-380b-4377-84dd-a28429c062c5.png)C`元素的单个向量中。在后一种情况下，第`i`行和第`j`列的元素位于索引`i
    * C + j`处。这种方法具有较小的内存占用，将所有数据存储在单个连续块中，并且实现起来也更简单。因此，这是首选解决方案的原因。
- en: 'A possible implementation of the two-dimensional array class with the requested
    functionality is shown here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了具有所请求功能的二维数组类的可能实现：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 18\. Minimum function with any number of arguments
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 18\. 具有任意数量参数的最小函数
- en: 'It is possible to write function templates that can take a variable number
    of arguments using variadic function templates. For this, we need to implement
    compile-time recursion (which is actually just calls through a set of overloaded
    functions). The following snippet shows how the requested function could be implemented:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用可变函数模板编写可以接受可变数量参数的函数模板。为此，我们需要实现编译时递归（实际上只是通过一组重载函数进行调用）。以下片段显示了如何实现所请求的函数：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In order to be able to use a user-provided binary comparison function, we need
    to write another function template. The comparison function must be the first
    argument because it cannot follow the function parameter pack. On the other hand,
    this cannot be an overload of the previous minimum function, but a function with
    a different name. The reason is that the compiler would not be able to differentiate
    between the template parameter lists `<typename T1, typename... T>` and `<class
    Compare, typename T1, typename... T>`. The changes are minimal and should be easy
    to follow in this snippet:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用用户提供的二进制比较函数，我们需要编写另一个函数模板。比较函数必须是第一个参数，因为它不能跟随函数参数包。另一方面，这不能是前一个最小函数的重载，而是具有不同名称的函数。原因是编译器无法区分模板参数列表`<typename
    T1, typename... T>`和`<class Compare, typename T1, typename... T>`。更改很小，应该很容易在此片段中跟踪：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 19\. Adding a range of values to a container
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 19\. 向容器添加一系列值
- en: 'Writing functions with any number of arguments is possible using variadic function
    templates. The function should have the container as the first parameter, followed
    by a variable number of arguments representing the values to be added at the back
    of the container. However, writing such a function template can be significantly
    simplified using fold expressions. Such an implementation is shown here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可变函数模板可以编写具有任意数量参数的函数。该函数应该将容器作为第一个参数，然后是表示要添加到容器后面的值的可变数量的参数。但是，使用折叠表达式可以显着简化编写这样的函数模板。这里展示了这样的实现：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Examples of using this function template, with various container types, can
    be seen in the following listing:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在以下清单中看到使用此函数模板的各种容器类型的示例：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 20\. Container any, all, none
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 20\. 容器任何，全部，无
- en: 'The requirement to be able to check the presence or absence of a variable number
    of arguments suggests that we should write variadic function templates. However,
    these functions require a helper function, a general-purpose one that checks whether
    an element is found in a container or not and returns a `bool` to indicate success
    or failure. Since all these functions, which we could call `contains_all`, `contains_any`,
    and `contains_none`, do is apply logical operators on the results returned by
    the helper function, we would use fold expressions to simplify the code. Short
    circuit evaluation is enabled after the expansion of the fold expression, which
    means we are evaluating only the elements that lead to a definitive result. So
    if we are looking for the presence of all 1, 2, and 3, and 2 is missing, the function
    will return after looking up value 2 in the container without checking value 3:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 能够检查变量数量的存在或不存在的要求表明，我们应该编写可变函数模板。然而，这些函数需要一个辅助函数，一个通用的函数，用于检查元素是否在容器中找到，并返回一个`bool`来指示成功或失败。由于所有这些函数，我们可以称之为`contains_all`，`contains_any`和`contains_none`，都是对辅助函数返回的结果应用逻辑运算符，我们将使用折叠表达式来简化代码。在折叠表达式扩展后启用短路评估，这意味着我们只评估导致明确结果的元素。因此，如果我们正在寻找所有1、2和3的存在，并且2缺失，那么在查找容器中的值2时，函数将返回而不检查值3：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 21\. System handle wrapper
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 21. 系统句柄包装器
- en: 'System handles are a form of reference to system resources. Because all operating
    systems were at least initially written in C, creating and releasing the handles
    is done through dedicated system functions. This increases the risk of leaking
    resources because of erroneous disposal, such as in the case of an exception.
    In the following snippet, specific to Windows, you can see a function where a
    file is opened, read from, and eventually closed. However, this has a couple of
    problems: in one case, the developer forgot to close the handle before leaving
    the function; in another case, a function that throws is called before the handle
    is properly closed, without the exception being caught. However, since the function
    throws, that cleanup code never executes:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 系统句柄是对系统资源的引用形式。因为所有操作系统最初至少是用C编写的，所以创建和释放句柄是通过专用系统函数完成的。这增加了因错误处理而导致资源泄漏的风险，例如在异常情况下。在下面的代码片段中，特定于Windows，您可以看到一个函数，在该函数中打开文件，从中读取，并最终关闭。然而，这有一些问题：在一个情况下，开发人员忘记在离开函数之前关闭句柄；在另一种情况下，在句柄正确关闭之前调用了一个抛出异常的函数，而没有捕获异常。然而，由于函数抛出异常，清理代码永远不会执行：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A C++ wrapper class can ensure proper disposal of the handle when the wrapper
    object goes out of scope and is destroyed (whether that happens through a normal
    execution path or as the result of an exception). A proper implementation should
    account for different types of handles, with a range of values to indicate an
    invalid handle (such as 0/null or -1). The implementation shown next provides:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: C++包装类可以确保在包装对象超出范围并被销毁时正确处理句柄（无论是通过正常执行路径还是作为异常的结果）。一个合适的实现应该考虑不同类型的句柄，以及一系列值来指示无效句柄（如0/null或-1）。下面显示的实现提供了：
- en: Explicit acquisition and automatic release of the handle when the object is
    destroyed
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对象被销毁时显式获取和自动释放句柄
- en: Move semantics to enable transfer of ownership of the handle
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动语义以实现句柄所有权的转移
- en: Comparison operators to check whether two objects refer to the same handle
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较运算符用于检查两个对象是否引用相同的句柄
- en: Additional operations such as swapping and resetting
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他操作，如交换和重置
- en: The implementation shown here is a modified version of the handle class implemented
    by Kenny Kerr and published in the article *Windows with C++ - C++ and the Windows
    API*, MSDN Magazine, July 2011, [https://msdn.microsoft.com/en-us/magazine/hh288076.aspx](https://msdn.microsoft.com/en-us/magazine/hh288076.aspx).
    Although the handle traits shown here refer to Windows handles, it should be fairly
    simple to write traits appropriate for other platforms.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的实现是Kenny Kerr实现的句柄类的修改版本，并发表在2011年7月的MSDN杂志文章*Windows with C++ - C++ and
    the Windows API*中，[https://msdn.microsoft.com/en-us/magazine/hh288076.aspx](https://msdn.microsoft.com/en-us/magazine/hh288076.aspx)。尽管这里显示的句柄特性是指Windows句柄，但编写适用于其他平台的特性应该是相当简单的。
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With this handle type defined, we can rewrite the previous example in simpler
    terms, avoiding all those problems with handles not properly closed because of
    exceptions occurring that are not properly handled, or simply because developers
    forget to release resources when no longer needed. This code is both simpler and
    more robust:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这种句柄类型的定义，我们可以用更简单的术语重写先前的示例，避免所有那些因为异常而未正确关闭句柄的问题，这些异常发生时没有得到正确处理，或者仅仅是因为开发人员忘记在不再需要时释放资源。这段代码既更简单又更健壮：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 22\. Literals of various temperature scales
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 22. 各种温度标度的文字
- en: 'To meet this requirement, we need to provide an implementation for several
    types, operators, and functions:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足这一要求，我们需要为多种类型、运算符和函数提供实现：
- en: An enumeration of supported temperature scales called `scale`.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 称为`scale`的支持温度标度的枚举。
- en: A class template to represent a temperature value, parameterized with the scale,
    called `quantity`.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类模板，用于表示温度值，参数化为`quantity`，称为`quantity`。
- en: Comparison operators `==`, `!=`, `<`, `>`, `<=`, and `>=` that compare two quantities
    of the same time.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较运算符`==`、`!=`、`<`、`>`、`<=`和`>=`，用于比较相同类型的两个数量。
- en: Arithmetic operators `+` and `-` that add and subtract values of the same quantity
    type. Additionally, we could implement member operators `+=` and `-+`.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术运算符`+`和`-`用于添加和减去相同类型的值。此外，我们可以实现成员运算符`+=`和`-+`。
- en: A function template to convert temperatures from one scale to another, called
    `temperature_cast`. This function does not perform the conversion itself but uses
    type traits to do that.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个函数模板，用于将温度从一种标度转换为另一种，称为`temperature_cast`。这个函数本身不执行转换，而是使用类型特性来执行转换。
- en: Literal operators `""_deg`, `""_f`, and `""_k` for creating user-defined temperature
    literals.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于创建用户定义的温度字面量的文字操作符`""_deg`，`""_f`和`""_k`。
- en: For brevity, the following snippet only contains the code that handles Celsius
    and Fahrenheit temperatures. You should take it as a further exercise to extend
    the code with support for the Kelvin scale. The code accompanying the book contains
    the full implementation of all three required scales.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，以下代码片段仅包含处理摄氏度和华氏度温度的代码。您应该将其视为进一步练习，以扩展代码以支持开尔文标度。附带书籍的代码包含了所有三个所需标度的完整实现。
- en: 'The `are_equal()` function is a utility function used to compare floating-point
    values:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`are_equal()`函数是一个用于比较浮点值的实用函数：'
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The enumeration of possible temperature scales and the class that represents
    a temperature value are defined as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的温度标度的枚举和表示温度值的类定义如下：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The comparison operators for the `quantity<S>` class can be seen here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`quantity<S>`类的比较操作符可以在这里看到：'
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To convert between temperature values of different scales, we will define a
    function template called `temperature_cast()` that utilizes several type traits
    to perform the actual conversion. All these are shown here, although not all type
    traits; the others can be found in the code accompanying the book:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在不同温度标度之间进行转换，我们将定义一个名为`temperature_cast()`的函数模板，该函数利用了几个类型特征来执行实际的转换。所有这些都在这里显示，尽管并非所有类型特征；其他类型特征可以在附带书籍的代码中找到：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The literal operators for creating temperature values are shown in the following
    snippet. These operators are defined in a separate namespace, called `temperature_scale_literals`,
    which is a good practice in order to minimize the risk of name collision with
    other literal operators:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 用于创建温度值的文字操作符显示在以下代码片段中。这些操作符定义在一个名为`temperature_scale_literals`的单独命名空间中，这是一种良好的做法，以减少与其他文字操作符的名称冲突的风险：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following example shows how to define two temperature values, one in Celsius
    and one in Fahrenheit, and convert between the two:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了如何定义两个温度值，一个是摄氏度，一个是华氏度，并在两者之间进行转换：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
